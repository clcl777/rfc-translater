{
  "title": {
    "text": "draft-ietf-oauth-v2-1-09",
    "ja": "RFC draft-ietf-oauth-v2-1-09"
  },
  "number": "draft-ietf-oauth-v2-1-09",
  "created_at": "2023-07-24 23:44:42.699983+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "OAuth Working Group                                             D. Hardt\nInternet-Draft                                                     Hell\nIntended status: Standards Track                              A. Parecki\nExpires: 11 January 2024                                            Okta\n                                                          T. Lodderstedt\n                                                                 yes.com\n                                                            10 July 2023",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "The OAuth 2.1 Authorization Framework draft-ietf-oauth-v2-1-09",
      "ja": "OAUTH 2.1認証フレームワークDraft-IITF-OAUTH-V2-1-09"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "The OAuth 2.1 authorization framework enables an application to obtain limited access to a protected resource, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and an authorization service, or by allowing the application to obtain access on its own behalf. This specification replaces and obsoletes the OAuth 2.0 Authorization Framework described in RFC 6749 and the Bearer Token Usage in RFC 6750.",
      "ja": "OAUTH 2.1承認フレームワークにより、リソース所有者と承認サービス間の承認相互作用を調整することにより、またはアプリケーションが独自のアクセスを取得できるようにすることにより、リソース所有者に代わって、アプリケーションが保護されたリソースへの限定アクセスを取得できます。この仕様は、RFC 6749で説明されているOAUTH 2.0認証フレームワークとRFC 6750のベアラートークンの使用に取って代わり、廃止されます。"
    },
    {
      "indent": 0,
      "text": "Discussion Venues",
      "ja": "ディスカッション会場"
    },
    {
      "indent": 3,
      "text": "This note is to be removed before publishing as an RFC.",
      "ja": "このメモは、RFCとして公開する前に削除されます。"
    },
    {
      "indent": 3,
      "text": "Discussion of this document takes place on the OAuth Working Group mailing list (oauth@ietf.org), which is archived at https://mailarchive.ietf.org/arch/browse/oauth/.",
      "ja": "このドキュメントの議論は、https://mailarchive.ietf.org/arch/browse/oauth/にアーカイブされているOAuthワーキンググループメーリングリスト（oauth@ietf.org）で行われます。"
    },
    {
      "indent": 3,
      "text": "Source for this draft and an issue tracker can be found at https://github.com/oauth-wg/oauth-v2-1.",
      "ja": "このドラフトのソースと問題トラッカーは、https：//github.com/oauth-wg/oauth-v2-1にあります。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.",
      "ja": "このインターネットドラフトは、BCP 78およびBCP 79の規定に完全に適合して提出されています。"
    },
    {
      "indent": 3,
      "text": "Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.",
      "ja": "インターネットドラフトは、インターネットエンジニアリングタスクフォース（IETF）の作業文書です。他のグループは、作業文書をインターネットドラフトとして配布する場合もあることに注意してください。現在のインターネットドラフトのリストは、https：//datatracker.ietf.org/drafts/current/にあります。"
    },
    {
      "indent": 3,
      "text": "Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as \"work in progress.\" This Internet-Draft will expire on 11 January 2024.",
      "ja": "インターネットドラフトは、最大6か月間有効なドラフトドキュメントであり、いつでも他のドキュメントに更新、交換、または廃止される場合があります。インターネットドラフトを参照資料として使用したり、「進行中の作業」以外に引用することは不適切です。このインターネットドラフトは、2024年1月11日に期限切れになります。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2023 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2023 IETF Trustおよび文書著者として特定された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/ license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/ license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、改訂されたBSDライセンスで説明されている保証なしで提供されるように、改訂されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   5\n  1.1.  Roles . . . . . . . . . . . . . . . . . . . . . . . . . .   7\n  1.2.  Protocol Flow . . . . . . . . . . . . . . . . . . . . . .   7\n  1.3.  Authorization Grant . . . . . . . . . . . . . . . . . . .   9\n    1.3.1.  Authorization Code  . . . . . . . . . . . . . . . . .   9\n    1.3.2.  Refresh Token . . . . . . . . . . . . . . . . . . . .   9\n    1.3.3.  Client Credentials  . . . . . . . . . . . . . . . . .  11\n  1.4.  Access Token  . . . . . . . . . . . . . . . . . . . . . .  11\n  1.5.  Communication security  . . . . . . . . . . . . . . . . .  12\n  1.6.  HTTP Redirections . . . . . . . . . . . . . . . . . . . .  13\n  1.7.  Interoperability  . . . . . . . . . . . . . . . . . . . .  13\n  1.8.  Compatibility with OAuth 2.0  . . . . . . . . . . . . . .  14\n  1.9.  Notational Conventions  . . . . . . . . . . . . . . . . .  14\n2.  Client Registration . . . . . . . . . . . . . . . . . . . . .  15\n  2.1.  Client Types  . . . . . . . . . . . . . . . . . . . . . .  15\n  2.2.  Client Identifier . . . . . . . . . . . . . . . . . . . .  17\n  2.3.  Client Redirection Endpoint . . . . . . . . . . . . . . .  17\n    2.3.1.  Registration Requirements . . . . . . . . . . . . . .  18\n    2.3.2.  Multiple Redirect URIs  . . . . . . . . . . . . . . .  19\n    2.3.3.  Preventing CSRF Attacks . . . . . . . . . . . . . . .  19\n    2.3.4.  Preventing Mix-Up Attacks . . . . . . . . . . . . . .  19\n    2.3.5.  Invalid Endpoint  . . . . . . . . . . . . . . . . . .  19\n    2.3.6.  Endpoint Content  . . . . . . . . . . . . . . . . . .  19\n  2.4.  Client Authentication . . . . . . . . . . . . . . . . . .  20\n    2.4.1.  Client Secret . . . . . . . . . . . . . . . . . . . .  21\n    2.4.2.  Other Authentication Methods  . . . . . . . . . . . .  22\n  2.5.  Unregistered Clients  . . . . . . . . . . . . . . . . . .  22\n3.  Protocol Endpoints  . . . . . . . . . . . . . . . . . . . . .  22\n  3.1.  Authorization Endpoint  . . . . . . . . . . . . . . . . .  23\n  3.2.  Token Endpoint  . . . . . . . . . . . . . . . . . . . . .  23",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    3.2.1.  Client Authentication . . . . . . . . . . . . . . . .  24\n    3.2.2.  Token Request . . . . . . . . . . . . . . . . . . . .  25\n    3.2.3.  Token Response  . . . . . . . . . . . . . . . . . . .  26\n4.  Grant Types . . . . . . . . . . . . . . . . . . . . . . . . .  30\n  4.1.  Authorization Code Grant  . . . . . . . . . . . . . . . .  30\n    4.1.1.  Authorization Request . . . . . . . . . . . . . . . .  32\n    4.1.2.  Authorization Response  . . . . . . . . . . . . . . .  35\n    4.1.3.  Token Endpoint Extension  . . . . . . . . . . . . . .  38\n  4.2.  Client Credentials Grant  . . . . . . . . . . . . . . . .  39\n    4.2.1.  Token Endpoint Extension  . . . . . . . . . . . . . .  40\n  4.3.  Refresh Token Grant . . . . . . . . . . . . . . . . . . .  41\n    4.3.1.  Token Endpoint Extension  . . . . . . . . . . . . . .  41\n    4.3.2.  Refresh Token Response  . . . . . . . . . . . . . . .  43\n    4.3.3.  Refresh Token Recommendations . . . . . . . . . . . .  43\n  4.4.  Extension Grants  . . . . . . . . . . . . . . . . . . . .  43\n5.  Accessing Protected Resources . . . . . . . . . . . . . . . .  44\n  5.1.  Access Token Types  . . . . . . . . . . . . . . . . . . .  44\n  5.2.  Bearer Tokens . . . . . . . . . . . . . . . . . . . . . .  45\n    5.2.1.  Authenticated Requests  . . . . . . . . . . . . . . .  45\n    5.2.2.  Access Token Validation . . . . . . . . . . . . . . .  47\n    5.2.3.  The WWW-Authenticate Response Header Field  . . . . .  48\n    5.2.4.  Error Codes . . . . . . . . . . . . . . . . . . . . .  49\n  5.3.  Error Response  . . . . . . . . . . . . . . . . . . . . .  50\n    5.3.1.  Extension Token Types . . . . . . . . . . . . . . . .  50\n  5.4.  Sender-Constrained Access Tokens  . . . . . . . . . . . .  51\n6.  Extensibility . . . . . . . . . . . . . . . . . . . . . . . .  51\n  6.1.  Defining Access Token Types . . . . . . . . . . . . . . .  51\n  6.2.  Defining New Endpoint Parameters  . . . . . . . . . . . .  51\n  6.3.  Defining New Authorization Grant Types  . . . . . . . . .  52\n  6.4.  Defining New Authorization Endpoint Response Types  . . .  52\n  6.5.  Defining Additional Error Codes . . . . . . . . . . . . .  53\n7.  Security Considerations . . . . . . . . . . . . . . . . . . .  53\n  7.1.  Access Token Security Considerations  . . . . . . . . . .  53\n    7.1.1.  Security Threats  . . . . . . . . . . . . . . . . . .  53\n    7.1.2.  Threat Mitigation . . . . . . . . . . . . . . . . . .  54\n    7.1.3.  Summary of Recommendations  . . . . . . . . . . . . .  55\n    7.1.4.  Access Token Privilege Restriction  . . . . . . . . .  56\n  7.2.  Client Authentication . . . . . . . . . . . . . . . . . .  57\n  7.3.  Client Impersonation  . . . . . . . . . . . . . . . . . .  57\n    7.3.1.  Impersonation of Native Apps  . . . . . . . . . . . .  58\n    7.3.2.  Access Token Privilege Restriction  . . . . . . . . .  58\n  7.4.  Client Impersonating Resource Owner . . . . . . . . . . .  59\n  7.5.  Protecting the Authorization Code Flow  . . . . . . . . .  59\n    7.5.1.  Loopback Redirect Considerations in Native Apps . . .  59\n    7.5.2.  HTTP 307 Redirect . . . . . . . . . . . . . . . . . .  60\n  7.6.  Authorization Code Injection  . . . . . . . . . . . . . .  60\n    7.6.1.  Countermeasures . . . . . . . . . . . . . . . . . . .  61\n  7.7.  Ensuring Endpoint Authenticity  . . . . . . . . . . . . .  61\n     7.8.  Credentials-Guessing Attacks  . . . . . . . . . . . . . .  62\n  7.9.  Phishing Attacks  . . . . . . . . . . . . . . . . . . . .  62\n  7.10. Cross-Site Request Forgery  . . . . . . . . . . . . . . .  62\n  7.11. Clickjacking  . . . . . . . . . . . . . . . . . . . . . .  63\n  7.12. Code Injection and Input Validation . . . . . . . . . . .  64\n  7.13. Open Redirection  . . . . . . . . . . . . . . . . . . . .  64\n    7.13.1.  Client as Open Redirector  . . . . . . . . . . . . .  65\n    7.13.2.  Authorization Server as Open Redirector  . . . . . .  65\n  7.14. Authorization Server Mix-Up Mitigation in Native Apps . .  66\n8.  Native Applications . . . . . . . . . . . . . . . . . . . . .  66\n  8.1.  Registration of Native App Clients  . . . . . . . . . . .  67\n    8.1.1.  Client Authentication of Native Apps  . . . . . . . .  68\n  8.2.  Using Inter-App URI Communication for OAuth in Native\n        Apps  . . . . . . . . . . . . . . . . . . . . . . . . . .  68\n  8.3.  Initiating the Authorization Request from a Native App  .  68\n  8.4.  Receiving the Authorization Response in a Native App  . .  69\n    8.4.1.  Claimed \"https\" Scheme URI Redirection  . . . . . . .  69\n    8.4.2.  Loopback Interface Redirection  . . . . . . . . . . .  70\n    8.4.3.  Private-Use URI Scheme Redirection  . . . . . . . . .  71\n  8.5.  Security Considerations in Native Apps  . . . . . . . . .  72\n    8.5.1.  Embedded User Agents in Native Apps . . . . . . . . .  72\n    8.5.2.  Fake External User-Agents in Native Apps  . . . . . .  73\n    8.5.3.  Malicious External User-Agents in Native Apps . . . .  73\n9.  Browser-Based Apps  . . . . . . . . . . . . . . . . . . . . .  73\n10. Differences from OAuth 2.0  . . . . . . . . . . . . . . . . .  74\n  10.1.  Removal of the OAuth 2.0 Implicit grant  . . . . . . . .  75\n  10.2.  Redirect URI Parameter in Token Request  . . . . . . . .  75\n11. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  76\n12. References  . . . . . . . . . . . . . . . . . . . . . . . . .  76\n  12.1.  Normative References . . . . . . . . . . . . . . . . . .  76\n  12.2.  Informative References . . . . . . . . . . . . . . . . .  78\nAppendix A.  Augmented Backus-Naur Form (ABNF) Syntax . . . . . .  81\n  A.1.  \"client_id\" Syntax  . . . . . . . . . . . . . . . . . . .  82\n  A.2.  \"client_secret\" Syntax  . . . . . . . . . . . . . . . . .  82\n  A.3.  \"response_type\" Syntax  . . . . . . . . . . . . . . . . .  82\n  A.4.  \"scope\" Syntax  . . . . . . . . . . . . . . . . . . . . .  82\n  A.5.  \"state\" Syntax  . . . . . . . . . . . . . . . . . . . . .  82\n  A.6.  \"redirect_uri\" Syntax . . . . . . . . . . . . . . . . . .  82\n  A.7.  \"error\" Syntax  . . . . . . . . . . . . . . . . . . . . .  83\n  A.8.  \"error_description\" Syntax  . . . . . . . . . . . . . . .  83\n  A.9.  \"error_uri\" Syntax  . . . . . . . . . . . . . . . . . . .  83\n  A.10. \"grant_type\" Syntax . . . . . . . . . . . . . . . . . . .  83\n  A.11. \"code\" Syntax . . . . . . . . . . . . . . . . . . . . . .  83\n  A.12. \"access_token\" Syntax . . . . . . . . . . . . . . . . . .  83\n  A.13. \"token_type\" Syntax . . . . . . . . . . . . . . . . . . .  83\n  A.14. \"expires_in\" Syntax . . . . . . . . . . . . . . . . . . .  84\n  A.15. \"refresh_token\" Syntax  . . . . . . . . . . . . . . . . .  84\n  A.16. Endpoint Parameter Syntax . . . . . . . . . . . . . . . .  84\n     A.17. \"code_verifier\" Syntax  . . . . . . . . . . . . . . . . .  84\n  A.18. \"code_challenge\" Syntax . . . . . . . . . . . . . . . . .  84\nAppendix B.  Use of application/x-www-form-urlencoded Media\n        Type  . . . . . . . . . . . . . . . . . . . . . . . . . .  84\nAppendix C.  Extensions . . . . . . . . . . . . . . . . . . . . .  85\nAppendix D.  Acknowledgements . . . . . . . . . . . . . . . . . .  86\nAppendix E.  Document History . . . . . . . . . . . . . . . . . .  87\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  90",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "OAuth introduces an authorization layer to the client-server authentication model by separating the role of the client from that of the resource owner. In OAuth, the client requests access to resources controlled by the resource owner and hosted by the resource server. Instead of using the resource owner's credentials to access protected resources, the client obtains an access token - a credential representing a specific set of access attributes such as scope and lifetime. Access tokens are issued to clients by an authorization server with the approval of the resource owner. The client uses the access token to access the protected resources hosted by the resource server.",
      "ja": "OAUTHは、クライアントの役割をリソース所有者の役割から分離することにより、クライアントサーバー認証モデルに承認レイヤーを導入します。OAuthでは、クライアントはリソース所有者によって制御され、リソースサーバーによってホストされているリソースへのアクセスを要求します。リソース所有者の資格情報を使用して保護されたリソースにアクセスする代わりに、クライアントはアクセストークンを取得します。これは、範囲や生涯などの特定のアクセス属性セットを表す資格情報です。アクセストークンは、リソース所有者の承認を得て、承認サーバーによってクライアントに発行されます。クライアントは、アクセストークンを使用して、リソースサーバーがホストする保護されたリソースにアクセスします。"
    },
    {
      "indent": 3,
      "text": "In the older, more limited client-server authentication model, the client requests an access-restricted resource (protected resource) on the server by authenticating to the server using the resource owner's credentials. In order to provide applications access to restricted resources, the resource owner shares their credentials with the application. This creates several problems and limitations:",
      "ja": "より古い、より限られたクライアントサーバー認証モデルでは、クライアントは、リソース所有者の資格情報を使用してサーバーに認証することにより、サーバーにアクセス制限リソース（保護されたリソース）を要求します。制限付きリソースへのアプリケーションアクセスを提供するために、リソース所有者はアプリケーションと資格情報を共有します。これにより、いくつかの問題と制限が作成されます。"
    },
    {
      "indent": 3,
      "text": "* Applications are required to store the resource owner's credentials for future use, typically a password in clear-text.",
      "ja": "* リソース所有者の資格情報を保存するために、将来の使用のためにアプリケーションが必要です。通常、クリアテキストのパスワードです。"
    },
    {
      "indent": 3,
      "text": "* Servers are required to support password authentication, despite the security weaknesses inherent in passwords.",
      "ja": "* パスワードに固有のセキュリティの弱点にもかかわらず、パスワード認証をサポートするためにサーバーが必要です。"
    },
    {
      "indent": 3,
      "text": "* Applications gain overly broad access to the resource owner's protected resources, leaving resource owners without any ability to restrict duration or access to a limited subset of resources.",
      "ja": "* アプリケーションは、リソース所有者の保護されたリソースへの広範なアクセスを獲得し、リソースの所有者が限られたリソースへの期間またはアクセスを制限することができません。"
    },
    {
      "indent": 3,
      "text": "* Resource owners often reuse passwords with other unrelated services, despite best security practices. This password reuse means a vulnerability or exposure in one service may have security implications in completely unrelated services.",
      "ja": "* リソース所有者は、最良のセキュリティ慣行にもかかわらず、他の無関係なサービスでパスワードを再利用することがよくあります。このパスワードの再利用は、1つのサービスでの脆弱性または露出が完全に無関係なサービスにセキュリティに影響を与える可能性があることを意味します。"
    },
    {
      "indent": 3,
      "text": "* Resource owners cannot revoke access to an individual application without revoking access to all third parties, and must do so by changing their password.",
      "ja": "* リソースの所有者は、すべての第三者へのアクセスを取り消すことなく、個々のアプリケーションへのアクセスを取り消すことはできず、パスワードを変更してもそうする必要があります。"
    },
    {
      "indent": 3,
      "text": "* Compromise of any application results in compromise of the end-user's password and all of the data protected by that password.",
      "ja": "* アプリケーションの妥協は、エンドユーザーのパスワードとそのパスワードによって保護されているすべてのデータの妥協をもたらします。"
    },
    {
      "indent": 3,
      "text": "With OAuth, an end-user (resource owner) can grant a printing service (client) access to their protected photos stored at a photo- sharing service (resource server), without sharing their username and password with the printing service. Instead, they authenticate directly with a server trusted by the photo-sharing service (authorization server), which issues the printing service delegation-specific credentials (access token).",
      "ja": "OAUTHを使用すると、エンドユーザー（リソースオーナー）は、印刷サービス（リソースサーバー）に保存されている保護された写真への印刷サービス（クライアント）アクセスを印刷サービスと共有せずに付与できます。代わりに、印刷サービス委任固有の資格情報（アクセストークン）を発行する写真共有サービス（Authorization Server）によって信頼されたサーバーで直接認証されます。"
    },
    {
      "indent": 3,
      "text": "This separation of concerns also provides the ability to use more advanced user authentication methods such as multi-factor authentication and even passwordless authentication, without any modification to the applications. With all user authentication logic handled by the authorization server, applications don't need to be concerned with the specifics of implementing any particular authentication mechanism. This provides the ability for the authorization server to manage the user authentication policies and even change them in the future without coordinating the changes with applications.",
      "ja": "この懸念の分離は、アプリケーションを変更することなく、マルチファクター認証やパスワードレス認証など、より高度なユーザー認証方法を使用する機能も提供します。Authorization Serverによって処理されるすべてのユーザー認証ロジックにより、アプリケーションは特定の認証メカニズムを実装する詳細に関係する必要はありません。これにより、承認サーバーがアプリケーションで変更を調整することなく、ユーザー認証ポリシーを管理し、将来それらを変更する機能を提供します。"
    },
    {
      "indent": 3,
      "text": "The authorization layer can also simplify how a resource server determines if a request is authorized. Traditionally, after authenticating the client, each resource server would evaluate policies to compute if the client is authorized on each API call. In a distributed system, the policies need to be synchronized to all the resource servers, or the resource server must call a central policy server to process each request. In OAuth, evaluation of the policies is performed only when a new access token is created by the authorization server. If the authorized access is represented in the access token, the resource server no longer needs to evaluate the policies, and only needs to validate the access token. This simplification applies when the application is acting on behalf of a resource owner, or on behalf of itself.",
      "ja": "承認レイヤーは、リソースサーバーがリクエストが承認されているかどうかを判断する方法を簡素化することもできます。従来、クライアントを認証した後、各リソースサーバーは、各API呼び出しでクライアントが承認されている場合にポリシーを評価して計算します。分散システムでは、ポリシーをすべてのリソースサーバーに同期する必要があります。または、リソースサーバーが各リクエストを処理するために中央ポリシーサーバーを呼び出す必要があります。OAuthでは、ポリシーの評価は、認証サーバーによって新しいアクセストークンが作成された場合にのみ実行されます。アクセストークンに承認されたアクセスが表されている場合、リソースサーバーはポリシーを評価する必要がなくなり、アクセストークンを検証するだけです。この簡素化は、アプリケーションがリソース所有者に代わって、またはそれ自体に代わって行動している場合に適用されます。"
    },
    {
      "indent": 3,
      "text": "OAuth is an authorization protocol, and is not an authentication protocol. The access token represents the authorization granted to the client. It is a common practice for the client to present the access token to a proprietary API which returns a user identifier for the resource owner, and then using the result of the API as a proxy for authenticating the user. This practice is not part of the OAuth standard or security considerations, and may not have been considered by the resource owner. Implementors should carefully consult the documentation of the resource server before adopting this practice.",
      "ja": "OAuthは認証プロトコルであり、認証プロトコルではありません。アクセストークンは、クライアントに付与された承認を表します。クライアントがアクセストークンを独自のAPIに提示する一般的な慣行であり、リソース所有者のユーザー識別子を返し、APIの結果をユーザーを認証するためのプロキシとして使用します。このプラクティスは、OAUTH標準またはセキュリティの考慮事項の一部ではなく、リソース所有者によって考慮されていない可能性があります。実装者は、このプラクティスを採用する前に、リソースサーバーのドキュメントを慎重に参照する必要があります。"
    },
    {
      "indent": 3,
      "text": "This specification is designed for use with HTTP ([RFC9110]). The use of OAuth over any protocol other than HTTP is out of scope.",
      "ja": "この仕様は、HTTP（[RFC9110]）で使用するために設計されています。HTTP以外のプロトコルでのOAuthの使用は、範囲外です。"
    },
    {
      "indent": 3,
      "text": "Since the publication of the OAuth 2.0 Authorization Framework ([RFC6749]) in October 2012, it has been updated by OAuth 2.0 for Native Apps ([RFC8252]), OAuth Security Best Current Practice ([I-D.ietf-oauth-security-topics]), and OAuth 2.0 for Browser-Based Apps ([I-D.ietf-oauth-browser-based-apps]). The OAuth 2.0 Authorization Framework: Bearer Token Usage ([RFC6750]) has also been updated with ([I-D.ietf-oauth-security-topics]). This Standards Track specification consolidates the information in all of these documents and removes features that have been found to be insecure in [I-D.ietf-oauth-security-topics].",
      "ja": "2012年10月にOAUTH 2.0認証フレームワーク（[RFC6749]）が発行されて以来、ネイティブアプリ向けのOAUTH 2.0によって更新されています（[RFC8252]）、OAUTHセキュリティベストカレントプラクティス（[i-d.ietf-oauth-security-topics]）、およびoauth 2.0 for browser apps（i-d.psf-app-bross-bross-brows-brows-brows-for。OAuth 2.0認証フレームワーク：Bearer Tokenの使用（[RFC6750]）も更新されています（[i-d.ietf-oauth-security-topics]）。この標準トラック仕様は、これらのすべてのドキュメントの情報を統合し、[i-d.ietf-oauth-security-topics]で安全であることがわかった機能を削除します。"
    },
    {
      "indent": 0,
      "text": "1.1. Roles",
      "section_title": true,
      "ja": "1.1. 役割"
    },
    {
      "indent": 3,
      "text": "OAuth defines four roles:",
      "ja": "Oauthは4つの役割を定義します。"
    },
    {
      "indent": 3,
      "text": "\"resource owner\": An entity capable of granting access to a protected resource. When the resource owner is a person, it is referred to as an end-user. This is sometimes abbreviated as \"RO\".",
      "ja": "「リソース所有者」：保護されたリソースへのアクセスを許可できるエンティティ。リソースの所有者が人である場合、それはエンドユーザーと呼ばれます。これは「RO」と略されることがあります。"
    },
    {
      "indent": 3,
      "text": "\"resource server\": The server hosting the protected resources, capable of accepting and responding to protected resource requests using access tokens. The resource server is often accessible via an API. This is sometimes abbreviated as \"RS\".",
      "ja": "「リソースサーバー」：アクセストークンを使用して保護されたリソース要求を受け入れて応答できる保護されたリソースをホストするサーバー。リソースサーバーは、APIを介してアクセスできることがよくあります。これは「RS」と略されることがあります。"
    },
    {
      "indent": 3,
      "text": "\"client\": An application making protected resource requests on behalf of the resource owner and with its authorization. The term \"client\" does not imply any particular implementation characteristics (e.g., whether the application executes on a server, a desktop, or other devices).",
      "ja": "「クライアント」：リソース所有者に代わって、およびその承認を受けて、リソースリクエストを保護するアプリケーション。「クライアント」という用語は、特定の実装特性（たとえば、アプリケーションがサーバー、デスクトップ、またはその他のデバイスで実行されるかどうか）を意味するものではありません。"
    },
    {
      "indent": 3,
      "text": "\"authorization server\": The server issuing access tokens to the client after successfully authenticating the resource owner and obtaining authorization. This is sometimes abbreviated as \"AS\".",
      "ja": "「Authorization Server」：リソース所有者を正常に認証し、認可を取得した後、クライアントにアクセストークンを発行するサーバー。これは時々「as」と略されます。"
    },
    {
      "indent": 3,
      "text": "The interaction between the authorization server and resource server is beyond the scope of this specification, however several extensions have been defined to provide an option for interoperability between resource servers and authorization servers. The authorization server may be the same server as the resource server or a separate entity. A single authorization server may issue access tokens accepted by multiple resource servers.",
      "ja": "Authorization ServerとResource Server間の相互作用はこの仕様の範囲を超えていますが、リソースサーバーと認証サーバー間の相互運用性のオプションを提供するためにいくつかの拡張機能が定義されています。Authorization Serverは、リソースサーバーまたは別のエンティティと同じサーバーである場合があります。単一の承認サーバーは、複数のリソースサーバーによって受け入れられたアクセストークンを発行する場合があります。"
    },
    {
      "indent": 0,
      "text": "1.2. Protocol Flow",
      "section_title": true,
      "ja": "1.2. プロトコルフロー"
    },
    {
      "indent": 8,
      "text": "+--------+                               +---------------+\n|        |--(1)- Authorization Request ->|   Resource    |\n|        |                               |     Owner     |\n|        |<-(2)-- Authorization Grant ---|               |\n|        |                               +---------------+\n|        |\n|        |                               +---------------+\n|        |--(3)-- Authorization Grant -->| Authorization |\n| Client |                               |     Server    |\n|        |<-(4)----- Access Token -------|               |\n|        |                               +---------------+\n|        |\n|        |                               +---------------+\n|        |--(5)----- Access Token ------>|    Resource   |\n|        |                               |     Server    |\n|        |<-(6)--- Protected Resource ---|               |\n+--------+                               +---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 1: Abstract Protocol Flow",
      "ja": "図1：要約プロトコルフロー"
    },
    {
      "indent": 3,
      "text": "The abstract OAuth 2.1 flow illustrated in Figure 1 describes the interaction between the four roles and includes the following steps:",
      "ja": "図1に示す抽象的OAuth 2.1フローは、4つの役割間の相互作用を説明し、次の手順を含めます。"
    },
    {
      "indent": 3,
      "text": "1. The client requests authorization from the resource owner. The authorization request can be made directly to the resource owner (as shown), or preferably indirectly via the authorization server as an intermediary.",
      "ja": "1. クライアントは、リソース所有者に承認を要求します。承認要求は、リソース所有者に直接（図のように）、または仲介者としての承認サーバーを介して間接的に間接的に行うことができます。"
    },
    {
      "indent": 3,
      "text": "2. The client receives an authorization grant, which is a credential representing the resource owner's authorization, expressed using one of the authorization grant types defined in this specification or using an extension grant type. The authorization grant type depends on the method used by the client to request authorization and the types supported by the authorization server.",
      "ja": "2. クライアントは、この仕様で定義されている承認助成金タイプのいずれかを使用して、または拡張補助金タイプを使用して、リソース所有者の承認を表す資格である承認助成金を受け取ります。承認助成金の種類は、クライアントが認証を要求するために使用する方法と、承認サーバーによってサポートされているタイプに依存します。"
    },
    {
      "indent": 3,
      "text": "3. The client requests an access token by authenticating with the authorization server and presenting the authorization grant.",
      "ja": "3. クライアントは、承認サーバーを認証し、認証助成金を提示することにより、アクセストークンを要求します。"
    },
    {
      "indent": 3,
      "text": "4. The authorization server authenticates the client and validates the authorization grant, and if valid, issues an access token.",
      "ja": "4. 承認サーバーは、クライアントを認証し、承認助成金を検証し、有効な場合はアクセストークンを発行します。"
    },
    {
      "indent": 3,
      "text": "5. The client requests the protected resource from the resource server and authenticates by presenting the access token.",
      "ja": "5. クライアントは、リソースサーバーに保護されたリソースを要求し、アクセストークンを提示することにより認証を受けます。"
    },
    {
      "indent": 3,
      "text": "6. The resource server validates the access token, and if valid, serves the request.",
      "ja": "6. リソースサーバーはアクセストークンを検証し、有効な場合はリクエストを提供します。"
    },
    {
      "indent": 3,
      "text": "The preferred method for the client to obtain an authorization grant from the resource owner (depicted in steps (1) and (2)) is to use the authorization server as an intermediary, which is illustrated in Figure 3 in Section 4.1.",
      "ja": "クライアントがリソース所有者から承認助成金を取得するための優先方法（ステップ（1）および（2）に描かれている）は、承認サーバーを中間として使用することです。これは、セクション4.1の図3に示すものです。"
    },
    {
      "indent": 0,
      "text": "1.3. Authorization Grant",
      "section_title": true,
      "ja": "1.3. 承認助成金"
    },
    {
      "indent": 3,
      "text": "An authorization grant represents the resource owner's authorization (to access its protected resources) used by the client to obtain an access token. This specification defines three grant types -- authorization code, refresh token, and client credentials -- as well as an extensibility mechanism for defining additional types.",
      "ja": "認可助成金は、クライアントがアクセストークンを取得するために使用されるリソース所有者の承認（保護されたリソースにアクセスするため）を表します。この仕様では、3つの助成金タイプ（承認コード、更新トークン、クライアント資格情報）と、追加のタイプを定義するための拡張性メカニズムを定義します。"
    },
    {
      "indent": 0,
      "text": "1.3.1. Authorization Code",
      "section_title": true,
      "ja": "1.3.1. 承認コード"
    },
    {
      "indent": 3,
      "text": "An authorization code is a temporary credential used to obtain an access token. Instead of the client requesting authorization directly from the resource owner, the client directs the resource owner to an authorization server (via its user agent, which in turn directs the resource owner back to the client with the authorization code. The client can then exchange the authorization code for an access token.",
      "ja": "承認コードは、アクセストークンを取得するために使用される一時的な資格です。クライアントがリソース所有者に直接認証を要求する代わりに、クライアントはリソース所有者を認証サーバーに向けます（ユーザーエージェントを介して、リソース所有者を認証コードでクライアントに戻すようにします。クライアントは認証コードをアクセストークンと交換できます。"
    },
    {
      "indent": 3,
      "text": "Before directing the resource owner back to the client with the authorization code, the authorization server authenticates the resource owner, and may request the resource owner's consent or otherwise inform them of the client's request. Because the resource owner only authenticates with the authorization server, the resource owner's credentials are never shared with the client, and the client does not need to have knowledge of any additional authentication steps such as multi-factor authentication or delegated accounts.",
      "ja": "リソース所有者を承認コードでクライアントに送り返す前に、承認サーバーはリソース所有者を認証し、リソース所有者の同意を要求するか、クライアントの要求を通知する場合があります。リソース所有者はAuthorization Serverでのみ認証されるため、リソース所有者の資格情報はクライアントと共有されることはなく、クライアントはマルチファクター認証や委任されたアカウントなどの追加の認証ステップの知識を持つ必要はありません。"
    },
    {
      "indent": 3,
      "text": "The authorization code provides a few important security benefits, such as the ability to authenticate the client, as well as the transmission of the access token directly to the client without passing it through the resource owner's user agent and potentially exposing it to others, including the resource owner.",
      "ja": "承認コードは、クライアントを認証する機能や、リソース所有者のユーザーエージェントを通過せずにアクセストークンを直接クライアントに直接送信し、リソース所有者を含む他の人にさらされることなく、クライアントに直接送信するなど、いくつかの重要なセキュリティ特典を提供します。"
    },
    {
      "indent": 0,
      "text": "1.3.2. Refresh Token",
      "section_title": true,
      "ja": "1.3.2. トークンを更新します"
    },
    {
      "indent": 3,
      "text": "Refresh tokens are credentials used to obtain access tokens. Refresh tokens are issued to the client by the authorization server and are used to obtain a new access token when the current access token becomes invalid or expires, or to obtain additional access tokens with identical or narrower scope (access tokens may have a shorter lifetime and fewer permissions than authorized by the resource owner). Issuing a refresh token is optional at the discretion of the authorization server, and may be issued based on properties of the client, properties of the request, policies within the authorization server, or any other criteria. If the authorization server issues a refresh token, it is included when issuing an access token (i.e., step (2) in Figure 2).",
      "ja": "更新トークンは、アクセストークンを取得するために使用される資格情報です。更新トークンは認証サーバーによってクライアントに発行され、現在のアクセストークンが無効になったり期限切れになったときに新しいアクセストークンを取得したり、同一または狭いスコープで追加のアクセストークンを取得したりするために使用されます（アクセストークンは、リソース所有者が認証するよりも寿命が短くなり、許可が少ない場合があります）。更新トークンの発行は、認証サーバーの裁量でオプションであり、クライアントのプロパティ、リクエストのプロパティ、承認サーバー内のポリシー、またはその他の基準に基づいて発行される場合があります。Authorization Serverが更新トークンを発行する場合、アクセストークンを発行するときに含まれています（つまり、図2のステップ（2））。"
    },
    {
      "indent": 3,
      "text": "A refresh token is a string representing the authorization granted to the client by the resource owner. The string is considered opaque to the client. The refresh token may be an identifier used to retrieve the authorization information or may encode this information into the string itself. Unlike access tokens, refresh tokens are intended for use only with authorization servers and are never sent to resource servers.",
      "ja": "リフレッシュトークンは、リソース所有者によってクライアントに付与された承認を表す文字列です。文字列はクライアントにとって不透明と見なされます。更新トークンは、承認情報を取得するために使用される識別子であるか、この情報を文字列自体にエンコードする場合があります。アクセストークンとは異なり、更新トークンは承認サーバーでのみ使用することを目的としており、リソースサーバーに送信されることはありません。"
    },
    {
      "indent": 2,
      "text": "+--------+                                           +---------------+\n|        |--(1)------- Authorization Grant --------->|               |\n|        |                                           |               |\n|        |<-(2)----------- Access Token -------------|               |\n|        |               & Refresh Token             |               |\n|        |                                           |               |\n|        |                            +----------+   |               |\n|        |--(3)---- Access Token ---->|          |   |               |\n|        |                            |          |   |               |\n|        |<-(4)- Protected Resource --| Resource |   | Authorization |\n| Client |                            |  Server  |   |     Server    |\n|        |--(5)---- Access Token ---->|          |   |               |\n|        |                            |          |   |               |\n|        |<-(6)- Invalid Token Error -|          |   |               |\n|        |                            +----------+   |               |\n|        |                                           |               |\n|        |--(7)----------- Refresh Token ----------->|               |\n|        |                                           |               |\n|        |<-(8)----------- Access Token -------------|               |\n+--------+           & Optional Refresh Token        +---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 2: Refreshing an Expired Access Token",
      "ja": "図2：期限切れのアクセストークンを更新します"
    },
    {
      "indent": 3,
      "text": "The flow illustrated in Figure 2 includes the following steps:",
      "ja": "図2に示すフローには、次の手順が含まれています。"
    },
    {
      "indent": 3,
      "text": "1. The client requests an access token by authenticating with the authorization server and presenting an authorization grant.",
      "ja": "1. クライアントは、承認サーバーを認証し、認証助成金を提示することにより、アクセストークンを要求します。"
    },
    {
      "indent": 3,
      "text": "2. The authorization server authenticates the client and validates the authorization grant, and if valid, issues an access token and optionally a refresh token.",
      "ja": "2. Authorization Serverはクライアントを認証し、認証助成金を検証し、有効な場合はアクセストークンとオプションで更新トークンを発行します。"
    },
    {
      "indent": 3,
      "text": "3. The client makes a protected resource request to the resource server by presenting the access token.",
      "ja": "3. クライアントは、アクセストークンを提示することにより、リソースサーバーに保護されたリソースリクエストを行います。"
    },
    {
      "indent": 3,
      "text": "4. The resource server validates the access token, and if valid, serves the request.",
      "ja": "4. リソースサーバーはアクセストークンを検証し、有効な場合はリクエストを提供します。"
    },
    {
      "indent": 3,
      "text": "5. Steps (3) and (4) repeat until the access token expires. If the client knows the access token expired, it skips to step (7); otherwise, it makes another protected resource request.",
      "ja": "5. 手順（3）および（4）は、アクセストークンが期限切れになるまで繰り返します。クライアントがアクセストークンが期限切れになったことを知っている場合、ステップ（7）にスキップします。それ以外の場合は、別の保護されたリソースリクエストを作成します。"
    },
    {
      "indent": 3,
      "text": "6. Since the access token is invalid, the resource server returns an invalid token error.",
      "ja": "6. アクセストークンは無効であるため、リソースサーバーは無効なトークンエラーを返します。"
    },
    {
      "indent": 3,
      "text": "7. The client requests a new access token by presenting the refresh token and providing client authentication if it has been issued credentials. The client authentication requirements are based on the client type and on the authorization server policies.",
      "ja": "7. クライアントは、リフレッシュトークンを提示し、クライアント認証を提供した場合にクライアント認証を提供することにより、新しいアクセストークンを要求します。クライアント認証要件は、クライアントタイプと承認サーバーポリシーに基づいています。"
    },
    {
      "indent": 3,
      "text": "8. The authorization server authenticates the client and validates the refresh token, and if valid, issues a new access token (and, optionally, a new refresh token).",
      "ja": "8. Authorization Serverはクライアントを認証し、更新トークンを検証し、有効な場合、新しいアクセストークン（およびオプションでは新しい更新トークン）を発行します。"
    },
    {
      "indent": 0,
      "text": "1.3.3. Client Credentials",
      "section_title": true,
      "ja": "1.3.3. クライアントの資格情報"
    },
    {
      "indent": 3,
      "text": "The client credentials or other forms of client authentication (e.g. a private key used to sign a JWT, as described in [RFC7523]) can be used as an authorization grant when the authorization scope is limited to the protected resources under the control of the client, or to protected resources previously arranged with the authorization server. Client credentials are used when the client is requesting access to protected resources based on an authorization previously arranged with the authorization server.",
      "ja": "クライアントの資格情報またはその他の形式のクライアント認証（例：[RFC7523]に記載されているJWTに署名するために使用される秘密鍵）は、承認範囲がクライアントの管理下にある保護されたリソースに制限されている場合、または承認サーバーに配置された保護されたリソースに制限されている場合、承認助成金として使用できます。クライアントの資格情報は、クライアントが、承認サーバーと以前に配置された承認に基づいて、保護されたリソースへのアクセスを要求しているときに使用されます。"
    },
    {
      "indent": 0,
      "text": "1.4. Access Token",
      "section_title": true,
      "ja": "1.4. アクセストークン"
    },
    {
      "indent": 3,
      "text": "Access tokens are credentials used to access protected resources. An access token is a string representing an authorization issued to the client. The string is considered opaque to the client, even if it has a structure. Depending on the authorization server, the access token string may be parseable by the resource server, such as when using the JSON Web Token Profile for Access Tokens ([RFC9068]).",
      "ja": "アクセストークンは、保護されたリソースにアクセスするために使用される資格情報です。アクセストークンは、クライアントに発行された承認を表す文字列です。文字列は、たとえ構造がある場合でも、クライアントにとって不透明と見なされます。Authorization Serverに応じて、アクセストークンにJSON Webトークンプロファイルを使用する場合など、アクセストークン文字列がリソースサーバーによって解析可能になる場合があります（[RFC9068]）。"
    },
    {
      "indent": 3,
      "text": "Access tokens represent specific scopes and durations of access, granted by the resource owner, and enforced by the resource server and authorization server.",
      "ja": "アクセストークンは、リソース所有者によって付与され、リソースサーバーと承認サーバーによって実施された特定のスコープとアクセス期間を表します。"
    },
    {
      "indent": 3,
      "text": "The token may be used by the RS to retrieve the authorization information, or the token may self-contain the authorization information in a verifiable manner (i.e., a token string consisting of a signed data payload). One example of a token retrieval mechanism is Token Introspection [RFC7662], in which the RS calls an endpoint on the AS to validate the token presented by the client. One example of a structured token format is [RFC9068], a method of encoding access token data as a JSON Web Token [RFC7519].",
      "ja": "トークンは、RSによって許可情報を取得するために使用される場合があります。または、トークンは、検証可能な方法で承認情報を自己含有することができます（つまり、署名されたデータペイロードで構成されるトークン文字列）。トークン検索メカニズムの1つの例は、トークン内省[RFC7662]であり、RSはクライアントが提示したトークンを検証するためにエンドポイントを呼び出します。構造化されたトークン形式の1つの例は[RFC9068]です。これは、JSON Webトークン[RFC7519]としてアクセストークンデータをエンコードする方法です。"
    },
    {
      "indent": 3,
      "text": "Additional authentication credentials, which are beyond the scope of this specification, may be required in order for the client to use an access token. This is typically referred to as a sender-constrained access token, such as DPoP [I-D.ietf-oauth-dpop] and Mutual TLS Access Tokens [RFC8705].",
      "ja": "クライアントがアクセストークンを使用するには、この仕様の範囲を超えた追加の認証資格情報が必要になる場合があります。これは通常、DPOP [I-D.IETF-OAUTH-DPOP]や相互TLSアクセストークン[RFC8705]など、送信者に制約のあるアクセストークンと呼ばれます。"
    },
    {
      "indent": 3,
      "text": "The access token provides an abstraction layer, replacing different authorization constructs (e.g., username and password) with a single token understood by the resource server. This abstraction enables issuing access tokens more restrictive than the authorization grant used to obtain them, as well as removing the resource server's need to understand a wide range of authentication methods.",
      "ja": "アクセストークンは、抽象化レイヤーを提供し、さまざまな認証コンストラクト（ユーザー名とパスワードなど）をリソースサーバーが理解した単一のトークンに置き換えます。この抽象化により、アクセストークンを発行することで、それらを取得するために使用される承認助成金よりも制限があり、リソースサーバーの幅広い認証方法を理解する必要性を削除できます。"
    },
    {
      "indent": 3,
      "text": "Access tokens can have different formats, structures, and methods of utilization (e.g., cryptographic properties) based on the resource server security requirements. Access token attributes and the methods used to access protected resources may be extended beyond what is described in this specification.",
      "ja": "アクセストークンには、リソースサーバーのセキュリティ要件に基づいて、さまざまな形式、構造、および使用方法（暗号化プロパティなど）を使用できます。アクセストークン属性と保護されたリソースにアクセスするために使用される方法は、この仕様で説明されているものを超えて拡張できます。"
    },
    {
      "indent": 3,
      "text": "Access tokens (as well as any confidential access token attributes) MUST be kept confidential in transit and storage, and only shared among the authorization server, the resource servers the access token is valid for, and the client to whom the access token is issued.",
      "ja": "アクセストークン（および任意の機密アクセストークン属性）は、輸送とストレージで機密を保持する必要があり、認証サーバー、アクセストークンが有効なリソースサーバー、およびアクセストークンが発行されるクライアントのみを共有する必要があります。"
    },
    {
      "indent": 3,
      "text": "The authorization server MUST ensure that access tokens cannot be generated, modified, or guessed to produce valid access tokens by unauthorized parties.",
      "ja": "Authorization Serverは、アクセストークンを生成、変更、または推測して、許可されていない当事者によって有効なアクセストークンを生成できないことを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "1.5. Communication security",
      "section_title": true,
      "ja": "1.5. コミュニケーションセキュリティ"
    },
    {
      "indent": 3,
      "text": "Implementations MUST use a mechanism to provide communication authentication, integrity and confidentiality such as Transport-Layer Security [RFC8446], to protect the exchange of clear-text credentials and tokens either in the content or in header fields from eavesdropping, tampering, and message forgery (eg. see Section 2.4.1, Section 7.6, Section 3.2, and Section 5.2).",
      "ja": "実装は、メカニズムを使用して、通信認証、整合性、輸送層セキュリティ[RFC8446]などの機密性を提供し、コンテンツまたはヘッダーフィールドのクリアテキスト資格情報とトークンの交換を保護する必要があります。"
    },
    {
      "indent": 3,
      "text": "OAuth URLs MUST use the https scheme except for loopback interface redirect URIs, which MAY use the http scheme. When using https, TLS certificates MUST be checked according to [RFC9110]. At the time of this writing, TLS version 1.3 [RFC8446] is the most recent version.",
      "ja": "OAuth URLは、HTTPスキームを使用する可能性のあるループバックインターフェイスリダイレクトURIを除き、HTTPSスキームを使用する必要があります。HTTPSを使用する場合、[RFC9110]に従ってTLS証明書を確認する必要があります。この執筆時点で、TLSバージョン1.3 [RFC8446]は最新のバージョンです。"
    },
    {
      "indent": 3,
      "text": "Implementations MAY also support additional transport-layer security mechanisms that meet their security requirements.",
      "ja": "実装は、セキュリティ要件を満たす追加の輸送層セキュリティメカニズムをサポートする場合があります。"
    },
    {
      "indent": 3,
      "text": "The identification of the TLS versions and algorithms is outside the scope of this specification. Refer to [BCP195] for up to date recommendations on transport layer security, and to the relevant specifications for certificate validation and other security considerations.",
      "ja": "TLSバージョンとアルゴリズムの識別は、この仕様の範囲外です。輸送層のセキュリティに関する最新の推奨事項、および証明書の検証およびその他のセキュリティに関する考慮事項の関連する仕様については、[BCP195]を参照してください。"
    },
    {
      "indent": 0,
      "text": "1.6. HTTP Redirections",
      "section_title": true,
      "ja": "1.6. HTTPリダイレクト"
    },
    {
      "indent": 3,
      "text": "This specification makes extensive use of HTTP redirections, in which the client or the authorization server directs the resource owner's user agent to another destination. While the examples in this specification show the use of the HTTP 302 status code, any other method available via the user agent to accomplish this redirection, with the exception of HTTP 307, is allowed and is considered to be an implementation detail. See Section 7.5.2 for details.",
      "ja": "この仕様により、HTTPリダイレクトが広範囲に使用されています。クライアントまたは承認サーバーは、リソース所有者のユーザーエージェントを別の目的地に指示します。この仕様の例はHTTP 302ステータスコードの使用を示していますが、HTTP 307を除き、このリダイレクトを達成するためにユーザーエージェントを介して利用可能な他の方法は許可されており、実装の詳細と見なされます。詳細については、セクション7.5.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "1.7. Interoperability",
      "section_title": true,
      "ja": "1.7. 相互運用性"
    },
    {
      "indent": 3,
      "text": "OAuth 2.1 provides a rich authorization framework with well-defined security properties.",
      "ja": "OAUTH 2.1は、明確に定義されたセキュリティプロパティを備えた豊富な承認フレームワークを提供します。"
    },
    {
      "indent": 3,
      "text": "This specification leaves a few required components partially or fully undefined (e.g., client registration, authorization server capabilities, endpoint discovery). Some of these behaviors are defined in optional extensions which implementations can choose to use, such as:",
      "ja": "この仕様は、いくつかの必要なコンポーネントが部分的または完全に定義されていないままになります（たとえば、クライアント登録、承認サーバー機能、エンドポイントの発見）。これらの動作のいくつかは、次のような実装が使用することを選択できるオプションの拡張機能で定義されています。"
    },
    {
      "indent": 3,
      "text": "* [RFC8414]: Authorization Server Metadata, defining an endpoint clients can use to look up the information needed to interact with a particular OAuth server",
      "ja": "* [RFC8414]：Authorization Serverメタデータ、エンドポイントクライアントを定義することで、特定のOAuthサーバーと対話するために必要な情報を検索するために使用できます"
    },
    {
      "indent": 3,
      "text": "* [RFC7591]: Dynamic Client Registration, providing a mechanism for programmatically registering clients with an authorization server",
      "ja": "* [RFC7591]：ダイナミッククライアント登録、クライアントを承認サーバーにプログラム的に登録するメカニズムを提供する"
    },
    {
      "indent": 3,
      "text": "* [RFC7592]: Dynamic Client Management, providing a mechanism for updating dynamically registered client information",
      "ja": "* [RFC7592]：動的に登録されたクライアント情報を更新するためのメカニズムを提供する動的なクライアント管理"
    },
    {
      "indent": 3,
      "text": "* [RFC7662]: Token Introspection, defining a mechanism for resource servers to obtain information about access tokens",
      "ja": "* [RFC7662]：トークン内省、リソースサーバーがアクセストークンに関する情報を取得するメカニズムを定義する"
    },
    {
      "indent": 3,
      "text": "Please refer to Appendix C for a list of current known extensions at the time of this publication.",
      "ja": "この出版物の時点での現在の既知の拡張機能のリストについては、付録Cを参照してください。"
    },
    {
      "indent": 0,
      "text": "1.8. Compatibility with OAuth 2.0",
      "section_title": true,
      "ja": "1.8. OAUTH 2.0との互換性"
    },
    {
      "indent": 3,
      "text": "OAuth 2.1 is compatible with OAuth 2.0 with the extensions and restrictions from known best current practices applied. Specifically, features not specified in OAuth 2.0 core, such as PKCE, are required in OAuth 2.1. Additionally, some features available in OAuth 2.0, such as the Implicit or Resource Owner Credentials grant types, are not specified in OAuth 2.1. Furthermore, some behaviors allowed in OAuth 2.0 are restricted in OAuth 2.1, such as the strict string matching of redirect URIs required by OAuth 2.1.",
      "ja": "OAUTH 2.1は、OAUTH 2.0と互換性があります。具体的には、PKCEなどのOAUTH 2.0コアで指定されていない機能は、OAUTH 2.1で必要です。さらに、OAUTH 2.0で利用可能ないくつかの機能は、暗黙的またはリソース所有者資格情報の付与タイプなど、OAUTH 2.1では指定されていません。さらに、OAUTH 2.0で許可されているいくつかの動作は、OAUTH 2.1で必要なリダイレクトURIの厳密な文字列マッチングなど、OAUTH 2.1で制限されています。"
    },
    {
      "indent": 3,
      "text": "See Section 10 for more details on the differences from OAuth 2.0.",
      "ja": "OAUTH 2.0の違いの詳細については、セクション10を参照してください。"
    },
    {
      "indent": 0,
      "text": "1.9. Notational Conventions",
      "section_title": true,
      "ja": "1.9. 表記規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 3,
      "text": "This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234]. Additionally, the rule URI-reference is included from \"Uniform Resource Identifier (URI): Generic Syntax\" [RFC3986].",
      "ja": "この仕様では、[RFC5234]の拡張されたBackus-Naurフォーム（ABNF）表記を使用します。さらに、ルールURI-referenceは、「ユニフォームリソース識別子（URI）：ジェネリック構文」[RFC3986]から含まれています。"
    },
    {
      "indent": 3,
      "text": "Certain security-related terms are to be understood in the sense defined in [RFC4949]. These terms include, but are not limited to, \"attack\", \"authentication\", \"authorization\", \"certificate\", \"confidentiality\", \"credential\", \"encryption\", \"identity\", \"sign\", \"signature\", \"trust\", \"validate\", and \"verify\".",
      "ja": "特定のセキュリティ関連の用語は、[RFC4949]で定義されている意味で理解されます。これらの用語には、「攻撃」、「認証」、「認証」、「証明書」、「機密性」、「資格情報」、「暗号化」、「身元」、「署名」、「署名」、「信頼」、「検証」、「検証」が含まれますが、これらに限定されません。"
    },
    {
      "indent": 3,
      "text": "The term \"content\" is to be interpreted as described in Section 6.4 of [RFC9110].",
      "ja": "「コンテンツ」という用語は、[RFC9110]のセクション6.4で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "The term \"user agent\" is to be interpreted as described in Section 3.5 of [RFC9110].",
      "ja": "「ユーザーエージェント」という用語は、[RFC9110]のセクション3.5で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "Unless otherwise noted, all the protocol parameter names and values are case sensitive.",
      "ja": "特に明記しない限り、すべてのプロトコルパラメーター名と値はケースに敏感です。"
    },
    {
      "indent": 0,
      "text": "2. Client Registration",
      "section_title": true,
      "ja": "2. クライアント登録"
    },
    {
      "indent": 3,
      "text": "Before initiating the protocol, the client must establish its registration with the authorization server. The means through which the client registers with the authorization server are beyond the scope of this specification but typically involve the client developer manually registering the client at the authorization server's website after creating an account and agreeing to the service's Terms of Service, or by using Dynamic Client Registration ([RFC7591]).",
      "ja": "プロトコルを開始する前に、クライアントは承認サーバーへの登録を確立する必要があります。クライアントが承認サーバーで登録する手段は、この仕様の範囲を超えていますが、通常、クライアント開発者がアカウントを作成し、サービスの利用規約に同意した後、またはダイナミッククライアント登録を使用して認証サーバーのWebサイトでクライアントを手動で登録することを伴います（[RFC7591]）。"
    },
    {
      "indent": 3,
      "text": "Client registration does not require a direct interaction between the client and the authorization server. When supported by the authorization server, registration can rely on other means for establishing trust and obtaining the required client properties (e.g., redirect URI, client type). For example, registration can be accomplished using a self-issued or third-party-issued assertion, or by the authorization server performing client discovery using a trusted channel.",
      "ja": "クライアント登録では、クライアントと承認サーバーの間の直接的な相互作用は必要ありません。承認サーバーによってサポートされる場合、登録は、信頼を確立し、必要なクライアントプロパティを取得するための他の手段に依存できます（例：URI、クライアントタイプなど）。たとえば、登録は、自己発行またはサードパーティ発行のアサーションを使用して、または信頼できるチャネルを使用してクライアントの発見を実行する承認サーバーによって達成できます。"
    },
    {
      "indent": 3,
      "text": "When registering a client, the client developer SHALL:",
      "ja": "クライアントを登録する場合、クライアント開発者は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* specify the client type as described in Section 2.1,",
      "ja": "* セクション2.1で説明されているクライアントタイプを指定します。"
    },
    {
      "indent": 3,
      "text": "* provide client details needed by the grant type in use, such as redirect URIs as described in Section 2.3, and",
      "ja": "* セクション2.3で説明されているURIをリダイレクトするなど、使用中の助成金タイプで必要なクライアントの詳細を提供します。"
    },
    {
      "indent": 3,
      "text": "* include any other information required by the authorization server (e.g., application name, website, description, logo image, the acceptance of legal terms).",
      "ja": "* 承認サーバーで必要なその他の情報（アプリケーション名、ウェブサイト、説明、ロゴ画像、法的条件の受け入れなど）を含めます。"
    },
    {
      "indent": 3,
      "text": "Dynamic Client Registration ([RFC7591]) defines a common general data model for clients that may be used even with manual client registration.",
      "ja": "動的クライアント登録（[RFC7591]）は、手動クライアント登録を使用しても使用される可能性のあるクライアントの一般的な一般データモデルを定義します。"
    },
    {
      "indent": 0,
      "text": "2.1. Client Types",
      "section_title": true,
      "ja": "2.1. クライアントタイプ"
    },
    {
      "indent": 3,
      "text": "OAuth 2.1 defines two client types based on their ability to authenticate securely with the authorization server.",
      "ja": "OAUTH 2.1は、Authorization Serverで安全に認証する機能に基づいて2つのクライアントタイプを定義します。"
    },
    {
      "indent": 3,
      "text": "\"confidential\": Clients that have credentials with the AS are designated as \"confidential clients\"",
      "ja": "「Confidential」：ASの資格情報を持っているクライアントは「Confidential Clients」と指定されています"
    },
    {
      "indent": 3,
      "text": "\"public\": Clients without credentials are called \"public clients\"",
      "ja": "「パブリック」：資格情報のないクライアントは「パブリッククライアント」と呼ばれます"
    },
    {
      "indent": 3,
      "text": "Any clients with credentials MUST take precautions to prevent leakage and abuse of their credentials.",
      "ja": "資格情報を持つクライアントは、資格の漏れや乱用を防ぐために予防策を講じなければなりません。"
    },
    {
      "indent": 3,
      "text": "Client authentication allows an Authorization Server to ensure it is interacting with a certain client (identified by its client_id) in an OAuth flow. The Authorization Server might make policy decisions about things such as whether to prompt the user for consent on every authorization or only the first based on the confidence that the Authorization Server is actually communicating with the legitimate client.",
      "ja": "クライアント認証により、認証サーバーは、OAuthフロー内の特定のクライアント（client_idによって識別）と対話していることを確認できます。承認サーバーは、すべての承認についてユーザーに同意を求めるかどうか、または承認サーバーが実際に正当なクライアントと通信しているという自信に基づいて最初のもののみを促すなど、事柄についてポリシー決定を下す場合があります。"
    },
    {
      "indent": 3,
      "text": "Whether and how an Authorization Server validates the identity of a client or the party providing/operating this client is out of scope of this specification. Authorization servers SHOULD consider the level of confidence in a client's identity when deciding whether they allow a client access to more sensitive resources and operations such as the Client Credentials grant type and how often to prompt the user for consent.",
      "ja": "承認サーバーがクライアントまたはこのクライアントを提供/操作する当事者の身元を検証するかどうか、および方法は、この仕様の範囲外です。許可サーバーは、クライアントがより機密性の高いリソースやクライアント資格情報の付与タイプなどのより機密のリソースへのアクセスを許可し、ユーザーに同意を求める頻度を決定する際に、クライアントの身元に対する信頼レベルを考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "A single client_id SHOULD NOT be treated as more than one type of client.",
      "ja": "単一のclient_idを複数のタイプのクライアントとして扱うべきではありません。"
    },
    {
      "indent": 3,
      "text": "This specification has been designed around the following client profiles:",
      "ja": "この仕様は、次のクライアントプロファイルを中心に設計されています。"
    },
    {
      "indent": 3,
      "text": "\"web application\": A web application is a client running on a web server. Resource owners access the client via an HTML user interface rendered in a user agent on the device used by the resource owner. The client credentials as well as any access tokens issued to the client are stored on the web server and are not exposed to or accessible by the resource owner.",
      "ja": "「Webアプリケーション」：Webアプリケーションは、Webサーバーで実行されているクライアントです。リソース所有者は、リソース所有者が使用するデバイス上のユーザーエージェントにレンダリングされたHTMLユーザーインターフェイスを介してクライアントにアクセスします。クライアントの資格情報とクライアントに発行されたアクセストークンは、Webサーバーに保存され、リソース所有者にさらされたりアクセスできません。"
    },
    {
      "indent": 3,
      "text": "\"browser-based application\": A browser-based application is a client in which the client code is downloaded from a web server and executes within a user agent (e.g., web browser) on the device used by the resource owner. Protocol data and credentials are easily accessible (and often visible) to the resource owner. If such applications wish to use client credentials, it is recommended to utilize the backend for frontend pattern. Since such applications reside within the user agent, they can make seamless use of the user agent capabilities when requesting authorization.",
      "ja": "「ブラウザベースのアプリケーション」：ブラウザーベースのアプリケーションは、クライアントであるクライアントであり、クライアントコードがWebサーバーからダウンロードされ、リソース所有者が使用するデバイス上のユーザーエージェント（Webブラウザーなど）内で実行されます。プロトコルデータと資格情報は、リソース所有者が簡単にアクセスできます（そして多くの場合見ることができます）。そのようなアプリケーションがクライアントの資格情報を使用したい場合は、フロントエンドパターンにバックエンドを使用することをお勧めします。このようなアプリケーションはユーザーエージェント内に存在するため、承認を要求するときにユーザーエージェント機能をシームレスに使用できます。"
    },
    {
      "indent": 3,
      "text": "\"native application\": A native application is a client installed and executed on the device used by the resource owner. Protocol data and credentials are accessible to the resource owner. It is assumed that any client authentication credentials included in the application can be extracted. Dynamically issued access tokens and refresh tokens can receive an acceptable level of protection. On some platforms, these credentials are protected from other applications residing on the same device. If such applications wish to use client credentials, it is recommended to utilize the backend for frontend pattern, or issue the credentials at runtime using Dynamic Client Registration ([RFC7591]).",
      "ja": "「ネイティブアプリケーション」：ネイティブアプリケーションは、リソース所有者が使用するデバイスにインストールおよび実行されるクライアントです。プロトコルデータと資格情報は、リソース所有者がアクセスできます。アプリケーションに含まれるクライアント認証資格情報を抽出できると想定されています。動的に発行されたアクセストークンと更新トークンは、許容可能なレベルの保護を受けることができます。一部のプラットフォームでは、これらの資格情報は、同じデバイスに存在する他のアプリケーションから保護されています。そのようなアプリケーションがクライアント資格情報を使用する場合は、フロントエンドパターンにバックエンドを使用するか、動的クライアント登録（[RFC7591]）を使用して実行時に資格情報を発行することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "2.2. Client Identifier",
      "section_title": true,
      "ja": "2.2. クライアント識別子"
    },
    {
      "indent": 3,
      "text": "Every client is identified in the context of an authorization server by a client identifier -- a unique string representing the registration information provided by the client. While the Authorization Server typically issues the client identifier itself, it may also serve clients whose client identifier was created by a party other than the Authorization Server. The client identifier is not a secret; it is exposed to the resource owner and MUST NOT be used alone for client authentication. The client identifier is unique in the context of an authorization server.",
      "ja": "すべてのクライアントは、クライアント識別子によって認証サーバーのコンテキストで識別されます。クライアントが提供する登録情報を表す一意の文字列です。認証サーバーは通常、クライアント識別子自体を発行しますが、クライアントの識別子が認証サーバー以外のパーティによって作成されたクライアントにサービスを提供する場合があります。クライアント識別子は秘密ではありません。リソース所有者にさらされており、クライアント認証のために単独で使用してはなりません。クライアント識別子は、認証サーバーのコンテキストで一意です。"
    },
    {
      "indent": 3,
      "text": "The client identifier string size is left undefined by this specification. The client should avoid making assumptions about the identifier size. The authorization server SHOULD document the size of any identifier it issues.",
      "ja": "クライアント識別子の文字列サイズは、この仕様によって未定義のままになります。クライアントは、識別子サイズについて仮定を避ける必要があります。Authorization Serverは、問題のある識別子のサイズを文書化する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the authorization server supports clients with client identifiers issued by parties other than the authorization server, the authorization server SHOULD take precautions to avoid clients impersonating resource owners as described in Section 7.4.",
      "ja": "Authorization Serverが、承認サーバー以外の当事者によって発行されたクライアント識別子を持つクライアントをサポートしている場合、認証サーバーは、セクション7.4で説明されているように、クライアントがリソース所有者になりすましないように予防策を講じる必要があります。"
    },
    {
      "indent": 0,
      "text": "2.3. Client Redirection Endpoint",
      "section_title": true,
      "ja": "2.3. クライアントリダイレクトエンドポイント"
    },
    {
      "indent": 3,
      "text": "The client redirection endpoint (also referred to as \"redirect endpoint\") is the URI of the client that the authorization server redirects the user agent back to after completing its interaction with the resource owner.",
      "ja": "クライアントリダイレクトエンドポイント（「リダイレクトエンドポイント」とも呼ばれる）は、クライアントのURIであり、認証サーバーがリソース所有者との対話を完了した後にユーザーエージェントをリダイレクトします。"
    },
    {
      "indent": 3,
      "text": "The authorization server redirects the user agent to one of the client's redirection endpoints previously established with the authorization server during the client registration process.",
      "ja": "Authorization Serverは、ユーザーエージェントを、クライアント登録プロセス中に認証サーバーで以前に確立されたクライアントのリダイレクトエンドポイントの1つにリダイレクトします。"
    },
    {
      "indent": 3,
      "text": "The redirect URI MUST be an absolute URI as defined by [RFC3986] Section 4.3. The redirect URI MAY include an \"application/x-www-form-urlencoded\" formatted query component ([WHATWG.URL]), which MUST be retained when adding additional query parameters. The redirect URI MUST NOT include a fragment component.",
      "ja": "リダイレクトURIは、[RFC3986]セクション4.3で定義されている絶対URIでなければなりません。リダイレクトURIには、「アプリケーション/x-www-form-urlencoded」フォーマットされたクエリコンポーネント（[whatwg.url]）が含まれる場合があります。これは、追加のクエリパラメーターを追加するときに保持する必要があります。リダイレクトURIには、フラグメントコンポーネントを含めてはなりません。"
    },
    {
      "indent": 0,
      "text": "2.3.1. Registration Requirements",
      "section_title": true,
      "ja": "2.3.1. 登録要件"
    },
    {
      "indent": 3,
      "text": "Authorization servers MUST require clients to register their complete redirect URI (including the path component). Authorization servers MUST reject authorization requests that specify a redirect URI that doesn't exactly match one that was registered, with an exception for loopback redirects, where an exact match is required except for the port URI component, see Section 4.1.1 for details.",
      "ja": "承認サーバーは、クライアントが完全なリダイレクトURI（パスコンポーネントを含む）を登録するように要求する必要があります。承認サーバーは、ポートURIコンポーネントを除いて正確な一致が必要なループバックリダイレクトを除き、登録されたリダイレクトURIを正確に一致させないリダイレクトURIを指定する承認リクエストを拒否する必要があります。詳細については、セクション4.1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "The authorization server MAY allow the client to register multiple redirect URIs.",
      "ja": "Authorization Serverにより、クライアントは複数のリダイレクトURIを登録できる場合があります。"
    },
    {
      "indent": 3,
      "text": "Registration may happen out of band, such as a manual step of configuring the client information at the authorization server, or may happen at runtime, such as in the initial POST in Pushed Authorization Requests [RFC9126].",
      "ja": "登録は、承認サーバーでクライアント情報を構成する手動のステップなど、バンドから発生する可能性があります。また、プッシュされた承認要求[RFC9126]の最初の投稿など、実行時に発生する場合があります。"
    },
    {
      "indent": 3,
      "text": "For private-use URI scheme-based redirect URIs, authorization servers SHOULD enforce the requirement in Section 8.4.3 that clients use schemes that are reverse domain name based. At a minimum, any private-use URI scheme that doesn't contain a period character (.) SHOULD be rejected.",
      "ja": "プライベート使用URIスキームベースのリダイレクトURIの場合、承認サーバーは、クライアントが逆ドメイン名ベースのスキームを使用するセクション8.4.3で要件を実施する必要があります。少なくとも、ピリオド文字（。）を含まない個人用URIスキームは拒否される必要があります。"
    },
    {
      "indent": 3,
      "text": "In addition to the collision-resistant properties, this can help to prove ownership in the event of a dispute where two apps claim the same private-use URI scheme (where one app is acting maliciously). For example, if two apps claimed com.example.app, the owner of example.com could petition the app store operator to remove the counterfeit app. Such a petition is harder to prove if a generic URI scheme was used.",
      "ja": "衝突耐性のプロパティに加えて、これは、2つのアプリが同じプライベート使用URIスキーム（1つのアプリが悪意を持って行動している場合）を主張する紛争が発生した場合に所有権を証明するのに役立ちます。たとえば、2つのアプリがcom.example.appを請求した場合、Example.comの所有者は、偽造アプリを削除するようにApp Storeオペレーターに請願することができます。このような請願書は、一般的なURIスキームが使用された場合に証明するのが難しいです。"
    },
    {
      "indent": 3,
      "text": "Clients MUST NOT expose URLs that forward the user's browser to arbitrary URIs obtained from a query parameter (\"open redirector\"), as described in Section 7.13. Open redirectors can enable exfiltration of authorization codes and access tokens.",
      "ja": "クライアントは、セクション7.13で説明されているように、ユーザーのブラウザをクエリパラメーター（「オープンリダイレクター」）から取得した任意のURIに転送するURLを公開してはなりません。オープンリダイレクターは、承認コードの除去を可能にし、トークンにアクセスできます。"
    },
    {
      "indent": 3,
      "text": "The client MAY use the state request parameter to achieve per-request customization if needed rather than varying the redirect URI per request.",
      "ja": "クライアントは、リクエストごとにリダイレクトURIを変更するのではなく、必要に応じてレクエストごとのカスタマイズを実現するために、状態要求パラメーターを使用できます。"
    },
    {
      "indent": 3,
      "text": "Without requiring registration of redirect URIs, attackers can use the authorization endpoint as an open redirector as described in Section 7.13.",
      "ja": "リダイレクトURISの登録を要求することなく、攻撃者は、セクション7.13で説明されているように、承認エンドポイントをオープンリダイレクターとして使用できます。"
    },
    {
      "indent": 0,
      "text": "2.3.2. Multiple Redirect URIs",
      "section_title": true,
      "ja": "2.3.2. 複数のリダイレクトURI"
    },
    {
      "indent": 3,
      "text": "If multiple redirect URIs have been registered, the client MUST include a redirect URI with the authorization request using the redirect_uri request parameter.",
      "ja": "複数のリダイレクトURIが登録されている場合、クライアントはredirect_uriリクエストパラメーターを使用して承認要求にリダイレクトURIを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "2.3.3. Preventing CSRF Attacks",
      "section_title": true,
      "ja": "2.3.3. CSRF攻撃の防止"
    },
    {
      "indent": 3,
      "text": "Clients MUST prevent Cross-Site Request Forgery (CSRF) attacks. In this context, CSRF refers to requests to the redirection endpoint that do not originate at the authorization server, but a malicious third party (see Section 4.4.1.8. of [RFC6819] for details). Clients that have ensured that the authorization server supports the code_challenge parameter MAY rely on the CSRF protection provided by that mechanism. In OpenID Connect flows, validating the nonce parameter provides CSRF protection. Otherwise, one-time use CSRF tokens carried in the state parameter that are securely bound to the user agent MUST be used for CSRF protection (see Section 7.10).",
      "ja": "クライアントは、クロスサイトリクエストフォーファリー（CSRF）攻撃を防ぐ必要があります。これに関連して、CSRFとは、承認サーバーで発生するのではなく、悪意のある第三者（[RFC6819]のセクション4.4.1.8。を参照）でリダイレクトエンドポイントへのリクエストを指します。認証サーバーがCode_Challengeパラメーターをサポートすることを保証したクライアントは、そのメカニズムによって提供されるCSRF保護に依存する場合があります。OpenID Connectフローでは、NonCeパラメーターを検証するとCSRF保護が提供されます。それ以外の場合は、ユーザーエージェントにしっかりと結合した状態パラメーターで運ばれる1回限りの使用CSRFトークンをCSRF保護に使用する必要があります（セクション7.10を参照）。"
    },
    {
      "indent": 0,
      "text": "2.3.4. Preventing Mix-Up Attacks",
      "section_title": true,
      "ja": "2.3.4. ミックスアップ攻撃の防止"
    },
    {
      "indent": 3,
      "text": "In order to prevent mix-up attacks, clients MUST only process redirect responses of the authorization server they sent the respective request to and from the same user agent this authorization request was initiated with. Clients MUST store the authorization server they sent an authorization request to and bind this information to the user agent and check that the authorization response was received from the correct authorization server. Clients MUST ensure that the subsequent access token request, if applicable, is sent to the same authorization server. Clients SHOULD use distinct redirect URIs for each authorization server as a means to identify the authorization server a particular response came from.",
      "ja": "ミックスアップ攻撃を防ぐために、クライアントは、同じユーザーエージェントとの間でそれぞれのリクエストを送信した承認サーバーのリダイレクト応答のみを処理する必要があります。クライアントは、認証リクエストを送信した承認サーバーを保存し、この情報をユーザーエージェントにバインドし、正しい承認サーバーから承認応答が受信されたことを確認する必要があります。クライアントは、後続のアクセストークン要求が、該当する場合、同じ承認サーバーに送信されることを確認する必要があります。クライアントは、特定の応答が生まれた承認サーバーを特定する手段として、各認証サーバーに対して異なるリダイレクトURIを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.3.5. Invalid Endpoint",
      "section_title": true,
      "ja": "2.3.5. 無効なエンドポイント"
    },
    {
      "indent": 3,
      "text": "If an authorization request fails validation due to a missing, invalid, or mismatching redirect URI, the authorization server SHOULD inform the resource owner of the error and MUST NOT automatically redirect the user agent to the invalid redirect URI.",
      "ja": "承認要求が欠落、無効、または不一致のリダイレクトURIのために検証に失敗した場合、承認サーバーはリソース所有者にエラーを通知し、ユーザーエージェントを無効なリダイレクトURIに自動的にリダイレクトしてはなりません。"
    },
    {
      "indent": 0,
      "text": "2.3.6. Endpoint Content",
      "section_title": true,
      "ja": "2.3.6. エンドポイントコンテンツ"
    },
    {
      "indent": 3,
      "text": "The redirection request to the client's endpoint typically results in an HTML document response, processed by the user agent. If the HTML response is served directly as the result of the redirection request, any script included in the HTML document will execute with full access to the redirect URI and the artifacts (e.g. authorization code) it contains. Additionally, the request URL containing the authorization code may be sent in the HTTP Referer header to any embedded images, stylesheets and other elements loaded in the page.",
      "ja": "クライアントのエンドポイントへのリダイレクト要求は、通常、ユーザーエージェントによって処理されるHTMLドキュメント応答をもたらします。HTML応答がリダイレクトリクエストの結果として直接提供される場合、HTMLドキュメントに含まれるスクリプトは、リダイレクトURIおよびアーティファクト（たとえば認証コード）に完全にアクセスできるように実行されます。さらに、承認コードを含むリクエストURLは、ページにロードされた埋め込み画像、スタイルシート、その他の要素にHTTP参照ヘッダーに送信される場合があります。"
    },
    {
      "indent": 3,
      "text": "The client SHOULD NOT include any third-party scripts (e.g., third-party analytics, social plug-ins, ad networks) in the redirect URI endpoint response. Instead, it SHOULD extract the artifacts from the URI and redirect the user agent again to another endpoint without exposing the artifacts (in the URI or elsewhere). If third-party scripts are included, the client MUST ensure that its own scripts (used to extract and remove the credentials from the URI) will execute first.",
      "ja": "クライアントは、リダイレクトURIエンドポイント応答にサードパーティのスクリプト（サードパーティ分析、ソーシャルプラグイン、広告ネットワークなど）を含めるべきではありません。代わりに、URIからアーティファクトを抽出し、ユーザーエージェントを別のエンドポイントに再びリダイレクトしません（URIまたは他の場所）。サードパーティのスクリプトが含まれている場合、クライアントは、独自のスクリプト（URIから資格情報を抽出して削除するために使用される）を最初に実行する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.4. Client Authentication",
      "section_title": true,
      "ja": "2.4. クライアント認証"
    },
    {
      "indent": 3,
      "text": "The authorization server MUST only rely on client authentication if the process of issuance/registration and distribution of the underlying credentials ensures their confidentiality.",
      "ja": "承認サーバーは、発行/登録のプロセスと基礎となる資格情報の配布のプロセスが機密性を保証する場合にのみ、クライアント認証に依存する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client is confidential, the authorization server MAY accept any form of client authentication meeting its security requirements (e.g., password, public/private key pair).",
      "ja": "クライアントが機密である場合、承認サーバーは、セキュリティ要件（パスワード、パブリック/秘密キーペアなど）を満たす任意の形式のクライアント認証を受け入れることができます。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED to use asymmetric (public-key based) methods for client authentication such as mTLS [RFC8705] or using signed JWTs (\"Private Key JWT\") in accordance with [RFC7521] and [RFC7523] (in [OpenID] defined as the client authentication method private_key_jwt). When such methods for client authentication are used, authorization servers do not need to store sensitive symmetric keys, making these methods more robust against a number of attacks.",
      "ja": "MTLS [RFC8705]などのクライアント認証に非対称（パブリックキーベースの）方法を使用するか、[RFC7521]および[RFC7523]に従って署名されたJWTS（ \"Private Key JWT\"）を使用することをお勧めします。クライアント認証のためのこのような方法を使用する場合、承認サーバーは機密性の対称キーを保存する必要はなく、これらの方法を多くの攻撃に対してより堅牢にします。"
    },
    {
      "indent": 3,
      "text": "When client authentication is not possible, the authorization server SHOULD employ other means to validate the client's identity -- for example, by requiring the registration of the client redirect URI or enlisting the resource owner to confirm identity. A valid redirect URI is not sufficient to verify the client's identity when asking for resource owner authorization but can be used to prevent delivering credentials to a counterfeit client after obtaining resource owner authorization.",
      "ja": "クライアント認証が不可能な場合、承認サーバーは、クライアントの身元を検証するために他の手段を採用する必要があります。たとえば、クライアントのリダイレクトURIの登録を要求するか、リソース所有者にIDを確認することを要求する必要があります。有効なリダイレクトURIは、リソース所有者の承認を求める際にクライアントの身元を確認するのに十分ではありませんが、リソース所有者の承認を取得した後、偽造クライアントに資格情報を提供するのを防ぐために使用できます。"
    },
    {
      "indent": 3,
      "text": "The client MUST NOT use more than one authentication method in each request to prevent a conflict of which authentication mechanism is authoritative for the request.",
      "ja": "クライアントは、各リクエストで複数の認証方法を使用して、認証メカニズムがリクエストに対して権威ある競合を防ぐ必要があります。"
    },
    {
      "indent": 3,
      "text": "The authorization server MUST consider the security implications of interacting with unauthenticated clients and take measures to limit the potential exposure of tokens issued to such clients, (e.g., limiting the lifetime of refresh tokens).",
      "ja": "認証サーバーは、認定されていないクライアントと対話することのセキュリティへの影響を考慮し、そのようなクライアントに発行されたトークンの潜在的な露出を制限するための措置を講じる必要があります（たとえば、リフレッシュトークンの寿命を制限します）。"
    },
    {
      "indent": 3,
      "text": "The privileges an authorization server associates with a certain client identity MUST depend on the assessment of the overall process for client identification and client credential lifecycle management. See Section 7.2 for additional details.",
      "ja": "許可サーバーに特定のクライアントのIDと関連する権限サーバーは、クライアントの識別とクライアントの資格情報のライフサイクル管理のための全体的なプロセスの評価に依存する必要があります。詳細については、セクション7.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.4.1. Client Secret",
      "section_title": true,
      "ja": "2.4.1. クライアントの秘密"
    },
    {
      "indent": 3,
      "text": "Clients in possession of a client secret, sometimes known as a client password, MAY use the HTTP Basic authentication scheme as defined in Section 11 of [RFC9110] to authenticate with the authorization server. The client identifier is encoded using the application/x-www-form-urlencoded encoding algorithm per Appendix B, and the encoded value is used as the username; the client secret is encoded using the same algorithm and used as the password. The authorization server MUST support the HTTP Basic authentication scheme for authenticating clients that were issued a client secret.",
      "ja": "クライアントの秘密を所有しているクライアントは、クライアントのパスワードとして知られる場合がありますが、[RFC9110]のセクション11で定義されているHTTP基本認証スキームを使用して、認証サーバーで認証できます。クライアント識別子は、付録Bごとにアプリケーション/x-www-form-urlencodedエンコードアルゴリズムを使用してエンコードされ、エンコードされた値はユーザー名として使用されます。クライアントの秘密は、同じアルゴリズムを使用してエンコードされ、パスワードとして使用されます。Authorization Serverは、クライアントの秘密を発行されたクライアントを認証するためのHTTP基本認証スキームをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "For example (with extra line breaks for display purposes only):",
      "ja": "たとえば、ディスプレイのみのための追加のラインブレークがあります）：："
    },
    {
      "indent": 3,
      "text": "Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In addition to that, the authorization server MAY support including the client credentials in the request content using the following parameters:",
      "ja": "それに加えて、承認サーバーは、次のパラメーターを使用して、リクエストコンテンツのクライアント資格情報を含むサポートする場合があります。"
    },
    {
      "indent": 3,
      "text": "\"client_id\": REQUIRED. The client identifier issued to the client during the registration process described by Section 2.2.",
      "ja": "「client_id」：必須。セクション2.2で説明されている登録プロセス中にクライアントに発行されたクライアント識別子。"
    },
    {
      "indent": 3,
      "text": "\"client_secret\": REQUIRED. The client secret.",
      "ja": "「client_secret」：必須。クライアントの秘密。"
    },
    {
      "indent": 3,
      "text": "Including the client credentials in the request content using the two parameters is NOT RECOMMENDED and SHOULD be limited to clients unable to directly utilize the HTTP Basic authentication scheme (or other password-based HTTP authentication schemes). The parameters can only be transmitted in the request content and MUST NOT be included in the request URI.",
      "ja": "2つのパラメーターを使用してリクエストコンテンツにクライアント資格情報を含めることは推奨されず、HTTP Basic認証スキーム（またはその他のパスワードベースのHTTP認証スキーム）を直接使用できないクライアントに限定する必要があります。パラメーターはリクエストコンテンツにのみ送信でき、リクエストURIに含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "For example, a request to refresh an access token (Section 4.3) using the content parameters (with extra line breaks for display purposes only):",
      "ja": "たとえば、コンテンツパラメーターを使用してアクセストークン（セクション4.3）を更新するリクエスト（ディスプレイ目的でのみのラインブレークを使用）："
    },
    {
      "indent": 3,
      "text": "POST /token HTTP/1.1 Host: server.example.com Content-Type: application/x-www-form-urlencoded",
      "ja": "投稿/トークンhttp/1.1ホスト：server.example.comコンテンツタイプ：アプリケーション/x-www-form-urlencoded"
    },
    {
      "indent": 3,
      "text": "grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA &client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw Since this client authentication method involves a password, the authorization server MUST protect any endpoint utilizing it against brute force attacks.",
      "ja": "grant_type = refresh_token＆refresh_token = tgzv3jokf0xg5qx2tlkwia＆client_id = s6bhdrkqt3＆client_secret = 7fjfp0zbr1ktdrbnfvdmiw"
    },
    {
      "indent": 0,
      "text": "2.4.2. Other Authentication Methods",
      "section_title": true,
      "ja": "2.4.2. その他の認証方法"
    },
    {
      "indent": 3,
      "text": "The authorization server MAY support any suitable authentication scheme matching its security requirements. When using other authentication methods, the authorization server MUST define a mapping between the client identifier (registration record) and authentication scheme.",
      "ja": "Authorization Serverは、セキュリティ要件に一致する適切な認証スキームをサポートできます。他の認証方法を使用する場合、承認サーバーは、クライアント識別子（登録記録）と認証スキームの間のマッピングを定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "Some additional authentication methods such as mTLS [RFC8705] and Private Key JWT [RFC7523] are defined in the \"OAuth Token Endpoint Authentication Methods (https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml#token-endpoint-auth-method)\" registry, and may be useful as generic client authentication methods beyond the specific use of protecting the token endpoint.",
      "ja": "MTLS [RFC8705]や秘密鍵JWT [RFC7523]などのいくつかの追加の認証方法は、「OAuthトークンエンドポイント認証方法（https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhl# utoken-pirint-ascistry-astoken-pointpoint-pointoping-paramod）で定義されています。トークンエンドポイントを保護する特定の使用を超えた方法。"
    },
    {
      "indent": 0,
      "text": "2.5. Unregistered Clients",
      "section_title": true,
      "ja": "2.5. 未登録のクライアント"
    },
    {
      "indent": 3,
      "text": "This specification does not require that clients be registered with the authorization server. However, the use of unregistered clients is beyond the scope of this specification and requires additional security analysis and review of its interoperability impact.",
      "ja": "この仕様では、クライアントを承認サーバーに登録する必要はありません。ただし、未登録のクライアントの使用は、この仕様の範囲を超えており、追加のセキュリティ分析と相互運用性の影響のレビューが必要です。"
    },
    {
      "indent": 0,
      "text": "3. Protocol Endpoints",
      "section_title": true,
      "ja": "3. プロトコルエンドポイント"
    },
    {
      "indent": 3,
      "text": "The authorization process utilizes two authorization server endpoints (HTTP resources):",
      "ja": "承認プロセスは、2つの承認サーバーエンドポイント（HTTPリソース）を利用します。"
    },
    {
      "indent": 3,
      "text": "* Authorization endpoint - used by the client to obtain authorization from the resource owner via user agent redirection.",
      "ja": "* 認証エンドポイント - ユーザーエージェントリダイレクトを介してリソース所有者から認可を取得するためにクライアントが使用します。"
    },
    {
      "indent": 3,
      "text": "* Token endpoint - used by the client to exchange an authorization grant for an access token, typically with client authentication.",
      "ja": "* トークンのエンドポイント - クライアントがアクセストークンとの許可助成金を交換するために使用します。通常、クライアント認証を使用します。"
    },
    {
      "indent": 3,
      "text": "As well as one client endpoint:",
      "ja": "1つのクライアントエンドポイントと同様に："
    },
    {
      "indent": 3,
      "text": "* Redirection endpoint - used by the authorization server to return responses containing authorization credentials to the client via the resource owner user agent.",
      "ja": "* リダイレクトエンドポイント - 認証サーバーがリソース所有者のユーザーエージェントを介してクライアントに認証資格情報を含む応答を返すために使用します。"
    },
    {
      "indent": 3,
      "text": "Not every authorization grant type utilizes both endpoints. Extension grant types MAY define additional endpoints as needed.",
      "ja": "すべての承認助成金タイプが両方のエンドポイントを利用しているわけではありません。拡張助成金タイプは、必要に応じて追加のエンドポイントを定義する場合があります。"
    },
    {
      "indent": 0,
      "text": "3.1. Authorization Endpoint",
      "section_title": true,
      "ja": "3.1. 承認エンドポイント"
    },
    {
      "indent": 3,
      "text": "The authorization endpoint is used to interact with the resource owner and obtain an authorization grant. The authorization server MUST first authenticate the resource owner. The way in which the authorization server authenticates the resource owner (e.g., username and password login, passkey, federated login, or by using an established session) is beyond the scope of this specification.",
      "ja": "承認エンドポイントは、リソース所有者と対話し、承認助成金を取得するために使用されます。Authorization Serverは、まずリソース所有者を認証する必要があります。Authorization Serverがリソース所有者を認証する方法（例：ユーザー名とパスワードログイン、PassKey、Federatedログイン、または確立されたセッションを使用して）は、この仕様の範囲を超えています。"
    },
    {
      "indent": 3,
      "text": "The means through which the client obtains the URL of the authorization endpoint are beyond the scope of this specification, but the URL is typically provided in the service documentation, or in the authorization server's metadata document ([RFC8414]).",
      "ja": "クライアントが承認エンドポイントのURLを取得する手段は、この仕様の範囲を超えていますが、URLは通常、サービスドキュメント、または承認サーバーのメタデータドキュメント（[RFC8414]）で提供されます。"
    },
    {
      "indent": 3,
      "text": "The authorization endpoint URL MUST NOT include a fragment component, and MAY include an \"application/x-www-form-urlencoded\" formatted query component [WHATWG.URL], which MUST be retained when adding additional query parameters.",
      "ja": "Authorization Endpoint URLにはフラグメントコンポーネントを含めてはなりません。また、「アプリケーション/x-www-form-urlencoded」フォーマットクエリコンポーネント[whatwg.url]を含めることができます。"
    },
    {
      "indent": 3,
      "text": "The authorization server MUST support the use of the HTTP GET method Section 9.3.1 of [RFC9110] for the authorization endpoint and MAY support the POST method (Section 9.3.3 of [RFC9110]) as well.",
      "ja": "承認サーバーは、認証エンドポイントのために[RFC9110]のHTTP GETメソッドセクション9.3.1の使用をサポートする必要があり、POSTメソッド（[RFC9110]のセクション9.3.3）もサポートすることができます。"
    },
    {
      "indent": 3,
      "text": "The authorization server MUST ignore unrecognized request parameters sent to the authorization endpoint.",
      "ja": "承認サーバーは、認定エンドポイントに送信された認識されていない要求パラメーターを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Request and response parameters defined by this specification MUST NOT be included more than once. Parameters sent without a value MUST be treated as if they were omitted from the request.",
      "ja": "この仕様で定義されたリクエストと応答のパラメーターは、複数回含めてはなりません。値なしで送信されたパラメーターは、リクエストから省略されたかのように扱わなければなりません。"
    },
    {
      "indent": 3,
      "text": "An authorization server that redirects a request potentially containing user credentials MUST avoid forwarding these user credentials accidentally (see Section 7.5.2 for details).",
      "ja": "ユーザーの資格情報を含む可能性のある要求をリダイレクトする承認サーバーは、これらのユーザー資格情報を誤って転送することを避ける必要があります（詳細については、セクション7.5.2を参照）。"
    },
    {
      "indent": 3,
      "text": "Cross-Origin Resource Sharing (also known as CORS) [WHATWG.CORS] MUST NOT be supported at the Authorization Endpoint as the client does not access this endpoint directly, instead the client redirects the user agent to it.",
      "ja": "クロスオリジンリソース共有（CORSとも呼ばれる）[Whatwg.Cors]は、クライアントがこのエンドポイントに直接アクセスしないため、認証エンドポイントでサポートされてはなりません。代わりに、クライアントはユーザーエージェントをリダイレクトします。"
    },
    {
      "indent": 0,
      "text": "3.2. Token Endpoint",
      "section_title": true,
      "ja": "3.2. トークンエンドポイント"
    },
    {
      "indent": 3,
      "text": "The token endpoint is used by the client to obtain an access token using a grant such as those described in Section 4 and Section 4.3.",
      "ja": "トークンエンドポイントは、セクション4およびセクション4.3で説明されているような助成金を使用してアクセストークンを取得するためにクライアントによって使用されます。"
    },
    {
      "indent": 3,
      "text": "The means through which the client obtains the URL of the token endpoint are beyond the scope of this specification, but the URL is typically provided in the service documentation and configured during development of the client, or provided in the authorization server's metadata document ([RFC8414]) and fetched programmatically at runtime.",
      "ja": "クライアントがトークンエンドポイントのURLを取得する手段はこの仕様の範囲を超えていますが、URLは通常、サービスドキュメントで提供され、クライアントの開発中に構成されているか、Authorization Serverのメタデータドキュメント（[RFC8414]）で提供され、実行時にプログラム的に獲得されます。"
    },
    {
      "indent": 3,
      "text": "The token endpoint URL MUST NOT include a fragment component, and MAY include an application/x-www-form-urlencoded formatted query component ([WHATWG.URL]).",
      "ja": "トークンのエンドポイントURLにはフラグメントコンポーネントを含めてはなりません。また、アプリケーション/x-www-form-urlencodedフォーマットクエリコンポーネント（[whatwg.url]）を含めることができます。"
    },
    {
      "indent": 3,
      "text": "The client MUST use the HTTP POST method when making requests to the token endpoint.",
      "ja": "クライアントは、トークンエンドポイントにリクエストを行うときにHTTP POSTメソッドを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The authorization server MUST ignore unrecognized request parameters sent to the token endpoint.",
      "ja": "Authorization Serverは、トークンエンドポイントに送信された認識されていない要求パラメーターを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameters sent without a value MUST be treated as if they were omitted from the request. Request and response parameters defined by this specification MUST NOT be included more than once.",
      "ja": "値なしで送信されたパラメーターは、リクエストから省略されたかのように扱わなければなりません。この仕様で定義されたリクエストと応答のパラメーターは、複数回含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "Authorization servers that wish to support browser-based applications (applications running exclusively in client-side JavaScript without access to a supporting backend server) will need to ensure the token endpoint supports the necessary CORS ([WHATWG.CORS]) headers to allow the responses to be visible to the application. If the authorization server provides additional endpoints to the application, such as metadata URLs, dynamic client registration, revocation, introspection, discovery or user info endpoints, these endpoints may also be accessed by the browser-based application, and will also need to have the CORS headers defined to allow access. See [I-D.ietf-oauth-browser-based-apps] for further details.",
      "ja": "ブラウザベースのアプリケーションをサポートする承認サーバー（サポートするバックエンドサーバーにアクセスすることなくクライアント側JavaScriptでのみ実行されるアプリケーション）は、トークンエンドポイントが必要なCORS（[WhatWg.Cors]）ヘッダーをサポートして、応答をアプリケーションに見えるようにする必要があります。認証サーバーが、メタデータURL、動的クライアント登録、取り消し、内省、発見、またはユーザー情報エンドポイントなど、アプリケーションに追加のエンドポイントを提供する場合、これらのエンドポイントにはブラウザベースのアプリケーションによってもアクセスでき、アクセスを許可するためにCORSヘッダーを定義する必要があります。詳細については、[i-d.ietf-oauth-browserベースのアプリ]を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Client Authentication",
      "section_title": true,
      "ja": "3.2.1. クライアント認証"
    },
    {
      "indent": 3,
      "text": "Confidential clients MUST authenticate with the authorization server as described in Section 2.4 when making requests to the token endpoint.",
      "ja": "Confidentialクライアントは、トークンエンドポイントにリクエストを行うときに、セクション2.4で説明されているように、認証サーバーで認証する必要があります。"
    },
    {
      "indent": 3,
      "text": "Client authentication is used for:",
      "ja": "クライアント認証は以下に使用されます。"
    },
    {
      "indent": 3,
      "text": "* Enforcing the binding of refresh tokens and authorization codes to the client they were issued to. Client authentication adds an additional layer of security when an authorization code is transmitted to the redirection endpoint over an insecure channel.",
      "ja": "* リフレッシュトークンと認可コードのバインディングを、発行されたクライアントに実施します。クライアント認証は、安全でないチャネル上で承認コードがリダイレクトエンドポイントに送信される場合、セキュリティの追加レイヤーを追加します。"
    },
    {
      "indent": 3,
      "text": "* Recovering from a compromised client by disabling the client or changing its credentials, thus preventing an attacker from abusing stolen refresh tokens. Changing a single set of client credentials is significantly faster than revoking an entire set of refresh tokens.",
      "ja": "* クライアントを無効にしたり、資格情報を変更したりすることで、妥協したクライアントから回復し、攻撃者が盗まれた更新トークンを乱用することを妨げます。クライアント資格情報の単一セットを変更すると、更新トークンのセット全体を取り消すよりも大幅に高速です。"
    },
    {
      "indent": 3,
      "text": "* Implementing authentication management best practices, which require periodic credential rotation. Rotation of an entire set of refresh tokens can be challenging, while rotation of a single set of client credentials is significantly easier.",
      "ja": "* 定期的な資格的回転が必要な認証管理のベストプラクティスを実装します。リフレッシュトークンのセット全体の回転は困難な場合がありますが、クライアント資格情報の単一セットの回転は非常に簡単です。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Token Request",
      "section_title": true,
      "ja": "3.2.2. トークンリクエスト"
    },
    {
      "indent": 3,
      "text": "The client makes a request to the token endpoint by sending the following parameters using the application/x-www-form-urlencoded format per Appendix B with a character encoding of UTF-8 in the HTTP request content:",
      "ja": "クライアントは、付録Bごとにアプリケーション/X-WWW-Form-Urlencodedフォーマットを使用して次のパラメーターを送信して、HTTP要求コンテンツでUTF-8をエンコードすることにより、次のパラメーターを送信することにより、トークンエンドポイントにリクエストを行います。"
    },
    {
      "indent": 3,
      "text": "\"client_id\": REQUIRED, if the client is not authenticating with the authorization server as described in Section 3.2.1.",
      "ja": "「client_id」：セクション3.2.1で説明されているように、クライアントが承認サーバーを認証していない場合。"
    },
    {
      "indent": 3,
      "text": "\"grant_type\": REQUIRED. Identifier of the grant type the client uses with the particular token request. This specification defines the values authorization_code, refresh_token, and client_credentials. The grant type determines the further parameters required or supported by the token request. The details of those grant types are defined below.",
      "ja": "「grant_type」：必須。クライアントが特定のトークンリクエストで使用する助成金タイプの識別子。この仕様は、Value Authorization_Code、refresh_token、およびclient_credentialsを定義します。助成金の種類は、トークン要求に必要なまたはサポートされるさらなるパラメーターを決定します。これらの助成金タイプの詳細は、以下に定義されています。"
    },
    {
      "indent": 3,
      "text": "Confidential clients MUST authenticate with the authorization server as described in Section 3.2.1.",
      "ja": "Confidentialクライアントは、セクション3.2.1で説明されているように、認証サーバーで認証する必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, the client makes the following HTTP request (with extra line breaks for display purposes only):",
      "ja": "たとえば、クライアントは次のHTTPリクエストを行います（表示目的でのみ追加のラインブレークがあります）："
    },
    {
      "indent": 1,
      "text": "POST /token HTTP/1.1 Host: server.example.com Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW Content-Type: application/x-www-form-urlencoded",
      "ja": "post/token http/1.1ホスト：server.example.com認証：基本czzcagrsa3f0mzpnwdfmqmf0m2jw content-type：application/x-www-form-urlencoded"
    },
    {
      "indent": 1,
      "text": "grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA\n&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb\n&code_verifier=3641a2d12d66101249cdf7a79c000c1f8c05d2aafcf14bf146497bed",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The authorization server MUST:",
      "ja": "承認サーバーは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* require client authentication for confidential clients (or clients with other authentication requirements),",
      "ja": "* 機密クライアント（または他の認証要件を持つクライアント）にクライアント認証が必要です。"
    },
    {
      "indent": 3,
      "text": "* authenticate the client if client authentication is included",
      "ja": "* クライアント認証が含まれている場合は、クライアントに認証します"
    },
    {
      "indent": 3,
      "text": "Further grant type specific processing rules apply and are specified with the respective grant type.",
      "ja": "さらに助成金タイプの特定の処理ルールが適用され、それぞれの助成金タイプで指定されています。"
    },
    {
      "indent": 0,
      "text": "3.2.2.1. Access Token Scope",
      "section_title": true,
      "ja": "3.2.2.1. トークンスコープにアクセスします"
    },
    {
      "indent": 3,
      "text": "The authorization and token endpoints allow the client to specify the scope of the access request using the scope request parameter. In turn, the authorization server uses the scope response parameter to inform the client of the scope of the access token issued.",
      "ja": "承認とトークンのエンドポイントにより、クライアントはスコープリクエストパラメーターを使用してアクセス要求のスコープを指定できます。次に、承認サーバーは、スコープ応答パラメーターを使用して、発行されたアクセストークンの範囲をクライアントに通知します。"
    },
    {
      "indent": 3,
      "text": "The value of the scope parameter is expressed as a list of space-delimited, case-sensitive strings. The strings are defined by the authorization server. If the value contains multiple space-delimited strings, their order does not matter, and each string adds an additional access range to the requested scope.",
      "ja": "スコープパラメーターの値は、スペースが削除された、ケースに敏感な文字列のリストとして表されます。文字列は、承認サーバーによって定義されます。値に複数の空間削除された文字列が含まれている場合、順序は重要ではなく、各文字列は要求されたスコープに追加のアクセス範囲を追加します。"
    },
    {
      "indent": 7,
      "text": "scope       = scope-token *( SP scope-token )\nscope-token = 1*( %x21 / %x23-5B / %x5D-7E )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The authorization server MAY fully or partially ignore the scope requested by the client, based on the authorization server policy or the resource owner's instructions. If the issued access token scope is different from the one requested by the client, the authorization server MUST include the scope response parameter in the token response (Section 3.2.3) to inform the client of the actual scope granted.",
      "ja": "Authorization Serverは、承認サーバーポリシーまたはリソース所有者の指示に基づいて、クライアントが要求するスコープを完全または部分的に無視する場合があります。発行されたアクセストークンスコープがクライアントが要求したスコープと異なる場合、認証サーバーは、付与された実際のスコープをクライアントに通知するために、トークン応答（セクション3.2.3）にスコープ応答パラメーターを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client omits the scope parameter when requesting authorization, the authorization server MUST either process the request using a pre-defined default value or fail the request indicating an invalid scope. The authorization server SHOULD document its scope requirements and default value (if defined).",
      "ja": "クライアントが承認を要求するときにスコープパラメーターを省略した場合、承認サーバーは、事前に定義されたデフォルト値を使用して要求を処理するか、無効なスコープを示す要求に失敗する必要があります。承認サーバーは、スコープ要件とデフォルト値を文書化する必要があります（定義されている場合）。"
    },
    {
      "indent": 0,
      "text": "3.2.3. Token Response",
      "section_title": true,
      "ja": "3.2.3. トークン応答"
    },
    {
      "indent": 3,
      "text": "If the access token request is valid and authorized, the authorization server issues an access token and optional refresh token.",
      "ja": "アクセストークン要求が有効かつ承認されている場合、承認サーバーはアクセストークンとオプションの更新トークンを発行します。"
    },
    {
      "indent": 3,
      "text": "If the request client authentication failed or is invalid, the authorization server returns an error response as described in Section 3.2.3.1.",
      "ja": "リクエストクライアント認証が失敗したか無効である場合、承認サーバーはセクション3.2.3.1で説明されているようにエラー応答を返します。"
    },
    {
      "indent": 3,
      "text": "The authorization server issues an access token and optional refresh token by creating an HTTP response content using the application/json media type as defined by [RFC8259] with the following parameters and an HTTP 200 (OK) status code:",
      "ja": "Authorization Serverは、次のパラメーターとHTTP 200（OK）ステータスコードを使用して[RFC8259]で定義されているアプリケーション/JSONメディアタイプを使用してHTTP応答コンテンツを作成することにより、アクセストークンとオプションの更新トークンを発行します。"
    },
    {
      "indent": 3,
      "text": "\"access_token\": REQUIRED. The access token issued by the authorization server.",
      "ja": "「Access_Token」：必須。Authorization Serverによって発行されたアクセストークン。"
    },
    {
      "indent": 3,
      "text": "\"token_type\": REQUIRED. The type of the access token issued as described in Section 5.1. Value is case insensitive.",
      "ja": "「token_type」：必須。セクション5.1で説明されているように発行されたアクセストークンのタイプ。価値は症例が鈍感です。"
    },
    {
      "indent": 3,
      "text": "\"expires_in\": RECOMMENDED. The lifetime in seconds of the access token. For example, the value 3600 denotes that the access token will expire in one hour from the time the response was generated. If omitted, the authorization server SHOULD provide the expiration time via other means or document the default value.",
      "ja": "「expires_in」：推奨されます。アクセストークンの数秒での寿命。たとえば、値3600は、アクセストークンが応答が生成されてから1時間で期限切れになることを示します。省略した場合、承認サーバーは他の手段を介して有効期限を提供するか、デフォルト値を文書化する必要があります。"
    },
    {
      "indent": 3,
      "text": "\"scope\": RECOMMENDED, if identical to the scope requested by the client; otherwise, REQUIRED. The scope of the access token as described by Section 3.2.2.1.",
      "ja": "「スコープ」：クライアントが要求したスコープと同一の場合は推奨されます。それ以外の場合は、必要です。セクション3.2.2.1で説明されているように、アクセストークンの範囲。"
    },
    {
      "indent": 3,
      "text": "\"refresh_token\": OPTIONAL. The refresh token, which can be used to obtain new access tokens based on the grant passed in the corresponding token request.",
      "ja": "「REFRESH_TOKEN」：オプション。リフレッシュトークンは、対応するトークンリクエストで渡された助成金に基づいて新しいアクセストークンを取得するために使用できます。"
    },
    {
      "indent": 3,
      "text": "Authorization servers SHOULD determine, based on a risk assessment and their own policies, whether to issue refresh tokens to a certain client. If the authorization server decides not to issue refresh tokens, the client MAY obtain new access tokens by starting the OAuth flow over, for example initiating a new authorization code request. In such a case, the authorization server may utilize cookies and persistent grants to optimize the user experience.",
      "ja": "認証サーバーは、リスク評価と独自のポリシーに基づいて、特定のクライアントにトークンを更新するかどうかを決定する必要があります。承認サーバーが更新トークンを発行しないことを決定した場合、クライアントは、新しい承認コード要求を開始するなど、OAuthフローを起動することで新しいアクセストークンを取得できます。そのような場合、認証サーバーは、ユーザーエクスペリエンスを最適化するためにCookieと永続的な助成金を利用する場合があります。"
    },
    {
      "indent": 3,
      "text": "If refresh tokens are issued, those refresh tokens MUST be bound to the scope and resource servers as consented by the resource owner. This is to prevent privilege escalation by the legitimate client and reduce the impact of refresh token leakage.",
      "ja": "更新トークンが発行された場合、これらの更新トークンは、リソース所有者が同意したスコープとリソースサーバーにバインドする必要があります。これは、正当なクライアントによる特権のエスカレーションを防ぎ、リフレッシュトークンの漏れの影響を減らすためです。"
    },
    {
      "indent": 3,
      "text": "The parameters are serialized into a JavaScript Object Notation (JSON) structure by adding each parameter at the highest structure level. Parameter names and string values are included as JSON strings. Numerical values are included as JSON numbers. The order of parameters does not matter and can vary.",
      "ja": "パラメーターは、各パラメーターを最高の構造レベルで追加することにより、JavaScriptオブジェクト表記（JSON）構造にシリアル化されます。パラメーター名と文字列値はJSON文字列として含まれています。数値はJSON番号として含まれています。パラメーターの順序は重要ではなく、変化する可能性があります。"
    },
    {
      "indent": 3,
      "text": "The authorization server MUST include the HTTP Cache-Control response header field (see Section 5.2 of [RFC9111]) with a value of no-store in any response containing tokens, credentials, or other sensitive information.",
      "ja": "Authorization Serverには、トークン、資格情報、またはその他の機密情報を含む任意の応答に、NOストアの値を持つHTTPキャッシュコントロール応答ヘッダーフィールド（[RFC9111]のセクション5.2を参照）を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: no-store",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "{\n  \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":3600,\n  \"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\",\n  \"example_parameter\":\"example_value\"\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The client MUST ignore unrecognized value names in the response. The sizes of tokens and other values received from the authorization server are left undefined. The client should avoid making assumptions about value sizes. The authorization server SHOULD document the size of any value it issues.",
      "ja": "クライアントは、応答の認識されていない値名を無視する必要があります。認証サーバーから受信されたトークンとその他の値のサイズは未定義のままです。クライアントは、値サイズについて仮定を避ける必要があります。Authorization Serverは、発行する価値のサイズを文書化する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2.3.1. Error Response",
      "section_title": true,
      "ja": "3.2.3.1. エラー応答"
    },
    {
      "indent": 3,
      "text": "The authorization server responds with an HTTP 400 (Bad Request) status code (unless specified otherwise) and includes the following parameters with the response:",
      "ja": "Authorization Serverは、HTTP 400（悪い要求）ステータスコード（特に指定がない場合）で応答し、応答に次のパラメーターを含めます。"
    },
    {
      "indent": 3,
      "text": "\"error\": REQUIRED. A single ASCII [USASCII] error code from the following:",
      "ja": "「エラー」：必須。以下からの単一のASCII [USASCII]エラーコード："
    },
    {
      "indent": 6,
      "text": "\"invalid_request\": The request is missing a required parameter, includes an unsupported parameter value (other than grant type), repeats a parameter, includes multiple credentials, utilizes more than one mechanism for authenticating the client, contains a code_verifier although no code_challenge was sent in the authorization request, or is otherwise malformed.",
      "ja": "「Invalid_Request」：要求には、必要なパラメーターが欠落しており、サポートされていないパラメーター値（助成金タイプ以外）が含まれ、パラメーターを繰り返し、複数の資格情報を含み、クライアントを認証するための複数のメカニズムを使用します。"
    },
    {
      "indent": 6,
      "text": "\"invalid_client\": Client authentication failed (e.g., unknown client, no client authentication included, or unsupported authentication method). The authorization server MAY return an HTTP 401 (Unauthorized) status code to indicate which HTTP authentication schemes are supported. If the client attempted to authenticate via the Authorization request header field, the authorization server MUST respond with an HTTP 401 (Unauthorized) status code and include the WWW-Authenticate response header field matching the authentication scheme used by the client.",
      "ja": "「Invalid_Client」：クライアント認証に失敗しました（例：不明なクライアント、クライアント認証が含まれていない、またはサポートされていない認証方法）。Authorization Serverは、HTTP 401（不正）ステータスコードを返して、どのHTTP認証スキームがサポートされているかを示します。クライアントが承認要求ヘッダーフィールドを介して認証を試みた場合、承認サーバーはHTTP 401（不正）ステータスコードで応答し、クライアントが使用する認証スキームに一致するwww-authenticate応答ヘッダーフィールドを含める必要があります。"
    },
    {
      "indent": 6,
      "text": "\"invalid_grant\": The provided authorization grant (e.g.,",
      "ja": "「Invalid_Grant」：提供された承認助成金（例えば、"
    },
    {
      "indent": 9,
      "text": "authorization code, resource owner credentials) or refresh token is invalid, expired, revoked, does not match the redirect URI used in the authorization request, or was issued to another client.",
      "ja": "承認コード、リソース所有者の資格情報）または更新トークンは無効であり、期限切れ、撤回された、または承認要求で使用されたリダイレクトURIと一致しないか、別のクライアントに発行されました。"
    },
    {
      "indent": 6,
      "text": "\"unauthorized_client\": The authenticated client is not authorized to use this authorization grant type.",
      "ja": "「Unauthorized_client」：認証されたクライアントは、この承認助成金タイプを使用することを許可されていません。"
    },
    {
      "indent": 6,
      "text": "\"unsupported_grant_type\": The authorization grant type is not supported by the authorization server.",
      "ja": "「unsupported_grant_type」：承認助成金タイプは、承認サーバーによってサポートされていません。"
    },
    {
      "indent": 6,
      "text": "\"invalid_scope\": The requested scope is invalid, unknown, malformed, or exceeds the scope granted by the resource owner.",
      "ja": "「Invalid_Scope」：要求されたスコープは無効で、不明、不正さ、またはリソース所有者によって付与されたスコープを超えています。"
    },
    {
      "indent": 6,
      "text": "Values for the error parameter MUST NOT include characters outside the set %x20-21 / %x23-5B / %x5D-7E.",
      "ja": "エラーパラメーターの値は、セット％x20-21 /％x23-5b /％x5d-7eの外側の文字を含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "\"error_description\": OPTIONAL. Human-readable ASCII [USASCII] text providing additional information, used to assist the client developer in understanding the error that occurred. Values for the error_description parameter MUST NOT include characters outside the set %x20-21 / %x23-5B / %x5D-7E.",
      "ja": "「error_description」：オプション。クライアント開発者が発生したエラーを理解するのを支援するために使用される追加情報を提供する人間読み取り可能なASCII [USASCII]テキスト。error_descriptionパラメーターの値は、セット％x20-21 /％x23-5b /％x5d-7eの外側の文字を含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "\"error_uri\": OPTIONAL. A URI identifying a human-readable web page with information about the error, used to provide the client developer with additional information about the error. Values for the error_uri parameter MUST conform to the URI-reference syntax and thus MUST NOT include characters outside the set %x21 / %x23-5B / %x5D-7E.",
      "ja": "「error_uri」：オプション。クライアント開発者にエラーに関する追加情報を提供するために使用されるエラーに関する情報を含む人間が読み取るWebページを識別するURI。ERROR_URIパラメーターの値は、URI-Referenceの構文に準拠する必要があるため、設定された％x21 /％x23-5b /％x5d-7eの外側の文字を含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "The parameters are included in the content of the HTTP response using the application/json media type as defined by [RFC7159]. The parameters are serialized into a JSON structure by adding each parameter at the highest structure level. Parameter names and string values are included as JSON strings. Numerical values are included as JSON numbers. The order of parameters does not matter and can vary.",
      "ja": "パラメーターは、[RFC7159]で定義されているアプリケーション/JSONメディアタイプを使用して、HTTP応答の内容に含まれています。パラメーターは、各パラメーターを最高の構造レベルで追加することにより、JSON構造にシリアル化されます。パラメーター名と文字列値はJSON文字列として含まれています。数値はJSON番号として含まれています。パラメーターの順序は重要ではなく、変化する可能性があります。"
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 400 Bad Request\nContent-Type: application/json\nCache-Control: no-store",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "{\n \"error\":\"invalid_request\"\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4. Grant Types",
      "section_title": true,
      "ja": "4. 付与タイプ"
    },
    {
      "indent": 3,
      "text": "To request an access token, the client obtains authorization from the resource owner. This specification defines the following authorization grant types:",
      "ja": "アクセストークンをリクエストするために、クライアントはリソース所有者から承認を取得します。この仕様は、次の承認助成金の種類を定義します。"
    },
    {
      "indent": 3,
      "text": "* authorization code",
      "ja": "* 承認コード"
    },
    {
      "indent": 3,
      "text": "* client credentials, and",
      "ja": "* クライアントの資格情報、および"
    },
    {
      "indent": 3,
      "text": "* refresh token",
      "ja": "* トークンを更新します"
    },
    {
      "indent": 3,
      "text": "It also provides an extension mechanism for defining additional grant types.",
      "ja": "また、追加の助成金タイプを定義するための拡張メカニズムも提供します。"
    },
    {
      "indent": 0,
      "text": "4.1. Authorization Code Grant",
      "section_title": true,
      "ja": "4.1. 承認コード助成金"
    },
    {
      "indent": 3,
      "text": "The authorization code grant type is used to obtain both access tokens and refresh tokens.",
      "ja": "Authorization Code Grant Typeは、アクセストークンと更新トークンの両方を取得するために使用されます。"
    },
    {
      "indent": 3,
      "text": "The grant type uses the additional authorization endpoint to let the authorization server interact with the resource owner in order to get consent for resource access.",
      "ja": "グラントタイプは、追加の認証エンドポイントを使用して、リソースアクセスの同意を得るために、承認サーバーがリソース所有者と対話できるようにします。"
    },
    {
      "indent": 3,
      "text": "Since this is a redirect-based flow, the client must be capable of initiating the flow with the resource owner's user agent (typically a web browser) and capable of being redirected back to from the authorization server.",
      "ja": "これはリダイレクトベースのフローであるため、クライアントはリソース所有者のユーザーエージェント（通常はWebブラウザー）でフローを開始でき、認証サーバーからリダイレクトできる必要があります。"
    },
    {
      "indent": 4,
      "text": "+----------+\n| Resource |\n|   Owner  |\n+----------+\n      ^\n      |\n      |\n+-----|----+          Client Identifier      +---------------+\n| .---+---------(1)-- & Redirect URI ------->|               |\n| |   |    |                                 |               |\n| |   '---------(2)-- User authenticates --->|               |\n| | User-  |                                 | Authorization |\n| | Agent  |                                 |     Server    |\n| |        |                                 |               |\n| |    .--------(3)-- Authorization Code ---<|               |\n+-|----|---+                                 +---------------+\n  |    |                                         ^      v\n  |    |                                         |      |\n  ^    v                                         |      |\n+---------+                                      |      |\n|         |>---(4)-- Authorization Code ---------'      |\n|  Client |          & Redirect URI                     |\n|         |                                             |\n|         |<---(5)----- Access Token -------------------'\n+---------+       (w/ Optional Refresh Token)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 3: Authorization Code Flow",
      "ja": "図3：認証コードフロー"
    },
    {
      "indent": 3,
      "text": "The flow illustrated in Figure 3 includes the following steps:",
      "ja": "図3に示すフローには、次の手順が含まれています。"
    },
    {
      "indent": 3,
      "text": "(1) The client initiates the flow by directing the resource owner's user agent to the authorization endpoint. The client includes its client identifier, code challenge (derived from a generated code verifier), optional requested scope, optional local state, and a redirect URI to which the authorization server will send the user agent back once access is granted (or denied).",
      "ja": "(1) クライアントは、リソース所有者のユーザーエージェントを承認エンドポイントに指示することにより、フローを開始します。クライアントには、クライアント識別子、コードチャレンジ（生成されたコード検証剤から派生）、オプションの要求されたスコープ、オプションのローカル状態、およびアクセスが許可された（または拒否された）承認サーバーがユーザーエージェントを送信するリダイレクトURIが含まれます。"
    },
    {
      "indent": 3,
      "text": "(2) The authorization server authenticates the resource owner (via the user agent) and establishes whether the resource owner grants or denies the client's access request.",
      "ja": "(2) Authorization Serverは、リソース所有者（ユーザーエージェントを介して）を認証し、リソース所有者がクライアントのアクセスリクエストを付与するか拒否するかを確立します。"
    },
    {
      "indent": 3,
      "text": "(3) Assuming the resource owner grants access, the authorization server redirects the user agent back to the client using the redirect URI provided earlier (in the request or during client registration). The redirect URI includes an authorization code and any local state provided by the client earlier.",
      "ja": "(3) リソース所有者がアクセスを付与すると仮定すると、Authorization Serverは、以前に提供されたRedirect URIを使用して（リクエストまたはクライアント登録中に）ユーザーエージェントをクライアントにリダイレクトします。リダイレクトURIには、承認コードとクライアントが以前に提供したローカル州が含まれています。"
    },
    {
      "indent": 3,
      "text": "(4) The client requests an access token from the authorization server's token endpoint by including the authorization code received in the previous step, and including its code verifier. When making the request, the client authenticates with the authorization server if it can. The client includes the redirect URI used to obtain the authorization code for verification.",
      "ja": "(4) クライアントは、前のステップで受信した承認コードを含めることにより、認証サーバーのトークンエンドポイントからアクセストークンを要求し、コード検証者を含めます。リクエストを行うとき、クライアントは、可能であれば認証サーバーで認証されます。クライアントには、検証のための承認コードを取得するために使用されるリダイレクトURIが含まれています。"
    },
    {
      "indent": 3,
      "text": "(5) The authorization server authenticates the client when possible, validates the authorization code, validates the code verifier, and ensures that the redirect URI received matches the URI used to redirect the client in step (3). If valid, the authorization server responds back with an access token and, optionally, a refresh token.",
      "ja": "(5) Authorization Serverは、可能な場合はクライアントを認証し、認証コードを検証し、コードVerifierを検証し、Redirect URIがURIがステップ（3）でリダイレクトするために使用したURIと一致することを保証します。有効な場合、Authorization Serverはアクセストークン、およびオプションで更新トークンで応答します。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Authorization Request",
      "section_title": true,
      "ja": "4.1.1. 承認リクエスト"
    },
    {
      "indent": 3,
      "text": "To begin the authorization request, the client builds the authorization request URI by adding parameters to the authorization server's authorization endpoint URI. The client will eventually redirect the user agent to this URI to initiate the request.",
      "ja": "承認要求を開始するために、クライアントは、承認サーバーの承認エンドポイントURIにパラメーターを追加することにより、認証要求URIを作成します。クライアントは最終的にユーザーエージェントをこのURIにリダイレクトしてリクエストを開始します。"
    },
    {
      "indent": 3,
      "text": "Clients use a unique secret per authorization request to protect against authorization code injection and CSRF attacks. The client first generates this secret, which it can use at the time of redeeming the authorization code to prove that the client using the authorization code is the same client that requested it.",
      "ja": "クライアントは、認証コードインジェクションとCSRF攻撃から保護するために、認証要求ごとの独自の秘密を使用します。クライアントは最初にこの秘密を生成します。この秘密は、認証コードを使用して承認コードを使用してクライアントが要求したクライアントと同じであることを証明するために使用できるこの秘密を生成します。"
    },
    {
      "indent": 3,
      "text": "The client constructs the request URI by adding the following parameters to the query component of the authorization endpoint URI using the application/x-www-form-urlencoded format, per Appendix B:",
      "ja": "クライアントは、付録Bごとに、アプリケーション/X-WWW-Form-Urlencodedフォーマットを使用して、承認エンドポイントURIのクエリコンポーネントに次のパラメーターを追加することにより、リクエストURIを構築します。"
    },
    {
      "indent": 3,
      "text": "\"response_type\": REQUIRED. The authorization endpoint supports different sets of request and response pameters. The client determines the type of flow by using a certain response_type value. This specification defines the value code, which must be used to signal that the client wants to use the authorization code flow.",
      "ja": "「Response_Type」：必須。承認エンドポイントは、さまざまなリクエストおよび応答パメーターのセットをサポートしています。クライアントは、特定のResponse_Type値を使用してフローのタイプを決定します。この仕様は値コードを定義します。これは、クライアントが認証コードフローを使用することを信号するために使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Extension response types MAY contain a space-delimited (%x20) list of values, where the order of values does not matter (e.g., response type a b is the same as b a). The meaning of such composite response types is defined by their respective specifications.",
      "ja": "拡張応答タイプには、値の順序が重要ではないスペース削除（％x20）リストが含まれている場合があります（例：応答タイプA BはB Aと同じです）。このような複合応答タイプの意味は、それぞれの仕様によって定義されます。"
    },
    {
      "indent": 3,
      "text": "Some extension response types are defined by ([OpenID]).",
      "ja": "一部の拡張応答タイプは（[OpenID]）で定義されます。"
    },
    {
      "indent": 3,
      "text": "If an authorization request is missing the response_type parameter, or if the response type is not understood, the authorization server MUST return an error response as described in Section 4.1.2.1.",
      "ja": "承認要求にresponse_typeパラメーターが欠落している場合、または応答タイプが理解されていない場合、承認サーバーはセクション4.1.2.1で説明されているようにエラー応答を返す必要があります。"
    },
    {
      "indent": 3,
      "text": "\"client_id\": REQUIRED. The client identifier as described in Section 2.2.",
      "ja": "「client_id」：必須。セクション2.2で説明されているクライアント識別子。"
    },
    {
      "indent": 3,
      "text": "\"code_challenge\": REQUIRED or RECOMMENDED (see Section 7.6). Code challenge.",
      "ja": "「code_challenge」：必須または推奨（セクション7.6を参照）。コードチャレンジ。"
    },
    {
      "indent": 3,
      "text": "\"code_challenge_method\": OPTIONAL, defaults to plain if not present in the request. Code verifier transformation method is S256 or plain.",
      "ja": "「code_challenge_method」：オプションでは、リクエストに存在しない場合はデフォルトです。コード検証剤変換法はS256またはプレーンです。"
    },
    {
      "indent": 3,
      "text": "\"redirect_uri\": OPTIONAL. As described in Section 2.3.",
      "ja": "「Redirect_uri」：オプション。セクション2.3で説明されているように。"
    },
    {
      "indent": 3,
      "text": "\"scope\": OPTIONAL. The scope of the access request as described by Section 3.2.2.1.",
      "ja": "「スコープ」：オプション。セクション3.2.2.1で説明されているアクセス要求の範囲。"
    },
    {
      "indent": 3,
      "text": "\"state\": OPTIONAL. An opaque value used by the client to maintain state between the request and callback. The authorization server includes this value when redirecting the user agent back to the client.",
      "ja": "「状態」：オプション。クライアントがリクエストとコールバックの間で状態を維持するために使用する不透明な値。認証サーバーには、ユーザーエージェントをクライアントにリダイレクトするときにこの値が含まれます。"
    },
    {
      "indent": 3,
      "text": "The code_verifier is a unique high-entropy cryptographically random\nstring generated for each authorization request, using the unreserved\ncharacters [A-Z] / [a-z] / [0-9] / \"-\" / \".\" / \"_\" / \"~\", with a\nminimum length of 43 characters and a maximum length of 128\ncharacters.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The client stores the code_verifier temporarily, and calculates the code_challenge which it uses in the authorization request.",
      "ja": "クライアントはCode_verifierを一時的に保存し、承認要求で使用するCode_Challengeを計算します。"
    },
    {
      "indent": 3,
      "text": "ABNF for code_verifier is as follows.",
      "ja": "code_verifierのabnfは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "code-verifier = 43*128unreserved\nunreserved = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\nALPHA = %x41-5A / %x61-7A\nDIGIT = %x30-39",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Clients SHOULD use code challenge methods that do not expose the code_verifier in the authorization request. Otherwise, attackers that can read the authorization request (cf. Attacker A4 in [I-D.ietf-oauth-security-topics]) can break the security provided by this mechanism. Currently, S256 is the only such method.",
      "ja": "クライアントは、承認リクエストでcode_verifierを公開しないコードチャレンジメソッドを使用する必要があります。それ以外の場合、[i-d.ietf-oauth-security-topics]の攻撃者A4を参照）を読むことができる攻撃者は、このメカニズムによって提供されるセキュリティを破ることができます。現在、S256はそのような方法だけです。"
    },
    {
      "indent": 3,
      "text": "NOTE: The code verifier SHOULD have enough entropy to make it impractical to guess the value. It is RECOMMENDED that the output of a suitable random number generator be used to create a 32-octet sequence. The octet sequence is then base64url-encoded to produce a 43-octet URL-safe string to use as the code verifier.",
      "ja": "注：コード検証者は、値を推測するのに非現実的にするのに十分なエントロピーを持つ必要があります。適切な乱数ジェネレーターの出力を使用して、32-OCTETシーケンスを作成することをお勧めします。OctetシーケンスはBase64urlエンコードされており、コード検証剤として使用する43オクテットのURLセーフ文字列を生成します。"
    },
    {
      "indent": 3,
      "text": "The client then creates a code_challenge derived from the code verifier by using one of the following transformations on the code verifier:",
      "ja": "次に、クライアントは、コード検証者の次の変換のいずれかを使用して、コード検証者から派生したcode_challengeを作成します。"
    },
    {
      "indent": 3,
      "text": "S256\n  code_challenge = BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "plain code_challenge = code_verifier",
      "ja": "Plain Code_Challenge = code_verifier"
    },
    {
      "indent": 3,
      "text": "If the client is capable of using S256, it MUST use S256, as S256 is Mandatory To Implement (MTI) on the server. Clients are permitted to use plain only if they cannot support S256 for some technical reason, for example constrained environments that do not have a hashing function available, and know via out-of-band configuration or via Authorization Server Metadata ([RFC8414]) that the server supports plain.",
      "ja": "クライアントがS256を使用できる場合、S256はサーバーに（MTI）を実装することが必須であるため、S256を使用する必要があります。クライアントは、何らかの技術的な理由でS256をサポートできない場合にのみプレーンを使用することができます。たとえば、ハッシュ機能を使用できない制約された環境、およびサーバーがプレーンをサポートする承認サーバーメタデータ（[RFC8414]）を介して使用できます。"
    },
    {
      "indent": 3,
      "text": "ABNF for code_challenge is as follows.",
      "ja": "code_challengeのabnfは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "code-challenge = 43*128unreserved\nunreserved = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\nALPHA = %x41-5A / %x61-7A\nDIGIT = %x30-39",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The properties code_challenge and code_verifier are adopted from the OAuth 2.0 extension known as \"Proof-Key for Code Exchange\", or PKCE ([RFC7636]) where this technique was originally developed.",
      "ja": "プロパティcode_challengeとcode_verifierは、この手法が最初に開発された「コード交換用」またはpkce（[rfc7636]）として知られるOAuth 2.0拡張機能から採用されています。"
    },
    {
      "indent": 3,
      "text": "Authorization servers MUST support the code_challenge and code_verifier parameters.",
      "ja": "承認サーバーは、code_challengeおよびcode_verifierパラメーターをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Clients MUST use code_challenge and code_verifier and authorization servers MUST enforce their use except under the conditions described in Section 7.6. In this case, using and enforcing code_challenge and code_verifier as described in the following is still RECOMMENDED.",
      "ja": "クライアントはcode_challengeとcode_verifierを使用する必要があり、セクション7.6で説明されている条件下を除き、サーバーは使用を実施する必要があります。この場合、以下で説明されているようにcode_challengeとcode_verifierを使用および施行することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The state and scope parameters SHOULD NOT include sensitive client or resource owner information in plain text, as they can be transmitted over insecure channels or stored insecurely.",
      "ja": "状態および範囲のパラメーターには、安全でないチャネル上に送信したり、不安定に保管されたりすることができるため、敏感なクライアントまたはリソースの所有者情報をプレーンテキストに含めるべきではありません。"
    },
    {
      "indent": 3,
      "text": "The client directs the resource owner to the constructed URI using an HTTP redirection, or by other means available to it via the user agent.",
      "ja": "クライアントは、HTTPリダイレクトを使用して、またはユーザーエージェントを介して利用可能な他の手段により、リソース所有者を構築されたURIに指示します。"
    },
    {
      "indent": 3,
      "text": "For example, the client directs the user agent to make the following\nHTTP request (with extra line breaks for display purposes only):\n   GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz\n    &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb\n    &code_challenge=6fdkQaPm51l13DSukcAH3Mdx7_ntecHYd1vi3n0hMZY\n    &code_challenge_method=S256 HTTP/1.1\nHost: server.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The authorization server validates the request to ensure that all required parameters are present and valid.",
      "ja": "Authorization Serverは、必要なすべてのパラメーターが存在していて有効であることを確認するための要求を検証します。"
    },
    {
      "indent": 3,
      "text": "In particular, the authorization server MUST validate the redirect_uri in the request if present, ensuring that it matches one of the registered redirect URIs previously established during client registration (Section 2). When comparing the two URIs the authorization server MUST ensure that the two URIs are equal, see [RFC3986], Section 6.2.1, Simple String Comparison, for details.",
      "ja": "特に、承認サーバーは、存在する場合はリクエストのRedirect_uriを検証する必要があり、クライアント登録中に以前に確立された登録されたリダイレクトURIの1つと一致するようにします（セクション2）。2つのURIを比較する場合、認証サーバーは2つのURIが等しいことを確認する必要があります。詳細については、[RFC3986]、セクション6.2.1、単純な文字列比較を参照してください。"
    },
    {
      "indent": 3,
      "text": "If the request is valid, the authorization server authenticates the resource owner and obtains an authorization decision (by asking the resource owner or by establishing approval via other means).",
      "ja": "リクエストが有効な場合、承認サーバーはリソース所有者を認証し、認証決定を取得します（リソース所有者に尋ねるか、他の手段で承認を確立することによって）。"
    },
    {
      "indent": 3,
      "text": "When a decision is established, the authorization server directs the user agent to the provided client redirect URI using an HTTP redirection response, or by other means available to it via the user agent.",
      "ja": "決定が確立されると、承認サーバーは、HTTPリダイレクト応答を使用して、またはユーザーエージェントを介して利用可能な他の手段により、ユーザーエージェントを提供されたクライアントにリダイレクトURIに指示します。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Authorization Response",
      "section_title": true,
      "ja": "4.1.2. 承認応答"
    },
    {
      "indent": 3,
      "text": "If the resource owner grants the access request, the authorization server issues an authorization code and delivers it to the client by adding the following parameters to the query component of the redirect URI using the application/x-www-form-urlencoded format, per Appendix B:",
      "ja": "リソース所有者がアクセス要求を付与する場合、Authorization Serverは認証コードを発行し、付録Bごとにアプリケーション/X-WWW-Form-Urlencoded Formatを使用してRedirect URIのクエリコンポーネントに次のパラメーターを追加することにより、クライアントに配信します。"
    },
    {
      "indent": 3,
      "text": "\"code\": REQUIRED. The authorization code is generated by the authorization server and opaque to the client. The authorization code MUST expire shortly after it is issued to mitigate the risk of leaks. A maximum authorization code lifetime of 10 minutes is RECOMMENDED. The client MUST NOT use the authorization code more than once. If an authorization code is used more than once, the authorization server MUST deny the request and SHOULD revoke (when possible) all access tokens and refresh tokens previously issued based on that authorization code. The authorization code is bound to the client identifier, code challenge and redirect URI.",
      "ja": "「コード」：必須。承認コードは、承認サーバーによって生成され、クライアントに不透明です。承認コードは、漏れのリスクを軽減するために発行された直後に期限切れになる必要があります。10分の最大許可コード寿命が推奨されます。クライアントは、承認コードを複数回使用してはなりません。許可コードが複数回使用されている場合、承認サーバーはリクエストを拒否する必要があり、すべてのアクセストークンとその認証コードに基づいて以前に発行されたトークンを更新する必要があります。承認コードは、クライアント識別子、コードチャレンジ、およびURIのリダイレクトに拘束されます。"
    },
    {
      "indent": 3,
      "text": "\"state\": REQUIRED if the state parameter was present in the client authorization request. The exact value received from the client.",
      "ja": "「状態」：クライアント承認リクエストに状態パラメーターが存在する場合が必要です。クライアントから受け取った正確な値。"
    },
    {
      "indent": 3,
      "text": "\"iss\": OPTIONAL. The identifier of the authorization server which",
      "ja": "「ISS」：オプション。承認サーバーの識別子"
    },
    {
      "indent": 6,
      "text": "the client can use to prevent mixup attacks, if the client interacts with more than one authorization server. See [RFC9207] for additional details on when this parameter is necessary, and how the client can use it to prevent mixup attacks.",
      "ja": "クライアントが複数の承認サーバーと対話する場合、クライアントは混合攻撃を防ぐために使用できます。[RFC9207]を参照してください。このパラメーターが必要な時期と、クライアントがそれを使用して混合攻撃を防止する方法については、参照してください。"
    },
    {
      "indent": 3,
      "text": "For example, the authorization server redirects the user agent by sending the following HTTP response:",
      "ja": "たとえば、承認サーバーは、次のHTTP応答を送信することにより、ユーザーエージェントをリダイレクトします。"
    },
    {
      "indent": 1,
      "text": "HTTP/1.1 302 Found\nLocation: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA\n          &state=xyz&iss=https%3A%2F%2Fauthorization-server.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The client MUST ignore unrecognized response parameters. The authorization code string size is left undefined by this specification. The client should avoid making assumptions about code value sizes. The authorization server SHOULD document the size of any value it issues.",
      "ja": "クライアントは、認識されていない応答パラメーターを無視する必要があります。認証コード文字列のサイズは、この仕様によって定義されていません。クライアントは、コード値のサイズについて仮定を避ける必要があります。Authorization Serverは、発行する価値のサイズを文書化する必要があります。"
    },
    {
      "indent": 3,
      "text": "The authorization server MUST associate the code_challenge and code_challenge_method values with the issued authorization code so the code challenge can be verified later.",
      "ja": "承認サーバーは、code_challengeおよびcode_challenge_method値を発行された承認コードに関連付ける必要があるため、後でコードチャレンジを検証できるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "The exact method that the server uses to associate the code_challenge with the issued code is out of scope for this specification. The code challenge could be stored on the server and associated with the code there. The code_challenge and code_challenge_method values may be stored in encrypted form in the code itself, but the server MUST NOT include the code_challenge value in a response parameter in a form that entities other than the AS can extract.",
      "ja": "サーバーがcode_challengeを発行されたコードに関連付けるために使用する正確な方法は、この仕様の範囲外です。コードチャレンジは、サーバーに保存され、そこのコードに関連付けられます。code_challengeおよびcode_challenge_method値は、コード自体に暗号化された形式に保存される場合がありますが、サーバーは、AS抽出以外のエンティティ以外のエンティティにcode_challenge値を応答パラメーターに含めるべきではありません。"
    },
    {
      "indent": 3,
      "text": "Clients MUST prevent injection (replay) of authorization codes into the authorization response by attackers. Using code_challenge and code_verifier prevents injection of authorization codes since the authorization server will reject a token request with a mismatched code_verifier. See Section 7.6 for more details.",
      "ja": "クライアントは、攻撃者による承認応答への承認コードの注入（リプレイ）を防ぐ必要があります。code_challengeとcode_verifierを使用すると、承認サーバーは不一致のcode_verifierを使用してトークン要求を拒否するため、承認コードの噴射を防ぎます。詳細については、セクション7.6を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.1.2.1. Error Response",
      "section_title": true,
      "ja": "4.1.2.1. エラー応答"
    },
    {
      "indent": 3,
      "text": "If the request fails due to a missing, invalid, or mismatching redirect URI, or if the client identifier is missing or invalid, the authorization server SHOULD inform the resource owner of the error and MUST NOT automatically redirect the user agent to the invalid redirect URI.",
      "ja": "欠落、無効、または不一致のURIの不一致のためにリクエストが障害を発生させた場合、またはクライアントの識別子が欠落または無効な場合、承認サーバーはリソース所有者にエラーを通知し、ユーザーエージェントを無効なリダイレクトURIに自動的にリダイレクトしてはなりません。"
    },
    {
      "indent": 3,
      "text": "An AS MUST reject requests without a code_challenge from public clients, and MUST reject such requests from other clients unless there is reasonable assurance that the client mitigates authorization code injection in other ways. See Section 7.6 for details.",
      "ja": "ASは、パブリッククライアントからのcode_challengeなしでリクエストを拒否しなければならず、クライアントが他の方法で認可コードインジェクションを緩和するという合理的な保証がない限り、他のクライアントからのそのような要求を拒否する必要があります。詳細については、セクション7.6を参照してください。"
    },
    {
      "indent": 3,
      "text": "If the server does not support the requested code_challenge_method transformation, the authorization endpoint MUST return the authorization error response with error value set to invalid_request. The error_description or the response of error_uri SHOULD explain the nature of error, e.g., transform algorithm not supported.",
      "ja": "サーバーが要求されたcode_challenge_method変換をサポートしていない場合、Authorization Endpointは、ERRORid_Requestに設定された[承認エラー応答]を返す必要があります。error_descriptionまたはerror_uriの応答は、サポートされていない変換アルゴリズムなどのエラーの性質を説明する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the resource owner denies the access request or if the request fails for reasons other than a missing or invalid redirect URI, the authorization server informs the client by adding the following parameters to the query component of the redirect URI using the application/x-www-form-urlencoded format, per Appendix B:",
      "ja": "リソース所有者がアクセス要求を拒否した場合、またはリクエストが不足または無効なリダイレクトURI以外の理由で故障した場合、承認サーバーは、付録Bによると、アプリケーション/X-WWW-Form-Urlencodedフォーマットを使用してリダイレクトURIのクエリコンポーネントに次のパラメーターを追加することによりクライアントに通知します。"
    },
    {
      "indent": 3,
      "text": "\"error\": REQUIRED. A single ASCII [USASCII] error code from the following:",
      "ja": "「エラー」：必須。以下からの単一のASCII [USASCII]エラーコード："
    },
    {
      "indent": 6,
      "text": "\"invalid_request\": The request is missing a required parameter, includes an invalid parameter value, includes a parameter more than once, or is otherwise malformed.",
      "ja": "「Invalid_Request」：要求には必要なパラメーターが欠落しているか、無効なパラメーター値が含まれている、パラメーターが複数回含まれているか、そうでなければ奇形が含まれます。"
    },
    {
      "indent": 6,
      "text": "\"unauthorized_client\": The client is not authorized to request an authorization code using this method.",
      "ja": "「unauthorized_client」：クライアントは、この方法を使用して承認コードを要求する権限を与えられていません。"
    },
    {
      "indent": 6,
      "text": "\"access_denied\": The resource owner or authorization server denied the request.",
      "ja": "「Access_Denied」：リソース所有者または承認サーバーがリクエストを拒否しました。"
    },
    {
      "indent": 6,
      "text": "\"unsupported_response_type\": The authorization server does not support obtaining an authorization code using this method.",
      "ja": "「unsupported_response_type」：Authorization Serverは、この方法を使用して認証コードの取得をサポートしていません。"
    },
    {
      "indent": 6,
      "text": "\"invalid_scope\": The requested scope is invalid, unknown, or malformed.",
      "ja": "「Invalid_scope」：要求されたスコープは無効、不明、または不正されています。"
    },
    {
      "indent": 6,
      "text": "\"server_error\": The authorization server encountered an unexpected condition that prevented it from fulfilling the request. (This error code is needed because a 500 Internal Server Error HTTP status code cannot be returned to the client via an HTTP redirect.)",
      "ja": "「Server_Error」：承認サーバーは、リクエストを満たすことを妨げる予期しない条件に遭遇しました。（HTTPリダイレクトを介して500内のサーバーエラーHTTPステータスコードをクライアントに返すことができないため、このエラーコードが必要です。）"
    },
    {
      "indent": 6,
      "text": "\"temporarily_unavailable\": The authorization server is currently unable to handle the request due to a temporary overloading or maintenance of the server. (This error code is needed because a 503 Service Unavailable HTTP status code cannot be returned to the client via an HTTP redirect.)",
      "ja": "「一時的に_unavailable」：承認サーバーは現在、サーバーの一時的な過負荷またはメンテナンスのためにリクエストを処理できません。（HTTP Redirectを介して503サービスを利用できないHTTPステータスコードをクライアントに返すことができないため、このエラーコードが必要です。）"
    },
    {
      "indent": 6,
      "text": "Values for the error parameter MUST NOT include characters outside the set %x20-21 / %x23-5B / %x5D-7E.",
      "ja": "エラーパラメーターの値は、セット％x20-21 /％x23-5b /％x5d-7eの外側の文字を含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "\"error_description\": OPTIONAL. Human-readable ASCII [USASCII] text",
      "ja": "「error_description」：オプション。人間読み取り可能なASCII [USASCII]テキスト"
    },
    {
      "indent": 6,
      "text": "providing additional information, used to assist the client developer in understanding the error that occurred. Values for the error_description parameter MUST NOT include characters outside the set %x20-21 / %x23-5B / %x5D-7E.",
      "ja": "クライアント開発者が発生したエラーを理解するのを支援するために使用される追加情報を提供します。error_descriptionパラメーターの値は、セット％x20-21 /％x23-5b /％x5d-7eの外側の文字を含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "\"error_uri\": OPTIONAL. A URI identifying a human-readable web page with information about the error, used to provide the client developer with additional information about the error. Values for the error_uri parameter MUST conform to the URI-reference syntax and thus MUST NOT include characters outside the set %x21 / %x23-5B / %x5D-7E.",
      "ja": "「error_uri」：オプション。クライアント開発者にエラーに関する追加情報を提供するために使用されるエラーに関する情報を含む人間が読み取るWebページを識別するURI。ERROR_URIパラメーターの値は、URI-Referenceの構文に準拠する必要があるため、設定された％x21 /％x23-5b /％x5d-7eの外側の文字を含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "\"state\": REQUIRED if a state parameter was present in the client authorization request. The exact value received from the client.",
      "ja": "「状態」：クライアント承認リクエストに状態パラメーターが存在する場合が必要です。クライアントから受け取った正確な値。"
    },
    {
      "indent": 3,
      "text": "\"iss\": OPTIONAL. The identifier of the authorization server. See Section 4.1.2 above for details.",
      "ja": "「ISS」：オプション。Authorization Serverの識別子。詳細については、上記のセクション4.1.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "For example, the authorization server redirects the user agent by sending the following HTTP response:",
      "ja": "たとえば、承認サーバーは、次のHTTP応答を送信することにより、ユーザーエージェントをリダイレクトします。"
    },
    {
      "indent": 1,
      "text": "HTTP/1.1 302 Found\nLocation: https://client.example.com/cb?error=access_denied\n          &state=xyz&iss=https%3A%2F%2Fauthorization-server.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.1.3. Token Endpoint Extension",
      "section_title": true,
      "ja": "4.1.3. トークンエンドポイント拡張機能"
    },
    {
      "indent": 3,
      "text": "The authorization grant type is identified at the token endpoint with the grant_type value of authorization_code.",
      "ja": "承認助成金タイプは、authorization_codeのgrant_type値を備えたトークンエンドポイントで識別されます。"
    },
    {
      "indent": 3,
      "text": "If this value is set, the following additional token request parameters beyond Section 3.2.2 are required:",
      "ja": "この値が設定されている場合、セクション3.2.2を超える追加のトークン要求パラメーターが必要です。"
    },
    {
      "indent": 3,
      "text": "\"code\": REQUIRED. The authorization code received from the authorization server.",
      "ja": "「コード」：必須。認証サーバーから受信した認証コード。"
    },
    {
      "indent": 3,
      "text": "\"code_verifier\": REQUIRED, if the code_challenge parameter was included in the authorization request. MUST NOT be used otherwise. The original code verifier string.",
      "ja": "「code_verifier」：code_challengeパラメーターが承認リクエストに含まれている場合。それ以外の場合は使用してはなりません。元のコード検証文字列。"
    },
    {
      "indent": 3,
      "text": "For example, the client makes the following HTTP request (with extra line breaks for display purposes only):",
      "ja": "たとえば、クライアントは次のHTTPリクエストを行います（表示目的でのみ追加のラインブレークがあります）："
    },
    {
      "indent": 1,
      "text": "POST /token HTTP/1.1 Host: server.example.com Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW Content-Type: application/x-www-form-urlencoded",
      "ja": "post/token http/1.1ホスト：server.example.com認証：基本czzcagrsa3f0mzpnwdfmqmf0m2jw content-type：application/x-www-form-urlencoded"
    },
    {
      "indent": 1,
      "text": "grant_type=authorization_code\n&code=SplxlOBeZQQYbYS6WxSbIA\n&code_verifier=3641a2d12d66101249cdf7a79c000c1f8c05d2aafcf14bf146497bed",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In addition to the processing rules in Section 3.2.2, the authorization server MUST:",
      "ja": "セクション3.2.2の処理ルールに加えて、承認サーバーは以下を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "* ensure that the authorization code was issued to the authenticated confidential client, or if the client is public, ensure that the code was issued to client_id in the request,",
      "ja": "* 認証コードが認証された機密クライアントに発行されたことを確認するか、クライアントが公開されている場合は、リクエストでクライアント_IDにコードが発行されたことを確認してください。"
    },
    {
      "indent": 3,
      "text": "* verify that the authorization code is valid,",
      "ja": "* 承認コードが有効であることを確認してください。"
    },
    {
      "indent": 3,
      "text": "* verify that the code_verifier parameter is present if and only if a code_challenge parameter was present in the authorization request,",
      "ja": "* code_challengeパラメーターが承認リクエストに存在した場合にのみ、code_verifierパラメーターが存在することを確認します。"
    },
    {
      "indent": 3,
      "text": "* if a code_verifier is present, verify the code_verifier by calculating the code challenge from the received code_verifier and comparing it with the previously associated code_challenge, after first transforming it according to the code_challenge_method method specified by the client, and",
      "ja": "* code_verifierが存在する場合は、クライアントが指定したcode_challenge_methodメソッドに従って最初に変換した後、受信したcode_verifierからコードチャレンジを計算し、以前に関連付けられたcode_challengeと比較することにより、code_verifierを確認します。"
    },
    {
      "indent": 3,
      "text": "* If there was no code_challenge in the authorization request associated with the authorization code in the token request, the authorization server MUST reject the token request.",
      "ja": "* トークン要求の承認コードに関連付けられた承認要求にcode_challengeがなかった場合、承認サーバーはトークンリクエストを拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "See Section 10.2 for details on backwards compatibility with OAuth 2.0 clients regarding the redirect_uri parameter in the token request.",
      "ja": "トークンリクエストのRedirect_URIパラメーターに関するOAUTH 2.0クライアントとの後方互換性の詳細については、セクション10.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.2. Client Credentials Grant",
      "section_title": true,
      "ja": "4.2. クライアント資格認定補助金"
    },
    {
      "indent": 3,
      "text": "The client can request an access token using only its client credentials (or other supported means of authentication) when the client is requesting access to the protected resources under its control, or those of another resource owner that have been previously arranged with the authorization server (the method of which is beyond the scope of this specification).",
      "ja": "クライアントは、クライアントがその制御下にある保護されたリソースへのアクセスを要求している場合、または以前に承認サーバーに配置された別のリソース所有者のアクセスを要求している場合、クライアントの資格情報（またはその他のサポートされている認証手段）のみを使用してアクセストークンを要求できます（その方法はこの仕様の範囲を超えています）。"
    },
    {
      "indent": 3,
      "text": "The client credentials grant type MUST only be used by confidential clients.",
      "ja": "クライアント資格情報の付与タイプは、機密クライアントがのみ使用する必要があります。"
    },
    {
      "indent": 8,
      "text": "+---------+                                  +---------------+\n|         |                                  |               |\n|         |>--(1)- Client Authentication --->| Authorization |\n| Client  |                                  |     Server    |\n|         |<--(2)---- Access Token ---------<|               |\n|         |                                  |               |\n+---------+                                  +---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 4: Client Credentials Grant",
      "ja": "図4：クライアント資格認定助成"
    },
    {
      "indent": 3,
      "text": "The use of the client credentials grant illustrated in Figure 4 includes the following steps:",
      "ja": "図4に示されているクライアント資格情報の付与の使用には、次の手順が含まれています。"
    },
    {
      "indent": 3,
      "text": "(1) The client authenticates with the authorization server and requests an access token from the token endpoint.",
      "ja": "(1) クライアントは、承認サーバーで認証され、トークンエンドポイントからアクセストークンを要求します。"
    },
    {
      "indent": 3,
      "text": "(2) The authorization server authenticates the client, and if valid, issues an access token.",
      "ja": "(2) Authorization Serverはクライアントを認証し、有効な場合、アクセストークンを発行します。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Token Endpoint Extension",
      "section_title": true,
      "ja": "4.2.1. トークンエンドポイント拡張機能"
    },
    {
      "indent": 3,
      "text": "The authorization grant type is identified at the token endpoint with the grant_type value of client_credentials.",
      "ja": "承認助成金の種類は、client_credentialsのgrant_type値を持つトークンエンドポイントで識別されます。"
    },
    {
      "indent": 3,
      "text": "If this value is set, the following additional token request parameters beyond Section 3.2.2 are supported:",
      "ja": "この値が設定されている場合、セクション3.2.2を超える次の追加のトークン要求パラメーターがサポートされています。"
    },
    {
      "indent": 3,
      "text": "\"scope\": OPTIONAL. The scope of the access request as described by Section 3.2.2.1.",
      "ja": "「スコープ」：オプション。セクション3.2.2.1で説明されているアクセス要求の範囲。"
    },
    {
      "indent": 3,
      "text": "For example, the client makes the following HTTP request using transport-layer security (with extra line breaks for display purposes only):",
      "ja": "たとえば、クライアントは、輸送層のセキュリティを使用して次のHTTP要求を行います（ディスプレイ目的のみの追加のラインブレークを使用）：："
    },
    {
      "indent": 3,
      "text": "POST /token HTTP/1.1 Host: server.example.com Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW Content-Type: application/x-www-form-urlencoded",
      "ja": "post/token http/1.1ホスト：server.example.com認証：基本czzcagrsa3f0mzpnwdfmqmf0m2jw content-type：application/x-www-form-urlencoded"
    },
    {
      "indent": 3,
      "text": "grant_type=client_credentials",
      "ja": "grant_type = client_credentials"
    },
    {
      "indent": 3,
      "text": "The authorization server MUST authenticate the client.",
      "ja": "Authorization Serverは、クライアントを認証する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3. Refresh Token Grant",
      "section_title": true,
      "ja": "4.3. トークングラントを更新します"
    },
    {
      "indent": 3,
      "text": "The refresh token is a credential issued by the authorization server to a client, which can be used to obtain new (fresh) access tokens based on an existing grant. The client uses this option either because the previous access token has expired or the client previously obtained an access token with a scope more narrow than approved by the respective grant and later requires an access token with a different scope under the same grant.",
      "ja": "更新トークンは、承認サーバーがクライアントに発行する資格情報であり、既存の助成金に基づいて新しい（新鮮な）アクセストークンを取得するために使用できます。クライアントは、以前のアクセストークンの有効期限が切れたか、クライアントが以前にそれぞれの助成金によって承認されたスコープを備えたアクセストークンを取得し、後に同じ助成金の下で異なるスコープを持つアクセストークンを必要とするため、このオプションを使用します。"
    },
    {
      "indent": 3,
      "text": "Refresh tokens MUST be kept confidential in transit and storage, and shared only among the authorization server and the client to whom the refresh tokens were issued. The authorization server MUST maintain the binding between a refresh token and the client to whom it was issued.",
      "ja": "更新トークンは、輸送とストレージの機密を保持する必要があり、認証サーバーとリフレッシュトークンが発行されたクライアントの間でのみ共有する必要があります。承認サーバーは、更新トークンとそれが発行されたクライアントとの間のバインディングを維持する必要があります。"
    },
    {
      "indent": 3,
      "text": "The authorization server MUST verify the binding between the refresh token and client identity whenever the client identity can be authenticated. When client authentication is not possible, the authorization server SHOULD issue sender-constrained refresh tokens or use refresh token rotation as described in Section 4.3.1.",
      "ja": "承認サーバーは、クライアントのアイデンティティを認証できる場合はいつでも、更新トークンとクライアントのアイデンティティの間のバインディングを確認する必要があります。クライアント認証が不可能な場合、承認サーバーは、セクション4.3.1で説明されているように、Sender-Constraendeの更新トークンを発行するか、更新トークン回転を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The authorization server MUST ensure that refresh tokens cannot be generated, modified, or guessed to produce valid refresh tokens by unauthorized parties.",
      "ja": "承認サーバーは、不正な当事者によって有効な更新トークンを生成するために更新トークンを生成、変更、または推測できないことを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3.1. Token Endpoint Extension",
      "section_title": true,
      "ja": "4.3.1. トークンエンドポイント拡張機能"
    },
    {
      "indent": 3,
      "text": "The authorization grant type is identified at the token endpoint with the grant_type value of refresh_token.",
      "ja": "承認助成金の種類は、refried_tokenのgrant_type値を備えたトークンエンドポイントで識別されます。"
    },
    {
      "indent": 3,
      "text": "If this value is set, the following additional parameters beyond Section 3.2.2 are required/supported:",
      "ja": "この値が設定されている場合、セクション3.2.2を超える次の追加パラメーターが必要/サポートされています。"
    },
    {
      "indent": 3,
      "text": "\"refresh_token\": REQUIRED. The refresh token issued to the client.",
      "ja": "「refress_token」：必須。クライアントに発行された更新トークン。"
    },
    {
      "indent": 3,
      "text": "\"scope\": OPTIONAL. The scope of the access request as described by Section 3.2.2.1. The requested scope MUST NOT include any scope not originally granted by the resource owner, and if omitted is treated as equal to the scope originally granted by the resource owner.",
      "ja": "「スコープ」：オプション。セクション3.2.2.1で説明されているアクセス要求の範囲。要求されたスコープには、元々リソース所有者によって付与されたものではないスコープを含めてはなりません。省略された場合は、リソース所有者が元々付与されたスコープに等しいと扱われます。"
    },
    {
      "indent": 3,
      "text": "Because refresh tokens are typically long-lasting credentials used to request additional access tokens, the refresh token is bound to the client to which it was issued. Confidential clients MUST authenticate with the authorization server as described in Section 3.2.1.",
      "ja": "更新トークンは通常、追加のアクセストークンを要求するために使用される長期にわたる資格情報であるため、更新トークンは発行されたクライアントにバインドされます。Confidentialクライアントは、セクション3.2.1で説明されているように、認証サーバーで認証する必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, the client makes the following HTTP request using transport-layer security (with extra line breaks for display purposes only):",
      "ja": "たとえば、クライアントは、輸送層のセキュリティを使用して次のHTTP要求を行います（ディスプレイ目的のみの追加のラインブレークを使用）：："
    },
    {
      "indent": 3,
      "text": "POST /token HTTP/1.1 Host: server.example.com Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW Content-Type: application/x-www-form-urlencoded",
      "ja": "post/token http/1.1ホスト：server.example.com認証：基本czzcagrsa3f0mzpnwdfmqmf0m2jw content-type：application/x-www-form-urlencoded"
    },
    {
      "indent": 3,
      "text": "grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA",
      "ja": "grant_type = refress_token＆refresh_token = tgzv3jokf0xg5qx2tlkwia"
    },
    {
      "indent": 3,
      "text": "In addition to the processing rules in Section 3.2.2, the authorization server MUST:",
      "ja": "セクション3.2.2の処理ルールに加えて、承認サーバーは以下を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "* if client authentication is included in the request, ensure that the refresh token was issued to the authenticated client, OR if a client_id is included in the request, ensure the refresh token was issued to the matching client",
      "ja": "* クライアント認証がリクエストに含まれている場合は、更新トークンが認証されたクライアントに発行されたことを確認するか、クライアント_IDがリクエストに含まれている場合は、マッチングクライアントに更新トークンが発行されたことを確認してください"
    },
    {
      "indent": 3,
      "text": "* validate that the grant corresponding to this refresh token is still active",
      "ja": "* この更新トークンに対応する助成金がまだアクティブであることを確認します"
    },
    {
      "indent": 3,
      "text": "* validate the refresh token",
      "ja": "* 更新トークンを検証します"
    },
    {
      "indent": 3,
      "text": "Authorization servers MUST utilize one of these methods to detect refresh token replay by malicious actors for public clients:",
      "ja": "承認サーバーは、これらの方法のいずれかを利用して、パブリッククライアント向けの悪意のあるアクターによるリフレッシュトークンリプレイを検出する必要があります。"
    },
    {
      "indent": 3,
      "text": "* _Sender-constrained refresh tokens:_ the authorization server cryptographically binds the refresh token to a certain client instance, e.g. by utilizing [RFC8705] or [I-D.ietf-oauth-dpop].",
      "ja": "* _SENDER-CONSTRAEND REFRESH TOKEN：_ Authorization Serverは、リフレッシュトークンを特定のクライアントインスタンスに暗号化します。[rfc8705]または[i-d.ietf-oauth-dpop]を使用することにより。"
    },
    {
      "indent": 3,
      "text": "* _Refresh token rotation:_ the authorization server issues a new refresh token with every access token refresh response. The previous refresh token is invalidated but information about the relationship is retained by the authorization server. If a refresh token is compromised and subsequently used by both the attacker and the legitimate client, one of them will present an invalidated refresh token, which will inform the authorization server of the breach. The authorization server cannot determine which party submitted the invalid refresh token, but it will revoke the active refresh token as well as the access authorization grant associated with it. This stops the attack at the cost of forcing the legitimate client to obtain a fresh authorization grant.",
      "ja": "* _refreshトークン回転：_ Authorization Serverは、アクセスするたびに新しい更新トークンを発行します。トークンリフレッシュ応答。以前の更新トークンは無効ですが、関係に関する情報は承認サーバーによって保持されます。更新トークンが侵害され、その後攻撃者と合法的なクライアントの両方が使用する場合、そのうちの1人は無効な更新トークンを提示し、承認サーバーに違反を通知します。Authorization Serverは、どのパーティが無効な更新トークンを提出したかを決定することはできませんが、それに関連するActive Refresh TokenとAccess Authorization Grantが取り消されます。これにより、正当なクライアントに新たな承認助成金を取得するように強制するための犠牲を払って攻撃が停止します。"
    },
    {
      "indent": 3,
      "text": "Implementation note: the grant to which a refresh token belongs may be encoded into the refresh token itself. This can enable an authorization server to efficiently determine the grant to which a refresh token belongs, and by extension, all refresh tokens that need to be revoked. Authorization servers MUST ensure the integrity of the refresh token value in this case, for example, using signatures.",
      "ja": "実装注：更新トークンが属する助成金は、更新トークン自体にエンコードされる場合があります。これにより、承認サーバーが更新トークンが属する助成金を効率的に決定できるようになり、さらにはすべてのリフレッシュトークンを取り消す必要があります。承認サーバーは、この場合、署名を使用して、更新トークン値の整合性を確保する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Refresh Token Response",
      "section_title": true,
      "ja": "4.3.2. トークンの応答を更新します"
    },
    {
      "indent": 3,
      "text": "If valid and authorized, the authorization server issues an access token as described in Section 3.2.3.",
      "ja": "有効かつ承認された場合、承認サーバーは、セクション3.2.3で説明されているようにアクセストークンを発行します。"
    },
    {
      "indent": 3,
      "text": "The authorization server MAY issue a new refresh token, in which case the client MUST discard the old refresh token and replace it with the new refresh token.",
      "ja": "Authorization Serverは、新しい更新トークンを発行する場合があります。この場合、クライアントは古い更新トークンを破棄し、新しい更新トークンに置き換える必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3.3. Refresh Token Recommendations",
      "section_title": true,
      "ja": "4.3.3. トークンの推奨事項を更新します"
    },
    {
      "indent": 3,
      "text": "The authorization server MAY revoke the old refresh token after issuing a new refresh token to the client. If a new refresh token is issued, the refresh token scope MUST be identical to that of the refresh token included by the client in the request.",
      "ja": "認証サーバーは、クライアントに新しい更新トークンを発行した後、古い更新トークンを取り消すことができます。新しい更新トークンが発行された場合、リクエストにクライアントが含めたリフレッシュトークンの更新スコープと同一でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Authorization servers MAY revoke refresh tokens automatically in case of a security event, such as:",
      "ja": "承認サーバーは、次のようなセキュリティイベントの場合、トークンを自動的にリフレッシュする場合があります。"
    },
    {
      "indent": 3,
      "text": "* password change",
      "ja": "* パスワードの変更"
    },
    {
      "indent": 3,
      "text": "* logout at the authorization server",
      "ja": "* Authorization Serverでのログアウト"
    },
    {
      "indent": 3,
      "text": "Refresh tokens SHOULD expire if the client has been inactive for some time, i.e., the refresh token has not been used to obtain new access tokens for some time. The expiration time is at the discretion of the authorization server. It might be a global value or determined based on the client policy or the grant associated with the refresh token (and its sensitivity).",
      "ja": "クライアントがしばらく非アクティブであった場合、リフレッシュトークンは期限切れになります。つまり、リフレッシュトークンは、しばらくの間新しいアクセストークンを取得するために使用されていません。有効期限は、承認サーバーの裁量にあります。それはグローバルな価値であるか、クライアントポリシーまたは更新トークン（およびその感度）に関連する助成金に基づいて決定される場合があります。"
    },
    {
      "indent": 0,
      "text": "4.4. Extension Grants",
      "section_title": true,
      "ja": "4.4. 拡張助成金"
    },
    {
      "indent": 3,
      "text": "The client uses an extension grant type by specifying the grant type using an absolute URI (defined by the authorization server) as the value of the grant_type parameter of the token endpoint, and by adding any additional parameters necessary.",
      "ja": "クライアントは、トークンエンドポイントのgrant_typeパラメーターの値として絶対URI（承認サーバーで定義）を使用して助成金タイプを指定し、必要な追加パラメーターを追加することにより、拡張補助金タイプを使用します。"
    },
    {
      "indent": 3,
      "text": "For example, to request an access token using the Device Authorization Grant as defined by [RFC8628] after the user has authorized the client on a separate device, the client makes the following HTTP request (with extra line breaks for display purposes only):",
      "ja": "たとえば、[RFC8628]で定義されたデバイス認証助成金を使用してアクセストークンを要求するには、ユーザーが別のデバイスでクライアントを承認した後、クライアントは次のHTTPリクエストを行います（ディスプレイ目的でのみ追加のラインブレークを使用）。"
    },
    {
      "indent": 5,
      "text": "POST /token HTTP/1.1 Host: server.example.com Content-Type: application/x-www-form-urlencoded",
      "ja": "投稿/トークンhttp/1.1ホスト：server.example.comコンテンツタイプ：アプリケーション/x-www-form-urlencoded"
    },
    {
      "indent": 5,
      "text": "grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code &device_code=GmRhmhcxhwEzkoEqiMEg_DnyEysNkuNhszIySk9eS &client_id=C409020731",
      "ja": "grant_type = urn％3aietf％3aparams％3aoauth％3agrant-type％3adevice_code＆device_code = gmrhmhcxhwezkoeqimeg_dnyeysnkunhsziysk9es＆client_id = C4090207311"
    },
    {
      "indent": 3,
      "text": "If the access token request is valid and authorized, the authorization server issues an access token and optional refresh token as described in Section 3.2.3. If the request failed client authentication or is invalid, the authorization server returns an error response as described in Section 3.2.3.1.",
      "ja": "アクセストークン要求が有効かつ承認されている場合、承認サーバーは、セクション3.2.3で説明されているように、アクセストークンとオプションの更新トークンを発行します。要求がクライアント認証に失敗した場合、または無効である場合、承認サーバーはセクション3.2.3.1で説明されているようにエラー応答を返します。"
    },
    {
      "indent": 0,
      "text": "5. Accessing Protected Resources",
      "section_title": true,
      "ja": "5. 保護されたリソースへのアクセス"
    },
    {
      "indent": 3,
      "text": "The client accesses protected resources by presenting the access token to the resource server. The resource server MUST validate the access token and ensure that it has not expired and that its scope covers the requested resource. The methods used by the resource server to validate the access token (as well as any error responses) are beyond the scope of this specification, but generally involve an interaction or coordination between the resource server and the authorization server. For example, when the resource server and authorization server are colocated or are part of the same system, they may share a database or other storage; when the two components are operated independently, they may use Token Introspection [RFC7662] or a structured access token format such as a JWT [RFC9068].",
      "ja": "クライアントは、アクセストークンをリソースサーバーに提示することにより、保護されたリソースにアクセスします。リソースサーバーは、アクセストークンを検証し、有効期限が切れていないこと、およびそのスコープが要求されたリソースをカバーすることを確認する必要があります。リソースサーバーがアクセストークンを検証するために使用する方法（およびエラー応答）は、この仕様の範囲を超えていますが、一般にリソースサーバーと承認サーバー間の相互作用または調整が含まれます。たとえば、リソースサーバーと承認サーバーが同じシステムの一部である場合、または同じシステムの一部である場合、データベースまたはその他のストレージを共有する場合があります。2つのコンポーネントが独立して動作する場合、トークン内省[RFC7662]またはJWTなどの構造化アクセストークン形式を使用する場合があります。"
    },
    {
      "indent": 3,
      "text": "The method in which the client utilizes the access token to access protected resources at the resource server depends on the type of access token issued by the authorization server. Typically, it involves using the HTTP Authorization request header field [RFC7235] with an authentication scheme defined by the specification of the access token type used, such as Bearer, defined below.",
      "ja": "クライアントがアクセストークンを利用してリソースサーバーで保護されたリソースにアクセスする方法は、認証サーバーが発行したアクセストークンのタイプに依存します。通常、以下に定義するベアラーなど、使用されるアクセストークンタイプの仕様によって定義された認証スキームを使用して、HTTP認証要求ヘッダーフィールド[RFC7235]を使用することが含まれます。"
    },
    {
      "indent": 0,
      "text": "5.1. Access Token Types",
      "section_title": true,
      "ja": "5.1. アクセストークンタイプ"
    },
    {
      "indent": 3,
      "text": "The access token type provides the client with the information required to successfully utilize the access token to make a protected resource request (along with type-specific attributes). The client MUST NOT use an access token if it does not understand the token type.",
      "ja": "アクセストークンタイプは、アクセストークンを正常に利用して保護されたリソースリクエストを（タイプ固有の属性とともに）行うために必要な情報をクライアントに提供します。クライアントは、トークンタイプを理解していない場合は、アクセストークンを使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "For example, the Bearer token type defined in this specification is utilized by simply including the access token string in the request: GET /resource/1 HTTP/1.1 Host: example.com Authorization: Bearer mF_9.B5f-4.1JqM",
      "ja": "たとえば、この仕様で定義されているベアラートークンタイプは、リクエストにアクセストークン文字列を含めるだけで利用されます：get/resource/1 http/1.1ホスト：example.com認証：ベアラーMF_9.B5F-4.1JQM"
    },
    {
      "indent": 3,
      "text": "The above example is provided for illustration purposes only.",
      "ja": "上記の例は、図のみを目的としています。"
    },
    {
      "indent": 3,
      "text": "Each access token type definition specifies the additional attributes (if any) sent to the client together with the access_token response parameter. It also defines the HTTP authentication method used to include the access token when making a protected resource request.",
      "ja": "各アクセストークンタイプ定義は、Access_Token Responseパラメーターとともにクライアントに送信される追加の属性（存在する場合）を指定します。また、保護されたリソース要求を行うときにアクセストークンを含めるために使用されるHTTP認証方法も定義します。"
    },
    {
      "indent": 0,
      "text": "5.2. Bearer Tokens",
      "section_title": true,
      "ja": "5.2. ベアラートークン"
    },
    {
      "indent": 3,
      "text": "A Bearer Token is a security token with the property that any party in possession of the token (a \"bearer\") can use the token in any way that any other party in possession of it can. Using a Bearer Token does not require a bearer to prove possession of cryptographic key material (proof-of-possession).",
      "ja": "ベアラートークンは、トークンを所有している当事者（「ベアラー」）が、他の当事者が所有する他の当事者ができるような方法でトークンを使用できるというプロパティのセキュリティトークンです。担い手のトークンを使用しても、担い手は暗号化の重要な資料の所持を証明する必要はありません（所有証明の証明）。"
    },
    {
      "indent": 3,
      "text": "Bearer Tokens may be enhanced with proof-of-possession specifications such as mTLS [RFC8705] to provide proof-of-possession characteristics.",
      "ja": "Bearer Tokensは、MTLS [RFC8705]などのプルーフオブポッセッション仕様で強化されて、プルーフオブセッションの特性を提供する場合があります。"
    },
    {
      "indent": 3,
      "text": "To protect against access token disclosure, the communication interaction between the client and the resource server MUST utilize confidentiality and integrity protection as described in Section 1.5.",
      "ja": "アクセストークンの開示から保護するために、クライアントとリソースサーバーの間の通信相互作用は、セクション1.5で説明されているように、機密性と整合性保護を利用する必要があります。"
    },
    {
      "indent": 3,
      "text": "There is no requirement on the particular structure or format of a bearer token, as described in Section 5. If a bearer token is a reference to authorization information, such references MUST be infeasible for an attacker to guess, such as using a sufficiently long cryptographically random string. If a bearer token uses an encoding mechanism to contain the authorization information in the token itself, the access token MUST use integrity protection sufficient to prevent the token from being modified. One example of an encoding and signing mechanism for access tokens is described in JSON Web Token Profile for Access Tokens [RFC9068].",
      "ja": "セクション5で説明されているように、ベアラートークンの特定の構造または形式には要件はありません。ベアラートークンが許可情報への参照である場合、そのような参照は、十分に長い暗号的にランダムな文字列を使用するなど、攻撃者が推測することは不可能です。Bearer Tokenがエンコーディングメカニズムを使用してトークン自体に承認情報を含める場合、アクセストークンはトークンが変更されないように十分な整合性保護を使用する必要があります。アクセストークンのエンコーディングおよび署名メカニズムの1つの例は、アクセストークン[RFC9068]のJSON Webトークンプロファイルで説明されています。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Authenticated Requests",
      "section_title": true,
      "ja": "5.2.1. 認証されたリクエスト"
    },
    {
      "indent": 3,
      "text": "This section defines two methods of sending Bearer tokens in resource requests to resource servers. Clients MUST use one of the two methods defined below, and MUST NOT use more than one method to transmit the token in each request.",
      "ja": "このセクションでは、リソースリクエストのベアラートークンをリソースサーバーに送信する2つの方法を定義します。クライアントは、以下に定義されている2つの方法のいずれかを使用する必要があり、各リクエストでトークンを送信するために複数の方法を使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "In particular, clients MUST NOT send the access token in a URI query parameter, and resource servers MUST ignore access tokens in a URI query parameter.",
      "ja": "特に、クライアントはURIクエリパラメーターでアクセストークンを送信してはなりません。リソースサーバーは、URIクエリパラメーターのアクセストークンを無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.1.1. Authorization Request Header Field",
      "section_title": true,
      "ja": "5.2.1.1. 承認要求ヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "When sending the access token in the Authorization request header field defined by HTTP/1.1 [RFC7235], the client uses the Bearer authentication scheme to transmit the access token.",
      "ja": "HTTP/1.1 [RFC7235]で定義されたAuthorization Request Headerフィールドにアクセストークンを送信すると、クライアントはBearer認証スキームを使用してアクセストークンを送信します。"
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 4,
      "text": "GET /resource HTTP/1.1 Host: server.example.com Authorization: Bearer mF_9.B5f-4.1JqM",
      "ja": "Get /Resource HTTP /1.1 HOST：server.example.com認証：BEARER MF_9.B5F-4.1JQM"
    },
    {
      "indent": 3,
      "text": "The syntax of the Authorization header field for this scheme follows the usage of the Basic scheme defined in Section 2 of [RFC2617]. Note that, as with Basic, it does not conform to the generic syntax defined in Section 1.2 of [RFC2617] but is compatible with the general authentication framework in HTTP 1.1 Authentication [RFC7235], although it does not follow the preferred practice outlined therein in order to reflect existing deployments. The syntax for Bearer credentials is as follows:",
      "ja": "このスキームの認証ヘッダーフィールドの構文は、[RFC2617]のセクション2で定義されている基本スキームの使用に従います。Basicと同様に、[RFC2617]のセクション1.2で定義されている一般的な構文に準拠するのではなく、HTTP 1.1認証[RFC7235]の一般的な認証フレームワークと互換性がありますが、既存の展開を反映するために概説されている好ましいプラクティスに従うことはありません。Bearer資格情報の構文は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "b64token    = 1*( ALPHA / DIGIT /\n                 \"-\" / \".\" / \"_\" / \"~\" / \"+\" / \"/\" ) *\"=\"\ncredentials = \"Bearer\" 1*SP b64token",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Clients SHOULD make authenticated requests with a bearer token using the Authorization request header field with the Bearer HTTP authorization scheme. Resource servers MUST support this method.",
      "ja": "クライアントは、Bearer HTTP認証スキームを使用して承認要求ヘッダーフィールドを使用して、Bearerトークンで認証されたリクエストを行う必要があります。リソースサーバーはこの方法をサポートする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.1.2. Form-Encoded Content Parameter",
      "section_title": true,
      "ja": "5.2.1.2. フォームエンコードコンテンツパラメーター"
    },
    {
      "indent": 3,
      "text": "When sending the access token in the HTTP request content, the client adds the access token to the request content using the access_token parameter. The client MUST NOT use this method unless all of the following conditions are met:",
      "ja": "HTTP要求コンテンツでアクセストークンを送信するとき、クライアントはAccess_Tokenパラメーターを使用してアクセストークンを要求コンテンツに追加します。次の条件のすべてが満たされない限り、クライアントはこの方法を使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "* The HTTP request includes the Content-Type header field set to application/x-www-form-urlencoded.",
      "ja": "* HTTP要求には、アプリケーション/X-WWW-Form-Urlencodedに設定されたコンテンツタイプのヘッダーフィールドが含まれています。"
    },
    {
      "indent": 3,
      "text": "* The content follows the encoding requirements of the application/ x-www-form-urlencoded content-type as defined by the URL Living Standard [WHATWG.URL].",
      "ja": "* コンテンツは、URLリビング標準[Whatwg.url]で定義されているアプリケーション/ x-www-form-urlencodedコンテンツタイプのエンコード要件に従います。"
    },
    {
      "indent": 3,
      "text": "* The HTTP request content is single-part.",
      "ja": "* HTTPリクエストコンテンツはシングルパートです。"
    },
    {
      "indent": 3,
      "text": "* The content to be encoded in the request MUST consist entirely of ASCII [USASCII] characters.",
      "ja": "* リクエストでエンコードされるコンテンツは、完全にASCII [USASCII]文字で構成されている必要があります。"
    },
    {
      "indent": 3,
      "text": "* The HTTP request method is one for which the content has defined semantics. In particular, this means that the GET method MUST NOT be used.",
      "ja": "* HTTP要求方法は、コンテンツがセマンティクスを定義した方法です。特に、これは、GETメソッドを使用してはならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "The content MAY include other request-specific parameters, in which case the access_token parameter MUST be properly separated from the request-specific parameters using & character(s) (ASCII code 38).",
      "ja": "コンテンツには、他のリクエスト固有のパラメーターが含まれる場合があります。この場合、Access_Tokenパラメーターは、＆文字を使用してリクエスト固有のパラメーターから適切に分離する必要があります（ASCIIコード38）。"
    },
    {
      "indent": 3,
      "text": "For example, the client makes the following HTTP request using transport-layer security:",
      "ja": "たとえば、クライアントは、トランスポート層セキュリティを使用して次のHTTP要求を行います。"
    },
    {
      "indent": 3,
      "text": "POST /resource HTTP/1.1 Host: server.example.com Content-Type: application/x-www-form-urlencoded",
      "ja": "投稿/リソースhttp/1.1ホスト：server.example.com Content-Type：Application/x-www-form-urlencoded"
    },
    {
      "indent": 3,
      "text": "access_token=mF_9.B5f-4.1JqM",
      "ja": "Access_Token = MF_9.B5F-4.1JQM"
    },
    {
      "indent": 3,
      "text": "The application/x-www-form-urlencoded method SHOULD NOT be used except in application contexts where participating clients do not have access to the Authorization request header field. Resource servers MAY support this method.",
      "ja": "アプリケーション/x-www-form-urlencodedメソッドは、参加しているクライアントが承認要求ヘッダーフィールドにアクセスできないアプリケーションコンテキストを除き、使用しないでください。リソースサーバーはこの方法をサポートする場合があります。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Access Token Validation",
      "section_title": true,
      "ja": "5.2.2. アクセストークン検証"
    },
    {
      "indent": 3,
      "text": "After receiving the access token, the resource server MUST check that the access token is not yet expired, is authorized to access the requested resource, was issued with the appropriate scope, and meets other policy requirements of the resource server to access the protected resource.",
      "ja": "アクセストークンを受信した後、リソースサーバーは、アクセストークンがまだ期限切れになっていないことを確認する必要があり、要求されたリソースにアクセスし、適切な範囲で発行され、リソースサーバーの他のポリシー要件を満たして保護されたリソースにアクセスします。"
    },
    {
      "indent": 3,
      "text": "Access tokens generally fall into two categories: reference tokens or self-encoded tokens. Reference tokens can be validated by querying the authorization server or looking up the token in a token database, whereas self-encoded tokens contain the authorization information in an encrypted and/or signed string which can be extracted by the resource server.",
      "ja": "アクセストークンは通常、トークンまたは自己エンコードトークンの2つのカテゴリに分類されます。リファレンストークンは、承認サーバーをクエリするか、トークンデータベースでトークンを検索することで検証できますが、自己エンコードされたトークンには、リソースサーバーが抽出できる暗号化および/または署名された文字列に承認情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "A standardized method to query the authorization server to check the validity of an access token is defined in Token Introspection ([RFC7662]).",
      "ja": "アクセストークンの有効性を確認するための認証サーバーを照会する標準化された方法は、トークン内省で定義されています（[RFC7662]）。"
    },
    {
      "indent": 3,
      "text": "A standardized method of encoding information in a token string is defined in JWT Profile for Access Tokens ([RFC9068]).",
      "ja": "トークン文字列内の情報をエンコードする標準化された方法は、アクセストークンのJWTプロファイルで定義されています（[RFC9068]）。"
    },
    {
      "indent": 3,
      "text": "See Section 7.1 for additional considerations around creating and validating access tokens.",
      "ja": "アクセストークンの作成と検証に関する追加の考慮事項については、セクション7.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.3. The WWW-Authenticate Response Header Field",
      "section_title": true,
      "ja": "5.2.3. www-authenticate応答ヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "If the protected resource request does not include authentication credentials or does not contain an access token that enables access to the protected resource, the resource server MUST include the HTTP WWW-Authenticate response header field; it MAY include it in response to other conditions as well. The WWW-Authenticate header field uses the framework defined by HTTP/1.1 [RFC7235].",
      "ja": "保護されたリソース要求に認証資格情報が含まれていないか、保護されたリソースへのアクセスを可能にするアクセストークンが含まれていない場合、リソースサーバーにはHTTP www-authenticate応答ヘッダーフィールドを含める必要があります。他の条件にも応えてそれを含めることができます。www-authenticateヘッダーフィールドは、HTTP/1.1 [RFC7235]で定義されたフレームワークを使用します。"
    },
    {
      "indent": 3,
      "text": "All challenges for this token type MUST use the auth-scheme value Bearer. This scheme MUST be followed by one or more auth-param values. The auth-param attributes used or defined by this specification for this token type are as follows. Other auth-param attributes MAY be used as well.",
      "ja": "このトークンタイプのすべての課題は、Auth-Scheme Value Bearerを使用する必要があります。このスキームには、1つ以上のAuth-Param値が続く必要があります。このトークンタイプのこの仕様で使用または定義されたAuth-Param属性は次のとおりです。他のAuth-Param属性も使用できます。"
    },
    {
      "indent": 3,
      "text": "A realm attribute MAY be included to indicate the scope of protection in the manner described in HTTP/1.1 [RFC7235]. The realm attribute MUST NOT appear more than once.",
      "ja": "HTTP/1.1 [RFC7235]に記載されている方法での保護範囲を示すために、レルム属性を含めることができます。レルム属性は、複数回表示してはなりません。"
    },
    {
      "indent": 3,
      "text": "The scope attribute is defined in Section 3.2.2.1. The scope attribute is a space-delimited list of case-sensitive scope values indicating the required scope of the access token for accessing the requested resource. scope values are implementation defined; there is no centralized registry for them; allowed values are defined by the authorization server. The order of scope values is not significant. In some cases, the scope value will be used when requesting a new access token with sufficient scope of access to utilize the protected resource. Use of the scope attribute is OPTIONAL. The scope attribute MUST NOT appear more than once. The scope value is intended for programmatic use and is not meant to be displayed to end-users.",
      "ja": "スコープ属性は、セクション3.2.2.1で定義されています。スコープ属性は、要求されたリソースにアクセスするためにアクセストークンに必要なスコープを示すケースに敏感なスコープ値のスペース削除リストです。スコープ値は実装定義です。それらのための集中登録はありません。許可された値は、承認サーバーによって定義されます。スコープ値の順序は重要ではありません。場合によっては、保護されたリソースを利用するのに十分なアクセス範囲を備えた新しいアクセストークンを要求するときにスコープ値が使用されます。スコープ属性の使用はオプションです。スコープ属性は、複数回表示してはなりません。スコープ値はプログラムの使用を目的としており、エンドユーザーに表示されることを意図していません。"
    },
    {
      "indent": 3,
      "text": "Two example scope values follow; these are taken from the OpenID Connect [OpenID.Messages] and the Open Authentication Technology Committee (OATC) Online Multimedia Authorization Protocol [OMAP] OAuth 2.0 use cases, respectively:",
      "ja": "2つの例の範囲値が続きます。これらは、OpenID Connect [OpenID.Messages]およびOpen Authentication Technology Committee（OATC）オンラインマルチメディア認証プロトコル[OMAP] OAuth 2.0ユースケースから取得しています。"
    },
    {
      "indent": 3,
      "text": "scope=\"openid profile email\"\nscope=\"urn:example:channel=HBO&urn:example:rating=G,PG-13\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the protected resource request included an access token and failed authentication, the resource server SHOULD include the error attribute to provide the client with the reason why the access request was declined. The parameter value is described in Section 5.2.4. In addition, the resource server MAY include the error_description attribute to provide developers a human-readable explanation that is not meant to be displayed to end-users. It also MAY include the error_uri attribute with an absolute URI identifying a human-readable web page explaining the error. The error, error_description, and error_uri attributes MUST NOT appear more than once.",
      "ja": "保護されたリソース要求にアクセストークンと障害認証が含まれている場合、リソースサーバーにエラー属性を含める必要があります。クライアントにアクセス要求が拒否された理由を提供します。パラメーター値は、セクション5.2.4で説明されています。さらに、リソースサーバーには、ERROR_Description属性を含めて、開発者にエンドユーザーに表示されることを意図していない人間の読み取り可能な説明を提供できます。また、エラーを説明する人間が読むことができるWebページを識別する絶対的なURIを備えたERROR_URI属性を含めることもできます。エラー、error_description、およびerror_uri属性は、複数回表示されない必要があります。"
    },
    {
      "indent": 3,
      "text": "Values for the scope attribute (specified in Appendix A.4) MUST NOT include characters outside the set %x21 / %x23-5B / %x5D-7E for representing scope values and %x20 for delimiters between scope values. Values for the error and error_description attributes (specified in Appendix A.7 and Appendix A.8) MUST NOT include characters outside the set %x20-21 / %x23-5B / %x5D-7E. Values for the error_uri attribute (specified in Appendix A.9 of) MUST conform to the URI-reference syntax and thus MUST NOT include characters outside the set %x21 / %x23-5B / %x5D-7E.",
      "ja": "スコープ属性の値（付録A.4で指定）は、スコープ値を表すためにセット％x21 /％x23-5b /％x5d-7eの外側の文字を、スコープ値間の区切り文字に％x20を含めるべきではありません。エラーとERROR_Description属性の値（付録A.7および付録A.8で指定）は、セット％x20-21 /％x23-5b /％x5d-7eの外側の文字を含めてはなりません。ERROR_URI属性の値（付録A.9で指定）は、URI-Referenceの構文に準拠する必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, in response to a protected resource request without authentication:",
      "ja": "たとえば、認証なしの保護されたリソース要求に応じて："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 401 Unauthorized WWW-Authenticate: Bearer realm=\"example\"",
      "ja": "HTTP/1.1 401不正www-authenticate：Bearer Realm = \"Example\""
    },
    {
      "indent": 3,
      "text": "And in response to a protected resource request with an authentication attempt using an expired access token:",
      "ja": "そして、期限切れのアクセストークンを使用した認証試行を使用した保護されたリソース要求に応じて："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 401 Unauthorized WWW-Authenticate: Bearer realm=\"example\", error=\"invalid_token\", error_description=\"The access token expired\"",
      "ja": "http/1.1 401不正www-authenticate：bearer remolm = \"example\"、error = \"invalid_token\"、error_description = \"アクセストークンの期限切れ\""
    },
    {
      "indent": 0,
      "text": "5.2.4. Error Codes",
      "section_title": true,
      "ja": "5.2.4. エラーコード"
    },
    {
      "indent": 3,
      "text": "When a request fails, the resource server responds using the appropriate HTTP status code (typically, 400, 401, 403, or 405) and includes one of the following error codes in the response:",
      "ja": "リクエストが失敗すると、リソースサーバーは適切なHTTPステータスコード（通常、400、401、403、または405）を使用して応答し、応答に次のエラーコードのいずれかを含めます。"
    },
    {
      "indent": 3,
      "text": "\"invalid_request\": The request is missing a required parameter, includes an unsupported parameter or parameter value, repeats the same parameter, uses more than one method for including an access token, or is otherwise malformed. The resource server SHOULD respond with the HTTP 400 (Bad Request) status code.",
      "ja": "「Invalid_Request」：要求には、必要なパラメーターが欠落しています。サポートされていないパラメーターまたはパラメーター値が含まれます。リソースサーバーは、HTTP 400（悪い要求）ステータスコードで応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "\"invalid_token\": The access token provided is expired, revoked, malformed, or invalid for other reasons. The resource SHOULD respond with the HTTP 401 (Unauthorized) status code. The client MAY request a new access token and retry the protected resource request.",
      "ja": "「Invalid_token」：提供されたアクセストークンは、他の理由で有効期限が切れたり、取り消されたり、不正されたり、無効です。リソースは、HTTP 401（不正）ステータスコードで応答する必要があります。クライアントは、新しいアクセストークンを要求し、保護されたリソースリクエストを再試行する場合があります。"
    },
    {
      "indent": 3,
      "text": "\"insufficient_scope\": The request requires higher privileges",
      "ja": "「不十分な_scope」：リクエストには、より高い特権が必要です"
    },
    {
      "indent": 6,
      "text": "(scopes) than provided by the scopes granted to the client and represented by the access token. The resource server SHOULD respond with the HTTP 403 (Forbidden) status code and MAY include the scope attribute with the scope necessary to access the protected resource.",
      "ja": "（スコープ）クライアントに付与され、アクセストークンで表されるスコープによって提供されるよりも。リソースサーバーは、HTTP 403（FORBIDDEN）ステータスコードで応答する必要があり、保護されたリソースにアクセスするために必要なスコープにスコープ属性を含めることができます。"
    },
    {
      "indent": 3,
      "text": "If the request lacks any authentication information (e.g., the client was unaware that authentication is necessary or attempted using an unsupported authentication method), the resource server SHOULD NOT include an error code or other error information.",
      "ja": "リクエストに認証情報がない場合（たとえば、クライアントは、サポートされていない認証方法を使用して認証が必要または試行されることをクライアントに知らなかった場合）、リソースサーバーにはエラーコードやその他のエラー情報を含めるべきではありません。"
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 401 Unauthorized WWW-Authenticate: Bearer realm=\"example\"",
      "ja": "HTTP/1.1 401不正www-authenticate：Bearer Realm = \"Example\""
    },
    {
      "indent": 0,
      "text": "5.3. Error Response",
      "section_title": true,
      "ja": "5.3. エラー応答"
    },
    {
      "indent": 3,
      "text": "If a resource access request fails, the resource server SHOULD inform the client of the error. The method by which the resource server does this is determined by the particular token type, such as the description of Bearer tokens in Section 5.2.4.",
      "ja": "リソースアクセス要求が失敗した場合、リソースサーバーはクライアントにエラーを通知する必要があります。リソースサーバーがこれを行う方法は、セクション5.2.4のベアラートークンの説明など、特定のトークンタイプによって決定されます。"
    },
    {
      "indent": 0,
      "text": "5.3.1. Extension Token Types",
      "section_title": true,
      "ja": "5.3.1. 拡張トークンタイプ"
    },
    {
      "indent": 3,
      "text": "[RFC6750] establishes a common registry in Section 11.4 of [RFC6749] for error values to be shared among OAuth token authentication schemes.",
      "ja": "[RFC6750]は、OAUTHトークン認証スキーム間でエラー値を共有するために、[RFC6749]のセクション11.4に共通のレジストリを確立します。"
    },
    {
      "indent": 3,
      "text": "New authentication schemes designed primarily for OAuth token authentication SHOULD define a mechanism for providing an error status code to the client, in which the error values allowed are registered in the error registry established by this specification.",
      "ja": "主にOAuthトークン認証向けに設計された新しい認証スキームは、クライアントにエラーステータスコードを提供するメカニズムを定義する必要があります。クライアントには、許可されたエラー値がこの仕様によって確立されたエラーレジストリに登録されます。"
    },
    {
      "indent": 3,
      "text": "Such schemes MAY limit the set of valid error codes to a subset of the registered values. If the error code is returned using a named parameter, the parameter name SHOULD be error.",
      "ja": "このようなスキームは、有効なエラーコードのセットを登録値のサブセットに制限する場合があります。名前付きパラメーターを使用してエラーコードが返される場合、パラメーター名はエラーにする必要があります。"
    },
    {
      "indent": 3,
      "text": "Other schemes capable of being used for OAuth token authentication, but not primarily designed for that purpose, MAY bind their error values to the registry in the same manner.",
      "ja": "OAuthトークン認証に使用できる他のスキームは、主にその目的のために設計されていないため、エラー値を同じ方法でレジストリに結合する場合があります。"
    },
    {
      "indent": 3,
      "text": "New authentication schemes MAY choose to also specify the use of the error_description and error_uri parameters to return error information in a manner parallel to their usage in this specification.",
      "ja": "新しい認証スキームは、この仕様の使用方法と並行してエラー情報を返すために、error_descriptionとerror_uriパラメーターの使用を指定することも選択できます。"
    },
    {
      "indent": 0,
      "text": "5.4. Sender-Constrained Access Tokens",
      "section_title": true,
      "ja": "5.4. 送信者に制約のあるアクセストークン"
    },
    {
      "indent": 3,
      "text": "A sender-constrained access token scopes the applicability of an access token to a certain sender. This sender is obliged to demonstrate knowledge of a certain secret as prerequisite for the acceptance of that access token at the recipient (e.g., a resource server).",
      "ja": "送信者に制約のあるアクセストークンは、特定の送信者へのアクセストークンの適用性をスコープします。この送信者は、受信者でのアクセストークン（リソースサーバーなど）の受け入れの前提条件として特定の秘密の知識を示す義務があります。"
    },
    {
      "indent": 3,
      "text": "Authorization and resource servers SHOULD use mechanisms for sender-constraining access tokens, such as Mutual TLS for OAuth 2.0 [RFC8705] or OAuth Demonstration of Proof of Possession (DPoP) [I-D.ietf-oauth-dpop]. See [I-D.ietf-oauth-security-topics] Section 4.10.1, to prevent misuse of stolen and leaked access tokens.",
      "ja": "承認とリソースサーバーは、OAUTH 2.0 [RFC8705]の相互TLSや所有証明の実証（DPOP）[I-D.IETF-OAUTH-DPOP]など、送信者に制約のあるアクセストークンにメカニズムを使用する必要があります。[i-d.ietf-oauth-security-topics]セクション4.10.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED to use end-to-end TLS between the client and the resource server. If TLS traffic needs to be terminated at an intermediary, refer to Section 4.13 of [I-D.ietf-oauth-security-topics] for further security advice.",
      "ja": "クライアントとリソースサーバーの間でエンドツーエンドのTLSを使用することをお勧めします。TLSトラフィックを仲介者で終了する必要がある場合は、さらなるセキュリティアドバイスについては、[i-d.ietf-oauth-security-topics]のセクション4.13を参照してください。"
    },
    {
      "indent": 0,
      "text": "6. Extensibility",
      "section_title": true,
      "ja": "6. 拡張性"
    },
    {
      "indent": 0,
      "text": "6.1. Defining Access Token Types",
      "section_title": true,
      "ja": "6.1. アクセストークンタイプの定義"
    },
    {
      "indent": 3,
      "text": "Access token types can be defined in one of two ways: registered in the Access Token Types registry (following the procedures in Section 11.1 of [RFC6749]), or by using a unique absolute URI as its name.",
      "ja": "アクセストークンタイプは、アクセストークンタイプレジストリ（[RFC6749]のセクション11.1の手順に従う）に登録されている2つの方法のいずれかで定義できます。または、その名前として一意の絶対URIを使用して。"
    },
    {
      "indent": 3,
      "text": "Types utilizing a URI name SHOULD be limited to vendor-specific implementations that are not commonly applicable, and are specific to the implementation details of the resource server where they are used.",
      "ja": "URI名を使用するタイプは、一般的に適用されないベンダー固有の実装に限定され、使用されているリソースサーバーの実装詳細に固有のベンダー固有の実装に限定する必要があります。"
    },
    {
      "indent": 3,
      "text": "All other types MUST be registered. Type names MUST conform to the type-name ABNF. If the type definition includes a new HTTP authentication scheme, the type name SHOULD be identical to the HTTP authentication scheme name (as defined by [RFC2617]). The token type example is reserved for use in examples.",
      "ja": "他のすべてのタイプを登録する必要があります。タイプ名は、タイプ名ABNFに準拠する必要があります。タイプ定義に新しいHTTP認証スキームが含まれている場合、タイプ名はHTTP認証スキーム名（[RFC2617]で定義されている）と同一である必要があります。トークンタイプの例は、例で使用するために予約されています。"
    },
    {
      "indent": 3,
      "text": "type-name  = 1*name-char\nname-char  = \"-\" / \".\" / \"_\" / DIGIT / ALPHA",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.2. Defining New Endpoint Parameters",
      "section_title": true,
      "ja": "6.2. 新しいエンドポイントパラメーターの定義"
    },
    {
      "indent": 3,
      "text": "New request or response parameters for use with the authorization endpoint or the token endpoint are defined and registered in the OAuth Parameters registry following the procedure in Section 11.2 of [RFC6749].",
      "ja": "認証エンドポイントまたはトークンエンドポイントで使用する新しい要求または応答パラメーターは、[RFC6749]のセクション11.2の手順に従って、OAUTHパラメーターレジストリに定義および登録されます。"
    },
    {
      "indent": 3,
      "text": "Parameter names MUST conform to the param-name ABNF, and parameter values syntax MUST be well-defined (e.g., using ABNF, or a reference to the syntax of an existing parameter).",
      "ja": "パラメーター名は、パラメーター名ABNFに準拠する必要があり、パラメーター値構文は明確に定義する必要があります（たとえば、ABNFを使用するか、既存のパラメーターの構文を参照）。"
    },
    {
      "indent": 3,
      "text": "param-name  = 1*name-char\nname-char   = \"-\" / \".\" / \"_\" / DIGIT / ALPHA",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Unregistered vendor-specific parameter extensions that are not commonly applicable and that are specific to the implementation details of the authorization server where they are used SHOULD utilize a vendor-specific prefix that is not likely to conflict with other registered values (e.g., begin with 'companyname_').",
      "ja": "一般的に適用されず、使用されている承認サーバーの実装の詳細に固有の未登録のベンダー固有のパラメーター拡張機能は、他の登録値と競合する可能性が高いベンダー固有のプレフィックスを利用する必要があります（例えば、「CompanyName_」と開始する）。"
    },
    {
      "indent": 0,
      "text": "6.3. Defining New Authorization Grant Types",
      "section_title": true,
      "ja": "6.3. 新しい承認助成金タイプの定義"
    },
    {
      "indent": 3,
      "text": "New authorization grant types can be defined by assigning them a unique absolute URI for use with the grant_type parameter. If the extension grant type requires additional token endpoint parameters, they MUST be registered in the OAuth Parameters registry as described by Section 11.2 of [RFC6749].",
      "ja": "新しい承認補助金の種類は、grant_typeパラメーターで使用するための一意の絶対URIを割り当てることで定義できます。拡張補助金タイプに追加のトークンエンドポイントパラメーターが必要な場合、[RFC6749]のセクション11.2で説明されているように、OAUTHパラメーターレジストリに登録する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.4. Defining New Authorization Endpoint Response Types",
      "section_title": true,
      "ja": "6.4. 新しい承認エンドポイント応答タイプの定義"
    },
    {
      "indent": 3,
      "text": "New response types for use with the authorization endpoint are defined and registered in the Authorization Endpoint Response Types registry following the procedure in Section 11.3 of [RFC6749]. Response type names MUST conform to the response-type ABNF.",
      "ja": "認証エンドポイントで使用する新しい応答タイプは、[RFC6749]のセクション11.3の手順に従って、承認エンドポイント応答タイプのレジストリに定義および登録されます。応答タイプ名は、応答型ABNFに準拠する必要があります。"
    },
    {
      "indent": 3,
      "text": "response-type  = response-name *( SP response-name )\nresponse-name  = 1*response-char\nresponse-char  = \"_\" / DIGIT / ALPHA",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If a response type contains one or more space characters (%x20), it is compared as a space-delimited list of values in which the order of values does not matter. Only one order of values can be registered, which covers all other arrangements of the same set of values.",
      "ja": "応答タイプに1つ以上のスペース文字（％x20）が含まれている場合、値の順序が重要ではない値の空間決定リストとして比較されます。同じ値のセットの他のすべての配置をカバーする値の1つの順序のみを登録できます。"
    },
    {
      "indent": 3,
      "text": "For example, an extension can define and register the code other_token response type. Once registered, the same combination cannot be registered as other_token code, but both values can be used to denote the same response type.",
      "ja": "たとえば、拡張機能はコードを定義および登録できます。登録されると、同じ組み合わせをother_tokenコードと登録することはできませんが、両方の値を使用して同じ応答タイプを示すことができます。"
    },
    {
      "indent": 0,
      "text": "6.5. Defining Additional Error Codes",
      "section_title": true,
      "ja": "6.5. 追加のエラーコードの定義"
    },
    {
      "indent": 3,
      "text": "In cases where protocol extensions (i.e., access token types, extension parameters, or extension grant types) require additional error codes to be used with the authorization code grant error response (Section 4.1.2.1), the token error response (Section 3.2.3.1), or the resource access error response (Section 5.3), such error codes MAY be defined.",
      "ja": "プロトコル拡張（つまり、アクセストークンタイプ、拡張パラメーター、または拡張助成金タイプ）が必要な場合、認証コード助成金エラー応答（セクション4.1.2.1）、トークンエラー応答（セクション3.2.3.1）、またはリソースアクセスエラー応答（セクション5.3）、またはそのようなエラーコードは定義される場合があります。"
    },
    {
      "indent": 3,
      "text": "Extension error codes MUST be registered (following the procedures in Section 11.4 of [RFC6749]) if the extension they are used in conjunction with is a registered access token type, a registered endpoint parameter, or an extension grant type. Error codes used with unregistered extensions MAY be registered.",
      "ja": "拡張エラーコードを登録する必要があります（[RFC6749]のセクション11.4の手順に従ってください）。拡張機能が登録されているアクセストークンタイプ、登録エンドポイントパラメーター、または拡張補助金タイプである場合。未登録の拡張機能で使用されるエラーコードが登録される場合があります。"
    },
    {
      "indent": 3,
      "text": "Error codes MUST conform to the error ABNF and SHOULD be prefixed by an identifying name when possible. For example, an error identifying an invalid value set to the extension parameter example SHOULD be named example_invalid.",
      "ja": "エラーコードはエラーABNFに準拠する必要があり、可能な場合は識別名が付いている必要があります。たとえば、拡張機能パラメーターの例に設定された無効な値を識別するエラーは、example_invalidという名前にする必要があります。"
    },
    {
      "indent": 3,
      "text": "error      = 1*error-char\nerror-char = %x20-21 / %x23-5B / %x5D-7E",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "As a flexible and extensible framework, OAuth's security considerations depend on many factors. The following sections provide implementers with security guidelines focused on the three client profiles described in Section 2.1: web application, browser-based application, and native application.",
      "ja": "柔軟で拡張可能なフレームワークとして、OAUTHのセキュリティ上の考慮事項は多くの要因に依存しています。次のセクションでは、セクション2.1で説明されている3つのクライアントプロファイル、Webアプリケーション、ブラウザーベースのアプリケーション、およびネイティブアプリケーションに焦点を当てたセキュリティガイドラインを実装者に提供します。"
    },
    {
      "indent": 3,
      "text": "A comprehensive OAuth security model and analysis, as well as background for the protocol design, is provided by [RFC6819] and [I-D.ietf-oauth-security-topics].",
      "ja": "包括的なOAUTHセキュリティモデルと分析、およびプロトコル設計の背景は、[RFC6819]および[I-D.IETF-OAUTH-SECURITY-TOPICS]によって提供されます。"
    },
    {
      "indent": 0,
      "text": "7.1. Access Token Security Considerations",
      "section_title": true,
      "ja": "7.1. トークンのセキュリティ上の考慮事項にアクセスします"
    },
    {
      "indent": 0,
      "text": "7.1.1. Security Threats",
      "section_title": true,
      "ja": "7.1.1. セキュリティの脅威"
    },
    {
      "indent": 3,
      "text": "The following list presents several common threats against protocols utilizing some form of tokens. This list of threats is based on NIST Special Publication 800-63 [NIST800-63].",
      "ja": "次のリストは、何らかの形のトークンを利用するプロトコルに対するいくつかの一般的な脅威を示しています。この脅威のリストは、NIST Special Publication 800-63 [NIST800-63]に基づいています。"
    },
    {
      "indent": 0,
      "text": "7.1.1.1. Access token manufacture/modification",
      "section_title": true,
      "ja": "7.1.1.1. アクセストークン製造/変更"
    },
    {
      "indent": 3,
      "text": "An attacker may generate a bogus access token or modify the token contents (such as the authentication or attribute statements) of an existing token, causing the resource server to grant inappropriate access to the client. For example, an attacker may modify the token to extend the validity period; a malicious client may modify the assertion to gain access to information that they should not be able to view.",
      "ja": "攻撃者は、既存のトークンのトークンコンテンツ（認証や属性ステートメントなど）を偽のアクセストークンを生成または変更して、リソースサーバーにクライアントへの不適切なアクセスを許可します。たとえば、攻撃者はトークンを変更して有効期間を延長する場合があります。悪意のあるクライアントは、視聴できない情報にアクセスするために、アサーションを変更する場合があります。"
    },
    {
      "indent": 0,
      "text": "7.1.1.2. Access token disclosure",
      "section_title": true,
      "ja": "7.1.1.2. アクセストークン開示"
    },
    {
      "indent": 3,
      "text": "Access tokens may contain authentication and attribute statements that include sensitive information.",
      "ja": "アクセストークンには、機密情報を含む認証と属性ステートメントが含まれる場合があります。"
    },
    {
      "indent": 0,
      "text": "7.1.1.3. Access token redirect",
      "section_title": true,
      "ja": "7.1.1.3. アクセストークンリダイレクト"
    },
    {
      "indent": 3,
      "text": "An attacker uses an access token generated for consumption by one resource server to gain access to a different resource server that mistakenly believes the token to be for it.",
      "ja": "攻撃者は、1つのリソースサーバーによって消費用に生成されたアクセストークンを使用して、トークンがそのためであると誤って信じている別のリソースサーバーへのアクセスを獲得します。"
    },
    {
      "indent": 0,
      "text": "7.1.1.4. Access token replay",
      "section_title": true,
      "ja": "7.1.1.4. アクセストークンリプレイ"
    },
    {
      "indent": 3,
      "text": "An attacker attempts to use an access token that has already been used with that resource server in the past.",
      "ja": "攻撃者は、過去にそのリソースサーバーですでに使用されていたアクセストークンを使用しようとします。"
    },
    {
      "indent": 0,
      "text": "7.1.2. Threat Mitigation",
      "section_title": true,
      "ja": "7.1.2. 脅威緩和"
    },
    {
      "indent": 3,
      "text": "A large range of threats can be mitigated by protecting the contents of the access token by using a digital signature.",
      "ja": "デジタル署名を使用して、アクセストークンの内容を保護することにより、さまざまな脅威を軽減できます。"
    },
    {
      "indent": 3,
      "text": "Alternatively, a bearer token can contain a reference to authorization information, rather than encoding the information directly. Using a reference may require an extra interaction between a resource server and authorization server to resolve the reference to the authorization information. The mechanics of such an interaction are not defined by this specification, but one such mechanism is defined in Token Introspection [RFC7662].",
      "ja": "あるいは、ベアラートークンには、情報を直接エンコードするのではなく、認証情報への参照を含めることができます。参照を使用すると、リソースサーバーと承認サーバー間の追加の対話が必要になる場合があり、認証情報への参照を解決します。このような相互作用のメカニズムは、この仕様では定義されていませんが、そのようなメカニズムの1つはトークン内省[RFC7662]で定義されています。"
    },
    {
      "indent": 3,
      "text": "This document does not specify the encoding or the contents of the access token; hence, detailed recommendations about the means of guaranteeing access token integrity protection are outside the scope of this specification. One example of an encoding and signing mechanism for access tokens is described in JSON Web Token Profile for Access Tokens [RFC9068].",
      "ja": "このドキュメントでは、アクセストークンのエンコードまたは内容を指定しません。したがって、アクセストークンの整合性保護を保証する手段に関する詳細な推奨事項は、この仕様の範囲外です。アクセストークンのエンコーディングおよび署名メカニズムの1つの例は、アクセストークン[RFC9068]のJSON Webトークンプロファイルで説明されています。"
    },
    {
      "indent": 3,
      "text": "To deal with access token redirects, it is important for the authorization server to include the identity of the intended recipients (the audience), typically a single resource server (or a list of resource servers), in the token. Restricting the use of the token to a specific scope is also RECOMMENDED.",
      "ja": "アクセストークンリダイレクトに対処するには、認証サーバーがトークンに単一のリソースサーバー（またはリソースサーバーのリスト）（通常、単一のリソースサーバー（またはリソースサーバーのリスト））のIDをトークンに含めることが重要です。トークンの使用を特定の範囲に制限することもお勧めします。"
    },
    {
      "indent": 3,
      "text": "If cookies are transmitted without TLS protection, any information contained in them is at risk of disclosure. Therefore, Bearer tokens MUST NOT be stored in cookies that can be sent in the clear, as any information in them is at risk of disclosure. See \"HTTP State Management Mechanism\" [RFC6265] for security considerations about cookies.",
      "ja": "CookieがTLS保護なしで送信される場合、それらに含まれる情報は開示のリスクがあります。したがって、ベアラートークンは、それらの情報が開示のリスクがあるため、明確に送信できるCookieに保管してはなりません。Cookieに関するセキュリティに関する考慮事項については、「HTTP状態管理メカニズム」[RFC6265]を参照してください。"
    },
    {
      "indent": 3,
      "text": "In some deployments, including those utilizing load balancers, the TLS connection to the resource server terminates prior to the actual server that provides the resource. This could leave the token unprotected between the front-end server where the TLS connection terminates and the back-end server that provides the resource. In such deployments, sufficient measures MUST be employed to ensure confidentiality of the access token between the front-end and back-end servers; encryption of the token is one such possible measure.",
      "ja": "ロードバランサーを使用するものを含む一部の展開では、リソースサーバーへのTLS接続は、リソースを提供する実際のサーバーの前に終了します。これにより、TLS接続が終了するフロントエンドサーバーとリソースを提供するバックエンドサーバーの間で、トークンが保護されていない場合があります。このような展開では、フロントエンドサーバーとバックエンドサーバー間のアクセストークンの機密性を確保するために、十分な測定値を採用する必要があります。トークンの暗号化は、そのような可能な尺度の1つです。"
    },
    {
      "indent": 0,
      "text": "7.1.3. Summary of Recommendations",
      "section_title": true,
      "ja": "7.1.3. 推奨事項の概要"
    },
    {
      "indent": 0,
      "text": "7.1.3.1. Safeguard bearer tokens",
      "section_title": true,
      "ja": "7.1.3.1. ベアラートークンを保護します"
    },
    {
      "indent": 3,
      "text": "Client implementations MUST ensure that bearer tokens are not leaked to unintended parties, as they will be able to use them to gain access to protected resources. This is the primary security consideration when using bearer tokens and underlies all the more specific recommendations that follow.",
      "ja": "クライアントの実装は、保護されたリソースにアクセスするためにそれらを使用できるため、ベアラートークンが意図しない当事者に漏れないようにする必要があります。これは、Bearer Tokensを使用し、以下のより具体的な推奨事項の根底にある場合の主要なセキュリティの考慮事項です。"
    },
    {
      "indent": 0,
      "text": "7.1.3.2. Validate TLS certificate chains",
      "section_title": true,
      "ja": "7.1.3.2. TLS証明書チェーンを検証します"
    },
    {
      "indent": 3,
      "text": "The client MUST validate the TLS certificate chain when making requests to protected resources. Failing to do so may enable DNS hijacking attacks to steal the token and gain unintended access.",
      "ja": "クライアントは、保護されたリソースをリクエストするときにTLS証明書チェーンを検証する必要があります。そうしないと、DNSハイジャック攻撃がトークンを盗み、意図しないアクセスを得ることができます。"
    },
    {
      "indent": 0,
      "text": "7.1.3.3. Always use TLS (https)",
      "section_title": true,
      "ja": "7.1.3.3. 常にTLS（https）を使用してください"
    },
    {
      "indent": 3,
      "text": "Clients MUST always use TLS (https) or equivalent transport security when making requests with bearer tokens. Failing to do so exposes the token to numerous attacks that could give attackers unintended access.",
      "ja": "クライアントは、Bearer Tokensでリクエストを行う際に、常にTLS（HTTPS）または同等の輸送セキュリティを使用する必要があります。そうしないと、攻撃者に意図しないアクセスを与える可能性のある多数の攻撃にトークンをさらします。"
    },
    {
      "indent": 0,
      "text": "7.1.3.4. Don't store bearer tokens in HTTP cookies",
      "section_title": true,
      "ja": "7.1.3.4. HTTP Cookieにベアラートークンを保管しないでください"
    },
    {
      "indent": 3,
      "text": "Implementations MUST NOT store bearer tokens within cookies that can be sent in the clear (which is the default transmission mode for cookies). Implementations that do store bearer tokens in cookies MUST take precautions against cross-site request forgery.",
      "ja": "実装は、クリア（Cookieのデフォルト送信モード）で送信できるCookie内にベアラートークンを保存してはなりません。クッキーにベアラートークンを保存する実装は、クロスサイトのリクエスト偽造に対して予防策を講じる必要があります。"
    },
    {
      "indent": 0,
      "text": "7.1.3.5. Issue short-lived bearer tokens",
      "section_title": true,
      "ja": "7.1.3.5. 短命のベアラートークンを発行します"
    },
    {
      "indent": 3,
      "text": "Authorization servers SHOULD issue short-lived bearer tokens, particularly when issuing tokens to clients that run within a web browser or other environments where information leakage may occur. Using short-lived bearer tokens can reduce the impact of them being leaked.",
      "ja": "許可サーバーは、特に情報の漏れが発生する可能性のあるWebブラウザーまたは他の環境内で実行されるクライアントにトークンを発行する場合、短命のベアラートークンを発行する必要があります。短命のベアラートークンを使用すると、それらが漏れているという影響を減らすことができます。"
    },
    {
      "indent": 0,
      "text": "7.1.3.6. Issue scoped bearer tokens",
      "section_title": true,
      "ja": "7.1.3.6. スコープ付きベアラートークンを発行します"
    },
    {
      "indent": 3,
      "text": "Authorization servers SHOULD issue bearer tokens that contain an audience restriction, scoping their use to the intended relying party or set of relying parties.",
      "ja": "承認サーバーは、視聴者の制限を含むベアラートークンを発行し、意図した頼りの当事者または頼る当事者のセットに使用することをスコーピングする必要があります。"
    },
    {
      "indent": 0,
      "text": "7.1.3.7. Don't pass bearer tokens in page URLs",
      "section_title": true,
      "ja": "7.1.3.7. ページURLでベアラートークンを渡さないでください"
    },
    {
      "indent": 3,
      "text": "Bearer tokens MUST NOT be passed in page URLs (for example, as query string parameters). Instead, bearer tokens SHOULD be passed in HTTP message headers or message bodies for which confidentiality measures are taken. Browsers, web servers, and other software may not adequately secure URLs in the browser history, web server logs, and other data structures. If bearer tokens are passed in page URLs, attackers might be able to steal them from the history data, logs, or other unsecured locations.",
      "ja": "ベアラートークンは、ページURL（たとえば、文字列パラメーターとして）に渡されてはなりません。代わりに、ベアラートークンは、機密性の測定が行われるHTTPメッセージヘッダーまたはメッセージ本文で渡す必要があります。ブラウザ、Webサーバー、およびその他のソフトウェアは、ブラウザ履歴、Webサーバーログ、およびその他のデータ構造でURLを適切に保護できない場合があります。ベアラートークンがページURLに渡された場合、攻撃者は履歴データ、ログ、またはその他の無担保の場所からそれらを盗むことができる場合があります。"
    },
    {
      "indent": 0,
      "text": "7.1.4. Access Token Privilege Restriction",
      "section_title": true,
      "ja": "7.1.4. アクセストークン特権制限"
    },
    {
      "indent": 3,
      "text": "The privileges associated with an access token SHOULD be restricted to the minimum required for the particular application or use case. This prevents clients from exceeding the privileges authorized by the resource owner. It also prevents users from exceeding their privileges authorized by the respective security policy. Privilege restrictions also help to reduce the impact of access token leakage.",
      "ja": "アクセストークンに関連付けられている特権は、特定のアプリケーションまたはユースケースに必要な最小値に制限される必要があります。これにより、クライアントはリソース所有者によって承認された特権を超えることができなくなります。また、ユーザーがそれぞれのセキュリティポリシーで承認された特権を超えることを防ぎます。特権制限は、アクセストークンの漏れの影響を減らすのにも役立ちます。"
    },
    {
      "indent": 3,
      "text": "In particular, access tokens SHOULD be restricted to certain resource servers (audience restriction), preferably to a single resource server. To put this into effect, the authorization server associates the access token with certain resource servers and every resource server is obliged to verify, for every request, whether the access token sent with that request was meant to be used for that particular resource server. If not, the resource server MUST refuse to serve the respective request. Clients and authorization servers MAY utilize the parameters scope or resource as specified in this document and [RFC8707], respectively, to determine the resource server they want to access.",
      "ja": "特に、アクセストークンは、特定のリソースサーバー（オーディエンスの制限）、できれば単一のリソースサーバーに制限される必要があります。これを有効にするために、Authorization Serverはアクセストークンを特定のリソースサーバーに関連付け、すべてのリソースサーバーは、そのリクエストで送信されたアクセストークンがその特定のリソースサーバーに使用されることを意図しているかどうかを確認する義務があります。そうでない場合、リソースサーバーはそれぞれのリクエストを提供することを拒否する必要があります。クライアントと承認サーバーは、このドキュメントで指定されているパラメーターの範囲またはリソースをそれぞれ利用し、それぞれアクセスするリソースサーバーを決定することができます。"
    },
    {
      "indent": 3,
      "text": "Additionally, access tokens SHOULD be restricted to certain resources and actions on resource servers or resources. To put this into effect, the authorization server associates the access token with the respective resource and actions and every resource server is obliged to verify, for every request, whether the access token sent with that request was meant to be used for that particular action on the particular resource. If not, the resource server must refuse to serve the respective request. Clients and authorization servers MAY utilize the parameter scope and authorization_details as specified in [RFC9396] to determine those resources and/or actions.",
      "ja": "さらに、アクセストークンは、リソースサーバーまたはリソース上の特定のリソースとアクションに制限される必要があります。これを有効にするために、Authorization Serverはアクセストークンをそれぞれのリソースとアクションに関連付け、すべてのリソースサーバーは、その要求で送信されたアクセストークンが特定のリソースでその特定のアクションに使用されることを意図しているかどうかをすべての要求に対して確認する義務があります。そうでない場合、リソースサーバーはそれぞれのリクエストを提供することを拒否する必要があります。クライアントおよび認証サーバーは、[RFC9396]で指定されているパラメータースコープと承認_Detailsを利用して、これらのリソースおよび/またはアクションを決定できます。"
    },
    {
      "indent": 0,
      "text": "7.2. Client Authentication",
      "section_title": true,
      "ja": "7.2. クライアント認証"
    },
    {
      "indent": 3,
      "text": "Depending on the overall process of client registration and credential lifecycle management, this may affect the confidence an authorization server has in a particular client.",
      "ja": "クライアント登録の全体的なプロセスと資格情報のライフサイクル管理に応じて、これは特定のクライアントに承認サーバーが持っている自信に影響を与える可能性があります。"
    },
    {
      "indent": 3,
      "text": "For example, authentication of a dynamically registered client does not prove the identity of the client, it only ensures that repeated requests to the authorization server were made from the same client instance. Such clients may be limited in terms of which scopes they are allowed to request, or may have other limitations such as shorter token lifetimes.",
      "ja": "たとえば、動的に登録されたクライアントの認証は、クライアントのIDを証明するのではなく、認証サーバーに繰り返しリクエストが同じクライアントインスタンスから作成されたことを保証します。このようなクライアントは、要求が許可されているスコープの点で制限されている場合や、より短いトークン寿命などの他の制限がある場合があります。"
    },
    {
      "indent": 3,
      "text": "In contrast, if there is a registered application whose developer's identity was verified, who signed a contract and is issued a client secret that is only used in a secure backend service, the authorization server might allow this client to request more sensitive scopes or to be issued longer-lasting tokens.",
      "ja": "対照的に、開発者の身元が検証され、契約に署名し、安全なバックエンドサービスでのみ使用されるクライアントの秘密を発行された登録アプリケーションがある場合、承認サーバーは、このクライアントがより機密のスコープを要求したり、長期にわたるトークンを発行したりする可能性があります。"
    },
    {
      "indent": 0,
      "text": "7.3. Client Impersonation",
      "section_title": true,
      "ja": "7.3. クライアントのなりすまし"
    },
    {
      "indent": 3,
      "text": "If a confidential client has its credentials stolen, a malicious client can impersonate the client and obtain access to protected resources.",
      "ja": "機密クライアントが資格情報を盗まれている場合、悪意のあるクライアントはクライアントになりすまして保護されたリソースへのアクセスを取得できます。"
    },
    {
      "indent": 3,
      "text": "The authorization server SHOULD enforce explicit resource owner authentication and provide the resource owner with information about the client and the requested authorization scope and lifetime. It is up to the resource owner to review the information in the context of the current client and to authorize or deny the request.",
      "ja": "Authorization Serverは、明示的なリソース所有者認証を実施し、リソース所有者にクライアントと要求された承認範囲と生涯に関する情報を提供する必要があります。現在のクライアントのコンテキストで情報を確認し、リクエストを承認または拒否するのは、リソース所有者次第です。"
    },
    {
      "indent": 3,
      "text": "The authorization server SHOULD NOT process repeated authorization requests automatically (without active resource owner interaction) without authenticating the client or relying on other measures to ensure that the repeated request comes from the original client and not an impersonator.",
      "ja": "承認サーバーは、クライアントを認証することなく、または他の測定値に依存することなく（アクティブなリソース所有者の相互作用なし）、繰り返しの承認要求を自動的に処理するべきではありません。"
    },
    {
      "indent": 0,
      "text": "7.3.1. Impersonation of Native Apps",
      "section_title": true,
      "ja": "7.3.1. ネイティブアプリのなりすまし"
    },
    {
      "indent": 3,
      "text": "As stated above, the authorization server SHOULD NOT process authorization requests automatically without user consent or interaction, except when the identity of the client can be assured. This includes the case where the user has previously approved an authorization request for a given client ID -- unless the identity of the client can be proven, the request SHOULD be processed as if no previous request had been approved.",
      "ja": "上記のように、クライアントの身元を保証できる場合を除き、承認サーバーは、ユーザーの同意または相互作用なしに認証要求を自動的に処理するべきではありません。これには、ユーザーが特定のクライアントIDの承認要求を以前に承認した場合が含まれます。クライアントの身元が証明できない限り、リクエストは以前のリクエストが承認されていないかのように処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "Measures such as claimed https scheme redirects MAY be accepted by authorization servers as identity proof. Some operating systems may offer alternative platform-specific identity features that MAY be accepted, as appropriate.",
      "ja": "請求されたHTTPSスキームリダイレクトなどの措置は、承認サーバーによって身元証明として受け入れられる場合があります。一部のオペレーティングシステムは、必要に応じて、受け入れられる可能性のある代替プラットフォーム固有のアイデンティティ機能を提供する場合があります。"
    },
    {
      "indent": 0,
      "text": "7.3.2. Access Token Privilege Restriction",
      "section_title": true,
      "ja": "7.3.2. アクセストークン特権制限"
    },
    {
      "indent": 3,
      "text": "The client SHOULD request access tokens with the minimal scope necessary. The authorization server SHOULD take the client identity into account when choosing how to honor the requested scope and MAY issue an access token with fewer scopes than requested.",
      "ja": "クライアントは、必要な最小スコープでアクセストークンを要求する必要があります。承認サーバーは、要求されたスコープを尊重する方法を選択する際にクライアントのIDを考慮し、要求よりも少ないスコープでアクセストークンを発行する場合があります。"
    },
    {
      "indent": 3,
      "text": "The privileges associated with an access token SHOULD be restricted to the minimum required for the particular application or use case. This prevents clients from exceeding the privileges authorized by the resource owner. It also prevents users from exceeding their privileges authorized by the respective security policy. Privilege restrictions also help to reduce the impact of access token leakage.",
      "ja": "アクセストークンに関連付けられている特権は、特定のアプリケーションまたはユースケースに必要な最小値に制限される必要があります。これにより、クライアントはリソース所有者によって承認された特権を超えることができなくなります。また、ユーザーがそれぞれのセキュリティポリシーで承認された特権を超えることを防ぎます。特権制限は、アクセストークンの漏れの影響を減らすのにも役立ちます。"
    },
    {
      "indent": 3,
      "text": "In particular, access tokens SHOULD be restricted to certain resource servers (audience restriction), preferably to a single resource server. To put this into effect, the authorization server associates the access token with certain resource servers and every resource server is obliged to verify, for every request, whether the access token sent with that request was meant to be used for that particular resource server. If not, the resource server MUST refuse to serve the respective request. Clients and authorization servers MAY utilize the parameters scope or resource as specified in [RFC8707], respectively, to determine the resource server they want to access.",
      "ja": "特に、アクセストークンは、特定のリソースサーバー（オーディエンスの制限）、できれば単一のリソースサーバーに制限される必要があります。これを有効にするために、Authorization Serverはアクセストークンを特定のリソースサーバーに関連付け、すべてのリソースサーバーは、そのリクエストで送信されたアクセストークンがその特定のリソースサーバーに使用されることを意図しているかどうかを確認する義務があります。そうでない場合、リソースサーバーはそれぞれのリクエストを提供することを拒否する必要があります。クライアントと承認サーバーは、[RFC8707]でそれぞれ指定されているパラメータースコープまたはリソースを使用して、アクセスするリソースサーバーを決定できます。"
    },
    {
      "indent": 0,
      "text": "7.4. Client Impersonating Resource Owner",
      "section_title": true,
      "ja": "7.4. クライアントはリソースの所有者になりすまします"
    },
    {
      "indent": 3,
      "text": "Resource servers may make access control decisions based on the identity of a resource owner for which an access token was issued, or based on the identity of a client in the client credentials grant. If both options are possible, depending on the details of the implementation, a client's identity may be mistaken for the identity of a resource owner. For example, if a client is able to choose its own client_id during registration with the authorization server, a malicious client may set it to a value identifying an end-user (e.g., a sub value if OpenID Connect is used). If the resource server cannot properly distinguish between access tokens issued to clients and access tokens issued to end-users, the client may then be able to access resource of the end-user.",
      "ja": "リソースサーバーは、アクセストークンが発行されたリソース所有者のIDに基づいて、またはクライアント資格認定の助成金のクライアントの身元に基づいて、アクセス制御決定を行う場合があります。両方のオプションが可能な場合、実装の詳細に応じて、クライアントの身元がリソース所有者のIDと間違っている場合があります。たとえば、クライアントが承認サーバーへの登録中に独自のclient_idを選択できる場合、悪意のあるクライアントは、エンドユーザーを識別する値に設定できます（たとえば、OpenID Connectが使用されている場合はサブ値）。リソースサーバーがクライアントに発行されたアクセストークンとエンドユーザーに発行されたアクセストークンを適切に区別できない場合、クライアントはエンドユーザーのリソースにアクセスできる場合があります。"
    },
    {
      "indent": 3,
      "text": "If the authorization server has a common namespace for client IDs and user identifiers, causing the resource server to be unable to distinguish an access token authorized by a resource owner from an access token authorized by a client itself, authorization servers SHOULD NOT allow clients to influence their client_id or any other Claim if that can cause confusion with a genuine resource owner. Where this cannot be avoided, authorization servers MUST provide other means for the resource server to distinguish between the two types of access tokens.",
      "ja": "Authorization ServerにクライアントIDとユーザー識別子の共通名スペースがある場合、リソースサーバーがクライアント自体によって許可されたアクセストークンから許可されたアクセストークンを区別できなくなった場合、承認サーバーがクライアント_IDまたはその他の主張に影響を与えることはできません。これを避けられない場合、承認サーバーは、リソースサーバーが2種類のアクセストークンを区別するための他の手段を提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.5. Protecting the Authorization Code Flow",
      "section_title": true,
      "ja": "7.5. 承認コードフローの保護"
    },
    {
      "indent": 0,
      "text": "7.5.1. Loopback Redirect Considerations in Native Apps",
      "section_title": true,
      "ja": "7.5.1. ネイティブアプリのループバックリダイレクトに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Loopback interface redirect URIs MAY use the http scheme (i.e., without TLS). This is acceptable for loopback interface redirect URIs as the HTTP request never leaves the device.",
      "ja": "ループバックインターフェイスリダイレクトURIは、HTTPスキーム（つまり、TLSなし）を使用する場合があります。これは、HTTPリクエストがデバイスを離れることはないため、ループバックインターフェイスをリダイレクトURISで許容できます。"
    },
    {
      "indent": 3,
      "text": "Clients should open the network port only when starting the authorization request and close it once the response is returned.",
      "ja": "クライアントは、承認要求を起動するときにのみネットワークポートを開き、応答が返されたら閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "Clients should listen on the loopback network interface only, in order to avoid interference by other network actors.",
      "ja": "クライアントは、他のネットワークアクターによる干渉を避けるために、ループバックネットワークインターフェイスのみをリッスンする必要があります。"
    },
    {
      "indent": 3,
      "text": "Clients should use loopback IP literals rather than the string localhost as described in Section 8.4.2.",
      "ja": "クライアントは、セクション8.4.2で説明されているように、文字列localhostではなく、ループバックIPリテラルを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.5.2. HTTP 307 Redirect",
      "section_title": true,
      "ja": "7.5.2. HTTP 307リダイレクト"
    },
    {
      "indent": 3,
      "text": "An authorization server which redirects a request that potentially contains user credentials MUST NOT use the 307 status code (Section 15.4.8 of [RFC9110]) for redirection. If an HTTP redirection (and not, for example, JavaScript) is used for such a request, AS SHOULD use the status code 303 (\"See Other\").",
      "ja": "リダイレクトのために、ユーザーの資格情報が潜在的にユーザーの資格情報が含まれている可能性がある307ステータスコード（[RFC9110]のセクション15.4.8）を使用しないでください。HTTPリダイレクト（たとえば、JavaScriptなどではない）がそのような要求に使用されている場合、ステータスコード303（「他の」を参照」）を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "At the authorization endpoint, a typical protocol flow is that the AS prompts the user to enter their credentials in a form that is then submitted (using the POST method) back to the authorization server. The AS checks the credentials and, if successful, redirects the user agent to the client's redirect URI.",
      "ja": "Authorization Endpointでは、典型的なプロトコルフローは、ASがユーザーがフォームで資格情報を入力するように求めていることです。ASは資格情報をチェックし、成功した場合、ユーザーエージェントをクライアントのリダイレクトURIにリダイレクトします。"
    },
    {
      "indent": 3,
      "text": "If the status code 307 were used for redirection, the user agent would send the user credentials via a POST request to the client.",
      "ja": "ステータスコード307がリダイレクトに使用された場合、ユーザーエージェントは、クライアントにPOSTリクエストを介してユーザー資格情報を送信します。"
    },
    {
      "indent": 3,
      "text": "This discloses the sensitive credentials to the client. If the relying party is malicious, it can use the credentials to impersonate the user at the AS.",
      "ja": "これにより、敏感な資格情報がクライアントに開示されます。頼っている当事者が悪意がある場合、資格情報を使用してASでユーザーになりすまします。"
    },
    {
      "indent": 3,
      "text": "The behavior might be unexpected for developers, but is defined in Section 15.4.8 of [RFC9110]. This status code does not require the user agent to rewrite the POST request to a GET request and thereby drop the form data in the POST request content.",
      "ja": "動作は開発者にとって予想外かもしれませんが、[RFC9110]のセクション15.4.8で定義されています。このステータスコードでは、ユーザーエージェントがPOSTリクエストをGETリクエストに書き換えて、POSTリクエストコンテンツのフォームデータを削除する必要はありません。"
    },
    {
      "indent": 3,
      "text": "In HTTP [RFC9110], only the status code 303 unambigiously enforces rewriting the HTTP POST request to an HTTP GET request. For all other status codes, including the popular 302, user agents can opt not to rewrite POST to GET requests and therefore reveal the user credentials to the client. (In practice, however, most user agents will only show this behaviour for 307 redirects.)",
      "ja": "HTTP [RFC9110]では、HTTP POSTリクエストをHTTP GETリクエストに書き換えて、ステータスコード303のみが明らかに施行されていません。人気のある302を含む他のすべてのステータスコードについて、ユーザーエージェントは、投稿を書き換えてリクエストを取得することを選択でき、したがってクライアントにユーザーの資格情報を明らかにすることができます。（ただし、ほとんどのユーザーエージェントは、307のリダイレクトに対してこの動作のみを表示します。）"
    },
    {
      "indent": 0,
      "text": "7.6. Authorization Code Injection",
      "section_title": true,
      "ja": "7.6. 承認コードインジェクション"
    },
    {
      "indent": 3,
      "text": "Authorization code injection is an attack where the client receives an authorization code from the attacker in its redirect URI instead of the authorization code from the legitimate authorization server. Without protections in place, there is no mechanism by which the client can know that the attack has taken place. Authorization code injection can lead to both the attacker obtaining access to a victim's account, as well as a victim accidentally gaining access to the attacker's account.",
      "ja": "承認コードインジェクションは、クライアントが正当な認証サーバーからの認証コードの代わりに、リダイレクトURIで攻撃者から認証コードを受信する攻撃です。保護が整っていない場合、クライアントが攻撃が行われたことをクライアントが知ることができるメカニズムはありません。承認コードインジェクションは、攻撃者が被害者のアカウントへのアクセスを取得することと、誤って攻撃者のアカウントへのアクセスを取得することにつながる可能性があります。"
    },
    {
      "indent": 0,
      "text": "7.6.1. Countermeasures",
      "section_title": true,
      "ja": "7.6.1. 対策"
    },
    {
      "indent": 3,
      "text": "To prevent injection of authorization codes into the client, using code_challenge and code_verifier is REQUIRED for clients, and authorization servers MUST enforce their use, unless both of the following criteria are met:",
      "ja": "クライアントへの承認コードの注入を防ぐために、Code_Challengeとcode_verifierを使用することがクライアントに必要であり、承認サーバーは、次の両方の基準が満たされない限り、使用を実施する必要があります。"
    },
    {
      "indent": 3,
      "text": "* The client is a confidential client.",
      "ja": "* クライアントは機密クライアントです。"
    },
    {
      "indent": 3,
      "text": "* In the specific deployment and the specific request, there is reasonable assurance by the authorization server that the client implements the OpenID Connect nonce mechanism properly.",
      "ja": "* 特定の展開と特定の要求では、クライアントがOpenID Connect NonCeメカニズムを適切に実装するという認証サーバーによる合理的な保証があります。"
    },
    {
      "indent": 3,
      "text": "In this case, using and enforcing code_challenge and code_verifier is still RECOMMENDED.",
      "ja": "この場合、code_challengeとcode_verifierの使用と実施が引き続き推奨されます。"
    },
    {
      "indent": 3,
      "text": "The code_challenge or OpenID Connect nonce value MUST be transaction-specific and securely bound to the client and the user agent in which the transaction was started. If a transaction leads to an error, fresh values for code_challenge or nonce MUST be chosen.",
      "ja": "Code_ChallengeまたはOpenID Connect Nonce値は、トランザクション固有であり、クライアントとトランザクションが開始されたユーザーエージェントに安全にバインドされている必要があります。トランザクションがエラーにつながる場合、code_challengeまたはnonceの新鮮な値を選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "Relying on the client to validate the OpenID Connect nonce parameter means the authorization server has no way to confirm that the client has actually protected itself against authorization code injection attacks. If an attacker is able to inject an authorization code into a client, the client would still exchange the injected authorization code and obtain tokens, and would only later reject the ID token after validating the nonce and seeing that it doesn't match. In contrast, the authorization server enforcing the code_challenge and code_verifier parameters provides a higher security outcome, since the authorization server is able to recognize the authorization code injection attack pre-emtpively and avoid issuing any tokens in the first place.",
      "ja": "OpenID Connect Nonceパラメーターを検証するようにクライアントに依存することは、認証サーバーがクライアントが実際に認証コードインジェクション攻撃に対して保護していることを確認する方法がないことを意味します。攻撃者がクライアントに承認コードを挿入できる場合、クライアントは引き続き注入された認証コードを交換し、トークンを取得し、後でノンセを検証してそれが一致しないことを確認した後にのみIDトークンを拒否します。対照的に、CODE_CHALLENGEとCODE_VERIFIERパラメーターを施行する承認サーバーは、認証コードインジェクション攻撃を前に認識し、そもそもトークンの発行を避けることができるため、より高いセキュリティ結果を提供します。"
    },
    {
      "indent": 3,
      "text": "Historic note: Although PKCE [RFC7636] (where the code_challenge and code_verifier parameters were created) was originally designed as a mechanism to protect native apps from authorization code exfiltration attacks, all kinds of OAuth clients, including web applications and other confidential clients, are susceptible to authorziation code injection attacks, which are solved by the code_challenge and code_verifier mechanism.",
      "ja": "歴史的メモ：PKCE [RFC7636]（Code_Challengeとcode_verifierパラメーターが作成された場所）は、元々、ネイティブアプリを認証コード除去攻撃から保護するメカニズムとして設計されていました。"
    },
    {
      "indent": 0,
      "text": "7.7. Ensuring Endpoint Authenticity",
      "section_title": true,
      "ja": "7.7. エンドポイントの信頼性を確保します"
    },
    {
      "indent": 3,
      "text": "The risk related to man-in-the-middle attacks is mitigated by the mandatory use of channel security mechanisms such as [RFC8446] for communicating with the Authorization and Token Endpoints. See Section 1.5 for further details.",
      "ja": "中間の攻撃に関連するリスクは、[RFC8446]などのチャネルセキュリティメカニズムの強制的な使用により、承認とトークンのエンドポイントと通信することによって軽減されます。詳細については、セクション1.5を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.8. Credentials-Guessing Attacks",
      "section_title": true,
      "ja": "7.8. 資格情報攻撃"
    },
    {
      "indent": 3,
      "text": "The authorization server MUST prevent attackers from guessing access tokens, authorization codes, refresh tokens, resource owner passwords, and client credentials.",
      "ja": "承認サーバーは、攻撃者がアクセストークン、承認コード、リフレッシュトークン、リソース所有者のパスワード、クライアントの資格情報を推測できないようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "The probability of an attacker guessing generated tokens (and other credentials not intended for handling by end-users) MUST be less than or equal to 2^(-128) and SHOULD be less than or equal to 2^(-160).",
      "ja": "攻撃者が生成されたトークン（およびエンドユーザーによる取り扱いを意図していない他の資格情報）の確率は、2^（-128）以下でなければならず、2^（-160）以下でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The authorization server MUST utilize other means to protect credentials intended for end-user usage.",
      "ja": "Authorization Serverは、エンドユーザーの使用を目的とした資格情報を保護するために、他の手段を利用する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.9. Phishing Attacks",
      "section_title": true,
      "ja": "7.9. フィッシング攻撃"
    },
    {
      "indent": 3,
      "text": "Wide deployment of this and similar protocols may cause end-users to become inured to the practice of being redirected to websites where they are asked to enter their passwords. If end-users are not careful to verify the authenticity of these websites before entering their credentials, it will be possible for attackers to exploit this practice to steal resource owners' passwords.",
      "ja": "このプロトコルと同様のプロトコルの幅広い展開により、エンドユーザーは、パスワードを入力するように求められるWebサイトにリダイレクトされるという練習に耐えられる可能性があります。エンドユーザーが資格情報を入力する前にこれらのWebサイトの信ity性を検証するように注意しない場合、攻撃者はこのプラクティスを悪用してリソース所有者のパスワードを盗むことができます。"
    },
    {
      "indent": 3,
      "text": "Service providers should attempt to educate end-users about the risks phishing attacks pose and should provide mechanisms that make it easy for end-users to confirm the authenticity of their sites. Client developers should consider the security implications of how they interact with the user agent (e.g., external, embedded), and the ability of the end-user to verify the authenticity of the authorization server.",
      "ja": "サービスプロバイダーは、フィッシング攻撃がポーズをとるリスクについてエンドユーザーに教育しようとする必要があり、エンドユーザーがサイトの信頼性を簡単に確認できるメカニズムを提供する必要があります。クライアント開発者は、ユーザーエージェントとの対話（外部、組み込み）との対話のセキュリティへの意味と、承認サーバーの信頼性を検証するエンドユーザーの能力を考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "See Section 1.5 for further details on mitigating the risk of phishing attacks.",
      "ja": "フィッシング攻撃のリスクを軽減する詳細については、セクション1.5を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.10. Cross-Site Request Forgery",
      "section_title": true,
      "ja": "7.10. クロスサイトのリクエスト偽造"
    },
    {
      "indent": 3,
      "text": "An attacker might attempt to inject a request to the redirect URI of the legitimate client on the victim's device, e.g., to cause the client to access resources under the attacker's control. This is a variant of an attack known as Cross-Site Request Forgery (CSRF).",
      "ja": "攻撃者は、たとえば、クライアントが攻撃者の管理下にあるリソースにアクセスできるように、被害者のデバイス上の正当なクライアントのリダイレクトURIにリクエストを注入しようとする場合があります。これは、クロスサイトリクエスト偽造（CSRF）として知られる攻撃のバリアントです。"
    },
    {
      "indent": 3,
      "text": "The traditional countermeasure is that clients pass a random value, also known as a CSRF Token, in the state parameter that links the request to the redirect URI to the user agent session as described. This countermeasure is described in detail in [RFC6819], Section 5.3.5. The same protection is provided by the code_verifier parameter or the OpenID Connect nonce value.",
      "ja": "従来の対策は、クライアントがCSRFトークンとも呼ばれるランダムな値を、リクエストをリダイレクトURIにリダイレクトURIにリダイレクトするように、説明されているようにユーザーエージェントセッションに渡すことです。この対策については、[RFC6819]、セクション5.3.5で詳細に説明されています。同じ保護は、Code_verifierパラメーターまたはOpenID Connect NonCe値によって提供されます。"
    },
    {
      "indent": 3,
      "text": "When using code_verifier instead of state or nonce for CSRF protection, it is important to note that:",
      "ja": "CSRF保護のために状態または非CEの代わりにcode_verifierを使用する場合、次のことに注意することが重要です。"
    },
    {
      "indent": 3,
      "text": "* Clients MUST ensure that the AS supports the code_challenge_method intended to be used by the client. If an authorization server does not support the requested method, state or nonce MUST be used for CSRF protection instead.",
      "ja": "* クライアントは、ASがクライアントが使用することを目的としたcode_challenge_methodをサポートすることを確認する必要があります。承認サーバーが要求されたメソッドをサポートしていない場合、代わりにCSRF保護に状態または非CEを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If state is used for carrying application state, and integrity of its contents is a concern, clients MUST protect state against tampering and swapping. This can be achieved by binding the contents of state to the browser session and/or signed/encrypted state values [I-D.bradley-oauth-jwt-encoded-state].",
      "ja": "* 状態がアプリケーションの状態を運ぶために使用され、その内容の整合性が懸念事項である場合、クライアントは、改ざんやスワッピングから状態を保護する必要があります。これは、状態の内容をブラウザセッションおよび/または署名/暗号化された状態値[i-d.bradley-oauth-jwt-Encoded-state]にバインドすることで実現できます。"
    },
    {
      "indent": 3,
      "text": "AS therefore MUST provide a way to detect their supported code challenge methods either via AS metadata according to [RFC8414] or provide a deployment-specific way to ensure or determine support.",
      "ja": "したがって、[RFC8414]に従ってメタデータを介してサポートされているコードチャレンジメソッドを検出する方法を提供するか、サポートを確保または決定するための展開固有の方法を提供する方法を提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.11. Clickjacking",
      "section_title": true,
      "ja": "7.11. クリックジャック"
    },
    {
      "indent": 3,
      "text": "As described in Section 4.4.1.9 of [RFC6819], the authorization request is susceptible to clickjacking attacks, also called user interface redressing. In such an attack, an attacker embeds the authorization endpoint user interface in an innocuous context. A user believing to interact with that context, for example, clicking on buttons, inadvertently interacts with the authorization endpoint user interface instead. The opposite can be achieved as well: A user believing to interact with the authorization endpoint might inadvertently type a password into an attacker-provided input field overlaid over the original user interface. Clickjacking attacks can be designed such that users can hardly notice the attack, for example using almost invisible iframes overlaid on top of other elements.",
      "ja": "[RFC6819]のセクション4.4.1.9で説明されているように、承認リクエストは、ユーザーインターフェイス救済とも呼ばれる攻撃をクリックする可能性があります。このような攻撃では、攻撃者が無害なコンテキストで承認エンドポイントユーザーインターフェイスを埋め込みます。たとえば、そのコンテキストと対話すると信じているユーザーは、ボタンをクリックすると、代わりに承認エンドポイントユーザーインターフェイスと誤って対話します。逆のことも実現できます。認証エンドポイントと対話すると信じているユーザーは、攻撃者が提供する入力フィールドに、元のユーザーインターフェイス上でオーバーレイされた攻撃者が提供する入力フィールドに誤って入力する可能性があります。クリックジャック攻撃は、ユーザーが攻撃にほとんど気付かないように設計することができます。たとえば、他の要素の上にオーバーレイされたほとんど目に見えないiframesを使用します。"
    },
    {
      "indent": 3,
      "text": "An attacker can use this vector to obtain the user's authentication credentials, change the scope of access granted to the client, and potentially access the user's resources.",
      "ja": "攻撃者は、このベクトルを使用してユーザーの認証資格情報を取得し、クライアントに付与されたアクセスの範囲を変更し、ユーザーのリソースにアクセスする可能性があります。"
    },
    {
      "indent": 3,
      "text": "Authorization servers MUST prevent clickjacking attacks. Multiple countermeasures are described in [RFC6819], including the use of the X-Frame-Options HTTP response header field and frame-busting JavaScript. In addition to those, authorization servers SHOULD also use Content Security Policy (CSP) level 2 [CSP-2] or greater.",
      "ja": "承認サーバーは、クリックジャック攻撃を防ぐ必要があります。[RFC6819]で複数の対策が説明されています。これには、XフレームオプションHTTP応答ヘッダーフィールドの使用やフレームバストJavaScriptが含まれます。それらに加えて、承認サーバーはコンテンツセキュリティポリシー（CSP）レベル2 [CSP-2]以上を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "To be effective, CSP must be used on the authorization endpoint and, if applicable, other endpoints used to authenticate the user and authorize the client (e.g., the device authorization endpoint, login pages, error pages, etc.). This prevents framing by unauthorized origins in user agents that support CSP. The client MAY permit being framed by some other origin than the one used in its redirection endpoint. For this reason, authorization servers SHOULD allow administrators to configure allowed origins for particular clients and/or for clients to register these dynamically.",
      "ja": "効果的であるためには、CSPを承認エンドポイントで使用する必要があり、該当する場合は、ユーザーの認証とクライアントの認証に使用される他のエンドポイント（例：デバイス認証エンドポイント、ログインページ、エラーページなど）。これにより、CSPをサポートするユーザーエージェントの不正な起源によるフレーミングを防ぎます。クライアントは、リダイレクトエンドポイントで使用されているエンドポイントで使用されているもの以外の起源に囲まれていることを許可する場合があります。このため、承認サーバーは、管理者が特定のクライアントおよび/またはクライアントがこれらを動的に登録できるように許可されたオリジンを構成できるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "Using CSP allows authorization servers to specify multiple origins in a single response header field and to constrain these using flexible patterns (see [CSP-2] for details). Level 2 of this standard provides a robust mechanism for protecting against clickjacking by using policies that restrict the origin of frames (using frame-ancestors) together with those that restrict the sources of scripts allowed to execute on an HTML page (by using script-src). A non-normative example of such a policy is shown in the following listing:",
      "ja": "CSPを使用すると、承認サーバーが単一の応答ヘッダーフィールドに複数の起源を指定し、柔軟なパターンを使用してこれらを制約することができます（詳細については[CSP-2]を参照）。この標準のレベル2は、フレームの起源（フレームアンベストを使用）を制限するポリシーを使用してクリックジャックから保護するための堅牢なメカニズムと、HTMLページで実行されるスクリプトのソース（スクリプト-SRCを使用して）を制限するものを提供します。このようなポリシーの非規範的な例は、次のリストに示されています。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 200 OK Content-Security-Policy: frame-ancestors\nhttps://ext.example.org:8000 Content-Security-Policy: script-src\n'self' X-Frame-Options: ALLOW-FROM https://ext.example.org:8000 ...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Because some user agents do not support [CSP-2], this technique SHOULD be combined with others, including those described in [RFC6819], unless such legacy user agents are explicitly unsupported by the authorization server. Even in such cases, additional countermeasures SHOULD still be employed.",
      "ja": "一部のユーザーエージェントは[CSP-2]をサポートしていないため、この手法は[RFC6819]に記載されているものを含む他の手法と組み合わせる必要があります。そのような場合でも、追加の対策を採用する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.12. Code Injection and Input Validation",
      "section_title": true,
      "ja": "7.12. コードインジェクションと入力検証"
    },
    {
      "indent": 3,
      "text": "A code injection attack occurs when an input or otherwise external variable is used by an application unsanitized and causes modification to the application logic. This may allow an attacker to gain access to the application device or its data, cause denial of service, or introduce a wide range of malicious side-effects.",
      "ja": "コードインジェクション攻撃は、入力またはその他の外部変数がアプリケーションで使用されていない場合に使用され、アプリケーションロジックの変更を引き起こす場合に発生します。これにより、攻撃者はアプリケーションデバイスまたはそのデータにアクセスしたり、サービスの拒否を引き起こしたり、幅広い悪意のある副作用を導入したりすることができます。"
    },
    {
      "indent": 3,
      "text": "The authorization server and client MUST sanitize (and validate when possible) any value received -- in particular, the value of the state and redirect_uri parameters.",
      "ja": "承認サーバーとクライアントは、受信した値、特に状態とRedirect_URIパラメーターの値を消毒（および可能な場合は検証）する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.13. Open Redirection",
      "section_title": true,
      "ja": "7.13. オープンリダイレクト"
    },
    {
      "indent": 3,
      "text": "The following attacks can occur when an AS or client has an open redirector. An open redirector is an endpoint that forwards a user's browser to an arbitrary URI obtained from a query parameter. Such endpoints are sometimes implemented, for example, to show a message before a user is then redirected to an external website, or to redirect users back to a URL they were intending to visit before being interrupted, e.g., by a login prompt.",
      "ja": "ASまたはクライアントがオープンリダイレクターを持っている場合、次の攻撃が発生する可能性があります。オープンリダイレクターは、ユーザーのブラウザをクエリパラメーターから取得した任意のURIに転送するエンドポイントです。このようなエンドポイントは、たとえば、ユーザーが外部Webサイトにリダイレクトされる前にメッセージを表示するか、ユーザーをログインプロンプトで中断する前に訪問するつもりだったURLにリダイレクトするために実装されることがあります。"
    },
    {
      "indent": 0,
      "text": "7.13.1. Client as Open Redirector",
      "section_title": true,
      "ja": "7.13.1. オープンリダイレクターとしてのクライアント"
    },
    {
      "indent": 3,
      "text": "Clients MUST NOT expose open redirectors. Attackers may use open redirectors to produce URLs pointing to the client and utilize them to exfiltrate authorization codes, as described in Section 4.1.1 of [I-D.ietf-oauth-security-topics]. Another abuse case is to produce URLs that appear to point to the client. This might trick users into trusting the URL and follow it in their browser. This can be abused for phishing.",
      "ja": "クライアントは、オープンリダイレクターを公開してはなりません。攻撃者は、[i-d.ietf-oauth-security-topics]のセクション4.1.1で説明されているように、オープンリダイレクターを使用してクライアントを指すURLを生成し、クライアントを指すURLを生成し、承認コードを使用して承認コードを使用することができます。別の虐待のケースは、クライアントを指すように見えるURLを生成することです。これにより、ユーザーがURLを信頼し、ブラウザでそれに従うようになります。これはフィッシングのために乱用することができます。"
    },
    {
      "indent": 3,
      "text": "In order to prevent open redirection, clients should only redirect if the target URLs are whitelisted or if the origin and integrity of a request can be authenticated. Countermeasures against open redirection are described by OWASP [owasp_redir].",
      "ja": "オープンリダイレクトを防ぐために、クライアントはターゲットURLがホワイトリストに登録されている場合、またはリクエストの起源と整合性を認証できる場合にのみリダイレクトする必要があります。オープンリダイレクトに対する対策は、OWASP [OWASP_REDIR]によって説明されています。"
    },
    {
      "indent": 0,
      "text": "7.13.2. Authorization Server as Open Redirector",
      "section_title": true,
      "ja": "7.13.2. オープンリダイレクターとしての承認サーバー"
    },
    {
      "indent": 3,
      "text": "Just as with clients, attackers could try to utilize a user's trust in the authorization server (and its URL in particular) for performing phishing attacks. OAuth authorization servers regularly redirect users to other web sites (the clients), but must do so in a safe way.",
      "ja": "クライアントと同様に、攻撃者は、フィッシング攻撃を実行するために、認証サーバー（および特にそのURL）に対するユーザーの信頼を利用しようとすることができます。OAuth Authorizationサーバーは、ユーザーを他のWebサイト（クライアント）に定期的にリダイレクトしますが、安全な方法でそれを行う必要があります。"
    },
    {
      "indent": 3,
      "text": "Section 4.1.2.1 already prevents open redirects by stating that the AS MUST NOT automatically redirect the user agent in case of an invalid combination of client_id and redirect_uri.",
      "ja": "セクション4.1.2.1は、client_idとredirect_uriの無効な組み合わせの場合、ASがユーザーエージェントを自動的にリダイレクトしてはならないことを述べることにより、オープンリダイレクトを既に防止します。"
    },
    {
      "indent": 3,
      "text": "However, an attacker could also utilize a correctly registered redirect URI to perform phishing attacks. The attacker could, for example, register a client via dynamic client registration [RFC7591] and execute one of the following attacks:",
      "ja": "ただし、攻撃者は、正しく登録されたリダイレクトURIを利用してフィッシング攻撃を実行することもできます。たとえば、攻撃者は、ダイナミッククライアント登録[RFC7591]を介してクライアントを登録し、次のいずれかの攻撃を実行できます。"
    },
    {
      "indent": 3,
      "text": "1. Intentionally send an erroneous authorization request, e.g., by using an invalid scope value, thus instructing the AS to redirect the user-agent to its phishing site.",
      "ja": "1. 無効なスコープ値を使用して、誤った承認要求を意図的に送信し、ユーザーエージェントをフィッシングサイトにリダイレクトするように指示します。"
    },
    {
      "indent": 3,
      "text": "2. Intentionally send a valid authorization request with client_id and redirect_uri controlled by the attacker. After the user authenticates, the AS prompts the user to provide consent to the request. If the user notices an issue with the request and declines the request, the AS still redirects the user agent to the phishing site. In this case, the user agent will be redirected to the phishing site regardless of the action taken by the user.",
      "ja": "2. 攻撃者が制御するclient_idおよびredirect_uriを使用して、有効な承認要求を意図的に送信します。ユーザーが認証した後、ASはユーザーにリクエストに同意を提供するように促します。ユーザーがリクエストの問題に気付いてリクエストを拒否した場合、ASはまだユーザーエージェントをフィッシングサイトにリダイレクトします。この場合、ユーザーエージェントは、ユーザーが取ったアクションに関係なくフィッシングサイトにリダイレクトされます。"
    },
    {
      "indent": 3,
      "text": "3. Intentionally send a valid silent authentication request (prompt=none) with client_id and redirect_uri controlled by the attacker. In this case, the AS will automatically redirect the user agent to the phishing site.",
      "ja": "3. 攻撃者によって制御されたClient_IDおよびRedirect_URIを使用して、有効なサイレント認証要求（PROMPT = NONE）を意図的に送信します。この場合、ASはユーザーエージェントを自動的にフィッシングサイトにリダイレクトします。"
    },
    {
      "indent": 3,
      "text": "The AS MUST take precautions to prevent these threats. The AS MUST always authenticate the user first and, with the exception of the silent authentication use case, prompt the user for credentials when needed, before redirecting the user. Based on its risk assessment, the AS needs to decide whether it can trust the redirect URI or not. It could take into account URI analytics done internally or through some external service to evaluate the credibility and trustworthiness content behind the URI, and the source of the redirect URI and other client data.",
      "ja": "ASは、これらの脅威を防ぐために予防策を講じなければなりません。ASは常に最初にユーザーを認証する必要があり、サイレント認証ユースケースを除き、ユーザーをリダイレクトする前に、必要に応じてユーザーに資格情報を求めます。リスク評価に基づいて、リダイレクトURIを信頼できるかどうかを決定する必要があります。URIの背後にある信頼性と信頼性コンテンツ、およびリダイレクトURIおよびその他のクライアントデータのソースを評価するために、内部または外部サービスを通じて行われるURI分析を考慮することができます。"
    },
    {
      "indent": 3,
      "text": "The AS SHOULD only automatically redirect the user agent if it trusts the redirect URI. If the URI is not trusted, the AS MAY inform the user and rely on the user to make the correct decision.",
      "ja": "ASは、リダイレクトURIを信頼している場合にのみ、ユーザーエージェントを自動的にリダイレクトする必要があります。URIが信頼されていない場合、ASはユーザーに通知し、正しい決定を下すためにユーザーに依存する可能性があります。"
    },
    {
      "indent": 0,
      "text": "7.14. Authorization Server Mix-Up Mitigation in Native Apps",
      "section_title": true,
      "ja": "7.14. ネイティブアプリの承認サーバーのミックスアップ緩和"
    },
    {
      "indent": 3,
      "text": "(TODO: merge this with the regular mix-up section when it is brought in)",
      "ja": "（TODO：これを通常のミックスアップセクションとマージしたとき）"
    },
    {
      "indent": 3,
      "text": "To protect against a compromised or malicious authorization server attacking another authorization server used by the same app, it is REQUIRED that a unique redirect URI is used for each authorization server used by the app (for example, by varying the path component), and that authorization responses are rejected if the redirect URI they were received on doesn't match the redirect URI in an outgoing authorization request.",
      "ja": "同じアプリで使用される別の認証サーバーを攻撃する侵害または悪意のある認証サーバーから保護するために、アプリが使用する各認証サーバーに一意のリダイレクトURIが使用され（たとえば、パスコンポーネントを変化させることにより）、承認uRIがredirect urization urization uriation uriationのリクエストと一致しない場合、承認応答が拒否される必要があります。"
    },
    {
      "indent": 3,
      "text": "The native app MUST store the redirect URI used in the authorization request with the authorization session data (i.e., along with state and other related data) and MUST verify that the URI on which the authorization response was received exactly matches it.",
      "ja": "ネイティブアプリは、承認リクエストで使用されるリダイレクトURIを認証セッションデータ（つまり、状態およびその他の関連データとともに）とともに保存する必要があり、認証応答が受信されたURIが正確に一致することを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "The requirement of Section 8.1, specifically that authorization servers reject requests with URIs that don't match what was registered, is also required to prevent such attacks.",
      "ja": "セクション8.1の要件、特に承認サーバーは、登録されたものと一致しないURIの要求を拒否することも、そのような攻撃を防ぐために必要です。"
    },
    {
      "indent": 0,
      "text": "8. Native Applications",
      "section_title": true,
      "ja": "8. ネイティブアプリケーション"
    },
    {
      "indent": 3,
      "text": "Native applications are clients installed and executed on the device used by the resource owner (i.e., desktop application, native mobile application). Native applications require special consideration related to security, platform capabilities, and overall end-user experience.",
      "ja": "ネイティブアプリケーションは、リソース所有者が使用するデバイスにインストールおよび実行されたクライアントです（つまり、デスクトップアプリケーション、ネイティブモバイルアプリケーション）。ネイティブアプリケーションでは、セキュリティ、プラットフォーム機能、および全体的なエンドユーザーエクスペリエンスに関連する特別な考慮事項が必要です。"
    },
    {
      "indent": 3,
      "text": "The authorization endpoint requires interaction between the client and the resource owner's user agent. The best current practice is to perform the OAuth authorization request in an external user agent (typically the browser) rather than an embedded user agent (such as one implemented with web-views).",
      "ja": "承認エンドポイントには、クライアントとリソース所有者のユーザーエージェントとの相互作用が必要です。現在の最良のプラクティスは、埋め込まれたユーザーエージェント（Webビューで実装されたものなど）ではなく、外部ユーザーエージェント（通常はブラウザ）でOAuth Authorizationリクエストを実行することです。"
    },
    {
      "indent": 3,
      "text": "The native application can capture the response from the authorization server using a redirect URI with a scheme registered with the operating system to invoke the client as the handler, manual copy-and-paste of the credentials, running a local web server, installing a user agent extension, or by providing a redirect URI identifying a server-hosted resource under the client's control, which in turn makes the response available to the native application.",
      "ja": "ネイティブアプリケーションは、オペレーティングシステムに登録されたスキームを使用してURIをリダイレクトし、クライアントをハンドラー、資格情報の手動のコピーアンドパステ、ローカルWebサーバーの実行、ユーザーエージェント拡張機能のインストール、またはリダイレクトURIを提供することにより、クライアントのコントロールの下でリダイレクトURIを提供することにより、ネイティブアプリケーションを利用できるようにすることにより、リダイレクトURIを使用して認証サーバーからの応答をキャプチャできます。"
    },
    {
      "indent": 3,
      "text": "Previously, it was common for native apps to use embedded user agents (commonly implemented with web-views) for OAuth authorization requests. That approach has many drawbacks, including the host app being able to copy user credentials and cookies as well as the user needing to authenticate from scratch in each app. See Section 8.5.1 for a deeper analysis of the drawbacks of using embedded user agents for OAuth.",
      "ja": "以前は、ネイティブアプリがOAUTH Authorizationリクエストに組み込みユーザーエージェント（一般的にWebビューで実装されている）を使用することが一般的でした。このアプローチには、ユーザーの資格情報やCookieをコピーできるホストアプリや、各アプリのゼロから認証する必要があるユーザーなど、多くの欠点があります。OAUTHに組み込みユーザーエージェントを使用することの欠点のより深い分析については、セクション8.5.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Native app authorization requests that use the system browser are more secure and can take advantage of the user's authentication state on the device. Being able to use the existing authentication session in the browser enables single sign-on, as users don't need to authenticate to the authorization server each time they use a new app (unless required by the authorization server policy).",
      "ja": "システムブラウザを使用するネイティブアプリ認証リクエストは、より安全で、デバイス上のユーザーの認証状態を活用できます。ブラウザで既存の認証セッションを使用できると、ユーザーが新しいアプリを使用するたびに認証サーバーに認証する必要がないため、シングルサインオンを有効にします（Authorization Serverポリシーで要求されない限り）。"
    },
    {
      "indent": 3,
      "text": "Supporting authorization flows between a native app and the browser is possible without changing the OAuth protocol itself, as the OAuth authorization request and response are already defined in terms of URIs. This encompasses URIs that can be used for inter-app communication. Some OAuth server implementations that assume all clients are confidential web clients will need to add an understanding of public native app clients and the types of redirect URIs they use to support this best practice.",
      "ja": "OAuth Authorizationリクエストと応答はURISの観点から既に定義されているため、OAUTHプロトコル自体を変更することなく、ネイティブアプリとブラウザ間の認証のサポートフローをサポートすることは可能です。これには、アプリ間通信に使用できるURIが含まれます。すべてのクライアントが機密のWebクライアントであると仮定する一部のOAUTHサーバーの実装は、パブリックネイティブアプリクライアントと、このベストプラクティスをサポートするために使用するリダイレクトURIのタイプを理解する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.1. Registration of Native App Clients",
      "section_title": true,
      "ja": "8.1. ネイティブアプリクライアントの登録"
    },
    {
      "indent": 3,
      "text": "Except when using a mechanism like Dynamic Client Registration [RFC7591] to provision per-instance secrets, native apps are classified as public clients, as defined in Section 2.1; they MUST be registered with the authorization server as such. Authorization servers MUST record the client type in the client registration details in order to identify and process requests accordingly.",
      "ja": "ダイナミッククライアント登録[RFC7591]のようなメカニズムを使用して、インスタンスごとの秘密を提供する場合を除き、セクション2.1で定義されているように、ネイティブアプリはパブリッククライアントとして分類されます。そのように、それらは承認サーバーに登録する必要があります。承認サーバーは、リクエストを識別および処理するために、クライアント登録の詳細にクライアントタイプを記録する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.1.1. Client Authentication of Native Apps",
      "section_title": true,
      "ja": "8.1.1. ネイティブアプリのクライアント認証"
    },
    {
      "indent": 3,
      "text": "Secrets that are statically included as part of an app distributed to multiple users should not be treated as confidential secrets, as one user may inspect their copy and learn the shared secret. For this reason, it is NOT RECOMMENDED for authorization servers to require client authentication of public native apps clients using a shared secret, as this serves little value beyond client identification which is already provided by the client_id request parameter.",
      "ja": "複数のユーザーに配布されたアプリの一部として静的に含まれる秘密は、1人のユーザーがコピーを検査し、共有秘密を学ぶことができるため、機密の秘密として扱われるべきではありません。このため、Shared Secretを使用してパブリックネイティブアプリのクライアントのクライアント認証を承認することを許可することはお勧めしません。"
    },
    {
      "indent": 3,
      "text": "Authorization servers that still require a statically included shared secret for native app clients MUST treat the client as a public client (as defined in Section 2.1), and not accept the secret as proof of the client's identity. Without additional measures, such clients are subject to client impersonation (see Section 7.3.1).",
      "ja": "まだネイティブアプリのクライアントに静的に含まれる共有秘密を必要とする許可サーバーは、クライアントをパブリッククライアントとして（セクション2.1で定義しているように）扱い、秘密をクライアントの身元の証明として受け入れない必要があります。追加の措置がなければ、そのようなクライアントはクライアントのなりすましの対象となります（セクション7.3.1を参照）。"
    },
    {
      "indent": 0,
      "text": "8.2. Using Inter-App URI Communication for OAuth in Native Apps",
      "section_title": true,
      "ja": "8.2. ネイティブアプリでOAuthにアプリ間のURI通信を使用します"
    },
    {
      "indent": 3,
      "text": "Just as URIs are used for OAuth on the web to initiate the authorization request and return the authorization response to the requesting website, URIs can be used by native apps to initiate the authorization request in the device's browser and return the response to the requesting native app.",
      "ja": "Web上のOAuthにURIが使用されて承認要求を開始し、リクエストWebサイトへの承認応答を返すように、URIはネイティブアプリで使用してデバイスのブラウザで承認要求を開始し、リクエストネイティブアプリへの応答を返すことができます。"
    },
    {
      "indent": 3,
      "text": "By adopting the same methods used on the web for OAuth, benefits seen in the web context like the usability of a single sign-on session and the security of a separate authentication context are likewise gained in the native app context. Reusing the same approach also reduces the implementation complexity and increases interoperability by relying on standards-based web flows that are not specific to a particular platform.",
      "ja": "OAuthのためにWebで使用されるのと同じ方法を採用することにより、単一のサインオンセッションの使いやすさや個別の認証コンテキストのセキュリティなど、Webコンテキストで見られる利点も同様にネイティブアプリのコンテキストで得られます。同じアプローチを再利用すると、特定のプラットフォームに固有の標準ベースのWebフローに依存することにより、実装の複雑さも低下し、相互運用性が向上します。"
    },
    {
      "indent": 3,
      "text": "Native apps MUST use an external user agent to perform OAuth authorization requests. This is achieved by opening the authorization request in the browser (detailed in Section 8.3) and using a redirect URI that will return the authorization response back to the native app (defined in Section 8.4).",
      "ja": "ネイティブアプリは、外部ユーザーエージェントを使用してOAUTH認証リクエストを実行する必要があります。これは、ブラウザで承認要求を開き（セクション8.3で詳述）、承認応答をネイティブアプリ（セクション8.4で定義）に戻すリダイレクトURIを使用することで達成されます。"
    },
    {
      "indent": 0,
      "text": "8.3. Initiating the Authorization Request from a Native App",
      "section_title": true,
      "ja": "8.3. ネイティブアプリからの承認要求を開始します"
    },
    {
      "indent": 3,
      "text": "Native apps needing user authorization create an authorization request URI with the authorization code grant type per Section 4.1 using a redirect URI capable of being received by the native app.",
      "ja": "ユーザー認証が必要なネイティブアプリは、ネイティブアプリが受信できるリダイレクトURIを使用して、セクション4.1ごとに認証コード助成金タイプを使用して承認要求URIを作成します。"
    },
    {
      "indent": 3,
      "text": "The function of the redirect URI for a native app authorization request is similar to that of a web-based authorization request. Rather than returning the authorization response to the OAuth client's server, the redirect URI used by a native app returns the response to the app. Several options for a redirect URI that will return the authorization response to the native app in different platforms are documented in Section 8.4. Any redirect URI that allows the app to receive the URI and inspect its parameters is viable.",
      "ja": "ネイティブアプリ認証リクエストに対するRedirect URIの機能は、Webベースの承認要求の機能と類似しています。OAUTHクライアントのサーバーへの承認応答を返すのではなく、ネイティブアプリが使用するリダイレクトURIは、アプリへの応答を返します。さまざまなプラットフォームのネイティブアプリへの承認応答を返すリダイレクトURIのいくつかのオプションについては、セクション8.4に記載されています。アプリがURIを受信し、そのパラメーターを検査できるようにするリダイレクトURIは実行可能です。"
    },
    {
      "indent": 3,
      "text": "After constructing the authorization request URI, the app uses platform-specific APIs to open the URI in an external user agent. Typically, the external user agent used is the default browser, that is, the application configured for handling http and https scheme URIs on the system; however, different browser selection criteria and other categories of external user agents MAY be used.",
      "ja": "承認要求URIを作成した後、アプリはプラットフォーム固有のAPIを使用して、外部ユーザーエージェントでURIを開きます。通常、使用される外部ユーザーエージェントは、デフォルトのブラウザ、つまり、システム上のHTTPおよびHTTPSスキームURIを処理するために構成されたアプリケーションです。ただし、さまざまなブラウザの選択基準と外部ユーザーエージェントのその他のカテゴリを使用する場合があります。"
    },
    {
      "indent": 3,
      "text": "This best practice focuses on the browser as the RECOMMENDED external user agent for native apps. An external user agent designed specifically for user authorization and capable of processing authorization requests and responses like a browser MAY also be used. Other external user agents, such as a native app provided by the authorization server may meet the criteria set out in this best practice, including using the same redirect URI properties, but their use is out of scope for this specification.",
      "ja": "このベストプラクティスは、ネイティブアプリに推奨される外部ユーザーエージェントとしてブラウザに焦点を当てています。ユーザー認証専用に設計された外部ユーザーエージェントが設計され、ブラウザのような許可リクエストと応答を処理できることも使用できます。Authorization Serverが提供するネイティブアプリなど、他の外部ユーザーエージェントは、同じリダイレクトURIプロパティを使用するなど、このベストプラクティスで定められた基準を満たすことができますが、その使用はこの仕様の範囲外です。"
    },
    {
      "indent": 3,
      "text": "Some platforms support a browser feature known as \"in-app browser tabs\", where an app can present a tab of the browser within the app context without switching apps, but still retain key benefits of the browser such as a shared authentication state and security context. On platforms where they are supported, it is RECOMMENDED, for usability reasons, that apps use in-app browser tabs for the authorization request.",
      "ja": "一部のプラットフォームは、「In-Appブラウザータブ」と呼ばれるブラウザ機能をサポートしています。アプリはアプリを切り替えることなく、アプリコンテキスト内にブラウザのタブを表示できますが、共有認証状態やセキュリティコンテキストなどのブラウザの重要な利点を保持します。それらがサポートされているプラットフォームでは、ユーザビリティの理由から、アプリが承認リクエストにアプリ内ブラウザータブを使用することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "8.4. Receiving the Authorization Response in a Native App",
      "section_title": true,
      "ja": "8.4. ネイティブアプリで承認応答を受信します"
    },
    {
      "indent": 3,
      "text": "There are several redirect URI options available to native apps for receiving the authorization response from the browser, the availability and user experience of which varies by platform.",
      "ja": "ブラウザから認証応答を受信するために、ネイティブアプリが利用できるリダイレクトURIオプションがいくつかあり、その可用性とユーザーエクスペリエンスはプラットフォームによって異なります。"
    },
    {
      "indent": 0,
      "text": "8.4.1. Claimed \"https\" Scheme URI Redirection",
      "section_title": true,
      "ja": "8.4.1. 「HTTPS」スキームURIリダイレクトを主張しました"
    },
    {
      "indent": 3,
      "text": "Some operating systems allow apps to claim https URIs (see Section 4.2.2 of [RFC9110]) in the domains they control. When the browser encounters a claimed URI, instead of the page being loaded in the browser, the native app is launched with the URI supplied as a launch parameter.",
      "ja": "一部のオペレーティングシステムでは、アプリがHTTPS URIを請求することができます（[RFC9110]のセクション4.2.2を参照）。ブラウザが請求されたURIに遭遇すると、ページがブラウザにロードされる代わりに、ネイティブアプリが起動パラメーターとして提供されたURIで起動されます。"
    },
    {
      "indent": 3,
      "text": "Such URIs can be used as redirect URIs by native apps. They are indistinguishable to the authorization server from a regular web-based client redirect URI. An example is: https://app.example.com/oauth2redirect/example-provider",
      "ja": "このようなURIは、ネイティブアプリによるURIをリダイレクトとして使用できます。これらは、通常のWebベースのクライアントリダイレクトURIから認証サーバーに見分けがつかない。例として：https：//app.example.com/oauth2redirect/example-provider"
    },
    {
      "indent": 3,
      "text": "As the redirect URI alone is not enough to distinguish public native app clients from confidential web clients, it is REQUIRED in Section 8.1 that the client type be recorded during client registration to enable the server to determine the client type and act accordingly.",
      "ja": "リダイレクトURIだけでは、パブリックネイティブアプリのクライアントと機密Webクライアントを区別するには十分ではないため、セクション8.1では、クライアントの登録中にクライアントタイプを記録して、サーバーがクライアントタイプを決定し、それに応じて行動できるようにすることが必要です。"
    },
    {
      "indent": 3,
      "text": "App-claimed https scheme redirect URIs have some advantages compared to other native app redirect options in that the identity of the destination app is guaranteed to the authorization server by the operating system. For this reason, native apps SHOULD use them over the other options where possible.",
      "ja": "アプリにクレインしたHTTPSスキームリダイレクトURIには、宛先アプリのIDがオペレーティングシステムによって承認サーバーに保証されているという点で、他のネイティブアプリリダイレクトオプションと比較していくつかの利点があります。このため、ネイティブアプリは、可能であれば他のオプションでそれらを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.4.2. Loopback Interface Redirection",
      "section_title": true,
      "ja": "8.4.2. ループバックインターフェイスリダイレクト"
    },
    {
      "indent": 3,
      "text": "Native apps that are able to open a port on the loopback network interface without needing special permissions (typically, those on desktop operating systems) can use the loopback interface to receive the OAuth redirect.",
      "ja": "特別な権限（通常、デスクトップオペレーティングシステムのもの）を必要とせずにループバックネットワークインターフェイスのポートを開くことができるネイティブアプリは、ループバックインターフェイスを使用してOAUTHリダイレクトを受信できます。"
    },
    {
      "indent": 3,
      "text": "Loopback redirect URIs use the http scheme and are constructed with the loopback IP literal and whatever port the client is listening on.",
      "ja": "ループバックリダイレクトurisはHTTPスキームを使用し、クライアントが聴いているポートがリテラルであるループバックIPで構築されます。"
    },
    {
      "indent": 3,
      "text": "That is, http://127.0.0.1:{port}/{path} for IPv4, and http://[::1]:{port}/{path} for IPv6. An example redirect using the IPv4 loopback interface with a randomly assigned port:",
      "ja": "つまり、IPv4の場合はhttp://127.0.0.1: {port} // [:: 1]：{port}/{path} for ipv6の場合。ランダムに割り当てられたポートを使用したIPv4ループバックインターフェイスを使用したリダイレクトの例："
    },
    {
      "indent": 3,
      "text": "http://127.0.0.1:51004/oauth2redirect/example-provider",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An example redirect using the IPv6 loopback interface with a randomly assigned port:",
      "ja": "ランダムに割り当てられたポートを使用したIPv6ループバックインターフェイスを使用したリダイレクトの例："
    },
    {
      "indent": 3,
      "text": "http://[::1]:61023/oauth2redirect/example-provider",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "While redirect URIs using the name localhost (i.e., http://localhost:{port}/{path}) function similarly to loopback IP redirects, the use of localhost is NOT RECOMMENDED. Specifying a redirect URI with the loopback IP literal rather than localhost avoids inadvertently listening on network interfaces other than the loopback interface. It is also less susceptible to client-side firewalls and misconfigured host name resolution on the user's device.",
      "ja": "LocalHost（つまり、http：// localhost：{port}/{path}）という名前の名前を使用してurisをリダイレクトしますが、Loopback IP Redirectsと同様に機能しますが、LocalHostの使用は推奨されません。LocalHostではなくLoopback IPリテラルでリダイレクトURIを指定すると、ループバックインターフェイス以外のネットワークインターフェイスで誤ってリッスンすることができません。また、クライアント側のファイアウォールや、ユーザーのデバイスでの誤解されたホスト名の解像度の影響を受けません。"
    },
    {
      "indent": 3,
      "text": "The authorization server MUST allow any port to be specified at the time of the request for loopback IP redirect URIs, to accommodate clients that obtain an available ephemeral port from the operating system at the time of the request.",
      "ja": "承認サーバーは、ループバックIPリダイレクトURIのリクエスト時に任意のポートを指定することを許可する必要があります。"
    },
    {
      "indent": 3,
      "text": "Clients SHOULD NOT assume that the device supports a particular version of the Internet Protocol. It is RECOMMENDED that clients attempt to bind to the loopback interface using both IPv4 and IPv6 and use whichever is available.",
      "ja": "クライアントは、デバイスがインターネットプロトコルの特定のバージョンをサポートしていると想定すべきではありません。クライアントは、IPv4とIPv6の両方を使用してループバックインターフェイスにバインドしようとし、利用可能な方を使用することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "8.4.3. Private-Use URI Scheme Redirection",
      "section_title": true,
      "ja": "8.4.3. 個人用URIスキームリダイレクト"
    },
    {
      "indent": 3,
      "text": "Many mobile and desktop computing platforms support inter-app communication via URIs by allowing apps to register private-use URI schemes (sometimes colloquially referred to as \"custom URL schemes\") like com.example.app. When the browser or another app attempts to load a URI with a private-use URI scheme, the app that registered it is launched to handle the request.",
      "ja": "多くのモバイルおよびデスクトップコンピューティングプラットフォームは、com.example.appなどのプライベート使用URIスキーム（「カスタムURLスキーム」と呼ばれることもあります）を登録できるようにすることにより、URIを介したアプリ間通信をサポートしています。ブラウザまたは別のアプリがURIをプライベート使用URIスキームでロードしようとすると、登録されたアプリはリクエストを処理するために起動されます。"
    },
    {
      "indent": 3,
      "text": "Many environments that support private-use URI schemes do not provide a mechanism to claim a scheme and prevent other parties from using another application's scheme. As such, clients using private-use URI schemes are vulnerable to potential attacks on their redirect URIs, so this option should only be used if the previously mentioned more secure options are not available.",
      "ja": "個人用URIスキームをサポートする多くの環境は、スキームを主張し、他の当事者が別のアプリケーションのスキームを使用することを妨げるメカニズムを提供しません。そのため、プライベート使用URIスキームを使用しているクライアントは、リダイレクトURIに対する潜在的な攻撃に対して脆弱であるため、このオプションは、前述のより安全なオプションが利用できない場合にのみ使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "To perform an authorization request with a private-use URI scheme redirect, the native app launches the browser with a standard authorization request, but one where the redirect URI utilizes a private-use URI scheme it registered with the operating system.",
      "ja": "プライベート使用URIスキームリダイレクトを使用して承認リクエストを実行するために、ネイティブアプリは標準的な承認リクエストでブラウザを起動しますが、リダイレクトURIがオペレーティングシステムに登録されたプライベート使用URIスキームを利用します。"
    },
    {
      "indent": 3,
      "text": "When choosing a URI scheme to associate with the app, apps MUST use a URI scheme based on a domain name under their control, expressed in reverse order, as recommended by Section 3.8 of [RFC7595] for private-use URI schemes.",
      "ja": "アプリに関連付けるURIスキームを選択する場合、アプリは、プライベート使用URIスキームのために[RFC7595]のセクション3.8で推奨されるように、逆順序で表現されたドメイン名に基づいてURIスキームを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, an app that controls the domain name app.example.com can use com.example.app as their scheme. Some authorization servers assign client identifiers based on domain names, for example, client1234.usercontent.example.net, which can also be used as the domain name for the scheme when reversed in the same manner. A scheme such as myapp, however, would not meet this requirement, as it is not based on a domain name.",
      "ja": "たとえば、ドメイン名App.example.comを制御するアプリは、com.example.appをスキームとして使用できます。一部の承認サーバーは、ドメイン名に基づいてクライアント識別子を割り当てます。たとえば、client1234.usercontent.example.net。同じ方法で逆転したときにスキームのドメイン名として使用できます。ただし、MyAppなどのスキームは、ドメイン名に基づいていないため、この要件を満たしていません。"
    },
    {
      "indent": 3,
      "text": "When there are multiple apps by the same publisher, care must be taken so that each scheme is unique within that group. On platforms that use app identifiers based on reverse-order domain names, those identifiers can be reused as the private-use URI scheme for the OAuth redirect to help avoid this problem.",
      "ja": "同じ出版社によって複数のアプリがある場合、各スキームがそのグループ内で一意になるように注意する必要があります。リバースオーダードメイン名に基づいてアプリ識別子を使用するプラットフォームでは、これらの識別子をOAUTHリダイレクトのプライベート使用URIスキームとして再利用して、この問題を回避することができます。"
    },
    {
      "indent": 3,
      "text": "Following the requirements of Section 3.2 of [RFC3986], as there is no naming authority for private-use URI scheme redirects, only a single slash (/) appears after the scheme component. A complete example of a redirect URI utilizing a private-use URI scheme is:",
      "ja": "[RFC3986]のセクション3.2の要件に従って、個人用URIスキームリダイレクトの命名権限がないため、スキームコンポーネントの後に1つのスラッシュ（/）のみが表示されます。個人用URIスキームを使用しているリダイレクトURIの完全な例は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "com.example.app:/oauth2redirect/example-provider",
      "ja": "com.example.app:/oauth2redirect/example-provider"
    },
    {
      "indent": 3,
      "text": "When the authorization server completes the request, it redirects to the client's redirect URI as it would normally. As the redirect URI uses a private-use URI scheme, it results in the operating system launching the native app, passing in the URI as a launch parameter. Then, the native app uses normal processing for the authorization response.",
      "ja": "Authorization Serverがリクエストを完了すると、通常と同じようにクライアントのリダイレクトURIにリダイレクトします。リダイレクトURIがプライベート使用URIスキームを使用すると、オペレーティングシステムがネイティブアプリを起動し、URIを起動パラメーターとして渡すことになります。次に、ネイティブアプリは、承認応答のために通常の処理を使用します。"
    },
    {
      "indent": 0,
      "text": "8.5. Security Considerations in Native Apps",
      "section_title": true,
      "ja": "8.5. ネイティブアプリのセキュリティ上の考慮事項"
    },
    {
      "indent": 0,
      "text": "8.5.1. Embedded User Agents in Native Apps",
      "section_title": true,
      "ja": "8.5.1. ネイティブアプリに埋め込まれたユーザーエージェント"
    },
    {
      "indent": 3,
      "text": "Embedded user agents are a technically possible method for authorizing native apps. These embedded user agents are unsafe for use by third parties to the authorization server by definition, as the app that hosts the embedded user agent can access the user's full authentication credentials, not just the OAuth authorization grant that was intended for the app.",
      "ja": "組み込みユーザーエージェントは、ネイティブアプリを承認するための技術的に可能な方法です。これらの組み込みユーザーエージェントは、埋め込みユーザーエージェントをホストするアプリは、アプリ向けのOAUTH認証資格情報だけでなく、ユーザーの完全な認証資格情報にアクセスできます。"
    },
    {
      "indent": 3,
      "text": "In typical web-view-based implementations of embedded user agents, the host application can record every keystroke entered in the login form to capture usernames and passwords, automatically submit forms to bypass user consent, and copy session cookies and use them to perform authenticated actions as the user.",
      "ja": "組み込みユーザーエージェントの典型的なWebビューベースの実装では、ホストアプリケーションは、ユーザー名とパスワードをキャプチャするためにログインフォームに入力されたすべてのキーストロークを記録し、ユーザーの同意を自動的に送信し、セッションCookieをコピーしてユーザーとして認証アクションを実行することができます。"
    },
    {
      "indent": 3,
      "text": "Even when used by trusted apps belonging to the same party as the authorization server, embedded user agents violate the principle of least privilege by having access to more powerful credentials than they need, potentially increasing the attack surface.",
      "ja": "Authorization Serverと同じ当事者に属する信頼できるアプリが使用する場合でも、組み込みユーザーエージェントは、必要以上に強力な資格情報にアクセスすることにより、最小特権の原則に違反し、攻撃面を増やす可能性があります。"
    },
    {
      "indent": 3,
      "text": "Encouraging users to enter credentials in an embedded user agent without the usual address bar and visible certificate validation features that browsers have makes it impossible for the user to know if they are signing in to the legitimate site; even when they are, it trains them that it's OK to enter credentials without validating the site first.",
      "ja": "ユーザーが、通常のアドレスバーとブラウザが持つ目に見える証明書の検証機能を使用せずに組み込みユーザーエージェントに資格情報を入力することを奨励することにより、ユーザーが正当なサイトにサインインしているかどうかを知ることができません。彼らがそうであっても、最初にサイトを検証せずに資格情報を入力しても大丈夫だと彼らに訓練します。"
    },
    {
      "indent": 3,
      "text": "Aside from the security concerns, embedded user agents do not share the authentication state with other apps or the browser, requiring the user to log in for every authorization request, which is often considered an inferior user experience.",
      "ja": "セキュリティの懸念とは別に、組み込みユーザーエージェントは認証状態を他のアプリやブラウザと共有していないため、ユーザーは承認リクエストごとにログインする必要があります。"
    },
    {
      "indent": 0,
      "text": "8.5.2. Fake External User-Agents in Native Apps",
      "section_title": true,
      "ja": "8.5.2. ネイティブアプリの偽の外部ユーザーエージェント"
    },
    {
      "indent": 3,
      "text": "The native app that is initiating the authorization request has a large degree of control over the user interface and can potentially present a fake external user agent, that is, an embedded user agent made to appear as an external user agent.",
      "ja": "承認リクエストを開始しているネイティブアプリは、ユーザーインターフェイスを大幅に制御し、偽の外部ユーザーエージェント、つまり外部ユーザーエージェントとして表示される組み込みユーザーエージェントを提示する可能性があります。"
    },
    {
      "indent": 3,
      "text": "When all good actors are using external user agents, the advantage is that it is possible for security experts to detect bad actors, as anyone faking an external user agent is provably bad. On the other hand, if good and bad actors alike are using embedded user agents, bad actors don't need to fake anything, making them harder to detect. Once a malicious app is detected, it may be possible to use this knowledge to blacklist the app's signature in malware scanning software, take removal action (in the case of apps distributed by app stores) and other steps to reduce the impact and spread of the malicious app.",
      "ja": "すべての優れたアクターが外部ユーザーエージェントを使用している場合、外部ユーザーエージェントを偽造する人が証明されているため、セキュリティの専門家が悪い俳優を検出することが可能であるという利点があります。一方、良い俳優と悪い俳優が埋め込まれたユーザーエージェントを使用している場合、悪い俳優は何も偽造する必要はなく、それらを検出するのが難しくなります。悪意のあるアプリが検出されると、この知識を使用して、マルウェアスキャンソフトウェアでアプリの署名をブラックリストに登録し、削除アクション（アプリストアで配布されているアプリの場合）やその他の手順を削除して、悪意のあるアプリの影響と拡散を減らすことができます。"
    },
    {
      "indent": 3,
      "text": "Authorization servers can also directly protect against fake external user agents by requiring an authentication factor only available to true external user agents.",
      "ja": "認証サーバーは、真の外部ユーザーエージェントのみが利用できる認証係数を要求することにより、偽の外部ユーザーエージェントから直接保護することもできます。"
    },
    {
      "indent": 3,
      "text": "Users who are particularly concerned about their security when using in-app browser tabs may also take the additional step of opening the request in the full browser from the in-app browser tab and complete the authorization there, as most implementations of the in-app browser tab pattern offer such functionality.",
      "ja": "アプリ内ブラウザタブを使用する際にセキュリティに特に懸念しているユーザーは、アプリ内ブラウザタブから完全なブラウザでリクエストを開くための追加のステップを実行し、アプリ内ブラウザータブパターンのほとんどの実装がそのような機能を提供するため、そこで認可を完了することもできます。"
    },
    {
      "indent": 0,
      "text": "8.5.3. Malicious External User-Agents in Native Apps",
      "section_title": true,
      "ja": "8.5.3. ネイティブアプリの悪意のある外部ユーザーエージェント"
    },
    {
      "indent": 3,
      "text": "If a malicious app is able to configure itself as the default handler for https scheme URIs in the operating system, it will be able to intercept authorization requests that use the default browser and abuse this position of trust for malicious ends such as phishing the user.",
      "ja": "悪意のあるアプリがオペレーティングシステムのHTTPSスキームURIのデフォルトハンドラーとして自分自身を構成できる場合、デフォルトのブラウザを使用する認証要求を傍受し、ユーザーのフィッシングなどの悪意のある目的のためにこの信頼の位置を悪用することができます。"
    },
    {
      "indent": 3,
      "text": "This attack is not confined to OAuth; a malicious app configured in this way would present a general and ongoing risk to the user beyond OAuth usage by native apps. Many operating systems mitigate this issue by requiring an explicit user action to change the default handler for http and https scheme URIs.",
      "ja": "この攻撃はOAuthに限定されません。この方法で構成された悪意のあるアプリは、ネイティブアプリによるOAuthの使用を超えてユーザーに一般的かつ継続的なリスクを提示します。多くのオペレーティングシステムは、HTTPおよびHTTPSスキームURIのデフォルトハンドラーを変更するために明示的なユーザーアクションを要求することにより、この問題を軽減します。"
    },
    {
      "indent": 0,
      "text": "9. Browser-Based Apps",
      "section_title": true,
      "ja": "9. ブラウザベースのアプリ"
    },
    {
      "indent": 3,
      "text": "Browser-based apps are are clients that run in a web browser, typically written in JavaScript, also known as \"single-page apps\". These types of apps have particular security considerations similar to native apps.",
      "ja": "ブラウザベースのアプリは、通常は「シングルページアプリ」とも呼ばれるJavaScriptで書かれているWebブラウザーで実行されるクライアントです。これらのタイプのアプリには、ネイティブアプリと同様の特別なセキュリティ上の考慮事項があります。"
    },
    {
      "indent": 3,
      "text": "TODO: Bring in the normative text of the browser-based apps BCP when it is finalized.",
      "ja": "TODO：ブラウザベースのアプリBCPの規範的なテキストを最終化したときに持ち込みます。"
    },
    {
      "indent": 0,
      "text": "10. Differences from OAuth 2.0",
      "section_title": true,
      "ja": "10. OAuth 2.0との違い"
    },
    {
      "indent": 3,
      "text": "This draft consolidates the functionality in OAuth 2.0 [RFC6749], OAuth 2.0 for Native Apps ([RFC8252]), Proof Key for Code Exchange ([RFC7636]), OAuth 2.0 for Browser-Based Apps ([I-D.ietf-oauth-browser-based-apps]), OAuth Security Best Current Practice ([I-D.ietf-oauth-security-topics]), and Bearer Token Usage ([RFC6750]).",
      "ja": "このドラフトは、OAUTH 2.0 [RFC6749]、ネイティブアプリ用のOAUTH 2.0（[RFC8252]）、コード交換の証拠キー（[RFC7636]）、ブラウザベースのアプリ向けのOAUTH 2.0（[i-D.IETF-OAUTH-BROWSERベースのBROWSERベースのBROWSERベース）のベストセキュリティ[I] 、およびベアラートークンの使用（[RFC6750]）。"
    },
    {
      "indent": 3,
      "text": "Where a later draft updates or obsoletes functionality found in the original [RFC6749], that functionality in this draft is updated with the normative changes described in a later draft, or removed entirely.",
      "ja": "元の[RFC6749]で見つかった後のドラフトの更新または廃止機能が、このドラフトのその機能が後のドラフトで説明されている規範的な変更で更新されるか、完全に削除されます。"
    },
    {
      "indent": 3,
      "text": "A non-normative list of changes from OAuth 2.0 is listed below:",
      "ja": "OAUTH 2.0からの変更の非規範的なリストを以下に示します。"
    },
    {
      "indent": 3,
      "text": "* The authorization code grant is extended with the functionality from PKCE ([RFC7636]) such that the default method of using the authorization code grant according to this specification requires the addition of the PKCE parameters",
      "ja": "* 承認コード助成金は、PKCE（[RFC7636]）からの機能とともに拡張され、この仕様に従って承認コード助成金を使用するデフォルトの方法には、PKCEパラメーターの追加が必要になります。"
    },
    {
      "indent": 3,
      "text": "* Redirect URIs must be compared using exact string matching as per Section 4.1.3 of [I-D.ietf-oauth-security-topics]",
      "ja": "* [i-d.ietf-oauth-security-topics]のセクション4.1.3に従って、正確な文字列マッチングを使用してURIをリダイレクトする必要があります。"
    },
    {
      "indent": 3,
      "text": "* The Implicit grant (response_type=token) is omitted from this specification as per Section 2.1.2 of [I-D.ietf-oauth-security-topics]",
      "ja": "* [i-d.ietf-oauth-security-topics]のセクション2.1.2に従って、この仕様から暗黙の助成金（Response_type = token）は省略されています。"
    },
    {
      "indent": 3,
      "text": "* The Resource Owner Password Credentials grant is omitted from this specification as per Section 2.4 of [I-D.ietf-oauth-security-topics]",
      "ja": "* [i-d.ietf-oauth-security-topics]のセクション2.4に従って、この仕様からリソース所有者のパスワード資格認定は省略されています。"
    },
    {
      "indent": 3,
      "text": "* Bearer token usage omits the use of bearer tokens in the query string of URIs as per Section 4.3.2 of [I-D.ietf-oauth-security-topics]",
      "ja": "* Bearerトークンの使用は、[i-d.ietf-oauth-security-topics]のセクション4.3.2に従って、urisのクエリ文字列でベアラートークンの使用を省略します。"
    },
    {
      "indent": 3,
      "text": "* Refresh tokens for public clients must either be sender-constrained or one-time use as per Section 4.13.2 of [I-D.ietf-oauth-security-topics]",
      "ja": "* パブリッククライアントのトークンの更新は、[i-d.ietf-oauth-security-topics]のセクション4.13.2に従って、送信者に制約のあるものであるか、1回限りの使用でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* The token endpoint request containing an authorization code no longer contains the redirect_uri parameter",
      "ja": "* 認証コードを含むトークンエンドポイントリクエストには、redirect_uriパラメーターが含まれなくなりました"
    },
    {
      "indent": 0,
      "text": "10.1. Removal of the OAuth 2.0 Implicit grant",
      "section_title": true,
      "ja": "10.1. OAuth 2.0暗黙の助成金の除去"
    },
    {
      "indent": 3,
      "text": "The OAuth 2.0 Implicit grant is omitted from OAuth 2.1 as it was deprecated in [I-D.ietf-oauth-security-topics].",
      "ja": "OAuth 2.0の暗黙的助成金は、[i-d.ietf-oauth-security-topics]で非推奨されているため、OAuth 2.1から省略されています。"
    },
    {
      "indent": 3,
      "text": "The intent of removing the Implicit grant is to no longer issue access tokens in the authorization response, as such tokens are vulnerable to leakage and injection, and are unable to be sender-constrained to a client. This behavior was indicated by clients using the response_type=token parameter. This value for the response_type parameter is no longer defined in OAuth 2.1.",
      "ja": "暗黙の助成金を削除する意図は、そのようなトークンは漏れや注入に対して脆弱であり、クライアントに制約に制約されることができないため、承認対応でアクセストークンを発行しなくなることです。この動作は、response_type = tokenパラメーターを使用してクライアントによって示されました。Response_Typeパラメーターのこの値は、OAUTH 2.1では定義されなくなりました。"
    },
    {
      "indent": 3,
      "text": "Removal of response_type=token does not have an effect on other extension response types returning other artifacts from the authorization endpoint, for example, response_type=id_token defined by [OpenID].",
      "ja": "response_type = tokenの削除は、承認エンドポイントから他のアーティファクトを返す他の拡張応答タイプに影響を与えません。"
    },
    {
      "indent": 0,
      "text": "10.2. Redirect URI Parameter in Token Request",
      "section_title": true,
      "ja": "10.2. トークンリクエストでURIパラメーターをリダイレクトします"
    },
    {
      "indent": 3,
      "text": "In OAuth 2.0, the request to the token endpoint in the authorization code flow (section 4.1.3 of [RFC6749]) contains an optional redirect_uri parameter. The parameter was intended to prevent an authorization code injection attack, and was required if the redirect_uri parameter was sent in the original authorization request. The authorization request only required the redirect_uri parameter if multiple redirect URIs were registered to the specific client. However, in practice, many authorization server implementations required the redirect_uri parameter in the authorization request even if only one was registered, leading the redirect_uri parameter to be required at the token endpoint as well.",
      "ja": "OAUTH 2.0では、認証コードフロー（[RFC6749]のセクション4.1.3）のトークンエンドポイントへの要求には、オプションのRedirect_URIパラメーターが含まれています。このパラメーターは、承認コードインジェクション攻撃を防ぐことを目的としており、Redirect_uriパラメーターが元の承認リクエストで送信された場合に必要でした。承認要求は、複数のリダイレクトURIが特定のクライアントに登録された場合にのみ、Redirect_URIパラメーターを必要としました。ただし、実際には、多くの承認サーバーの実装では、1つだけが登録されていても、承認リクエストでRedirect_URIパラメーターを必要とし、トークンエンドポイントでもRedirect_URIパラメーターを必要とします。"
    },
    {
      "indent": 3,
      "text": "In OAuth 2.1, authorization code injection is prevented by the code_challenge and code_verifier parameters, making the inclusion of the redirect_uri parameter serve no purpose in the token request. As such, it has been removed.",
      "ja": "OAUTH 2.1では、Code_Challengeおよびcode_verifierパラメーターによって承認コードインジェクションが防止されるため、Redirect_uriパラメーターを含めることで、トークンリクエストに目的がありません。そのため、削除されました。"
    },
    {
      "indent": 3,
      "text": "For backwards compatibility of an authorization server wishing to support both OAuth 2.0 and OAuth 2.1 clients, the authorization server MUST allow clients to send the redirect_uri parameter in the token request (Section 4.1.3), and MUST enforce the parameter as described in [RFC6749]. The authorization server can use the client_id in the request to determine whether to enforce this behavior for the specific client that it knows will be using the older OAuth 2.0 behavior.",
      "ja": "OAUTH 2.0とOAUTH 2.1クライアントの両方をサポートする承認サーバーの後方互換性のために、承認サーバーはクライアントがトークン要求（セクション4.1.3）でRedirect_URIパラメーターを送信できるようにし、[RFC6749]で説明されているパラメーターを強制する必要があります。Authorization Serverは、リクエストでClient_IDを使用して、古いOAUTH 2.0動作を使用することがわかっている特定のクライアントのこの動作を実施するかどうかを判断できます。"
    },
    {
      "indent": 3,
      "text": "A client following only the OAuth 2.1 recommendations will not send the redirect_uri in the token request, and therefore will not be compatible with an authorization server that expects the parameter in the token request.",
      "ja": "OAUTH 2.1の推奨事項のみをフォローしているクライアントは、トークンリクエストにRedirect_uriを送信しないため、トークンリクエストのパラメーターを期待する承認サーバーと互換性がありません。"
    },
    {
      "indent": 0,
      "text": "11. IANA Considerations",
      "section_title": true,
      "ja": "11. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document does not require any IANA actions.",
      "ja": "このドキュメントでは、IANAアクションは必要ありません。"
    },
    {
      "indent": 3,
      "text": "All referenced registries are defined by [RFC6749] and related documents that this work is based upon. No changes to those registries are required by this specification.",
      "ja": "参照されるすべてのレジストリは、[RFC6749]およびこの作業が基づいている関連ドキュメントによって定義されます。この仕様では、これらのレジストリの変更は必要ありません。"
    },
    {
      "indent": 0,
      "text": "12. References",
      "section_title": true,
      "ja": "12. 参考文献"
    },
    {
      "indent": 0,
      "text": "12.1. Normative References",
      "section_title": true,
      "ja": "12.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[BCP195] Saint-Andre, P., \"Recommendations for Secure Use of Transport Layer Security (TLS)\", 2015.",
      "ja": "[BCP195] Saint-Andre、P。、「輸送層セキュリティの安全な使用に関する推奨事項（TLS）」、2015年。"
    },
    {
      "indent": 3,
      "text": "[I-D.ietf-oauth-security-topics] Lodderstedt, T., Bradley, J., Labunets, A., and D. Fett, \"OAuth 2.0 Security Best Current Practice\", Work in Progress, Internet-Draft, draft-ietf-oauth-security-topics-23, 5 June 2023, <https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-23>.",
      "ja": "[i-d.ietf-oauth-security-topics] Lodderstedt、T.、Bradley、J.、Labunets、A。、およびD. Fett、「Oauth 2.0 Security Best Current Practice」、Work in Progress、Draft-oauth-Security-Topics-23、5 6月5日、<https：//datatrackrackerg/ oauth-security-topics-23>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487/RFC2119、1997年3月、<https://www.rfc-editor.org/info/rfc2119>"
    },
    {
      "indent": 3,
      "text": "[RFC2617] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A., and L. Stewart, \"HTTP Authentication: Basic and Digest Access Authentication\", RFC 2617, DOI 10.17487/RFC2617, June 1999, <https://www.rfc-editor.org/info/rfc2617>.",
      "ja": "[RFC2617] Franks、J.、Hallam-Baker、P.、Hostetler、J.、Lawrence、S.、Leach、P.、Luotonen、A.、およびL. Stewart、「HTTP認証：基本および消化アクセス認証」、RFC 2617、DOI 10.17487/RFC2617 o/rfc2617>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <https://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986] Berners-Lee、T.、Fielding、R。、およびL. Masinter、「Uniform Resource Identifier（URI）：Generic Syntax」、Std 66、RFC 3986、DOI 10.17487/RFC3986、2005年1月、<https:/"
    },
    {
      "indent": 3,
      "text": "[RFC4949] Shirey, R., \"Internet Security Glossary, Version 2\", FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007, <https://www.rfc-editor.org/info/rfc4949>.",
      "ja": "[RFC4949] Shirey、R。、「インターネットセキュリティ用語集、バージョン2」、FYI 36、RFC 4949、DOI 10.17487/RFC4949、2007年8月、<https://www.rfc-editor.org/info/rfc4949>"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, <https://www.rfc-editor.org/info/rfc5234>.",
      "ja": "[RFC5234] Crocker、D.、ed。P. Overell、「構文仕様のための拡張BNF：ABNF：STD 68、RFC 5234、DOI 10.17487/RFC5234、2008年1月、<https://www.rfc-editor.org/info/rfc5234>。"
    },
    {
      "indent": 3,
      "text": "[RFC6749] Hardt, D., Ed., \"The OAuth 2.0 Authorization Framework\", RFC 6749, DOI 10.17487/RFC6749, October 2012, <https://www.rfc-editor.org/info/rfc6749>.",
      "ja": "[RFC6749] Hardt、D.、ed。、「The Oauth 2.0 Authorization Framework」、RFC 6749、DOI 10.17487/RFC6749、2012年10月、<https://www.rfc-editor.org/info/rfc6749>"
    },
    {
      "indent": 3,
      "text": "[RFC6750] Jones, M. and D. Hardt, \"The OAuth 2.0 Authorization Framework: Bearer Token Usage\", RFC 6750, DOI 10.17487/RFC6750, October 2012, <https://www.rfc-editor.org/info/rfc6750>.",
      "ja": "[RFC6750]ジョーンズ、M。およびD.ハード、「OAuth 2.0認証フレームワーク：ベアラートークン使用量」、RFC 6750、DOI 10.17487/RFC6750、2012年10月、<https://www.rfc-editor.org/info/rfc6750>"
    },
    {
      "indent": 3,
      "text": "[RFC7159] Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data Interchange Format\", RFC 7159, DOI 10.17487/RFC7159, March 2014, <https://www.rfc-editor.org/info/rfc7159>.",
      "ja": "[RFC7159] Bray、T.、ed。、「JavaScriptオブジェクト表記（JSON）データインターチェンジ形式」、RFC 7159、DOI 10.17487/RFC7159、2014年3月、<https://www.rfc-editor.org/info/rfc7159>。"
    },
    {
      "indent": 3,
      "text": "[RFC7235] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Authentication\", RFC 7235, DOI 10.17487/RFC7235, June 2014, <https://www.rfc-editor.org/info/rfc7235>.",
      "ja": "[RFC7235] Fielding、R.、ed。and J. Reschke、ed。、「HyperText Transfer Protocol（HTTP/1.1）：認証」、RFC 7235、DOI 10.17487/RFC7235、2014年6月、<https://www.rfc-editor.org/info/rfc7235>"
    },
    {
      "indent": 3,
      "text": "[RFC7521] Campbell, B., Mortimore, C., Jones, M., and Y. Goland, \"Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants\", RFC 7521, DOI 10.17487/RFC7521, May 2015, <https://www.rfc-editor.org/info/rfc7521>.",
      "ja": "[RFC7521] Campbell、B.、Mortimore、C.、Jones、M。、およびY. Goland、「OAUTH 2.0クライアント認証と認証助成金のアサーションフレームワーク」、RFC 7521、DOI 10.17487/RFC7521、2015年5月、<https：/<https ://"
    },
    {
      "indent": 3,
      "text": "[RFC7523] Jones, M., Campbell, B., and C. Mortimore, \"JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants\", RFC 7523, DOI 10.17487/RFC7523, May 2015, <https://www.rfc-editor.org/info/rfc7523>.",
      "ja": "[RFC7523] Jones、M.、Campbell、B。、およびC. Mortimore、「OAUTH 2.0クライアント認証と認証助成金のJSON Webトークン（JWT）プロファイル」、RFC 7523、DOI 10.17487"
    },
    {
      "indent": 3,
      "text": "[RFC7595] Thaler, D., Ed., Hansen, T., and T. Hardie, \"Guidelines and Registration Procedures for URI Schemes\", BCP 35, RFC 7595, DOI 10.17487/RFC7595, June 2015, <https://www.rfc-editor.org/info/rfc7595>.",
      "ja": "[RFC7595] Thaler、D.、ed。、Hansen、T.、およびT. Hardie、「URIスキームのガイドラインと登録手順」、BCP 35、RFC 7595、DOI 10.17487"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487/RFC8174、5月、<https：//www.rfc-editor.org/info/-urfc8174>"
    },
    {
      "indent": 3,
      "text": "[RFC8252] Denniss, W. and J. Bradley, \"OAuth 2.0 for Native Apps\", BCP 212, RFC 8252, DOI 10.17487/RFC8252, October 2017, <https://www.rfc-editor.org/info/rfc8252>.",
      "ja": "[RFC8252] Denniss、W。and J. Bradley、「ネイティブアプリのOAuth 2.0」、BCP 212、RFC 8252、DOI 10.17487/RFC8252、2017年10月、<https://www.rfc-editor.org/info/rfc8252>。"
    },
    {
      "indent": 3,
      "text": "[RFC8259] Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data Interchange Format\", STD 90, RFC 8259, DOI 10.17487/RFC8259, December 2017, <https://www.rfc-editor.org/info/rfc8259>.",
      "ja": "[RFC8259] Bray、T.、ed。、「JavaScriptオブジェクト表記（JSON）データインターチェンジ形式」、STD 90、RFC 8259、DOI 10.17487/RFC8259、2017年12月、<https：//www.rfc-editor.org/info/RFC8259>"
    },
    {
      "indent": 3,
      "text": "[RFC8446] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.",
      "ja": "[RFC8446] Rescorla、E。、「輸送層セキュリティ（TLS）プロトコルバージョン1.3」、RFC 8446、DOI 10.17487/RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc846>"
    },
    {
      "indent": 3,
      "text": "[RFC9110] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \"HTTP Semantics\", STD 97, RFC 9110, DOI 10.17487/RFC9110, June 2022, <https://www.rfc-editor.org/info/rfc9110>.",
      "ja": "[RFC9110] Fielding、R.、Ed。、Ed。、Nottingham、M.、ed。、およびJ. Reschke、ed。、 \"HTTP Semantics\"、Std 97、RFC 9110、DOI 10.17487/RFC9110、2022年6月、<https://ww.rfc-editor.org/fo/-urfo/-fo/"
    },
    {
      "indent": 3,
      "text": "[RFC9111] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \"HTTP Caching\", STD 98, RFC 9111, DOI 10.17487/RFC9111, June 2022, <https://www.rfc-editor.org/info/rfc9111>.",
      "ja": "[RFC9111] Fielding、R.、ed。、Nottingham、M.、ed。、およびJ. Reschke、ed。、 \"Http Caching\"、Std 98、RFC 9111、doi 10.17487/rfc9111、2022年6月、<https://ww.rfc-editor.org/fo/-urfo/"
    },
    {
      "indent": 3,
      "text": "[RFC9207] Meyer zu Selhausen, K. and D. Fett, \"OAuth 2.0 Authorization Server Issuer Identification\", RFC 9207, DOI 10.17487/RFC9207, March 2022, <https://www.rfc-editor.org/info/rfc9207>.",
      "ja": "[RFC9207] Meyer Zu Selhausen、K。およびD. Fett、「OAuth 2.0 Authorization Server発行者識別」、RFC 9207、DOI 10.17487/RFC9207、2022年3月、<https://www.rfc-editor.org/info/rfc9207>。"
    },
    {
      "indent": 3,
      "text": "[USASCII] Institute, A. N. S., \"Coded Character Set -- 7-bit American Standard Code for Information Interchange, ANSI X3.4\", 1986.",
      "ja": "[US ASCII] Institute、A。N. D.、「コード化された文字セット-7ビットアメリカ標準コードの情報インターチェンジ、ANSI X3.4」、1986。"
    },
    {
      "indent": 3,
      "text": "[W3C.REC-xml-20081126] Bray, T., Paoli, J., Sperberg-McQueen, C. M., Maler, E., and F. Yergeau, \"Extensible Markup Language\", November 2008, <https://www.w3.org/TR/REC-xml/REC-xml-20081126.xml>.",
      "ja": "[W3C.REC-XML-20081126] Bray、T.、Paoli、J.、Sperberg-Mcqueen、C。M.、Maler、E。、およびF. Yergeau、「拡張可能なマークアップ言語」、2008年11月、<https://www.w3.org/tr/rec-xml/rec-xml-20081126.xml>。"
    },
    {
      "indent": 3,
      "text": "[WHATWG.CORS] WHATWG, \"Fetch Standard: CORS protocol\", June 2023, <https://fetch.spec.whatwg.org/#http-cors-protocol>.",
      "ja": "[whatwg.cors] whatwg、 \"Fetch Standard：Cors Protocol\"、2023年6月、<https://fetch.spec.whatwg.org/#http-cors-protocol>。"
    },
    {
      "indent": 3,
      "text": "[WHATWG.URL] WHATWG, \"URL\", May 2022, <https://url.spec.whatwg.org/>.",
      "ja": "[whatwg.url] whatwg、 \"url\"、2022年5月、<https://url.spec.whatwg.org/>。"
    },
    {
      "indent": 0,
      "text": "12.2. Informative References",
      "section_title": true,
      "ja": "12.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[CSP-2] \"Content Security Policy Level 2\", December 2016, <https://www.w3.org/TR/CSP2>.",
      "ja": "[CSP-2]「コンテンツセキュリティポリシーレベル2」、2016年12月、<https://www.w3.org/tr/csp2>。"
    },
    {
      "indent": 3,
      "text": "[I-D.bradley-oauth-jwt-encoded-state] Bradley, J., Lodderstedt, T., and H. Zandbelt, \"Encoding claims in the OAuth 2 state parameter using a JWT\", Work in Progress, Internet-Draft, draft-bradley-oauth-jwt-encoded-state-09, 4 November 2018, <https://datatracker.ietf.org/doc/html/draft-bradley-oauth-jwt-encoded-state-09>.",
      "ja": "[i-d.bradley-oauth-jwt-encoded-state] Bradley、J.、Lodderstedt、T。、およびH. Zandbelt、「JWTを使用したOAuth 2状態パラメーターのクレームをエンコードする」、進行中の作業、インターネットドラフト、ドラフト - ブラドリー-JWT-JWT-ENCODED-STATE-09、4 h.4 .org/doc/html/draft-bradley-oauth-jwt-encoded-state-09>。"
    },
    {
      "indent": 3,
      "text": "[I-D.ietf-oauth-browser-based-apps] Parecki, A. and D. Waite, \"OAuth 2.0 for Browser-Based Apps\", Work in Progress, Internet-Draft, draft-ietf-oauth-browser-based-apps-14, 29 June 2023, <https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps-14>.",
      "ja": "[i-d.ietf-oauth-browserベースのアプリ] Parecki、A。and D. Waite、 \"Oauth 2.0 for browserベースのアプリ]、作業中の作業、インターネットドラフト、ドラフト -  oauth-browser base-apps-14、29 6月29 -Apps-14>。"
    },
    {
      "indent": 3,
      "text": "[I-D.ietf-oauth-dpop] Fett, D., Campbell, B., Bradley, J., Lodderstedt, T., Jones, M. B., and D. Waite, \"OAuth 2.0 Demonstrating Proof-of-Possession at the Application Layer (DPoP)\", Work in Progress, Internet-Draft, draft-ietf-oauth-dpop-16, 13 April 2023, <https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop-16>.",
      "ja": "[i-d.ietf-oauth-dpop] fett、D.、Campbell、B.、Bradley、J.、Lodderstedt、T.、Jones、M。B.、およびD. Waite、「Oauth 2.0アプリケーション層（DPOP）でのプルーフの証明」 org/doc/html/draft-itf-oauth-dpop-16>。"
    },
    {
      "indent": 3,
      "text": "[I-D.ietf-oauth-token-binding] Jones, M., Campbell, B., Bradley, J., and W. Denniss, \"OAuth 2.0 Token Binding\", Work in Progress, Internet-Draft, draft-ietf-oauth-token-binding-08, 19 October 2018, <https://datatracker.ietf.org/doc/html/draft-ietf-oauth-token-binding-08>.",
      "ja": "[i-d.ietf-oauth-token Binding]ジョーンズ、M。、キャンベル、B。、ブラッドリー、J。、およびW.デニス、「Oauth 2.0トークンバインディング」、ワークインターネットドラフト、ドラフト-oauth-token-token-token-token-binding-08、10 10月19日、<https:/ inding-08>。"
    },
    {
      "indent": 3,
      "text": "[NIST800-63] Burr, W., Dodson, D., Newton, E., Perlner, R., Polk, T., Gupta, S., and E. Nabbus, \"NIST Special Publication 800-63-1, INFORMATION SECURITY\", December 2011, <http://csrc.nist.gov/publications/>.",
      "ja": "[Nist800-63] Burr、W.、Dodson、D.、Newton、E.、Perlner、R.、Polk、T.、Gupta、S.、およびE. Nabbus、 \"Nist Special Publication 800-63-1、Information Security\"、<http://csrc.nist.gov/publications/>。"
    },
    {
      "indent": 3,
      "text": "[OMAP] Huff, J., Schlacht, D., Nadalin, A., Simmons, J., Rosenberg, P., Madsen, P., Ace, T., Rickelton-Abdi, C., and B. Boyer, \"Online Multimedia Authorization Protocol: An Industry Standard for Authorized Access to Internet Multimedia Resources\", August 2012, <https://www.svta.org/product/online-multimedia-authorization-protocol/>.",
      "ja": "[Omap] Huff、J.、Schlacht、D.、Nadalin、A.、Simmons、J.、Rosenberg、P.、Madsen、P.、Ace、T.、Rickelton-Abdi、C.、およびB. Boyer、「オンラインマルチメディア認証プロトコル：インターネットマルチメディアリソースへの認定アクセスのための業界標準」 Imedia-authorization-protocol/>。"
    },
    {
      "indent": 3,
      "text": "[OpenID] Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and C. Mortimore, \"OpenID Connect Core 1.0\", November 2014, <https://openid.net/specs/openid-connect-core-1_0.html>.",
      "ja": "[Openid] Sakimura、N.、Bradley、J.、Jones、M.、De Medeiros、B。、およびC. Mortimore、 \"Openid Connect Core 1.0\"、<https://openid.net/specs/openid-connect-core-1_0.html>。"
    },
    {
      "indent": 3,
      "text": "[OpenID.Messages] Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., Mortimore, C., and E. Jay, \"OpenID Connect Messages 1.0\", June 2012, <http://openid.net/specs/openid-connect-messages-1_0.html>.",
      "ja": "[OpenID.Messages] Sakimura、N.、Bradley、J.、Jones、M.、De Medeiros、B.、Mortimore、C。、およびE. Jay、 \"OpenID Connect Messages 1.0\"、<http://openid.net/specs/openid/openid-connect-messages-1_0.html>。"
    },
    {
      "indent": 3,
      "text": "[owasp_redir] \"OWASP Cheat Sheet Series - Unvalidated Redirects and Forwards\", 2020, <https://cheatsheetseries.owasp.org/cheatsheets/ Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html>.",
      "ja": "[owasp_redir] \"owaspチートシートシリーズ - 未検証リダイレクトとフォワード\"、2020、<https://cheatsheetseries.owasp.org/cheatsheets/ unvalidated_redirects_and_forwards_cheat_sheet.html>。"
    },
    {
      "indent": 3,
      "text": "[RFC6265] Barth, A., \"HTTP State Management Mechanism\", RFC 6265, DOI 10.17487/RFC6265, April 2011, <https://www.rfc-editor.org/info/rfc6265>.",
      "ja": "[RFC6265] Barth、A。、「HTTP状態管理メカニズム」、RFC 6265、DOI 10.17487/RFC6265、2011年4月、<https://www.rfc-editor.org/info/rfc6265>。"
    },
    {
      "indent": 3,
      "text": "[RFC6819] Lodderstedt, T., Ed., McGloin, M., and P. Hunt, \"OAuth 2.0 Threat Model and Security Considerations\", RFC 6819, DOI 10.17487/RFC6819, January 2013, <https://www.rfc-editor.org/info/rfc6819>.",
      "ja": "[RFC6819] LodderStedt、T.、Ed。、McGloin、M.、およびP. Hunt、「OAuth 2.0の脅威モデルとセキュリティの考慮事項」、RFC 6819、DOI 10.17487/RFC6819、2013年1月、<https://www.rfc-editor.org/info/"
    },
    {
      "indent": 3,
      "text": "[RFC7009] Lodderstedt, T., Ed., Dronia, S., and M. Scurtescu, \"OAuth 2.0 Token Revocation\", RFC 7009, DOI 10.17487/RFC7009, August 2013, <https://www.rfc-editor.org/info/rfc7009>.",
      "ja": "[RFC7009] LodderStedt、T.、Ed。、Dronia、S。、およびM. Scurtescu、「Oauth 2.0トークンRegocation」、RFC 7009、DOI 10.17487/RFC7009、2013年8月、<https：//www.rfc-editor.org/info/-urfc7009>"
    },
    {
      "indent": 3,
      "text": "[RFC7519] Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Token (JWT)\", RFC 7519, DOI 10.17487/RFC7519, May 2015, <https://www.rfc-editor.org/info/rfc7519>.",
      "ja": "[RFC7519] Jones、M.、Bradley、J。、およびN. Sakimura、「JSON Web Token（JWT）」、RFC 7519、DOI 10.17487/RFC7519、2015年5月<https：//www.rfc-editor.org/fo/rfc7519>"
    },
    {
      "indent": 3,
      "text": "[RFC7591] Richer, J., Ed., Jones, M., Bradley, J., Machulak, M., and P. Hunt, \"OAuth 2.0 Dynamic Client Registration Protocol\", RFC 7591, DOI 10.17487/RFC7591, July 2015, <https://www.rfc-editor.org/info/rfc7591>.",
      "ja": "[RFC7591] Richer、J.、Ed。、Jones、M.、Bradley、J.、Machulak、M.、およびP. Hunt、「OAuth 2.0ダイナミッククライアント登録プロトコル」、RFC 7591、DOI 10.17487/RFC7591、2015年7月、<https ://"
    },
    {
      "indent": 3,
      "text": "[RFC7592] Richer, J., Ed., Jones, M., Bradley, J., and M. Machulak, \"OAuth 2.0 Dynamic Client Registration Management Protocol\", RFC 7592, DOI 10.17487/RFC7592, July 2015, <https://www.rfc-editor.org/info/rfc7592>.",
      "ja": "[RFC7592] Richer、J.、ed。、ed。、Jones、M.、Bradley、J.、およびM. Machulak、「OAUTH 2.0 Dynamic Client Registration Management Protocol \"、RFC 7592、DOI 10.17487/RFC7592、2015年7月、<https://ww.rfc-editor.org/info/"
    },
    {
      "indent": 3,
      "text": "[RFC7636] Sakimura, N., Ed., Bradley, J., and N. Agarwal, \"Proof Key for Code Exchange by OAuth Public Clients\", RFC 7636, DOI 10.17487/RFC7636, September 2015, <https://www.rfc-editor.org/info/rfc7636>.",
      "ja": "[RFC7636] Sakimura、N.、Ed。、Bradley、J。、およびN. Agarwal、「Oauth Public Clientsによるコード交換の証拠鍵」、RFC 7636、DOI 10.17487/RFC7636、2015年9月、<https://ww.rfc-editor.orfc/-fc/-fc/.-fu/-fc76>。"
    },
    {
      "indent": 3,
      "text": "[RFC7662] Richer, J., Ed., \"OAuth 2.0 Token Introspection\", RFC 7662, DOI 10.17487/RFC7662, October 2015, <https://www.rfc-editor.org/info/rfc7662>.",
      "ja": "[RFC7662] Richer、J.、ed。、「Oauth 2.0トークン内注文」、RFC 7662、DOI 10.17487/RFC7662、2015年10月、<https://www.rfc-editor.org/info/rfc762>"
    },
    {
      "indent": 3,
      "text": "[RFC8414] Jones, M., Sakimura, N., and J. Bradley, \"OAuth 2.0 Authorization Server Metadata\", RFC 8414, DOI 10.17487/RFC8414, June 2018, <https://www.rfc-editor.org/info/rfc8414>.",
      "ja": "[RFC8414] Jones、M.、Sakimura、N。、およびJ. Bradley、 \"Oauth 2.0 Authorization Server Metadata\"、RFC 8414、DOI 10.17487/RFC8414、2018年6月、<https：//www.rfc-editor.org/info/-rfc8414>"
    },
    {
      "indent": 3,
      "text": "[RFC8628] Denniss, W., Bradley, J., Jones, M., and H. Tschofenig, \"OAuth 2.0 Device Authorization Grant\", RFC 8628, DOI 10.17487/RFC8628, August 2019, <https://www.rfc-editor.org/info/rfc8628>.",
      "ja": "[RFC8628] Denniss、W.、Bradley、J.、Jones、M。、およびH. Tschofenig、「Oauth 2.0 Device Authorization Grant」、RFC 8628、DOI 10.17487/RFC8628、2019年8月、<https://ww.rfc-editor.orfc8628>。"
    },
    {
      "indent": 3,
      "text": "[RFC8705] Campbell, B., Bradley, J., Sakimura, N., and T. Lodderstedt, \"OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens\", RFC 8705, DOI 10.17487/RFC8705, February 2020, <https://www.rfc-editor.org/info/rfc8705>.",
      "ja": "[RFC8705] Campbell、B.、Bradley、J.、Sakimura、N。、およびT. Lodderstedt、「OAUTH 2.0相互TLSクライアント認証と証明書バウンドアクセストークン」、RFC 8705、DOI 10.17487/RFC8705、February 2020、<htps： 705>。"
    },
    {
      "indent": 3,
      "text": "[RFC8707] Campbell, B., Bradley, J., and H. Tschofenig, \"Resource Indicators for OAuth 2.0\", RFC 8707, DOI 10.17487/RFC8707, February 2020, <https://www.rfc-editor.org/info/rfc8707>.",
      "ja": "[RFC8707] Campbell、B.、Bradley、J。、およびH. Tschofenig、「OAUTH 2.0のリソースインジケーター」、RFC 8707、DOI 10.17487/RFC8707、2020年2月、<https：//www.rfc-editor.org/info/-urfc8707>"
    },
    {
      "indent": 3,
      "text": "[RFC9068] Bertocci, V., \"JSON Web Token (JWT) Profile for OAuth 2.0 Access Tokens\", RFC 9068, DOI 10.17487/RFC9068, October 2021, <https://www.rfc-editor.org/info/rfc9068>.",
      "ja": "[RFC9068] Bertocci、V。、 \"Json Web Token（JWT）Profile for OAuth 2.0 Access Tokens\"、RFC 9068、DOI 10.17487/RFC9068、2021年10月、<https：//www.rfc-editor.org/fo/rfc9068>"
    },
    {
      "indent": 3,
      "text": "[RFC9126] Lodderstedt, T., Campbell, B., Sakimura, N., Tonge, D., and F. Skokan, \"OAuth 2.0 Pushed Authorization Requests\", RFC 9126, DOI 10.17487/RFC9126, September 2021, <https://www.rfc-editor.org/info/rfc9126>.",
      "ja": "[RFC9126] LodderStedt、T.、Campbell、B.、Sakimura、N.、Tonge、D。、およびF. Skokan、「Oauth 2.0プッシュ承認要求」、RFC 9126、DOI 10.17487/RFC9126、2021年9月< 。"
    },
    {
      "indent": 3,
      "text": "[RFC9396] Lodderstedt, T., Richer, J., and B. Campbell, \"OAuth 2.0 Rich Authorization Requests\", RFC 9396, DOI 10.17487/RFC9396, May 2023, <https://www.rfc-editor.org/info/rfc9396>.",
      "ja": "[RFC9396] LodderStedt、T.、Richer、J。、およびB. Campbell、「OAuth 2.0リッチ認証リクエスト」、RFC 9396、DOI 10.17487/RFC9396、2023年5月、<https：//www.rfc-editor.org/fo/rfc9396>"
    },
    {
      "indent": 0,
      "text": "Appendix A. Augmented Backus-Naur Form (ABNF) Syntax",
      "ja": "付録A. 増強されたBackus-Naurフォーム（ABNF）構文"
    },
    {
      "indent": 3,
      "text": "This section provides Augmented Backus-Naur Form (ABNF) syntax descriptions for the elements defined in this specification using the notation of [RFC5234]. The ABNF below is defined in terms of Unicode code points [W3C.REC-xml-20081126]; these characters are typically encoded in UTF-8. Elements are presented in the order first defined.",
      "ja": "このセクションでは、[RFC5234]の表記法を使用して、この仕様で定義されている要素の拡張されたBackus-NAURフォーム（ABNF）構文の説明を提供します。以下のABNFは、Unicodeコードポイント[W3C.REC-XML-20081126]の観点から定義されています。これらの文字は通常、UTF-8でエンコードされます。要素は、最初に定義された順序で表示されます。"
    },
    {
      "indent": 3,
      "text": "Some of the definitions that follow use the \"URI-reference\" definition from [RFC3986].",
      "ja": "以下の定義のいくつかは、[RFC3986]の「URI-Reference」定義を使用しています。"
    },
    {
      "indent": 3,
      "text": "Some of the definitions that follow use these common definitions:\n   VSCHAR     = %x20-7E\nNQCHAR     = %x21 / %x23-5B / %x5D-7E\nNQSCHAR    = %x20-21 / %x23-5B / %x5D-7E",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1. \"client_id\" Syntax",
      "section_title": true,
      "ja": "A.1. 「client_id」構文"
    },
    {
      "indent": 3,
      "text": "The client_id element is defined in Section 2.4.1:",
      "ja": "client_id要素は、セクション2.4.1で定義されています。"
    },
    {
      "indent": 3,
      "text": "client-id     = *VSCHAR",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2. \"client_secret\" Syntax",
      "section_title": true,
      "ja": "A.2. 「client_secret」構文"
    },
    {
      "indent": 3,
      "text": "The client_secret element is defined in Section 2.4.1:",
      "ja": "client_secret要素は、セクション2.4.1で定義されています。"
    },
    {
      "indent": 3,
      "text": "client-secret = *VSCHAR",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3. \"response_type\" Syntax",
      "section_title": true,
      "ja": "A.3. 「Response_Type」構文"
    },
    {
      "indent": 3,
      "text": "The response_type element is defined in Section 4.1.1 and Section 6.4:",
      "ja": "Response_Type要素は、セクション4.1.1およびセクション6.4で定義されています。"
    },
    {
      "indent": 3,
      "text": "response-type = response-name *( SP response-name )\nresponse-name = 1*response-char\nresponse-char = \"_\" / DIGIT / ALPHA",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4. \"scope\" Syntax",
      "section_title": true,
      "ja": "A.4. 「スコープ」構文"
    },
    {
      "indent": 3,
      "text": "The scope element is defined in Section 3.2.2.1:",
      "ja": "スコープ要素は、セクション3.2.2.1で定義されています。"
    },
    {
      "indent": 4,
      "text": "scope       = scope-token *( SP scope-token )\nscope-token = 1*NQCHAR",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5. \"state\" Syntax",
      "section_title": true,
      "ja": "A.5. 「状態」構文"
    },
    {
      "indent": 3,
      "text": "The state element is defined in Section 4.1.1, Section 4.1.2, and Section 4.1.2.1:",
      "ja": "状態要素は、セクション4.1.1、セクション4.1.2、およびセクション4.1.2.1で定義されています。"
    },
    {
      "indent": 4,
      "text": "state      = 1*VSCHAR",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.6. \"redirect_uri\" Syntax",
      "section_title": true,
      "ja": "A.6. 「Redirect_uri」構文"
    },
    {
      "indent": 3,
      "text": "The redirect_uri element is defined in Section 4.1.1, and Section 4.1.3:",
      "ja": "Redirect_uri要素は、セクション4.1.1、およびセクション4.1.3で定義されています。"
    },
    {
      "indent": 4,
      "text": "redirect-uri      = URI-reference",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.7. \"error\" Syntax",
      "section_title": true,
      "ja": "A.7. 「エラー」構文"
    },
    {
      "indent": 3,
      "text": "The error element is defined in Sections Section 4.1.2.1, Section 3.2.3.1, 7.2, and 8.5:",
      "ja": "エラー要素は、セクション4.1.2.1、セクション3.2.3.1、7.2、および8.5で定義されています。"
    },
    {
      "indent": 4,
      "text": "error             = 1*NQSCHAR",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.8. \"error_description\" Syntax",
      "section_title": true,
      "ja": "A.8. 「error_description」構文"
    },
    {
      "indent": 3,
      "text": "The error_description element is defined in Sections Section 4.1.2.1, Section 3.2.3.1, and Section 5.3:",
      "ja": "ERROR_Description要素は、セクション4.1.2.1、セクション3.2.3.1、およびセクション5.3で定義されています。"
    },
    {
      "indent": 4,
      "text": "error-description = 1*NQSCHAR",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.9. \"error_uri\" Syntax",
      "section_title": true,
      "ja": "A.9. 「error_uri」構文"
    },
    {
      "indent": 3,
      "text": "The error_uri element is defined in Sections Section 4.1.2.1, Section 3.2.3.1, and 7.2:",
      "ja": "ERROR_URI要素は、セクション4.1.2.1、セクション3.2.3.1、および7.2で定義されています。"
    },
    {
      "indent": 4,
      "text": "error-uri         = URI-reference",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.10. \"grant_type\" Syntax",
      "section_title": true,
      "ja": "A.10. 「grant_type」構文"
    },
    {
      "indent": 3,
      "text": "The grant_type element is defined in Section Section 3.2.2:",
      "ja": "grant_type要素は、セクション3.2.2のセクションで定義されています。"
    },
    {
      "indent": 4,
      "text": "grant-type = grant-name / URI-reference\ngrant-name = 1*name-char\nname-char  = \"-\" / \".\" / \"_\" / DIGIT / ALPHA",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.11. \"code\" Syntax",
      "section_title": true,
      "ja": "A.11. 「コード」構文"
    },
    {
      "indent": 3,
      "text": "The code element is defined in Section 4.1.3:",
      "ja": "コード要素は、セクション4.1.3で定義されています。"
    },
    {
      "indent": 4,
      "text": "code       = 1*VSCHAR",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.12. \"access_token\" Syntax",
      "section_title": true,
      "ja": "A.12. 「Access_Token」構文"
    },
    {
      "indent": 3,
      "text": "The access_token element is defined in Section 3.2.3:",
      "ja": "Access_Token要素は、セクション3.2.3で定義されています。"
    },
    {
      "indent": 4,
      "text": "access-token = 1*VSCHAR",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.13. \"token_type\" Syntax",
      "section_title": true,
      "ja": "A.13. 「token_type」構文"
    },
    {
      "indent": 3,
      "text": "The token_type element is defined in Section 3.2.3, and Section 6.1:",
      "ja": "token_type要素は、セクション3.2.3、およびセクション6.1で定義されています。"
    },
    {
      "indent": 4,
      "text": "token-type = type-name / URI-reference\ntype-name  = 1*name-char\nname-char  = \"-\" / \".\" / \"_\" / DIGIT / ALPHA",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.14. \"expires_in\" Syntax",
      "section_title": true,
      "ja": "A.14. 「expires_in」構文"
    },
    {
      "indent": 3,
      "text": "The expires_in element is defined in Section 3.2.3:",
      "ja": "Expires_in要素は、セクション3.2.3で定義されています。"
    },
    {
      "indent": 4,
      "text": "expires-in = 1*DIGIT",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.15. \"refresh_token\" Syntax",
      "section_title": true,
      "ja": "A.15. 「REFRESH_TOKEN」構文"
    },
    {
      "indent": 3,
      "text": "The refresh_token element is defined in Section 3.2.3 and Section 4.3:",
      "ja": "更新要素は、セクション3.2.3およびセクション4.3で定義されています。"
    },
    {
      "indent": 4,
      "text": "refresh-token = 1*VSCHAR",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.16. Endpoint Parameter Syntax",
      "section_title": true,
      "ja": "A.16. エンドポイントパラメーター構文"
    },
    {
      "indent": 3,
      "text": "The syntax for new endpoint parameters is defined in Section 6.2:",
      "ja": "新しいエンドポイントパラメーターの構文は、セクション6.2で定義されています。"
    },
    {
      "indent": 4,
      "text": "param-name = 1*name-char\nname-char  = \"-\" / \".\" / \"_\" / DIGIT / ALPHA",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.17. \"code_verifier\" Syntax",
      "section_title": true,
      "ja": "A.17. 「code_verifier」構文"
    },
    {
      "indent": 3,
      "text": "ABNF for code_verifier is as follows.",
      "ja": "code_verifierのabnfは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "code-verifier = 43*128unreserved\nunreserved = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\nALPHA = %x41-5A / %x61-7A\nDIGIT = %x30-39",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.18. \"code_challenge\" Syntax",
      "section_title": true,
      "ja": "A.18. 「code_challenge」構文"
    },
    {
      "indent": 3,
      "text": "ABNF for code_challenge is as follows.",
      "ja": "code_challengeのabnfは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "code-challenge = 43*128unreserved\nunreserved = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\nALPHA = %x41-5A / %x61-7A\nDIGIT = %x30-39",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix B. Use of application/x-www-form-urlencoded Media Type",
      "ja": "付録B. アプリケーション/X-WWW-Form-Urlencodedメディアタイプの使用"
    },
    {
      "indent": 3,
      "text": "TBD: Describe OAuth's use of application/x-www-form-urlencoded encoding, both for URL parameters as well as for the client_id and secret encoding.",
      "ja": "TBD：URLパラメーターとclient_idおよびsecretエンコーディングの両方で、OAUTHのアプリケーション/x-www-form-urlencodedエンコードの使用について説明します。"
    },
    {
      "indent": 3,
      "text": "GitHub discussion: https://github.com/oauth-wg/oauth-v2-1/issues/128\n(https://github.com/oauth-wg/oauth-v2-1/issues/128)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix C. Extensions",
      "section_title": true,
      "ja": "付録C. 拡張機能"
    },
    {
      "indent": 3,
      "text": "Below is a list of well-established extensions at the time of publication:",
      "ja": "以下は、公開時の定評のある拡張機能のリストです。"
    },
    {
      "indent": 3,
      "text": "* [RFC8628]: OAuth 2.0 Device Authorization Grant",
      "ja": "* [RFC8628]：OAUTH 2.0デバイス認証助成金"
    },
    {
      "indent": 6,
      "text": "- The Device Authorization Grant (formerly known as the Device Flow) is an extension that enables devices with no browser or limited input capability to obtain an access token. This is commonly used by smart TV apps, or devices like hardware video encoders that can stream video to a streaming video service.",
      "ja": "- デバイス認証助成金（以前はデバイスフローとして知られていました）は、ブラウザや入力機能が限られていないデバイスがアクセストークンを取得できるようにする拡張機能です。これは、一般的にスマートテレビアプリ、またはビデオをストリーミングビデオサービスにストリーミングできるハードウェアビデオエンコーダーなどのデバイスで使用されます。"
    },
    {
      "indent": 3,
      "text": "* [RFC8414]: Authorization Server Metadata",
      "ja": "* [RFC8414]：承認サーバーメタデータ"
    },
    {
      "indent": 6,
      "text": "- Authorization Server Metadata (also known as OAuth Discovery) defines an endpoint clients can use to look up the information needed to interact with a particular OAuth server, such as the location of the authorization and token endpoints and the supported grant types.",
      "ja": "- Authorization Server Metadata（OAuth Discoveryとも呼ばれる）は、クライアントが、認証の位置やトークンエンドポイント、サポートされている助成金タイプなど、特定のOAuthサーバーと対話するために必要な情報を検索するために使用できるエンドポイントを定義します。"
    },
    {
      "indent": 3,
      "text": "* [RFC8707]: Resource Indicators",
      "ja": "* [RFC8707]：リソースインジケーター"
    },
    {
      "indent": 6,
      "text": "- Provides a way for the client to explicitly signal to the authorization server where it intends to use the access token it is requesting.",
      "ja": "- クライアントが、要求しているアクセストークンを使用する予定の認証サーバーに明示的に信号を送る方法を提供します。"
    },
    {
      "indent": 3,
      "text": "* [RFC7591]: Dynamic Client Registration",
      "ja": "* [RFC7591]：ダイナミッククライアント登録"
    },
    {
      "indent": 6,
      "text": "- Dynamic Client Registration provides a mechanism for programmatically registering clients with an authorization server.",
      "ja": "- ダイナミッククライアント登録は、クライアントを承認サーバーにプログラム的に登録するメカニズムを提供します。"
    },
    {
      "indent": 3,
      "text": "* [RFC7592]: Dynamic Client Management",
      "ja": "* [RFC7592]：ダイナミッククライアント管理"
    },
    {
      "indent": 6,
      "text": "- Dynamic Client Management provides a mechanism for updating dynamically registered client information.",
      "ja": "- 動的クライアント管理は、動的に登録されたクライアント情報を更新するためのメカニズムを提供します。"
    },
    {
      "indent": 3,
      "text": "* [RFC9068]: JSON Web Token (JWT) Profile for OAuth 2.0 Access Tokens",
      "ja": "* [RFC9068]：oauth 2.0アクセストークンのJSON Webトークン（JWT）プロファイル"
    },
    {
      "indent": 6,
      "text": "- This specification defines a profile for issuing OAuth access tokens in JSON Web Token (JWT) format.",
      "ja": "- この仕様は、JSON Webトークン（JWT）形式でOAuthアクセストークンを発行するためのプロファイルを定義します。"
    },
    {
      "indent": 3,
      "text": "* [RFC8705]: Mutual TLS",
      "ja": "* [RFC8705]：相互TL"
    },
    {
      "indent": 6,
      "text": "- Mutual TLS describes a mechanism of binding access tokens and refresh tokens to the clients they were issued to, as well as a client authentication mechanism, via TLS certificate authentication.",
      "ja": "- 相互TLSは、TLS証明書認証を介して、発行されたクライアントにトークンをバインドし、トークンをクライアントにリフレッシュするメカニズムを説明します。"
    },
    {
      "indent": 3,
      "text": "* [RFC7662]: Token Introspection",
      "ja": "* [RFC7662]：トークン内省"
    },
    {
      "indent": 6,
      "text": "- The Token Introspection extension defines a mechanism for resource servers to obtain information about access tokens.",
      "ja": "- トークン内注文拡張は、アクセストークンに関する情報を取得するためのリソースサーバーのメカニズムを定義します。"
    },
    {
      "indent": 3,
      "text": "* [RFC7009]: Token Revocation",
      "ja": "* [RFC7009]：トークンの取り消し"
    },
    {
      "indent": 6,
      "text": "- The Token Revocation extension defines a mechanism for clients to indicate to the authorization server that an access token is no longer needed.",
      "ja": "- Token Rococation Extensionは、クライアントがアクセストークンが不要であることを認証サーバーに示すメカニズムを定義します。"
    },
    {
      "indent": 3,
      "text": "* [RFC9126]: Pushed Authorization Requests",
      "ja": "* [RFC9126]：プッシュされた承認要求"
    },
    {
      "indent": 6,
      "text": "- The Pushed Authorization Requests extension describes a technique of initiating an OAuth flow from the back channel, providing better security and more flexibility for building complex authorization requests.",
      "ja": "- プッシュされた承認要求拡張機能は、バックチャネルからOAuthフローを開始する手法を説明し、複雑な承認要求を構築するためのセキュリティと柔軟性を高めます。"
    },
    {
      "indent": 3,
      "text": "* [RFC9207]: Authorization Server Issuer Identification",
      "ja": "* [RFC9207]：Authorization Server発行者の識別"
    },
    {
      "indent": 6,
      "text": "- The iss parameter in the authorization response indicates the identity of the authorization server to prevent mix-up attacks in the client.",
      "ja": "- 認証応答のISSパラメーターは、クライアントの混乱攻撃を防ぐための認証サーバーのIDを示しています。"
    },
    {
      "indent": 3,
      "text": "* [RFC9396]: Rich Authorization Requests",
      "ja": "* [RFC9396]：豊富な承認要求"
    },
    {
      "indent": 6,
      "text": "- Rich Authorization Requests specifies a new parameter authorization_details that is used to carry fine-grained authorization data in the OAuth authorization request.",
      "ja": "- RICH Authorizationリクエストは、OAUTH認証リクエストに微調整された承認データを伝達するために使用される新しいパラメーターAuthorization_Detailsを指定します。"
    },
    {
      "indent": 0,
      "text": "Appendix D. Acknowledgements",
      "section_title": true,
      "ja": "付録D. 謝辞"
    },
    {
      "indent": 3,
      "text": "This specification is the work of the OAuth Working Group, and its starting point was based on the contents of the following specifications: OAuth 2.0 Authorization Framework (RFC 6749), OAuth 2.0 for Native Apps (RFC 8252), OAuth Security Best Current Practice, and OAuth 2.0 for Browser-Based Apps. The editors would like to thank everyone involved in the creation of those specifications upon which this is built.",
      "ja": "この仕様はOAUTHワーキンググループの作業であり、その出発点は、次の仕様の内容に基づいていました：OAUTH 2.0認証フレームワーク（RFC 6749）、ネイティブアプリ用のOAUTH 2.0（RFC 8252）、OAUTHセキュリティベストカレントプラクティス、ブローダーベースのアプリ用のOAUTH 2.0。編集者は、これが構築された仕様の作成に関与するすべての人に感謝したいと思います。"
    },
    {
      "indent": 3,
      "text": "The editors would also like to thank the following individuals for their ideas, feedback, corrections, and wording that helped shape this version of the specification: Vittorio Bertocci, Michael Jones, Justin Richer, Daniel Fett, Brian Campbell, Joseph Heenan, Roberto Polli, Andrii Deinega, Falko, Michael Peck, and Bob Hamburg.",
      "ja": "編集者はまた、このバージョンの仕様を形作るのに役立つアイデア、フィードバック、修正、文言について次の個人に感謝したいと思います：Vittorio Bertocci、Michael Jones、Justin Richer、Daniel Fett、Brian Campbell、Joseph Heenan、Roberto Polli、Andrii Deinega、Falko、Michael Peck、Bob Hambur。"
    },
    {
      "indent": 3,
      "text": "Discussions around this specification have also occurred at the OAuth Security Workshop in 2021 and 2022. The authors thank the organizers of the workshop (Guido Schmitz, Steinar Noem, and Daniel Fett) for hosting an event that's conducive to collaboration and community input.",
      "ja": "この仕様に関する議論は、2021年と2022年のOAUTHセキュリティワークショップでも発生しました。著者は、コラボレーションとコミュニティの入力に係なイベントを開催してくれたワークショップ（Guido Schmitz、Steinar Noem、Daniel Fett）の主催者に感謝します。"
    },
    {
      "indent": 0,
      "text": "Appendix E. Document History",
      "section_title": true,
      "ja": "付録E. 文書履歴"
    },
    {
      "indent": 3,
      "text": "[[ To be removed from the final specification ]]",
      "ja": "[[最終仕様から削除する]]"
    },
    {
      "indent": 3,
      "text": "-09",
      "ja": "-09"
    },
    {
      "indent": 3,
      "text": "* AS MUST NOT support CORS requests at authorization endpoint",
      "ja": "* 認証エンドポイントでCORSリクエストをサポートしてはなりません"
    },
    {
      "indent": 3,
      "text": "* more detail on asymmetric client authentication",
      "ja": "* 非対称クライアント認証の詳細"
    },
    {
      "indent": 3,
      "text": "* sync CSRF description from security BCP",
      "ja": "* セキュリティBCPからCSRF説明を同期します"
    },
    {
      "indent": 3,
      "text": "* update and move sender-constrained access tokens section",
      "ja": "* Sender-Constraended Access Tokensセクションを更新および移動します"
    },
    {
      "indent": 3,
      "text": "* sync client impersonating resource owner with security BCP",
      "ja": "* リソース所有者にセキュリティBCPになりすましているクライアントを同期します"
    },
    {
      "indent": 3,
      "text": "* add reference to authorization request from redirect URI registration section",
      "ja": "* Redirect URI登録セクションからの承認要求への参照を追加する"
    },
    {
      "indent": 3,
      "text": "* sync refresh rotation section from security BCP",
      "ja": "* セキュリティBCPから回転を更新するセクションを同期します"
    },
    {
      "indent": 3,
      "text": "* sync redirect URI matching text from security BCP",
      "ja": "* 同期セキュリティBCPからのURIマッチングテキストをリダイレクトします"
    },
    {
      "indent": 3,
      "text": "* updated references to RAR (RFC9396)",
      "ja": "* RARへの更新された参照（RFC9396）"
    },
    {
      "indent": 3,
      "text": "* clarifications on URIs",
      "ja": "* ウリスの説明"
    },
    {
      "indent": 3,
      "text": "* removed redirect_uri from the token request",
      "ja": "* トークンリクエストからredirect_uriを削除しました"
    },
    {
      "indent": 3,
      "text": "* expanded security considerations around code_verifier",
      "ja": "* code_verifierに関するセキュリティ上の考慮事項を拡張しました"
    },
    {
      "indent": 3,
      "text": "* revised introduction section",
      "ja": "* 改訂された紹介セクション"
    },
    {
      "indent": 3,
      "text": "-08",
      "ja": "-08"
    },
    {
      "indent": 3,
      "text": "* Updated acknowledgments",
      "ja": "* 更新された謝辞"
    },
    {
      "indent": 3,
      "text": "* Swap \"by a trusted party\" with \"by an outside party\" in client ID definition",
      "ja": "* クライアントID定義の「外部のパーティーによる」と「信頼できるパーティーによる」スワップ"
    },
    {
      "indent": 3,
      "text": "* Replaced \"verify the identity of the resource owner\" with \"authenticate\"",
      "ja": "* 「リソース所有者の身元を確認する」を「認証」に置き換えました"
    },
    {
      "indent": 3,
      "text": "* Clarified refresh token rotation to match RFC6819",
      "ja": "* RFC6819に一致するように、リフレッシュトークンの回転を明確にします"
    },
    {
      "indent": 3,
      "text": "* Added appendix to hold application/x-www-form-urlencoded examples",
      "ja": "* アプリケーション/x-www-form-urlencodedの例を保持する付録を追加しました"
    },
    {
      "indent": 3,
      "text": "* Fixed references to entries in appendix",
      "ja": "* 付録のエントリへの参照を修正しました"
    },
    {
      "indent": 3,
      "text": "* Incorporated new \"Phishing via AS\" section from Security BCP",
      "ja": "* セキュリティBCPからのセクションの新しい「フィッシング」"
    },
    {
      "indent": 3,
      "text": "* Rephrase description of the motivation for client authentication",
      "ja": "* クライアント認証の動機の説明を言い換えます"
    },
    {
      "indent": 3,
      "text": "* Moved \"scope\" parameter in token request into specific grant types to match OAuth 2.0",
      "ja": "* トークンリクエストの「スコープ」パラメーターを特定のグラントタイプに移動して、OAUTH 2.0に一致させる"
    },
    {
      "indent": 3,
      "text": "* Updated Clickjacking and Open Redirection description from the latest version of the Security BCP",
      "ja": "* ClickJackingとOpen Redirectionの説明を更新しました。セキュリティBCPの最新バージョンから"
    },
    {
      "indent": 3,
      "text": "* Moved normative requirements out of authorization code security considerations section",
      "ja": "* 承認コードセキュリティの考慮事項から規範的要件を移動しましたセクション"
    },
    {
      "indent": 3,
      "text": "* Security considerations clarifications, and removed a duplicate section",
      "ja": "* セキュリティの考慮事項は明確になり、複製セクションを削除しました"
    },
    {
      "indent": 3,
      "text": "-07",
      "ja": "-07"
    },
    {
      "indent": 3,
      "text": "* Removed \"third party\" from abstract",
      "ja": "* 要約から「サードパーティ」を削除しました"
    },
    {
      "indent": 3,
      "text": "* Added MFA and passwordless as additional motiviations in introduction",
      "ja": "* 紹介の追加の動機としてMFAとパスワードレスを追加しました"
    },
    {
      "indent": 3,
      "text": "* Mention PAR as one way redirect URI registration can happen",
      "ja": "* 片道のリダイレクトURI登録が発生する可能性があることを言及する"
    },
    {
      "indent": 3,
      "text": "* Added a reference to requiring CORS headers on the token endpoint",
      "ja": "* トークンエンドポイントにCORSヘッダーを要求することへの参照を追加しました"
    },
    {
      "indent": 3,
      "text": "* Updated reference to OMAP extension",
      "ja": "* OMAP拡張機能への参照を更新しました"
    },
    {
      "indent": 3,
      "text": "* Fixed numbering in sequence diagram",
      "ja": "* シーケンス図の修正番号"
    },
    {
      "indent": 3,
      "text": "-06",
      "ja": "-06"
    },
    {
      "indent": 3,
      "text": "* Removed \"credentialed client\" term",
      "ja": "* 「資格認定クライアント」の用語を削除しました"
    },
    {
      "indent": 3,
      "text": "* Simplified definition of \"confidential\" and \"public\" clients",
      "ja": "* 「機密」および「パブリック」クライアントの簡素化された定義"
    },
    {
      "indent": 3,
      "text": "* Incorporated the iss response parameter referencing RFC9207",
      "ja": "* RFC9207を参照するISS応答パラメーターを組み込みました"
    },
    {
      "indent": 3,
      "text": "* Added section on access token validation by the RS",
      "ja": "* Rsによるアクセストークン検証に関するセクションを追加しました"
    },
    {
      "indent": 3,
      "text": "* Removed requirement for authorization servers to support all 3 redirect methods for native apps",
      "ja": "* ネイティブアプリの3つのリダイレクト方法すべてをサポートするための承認サーバーの要件を削除しました"
    },
    {
      "indent": 3,
      "text": "* Fixes for some references",
      "ja": "* いくつかの参照の修正"
    },
    {
      "indent": 3,
      "text": "* Updates HTTP references to RFC 9110",
      "ja": "* RFC 9110へのHTTP参照を更新します"
    },
    {
      "indent": 3,
      "text": "* Clarifies \"authorization grant\" term",
      "ja": "* 「承認助成金」期間を明確にします"
    },
    {
      "indent": 3,
      "text": "* Clarifies client credential grant usage",
      "ja": "* クライアントの資格認定の助成金の使用を明確にします"
    },
    {
      "indent": 3,
      "text": "* Clean up authorization code diagram",
      "ja": "* 認証コード図をクリーンアップします"
    },
    {
      "indent": 3,
      "text": "* Updated reference for application/x-www-form-urlencoded and removed outdated note about it not being in the IANA registry",
      "ja": "* アプリケーションのリファレンスを更新/x-www-form-urlencodedおよび削除しました。"
    },
    {
      "indent": 3,
      "text": "-05",
      "ja": "-05"
    },
    {
      "indent": 3,
      "text": "* Added a section about the removal of the implicit flow",
      "ja": "* 暗黙の流れの除去に関するセクションを追加しました"
    },
    {
      "indent": 3,
      "text": "* Moved many normative requirements from security considerations into the appropriate inline sections",
      "ja": "* 多くの規範的要件をセキュリティの考慮事項から適切なインラインセクションに移動しました"
    },
    {
      "indent": 3,
      "text": "* Reorganized and consolidated TLS language",
      "ja": "* TLS言語の再編成および統合された言語"
    },
    {
      "indent": 3,
      "text": "* Require TLS on redirect URIs except for localhost/custom URL scheme",
      "ja": "* LocalHost/Custom URLスキームを除き、Redirect URISにTLSが必要です"
    },
    {
      "indent": 3,
      "text": "* Updated refresh token guidance to match security BCP",
      "ja": "* セキュリティBCPを一致させるために、更新されたトークンガイダンスを更新しました"
    },
    {
      "indent": 3,
      "text": "-04",
      "ja": "-04"
    },
    {
      "indent": 3,
      "text": "* Added explicit mention of not sending access tokens in URI query strings",
      "ja": "* URIクエリ文字列にアクセストークンを送信しないという明確な言及が追加されました"
    },
    {
      "indent": 3,
      "text": "* Clarifications on definition of client types",
      "ja": "* クライアントタイプの定義に関する説明"
    },
    {
      "indent": 3,
      "text": "* Consolidated text around loopback vs localhost",
      "ja": "* Loopback vs LocalHostの周りの統合テキスト"
    },
    {
      "indent": 3,
      "text": "* Editorial clarifications throughout the document",
      "ja": "* ドキュメント全体の編集の明確化"
    },
    {
      "indent": 3,
      "text": "-03",
      "ja": "-03"
    },
    {
      "indent": 3,
      "text": "* refactoring to collect all the grant types under the same top-level header in section 4",
      "ja": "* セクション4の同じトップレベルのヘッダーの下にあるすべての助成金タイプを収集するためのリファクタリング"
    },
    {
      "indent": 3,
      "text": "* Better split normative and security consideration text into the appropriate places, both moving text that was really security considerations out of the main part of the document, as well as pulling normative requirements from the security considerations sections into the appropriate part of the main document",
      "ja": "* より良い規範とセキュリティの検討テキストを適切な場所に分割します。どちらも、ドキュメントの主要部分からのセキュリティに関する考慮事項である移動テキストと、セキュリティ考慮事項のセクションからメインドキュメントの適切な部分に規範的要件を引き出します"
    },
    {
      "indent": 3,
      "text": "* Incorporated many of the published errata on RFC6749",
      "ja": "* RFC6749に公開されたエラタの多くを組み込みました"
    },
    {
      "indent": 3,
      "text": "* Updated references to various RFCs",
      "ja": "* さまざまなRFCへの参照を更新しました"
    },
    {
      "indent": 3,
      "text": "* Editorial clarifications throughout the document",
      "ja": "* ドキュメント全体の編集の明確化"
    },
    {
      "indent": 3,
      "text": "-02",
      "ja": "-02"
    },
    {
      "indent": 3,
      "text": "-01",
      "ja": "-01"
    },
    {
      "indent": 3,
      "text": "-00",
      "ja": "-00"
    },
    {
      "indent": 3,
      "text": "* initial revision",
      "ja": "* 初期改訂"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Dick Hardt Hell Email: dick.hardt@gmail.com",
      "ja": "Dick Hardt Hellメール：dick.hardt@gmail.com"
    },
    {
      "indent": 3,
      "text": "Aaron Parecki Okta Email: aaron@parecki.com URI: https://aaronparecki.com",
      "ja": "Aaron Parecki oktaメール：aaron@parecki.com URI：https：//aaronparecki.com"
    },
    {
      "indent": 3,
      "text": "Torsten Lodderstedt yes.com Email: torsten@lodderstedt.net",
      "ja": "torsten lodderstedt yes.comメール：torsten@lodderstedt.net"
    },
    {
      "indent": 0,
      "text": "Hardt, et al. Expires 11 January 2024 [Page 90]",
      "ja": "ハード、他2024年1月11日有効期限が切れ[90ページ]"
    }
  ],
  "is_draft": true
}