{
  "title": {
    "text": "draft-ietf-tls-ctls-06",
    "ja": "RFC draft-ietf-tls-ctls-06"
  },
  "number": "draft-ietf-tls-ctls-06",
  "created_at": "2022-08-12 20:01:12.100949+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "TLS Working Group                                            E. Rescorla\nInternet-Draft                                                   Mozilla\nIntended status: Standards Track                               R. Barnes\nExpires: 10 January 2023                                           Cisco\n                                                           H. Tschofenig\n                                                             Arm Limited\n                                                             B. Schwartz\n                                                                  Google\n                                                             9 July 2022",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": " Compact TLS 1.3 draft-ietf-tls-ctls-06",
      "ja": "コンパクトTLS 1.3ドラフト-ITEF-TLS-CTLS-06"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document specifies a \"compact\" version of TLS and DTLS. It is logically isomorphic to ordinary TLS, but saves space by trimming obsolete material, tighter encoding, a template-based specialization technique, and alternative cryptographic techniques. cTLS is not directly interoperable with TLS or DTLS, but it should eventually be possible for a single server port to offer cTLS alongside TLS or DTLS.",
      "ja": "このドキュメントは、TLSとDTLSの「コンパクト」バージョンを指定します。これは通常のTLSにとって論理的に同型ですが、時代遅れの素材、タイトなエンコード、テンプレートベースの専門化技術、および代替暗号化技術をトリミングすることでスペースを節約します。CTLSはTLSまたはDTLSと直接相互運用できませんが、最終的に単一のサーバーポートがTLSまたはDTLと一緒にCTLを提供することが可能になるはずです。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.",
      "ja": "このインターネットドラフトは、BCP 78およびBCP 79の規定に完全に適合して提出されています。"
    },
    {
      "indent": 3,
      "text": "Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.",
      "ja": "インターネットドラフトは、インターネットエンジニアリングタスクフォース（IETF）の作業文書です。他のグループは、作業文書をインターネットドラフトとして配布する場合もあることに注意してください。現在のインターネットドラフトのリストは、https：//datatracker.ietf.org/drafts/current/にあります。"
    },
    {
      "indent": 3,
      "text": "Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as \"work in progress.\"",
      "ja": "インターネットドラフトは、最大6か月間有効なドラフトドキュメントであり、いつでも他のドキュメントで更新、交換、または廃止される場合があります。インターネットドラフトを参照資料として使用したり、「進行中の作業」以外に引用することは不適切です。"
    },
    {
      "indent": 3,
      "text": "This Internet-Draft will expire on 10 January 2023.",
      "ja": "このインターネットドラフトは、2023年1月10日に期限切れになります。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2022 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2022 IETF Trustおよび文書著者として特定された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/ license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/ license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、修正されたBSDライセンスで説明されているように保証なしで提供される修正されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2\n2.  Conventions and Definitions . . . . . . . . . . . . . . . . .   3\n  2.1.  Template-based Specialization . . . . . . . . . . . . . .   4\n    2.1.1.  Initial template elements . . . . . . . . . . . . . .   6\n    2.1.2.  Static vector compression . . . . . . . . . . . . . .  11\n  2.2.  Record Layer  . . . . . . . . . . . . . . . . . . . . . .  12\n  2.3.  cTLS Handshake Layer  . . . . . . . . . . . . . . . . . .  14\n    2.3.1.  The Transport layer . . . . . . . . . . . . . . . . .  14\n    2.3.2.  The Transcript layer  . . . . . . . . . . . . . . . .  15\n    2.3.3.  The Logical layer . . . . . . . . . . . . . . . . . .  16\n3.  Handshake Messages  . . . . . . . . . . . . . . . . . . . . .  16\n  3.1.  ClientHello . . . . . . . . . . . . . . . . . . . . . . .  16\n  3.2.  ServerHello . . . . . . . . . . . . . . . . . . . . . . .  16\n  3.3.  HelloRetryRequest . . . . . . . . . . . . . . . . . . . .  17\n4.  Examples  . . . . . . . . . . . . . . . . . . . . . . . . . .  17\n5.  Security Considerations . . . . . . . . . . . . . . . . . . .  18\n6.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  18\n  6.1.  Adding a ContentType  . . . . . . . . . . . . . . . . . .  18\n  6.2.  Template Keys . . . . . . . . . . . . . . . . . . . . . .  18\n  6.3.  Adding a cTLS Template message type . . . . . . . . . . .  19\n  6.4.  Activating the HelloRetryRequest MessageType  . . . . . .  20\n  6.5.  Reserved profiles . . . . . . . . . . . . . . . . . . . .  20\n7.  Normative References  . . . . . . . . . . . . . . . . . . . .  20\nAppendix A.  Example Exchange . . . . . . . . . . . . . . . . . .  21\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  23\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  23",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "DISCLAIMER: This is a work-in-progress draft of cTLS and has not yet seen significant security analysis, so could contain major errors. It should not be used as a basis for building production systems.",
      "ja": "免責事項：これはCTLSの進行中のドラフトであり、まだ重要なセキュリティ分析を見ていないため、大きなエラーを含めることができます。生産システムを構築するための基礎として使用しないでください。"
    },
    {
      "indent": 3,
      "text": "This document specifies \"compact\" versions of TLS [RFC8446] and DTLS [RFC9147], respectively known as \"Stream cTLS\" and \"Datagram cTLS\". cTLS provides equivalent security and functionality to TLS and DTLS, but it is designed to take up minimal bandwidth. The space reduction is achieved by five basic techniques:",
      "ja": "このドキュメントは、それぞれ「Stream CTLS」および「Datagram CTLS」として知られているTLS [RFC8446]およびDTLS [RFC9147]の「コンパクト」バージョンを指定します。CTLSは、TLSとDTLSに同等のセキュリティと機能を提供しますが、最小限の帯域幅を占有するように設計されています。空間削減は、5つの基本的なテクニックによって達成されます。"
    },
    {
      "indent": 3,
      "text": "* Omitting unnecessary values that are a holdover from previous versions of TLS.",
      "ja": "* TLSの以前のバージョンからのホールドオーバーである不必要な値を省略します。"
    },
    {
      "indent": 3,
      "text": "* Omitting the fields and handshake messages required for preserving backwards-compatibility with earlier TLS versions.",
      "ja": "* 以前のTLSバージョンを使用して後方互換性を維持するために必要なフィールドとハンドシェイクメッセージを省略します。"
    },
    {
      "indent": 3,
      "text": "* More compact encodings, for example point compression.",
      "ja": "* よりコンパクトなエンコーディング、たとえばポイント圧縮。"
    },
    {
      "indent": 3,
      "text": "* A template-based specialization mechanism that allows pre-populating information at both endpoints without the need for negotiation.",
      "ja": "* 交渉を必要とせずに、両方のエンドポイントで情報を事前に入力できるテンプレートベースの専門化メカニズム。"
    },
    {
      "indent": 3,
      "text": "* Alternative cryptographic techniques, such as semi-static Diffie-Hellman.",
      "ja": "* 半静的ディフェルマンなどの代替暗号化技術。"
    },
    {
      "indent": 6,
      "text": "OPEN ISSUE: Semi-static and point compression are never mentioned again.",
      "ja": "未解決の問題：半静的と点圧縮は二度と言及されません。"
    },
    {
      "indent": 3,
      "text": "For the common (EC)DHE handshake with pre-established certificates, Stream cTLS achieves an overhead of 45 bytes over the minimum required by the cryptovariables. For a PSK handshake, the overhead is 21 bytes. Annotated handshake transcripts for these cases can be found in Appendix A.",
      "ja": "事前に確立された証明書を使用した一般的な（EC）DHEの握手の場合、Stream CTLSは、Cryptovariablesが必要とする最小値にわたって45バイトのオーバーヘッドを達成します。PSKの握手の場合、オーバーヘッドは21バイトです。これらのケースの注釈付きの握手転写産物は、付録Aにあります。"
    },
    {
      "indent": 6,
      "text": "TODO: Update these values.",
      "ja": "TODO：これらの値を更新します。"
    },
    {
      "indent": 3,
      "text": "cTLS supports the functionality of TLS and DTLS 1.3, and is forward-compatible to future versions of TLS and DTLS. cTLS itself is versioned by CTLSTemplate.version (currently zero).",
      "ja": "CTLSは、TLSおよびDTLS 1.3の機能をサポートしており、TLSおよびDTLSの将来のバージョンとは将来のバージョンに対応できます。CTLS自体は、CTLSTEMPLATE.VERSION（現在ゼロ）によってバージョンされています。"
    },
    {
      "indent": 0,
      "text": "2. Conventions and Definitions",
      "section_title": true,
      "ja": "2. 慣習と定義"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 3,
      "text": "Structure definitions listed below override TLS 1.3 definitions; any PDU not internally defined is taken from TLS 1.3.",
      "ja": "以下にリストされている構造定義TLS 1.3定義をオーバーライドします。内部的に定義されていないPDUは、TLS 1.3から取得されます。"
    },
    {
      "indent": 0,
      "text": "2.1. Template-based Specialization",
      "section_title": true,
      "ja": "2.1. テンプレートベースの専門化"
    },
    {
      "indent": 3,
      "text": "A significant transmission overhead in TLS 1.3 is contributed to by two factors:",
      "ja": "TLS 1.3の重要なトランスミッションオーバーヘッドは、2つの要因によって寄与されます。"
    },
    {
      "indent": 3,
      "text": "* the negotiation of algorithm parameters, and extensions, as well as",
      "ja": "* アルゴリズムパラメーター、および拡張機能の交渉、および"
    },
    {
      "indent": 3,
      "text": "* the exchange of certificates.",
      "ja": "* 証明書の交換。"
    },
    {
      "indent": 3,
      "text": "TLS 1.3 supports different credential types and modes that are impacted differently by a compression scheme. For example, TLS supports certificate-based authentication, raw public key-based authentication as well as pre-shared key (PSK)-based authentication. PSK-based authentication can be used with externally configured PSKs or with PSKs established through tickets.",
      "ja": "TLS 1.3は、圧縮スキームによって異なる影響を与えるさまざまな資格情報タイプとモードをサポートします。たとえば、TLSは、証明書ベースの認証、生の公開キーベースの認証、および事前共有キー（PSK）ベースの認証をサポートしています。PSKベースの認証は、外部で構成されたPSKまたはチケットを通じてPSKを確立して使用できます。"
    },
    {
      "indent": 3,
      "text": "The basic idea of template-based specialization is that we start with the basic TLS 1.3 handshake, which is fully general and then remove degrees of freedom, eliding parts of the handshake which are used to express those degrees of freedom. For example, if we only support one version of TLS, then it is not necessary to have version negotiation and the supported_versions extension can be omitted. Thus, each specialization produces a new protocol that preserves the security guarantees of TLS, but has its own unique handshake.",
      "ja": "テンプレートベースの専門化の基本的なアイデアは、基本的なTLS 1.3の握手から始めて、完全に一般的であり、自由度を除去し、それらの自由度を表現するために使用される握手の一部を排除することです。たとえば、TLSの1つのバージョンのみをサポートする場合、バージョンのネゴシエーションを行う必要はなく、supported_versions拡張子を省略できます。したがって、各専門分野は、TLSのセキュリティ保証を保持する新しいプロトコルを生成しますが、独自の握手があります。"
    },
    {
      "indent": 3,
      "text": "By assuming that out-of-band agreements took place already prior to the start of the cTLS protocol exchange, the amount of data exchanged can be radically reduced. Because different clients may use different compression templates and because multiple compression templates may be available for use in different deployment environments, a client needs to inform the server about the profile it is planning to use. The profile field in the ClientHello serves this purpose.",
      "ja": "CTLSプロトコル交換の開始前にすでに帯域外契約が発生していると仮定することにより、交換されるデータの量は根本的に削減できます。異なるクライアントは異なる圧縮テンプレートを使用する可能性があり、異なる展開環境で使用できるように複数の圧縮テンプレートが利用可能である可能性があるため、クライアントは使用する予定のプロファイルについてサーバーに通知する必要があります。ClientHelloのプロファイルフィールドは、この目的に役立ちます。"
    },
    {
      "indent": 3,
      "text": "Although the template-based specialization mechanisms described here are general, we also include specific mechanism for certificate-based exchanges because those are where the most complexity and size reduction can be obtained. Most of the other exchanges in TLS 1.3 are highly optimized and do not require compression to be used.",
      "ja": "ここで説明するテンプレートベースの専門化メカニズムは一般的ですが、最も複雑さとサイズの削減を得ることができるため、証明書ベースの交換用の特定のメカニズムも含まれています。TLS 1.3の他の交換のほとんどは高度に最適化されており、圧縮を使用する必要はありません。"
    },
    {
      "indent": 3,
      "text": "The compression profile defining the use of algorithms, algorithm parameters, and extensions is represented by the CTLSTemplate structure:",
      "ja": "アルゴリズム、アルゴリズムパラメーター、および拡張機能の使用を定義する圧縮プロファイルは、CTLSTEMPLATE構造によって表されます。"
    },
    {
      "indent": 3,
      "text": "enum {\n  profile(0),\n  version(1),\n  cipher_suite(2),\n  dh_group(3),\n  signature_algorithm(4),\n  random(5),\n  mutual_auth(6),\n  handshake_framing(7),\n  client_hello_extensions(8),\n  server_hello_extensions(9),\n  encrypted_extensions(10),\n  cert_request_extensions(11),\n  known_certificates(12),\n  finished_size(13),\n  optional(65535)\n} CTLSTemplateElementType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n  CTLSTemplateElementType type;\n  opaque data<0..2^32-1>;\n} CTLSTemplateElement;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n  uint16 ctls_version = 0;\n  CTLSTemplateElement elements<0..2^32-1>\n} CTLSTemplate;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "TODO: Reorder enum.",
      "ja": "TODO：列挙列を再注文します。"
    },
    {
      "indent": 3,
      "text": "Elements in a CTLSTemplate MUST appear sorted by the type field in strictly ascending order. The initial elements are defined in the subsections below. Future elements can be added via an IANA registry (Section 6.2). When generating a template, all elements are OPTIONAL to include. When processing a template, all elements are mandatory to understand (but see discussion of optional in Section 2.1.1.11).",
      "ja": "CTLSTEMPLATE内の要素は、タイプフィールドによって厳密に昇順でソートされているように見える必要があります。初期要素は、以下のサブセクションで定義されています。将来の要素は、IANAレジストリ（セクション6.2）を介して追加できます。テンプレートを生成するとき、すべての要素はオプションを含めることができます。テンプレートを処理する場合、すべての要素が理解できるように必須です（ただし、セクション2.1.1.11でオプションの説明を参照）。"
    },
    {
      "indent": 3,
      "text": "For ease of configuration, an equivalent JSON dictionary format is also defined. It consists of a dictionary whose keys are the name of each element type (converted from snake_case to camelCase), and whose values are a type-specific representation of the element intended to maximize legibility. The cTLS version is represented by the key \"ctlsVersion\", whose value is an integer, defaulting to 0 if omitted.",
      "ja": "構成を容易にするために、同等のJSON辞書形式も定義されています。これは、キーが各要素タイプ（snake_caseからcamelcaseに変換）の名前であり、その値は読みやすさを最大化することを目的とした要素のタイプ固有の表現である辞書で構成されています。CTLSバージョンは、整数であるキー「CTLSversion」で表されます。"
    },
    {
      "indent": 6,
      "text": "OPEN ISSUE: Is it really worth converting snake_case to camelCase? camelCase is slightly more traditional in JSON, and saves one byte, but it seems annoying to implement.",
      "ja": "未解決の問題：snake_caseをCamelcaseに変換する価値はありますか？CamelcaseはJSONではわずかに伝統的であり、1つのバイトを節約しますが、実装するのは面倒です。"
    },
    {
      "indent": 3,
      "text": "For example, the following specialization describes a protocol with a single fixed version (TLS 1.3) and a single fixed cipher suite (TLS_AES_128_GCM_SHA256). On the wire, ClientHello.cipher_suites, ServerHello.cipher_suites, and the supported_versions extensions in the ClientHello and ServerHello would be omitted.",
      "ja": "たとえば、次の専門分野では、単一の固定バージョン（TLS 1.3）と単一の固定暗号スイート（TLS_AES_128_GCM_SHA256）を備えたプロトコルについて説明しています。ワイヤーでは、clienthello.ciphel_suites、serverhello.cipher_suites、およびclienthelloおよびserverhelloのsupported_versions拡張機能が省略されます。"
    },
    {
      "indent": 3,
      "text": "{\n  \"ctlsVersion\": 0,\n  \"profile\": \"0001020304050607\",\n  \"version\": 772,\n  \"cipherSuite\": \"TLS_AES_128_GCM_SHA256\"\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.1.1. Initial template elements",
      "section_title": true,
      "ja": "2.1.1. 初期テンプレート要素"
    },
    {
      "indent": 6,
      "text": "TODO: Reorder section.",
      "ja": "TODO：並べ替えセクション。"
    },
    {
      "indent": 0,
      "text": "2.1.1.1. profile",
      "section_title": true,
      "ja": "2.1.1.1. プロフィール"
    },
    {
      "indent": 3,
      "text": "This element identifies the profile being defined. Its binary value is:",
      "ja": "この要素は、定義されているプロファイルを識別します。そのバイナリ値は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "opaque ProfileID<1..2^8-1>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This encodes the profile ID, if one is specified. IDs whose decoded length is 4 bytes or less are reserved (see Section 6.5). When a reserved value is used (including the default value), other keys MUST NOT appear in the template, and a client MUST NOT accept the template unless it recognizes the ID.",
      "ja": "これは、指定されている場合、プロファイルIDをエンコードします。デコードされた長さが4バイト以下のIDは予約されています（セクション6.5を参照）。予約済みの値が使用されている場合（デフォルト値を含む）、他のキーがテンプレートに表示されてはならず、クライアントはIDを認識しない限りテンプレートを受け入れてはなりません。"
    },
    {
      "indent": 3,
      "text": "In JSON, the profile ID is represented as a hexadecimal-encoded string.",
      "ja": "JSONでは、プロファイルIDは16進数エンコード文字列として表されます。"
    },
    {
      "indent": 0,
      "text": "2.1.1.2. version",
      "section_title": true,
      "ja": "2.1.1.2. バージョン"
    },
    {
      "indent": 3,
      "text": "Value: a single ProtocolVersion ([RFC8446], Section 4.1.2) that both parties agree to use. For TLS 1.3, the ProtocolVersion is 0x0304.",
      "ja": "値：両方の当事者が使用することに同意する単一のプロトコルバージョン（[RFC8446]、セクション4.1.2）。TLS 1.3の場合、プロトコルバージョンは0x0304です。"
    },
    {
      "indent": 3,
      "text": "When this element is included, the supported_versions extension is omitted from ClientHello.extensions.",
      "ja": "この要素が含まれている場合、supported_versions拡張子はclienthello.extensionsから省略されます。"
    },
    {
      "indent": 3,
      "text": "In JSON, the version is represented as an integer (772 = 0x0304 for TLS 1.3).",
      "ja": "JSONでは、バージョンは整数として表されます（TLS 1.3の場合は772 = 0x0304）。"
    },
    {
      "indent": 0,
      "text": "2.1.1.3. cipher_suite",
      "section_title": true,
      "ja": "2.1.1.3. cipher_suite"
    },
    {
      "indent": 3,
      "text": "Value: a single CipherSuite ([RFC8446], Section 4.1.2) that both parties agree to use.",
      "ja": "値：両当事者が使用することに同意する単一のciphersuite（[rfc8446]、セクション4.1.2）。"
    },
    {
      "indent": 3,
      "text": "When this element is included, the ClientHello.cipher_suites and ServerHello.cipher_suite fields are omitted.",
      "ja": "この要素が含まれている場合、clienthello.cipher_suitesとserverhello.ciphel_suiteフィールドが省略されます。"
    },
    {
      "indent": 3,
      "text": "In JSON, the cipher suite is represented using the \"TLS_AEAD_HASH\" syntax defined in [RFC8446], Section 8.4.",
      "ja": "JSONでは、[RFC8446]、セクション8.4で定義されている「TLS_AEAD_HASH」構文を使用して、暗号スイートが表されます。"
    },
    {
      "indent": 0,
      "text": "2.1.1.4. dh_group",
      "section_title": true,
      "ja": "2.1.1.4. DH_GROUP"
    },
    {
      "indent": 3,
      "text": "Value: a single NamedGroup ([RFC8446], Section 4.2.7) to use for key establishment.",
      "ja": "値：主要な施設に使用する単一の名前のnamegroup（[rfc8446]、セクション4.2.7）。"
    },
    {
      "indent": 3,
      "text": "This is equivalent to a literal \"supported_groups\" extension consisting solely of this group.",
      "ja": "これは、このグループのみで構成される文字通りの「supported_groups」拡張機能に相当します。"
    },
    {
      "indent": 3,
      "text": "Static vectors (see Section 2.1.2):",
      "ja": "静的ベクトル（セクション2.1.2を参照）："
    },
    {
      "indent": 3,
      "text": "* KeyShareClientHello.client_shares",
      "ja": "* keyshareclienthello.client_shares"
    },
    {
      "indent": 3,
      "text": "* KeyShareEntry.key_exchange, if the NamedGroup uses fixed-size key shares.",
      "ja": "* keyshareentry.key_exchange、名前付きグループが固定サイズのキー共有を使用する場合。"
    },
    {
      "indent": 3,
      "text": "In JSON, the group is listed by the code point name in [RFC8446], Section 4.2.7 (e.g., \"x25519\").",
      "ja": "JSONでは、グループは[RFC8446]、セクション4.2.7（例： \"x25519\"）のコードポイント名によってリストされています。"
    },
    {
      "indent": 0,
      "text": "2.1.1.5. signature_algorithm",
      "section_title": true,
      "ja": "2.1.1.5. signature_algorithm"
    },
    {
      "indent": 3,
      "text": "Value: a single SignatureScheme ([RFC8446], Section 4.2.3) to use for authentication.",
      "ja": "値：認証に使用する単一のSignatureScheme（[RFC8446]、セクション4.2.3）。"
    },
    {
      "indent": 3,
      "text": "This is equivalent to a literal \"signature_algorithms\" extension consisting solely of this group.",
      "ja": "これは、このグループのみで構成される文字通りの「signature_algorithms」拡張機能に相当します。"
    },
    {
      "indent": 3,
      "text": "In JSON, the signature algorithm is listed by the code point name in [RFC8446], Section 4.2.3. (e.g., ecdsa_secp256r1_sha256).",
      "ja": "JSONでは、署名アルゴリズムは[RFC8446]、セクション4.2.3のコードポイント名によってリストされています。（例：ECDSA_SECP256R1_SHA256）。"
    },
    {
      "indent": 0,
      "text": "2.1.1.6. random",
      "section_title": true,
      "ja": "2.1.1.6. ランダム"
    },
    {
      "indent": 3,
      "text": "Value: a single uint8.",
      "ja": "値：単一のUINT8。"
    },
    {
      "indent": 3,
      "text": "The ClientHello.Random and ServerHello.Random values are truncated to the given length. Where a 32-byte Random is required, the Random is padded to the right with 0s and the anti-downgrade mechanism in [RFC8446], Section 4.1.3 is disabled. IMPORTANT: Using short Random values can lead to potential attacks. The Random length MUST be less than or equal to 32 bytes.",
      "ja": "clienthello.randomおよびserverhello.randomの値は、与えられた長さに切り捨てられます。32バイトのランダムが必要な場合、ランダムは0Sと[RFC8446]のアンチダウングラードメカニズムを備えた右にパッドで埋められ、セクション4.1.3は無効になります。重要：短いランダム値を使用すると、潜在的な攻撃につながる可能性があります。ランダムな長さは、32バイト以下でなければなりません。"
    },
    {
      "indent": 6,
      "text": "OPEN ISSUE: Karthik Bhargavan suggested the idea of hashing ephemeral public keys and to use the result (truncated to 32 bytes) as random values. Such a change would require a security analysis.",
      "ja": "未解決の問題：Karthik Bhargavanは、短命の公開キーをハッシュし、結果（32バイトに切り捨てられた）をランダム値として使用するという考えを提案しました。このような変更には、セキュリティ分析が必要になります。"
    },
    {
      "indent": 3,
      "text": "In JSON, the length is represented as an integer.",
      "ja": "JSONでは、長さは整数として表されます。"
    },
    {
      "indent": 0,
      "text": "2.1.1.7. mutual_auth",
      "section_title": true,
      "ja": "2.1.1.7. 相互_Auth"
    },
    {
      "indent": 3,
      "text": "Value: a single uint8, with 1 representing \"true\" and 0 representing \"false\". All other values are forbidden.",
      "ja": "値：単一のUINT8、1は「true」を表し、0は「false」を表します。他のすべての値は禁止されています。"
    },
    {
      "indent": 3,
      "text": "If set to true, this element indicates that the client must authenticate with a certificate by sending Certificate and a CertificateVerify message. The server MUST omit the CertificateRequest message, as its contents are redundant.",
      "ja": "Trueに設定されている場合、この要素は、クライアントが証明書とCertifativeVerifyメッセージを送信して証明書で認証する必要があることを示します。サーバーは、そのコンテンツが冗長であるため、証明書メッセージを省略する必要があります。"
    },
    {
      "indent": 6,
      "text": "OPEN ISSUE: We don't actually say that you can omit empty messages, so we need to add that somewhere.",
      "ja": "OPENの問題：空のメッセージを省略できると実際には言っていないので、どこかに追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "In JSON, this value is represented as true or false.",
      "ja": "JSONでは、この値は真または偽として表されます。"
    },
    {
      "indent": 0,
      "text": "2.1.1.8. client_hello_extensions, server_hello_extensions, encrypted_extensions, and cert_request_extensions",
      "ja": "2.1.1.8. client_hello_extensions、server_hello_extensions、encrypted_extensions、cert_request_extensions"
    },
    {
      "indent": 3,
      "text": "Value: a single CTLSExtensionTemplate struct:",
      "ja": "値：単一のctlsextensionTemplate struct："
    },
    {
      "indent": 3,
      "text": "struct {\n  Extension predefined_extensions<0..2^16-1>;\n  ExtensionType expected_extensions<0..2^16-1>;\n  uint8 allow_additional;\n} CTLSExtensionTemplate;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The predefined_extensions field indicates extensions that should be treated as if they were included in the corresponding message. This allows these extensions to be omitted entirely.",
      "ja": "predefined_extensionsフィールドは、対応するメッセージに含まれているかのように扱う必要がある拡張機能を示します。これにより、これらの拡張機能を完全に省略できます。"
    },
    {
      "indent": 3,
      "text": "The expected_extensions field indicates extensions that must be included in the corresponding message, at the beginning of its extensions field. The types of these extensions are omitted when serializing the extensions field of the corresponding message.",
      "ja": "expected_extensionsフィールドは、拡張フィールドの先頭にある対応するメッセージに含める必要がある拡張機能を示します。これらの拡張機能のタイプは、対応するメッセージの拡張フィールドフィールドをシリアル化するときに省略されます。"
    },
    {
      "indent": 3,
      "text": "The allow_additional field MUST be 0 (false) or 1 (true), indicating whether additional extensions are allowed here.",
      "ja": "Alow_Additionalフィールドは0（FALSE）または1（TRUE）でなければならず、ここで追加の拡張が許可されているかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "predefined_extensions and expected_extensions MUST be in strictly ascending order by ExtensionType, and a single ExtensionType MUST NOT appear in both lists. If the version, dh_group, or signature_algorithm element appears in the template, the corresponding ExtensionType MUST NOT appear here.",
      "ja": "predefined_extensionsとexpection_extensionsは、extensionTypeによって厳密に昇順である必要があり、単一の拡張子型が両方のリストに表示されないでください。バージョン、dh_group、またはsignature_algorithm要素がテンプレートに表示されている場合、対応するextensionTypeがここに表示されてはなりません。"
    },
    {
      "indent": 6,
      "text": "OPEN ISSUE: Are there other extensions that would benefit from special treatment, as opposed to hex values.",
      "ja": "OPENの問題：HEX値とは対照的に、特別な治療の恩恵を受ける他の拡張機能があります。"
    },
    {
      "indent": 3,
      "text": "Static vectors (see Section 2.1.2):",
      "ja": "静的ベクトル（セクション2.1.2を参照）："
    },
    {
      "indent": 3,
      "text": "* Extension.extension_data for any extension in expected_extensions whose value has fixed length. This applies only to the corresponding message.",
      "ja": "* extension.extension_data値が固定された長さのexpect_extensionsの任意の拡張機能。これは、対応するメッセージにのみ適用されます。"
    },
    {
      "indent": 3,
      "text": "* The extensions field of the corresponding message, if allow_additional is false.",
      "ja": "* Allow_Additionalがfalseの場合、対応するメッセージの拡張フィールド。"
    },
    {
      "indent": 3,
      "text": "In JSON, this value is represented as a dictionary with three keys:",
      "ja": "JSONでは、この値は3つのキーを持つ辞書として表されます。"
    },
    {
      "indent": 3,
      "text": "* predefinedExtensions: a dictionary mapping ExtensionType names ([RFC8446], Section 4.2) to values encoded as hexadecimal strings.",
      "ja": "* predefinedExtensions：六十種類の文字列としてエンコードされた値への辞書マッピングextensionType名（[RFC8446]、セクション4.2）。"
    },
    {
      "indent": 3,
      "text": "* expectedExtensions: an array of ExtensionType names.",
      "ja": "* expectsextensions：extensionType名の配列。"
    },
    {
      "indent": 3,
      "text": "* allowAdditional: true or false.",
      "ja": "* AlowAdditional：trueまたはfalse。"
    },
    {
      "indent": 3,
      "text": "If predefinedExtensions or expectedExtensions is empty, it MAY be omitted.",
      "ja": "predexedextensionsまたはexpectsextensionsが空の場合、省略される場合があります。"
    },
    {
      "indent": 6,
      "text": "OPEN ISSUE: Should we have a certificate_entry_extensions element?",
      "ja": "Open Issue：certificate_entry_extensions要素がある必要がありますか？"
    },
    {
      "indent": 0,
      "text": "2.1.1.9. finished_size",
      "section_title": true,
      "ja": "2.1.1.9. finited_size"
    },
    {
      "indent": 3,
      "text": "Value: uint8, indicating that the Finished value is to be truncated to the given length.",
      "ja": "値：UINT8。完成した値が与えられた長さに切り捨てられることを示しています。"
    },
    {
      "indent": 6,
      "text": "OPEN ISSUE: How short should we allow this to be? TLS 1.3 uses the native hash and TLS 1.2 used 12 bytes. More analysis is needed to know the minimum safe Finished size. See [RFC8446], Appendix E.1 for more on this, as well as https://mailarchive.ietf.org/arch/msg/tls/ TugB5ddJu3nYg7chcyeIyUqWSbA.",
      "ja": "未解決の問題：これをどれほど短くする必要がありますか？TLS 1.3は、ネイティブハッシュおよびTLS 1.2を使用して12バイトを使用します。最小安全な完成サイズを知るには、さらに分析が必要です。詳細については、[RFC8446]、付録E.1、およびhttps://mailarchive.ietf.org/arch/msg/tls/ tugb5ddju3nyg7chcyeiuqwsbaを参照してください。"
    },
    {
      "indent": 3,
      "text": "In JSON, this length is represented as an integer.",
      "ja": "JSONでは、この長さは整数として表されます。"
    },
    {
      "indent": 0,
      "text": "2.1.1.10. handshake_framing",
      "section_title": true,
      "ja": "2.1.1.10. handshake_framing"
    },
    {
      "indent": 3,
      "text": "Value: uint8, with 0 indicating \"false\" and 1 indicating \"true\". If true, handshake messages MUST be conveyed inside a Handshake ([RFC8446], Section 4) struct on stream transports, or a DTLSHandshake ([RFC9147], Section 5.2) struct on datagram transports, and MAY be broken into multiple records as in TLS and DTLS. Otherwise, each handshake message is conveyed in a CTLSHandshake or CTLSDatagramHandshake struct (Section 2.3), which MUST be the payload of a single record.",
      "ja": "値：uint8、0は「false」を示し、1は「真」を示します。真実の場合、ハンドシェイクメッセージは、ストリーム輸送の握手（[RFC8446]、セクション4）の構造、またはDTLSHANDSHAKE（[RFC9147]、セクション5.2）のデータグラム輸送の構造内で伝えられ、TLSのように複数のレコードに分割される可能性があります。およびdtls。それ以外の場合、各ハンドシェイクメッセージは、CTLShandshakeまたはCTLSDatagramHandshake struct（セクション2.3）で伝えられます。これは、単一のレコードのペイロードでなければなりません。"
    },
    {
      "indent": 3,
      "text": "In JSON, this value is represented as true or false.",
      "ja": "JSONでは、この値は真または偽として表されます。"
    },
    {
      "indent": 0,
      "text": "2.1.1.11. optional",
      "section_title": true,
      "ja": "2.1.1.11. オプション"
    },
    {
      "indent": 3,
      "text": "Value: a CTLSTemplate containing elements that are not required to be understood by the client. Server operators MUST NOT place an element in this section unless the server is able to determine whether the client is using it from the client data it receives. A key MUST NOT appear in both the main template and the optional section.",
      "ja": "値：クライアントが理解する必要がない要素を含むCTLSTEMプレート。サーバーオペレーターは、クライアントが受信したクライアントデータからクライアントがそれを使用しているかどうかを決定できない限り、このセクションに要素を配置してはなりません。キーは、メインテンプレートとオプションのセクションの両方に表示されてはなりません。"
    },
    {
      "indent": 3,
      "text": "In JSON, this value is represented in the same way as the CTLSTemplate itself.",
      "ja": "JSONでは、この値はCTLSTEMプレート自体と同じように表されます。"
    },
    {
      "indent": 0,
      "text": "2.1.1.12. known_certificates",
      "section_title": true,
      "ja": "2.1.1.12. 既知の_certificates"
    },
    {
      "indent": 3,
      "text": "Value: a CertificateMap struct:",
      "ja": "値：certificatemap struct："
    },
    {
      "indent": 3,
      "text": "struct {\n  opaque id<1..2^8-1>;\n  opaque cert_data<1..2^16-1>;\n} CertificateMapEntry;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n  CertificateMapEntry entries<2..2^24-1>;\n} CertificateMap;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Entries in the certificate map must appear in strictly ascending lexicographic order by ID.",
      "ja": "証明書マップのエントリは、IDによって厳密に昇順の辞書順に表示される必要があります。"
    },
    {
      "indent": 3,
      "text": "In JSON, CertificateMap is represented as a dictionary from id to cert_data, which are both represented as hexademical strings:",
      "ja": "JSONでは、CertiberateMapはIDからCERT_DATAへの辞書として表されます。どちらも六角形の文字列として表されます。"
    },
    {
      "indent": 3,
      "text": "{\n  \"00\": \"3082...\",\n  \"01\": \"3082...\",\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Certificates are a major contributor to the size of a TLS handshake. In order to avoid this overhead when the parties to a handshake have already exchanged certificates, a compression profile can specify a dictionary of \"known certificates\" that effectively acts as a compression dictionary on certificates.",
      "ja": "証明書は、TLSの握手の規模の主要な貢献者です。握手の当事者がすでに証明書を交換しているこのオーバーヘッドを回避するために、圧縮プロファイルは、証明書の圧縮辞書として効果的に機能する「既知の証明書」の辞書を指定できます。"
    },
    {
      "indent": 3,
      "text": "When compressing a Certificate message, the sender examines the cert_data field of each CertificateEntry. If the cert_data matches a value in the known certificates object, then the sender replaces the cert_data with the corresponding key. Decompression works the opposite way, replacing keys with values.",
      "ja": "証明書メッセージを圧縮するとき、送信者は各CertimateEntryのCERT_DATAフィールドを調べます。CERT_DATAが既知の証明書オブジェクトの値と一致する場合、送信者はCERT_DATAを対応するキーに置き換えます。減圧は反対の方法で機能し、キーを値に置き換えます。"
    },
    {
      "indent": 3,
      "text": "Note that in this scheme, there is no signaling on the wire for whether a given cert_data value is compressed or uncompressed. Known certificates objects SHOULD be constructed in such a way as to avoid a uncompressed object being mistaken for compressed one and erroneously decompressed. For X.509, it is sufficient for the first byte of the compressed value (key) to have a value other than 0x30, since every X.509 certificate starts with this byte.",
      "ja": "このスキームでは、特定のCERT_DATA値が圧縮または非圧縮されているかどうかについて、ワイヤに信号がないことに注意してください。既知の証明書オブジェクトは、圧縮されていないオブジェクトが圧縮されたものと間違われ、誤って減圧されないように、構築する必要があります。X.509の場合、圧縮値の最初のバイト（キー）が0x30以外の値を持つことは十分です。X.509すべての証明書はこのバイトから始まるためです。"
    },
    {
      "indent": 0,
      "text": "2.1.2. Static vector compression",
      "section_title": true,
      "ja": "2.1.2. 静的ベクトル圧縮"
    },
    {
      "indent": 3,
      "text": "Some cTLS template elements imply that certain vectors (as defined in [RFC8446], Section 3.4) have a fixed number of elements during the handshake. These template elements note these \"static vectors\" in their definition. When encoding a \"static vector\", its length prefix is omitted.",
      "ja": "一部のCTLSテンプレート要素は、特定のベクトル（[RFC8446]、セクション3.4で定義されている）が握手中に固定数の要素を持っていることを意味します。これらのテンプレート要素は、これらの「静的ベクトル」を定義に注目しています。「静的ベクトル」をエンコードするとき、その長さのプレフィックスは省略されています。"
    },
    {
      "indent": 3,
      "text": "For example, suppose that the cTLS template is:",
      "ja": "たとえば、CTLSテンプレートが次のとおりです。"
    },
    {
      "indent": 3,
      "text": "{\n  \"ctlsVersion\": 0,\n  \"version\": 772,\n  \"dhGroup\": \"x25519\",\n  \"clientHelloExtensions\": {\n    \"expectedExtensions\": [\"key_share\"],\n    \"allowAdditional\": false\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Then, the following structure:",
      "ja": "次に、次の構造："
    },
    {
      "indent": 6,
      "text": "28                 // length(extensions)\n33 26              // extension_type = KeyShare\n  0024             // length(client_shares)\n    001d           // KeyShareEntry.group\n    0020           // length(KeyShareEntry.key_exchange)\n      a690...af948 // KeyShareEntry.key_exchange",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "is compressed down to:",
      "ja": "圧縮されています："
    },
    {
      "indent": 6,
      "text": "a690...af948 // KeyShareEntry.key_exchange",
      "ja": "a690 ... af948 // keyshareentry.key_exchange"
    },
    {
      "indent": 3,
      "text": "according to the following rationale:",
      "ja": "次の根拠によると、"
    },
    {
      "indent": 3,
      "text": "* The length of extensions is omitted because allowAdditional is false, so the number of items in extensions (i.e., 1) is known in advance.",
      "ja": "* AllowAdditionalが偽であるため、拡張機能の長さは省略されているため、拡張機能（つまり、1）のアイテムの数は事前に知られています。"
    },
    {
      "indent": 3,
      "text": "* extension_type is omitted because it is specified by expected_extensions.",
      "ja": "* extension_typeは、expection_extensionsで指定されているため省略されています。"
    },
    {
      "indent": 3,
      "text": "* The length of client_shares is omitted because the use of dhGroup implies that there can only be one KeyShareEntry.",
      "ja": "* dhgroupの使用は、キーシェアエントリーが1つしかないことを意味するため、client_sharesの長さは省略されています。"
    },
    {
      "indent": 3,
      "text": "* KeyShareEntry.group is omitted because it is specified by dhGroup.",
      "ja": "* keyshareentry.groupは、dhgroupで指定されているため省略されています。"
    },
    {
      "indent": 3,
      "text": "* The length of the key_exchange is omitted because the \"x25519\" key share has a fixed size (32 bytes).",
      "ja": "* 「x25519」キー共有の固定サイズ（32バイト）があるため、key_exchangeの長さは省略されています。"
    },
    {
      "indent": 0,
      "text": "2.2. Record Layer",
      "section_title": true,
      "ja": "2.2. レコードレイヤー"
    },
    {
      "indent": 3,
      "text": "The only cTLS records that are sent in plaintext are handshake records (ClientHello and ServerHello/HRR) and alerts. cTLS alerts are the same as TLS/DTLS alerts and use the same content types. For handshake records, we set the content_type field to a fixed cTLS-specific value to distinguish cTLS plaintext records from encrypted records, TLS/DTLS records, and other protocols using the same 5-tuple.",
      "ja": "プレーンテキストで送信される唯一のCTLSレコードは、ハンドシェイクレコード（ClientHelloおよびServerHello/HRR）とアラートです。CTLSアラートは、TLS/DTLSアラートと同じであり、同じコンテンツタイプを使用します。ハンドシェイクレコードの場合、CONTERT_TYPEフィールドを固定CTLS固有の値に設定して、CTLSプレーンテキストレコードを暗号化されたレコード、TLS/DTLSレコード、および同じ5タプルを使用して他のプロトコルと区別します。"
    },
    {
      "indent": 9,
      "text": "struct {\n    ContentType content_type = ctls_handshake;\n    opaque profile_id<0..2^8-1>;\n    opaque fragment<0..2^16-1>;\n} CTLSClientPlaintext;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The profile_id field MUST identify the profile that is in use. A zero-length ID corresponds to the cTLS default protocol. The server's reply does not include the profile_id, because the server must be using the same profile indicated by the client.",
      "ja": "Profile_idフィールドは、使用されているプロファイルを識別する必要があります。ゼロ長IDは、CTLSデフォルトプロトコルに対応します。サーバーは、クライアントが指定した同じプロファイルを使用している必要があるため、サーバーの返信にはProfile_IDが含まれていません。"
    },
    {
      "indent": 9,
      "text": "struct {\n    ContentType content_type = ctls_handshake;\n    opaque fragment<0..2^16-1>;\n} CTLSServerPlaintext;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Encrypted records use DTLS 1.3 [RFC9147] record framing, comprising a configuration octet followed by optional connection ID, sequence number, and length fields. The encryption process and additional data are also as described in DTLS.",
      "ja": "暗号化されたレコードは、DTLS 1.3 [RFC9147]レコードフレーミングを使用します。これは、オプションの接続ID、シーケンス番号、および長さフィールドが続く構成Octetを含む。暗号化プロセスと追加データは、DTLSで説明されているとおりです。"
    },
    {
      "indent": 9,
      "text": "0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|0|0|1|C|S|L|E E|\n+-+-+-+-+-+-+-+-+\n| Connection ID |   Legend:\n| (if any,      |\n/  length as    /   C   - Connection ID (CID) present\n|  negotiated)  |   S   - Sequence number length\n+-+-+-+-+-+-+-+-+   L   - Length present\n| 8 or 16 bit   |   E   - Epoch\n|Sequence Number|\n| (if present)  |\n+-+-+-+-+-+-+-+-+\n| 16 bit Length |\n| (if present)  |\n+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "struct {\n    opaque unified_hdr[variable];\n    opaque encrypted_record[length];\n} CTLSCiphertext;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The presence and size of the connection ID field is negotiated as in DTLS.",
      "ja": "接続IDフィールドの存在とサイズは、DTLSのようにネゴシエートされます。"
    },
    {
      "indent": 3,
      "text": "As with DTLS, the length field MAY be omitted by clearing the L bit, which means that the record consumes the entire rest of the data in the lower level transport. In this case it is not possible to have multiple DTLSCiphertext format records without length fields in the same datagram. In stream-oriented transports (e.g., TCP), the length field MUST be present. For use over other transports length information may be inferred from the underlying layer.",
      "ja": "DTLSと同様に、Lビットをクリアすることで長さフィールドを省略できます。つまり、レコードは低レベルの輸送で残りのデータ全体を消費します。この場合、同じデータグラムに長さフィールドのない複数のDTLSciphertext形式のレコードを持つことはできません。ストリーム指向のトランスポンド（TCPなど）では、長さフィールドが存在する必要があります。他の輸送で使用するには、基礎となる層から長さの情報が推測される場合があります。"
    },
    {
      "indent": 3,
      "text": "Normal DTLS does not provide a mechanism for suppressing the sequence number field entirely. When a reliable, ordered transport (e.g., TCP) is in use, the S bit in the configuration octet MUST be cleared and the sequence number MUST be omitted. When an unreliable transport is in use, the S bit has its usual meaning and the sequence number MUST be included.",
      "ja": "通常のDTLSは、シーケンス番号フィールドを完全に抑制するメカニズムを提供しません。信頼できる順序付けられた輸送（TCPなど）が使用されている場合、構成のSビットをクリアし、シーケンス番号を省略する必要があります。信頼できないトランスポートが使用されている場合、Sビットには通常の意味があり、シーケンス番号を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "2.3. cTLS Handshake Layer",
      "section_title": true,
      "ja": "2.3. CTLSハンドシェイク層"
    },
    {
      "indent": 3,
      "text": "The cTLS handshake is modeled in three layers:",
      "ja": "CTLSハンドシェイクは、3つのレイヤーでモデル化されています。"
    },
    {
      "indent": 3,
      "text": "1. The Transport layer",
      "ja": "1. 輸送層"
    },
    {
      "indent": 3,
      "text": "2. The Transcript layer",
      "ja": "2. 転写層"
    },
    {
      "indent": 3,
      "text": "3. The Logical layer",
      "ja": "3. 論理レイヤー"
    },
    {
      "indent": 0,
      "text": "2.3.1. The Transport layer",
      "section_title": true,
      "ja": "2.3.1. 輸送層"
    },
    {
      "indent": 3,
      "text": "When template.handshake_framing is false, the cTLS transport layer uses a custom handshake framing that saves space by relying on the record layer for message lengths. (This saves 3 bytes per message compared to TLS, or 9 bytes compared to DTLS.) This compact framing is defined by the CTLSHandshake and CTLSDatagramHandshake structs.",
      "ja": "Template.Handshake_Framingがfalseの場合、CTLSトランスポートレイヤーは、メッセージの長さをレコードレイヤーに依存することでスペースを節約するカスタムハンドシェイクフレーミングを使用します。（これにより、TLSと比較してメッセージごとに3バイト、またはDTLと比較して9バイトが節約されます。）このコンパクトなフレーミングは、CTLSHANDSHAKEおよびCTLSDATAGRAMHANDSHAKE構造体によって定義されます。"
    },
    {
      "indent": 3,
      "text": "Any handshake type registered in the IANA TLS HandshakeType Registry can be conveyed in a CTLS[Datagram]Handshake, but not all messages are actually allowed on a given connection. This definition shows the messages types supported in CTLSHandshake as of TLS 1.3 and DTLS 1.3, but any future message types are also permitted.",
      "ja": "IANA TLSハンドシェークタイプレジストリに登録されているハンドシェイクタイプは、CTLS [datagram]ハンドシェイクで伝達できますが、すべてのメッセージが実際に特定の接続で許可されているわけではありません。この定義は、TLS 1.3およびDTLS 1.3の時点でCTLShandshakeでサポートされているメッセージタイプを示していますが、将来のメッセージタイプも許可されています。"
    },
    {
      "indent": 7,
      "text": "struct {\n    HandshakeType msg_type;    /* handshake type */\n    select (CTLSHandshake.msg_type) {\n        case client_hello:          ClientHello;\n        case server_hello:          ServerHello;\n        case hello_retry_request:   HelloRetryRequest;  /* New */\n        case end_of_early_data:     EndOfEarlyData;\n        case encrypted_extensions:  EncryptedExtensions;\n        case certificate_request:   CertificateRequest;\n        case certificate:           Certificate;\n        case certificate_verify:    CertificateVerify;\n        case finished:              Finished;\n        case new_session_ticket:    NewSessionTicket;\n        case key_update:            KeyUpdate;\n        case request_connection_id: RequestConnectionId;\n        case new_connection_id:     NewConnectionId;\n    };\n} CTLSHandshake;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "struct {\n    HandshakeType msg_type;    /* handshake type */\n    uint16 message_seq;        /* DTLS-required field */\n    select (CTLSDatagramHandshake.msg_type) {\n      ... /* same as CTLSHandshake */\n    };\n} CTLSDatagramHandshake;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each CTLSHandshake or CTLSDatagramHandshake MUST be conveyed as a single CTLSClientPlaintext.fragment, CTLSServerPlaintext.fragment, or CTLSCiphertext.encrypted_record, and is therefore limited to a maximum length of 2^16-1 or less. When operating over UDP, large CTLSDatagramHandshake messages will also require the use of IP fragmentation, which is sometimes undesirable. Operators can avoid these concerns by setting template.handshakeFraming = true.",
      "ja": "各ctlshandshakeまたはctlsdatagramhandshakeは、単一のctlsclientplaintext.fragment、ctlsserverplaintext.fragment、またはctlsciphertext.encrypted_recordとして伝達する必要があります。UDPを介して動作する場合、大規模なCTLSDATAGRAMHHANDSHAKEメッセージには、IPフラグメンテーションの使用も必要になります。オペレーターは、テンプレートを設定することにより、これらの懸念を回避できます。HandshakeFraming= true。"
    },
    {
      "indent": 0,
      "text": "2.3.2. The Transcript layer",
      "section_title": true,
      "ja": "2.3.2. 転写層"
    },
    {
      "indent": 3,
      "text": "TLS and DTLS start the handshake with an empty transcript. cTLS is different: it starts the transcript with a \"virtual message\" whose HandshakeType is ctls_template (Section 6.3) containing the CTLSTemplate used for this connection. This message is included in the transcript even though it is not exchanged during connection setup, in order to ensure that both parties are using the same template. Subsequent messages are appended to the transcript as usual.",
      "ja": "TLSとDTLSは、空の転写産物で握手を開始します。CTLSは異なります。この接続に使用されるCTLSTEMプレートを含むHandShakeTypeがCTLS_TEMPLATE（セクション6.3）である「仮想メッセージ」でトランスクリプトを開始します。このメッセージは、両当事者が同じテンプレートを使用していることを確認するために、接続セットアップ中に交換されていない場合でも、トランスクリプトに含まれています。後続のメッセージは、通常どおりトランスクリプトに追加されます。"
    },
    {
      "indent": 3,
      "text": "When computing the handshake transcript, all handshake messages are represented in TLS Handshake messages, as in DTLS 1.3 ([RFC9147], Section 5.2), regardless of template.handshake_framing.",
      "ja": "握手転写産物を計算するとき、すべての握手メッセージは、TLS 1.3（[RFC9147]、セクション5.2）のように、TLSハンドシェイクメッセージで表されます。Handshake_Framingに関係なく。"
    },
    {
      "indent": 3,
      "text": "To ensure that all parties agree about what protocol is in use, the Cryptographic Label Prefix used for the handshake SHALL be \"Sctls \" for Stream cTLS and \"Dctls \" for Datagram cTLS. (This is similar to the prefix substitution in Section 5.9 of [RFC9147]).",
      "ja": "すべての関係者が使用しているプロトコルについて確実に同意するようにするために、握手に使用される暗号化ラベルプレフィックスは、Stream CTLSの「SCTL」およびデータグラムCTLの「DCTL」とするものとします。（これは、[RFC9147]のセクション5.9のプレフィックス置換に似ています）。"
    },
    {
      "indent": 0,
      "text": "2.3.3. The Logical layer",
      "section_title": true,
      "ja": "2.3.3. 論理レイヤー"
    },
    {
      "indent": 3,
      "text": "The logical handshake layer consists of handshake messages that are reconstructed following the instructions in the template. At this layer, predefined extensions are reintroduced, truncated Random values are extended, and all information is prepared to enable the cryptographic handshake and any import or export of key material and configuration.",
      "ja": "論理的な握手層は、テンプレートの命令に従って再構築される握手メッセージで構成されています。このレイヤーでは、事前定義された拡張機能が再導入され、切り捨てられたランダム値が拡張され、すべての情報が設定され、暗号化の握手と主要な資料と構成のインポートまたはエクスポートが可能になります。"
    },
    {
      "indent": 3,
      "text": "There is no obligation to reconstruct logical handshake messages in any specific format, and client and server do not need to agree on the precise representation of these messages, so long as they agree on their logical contents.",
      "ja": "特定の形式で論理的なハンドシェイクメッセージを再構築する義務はなく、クライアントとサーバーは、これらのメッセージの正確な表現に同意する必要はありません。"
    },
    {
      "indent": 0,
      "text": "3. Handshake Messages",
      "section_title": true,
      "ja": "3. 握手メッセージ"
    },
    {
      "indent": 3,
      "text": "In general, we retain the basic structure of each individual TLS or DTLS handshake message. However, the following handshake messages have been modified for space reduction and cleaned up to remove pre-TLS 1.3 baggage.",
      "ja": "一般に、個々のTLSまたはDTLSハンドシェイクメッセージの基本構造を保持します。ただし、以下の握手メッセージはスペースの削減のために変更され、TLS 1.3の手荷物を削除するためにクリーンアップされました。"
    },
    {
      "indent": 0,
      "text": "3.1. ClientHello",
      "section_title": true,
      "ja": "3.1. clienthello"
    },
    {
      "indent": 3,
      "text": "The cTLS ClientHello is defined as follows.",
      "ja": "CTLS ClientHelloは次のように定義されています。"
    },
    {
      "indent": 9,
      "text": "opaque Random[RandomLength];      // variable length",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "struct {\n    Random random;\n    CipherSuite cipher_suites<1..2^16-1>;\n    Extension extensions<1..2^16-1>;\n} ClientHello;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2. ServerHello",
      "section_title": true,
      "ja": "3.2. serverhello"
    },
    {
      "indent": 3,
      "text": "We redefine ServerHello in the following way.",
      "ja": "ServerHelloを次の方法で再定義します。"
    },
    {
      "indent": 9,
      "text": "struct {\n    Random random;\n    CipherSuite cipher_suite;\n    Extension extensions<1..2^16-1>;\n} ServerHello;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3. HelloRetryRequest",
      "section_title": true,
      "ja": "3.3. HelloretryRequest"
    },
    {
      "indent": 3,
      "text": "In cTLS, the HelloRetryRequest message is a true handshake message instead of a specialization of ServerHello. The HelloRetryRequest has the following format.",
      "ja": "CTLSでは、helloretryrequestメッセージは、serverhelloの専門化ではなく、真の握手メッセージです。HelloretryRequestには次の形式があります。"
    },
    {
      "indent": 9,
      "text": "struct {\n    CipherSuite cipher_suite;\n    Extension extensions<2..2^16-1>;\n} HelloRetryRequest;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The HelloRetryRequest is the same as the ServerHello above but without the unnecessary sentinel Random value.",
      "ja": "HelloretryRequestは、上記のServerHelloと同じですが、不必要なセンチネルランダム値はありません。"
    },
    {
      "indent": 6,
      "text": "OPEN ISSUE: Does server_hello_extensions apply to HelloRetryRequest?",
      "ja": "Open Issue：server_hello_extensionsはhelloretryrequestに適用されますか？"
    },
    {
      "indent": 0,
      "text": "4. Examples",
      "section_title": true,
      "ja": "4. 例"
    },
    {
      "indent": 3,
      "text": "This section provides some example specializations.",
      "ja": "このセクションでは、いくつかの例の専門化を示します。"
    },
    {
      "indent": 3,
      "text": "For this example we use TLS 1.3 only with AES_GCM, x25519, ALPN h2, short random values, and everything else is ordinary TLS 1.3.",
      "ja": "この例では、AES_GCM、X25519、ALPN H2、短いランダム値でのみTLS 1.3を使用し、他のすべては通常のTLS 1.3です。"
    },
    {
      "indent": 3,
      "text": "{\n   \"ctlsVersion\": 0,\n   \"profile\": \"0504030201\",\n   \"version\" : 772,\n   \"random\": 16,\n   \"cipherSuite\" : \"TLS_AES_128_GCM_SHA256\",\n   \"dhGroup\": \"x25519\",\n   \"clientHelloExtensions\": {\n      \"predefinedExtensions\": {\n          \"application_layer_protocol_negotiation\" : \"030016832\",\n      },\n      \"allowAdditional\": true\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Version 772 corresponds to the hex representation 0x0304 (i.e. 1.3).",
      "ja": "バージョン772は、HEX表現0x0304（つまり1.3）に対応しています。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "WARNING: This document is effectively brand new and has seen no analysis. The idea here is that cTLS is isomorphic to TLS 1.3, and therefore should provide equivalent security guarantees.",
      "ja": "警告：このドキュメントは事実上真新しいものであり、分析は見られません。ここでの考え方は、CTLSがTLS 1.3に同型であるため、同等のセキュリティ保証を提供する必要があるということです。"
    },
    {
      "indent": 3,
      "text": "The use of key ids is a new feature introduced in this document, which requires some analysis, especially as it looks like a potential source of identity misbinding. This is, however, entirely separable from the rest of the specification.",
      "ja": "キーIDの使用は、このドキュメントで導入された新機能であり、特にアイデンティティの誤った違いの潜在的なソースのように見えるため、いくつかの分析が必要です。ただし、これは、仕様の残りの部分から完全に分離できます。"
    },
    {
      "indent": 3,
      "text": "Transcript expansion also needs some analysis and we need to determine whether we need an extension to indicate that cTLS is in use and with which profile.",
      "ja": "トランスクリプトの拡張にもいくつかの分析が必要であり、CTLSが使用されていることとどのプロファイルで使用されていることを示すために拡張機能が必要かどうかを判断する必要があります。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "6.1. Adding a ContentType",
      "section_title": true,
      "ja": "6.1. ContentTypeの追加"
    },
    {
      "indent": 3,
      "text": "This document requests that a code point be allocated from the \"TLS ContentType registry. This value must be in the range 0-31 (inclusive). The row to be added in the registry has the following form:",
      "ja": "このドキュメントは、コードポイントを「TLS ContentTypeレジストリから割り当てることを要求します。この値は0-31（包括的）範囲にある必要があります。レジストリに追加する行には次の形式があります。"
    },
    {
      "indent": 13,
      "text": "+=======+================+=========+===========+\n| Value | Description    | DTLS-OK | Reference |\n+=======+================+=========+===========+\n| TBD   | ctls           | Y       | RFCXXXX   |\n+-------+----------------+---------+-----------+\n| TBD   | ctls_handshake | Y       | RFCXXXX   |\n+-------+----------------+---------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Table 1",
      "ja": "表1"
    },
    {
      "indent": 6,
      "text": "RFC EDITOR: Please replace the value TBD with the value assigned by IANA, and the value XXXX to the RFC number assigned for this document.",
      "ja": "RFCエディター：値TBDをIANAによって割り当てられた値を、このドキュメントに割り当てられたRFC番号に値xxxxを置き換えてください。"
    },
    {
      "indent": 6,
      "text": "OPEN ISSUE: Should we require standards action for all profile IDs that would fit in 2 octets.",
      "ja": "OPENの問題：2オクテットに適合するすべてのプロファイルIDに対して標準アクションが必要な場合。"
    },
    {
      "indent": 0,
      "text": "6.2. Template Keys",
      "section_title": true,
      "ja": "6.2. テンプレートキー"
    },
    {
      "indent": 3,
      "text": "This document requests that IANA open a new registry entitled \"cTLS Template Keys\", on the Transport Layer Security (TLS) Parameters page, with a \"Specification Required\" registration policy and the following initial contents:",
      "ja": "このドキュメントは、IANAが「CTLSテンプレートキー」というタイトルの新しいレジストリを開くことを要求します。TransportLayer Security（TLS）パラメーターページで、「仕様が必要」登録ポリシーと次の初期内容を備えています。"
    },
    {
      "indent": 11,
      "text": "+=========================+=======+=================+\n| Name                    | Value | Reference       |\n+=========================+=======+=================+\n| profile                 | 0     | (This document) |\n+-------------------------+-------+-----------------+\n| version                 | 1     | (This document) |\n+-------------------------+-------+-----------------+\n| cipher_suite            | 2     | (This document) |\n+-------------------------+-------+-----------------+\n| dh_group                | 3     | (This document) |\n+-------------------------+-------+-----------------+\n| signature_algorithm     | 4     | (This document) |\n+-------------------------+-------+-----------------+\n| random                  | 5     | (This document) |\n+-------------------------+-------+-----------------+\n| mutual_auth             | 6     | (This document) |\n+-------------------------+-------+-----------------+\n| handshake_framing       | 7     | (This document) |\n+-------------------------+-------+-----------------+\n| client_hello_extensions | 8     | (This document) |\n+-------------------------+-------+-----------------+\n| server_hello_extensions | 9     | (This document) |\n+-------------------------+-------+-----------------+\n| encrypted_extensions    | 10    | (This document) |\n+-------------------------+-------+-----------------+\n| cert_request_extensions | 11    | (This document) |\n+-------------------------+-------+-----------------+\n| known_certificates      | 12    | (This document) |\n+-------------------------+-------+-----------------+\n| finished_size           | 13    | (This document) |\n+-------------------------+-------+-----------------+\n| optional                | 65535 | (This document) |\n+-------------------------+-------+-----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 34,
      "text": "Table 2",
      "ja": "表2"
    },
    {
      "indent": 0,
      "text": "6.3. Adding a cTLS Template message type",
      "section_title": true,
      "ja": "6.3. CTLSテンプレートメッセージタイプを追加します"
    },
    {
      "indent": 3,
      "text": "IANA is requested to add the following entry to the TLS HandshakeType registry.",
      "ja": "IANAは、TLSハンドシェークタイプレジストリに次のエントリを追加するように要求されます。"
    },
    {
      "indent": 3,
      "text": "* Value: TBD",
      "ja": "* 値：TBD"
    },
    {
      "indent": 3,
      "text": "* Description: ctls_template",
      "ja": "* 説明：CTLS_TEMPLATE"
    },
    {
      "indent": 3,
      "text": "* DTLS-OK: ??? Not clear what to put here.",
      "ja": "* DTLS-OK：???ここに何を置くべきか明確ではありません。"
    },
    {
      "indent": 3,
      "text": "* Reference: (This document)",
      "ja": "* 参照：（このドキュメント）"
    },
    {
      "indent": 3,
      "text": "* Comment: Virtual message used in cTLS.",
      "ja": "* コメント：CTLSで使用される仮想メッセージ。"
    },
    {
      "indent": 0,
      "text": "6.4. Activating the HelloRetryRequest MessageType",
      "section_title": true,
      "ja": "6.4. HelloretryRequest MessageTypeのアクティブ化"
    },
    {
      "indent": 3,
      "text": "This document requests that IANA change the name of entry 6 in the TLS HandshakeType Registry from \"hello_retry_request_RESERVED\" to \"hello_retry_request\", and set its Reference field to this document.",
      "ja": "このドキュメントは、IANAがTLS HandShakeTypeレジストリのエントリ6の名前を「hello_retry_request_reserved」から「hello_retry_request」に変更し、その参照フィールドをこのドキュメントに設定することを要求します。"
    },
    {
      "indent": 0,
      "text": "6.5. Reserved profiles",
      "section_title": true,
      "ja": "6.5. 予約済みプロファイル"
    },
    {
      "indent": 3,
      "text": "This document requests that IANA open a new registry entitled \"Well-known cTLS Profile IDs\", on the Transport Layer Security (TLS) Parameters page, with the following columns:",
      "ja": "このドキュメントでは、IANAが「有名なCTLSプロファイルID」というタイトルの新しいレジストリを開くことを要求します。トランスポートレイヤーセキュリティ（TLS）パラメーターページで、次の列があります。"
    },
    {
      "indent": 3,
      "text": "* ID value: A sequence of 1-4 octets.",
      "ja": "* ID値：1〜4オクテットのシーケンス。"
    },
    {
      "indent": 3,
      "text": "* Template: A JSON object.",
      "ja": "* テンプレート：JSONオブジェクト。"
    },
    {
      "indent": 3,
      "text": "* Note: An explanation or reference.",
      "ja": "* 注：説明または参照。"
    },
    {
      "indent": 3,
      "text": "The ID values of length 1 are subject to a \"Standards Action\" registry policy. Values of length 2 are subject to an \"RFC Required\" policy. Values of length 3 and 4 are subject to a \"First Come First Served\" policy. Values longer than 4 octets are not subject to registration and MUST NOT appear in this registry.",
      "ja": "長さ1のID値は、「標準アクション」レジストリポリシーの対象となります。長さ2の値は、「RFCが必要」ポリシーの対象となります。長さ3と4の値は、「最初に来る最初の提供」ポリシーの対象となります。4オクテットより長い値は登録の対象ではなく、このレジストリに表示されてはなりません。"
    },
    {
      "indent": 3,
      "text": "The initial registry contents are:",
      "ja": "初期レジストリの内容は次のとおりです。"
    },
    {
      "indent": 14,
      "text": "+==========+==================+===============+\n| ID value | Template         | Note          |\n+==========+==================+===============+\n| [0x00]   | {\"version\": 772} | cTLS 1.3-only |\n+----------+------------------+---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 34,
      "text": "Table 3",
      "ja": "表3"
    },
    {
      "indent": 0,
      "text": "7. Normative References",
      "section_title": true,
      "ja": "7. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/rfc/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487/RFC2119、1997年3月、<https://www.rfc-editor.org/rfc/RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487/RFC8174、2017年5月、<https：//www.rfc-editor.org/rfc/RFC8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8446] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/rfc/rfc8446>.",
      "ja": "[RFC8446] Rescorla、E。、「輸送層セキュリティ（TLS）プロトコルバージョン1.3」、RFC 8446、DOI 10.17487/RFC8446、2018年8月、<https://www.rfc-editor.org/rfc/RFC846>"
    },
    {
      "indent": 3,
      "text": "[RFC9147] Rescorla, E., Tschofenig, H., and N. Modadugu, \"The Datagram Transport Layer Security (DTLS) Protocol Version 1.3\", RFC 9147, DOI 10.17487/RFC9147, April 2022, <https://www.rfc-editor.org/rfc/rfc9147>.",
      "ja": "[RFC9147] Rescorla、E.、Tschofenig、H。、およびN. Modadugu、「データグラム輸送層セキュリティ（DTLS）プロトコルバージョン1.3」、RFC 9147、DOI 10.17487/RFC9147、2022年4月、<https：// www。rfc-editor.org/rfc/rfc9147>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Example Exchange",
      "section_title": true,
      "ja": "付録A.例交換の例"
    },
    {
      "indent": 3,
      "text": "The follow exchange illustrates a complete cTLS-based exchange supporting mutual authentication using certificates. The digital signatures use ECDSA with SHA256 and NIST P256r1. The ephemeral Diffie-Hellman uses the FX25519 curve and the exchange negotiates TLS-AES-128-CCM8-SHA256. The certificates are exchanged using certificate identifiers.",
      "ja": "フォローエクスチェンジは、証明書を使用した相互認証をサポートする完全なCTLSベースの交換を示しています。デジタル署名は、SHA256とNIST P256R1を搭載したECDSAを使用しています。Ephemeral Diffie-HellmanはFX25519曲線を使用し、ExchangeはTLS-AS-128-CCM8-SHA256を交渉します。証明書は、証明書識別子を使用して交換されます。"
    },
    {
      "indent": 3,
      "text": "The resulting byte counts are as follows:",
      "ja": "結果のバイト数は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "                     ECDHE\n              ------------------\n              TLS  CTLS  Overhead\n              ---  ----  --------\nClientHello   132   69       2\nServerHello    90   64       2\nServerFlight  478   73       5\nClientFlight  458   73       5\n==================================\nTotal        1158  279      14",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following compression profile was used in this example:",
      "ja": "この例では、次の圧縮プロファイルが使用されました。"
    },
    {
      "indent": 3,
      "text": "{\n  \"ctlsVersion\": 0,\n  \"profile\": \"abcdef1234\",\n  \"version\": 772,\n  \"cipherSuite\": \"TLS_AES_128_CCM_8_SHA256\",\n  \"dhGroup\": \"x25519\",\n  \"signatureAlgorithm\": \"ecdsa_secp256r1_sha256\",\n  \"finishedSize\": 8,\n  \"clientHelloExtensions\": {\n    \"predefinedExtensions\": {\n      \"server_name\": \"000e00000b6578616d706c652e636f6d\"\n    },\n    \"expectedExtensions\": [\"key_share\"],\n    \"allowAdditional\": false\n  },\n  \"serverHelloExtensions\": {\n    \"expectedExtensions\": [\"key_share\"],\n    \"allowAdditional\": false\n  },\n  \"certificateRequestExtensions\": {\n    \"predefinedExtensions\": {\n      \"certificate_request_context\": \"00\",\n      \"signature_algorithms\": \"00020403\"\n    },\n    \"allowAdditional\": false\n  },\n  \"mutualAuth\": true,\n  \"knownCertificates\": {\n    \"61\": \"3082...\",\n    \"62\": \"3082...\",\n    \"63\": \"...\",\n    \"64\": \"...\",\n    ...\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ClientHello: 71 bytes = Profile ID(5) + Random(32) + DH(32) +\nOverhead(2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "01                    // Handshake.msg_type = ClientHello\n05 abcdef1234         // ClientHello.profile_id\n5856a1...43168c130    // ClientHello.random\na690...af948          // KeyShareEntry.key_exchange",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ServerHello: 65 bytes = Random(32) + DH(32) + Overhead(1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "02                     // Handshake.msg_type = ServerHello\ncff4c0...684c859ca8    // ServerHello.random\n9fbc...0f49            // KeyShareEntry.key_exchange",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Server Flight: 78 = SIG(64) + MAC(8) + CERTID(1) + Overhead(5)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The EncryptedExtensions, and the CertificateRequest messages are omitted because they are empty.",
      "ja": "暗号化されたextextensions、およびcertifateRequestメッセージは空であるため省略されています。"
    },
    {
      "indent": 3,
      "text": "0b                 // Certificate\n  03               //   CertificateList\n    01             //     CertData.length\n      61           //       CertData = 'a'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "0f                 // CertificateVerify\n  3045...10ce      //   signature",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "14                 // Finished\n  bfc9d66715bb2b04 //   VerifyData",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Client Flight: 78 bytes = SIG(64) + MAC(8) + CERTID(1) + Overhead(5)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "0b                 // Certificate\n  03               //   CertificateList\n    01             //     CertData.length\n      62           //       CertData = 'b'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "0f                 // CertificateVerify\n  3045...f60e //   signature",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "14                 // Finished\n  35e9c34eec2c5dc1 //   VerifyData",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "We would like to thank Karthikeyan Bhargavan, Owen Friel, Sean Turner, Martin Thomson, and Chris Wood.",
      "ja": "Karthikeyan Bhargavan、Owen Friel、Sean Turner、Martin Thomson、Chris Woodに感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Eric Rescorla Mozilla Email: ekr@rtfm.com",
      "ja": "Eric Rescorla Mozillaメール：ekr@rtfm.com"
    },
    {
      "indent": 3,
      "text": "Richard Barnes Cisco",
      "ja": "リチャード・バーンズ・シスコ"
    },
    {
      "indent": 3,
      "text": "Email: rlb@ipv.sx",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hannes Tschofenig Arm Limited Email: hannes.tschofenig@arm.com",
      "ja": "Hannes Tschofenig ARM Limited Email：hannes.tchofenig@arm.com"
    },
    {
      "indent": 3,
      "text": "Benjamin M. Schwartz Google Email: bemasc@google.com",
      "ja": "Benjamin M. Schwartz Googleメール：bemasc@google.com"
    }
  ],
  "is_draft": true
}