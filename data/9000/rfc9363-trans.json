{
  "title": {
    "text": "RFC 9363 - A YANG Data Model for Static Context Header Compression (SCHC)",
    "ja": "RFC 9363 - 静的コンテキストヘッダー圧縮のヤンデータモデル（SCHC）"
  },
  "number": 9363,
  "created_at": "2024-03-16 03:51:29.507868+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       A. Minaburo\nRequest for Comments: 9363                                        Acklio\nCategory: Standards Track                                     L. Toutain\nISSN: 2070-1721                                           IMT Atlantique\n                                                              March 2023",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "A YANG Data Model for Static Context Header Compression (SCHC)",
      "title": true,
      "section_title": true,
      "ja": "静的コンテキストヘッダー圧縮のヤンデータモデル（SCHC）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes a YANG data model for the Static Context Header Compression (SCHC) compression and fragmentation Rules.",
      "ja": "このドキュメントでは、静的コンテキストヘッダー圧縮（SCHC）圧縮および断片化ルールのYangデータモデルについて説明します。"
    },
    {
      "indent": 3,
      "text": "This document formalizes the description of the Rules for better interoperability between SCHC instances either to exchange a set of Rules or to modify the parameters of some Rules.",
      "ja": "このドキュメントは、SCHCインスタンス間のより良い相互運用性のためのルールの説明を形式化し、一連のルールを交換したり、いくつかのルールのパラメーターを変更したりします。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準トラックドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 7841のセクション2で入手できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9363.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https：//www.rfc-editor.org/info/rfc9363で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2023 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2023 IETF Trustおよび文書著者として特定された人。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、改訂されたBSDライセンスで説明されている保証なしで提供されるように、改訂されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n2.  Requirements Language\n3.  Terminology\n4.  SCHC Rules\n  4.1.  Compression Rules\n  4.2.  Identifier Generation\n  4.3.  Convention for Field Identifier\n  4.4.  Convention for Field Length\n  4.5.  Convention for Field Position\n  4.6.  Convention for Direction Indicator\n  4.7.  Convention for Target Value\n  4.8.  Convention for Matching Operator\n    4.8.1.  Matching Operator Arguments\n  4.9.  Convention for Compression Decompression Actions\n    4.9.1.  Compression Decompression Action Arguments\n  4.10. Fragmentation Rule\n    4.10.1.  Fragmentation Mode\n    4.10.2.  Fragmentation Header\n    4.10.3.  Last Fragment Format\n    4.10.4.  Acknowledgment Behavior\n    4.10.5.  Timer Values\n    4.10.6.  Fragmentation Parameter\n    4.10.7.  Layer 2 Parameters\n5.  Rule Definition\n  5.1.  Compression Rule\n  5.2.  Fragmentation Rule\n  5.3.  YANG Tree\n6.  YANG Data Model\n7.  IANA Considerations\n  7.1.  URI Registration\n  7.2.  YANG Module Name Registration\n8.  Security Considerations\n9.  References\n  9.1.  Normative References\n  9.2.  Informative References\nAppendix A.  Example\nAcknowledgments\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "SCHC is a compression and fragmentation mechanism for constrained networks defined in [RFC8724]. It is based on a static context shared by two entities at the boundary of the constrained network. [RFC8724] provides an informal representation of the Rules used either for compression/decompression (C/D) or fragmentation/ reassembly (F/R). The goal of this document is to formalize the description of the Rules to offer:",
      "ja": "SCHCは、[RFC8724]で定義されている制約されたネットワークの圧縮および断片化メカニズムです。これは、制約されたネットワークの境界で2つのエンティティが共有する静的コンテキストに基づいています。[RFC8724]は、圧縮/減圧（C/D）または断片化/再組み立て（F/R）のいずれかに使用されるルールの非公式の表現を提供します。このドキュメントの目標は、提供するルールの説明を正式化することです。"
    },
    {
      "indent": 6,
      "text": "* the same definition on both ends, even if the internal representation is different, and",
      "ja": "* 内部表現が異なる場合でも、両端の同じ定義、そして"
    },
    {
      "indent": 6,
      "text": "* an update of the other end to set up some specific values (e.g., IPv6 prefix, destination address, etc.).",
      "ja": "* もう一方の端の更新で、いくつかの特定の値（IPv6プレフィックス、宛先アドレスなど）を設定します。"
    },
    {
      "indent": 3,
      "text": "[LPWAN-ARCH] illustrates the exchange of Rules using the YANG data model.",
      "ja": "[LPWAN-ARCH]は、Yangデータモデルを使用したルールの交換を示しています。"
    },
    {
      "indent": 3,
      "text": "This document defines a YANG data model [RFC7950] to represent both compression and fragmentation Rules, which leads to common representation for values for all the Rules' elements.",
      "ja": "このドキュメントでは、Yangデータモデル[RFC7950]を定義して、圧縮ルールとフラグメンテーションルールの両方を表し、すべてのルールの要素の値の共通の表現につながります。"
    },
    {
      "indent": 0,
      "text": "2. Requirements Language",
      "section_title": true,
      "ja": "2. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Terminology",
      "section_title": true,
      "ja": "3. 用語"
    },
    {
      "indent": 3,
      "text": "This section defines the terminology and acronyms used in this document. It extends the terminology of [RFC8376].",
      "ja": "このセクションでは、このドキュメントで使用されている用語と頭字語を定義します。[RFC8376]の用語を拡張します。"
    },
    {
      "indent": 3,
      "text": "App:",
      "ja": "アプリ："
    },
    {
      "indent": 12,
      "text": "Low-Power WAN (LPWAN) Application, as defined by [RFC8376]. An application sending/receiving packets to/from the Dev.",
      "ja": "[RFC8376]で定義されている低電力WAN（LPWAN）アプリケーション。開発者への送信/受信パケットを開発者に送信/受信します。"
    },
    {
      "indent": 3,
      "text": "Bi:",
      "ja": "bi："
    },
    {
      "indent": 12,
      "text": "Bidirectional. Characterizes a Field Descriptor that applies to headers of packets traveling in either direction (Up and Dw; see this glossary).",
      "ja": "双方向。どちらかの方向に移動するパケットのヘッダーに適用されるフィールド記述子を特徴付けます（UPとDW;この用語集を参照）。"
    },
    {
      "indent": 3,
      "text": "CDA:",
      "ja": "CDA："
    },
    {
      "indent": 12,
      "text": "Compression/Decompression Action. Describes the pair of actions that are performed at the compressor to compress a header field and at the decompressor to recover the original value of the header field.",
      "ja": "圧縮/減圧作用。コンプレッサーで実行されるアクションのペアについて、ヘッダーフィールドを圧縮し、減圧器でヘッダーフィールドの元の値を回復することを説明します。"
    },
    {
      "indent": 3,
      "text": "Context:",
      "ja": "コンテクスト："
    },
    {
      "indent": 12,
      "text": "A set of Rules used to compress/decompress headers.",
      "ja": "ヘッダーを圧縮/解凍するために使用される一連のルール。"
    },
    {
      "indent": 3,
      "text": "Dev:",
      "ja": "開発："
    },
    {
      "indent": 12,
      "text": "Device, as defined by [RFC8376].",
      "ja": "[RFC8376]で定義されているデバイス。"
    },
    {
      "indent": 3,
      "text": "DevIID:",
      "ja": "Deviid："
    },
    {
      "indent": 12,
      "text": "Device Interface Identifier. The IID that identifies the Dev interface.",
      "ja": "デバイスインターフェイス識別子。開発インターフェイスを識別するIID。"
    },
    {
      "indent": 3,
      "text": "DI:",
      "ja": "di："
    },
    {
      "indent": 12,
      "text": "Direction Indicator. This field tells which direction of packet travel (Up, Dw, or Bi) a Field Descriptor applies to. This allows for asymmetric processing, using the same Rule.",
      "ja": "方向インジケーター。このフィールドは、フィールド記述子が適用されるパケットトラベル（UP、DW、またはBI）の方向を示しています。これにより、同じルールを使用して非対称処理が可能になります。"
    },
    {
      "indent": 3,
      "text": "Dw:",
      "ja": "DW："
    },
    {
      "indent": 12,
      "text": "Downlink direction for compression/decompression, from SCHC C/D in the network to SCHC C/D in the Dev.",
      "ja": "ネットワーク内のSCHC C/Dから開発者のSCHC C/Dまで、圧縮/減圧のためのダウンリンク方向。"
    },
    {
      "indent": 3,
      "text": "FID:",
      "ja": "fid："
    },
    {
      "indent": 12,
      "text": "Field Identifier or Field ID. This identifies the protocol and field a Field Descriptor applies to.",
      "ja": "フィールド識別子またはフィールドID。これにより、フィールド記述子が適用されるプロトコルとフィールドが識別されます。"
    },
    {
      "indent": 3,
      "text": "FL:",
      "ja": "FL："
    },
    {
      "indent": 12,
      "text": "Field Length. This is the length of the original packet header field. It is expressed as a number of bits for header fields of fixed lengths or as a type (e.g., variable, token length, ...) for Field Lengths that are unknown at the time of Rule creation. The length of a header field is defined in the corresponding protocol specification (such as IPv6 or UDP).",
      "ja": "フィールドの長さ。これは、元のパケットヘッダーフィールドの長さです。固定された長さのヘッダーフィールドに対して、またはルール作成時に不明なフィールド長のタイプ（たとえば、可変、トークンの長さなど）として多数のビットとして表されます。ヘッダーフィールドの長さは、対応するプロトコル仕様（IPv6やUDPなど）で定義されています。"
    },
    {
      "indent": 3,
      "text": "FP:",
      "ja": "FP："
    },
    {
      "indent": 12,
      "text": "Field Position. When a field is expected to appear multiple times in a header, the Field Position specifies the occurrence this Field Descriptor applies to (for example, first Uri-Path option, second Uri-Path, etc. in a Constrained Application Protocol (CoAP) header), counting from 1. The value 0 is special and means \"don't care\" (see Section 7.2 of [RFC8724]).",
      "ja": "フィールド位置。フィールドがヘッダーに複数回表示されると予想される場合、フィールドの位置は、このフィールド記述子が適用する発生を指定します（たとえば、最初のURI-Pathオプション、2番目のURI-Pathなど。）、1からのカウント値0は特別であり、「気にしない」を意味します（[RFC8724]のセクション7.2を参照）。"
    },
    {
      "indent": 3,
      "text": "IID:",
      "ja": "IID："
    },
    {
      "indent": 12,
      "text": "Interface Identifier. See the IPv6 addressing architecture [RFC7136].",
      "ja": "インターフェイス識別子。IPv6アドレス指定アーキテクチャ[RFC7136]を参照してください。"
    },
    {
      "indent": 3,
      "text": "L2 Word:",
      "ja": "L2ワード："
    },
    {
      "indent": 12,
      "text": "This is the minimum subdivision of payload data that the Layer 2 (L2) will carry. In most L2 technologies, the L2 Word is an octet. In bit-oriented radio technologies, the L2 Word might be a single bit. The L2 Word size is assumed to be constant over time for each device.",
      "ja": "これは、レイヤー2（L2）が携帯するペイロードデータの最小区分です。ほとんどのL2テクノロジーでは、L2ワードはオクテットです。ビット指向のラジオテクノロジーでは、L2ワードは単一のものかもしれません。L2ワードサイズは、各デバイスの時間の経過とともに一定であると想定されています。"
    },
    {
      "indent": 3,
      "text": "MO:",
      "ja": "MO："
    },
    {
      "indent": 12,
      "text": "Matching Operator. An operator used to match a value contained in a header field with a value contained in a Rule.",
      "ja": "マッチングオペレーター。ヘッダーフィールドに含まれる値をルールに含む値と一致させるために使用されるオペレーター。"
    },
    {
      "indent": 3,
      "text": "RuleID:",
      "ja": "Ruleid："
    },
    {
      "indent": 12,
      "text": "Rule Identifier. An identifier for a Rule. SCHC C/D on both sides share the same RuleID for a given packet. A set of RuleIDs are used to support SCHC F/R functionality.",
      "ja": "ルール識別子。ルールの識別子。両側のSCHC C/Dは、特定のパケットに対して同じRuleIDを共有しています。SCHC F/Rの機能をサポートするために、RoolIDのセットが使用されます。"
    },
    {
      "indent": 3,
      "text": "TV:",
      "ja": "テレビ："
    },
    {
      "indent": 12,
      "text": "Target Value. A value contained in a Rule that will be matched with the value of a header field.",
      "ja": "目標値。ルールに含まれる値は、ヘッダーフィールドの値と一致します。"
    },
    {
      "indent": 3,
      "text": "Up:",
      "ja": "上："
    },
    {
      "indent": 12,
      "text": "Uplink direction for compression/decompression, from the Dev SCHC C/D to the network SCHC C/D.",
      "ja": "DEV SCHC C/DからネットワークSCHC C/Dまで、圧縮/減圧のためのアップリンク方向。"
    },
    {
      "indent": 0,
      "text": "4. SCHC Rules",
      "section_title": true,
      "ja": "4. SCHCルール"
    },
    {
      "indent": 3,
      "text": "SCHC compression is generic; the main mechanism does not refer to a specific protocol. Any header field is abstracted through a Field Identifier (FID), a position (FP), a direction (DI), and a value that can be a numerical value or a string. [RFC8724] and [RFC8824] specify fields for IPv6 [RFC8200], UDP [RFC0768], and CoAP [RFC7252], including options defined for no server response [RFC7967] and Object Security for Constrained RESTful Environments (OSCORE) [RFC8613]. For the latter, [RFC8824] splits this field into subfields.",
      "ja": "SCHC圧縮は一般的です。主なメカニズムは、特定のプロトコルを参照していません。ヘッダーフィールドは、フィールド識別子（FID）、位置（FP）、方向（DI）、および数値または文字列になる値を介して抽出されます。[RFC8724]および[RFC8824]は、IPv6 [RFC8200]、UDP [RFC0768]、およびCOAP [RFC7252]のフィールドを指定します。後者の場合、[RFC8824]はこのフィールドをサブフィールドに分割します。"
    },
    {
      "indent": 3,
      "text": "SCHC fragmentation requires a set of common parameters that are included in a Rule. These parameters are defined in [RFC8724].",
      "ja": "SCHCの断片化には、ルールに含まれる共通のパラメーターのセットが必要です。これらのパラメーターは[RFC8724]で定義されています。"
    },
    {
      "indent": 3,
      "text": "The YANG data model enables the compression and the fragmentation selection using the feature statement.",
      "ja": "Yangデータモデルは、機能ステートメントを使用して圧縮とフラグメンテーションの選択を可能にします。"
    },
    {
      "indent": 0,
      "text": "4.1. Compression Rules",
      "section_title": true,
      "ja": "4.1. 圧縮ルール"
    },
    {
      "indent": 3,
      "text": "[RFC8724] proposes an informal representation of the compression Rule. A compression context for a device is composed of a set of Rules. Each Rule contains information to describe a specific field in the header to be compressed.",
      "ja": "[RFC8724]は、圧縮ルールの非公式な表現を提案しています。デバイスの圧縮コンテキストは、一連のルールで構成されています。各ルールには、圧縮されるヘッダー内の特定のフィールドを説明する情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "  +-----------------------------------------------------------------+\n  |                      Rule N                                     |\n +-----------------------------------------------------------------+|\n |                    Rule i                                       ||\n+-----------------------------------------------------------------+||\n|  (FID)            Rule 1                                        |||\n|+-------+--+--+--+------------+-----------------+---------------+|||\n||Field 1|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||||\n|+-------+--+--+--+------------+-----------------+---------------+|||\n||Field 2|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||||\n|+-------+--+--+--+------------+-----------------+---------------+|||\n||...    |..|..|..|   ...      | ...             | ...           ||||\n|+-------+--+--+--+------------+-----------------+---------------+||/\n||Field N|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act|||\n|+-------+--+--+--+------------+-----------------+---------------+|/\n|                                                                 |\n\\-----------------------------------------------------------------/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 1: Compression Decompression Context",
      "ja": "図1：圧縮減圧コンテキスト"
    },
    {
      "indent": 0,
      "text": "4.2. Identifier Generation",
      "section_title": true,
      "ja": "4.2. 識別子生成"
    },
    {
      "indent": 3,
      "text": "Identifiers used in the SCHC YANG data model are from the identityref statement to ensure global uniqueness and easy augmentation if needed. The principle to define a new type based on a group of identityref is the following:",
      "ja": "SCHC Yangデータモデルで使用される識別子は、必要に応じてグローバルな一意性と簡単な増強を確保するために、IDREFステートメントからのものです。IDREFのグループに基づいて新しいタイプを定義する原則は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* Define a main identity ending with the keyword base-type.",
      "ja": "* キーワードベースタイプで終わるメインアイデンティティを定義します。"
    },
    {
      "indent": 6,
      "text": "* Derive all the identities used in the data model from this base type.",
      "ja": "* このベースタイプからデータモデルで使用されるすべてのアイデンティティを導き出します。"
    },
    {
      "indent": 6,
      "text": "* Create a typedef from this base type.",
      "ja": "* このベースタイプからtypedefを作成します。"
    },
    {
      "indent": 3,
      "text": "The example below (Figure 2) shows how an identityref is created for Reassembly Check Sequence (RCS) algorithms used during SCHC fragmentation.",
      "ja": "以下の例（図2）は、SCHC断片化中に使用される再組み立てチェックシーケンス（RCS）アルゴリズムのためにIDREFがどのように作成されるかを示しています。"
    },
    {
      "indent": 5,
      "text": "identity rcs-algorithm-base-type {\n  description\n    \"Identify which algorithm is used to compute RCS.\n     The algorithm also defines the size of the RCS field.\";\n  reference\n    \"RFC 8724 SCHC: Generic Framework for Static Context Header\n              Compression and Fragmentation\";\n}\n\nidentity rcs-crc32 {\n  base rcs-algorithm-base-type;\n  description\n    \"CRC32 defined as default RCS in RFC 8724.  This RCS is\n     4 bytes long.\";\n  reference\n    \"RFC 8724 SCHC: Generic Framework for Static Context Header\n              Compression and Fragmentation\";\n}\n\ntypedef rcs-algorithm-type {\n  type identityref {\n    base rcs-algorithm-base-type;\n  }\n  description\n    \"Define the type for RCS algorithm in Rules.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Figure 2: Principle to Define a Type Based on identityref",
      "ja": "図2：IdentityRefに基づいてタイプを定義する原則"
    },
    {
      "indent": 0,
      "text": "4.3. Convention for Field Identifier",
      "section_title": true,
      "ja": "4.3. フィールド識別子の慣習"
    },
    {
      "indent": 3,
      "text": "In the process of compression, the headers of the original packet are first parsed to create a list of fields. This list of fields is matched against the Rules to find the appropriate Rule and apply compression. [RFC8724] does not state how the Field ID value is constructed. In examples, identification is done through a string indexed by the protocol name (e.g., IPv6.version, CoAP.version, etc.).",
      "ja": "圧縮の過程で、元のパケットのヘッダーが最初に解析され、フィールドのリストが作成されます。このフィールドのリストは、適切なルールを見つけて圧縮を適用するためにルールと一致します。[RFC8724]は、フィールドID値の構築方法を述べていません。たとえば、識別は、プロトコル名でインデックス付けされた文字列（例：IPv6.version、coap.versionなど）を使用して行われます。"
    },
    {
      "indent": 3,
      "text": "The current YANG data model includes field definitions found in [RFC8724] and [RFC8824].",
      "ja": "現在のYangデータモデルには、[RFC8724]および[RFC8824]に見られるフィールド定義が含まれています。"
    },
    {
      "indent": 3,
      "text": "Using the YANG data model, each field MUST be identified through a global YANG identityref.",
      "ja": "Yangデータモデルを使用して、各フィールドをグローバルなYang IdentiteRefで識別する必要があります。"
    },
    {
      "indent": 3,
      "text": "A YANG Field ID for the protocol is always derived from the fid-base-type. Then, an identity for each protocol is specified using the naming convention fid-<<protocol name>>-base-type. All possible fields for this protocol MUST derive from the protocol identity. The naming convention is \"fid-\" followed by the protocol name and the field name. If a field has to be divided into subfields, the field identity serves as a base.",
      "ja": "プロトコルのYangフィールドIDは、常にFIDベースタイプから派生します。次に、各プロトコルのアイデンティティが命名規則fid  -  <<プロトコル名>>  - ベースタイプを使用して指定されます。このプロトコルのすべての可能なフィールドは、プロトコルIDから派生する必要があります。命名規則は「fid-」に続いて、プロトコル名とフィールド名が続きます。フィールドをサブフィールドに分割する必要がある場合、フィールドアイデンティティはベースとして機能します。"
    },
    {
      "indent": 3,
      "text": "The full field-id definition is found in Section 6. A type is defined for the IPv6 protocol, and each field is based on it. Note that the Diffserv bits derive from the Traffic Class identity.",
      "ja": "Full-IDの定義はセクション6にあります。IPv6プロトコルに対してタイプが定義されており、各フィールドはそれに基づいています。diffservビットは、トラフィッククラスのIDに由来することに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.4. Convention for Field Length",
      "section_title": true,
      "ja": "4.4. フィールドの長さの慣習"
    },
    {
      "indent": 3,
      "text": "The Field Length is either an integer giving the size of a field in bits or a specific function. [RFC8724] defines the \"var\" function, which allows variable-length fields (whose length is expressed in bytes), and [RFC8824] defines the \"tkl\" function for managing the CoAP Token Length field.",
      "ja": "フィールドの長さは、ビットのフィールドのサイズを与える整数または特定の関数のいずれかです。[RFC8724]は、「VAR」関数を定義します。これは、可変長さのフィールド（長さがバイトで表される）を許可し、[RFC8824]は、COAPトークンの長さフィールドを管理するための「TKL」関数を定義します。"
    },
    {
      "indent": 3,
      "text": "The naming convention is \"fl-\" followed by the function name.",
      "ja": "命名規則は「fl-」に続く関数名です。"
    },
    {
      "indent": 3,
      "text": "The Field Length function can be defined as an identityref, as described in Section 6. Therefore, the type for the Field Length is a union between an integer giving the size of the length in bits and the identityref.",
      "ja": "セクション6で説明されているように、フィールドの長さ関数はIDREFとして定義できます。したがって、フィールド長のタイプは、ビットの長さのサイズを与える整数とIDREFの結合です。"
    },
    {
      "indent": 0,
      "text": "4.5. Convention for Field Position",
      "section_title": true,
      "ja": "4.5. フィールドポジションのための慣習"
    },
    {
      "indent": 3,
      "text": "The Field Position is a positive integer that gives the occurrence times of a specific field from the header start. The default value is 1 and is incremented at each repetition. Value 0 indicates that the position is not important and is not considered during the Rule selection process.",
      "ja": "フィールドの位置は、ヘッダー開始から特定のフィールドの発生時間を与える正の整数です。デフォルト値は1で、繰り返しごとに増加します。値0は、位置が重要ではなく、ルール選択プロセス中に考慮されないことを示します。"
    },
    {
      "indent": 3,
      "text": "The Field Position is a positive integer. The type is uint8.",
      "ja": "フィールドの位置は正の整数です。タイプはUINT8です。"
    },
    {
      "indent": 0,
      "text": "4.6. Convention for Direction Indicator",
      "section_title": true,
      "ja": "4.6. 方向指標の慣習"
    },
    {
      "indent": 3,
      "text": "The Direction Indicator is used to tell if a field appears in both directions (Bi) or only uplink (Up) or Downlink (Dw). The naming convention is \"di\" followed by the Direction Indicator name.",
      "ja": "方向インジケーターは、フィールドが両方向（bi）に表示されるか、アップリンク（up）またはダウンリンク（dw）のみに表示されるかどうかを判断するために使用されます。命名規則は「DI」に続く指示インジケータ名が続きます。"
    },
    {
      "indent": 3,
      "text": "The type is \"di-type\".",
      "ja": "タイプは「di-type」です。"
    },
    {
      "indent": 0,
      "text": "4.7. Convention for Target Value",
      "section_title": true,
      "ja": "4.7. 目標価値の条約"
    },
    {
      "indent": 3,
      "text": "The Target Value is a list of binary sequences of any length, aligned to the left. In the Rule, the structure will be used as a list, with the index as a key. The highest index value is used to compute the size of the index sent in residue for the match-mapping Compression Decompression Action (CDA). The index can specify several values:",
      "ja": "ターゲット値は、左に整列した、任意の長さのバイナリシーケンスのリストです。ルールでは、構造はリストとして使用され、インデックスをキーとして使用します。最高のインデックス値は、マッチマッピング圧縮減圧アクション（CDA）のために残留物で送信されるインデックスのサイズを計算するために使用されます。インデックスはいくつかの値を指定できます。"
    },
    {
      "indent": 6,
      "text": "* For equal and most significant bits (MSBs), the Target Value contains a single element. Therefore, the index is set to 0.",
      "ja": "* 等しく最も重要なビット（MSB）の場合、ターゲット値には単一の要素が含まれます。したがって、インデックスは0に設定されます。"
    },
    {
      "indent": 6,
      "text": "* For match-mapping, the Target Value can contain several elements. Index values MUST start from 0 and MUST be contiguous.",
      "ja": "* マッチマッピングの場合、ターゲット値にはいくつかの要素を含めることができます。インデックス値は0から開始する必要があり、隣接する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the header field contains text, the binary sequence uses the same encoding.",
      "ja": "ヘッダーフィールドにテキストが含まれている場合、バイナリシーケンスは同じエンコードを使用します。"
    },
    {
      "indent": 0,
      "text": "4.8. Convention for Matching Operator",
      "section_title": true,
      "ja": "4.8. 一致するオペレーターのための慣習"
    },
    {
      "indent": 3,
      "text": "The Matching Operator (MO) is a function applied between a field value provided by the parsed header and the Target Value. [RFC8724] defines 4 MOs.",
      "ja": "一致する演算子（MO）は、解析されたヘッダーによって提供されるフィールド値とターゲット値の間に適用される関数です。[RFC8724]は4か月を定義します。"
    },
    {
      "indent": 3,
      "text": "The naming convention is \"mo-\" followed by the MO name.",
      "ja": "命名規則は「MO-」に続くMO名です。"
    },
    {
      "indent": 3,
      "text": "The type is \"mo-type\".",
      "ja": "タイプは「mo-type」です。"
    },
    {
      "indent": 0,
      "text": "4.8.1. Matching Operator Arguments",
      "section_title": true,
      "ja": "4.8.1. 一致するオペレーターの引数"
    },
    {
      "indent": 3,
      "text": "They are viewed as a list, built with a tv-struct (see Section 4.7).",
      "ja": "それらは、テレビ構造で構築されたリストと見なされています（セクション4.7を参照）。"
    },
    {
      "indent": 0,
      "text": "4.9. Convention for Compression Decompression Actions",
      "section_title": true,
      "ja": "4.9. 圧縮減圧アクションのための条約"
    },
    {
      "indent": 3,
      "text": "The Compression Decompression Action (CDA) identifies the function to use for compression or decompression. [RFC8724] defines 7 CDAs.",
      "ja": "圧縮減圧作用（CDA）は、圧縮または減圧に使用する関数を識別します。[RFC8724]は7つのCDAを定義します。"
    },
    {
      "indent": 3,
      "text": "The naming convention is \"cda-\" followed by the CDA name.",
      "ja": "命名規則は「CDA-」に続くCDA名が続きます。"
    },
    {
      "indent": 0,
      "text": "4.9.1. Compression Decompression Action Arguments",
      "section_title": true,
      "ja": "4.9.1. 圧縮減圧動作の引数"
    },
    {
      "indent": 3,
      "text": "Currently no CDA requires arguments, but some CDAs may require one or several arguments in the future. They are viewed as a list of target-value type.",
      "ja": "現在、CDAは引数を必要としませんが、一部のCDAは将来1つまたは複数の引数を必要とする場合があります。それらは、ターゲット値タイプのリストと見なされます。"
    },
    {
      "indent": 0,
      "text": "4.10. Fragmentation Rule",
      "section_title": true,
      "ja": "4.10. 断片化ルール"
    },
    {
      "indent": 3,
      "text": "Fragmentation is optional in the data model and depends on the presence of the \"fragmentation\" feature.",
      "ja": "断片化はデータモデルではオプションであり、「断片化」機能の存在に依存します。"
    },
    {
      "indent": 3,
      "text": "Most of the fragmentation parameters are listed in Appendix D of [RFC8724].",
      "ja": "断片化パラメーターのほとんどは、[RFC8724]の付録Dにリストされています。"
    },
    {
      "indent": 3,
      "text": "Since fragmentation Rules work for a specific direction, they MUST contain a mandatory Direction Indicator. The type is the same as the one used in compression entries, but bidirectional MUST NOT be used.",
      "ja": "断片化ルールは特定の方向に機能するため、必須の方向指標を含める必要があります。このタイプは、圧縮エントリで使用されているタイプと同じですが、双方向は使用してはなりません。"
    },
    {
      "indent": 0,
      "text": "4.10.1. Fragmentation Mode",
      "section_title": true,
      "ja": "4.10.1. 断片化モード"
    },
    {
      "indent": 3,
      "text": "[RFC8724] defines 3 fragmentation modes:",
      "ja": "[RFC8724] 3つの断片化モードを定義します。"
    },
    {
      "indent": 6,
      "text": "* No ACK: This mode is unidirectional; no acknowledgment is sent back.",
      "ja": "* ACKなし：このモードは一方向です。謝辞は返送されません。"
    },
    {
      "indent": 6,
      "text": "* ACK Always: Each fragmentation window must be explicitly acknowledged before going to the next.",
      "ja": "* ACK常に：各断片化ウィンドウは、次の断片化ウィンドウを明示的に確認する必要があります。"
    },
    {
      "indent": 6,
      "text": "* ACK on Error: A window is acknowledged only when the receiver detects some missing fragments.",
      "ja": "* ACK ON ERROR：ウィンドウは、レシーバーが不足しているフラグメントを検出した場合にのみ認められます。"
    },
    {
      "indent": 3,
      "text": "The type is \"fragmentation-mode-type\". The naming convention is \"fragmentation-mode-\" followed by the fragmentation mode name.",
      "ja": "タイプは「フラグメンテーションモードタイプ」です。命名規則は、「フラグメンテーションモード」に続くフラグメンテーションモード名です。"
    },
    {
      "indent": 0,
      "text": "4.10.2. Fragmentation Header",
      "section_title": true,
      "ja": "4.10.2. 断片化ヘッダー"
    },
    {
      "indent": 3,
      "text": "A data fragment header, starting with the RuleID, can be sent in the fragmentation direction. [RFC8724] indicates that the SCHC header may be composed of the following (cf. Figure 3):",
      "ja": "Roolidから始まるデータフラグメントヘッダーは、断片化方向に送信できます。[RFC8724]は、SCHCヘッダーが以下で構成されている可能性があることを示しています（図3を参照）。"
    },
    {
      "indent": 6,
      "text": "* a Datagram Tag (DTag) identifying the datagram being fragmented if the fragmentation applies concurrently on several datagrams. This field is optional, and its length is defined by the Rule.",
      "ja": "* 断片化がいくつかのデータグラムに同時に適用される場合、断片化されているデータグラムを識別するデータグラムタグ（DTAG）。このフィールドはオプションであり、その長さはルールによって定義されます。"
    },
    {
      "indent": 6,
      "text": "* a Window (W) used in ACK-Always and ACK-on-Error modes. In ACK-Always, its size is 1. In ACK-on-Error, it depends on the Rule. This field is not needed in No-ACK mode.",
      "ja": "* Ack-alwaysおよびack-on-errorモードで使用されるウィンドウ（W）。Ack-alwaysでは、そのサイズは1です。Ack-on-errorでは、ルールに依存します。このフィールドは、No-ackモードでは必要ありません。"
    },
    {
      "indent": 6,
      "text": "* a Fragment Compressed Number (FCN) indicating the fragment/tile position within the window. This field is mandatory on all modes defined in [RFC8724], and its size is defined by the Rule.",
      "ja": "* ウィンドウ内のフラグメント/タイルの位置を示すフラグメント圧縮数（FCN）。このフィールドは、[RFC8724]で定義されているすべてのモードで必須であり、そのサイズはルールによって定義されます。"
    },
    {
      "indent": 3,
      "text": "|-- SCHC Fragment Header ----|\n         |-- T --|-M-|-- N --|\n+-- ... -+- ... -+---+- ... -+--------...-------+~~~~~~~~~~~~~~~~~~~~\n| RuleID | DTag  | W |  FCN  | Fragment Payload | padding (as needed)\n+-- ... -+- ... -+---+- ... -+--------...-------+~~~~~~~~~~~~~~~~~~~~",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 3: Data Fragment Header from RFC 8724",
      "ja": "図3：RFC 8724のデータフラグメントヘッダー"
    },
    {
      "indent": 0,
      "text": "4.10.3. Last Fragment Format",
      "section_title": true,
      "ja": "4.10.3. 最後のフラグメント形式"
    },
    {
      "indent": 3,
      "text": "The last fragment of a datagram is sent with a Reassembly Check Sequence (RCS) field to detect residual transmission errors and possible losses in the last window. [RFC8724] defines a single algorithm based on Ethernet CRC computation.",
      "ja": "データグラムの最後のフラグメントは、再組み立てチェックシーケンス（RCS）フィールドで送信され、最後のウィンドウで残留伝送エラーと可能な損失を検出します。[RFC8724]は、イーサネットCRC計算に基づいて単一のアルゴリズムを定義します。"
    },
    {
      "indent": 3,
      "text": "The naming convention is \"rcs-\" followed by the algorithm name.",
      "ja": "命名規則は「RCS-」に続いてアルゴリズム名が続きます。"
    },
    {
      "indent": 3,
      "text": "For ACK-on-Error mode, the All-1 fragment may just contain the RCS or can include a tile. The following parameters define the behavior:",
      "ja": "ACKオンエラーモードの場合、ALL-1フラグメントにはRCSを含むか、タイルを含めることができます。次のパラメーターが動作を定義します。"
    },
    {
      "indent": 6,
      "text": "* all-1-data-no: The last fragment contains no data, just the RCS.",
      "ja": "* All-1-Data-No：最後のフラグメントにはデータが含まれておらず、RCのみが含まれています。"
    },
    {
      "indent": 6,
      "text": "* all-1-data-yes: The last fragment includes a single tile and the RCS.",
      "ja": "* All-1-Data-Yes：最後のフラグメントには、単一のタイルとRCが含まれます。"
    },
    {
      "indent": 6,
      "text": "* all-1-data-sender-choice: The last fragment may or may not contain a single tile. The receiver can detect if a tile is present.",
      "ja": "* All-1-Data-Sender-Choice：最後のフラグメントには、単一のタイルが含まれている場合と含まれていない場合があります。受信機は、タイルが存在するかどうかを検出できます。"
    },
    {
      "indent": 3,
      "text": "The naming convention is \"all-1-data-\" followed by the behavior identifier.",
      "ja": "命名規則は「All-1-Data-」に続く動作識別子が続きます。"
    },
    {
      "indent": 0,
      "text": "4.10.4. Acknowledgment Behavior",
      "section_title": true,
      "ja": "4.10.4. 謝辞行動"
    },
    {
      "indent": 3,
      "text": "The acknowledgment fragment header goes in the opposite direction of data. [RFC8724] defines the header, which is composed of the following (see Figure 4):",
      "ja": "承認フラグメントヘッダーは、データの反対方向に進みます。[RFC8724]はヘッダーを定義します。これは、次のもので構成されています（図4を参照）。"
    },
    {
      "indent": 6,
      "text": "* a DTag (if present).",
      "ja": "* DTAG（存在する場合）。"
    },
    {
      "indent": 6,
      "text": "* a mandatory window, as in the data fragment.",
      "ja": "* データフラグメントのように、必須ウィンドウ。"
    },
    {
      "indent": 6,
      "text": "* a C bit giving the status of RCS validation. In case of failure, a bitmap follows, indicating the received tile.",
      "ja": "* RCS検証のステータスを与えるCビット。障害の場合、ビットマップが続き、受信したタイルを示します。"
    },
    {
      "indent": 3,
      "text": "|--- SCHC ACK Header ----|\n         |-- T --|-M-| 1 |\n+-- ... -+- ... -+---+---+~~~~~~~~~~~~~~~~~~\n| RuleID |  DTag | W |C=1| padding as needed                (success)\n+-- ... -+- ... -+---+---+~~~~~~~~~~~~~~~~~~\n\n+-- ... -+- ... -+---+---+------ ... ------+~~~~~~~~~~~~~~~\n| RuleID |  DTag | W |C=0|Compressed Bitmap| pad. as needed (failure)\n+-- ... -+- ... -+---+---+------ ... ------+~~~~~~~~~~~~~~~",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Figure 4: Acknowledgment Fragment Header for RFC 8724",
      "ja": "図4：RFC 8724の確認フラグメントヘッダー"
    },
    {
      "indent": 3,
      "text": "For ACK-on-Error, SCHC defines when an acknowledgment can be sent. This can be at any time defined by the Layer 2, at the end of a window (FCN all-0), or as a response to receiving the last fragment (FCN all-1). The naming convention is \"ack-behavior\" followed by the algorithm name.",
      "ja": "ACKオンエラーの場合、SCHCは、確認をいつ送信できるかを定義します。これは、いつでもレイヤー2、ウィンドウの端（FCN ALL-0）で定義されるか、最後のフラグメント（FCN ALL-1）を受信することへの応答として定義できます。命名規則は「ACK-Behavior」に続くアルゴリズム名が続きます。"
    },
    {
      "indent": 0,
      "text": "4.10.5. Timer Values",
      "section_title": true,
      "ja": "4.10.5. タイマー値"
    },
    {
      "indent": 3,
      "text": "The state machine requires some common values to handle fragmentation correctly.",
      "ja": "状態マシンは、断片化を正しく処理するためにいくつかの共通値を必要とします。"
    },
    {
      "indent": 6,
      "text": "* The Retransmission Timer gives the duration before sending an ACK request (cf. Section 8.2.2.4 of [RFC8724]). If specified, the value MUST be strictly positive.",
      "ja": "* 再送信タイマーは、ACK要求を送信する前に期間を与えます（[RFC8724]のセクション8.2.2.4を参照）。指定した場合、値は厳密に正でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* The Inactivity Timer gives the duration before aborting a fragmentation session (cf. Section 8.2.2.4 of [RFC8724]). The value 0 explicitly indicates that this timer is disabled.",
      "ja": "* 非アクティブタイマーは、断片化セッションを中止する前の期間を示します（[RFC8724]のセクション8.2.2.4を参照）。値0は、このタイマーが無効になっていることを明示的に示します。"
    },
    {
      "indent": 3,
      "text": "[RFC8724] does not specify any range for these timers. [RFC9011] recommends a duration of 12 hours. In fact, the value range should be between milliseconds for real-time systems to several days for worse-than-best-effort systems. To allow a large range of applications, two parameters must be specified:",
      "ja": "[RFC8724]は、これらのタイマーの範囲を指定していません。[RFC9011]は12時間の期間を推奨します。実際、値の範囲は、リアルタイムシステムのミリ秒間で数日間で、最も悪いエフォルトシステムの場合は数日間でなければなりません。幅広いアプリケーションを許可するには、2つのパラメーターを指定する必要があります。"
    },
    {
      "indent": 6,
      "text": "* the duration of a tick. It is computed by this formula: 2^(tick-duration)/10^6. When tick-duration is set to 0, the unit is the microsecond. The default value of 20 leads to a unit of 1.048575 seconds. A value of 32 leads to a tick-duration of about 1 hour 11 minutes.",
      "ja": "* ダニの期間。これは、この式で計算されます：2^（ティック持続時間）/10^6。ティック期間が0に設定されると、ユニットはマイクロ秒です。20のデフォルト値は、1.048575秒の単位につながります。32の値は、約1時間11分のティック期間につながります。"
    },
    {
      "indent": 6,
      "text": "* the number of ticks in the predefined unit. With the default tick-duration value of 20, the timers can cover a range between 1.0 second and 19 hours, as recommended in [RFC9011].",
      "ja": "* 事前定義されたユニットのダニの数。[RFC9011]で推奨されているように、デフォルトのダニの継続的な値が20の場合、タイマーは1.0秒から19時間の範囲をカバーできます。"
    },
    {
      "indent": 0,
      "text": "4.10.6. Fragmentation Parameter",
      "section_title": true,
      "ja": "4.10.6. 断片化パラメーター"
    },
    {
      "indent": 3,
      "text": "The SCHC fragmentation protocol specifies the number of attempts before aborting through the parameter:",
      "ja": "SCHCフラグメンテーションプロトコルは、パラメーターを中止する前の試行回数を指定します。"
    },
    {
      "indent": 6,
      "text": "* max-ack-requests (cf. Section 8.2.2.4 of [RFC8724])",
      "ja": "* Max-ack-Requests（[RFC8724]のセクション8.2.2.4を参照）"
    },
    {
      "indent": 0,
      "text": "4.10.7. Layer 2 Parameters",
      "section_title": true,
      "ja": "4.10.7. レイヤー2パラメーター"
    },
    {
      "indent": 3,
      "text": "The data model includes two parameters needed for fragmentation:",
      "ja": "データモデルには、断片化に必要な2つのパラメーターが含まれています。"
    },
    {
      "indent": 6,
      "text": "* l2-word-size: [RFC8724] base fragmentation, in bits, on a Layer 2 Word that can be of any length. The default value is 8 and corresponds to the default value for the byte-aligned Layer 2. A value of 1 will indicate that there is no alignment and no need for padding.",
      "ja": "* L2ワードサイズ：[RFC8724]ベースの断片化、ビットで、レイヤー2ワードでは、任意の長さである可能性があります。デフォルト値は8で、バイトアリードレイヤー2のデフォルト値に対応します。"
    },
    {
      "indent": 6,
      "text": "* maximum-packet-size: defines the maximum size of an uncompressed datagram. By default, the value is set to 1280 bytes.",
      "ja": "* 最大パケットサイズ：非圧縮データグラムの最大サイズを定義します。デフォルトでは、値は1280バイトに設定されています。"
    },
    {
      "indent": 3,
      "text": "They are defined as unsigned integers; see Section 6.",
      "ja": "それらは、署名されていない整数として定義されています。セクション6を参照してください。"
    },
    {
      "indent": 0,
      "text": "5. Rule Definition",
      "section_title": true,
      "ja": "5. ルール定義"
    },
    {
      "indent": 3,
      "text": "A Rule is identified by a unique Rule Identifier (RuleID) comprising both a RuleID value and a RuleID length. The YANG grouping rule-id-type defines the structure used to represent a RuleID. A length of 0 is allowed to represent an implicit Rule.",
      "ja": "ルールは、RoolID値とRuleID長の両方を含む一意のルール識別子（RoolID）によって識別されます。Yang Grouping Rule-IDタイプは、RuleIDを表すために使用される構造を定義します。0の長さは、暗黙的なルールを表すことができます。"
    },
    {
      "indent": 3,
      "text": "Three natures of Rules are defined in [RFC8724]:",
      "ja": "ルールの3つの性質は[RFC8724]で定義されています。"
    },
    {
      "indent": 6,
      "text": "* Compression: A compression Rule is associated with the RuleID.",
      "ja": "* 圧縮：圧縮ルールはRuleIDに関連付けられています。"
    },
    {
      "indent": 6,
      "text": "* No-compression: This identifies the default Rule used to send a packet integrally when no-compression Rule was found (see Section 6 of [RFC8724]).",
      "ja": "* 非圧縮：これは、圧縮なしのルールが見つかったときにパケットを統合的に送信するために使用されるデフォルトのルールを識別します（[RFC8724]のセクション6を参照）。"
    },
    {
      "indent": 6,
      "text": "* Fragmentation: Fragmentation parameters are associated with the RuleID. Fragmentation is optional, and the feature \"fragmentation\" should be set.",
      "ja": "* 断片化：フラグメンテーションパラメーターは、RuleIDに関連付けられています。断片化はオプションであり、機能「フラグメンテーション」を設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The YANG data model respectively introduces these three identities :",
      "ja": "Yangデータモデルはそれぞれこれらの3つのアイデンティティを紹介します。"
    },
    {
      "indent": 6,
      "text": "* nature-compression",
      "ja": "* 自然圧縮"
    },
    {
      "indent": 6,
      "text": "* nature-no-compression",
      "ja": "* 自然 - 圧縮"
    },
    {
      "indent": 6,
      "text": "* nature-fragmentation",
      "ja": "* 自然燃焼"
    },
    {
      "indent": 3,
      "text": "The naming convention is \"nature-\" followed by the nature identifier.",
      "ja": "命名規則は、「自然」に続いて自然識別子が続きます。"
    },
    {
      "indent": 3,
      "text": "To access a specific Rule, the RuleID length and value are used as a key. The Rule is either a compression or a fragmentation Rule.",
      "ja": "特定のルールにアクセスするために、RuleIDの長さと値がキーとして使用されます。ルールは、圧縮または断片化ルールのいずれかです。"
    },
    {
      "indent": 0,
      "text": "5.1. Compression Rule",
      "section_title": true,
      "ja": "5.1. 圧縮ルール"
    },
    {
      "indent": 3,
      "text": "A compression Rule is composed of entries describing its processing. An entry contains all the information defined in Figure 1 with the types defined above.",
      "ja": "圧縮ルールは、その処理を説明するエントリで構成されています。エントリには、図1に定義されているすべての情報が含まれており、上記のタイプがあります。"
    },
    {
      "indent": 3,
      "text": "The compression Rule described Figure 1 is defined by compression-content. It defines a list of compression-rule-entry, indexed by their Field ID, position, and direction. The compression-rule-entry element represents a line in Figure 1. Their type reflects the identifier types defined in Section 4.1.",
      "ja": "図1の圧縮ルールは、圧縮コンテンツによって定義されます。フィールドID、位置、方向によってインデックス付けされた圧縮ルールエントリのリストを定義します。圧縮ルールエントリ要素は、図1の線を表しています。それらのタイプは、セクション4.1で定義されている識別子タイプを反映しています。"
    },
    {
      "indent": 3,
      "text": "Some checks are performed on the values:",
      "ja": "一部のチェックは、値について実行されます。"
    },
    {
      "indent": 6,
      "text": "* When MO is ignore, no Target Value is needed; for other MOs, there MUST be a Target Value present.",
      "ja": "* MOが無視される場合、ターゲット値は必要ありません。他のMOの場合、ターゲット値が存在する必要があります。"
    },
    {
      "indent": 6,
      "text": "* When MSB MO is specified, the matching-operator-value must be present.",
      "ja": "* MSB MOが指定されている場合、マッチングオペレーター値が存在する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2. Fragmentation Rule",
      "section_title": true,
      "ja": "5.2. 断片化ルール"
    },
    {
      "indent": 3,
      "text": "A fragmentation Rule is composed of entries describing the protocol behavior. Some on them are numerical entries, others are identifiers defined in Section 4.10.",
      "ja": "断片化ルールは、プロトコルの動作を説明するエントリで構成されています。それらのいくつかは数値エントリであり、他のものはセクション4.10で定義されている識別子です。"
    },
    {
      "indent": 0,
      "text": "5.3. YANG Tree",
      "section_title": true,
      "ja": "5.3. ヤンの木"
    },
    {
      "indent": 3,
      "text": "The YANG data model described in this document conforms to the Network Management Datastore Architecture defined in [RFC8342].",
      "ja": "このドキュメントで説明されているYangデータモデルは、[RFC8342]で定義されているネットワーク管理データストアアーキテクチャに準拠しています。"
    },
    {
      "indent": 3,
      "text": "module: ietf-schc\n  +--rw schc\n     +--rw rule* [rule-id-value rule-id-length]\n        +--rw rule-id-value                   uint32\n        +--rw rule-id-length                  uint8\n        +--rw rule-nature                     nature-type\n        +--rw (nature)?\n           +--:(fragmentation) {fragmentation}?\n           |  +--rw fragmentation-mode\n           |  |       schc:fragmentation-mode-type\n           |  +--rw l2-word-size?             uint8\n           |  +--rw direction                 schc:di-type\n           |  +--rw dtag-size?                uint8\n           |  +--rw w-size?                   uint8\n           |  +--rw fcn-size                  uint8\n           |  +--rw rcs-algorithm?            rcs-algorithm-type\n           |  +--rw maximum-packet-size?      uint16\n           |  +--rw window-size?              uint16\n           |  +--rw max-interleaved-frames?   uint8\n           |  +--rw inactivity-timer\n           |  |  +--rw ticks-duration?   uint8\n           |  |  +--rw ticks-numbers?    uint16\n           |  +--rw retransmission-timer\n           |  |  +--rw ticks-duration?   uint8\n           |  |  +--rw ticks-numbers?    uint16\n           |  +--rw max-ack-requests?         uint8\n           |  +--rw (mode)?\n           |     +--:(no-ack)\n           |     +--:(ack-always)\n           |     +--:(ack-on-error)\n           |        +--rw tile-size?          uint8\n           |        +--rw tile-in-all-1?      schc:all-1-data-type\n           |        +--rw ack-behavior?       schc:ack-behavior-type\n           +--:(compression) {compression}?\n              +--rw entry*\n                      [field-id field-position direction-indicator]\n                 +--rw field-id                    schc:fid-type\n                 +--rw field-length                schc:fl-type\n                 +--rw field-position              uint8\n                 +--rw direction-indicator         schc:di-type\n                 +--rw target-value* [index]\n                 |  +--rw index    uint16\n                 |  +--rw value?   binary\n                 +--rw matching-operator           schc:mo-type\n                 +--rw matching-operator-value* [index]\n                 |  +--rw index    uint16\n                 |  +--rw value?   binary\n                 +--rw comp-decomp-action          schc:cda-type\n                 +--rw comp-decomp-action-value* [index]\n                    +--rw index    uint16\n                    +--rw value?   binary",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 5: Overview of the SCHC Data Model",
      "ja": "図5：SCHCデータモデルの概要"
    },
    {
      "indent": 0,
      "text": "6. YANG Data Model",
      "section_title": true,
      "ja": "6. ヤンデータモデル"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS> file \"ietf-schc@2023-03-01.yang\"\nmodule ietf-schc {\n  yang-version 1.1;\n  namespace \"urn:ietf:params:xml:ns:yang:ietf-schc\";\n  prefix schc;\n\n  organization\n    \"IETF IPv6 over Low Power Wide-Area Networks (lpwan) Working\n     Group\";\n  contact\n    \"WG Web:   <https://datatracker.ietf.org/wg/lpwan/about/>\n     WG List:  <mailto:lp-wan@ietf.org>\n     Editor:   Laurent Toutain\n       <mailto:laurent.toutain@imt-atlantique.fr>\n     Editor:   Ana Minaburo\n       <mailto:ana@ackl.io>\";\n  description\n    \"Copyright (c) 2023 IETF Trust and the persons identified as\n     authors of the code.  All rights reserved.\n     Redistribution and use in source and binary forms, with or\n     without modification, is permitted pursuant to, and subject to\n     the license terms contained in, the Revised BSD License set\n     forth in Section 4.c of the IETF Trust's Legal Provisions\n     Relating to IETF Documents\n     (https://trustee.ietf.org/license-info).\n     This version of this YANG module is part of RFC 9363\n     (https://www.rfc-editor.org/info/rfc9363); see the RFC itself\n     for full legal notices.\n     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL\n     NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',\n     'MAY', and 'OPTIONAL' in this document are to be interpreted as\n     described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,\n     they appear in all capitals, as shown here.\n     ***************************************************************\n     Generic data model for the Static Context Header Compression\n     Rule for SCHC, based on RFCs 8724 and 8824.  Including\n     compression, no-compression, and fragmentation Rules.\n\n     This module is a YANG data model for SCHC Rules (RFCs 8724 and\n     8824).  RFC 8724 describes compression Rules in an abstract\n     way through a table.\n |-----------------------------------------------------------------|\n |  (FID)            Rule 1                                        |\n |+-------+--+--+--+------------+-----------------+---------------+|\n ||Field 1|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||\n |+-------+--+--+--+------------+-----------------+---------------+|\n ||Field 2|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||\n |+-------+--+--+--+------------+-----------------+---------------+|\n ||...    |..|..|..|   ...      | ...             | ...           ||\n |+-------+--+--+--+------------+-----------------+---------------+|\n ||Field N|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||\n |+-------+--+--+--+------------+-----------------+---------------+|\n |-----------------------------------------------------------------|\n     This module specifies a global data model that can be used for\n     Rule exchanges or modification.  It specifies both the data\n     model format and the global identifiers used to describe some\n     operations in fields.\n     This data model applies to both compression and fragmentation.\";\n\n  revision 2023-03-01 {\n    description\n      \"Initial version from RFC 9363.\";\n    reference\n      \"RFC 9363 A YANG Data Model for Static Context Header\n                Compression (SCHC)\";\n  }\n\n  feature compression {\n    description\n      \"SCHC compression capabilities are taken into account.\";\n  }\n\n  feature fragmentation {\n    description\n      \"SCHC fragmentation capabilities are taken into account.\";\n  }\n\n  // -------------------------\n  //  Field ID type definition\n  //--------------------------\n  // generic value TV definition\n\n  identity fid-base-type {\n    description\n      \"Field ID base type for all fields.\";\n  }\n\n  identity fid-ipv6-base-type {\n    base fid-base-type;\n    description\n      \"Field ID base type for IPv6 headers described in RFC 8200.\";\n    reference\n      \"RFC 8200 Internet Protocol, Version 6 (IPv6) Specification\";\n  }\n\n  identity fid-ipv6-version {\n    base fid-ipv6-base-type;\n    description\n      \"IPv6 version field.\";\n    reference\n      \"RFC 8200 Internet Protocol, Version 6 (IPv6) Specification\";\n  }\n\n  identity fid-ipv6-trafficclass {\n    base fid-ipv6-base-type;\n    description\n      \"IPv6 Traffic Class field.\";\n    reference\n      \"RFC 8200 Internet Protocol, Version 6 (IPv6) Specification\";\n  }\n\n  identity fid-ipv6-trafficclass-ds {\n    base fid-ipv6-trafficclass;\n    description\n      \"IPv6 Traffic Class field: Diffserv field.\";\n    reference\n      \"RFC 8200 Internet Protocol, Version 6 (IPv6) Specification,\n       RFC 3168 The Addition of Explicit Congestion Notification\n                (ECN) to IP\";\n  }\n\n  identity fid-ipv6-trafficclass-ecn {\n    base fid-ipv6-trafficclass;\n    description\n      \"IPv6 Traffic Class field: ECN field.\";\n    reference\n      \"RFC 8200 Internet Protocol, Version 6 (IPv6) Specification,\n       RFC 3168 The Addition of Explicit Congestion Notification\n                (ECN) to IP\";\n  }\n\n  identity fid-ipv6-flowlabel {\n    base fid-ipv6-base-type;\n    description\n      \"IPv6 Flow Label field.\";\n    reference\n      \"RFC 8200 Internet Protocol, Version 6 (IPv6) Specification\";\n  }\n\n  identity fid-ipv6-payload-length {\n    base fid-ipv6-base-type;\n    description\n      \"IPv6 Payload Length field.\";\n    reference\n      \"RFC 8200 Internet Protocol, Version 6 (IPv6) Specification\";\n  }\n\n  identity fid-ipv6-nextheader {\n    base fid-ipv6-base-type;\n    description\n      \"IPv6 Next Header field.\";\n    reference\n      \"RFC 8200 Internet Protocol, Version 6 (IPv6) Specification\";\n  }\n\n  identity fid-ipv6-hoplimit {\n    base fid-ipv6-base-type;\n    description\n      \"IPv6 Next Header field.\";\n    reference\n      \"RFC 8200 Internet Protocol, Version 6 (IPv6) Specification\";\n  }\n\n  identity fid-ipv6-devprefix {\n    base fid-ipv6-base-type;\n    description\n      \"Corresponds to either the source address or the destination\n       address prefix of RFC 8200 depending on whether it is an\n       uplink or a downlink message.\";\n    reference\n      \"RFC 8200 Internet Protocol, Version 6 (IPv6) Specification\";\n  }\n\n  identity fid-ipv6-deviid {\n    base fid-ipv6-base-type;\n    description\n      \"Corresponds to either the source address or the destination\n       address IID of RFC 8200 depending on whether it is an uplink\n       or a downlink message.\";\n    reference\n      \"RFC 8200 Internet Protocol, Version 6 (IPv6) Specification\";\n  }\n\n  identity fid-ipv6-appprefix {\n    base fid-ipv6-base-type;\n    description\n      \"Corresponds to either the source address or the destination\n       address prefix of RFC 8200 depending on whether it is an\n       uplink or a downlink message.\";\n    reference\n      \"RFC 8200 Internet Protocol, Version 6 (IPv6) Specification\";\n  }\n\n  identity fid-ipv6-appiid {\n    base fid-ipv6-base-type;\n    description\n      \"Corresponds to either the source address or the destination\n       address IID of RFC 8200 depending on whether it is an uplink\n       or a downlink message.\";\n    reference\n      \"RFC 8200 Internet Protocol, Version 6 (IPv6) Specification\";\n  }\n\n  identity fid-udp-base-type {\n    base fid-base-type;\n    description\n      \"Field ID base type for UDP headers described in RFC 768.\";\n    reference\n      \"RFC 768 User Datagram Protocol\";\n  }\n\n  identity fid-udp-dev-port {\n    base fid-udp-base-type;\n    description\n      \"UDP source or destination port, if uplink or downlink\n       communication, respectively.\";\n    reference\n      \"RFC 768 User Datagram Protocol\";\n  }\n\n  identity fid-udp-app-port {\n    base fid-udp-base-type;\n    description\n      \"UDP destination or source port, if uplink or downlink\n       communication, respectively.\";\n    reference\n      \"RFC 768 User Datagram Protocol\";\n  }\n\n  identity fid-udp-length {\n    base fid-udp-base-type;\n    description\n      \"UDP length.\";\n    reference\n      \"RFC 768 User Datagram Protocol\";\n  }\n\n  identity fid-udp-checksum {\n    base fid-udp-base-type;\n    description\n      \"UDP length.\";\n    reference\n      \"RFC 768 User Datagram Protocol\";\n  }\n\n  identity fid-coap-base-type {\n    base fid-base-type;\n    description\n      \"Field ID base type for UDP headers described.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-version {\n    base fid-coap-base-type;\n    description\n      \"CoAP version.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-type {\n    base fid-coap-base-type;\n    description\n      \"CoAP type.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-tkl {\n    base fid-coap-base-type;\n    description\n      \"CoAP token length.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-code {\n    base fid-coap-base-type;\n    description\n      \"CoAP code.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-code-class {\n    base fid-coap-code;\n    description\n      \"CoAP code class.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-code-detail {\n    base fid-coap-code;\n    description\n      \"CoAP code detail.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-mid {\n    base fid-coap-base-type;\n    description\n      \"CoAP message ID.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-token {\n    base fid-coap-base-type;\n    description\n      \"CoAP token.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option {\n    base fid-coap-base-type;\n    description\n      \"Generic CoAP option.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option-if-match {\n    base fid-coap-option;\n    description\n      \"CoAP option If-Match.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option-uri-host {\n    base fid-coap-option;\n    description\n      \"CoAP option Uri-Host.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option-etag {\n    base fid-coap-option;\n    description\n      \"CoAP option ETag.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option-if-none-match {\n    base fid-coap-option;\n    description\n      \"CoAP option if-none-match.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option-observe {\n    base fid-coap-option;\n    description\n      \"CoAP option Observe.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option-uri-port {\n    base fid-coap-option;\n    description\n      \"CoAP option Uri-Port.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option-location-path {\n    base fid-coap-option;\n    description\n      \"CoAP option Location-Path.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option-uri-path {\n    base fid-coap-option;\n    description\n      \"CoAP option Uri-Path.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option-content-format {\n    base fid-coap-option;\n    description\n      \"CoAP option Content Format.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option-max-age {\n    base fid-coap-option;\n    description\n      \"CoAP option Max-Age.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option-uri-query {\n    base fid-coap-option;\n    description\n      \"CoAP option Uri-Query.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option-accept {\n    base fid-coap-option;\n    description\n      \"CoAP option Accept.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option-location-query {\n    base fid-coap-option;\n    description\n      \"CoAP option Location-Query.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option-block2 {\n    base fid-coap-option;\n    description\n      \"CoAP option Block2.\";\n    reference\n      \"RFC 7959 Block-Wise Transfers in the Constrained\n                Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option-block1 {\n    base fid-coap-option;\n    description\n      \"CoAP option Block1.\";\n    reference\n      \"RFC 7959 Block-Wise Transfers in the Constrained\n                Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option-size2 {\n    base fid-coap-option;\n    description\n      \"CoAP option Size2.\";\n    reference\n      \"RFC 7959 Block-Wise Transfers in the Constrained\n                Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option-proxy-uri {\n    base fid-coap-option;\n    description\n      \"CoAP option Proxy-Uri.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option-proxy-scheme {\n    base fid-coap-option;\n    description\n      \"CoAP option Proxy-Scheme.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option-size1 {\n    base fid-coap-option;\n    description\n      \"CoAP option Size1.\";\n    reference\n      \"RFC 7252 The Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option-no-response {\n    base fid-coap-option;\n    description\n      \"CoAP option No response.\";\n    reference\n      \"RFC 7967 Constrained Application Protocol (CoAP)\n                Option for No Server Response\";\n  }\n\n  identity fid-oscore-base-type {\n    base fid-coap-option;\n    description\n      \"OSCORE options (RFC8613) split in suboptions.\";\n    reference\n      \"RFC 8824 Static Context Header Compression (SCHC) for the\n                Constrained Application Protocol (CoAP)\";\n  }\n\n  identity fid-coap-option-oscore-flags {\n    base fid-coap-option;\n    description\n      \"CoAP option OSCORE flags.\";\n    reference\n      \"RFC 8824 Static Context Header Compression (SCHC) for the\n                Constrained Application Protocol (CoAP) (see\n                Section 6.4)\";\n  }\n\n  identity fid-coap-option-oscore-piv {\n    base fid-coap-option;\n    description\n      \"CoAP option OSCORE flags.\";\n    reference\n      \"RFC 8824 Static Context Header Compression (SCHC) for the\n                Constrained Application Protocol (CoAP) (see\n                Section 6.4)\";\n  }\n\n  identity fid-coap-option-oscore-kid {\n    base fid-coap-option;\n    description\n      \"CoAP option OSCORE flags.\";\n    reference\n      \"RFC 8824 Static Context Header Compression (SCHC) for the\n                Constrained Application Protocol (CoAP) (see\n                Section 6.4)\";\n  }\n\n  identity fid-coap-option-oscore-kidctx {\n    base fid-coap-option;\n    description\n      \"CoAP option OSCORE flags.\";\n    reference\n      \"RFC 8824 Static Context Header Compression (SCHC) for the\n                Constrained Application Protocol (CoAP)(see\n                Section 6.4)\";\n  }\n\n  //----------------------------------\n  // Field Length type definition\n  //----------------------------------\n\n  identity fl-base-type {\n    description\n      \"Used to extend Field Length functions.\";\n  }\n\n  identity fl-variable {\n    base fl-base-type;\n    description\n      \"Residue length in bytes is sent as defined for CoAP.\";\n    reference\n      \"RFC 8824 Static Context Header Compression (SCHC) for the\n                Constrained Application Protocol (CoAP) (see\n                Section 5.3)\";\n  }\n\n  identity fl-token-length {\n    base fl-base-type;\n    description\n      \"Residue length in bytes is sent as defined for CoAP.\";\n    reference\n      \"RFC 8824 Static Context Header Compression (SCHC) for the\n                Constrained Application Protocol (CoAP) (see\n                Section 4.5)\";\n  }\n\n  //---------------------------------\n  // Direction Indicator type\n  //---------------------------------\n\n  identity di-base-type {\n    description\n      \"Used to extend Direction Indicators.\";\n  }\n\n  identity di-bidirectional {\n    base di-base-type;\n    description\n      \"Direction Indicator of bidirectionality.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context\n                Header Compression and Fragmentation (see\n                Section 7.1)\";\n  }\n\n  identity di-up {\n    base di-base-type;\n    description\n      \"Direction Indicator of uplink.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context\n                Header Compression and Fragmentation (see\n                Section 7.1)\";\n  }\n\n  identity di-down {\n    base di-base-type;\n    description\n      \"Direction Indicator of downlink.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context\n                Header Compression and Fragmentation (see\n                Section 7.1)\";\n  }\n\n  //----------------------------------\n  // Matching Operator type definition\n  //----------------------------------\n\n  identity mo-base-type {\n    description\n      \"Matching Operator: used in the Rule selection process\n       to check if a Target Value matches the field's value.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context\n                Header Compression and Fragmentation (see\n                Section 7.2)\";\n  }\n\n  identity mo-equal {\n    base mo-base-type;\n    description\n      \"equal MO.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context\n                Header Compression and Fragmentation (see\n                Section 7.3)\";\n  }\n\n  identity mo-ignore {\n    base mo-base-type;\n    description\n      \"ignore MO.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context\n                Header Compression and Fragmentation (see\n                Section 7.3)\";\n  }\n\n  identity mo-msb {\n    base mo-base-type;\n    description\n      \"MSB MO.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context\n                Header Compression and Fragmentation (see\n                Section 7.3)\";\n  }\n\n  identity mo-match-mapping {\n    base mo-base-type;\n    description\n      \"match-mapping MO.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context\n                Header Compression and Fragmentation (see\n                Section 7.3)\";\n  }\n\n  //------------------------------\n  // CDA type definition\n  //------------------------------\n\n  identity cda-base-type {\n    description\n      \"Compression Decompression Actions. Specify the action to\n       be applied to the field's value in a specific Rule.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context\n                Header Compression and Fragmentation (see\n                Section 7.2)\";\n  }\n\n  identity cda-not-sent {\n    base cda-base-type;\n    description\n      \"not-sent CDA.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context\n                Header Compression and Fragmentation (see\n                Section 7.4)\";\n  }\n\n  identity cda-value-sent {\n    base cda-base-type;\n    description\n      \"value-sent CDA.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context\n                Header Compression and Fragmentation (see\n                Section 7.4)\";\n  }\n\n  identity cda-lsb {\n    base cda-base-type;\n    description\n      \"Least Significant Bit (LSB) CDA.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context\n                Header Compression and Fragmentation (see\n                Section 7.4)\";\n  }\n\n  identity cda-mapping-sent {\n    base cda-base-type;\n    description\n      \"mapping-sent CDA.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context\n                Header Compression and Fragmentation (see\n                Section 7.4)\";\n  }\n\n  identity cda-compute {\n    base cda-base-type;\n    description\n      \"compute-* CDA.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context\n                Header Compression and Fragmentation (see\n                Section 7.4)\";\n  }\n\n  identity cda-deviid {\n    base cda-base-type;\n    description\n      \"DevIID CDA.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context\n                Header Compression and Fragmentation (see\n                Section 7.4)\";\n  }\n\n  identity cda-appiid {\n    base cda-base-type;\n    description\n      \"Application Interface Identifier (AppIID) CDA.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context\n                Header Compression and Fragmentation (see\n                Section 7.4)\";\n  }\n\n  // -- type definition\n\n  typedef fid-type {\n    type identityref {\n      base fid-base-type;\n    }\n    description\n      \"Field ID generic type.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation\";\n  }\n\n  typedef fl-type {\n    type identityref {\n      base fl-base-type;\n    }\n    description\n      \"Function used to indicate Field Length.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation\";\n  }\n\n  typedef di-type {\n    type identityref {\n      base di-base-type;\n    }\n    description\n      \"Direction in LPWAN network: up when emitted by the device,\n       down when received by the device, or bi when emitted or\n       received by the device.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation\";\n  }\n\n  typedef mo-type {\n    type identityref {\n      base mo-base-type;\n    }\n    description\n      \"Matching Operator (MO) to compare field values with\n       Target Values.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation\";\n  }\n\n  typedef cda-type {\n    type identityref {\n      base cda-base-type;\n    }\n    description\n      \"Compression Decompression Action to compress or\n       decompress a field.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation\";\n  }\n\n  // -- FRAGMENTATION TYPE\n  // -- fragmentation modes\n\n  identity fragmentation-mode-base-type {\n    description\n      \"Define the fragmentation mode.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation\";\n  }\n\n  identity fragmentation-mode-no-ack {\n    base fragmentation-mode-base-type;\n    description\n      \"No-ACK mode.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation\";\n  }\n\n  identity fragmentation-mode-ack-always {\n    base fragmentation-mode-base-type;\n    description\n      \"ACK-Always mode.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation\";\n  }\n\n  identity fragmentation-mode-ack-on-error {\n    base fragmentation-mode-base-type;\n    description\n      \"ACK-on-Error mode.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation\";\n  }\n\n  typedef fragmentation-mode-type {\n    type identityref {\n      base fragmentation-mode-base-type;\n    }\n    description\n      \"Define the type used for fragmentation mode in Rules.\";\n  }\n\n  // -- Ack behavior\n\n  identity ack-behavior-base-type {\n    description\n      \"Define when to send an Acknowledgment.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation\";\n  }\n\n  identity ack-behavior-after-all-0 {\n    base ack-behavior-base-type;\n    description\n      \"Fragmentation expects ACK after sending All-0 fragment.\";\n  }\n\n  identity ack-behavior-after-all-1 {\n    base ack-behavior-base-type;\n    description\n      \"Fragmentation expects ACK after sending All-1 fragment.\";\n  }\n\n  identity ack-behavior-by-layer2 {\n    base ack-behavior-base-type;\n    description\n      \"Layer 2 defines when to send an ACK.\";\n  }\n\n  typedef ack-behavior-type {\n    type identityref {\n      base ack-behavior-base-type;\n    }\n    description\n      \"Define the type used for ACK behavior in Rules.\";\n  }\n\n  // -- All-1 with data types\n\n  identity all-1-data-base-type {\n    description\n      \"Type to define when to send an Acknowledgment message.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation\";\n  }\n\n  identity all-1-data-no {\n    base all-1-data-base-type;\n    description\n      \"All-1 contains no tiles.\";\n  }\n\n  identity all-1-data-yes {\n    base all-1-data-base-type;\n    description\n      \"All-1 MUST contain a tile.\";\n  }\n\n  identity all-1-data-sender-choice {\n    base all-1-data-base-type;\n    description\n      \"Fragmentation process chooses to send tiles or not in All-1.\";\n  }\n\n  typedef all-1-data-type {\n    type identityref {\n      base all-1-data-base-type;\n    }\n    description\n      \"Define the type used for All-1 format in Rules.\";\n  }\n\n  // -- RCS algorithm types\n\n  identity rcs-algorithm-base-type {\n    description\n      \"Identify which algorithm is used to compute RCS.\n       The algorithm also defines the size of the RCS field.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation\";\n  }\n\n  identity rcs-crc32 {\n    base rcs-algorithm-base-type;\n    description\n      \"CRC32 defined as default RCS in RFC 8724.  This RCS is\n       4 bytes long.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation\";\n  }\n\n  typedef rcs-algorithm-type {\n    type identityref {\n      base rcs-algorithm-base-type;\n    }\n    description\n      \"Define the type for RCS algorithm in Rules.\";\n  }\n\n  // --------  RULE ENTRY DEFINITION ------------\n\n  grouping tv-struct {\n    description\n      \"Defines the Target Value element.  If the header field\n       contains a text, the binary sequence uses the same encoding.\n       field-id allows the conversion to the appropriate type.\";\n    leaf index {\n      type uint16;\n      description\n        \"Index gives the position in the matching list.  If only one\n         element is present, index is 0.  Otherwise, index is the\n         order in the matching list, starting at 0.\";\n    }\n    leaf value {\n      type binary;\n      description\n        \"Target Value content as an untyped binary value.\";\n    }\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation\";\n  }\n\n  grouping compression-rule-entry {\n    description\n      \"These entries define a compression entry (i.e., a line),\n       as defined in RFC 8724.\n   +-------+--+--+--+------------+-----------------+---------------+\n   |Field 1|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act|\n   +-------+--+--+--+------------+-----------------+---------------+\n       An entry in a compression Rule is composed of 7 elements:\n       - Field ID: the header field to be compressed\n       - Field Length : either a positive integer or a function\n       - Field Position: a positive (and possibly equal to 0)\n         integer\n       - Direction Indicator: an indication in which direction the\n         compression and decompression process is effective\n       - Target Value: a value against which the header field is\n         compared\n       - Matching Operator: the comparison operation and optional\n         associate parameters\n       - Comp./Decomp. Action: the compression or decompression\n         action and optional parameters\n      \";\n    leaf field-id {\n      type schc:fid-type;\n      mandatory true;\n      description\n        \"Field ID, identify a field in the header with a YANG\n         identity reference.\";\n    }\n    leaf field-length {\n      type union {\n      type uint8;\n      type schc:fl-type;\n        }\n      mandatory true;\n      description\n        \"Field Length, expressed in number of bits if the length is\n         known when the Rule is created or through a specific\n         function if the length is variable.\";\n    }\n    leaf field-position {\n      type uint8;\n      mandatory true;\n      description\n        \"Field Position in the header is an integer.  Position 1\n         matches the first occurrence of a field in the header,\n         while incremented position values match subsequent\n         occurrences.\n         Position 0 means that this entry matches a field\n         irrespective of its position of occurrence in the\n         header.\n         Be aware that the decompressed header may have\n         position-0 fields ordered differently than they\n         appeared in the original packet.\";\n    }\n    leaf direction-indicator {\n      type schc:di-type;\n      mandatory true;\n      description\n        \"Direction Indicator, indicate if this field must be\n         considered for Rule selection or ignored based on the\n         direction (bidirectional, only uplink, or only\n         downlink).\";\n    }\n    list target-value {\n      key \"index\";\n      uses tv-struct;\n      description\n        \"A list of values to compare with the header field value.\n         If Target Value is a singleton, position must be 0.\n         For use as a matching list for the mo-match-mapping Matching\n         Operator, index should take consecutive values starting\n         from 0.\";\n    }\n    leaf matching-operator {\n      type schc:mo-type;\n      must \"../target-value or derived-from-or-self(.,\n                                                   'mo-ignore')\" {\n        error-message\n          \"mo-equal, mo-msb, and mo-match-mapping need target-value\";\n        description\n          \"target-value is not required for mo-ignore.\";\n      }\n      must \"not (derived-from-or-self(., 'mo-msb')) or\n            ../matching-operator-value\" {\n        error-message \"mo-msb requires length value\";\n      }\n      mandatory true;\n      description\n        \"MO: Matching Operator.\";\n      reference\n        \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                  Compression and Fragmentation (see Section 7.3)\";\n    }\n    list matching-operator-value {\n      key \"index\";\n      uses tv-struct;\n      description\n        \"Matching Operator Arguments, based on TV structure to allow\n         several arguments.\n         In RFC 8724, only the MSB Matching Operator needs arguments\n         (a single argument, which is the number of most significant\n         bits to be matched).\";\n    }\n    leaf comp-decomp-action {\n      type schc:cda-type;\n      must \"../target-value or\n                derived-from-or-self(., 'cda-value-sent') or\n                derived-from-or-self(., 'cda-compute') or\n                derived-from-or-self(., 'cda-appiid') or\n                derived-from-or-self(., 'cda-deviid')\" {\n        error-message\n          \"cda-not-sent, cda-lsb, and cda-mapping-sent need\n           target-value\";\n        description\n          \"target-value is not required for some CDA.\";\n      }\n      mandatory true;\n      description\n        \"CDA: Compression Decompression Action.\";\n      reference\n        \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                  Compression and Fragmentation (see Section 7.4)\";\n    }\n    list comp-decomp-action-value {\n      key \"index\";\n      uses tv-struct;\n      description\n        \"CDA arguments, based on a TV structure, in order to allow\n         for several arguments.  The CDAs specified in RFC 8724\n         require no argument.\";\n    }\n  }\n\n  // --Rule nature\n\n  identity nature-base-type {\n    description\n      \"A Rule, identified by its RuleID, is used for a single\n       purpose.  RFC 8724 defines 3 natures:\n       compression, no-compression, and fragmentation.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation (see Section 6)\";\n  }\n\n  identity nature-compression {\n    base nature-base-type;\n    description\n      \"Identify a compression Rule.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation (see Section 6)\";\n  }\n\n  identity nature-no-compression {\n    base nature-base-type;\n    description\n      \"Identify a no-compression Rule.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation (see Section 6)\";\n  }\n\n  identity nature-fragmentation {\n    base nature-base-type;\n    description\n      \"Identify a fragmentation Rule.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation (see Section 6)\";\n  }\n\n  typedef nature-type {\n    type identityref {\n      base nature-base-type;\n    }\n    description\n      \"Defines the type to indicate the nature of the Rule.\";\n  }\n\n  grouping compression-content {\n    list entry {\n      must \"derived-from-or-self(../rule-nature,\n                                        'nature-compression')\" {\n        error-message \"Rule nature must be compression\";\n      }\n      key \"field-id field-position direction-indicator\";\n      uses compression-rule-entry;\n      description\n        \"A compression Rule is a list of Rule entries, each\n         describing a header field.  An entry is identified\n         through a field-id, its position in the packet, and\n         its direction.\";\n    }\n    description\n      \"Define a compression Rule composed of a list of entries.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation\";\n  }\n\n  grouping fragmentation-content {\n    description\n      \"This grouping defines the fragmentation parameters for\n       all the modes (No ACK, ACK Always, and ACK on Error) specified\n       in RFC 8724.\";\n    leaf fragmentation-mode {\n      type schc:fragmentation-mode-type;\n      must \"derived-from-or-self(../rule-nature,\n                                        'nature-fragmentation')\" {\n        error-message \"Rule nature must be fragmentation\";\n      }\n      mandatory true;\n      description\n        \"Which fragmentation mode is used (No ACK, ACK Always, or\n         ACK on Error).\";\n    }\n    leaf l2-word-size {\n      type uint8;\n      default \"8\";\n      description\n        \"Size, in bits, of the Layer 2 Word.\";\n    }\n    leaf direction {\n      type schc:di-type;\n      must \"derived-from-or-self(., 'di-up') or\n            derived-from-or-self(., 'di-down')\" {\n        error-message\n          \"Direction for fragmentation Rules are up or down.\";\n      }\n      mandatory true;\n      description\n        \"MUST be up or down, bidirectional MUST NOT be used.\";\n    }\n    // SCHC Frag header format\n    leaf dtag-size {\n      type uint8;\n      default \"0\";\n      description\n        \"Size, in bits, of the DTag field (T variable from\n         RFC 8724).\";\n    }\n    leaf w-size {\n      when \"derived-from-or-self(../fragmentation-mode,\n                                'fragmentation-mode-ack-on-error')\n            or\n            derived-from-or-self(../fragmentation-mode,\n                                'fragmentation-mode-ack-always') \";\n      type uint8;\n      description\n        \"Size, in bits, of the window field (M variable from\n         RFC 8724).\";\n    }\n    leaf fcn-size {\n      type uint8;\n      mandatory true;\n      description\n        \"Size, in bits, of the FCN field (N variable from\n         RFC 8724).\";\n    }\n    leaf rcs-algorithm {\n      type rcs-algorithm-type;\n      default \"schc:rcs-crc32\";\n      description\n        \"Algorithm used for RCS.  The algorithm specifies the RCS\n         size.\";\n    }\n    // SCHC fragmentation protocol parameters\n    leaf maximum-packet-size {\n      type uint16;\n      default \"1280\";\n      description\n        \"When decompression is done, packet size must not\n         strictly exceed this limit, expressed in bytes.\";\n    }\n    leaf window-size {\n      type uint16;\n      description\n        \"By default, if not specified, the FCN value is 2^w-size - 1.\n         This value should not be exceeded.  Possible FCN values\n         are between 0 and window-size - 1.\";\n    }\n    leaf max-interleaved-frames {\n      type uint8;\n      default \"1\";\n      description\n        \"Maximum of simultaneously fragmented frames.  Maximum value\n         is 2^dtag-size.  All DTag values can be used, but more than\n         max-interleaved-frames MUST NOT be active at any time.\";\n    }\n    container inactivity-timer {\n      leaf ticks-duration {\n        type uint8;\n        default \"20\";\n        description\n          \"Duration of one tick in microseconds:\n              2^ticks-duration/10^6 = 1.048s.\";\n      }\n      leaf ticks-numbers {\n        type uint16 {\n          range \"0..max\";\n        }\n        description\n          \"Timer duration = ticks-numbers*2^ticks-duration / 10^6.\";\n      }\n\n      description\n        \"Duration in seconds of the Inactivity Timer; 0 indicates\n         that the timer is disabled.\n\n         Allows a precision from microsecond to year by sending the\n         tick-duration value. For instance:\n\n        tick-duration: smallest value   <-> highest value\n\n        20: 00y 000d 00h 00m 01s.048575<->00y 000d 19h 05m 18s.428159\n        21: 00y 000d 00h 00m 02s.097151<->00y 001d 14h 10m 36s.856319\n        22: 00y 000d 00h 00m 04s.194303<->00y 003d 04h 21m 13s.712639\n        23: 00y 000d 00h 00m 08s.388607<->00y 006d 08h 42m 27s.425279\n        24: 00y 000d 00h 00m 16s.777215<->00y 012d 17h 24m 54s.850559\n        25: 00y 000d 00h 00m 33s.554431<->00y 025d 10h 49m 49s.701119\n\n         Note that the smallest value is also the incrementation\n         step.\";\n    }\n    container retransmission-timer {\n      leaf ticks-duration {\n        type uint8;\n        default \"20\";\n        description\n          \"Duration of one tick in microseconds:\n              2^ticks-duration/10^6 = 1.048s.\";\n      }\n      leaf ticks-numbers {\n        type uint16 {\n          range \"1..max\";\n        }\n        description\n          \"Timer duration = ticks-numbers*2^ticks-duration / 10^6.\";\n      }\n      when \"derived-from-or-self(../fragmentation-mode,\n                                'fragmentation-mode-ack-on-error')\n            or\n            derived-from-or-self(../fragmentation-mode,\n                                'fragmentation-mode-ack-always') \";\n      description\n        \"Duration in seconds of the Retransmission Timer.\n         See the Inactivity Timer.\";\n    }\n    leaf max-ack-requests {\n      when \"derived-from-or-self(../fragmentation-mode,\n                                'fragmentation-mode-ack-on-error')\n            or\n            derived-from-or-self(../fragmentation-mode,\n                                'fragmentation-mode-ack-always') \";\n      type uint8 {\n        range \"1..max\";\n      }\n      description\n        \"The maximum number of retries for a specific SCHC ACK.\";\n    }\n    choice mode {\n      case no-ack;\n      case ack-always;\n      case ack-on-error {\n        leaf tile-size {\n          when \"derived-from-or-self(../fragmentation-mode,\n                             'fragmentation-mode-ack-on-error')\";\n          type uint8;\n          description\n            \"Size, in bits, of tiles.  If not specified or set to 0,\n             tiles fill the fragment.\";\n        }\n        leaf tile-in-all-1 {\n          when \"derived-from-or-self(../fragmentation-mode,\n                             'fragmentation-mode-ack-on-error')\";\n          type schc:all-1-data-type;\n          description\n            \"Defines whether the sender and receiver expect a tile in\n             All-1 fragments or not, or if it is left to the sender's\n             choice.\";\n        }\n        leaf ack-behavior {\n          when \"derived-from-or-self(../fragmentation-mode,\n                             'fragmentation-mode-ack-on-error')\";\n          type schc:ack-behavior-type;\n          description\n            \"Sender behavior to acknowledge, after All-0 or All-1 or\n             when the LPWAN allows it.\";\n        }\n      }\n      description\n        \"RFC 8724 defines 3 fragmentation modes.\";\n    }\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation\";\n  }\n\n  // Define RuleID.  RuleID is composed of a RuleID value and a\n  // RuleID length\n\n  grouping rule-id-type {\n    leaf rule-id-value {\n      type uint32;\n      description\n        \"RuleID value.  This value must be unique, considering its\n         length.\";\n    }\n    leaf rule-id-length {\n      type uint8 {\n        range \"0..32\";\n      }\n      description\n        \"RuleID length, in bits.  The value 0 is for implicit\n         Rules.\";\n    }\n    description\n      \"A RuleID is composed of a value and a length, expressed in\n       bits.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation\";\n  }\n\n  // SCHC table for a specific device.\n\n  container schc {\n    list rule {\n      key \"rule-id-value rule-id-length\";\n      uses rule-id-type;\n      leaf rule-nature {\n        type nature-type;\n        mandatory true;\n        description\n          \"Specify the Rule's nature.\";\n      }\n      choice nature {\n        case fragmentation {\n          if-feature \"fragmentation\";\n          uses fragmentation-content;\n        }\n        case compression {\n          if-feature \"compression\";\n          uses compression-content;\n        }\n        description\n          \"A Rule is for compression, for no-compression, or for\n           fragmentation.\";\n      }\n      description\n        \"Set of compression, no-compression, or fragmentation\n         Rules identified by their rule-id.\";\n    }\n    description\n      \"A SCHC set of Rules is composed of a list of Rules that are\n       used for compression, no-compression, or fragmentation.\";\n    reference\n      \"RFC 8724 SCHC: Generic Framework for Static Context Header\n                Compression and Fragmentation\";\n  }\n}\n<CODE ENDS>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Figure 6: SCHC YANG Data Model",
      "ja": "図6：Schc Yangデータモデル"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document registers one URI and one YANG data model.",
      "ja": "このドキュメントは、1つのURIと1つのYangデータモデルを登録します。"
    },
    {
      "indent": 0,
      "text": "7.1. URI Registration",
      "section_title": true,
      "ja": "7.1. URI登録"
    },
    {
      "indent": 3,
      "text": "IANA registered the following URI in the \"IETF XML Registry\" [RFC3688]:",
      "ja": "IANAは、「IETF XMLレジストリ」[RFC3688]に次のURIを登録しました。"
    },
    {
      "indent": 3,
      "text": "URI:",
      "ja": "URI："
    },
    {
      "indent": 12,
      "text": "urn:ietf:params:xml:ns:yang:ietf-schc",
      "ja": "urn：ietf：params：xml：ns：yang：ietf-schc"
    },
    {
      "indent": 3,
      "text": "Registrant Contact:",
      "ja": "登録者の連絡先："
    },
    {
      "indent": 12,
      "text": "The IESG.",
      "ja": "IESG。"
    },
    {
      "indent": 3,
      "text": "XML:",
      "ja": "XML："
    },
    {
      "indent": 12,
      "text": "N/A; the requested URI is an XML namespace.",
      "ja": "n/a;要求されたURIはXMLネームスペースです。"
    },
    {
      "indent": 0,
      "text": "7.2. YANG Module Name Registration",
      "section_title": true,
      "ja": "7.2. Yangモジュール名登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following YANG data model in the \"YANG Module Names\" registry [RFC6020].",
      "ja": "IANAは、「Yangモジュール名」レジストリ[RFC6020]に次のYangデータモデルを登録しています。"
    },
    {
      "indent": 3,
      "text": "name:",
      "ja": "名前："
    },
    {
      "indent": 12,
      "text": "ietf-schc",
      "ja": "IETF-SCHC"
    },
    {
      "indent": 3,
      "text": "namespace:",
      "ja": "名前空間："
    },
    {
      "indent": 12,
      "text": "urn:ietf:params:xml:ns:yang:ietf-schc",
      "ja": "urn：ietf：params：xml：ns：yang：ietf-schc"
    },
    {
      "indent": 3,
      "text": "prefix:",
      "ja": "プレフィックス："
    },
    {
      "indent": 12,
      "text": "schc",
      "ja": "Schc"
    },
    {
      "indent": 3,
      "text": "reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "RFC 9363",
      "ja": "RFC 9363"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The YANG module specified in this document defines a schema for data that is designed to be accessed via network management protocols such as NETCONF [RFC6241] or RESTCONF [RFC8040]. The lowest NETCONF layer is the secure transport layer, and the mandatory-to-implement secure transport is Secure Shell (SSH) [RFC6242]. The lowest RESTCONF layer is HTTPS, and the mandatory-to-implement secure transport is TLS [RFC8446].",
      "ja": "このドキュメントで指定されたYangモジュールは、NetConf [RFC6241]やRestConf [RFC8040]などのネットワーク管理プロトコルを介してアクセスするように設計されたデータのスキーマを定義しています。最低のネットコン層は安全な輸送層であり、実装から実装の安全な輸送は安全なシェル（SSH）[RFC6242]です。最も低いRESTCONF層はHTTPSであり、実装対象の安全な輸送はTLS [RFC8446]です。"
    },
    {
      "indent": 3,
      "text": "The Network Configuration Access Control Model (NACM) [RFC8341] provides the means to restrict access for particular NETCONF or RESTCONF users to a preconfigured subset of all available NETCONF or RESTCONF protocol operations and content.",
      "ja": "ネットワーク構成アクセス制御モデル（NACM）[RFC8341]は、利用可能なすべてのNetConfまたはRestConfプロトコル操作とコンテンツの事前に設定されたサブセットに特定のNetConfまたはRestConfユーザーのアクセスを制限する手段を提供します。"
    },
    {
      "indent": 3,
      "text": "There are a number of data nodes defined in this YANG module that are writable/creatable/deletable (i.e., config true, which is the default). These data nodes may be considered sensitive or vulnerable in some network environments. Write operations (e.g., edit-config) to these data nodes without proper protection can have a negative effect on network operations. These are the subtrees and data nodes and their sensitivity/vulnerability:",
      "ja": "このYangモジュールには、書き込み可能/クリエーション/削除可能な（つまり、デフォルトである構成真実）と定義されている多くのデータノードがあります。これらのデータノードは、一部のネットワーク環境で敏感または脆弱と見なされる場合があります。適切な保護なしにこれらのデータノードに操作を書き込む（例：編集config）は、ネットワーク操作に悪影響を与える可能性があります。これらは、サブツリーとデータノードとその感度/脆弱性です。"
    },
    {
      "indent": 3,
      "text": "/schc:",
      "ja": "/SCHC："
    },
    {
      "indent": 12,
      "text": "All the data nodes may be modified. The Rule contains sensitive information, such as the application IPv6 address where the device's data will be sent after decompression. An attacker may try to modify other devices' Rules by changing the application address and may block communication or allows traffic eavesdropping. Therefore, a device must be allowed to modify only its own rules on the remote SCHC instance. The identity of the requester must be validated. This can be done through certificates or access lists. Modification may be allowed regarding the Field Descriptor (i.e., IPv6 addresses field descriptors should not be modified, but UDP dev port could be changed).",
      "ja": "すべてのデータノードが変更される場合があります。ルールには、デバイスのデータが減圧後に送信されるアプリケーションIPv6アドレスなどの機密情報が含まれています。攻撃者は、アプリケーションアドレスを変更して他のデバイスのルールを変更しようとする場合があり、通信をブロックしたり、トラフィックを盗聴したりすることがあります。したがって、デバイスは、リモートSCHCインスタンスに関する独自のルールのみを変更することを許可する必要があります。要求者の身元を検証する必要があります。これは、証明書またはアクセスリストを介して実行できます。フィールド記述子に関して変更が許可される場合があります（つまり、IPv6アドレスフィールド記述子を変更してはなりませんが、UDP開発ポートを変更できます）。"
    },
    {
      "indent": 3,
      "text": "Some of the readable data nodes in this YANG module may be considered sensitive or vulnerable in some network environments. It is thus important to control read access (e.g., via get, get-config, or notification) to these data nodes. These are the subtrees and data nodes and their sensitivity/vulnerability:",
      "ja": "このYangモジュールの読み取り可能なデータノードの一部は、一部のネットワーク環境で敏感または脆弱と見なされる場合があります。したがって、これらのデータノードへの読み取りアクセス（GET、GetConfig、または通知を介して）を制御することが重要です。これらは、サブツリーとデータノードとその感度/脆弱性です。"
    },
    {
      "indent": 3,
      "text": "/schc:",
      "ja": "/SCHC："
    },
    {
      "indent": 12,
      "text": "By reading a module, an attacker may learn the traffic generated by a device and can also learn about application addresses or REST API.",
      "ja": "モジュールを読み取ることにより、攻撃者はデバイスによって生成されたトラフィックを学習することができ、アプリケーションアドレスやREST APIについても学習できます。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9. 参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC0768]  Postel, J., \"User Datagram Protocol\", STD 6, RFC 768,\n           DOI 10.17487/RFC0768, August 1980,\n           <https://www.rfc-editor.org/info/rfc768>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC3688]  Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688,\n           DOI 10.17487/RFC3688, January 2004,\n           <https://www.rfc-editor.org/info/rfc3688>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6020]  Bjorklund, M., Ed., \"YANG - A Data Modeling Language for\n           the Network Configuration Protocol (NETCONF)\", RFC 6020,\n           DOI 10.17487/RFC6020, October 2010,\n           <https://www.rfc-editor.org/info/rfc6020>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6241]  Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed.,\n           and A. Bierman, Ed., \"Network Configuration Protocol\n           (NETCONF)\", RFC 6241, DOI 10.17487/RFC6241, June 2011,\n           <https://www.rfc-editor.org/info/rfc6241>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6242]  Wasserman, M., \"Using the NETCONF Protocol over Secure\n           Shell (SSH)\", RFC 6242, DOI 10.17487/RFC6242, June 2011,\n           <https://www.rfc-editor.org/info/rfc6242>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7136]  Carpenter, B. and S. Jiang, \"Significance of IPv6\n           Interface Identifiers\", RFC 7136, DOI 10.17487/RFC7136,\n           February 2014, <https://www.rfc-editor.org/info/rfc7136>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7252]  Shelby, Z., Hartke, K., and C. Bormann, \"The Constrained\n           Application Protocol (CoAP)\", RFC 7252,\n           DOI 10.17487/RFC7252, June 2014,\n           <https://www.rfc-editor.org/info/rfc7252>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8040]  Bierman, A., Bjorklund, M., and K. Watsen, \"RESTCONF\n           Protocol\", RFC 8040, DOI 10.17487/RFC8040, January 2017,\n           <https://www.rfc-editor.org/info/rfc8040>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8200]  Deering, S. and R. Hinden, \"Internet Protocol, Version 6\n           (IPv6) Specification\", STD 86, RFC 8200,\n           DOI 10.17487/RFC8200, July 2017,\n           <https://www.rfc-editor.org/info/rfc8200>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8341]  Bierman, A. and M. Bjorklund, \"Network Configuration\n           Access Control Model\", STD 91, RFC 8341,\n           DOI 10.17487/RFC8341, March 2018,\n           <https://www.rfc-editor.org/info/rfc8341>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8342]  Bjorklund, M., Schoenwaelder, J., Shafer, P., Watsen, K.,\n           and R. Wilton, \"Network Management Datastore Architecture\n           (NMDA)\", RFC 8342, DOI 10.17487/RFC8342, March 2018,\n           <https://www.rfc-editor.org/info/rfc8342>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8446]  Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n           Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n           <https://www.rfc-editor.org/info/rfc8446>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8613]  Selander, G., Mattsson, J., Palombini, F., and L. Seitz,\n           \"Object Security for Constrained RESTful Environments\n           (OSCORE)\", RFC 8613, DOI 10.17487/RFC8613, July 2019,\n           <https://www.rfc-editor.org/info/rfc8613>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8724]  Minaburo, A., Toutain, L., Gomez, C., Barthel, D., and JC.\n           Zuniga, \"SCHC: Generic Framework for Static Context Header\n           Compression and Fragmentation\", RFC 8724,\n           DOI 10.17487/RFC8724, April 2020,\n           <https://www.rfc-editor.org/info/rfc8724>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8824]  Minaburo, A., Toutain, L., and R. Andreasen, \"Static\n           Context Header Compression (SCHC) for the Constrained\n           Application Protocol (CoAP)\", RFC 8824,\n           DOI 10.17487/RFC8824, June 2021,\n           <https://www.rfc-editor.org/info/rfc8824>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[LPWAN-ARCH]\n           Pelov, A., Thubert, P., and A. Minaburo, \"LPWAN Static\n           Context Header Compression (SCHC) Architecture\", Work in\n           Progress, Internet-Draft, draft-ietf-lpwan-architecture-\n           02, 30 June 2022, <https://datatracker.ietf.org/doc/html/\n           draft-ietf-lpwan-architecture-02>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7950]  Bjorklund, M., Ed., \"The YANG 1.1 Data Modeling Language\",\n           RFC 7950, DOI 10.17487/RFC7950, August 2016,\n           <https://www.rfc-editor.org/info/rfc7950>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7967]  Bhattacharyya, A., Bandyopadhyay, S., Pal, A., and T.\n           Bose, \"Constrained Application Protocol (CoAP) Option for\n           No Server Response\", RFC 7967, DOI 10.17487/RFC7967,\n           August 2016, <https://www.rfc-editor.org/info/rfc7967>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8376]  Farrell, S., Ed., \"Low-Power Wide Area Network (LPWAN)\n           Overview\", RFC 8376, DOI 10.17487/RFC8376, May 2018,\n           <https://www.rfc-editor.org/info/rfc8376>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9011]  Gimenez, O., Ed. and I. Petrov, Ed., \"Static Context\n           Header Compression and Fragmentation (SCHC) over LoRaWAN\",\n           RFC 9011, DOI 10.17487/RFC9011, April 2021,\n           <https://www.rfc-editor.org/info/rfc9011>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix A. Example",
      "section_title": true,
      "ja": "付録A. 例"
    },
    {
      "indent": 3,
      "text": "The informal Rules given Figure 7 are represented in XML, as shown in Figure 8.",
      "ja": "図7に示す非公式のルールは、図8に示すようにXMLで表されています。"
    },
    {
      "indent": 3,
      "text": "/-------------------------\\\n|Rule 6/3            110  |\n|---------------+---+--+--+----------------+-------+----------------\\\n|IPV6.VER       |  4| 1|BI|               6|EQUAL  |NOT-SENT        |\n|IPV6.TC        |  8| 1|BI|               0|EQUAL  |NOT-SENT        |\n|IPV6.FL        | 20| 1|BI|               0|IGNORE |NOT-SENT        |\n|IPV6.LEN       | 16| 1|BI|                |IGNORE |COMPUTE-LENGTH  |\n|IPV6.NXT       |  8| 1|BI|              58|EQUAL  |NOT-SENT        |\n|IPV6.HOP_LMT   |  8| 1|BI|             255|IGNORE |NOT-SENT        |\n|IPV6.DEV_PREFIX| 64| 1|BI|200104701f2101d2|EQUAL  |NOT-SENT        |\n|IPV6.DEV_IID   | 64| 1|BI|0000000000000003|EQUAL  |NOT-SENT        |\n|IPV6.APP_PREFIX| 64| 1|BI|                |IGNORE |VALUE-SENT      |\n|IPV6.APP_IID   | 64| 1|BI|                |IGNORE |VALUE-SENT      |\n\\---------------+---+--+--+----------------+-------+----------------/\n/-------------------------\\\n|Rule 12/11     00001100  |\n!=========================+=========================================\\\n!^ Fragmentation mode : NoAck   header dtag 2 Window  0 FCN  3  UP ^!\n!^ No Tile size specified                                          ^!\n!^ RCS Algorithm: RCS_CRC32                                        ^!\n\\===================================================================/\n/-------------------------\\\n|Rule 100/8     01100100  |\n| NO-COMPRESSION RULE     |\n\\-------------------------/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 26,
      "text": "Figure 7: Rules Example",
      "ja": "図7：ルールの例"
    },
    {
      "indent": 3,
      "text": "<?xml version='1.0' encoding='UTF-8'?>\n  <schc xmlns=\"urn:ietf:params:xml:ns:yang:ietf-schc\">\n  <rule>\n    <rule-id-value>6</rule-id-value>\n    <rule-id-length>3</rule-id-length>\n    <rule-nature>nature-compression</rule-nature>\n    <entry>\n      <field-id>fid-ipv6-version</field-id>\n      <field-length>4</field-length>\n      <field-position>1</field-position>\n      <direction-indicator>di-bidirectional</direction-indicator>\n      <matching-operator>mo-equal</matching-operator>\n      <comp-decomp-action>cda-not-sent</comp-decomp-action>\n      <target-value>\n        <index>0</index>\n        <value>AAY=</value>\n      </target-value>\n    </entry>\n    <entry>\n      <field-id>fid-ipv6-trafficclass</field-id>\n      <field-length>8</field-length>\n      <field-position>1</field-position>\n      <direction-indicator>di-bidirectional</direction-indicator>\n      <matching-operator>mo-equal</matching-operator>\n      <comp-decomp-action>cda-not-sent</comp-decomp-action>\n      <target-value>\n        <index>0</index>\n        <value>AA==</value>\n      </target-value>\n    </entry>\n    <entry>\n      <field-id>fid-ipv6-flowlabel</field-id>\n      <field-length>20</field-length>\n      <field-position>1</field-position>\n      <direction-indicator>di-bidirectional</direction-indicator>\n      <matching-operator>mo-ignore</matching-operator>\n      <comp-decomp-action>cda-not-sent</comp-decomp-action>\n      <target-value>\n        <index>0</index>\n        <value>AA==</value>\n      </target-value>\n    </entry>\n    <entry>\n      <field-id>fid-ipv6-payload-length</field-id>\n      <field-length>16</field-length>\n      <field-position>1</field-position>\n      <direction-indicator>di-bidirectional</direction-indicator>\n      <matching-operator>mo-ignore</matching-operator>\n      <comp-decomp-action>cda-compute</comp-decomp-action>\n    </entry>\n    <entry>\n      <field-id>fid-ipv6-nextheader</field-id>\n      <field-length>8</field-length>\n      <field-position>1</field-position>\n      <direction-indicator>di-bidirectional</direction-indicator>\n      <matching-operator>mo-equal</matching-operator>\n      <comp-decomp-action>cda-not-sent</comp-decomp-action>\n      <target-value>\n        <index>0</index>\n        <value>ADo=</value>\n      </target-value>\n    </entry>\n    <entry>\n      <field-id>fid-ipv6-hoplimit</field-id>\n      <field-length>8</field-length>\n      <field-position>1</field-position>\n      <direction-indicator>di-bidirectional</direction-indicator>\n      <matching-operator>mo-ignore</matching-operator>\n      <comp-decomp-action>cda-not-sent</comp-decomp-action>\n      <target-value>\n        <index>0</index>\n        <value>AP8=</value>\n      </target-value>\n    </entry>\n    <entry>\n      <field-id>fid-ipv6-devprefix</field-id>\n      <field-length>64</field-length>\n      <field-position>1</field-position>\n      <direction-indicator>di-bidirectional</direction-indicator>\n      <matching-operator>mo-equal</matching-operator>\n      <comp-decomp-action>cda-not-sent</comp-decomp-action>\n      <target-value>\n        <index>0</index>\n        <value>IAEEcB8hAdI=</value>\n      </target-value>\n    </entry>\n    <entry>\n      <field-id>fid-ipv6-deviid</field-id>\n      <field-length>64</field-length>\n      <field-position>1</field-position>\n      <direction-indicator>di-bidirectional</direction-indicator>\n      <matching-operator>mo-equal</matching-operator>\n      <comp-decomp-action>cda-not-sent</comp-decomp-action>\n      <target-value>\n        <index>0</index>\n        <value>AAAAAAAAAAM=</value>\n      </target-value>\n    </entry>\n    <entry>\n      <field-id>fid-ipv6-appprefix</field-id>\n      <field-length>64</field-length>\n      <field-position>1</field-position>\n      <direction-indicator>di-bidirectional</direction-indicator>\n      <matching-operator>mo-ignore</matching-operator>\n      <comp-decomp-action>cda-value-sent</comp-decomp-action>\n    </entry>\n    <entry>\n      <field-id>fid-ipv6-appiid</field-id>\n      <field-length>64</field-length>\n      <field-position>1</field-position>\n      <direction-indicator>di-bidirectional</direction-indicator>\n      <matching-operator>mo-ignore</matching-operator>\n      <comp-decomp-action>cda-value-sent</comp-decomp-action>\n    </entry>\n  </rule>\n  <rule>\n    <rule-id-value>12</rule-id-value>\n    <rule-id-length>11</rule-id-length>\n    <rule-nature>nature-fragmentation</rule-nature>\n    <direction>di-up</direction>\n    <rcs-algorithm>rcs-crc32</rcs-algorithm>\n    <dtag-size>2</dtag-size>\n    <fcn-size>3</fcn-size>\n    <fragmentation-mode>\n         fragmentation-mode-no-ack\n    </fragmentation-mode>\n  </rule>\n  <rule>\n    <rule-id-value>100</rule-id-value>\n    <rule-id-length>8</rule-id-length>\n    <rule-nature>nature-no-compression</rule-nature>\n  </rule>\n </schc>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 8: XML Representation of the Rules",
      "ja": "図8：ルールのXML表現"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "section_title": true,
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Dominique Barthel, Carsten Bormann, Ivan Martinez, and Alexander Pelov for their careful reading and valuable inputs. A special thanks for Joe Clarke, Carl Moberg, Tom Petch, Martin Thomson, and Éric Vyncke for their explanations and wise advice when building the model.",
      "ja": "著者は、Dominique Barthel、Carsten Bormann、Ivan Martinez、およびAlexander Pelovに慎重な読書と貴重なインプットに感謝したいと思います。ジョー・クラーク、カール・モーバーグ、トム・ペッチ、マーティン・トムソン、エリック・ヴィンチに、モデルを構築する際の説明と賢明なアドバイスに感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Ana Minaburo\nAcklio\n1137A avenue des Champs Blancs\n35510 Cesson-Sevigne Cedex\nFrance\nEmail: ana@ackl.io",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Laurent Toutain\nInstitut MINES TELECOM; IMT Atlantique\n2 rue de la Chataigneraie CS 17607\n35576 Cesson-Sevigne Cedex\nFrance\nEmail: Laurent.Toutain@imt-atlantique.fr",
      "raw": true,
      "ja": ""
    }
  ]
}