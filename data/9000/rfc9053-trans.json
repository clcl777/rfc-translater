{
  "title": {
    "text": "RFC 9053 - CBOR Object Signing and Encryption (COSE): Initial Algorithms",
    "ja": "RFC 9053 - CBORオブジェクトの署名と暗号化（COSE）：初期アルゴリズム"
  },
  "number": 9053,
  "created_at": "2024-03-20 11:26:37.831725+09:00",
  "updated_by": "自動生成(GPT)",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         J. Schaad\nRequest for Comments: 9053                                August Cellars\nObsoletes: 8152                                              August 2022\nCategory: Informational                                                 \nISSN: 2070-1721",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "CBOR Object Signing and Encryption (COSE): Initial Algorithms",
      "title": true,
      "section_title": true,
      "ja": "CBORオブジェクトの署名と暗号化（COSE）：初期アルゴリズム"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size. There is a need to be able to define basic security services for this data format. This document defines a set of algorithms that can be used with the CBOR Object Signing and Encryption (COSE) protocol (RFC 9052).",
      "ja": "Concise Binary Object Representation (CBOR) は、小さなコードサイズと小さなメッセージサイズを目指して設計されたデータ形式です。このデータ形式に基本的なセキュリティサービスを定義できる必要があります。この文書は、CBOR Object Signing and Encryption (COSE) プロトコル（RFC 9052）で使用できるアルゴリズムのセットを定義します。"
    },
    {
      "indent": 3,
      "text": "This document, along with RFC 9052, obsoletes RFC 8152.",
      "ja": "この文書は、RFC 9052とともにRFC 8152を廃止します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "この文書はインターネット標準トラック仕様ではありません。情報提供のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "この文書はInternet Engineering Task Force（IETF）の製品です。IETFコミュニティの合意を表しています。公開レビューを受け、Internet Engineering Steering Group（IESG）による出版承認を受けています。IESGによって承認されたすべての文書がインターネット標準のいずれかの候補となるわけではありません。RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9053.",
      "ja": "この文書の現在の状況、誤植、およびフィードバックの方法に関する情報は、https://www.rfc-editor.org/info/rfc9053 で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2022 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2022 IETF Trustおよび文書の著者として特定された人々。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "この文書は、この文書の公開日に有効なBCP 78およびIETF文書に関するIETF信託の法的規定（https://trustee.ietf.org/license-info）の対象となります。これらの文書を注意深く確認してください。これらは、この文書に関するあなたの権利と制限を説明しています。この文書から抽出されたコードコンポーネントには、信託法的規定のセクション4.eに記載されているように改訂されたBSDライセンステキストを含める必要があり、改訂されたBSDライセンスに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Requirements Terminology\n  1.2.  Changes from RFC 8152\n  1.3.  Document Terminology\n  1.4.  CDDL Grammar for CBOR Data Structures\n  1.5.  Examples\n2.  Signature Algorithms\n  2.1.  ECDSA\n    2.1.1.  Security Considerations for ECDSA\n  2.2.  Edwards-Curve Digital Signature Algorithm (EdDSA)\n    2.2.1.  Security Considerations for EdDSA\n3.  Message Authentication Code (MAC) Algorithms\n  3.1.  Hash-Based Message Authentication Codes (HMACs)\n    3.1.1.  Security Considerations for HMAC\n  3.2.  AES Message Authentication Code (AES-CBC-MAC)\n    3.2.1.  Security Considerations for AES-CBC-MAC\n4.  Content Encryption Algorithms\n  4.1.  AES-GCM\n    4.1.1.  Security Considerations for AES-GCM\n  4.2.  AES-CCM\n    4.2.1.  Security Considerations for AES-CCM\n  4.3.  ChaCha20 and Poly1305\n    4.3.1.  Security Considerations for ChaCha20/Poly1305\n5.  Key Derivation Functions (KDFs)\n  5.1.  HMAC-Based Extract-and-Expand Key Derivation Function\n        (HKDF)\n  5.2.  Context Information Structure\n6.  Content Key Distribution Methods\n  6.1.  Direct Encryption\n    6.1.1.  Direct Key\n    6.1.2.  Direct Key with KDF\n  6.2.  Key Wrap\n    6.2.1.  AES Key Wrap\n  6.3.  Direct Key Agreement\n    6.3.1.  Direct ECDH\n  6.4.  Key Agreement with Key Wrap\n    6.4.1.  ECDH with Key Wrap\n7.  Key Object Parameters\n  7.1.  Elliptic Curve Keys\n    7.1.1.  Double Coordinate Curves\n  7.2.  Octet Key Pair\n  7.3.  Symmetric Keys\n8.  COSE Capabilities\n  8.1.  Assignments for Existing Algorithms\n  8.2.  Assignments for Existing Key Types\n  8.3.  Examples\n9.  CBOR Encoding Restrictions\n10. IANA Considerations\n  10.1.  Changes to the \"COSE Key Types\" Registry\n  10.2.  Changes to the \"COSE Algorithms\" Registry\n  10.3.  Changes to the \"COSE Key Type Parameters\" Registry\n  10.4.  Expert Review Instructions\n11. Security Considerations\n12. References\n  12.1.  Normative References\n  12.2.  Informative References\nAcknowledgments\nAuthor's Address",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "There has been an increased focus on small, constrained devices that make up the Internet of Things (IoT). One of the standards that has come out of this process is \"Concise Binary Object Representation (CBOR)\" [STD94]. CBOR extended the data model of JavaScript Object Notation (JSON) [STD90] by allowing for binary data, among other changes. CBOR has been adopted by several of the IETF working groups dealing with the IoT world as their method of encoding data structures. CBOR was designed specifically to be small in terms of both messages transported and implementation size and to have a schema-free decoder. A need exists to provide message security services for IoT, and using CBOR as the message-encoding format makes sense.",
      "ja": "このプロセスから生まれた標準の1つが「Concise Binary Object Representation (CBOR)」です。CBORは、JSONのデータモデルを拡張し、バイナリデータを含むことができるようになりました。CBORは、いくつかのIETFワーキンググループによって採用され、メッセージの輸送量や実装サイズが小さく、スキーマフリーのデコーダーを持つように設計されています。IoT向けのメッセージセキュリティサービスを提供する必要があり、CBORをメッセージエンコーディング形式として使用することは理にかなっています。"
    },
    {
      "indent": 3,
      "text": "The core COSE specification consists of two documents. [RFC9052] contains the serialization structures and the procedures for using the different cryptographic algorithms. This document provides an initial set of algorithms for use with those structures.",
      "ja": "COSE仕様の中核は2つの文書で構成されています。[RFC9052]にはシリアル化構造と異なる暗号アルゴリズムを使用する手順が含まれています。この文書は、これらの構造と使用するための初期のアルゴリズムセットを提供します。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Terminology",
      "section_title": true,
      "ja": "1.1. 要件用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書におけるキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、および「OPTIONAL」は、全て大文字で表記されている場合に限り、BCP 14 [RFC2119] [RFC8174] で説明されているように解釈されるべきです。"
    },
    {
      "indent": 0,
      "text": "1.2. Changes from RFC 8152",
      "section_title": true,
      "ja": "1.2. RFC 8152 からの変更"
    },
    {
      "indent": 6,
      "text": "* Extracted the sections dealing with specific algorithms and placed them into this document. The sections dealing with structure and general processing rules are placed in [RFC9052].",
      "ja": "* 特定のアルゴリズムに関するセクションを抽出し、このドキュメントに配置しました。構造と一般的な処理ルールに関するセクションは[RFC9052]に配置されています。"
    },
    {
      "indent": 6,
      "text": "* Made text clarifications and changes in terminology.",
      "ja": "* 用語の説明と変更を行いました。"
    },
    {
      "indent": 6,
      "text": "* Removed all of the details relating to countersignatures and placed them in [COUNTERSIGN].",
      "ja": "* カウンターサインに関連するすべての詳細を削除し、[COUNTERSIGN]に配置しました。"
    },
    {
      "indent": 0,
      "text": "1.3. Document Terminology",
      "section_title": true,
      "ja": "1.3. 文書用語"
    },
    {
      "indent": 3,
      "text": "In this document, we use the following terminology:",
      "ja": "この文書では、以下の用語を使用しています。"
    },
    {
      "indent": 3,
      "text": "Byte:",
      "ja": "バイト"
    },
    {
      "indent": 12,
      "text": "A synonym for octet.",
      "ja": "8つ組"
    },
    {
      "indent": 3,
      "text": "Constrained Application Protocol (CoAP):",
      "ja": "Constrained Application Protocol (CoAP):"
    },
    {
      "indent": 12,
      "text": "A specialized web transfer protocol for use in constrained systems. It is defined in [RFC7252].",
      "ja": "[RFC7252] で定義された制約のあるシステムで使用するための専用のWeb転送プロトコル。"
    },
    {
      "indent": 3,
      "text": "Authenticated Encryption (AE) algorithms [RFC5116]:",
      "ja": "認証付き暗号（AE）アルゴリズム[RFC5116]:"
    },
    {
      "indent": 12,
      "text": "Encryption algorithms that provide an authentication check of the contents along with the encryption service. An example of an AE algorithm used in COSE is AES Key Wrap [RFC3394]. These algorithms are used for key encryption, but Authenticated Encryption with Associated Data (AEAD) algorithms would be preferred.",
      "ja": "コンテンツと一緒に認証チェックを提供する暗号化アルゴリズム。COSEで使用されるAEアルゴリズムの例はAES Key Wrap [RFC3394]です。これらのアルゴリズムは鍵の暗号化に使用されますが、関連データを持つ認証付き暗号化（AEAD）アルゴリズムが好ましいです。"
    },
    {
      "indent": 3,
      "text": "AEAD algorithms [RFC5116]:",
      "ja": "AEADアルゴリズム[RFC5116]:"
    },
    {
      "indent": 12,
      "text": "Encryption algorithms that provide the same authentication service of the content as AE algorithms do, and also allow associated data that is not part of the encrypted body to be included in the authentication service. An example of an AEAD algorithm used in COSE is AES-GCM [RFC5116]. These algorithms are used for content encryption and can be used for key encryption as well.",
      "ja": "AEアルゴリズムと同じ認証サービスを提供し、暗号化された本文の一部ではない関連データを認証サービスに含めることができる暗号化アルゴリズム。COSEで使用されるAEADアルゴリズムの例としては、AES-GCM [RFC5116] があります。これらのアルゴリズムはコンテンツの暗号化に使用され、キーの暗号化にも使用できます。"
    },
    {
      "indent": 3,
      "text": "The term \"byte string\" is used for sequences of bytes, while the term \"text string\" is used for sequences of characters.",
      "ja": "「バイト列」という用語はバイトの連続を指し、「テキスト列」という用語は文字の連続を指します。"
    },
    {
      "indent": 3,
      "text": "The tables for algorithms contain the following columns:",
      "ja": "アルゴリズムのテーブルには、次の列が含まれています："
    },
    {
      "indent": 6,
      "text": "* A name for the algorithm for use in documents.",
      "ja": "* 文書で使用するアルゴリズムの名前。"
    },
    {
      "indent": 6,
      "text": "* The value used on the wire for the algorithm. One place this is used is the algorithm header parameter of a message.",
      "ja": "* アルゴリズムで使用されるワイヤー上の値。これが使用される場所の1つは、メッセージのアルゴリズムヘッダーパラメータです。"
    },
    {
      "indent": 6,
      "text": "* A short description so that the algorithm can be easily identified when scanning the IANA registry.",
      "ja": "* IANAレジストリをスキャンする際にアルゴリズムを簡単に特定できるようにするための簡単な説明。"
    },
    {
      "indent": 3,
      "text": "Additional columns may be present in a table depending on the algorithms.",
      "ja": "アルゴリズムによっては、テーブルに追加の列が存在する場合があります。"
    },
    {
      "indent": 0,
      "text": "1.4. CDDL Grammar for CBOR Data Structures",
      "section_title": true,
      "ja": "1.4. CDDL Grammar for CBOR Data Structures"
    },
    {
      "indent": 3,
      "text": "When COSE was originally written, the Concise Data Definition Language (CDDL) [RFC8610] had not yet been published in an RFC, so it could not be used as the data description language to normatively describe the CBOR data structures employed by COSE. For that reason, the CBOR data objects defined here are described in prose. Additional (non-normative) descriptions of the COSE data objects are provided in a subset of CDDL, described in [RFC9052].",
      "ja": "COSEが最初に書かれたとき、Concise Data Definition Language（CDDL）[RFC8610]がまだRFCで公開されていなかったため、COSEで使用されるCBORデータ構造を規範的に記述するためのデータ記述言語として使用することはできませんでした。そのため、ここで定義されたCBORデータオブジェクトは文章で説明されています。COSEデータオブジェクトの追加（非規範的な）説明は、[RFC9052]で説明されているCDDLのサブセットで提供されています。"
    },
    {
      "indent": 0,
      "text": "1.5. Examples",
      "section_title": true,
      "ja": "1.5. 例"
    },
    {
      "indent": 3,
      "text": "A GitHub project has been created at [GitHub-Examples] that contains a set of testing examples. Each example is found in a JSON file that contains the inputs used to create the example, some of the intermediate values that can be used for debugging, and the output of the example. The results are encoded using both hexadecimal and CBOR diagnostic notation format.",
      "ja": "[GitHub-Examples]でGitHubプロジェクトが作成され、テスト例が含まれています。各例は、例を作成するために使用される入力、デバッグに使用できるいくつかの中間値、および例の出力が含まれるJSONファイルに見つかります。結果は16進数とCBOR診断表記形式の両方を使用してエンコードされています。"
    },
    {
      "indent": 3,
      "text": "Some of the examples are designed to be failure-testing cases; these are clearly marked as such in the JSON file.",
      "ja": "いくつかの例は失敗テストケースを想定して設計されています。これらはJSONファイルで明示的にそのようにマークされています。"
    },
    {
      "indent": 0,
      "text": "2. Signature Algorithms",
      "section_title": true,
      "ja": "2. 署名アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Section 8.1 of [RFC9052] contains a generic description of signature algorithms. This document defines signature algorithm identifiers for two signature algorithms.",
      "ja": "[RFC9052]のセクション8.1には、署名アルゴリズムの一般的な説明が含まれています。この文書は、2つの署名アルゴリズムのための署名アルゴリズム識別子を定義しています。"
    },
    {
      "indent": 0,
      "text": "2.1. ECDSA",
      "section_title": true,
      "ja": "2.1. ECDSA"
    },
    {
      "indent": 3,
      "text": "The Elliptic Curve Digital Signature Algorithm (ECDSA) [DSS] defines a signature algorithm using Elliptic Curve Cryptography (ECC). Implementations SHOULD use a deterministic version of ECDSA such as the one defined in [RFC6979]. The use of a deterministic signature algorithm allows systems to avoid relying on random number generators in order to avoid generating the same value of \"k\" (the per-message random value). Biased generation of the value \"k\" can be attacked, and collisions of this value lead to leaked keys. It additionally allows performing deterministic tests for the signature algorithm. The use of deterministic ECDSA does not lessen the need to have good random number generation when creating the private key.",
      "ja": "楕円曲線デジタル署名アルゴリズム（ECDSA）[DSS]は、楕円曲線暗号（ECC）を使用した署名アルゴリズムを定義します。実装は[RFC6979]で定義されているようなECDSAの決定論的バージョンを使用するべきです。決定論的署名アルゴリズムの使用により、システムはランダム数生成器に依存せずに\"k\"（メッセージごとのランダム値）の同じ値を生成することを避けることができます。値\"k\"のバイアス生成は攻撃され、この値の衝突は鍵の漏洩につながります。さらに、署名アルゴリズムの決定論的テストを実行することができます。決定論的ECDSAの使用は、秘密鍵を作成する際に良好なランダム数生成の必要性を減らすものではありません。"
    },
    {
      "indent": 3,
      "text": "The ECDSA signature algorithm is parameterized with a hash function (h). In the event that the length of the hash function output is greater than the group of the key, the leftmost bytes of the hash output are used.",
      "ja": "ECDSA署名アルゴリズムはハッシュ関数（h）でパラメータ化されています。ハッシュ関数の出力の長さが鍵のグループよりも大きい場合、ハッシュ出力の左端のバイトが使用されます。"
    },
    {
      "indent": 3,
      "text": "The algorithms defined in this document can be found in Table 1.",
      "ja": "この文書で定義されたアルゴリズムは、表1に記載されています。"
    },
    {
      "indent": 14,
      "text": "+=======+=======+=========+==================+\n| Name  | Value | Hash    | Description      |\n+=======+=======+=========+==================+\n| ES256 |   -7  | SHA-256 | ECDSA w/ SHA-256 |\n+-------+-------+---------+------------------+\n| ES384 |  -35  | SHA-384 | ECDSA w/ SHA-384 |\n+-------+-------+---------+------------------+\n| ES512 |  -36  | SHA-512 | ECDSA w/ SHA-512 |\n+-------+-------+---------+------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Table 1: ECDSA Algorithm Values",
      "ja": "表1：ECDSAアルゴリズムの値"
    },
    {
      "indent": 3,
      "text": "This document defines ECDSA as working only with the curves P-256, P-384, and P-521. This document requires that the curves be encoded using the \"EC2\" (two coordinate elliptic curve) key type. Implementations need to check that the key type and curve are correct when creating and verifying a signature. Future documents may define it to work with other curves and key types in the future.",
      "ja": "この文書は、ECDSAがP-256、P-384、およびP-521の曲線でのみ動作するよう定義しています。この文書では、曲線を「EC2」（2つの座標楕円曲線）鍵タイプを使用してエンコードする必要があります。実装は、署名の作成および検証時に鍵タイプと曲線が正しいことを確認する必要があります。将来の文書では、他の曲線や鍵タイプとの動作を定義する可能性があります。"
    },
    {
      "indent": 3,
      "text": "In order to promote interoperability, it is suggested that SHA-256 be used only with curve P-256, SHA-384 be used only with curve P-384, and SHA-512 be used only with curve P-521. This is aligned with the recommendation in Section 4 of [RFC5480].",
      "ja": "相互運用性を促進するために、SHA-256は曲線P-256のみを使用し、SHA-384は曲線P-384のみを使用し、SHA-512は曲線P-521のみを使用することが提案されています。これは[RFC5480]のセクション4の推奨事項と一致しています。"
    },
    {
      "indent": 3,
      "text": "The signature algorithm results in a pair of integers (R, S). These integers will be the same length as the length of the key used for the signature process. The signature is encoded by converting the integers into byte strings of the same length as the key size. The length is rounded up to the nearest byte and is left padded with zero bits to get to the correct length. The two integers are then concatenated together to form a byte string that is the resulting signature.",
      "ja": "署名アルゴリズムは、整数のペア（R、S）を生成します。これらの整数は、署名プロセスに使用される鍵の長さと同じ長さになります。署名は、整数を鍵サイズと同じ長さのバイト文字列に変換してエンコードされます。長さは最も近いバイトに丸められ、正しい長さに達するためにゼロビットで左側にパディングされます。次に、2つの整数を連結して、結果の署名となるバイト文字列が形成されます。"
    },
    {
      "indent": 3,
      "text": "Using the function defined in [RFC8017], the signature is:",
      "ja": "[RFC8017] で定義された関数を使用すると、署名は次のようになります。"
    },
    {
      "indent": 3,
      "text": "Signature = I2OSP(R, n) | I2OSP(S, n)",
      "ja": "Signature = I2OSP(R, n) | I2OSP(S, n)"
    },
    {
      "indent": 3,
      "text": "where n = ceiling(key_length / 8)",
      "ja": "n = ceiling(key_length / 8) となります。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムでCOSEキーを使用する場合、次のチェックが行われます："
    },
    {
      "indent": 6,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"EC2\".",
      "ja": "* \"kty\"フィールドは必ず存在し、\"EC2\"である必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the \"alg\" field is present, it MUST match the ECDSA signature algorithm being used.",
      "ja": "* \"alg\" フィールドが存在する場合、使用されている ECDSA 署名アルゴリズムと一致している必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the \"key_ops\" field is present, it MUST include \"sign\" when creating an ECDSA signature.",
      "ja": "* \"key_ops\" フィールドが存在する場合、ECDSA 署名を作成する際には、\"sign\" を含める必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the \"key_ops\" field is present, it MUST include \"verify\" when verifying an ECDSA signature.",
      "ja": "* もし「key_ops」フィールドが存在する場合、ECDSA署名を検証する際には「verify」を含めなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.1.1. Security Considerations for ECDSA",
      "section_title": true,
      "ja": "2.1.1. ECDSAのセキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The security strength of the signature is no greater than the minimum of the security strength associated with the bit length of the key and the security strength of the hash function.",
      "ja": "署名のセキュリティ強度は、鍵のビット長に関連付けられたセキュリティ強度とハッシュ関数のセキュリティ強度の最小値以下です。"
    },
    {
      "indent": 3,
      "text": "Note: Use of a deterministic signature technique is a good idea even when good random number generation exists. Doing so both reduces the possibility of having the same value of \"k\" in two signature operations and allows for reproducible signature values, which helps testing. There have been recent attacks involving faulting the device in order to extract the key. This can be addressed by combining both randomness and determinism [CFRG-DET-SIGS].",
      "ja": "注意：良好な乱数生成が存在する場合でも、確定的署名技術の使用は良い考えです。これにより、2つの署名操作で同じ「k」の値を持つ可能性が低くなり、テストを支援する再現可能な署名値が可能になります。最近、デバイスを故障させて鍵を抽出する攻撃が発生しています。これはランダム性と決定論を組み合わせることで対処できます。"
    },
    {
      "indent": 3,
      "text": "There are two substitution attacks that can theoretically be mounted against the ECDSA signature algorithm.",
      "ja": "ECDSA署名アルゴリズムに対して理論的に実行可能な2つの置換攻撃があります。"
    },
    {
      "indent": 6,
      "text": "* Changing the curve used to validate the signature: If one changes the curve used to validate the signature, then potentially one could have two messages with the same signature, each computed under a different curve. The only requirements on the new curve are that its order be the same as the old one and that it be acceptable to the client. An example would be to change from using the curve secp256r1 (aka P-256) to using secp256k1. (Both are 256-bit curves.) We currently do not have any way to deal with this version of the attack except to restrict the overall set of curves that can be used.",
      "ja": "* 署名を検証するために使用される曲線を変更すると、同じ署名を持つ2つのメッセージが可能になるかもしれません。新しい曲線には、古い曲線と同じ次数であり、クライアントに受け入れられる必要があります。例えば、曲線secp256r1（別名P-256）からsecp256k1を使用するように変更することが考えられます（どちらも256ビットの曲線です）。現在、この攻撃のバージョンに対処する方法は、使用できる曲線の全体セットを制限する以外にありません。"
    },
    {
      "indent": 6,
      "text": "* Changing the hash function used to validate the signature: If one either has two different hash functions of the same length or can truncate a hash function, then one could potentially find collisions between the hash functions rather than within a single hash function. For example, truncating SHA-512 to 256 bits might collide with a SHA-256 bit hash value. As the hash algorithm is part of the signature algorithm identifier, this attack is mitigated by including a signature algorithm identifier in the protected-header bucket.",
      "ja": "* 署名を検証するために使用されるハッシュ関数を変更する場合：同じ長さの2つの異なるハッシュ関数を持っているか、ハッシュ関数を切り捨てることができる場合、1つのハッシュ関数内ではなく、ハッシュ関数間で衝突を見つける可能性があります。たとえば、SHA-512を256ビットに切り捨てると、SHA-256ビットハッシュ値と衝突する可能性があります。ハッシュアルゴリズムは署名アルゴリズム識別子の一部であるため、この攻撃は保護ヘッダーバケットに署名アルゴリズム識別子を含めることで緩和されます。"
    },
    {
      "indent": 0,
      "text": "2.2. Edwards-Curve Digital Signature Algorithm (EdDSA)",
      "section_title": true,
      "ja": "2.2. Edwards-Curve Digital Signature Algorithm (EdDSA)"
    },
    {
      "indent": 3,
      "text": "[RFC8032] describes the elliptic curve signature scheme Edwards-curve Digital Signature Algorithm (EdDSA). In that document, the signature algorithm is instantiated using parameters for the edwards25519 and edwards448 curves. The document additionally describes two variants of the EdDSA algorithm: Pure EdDSA, where no hash function is applied to the content before signing, and HashEdDSA, where a hash function is applied to the content before signing and the result of that hash function is signed. For EdDSA, the content to be signed (either the message or the prehash value) is processed twice inside of the signature algorithm. For use with COSE, only the pure EdDSA version is used. This is because it is not expected that extremely large contents are going to be needed and, based on the arrangement of the message structure, the entire message is going to need to be held in memory in order to create or verify a signature. Therefore, there does not appear to be a need to be able to do block updates of the hash, followed by eliminating the message from memory. Applications can provide the same features by defining the content of the message as a hash value and transporting the COSE object (with the hash value) and the content as separate items.",
      "ja": "[RFC8032]は、楕円曲線署名スキームであるEdwards-curve Digital Signature Algorithm（EdDSA）について説明しています。その文書では、edwards25519およびedwards448曲線のパラメータを使用して署名アルゴリズムがインスタンス化されています。文書には、EdDSAアルゴリズムの2つのバリアントについても説明があります：純粋なEdDSAでは、署名前にコンテンツにハッシュ関数が適用されず、HashEdDSAでは、署名前にコンテンツにハッシュ関数が適用され、そのハッシュ関数の結果が署名されます。EdDSAでは、署名アルゴリズム内で署名されるコンテンツ（メッセージまたは事前ハッシュ値）が2回処理されます。COSEとの使用では、純粋なEdDSAバージョンのみが使用されます。これは、非常に大きなコンテンツが必要とされることはないと予想され、メッセージ構造の配置に基づいて、署名を作成または検証するためにメモリにメッセージ全体を保持する必要があるためです。したがって、ハッシュのブロック更新を行い、その後メッセージをメモリから削除する必要があるという必要性は見られません。アプリケーションは、メッセージの内容をハッシュ値として定義し、COSEオブジェクト（ハッシュ値を含む）とコンテンツを別々のアイテムとして輸送することで同じ機能を提供できます。"
    },
    {
      "indent": 3,
      "text": "The algorithm defined in this document can be found in Table 2. A single signature algorithm is defined, which can be used for multiple curves.",
      "ja": "この文書で定義されたアルゴリズムは、表2に見つけることができます。1つの署名アルゴリズムが定義されており、複数の曲線に使用することができます。"
    },
    {
      "indent": 22,
      "text": "+=======+=======+=============+\n| Name  | Value | Description |\n+=======+=======+=============+\n| EdDSA |   -8  | EdDSA       |\n+-------+-------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 2: EdDSA Algorithm Value",
      "ja": "表2: EdDSAアルゴリズムの値"
    },
    {
      "indent": 3,
      "text": "[RFC8032] describes the method of encoding the signature value.",
      "ja": "[RFC8032]は署名値をエンコードする方法を説明しています。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムでCOSEキーを使用する場合、以下のチェックが行われます。"
    },
    {
      "indent": 6,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"OKP\" (Octet Key Pair).",
      "ja": "* \"kty\"フィールドは必ず存在し、\"OKP\"（Octet Key Pair）である必要があります。"
    },
    {
      "indent": 6,
      "text": "* The \"crv\" field MUST be present, and it MUST be a curve defined for this signature algorithm.",
      "ja": "* \"crv\"フィールドは必ず存在し、この署名アルゴリズムのために定義された曲線でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If the \"alg\" field is present, it MUST match \"EdDSA\".",
      "ja": "* \"alg\" フィールドが存在する場合、それは \"EdDSA\" と一致する必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the \"key_ops\" field is present, it MUST include \"sign\" when creating an EdDSA signature.",
      "ja": "* \"key_ops\" フィールドが存在する場合、EdDSA 署名を作成する際には \"sign\" を含める必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the \"key_ops\" field is present, it MUST include \"verify\" when verifying an EdDSA signature.",
      "ja": "* \"key_ops\" フィールドが存在する場合、EdDSA 署名を検証する際には、\"verify\" を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "2.2.1. Security Considerations for EdDSA",
      "section_title": true,
      "ja": "2.2.1. EdDSAのセキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Public values are computed differently in EdDSA and Elliptic Curve Diffie-Hellman (ECDH); for this reason, the public key from one should not be used with the other algorithm.",
      "ja": "EdDSAと楕円曲線Diffie-Hellman（ECDH）では、公開値が異なる方法で計算されるため、片方の公開鍵を他方のアルゴリズムで使用すべきではありません。"
    },
    {
      "indent": 3,
      "text": "If batch signature verification is performed, a well-seeded cryptographic random number generator is REQUIRED (Section 8.2 of [RFC8032]). Signing and nonbatch signature verification are deterministic operations and do not need random numbers of any kind.",
      "ja": "バッチ署名検証が行われる場合、適切にシードされた暗号論的乱数生成器が必要です（[RFC8032]のセクション8.2）。署名と非バッチ署名検証は決定論的な操作であり、どんな種類の乱数も必要ありません。"
    },
    {
      "indent": 0,
      "text": "3. Message Authentication Code (MAC) Algorithms",
      "section_title": true,
      "ja": "3. メッセージ認証コード（MAC）アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Section 8.2 of [RFC9052] contains a generic description of MAC algorithms. This section defines the conventions for two MAC algorithms.",
      "ja": "[RFC9052]のセクション8.2には、MACアルゴリズムの一般的な説明が含まれています。このセクションでは、2つのMACアルゴリズムの規則が定義されています。"
    },
    {
      "indent": 0,
      "text": "3.1. Hash-Based Message Authentication Codes (HMACs)",
      "section_title": true,
      "ja": "3.1. ハッシュベースメッセージ認証コード（HMAC）"
    },
    {
      "indent": 3,
      "text": "HMAC [RFC2104] [RFC4231] was designed to deal with length extension attacks. The HMAC algorithm was also designed to allow new hash functions to be directly plugged in without changes to the hash function. The HMAC design process has been shown to be solid; although the security of hash functions such as MD5 has decreased over time, the security of HMAC combined with MD5 has not yet been shown to be compromised [RFC6151].",
      "ja": "HMAC [RFC2104] [RFC4231] は、長さ拡張攻撃に対処するために設計されました。HMAC アルゴリズムは、新しいハッシュ関数を変更せずに直接接続できるように設計されています。HMAC の設計プロセスは堅実であることが示されています。MD5 などのハッシュ関数のセキュリティは時間とともに低下していますが、MD5 と組み合わせた HMAC のセキュリティはまだ compromised されていないことが示されています [RFC6151]。"
    },
    {
      "indent": 3,
      "text": "The HMAC algorithm is parameterized by an inner and outer padding, a hash function (h), and an authentication tag value length. For this specification, the inner and outer padding are fixed to the values set in [RFC2104]. The length of the authentication tag corresponds to the difficulty of producing a forgery. For use in constrained environments, we define one HMAC algorithm that is truncated. There are currently no known issues with truncation; however, the security strength of the message tag is correspondingly reduced in strength. When truncating, the leftmost tag-length bits are kept and transmitted.",
      "ja": "HMACアルゴリズムは、内部および外部のパディング、ハッシュ関数（h）、および認証タグの値の長さによってパラメータ化されます。この仕様では、内部および外部のパディングは[RFC2104]で設定された値に固定されています。認証タグの長さは、偽造を生成する難しさに対応しています。制約のある環境で使用するために、切り捨てられた1つのHMACアルゴリズムを定義します。現在、切り捨てに関する既知の問題はありませんが、メッセージタグのセキュリティ強度が対応して低下します。切り捨てる場合、左端のタグ長のビットが保持されて送信されます。"
    },
    {
      "indent": 3,
      "text": "The algorithms defined in this document can be found in Table 3.",
      "ja": "この文書で定義されたアルゴリズムは、表3に記載されています。"
    },
    {
      "indent": 3,
      "text": "+=============+=======+=========+============+======================+\n| Name        | Value | Hash    | Tag Length | Description          |\n+=============+=======+=========+============+======================+\n| HMAC        |   4   | SHA-256 |     64     | HMAC w/ SHA-256      |\n| 256/64      |       |         |            | truncated to 64 bits |\n+-------------+-------+---------+------------+----------------------+\n| HMAC        |   5   | SHA-256 |    256     | HMAC w/ SHA-256      |\n| 256/256     |       |         |            |                      |\n+-------------+-------+---------+------------+----------------------+\n| HMAC        |   6   | SHA-384 |    384     | HMAC w/ SHA-384      |\n| 384/384     |       |         |            |                      |\n+-------------+-------+---------+------------+----------------------+\n| HMAC        |   7   | SHA-512 |    512     | HMAC w/ SHA-512      |\n| 512/512     |       |         |            |                      |\n+-------------+-------+---------+------------+----------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 3: HMAC Algorithm Values",
      "ja": "表3: HMACアルゴリズムの値"
    },
    {
      "indent": 3,
      "text": "Some recipient algorithms transport the key, while others derive a key from secret data. For those algorithms that transport the key (such as AES Key Wrap), the size of the HMAC key SHOULD be the same size as the output of the underlying hash function. For those algorithms that derive the key (such as ECDH), the derived key MUST be the same size as the output of the underlying hash function.",
      "ja": "一部の受信者アルゴリズムは鍵を輸送し、他のものは秘密データから鍵を導出します。鍵を輸送するアルゴリズム（AES Key Wrapなど）の場合、HMAC鍵のサイズは基礎となるハッシュ関数の出力と同じサイズであるべきです。鍵を導出するアルゴリズム（ECDHなど）の場合、導出された鍵は基礎となるハッシュ関数の出力と同じサイズでなければなりません。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムでCOSEキーを使用する場合、次のチェックが行われます。"
    },
    {
      "indent": 6,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"Symmetric\".",
      "ja": "* \"kty\"フィールドは必ず存在し、\"Symmetric\"である必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the \"alg\" field is present, it MUST match the HMAC algorithm being used.",
      "ja": "* もし\"alg\"フィールドが存在する場合、それは使用されているHMACアルゴリズムと一致しなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If the \"key_ops\" field is present, it MUST include \"MAC create\" when creating an HMAC authentication tag.",
      "ja": "* もし「key_ops」フィールドが存在する場合、HMAC 認証タグを作成する際には「MAC create」を含める必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the \"key_ops\" field is present, it MUST include \"MAC verify\" when verifying an HMAC authentication tag.",
      "ja": "* もし「key_ops」フィールドが存在する場合、HMAC 認証タグを検証する際には「MAC verify」を含めなければなりません。"
    },
    {
      "indent": 3,
      "text": "Implementations creating and validating MAC values MUST validate that the key type, key length, and algorithm are correct and appropriate for the entities involved.",
      "ja": "MAC値を作成および検証する実装は、関係するエンティティに適切であることを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.1.1. Security Considerations for HMAC",
      "section_title": true,
      "ja": "3.1.1. HMACのセキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "HMAC has proved to be resistant to attack even when used with weakened hash algorithms. The current best known attack is to brute force the key. This means that key size is going to be directly related to the security of an HMAC operation.",
      "ja": "HMACは、弱体化されたハッシュアルゴリズムと組み合わせて使用されていても攻撃に耐えることが証明されています。現在知られている最良の攻撃方法は、鍵を総当たりで探すことです。これは、鍵のサイズがHMAC操作のセキュリティに直接関係してくることを意味します。"
    },
    {
      "indent": 0,
      "text": "3.2. AES Message Authentication Code (AES-CBC-MAC)",
      "section_title": true,
      "ja": "3.2. AES メッセージ認証コード（AES-CBC-MAC）"
    },
    {
      "indent": 3,
      "text": "AES-CBC-MAC is the instantiation of the CBC-MAC construction (defined in [MAC]) using AES as the block cipher. For brevity, we also use \"AES-MAC\" to refer to AES-CBC-MAC. (Note that this is not the same algorithm as AES Cipher-Based Message Authentication Code (AES-CMAC) [RFC4493].)",
      "ja": "AES-CBC-MACは、AESをブロック暗号として使用するCBC-MAC構築の具体化です。簡潔にするため、私たちはAES-CBC-MACを指す際に「AES-MAC」も使用します。（AES Cipher-Based Message Authentication Code（AES-CMAC）[RFC4493]とは異なるアルゴリズムであることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "AES-CBC-MAC is parameterized by the key length, the authentication tag length, and the Initialization Vector (IV) used. For all of these algorithms, the IV is fixed to all zeros. We provide an array of algorithms for various key and tag lengths. The algorithms defined in this document are found in Table 4.",
      "ja": "AES-CBC-MACは、鍵長、認証タグ長、および使用される初期化ベクトル（IV）によってパラメータ化されます。これらのアルゴリズムすべてにおいて、IVはすべてゼロに固定されています。さまざまな鍵長とタグ長のアルゴリズムの配列を提供します。この文書で定義されているアルゴリズムは、表4にあります。"
    },
    {
      "indent": 5,
      "text": "+=========+=======+============+============+==================+\n| Name    | Value | Key Length | Tag Length | Description      |\n+=========+=======+============+============+==================+\n| AES-MAC |   14  |    128     |     64     | AES-MAC 128-bit  |\n| 128/64  |       |            |            | key, 64-bit tag  |\n+---------+-------+------------+------------+------------------+\n| AES-MAC |   15  |    256     |     64     | AES-MAC 256-bit  |\n| 256/64  |       |            |            | key, 64-bit tag  |\n+---------+-------+------------+------------+------------------+\n| AES-MAC |   25  |    128     |    128     | AES-MAC 128-bit  |\n| 128/128 |       |            |            | key, 128-bit tag |\n+---------+-------+------------+------------+------------------+\n| AES-MAC |   26  |    256     |    128     | AES-MAC 256-bit  |\n| 256/128 |       |            |            | key, 128-bit tag |\n+---------+-------+------------+------------+------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 4: AES-MAC Algorithm Values",
      "ja": "表4：AES-MACアルゴリズムの値"
    },
    {
      "indent": 3,
      "text": "Keys may be obtained from either a key structure or a recipient structure. Implementations creating and validating MAC values MUST validate that the key type, key length, and algorithm are correct and appropriate for the entities involved.",
      "ja": "キーは、キー構造または受信者構造から取得できます。MAC値を作成および検証する実装は、キーの種類、キーの長さ、およびアルゴリズムが正確で適切であることを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムで COSE キーを使用する場合、次のチェックが行われます："
    },
    {
      "indent": 6,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"Symmetric\".",
      "ja": "* \"kty\"フィールドは必ず存在し、\"Symmetric\"である必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the \"alg\" field is present, it MUST match the AES-MAC algorithm being used.",
      "ja": "* もし「alg」フィールドが存在する場合、それは使用されているAES-MACアルゴリズムと一致しなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If the \"key_ops\" field is present, it MUST include \"MAC create\" when creating an AES-MAC authentication tag.",
      "ja": "* もし「key_ops」フィールドが存在する場合、AES-MAC認証タグを作成する際には「MAC create」を含める必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the \"key_ops\" field is present, it MUST include \"MAC verify\" when verifying an AES-MAC authentication tag.",
      "ja": "* もし「key_ops」フィールドが存在する場合、AES-MAC認証タグを検証する際には「MAC verify」を含めなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Security Considerations for AES-CBC-MAC",
      "section_title": true,
      "ja": "3.2.1. AES-CBC-MACのセキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "A number of attacks exist against Cipher Block Chaining Message Authentication Code (CBC-MAC) that need to be considered.",
      "ja": "Cipher Block Chaining Message Authentication Code（CBC-MAC）に対する攻撃手法がいくつか存在し、考慮する必要があります。"
    },
    {
      "indent": 6,
      "text": "* A single key must only be used for messages of a fixed or known length. If this is not the case, an attacker will be able to generate a message with a valid tag given two message and tag pairs. This can be addressed by using different keys for messages of different lengths. The current structure mitigates this problem, as a specific encoding structure that includes lengths is built and signed. (CMAC also addresses this issue.)",
      "ja": "* 単一のキーは、固定または既知の長さのメッセージにのみ使用する必要があります。そうでない場合、攻撃者は、2つのメッセージとタグのペアが与えられた場合に有効なタグを持つメッセージを生成できます。これは、異なる長さのメッセージに対して異なるキーを使用することで対処できます。現在の構造は、特定の長さを含むエンコーディング構造が構築され、署名されるため、この問題を軽減します。（CMACもこの問題に対処します。）"
    },
    {
      "indent": 6,
      "text": "* In Cipher Block Chaining (CBC) mode, if the same key is used for both encryption and authentication operations, an attacker can produce messages with a valid authentication code.",
      "ja": "* Cipher Block Chaining（CBC）モードでは、同じキーが暗号化と認証操作の両方に使用される場合、攻撃者は有効な認証コードを持つメッセージを生成できます。"
    },
    {
      "indent": 6,
      "text": "* If the IV can be modified, then messages can be forged. This is addressed by fixing the IV to all zeros.",
      "ja": "* IV が変更可能な場合、メッセージを偽造することができます。これは IV をすべてゼロに固定することで解決されます。"
    },
    {
      "indent": 0,
      "text": "4. Content Encryption Algorithms",
      "section_title": true,
      "ja": "4. コンテンツ暗号化アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Section 8.3 of [RFC9052] contains a generic description of content encryption algorithms. This document defines the identifier and usages for three content encryption algorithms.",
      "ja": "[RFC9052]のセクション8.3には、コンテンツ暗号化アルゴリズムの一般的な説明が含まれています。この文書は、3つのコンテンツ暗号化アルゴリズムの識別子と使用法を定義しています。"
    },
    {
      "indent": 0,
      "text": "4.1. AES-GCM",
      "section_title": true,
      "ja": "4.1. AES-GCM"
    },
    {
      "indent": 3,
      "text": "The Galois/Counter Mode (GCM) mode is a generic AEAD block cipher mode defined in [AES-GCM]. The GCM mode is combined with the AES block encryption algorithm to define an AEAD cipher.",
      "ja": "Galois/Counter Mode（GCM）モードは、[AES-GCM]で定義された一般的なAEADブロック暗号モードです。GCMモードは、AESブロック暗号アルゴリズムと組み合わせてAEAD暗号を定義します。"
    },
    {
      "indent": 3,
      "text": "The GCM mode is parameterized by the size of the authentication tag and the size of the nonce. This document fixes the size of the nonce at 96 bits. The size of the authentication tag is limited to a small set of values. For this document, however, the size of the authentication tag is fixed at 128 bits.",
      "ja": "GCMモードは認証タグのサイズとノンスのサイズでパラメータ化されます。この文書では、ノンスのサイズを96ビットに固定します。認証タグのサイズは一部の値に制限されていますが、この文書では認証タグのサイズを128ビットに固定します。"
    },
    {
      "indent": 3,
      "text": "The set of algorithms defined in this document is in Table 5.",
      "ja": "この文書で定義されたアルゴリズムのセットは、表5にあります。"
    },
    {
      "indent": 6,
      "text": "+=========+=======+==========================================+\n| Name    | Value | Description                              |\n+=========+=======+==========================================+\n| A128GCM |   1   | AES-GCM mode w/ 128-bit key, 128-bit tag |\n+---------+-------+------------------------------------------+\n| A192GCM |   2   | AES-GCM mode w/ 192-bit key, 128-bit tag |\n+---------+-------+------------------------------------------+\n| A256GCM |   3   | AES-GCM mode w/ 256-bit key, 128-bit tag |\n+---------+-------+------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Table 5: Algorithm Values for AES-GCM",
      "ja": "表5：AES-GCMのアルゴリズム値"
    },
    {
      "indent": 3,
      "text": "Keys may be obtained from either a key structure or a recipient structure. Implementations that are encrypting or decrypting MUST validate that the key type, key length, and algorithm are correct and appropriate for the entities involved.",
      "ja": "キーは、キー構造または受信者構造から取得できます。暗号化または復号を行う実装は、キーの種類、長さ、およびアルゴリズムが正しいかつ関連するエンティティに適していることを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムでCOSEキーを使用する場合、次のチェックが行われます："
    },
    {
      "indent": 6,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"Symmetric\".",
      "ja": "* \"kty\"フィールドは必ず存在し、\"Symmetric\"である必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the \"alg\" field is present, it MUST match the AES-GCM algorithm being used.",
      "ja": "* もし「alg」フィールドが存在する場合、それは使用されているAES-GCMアルゴリズムと一致しなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If the \"key_ops\" field is present, it MUST include \"encrypt\" or \"wrap key\" when encrypting.",
      "ja": "* もし \"key_ops\" フィールドが存在する場合、暗号化する際には \"encrypt\" または \"wrap key\" を含める必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the \"key_ops\" field is present, it MUST include \"decrypt\" or \"unwrap key\" when decrypting.",
      "ja": "* \"key_ops\" フィールドが存在する場合、復号化する際には \"decrypt\" または \"unwrap key\" を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Security Considerations for AES-GCM",
      "section_title": true,
      "ja": "4.1.1. AES-GCMのセキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "When using AES-GCM, the following restrictions MUST be enforced:",
      "ja": "AES-GCMを使用する際は、次の制限を必ず遵守する必要があります。"
    },
    {
      "indent": 6,
      "text": "* The key and nonce pair MUST be unique for every message encrypted.",
      "ja": "* メッセージごとに、鍵とナンスのペアは一意である必要があります。"
    },
    {
      "indent": 6,
      "text": "* The total number of messages encrypted for a single key MUST NOT exceed 2^32 [SP800-38D]. An explicit check is required only in environments where it is expected that this limit might be exceeded.",
      "ja": "* 単一のキーで暗号化されたメッセージの総数は、2^32を超えてはなりません[SP800-38D]。この制限を超える可能性がある環境では、明示的なチェックが必要です。"
    },
    {
      "indent": 6,
      "text": "* [RFC8446] contains an analysis on the use of AES-CGM for its environment. Based on that recommendation, one should restrict the number of messages encrypted to 2^24.5.",
      "ja": "* [RFC8446]には、その環境でAES-CGMを使用する際の分析が含まれています。その推奨に基づいて、暗号化されるメッセージの数を2^24.5に制限する必要があります。"
    },
    {
      "indent": 6,
      "text": "* A more recent analysis in [ROBUST] indicates that the number of failed decryptions needs to be taken into account as part of determining when a key rollover is to be done. Following the recommendation in DTLS (Section 4.5.3 of [RFC9147]), the number of failed message decryptions should be limited to 2^36.",
      "ja": "* [ROBUST]におけるより最近の分析では、鍵の切り替えが行われるタイミングの一部として、失敗した復号化の回数を考慮する必要があることが示されています。DTLSの推奨事項（[RFC9147]のセクション4.5.3）に従い、失敗したメッセージの復号化回数は2^36に制限されるべきです。"
    },
    {
      "indent": 3,
      "text": "Consideration was given to supporting smaller tag values; the constrained community would desire tag sizes in the 64-bit range. Such use drastically changes both the maximum message size (generally not an issue) and the number of times that a key can be used. Given that Counter with CBC-MAC (CCM) is the usual mode for constrained environments, restricted modes are not supported.",
      "ja": "制約のあるコミュニティは、64ビットの範囲内でのタグサイズのサポートを希望しています。このような使用は、通常は問題にならない最大メッセージサイズと、キーを使用できる回数を大幅に変更します。制約のある環境では、Counter with CBC-MAC（CCM）が通常のモードであるため、制限されたモードはサポートされていません。"
    },
    {
      "indent": 0,
      "text": "4.2. AES-CCM",
      "section_title": true,
      "ja": "4.2. AES-CCM"
    },
    {
      "indent": 3,
      "text": "CCM is a generic authentication encryption block cipher mode defined in [RFC3610]. The CCM mode is combined with the AES block encryption algorithm to define an AEAD cipher that is commonly used in constrained devices.",
      "ja": "CCMは[RFC3610]で定義された一般的な認証暗号化ブロック暗号モードです。CCMモードはAESブロック暗号アルゴリズムと組み合わせて、制約のあるデバイスで一般的に使用されるAEAD暗号を定義します。"
    },
    {
      "indent": 3,
      "text": "The CCM mode has two parameter choices. The first choice is M, the size of the authentication field. The choice of the value for M involves a trade-off between message growth (from the tag) and the probability that an attacker can undetectably modify a message. The second choice is L, the size of the length field. This value requires a trade-off between the maximum message size and the size of the nonce.",
      "ja": "CCMモードには2つのパラメータ選択肢があります。最初の選択肢はMで、認証フィールドのサイズです。Mの値の選択には、メッセージの成長（タグから）と攻撃者がメッセージを検出不能に変更できる確率とのトレードオフが関係しています。2番目の選択肢はLで、長さフィールドのサイズです。この値は、最大メッセージサイズとナンスのサイズとの間のトレードオフが必要です。"
    },
    {
      "indent": 3,
      "text": "It is unfortunate that the specification for CCM specified L and M as a count of bytes rather than a count of bits. This leads to possible misunderstandings where AES-CCM-8 is frequently used to refer to a version of CCM mode where the size of the authentication is 64 bits and not 8 bits. In most cryptographic algorithm specifications, these values have traditionally been specified as bit counts rather than byte counts. This document will follow the convention of using bit counts so that it is easier to compare the different algorithms presented in this document.",
      "ja": "CCMの仕様でLとMがバイト数ではなくビット数として指定されていることは残念です。これにより、AES-CCM-8が認証のサイズが8ビットではなく64ビットであるCCMモードのバージョンを指すことがよくあります。ほとんどの暗号アルゴリズムの仕様では、これらの値は従来、バイト数ではなくビット数として指定されてきました。この文書では、異なるアルゴリズムを比較しやすくするために、ビット数を使用する慣習に従います。"
    },
    {
      "indent": 3,
      "text": "We define a matrix of algorithms in this document over the values of L and M. Constrained devices are usually operating in situations where they use short messages and want to avoid doing recipient-specific cryptographic operations. This favors smaller values of both L and M. Less-constrained devices will want to be able to use larger messages and are more willing to generate new keys for every operation. This favors larger values of L and M.",
      "ja": "この文書では、LとMの値にわたってアルゴリズムの行列を定義します。 制約のあるデバイスは通常、短いメッセージを使用し、受信者固有の暗号操作を避けたい状況で動作しています。 これは、LとMの両方の値が小さいことを好む傾向があります。 制約の少ないデバイスは、より大きなメッセージを使用したいと考え、各操作ごとに新しいキーを生成することをより積極的に行いたいと考えています。 これは、LとMの値が大きいことを好む傾向があります。"
    },
    {
      "indent": 3,
      "text": "The following values are used for L:",
      "ja": "次の値はLに使用されます。"
    },
    {
      "indent": 3,
      "text": "16 bits (2):",
      "ja": "16 ビット（2）:"
    },
    {
      "indent": 12,
      "text": "This limits messages to 2^16 bytes (64 KiB) in length. This is sufficiently long for messages in the constrained world. The nonce length is 13 bytes allowing for 2^104 possible values of the nonce without repeating.",
      "ja": "このメッセージの長さは2^16バイト（64 KiB）に制限されています。これは制約のある世界のメッセージには十分に長いです。ノンスの長さは13バイトで、繰り返すことなく2^104通りの可能な値を持つことができます。"
    },
    {
      "indent": 3,
      "text": "64 bits (8):",
      "ja": "64 ビット（8）:"
    },
    {
      "indent": 12,
      "text": "This limits messages to 2^64 bytes in length. The nonce length is 7 bytes, allowing for 2^56 possible values of the nonce without repeating.",
      "ja": "このメッセージの長さは2^64バイトに制限されています。ノンスの長さは7バイトで、ノンスの値は2^56通りありますが、繰り返しはありません。"
    },
    {
      "indent": 3,
      "text": "The following values are used for M:",
      "ja": "次の値はMに使用されます。"
    },
    {
      "indent": 3,
      "text": "64 bits (8):",
      "ja": "64 ビット（8）:"
    },
    {
      "indent": 12,
      "text": "This produces a 64-bit authentication tag. This implies that there is a 1 in 2^64 chance that a modified message will authenticate.",
      "ja": "これにより、64ビットの認証タグが生成されます。これは、変更されたメッセージが認証される可能性が2^64分の1であることを意味します。"
    },
    {
      "indent": 3,
      "text": "128 bits (16):",
      "ja": "128 ビット（16）"
    },
    {
      "indent": 12,
      "text": "This produces a 128-bit authentication tag. This implies that there is a 1 in 2^128 chance that a modified message will authenticate.",
      "ja": "これにより、128ビットの認証タグが生成されます。これは、修正されたメッセージが認証される可能性が2^128分の1であることを意味します。"
    },
    {
      "indent": 4,
      "text": "+====================+=======+====+=====+========+===============+\n| Name               | Value | L  | M   |  Key   | Description   |\n|                    |       |    |     | Length |               |\n+====================+=======+====+=====+========+===============+\n| AES-CCM-16-64-128  |   10  | 16 | 64  |  128   | AES-CCM mode  |\n|                    |       |    |     |        | 128-bit key,  |\n|                    |       |    |     |        | 64-bit tag,   |\n|                    |       |    |     |        | 13-byte nonce |\n+--------------------+-------+----+-----+--------+---------------+\n| AES-CCM-16-64-256  |   11  | 16 | 64  |  256   | AES-CCM mode  |\n|                    |       |    |     |        | 256-bit key,  |\n|                    |       |    |     |        | 64-bit tag,   |\n|                    |       |    |     |        | 13-byte nonce |\n+--------------------+-------+----+-----+--------+---------------+\n| AES-CCM-64-64-128  |   12  | 64 | 64  |  128   | AES-CCM mode  |\n|                    |       |    |     |        | 128-bit key,  |\n|                    |       |    |     |        | 64-bit tag,   |\n|                    |       |    |     |        | 7-byte nonce  |\n+--------------------+-------+----+-----+--------+---------------+\n| AES-CCM-64-64-256  |   13  | 64 | 64  |  256   | AES-CCM mode  |\n|                    |       |    |     |        | 256-bit key,  |\n|                    |       |    |     |        | 64-bit tag,   |\n|                    |       |    |     |        | 7-byte nonce  |\n+--------------------+-------+----+-----+--------+---------------+\n| AES-CCM-16-128-128 |   30  | 16 | 128 |  128   | AES-CCM mode  |\n|                    |       |    |     |        | 128-bit key,  |\n|                    |       |    |     |        | 128-bit tag,  |\n|                    |       |    |     |        | 13-byte nonce |\n+--------------------+-------+----+-----+--------+---------------+\n| AES-CCM-16-128-256 |   31  | 16 | 128 |  256   | AES-CCM mode  |\n|                    |       |    |     |        | 256-bit key,  |\n|                    |       |    |     |        | 128-bit tag,  |\n|                    |       |    |     |        | 13-byte nonce |\n+--------------------+-------+----+-----+--------+---------------+\n| AES-CCM-64-128-128 |   32  | 64 | 128 |  128   | AES-CCM mode  |\n|                    |       |    |     |        | 128-bit key,  |\n|                    |       |    |     |        | 128-bit tag,  |\n|                    |       |    |     |        | 7-byte nonce  |\n+--------------------+-------+----+-----+--------+---------------+\n| AES-CCM-64-128-256 |   33  | 64 | 128 |  256   | AES-CCM mode  |\n|                    |       |    |     |        | 256-bit key,  |\n|                    |       |    |     |        | 128-bit tag,  |\n|                    |       |    |     |        | 7-byte nonce  |\n+--------------------+-------+----+-----+--------+---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Table 6: Algorithm Values for AES-CCM",
      "ja": "表6：AES-CCMのアルゴリズム値"
    },
    {
      "indent": 3,
      "text": "Keys may be obtained from either a key structure or a recipient structure. Implementations that are encrypting or decrypting MUST validate that the key type, key length, and algorithm are correct and appropriate for the entities involved.",
      "ja": "キーは、キー構造または受信者構造から取得できます。暗号化または復号を行う実装は、キーの種類、キーの長さ、およびアルゴリズムが正しいかつ関連するエンティティに適していることを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムで COSE キーを使用する場合、次のチェックが行われます。"
    },
    {
      "indent": 6,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"Symmetric\".",
      "ja": "* \"kty\"フィールドは必ず存在し、\"Symmetric\"である必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the \"alg\" field is present, it MUST match the AES-CCM algorithm being used.",
      "ja": "* もし \"alg\" フィールドが存在する場合、それは使用されているAES-CCMアルゴリズムと一致しなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If the \"key_ops\" field is present, it MUST include \"encrypt\" or \"wrap key\" when encrypting.",
      "ja": "* もし「key_ops」フィールドが存在する場合、暗号化する際には「encrypt」または「wrap key」を含める必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the \"key_ops\" field is present, it MUST include \"decrypt\" or \"unwrap key\" when decrypting.",
      "ja": "* \"key_ops\" フィールドが存在する場合、復号化する際には \"decrypt\" または \"unwrap key\" を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Security Considerations for AES-CCM",
      "section_title": true,
      "ja": "4.2.1. AES-CCMのセキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "When using AES-CCM, the following restrictions MUST be enforced:",
      "ja": "AES-CCMを使用する際は、次の制限を必ず遵守する必要があります。"
    },
    {
      "indent": 6,
      "text": "* The key and nonce pair MUST be unique for every message encrypted. Note that the value of L influences the number of unique nonces.",
      "ja": "* キーとナンスのペアは、暗号化されるメッセージごとにユニークである必要があります。Lの値がユニークなナンスの数に影響を与えることに注意してください。"
    },
    {
      "indent": 6,
      "text": "* The total number of times the AES block cipher is used MUST NOT exceed 2^61 operations. This limit is the sum of times the block cipher is used in computing the MAC value and performing stream encryption operations. An explicit check is required only in environments where it is expected that this limit might be exceeded.",
      "ja": "* AESブロック暗号が使用される回数の合計は、2^61回を超えてはなりません。この制限は、MAC値を計算する際やストリーム暗号化操作を実行する際にブロック暗号が使用される回数の合計です。この制限を超える可能性がある環境では、明示的なチェックが必要です。"
    },
    {
      "indent": 6,
      "text": "* [RFC9147] contains an analysis on the use of AES-CCM for its environment. Based on that recommendation, one should restrict the number of messages encrypted to 2^23.",
      "ja": "* [RFC9147]には、その環境でAES-CCMを使用する際の分析が含まれています。その推奨に基づいて、暗号化されるメッセージの数を2^23に制限する必要があります。"
    },
    {
      "indent": 6,
      "text": "* In addition to the number of messages successfully decrypted, the number of failed decryptions needs to be tracked as well. Following the recommendation in DTLS (Section 4.5.3 of [RFC9147]), the number of failed message decryptions should be limited to 2^23.5. If one is using the 64-bit tag, then the limits are significantly smaller if one wants to keep the same integrity limits. A protocol recommending this needs to analyze what level of integrity is acceptable for the smaller tag size. It may be that, to keep the desired level of integrity, one needs to rekey as often as every 2^7 messages.",
      "ja": "* メッセージの復号に成功した数に加えて、失敗した復号の数も追跡する必要があります。DTLSの推奨に従うと、失敗したメッセージの復号の数は2^23.5に制限されるべきです。64ビットのタグを使用している場合、同じ整合性の制限を保持したい場合、制限はかなり小さくなります。このようなプロトコルを推奨する場合、より小さなタグサイズに対して許容できる整合性のレベルを分析する必要があります。望ましい整合性のレベルを維持するためには、2^7メッセージごとに再鍵を行う必要があるかもしれません。"
    },
    {
      "indent": 3,
      "text": "[RFC3610] additionally calls out one other consideration of note. It is possible to do a precomputation attack against the algorithm in cases where portions of the plaintext are highly predictable. This reduces the security of the key size by half. Ways to deal with this attack include adding a random portion to the nonce value and/or increasing the key size used. Using a portion of the nonce for a random value will decrease the number of messages that a single key can be used for. Increasing the key size may require more resources in the constrained device. See Sections 5 and 10 of [RFC3610] for more information.",
      "ja": "[RFC3610]には、注意すべきもう1つの考慮事項があります。平文の一部が非常に予測可能な場合、アルゴリズムに対する事前計算攻撃が可能です。これにより、鍵サイズのセキュリティが半分になります。この攻撃に対処する方法には、ノンス値にランダムな部分を追加することや、使用する鍵サイズを増やすことが含まれます。ノンスの一部をランダムな値に使用すると、単一の鍵で使用できるメッセージの数が減少します。鍵サイズを増やすと、制約のあるデバイスでより多くのリソースが必要になる場合があります。詳細については、[RFC3610]のセクション5と10を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.3. ChaCha20 and Poly1305",
      "section_title": true,
      "ja": "4.3. ChaCha20とPoly1305"
    },
    {
      "indent": 3,
      "text": "ChaCha20 and Poly1305 combined together is an AEAD mode that is defined in [RFC8439]. This is an algorithm defined using a cipher that is not AES and thus would not suffer from any future weaknesses found in AES. These cryptographic functions are designed to be fast in software-only implementations.",
      "ja": "ChaCha20とPoly1305を組み合わせたものは、[RFC8439]で定義されているAEADモードです。これはAESではない暗号を使用して定義されたアルゴリズムであり、したがってAESで見つかった将来の弱点には影響されません。これらの暗号関数は、ソフトウェアのみで高速に動作するように設計されています。"
    },
    {
      "indent": 3,
      "text": "The ChaCha20/Poly1305 AEAD construction defined in [RFC8439] has no parameterization. It takes as inputs a 256-bit key and a 96-bit nonce, as well as the plaintext and additional data, and produces the ciphertext as an output. We define one algorithm identifier for this algorithm in Table 7.",
      "ja": "[RFC8439] で定義されている ChaCha20/Poly1305 AEAD 構築にはパラメータ化がありません。入力として 256 ビットの鍵と 96 ビットのナンス、さらに平文と追加データを取り、暗号文を出力します。このアルゴリズムについては、表 7 で 1 つのアルゴリズム識別子を定義します。"
    },
    {
      "indent": 9,
      "text": "+===================+=======+==========================+\n| Name              | Value | Description              |\n+===================+=======+==========================+\n| ChaCha20/Poly1305 |   24  | ChaCha20/Poly1305 w/     |\n|                   |       | 256-bit key, 128-bit tag |\n+-------------------+-------+--------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "Table 7: Algorithm Value for ChaCha20/Poly1305",
      "ja": "表7: ChaCha20/Poly1305のアルゴリズム値"
    },
    {
      "indent": 3,
      "text": "Keys may be obtained from either a key structure or a recipient structure. Implementations that are encrypting or decrypting MUST validate that the key type, key length, and algorithm are correct and appropriate for the entities involved.",
      "ja": "キーは、キー構造または受信者構造から取得できます。暗号化または復号を行う実装は、キーの種類、キーの長さ、およびアルゴリズムが正しいかつ関連するエンティティに適していることを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムでCOSEキーを使用する場合、以下のチェックが行われます。"
    },
    {
      "indent": 6,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"Symmetric\".",
      "ja": "* \"kty\"フィールドは必ず存在し、\"Symmetric\"である必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the \"alg\" field is present, it MUST match the ChaCha20/Poly1305 algorithm being used.",
      "ja": "* \"alg\" フィールドが存在する場合、使用されている ChaCha20/Poly1305 アルゴリズムと一致している必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the \"key_ops\" field is present, it MUST include \"encrypt\" or \"wrap key\" when encrypting.",
      "ja": "* \"key_ops\" フィールドが存在する場合、暗号化する際には \"encrypt\" または \"wrap key\" を含める必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the \"key_ops\" field is present, it MUST include \"decrypt\" or \"unwrap key\" when decrypting.",
      "ja": "* \"key_ops\" フィールドが存在する場合、復号化する際には \"decrypt\" または \"unwrap key\" を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3.1. Security Considerations for ChaCha20/Poly1305",
      "section_title": true,
      "ja": "4.3.1. ChaCha20/Poly1305のセキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The key and nonce values MUST be a unique pair for every invocation of the algorithm. Nonce counters are considered to be an acceptable way of ensuring that they are unique.",
      "ja": "鍵とナンスの値は、アルゴリズムの各呼び出しに対してユニークなペアでなければなりません。ナンスカウンターは、それらがユニークであることを確実にするための受け入れられる方法と見なされます。"
    },
    {
      "indent": 3,
      "text": "A more recent analysis in [ROBUST] indicates that the number of failed decryptions needs to be taken into account as part of determining when a key rollover is to be done. Following the recommendation in DTLS (Section 4.5.3 of [RFC9147]), the number of failed message decryptions should be limited to 2^36.",
      "ja": "[ROBUST]におけるより最近の分析では、鍵の切り替えが行われるタイミングの一部として、失敗した復号化の回数を考慮する必要があることが示されています。DTLSの推奨に従い（[RFC9147]のセクション4.5.3）、失敗したメッセージの復号回数は2^36に制限されるべきです。"
    },
    {
      "indent": 3,
      "text": "[RFC8446] notes that the (64-bit) record sequence number would wrap before the safety limit is reached for ChaCha20/Poly1305. COSE implementations should not send more than 2^64 messages encrypted using a single ChaCha20/Poly1305 key.",
      "ja": "[RFC8446]は、（64ビットの）レコードシーケンス番号が、ChaCha20/Poly1305の安全限界に達する前にラップする可能性があることに言及しています。COSEの実装では、単一のChaCha20/Poly1305キーを使用して暗号化されたメッセージを2^64件以上送信すべきではありません。"
    },
    {
      "indent": 0,
      "text": "5. Key Derivation Functions (KDFs)",
      "section_title": true,
      "ja": "5. キー導出関数（KDF）"
    },
    {
      "indent": 3,
      "text": "Section 8.4 of [RFC9052] contains a generic description of key derivation functions. This document defines a single context structure and a single KDF. These elements are used for all of the recipient algorithms defined in this document that require a KDF process. These algorithms are defined in Sections 6.1.2, 6.3.1, and 6.4.1.",
      "ja": "[RFC9052]のセクション8.4には、鍵導出関数の一般的な説明が含まれています。この文書では、単一のコンテキスト構造と単一のKDFが定義されています。これらの要素は、KDFプロセスが必要なこの文書で定義されている受信者アルゴリズムすべてに使用されます。これらのアルゴリズムは、セクション6.1.2、6.3.1、および6.4.1で定義されています。"
    },
    {
      "indent": 0,
      "text": "5.1. HMAC-Based Extract-and-Expand Key Derivation Function (HKDF)",
      "section_title": true,
      "ja": "5.1. HMACベースの抽出および拡張キー導出関数（HKDF）"
    },
    {
      "indent": 3,
      "text": "The HKDF key derivation algorithm is defined in [RFC5869] and [HKDF].",
      "ja": "HKDF鍵導出アルゴリズムは[RFC5869]および[HKDF]で定義されています。"
    },
    {
      "indent": 3,
      "text": "The HKDF algorithm takes these inputs:",
      "ja": "HKDFアルゴリズムはこれらの入力を取ります。"
    },
    {
      "indent": 3,
      "text": "secret:",
      "ja": "秘密:"
    },
    {
      "indent": 12,
      "text": "A shared value that is secret. Secrets may be either previously shared or derived from operations like a Diffie-Hellman (DH) key agreement.",
      "ja": "秘密の共有値。秘密は以前に共有されたものであっても、Diffie-Hellman（DH）鍵合意のような操作から派生している可能性があります。"
    },
    {
      "indent": 3,
      "text": "salt:",
      "ja": "塩"
    },
    {
      "indent": 12,
      "text": "An optional value that is used to change the generation process. The salt value can be either public or private. If the salt is public and carried in the message, then the \"salt\" algorithm header parameter defined in Table 9 is used. While [RFC5869] suggests that the length of the salt be the same as the length of the underlying hash value, any positive salt length will improve the security, as different key values will be generated. This parameter is protected by being included in the key computation and does not need to be separately authenticated. The salt value does not need to be unique for every message sent.",
      "ja": "生成プロセスを変更するために使用されるオプションの値。ソルト値は公開または非公開のいずれかにすることができます。ソルトが公開され、メッセージに含まれている場合、表9で定義されている「salt」アルゴリズムヘッダーパラメータが使用されます。[RFC5869]では、ソルトの長さは基礎となるハッシュ値の長さと同じであるべきであると示唆していますが、正のソルトの長さはセキュリティを向上させます。異なるキー値が生成されるためです。このパラメータはキー計算に含まれて保護されており、別途認証する必要はありません。ソルト値は送信されるすべてのメッセージごとに一意である必要はありません。"
    },
    {
      "indent": 3,
      "text": "length:",
      "ja": "長さ"
    },
    {
      "indent": 12,
      "text": "The number of bytes of output that need to be generated.",
      "ja": "生成する必要がある出力のバイト数。"
    },
    {
      "indent": 3,
      "text": "context information:",
      "ja": "context information:"
    },
    {
      "indent": 12,
      "text": "Information that describes the context in which the resulting value will be used. Making this information specific to the context in which the material is going to be used ensures that the resulting material will always be tied to that usage. The context structure defined in Section 5.2 is used by the KDFs in this document.",
      "ja": "結果の値が使用されるコンテキストを説明する情報。この情報を使用される素材のコンテキストに特化させることで、常にその使用に結びついた素材が得られるようになります。この文書では、セクション5.2で定義されたコンテキスト構造がKDFsによって使用されます。"
    },
    {
      "indent": 3,
      "text": "PRF:",
      "ja": "PRF:"
    },
    {
      "indent": 12,
      "text": "The underlying pseudorandom function to be used in the HKDF algorithm. The PRF is encoded into the HKDF algorithm selection.",
      "ja": "HKDFアルゴリズムで使用される基礎となる疑似乱数関数。PRFはHKDFアルゴリズムの選択にエンコードされています。"
    },
    {
      "indent": 3,
      "text": "HKDF is defined to use HMAC as the underlying PRF. However, it is possible to use other functions in the same construct to provide a different KDF that is more appropriate in the constrained world. Specifically, one can use AES-CBC-MAC as the PRF for the expand step, but not for the extract step. When using a good random shared secret of the correct length, the extract step can be skipped. For the AES algorithm versions, the extract step is always skipped.",
      "ja": "HKDFは、基礎としてHMACを使用するように定義されています。ただし、同じ構造で他の関数を使用して、制約のある世界に適した異なるKDFを提供することも可能です。具体的には、AES-CBC-MACをPRFとして使用して、拡張ステップには使用できますが、抽出ステップには使用できません。適切な長さの良好なランダム共有秘密を使用する場合、抽出ステップをスキップできます。AESアルゴリズムのバージョンでは、抽出ステップは常にスキップされます。"
    },
    {
      "indent": 3,
      "text": "The extract step cannot be skipped if the secret is not uniformly random -- for example, if it is the result of an ECDH key agreement step. This implies that the AES HKDF version cannot be used with ECDH. If the extract step is skipped, the \"salt\" value is not used as part of the HKDF functionality.",
      "ja": "抽出ステップはスキップできません。たとえば、ECDH鍵合意ステップの結果である場合など、秘密が一様にランダムでない場合です。これは、AES HKDFバージョンをECDHと一緒に使用できないことを意味します。抽出ステップがスキップされると、「salt」値はHKDF機能の一部として使用されません。"
    },
    {
      "indent": 3,
      "text": "The algorithms defined in this document are found in Table 8.",
      "ja": "この文書で定義されたアルゴリズムは、表8に見つかります。"
    },
    {
      "indent": 7,
      "text": "+==============+===================+========================+\n| Name         | PRF               | Description            |\n+==============+===================+========================+\n| HKDF SHA-256 | HMAC with SHA-256 | HKDF using HMAC        |\n|              |                   | SHA-256 as the PRF     |\n+--------------+-------------------+------------------------+\n| HKDF SHA-512 | HMAC with SHA-512 | HKDF using HMAC        |\n|              |                   | SHA-512 as the PRF     |\n+--------------+-------------------+------------------------+\n| HKDF AES-    | AES-CBC-MAC-128   | HKDF using AES-MAC as  |\n| MAC-128      |                   | the PRF w/ 128-bit key |\n+--------------+-------------------+------------------------+\n| HKDF AES-    | AES-CBC-MAC-256   | HKDF using AES-MAC as  |\n| MAC-256      |                   | the PRF w/ 256-bit key |\n+--------------+-------------------+------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 26,
      "text": "Table 8: HKDF Algorithms",
      "ja": "表8：HKDFアルゴリズム"
    },
    {
      "indent": 4,
      "text": "+======+=======+======+============================+=============+\n| Name | Label | Type | Algorithm                  | Description |\n+======+=======+======+============================+=============+\n| salt | -20   | bstr | direct+HKDF-SHA-256,       | Random salt |\n|      |       |      | direct+HKDF-SHA-512,       |             |\n|      |       |      | direct+HKDF-AES-128,       |             |\n|      |       |      | direct+HKDF-AES-256, ECDH- |             |\n|      |       |      | ES+HKDF-256, ECDH-ES+HKDF- |             |\n|      |       |      | 512, ECDH-SS+HKDF-256,     |             |\n|      |       |      | ECDH-SS+HKDF-512, ECDH-    |             |\n|      |       |      | ES+A128KW, ECDH-ES+A192KW, |             |\n|      |       |      | ECDH-ES+A256KW, ECDH-      |             |\n|      |       |      | SS+A128KW, ECDH-SS+A192KW, |             |\n|      |       |      | ECDH-SS+A256KW             |             |\n+------+-------+------+----------------------------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 9: HKDF Algorithm Parameters",
      "ja": "表9：HKDFアルゴリズムパラメータ"
    },
    {
      "indent": 0,
      "text": "5.2. Context Information Structure",
      "section_title": true,
      "ja": "5.2. 文脈情報構造"
    },
    {
      "indent": 3,
      "text": "The context information structure is used to ensure that the derived keying material is \"bound\" to the context of the transaction. The context information structure used here is based on that defined in [SP800-56A]. By using CBOR for the encoding of the context information structure, we automatically get the same type and length separation of fields that is obtained by the use of ASN.1. This means that there is no need to encode the lengths for the base elements, as it is done by the encoding used in JSON Object Signing and Encryption (JOSE) (Section 4.6.2 of [RFC7518]).",
      "ja": "コンテキスト情報構造は、導出された鍵素材が取引のコンテキストに「結びつく」ことを確認するために使用されます。ここで使用されているコンテキスト情報構造は、[SP800-56A]で定義されているものに基づいています。コンテキスト情報構造のエンコーディングにCBORを使用することで、ASN.1の使用によって得られるフィールドの同じタイプと長さの分離が自動的に得られます。これは、JSON Object Signing and Encryption（JOSE）のエンコーディングで行われる長さのエンコードを行う必要がないことを意味します（[RFC7518]のセクション4.6.2）。"
    },
    {
      "indent": 3,
      "text": "The context information structure refers to PartyU and PartyV as the two parties that are doing the key derivation. Unless the application protocol defines differently, we assign PartyU to the entity that is creating the message and PartyV to the entity that is receiving the message. By defining this association, different keys will be derived for each direction, as the context information is different in each direction.",
      "ja": "コンテキスト情報構造は、キー導出を行っている2つの当事者としてPartyUとPartyVを参照しています。アプリケーションプロトコルが異なる定義を行わない限り、メッセージを作成するエンティティにPartyUを割り当て、メッセージを受信するエンティティにPartyVを割り当てます。この関連付けを定義することで、異なる方向ごとに異なるキーが導出されます。なぜなら、各方向でのコンテキスト情報が異なるためです。"
    },
    {
      "indent": 3,
      "text": "The context structure is built from information that is known to both entities. This information can be obtained from a variety of sources:",
      "ja": "文脈構造は、両者に知られている情報から構築されます。この情報はさまざまなソースから入手できます。"
    },
    {
      "indent": 6,
      "text": "* Fields can be defined by the application. This is commonly used to assign fixed names to parties, but it can be used for other items such as nonces.",
      "ja": "* フィールドはアプリケーションによって定義されることができます。これは一般的に当事者に固定の名前を割り当てるために使用されますが、nonceなどの他のアイテムにも使用できます。"
    },
    {
      "indent": 6,
      "text": "* Fields can be defined by usage of the output. Examples of this are the algorithm and key size that are being generated.",
      "ja": "* 出力の使用によってフィールドを定義することができます。生成されているアルゴリズムやキーサイズの例です。"
    },
    {
      "indent": 6,
      "text": "* Fields can be defined by parameters from the message. We define a set of header parameters in Table 10 that can be used to carry the values associated with the context structure. Examples of this are identities and nonce values. These header parameters are designed to be placed in the unprotected bucket of the recipient structure; they do not need to be in the protected bucket, since they are already included in the cryptographic computation by virtue of being included in the context structure.",
      "ja": "* フィールドはメッセージからのパラメータによって定義されることができます。私たちは、コンテキスト構造に関連する値を運ぶために使用できる一連のヘッダーパラメータを表10に定義します。これには、アイデンティティやナンス値などの例があります。これらのヘッダーパラメータは、受信者構造の保護されていないバケットに配置されるように設計されています。これらは保護されたバケットに含まれる必要はありません。なぜなら、これらはすでにコンテキスト構造に含まれているため、暗号計算に含まれているからです。"
    },
    {
      "indent": 3,
      "text": "+==========+=======+======+===========================+=============+\n| Name     | Label | Type | Algorithm                 | Description |\n+==========+=======+======+===========================+=============+\n| PartyU   | -21   | bstr | direct+HKDF-SHA-256,      | PartyU      |\n| identity |       |      | direct+HKDF-SHA-512,      | identity    |\n|          |       |      | direct+HKDF-AES-128,      | information |\n|          |       |      | direct+HKDF-AES-256,      |             |\n|          |       |      | ECDH-ES+HKDF-256,         |             |\n|          |       |      | ECDH-ES+HKDF-512,         |             |\n|          |       |      | ECDH-SS+HKDF-256,         |             |\n|          |       |      | ECDH-SS+HKDF-512,         |             |\n|          |       |      | ECDH-ES+A128KW,           |             |\n|          |       |      | ECDH-ES+A192KW,           |             |\n|          |       |      | ECDH-ES+A256KW,           |             |\n|          |       |      | ECDH-SS+A128KW,           |             |\n|          |       |      | ECDH-SS+A192KW,           |             |\n|          |       |      | ECDH-SS+A256KW            |             |\n+----------+-------+------+---------------------------+-------------+\n| PartyU   | -22   | bstr | direct+HKDF-SHA-256,      | PartyU      |\n| nonce    |       | /    | direct+HKDF-SHA-512,      | provided    |\n|          |       | int  | direct+HKDF-AES-128,      | nonce       |\n|          |       |      | direct+HKDF-AES-256,      |             |\n|          |       |      | ECDH-ES+HKDF-256,         |             |\n|          |       |      | ECDH-ES+HKDF-512,         |             |\n|          |       |      | ECDH-SS+HKDF-256,         |             |\n|          |       |      | ECDH-SS+HKDF-512,         |             |\n|          |       |      | ECDH-ES+A128KW,           |             |\n|          |       |      | ECDH-ES+A192KW,           |             |\n|          |       |      | ECDH-ES+A256KW,           |             |\n|          |       |      | ECDH-SS+A128KW,           |             |\n|          |       |      | ECDH-SS+A192KW,           |             |\n|          |       |      | ECDH-SS+A256KW            |             |\n+----------+-------+------+---------------------------+-------------+\n| PartyU   | -23   | bstr | direct+HKDF-SHA-256,      | PartyU      |\n| other    |       |      | direct+HKDF-SHA-512,      | other       |\n|          |       |      | direct+HKDF-AES-128,      | provided    |\n|          |       |      | direct+HKDF-AES-256,      | information |\n|          |       |      | ECDH-ES+HKDF-256,         |             |\n|          |       |      | ECDH-ES+HKDF-512,         |             |\n|          |       |      | ECDH-SS+HKDF-256,         |             |\n|          |       |      | ECDH-SS+HKDF-512,         |             |\n|          |       |      | ECDH-ES+A128KW,           |             |\n|          |       |      | ECDH-ES+A192KW,           |             |\n|          |       |      | ECDH-ES+A256KW,           |             |\n|          |       |      | ECDH-SS+A128KW,           |             |\n|          |       |      | ECDH-SS+A192KW,           |             |\n|          |       |      | ECDH-SS+A256KW            |             |\n+----------+-------+------+---------------------------+-------------+\n| PartyV   | -24   | bstr | direct+HKDF-SHA-256,      | PartyV      |\n| identity |       |      | direct+HKDF-SHA-512,      | identity    |\n|          |       |      | direct+HKDF-AES-128,      | information |\n|          |       |      | direct+HKDF-AES-256,      |             |\n|          |       |      | ECDH-ES+HKDF-256,         |             |\n|          |       |      | ECDH-ES+HKDF-512,         |             |\n|          |       |      | ECDH-SS+HKDF-256,         |             |\n|          |       |      | ECDH-SS+HKDF-512,         |             |\n|          |       |      | ECDH-ES+A128KW,           |             |\n|          |       |      | ECDH-ES+A192KW,           |             |\n|          |       |      | ECDH-ES+A256KW,           |             |\n|          |       |      | ECDH-SS+A128KW,           |             |\n|          |       |      | ECDH-SS+A192KW,           |             |\n|          |       |      | ECDH-SS+A256KW            |             |\n+----------+-------+------+---------------------------+-------------+\n| PartyV   | -25   | bstr | direct+HKDF-SHA-256,      | PartyV      |\n| nonce    |       | /    | direct+HKDF-SHA-512,      | provided    |\n|          |       | int  | direct+HKDF-AES-128,      | nonce       |\n|          |       |      | direct+HKDF-AES-256,      |             |\n|          |       |      | ECDH-ES+HKDF-256,         |             |\n|          |       |      | ECDH-ES+HKDF-512,         |             |\n|          |       |      | ECDH-SS+HKDF-256,         |             |\n|          |       |      | ECDH-SS+HKDF-512,         |             |\n|          |       |      | ECDH-ES+A128KW,           |             |\n|          |       |      | ECDH-ES+A192KW,           |             |\n|          |       |      | ECDH-ES+A256KW,           |             |\n|          |       |      | ECDH-SS+A128KW,           |             |\n|          |       |      | ECDH-SS+A192KW,           |             |\n|          |       |      | ECDH-SS+A256KW            |             |\n+----------+-------+------+---------------------------+-------------+\n| PartyV   | -26   | bstr | direct+HKDF-SHA-256,      | PartyV      |\n| other    |       |      | direct+HKDF-SHA-512,      | other       |\n|          |       |      | direct+HKDF-AES-128,      | provided    |\n|          |       |      | direct+HKDF-AES-256,      | information |\n|          |       |      | ECDH-ES+HKDF-256,         |             |\n|          |       |      | ECDH-ES+HKDF-512,         |             |\n|          |       |      | ECDH-SS+HKDF-256,         |             |\n|          |       |      | ECDH-SS+HKDF-512,         |             |\n|          |       |      | ECDH-ES+A128KW,           |             |\n|          |       |      | ECDH-ES+A192KW,           |             |\n|          |       |      | ECDH-ES+A256KW,           |             |\n|          |       |      | ECDH-SS+A128KW,           |             |\n|          |       |      | ECDH-SS+A192KW,           |             |\n|          |       |      | ECDH-SS+A256KW            |             |\n+----------+-------+------+---------------------------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Table 10: Context Algorithm Parameters",
      "ja": "表10：コンテキストアルゴリズムパラメータ"
    },
    {
      "indent": 3,
      "text": "We define a CBOR object to hold the context information. This object is referred to as COSE_KDF_Context. The object is based on a CBOR array type. The fields in the array are:",
      "ja": "私たちは、コンテキスト情報を保持するためのCBORオブジェクトを定義します。このオブジェクトはCOSE_KDF_Contextと呼ばれます。オブジェクトはCBOR配列タイプに基づいています。配列内のフィールドは次のとおりです："
    },
    {
      "indent": 3,
      "text": "AlgorithmID:",
      "ja": "AlgorithmID:"
    },
    {
      "indent": 12,
      "text": "This field indicates the algorithm for which the key material will be used. This normally is either a key wrap algorithm identifier or a content encryption algorithm identifier. The values are from the \"COSE Algorithms\" registry. This field is required to be present. The field exists in the context information so that a different key is generated for each algorithm even if all of the other context information is the same. In practice, this means if algorithm A is broken and thus finding the key is relatively easy, the key derived for algorithm B will not be the same as the key derived for algorithm A.",
      "ja": "このフィールドは、キー素材が使用されるアルゴリズムを示します。通常、これはキーラップアルゴリズム識別子またはコンテンツ暗号化アルゴリズム識別子のいずれかです。値は「COSE Algorithms」レジストリから取得されます。このフィールドは存在する必要があります。このフィールドはコンテキスト情報に存在し、他のすべてのコンテキスト情報が同じでも、異なるアルゴリズムごとに異なるキーが生成されるようになっています。実際には、これはアルゴリズムAが破られてキーを比較的簡単に見つけることができる場合、アルゴリズムB用に導出されたキーはアルゴリズムA用に導出されたキーと同じではないことを意味します。"
    },
    {
      "indent": 3,
      "text": "PartyUInfo:",
      "ja": "PartyUInfo:"
    },
    {
      "indent": 12,
      "text": "This field holds information about PartyU. The PartyUInfo is encoded as a CBOR array. The elements of PartyUInfo are encoded in the order presented below. The elements of the PartyUInfo array are:",
      "ja": "このフィールドにはPartyUに関する情報が格納されています。PartyUInfoはCBOR配列としてエンコードされています。PartyUInfoの要素は以下に示す順序でエンコードされています。PartyUInfo配列の要素は次の通りです。"
    },
    {
      "indent": 6,
      "text": "identity:",
      "ja": "アイデンティティ"
    },
    {
      "indent": 15,
      "text": "This contains the identity information for PartyU. The identities can be assigned in one of two manners. First, a protocol can assign identities based on roles. For example, the roles of \"client\" and \"server\" may be assigned to different entities in the protocol. Each entity would then use the correct label for the data it sends or receives. The second way for a protocol to assign identities is to use a name based on a naming system (i.e., DNS or X.509 names).",
      "ja": "これにはPartyUの識別情報が含まれています。識別情報は2つの方法のいずれかで割り当てることができます。まず、プロトコルは役割に基づいて識別情報を割り当てることができます。たとえば、プロトコル内の異なるエンティティに「クライアント」と「サーバー」の役割を割り当てることができます。その後、各エンティティは送受信するデータに適切なラベルを使用します。プロトコルが識別情報を割り当てるための2番目の方法は、名前に基づいた命名システム（つまり、DNSまたはX.509名）を使用することです。"
    },
    {
      "indent": 15,
      "text": "We define an algorithm parameter, \"PartyU identity\", that can be used to carry identity information in the message. However, identity information is often known as part of the protocol and can thus be inferred rather than made explicit. If identity information is carried in the message, applications SHOULD have a way of validating the supplied identity information. The identity information does not need to be specified and is set to nil in that case.",
      "ja": "私たちは、メッセージ内での識別情報の携帯に使用できるアルゴリズムパラメーター「PartyU identity」を定義します。ただし、識別情報はプロトコルの一部として通常知られており、明示的に作成されるのではなく推論されることがよくあります。識別情報がメッセージに含まれている場合、アプリケーションは提供された識別情報を検証する方法を持っているべきです。その場合、識別情報は指定する必要はなく、nilに設定されます。"
    },
    {
      "indent": 6,
      "text": "nonce:",
      "ja": "nonce:"
    },
    {
      "indent": 15,
      "text": "This contains a nonce value. The nonce can be either implicit from the protocol or carried as a value in the unprotected header bucket.",
      "ja": "これには一意の値が含まれています。ノンスはプロトコルから暗黙的に取得されるか、保護されていないヘッダーバケット内の値として運ばれることがあります。"
    },
    {
      "indent": 15,
      "text": "We define an algorithm parameter, \"PartyU nonce\", that can be used to carry this value in the message; however, the nonce value could be determined by the application and its value obtained in a different manner.",
      "ja": "私たちは、メッセージでこの値を運ぶために使用できるアルゴリズムパラメーター「PartyU nonce」を定義します。ただし、nonceの値はアプリケーションによって決定され、その値は異なる方法で取得される可能性があります。"
    },
    {
      "indent": 15,
      "text": "This option does not need to be specified; if not needed, it is set to nil.",
      "ja": "このオプションは指定する必要はありません。必要ない場合は、nilに設定されます。"
    },
    {
      "indent": 6,
      "text": "other:",
      "ja": "他"
    },
    {
      "indent": 15,
      "text": "This contains other information that is defined by the protocol. This option does not need to be specified; if not needed, it is set to nil.",
      "ja": "このオプションには、プロトコルで定義された他の情報が含まれています。このオプションは指定する必要はありません。必要がない場合は、nilに設定されます。"
    },
    {
      "indent": 3,
      "text": "PartyVInfo:",
      "ja": "PartyVInfo:"
    },
    {
      "indent": 12,
      "text": "This field holds information about PartyV. The content of the structure is the same as for the PartyUInfo but for PartyV.",
      "ja": "このフィールドにはPartyVに関する情報が格納されています。構造体の内容はPartyUInfoと同じですが、PartyV用です。"
    },
    {
      "indent": 3,
      "text": "SuppPubInfo:",
      "ja": "SuppPubInfo:"
    },
    {
      "indent": 12,
      "text": "This field contains public information that is mutually known to both parties, and is encoded as a CBOR array.",
      "ja": "このフィールドには、両当事者に共通に知られている公開情報が含まれており、CBOR配列としてエンコードされています。"
    },
    {
      "indent": 6,
      "text": "keyDataLength:",
      "ja": "keyDataLength:"
    },
    {
      "indent": 15,
      "text": "This is set to the number of bits of the desired output value. This practice means if algorithm A can use two different key lengths, the key derived for the longer key size will not contain the key for the shorter key size as a prefix.",
      "ja": "これは、出力値のビット数に設定されています。この実践は、アルゴリズムAが2つの異なるキー長を使用できる場合、より長いキーサイズ用に導出されたキーには、より短いキーサイズのキーが接頭辞として含まれないことを意味します。"
    },
    {
      "indent": 6,
      "text": "protected:",
      "ja": "保護された"
    },
    {
      "indent": 15,
      "text": "This field contains the protected parameter field. If there are no elements in the \"protected\" field, then use a zero-length bstr.",
      "ja": "このフィールドには保護されたパラメーターフィールドが含まれています。 \"protected\" フィールドに要素がない場合は、長さゼロの bstr を使用してください。"
    },
    {
      "indent": 6,
      "text": "other:",
      "ja": "そのまま出力します。"
    },
    {
      "indent": 15,
      "text": "This field is for free-form data defined by the application. For example, an application could define two different byte strings to be placed here to generate different keys for a data stream versus a control stream. This field is optional and will only be present if the application defines a structure for this information. Applications that define this SHOULD use CBOR to encode the data so that types and lengths are correctly included.",
      "ja": "このフィールドは、アプリケーションによって定義された自由形式のデータ用です。たとえば、アプリケーションは、データストリームと制御ストリーム用の異なるキーを生成するために、ここに配置する2つの異なるバイト文字列を定義できます。このフィールドはオプションであり、アプリケーションがこの情報の構造を定義している場合にのみ存在します。このように定義するアプリケーションは、データをエンコードするために CBOR を使用するべきです。これにより、タイプと長さが正しく含まれます。"
    },
    {
      "indent": 3,
      "text": "SuppPrivInfo:",
      "ja": "SuppPrivInfo:"
    },
    {
      "indent": 12,
      "text": "This field contains private information that is mutually known private information. An example of this information would be a pre-existing shared secret. (This could, for example, be used in combination with an ECDH key agreement to provide a secondary proof of identity.) The field is optional and will only be present if the application defines a structure for this information. Applications that define this SHOULD use CBOR to encode the data so that types and lengths are correctly included.",
      "ja": "このフィールドには、共有された秘密情報である相互に知られた秘密情報が含まれています。この情報の例としては、事前に共有された秘密が挙げられます。（これは、例えばECDH鍵合意と組み合わせて、二次的な身元の証明を提供するために使用できます。）このフィールドはオプションであり、アプリケーションがこの情報の構造を定義している場合にのみ存在します。これを定義するアプリケーションは、データをエンコードするためにCBORを使用するべきであり、タイプと長さが正しく含まれるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "The following CDDL fragment corresponds to the text above.",
      "ja": "次の CDDL フラグメントは、上記のテキストに対応します。"
    },
    {
      "indent": 3,
      "text": "PartyInfo = (\n    identity : bstr / nil,\n    nonce : bstr / int / nil,\n    other : bstr / nil\n)\n\nCOSE_KDF_Context = [\n    AlgorithmID : int / tstr,\n    PartyUInfo : [ PartyInfo ],\n    PartyVInfo : [ PartyInfo ],\n    SuppPubInfo : [\n        keyDataLength : uint,\n        protected : empty_or_serialized_map,\n        ? other : bstr\n    ],\n    ? SuppPrivInfo : bstr\n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6. Content Key Distribution Methods",
      "section_title": true,
      "ja": "6. コンテンツキー配布方法"
    },
    {
      "indent": 3,
      "text": "Section 8.5 of [RFC9052] contains a generic description of content key distribution methods. This document defines the identifiers and usage for a number of content key distribution methods.",
      "ja": "[RFC9052]のセクション8.5には、コンテンツキー配布方法の一般的な説明が含まれています。この文書は、いくつかのコンテンツキー配布方法の識別子と使用法を定義しています。"
    },
    {
      "indent": 0,
      "text": "6.1. Direct Encryption",
      "section_title": true,
      "ja": "6.1. 直接暗号化"
    },
    {
      "indent": 3,
      "text": "A direct encryption algorithm is defined in Section 8.5.1 of [RFC9052]. Information about how to fill in the COSE_Recipient structure is detailed there.",
      "ja": "[RFC9052]のセクション8.5.1で直接暗号化アルゴリズムが定義されています。COSE_Recipient構造体の入力方法に関する情報が詳細に記載されています。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Direct Key",
      "section_title": true,
      "ja": "6.1.1. 直接キー"
    },
    {
      "indent": 3,
      "text": "This recipient algorithm is the simplest; the identified key is directly used as the key for the next layer down in the message. There are no algorithm parameters defined for this algorithm. The algorithm identifier value is assigned in Table 11.",
      "ja": "この受信者アルゴリズムは、最も単純なものです。識別されたキーは、メッセージの下位レイヤーで直接使用されます。このアルゴリズムには定義されたアルゴリズムパラメータはありません。アルゴリズム識別子の値は、表11に割り当てられます。"
    },
    {
      "indent": 3,
      "text": "When this algorithm is used, the \"protected\" field MUST be zero length. The key type MUST be \"Symmetric\".",
      "ja": "このアルゴリズムが使用される場合、\"protected\" フィールドはゼロ長でなければなりません。キーの種類は「対称的」でなければなりません。"
    },
    {
      "indent": 6,
      "text": "+========+=======+============================================+\n| Name   | Value | Description                                |\n+========+=======+============================================+\n| direct |   -6  | Direct use of content encryption key (CEK) |\n+--------+-------+--------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": "Table 11: Direct Key",
      "ja": "表11：直接キー"
    },
    {
      "indent": 0,
      "text": "6.1.1.1. Security Considerations for Direct Key",
      "section_title": true,
      "ja": "6.1.1.1. 直接キーのセキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This recipient algorithm has several potential problems that need to be considered:",
      "ja": "この受信者アルゴリズムには考慮すべき潜在的な問題がいくつかあります。"
    },
    {
      "indent": 6,
      "text": "* These keys need to have some method of being regularly updated over time. All of the content encryption algorithms specified in this document have limits on how many times a key can be used without significant loss of security.",
      "ja": "* これらのキーは、時間の経過とともに定期的に更新される必要があります。この文書で指定されたすべてのコンテンツ暗号化アルゴリズムには、セキュリティの著しい損失なしにキーを使用できる回数に制限があります。"
    },
    {
      "indent": 6,
      "text": "* These keys need to be dedicated to a single algorithm. There have been a number of attacks developed over time when a single key is used for multiple different algorithms. One example of this is the use of a single key for both the CBC encryption mode and the CBC-MAC authentication mode.",
      "ja": "* これらのキーは1つのアルゴリズムに専用される必要があります。1つのキーが複数の異なるアルゴリズムに使用されると、時間の経過とともにいくつかの攻撃が開発されてきました。その1つの例は、CBC暗号化モードとCBC-MAC認証モードの両方に同じキーを使用することです。"
    },
    {
      "indent": 6,
      "text": "* Breaking one message means all messages are broken. If an adversary succeeds in determining the key for a single message, then the key for all messages is also determined.",
      "ja": "* 1つのメッセージが壊れると、すべてのメッセージが壊れます。敵が1つのメッセージの鍵を特定に成功した場合、すべてのメッセージの鍵も特定されます。"
    },
    {
      "indent": 0,
      "text": "6.1.2. Direct Key with KDF",
      "section_title": true,
      "ja": "6.1.2. KDFとの直接キー"
    },
    {
      "indent": 3,
      "text": "These recipient algorithms take a common shared secret between the two parties and apply the HKDF function (Section 5.1), using the context structure defined in Section 5.2 to transform the shared secret into the CEK. The \"protected\" field can be of nonzero length. Either the \"salt\" parameter for HKDF (Table 9) or the \"PartyU nonce\" parameter for the context structure (Table 10) MUST be present (both can be present if desired). The value in the \"salt\"/\"nonce\" parameter can be generated either randomly or deterministically. The requirement is that it be a unique value for the shared secret in question.",
      "ja": "これらの受信者アルゴリズムは、2つの当事者間で共有された共通の秘密を取り、セクション5.2で定義されたコンテキスト構造を使用して、共有された秘密をCEKに変換するためにHKDF関数（セクション5.1）を適用します。 \"protected\"フィールドはゼロでない長さにすることができます。 HKDFのための「salt」パラメータ（表9）またはコンテキスト構造の「PartyU nonce」パラメータ（表10）のいずれかが存在している必要があります（必要に応じて両方が存在しても構いません）。 \"salt\" / \"nonce\"パラメータの値はランダムに生成されるか、決定論的に生成されるかのいずれかです。要件は、それが問題の共有された秘密に対して一意の値であることです。"
    },
    {
      "indent": 3,
      "text": "If the salt/nonce value is generated randomly, then it is suggested that the length of the random value be the same length as the output of the hash function underlying HKDF. While there is no way to guarantee that it will be unique, there is a high probability that it will be unique. If the salt/nonce value is generated deterministically, it can be guaranteed to be unique, and thus there is no length requirement.",
      "ja": "塩/ナンス値がランダムに生成される場合、そのランダム値の長さはHKDFのハッシュ関数の出力と同じ長さであることが推奨されます。一意であることを保証する方法はありませんが、高い確率で一意である可能性があります。塩/ナンス値が決定論的に生成される場合、一意であることが保証されるため、長さの要件はありません。"
    },
    {
      "indent": 3,
      "text": "A new IV must be used for each message if the same key is used. The IV can be modified in a predictable manner, a random manner, or an unpredictable manner (e.g., encrypting a counter).",
      "ja": "同じキーを使用する場合は、各メッセージに新しいIVを使用する必要があります。IVは予測可能な方法、ランダムな方法、または予測不可能な方法（例：カウンターを暗号化する）で変更できます。"
    },
    {
      "indent": 3,
      "text": "The IV used for a key can also be generated using the same HKDF functionality used to generate the key. If HKDF is used for generating the IV, the algorithm identifier is set to 34 (\"IV-GENERATION\").",
      "ja": "鍵に使用されるIVも、鍵を生成するために使用されるHKDF機能を使用して生成することができます。IVを生成するためにHKDFが使用される場合、アルゴリズム識別子は34（「IV-GENERATION」）に設定されます。"
    },
    {
      "indent": 3,
      "text": "The set of algorithms defined in this document can be found in Table 12.",
      "ja": "この文書で定義されたアルゴリズムのセットは、表12にあります。"
    },
    {
      "indent": 3,
      "text": "+=====================+=======+==============+=====================+\n| Name                | Value | KDF          | Description         |\n+=====================+=======+==============+=====================+\n| direct+HKDF-SHA-256 |  -10  | HKDF SHA-256 | Shared secret w/    |\n|                     |       |              | HKDF and SHA-256    |\n+---------------------+-------+--------------+---------------------+\n| direct+HKDF-SHA-512 |  -11  | HKDF SHA-512 | Shared secret w/    |\n|                     |       |              | HKDF and SHA-512    |\n+---------------------+-------+--------------+---------------------+\n| direct+HKDF-AES-128 |  -12  | HKDF AES-    | Shared secret w/    |\n|                     |       | MAC-128      | AES-MAC 128-bit key |\n+---------------------+-------+--------------+---------------------+\n| direct+HKDF-AES-256 |  -13  | HKDF AES-    | Shared secret w/    |\n|                     |       | MAC-256      | AES-MAC 256-bit key |\n+---------------------+-------+--------------+---------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Table 12: Direct Key with KDF",
      "ja": "表12：KDFを使用したダイレクトキー"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムでCOSEキーを使用する場合、次のチェックが行われます："
    },
    {
      "indent": 6,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"Symmetric\".",
      "ja": "* \"kty\"フィールドは必ず存在し、\"Symmetric\"である必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the \"alg\" field is present, it MUST match the algorithm being used.",
      "ja": "* もし \"alg\" フィールドが存在する場合、それは使用されているアルゴリズムと一致していなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If the \"key_ops\" field is present, it MUST include \"derive key\" or \"derive bits\".",
      "ja": "* \"key_ops\" フィールドが存在する場合、\"derive key\" または \"derive bits\" を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1.2.1. Security Considerations for Direct Key with KDF",
      "section_title": true,
      "ja": "6.1.2.1. 直接鍵とKDFのセキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The shared secret needs to have some method of being regularly updated over time. The shared secret forms the basis of trust. Although not used directly, it should still be subject to scheduled rotation.",
      "ja": "共有された秘密は、時間の経過とともに定期的に更新される方法を持つ必要があります。共有された秘密は信頼の基盤を形成します。直接使用されない場合でも、定期的なローテーションの対象とすべきです。"
    },
    {
      "indent": 3,
      "text": "These methods do not provide for perfect forward secrecy, as the same shared secret is used for all of the keys generated; however, if the key for any single message is discovered, only the message or series of messages using that derived key are compromised. A new key derivation step will generate a new key that requires the same amount of work to get the key.",
      "ja": "これらの方法は完全な前方秘匿性を提供しませんが、生成されたすべてのキーに同じ共有秘密が使用されます。ただし、単一のメッセージのキーが発見された場合、その派生キーを使用するメッセージまたは一連のメッセージのみが危険にさらされます。新しいキー派生ステップにより、同じ作業量でキーを取得する必要がある新しいキーが生成されます。"
    },
    {
      "indent": 0,
      "text": "6.2. Key Wrap",
      "section_title": true,
      "ja": "6.2. キーのラップ"
    },
    {
      "indent": 3,
      "text": "Key wrap is defined in Section 8.5.2 of [RFC9052]. Information about how to fill in the COSE_Recipient structure is detailed there.",
      "ja": "キーのラップは[RFC9052]のセクション8.5.2で定義されています。COSE_Recipient構造体の入力方法に関する情報がそこに詳細に記載されています。"
    },
    {
      "indent": 0,
      "text": "6.2.1. AES Key Wrap",
      "section_title": true,
      "ja": "6.2.1. AESキーのラップ"
    },
    {
      "indent": 3,
      "text": "The AES Key Wrap algorithm is defined in [RFC3394]. This algorithm uses an AES key to wrap a value that is a multiple of 64 bits. As such, it can be used to wrap a key for any of the content encryption algorithms defined in this document. The algorithm requires a single fixed parameter, the initial value. This is fixed to the value specified in Section 2.2.3.1 of [RFC3394]. There are no public key parameters that vary on a per-invocation basis. The protected header bucket MUST be empty.",
      "ja": "AESキー包装アルゴリズムは[RFC3394]で定義されています。このアルゴリズムは、64ビットの倍数である値を包むためにAESキーを使用します。そのため、このドキュメントで定義されているコンテンツ暗号化アルゴリズムのいずれかのキーを包むために使用できます。このアルゴリズムには、1つの固定パラメータ、初期値が必要です。これは[RFC3394]のセクション2.2.3.1で指定された値に固定されています。呼び出し毎に異なる公開鍵パラメータはありません。保護されたヘッダーバケットは空でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Keys may be obtained from either a key structure or a recipient structure. Implementations that are encrypting or decrypting MUST validate that the key type, key length, and algorithm are correct and appropriate for the entities involved.",
      "ja": "キーは、キー構造または受信者構造から取得できます。暗号化または復号を行う実装は、キーの種類、長さ、およびアルゴリズムが正しいかつ関連するエンティティに適していることを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムでCOSEキーを使用する場合、以下のチェックが行われます。"
    },
    {
      "indent": 6,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"Symmetric\".",
      "ja": "* \"kty\"フィールドは必ず存在し、\"Symmetric\"である必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the \"alg\" field is present, it MUST match the AES Key Wrap algorithm being used.",
      "ja": "* もし「alg」フィールドが存在する場合、それは使用されているAES Key Wrapアルゴリズムと一致しなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If the \"key_ops\" field is present, it MUST include \"encrypt\" or \"wrap key\" when encrypting.",
      "ja": "* \"key_ops\" フィールドが存在する場合、暗号化する際には \"encrypt\" または \"wrap key\" を含める必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the \"key_ops\" field is present, it MUST include \"decrypt\" or \"unwrap key\" when decrypting.",
      "ja": "* \"key_ops\" フィールドが存在する場合、復号化する際には \"decrypt\" または \"unwrap key\" を含める必要があります。"
    },
    {
      "indent": 8,
      "text": "+========+=======+==========+=============================+\n| Name   | Value | Key Size | Description                 |\n+========+=======+==========+=============================+\n| A128KW |   -3  |   128    | AES Key Wrap w/ 128-bit key |\n+--------+-------+----------+-----------------------------+\n| A192KW |   -4  |   192    | AES Key Wrap w/ 192-bit key |\n+--------+-------+----------+-----------------------------+\n| A256KW |   -5  |   256    | AES Key Wrap w/ 256-bit key |\n+--------+-------+----------+-----------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Table 13: AES Key Wrap Algorithm Values",
      "ja": "表13：AESキー包装アルゴリズムの値"
    },
    {
      "indent": 0,
      "text": "6.2.1.1. Security Considerations for AES Key Wrap",
      "section_title": true,
      "ja": "6.2.1.1. AESキーのラップのセキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The shared secret needs to have some method of being regularly updated over time. The shared secret is the basis of trust.",
      "ja": "共有された秘密は、時間の経過とともに定期的に更新される方法が必要です。共有された秘密は信頼の基盤です。"
    },
    {
      "indent": 0,
      "text": "6.3. Direct Key Agreement",
      "section_title": true,
      "ja": "6.3. 直接鍵合意"
    },
    {
      "indent": 3,
      "text": "Direct Key Agreement is defined in Section 8.5.4 of [RFC9052]. Information about how to fill in the COSE_Recipient structure is detailed there.",
      "ja": "Direct Key Agreementは[RFC9052]のセクション8.5.4で定義されています。COSE_Recipient構造体の記入方法に関する情報がそこに詳細に記載されています。"
    },
    {
      "indent": 0,
      "text": "6.3.1. Direct ECDH",
      "section_title": true,
      "ja": "6.3.1. 直接ECDH"
    },
    {
      "indent": 3,
      "text": "The mathematics for ECDH can be found in [RFC6090]. In this document, the algorithm is extended to be used with the two curves defined in [RFC7748].",
      "ja": "ECDHの数学は[RFC6090]にあります。この文書では、アルゴリズムが[RFC7748]で定義された2つの曲線と共に使用されるように拡張されています。"
    },
    {
      "indent": 3,
      "text": "ECDH is parameterized by the following:",
      "ja": "ECDHは以下でパラメータ化されます。"
    },
    {
      "indent": 3,
      "text": "Curve Type/Curve:",
      "ja": "曲線タイプ/曲線:"
    },
    {
      "indent": 12,
      "text": "The curve selected controls not only the size of the shared secret, but the mathematics for computing the shared secret. The curve selected also controls how a point in the curve is represented and what happens for the identity points on the curve. In this specification, we allow for a number of different curves to be used. A set of curves is defined in Table 18.",
      "ja": "選択された曲線は、共有秘密のサイズだけでなく、共有秘密を計算するための数学を制御します。選択された曲線はまた、曲線上の点の表現方法や、曲線上の単位点に対する動作も制御します。この仕様では、複数の異なる曲線を使用することが許可されています。曲線のセットは、表18に定義されています。"
    },
    {
      "indent": 12,
      "text": "The math used to obtain the computed secret is based on the curve selected and not on the ECDH algorithm. For this reason, a new algorithm does not need to be defined for each of the curves.",
      "ja": "計算された秘密を取得するために使用される数学は、選択された曲線に基づいており、ECDHアルゴリズムに基づいていません。このため、各曲線ごとに新しいアルゴリズムを定義する必要はありません。"
    },
    {
      "indent": 3,
      "text": "Computed Secret to Shared Secret:",
      "ja": "計算された秘密を共有秘密に変換します。"
    },
    {
      "indent": 12,
      "text": "Once the computed secret is known, the resulting value needs to be converted to a byte string to run the KDF. The x-coordinate is used for all of the curves defined in this document. For curves X25519 and X448, the resulting value is used directly, as it is a byte string of a known length. For the P-256, P-384, and P-521 curves, the x-coordinate is run through the Integer-to-Octet-String primitive (I2OSP) function defined in [RFC8017], using the same computation for n as is defined in Section 2.1.",
      "ja": "計算された秘密がわかったら、結果の値をバイト文字列に変換してKDFを実行する必要があります。このドキュメントで定義されたすべての曲線についてx座標が使用されます。X25519およびX448の曲線では、結果の値が既知の長さのバイト文字列であるため、直接使用されます。P-256、P-384、およびP-521の曲線では、x座標は、[RFC8017]で定義された整数からオクテット文字列への変換（I2OSP）関数を使用して、セクション2.1で定義されているnに対して同じ計算が行われます。"
    },
    {
      "indent": 3,
      "text": "Ephemeral-Static or Static-Static:",
      "ja": "Ephemeral-StaticまたはStatic-Static:"
    },
    {
      "indent": 12,
      "text": "The key agreement process may be done using either a static or an ephemeral key for the sender's side. When using ephemeral keys, the sender MUST generate a new ephemeral key for every key agreement operation. The ephemeral key is placed in the \"ephemeral key\" parameter and MUST be present for all algorithm identifiers that use ephemeral keys. When using static keys, the sender MUST either generate a new random value or create a unique value for use as a KDF input. For the KDFs used, this means that either the \"salt\" parameter for HKDF (Table 9) or the \"PartyU nonce\" parameter for the context structure (Table 10) MUST be present (both can be present if desired). The value in the parameter MUST be unique for the pair of keys being used. It is acceptable to use a global counter that is incremented for every Static-Static operation and use the resulting value. Care must be taken that the counter is saved to permanent storage in a way that avoids reuse of that counter value. When using static keys, the static key should be identified to the recipient. The static key can be identified by providing either the key (\"static key\") or a key identifier for the static key (\"static key id\"). Both of these header parameters are defined in Table 15.",
      "ja": "鍵合意プロセスは、送信側に対して静的キーまたはエフェメラルキーのいずれかを使用して行うことができます。エフェメラルキーを使用する場合、送信者はすべての鍵合意操作ごとに新しいエフェメラルキーを生成する必要があります。エフェメラルキーは「ephemeral key」パラメータに配置され、エフェメラルキーを使用するすべてのアルゴリズム識別子に存在する必要があります。静的キーを使用する場合、送信者は新しいランダム値を生成するか、KDF入力として使用するための一意の値を作成する必要があります。使用されるKDFに対して、HKDF（表9）の「salt」パラメータまたはコンテキスト構造（表10）の「PartyU nonce」パラメータのいずれかが存在する必要があります（必要に応じて両方が存在することもできます）。パラメータ内の値は使用される鍵のペアに対して一意である必要があります。静的キーを使用する場合、静的キーは受信者に識別されるべきです。静的キーは、キー（「static key」）または静的キーのためのキー識別子（「static key id」）のいずれかを提供することで識別できます。これらのヘッダーパラメータは、表15で定義されています。"
    },
    {
      "indent": 3,
      "text": "Key Derivation Algorithm:",
      "ja": "鍵導出アルゴリズム:"
    },
    {
      "indent": 12,
      "text": "The result of an ECDH key agreement process does not provide a uniformly random secret. As such, it needs to be run through a KDF in order to produce a usable key. Processing the secret through a KDF also allows for the introduction of context material: how the key is going to be used and one-time material for Static-Static key agreement. All of the algorithms defined in this document use one of the HKDF algorithms defined in Section 5.1 with the context structure defined in Section 5.2.",
      "ja": "ECDH鍵合意プロセスの結果は一様ランダムな秘密を提供しません。そのため、使用可能な鍵を生成するためにKDFを通過する必要があります。秘密をKDFを通じて処理することは、鍵の使用方法やStatic-Static鍵合意のための一度限りの素材を導入することも可能にします。この文書で定義されているすべてのアルゴリズムは、セクション5.1で定義されているHKDFアルゴリズムのいずれかを使用し、セクション5.2で定義されているコンテキスト構造を使用します。"
    },
    {
      "indent": 3,
      "text": "Key Wrap Algorithm:",
      "ja": "キー包装アルゴリズム:"
    },
    {
      "indent": 12,
      "text": "No key wrap algorithm is used. This is represented in Table 14 as \"none\". The key size for the context structure is the content layer encryption algorithm size.",
      "ja": "キー ラップ アルゴリズムは使用されません。これは「なし」として表14に表されています。コンテキスト構造のキー サイズはコンテンツ レイヤーの暗号化アルゴリズムのサイズです。"
    },
    {
      "indent": 3,
      "text": "COSE does not have an Ephemeral-Ephemeral version defined. The reason for this is that COSE is not an online protocol by itself and thus does not have a method of establishing ephemeral secrets on both sides. The expectation is that a protocol would establish the secrets for both sides, and then they would be used as Static-Static for the purposes of COSE, or that the protocol would generate a shared secret and a direct encryption would be used.",
      "ja": "COSEにはエフェメラル-エフェメラルバージョンが定義されていません。これは、COSE自体がオンラインプロトコルではなく、したがって両側でエフェメラルシークレットを確立する方法がないためです。期待されるのは、プロトコルが両側のシークレットを確立し、それらがCOSEの目的のためにStatic-Staticとして使用されるか、プロトコルが共有シークレットを生成し、直接暗号化が使用されることです。"
    },
    {
      "indent": 3,
      "text": "The set of direct ECDH algorithms defined in this document is found in Table 14.",
      "ja": "この文書で定義されている直接ECDHアルゴリズムのセットは、表14にあります。"
    },
    {
      "indent": 3,
      "text": "+==========+=======+=========+==================+====+==============+\n| Name     | Value | KDF     | Ephemeral-Static |Key | Description  |\n|          |       |         |                  |Wrap|              |\n+==========+=======+=========+==================+====+==============+\n| ECDH-ES  | -25   | HKDF -- | yes              |none| ECDH ES w/   |\n| +        |       | SHA-256 |                  |    | HKDF --      |\n| HKDF-256 |       |         |                  |    | generate     |\n|          |       |         |                  |    | key          |\n|          |       |         |                  |    | directly     |\n+----------+-------+---------+------------------+----+--------------+\n| ECDH-ES  | -26   | HKDF -- | yes              |none| ECDH ES w/   |\n| +        |       | SHA-512 |                  |    | HKDF --      |\n| HKDF-512 |       |         |                  |    | generate     |\n|          |       |         |                  |    | key          |\n|          |       |         |                  |    | directly     |\n+----------+-------+---------+------------------+----+--------------+\n| ECDH-SS  | -27   | HKDF -- | no               |none| ECDH SS w/   |\n| +        |       | SHA-256 |                  |    | HKDF --      |\n| HKDF-256 |       |         |                  |    | generate     |\n|          |       |         |                  |    | key          |\n|          |       |         |                  |    | directly     |\n+----------+-------+---------+------------------+----+--------------+\n| ECDH-SS  | -28   | HKDF -- | no               |none| ECDH SS w/   |\n| +        |       | SHA-512 |                  |    | HKDF --      |\n| HKDF-512 |       |         |                  |    | generate     |\n|          |       |         |                  |    | key          |\n|          |       |         |                  |    | directly     |\n+----------+-------+---------+------------------+----+--------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Table 14: ECDH Algorithm Values",
      "ja": "表14：ECDHアルゴリズムの値"
    },
    {
      "indent": 4,
      "text": "+===========+=======+==========+===================+=============+\n| Name      | Label | Type     | Algorithm         | Description |\n+===========+=======+==========+===================+=============+\n| ephemeral | -1    | COSE_Key | ECDH-ES+HKDF-256, | Ephemeral   |\n| key       |       |          | ECDH-ES+HKDF-512, | public key  |\n|           |       |          | ECDH-ES+A128KW,   | for the     |\n|           |       |          | ECDH-ES+A192KW,   | sender      |\n|           |       |          | ECDH-ES+A256KW    |             |\n+-----------+-------+----------+-------------------+-------------+\n| static    | -2    | COSE_Key | ECDH-SS+HKDF-256, | Static      |\n| key       |       |          | ECDH-SS+HKDF-512, | public key  |\n|           |       |          | ECDH-SS+A128KW,   | for the     |\n|           |       |          | ECDH-SS+A192KW,   | sender      |\n|           |       |          | ECDH-SS+A256KW    |             |\n+-----------+-------+----------+-------------------+-------------+\n| static    | -3    | bstr     | ECDH-SS+HKDF-256, | Static      |\n| key id    |       |          | ECDH-SS+HKDF-512, | public key  |\n|           |       |          | ECDH-SS+A128KW,   | identifier  |\n|           |       |          | ECDH-SS+A192KW,   | for the     |\n|           |       |          | ECDH-SS+A256KW    | sender      |\n+-----------+-------+----------+-------------------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Table 15: ECDH Algorithm Parameters",
      "ja": "表15：ECDHアルゴリズムパラメータ"
    },
    {
      "indent": 3,
      "text": "This document defines these algorithms to be used with the curves P-256, P-384, P-521, X25519, and X448. Implementations MUST verify that the key type and curve are correct. Different curves are restricted to different key types. Implementations MUST verify that the curve and algorithm are appropriate for the entities involved.",
      "ja": "この文書は、曲線P-256、P-384、P-521、X25519、およびX448と使用するためにこれらのアルゴリズムを定義します。実装は、キーの種類と曲線が正しいことを検証する必要があります。異なる曲線は異なるキーの種類に制限されています。実装は、曲線とアルゴリズムが関係するエンティティに適していることを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムでCOSEキーを使用する場合、以下のチェックが行われます。"
    },
    {
      "indent": 6,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"EC2\" or \"OKP\".",
      "ja": "* \"kty\"フィールドは必ず存在し、\"EC2\"または\"OKP\"でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If the \"alg\" field is present, it MUST match the key agreement algorithm being used.",
      "ja": "* もし「alg」フィールドが存在する場合、それは使用されている鍵合意アルゴリズムと一致しなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If the \"key_ops\" field is present, it MUST include \"derive key\" or \"derive bits\" for the private key.",
      "ja": "* もし「key_ops」フィールドが存在する場合、それは必ず「derive key」または「derive bits」を含まなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If the \"key_ops\" field is present, it MUST be empty for the public key.",
      "ja": "* もし \"key_ops\" フィールドが存在する場合、公開鍵の場合は空でなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.3.1.1. Security Considerations for ECDH",
      "section_title": true,
      "ja": "6.3.1.1. ECDHのセキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "There is a method of checking that points provided from external entities are valid. For the \"EC2\" key format, this can be done by checking that the x and y values form a point on the curve. For the \"OKP\" format, there is no simple way to perform point validation.",
      "ja": "外部エンティティから提供されたポイントが有効であるかを確認する方法があります。 \"EC2\"キー形式の場合、xとyの値が曲線上のポイントを形成しているかどうかを確認することができます。 \"OKP\"形式の場合、ポイントの検証を行う簡単な方法はありません。"
    },
    {
      "indent": 3,
      "text": "Consideration was given to requiring that the public keys of both entities be provided as part of the key derivation process (as recommended in Section 6.1 of [RFC7748]). This was not done, because COSE is used in a store-and-forward format rather than in online key exchange. In order for this to be a problem, either the receiver public key has to be chosen maliciously or the sender has to be malicious. In either case, all security evaporates anyway.",
      "ja": "両者の公開鍵が鍵導出プロセスの一部として提供されることを要求することが検討されました（[RFC7748]のセクション6.1で推奨されています）。これは行われませんでした。なぜなら、COSEはオンライン鍵交換ではなく、ストア・アンド・フォワード形式で使用されているからです。これが問題になるためには、受信者の公開鍵が悪意を持って選択されるか、送信者が悪意を持っている必要があります。いずれの場合も、すべてのセキュリティが消失します。"
    },
    {
      "indent": 3,
      "text": "A proof of possession of the private key associated with the public key is recommended when a key is moved from untrusted to trusted (either by the end user or by the entity that is responsible for making trust statements on keys).",
      "ja": "公開鍵に関連付けられた秘密鍵の所有を証明することが推奨されます。鍵が信頼されていない状態から信頼された状態に移動する際（最終ユーザーまたは鍵に関する信頼ステートメントを行うエンティティによって）、"
    },
    {
      "indent": 0,
      "text": "6.4. Key Agreement with Key Wrap",
      "section_title": true,
      "ja": "6.4. キー合意とキーラップ"
    },
    {
      "indent": 3,
      "text": "Key Agreement with Key Wrap is defined in Section 8.5.5 of [RFC9052]. Information about how to fill in the COSE_Recipient structure is detailed there.",
      "ja": "[RFC9052]のセクション8.5.5でKey Agreement with Key Wrapが定義されています。COSE_Recipient構造体の記入方法に関する情報がそこに詳細に記載されています。"
    },
    {
      "indent": 0,
      "text": "6.4.1. ECDH with Key Wrap",
      "section_title": true,
      "ja": "6.4.1. ECDHとキーラップ"
    },
    {
      "indent": 3,
      "text": "These algorithms are defined in Table 16.",
      "ja": "これらのアルゴリズムは表16に定義されています。"
    },
    {
      "indent": 3,
      "text": "ECDH with Key Agreement is parameterized by the same header parameters as for ECDH; see Section 6.3.1, with the following modifications:",
      "ja": "ECDH with Key Agreementは、ECDHと同じヘッダーパラメーターでパラメータ化されます。セクション6.3.1を参照してください。以下の修正が加えられています。"
    },
    {
      "indent": 3,
      "text": "Key Wrap Algorithm:",
      "ja": "キー包装アルゴリズム:"
    },
    {
      "indent": 12,
      "text": "Any of the key wrap algorithms defined in Section 6.2 are supported. The size of the key used for the key wrap algorithm is fed into the KDF. The set of identifiers is found in Table 16.",
      "ja": "セクション6.2で定義されたキーラップアルゴリズムのいずれもサポートされています。キーラップアルゴリズムに使用されるキーのサイズがKDFに供給されます。識別子のセットは表16にあります。"
    },
    {
      "indent": 3,
      "text": "+=========+=====+=========+==================+======+==============+\n| Name    |Value| KDF     | Ephemeral-Static |Key   | Description  |\n|         |     |         |                  |Wrap  |              |\n+=========+=====+=========+==================+======+==============+\n| ECDH-ES |-29  | HKDF -- | yes              |A128KW| ECDH ES w/   |\n| +       |     | SHA-256 |                  |      | HKDF and AES |\n| A128KW  |     |         |                  |      | Key Wrap w/  |\n|         |     |         |                  |      | 128-bit key  |\n+---------+-----+---------+------------------+------+--------------+\n| ECDH-ES |-30  | HKDF -- | yes              |A192KW| ECDH ES w/   |\n| +       |     | SHA-256 |                  |      | HKDF and AES |\n| A192KW  |     |         |                  |      | Key Wrap w/  |\n|         |     |         |                  |      | 192-bit key  |\n+---------+-----+---------+------------------+------+--------------+\n| ECDH-ES |-31  | HKDF -- | yes              |A256KW| ECDH ES w/   |\n| +       |     | SHA-256 |                  |      | HKDF and AES |\n| A256KW  |     |         |                  |      | Key Wrap w/  |\n|         |     |         |                  |      | 256-bit key  |\n+---------+-----+---------+------------------+------+--------------+\n| ECDH-SS |-32  | HKDF -- | no               |A128KW| ECDH SS w/   |\n| +       |     | SHA-256 |                  |      | HKDF and AES |\n| A128KW  |     |         |                  |      | Key Wrap w/  |\n|         |     |         |                  |      | 128-bit key  |\n+---------+-----+---------+------------------+------+--------------+\n| ECDH-SS |-33  | HKDF -- | no               |A192KW| ECDH SS w/   |\n| +       |     | SHA-256 |                  |      | HKDF and AES |\n| A192KW  |     |         |                  |      | Key Wrap w/  |\n|         |     |         |                  |      | 192-bit key  |\n+---------+-----+---------+------------------+------+--------------+\n| ECDH-SS |-34  | HKDF -- | no               |A256KW| ECDH SS w/   |\n| +       |     | SHA-256 |                  |      | HKDF and AES |\n| A256KW  |     |         |                  |      | Key Wrap w/  |\n|         |     |         |                  |      | 256-bit key  |\n+---------+-----+---------+------------------+------+--------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "Table 16: ECDH Algorithm Values with Key Wrap",
      "ja": "表16：キー包装付きのECDHアルゴリズム値"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムでCOSEキーを使用する場合、以下のチェックが行われます。"
    },
    {
      "indent": 6,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"EC2\" or \"OKP\".",
      "ja": "* \"kty\"フィールドは必ず存在し、\"EC2\"または\"OKP\"でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If the \"alg\" field is present, it MUST match the key agreement algorithm being used.",
      "ja": "* もし「alg」フィールドが存在する場合、それは使用されている鍵合意アルゴリズムと一致しなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If the \"key_ops\" field is present, it MUST include \"derive key\" or \"derive bits\" for the private key.",
      "ja": "* もし \"key_ops\" フィールドが存在する場合、それは必ず \"derive key\" または \"derive bits\" を含まなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If the \"key_ops\" field is present, it MUST be empty for the public key.",
      "ja": "* \"key_ops\" フィールドが存在する場合、公開鍵の場合は空でなければなりません。"
    },
    {
      "indent": 0,
      "text": "7. Key Object Parameters",
      "section_title": true,
      "ja": "7. キーオブジェクトパラメータ"
    },
    {
      "indent": 3,
      "text": "The COSE_Key object defines a way to hold a single key object. It is still required that the members of individual key types be defined. This section of the document is where we define an initial set of members for specific key types.",
      "ja": "COSE_Keyオブジェクトは単一のキーオブジェクトを保持する方法を定義します。個々のキータイプのメンバーが定義されている必要があります。このドキュメントのこのセクションでは、特定のキータイプの初期メンバーを定義します。"
    },
    {
      "indent": 3,
      "text": "For each of the key types, we define both public and private members. The public members are what is transmitted to others for their usage. Private members allow individuals to archive keys. However, there are some circumstances in which private keys may be distributed to entities in a protocol. Examples include: entities that have poor random number generation, centralized key creation for multicast-type operations, and protocols in which a shared secret is used as a bearer token for authorization purposes.",
      "ja": "各キータイプについて、公開メンバーと非公開メンバーを定義します。公開メンバーは他の人に送信され、使用されます。非公開メンバーは個人がキーをアーカイブできるようにします。ただし、プロトコルで非公開キーがエンティティに配布される場合もあります。例には、ランダムな数値生成が不十分なエンティティ、マルチキャスト型操作のための中央集権的なキー作成、共有シークレットが認証目的のベアラートークンとして使用されるプロトコルなどがあります。"
    },
    {
      "indent": 3,
      "text": "Key types are identified by the \"kty\" member of the COSE_Key object. In this document, we define four values for the member:",
      "ja": "キーの種類は、COSE_Keyオブジェクトの\"kty\"メンバーによって識別されます。このドキュメントでは、そのメンバーに対して4つの値を定義します。"
    },
    {
      "indent": 13,
      "text": "+===========+=======+==========================+\n| Name      | Value | Description              |\n+===========+=======+==========================+\n| OKP       |   1   | Octet Key Pair           |\n+-----------+-------+--------------------------+\n| EC2       |   2   | Elliptic Curve Keys w/   |\n|           |       | x- and y-coordinate pair |\n+-----------+-------+--------------------------+\n| Symmetric |   4   | Symmetric Keys           |\n+-----------+-------+--------------------------+\n| Reserved  |   0   | This value is reserved   |\n+-----------+-------+--------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "Table 17: Key Type Values",
      "ja": "表17：キータイプの値"
    },
    {
      "indent": 0,
      "text": "7.1. Elliptic Curve Keys",
      "section_title": true,
      "ja": "7.1. 楕円曲線鍵"
    },
    {
      "indent": 3,
      "text": "Two different key structures are defined for elliptic curve keys. One version uses both an x-coordinate and a y-coordinate, potentially with point compression (\"EC2\"). This is the conventional elliptic curve (EC) point representation that is used in [RFC5480]. The other version uses only the x-coordinate, as the y-coordinate is either to be recomputed or not needed for the key agreement operation (\"OKP\").",
      "ja": "2つの異なる鍵構造が楕円曲線鍵のために定義されています。1つのバージョンはx座標とy座標の両方を使用し、ポイント圧縮を行うことがあります（「EC2」）。これは[RFC5480]で使用されている従来の楕円曲線（EC）ポイント表現です。もう1つのバージョンはx座標のみを使用し、y座標は鍵合意操作に再計算されるか必要ないかのどちらかです（「OKP」）。"
    },
    {
      "indent": 3,
      "text": "Applications MUST check that the curve and the key type are consistent and reject a key if they are not.",
      "ja": "アプリケーションは、曲線とキーの種類が一致しているかどうかを確認し、一致していない場合はキーを拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "+=========+=======+==========+=====================================+\n| Name    | Value | Key Type | Description                         |\n+=========+=======+==========+=====================================+\n| P-256   |   1   |   EC2    | NIST P-256, also known as secp256r1 |\n+---------+-------+----------+-------------------------------------+\n| P-384   |   2   |   EC2    | NIST P-384, also known as secp384r1 |\n+---------+-------+----------+-------------------------------------+\n| P-521   |   3   |   EC2    | NIST P-521, also known as secp521r1 |\n+---------+-------+----------+-------------------------------------+\n| X25519  |   4   |   OKP    | X25519 for use w/ ECDH only         |\n+---------+-------+----------+-------------------------------------+\n| X448    |   5   |   OKP    | X448 for use w/ ECDH only           |\n+---------+-------+----------+-------------------------------------+\n| Ed25519 |   6   |   OKP    | Ed25519 for use w/ EdDSA only       |\n+---------+-------+----------+-------------------------------------+\n| Ed448   |   7   |   OKP    | Ed448 for use w/ EdDSA only         |\n+---------+-------+----------+-------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "Table 18: Elliptic Curves",
      "ja": "表18：楕円曲線"
    },
    {
      "indent": 0,
      "text": "7.1.1. Double Coordinate Curves",
      "section_title": true,
      "ja": "7.1.1. 二重座標曲線"
    },
    {
      "indent": 3,
      "text": "Generally, protocols transmit elliptic-curve points as either the x-coordinate and y-coordinate or the x-coordinate and a sign bit for the y-coordinate. The latter encoding has not been recommended by the IETF due to potential IPR issues. However, for operations in constrained environments, the ability to shrink a message by not sending the y-coordinate is potentially useful.",
      "ja": "一般的に、プロトコルは楕円曲線の点をx座標とy座標、またはx座標とy座標の符号ビットとして送信します。後者のエンコーディングは、潜在的なIPRの問題のためにIETFによって推奨されていません。ただし、制約のある環境での操作では、y座標を送信しないことでメッセージを縮小できる能力が潜在的に有用です。"
    },
    {
      "indent": 3,
      "text": "For EC keys with both coordinates, the \"kty\" member is set to 2 (EC2). The key parameters defined in this section are summarized in Table 19. The members that are defined for this key type are:",
      "ja": "ECキーの両座標を持つ場合、\"kty\"メンバーは2（EC2）に設定されます。このセクションで定義されたキーのパラメータは、表19にまとめられています。このキータイプに定義されたメンバーは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "crv:",
      "ja": "crv:"
    },
    {
      "indent": 12,
      "text": "This contains an identifier of the curve to be used with the key. The curves defined in this document for this key type can be found in Table 18. Other curves may be registered in the future, and private curves can be used as well.",
      "ja": "これには、キーと一緒に使用する曲線の識別子が含まれています。このキータイプのためにこの文書で定義された曲線は、表18にあります。将来他の曲線が登録される可能性があり、プライベート曲線も使用できます。"
    },
    {
      "indent": 3,
      "text": "x: ",
      "ja": "x:"
    },
    {
      "indent": 12,
      "text": "This contains the x-coordinate for the EC point. The integer is converted to a byte string as defined in [SEC1]. Leading-zero octets MUST be preserved.",
      "ja": "このテキストにはECポイントのx座標が含まれています。整数は[SEC1]で定義されたバイト文字列に変換されます。先頭のゼロのオクテットは保持されなければなりません。"
    },
    {
      "indent": 3,
      "text": "y: ",
      "ja": "y:"
    },
    {
      "indent": 12,
      "text": "This contains either the sign bit or the value of the y-coordinate for the EC point. When encoding the value y, the integer is converted to a byte string (as defined in [SEC1]) and encoded as a CBOR bstr. Leading-zero octets MUST be preserved. Compressed point encoding is also supported. Compute the sign bit as laid out in the Elliptic-Curve-Point-to-Octet-String Conversion function of [SEC1]. If the sign bit is zero, then encode y as a CBOR false value; otherwise, encode y as a CBOR true value. The encoding of the infinity point is not supported.",
      "ja": "これには、ECポイントのy座標の符号ビットまたは値が含まれています。 yの値をエンコードするときは、整数をバイト文字列に変換し（[SEC1]で定義されている）、CBOR bstrとしてエンコードします。 先頭のゼロオクテットは保持する必要があります。 圧縮ポイントエンコーディングもサポートされています。 [SEC1]のElliptic-Curve-Point-to-Octet-String変換関数で指定されたように符号ビットを計算します。 符号ビットがゼロの場合、yをCBOR false値としてエンコードします。 それ以外の場合、yをCBOR true値としてエンコードします。 無限ポイントのエンコーディングはサポートされていません。"
    },
    {
      "indent": 3,
      "text": "d: ",
      "ja": "d:"
    },
    {
      "indent": 12,
      "text": "This contains the private key.",
      "ja": "これには秘密鍵が含まれています。"
    },
    {
      "indent": 3,
      "text": "For public keys, it is REQUIRED that \"crv\", \"x\", and \"y\" be present in the structure. For private keys, it is REQUIRED that \"crv\" and \"d\" be present in the structure. For private keys, it is RECOMMENDED that \"x\" and \"y\" also be present, but they can be recomputed from the required elements, and omitting them saves on space.",
      "ja": "公開鍵の場合、構造体に「crv」、「x」、および「y」が存在している必要があります。秘密鍵の場合、構造体に「crv」と「d」が存在している必要があります。秘密鍵の場合、「x」と「y」も存在していることが推奨されますが、必要な要素から再計算することができ、それらを省略することでスペースを節約できます。"
    },
    {
      "indent": 4,
      "text": "+======+======+=======+========+=================================+\n| Key  | Name | Label | CBOR   | Description                     |\n| Type |      |       | Type   |                                 |\n+======+======+=======+========+=================================+\n|  2   | crv  |   -1  | int /  | EC identifier -- Taken from the |\n|      |      |       | tstr   | \"COSE Elliptic Curves\" registry |\n+------+------+-------+--------+---------------------------------+\n|  2   |  x   |   -2  | bstr   | x-coordinate                    |\n+------+------+-------+--------+---------------------------------+\n|  2   |  y   |   -3  | bstr / | y-coordinate                    |\n|      |      |       | bool   |                                 |\n+------+------+-------+--------+---------------------------------+\n|  2   |  d   |   -4  | bstr   | Private key                     |\n+------+------+-------+--------+---------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 19: EC Key Parameters",
      "ja": "表19：ECキーのパラメータ"
    },
    {
      "indent": 0,
      "text": "7.2. Octet Key Pair",
      "section_title": true,
      "ja": "7.2. Octet Key Pair"
    },
    {
      "indent": 3,
      "text": "A new key type is defined for Octet Key Pairs (OKPs). Do not assume that keys using this type are elliptic curves. This key type could be used for other curve types (for example, mathematics based on hyper-elliptic surfaces).",
      "ja": "Octet Key Pairs（OKPs）用に新しいキータイプが定義されています。このタイプのキーが楕円曲線であるとは限りません。このキータイプは他の曲線タイプにも使用される可能性があります（例：超楕円曲面に基づく数学）。"
    },
    {
      "indent": 3,
      "text": "The key parameters defined in this section are summarized in Table 20. The members that are defined for this key type are:",
      "ja": "このセクションで定義された主要なパラメータは、表20にまとめられています。このキータイプに定義されているメンバーは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "crv:",
      "ja": "crv:"
    },
    {
      "indent": 12,
      "text": "This contains an identifier of the curve to be used with the key. The curves defined in this document for this key type can be found in Table 18. Other curves may be registered in the future, and private curves can be used as well.",
      "ja": "これには、キーと一緒に使用する曲線の識別子が含まれています。このキー種別のためにこの文書で定義された曲線は、表18にあります。将来他の曲線が登録される可能性があり、プライベート曲線も使用できます。"
    },
    {
      "indent": 3,
      "text": "x: ",
      "ja": "x:"
    },
    {
      "indent": 12,
      "text": "This contains the public key. The byte string contains the public key as defined by the algorithm. (For X25519, internally it is a little-endian integer.)",
      "ja": "これには公開鍵が含まれています。バイト文字列には、アルゴリズムで定義された公開鍵が含まれています。（X25519の場合、内部的にはリトルエンディアンの整数です。）"
    },
    {
      "indent": 3,
      "text": "d: ",
      "ja": "d:"
    },
    {
      "indent": 12,
      "text": "This contains the private key.",
      "ja": "これには秘密鍵が含まれています。"
    },
    {
      "indent": 3,
      "text": "For public keys, it is REQUIRED that \"crv\" and \"x\" be present in the structure. For private keys, it is REQUIRED that \"crv\" and \"d\" be present in the structure. For private keys, it is RECOMMENDED that \"x\" also be present, but it can be recomputed from the required elements, and omitting it saves on space.",
      "ja": "公開鍵の場合、構造に「crv」と「x」が存在することが必要です。秘密鍵の場合、構造に「crv」と「d」が存在することが必要です。秘密鍵の場合、「x」も存在することが推奨されますが、必要な要素から再計算でき、省略することでスペースを節約できます。"
    },
    {
      "indent": 3,
      "text": "+======+==========+=======+=======+=================================+\n| Name |   Key    | Label | Type  | Description                     |\n|      |   Type   |       |       |                                 |\n+======+==========+=======+=======+=================================+\n| crv  |    1     |   -1  | int / | EC identifier -- Taken from the |\n|      |          |       | tstr  | \"COSE Elliptic Curves\" registry |\n+------+----------+-------+-------+---------------------------------+\n| x    |    1     |   -2  | bstr  | Public Key                      |\n+------+----------+-------+-------+---------------------------------+\n| d    |    1     |   -4  | bstr  | Private key                     |\n+------+----------+-------+-------+---------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 20: Octet Key Pair Parameters",
      "ja": "表20：オクテットキーペアパラメータ"
    },
    {
      "indent": 0,
      "text": "7.3. Symmetric Keys",
      "section_title": true,
      "ja": "7.3. 対称鍵"
    },
    {
      "indent": 3,
      "text": "Occasionally, it is required that a symmetric key be transported between entities. This key structure allows for that to happen.",
      "ja": "時折、エンティティ間で対称キーを転送する必要があります。このキー構造はそのようなことが可能になります。"
    },
    {
      "indent": 3,
      "text": "For symmetric keys, the \"kty\" member is set to 4 (\"Symmetric\"). The member that is defined for this key type is:",
      "ja": "対称キーの場合、\"kty\"メンバーは4（\"Symmetric\"）に設定されます。このキー種別に定義されたメンバーは次のとおりです："
    },
    {
      "indent": 3,
      "text": "k:",
      "ja": "k:"
    },
    {
      "indent": 12,
      "text": "This contains the value of the key.",
      "ja": "これはキーの値を含んでいます。"
    },
    {
      "indent": 3,
      "text": "This key structure does not have a form that contains only public members. As it is expected that this key structure is going to be transmitted, care must be taken that it is never transmitted accidentally or insecurely. For symmetric keys, it is REQUIRED that \"k\" be present in the structure.",
      "ja": "このキー構造には、公開メンバーのみを含む形式がありません。このキー構造が送信されることが期待されているため、誤ってまたは安全でない方法で送信されないように注意を払う必要があります。対称キーの場合、構造体に \"k\" が存在することが必要です。"
    },
    {
      "indent": 13,
      "text": "+======+==========+=======+======+=============+\n| Name | Key Type | Label | Type | Description |\n+======+==========+=======+======+=============+\n|  k   |    4     |   -1  | bstr | Key Value   |\n+------+----------+-------+------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 21: Symmetric Key Parameters",
      "ja": "表21：対称鍵パラメータ"
    },
    {
      "indent": 0,
      "text": "8. COSE Capabilities",
      "section_title": true,
      "ja": "8. COSEの機能"
    },
    {
      "indent": 3,
      "text": "The capabilities of an algorithm or key type need to be specified in some situations. This has a counterpart in the S/MIME specifications, where SMIMECapabilities is defined in Section 2.5.2 of [RFC8551]. This document defines the same concept for COSE.",
      "ja": "アルゴリズムや鍵の種類の機能は、特定の状況で指定する必要があります。これは、S/MIME仕様において対応するものがあり、[RFC8551]のセクション2.5.2でSMIMECapabilitiesが定義されています。この文書は、COSEに対して同じ概念を定義しています。"
    },
    {
      "indent": 3,
      "text": "The algorithm identifier is not included in the capabilities data, as it should be encoded elsewhere in the message. The key type identifier is included in the capabilities data, as it is not expected to be encoded elsewhere.",
      "ja": "アルゴリズム識別子は、メッセージの他の場所にエンコードされるべきであるため、機能データに含まれていません。キータイプ識別子は、他の場所にエンコードされることは期待されていないため、機能データに含まれています。"
    },
    {
      "indent": 3,
      "text": "Two different types of capabilities are defined: capabilities for algorithms and capabilities for key type. Once defined by registration with IANA, the list of capabilities for an algorithm or key type is immutable. If it is later found that a new capability is needed for a key type or algorithm, it will require that a new code point be assigned to deal with that. As a general rule, the capabilities are going to map to algorithm-specific header parameters or key parameters, but they do not need to do so. An example of this is the HSS-LMS key type capabilities defined below, where the hash algorithm used is included.",
      "ja": "2つの異なるタイプの機能が定義されています：アルゴリズム用の機能とキータイプ用の機能。 IANAに登録された後、アルゴリズムまたはキータイプの機能のリストは不変です。後でキータイプまたはアルゴリズムに新しい機能が必要になった場合、それに対処するために新しいコードポイントが割り当てられる必要があります。一般的なルールとして、機能はアルゴリズム固有のヘッダーパラメータやキーパラメータにマッピングされる可能性がありますが、必ずしもそうである必要はありません。以下に定義されているHSS-LMSキータイプの機能の例を示します。使用されるハッシュアルゴリズムが含まれています。"
    },
    {
      "indent": 3,
      "text": "The capability structure is an array of values; the values included in the structure are dependent on a specific algorithm or key type. For algorithm capabilities, the first element should always be a key type value if applicable, but the items that are specific to a key (for example, a curve) should not be included in the algorithm capabilities. This means that if one wishes to enumerate all of the capabilities for a device that implements ECDH, it requires that all of the combinations of algorithms and key pairs be specified. The last example of Section 8.3 provides a case where this is done by allowing for a cross product to be specified between an array of algorithm capabilities and key type capabilities (see the ECDH-ES+A25KW element). For a key, the first element should be the key type value. While this means that the key type value will be duplicated if both an algorithm and key capability are used, the key type is needed in order to understand the rest of the values.",
      "ja": "能力構造は値の配列です。構造に含まれる値は特定のアルゴリズムまたはキータイプに依存します。アルゴリズムの能力については、該当する場合は常に最初の要素がキータイプの値であるべきですが、キーに固有の項目（たとえば、曲線）はアルゴリズムの能力に含めてはいけません。これは、ECDHを実装するデバイスのすべての能力を列挙する場合、アルゴリズムとキーペアのすべての組み合わせを指定する必要があることを意味します。セクション8.3の最後の例は、アルゴリズムの能力の配列とキータイプの能力の間でクロスプロダクトを指定することでこれを実現しています（ECDH-ES+A25KW要素を参照）。キーについては、最初の要素はキータイプの値であるべきです。これは、アルゴリズムとキーの能力の両方が使用される場合、キータイプの値が重複することを意味しますが、残りの値を理解するためにはキータイプが必要です。"
    },
    {
      "indent": 0,
      "text": "8.1. Assignments for Existing Algorithms",
      "section_title": true,
      "ja": "8.1. 既存のアルゴリズムの割り当て"
    },
    {
      "indent": 3,
      "text": "For the current set of algorithms in the registry other than IV-GENERATION (those in this document as well as those in [RFC8230], [RFC8778], and [RFC9021]), the capabilities list is an array with one element, the key type (from the \"COSE Key Types\" Registry). It is expected that future registered algorithms could have zero, one, or multiple elements.",
      "ja": "登録されているアルゴリズムの現在のセットについて、IV-GENERATION以外のもの（この文書および[RFC8230]、[RFC8778]、[RFC9021]に含まれるもの）について、機能リストは1つの要素、つまりキーの種類（「COSE Key Types」レジストリから）を持つ配列です。将来登録されるアルゴリズムには、要素がゼロ個、1個、または複数個ある可能性があります。"
    },
    {
      "indent": 0,
      "text": "8.2. Assignments for Existing Key Types",
      "section_title": true,
      "ja": "8.2. 既存のキータイプ用の割り当て"
    },
    {
      "indent": 3,
      "text": "There are a number of pre-existing key types; the following deals with creating the capability definition for those structures:",
      "ja": "事前に存在するいくつかのキータイプがあります。次の内容は、それらの構造に対する能力定義の作成に関わります。"
    },
    {
      "indent": 6,
      "text": "* OKP, EC2: The list of capabilities is:",
      "ja": "* OKP、EC2：機能のリストは次のとおりです。"
    },
    {
      "indent": 12,
      "text": "- The key type value. (1 for OKP or 2 for EC2.)",
      "ja": "- 鍵の種類の値。 (OKP の場合は 1、EC2 の場合は 2。)"
    },
    {
      "indent": 12,
      "text": "- One curve for that key type from the \"COSE Elliptic Curves\" registry.",
      "ja": "- 「COSE楕円曲線」レジストリからその鍵タイプ用の1つの曲線。"
    },
    {
      "indent": 6,
      "text": "* RSA: The list of capabilities is:",
      "ja": "* RSA: 機能のリストは次のとおりです。"
    },
    {
      "indent": 12,
      "text": "- The key type value (3).",
      "ja": "- キーのタイプ値（3）。"
    },
    {
      "indent": 6,
      "text": "* Symmetric: The list of capabilities is:",
      "ja": "* 対称的：機能のリストは："
    },
    {
      "indent": 12,
      "text": "- The key type value (4).",
      "ja": "- キーのタイプ値（4）。"
    },
    {
      "indent": 6,
      "text": "* HSS-LMS: The list of capabilities is:",
      "ja": "* HSS-LMS：機能のリストは次のとおりです。"
    },
    {
      "indent": 12,
      "text": "- The key type value (5).",
      "ja": "- キーの種類の値（5）。"
    },
    {
      "indent": 12,
      "text": "- Algorithm identifier for the underlying hash function from the \"COSE Algorithms\" registry.",
      "ja": "- \"COSE Algorithms\" レジストリから基礎となるハッシュ関数のアルゴリズム識別子。"
    },
    {
      "indent": 6,
      "text": "* WalnutDSA: The list of capabilities is:",
      "ja": "* WalnutDSA: 機能のリストは次のとおりです。"
    },
    {
      "indent": 12,
      "text": "- The key type value (6).",
      "ja": "- キータイプの値（6）。"
    },
    {
      "indent": 12,
      "text": "- The N value (group and matrix size) for the key, a uint.",
      "ja": "- キーのN値（グループと行列のサイズ）、uint用。"
    },
    {
      "indent": 12,
      "text": "- The q value (finite field order) for the key, a uint.",
      "ja": "- キーのq値（有限体の次数）、uint用。"
    },
    {
      "indent": 0,
      "text": "8.3. Examples",
      "section_title": true,
      "ja": "8.3. 例"
    },
    {
      "indent": 3,
      "text": "Capabilities can be used in a key derivation process to make sure that both sides are using the same parameters. The three examples below show different ways that one might utilize parameters in specifying an application protocol:",
      "ja": "能力は、両側が同じパラメータを使用していることを確認するために鍵導出プロセスで使用できます。以下の3つの例は、アプリケーションプロトコルを指定する際にパラメータを利用する異なる方法を示しています。"
    },
    {
      "indent": 6,
      "text": "* Only an algorithm capability: This is useful if the protocol wants to require a specific algorithm, such as ES256, but it is agnostic about which curve is being used. This requires that the algorithm identifier be specified in the protocol. See the first example.",
      "ja": "* アルゴリズムの能力のみ：プロトコルが特定のアルゴリズム（例：ES256）を要求したい場合に便利ですが、使用されている曲線については無関心です。これには、プロトコルでアルゴリズム識別子を指定する必要があります。最初の例を参照してください。"
    },
    {
      "indent": 6,
      "text": "* Only a key type capability: This is useful if the protocol wants to require a specific key type and curve, such as P-256, but will accept any algorithm using that curve (e.g., both ECDSA and ECDH). See the second example.",
      "ja": "* キーの種類のみ: プロトコルが特定のキーの種類と曲線（たとえば P-256）を要求するが、その曲線を使用する任意のアルゴリズム（例: ECDSA と ECDH の両方）を受け入れる場合に便利です。2番目の例を参照してください。"
    },
    {
      "indent": 6,
      "text": "* Both algorithm and key type capabilities: This is used if the protocol needs to nail down all of the options surrounding an algorithm -- e.g., EdDSA with the curve Ed25519. As with the first example, the algorithm identifier needs to be specified in the protocol. See the third example, which just concatenates the two capabilities together.",
      "ja": "* アルゴリズムとキータイプの機能の両方: プロトコルがアルゴリズムに関するすべてのオプションを確定する必要がある場合に使用されます-- 例: Ed25519曲線を使用したEdDSA。最初の例と同様に、プロトコルでアルゴリズム識別子を指定する必要があります。2つの機能を単に連結する第3の例を参照してください。"
    },
    {
      "indent": 3,
      "text": "Algorithm ES256\n\n0x8102                 / [2 \\ EC2 \\ ] /\n\nKey type EC2 with P-256 curve:\n\n0x820201               / [2 \\ EC2 \\, 1 \\ P-256 \\] /\n\nECDH-ES + A256KW with an X25519 curve:\n\n0x8101820104           / [1 \\ OKP \\],[1 \\ OKP \\, 4 \\ X25519 \\] /",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The capabilities can also be used by an entity to advertise what it is capable of doing. The decoded example below is one of many encodings that could be used for that purpose. Each array element includes three fields: the algorithm identifier, one or more algorithm capabilities, and one or more key type capabilities.",
      "ja": "その機能は、エンティティが何ができるかを広告するためにも使用できます。以下のデコードされた例は、その目的に使用できる多くのエンコーディングの1つです。各配列要素には、アルゴリズム識別子、1つ以上のアルゴリズムの機能、および1つ以上のキータイプの機能が含まれています。"
    },
    {
      "indent": 3,
      "text": "[\n [-8 / EdDSA /,\n   [1 / OKP key type /],\n   [\n     [1 / OKP /, 6 / Ed25519 / ],\n     [1 /OKP/, 7 /Ed448 /]\n   ]\n ],\n [-7 / ECDSA with SHA-256/,\n   [2 /EC2 key type/],\n   [\n     [2 /EC2/, 1 /P-256/],\n     [2 /EC2/, 3 /P-521/]\n   ]\n ],\n [ -31 / ECDH-ES+A256KW/,\n   [\n     [ 2 /EC2/],\n     [1 /OKP/ ]\n   ],\n   [\n     [2 /EC2/, 1 /P-256/],\n     [1 /OKP/, 4 / X25519/ ]\n   ]\n ],\n [ 1 / A128GCM /,\n   [ 4 / Symmetric / ],\n   [ 4 / Symmetric /]\n ]\n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Examining the above:",
      "ja": "上記を検討する:"
    },
    {
      "indent": 6,
      "text": "* The first element indicates that the entity supports EdDSA with curves Ed25519 and Ed448.",
      "ja": "* 最初の要素は、エンティティが曲線Ed25519とEd448を使用したEdDSAをサポートしていることを示しています。"
    },
    {
      "indent": 6,
      "text": "* The second element indicates that the entity supports ECDSA with SHA-256 with curves P-256 and P-521.",
      "ja": "* 2番目の要素は、エンティティがP-256とP-521の曲線を使用したSHA-256でのECDSAをサポートしていることを示しています。"
    },
    {
      "indent": 6,
      "text": "* The third element indicates that the entity supports Ephemeral-Static ECDH using AES256 key wrap. The entity can support the P-256 curve with an EC2 key type and the X25519 curve with an OKP key type.",
      "ja": "* 第3要素は、エンティティがAES256キーwrapを使用したエフェメラル-スタティックECDHをサポートしていることを示しています。エンティティは、EC2キータイプでP-256曲線と、OKPキータイプでX25519曲線をサポートできます。"
    },
    {
      "indent": 6,
      "text": "* The last element indicates that the entity supports AES-GCM of 128 bits for content encryption.",
      "ja": "* 最後の要素は、エンティティがコンテンツの暗号化に128ビットのAES-GCMをサポートしていることを示しています。"
    },
    {
      "indent": 3,
      "text": "The entity does not advertise that it supports any MAC algorithms.",
      "ja": "そのエンティティは、任意のMACアルゴリズムをサポートしていることを広告していません。"
    },
    {
      "indent": 0,
      "text": "9. CBOR Encoding Restrictions",
      "section_title": true,
      "ja": "9. CBORエンコーディングの制限"
    },
    {
      "indent": 3,
      "text": "This document limits the restrictions it imposes on how the CBOR Encoder needs to work. The new encoding restrictions are aligned with the Core Deterministic Encoding Requirements specified in Section 4.2.1 of RFC 8949 [STD94]. It has been narrowed down to the following restrictions:",
      "ja": "この文書は、CBORエンコーダが動作する制限に課せられる制限を限定しています。新しいエンコード制限は、RFC 8949 [STD94]のセクション4.2.1で指定されたコア決定論的エンコーディング要件と一致しています。以下の制限に絞られています。"
    },
    {
      "indent": 6,
      "text": "* The restriction applies to the encoding of the COSE_KDF_Context.",
      "ja": "* 制限は、COSE_KDF_Contextのエンコーディングに適用されます。"
    },
    {
      "indent": 6,
      "text": "* Encoding MUST be done using definite lengths, and the length of the (encoded) argument MUST be the minimum possible length. This means that the integer 1 is encoded as \"0x01\" and not \"0x1801\".",
      "ja": "* エンコーディングは必ず確定長で行われ、（エンコードされた）引数の長さは可能な限り最小限である必要があります。これは、整数1が「0x01」とエンコードされることを意味し、「0x1801」とはなりません。"
    },
    {
      "indent": 6,
      "text": "* Applications MUST NOT generate messages with the same label used twice as a key in a single map. Applications MUST NOT parse and process messages with the same label used twice as a key in a single map. Applications can enforce the parse-and-process requirement by using parsers that will fail the parse step or by using parsers that will pass all keys to the application, and the application can perform the check for duplicate keys.",
      "ja": "* アプリケーションは、1つのマップ内で2回使用される同じラベルをキーとして持つメッセージを生成してはなりません。アプリケーションは、1つのマップ内で2回使用される同じラベルをキーとして持つメッセージを解析および処理してはなりません。アプリケーションは、解析および処理の要件を強制するために、解析ステップに失敗するパーサーを使用するか、すべてのキーをアプリケーションに渡すパーサーを使用して、アプリケーションが重複するキーをチェックできます。"
    },
    {
      "indent": 0,
      "text": "10. IANA Considerations",
      "section_title": true,
      "ja": "10. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has updated all COSE registries except for \"COSE Header Parameters\" and \"COSE Key Common Parameters\" to point to this document instead of [RFC8152].",
      "ja": "IANAは、「COSEヘッダーパラメータ」と「COSEキーコモンパラメータ」を除くすべてのCOSEレジストリを、[RFC8152]の代わりにこの文書を指すように更新しました。"
    },
    {
      "indent": 0,
      "text": "10.1. Changes to the \"COSE Key Types\" Registry",
      "section_title": true,
      "ja": "10.1. 「COSE Key Types」レジストリへの変更"
    },
    {
      "indent": 3,
      "text": "IANA has added a new column in the \"COSE Key Types\" registry. The new column is labeled \"Capabilities\" and has been populated according to the entries in Table 22.",
      "ja": "IANAは「COSE Key Types」レジストリに新しい列を追加しました。新しい列は「Capabilities」とラベルされ、表22のエントリに従って埋められました。"
    },
    {
      "indent": 12,
      "text": "+=======+===========+============================+\n| Value | Name      | Capabilities               |\n+=======+===========+============================+\n| 1     | OKP       | [kty(1), crv]              |\n+-------+-----------+----------------------------+\n| 2     | EC2       | [kty(2), crv]              |\n+-------+-----------+----------------------------+\n| 3     | RSA       | [kty(3)]                   |\n+-------+-----------+----------------------------+\n| 4     | Symmetric | [kty(4)]                   |\n+-------+-----------+----------------------------+\n| 5     | HSS-LMS   | [kty(5), hash algorithm]   |\n+-------+-----------+----------------------------+\n| 6     | WalnutDSA | [kty(6), N value, q value] |\n+-------+-----------+----------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Table 22: Key Type Capabilities",
      "ja": "表22：キータイプの機能"
    },
    {
      "indent": 0,
      "text": "10.2. Changes to the \"COSE Algorithms\" Registry",
      "section_title": true,
      "ja": "10.2. 「COSEアルゴリズム」レジストリの変更"
    },
    {
      "indent": 3,
      "text": "IANA has added a new column in the \"COSE Algorithms\" registry. The new column is labeled \"Capabilities\" and has been populated with \"[kty]\" for all current, nonprovisional registrations.",
      "ja": "IANAは「COSE Algorithms」レジストリに新しい列を追加しました。新しい列は「Capabilities」とラベル付けされ、すべての現在の非プロビジョニング登録に対して「[kty]」が入力されています。"
    },
    {
      "indent": 3,
      "text": "IANA has updated the Reference column in the \"COSE Algorithms\" registry to include this document as a reference for all rows where it was not already present.",
      "ja": "IANAは、「COSE Algorithms」レジストリの「Reference」列を更新し、この文書を参照として追加しました。それが既に存在していないすべての行について。"
    },
    {
      "indent": 3,
      "text": "IANA has added a new row to the \"COSE Algorithms\" registry.",
      "ja": "IANAは「COSE Algorithms」レジストリに新しい行を追加しました。"
    },
    {
      "indent": 4,
      "text": "+===============+=======+===============+===========+=============+\n| Name          | Value | Description   | Reference | Recommended |\n+===============+=======+===============+===========+=============+\n| IV-GENERATION | 34    | For doing IV  | RFC 9053  | No          |\n|               |       | generation    |           |             |\n|               |       | for symmetric |           |             |\n|               |       | algorithms.   |           |             |\n+---------------+-------+---------------+-----------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "Table 23: New entry in the COSE Algorithms registry",
      "ja": "表23：COSEアルゴリズムレジストリへの新規エントリ"
    },
    {
      "indent": 3,
      "text": "The Capabilities column for this registration is to be empty.",
      "ja": "この登録の「Capabilities」列は空白にする必要があります。"
    },
    {
      "indent": 0,
      "text": "10.3. Changes to the \"COSE Key Type Parameters\" Registry",
      "section_title": true,
      "ja": "10.3. 「COSE Key Type Parameters」レジストリへの変更"
    },
    {
      "indent": 3,
      "text": "IANA has modified the description to \"Public Key\" for the line with \"Key Type\" of 1 and the \"Name\" of \"x\". See Table 20, which has been modified with this change.",
      "ja": "IANAは、「Key Type」が1で「Name」が「x」の行の説明を「公開鍵」に変更しました。この変更が加えられたTable 20を参照してください。"
    },
    {
      "indent": 0,
      "text": "10.4. Expert Review Instructions",
      "section_title": true,
      "ja": "10.4. 専門家レビューの指示"
    },
    {
      "indent": 3,
      "text": "All of the IANA registries established by [RFC8152] are, at least in part, defined as Expert Review [RFC8126]. This section gives some general guidelines for what the experts should be looking for, but they are being designated as experts for a reason, so they should be given substantial latitude.",
      "ja": "[RFC8152] で設立されたすべての IANA レジストリは、少なくとも部分的には Expert Review [RFC8126] として定義されています。このセクションでは、専門家が何を探しているかについて一般的なガイドラインを示していますが、彼らは理由があって専門家として指定されているため、かなりの裁量を与えられるべきです。"
    },
    {
      "indent": 3,
      "text": "Expert reviewers should take the following into consideration:",
      "ja": "専門家のレビュアーは、以下を考慮すべきです。"
    },
    {
      "indent": 6,
      "text": "* Point squatting should be discouraged. Reviewers are encouraged to get sufficient information for registration requests to ensure that the usage is not going to duplicate an existing registration and that the code point is likely to be used in deployments. The ranges tagged as private use are intended for testing purposes and closed environments; code points in other ranges should not be assigned for testing.",
      "ja": "* ポイント・スクワッティングは desu されるべきではありません。レビュアーは、登録リクエストのために十分な情報を取得するように奨励され、使用が既存の登録と重複しないこと、およびコードポイントが展開で使用される可能性が高いことを確認するようにしてください。プライベート・ユースとしてタグ付けされた範囲は、テスト目的および閉じられた環境向けです。他の範囲のコードポイントはテスト用に割り当てられるべきではありません。"
    },
    {
      "indent": 6,
      "text": "* Standards Track or BCP RFCs are required to register a code point in the Standards Action range. Specifications should exist for Specification Required ranges, but early assignment before an RFC is available is considered to be permissible. Specifications are needed for the first-come, first-served range if the points are expected to be used outside of closed environments in an interoperable way. When specifications are not provided, the description provided needs to have sufficient information to identify what the point is being used for.",
      "ja": "* Standards TrackまたはBCP RFCは、Standards Action範囲でコードポイントを登録する必要があります。Specification Required範囲には仕様が存在する必要がありますが、RFCが利用可能になる前の早期割り当ては許容されると見なされます。仕様が提供されていない場合、提供された説明には、ポイントがどのように使用されているかを識別するための十分な情報が必要です。"
    },
    {
      "indent": 6,
      "text": "* Experts should take into account the expected usage of fields when approving code point assignment. The fact that the Standards Action range is only available to Standards Track documents does not mean that a Standards Track document cannot have points assigned outside of that range. The length of the encoded value should be weighed against how many code points of that length are left and the size of device it will be used on.",
      "ja": "* 専門家は、コードポイントの割り当てを承認する際に、フィールドの予想される使用法を考慮すべきです。標準アクション範囲が標準トラックドキュメントにのみ利用可能であるという事実は、標準トラックドキュメントがその範囲外にポイントを割り当てることができないことを意味しません。符号化された値の長さは、その長さのコードポイントが残っている数と、それが使用されるデバイスのサイズに対して検討されるべきです。"
    },
    {
      "indent": 6,
      "text": "* When algorithms are registered, vanity registrations should be discouraged. One way to do this is to require registrations to provide additional documentation on security analysis of the algorithm. Another thing that should be considered is requesting an opinion on the algorithm from the Crypto Forum Research Group (CFRG). Algorithms are expected to meet the security requirements of the community and the requirements of the message structures in order to be suitable for registration.",
      "ja": "* アルゴリズムが登録される際には、虚栄心に基づく登録は desu されるべきではありません。これを防ぐ方法の一つは、アルゴリズムのセキュリティ分析に関する追加の文書提出を求めることです。また、アルゴリズムについて Crypto Forum Research Group (CFRG) からの意見を求めることも検討すべきです。アルゴリズムは、コミュニティのセキュリティ要件とメッセージ構造の要件を満たすことが期待され、登録に適しているとされます。"
    },
    {
      "indent": 0,
      "text": "11. Security Considerations",
      "section_title": true,
      "ja": "11. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "There are a number of security considerations that need to be taken into account by implementers of this specification. The security considerations that are specific to an individual algorithm are placed next to the description of the algorithm. While some considerations have been highlighted here, additional considerations may be found in the documents listed in the references.",
      "ja": "この仕様を実装する際に考慮すべきセキュリティに関する考慮事項がいくつかあります。個々のアルゴリズムに特有のセキュリティに関する考慮事項は、アルゴリズムの説明の隣に配置されます。ここで強調されている考慮事項もありますが、追加の考慮事項は参照文献にリストされている文書にも見つかるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Implementations need to protect the private key material for all individuals. Some cases in this document need to be highlighted with regard to this issue.",
      "ja": "実装はすべての個人の秘密鍵情報を保護する必要があります。この文書の一部については、この問題に関して強調する必要があります。"
    },
    {
      "indent": 6,
      "text": "* Use of the same key for two different algorithms can leak information about the key. It is therefore recommended that keys be restricted to a single algorithm.",
      "ja": "* 同じキーを2つの異なるアルゴリズムで使用すると、キーに関する情報が漏洩する可能性があります。そのため、キーは1つのアルゴリズムに制限されることが推奨されています。"
    },
    {
      "indent": 6,
      "text": "* Use of \"direct\" as a recipient algorithm combined with a second recipient algorithm exposes the direct key to the second recipient; Section 8.5 of [RFC9052] forbids combining \"direct\" recipient algorithms with other modes.",
      "ja": "* 「直接」という受信者アルゴリズムを第二の受信者アルゴリズムと組み合わせることで、直接キーが第二の受信者に露出します。[RFC9052]のセクション8.5は、「直接」受信者アルゴリズムを他のモードと組み合わせることを禁止しています。"
    },
    {
      "indent": 6,
      "text": "* Several of the algorithms in this document have limits on the number of times that a key can be used without leaking information about the key.",
      "ja": "* この文書のいくつかのアルゴリズムには、キーが使用される回数に制限があり、キーに関する情報が漏洩することがあります。"
    },
    {
      "indent": 3,
      "text": "The use of ECDH and direct plus KDF (with no key wrap) will not directly lead to the private key being leaked; the one-way function of the KDF will prevent that. There is, however, a different issue that needs to be addressed. Having two recipients requires that the CEK be shared between two recipients. The second recipient therefore has a CEK that was derived from material that can be used for the weak proof of origin. The second recipient could create a message using the same CEK and send it to the first recipient; the first recipient would, for either Static-Static ECDH or direct plus KDF, make an assumption that the CEK could be used for proof of origin, even though it is from the wrong entity. If the key wrap step is added, then no proof of origin is implied and this is not an issue.",
      "ja": "ECDHの使用と直接プラスKDF（キーのラップなし）は、秘密鍵が漏洩することに直接つながるわけではありません。KDFの一方向関数がそれを防ぎます。ただし、対処する必要がある別の問題があります。2つの受信者がいる場合、CEKは2つの受信者間で共有される必要があります。したがって、第2の受信者は、弱い起源の証明に使用できる材料から派生したCEKを持っています。第2の受信者は、同じCEKを使用してメッセージを作成し、最初の受信者に送信することができます。最初の受信者は、Static-Static ECDHまたは直接プラスKDFのいずれかの場合、CEKが起源の証明に使用できると仮定するでしょうが、それは誤ったエンティティから来ています。キーのラップステップが追加されると、起源の証明は暗示されず、これは問題ではありません。"
    },
    {
      "indent": 3,
      "text": "Although it has been mentioned before, it bears repeating that the use of a single key for multiple algorithms has been demonstrated in some cases to leak information about a key, providing the opportunity for attackers to forge integrity tags or gain information about encrypted content. Binding a key to a single algorithm prevents these problems. Key creators and key consumers are strongly encouraged to not only create new keys for each different algorithm, but to include that selection of algorithm in any distribution of key material and strictly enforce the matching of algorithms in the key structure to algorithms in the message structure. In addition to checking that algorithms are correct, the key form needs to be checked as well. Do not use an \"EC2\" key where an \"OKP\" key is expected.",
      "ja": "以前に言及されていますが、1つのキーを複数のアルゴリズムに使用することは、いくつかのケースでキーに関する情報を漏洩させる可能性があることが示されており、攻撃者が整合性タグを偽造したり、暗号化されたコンテンツに関する情報を入手する機会を提供しています。キーを1つのアルゴリズムにバインドすることで、これらの問題を防ぐことができます。キーの作成者とキーの利用者は、異なるアルゴリズムごとに新しいキーを作成するだけでなく、そのアルゴリズムの選択をキー素材の配布に含め、キー構造内のアルゴリズムとメッセージ構造内のアルゴリズムを厳密に一致させることを強くお勧めします。アルゴリズムが正しいかどうかを確認するだけでなく、キー形式も確認する必要があります。期待される\"OKP\"キーの場所で\"EC2\"キーを使用しないでください。"
    },
    {
      "indent": 3,
      "text": "Before using a key for transmission, or before acting on information received, a trust decision on a key needs to be made. Is the data or action something that the entity associated with the key has a right to see or a right to request? A number of factors are associated with this trust decision. Some highlighted here are:",
      "ja": "鍵を使用して情報を送信する前、または受信した情報に対して行動する前に、鍵に関する信頼決定を行う必要があります。データや行動が、鍵に関連するエンティティが見る権利や要求する権利があるものであるかどうか。この信頼決定にはいくつかの要因が関連しています。ここで強調されているいくつかは次のとおりです："
    },
    {
      "indent": 6,
      "text": "* What are the permissions associated with the key owner?",
      "ja": "* キー所有者に関連付けられた権限は何ですか？"
    },
    {
      "indent": 6,
      "text": "* Is the cryptographic algorithm acceptable in the current context?",
      "ja": "* 現在のコンテキストで暗号化アルゴリズムは受け入れ可能ですか？"
    },
    {
      "indent": 6,
      "text": "* Have the restrictions associated with the key, such as algorithm or freshness, been checked, and are they correct?",
      "ja": "* 鍵に関連する制限事項（アルゴリズムや新鮮さなど）が確認され、正しいですか？"
    },
    {
      "indent": 6,
      "text": "* Is the request something that is reasonable, given the current state of the application?",
      "ja": "* 現在のアプリケーションの状態を考えると、そのリクエストは妥当なものですか？"
    },
    {
      "indent": 6,
      "text": "* Have any security considerations that are part of the message been enforced (as specified by the application or \"crit\" header parameter)?",
      "ja": "* メッセージの一部として指定されたセキュリティ考慮事項は適用されていますか（アプリケーションまたは \"crit\" ヘッダーパラメーターで指定されたものに従って）？"
    },
    {
      "indent": 3,
      "text": "There are a large number of algorithms presented in this document that use nonce values. For all of the nonces defined in this document, there is some type of restriction on the nonce being a unique value for either a key or some other conditions. In all of these cases, there is no known requirement on the nonce being both unique and unpredictable; under these circumstances, it's reasonable to use a counter for creation of the nonce. In cases where one wants the pattern of the nonce to be unpredictable as well as unique, one can use a key created for that purpose and encrypt the counter to produce the nonce value.",
      "ja": "この文書には、ノンス値を使用する多数のアルゴリズムが示されています。この文書で定義されたすべてのノンスには、キーまたはその他の条件に対してノンスが一意の値であるという制限があります。これらのケースでは、ノンスが一意かつ予測不可能である必要はなく、そのような状況下では、ノンスの作成にカウンターを使用することが合理的です。ノンスのパターンを予測不可能かつ一意にしたい場合は、その目的のために作成されたキーを使用して、カウンターを暗号化してノンス値を生成することができます。"
    },
    {
      "indent": 3,
      "text": "One area that has been getting exposure is traffic analysis of encrypted messages based on the length of the message. This specification does not provide a uniform method for providing padding as part of the message structure. An observer can distinguish between two different messages (for example, \"YES\" and \"NO\") based on the length for all of the content encryption algorithms that are defined in this document. This means that it is up to the applications to document how content padding is to be done in order to prevent or discourage such analysis. (For example, the text strings could be defined as \"YES\" and \"NO \".)",
      "ja": "暗号化されたメッセージのトラフィック解析が注目されている分野の1つは、メッセージの長さに基づいています。この仕様では、メッセージ構造の一部としてパディングを提供するための一貫した方法を提供していません。この文書で定義されているすべてのコンテンツ暗号化アルゴリズムに基づいて、観察者は2つの異なるメッセージ（たとえば、「YES」と「NO」）を区別することができます。つまり、アプリケーションがどのようにコンテンツのパディングを行うかを文書化することが、そのような解析を防止または妨げるために必要です。（たとえば、テキスト文字列を「YES」と「NO 」と定義できます。）"
    },
    {
      "indent": 3,
      "text": "The analysis done in [RFC9147] is based on the number of records that are sent. This should map well to the number of messages sent when using COSE, so that analysis should hold here as well, under the assumption that the COSE messages are roughly the same size as DTLS records. It needs to be noted that the limits are based on the number of messages, but QUIC and DTLS are always pairwise-based endpoints. In contrast, [OSCORE-GROUPCOMM] uses COSE in a group communication scenario. Under these circumstances, it may be that no one single entity will see all of the messages that are encrypted, and therefore no single entity can trigger the rekey operation.",
      "ja": "[RFC9147]で行われた分析は送信されるレコードの数に基づいています。これはCOSEを使用する際に送信されるメッセージの数に適合するはずなので、COSEメッセージがDTLSレコードとほぼ同じサイズであると仮定すると、この分析はここでも成立するはずです。制限はメッセージの数に基づいていることに注意する必要がありますが、QUICとDTLSは常にペアベースのエンドポイントです。一方、[OSCORE-GROUPCOMM]はグループ通信シナリオでCOSEを使用しています。このような状況下では、暗号化されたすべてのメッセージを見ることができる単一のエンティティがいない可能性があり、したがって単一のエンティティが再鍵操作をトリガーすることはできません。"
    },
    {
      "indent": 0,
      "text": "12. References",
      "section_title": true,
      "ja": "12. 参考文献"
    },
    {
      "indent": 0,
      "text": "12.1. Normative References",
      "section_title": true,
      "ja": "12.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[AES-GCM]  Dworkin, M., \"Recommendation for Block Cipher Modes of\n           Operation: Galois/Counter Mode (GCM) and GMAC\", NIST\n           Special Publication 800-38D, DOI 10.6028/NIST.SP.800-38D,\n           November 2007, <https://csrc.nist.gov/publications/\n           nistpubs/800-38D/SP-800-38D.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[DSS]      National Institute of Standards and Technology, \"Digital\n           Signature Standard (DSS)\", FIPS PUB 186-4,\n           DOI 10.6028/NIST.FIPS.186-4, July 2013,\n           <https://nvlpubs.nist.gov/nistpubs/FIPS/\n           NIST.FIPS.186-4.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[MAC]      Menezes, A., van Oorschot, P., and S. Vanstone, \"Handbook\n           of Applied Cryptography\", CRC Press, Boca Raton, 1996,\n           <https://cacr.uwaterloo.ca/hac/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-\n           Hashing for Message Authentication\", RFC 2104,\n           DOI 10.17487/RFC2104, February 1997,\n           <https://www.rfc-editor.org/info/rfc2104>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC3394]  Schaad, J. and R. Housley, \"Advanced Encryption Standard\n           (AES) Key Wrap Algorithm\", RFC 3394, DOI 10.17487/RFC3394,\n           September 2002, <https://www.rfc-editor.org/info/rfc3394>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC3610]  Whiting, D., Housley, R., and N. Ferguson, \"Counter with\n           CBC-MAC (CCM)\", RFC 3610, DOI 10.17487/RFC3610, September\n           2003, <https://www.rfc-editor.org/info/rfc3610>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5869]  Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand\n           Key Derivation Function (HKDF)\", RFC 5869,\n           DOI 10.17487/RFC5869, May 2010,\n           <https://www.rfc-editor.org/info/rfc5869>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6090]  McGrew, D., Igoe, K., and M. Salter, \"Fundamental Elliptic\n           Curve Cryptography Algorithms\", RFC 6090,\n           DOI 10.17487/RFC6090, February 2011,\n           <https://www.rfc-editor.org/info/rfc6090>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6979]  Pornin, T., \"Deterministic Usage of the Digital Signature\n           Algorithm (DSA) and Elliptic Curve Digital Signature\n           Algorithm (ECDSA)\", RFC 6979, DOI 10.17487/RFC6979, August\n           2013, <https://www.rfc-editor.org/info/rfc6979>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7748]  Langley, A., Hamburg, M., and S. Turner, \"Elliptic Curves\n           for Security\", RFC 7748, DOI 10.17487/RFC7748, January\n           2016, <https://www.rfc-editor.org/info/rfc7748>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,\n           \"PKCS #1: RSA Cryptography Specifications Version 2.2\",\n           RFC 8017, DOI 10.17487/RFC8017, November 2016,\n           <https://www.rfc-editor.org/info/rfc8017>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8032]  Josefsson, S. and I. Liusvaara, \"Edwards-Curve Digital\n           Signature Algorithm (EdDSA)\", RFC 8032,\n           DOI 10.17487/RFC8032, January 2017,\n           <https://www.rfc-editor.org/info/rfc8032>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8439]  Nir, Y. and A. Langley, \"ChaCha20 and Poly1305 for IETF\n           Protocols\", RFC 8439, DOI 10.17487/RFC8439, June 2018,\n           <https://www.rfc-editor.org/info/rfc8439>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9052]  Schaad, J., \"CBOR Object Signing and Encryption (COSE):\n           Structures and Process\", STD 96, RFC 9052,\n           DOI 10.17487/RFC9052, August 2022,\n           <https://www.rfc-editor.org/info/rfc9052>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SEC1]     Certicom Research, \"SEC 1: Elliptic Curve Cryptography\",\n           Standards for Efficient Cryptography, May 2009,\n           <https://www.secg.org/sec1-v2.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[STD94]    Bormann, C. and P. Hoffman, \"Concise Binary Object\n           Representation (CBOR)\", STD 94, RFC 8949, December 2020,\n           <https://www.rfc-editor.org/info/std94>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "12.2. Informative References",
      "section_title": true,
      "ja": "12.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[CFRG-DET-SIGS]\n           Mattsson, J. P., Thormarker, E., and S. Ruohomaa,\n           \"Deterministic ECDSA and EdDSA Signatures with Additional\n           Randomness\", Work in Progress, Internet-Draft, draft-\n           mattsson-cfrg-det-sigs-with-noise-04, 15 February 2022,\n           <https://datatracker.ietf.org/doc/html/draft-mattsson-\n           cfrg-det-sigs-with-noise-04>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[COUNTERSIGN]\n           Schaad, J. and R. Housley, \"CBOR Object Signing and\n           Encryption (COSE): Countersignatures\", Work in Progress,\n           Internet-Draft, draft-ietf-cose-countersign-08, 22 August\n           2022, <https://datatracker.ietf.org/doc/html/draft-ietf-\n           cose-countersign-08>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[GitHub-Examples]\n           \"GitHub Examples of COSE\", commit 3221310, 3 June 2020,\n           <https://github.com/cose-wg/Examples>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HKDF]     Krawczyk, H., \"Cryptographic Extraction and Key\n           Derivation: The HKDF Scheme\", 2010,\n           <https://eprint.iacr.org/2010/264.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[OSCORE-GROUPCOMM]\n           Tiloca, M., Selander, G., Palombini, F., Mattsson, J. P.,\n           and J. Park, \"Group OSCORE - Secure Group Communication\n           for CoAP\", Work in Progress, Internet-Draft, draft-ietf-\n           core-oscore-groupcomm-14, 7 March 2022,\n           <https://datatracker.ietf.org/doc/html/draft-ietf-core-\n           oscore-groupcomm-14>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC4231]  Nystrom, M., \"Identifiers and Test Vectors for HMAC-SHA-\n           224, HMAC-SHA-256, HMAC-SHA-384, and HMAC-SHA-512\",\n           RFC 4231, DOI 10.17487/RFC4231, December 2005,\n           <https://www.rfc-editor.org/info/rfc4231>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC4493]  Song, JH., Poovendran, R., Lee, J., and T. Iwata, \"The\n           AES-CMAC Algorithm\", RFC 4493, DOI 10.17487/RFC4493, June\n           2006, <https://www.rfc-editor.org/info/rfc4493>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5116]  McGrew, D., \"An Interface and Algorithms for Authenticated\n           Encryption\", RFC 5116, DOI 10.17487/RFC5116, January 2008,\n           <https://www.rfc-editor.org/info/rfc5116>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5480]  Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,\n           \"Elliptic Curve Cryptography Subject Public Key\n           Information\", RFC 5480, DOI 10.17487/RFC5480, March 2009,\n           <https://www.rfc-editor.org/info/rfc5480>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6151]  Turner, S. and L. Chen, \"Updated Security Considerations\n           for the MD5 Message-Digest and the HMAC-MD5 Algorithms\",\n           RFC 6151, DOI 10.17487/RFC6151, March 2011,\n           <https://www.rfc-editor.org/info/rfc6151>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7252]  Shelby, Z., Hartke, K., and C. Bormann, \"The Constrained\n           Application Protocol (CoAP)\", RFC 7252,\n           DOI 10.17487/RFC7252, June 2014,\n           <https://www.rfc-editor.org/info/rfc7252>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7518]  Jones, M., \"JSON Web Algorithms (JWA)\", RFC 7518,\n           DOI 10.17487/RFC7518, May 2015,\n           <https://www.rfc-editor.org/info/rfc7518>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8126]  Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n           Writing an IANA Considerations Section in RFCs\", BCP 26,\n           RFC 8126, DOI 10.17487/RFC8126, June 2017,\n           <https://www.rfc-editor.org/info/rfc8126>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8152]  Schaad, J., \"CBOR Object Signing and Encryption (COSE)\",\n           RFC 8152, DOI 10.17487/RFC8152, July 2017,\n           <https://www.rfc-editor.org/info/rfc8152>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8230]  Jones, M., \"Using RSA Algorithms with CBOR Object Signing\n           and Encryption (COSE) Messages\", RFC 8230,\n           DOI 10.17487/RFC8230, September 2017,\n           <https://www.rfc-editor.org/info/rfc8230>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8446]  Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n           Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n           <https://www.rfc-editor.org/info/rfc8446>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8551]  Schaad, J., Ramsdell, B., and S. Turner, \"Secure/\n           Multipurpose Internet Mail Extensions (S/MIME) Version 4.0\n           Message Specification\", RFC 8551, DOI 10.17487/RFC8551,\n           April 2019, <https://www.rfc-editor.org/info/rfc8551>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8610]  Birkholz, H., Vigano, C., and C. Bormann, \"Concise Data\n           Definition Language (CDDL): A Notational Convention to\n           Express Concise Binary Object Representation (CBOR) and\n           JSON Data Structures\", RFC 8610, DOI 10.17487/RFC8610,\n           June 2019, <https://www.rfc-editor.org/info/rfc8610>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8778]  Housley, R., \"Use of the HSS/LMS Hash-Based Signature\n           Algorithm with CBOR Object Signing and Encryption (COSE)\",\n           RFC 8778, DOI 10.17487/RFC8778, April 2020,\n           <https://www.rfc-editor.org/info/rfc8778>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9021]  Atkins, D., \"Use of the Walnut Digital Signature Algorithm\n           with CBOR Object Signing and Encryption (COSE)\", RFC 9021,\n           DOI 10.17487/RFC9021, May 2021,\n           <https://www.rfc-editor.org/info/rfc9021>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9147]  Rescorla, E., Tschofenig, H., and N. Modadugu, \"The\n           Datagram Transport Layer Security (DTLS) Protocol Version\n           1.3\", RFC 9147, DOI 10.17487/RFC9147, April 2022,\n           <https://www.rfc-editor.org/info/rfc9147>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[ROBUST]   Fischlin, M., Günther, F., and C. Janson, \"Robust\n           Channels: Handling Unreliable Networks in the Record\n           Layers of QUIC and DTLS\", February 2020,\n           <https://eprint.iacr.org/2020/718.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SP800-38D]\n           Dworkin, M., \"Recommendation for Block Cipher Modes of\n           Operation: Galois/Counter Mode (GCM) and GMAC\", NIST\n           Special Publication 800-38D, November 2007,\n           <https://nvlpubs.nist.gov/nistpubs/Legacy/SP/\n           nistspecialpublication800-38d.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SP800-56A]\n           Barker, E., Chen, L., Roginsky, A., Vassilev, A., and R.\n           Davis, \"Recommendation for Pair-Wise Key Establishment\n           Schemes Using Discrete Logarithm Cryptography\", NIST\n           Special Publication 800-56A, Revision 3,\n           DOI 10.6028/NIST.SP.800-56Ar3, April 2018,\n           <https://nvlpubs.nist.gov/nistpubs/SpecialPublications/\n           NIST.SP.800-56Ar2.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[STD90]    Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data\n           Interchange Format\", STD 90, RFC 8259, December 2017,\n           <https://www.rfc-editor.org/info/std90>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "section_title": true,
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This document is a product of the COSE Working Group of the IETF.",
      "ja": "このドキュメントはIETFのCOSE Working Groupの成果物です。"
    },
    {
      "indent": 3,
      "text": "The following individuals are to blame for getting me started on this project in the first place: Richard Barnes, Matt Miller, and Martin Thomson.",
      "ja": "次の個人が最初にこのプロジェクトを始める原因となった責任があります：Richard Barnes、Matt Miller、およびMartin Thomson。"
    },
    {
      "indent": 3,
      "text": "The initial draft version of the specification was based to some degree on the outputs of the JOSE and S/MIME Working Groups.",
      "ja": "仕様の初期ドラフトバージョンは、ある程度、JOSEおよびS/MIMEワーキンググループの成果に基づいていました。"
    },
    {
      "indent": 3,
      "text": "The following individuals provided input into the final form of the document: Carsten Bormann, John Bradley, Brian Campbell, Michael B. Jones, Ilari Liusvaara, Francesca Palombini, Ludwig Seitz, and Göran Selander.",
      "ja": "次の個人が文書の最終形に入力を提供しました：Carsten Bormann、John Bradley、Brian Campbell、Michael B. Jones、Ilari Liusvaara、Francesca Palombini、Ludwig Seitz、およびGöran Selander。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "section_title": true,
      "ja": "著者の連絡先"
    },
    {
      "indent": 3,
      "text": "Jim Schaad\nAugust Cellars",
      "raw": true,
      "ja": ""
    }
  ]
}