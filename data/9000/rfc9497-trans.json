{
  "title": {
    "text": "RFC 9497 - Oblivious Pseudorandom Functions (OPRFs) Using Prime-Order Groups",
    "ja": "RFC 9497 - プライムオーダーグループを使用した、忘却の擬似ランダム関数（OPRF）"
  },
  "number": 9497,
  "created_at": "2024-02-28 22:31:34.638223+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                          A. Davidson\nRequest for Comments: 9497                                Brave Software\nCategory: Informational                                 A. Faz-Hernandez\nISSN: 2070-1721                                              N. Sullivan\n                                                              C. A. Wood\n                                                        Cloudflare, Inc.\n                                                           December 2023",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Oblivious Pseudorandom Functions (OPRFs) Using Prime-Order Groups",
      "title": true,
      "section_title": true,
      "ja": "プライムオーダーグループを使用した、忘却の擬似ランダム関数（OPRF）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "An Oblivious Pseudorandom Function (OPRF) is a two-party protocol between a client and a server for computing the output of a Pseudorandom Function (PRF). The server provides the PRF private key, and the client provides the PRF input. At the end of the protocol, the client learns the PRF output without learning anything about the PRF private key, and the server learns neither the PRF input nor output. An OPRF can also satisfy a notion of 'verifiability', called a VOPRF. A VOPRF ensures clients can verify that the server used a specific private key during the execution of the protocol. A VOPRF can also be partially oblivious, called a POPRF. A POPRF allows clients and servers to provide public input to the PRF computation. This document specifies an OPRF, VOPRF, and POPRF instantiated within standard prime-order groups, including elliptic curves. This document is a product of the Crypto Forum Research Group (CFRG) in the IRTF.",
      "ja": "忘れられない擬似ランダム関数（OPRF）は、クライアントとサーバーの間の2つのパーティプロトコルであり、擬似ランダム関数（PRF）の出力を計算するためのサーバーです。サーバーはPRF秘密キーを提供し、クライアントはPRF入力を提供します。プロトコルの最後に、クライアントはPRFの秘密鍵について何も学習せずにPRF出力を学習し、サーバーはPRF入力も出力も学習しません。OPRFは、VOPRFと呼ばれる「検証可能性」の概念を満たすこともできます。VOPRFは、クライアントがプロトコルの実行中にサーバーが特定の秘密キーを使用したことを確認できるようにします。VOPRFは、POPRFと呼ばれる部分的に忘れられます。POPRFを使用すると、クライアントとサーバーがPRF計算への公開入力を提供できます。このドキュメントは、楕円曲線を含む標準的なプライムオーダーグループ内にインスタンス化されたOPRF、VOPRF、およびPOPRFを指定します。このドキュメントは、IRTFのCrypto Forum Research Group（CFRG）の製品です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントは、インターネット標準の追跡仕様ではありません。情報目的で公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Crypto Forum Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネット研究タスクフォース（IRTF）の製品です。IRTFは、インターネット関連の研究開発活動の結果を公開しています。これらの結果は、展開に適していない場合があります。このRFCは、インターネット研究タスクフォース（IRTF）の暗号フォーラム研究グループのコンセンサスを表しています。IRSGによって公開されたことが承認された文書は、インターネット標準のレベルの候補者ではありません。RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9497.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https：//www.rfc-editor.org/info/rfc9497で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2023 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2023 IETF Trustおよび文書著者として特定された人。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Requirements Language\n  1.2.  Notation and Terminology\n2.  Preliminaries\n  2.1.  Prime-Order Group\n  2.2.  Discrete Logarithm Equivalence Proofs\n    2.2.1.  Proof Generation\n    2.2.2.  Proof Verification\n3.  Protocol\n  3.1.  Configuration\n  3.2.  Key Generation and Context Setup\n    3.2.1.  Deterministic Key Generation\n  3.3.  Online Protocol\n    3.3.1.  OPRF Protocol\n    3.3.2.  VOPRF Protocol\n    3.3.3.  POPRF Protocol\n4.  Ciphersuites\n  4.1.  OPRF(ristretto255, SHA-512)\n  4.2.  OPRF(decaf448, SHAKE-256)\n  4.3.  OPRF(P-256, SHA-256)\n  4.4.  OPRF(P-384, SHA-384)\n  4.5.  OPRF(P-521, SHA-512)\n  4.6.  Future Ciphersuites\n  4.7.  Random Scalar Generation\n    4.7.1.  Rejection Sampling\n    4.7.2.  Random Number Generation Using Extra Random Bits\n5.  Application Considerations\n  5.1.  Input Limits\n  5.2.  External Interface Recommendations\n  5.3.  Error Considerations\n  5.4.  POPRF Public Input\n6.  IANA Considerations\n7.  Security Considerations\n  7.1.  Security Properties\n  7.2.  Security Assumptions\n    7.2.1.  OPRF and VOPRF Assumptions\n    7.2.2.  POPRF Assumptions\n    7.2.3.  Static Diffie-Hellman Attack and Security Limits\n  7.3.  Domain Separation\n  7.4.  Timing Leaks\n8.  References\n  8.1.  Normative References\n  8.2.  Informative References\nAppendix A.  Test Vectors\n  A.1.  ristretto255-SHA512\n    A.1.1.  OPRF Mode\n    A.1.2.  VOPRF Mode\n    A.1.3.  POPRF Mode\n  A.2.  decaf448-SHAKE256\n    A.2.1.  OPRF Mode\n    A.2.2.  VOPRF Mode\n    A.2.3.  POPRF Mode\n  A.3.  P256-SHA256\n    A.3.1.  OPRF Mode\n    A.3.2.  VOPRF Mode\n    A.3.3.  POPRF Mode\n  A.4.  P384-SHA384\n    A.4.1.  OPRF Mode\n    A.4.2.  VOPRF Mode\n    A.4.3.  POPRF Mode\n  A.5.  P521-SHA512\n    A.5.1.  OPRF Mode\n    A.5.2.  VOPRF Mode\n    A.5.3.  POPRF Mode\nAcknowledgements\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "A Pseudorandom Function (PRF) F(k, x) is an efficiently computable function taking a private key k and a value x as input. This function is pseudorandom if the keyed function K(_) = F(k, _) is indistinguishable from a randomly sampled function acting on the same domain and range as K(). An Oblivious PRF (OPRF) is a two-party protocol between a server and a client, wherein the server holds a PRF key k and the client holds some input x. The protocol allows both parties to cooperate in computing F(k, x), such that the client learns F(k, x) without learning anything about k and the server does not learn anything about x or F(k, x). A Verifiable OPRF (VOPRF) is an OPRF, wherein the server also proves to the client that F(k, x) was produced by the key k corresponding to the server's public key, which the client knows. A Partially Oblivious PRF (POPRF) is a variant of a VOPRF, where the client and server interact in computing F(k, x, y), for some PRF F with server-provided key k, client-provided input x, and public input y, and the client receives proof that F(k, x, y) was computed using k corresponding to the public key that the client knows. A POPRF with fixed input y is functionally equivalent to a VOPRF.",
      "ja": "擬似ランダム関数（PRF）f（k、x）は、秘密キーkと値xを入力として使用する効率的に計算可能な関数です。キー付き関数k（_）= f（k、_）が、K（）と同じドメインと範囲に作用するランダムにサンプリングされた関数と区別できない場合、この関数は擬似ランダムです。忘れられないPRF（OPRF）は、サーバーとクライアントの間の2パーティのプロトコルであり、サーバーはPRFキーKを保持し、クライアントはいくつかの入力Xを保持します。プロトコルにより、両当事者はf（k、x）の計算に協力することができます。そのため、クライアントはkについて何も学習せずにf（k、x）を学習し、サーバーはxまたはf（k、x）について何も学習しません。検証可能なOPRF（VOPRF）はOPRFであり、サーバーはクライアントに、クライアントが知っているサーバーの公開キーに対応するキーKによってF（k、x）が生成されたことをクライアントに証明します。部分的に忘れられないPRF（POPRF）は、VOPRFのバリアントであり、クライアントとサーバーがコンピューティングF（K、X、Y）で対話し、サーバーが提供するキーK、クライアントが提供する入力X、およびパブリックを備えた一部のPRF Fについて入力Y、およびクライアントは、クライアントが知っている公開キーに対応するkを使用してf（k、x、y）が計算されたという証拠を受け取ります。固定入力yを持つPOPRFは、VOPRFと機能的に同等です。"
    },
    {
      "indent": 3,
      "text": "OPRFs have a variety of applications, including password-protected secret sharing schemes [JKKX16], privacy-preserving password stores [SJKS17], and password-authenticated key exchange (PAKE) [OPAQUE]. Verifiable OPRFs are necessary in some applications, such as Privacy Pass [PRIVACY-PASS]. Verifiable OPRFs have also been used for password-protected secret sharing schemes, such as that of [JKK14].",
      "ja": "OPRFには、パスワードで保護されたシークレット共有スキーム[JKKX16]、プライバシーを提供するパスワードストア[SJKS17]、パスワード認証キーエクスチェンジ（PAKE）[Opaque]など、さまざまなアプリケーションがあります。プライバシーパス[プライバシーパス]など、一部のアプリケーションで検証可能なOPRFが必要です。検証可能なOPRFは、[JKK14]のようなパスワードで保護されたシークレット共有スキームにも使用されています。"
    },
    {
      "indent": 3,
      "text": "This document specifies OPRF, VOPRF, and POPRF protocols built upon prime-order groups. The document describes each protocol variant, along with application considerations, and their security properties.",
      "ja": "このドキュメントは、Prim-Orderグループに基づいて構築されたOPRF、VOPRF、およびPOPRFプロトコルを指定します。このドキュメントでは、各プロトコルのバリアントと、アプリケーションの考慮事項とそのセキュリティプロパティについて説明しています。"
    },
    {
      "indent": 3,
      "text": "This document represents the consensus of the Crypto Forum Research Group (CFRG). It is not an IETF product and is not a standard.",
      "ja": "このドキュメントは、Crypto Forum Research Group（CFRG）のコンセンサスを表しています。IETF製品ではなく、標準でもありません。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Notation and Terminology",
      "section_title": true,
      "ja": "1.2. 表記と用語"
    },
    {
      "indent": 3,
      "text": "The following functions and notation are used throughout the document.",
      "ja": "次の機能と表記は、ドキュメント全体で使用されます。"
    },
    {
      "indent": 6,
      "text": "* For any object x, we write len(x) to denote its length in bytes.",
      "ja": "* 任意のオブジェクトXについては、len（x）を書き込み、バイト単位の長さを示します。"
    },
    {
      "indent": 6,
      "text": "* For two-byte arrays x and y, write x || y to denote their concatenation.",
      "ja": "* 2バイト配列xおよびyの場合、xを書き込み||yそれらの連結を示す。"
    },
    {
      "indent": 6,
      "text": "* I2OSP(x, xLen) converts a nonnegative integer x into a byte array of specified length xLen, as described in [RFC8017]. Note that this function returns a byte array in big-endian byte order.",
      "ja": "* i2osp（x、xlen）は、[RFC8017]で説明されているように、非陰性整数Xを指定された長さXLENのバイト配列に変換します。この関数は、Big-Endianバイトの順序でバイト配列を返すことに注意してください。"
    },
    {
      "indent": 6,
      "text": "* The notation T U[N] refers to an array called U, containing N items of type T. The type opaque means one single byte of uninterpreted data. Items of the array are zero-indexed and referred to as U[j], such that 0 <= j < N.",
      "ja": "* 表記t u [n]は、タイプTのnアイテムを含むuと呼ばれる配列を指します。タイプ不透明は、解釈されていないデータの1つのバイトを意味します。配列のアイテムはゼロインデックス化されており、u [j]と呼ばれるため、0 <= j <n。"
    },
    {
      "indent": 3,
      "text": "All algorithms and procedures described in this document are laid out in a Python-like pseudocode. Each function takes a set of inputs and parameters and produces a set of output values. Parameters become constant values once the protocol variant and the ciphersuite are fixed.",
      "ja": "このドキュメントで説明されているすべてのアルゴリズムと手順は、Pythonのような擬似コードでレイアウトされています。各関数は、入力とパラメーターのセットを取得し、一連の出力値を生成します。パラメーターは、プロトコルバリアントとciphersuiteが固定されると、一定の値になります。"
    },
    {
      "indent": 3,
      "text": "The PrivateInput data type refers to inputs that are known only to the client in the protocol, whereas the PublicInput data type refers to inputs that are known to both the client and server in the protocol. Both PrivateInput and PublicInput are opaque byte strings of arbitrary length no larger than 2^16 - 1 bytes. This length restriction exists because PublicInput and PrivateInput values are length-prefixed with two bytes before use throughout the protocol.",
      "ja": "PrivateInputデータ型は、プロトコル内のクライアントのみに知られている入力を指しますが、PublicInputデータ型は、プロトコル内のクライアントとサーバーの両方に知られている入力を指します。PrivateInputとpublicInputの両方は、2^16-1バイトより大きくない任意の長さの不透明なバイト文字列です。この長さの制限は、PublicInputとPrivateInputの値がプロトコル全体で使用する前に2バイトで長さで固定されているため存在します。"
    },
    {
      "indent": 3,
      "text": "String values, such as \"DeriveKeyPair\", \"Seed-\", and \"Finalize\", are ASCII string literals.",
      "ja": "「derivekeypair」、「シード」、「ファイナライズ」などの文字列値は、ASCII文字列リテラルです。"
    },
    {
      "indent": 3,
      "text": "The following terms are used throughout this document.",
      "ja": "このドキュメント全体で次の用語が使用されています。"
    },
    {
      "indent": 3,
      "text": "PRF:",
      "ja": "PRF："
    },
    {
      "indent": 12,
      "text": "Pseudorandom Function",
      "ja": "擬似ランダム関数"
    },
    {
      "indent": 3,
      "text": "OPRF:",
      "ja": "OPRF："
    },
    {
      "indent": 12,
      "text": "Oblivious Pseudorandom Function",
      "ja": "忘れられない擬似ランダム機能"
    },
    {
      "indent": 3,
      "text": "VOPRF:",
      "ja": "voprf："
    },
    {
      "indent": 12,
      "text": "Verifiable Oblivious Pseudorandom Function",
      "ja": "検証可能な忘却の疑似ランダム機能"
    },
    {
      "indent": 3,
      "text": "POPRF:",
      "ja": "poprf："
    },
    {
      "indent": 12,
      "text": "Partially Oblivious Pseudorandom Function",
      "ja": "部分的に忘れられない疑似ランダム機能"
    },
    {
      "indent": 3,
      "text": "Client:",
      "ja": "クライアント："
    },
    {
      "indent": 12,
      "text": "Protocol initiator. Learns PRF evaluation as the output of the protocol.",
      "ja": "プロトコルイニシエーター。PRF評価をプロトコルの出力として学習します。"
    },
    {
      "indent": 3,
      "text": "Server:",
      "ja": "サーバ："
    },
    {
      "indent": 12,
      "text": "Computes the PRF using a private key. Learns nothing about the client's input or output.",
      "ja": "秘密鍵を使用してPRFを計算します。クライアントの入力や出力については何も学びません。"
    },
    {
      "indent": 0,
      "text": "2. Preliminaries",
      "section_title": true,
      "ja": "2. 予備"
    },
    {
      "indent": 3,
      "text": "The protocols in this document have two primary dependencies:",
      "ja": "このドキュメントのプロトコルには、2つの主要な依存関係があります。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ："
    },
    {
      "indent": 12,
      "text": "A prime-order group implementing the API described below in Section 2.1. See Section 4 for specific instances of groups.",
      "ja": "以下で説明するAPIをセクション2.1で実装するプライムオーダーグループ。グループの特定のインスタンスについては、セクション4を参照してください。"
    },
    {
      "indent": 3,
      "text": "Hash:",
      "ja": "ハッシュ："
    },
    {
      "indent": 12,
      "text": "A cryptographic hash function whose output length is Nh bytes.",
      "ja": "出力の長さがNHバイトである暗号化ハッシュ関数。"
    },
    {
      "indent": 3,
      "text": "Section 4 specifies ciphersuites as combinations of Group and Hash.",
      "ja": "セクション4では、Ciphersuitesはグループとハッシュの組み合わせとして指定しています。"
    },
    {
      "indent": 0,
      "text": "2.1. Prime-Order Group",
      "section_title": true,
      "ja": "2.1. プライムオーダーグループ"
    },
    {
      "indent": 3,
      "text": "In this document, we assume the construction of an additive, prime-order group, denoted Group, for performing all mathematical operations. In prime-order groups, any element (other than the identity) can generate the other elements of the group. Usually, one element is fixed and defined as the group generator. Such groups are uniquely determined by the choice of the prime p that defines the order of the group. (However, different representations of the group for a single p may exist. Section 4 lists specific groups that indicate both the order and representation.)",
      "ja": "このドキュメントでは、すべての数学的操作を実行するために、添加剤、プライムオーダーグループ、示されたグループの構築を想定しています。プライムオーダーグループでは、任意の要素（アイデンティティ以外）がグループの他の要素を生成できます。通常、1つの要素が固定され、グループジェネレーターとして定義されます。このようなグループは、グループの順序を定義するプライムPの選択によって独自に決定されます。（ただし、単一のPのグループの異なる表現が存在する可能性があります。セクション4には、順序と表現の両方を示す特定のグループがリストされています。）"
    },
    {
      "indent": 3,
      "text": "The fundamental group operation is addition + with identity element I. For any elements A and B of the group, A + B = B + A is also a member of the group. Also, for any A in the group, there exists an element -A, such that A + (-A) = (-A) + A = I. Scalar multiplication by r is equivalent to the repeated application of the group operation on an element A with itself r - 1 times; this is denoted as r * A = A + ... + A. For any element A, p * A = I. The case when the scalar multiplication is performed on the group generator is denoted as ScalarMultGen(r). Given two elements A and B, the discrete logarithm problem is to find an integer k, such that B = k * A. Thus, k is the discrete logarithm of B with respect to the base A. The set of scalars corresponds to GF(p), a prime field of order p, and is represented as the set of integers defined by {0, 1, ..., p - 1}. This document uses types Element and Scalar to denote elements of the group and its set of scalars, respectively.",
      "ja": "基本的なグループ操作は、ID要素Iを追加することです。グループの任意の要素AおよびBについて、b = b aはグループのメンバーでもあります。また、グループ内の任意のAには、a（-a）=（-a）a = Iの要素-aが存在します。それ自体がr -1回。これは、r * a = a ... Aとして示されます。任意の要素a、p * a = Iの場合、グループジェネレーターでスカラー乗算が実行される場合は、scalarmultgen（r）として示されます。2つの要素aとbを考えると、離散対数問題は整数kを見つけることです。これにより、b = k * Aのように、kはベースAに対してbの離散対数です。スカラーのセットはGFに対応します（p）、順序Pの素数フィールド、および{0、1、...、p -1}で定義される整数のセットとして表されます。このドキュメントでは、タイプ要素とスカラーを使用して、グループの要素とそのスカラーのセットをそれぞれ示します。"
    },
    {
      "indent": 3,
      "text": "We now detail a number of member functions that can be invoked on a prime-order group.",
      "ja": "現在、プライムオーダーグループで呼び出すことができる多くのメンバー関数について詳しく説明しています。"
    },
    {
      "indent": 3,
      "text": "Order():",
      "ja": "注文（）："
    },
    {
      "indent": 12,
      "text": "Outputs the order of the group (i.e., p).",
      "ja": "グループの順序を出力します（つまり、p）。"
    },
    {
      "indent": 3,
      "text": "Identity():",
      "ja": "身元（）："
    },
    {
      "indent": 12,
      "text": "Outputs the identity element of the group (i.e., I).",
      "ja": "グループのアイデンティティ要素（つまり、i）を出力します。"
    },
    {
      "indent": 3,
      "text": "Generator():",
      "ja": "発生器（）："
    },
    {
      "indent": 12,
      "text": "Outputs the generator element of the group.",
      "ja": "グループのジェネレーター要素を出力します。"
    },
    {
      "indent": 3,
      "text": "HashToGroup(x):",
      "ja": "Hashtogroup（x）："
    },
    {
      "indent": 12,
      "text": "Deterministically maps an array of bytes x to an element of Group. The map must ensure that, for any adversary receiving R = HashToGroup(x), it is computationally difficult to reverse the mapping. This function is optionally parameterized by a domain separation tag (DST); see Section 4. Security properties of this function are described in [RFC9380].",
      "ja": "決定論的に、一連のバイトxをグループの要素にマッピングします。マップは、r = hashtogroup（x）を受け取っている敵の場合、マッピングを逆転させることが計算が困難であることを確認する必要があります。この関数は、オプションでドメイン分離タグ（DST）によってパラメーター化されます。セクション4を参照してください。この関数のセキュリティプロパティは[RFC9380]で説明されています。"
    },
    {
      "indent": 3,
      "text": "HashToScalar(x):",
      "ja": "Hashtoscalar（x）："
    },
    {
      "indent": 12,
      "text": "Deterministically maps an array of bytes x to an element in GF(p). This function is optionally parameterized by a DST; see Section 4. Security properties of this function are described in [RFC9380], Section 10.5.",
      "ja": "決定論的に、バイトxの配列をGF（p）の要素にマッピングします。この関数は、オプションでDSTによってパラメーター化されています。セクション4を参照してください。この関数のセキュリティプロパティは、[RFC9380]、セクション10.5で説明されています。"
    },
    {
      "indent": 3,
      "text": "RandomScalar():",
      "ja": "randomscalar（）："
    },
    {
      "indent": 12,
      "text": "Chooses at random a nonzero element in GF(p).",
      "ja": "GF（P）でゼロ以外の要素をランダムに選択します。"
    },
    {
      "indent": 3,
      "text": "ScalarInverse(s):",
      "ja": "ScalarInverse（s）："
    },
    {
      "indent": 12,
      "text": "Returns the inverse of input Scalar s on GF(p).",
      "ja": "GF（P）の入力スカラーSの逆を返します。"
    },
    {
      "indent": 3,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement（a）："
    },
    {
      "indent": 12,
      "text": "Maps an Element A to a canonical byte array buf of fixed-length Ne.",
      "ja": "要素aを固定長neの標準的なバイト配列bufにマッピングします。"
    },
    {
      "indent": 3,
      "text": "DeserializeElement(buf):",
      "ja": "DeserializeElement（BUF）："
    },
    {
      "indent": 12,
      "text": "Attempts to map a byte array buf to an Element A and fails if the input is not the valid canonical byte representation of an element of the group. This function can raise a DeserializeError if deserialization fails or A is the identity element of the group; see Section 4 for group-specific input validation steps.",
      "ja": "バイト配列BUFを要素Aにマッピングしようとする試みは、入力がグループの要素の有効な標準バイト表現ではない場合に故障します。この関数は、脱介入が失敗する場合、またはAがグループのアイデンティティ要素である場合、DeserializeErrorを上げることができます。グループ固有の入力検証手順については、セクション4を参照してください。"
    },
    {
      "indent": 3,
      "text": "SerializeScalar(s):",
      "ja": "serializescalar（s）："
    },
    {
      "indent": 12,
      "text": "Maps Scalar s to a canonical byte array buf of fixed-length Ns.",
      "ja": "固定長nsの標準バイト配列bufにスカラーをマップします。"
    },
    {
      "indent": 3,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar（BUF）："
    },
    {
      "indent": 12,
      "text": "Attempts to map a byte array buf to Scalar s. This function can raise a DeserializeError if deserialization fails; see Section 4 for group-specific input validation steps.",
      "ja": "バイトアレイBUFをスカラーにマッピングしようとします。この関数は、敏arialialializationが失敗した場合、脱介入を上げることができます。グループ固有の入力検証手順については、セクション4を参照してください。"
    },
    {
      "indent": 3,
      "text": "Section 4 contains details for the implementation of this interface for different prime-order groups instantiated over elliptic curves. In particular, for some choices of elliptic curves, e.g., those detailed in [RFC7748], which require accounting for cofactors, Section 4 describes required steps necessary to ensure the resulting group is of prime order.",
      "ja": "セクション4には、楕円曲線上にインスタンス化されたさまざまなプライムオーダーグループのこのインターフェイスの実装の詳細が含まれています。特に、楕円曲線、たとえば[RFC7748]で詳述されている楕円曲線のいくつかの選択では、補助因子の会計を必要とするものでは、セクション4では、結果のグループが一次秩序であることを確認するために必要な手順について説明します。"
    },
    {
      "indent": 0,
      "text": "2.2. Discrete Logarithm Equivalence Proofs",
      "section_title": true,
      "ja": "2.2. 離散対数等価証明"
    },
    {
      "indent": 3,
      "text": "A proof of knowledge allows a prover to convince a verifier that some statement is true. If the prover can generate a proof without interaction with the verifier, the proof is noninteractive. If the verifier learns nothing other than whether the statement claimed by the prover is true or false, the proof is zero-knowledge.",
      "ja": "知識の証明により、プローバーは、いくつかの声明が真実であることを検証者に納得させることができます。プロバーが検証剤との相互作用なしに証明を生成できる場合、証明は非相互作用です。検証者が、得点者によって主張された声明が真か虚偽であるかどうか以外に何も学習しない場合、証明はゼロ知識です。"
    },
    {
      "indent": 3,
      "text": "This section describes a noninteractive, zero-knowledge proof for discrete logarithm equivalence (DLEQ), which is used in the construction of VOPRF and POPRF. A DLEQ proof demonstrates that two pairs of group elements have the same discrete logarithm without revealing the discrete logarithm.",
      "ja": "このセクションでは、VOPRFおよびPOPRFの構築に使用される離散対数等価（DLEQ）の非インタラクティブなゼロ知識証明について説明します。DLEQの証明は、2つのペアのグループ要素が、離散対数を明らかにすることなく同じ離散対数を持っていることを示しています。"
    },
    {
      "indent": 3,
      "text": "The DLEQ proof resembles the Chaum-Pedersen [ChaumPedersen] proof, which is shown to be zero-knowledge by Jarecki, et al. [JKK14] and is noninteractive after applying the Fiat-Shamir transform [FS00]. Furthermore, Davidson, et al. [DGSTV18] showed a proof system for batching DLEQ proofs that has constant-size proofs with respect to the number of inputs. The specific DLEQ proof system presented below follows this latter construction with two modifications: (1) the transcript used to generate the seed includes more context information and (2) the individual challenges for each element in the proof is derived from a seed-prefixed hash-to-scalar invocation, rather than being sampled from a seeded Pseudorandom Number Generator (PRNG). The description is split into two subsections: one for generating the proof, which is done by servers in the verifiable protocols, and another for verifying the proof, which is done by clients in the protocol.",
      "ja": "DLEQの証明は、Chaum-Pedersen [Chaumpedersen]の証明に似ています。これは、Jarecki、et al。[JKK14]およびフィアットシャミル変換[FS00]を適用した後、非インタラクティブです。さらに、Davidson等。[DGSTV18]は、入力数に関して一定サイズの証明を持つDLEQプルーフをバッチするための証明システムを示しました。以下に示す特定のDLEQプルーフシステムは、2つの変更を伴うこの後者の構造に続きます。（1）シードを生成するために使用される転写には、より多くのコンテキスト情報が含まれ、（2）証明の各要素の個々の課題は、シードが育てられたハッシュから導き出されます。 - シードされた擬似ランダム数ジェネレーター（PRNG）からサンプリングされるのではなく、スカラーへの呼び出し。説明は2つのサブセクションに分割されます。1つは、検証可能なプロトコル内のサーバーによって行われる証明を生成するための1つ、もう1つはプロトコルのクライアントによって行われる証明を検証するために行われます。"
    },
    {
      "indent": 0,
      "text": "2.2.1. Proof Generation",
      "section_title": true,
      "ja": "2.2.1. 証明生成"
    },
    {
      "indent": 3,
      "text": "Generating a proof is done with the GenerateProof function, as defined below. Given Element values A and B, two non-empty lists of Element values C and D of length m, and Scalar k, this function produces a proof that k * A == B and k * C[i] == D[i] for each i in [0, ..., m - 1]. The output is a value of type Proof, which is a tuple of two Scalar values. We use the notation proof[0] and proof[1] to denote the first and second elements in this tuple, respectively.",
      "ja": "以下に定義するように、生成されたプルーフ関数でプルーフを生成することが行われます。要素値aとb、長さm、およびスカラーkの要素値cとdの2つの非空白のリストを指定すると、この関数はk * a == bおよびk * c [i] == d [iの証拠を生成します。] [0、...、m -1]の各iについて。出力はタイプ証明の値であり、2つのスカラー値のタプルです。表記証明[0]と証明[1]を使用して、それぞれこのタプルの最初と2番目の要素を示します。"
    },
    {
      "indent": 3,
      "text": "GenerateProof accepts lists of inputs to amortize the cost of proof generation. Applications can take advantage of this functionality to produce a single, constant-sized proof for m DLEQ inputs, rather than m proofs for m DLEQ inputs.",
      "ja": "GenerateProofは、入力のリストを受け入れ、証明生成のコストを償却します。アプリケーションは、この機能を利用して、M DLEQ入力のMプルーフではなく、M DLEQ入力の単一の定数サイズの証明を作成できます。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  Scalar k\n  Element A\n  Element B\n  Element C[m]\n  Element D[m]\n\nOutput:\n\n  Proof proof\n\nParameters:\n\n  Group G\n\ndef GenerateProof(k, A, B, C, D):\n  (M, Z) = ComputeCompositesFast(k, B, C, D)\n\n  r = G.RandomScalar()\n  t2 = r * A\n  t3 = r * M\n\n  Bm = G.SerializeElement(B)\n  a0 = G.SerializeElement(M)\n  a1 = G.SerializeElement(Z)\n  a2 = G.SerializeElement(t2)\n  a3 = G.SerializeElement(t3)\n\n  challengeTranscript =\n    I2OSP(len(Bm), 2) || Bm ||\n    I2OSP(len(a0), 2) || a0 ||\n    I2OSP(len(a1), 2) || a1 ||\n    I2OSP(len(a2), 2) || a2 ||\n    I2OSP(len(a3), 2) || a3 ||\n    \"Challenge\"\n\n  c = G.HashToScalar(challengeTranscript)\n  s = r - c * k\n\n  return [c, s]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The helper function ComputeCompositesFast is as defined below and is an optimization of the ComputeComposites function for servers since they have knowledge of the private key.",
      "ja": "ヘルパー関数ComputeCompositesfastは、以下に定義されているとおりであり、秘密鍵の知識があるため、サーバーのComputeComposites関数の最適化です。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  Scalar k\n  Element B\n  Element C[m]\n  Element D[m]\n\nOutput:\n\n  Element M\n  Element Z\n\nParameters:\n\n  Group G\n  PublicInput contextString\n\ndef ComputeCompositesFast(k, B, C, D):\n  Bm = G.SerializeElement(B)\n  seedDST = \"Seed-\" || contextString\n  seedTranscript =\n    I2OSP(len(Bm), 2) || Bm ||\n    I2OSP(len(seedDST), 2) || seedDST\n  seed = Hash(seedTranscript)\n\n  M = G.Identity()\n  for i in range(m):\n    Ci = G.SerializeElement(C[i])\n    Di = G.SerializeElement(D[i])\n    compositeTranscript =\n      I2OSP(len(seed), 2) || seed || I2OSP(i, 2) ||\n      I2OSP(len(Ci), 2) || Ci ||\n      I2OSP(len(Di), 2) || Di ||\n      \"Composite\"\n\n    di = G.HashToScalar(compositeTranscript)\n    M = di * C[i] + M\n\n  Z = k * M\n\n  return (M, Z)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When used in the protocol described in Section 3, the parameter contextString is as defined in Section 3.2.",
      "ja": "セクション3で説明したプロトコルで使用する場合、パラメーターコンテキストストリングはセクション3.2で定義されています。"
    },
    {
      "indent": 0,
      "text": "2.2.2. Proof Verification",
      "section_title": true,
      "ja": "2.2.2. 証明検証"
    },
    {
      "indent": 3,
      "text": "Verifying a proof is done with the VerifyProof function, as defined below. This function takes Element values A and B, two non-empty lists of Element values C and D of length m, and a Proof value output from GenerateProof. It outputs a single boolean value indicating whether or not the proof is valid for the given DLEQ inputs. Note this function can verify proofs on lists of inputs whenever the proof was generated as a batched DLEQ proof with the same inputs.",
      "ja": "以下に定義するように、証明の検証は、Verifruproof関数で行われます。この関数は、要素値aとb、長さmの要素値cとdの2つの非空白のリスト、および生成プルーフからの証明値出力を取得します。特定のDLEQ入力に対して証明が有効かどうかを示す単一のブール値を出力します。注この関数は、同じ入力を持つバッチ付きDLEQプルーフとして証明が生成されたときはいつでも、入力のリストの証明を確認できます。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  Element A\n  Element B\n  Element C[m]\n  Element D[m]\n  Proof proof\n\nOutput:\n\n  boolean verified\n\nParameters:\n\n  Group G\n\ndef VerifyProof(A, B, C, D, proof):\n  (M, Z) = ComputeComposites(B, C, D)\n  c = proof[0]\n  s = proof[1]\n\n  t2 = ((s * A) + (c * B))\n  t3 = ((s * M) + (c * Z))\n\n  Bm = G.SerializeElement(B)\n  a0 = G.SerializeElement(M)\n  a1 = G.SerializeElement(Z)\n  a2 = G.SerializeElement(t2)\n  a3 = G.SerializeElement(t3)\n\n  challengeTranscript =\n    I2OSP(len(Bm), 2) || Bm ||\n    I2OSP(len(a0), 2) || a0 ||\n    I2OSP(len(a1), 2) || a1 ||\n    I2OSP(len(a2), 2) || a2 ||\n    I2OSP(len(a3), 2) || a3 ||\n    \"Challenge\"\n\n  expectedC = G.HashToScalar(challengeTranscript)\n  verified = (expectedC == c)\n\n  return verified",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The definition of ComputeComposites is given below.",
      "ja": "ComputeCompositesの定義を以下に示します。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  Element B\n  Element C[m]\n  Element D[m]\n\nOutput:\n\n  Element M\n  Element Z\n\nParameters:\n\n  Group G\n  PublicInput contextString\n\ndef ComputeComposites(B, C, D):\n  Bm = G.SerializeElement(B)\n  seedDST = \"Seed-\" || contextString\n  seedTranscript =\n    I2OSP(len(Bm), 2) || Bm ||\n    I2OSP(len(seedDST), 2) || seedDST\n  seed = Hash(seedTranscript)\n\n  M = G.Identity()\n  Z = G.Identity()\n  for i in range(m):\n    Ci = G.SerializeElement(C[i])\n    Di = G.SerializeElement(D[i])\n    compositeTranscript =\n      I2OSP(len(seed), 2) || seed || I2OSP(i, 2) ||\n      I2OSP(len(Ci), 2) || Ci ||\n      I2OSP(len(Di), 2) || Di ||\n      \"Composite\"\n\n    di = G.HashToScalar(compositeTranscript)\n    M = di * C[i] + M\n    Z = di * D[i] + Z\n\n  return (M, Z)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When used in the protocol described in Section 3, the parameter contextString is as defined in Section 3.2.",
      "ja": "セクション3で説明したプロトコルで使用する場合、パラメーターコンテキストストリングはセクション3.2で定義されています。"
    },
    {
      "indent": 0,
      "text": "3. Protocol",
      "section_title": true,
      "ja": "3. プロトコル"
    },
    {
      "indent": 3,
      "text": "In this section, we define and describe three protocol variants referred to as the OPRF, VOPRF, and POPRF modes. Each of these variants involves two messages between the client and server, but they differ slightly in terms of the security properties; see Section 7.1 for more information. A high-level description of the functionality of each mode follows.",
      "ja": "このセクションでは、OPRF、VOPRF、およびPOPRFモードと呼ばれる3つのプロトコルバリアントを定義および説明します。これらのバリエーションにはそれぞれ、クライアントとサーバーの間に2つのメッセージが含まれますが、セキュリティプロパティの点でわずかに異なります。詳細については、セクション7.1を参照してください。各モードの機能の高レベルの説明が続きます。"
    },
    {
      "indent": 3,
      "text": "In the OPRF mode, a client and server interact to compute output = F(skS, input), where input is the client's private input, skS is the server's private key, and output is the OPRF output. After the execution of the protocol, the client learns the output and the server learns nothing. This interaction is shown below.",
      "ja": "OPRFモードでは、クライアントとサーバーが対話して出力= F（SKS、入力）を計算します。入力はクライアントのプライベート入力であり、SKSはサーバーのプライベートキー、出力はOPRF出力です。プロトコルの実行後、クライアントは出力を学習し、サーバーは何も学習しません。この相互作用を以下に示します。"
    },
    {
      "indent": 5,
      "text": "  Client(input)                                        Server(skS)\n-------------------------------------------------------------------\nblind, blindedElement = Blind(input)\n\n                           blindedElement\n                             ---------->\n\n              evaluatedElement = BlindEvaluate(skS, blindedElement)\n\n                           evaluatedElement\n                             <----------\n\noutput = Finalize(input, blind, evaluatedElement)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 1: OPRF Protocol Overview",
      "ja": "図1：OPRFプロトコルの概要"
    },
    {
      "indent": 3,
      "text": "In the VOPRF mode, the client additionally receives proof that the server used skS in computing the function. To achieve verifiability, as in [JKK14], the server provides a zero-knowledge proof that the key provided as input by the server in the BlindEvaluate function is the same key as is used to produce the server's public key, pkS, which the client receives as input to the protocol. This proof does not reveal the server's private key to the client. This interaction is shown below.",
      "ja": "VOPRFモードでは、クライアントは、サーバーが関数の計算にSKSを使用したという証拠をさらに受信します。[jkk14]のように検証可能性を実現するために、サーバーは、voldingvaluate関数のサーバーによって入力として提供されたキーが、サーバーの公開キーであるPKSを作成するために使用されるものと同じキーであるというゼロ知識証明を提供します。プロトコルへの入力として受信します。この証明は、クライアントに対するサーバーの秘密鍵を明らかにしません。この相互作用を以下に示します。"
    },
    {
      "indent": 5,
      "text": "  Client(input, pkS)       <---- pkS ------        Server(skS, pkS)\n-------------------------------------------------------------------\nblind, blindedElement = Blind(input)\n\n                           blindedElement\n                             ---------->\n\n            evaluatedElement, proof = BlindEvaluate(skS, pkS,\n                                                    blindedElement)\n\n                       evaluatedElement, proof\n                             <----------\n\noutput = Finalize(input, blind, evaluatedElement,\n                  blindedElement, pkS, proof)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Figure 2: VOPRF Protocol Overview with Additional Proof",
      "ja": "図2：追加の証明を備えたVOPRFプロトコルの概要"
    },
    {
      "indent": 3,
      "text": "The POPRF mode extends the VOPRF mode such that the client and server can additionally provide the public input info, which is used in computing the PRF. That is, the client and server interact to compute output = F(skS, input, info), as is shown below.",
      "ja": "POPRFモードはVOPRFモードを拡張して、クライアントとサーバーがPRFの計算に使用されるパブリックインプット情報をさらに提供できるようにします。つまり、クライアントとサーバーが対話して、以下に示すように、出力= F（SKS、入力、情報）を計算します。"
    },
    {
      "indent": 5,
      "text": "  Client(input, pkS, info) <---- pkS ------  Server(skS, pkS, info)\n-------------------------------------------------------------------\nblind, blindedElement, tweakedKey = Blind(input, info, pkS)\n\n                           blindedElement\n                             ---------->\n\n       evaluatedElement, proof = BlindEvaluate(skS, blindedElement,\n                                               info)\n\n                       evaluatedElement, proof\n                             <----------\n\noutput = Finalize(input, blind, evaluatedElement,\n                  blindedElement, proof, info, tweakedKey)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 3: POPRF Protocol Overview with Additional Public Input",
      "ja": "図3：追加のパブリック入力を含むPopRFプロトコルの概要"
    },
    {
      "indent": 3,
      "text": "Each protocol consists of an offline setup phase and an online phase, as described in Sections 3.2 and 3.3, respectively. Configuration details for the offline phase are described in Section 3.1.",
      "ja": "各プロトコルは、それぞれセクション3.2および3.3で説明されているように、オフラインセットアップフェーズとオンラインフェーズで構成されています。オフラインフェーズの構成詳細については、セクション3.1で説明します。"
    },
    {
      "indent": 0,
      "text": "3.1. Configuration",
      "section_title": true,
      "ja": "3.1. 構成"
    },
    {
      "indent": 3,
      "text": "Each of the three protocol variants are identified with a one-byte value (in hexadecimal):",
      "ja": "3つのプロトコルバリアントのそれぞれは、1バイト値（16進数）で識別されます。"
    },
    {
      "indent": 28,
      "text": "+===========+=======+\n| Mode      | Value |\n+===========+=======+\n| modeOPRF  | 0x00  |\n+-----------+-------+\n| modeVOPRF | 0x01  |\n+-----------+-------+\n| modePOPRF | 0x02  |\n+-----------+-------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": " Table 1: Identifiers for Protocol Variants",
      "ja": "表1：プロトコルバリアントの識別子"
    },
    {
      "indent": 3,
      "text": "Additionally, each protocol variant is instantiated with a ciphersuite or suite. Each ciphersuite is identified with an ASCII string identifier, referred to as identifier; see Section 4 for the set of initial ciphersuite values.",
      "ja": "さらに、各プロトコルバリアントには、ciphersuiteまたはスイートがインスタンス化されます。各ciphersuiteは、識別子と呼ばれるASCII文字列識別子で識別されます。初期のCiphersuite値のセットについては、セクション4を参照してください。"
    },
    {
      "indent": 3,
      "text": "The mode and ciphersuite identifier values are combined to create a \"context string\" used throughout the protocol with the following function:",
      "ja": "モードとciphersuiteの識別子値を組み合わせて、次の関数を使用してプロトコル全体で使用される「コンテキスト文字列」を作成します。"
    },
    {
      "indent": 3,
      "text": "def CreateContextString(mode, identifier):\n  return \"OPRFV1-\" || I2OSP(mode, 1) || \"-\" || identifier",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2. Key Generation and Context Setup",
      "section_title": true,
      "ja": "3.2. キー生成とコンテキストのセットアップ"
    },
    {
      "indent": 3,
      "text": "In the offline setup phase, the server generates a fresh, random key pair (skS, pkS). There are two ways to generate this key pair. The first of which is using the GenerateKeyPair function described below.",
      "ja": "オフラインセットアップフェーズでは、サーバーは新鮮でランダムなキーペア（SK、PK）を生成します。このキーペアを生成するには、2つの方法があります。その最初のものは、以下で説明するGenerateKeypair関数を使用することです。"
    },
    {
      "indent": 3,
      "text": "Input: None\n\nOutput:\n\n  Scalar skS\n  Element pkS\n\nParameters:\n\n  Group G\n\ndef GenerateKeyPair():\n  skS = G.RandomScalar()\n  pkS = G.ScalarMultGen(skS)\n  return skS, pkS",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The second way to generate the key pair is via the deterministic key generation function DeriveKeyPair, as described in Section 3.2.1. Applications and implementations can use either method in practice.",
      "ja": "キーペアを生成する2番目の方法は、セクション3.2.1で説明されているように、決定論的なキー生成関数を介してKeypairを導きます。アプリケーションと実装は、実際にはどちらの方法も使用できます。"
    },
    {
      "indent": 3,
      "text": "Also during the offline setup phase, both the client and server create a context used for executing the online phase of the protocol after agreeing on a mode and ciphersuite identifier. The context, such as OPRFServerContext, is an implementation-specific data structure that stores a context string and the relevant key material for each party.",
      "ja": "また、オフラインセットアップフェーズでは、クライアントとサーバーの両方が、モードとciphersuite識別子に同意した後、プロトコルのオンラインフェーズを実行するために使用されるコンテキストを作成します。OprfServerContextなどのコンテキストは、コンテキスト文字列と各パーティに関連する重要な資料を保存する実装固有のデータ構造です。"
    },
    {
      "indent": 3,
      "text": "The OPRF variant server and client contexts are created as follows:",
      "ja": "OPRFバリアントサーバーとクライアントコンテキストは次のように作成されます。"
    },
    {
      "indent": 3,
      "text": "def SetupOPRFServer(identifier, skS):\n  contextString = CreateContextString(modeOPRF, identifier)\n  return OPRFServerContext(contextString, skS)\n\ndef SetupOPRFClient(identifier):\n  contextString = CreateContextString(modeOPRF, identifier)\n  return OPRFClientContext(contextString)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The VOPRF variant server and client contexts are created as follows:",
      "ja": "VOPRFバリアントサーバーとクライアントコンテキストは次のように作成されます。"
    },
    {
      "indent": 3,
      "text": "def SetupVOPRFServer(identifier, skS):\n  contextString = CreateContextString(modeVOPRF, identifier)\n  return VOPRFServerContext(contextString, skS)\n\ndef SetupVOPRFClient(identifier, pkS):\n  contextString = CreateContextString(modeVOPRF, identifier)\n  return VOPRFClientContext(contextString, pkS)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The POPRF variant server and client contexts are created as follows:",
      "ja": "POPRFバリアントサーバーとクライアントコンテキストは次のように作成されます。"
    },
    {
      "indent": 3,
      "text": "def SetupPOPRFServer(identifier, skS):\n  contextString = CreateContextString(modePOPRF, identifier)\n  return POPRFServerContext(contextString, skS)\n\ndef SetupPOPRFClient(identifier, pkS):\n  contextString = CreateContextString(modePOPRF, identifier)\n  return POPRFClientContext(contextString, pkS)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.1. Deterministic Key Generation",
      "section_title": true,
      "ja": "3.2.1. 決定論的キー生成"
    },
    {
      "indent": 3,
      "text": "This section describes a deterministic key generation function, DeriveKeyPair. It accepts a seed of 32 bytes generated from a cryptographically secure random number generator and an optional (possibly empty) info string. Note that, by design, knowledge of seed and info is necessary to compute this function, which means that the secrecy of the output private key (skS) depends on the secrecy of seed (since the info string is public).",
      "ja": "このセクションでは、決定論的なキー生成関数であるDeriveKeypairについて説明します。暗号化的に安全な乱数ジェネレーターから生成された32バイトのシードと、オプションの（おそらく空の）情報文字列を受け入れます。設計により、この関数を計算するには種と情報の知識が必要であることに注意してください。つまり、出力秘密鍵（SKS）の秘密は種の秘密に依存することを意味します（情報文字列は公開されているため）。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  opaque seed[32]\n  PublicInput info\n\nOutput:\n\n  Scalar skS\n  Element pkS\n\nParameters:\n\n  Group G\n  PublicInput contextString\n\nErrors: DeriveKeyPairError\n\ndef DeriveKeyPair(seed, info):\n  deriveInput = seed || I2OSP(len(info), 2) || info\n  counter = 0\n  skS = 0\n  while skS == 0:\n    if counter > 255:\n      raise DeriveKeyPairError\n    skS = G.HashToScalar(deriveInput || I2OSP(counter, 1),\n                          DST = \"DeriveKeyPair\" || contextString)\n    counter = counter + 1\n  pkS = G.ScalarMultGen(skS)\n  return skS, pkS",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3. Online Protocol",
      "section_title": true,
      "ja": "3.3. オンラインプロトコル"
    },
    {
      "indent": 3,
      "text": "In the online phase, the client and server engage in a two-message protocol to compute the protocol output. This section describes the protocol details for each protocol variant. Throughout each description, the following parameters are assumed to exist:",
      "ja": "オンラインフェーズでは、クライアントとサーバーが2メッセージプロトコルに参加してプロトコル出力を計算します。このセクションでは、各プロトコルバリアントのプロトコルの詳細について説明します。各説明を通して、次のパラメーターが存在すると想定されています。"
    },
    {
      "indent": 3,
      "text": "G:",
      "ja": "G："
    },
    {
      "indent": 12,
      "text": "a prime-order group implementing the API described in Section 2.1",
      "ja": "セクション2.1で説明したAPIを実装するプライムオーダーグループ"
    },
    {
      "indent": 3,
      "text": "contextString:",
      "ja": "コンテキストストリング："
    },
    {
      "indent": 12,
      "text": "a PublicInput domain separation tag constructed during context setup, as created in Section 3.1",
      "ja": "セクション3.1で作成されたコンテキストセットアップ中に作成されたpublicinputドメイン分離タグ"
    },
    {
      "indent": 3,
      "text": "skS and pkS:",
      "ja": "sks and pks："
    },
    {
      "indent": 12,
      "text": "a Scalar and Element representing the private and public keys configured for the client and server in Section 3.2",
      "ja": "セクション3.2のクライアントとサーバー用に構成されたプライベートキーおよびパブリックキーを表すスカラーと要素"
    },
    {
      "indent": 3,
      "text": "Applications serialize protocol messages between the client and server for transmission. Element values and Scalar values are serialized to byte arrays, and values of type Proof are serialized as the concatenation of two serialized Scalar values. Deserializing these values can fail; in which case, the application MUST abort the protocol, raising a DeserializeError failure.",
      "ja": "アプリケーションは、クライアントとサーバー間のプロトコルメッセージを送信するためにシリアル化します。要素値とスカラー値はバイト配列にシリアル化され、タイプ証明の値は2つのシリアル化されたスカラー値の連結としてシリアル化されます。これらの値をゆるくすることは失敗する可能性があります。その場合、アプリケーションはプロトコルを中止して、脱必要な障害を引き起こす必要があります。"
    },
    {
      "indent": 3,
      "text": "Applications MUST check that input Element values received over the wire are not the group identity element. This check is handled after deserializing Element values; see Section 4 for more information and requirements on input validation for each ciphersuite.",
      "ja": "アプリケーションは、ワイヤーを介して受信した入力要素値がグループID要素ではないことを確認する必要があります。このチェックは、要素の脱気体化の後に処理されます。各ciphersuiteの入力検証に関する詳細情報と要件については、セクション4を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.3.1. OPRF Protocol",
      "section_title": true,
      "ja": "3.3.1. OPRFプロトコル"
    },
    {
      "indent": 3,
      "text": "The OPRF protocol begins with the client blinding its input, as described by the Blind function below. Note that this function can fail with an InvalidInputError error for certain inputs that map to the group identity element. Dealing with this failure is an application-specific decision; see Section 5.3.",
      "ja": "OPRFプロトコルは、以下のブラインド関数で説明されているように、クライアントが入力をブラインドすることから始まります。この関数は、グループIDの要素にマッピングされる特定の入力のInvalidInputErrorエラーで失敗する可能性があることに注意してください。この失敗に対処することは、アプリケーション固有の決定です。セクション5.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  PrivateInput input\n\nOutput:\n\n  Scalar blind\n  Element blindedElement\n\nParameters:\n\n  Group G\n\nErrors: InvalidInputError\n\ndef Blind(input):\n  blind = G.RandomScalar()\n  inputElement = G.HashToGroup(input)\n  if inputElement == G.Identity():\n    raise InvalidInputError\n  blindedElement = blind * inputElement\n\n  return blind, blindedElement",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Clients store blind locally and send blindedElement to the server for evaluation. Upon receipt, servers process blindedElement using the BlindEvaluate function described below.",
      "ja": "クライアントはブラインドをローカルに保存し、評価のためにブラインドレディングをサーバーに送信します。受領時に、サーバーは、以下に説明するブラインド評価機能を使用してブラインドレメントを処理します。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  Scalar skS\n  Element blindedElement\n\nOutput:\n\n  Element evaluatedElement\n\ndef BlindEvaluate(skS, blindedElement):\n  evaluatedElement = skS * blindedElement\n  return evaluatedElement",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Servers send the output evaluatedElement to clients for processing. Recall that servers may process multiple client inputs by applying the BlindEvaluate function to each blindedElement received and returning an array with the corresponding evaluatedElement values.",
      "ja": "サーバーは、処理のためにクライアントに出力EvaluatedElementを送信します。サーバーは、受信した各ブラインドレディレメントに盲目的な関数を適用し、対応する評価された要因を使用して配列を返すことにより、複数のクライアント入力を処理できることを思い出してください。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of evaluatedElement, clients process it to complete the OPRF evaluation with the Finalize function described below.",
      "ja": "EvaluatedElementを受信すると、クライアントはそれを処理して、以下に説明するファイナライズ関数を使用してOPRF評価を完了します。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  PrivateInput input\n  Scalar blind\n  Element evaluatedElement\n\nOutput:\n\n  opaque output[Nh]\n\nParameters:\n\n  Group G\n\ndef Finalize(input, blind, evaluatedElement):\n  N = G.ScalarInverse(blind) * evaluatedElement\n  unblindedElement = G.SerializeElement(N)\n\n  hashInput = I2OSP(len(input), 2) || input ||\n              I2OSP(len(unblindedElement), 2) || unblindedElement ||\n              \"Finalize\"\n  return Hash(hashInput)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An entity that knows both the private key and the input can compute the PRF result using the following Evaluate function.",
      "ja": "秘密鍵と入力の両方を知っているエンティティは、次の評価関数を使用してPRF結果を計算できます。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  Scalar skS\n  PrivateInput input\n\nOutput:\n\n  opaque output[Nh]\n\nParameters:\n\n  Group G\n\nErrors: InvalidInputError\n\ndef Evaluate(skS, input):\n  inputElement = G.HashToGroup(input)\n  if inputElement == G.Identity():\n    raise InvalidInputError\n  evaluatedElement = skS * inputElement\n  issuedElement = G.SerializeElement(evaluatedElement)\n\n  hashInput = I2OSP(len(input), 2) || input ||\n              I2OSP(len(issuedElement), 2) || issuedElement ||\n              \"Finalize\"\n  return Hash(hashInput)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3.2. VOPRF Protocol",
      "section_title": true,
      "ja": "3.3.2. VOPRFプロトコル"
    },
    {
      "indent": 3,
      "text": "The VOPRF protocol begins with the client blinding its input, using the same Blind function as in Section 3.3.1. Clients store the output blind locally and send blindedElement to the server for evaluation. Upon receipt, servers process blindedElement to compute an evaluated element and a DLEQ proof using the following BlindEvaluate function.",
      "ja": "VOPRFプロトコルは、セクション3.3.1と同じブラインド関数を使用して、入力をブラインドするクライアントから始まります。クライアントは、出力ブラインドをローカルに保存し、評価のためにブラインドエレメントをサーバーに送信します。受領時に、サーバーは盲検化を処理して、以下の盲検機能を使用して、評価された要素とDLEQプルーフを計算します。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  Scalar skS\n  Element pkS\n  Element blindedElement\n\nOutput:\n\n  Element evaluatedElement\n  Proof proof\n\nParameters:\n\n  Group G\n\ndef BlindEvaluate(skS, pkS, blindedElement):\n  evaluatedElement = skS * blindedElement\n  blindedElements = [blindedElement]     // list of length 1\n  evaluatedElements = [evaluatedElement] // list of length 1\n  proof = GenerateProof(skS, G.Generator(), pkS,\n                        blindedElements, evaluatedElements)\n  return evaluatedElement, proof",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the description above, inputs to GenerateProof are one-item lists. Using larger lists allows servers to batch the evaluation of multiple elements while producing a single batched DLEQ proof for them.",
      "ja": "上記の説明では、生成するための入力は1項目リストです。より大きなリストを使用すると、サーバーは複数の要素の評価をバッチでバッチでき、単一のバッチDLEQプルーフを作成します。"
    },
    {
      "indent": 3,
      "text": "The server sends both evaluatedElement and proof back to the client. Upon receipt, the client processes both values to complete the VOPRF computation using the Finalize function below.",
      "ja": "サーバーは、evalueatedElementと証明の両方をクライアントに送り返します。受領すると、クライアントは両方の値を処理して、以下のファイナライズ関数を使用してVOPRF計算を完了します。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  PrivateInput input\n  Scalar blind\n  Element evaluatedElement\n  Element blindedElement\n  Element pkS\n  Proof proof\n\nOutput:\n\n  opaque output[Nh]\n\nParameters:\n\n  Group G\n\nErrors: VerifyError\n\ndef Finalize(input, blind, evaluatedElement,\n             blindedElement, pkS, proof):\n  blindedElements = [blindedElement]     // list of length 1\n  evaluatedElements = [evaluatedElement] // list of length 1\n  if VerifyProof(G.Generator(), pkS, blindedElements,\n                 evaluatedElements, proof) == false:\n    raise VerifyError\n\n  N = G.ScalarInverse(blind) * evaluatedElement\n  unblindedElement = G.SerializeElement(N)\n\n  hashInput = I2OSP(len(input), 2) || input ||\n              I2OSP(len(unblindedElement), 2) || unblindedElement ||\n              \"Finalize\"\n  return Hash(hashInput)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "As in BlindEvaluate, inputs to VerifyProof are one-item lists. Clients can verify multiple inputs at once whenever the server produced a batched DLEQ proof for them.",
      "ja": "Vellincevaluateと同様に、Verifriproofへの入力は1項目のリストです。クライアントは、サーバーがバッチドレクプルーフを作成するたびに、複数の入力を一度に確認できます。"
    },
    {
      "indent": 3,
      "text": "Finally, an entity that knows both the private key and the input can compute the PRF result using the Evaluate function described in Section 3.3.1.",
      "ja": "最後に、秘密キーと入力の両方を知っているエンティティは、セクション3.3.1で説明されている評価関数を使用してPRF結果を計算できます。"
    },
    {
      "indent": 0,
      "text": "3.3.3. POPRF Protocol",
      "section_title": true,
      "ja": "3.3.3. POPRFプロトコル"
    },
    {
      "indent": 3,
      "text": "The POPRF protocol begins with the client blinding its input, using the following modified Blind function. In this step, the client also binds a public info value, which produces an additional tweakedKey to be used later in the protocol. Note that this function can fail with an InvalidInputError error for certain private inputs that map to the group identity element, as well as certain public inputs that, if not detected at this point, will cause server evaluation to fail. Dealing with either failure is an application-specific decision; see Section 5.3.",
      "ja": "POPRFプロトコルは、次の変更されたブラインド関数を使用して、入力をブラインドするクライアントから始まります。このステップでは、クライアントは公開情報値もバインドします。これにより、プロトコルの後半で使用される追加のTweakedKeyが生成されます。この関数は、グループIDの要素にマッピングされる特定のプライベート入力のInvalidInputErrorエラーと、この時点で検出されない場合、サーバーの評価を失敗させる特定のパブリック入力で故障する可能性があることに注意してください。いずれかの障害に対処することは、アプリケーション固有の決定です。セクション5.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  PrivateInput input\n  PublicInput info\n  Element pkS\n\nOutput:\n\n  Scalar blind\n  Element blindedElement\n  Element tweakedKey\n\nParameters:\n\n  Group G\n\nErrors: InvalidInputError\n\ndef Blind(input, info, pkS):\n  framedInfo = \"Info\" || I2OSP(len(info), 2) || info\n  m = G.HashToScalar(framedInfo)\n  T = G.ScalarMultGen(m)\n  tweakedKey = T + pkS\n  if tweakedKey == G.Identity():\n    raise InvalidInputError\n\n  blind = G.RandomScalar()\n  inputElement = G.HashToGroup(input)\n  if inputElement == G.Identity():\n    raise InvalidInputError\n\n  blindedElement = blind * inputElement\n\n  return blind, blindedElement, tweakedKey",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Clients store the outputs blind and tweakedKey locally and send blindedElement to the server for evaluation. Upon receipt, servers process blindedElement to compute an evaluated element and a DLEQ proof using the following BlindEvaluate function.",
      "ja": "クライアントは、出力をブラインドと微調整したものをローカルで保存し、評価のためにブラインドエレメントをサーバーに送信します。受領時に、サーバーは盲検化を処理して、以下の盲検機能を使用して、評価された要素とDLEQプルーフを計算します。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  Scalar skS\n  Element blindedElement\n  PublicInput info\n\nOutput:\n\n  Element evaluatedElement\n  Proof proof\n\nParameters:\n\n  Group G\n\nErrors: InverseError\n\ndef BlindEvaluate(skS, blindedElement, info):\n  framedInfo = \"Info\" || I2OSP(len(info), 2) || info\n  m = G.HashToScalar(framedInfo)\n  t = skS + m\n  if t == 0:\n    raise InverseError\n\n  evaluatedElement = G.ScalarInverse(t) * blindedElement\n\n  tweakedKey = G.ScalarMultGen(t)\n  evaluatedElements = [evaluatedElement] // list of length 1\n  blindedElements = [blindedElement]     // list of length 1\n  proof = GenerateProof(t, G.Generator(), tweakedKey,\n                        evaluatedElements, blindedElements)\n\n  return evaluatedElement, proof",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the description above, inputs to GenerateProof are one-item lists. Using larger lists allows servers to batch the evaluation of multiple elements while producing a single batched DLEQ proof for them.",
      "ja": "上記の説明では、生成するための入力は1項目リストです。より大きなリストを使用すると、サーバーは複数の要素の評価をバッチでバッチでき、単一のバッチDLEQプルーフを作成します。"
    },
    {
      "indent": 3,
      "text": "BlindEvaluate triggers InverseError when the function is about to calculate the inverse of a zero scalar, which does not exist and therefore yields a failure in the protocol. This only occurs for info values that map to the private key of the server. Thus, clients that cause this error should be assumed to know the server private key. Hence, this error can be a signal for the server to replace its private key.",
      "ja": "ブラインド評価は、関数がゼロスカラーの逆を計算しようとしているときにinverseRerrorをトリガーします。これは、サーバーの秘密鍵にマッピングされる情報値に対してのみ発生します。したがって、このエラーを引き起こすクライアントは、サーバーの秘密鍵を知っていると想定されるべきです。したがって、このエラーは、サーバーが秘密キーを置き換えるための信号になる可能性があります。"
    },
    {
      "indent": 3,
      "text": "The server sends both evaluatedElement and proof back to the client. Upon receipt, the client processes both values to complete the POPRF computation using the Finalize function below.",
      "ja": "サーバーは、evalueatedElementと証明の両方をクライアントに送り返します。受領すると、クライアントは両方の値を処理して、以下のファイナライズ関数を使用してPOPRF計算を完了します。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  PrivateInput input\n  Scalar blind\n  Element evaluatedElement\n  Element blindedElement\n  Proof proof\n  PublicInput info\n  Element tweakedKey\n\nOutput:\n\n  opaque output[Nh]\n\nParameters:\n\n  Group G\n\nErrors: VerifyError\n\ndef Finalize(input, blind, evaluatedElement, blindedElement,\n             proof, info, tweakedKey):\n  evaluatedElements = [evaluatedElement] // list of length 1\n  blindedElements = [blindedElement]     // list of length 1\n  if VerifyProof(G.Generator(), tweakedKey, evaluatedElements,\n                 blindedElements, proof) == false:\n    raise VerifyError\n\n  N = G.ScalarInverse(blind) * evaluatedElement\n  unblindedElement = G.SerializeElement(N)\n\n  hashInput = I2OSP(len(input), 2) || input ||\n              I2OSP(len(info), 2) || info ||\n              I2OSP(len(unblindedElement), 2) || unblindedElement ||\n              \"Finalize\"\n  return Hash(hashInput)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "As in BlindEvaluate, inputs to VerifyProof are one-item lists. Clients can verify multiple inputs at once whenever the server produced a batched DLEQ proof for them.",
      "ja": "Vellincevaluateと同様に、Verifriproofへの入力は1項目のリストです。クライアントは、サーバーがバッチドレクプルーフを作成するたびに、複数の入力を一度に確認できます。"
    },
    {
      "indent": 3,
      "text": "Finally, an entity that knows both the private key and the input can compute the PRF result using the Evaluate function described below.",
      "ja": "最後に、秘密キーと入力の両方を知っているエンティティは、以下に説明する評価関数を使用してPRF結果を計算できます。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  Scalar skS\n  PrivateInput input\n  PublicInput info\n\nOutput:\n\n  opaque output[Nh]\n\nParameters:\n\n  Group G\n\nErrors: InvalidInputError, InverseError\n\ndef Evaluate(skS, input, info):\n  inputElement = G.HashToGroup(input)\n  if inputElement == G.Identity():\n    raise InvalidInputError\n\n  framedInfo = \"Info\" || I2OSP(len(info), 2) || info\n  m = G.HashToScalar(framedInfo)\n  t = skS + m\n  if t == 0:\n    raise InverseError\n  evaluatedElement = G.ScalarInverse(t) * inputElement\n  issuedElement = G.SerializeElement(evaluatedElement)\n\n  hashInput = I2OSP(len(input), 2) || input ||\n              I2OSP(len(info), 2) || info ||\n              I2OSP(len(issuedElement), 2) || issuedElement ||\n              \"Finalize\"\n  return Hash(hashInput)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4. Ciphersuites",
      "section_title": true,
      "ja": "4. ciphersuites"
    },
    {
      "indent": 3,
      "text": "A ciphersuite (also referred to as 'suite' in this document) for the protocol wraps the functionality required for the protocol to take place. The ciphersuite should be available to both the client and server, and agreement on the specific instantiation is assumed throughout.",
      "ja": "プロトコルのためのciphersuite（このドキュメントでは「スイート」とも呼ばれます）は、プロトコルが行われるのに必要な機能をラップします。ciphersuiteはクライアントとサーバーの両方が利用できるようにする必要があり、特定のインスタンス化に関する合意が全体を通して想定されています。"
    },
    {
      "indent": 3,
      "text": "A ciphersuite contains instantiations of the following functionalities:",
      "ja": "ciphersuiteには、次の機能のインスタンス化が含まれています。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ："
    },
    {
      "indent": 12,
      "text": "A prime-order group exposing the API detailed in Section 2.1, with the generator element defined in the corresponding reference for each group. Each group also specifies HashToGroup, HashToScalar, and serialization functionalities. For HashToGroup, the domain separation tag (DST) is constructed in accordance with the recommendations in [RFC9380], Section 3.1. For HashToScalar, each group specifies an integer order that is used in reducing integer values to a member of the corresponding scalar field.",
      "ja": "セクション2.1で詳述されているAPIを公開するプライムオーダーグループ。各グループの対応する参照で定義されたジェネレーター要素。また、各グループは、Hashtogroup、Hashtoscalar、およびシリアル化機能も指定しています。Hashtogroupの場合、ドメイン分離タグ（DST）は、[RFC9380]、セクション3.1の推奨事項に従って構築されます。Hashtoscalarの場合、各グループは、対応するスカラーフィールドのメンバーに整数値を削減する際に使用される整数順序を指定します。"
    },
    {
      "indent": 3,
      "text": "Hash:",
      "ja": "ハッシュ："
    },
    {
      "indent": 12,
      "text": "A cryptographic hash function whose output length is Nh bytes long.",
      "ja": "出力の長さが長さのNHバイトの暗号化ハッシュ関数。"
    },
    {
      "indent": 3,
      "text": "This section includes an initial set of ciphersuites with supported groups and hash functions. It also includes implementation details for each ciphersuite, focusing on input validation. Future documents can specify additional ciphersuites as needed, provided they meet the requirements in Section 4.6.",
      "ja": "このセクションには、サポートされているグループとハッシュ関数を備えた最初のシファーセットセットが含まれています。また、入力検証に焦点を当てた各ciphersuiteの実装の詳細も含まれています。将来の文書は、セクション4.6の要件を満たしていれば、必要に応じて追加の暗号網を指定できます。"
    },
    {
      "indent": 3,
      "text": "For each ciphersuite, contextString is that which is computed in the Setup functions. Applications should take caution in using ciphersuites targeting P-256 and ristretto255. See Section 7.2 for related discussion.",
      "ja": "各ciphersuiteについて、コンテキストストリングはセットアップ関数で計算されるものです。アプリケーションは、P-256とRistretto255をターゲットにしたCiphersuitesを使用する際には注意が必要です。関連する議論については、セクション7.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.1. OPRF(ristretto255, SHA-512)",
      "section_title": true,
      "ja": "4.1. oprf（ristretto255、sha-512）"
    },
    {
      "indent": 3,
      "text": "This ciphersuite uses ristretto255 [RFC9496] for the Group and SHA-512 for the hash function. The value of the ciphersuite identifier is \"ristretto255-SHA512\".",
      "ja": "このCiphersuiteは、グループにRistretto255 [RFC9496]を使用し、ハッシュ関数にはSHA-512を使用します。ciphersuite識別子の値は「ristretto255-sha512」です。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ："
    },
    {
      "indent": 6,
      "text": "Order():",
      "ja": "注文（）："
    },
    {
      "indent": 15,
      "text": "Return 2^252 + 27742317777372353535851937790883648493 (see [RFC9496]).",
      "ja": "2^252 277423177777235353585193779083648493（[rfc9496]を参照）を返します。"
    },
    {
      "indent": 6,
      "text": "Identity():",
      "ja": "身元（）："
    },
    {
      "indent": 15,
      "text": "As defined in [RFC9496].",
      "ja": "[RFC9496]で定義されています。"
    },
    {
      "indent": 6,
      "text": "Generator():",
      "ja": "発生器（）："
    },
    {
      "indent": 15,
      "text": "As defined in [RFC9496].",
      "ja": "[RFC9496]で定義されています。"
    },
    {
      "indent": 6,
      "text": "HashToGroup():",
      "ja": "hashtogroup（）："
    },
    {
      "indent": 15,
      "text": "Use hash_to_ristretto255 [RFC9380] with DST = \"HashToGroup-\" || contextString and expand_message = expand_message_xmd using SHA-512.",
      "ja": "dst = \"hashtogroup-\"でhash_to_ristretto255 [rfc9380]を使用します||contextStringとendoct_message = expand_message_xmd sha-512を使用して。"
    },
    {
      "indent": 6,
      "text": "HashToScalar():",
      "ja": "hashtoscalar（）："
    },
    {
      "indent": 15,
      "text": "Compute uniform_bytes using expand_message = expand_message_xmd, DST = \"HashToScalar-\" || contextString, and an output length of 64 bytes, interpret uniform_bytes as a 512-bit integer in little-endian order, and reduce the integer modulo Group.Order().",
      "ja": "expand_message = Expand_message_xmd、dst = \"hashtoscalar-\" ||コンテキストストリング、および64バイトの出力長は、均一_BYTESを小さなエンディアン順で512ビット整数として解釈し、整数modulo group.order（）を減らします。"
    },
    {
      "indent": 6,
      "text": "ScalarInverse(s):",
      "ja": "ScalarInverse（s）："
    },
    {
      "indent": 15,
      "text": "Returns the multiplicative inverse of input Scalar s mod Group.Order().",
      "ja": "入力スカラーs mod group.order（）の乗法逆を返します。"
    },
    {
      "indent": 6,
      "text": "RandomScalar():",
      "ja": "randomscalar（）："
    },
    {
      "indent": 15,
      "text": "Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Section 4.7 for implementation guidance.",
      "ja": "範囲[0、g.order（）-1]に均一にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、セクション4.7を参照してください。"
    },
    {
      "indent": 6,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement（a）："
    },
    {
      "indent": 15,
      "text": "Implemented using the Encode function from Section 4.3.2 of [RFC9496]; Ne = 32.",
      "ja": "[RFC9496]のセクション4.3.2からのエンコード関数を使用して実装されました。NE = 32。"
    },
    {
      "indent": 6,
      "text": "DeserializeElement(buf):",
      "ja": "DeserializeElement（BUF）："
    },
    {
      "indent": 15,
      "text": "Implemented using the Decode function from Section 4.3.1 of [RFC9496]. Additionally, this function validates that the resulting element is not the group identity element. If these checks fail, deserialization returns an InputValidationError error.",
      "ja": "[RFC9496]のセクション4.3.1のデコード関数を使用して実装されました。さらに、この関数は、結果の要素がグループアイデンティティ要素ではないことを検証します。これらのチェックが失敗した場合、DeserializationはinputValidationErrorエラーを返します。"
    },
    {
      "indent": 6,
      "text": "SerializeScalar(s):",
      "ja": "serializescalar（s）："
    },
    {
      "indent": 15,
      "text": "Implemented by outputting the little-endian, 32-byte encoding of the Scalar value with the top three bits set to zero; Ns = 32.",
      "ja": "スカラー値の32バイトのエンコードを出力することにより実装され、上位3ビットがゼロに設定されています。NS = 32。"
    },
    {
      "indent": 6,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar（BUF）："
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a Scalar from a little-endian, 32-byte string. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1]. Note that this means the top three bits of the input MUST be zero.",
      "ja": "リトルエンディアンの32バイトの文字列からスカラーを脱着しようとすることにより実装されます。入力が範囲のスカラーを表していない場合、この関数は故障する可能性があります[0、g.order（）-1]。これは、入力の上位3ビットがゼロでなければならないことを意味することに注意してください。"
    },
    {
      "indent": 12,
      "text": "ristretto255 [RFC9496] Order(): Return 2^252 + 27742317777372353535851937790883648493 (see [RFC9496]). Identity(): As defined in [RFC9496]. Generator(): As defined in [RFC9496]. HashToGroup(): Use hash_to_ristretto255 [RFC9380] with DST = \"HashToGroup-\" || contextString and expand_message = expand_message_xmd using SHA-512. HashToScalar(): Compute uniform_bytes using expand_message = expand_message_xmd, DST = \"HashToScalar-\" || contextString, and an output length of 64 bytes, interpret uniform_bytes as a 512-bit integer in little-endian order, and reduce the integer modulo Group.Order(). ScalarInverse(s): Returns the multiplicative inverse of input Scalar s mod Group.Order(). RandomScalar(): Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Section 4.7 for implementation guidance. SerializeElement(A): Implemented using the Encode function from Section 4.3.2 of [RFC9496]; Ne = 32. DeserializeElement(buf): Implemented using the Decode function from Section 4.3.1 of [RFC9496]. Additionally, this function validates that the resulting element is not the group identity element. If these checks fail, deserialization returns an InputValidationError error. SerializeScalar(s): Implemented by outputting the little-endian, 32-byte encoding of the Scalar value with the top three bits set to zero; Ns = 32. DeserializeScalar(buf): Implemented by attempting to deserialize a Scalar from a little-endian, 32-byte string. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1]. Note that this means the top three bits of the input MUST be zero.",
      "ja": "ristretto255 [rfc9496] order（）：return 2^252 277423177772353535851937790883648493（[rfc9496]を参照）。ID（）：[RFC9496]で定義されています。Generator（）：[RFC9496]で定義されています。hashtogroup（）：dst = \"hashtogroup-\" || with hash_to_ristretto255 [rfc9380]を使用してください。contextStringとendoct_message = expand_message_xmd sha-512を使用して。hashtoscalar（）：excond_message = expand_message_xmd、dst = \"hashtoscalar-\" ||コンテキストストリング、および64バイトの出力長は、均一_BYTESを小さなエンディアン順で512ビット整数として解釈し、整数modulo group.order（）を減らします。ScalarInverse（s）：入力スカラーs mod group.order（）の乗法逆を返します。randomscalar（）：範囲[0、g.order（）-1]に均一にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、セクション4.7を参照してください。SerializeElement（a）：[RFC9496]のセクション4.3.2のエンコード関数を使用して実装されています。NE = 32. DeserializeElement（BUF）：[RFC9496]のセクション4.3.1のデコード関数を使用して実装されています。さらに、この関数は、結果の要素がグループアイデンティティ要素ではないことを検証します。これらのチェックが失敗した場合、DeserializationはinputValidationErrorエラーを返します。SerializeScalar（s）：スカラー値の小さなエンディアン、32バイトのエンコードを出力して、上位3ビットをゼロに設定することによって実装されています。NS = 32. DeserializeScalar（BUF）：小さなエンディアンの32バイトの文字列からスカラーをゆるくしようとすることにより実装されています。入力が範囲のスカラーを表していない場合、この関数は故障する可能性があります[0、g.order（）-1]。これは、入力の上位3ビットがゼロでなければならないことを意味することに注意してください。"
    },
    {
      "indent": 3,
      "text": "Hash:",
      "ja": "ハッシュ："
    },
    {
      "indent": 12,
      "text": "SHA-512; Nh = 64.",
      "ja": "SHA-512;NH = 64。"
    },
    {
      "indent": 0,
      "text": "4.2. OPRF(decaf448, SHAKE-256)",
      "section_title": true,
      "ja": "4.2. oprf（decaf448、shake-256）"
    },
    {
      "indent": 3,
      "text": "This ciphersuite uses decaf448 [RFC9496] for the Group and SHAKE-256 for the hash function. The value of the ciphersuite identifier is \"decaf448-SHAKE256\".",
      "ja": "このciphersuiteは、グループにdecaf448 [rfc9496]を使用し、ハッシュ関数にはShake-256を使用します。ciphersuite識別子の値は「decaf448-shake256」です。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ："
    },
    {
      "indent": 6,
      "text": "Order():",
      "ja": "注文（）："
    },
    {
      "indent": 15,
      "text": "Return 2^446 - 13818066809895115352007386748515426880336 692474882178609894547503885.",
      "ja": "2^446-1381806809895115352007386748515426880336 692474882178609894547503885。"
    },
    {
      "indent": 6,
      "text": "Identity():",
      "ja": "身元（）："
    },
    {
      "indent": 15,
      "text": "As defined in [RFC9496].",
      "ja": "[RFC9496]で定義されています。"
    },
    {
      "indent": 6,
      "text": "Generator():",
      "ja": "発生器（）："
    },
    {
      "indent": 15,
      "text": "As defined in [RFC9496].",
      "ja": "[RFC9496]で定義されています。"
    },
    {
      "indent": 6,
      "text": "RandomScalar():",
      "ja": "randomscalar（）："
    },
    {
      "indent": 15,
      "text": "Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Section 4.7 for implementation guidance.",
      "ja": "範囲[0、g.order（）-1]に均一にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、セクション4.7を参照してください。"
    },
    {
      "indent": 6,
      "text": "HashToGroup():",
      "ja": "hashtogroup（）："
    },
    {
      "indent": 15,
      "text": "Use hash_to_decaf448 [RFC9380] with DST = \"HashToGroup-\" || contextString and expand_message = expand_message_xof using SHAKE-256.",
      "ja": "dst = \"hashtogroup-\"でhash_to_decaf448 [rfc9380]を使用します||ContextStringと展開_Message = Expand_message_xof Shake-256を使用して。"
    },
    {
      "indent": 6,
      "text": "HashToScalar():",
      "ja": "hashtoscalar（）："
    },
    {
      "indent": 15,
      "text": "Compute uniform_bytes using expand_message = expand_message_xof, DST = \"HashToScalar-\" || contextString, and output length 64, interpret uniform_bytes as a 512-bit integer in little-endian order, and reduce the integer modulo Group.Order().",
      "ja": "expand_message = Expand_message_xof、dst = \"hashtoscalar-\" ||ContextString、および出力長64は、Uniform_bytesを小さなエンディアン順で512ビット整数として解釈し、整数modulo group.order（）を削減します。"
    },
    {
      "indent": 6,
      "text": "ScalarInverse(s):",
      "ja": "ScalarInverse（s）："
    },
    {
      "indent": 15,
      "text": "Returns the multiplicative inverse of input Scalar s mod Group.Order().",
      "ja": "入力スカラーs mod group.order（）の乗法逆を返します。"
    },
    {
      "indent": 6,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement（a）："
    },
    {
      "indent": 15,
      "text": "Implemented using the Encode function from Section 5.3.2 of [RFC9496]; Ne = 56.",
      "ja": "[RFC9496]のセクション5.3.2からのエンコード関数を使用して実装されました。NE = 56。"
    },
    {
      "indent": 6,
      "text": "DeserializeElement(buf):",
      "ja": "DeserializeElement（BUF）："
    },
    {
      "indent": 15,
      "text": "Implemented using the Decode function from Section 5.3.1 of [RFC9496]. Additionally, this function validates that the resulting element is not the group identity element. If these checks fail, deserialization returns an InputValidationError error.",
      "ja": "[RFC9496]のセクション5.3.1のデコード関数を使用して実装されました。さらに、この関数は、結果の要素がグループアイデンティティ要素ではないことを検証します。これらのチェックが失敗した場合、DeserializationはinputValidationErrorエラーを返します。"
    },
    {
      "indent": 6,
      "text": "SerializeScalar(s):",
      "ja": "serializescalar（s）："
    },
    {
      "indent": 15,
      "text": "Implemented by outputting the little-endian, 56-byte encoding of the Scalar value; Ns = 56.",
      "ja": "スカラー値の56バイトのエンコードを出力することによって実装されます。ns = 56。"
    },
    {
      "indent": 6,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar（BUF）："
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a Scalar from a little-endian, 56-byte string. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1].",
      "ja": "小さなエンディアンの56バイトの文字列からのスカラーを脱着しようとすることにより実装されます。入力が範囲のスカラーを表していない場合、この関数は故障する可能性があります[0、g.order（）-1]。"
    },
    {
      "indent": 12,
      "text": "decaf448 [RFC9496] Order(): Return 2^446 - 13818066809895115352007386748515426880336 692474882178609894547503885. Identity(): As defined in [RFC9496]. Generator(): As defined in [RFC9496]. RandomScalar(): Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Section 4.7 for implementation guidance. HashToGroup(): Use hash_to_decaf448 [RFC9380] with DST = \"HashToGroup-\" || contextString and expand_message = expand_message_xof using SHAKE-256. HashToScalar(): Compute uniform_bytes using expand_message = expand_message_xof, DST = \"HashToScalar-\" || contextString, and output length 64, interpret uniform_bytes as a 512-bit integer in little-endian order, and reduce the integer modulo Group.Order(). ScalarInverse(s): Returns the multiplicative inverse of input Scalar s mod Group.Order(). SerializeElement(A): Implemented using the Encode function from Section 5.3.2 of [RFC9496]; Ne = 56. DeserializeElement(buf): Implemented using the Decode function from Section 5.3.1 of [RFC9496]. Additionally, this function validates that the resulting element is not the group identity element. If these checks fail, deserialization returns an InputValidationError error. SerializeScalar(s): Implemented by outputting the little-endian, 56-byte encoding of the Scalar value; Ns = 56. DeserializeScalar(buf): Implemented by attempting to deserialize a Scalar from a little-endian, 56-byte string. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1].",
      "ja": "decaf448 [rfc9496] order（）：return 2^446-1381806809895115352007386748515426880336 692474882178609894547503885。Generator（）：[RFC9496]で定義されています。randomscalar（）：範囲[0、g.order（）-1]に均一にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、セクション4.7を参照してください。hashtogroup（）：dst = \"hashtogroup-\"でhash_to_decaf448 [rfc9380]を使用します||ContextStringと展開_Message = Expand_message_xof Shake-256を使用して。hashtoscalar（）：expand_message = endocient_message_xofを使用して均一_bytesを計算します。ContextString、および出力長64は、Uniform_bytesを小さなエンディアン順で512ビット整数として解釈し、整数modulo group.order（）を削減します。ScalarInverse（s）：入力スカラーs mod group.order（）の乗法逆を返します。SerializeElement（a）：[RFC9496]のセクション5.3.2のエンコード関数を使用して実装されています。NE = 56. DeserializeElement（BUF）：[RFC9496]のセクション5.3.1のデコード関数を使用して実装されています。さらに、この関数は、結果の要素がグループアイデンティティ要素ではないことを検証します。これらのチェックが失敗した場合、DeserializationはinputValidationErrorエラーを返します。SerializeScalar（S）：スカラー値の56バイトのエンコードを出力することにより実装されています。NS = 56. DeserializeScalar（BUF）：小さなエンディアンの56バイトの文字列からスカラーをゆるくしようとすることにより実装されています。入力が範囲のスカラーを表していない場合、この関数は故障する可能性があります[0、g.order（）-1]。"
    },
    {
      "indent": 3,
      "text": "Hash:",
      "ja": "ハッシュ："
    },
    {
      "indent": 12,
      "text": "SHAKE-256; Nh = 64.",
      "ja": "Shake-256;NH = 64。"
    },
    {
      "indent": 0,
      "text": "4.3. OPRF(P-256, SHA-256)",
      "section_title": true,
      "ja": "4.3. OPRF（P-256、SHA-256）"
    },
    {
      "indent": 3,
      "text": "This ciphersuite uses P-256 [NISTCurves] for the Group and SHA-256 for the hash function. The value of the ciphersuite identifier is \"P256-SHA256\".",
      "ja": "このciphersuiteは、グループにp-256 [nistcurves]を使用し、ハッシュ関数にはSHA-256を使用します。Ciphersuite識別子の値は「P256-Sha256」です。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ："
    },
    {
      "indent": 6,
      "text": "Order():",
      "ja": "注文（）："
    },
    {
      "indent": 15,
      "text": "Return 0xffffffff00000000ffffffffffffffffbce6faada7179e8 4f3b9cac2fc632551.",
      "ja": "0xfffffffff0000000000fffffffffffffffbbce6faada7179e8 4f3b9cac2ffc632551を返します。"
    },
    {
      "indent": 6,
      "text": "Identity():",
      "ja": "身元（）："
    },
    {
      "indent": 15,
      "text": "As defined in [NISTCurves].",
      "ja": "[nistcurves]で定義されています。"
    },
    {
      "indent": 6,
      "text": "Generator():",
      "ja": "発生器（）："
    },
    {
      "indent": 15,
      "text": "As defined in [NISTCurves].",
      "ja": "[nistcurves]で定義されています。"
    },
    {
      "indent": 6,
      "text": "RandomScalar():",
      "ja": "randomscalar（）："
    },
    {
      "indent": 15,
      "text": "Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Section 4.7 for implementation guidance.",
      "ja": "範囲[0、g.order（）-1]に均一にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、セクション4.7を参照してください。"
    },
    {
      "indent": 6,
      "text": "HashToGroup():",
      "ja": "hashtogroup（）："
    },
    {
      "indent": 15,
      "text": "Use hash_to_curve with suite P256_XMD:SHA-256_SSWU_RO_ [RFC9380] and DST = \"HashToGroup-\" || contextString.",
      "ja": "Suite P256_XMDを備えたHash_to_curveを使用：SHA-256_SSWU_RO_ [RFC9380]およびDST = \"Hashtogroup-\" ||コンテキストストリング。"
    },
    {
      "indent": 6,
      "text": "HashToScalar():",
      "ja": "hashtoscalar（）："
    },
    {
      "indent": 15,
      "text": "Use hash_to_field from [RFC9380] using L = 48, expand_message_xmd with SHA-256, DST = \"HashToScalar-\" || contextString, and a prime modulus equal to Group.Order().",
      "ja": "l = 48を使用して[rfc9380]のhash_to_fieldを使用します、sha-256、dst = \"hashtoscalar-\" ||ContextString、およびgroup.order（）に等しいプライムモジュラス。"
    },
    {
      "indent": 6,
      "text": "ScalarInverse(s):",
      "ja": "ScalarInverse（s）："
    },
    {
      "indent": 15,
      "text": "Returns the multiplicative inverse of input Scalar s mod Group.Order().",
      "ja": "入力スカラーs mod group.order（）の乗法逆を返します。"
    },
    {
      "indent": 6,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement（a）："
    },
    {
      "indent": 15,
      "text": "Implemented using the compressed Elliptic-Curve-Point-to-Octet-String method according to [SEC1]; Ne = 33.",
      "ja": "[SEC1]に従って、圧縮された楕円曲線のポイントからオクテット弦法を使用して実装されました。NE = 33。"
    },
    {
      "indent": 6,
      "text": "DeserializeElement(buf):",
      "ja": "DeserializeElement（BUF）："
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a 33-byte input string to a public key using the compressed Octet-String-to-Elliptic-Curve-Point method according to [SEC1] and then performing partial public-key validation, as defined in Section 5.6.2.3.4 of [KEYAGREEMENT]. This includes checking that the coordinates of the resulting point are in the correct range, that the point is on the curve, and that the point is not the group identity element. If these checks fail, deserialization returns an InputValidationError error.",
      "ja": "33バイトの入力文字列を[SEC1]に従って圧縮されたOctet-String-to-Elliptic-Curve-Pointメソッドを使用して公開キーに脱着しようとすることにより実装され、セクション5.6で定義されているように、部分的なパブリックキー検証を実行します。[keyagreement]の2.3.4。これには、結果のポイントの座標が正しい範囲にあること、ポイントが曲線上にあること、およびポイントがグループアイデンティティ要素ではないことを確認することが含まれます。これらのチェックが失敗した場合、DeserializationはinputValidationErrorエラーを返します。"
    },
    {
      "indent": 6,
      "text": "SerializeScalar(s):",
      "ja": "serializescalar（s）："
    },
    {
      "indent": 15,
      "text": "Implemented using the Field-Element-to-Octet-String conversion according to [SEC1]; Ns = 32.",
      "ja": "[SEC1]に従って、フィールドエレメントからオクセットのストリング変換を使用して実装されました。NS = 32。"
    },
    {
      "indent": 6,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar（BUF）："
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a Scalar from a 32-byte string using Octet-String-to-Field-Element from [SEC1]. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1].",
      "ja": "[SEC1]からのオクテットストリングからフィールドエレメントを使用して、32バイトの文字列からスカラーを脱派化しようとすることにより実装されます。入力が範囲のスカラーを表していない場合、この関数は故障する可能性があります[0、g.order（）-1]。"
    },
    {
      "indent": 12,
      "text": "P-256 (secp256r1) [NISTCurves] Order(): Return 0xffffffff00000000ffffffffffffffffbce6faada7179e8 4f3b9cac2fc632551. Identity(): As defined in [NISTCurves]. Generator(): As defined in [NISTCurves]. RandomScalar(): Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Section 4.7 for implementation guidance. HashToGroup(): Use hash_to_curve with suite P256_XMD:SHA-256_SSWU_RO_ [RFC9380] and DST = \"HashToGroup-\" || contextString. HashToScalar(): Use hash_to_field from [RFC9380] using L = 48, expand_message_xmd with SHA-256, DST = \"HashToScalar-\" || contextString, and a prime modulus equal to Group.Order(). ScalarInverse(s): Returns the multiplicative inverse of input Scalar s mod Group.Order(). SerializeElement(A): Implemented using the compressed Elliptic-Curve-Point-to-Octet-String method according to [SEC1]; Ne = 33. DeserializeElement(buf): Implemented by attempting to deserialize a 33-byte input string to a public key using the compressed Octet-String-to-Elliptic-Curve-Point method according to [SEC1] and then performing partial public-key validation, as defined in Section 5.6.2.3.4 of [KEYAGREEMENT]. This includes checking that the coordinates of the resulting point are in the correct range, that the point is on the curve, and that the point is not the group identity element. If these checks fail, deserialization returns an InputValidationError error. SerializeScalar(s): Implemented using the Field-Element-to-Octet-String conversion according to [SEC1]; Ns = 32. DeserializeScalar(buf): Implemented by attempting to deserialize a Scalar from a 32-byte string using Octet-String-to-Field-Element from [SEC1]. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1].",
      "ja": "P-256（secp256r1）[nistcurves] order（）：return 0xffffffff0000000000fffffffffffffffffbce6faada7179e8 4f3b9cac2fc632551。ID（）：[nistcurves]で定義されています。generator（）：[nistcurves]で定義されています。randomscalar（）：範囲[0、g.order（）-1]に均一にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、セクション4.7を参照してください。hashtogroup（）：suite p256_xmdを使用してhash_to_curveを使用：sha-256_sswu_ro_ [rfc9380]およびdst = \"hashtogroup-\" ||コンテキストストリング。hashtoscalar（）：l = 48、sha-256、dst = \"hashtoscalar-\" ||を使用して[rfc9380]を使用して[rfc9380]のhash_to_fieldを使用します。ContextString、およびgroup.order（）に等しいプライムモジュラス。ScalarInverse（s）：入力スカラーs mod group.order（）の乗法逆を返します。SerializeElement（a）：[SEC1]に従って圧縮された楕円曲線ポイントからオクセットストリング法を使用して実装されました。NE =33。DeserializeElement（BUF）：33バイトの入力文字列を[SEC1]に応じて圧縮されたOctet-String-to-Elliptic-Curve-Pointメソッドを使用して、33バイトの入力文字列を公開キーに脱直しようとすることにより実装し、部分的なパブリックを実行する - [keyagreement]のセクション5.6.2.3.4で定義されているキー検証。これには、結果のポイントの座標が正しい範囲にあること、ポイントが曲線上にあること、およびポイントがグループアイデンティティ要素ではないことを確認することが含まれます。これらのチェックが失敗した場合、DeserializationはinputValidationErrorエラーを返します。SerializeScalar（S）：[SEC1]に従ってフィールドエレメントからオクセットのストリング変換を使用して実装されました。NS = 32. DeserializeScalar（BUF）：[SEC1]からのOctet-String-to-Field-Elementを使用して、32バイトの文字列からスカラーをゆるくしようとすることにより実装されました。入力が範囲のスカラーを表していない場合、この関数は故障する可能性があります[0、g.order（）-1]。"
    },
    {
      "indent": 3,
      "text": "Hash:",
      "ja": "ハッシュ："
    },
    {
      "indent": 12,
      "text": "SHA-256; Nh = 32.",
      "ja": "SHA-256;NH = 32。"
    },
    {
      "indent": 0,
      "text": "4.4. OPRF(P-384, SHA-384)",
      "section_title": true,
      "ja": "4.4. OPRF（P-384、SHA-384）"
    },
    {
      "indent": 3,
      "text": "This ciphersuite uses P-384 [NISTCurves] for the Group and SHA-384 for the hash function. The value of the ciphersuite identifier is \"P384-SHA384\".",
      "ja": "このciphersuiteは、グループにp-384 [nistcurves]を使用し、ハッシュ関数にはSHA-384を使用します。ciphersuite識別子の値は「p384-sha384」です。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ："
    },
    {
      "indent": 6,
      "text": "Order():",
      "ja": "注文（）："
    },
    {
      "indent": 15,
      "text": "Return 0xfffffffffffffffffffffffffffffffffffffffffffffff fc7634d81f4372ddf581a0db248b0a77aecec196accc52973.",
      "ja": "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973。"
    },
    {
      "indent": 6,
      "text": "Identity():",
      "ja": "身元（）："
    },
    {
      "indent": 15,
      "text": "As defined in [NISTCurves].",
      "ja": "[nistcurves]で定義されています。"
    },
    {
      "indent": 6,
      "text": "Generator():",
      "ja": "発生器（）："
    },
    {
      "indent": 15,
      "text": "As defined in [NISTCurves].",
      "ja": "[nistcurves]で定義されています。"
    },
    {
      "indent": 6,
      "text": "RandomScalar():",
      "ja": "randomscalar（）："
    },
    {
      "indent": 15,
      "text": "Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Section 4.7 for implementation guidance.",
      "ja": "範囲[0、g.order（）-1]に均一にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、セクション4.7を参照してください。"
    },
    {
      "indent": 6,
      "text": "HashToGroup():",
      "ja": "hashtogroup（）："
    },
    {
      "indent": 15,
      "text": "Use hash_to_curve with suite P384_XMD:SHA-384_SSWU_RO_ [RFC9380] and DST = \"HashToGroup-\" || contextString.",
      "ja": "Suite P384_XMDでHASH_TO_CURVEを使用：SHA-384_SSWU_RO_ [RFC9380]およびDST = \"Hashtogroup-\" ||コンテキストストリング。"
    },
    {
      "indent": 6,
      "text": "HashToScalar():",
      "ja": "hashtoscalar（）："
    },
    {
      "indent": 15,
      "text": "Use hash_to_field from [RFC9380] using L = 72, expand_message_xmd with SHA-384, DST = \"HashToScalar-\" || contextString, and a prime modulus equal to Group.Order().",
      "ja": "l = 72を使用して[rfc9380]のhash_to_fieldを使用します。sha-384を使用してexpand_message_xmd、dst = \"hashtoscalar-\" ||ContextString、およびgroup.order（）に等しいプライムモジュラス。"
    },
    {
      "indent": 6,
      "text": "ScalarInverse(s):",
      "ja": "ScalarInverse（s）："
    },
    {
      "indent": 15,
      "text": "Returns the multiplicative inverse of input Scalar s mod Group.Order().",
      "ja": "入力スカラーs mod group.order（）の乗法逆を返します。"
    },
    {
      "indent": 6,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement（a）："
    },
    {
      "indent": 15,
      "text": "Implemented using the compressed Elliptic-Curve-Point-to-Octet-String method according to [SEC1]; Ne = 49.",
      "ja": "[SEC1]に従って、圧縮された楕円曲線のポイントからオクテット弦法を使用して実装されました。NE = 49。"
    },
    {
      "indent": 6,
      "text": "DeserializeElement(buf):",
      "ja": "DeserializeElement（BUF）："
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a 49-byte array to a public key using the compressed Octet-String-to-Elliptic-Curve-Point method according to [SEC1] and then performing partial public-key validation, as defined in Section 5.6.2.3.4 of [KEYAGREEMENT]. This includes checking that the coordinates of the resulting point are in the correct range, that the point is on the curve, and that the point is not the point at infinity. Additionally, this function validates that the resulting element is not the group identity element. If these checks fail, deserialization returns an InputValidationError error.",
      "ja": "セクション5.6.2.3で定義されているように、[SEC1]に従って圧縮されたオクテットストリングからエリプチから楕円形のポイントメソッドを使用して、49バイトのアレイを公開キーに脱直しようとすることにより実装されました。[keyagreement]の.4。これには、結果のポイントの座標が正しい範囲にあること、ポイントが曲線上にあること、およびポイントが無限のポイントではないことを確認することが含まれます。さらに、この関数は、結果の要素がグループアイデンティティ要素ではないことを検証します。これらのチェックが失敗した場合、DeserializationはinputValidationErrorエラーを返します。"
    },
    {
      "indent": 6,
      "text": "SerializeScalar(s):",
      "ja": "serializescalar（s）："
    },
    {
      "indent": 15,
      "text": "Implemented using the Field-Element-to-Octet-String conversion according to [SEC1]; Ns = 48.",
      "ja": "[SEC1]に従って、フィールドエレメントからオクセットのストリング変換を使用して実装されました。ns = 48。"
    },
    {
      "indent": 6,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar（BUF）："
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a Scalar from a 48-byte string using Octet-String-to-Field-Element from [SEC1]. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1].",
      "ja": "[SEC1]からのオクテットストリングからフィールドエレメントを使用して、48バイトの文字列からスカラーを脱着しようとすることにより実装されます。入力が範囲のスカラーを表していない場合、この関数は故障する可能性があります[0、g.order（）-1]。"
    },
    {
      "indent": 12,
      "text": "P-384 (secp384r1) [NISTCurves] Order(): Return 0xfffffffffffffffffffffffffffffffffffffffffffffff fc7634d81f4372ddf581a0db248b0a77aecec196accc52973. Identity(): As defined in [NISTCurves]. Generator(): As defined in [NISTCurves]. RandomScalar(): Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Section 4.7 for implementation guidance. HashToGroup(): Use hash_to_curve with suite P384_XMD:SHA-384_SSWU_RO_ [RFC9380] and DST = \"HashToGroup-\" || contextString. HashToScalar(): Use hash_to_field from [RFC9380] using L = 72, expand_message_xmd with SHA-384, DST = \"HashToScalar-\" || contextString, and a prime modulus equal to Group.Order(). ScalarInverse(s): Returns the multiplicative inverse of input Scalar s mod Group.Order(). SerializeElement(A): Implemented using the compressed Elliptic-Curve-Point-to-Octet-String method according to [SEC1]; Ne = 49. DeserializeElement(buf): Implemented by attempting to deserialize a 49-byte array to a public key using the compressed Octet-String-to-Elliptic-Curve-Point method according to [SEC1] and then performing partial public-key validation, as defined in Section 5.6.2.3.4 of [KEYAGREEMENT]. This includes checking that the coordinates of the resulting point are in the correct range, that the point is on the curve, and that the point is not the point at infinity. Additionally, this function validates that the resulting element is not the group identity element. If these checks fail, deserialization returns an InputValidationError error. SerializeScalar(s): Implemented using the Field-Element-to-Octet-String conversion according to [SEC1]; Ns = 48. DeserializeScalar(buf): Implemented by attempting to deserialize a Scalar from a 48-byte string using Octet-String-to-Field-Element from [SEC1]. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1].",
      "ja": "P-384 (secp384r1) [NISTCurves] Order(): Return 0xfffffffffffffffffffffffffffffffffffffffffffffff fc7634d81f4372ddf581a0db248b0a77aecec196accc52973.ID（）：[nistcurves]で定義されています。generator（）：[nistcurves]で定義されています。randomscalar（）：範囲[0、g.order（）-1]に均一にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、セクション4.7を参照してください。Hashtogroup（）：Suite P384_XMDを使用してHash_To_Curveを使用：SHA-384_SSWU_RO_ [RFC9380]およびDST = \"Hashtogroup-\" ||コンテキストストリング。hashtoscalar（）：l = 72、sha-384、dst = \"hashtoscalar-\"を使用してl = 72を使用して[rfc9380]からhash_to_fieldを使用します||ContextString、およびgroup.order（）に等しいプライムモジュラス。ScalarInverse（s）：入力スカラーs mod group.order（）の乗法逆を返します。SerializeElement（a）：[SEC1]に従って圧縮された楕円曲線ポイントからオクセットストリング法を使用して実装されました。NE = 49. DeserializeElement（BUF）：[SEC1]に応じて圧縮されたOctet-String-to-Elliptic-to-Elliptic-Curve-Curve-Pointメソッドを使用して49バイトの配列を公開キーに脱着しようとすることにより実装し、その後パブリックキーを実行する[keyagreement]のセクション5.6.2.3.4で定義されている検証。これには、結果のポイントの座標が正しい範囲にあること、ポイントが曲線上にあること、およびポイントが無限のポイントではないことを確認することが含まれます。さらに、この関数は、結果の要素がグループアイデンティティ要素ではないことを検証します。これらのチェックが失敗した場合、DeserializationはinputValidationErrorエラーを返します。SerializeScalar（S）：[SEC1]に従ってフィールドエレメントからオクセットのストリング変換を使用して実装されました。NS = 48. DeserializeScalar（BUF）：[SEC1]からのOctet-String-to-Field-Elementを使用して、48バイトの文字列からスカラーをゆるくしようとすることにより実装されました。入力が範囲のスカラーを表していない場合、この関数は故障する可能性があります[0、g.order（）-1]。"
    },
    {
      "indent": 3,
      "text": "Hash:",
      "ja": "ハッシュ："
    },
    {
      "indent": 12,
      "text": "SHA-384; Nh = 48.",
      "ja": "SHA-384;NH = 48。"
    },
    {
      "indent": 0,
      "text": "4.5. OPRF(P-521, SHA-512)",
      "section_title": true,
      "ja": "4.5. OPRF（P-521、SHA-512）"
    },
    {
      "indent": 3,
      "text": "This ciphersuite uses P-521 [NISTCurves] for the Group and SHA-512 for the hash function. The value of the ciphersuite identifier is \"P521-SHA512\".",
      "ja": "このciphersuiteは、グループにP-521 [nistcurves]を使用し、ハッシュ関数にはSHA-512を使用します。ciphersuite識別子の値は「p521-sha512」です。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ："
    },
    {
      "indent": 6,
      "text": "Order():",
      "ja": "注文（）："
    },
    {
      "indent": 15,
      "text": "Return 0x01fffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b889 9c47aebb6fb71e91386409.",
      "ja": "0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2296666666666666666666666666666666666666666666666666666666666666666666666666666666666666年9月9日91386409。"
    },
    {
      "indent": 6,
      "text": "Identity():",
      "ja": "身元（）："
    },
    {
      "indent": 15,
      "text": "As defined in [NISTCurves].",
      "ja": "[nistcurves]で定義されています。"
    },
    {
      "indent": 6,
      "text": "Generator():",
      "ja": "発生器（）："
    },
    {
      "indent": 15,
      "text": "As defined in [NISTCurves].",
      "ja": "[nistcurves]で定義されています。"
    },
    {
      "indent": 6,
      "text": "RandomScalar():",
      "ja": "randomscalar（）："
    },
    {
      "indent": 15,
      "text": "Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Section 4.7 for implementation guidance.",
      "ja": "範囲[0、g.order（）-1]に均一にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、セクション4.7を参照してください。"
    },
    {
      "indent": 6,
      "text": "HashToGroup():",
      "ja": "hashtogroup（）："
    },
    {
      "indent": 15,
      "text": "Use hash_to_curve with suite P521_XMD:SHA-512_SSWU_RO_ [RFC9380] and DST = \"HashToGroup-\" || contextString.",
      "ja": "Suite P521_xmdを使用してHash_to_curveを使用：Sha-512_sswu_ro_ [rfc9380]およびdst = \"hashtogroup-\" ||コンテキストストリング。"
    },
    {
      "indent": 6,
      "text": "HashToScalar():",
      "ja": "hashtoscalar（）："
    },
    {
      "indent": 15,
      "text": "Use hash_to_field from [RFC9380] using L = 98, expand_message_xmd with SHA-512, DST = \"HashToScalar-\" || contextString, and a prime modulus equal to Group.Order().",
      "ja": "l = 98を使用して[rfc9380]の[rfc9380]のhash_to_fieldを使用します。SHA-512を使用してexpand_message_xmd、dst = \"hashtoscalar-\" ||ContextString、およびgroup.order（）に等しいプライムモジュラス。"
    },
    {
      "indent": 6,
      "text": "ScalarInverse(s):",
      "ja": "ScalarInverse（s）："
    },
    {
      "indent": 15,
      "text": "Returns the multiplicative inverse of input Scalar s mod Group.Order().",
      "ja": "入力スカラーs mod group.order（）の乗法逆を返します。"
    },
    {
      "indent": 6,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement（a）："
    },
    {
      "indent": 15,
      "text": "Implemented using the compressed Elliptic-Curve-Point-to-Octet-String method according to [SEC1]; Ne = 67.",
      "ja": "[SEC1]に従って、圧縮された楕円曲線のポイントからオクテット弦法を使用して実装されました。NE = 67。"
    },
    {
      "indent": 6,
      "text": "DeserializeElement(buf):",
      "ja": "DeserializeElement（BUF）："
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a 67-byte input string to a public key using the compressed Octet-String-to-Elliptic-Curve-Point method according to [SEC1] and then performing partial public-key validation, as defined in Section 5.6.2.3.4 of [KEYAGREEMENT]. This includes checking that the coordinates of the resulting point are in the correct range, that the point is on the curve, and that the point is not the point at infinity. Additionally, this function validates that the resulting element is not the group identity element. If these checks fail, deserialization returns an InputValidationError error.",
      "ja": "67バイトの入力文字列を[SEC1]に従って圧縮されたオクテットストリングからエリプチから楕円形のポイントメソッドを使用して公開キーに脱着しようとすることにより実装され、セクション5.6で定義されているように、部分的なパブリックキー検証を実行します。[keyagreement]の2.3.4。これには、結果のポイントの座標が正しい範囲にあること、ポイントが曲線上にあること、およびポイントが無限のポイントではないことを確認することが含まれます。さらに、この関数は、結果の要素がグループアイデンティティ要素ではないことを検証します。これらのチェックが失敗した場合、DeserializationはinputValidationErrorエラーを返します。"
    },
    {
      "indent": 6,
      "text": "SerializeScalar(s):",
      "ja": "serializescalar（s）："
    },
    {
      "indent": 15,
      "text": "Implemented using the Field-Element-to-Octet-String conversion according to [SEC1]; Ns = 66.",
      "ja": "[SEC1]に従って、フィールドエレメントからオクセットのストリング変換を使用して実装されました。NS = 66。"
    },
    {
      "indent": 6,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar（BUF）："
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a Scalar from a 66-byte string using Octet-String-to-Field-Element from [SEC1]. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1].",
      "ja": "[SEC1]からのオクテットストリングからフィールドエレメントを使用して、66バイトの文字列からスカラーを脱着しようとすることにより実装されます。入力が範囲のスカラーを表していない場合、この関数は故障する可能性があります[0、g.order（）-1]。"
    },
    {
      "indent": 12,
      "text": "P-521 (secp521r1) [NISTCurves] Order(): Return 0x01fffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b889 9c47aebb6fb71e91386409. Identity(): As defined in [NISTCurves]. Generator(): As defined in [NISTCurves]. RandomScalar(): Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Section 4.7 for implementation guidance. HashToGroup(): Use hash_to_curve with suite P521_XMD:SHA-512_SSWU_RO_ [RFC9380] and DST = \"HashToGroup-\" || contextString. HashToScalar(): Use hash_to_field from [RFC9380] using L = 98, expand_message_xmd with SHA-512, DST = \"HashToScalar-\" || contextString, and a prime modulus equal to Group.Order(). ScalarInverse(s): Returns the multiplicative inverse of input Scalar s mod Group.Order(). SerializeElement(A): Implemented using the compressed Elliptic-Curve-Point-to-Octet-String method according to [SEC1]; Ne = 67. DeserializeElement(buf): Implemented by attempting to deserialize a 67-byte input string to a public key using the compressed Octet-String-to-Elliptic-Curve-Point method according to [SEC1] and then performing partial public-key validation, as defined in Section 5.6.2.3.4 of [KEYAGREEMENT]. This includes checking that the coordinates of the resulting point are in the correct range, that the point is on the curve, and that the point is not the point at infinity. Additionally, this function validates that the resulting element is not the group identity element. If these checks fail, deserialization returns an InputValidationError error. SerializeScalar(s): Implemented using the Field-Element-to-Octet-String conversion according to [SEC1]; Ns = 66. DeserializeScalar(buf): Implemented by attempting to deserialize a Scalar from a 66-byte string using Octet-String-to-Field-Element from [SEC1]. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1].",
      "ja": "P-521 (secp521r1) [NISTCurves] Order(): Return 0x01fffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b889 9c47aebb6fb71e91386409.ID（）：[nistcurves]で定義されています。generator（）：[nistcurves]で定義されています。randomscalar（）：範囲[0、g.order（）-1]に均一にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、セクション4.7を参照してください。Hashtogroup（）：Suite P521_xmdを使用してHash_to_curveを使用：SHA-512_SSWU_RO_ [RFC9380]およびDST = \"Hashtogroup-\" ||コンテキストストリング。hashtoscalar（）：l = 98、sha-512、dst = \"hashtoscalar-\" ||を使用してl = 98、expand_message_xmdを使用して[rfc9380]からhash_to_fieldを使用します。ContextString、およびgroup.order（）に等しいプライムモジュラス。ScalarInverse（s）：入力スカラーs mod group.order（）の乗法逆を返します。SerializeElement（a）：[SEC1]に従って圧縮された楕円曲線ポイントからオクセットストリング法を使用して実装されました。NE = 67. DeserializeElement（BUF）：[SEC1]に従って圧縮されたOctet-String-to-Elliptic-Curve-Pointメソッドを使用して、67バイトの入力文字列を公開キーに脱着しようとすることにより実装され、部分的なパブリックを実行する - [keyagreement]のセクション5.6.2.3.4で定義されているキー検証。これには、結果のポイントの座標が正しい範囲にあること、ポイントが曲線上にあること、およびポイントが無限のポイントではないことを確認することが含まれます。さらに、この関数は、結果の要素がグループアイデンティティ要素ではないことを検証します。これらのチェックが失敗した場合、DeserializationはinputValidationErrorエラーを返します。SerializeScalar（S）：[SEC1]に従ってフィールドエレメントからオクセットのストリング変換を使用して実装されました。NS = 66. DeserializeScalar（BUF）：[SEC1]からのOctet-String-to-Field-Elementを使用して、66バイトの文字列からスカラーを脱また重化しようとすることにより実装されました。入力が範囲のスカラーを表していない場合、この関数は故障する可能性があります[0、g.order（）-1]。"
    },
    {
      "indent": 3,
      "text": "Hash:",
      "ja": "ハッシュ："
    },
    {
      "indent": 12,
      "text": "SHA-512; Nh = 64.",
      "ja": "SHA-512;NH = 64。"
    },
    {
      "indent": 0,
      "text": "4.6. Future Ciphersuites",
      "section_title": true,
      "ja": "4.6. 将来のciphersuites"
    },
    {
      "indent": 3,
      "text": "A critical requirement of implementing the prime-order group using elliptic curves is a method to instantiate the function HashToGroup, which maps inputs to group elements. In the elliptic curve setting, this deterministically maps inputs (as byte arrays) to uniformly chosen points on the curve.",
      "ja": "楕円曲線を使用してプライムオーダーグループを実装するための重要な要件は、グループ要素に入力をマップする関数ハッシュトグループをインスタンス化する方法です。楕円曲線設定では、この決定論的に（バイト配列として）入力をマップして、曲線上のポイントを均一に選択します。"
    },
    {
      "indent": 3,
      "text": "In the security proof of the construction, Hash is modeled as a random oracle. This implies that any instantiation of HashToGroup must be pre-image and collision resistant. In Section 4, we give instantiations of this functionality based on the functions described in [RFC9380]. Consequently, any OPRF implementation must adhere to the implementation and security considerations discussed in [RFC9380] when instantiating the function.",
      "ja": "構造のセキュリティ証明では、ハッシュはランダムオラクルとしてモデル化されています。これは、ハッシュグラープのインスタンス化は、イメージ前と衝突耐性でなければならないことを意味します。セクション4では、[RFC9380]で説明されている機能に基づいて、この機能のインスタンス化を示します。その結果、OPRFの実装は、関数をインスタンス化する際に[RFC9380]で議論された実装とセキュリティの考慮事項を順守する必要があります。"
    },
    {
      "indent": 3,
      "text": "The DeserializeElement and DeserializeScalar functions instantiated for a particular prime-order group corresponding to a ciphersuite MUST adhere to the description in Section 2.1. Future ciphersuites MUST describe how input validation is done for DeserializeElement and DeserializeScalar.",
      "ja": "deserializeElementおよびDeserializecalar機能は、Ciphersuiteに対応する特定のPrime-orderグループに具体化された機能をセクション2.1の説明に付着させる必要があります。将来のシファースーツは、DeserializeElementとDeserializecalarの入力検証がどのように行われるかを説明する必要があります。"
    },
    {
      "indent": 3,
      "text": "Additionally, future ciphersuites must take care when choosing the security level of the group. See Section 7.2.3 for additional details.",
      "ja": "さらに、グループのセキュリティレベルを選択する際には、将来のCiphersuitesが注意する必要があります。詳細については、セクション7.2.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.7. Random Scalar Generation",
      "section_title": true,
      "ja": "4.7. ランダムスカラー生成"
    },
    {
      "indent": 3,
      "text": "Two popular algorithms for generating a random integer uniformly distributed in the range [0, G.Order() - 1] are described in the following subsections.",
      "ja": "範囲[0、g.order（）-1]に均一に分布したランダム整数を生成するための2つの一般的なアルゴリズムは、以下のサブセクションで説明されています。"
    },
    {
      "indent": 0,
      "text": "4.7.1. Rejection Sampling",
      "section_title": true,
      "ja": "4.7.1. 拒否サンプリング"
    },
    {
      "indent": 3,
      "text": "Generate a random byte array with Ns bytes and attempt to map to a Scalar by calling DeserializeScalar in constant time. If it succeeds, return the result. If it fails, try again with another random byte array until the procedure succeeds. Failure to implement DeserializeScalar in constant time can leak information about the underlying corresponding Scalar.",
      "ja": "NSバイトを使用してランダムなバイト配列を生成し、一定の時間でDeserializecalarを呼び出すことにより、スカラーにマッピングしようとします。成功した場合は、結果を返します。失敗した場合は、手順が成功するまで、別のランダムバイト配列で再試行してください。一定の時間にdeserializecalarを実装しないと、基礎となる対応するスカラーに関する情報が漏れます。"
    },
    {
      "indent": 3,
      "text": "As an optimization, if the group order is very close to a power of 2, it is acceptable to omit the rejection test completely. In particular, if the group order is p and there is an integer b such that |p - 2^b| is less than 2^(b/2), then RandomScalar can simply return a uniformly random integer of at most b bits.",
      "ja": "最適化として、グループの順序が2のパワーに非常に近い場合、拒否テストを完全に省略することは許容されます。特に、グループの順序がpで、| p -2^b |のような整数Bがある場合2^（b/2）未満である場合、Randomscalarは、ほとんどのBビットの均一にランダムな整数を単純に返すことができます。"
    },
    {
      "indent": 0,
      "text": "4.7.2. Random Number Generation Using Extra Random Bits",
      "section_title": true,
      "ja": "4.7.2. 余分なランダムビットを使用した乱数生成"
    },
    {
      "indent": 3,
      "text": "Generate a random byte array with L = ceil(((3 * ceil(log2(G.Order()))) / 2) / 8) bytes, and interpret it as an integer; reduce the integer modulo G.Order(), and return the result. See [RFC9380], Section 5 for the underlying derivation of L.",
      "ja": "l = ceil（（（3 * ceil（g.order（））） / 8） / 8）のl = ceil（（3 * ceil（g.order（））） / 8）でランダムなバイト配列を生成し、整数として解釈します。整数modulo g.order（）を減らし、結果を返します。Lの基礎となる導出については、[RFC9380]、セクション5を参照してください。"
    },
    {
      "indent": 0,
      "text": "5. Application Considerations",
      "section_title": true,
      "ja": "5. アプリケーションの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section describes considerations for applications, including external interface recommendations, explicit error treatment, and public input representation for the POPRF protocol variant.",
      "ja": "このセクションでは、外部インターフェイスの推奨事項、明示的なエラー処理、POPRFプロトコルバリアントのパブリック入力表現など、アプリケーションの考慮事項について説明します。"
    },
    {
      "indent": 0,
      "text": "5.1. Input Limits",
      "section_title": true,
      "ja": "5.1. 入力制限"
    },
    {
      "indent": 3,
      "text": "Application inputs, expressed as PrivateInput or PublicInput values, MUST be smaller than 2^16 - 1 bytes in length. Applications that require longer inputs can use a cryptographic hash function to map these longer inputs to a fixed-length input that fits within the PublicInput or PrivateInput length bounds. Note that some cryptographic hash functions have input length restrictions themselves, but these limits are often large enough to not be a concern in practice. For example, SHA-256 has an input limit of 2^61 bytes.",
      "ja": "PrivateInputまたはpublicInput値として表されるアプリケーション入力は、長さが2^16-1バイトより小さい必要があります。より長い入力を必要とするアプリケーションは、暗号化ハッシュ関数を使用して、これらの長い入力をpublicInputまたはprivateinputの長さの境界内に適合する固定長入力にマッピングできます。一部の暗号化ハッシュ関数には、入力長の制限自体がありますが、これらの制限は、実際には懸念されないほど十分に大きいことがあることに注意してください。たとえば、SHA-256の入力制限は2^61バイトです。"
    },
    {
      "indent": 0,
      "text": "5.2. External Interface Recommendations",
      "section_title": true,
      "ja": "5.2. 外部インターフェイスの推奨事項"
    },
    {
      "indent": 3,
      "text": "In Section 3.3, the interface of the protocol functions allows that some inputs (and outputs) to be group Element and Scalar values. However, implementations can instead operate over Element and Scalar values internally and only expose interfaces that operate with an application-specific format of messages.",
      "ja": "セクション3.3では、プロトコル関数のインターフェイスにより、一部の入力（および出力）がグループ要素とスカラー値になることができます。ただし、実装は代わりに要素とスカラーの値を内部的に操作し、アプリケーション固有のメッセージの形式で動作するインターフェイスのみを公開することができます。"
    },
    {
      "indent": 0,
      "text": "5.3. Error Considerations",
      "section_title": true,
      "ja": "5.3. エラーの考慮事項"
    },
    {
      "indent": 3,
      "text": "Some OPRF variants specified in this document have fallible operations. For example, Finalize and BlindEvaluate can fail if any element received from the peer fails input validation. The explicit errors generated throughout this specification, along with the conditions that lead to each error, are as follows:",
      "ja": "このドキュメントで指定されている一部のOPRFバリアントには、誤りのある操作があります。たとえば、ピアから受け取った要素が入力検証に失敗した場合、ファイナライズとブラインドヴァリュートは失敗する可能性があります。この仕様全体で生成された明示的なエラーは、各エラーにつながる条件とともに、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "VerifyError:",
      "ja": "VerifyError："
    },
    {
      "indent": 12,
      "text": "Verifiable OPRF proof verification failed (Sections 3.3.2 and 3.3.3).",
      "ja": "検証可能なOPRF証明検証に失敗しました（セクション3.3.2および3.3.3）。"
    },
    {
      "indent": 3,
      "text": "DeserializeError:",
      "ja": "DeserializeError："
    },
    {
      "indent": 12,
      "text": "Group Element or Scalar deserialization failure (Sections 2.1 and 3.3).",
      "ja": "グループ要素またはスカラースターリア化障害（セクション2.1および3.3）。"
    },
    {
      "indent": 3,
      "text": "InputValidationError:",
      "ja": "inputValidationError："
    },
    {
      "indent": 12,
      "text": "Validation of byte array inputs failed (Section 4).",
      "ja": "バイト配列入力の検証は失敗しました（セクション4）。"
    },
    {
      "indent": 3,
      "text": "There are other explicit errors generated in this specification; however, they occur with negligible probability in practice. We note them here for completeness.",
      "ja": "この仕様には他の明示的なエラーが生成されています。ただし、実際には無視できる確率で発生します。ここでは、完全性について注意してください。"
    },
    {
      "indent": 3,
      "text": "InvalidInputError:",
      "ja": "Invalidinputerror："
    },
    {
      "indent": 12,
      "text": "OPRF Blind input produces an invalid output element (Sections 3.3.1 and 3.3.3).",
      "ja": "OPRFブラインド入力は、無効な出力要素を生成します（セクション3.3.1および3.3.3）。"
    },
    {
      "indent": 3,
      "text": "InverseError:",
      "ja": "inverseRerror："
    },
    {
      "indent": 12,
      "text": "A tweaked private key is invalid, i.e., has no multiplicative inverse (Sections 2.1 and 3.3).",
      "ja": "微調整された秘密鍵は無効です。つまり、乗算的な逆はありません（セクション2.1および3.3）。"
    },
    {
      "indent": 3,
      "text": "In general, the errors in this document are meant as a guide to implementors. They are not an exhaustive list of all the errors an implementation might emit. For example, implementations might run out of memory and return a corresponding error.",
      "ja": "一般に、このドキュメントのエラーは、実装者へのガイドとして意図されています。それらは、実装が発する可能性のあるすべてのエラーの網羅的なリストではありません。たとえば、実装はメモリが不足し、対応するエラーを返す場合があります。"
    },
    {
      "indent": 0,
      "text": "5.4. POPRF Public Input",
      "section_title": true,
      "ja": "5.4. popRFパブリック入力"
    },
    {
      "indent": 3,
      "text": "Functionally, the VOPRF and POPRF variants differ in that the POPRF variant admits public input, whereas the VOPRF variant does not. Public input allows clients and servers to cryptographically bind additional data to the POPRF output. A POPRF with fixed public input is functionally equivalent to a VOPRF. However, there are differences in the underlying security assumptions made about each variant; see Section 7.2 for more details.",
      "ja": "機能的には、VOPRFとPOPRFのバリアントは、POPRFバリアントがパブリックインプットを認めるという点で異なりますが、VOPRFバリアントはそうではありません。パブリック入力により、クライアントとサーバーは、追加データをPOPRF出力に暗号化することができます。固定された公開入力を備えたPOPRFは、VOPRFと機能的に同等です。ただし、各バリアントについて行われた基礎となるセキュリティの仮定には違いがあります。詳細については、セクション7.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "This public input is known to both parties at the start of the protocol. It is RECOMMENDED that this public input be constructed with some type of higher-level domain separation to avoid cross protocol attacks or related issues. For example, protocols using this construction might ensure that the public input uses a unique, prefix-free encoding. See [RFC9380], Section 10.4 for further discussion on constructing domain separation values.",
      "ja": "この公開入力は、プロトコルの開始時に両当事者に知られています。クロスプロトコル攻撃や関連する問題を回避するために、この公開入力は、ある種の高レベルドメイン分離で構築することをお勧めします。たとえば、この構造を使用するプロトコルは、パブリック入力が一意のプレフィックスフリーのエンコードを使用することを保証する場合があります。ドメイン分離値の構築に関する詳細については、[RFC9380]、セクション10.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "Implementations of the POPRF may choose to not let applications control info in cases where this value is fixed or otherwise not useful to the application. In this case, the resulting protocol is functionally equivalent to the VOPRF, which does not admit public input.",
      "ja": "POPRFの実装は、この値が固定されている場合、またはアプリケーションに役立たない場合にアプリケーションに情報を制御させないことを選択する場合があります。この場合、結果のプロトコルは、パブリックインプットを認めないVOPRFと機能的に同等です。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "このドキュメントにはIANAアクションがありません。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This section discusses the security of the protocols defined in this specification, along with some suggestions and trade-offs that arise from the implementation of the protocol variants in this document. Note that the syntax of the POPRF variant is different from that of the OPRF and VOPRF variants since it admits an additional public input, but the same security considerations apply.",
      "ja": "このセクションでは、この仕様で定義されているプロトコルのセキュリティと、このドキュメントのプロトコルバリアントの実装から生じるいくつかの提案とトレードオフについて説明します。POPRFバリアントの構文は、追加のパブリック入力を認めているため、OPRFおよびVOPRFバリアントの構文とは異なることに注意してください。"
    },
    {
      "indent": 0,
      "text": "7.1. Security Properties",
      "section_title": true,
      "ja": "7.1. セキュリティプロパティ"
    },
    {
      "indent": 3,
      "text": "The security properties of an OPRF protocol with functionality y = F(k, x) include those of a standard PRF. Specifically:",
      "ja": "機能性y = f（k、x）を備えたOPRFプロトコルのセキュリティプロパティには、標準のPRFのセキュリティプロパティが含まれます。具体的には："
    },
    {
      "indent": 3,
      "text": "Pseudorandomness:",
      "ja": "疑似ランダムネス："
    },
    {
      "indent": 12,
      "text": "For a random sampling of k, F is pseudorandom if the output y = F(k, x) on any input x is indistinguishable from uniformly sampling any element in F's range.",
      "ja": "kのランダムサンプリングの場合、入力xの出力y = f（k、x）がfの範囲の要素を均一にサンプリングすることと見分けがつかない場合、fは擬似ランダムです。"
    },
    {
      "indent": 3,
      "text": "In other words, consider an adversary that picks inputs x from the domain of F and evaluates F on (k, x) (without knowledge of randomly sampled k). Then, the output distribution F(k, x) is indistinguishable from the output distribution of a randomly chosen function with the same domain and range.",
      "ja": "言い換えれば、fのドメインから入力xを選択し、f on（k、x）を評価する敵を検討してください（ランダムにサンプリングされたkの知識なし）。次に、出力分布f（k、x）は、同じドメインと範囲を持つランダムに選択された関数の出力分布と区別できません。"
    },
    {
      "indent": 3,
      "text": "A consequence of showing that a function is pseudorandom is that it is necessarily nonmalleable (i.e., we cannot compute a new evaluation of F from an existing evaluation). A genuinely random function will be nonmalleable with high probability, so a pseudorandom function must be nonmalleable to maintain indistinguishability.",
      "ja": "関数が疑似ランダムであることを示した結果、それは必ずしも有balであることです（つまり、既存の評価からFの新しい評価を計算することはできません）。真にランダムな関数は、確率が高い場合に有効ではないため、区別可能性を維持するために擬似ランダム関数は依存できない必要があります。"
    },
    {
      "indent": 3,
      "text": "Unconditional input secrecy:",
      "ja": "無条件の入力の秘密："
    },
    {
      "indent": 12,
      "text": "The server does not learn anything about the client input x, even with unbounded computation.",
      "ja": "サーバーは、固定されていない計算があっても、クライアント入力Xについて何も学習しません。"
    },
    {
      "indent": 3,
      "text": "In other words, an attacker with infinite computing power cannot recover any information about the client's private input x from an invocation of the protocol.",
      "ja": "言い換えれば、無限のコンピューティングパワーを持つ攻撃者は、プロトコルの呼び出しからクライアントのプライベート入力Xに関する情報を回復することはできません。"
    },
    {
      "indent": 3,
      "text": "Essentially, input secrecy is the property that, even if the server learns the client's private input x at some point in the future, the server cannot link any particular PRF evaluation to x. This property is also known as unlinkability [DGSTV18].",
      "ja": "基本的に、入力秘密は、将来のある時点でサーバーがクライアントのプライベート入力xを学習したとしても、サーバーが特定のPRF評価をxにリンクできないというプロパティです。この特性は、リンク不可能性[DGSTV18]としても知られています。"
    },
    {
      "indent": 3,
      "text": "Beyond client input secrecy, in the OPRF protocol, the server learns nothing about the output y of the function, nor does the client learn anything about the server's private key k.",
      "ja": "クライアントの入力秘密を超えて、OPRFプロトコルでは、サーバーは関数の出力Yについて何も学習しません。また、クライアントはサーバーの秘密キーkについて何も学習しません。"
    },
    {
      "indent": 3,
      "text": "For the VOPRF and POPRF protocol variants, there is an additional security property:",
      "ja": "VOPRFおよびPOPRFプロトコルバリアントには、追加のセキュリティプロパティがあります。"
    },
    {
      "indent": 3,
      "text": "Verifiable:",
      "ja": "検証可能："
    },
    {
      "indent": 12,
      "text": "The client must only complete execution of the protocol if it can successfully assert that the output it computes is correct. This is taken with respect to the private key held by the server.",
      "ja": "クライアントは、コンピューターの出力が正しいことを正常に主張できる場合にのみ、プロトコルの実行を完了する必要があります。これは、サーバーが保持している秘密鍵に関して取られます。"
    },
    {
      "indent": 3,
      "text": "Any VOPRF or POPRF that satisfies the 'verifiable' security property is known as 'verifiable'. In practice, the notion of verifiability requires that the server commits to the key before the actual protocol execution takes place. Then, the client verifies that the server has used the key in the protocol using this commitment. In the following, we may also refer to this commitment as a public key.",
      "ja": "「検証可能な」セキュリティプロパティを満たすVOPRFまたはPOPRFは、「検証可能」として知られています。実際には、検証可能性の概念には、実際のプロトコルの実行が行われる前にサーバーがキーにコミットすることが必要です。次に、クライアントは、このコミットメントを使用して、サーバーがプロトコルでキーを使用したことを確認します。以下では、このコミットメントを公開鍵と呼ぶこともあります。"
    },
    {
      "indent": 3,
      "text": "Finally, the POPRF variant also has the following security property:",
      "ja": "最後に、POPRFバリアントには次のセキュリティプロパティもあります。"
    },
    {
      "indent": 3,
      "text": "Partial obliviousness:",
      "ja": "部分的な忘却："
    },
    {
      "indent": 12,
      "text": "The client and server must be able to perform the PRF on the client's private and public input. Both the client and server know the public input, but similar to the OPRF and VOPRF protocols, the server learns nothing about the client's private input or the output of the function, and the client learns nothing about the server's private key.",
      "ja": "クライアントとサーバーは、クライアントのプライベートおよびパブリック入力でPRFを実行できる必要があります。クライアントとサーバーの両方がパブリック入力を知っていますが、OPRFおよびVOPRFプロトコルと同様に、サーバーはクライアントのプライベート入力または関数の出力について何も学習しません。クライアントはサーバーのプライベートキーについて何も学習しません。"
    },
    {
      "indent": 3,
      "text": "This property becomes useful when dealing with key management operations, such as the rotation of the server's keys. Note that partial obliviousness only applies to the POPRF variant because neither the OPRF nor VOPRF variants accept public input to the protocol.",
      "ja": "このプロパティは、サーバーのキーの回転などの主要な管理操作を扱うときに役立ちます。OPRFバリアントもVOPRFバリアントもプロトコルへのパブリック入力を受け入れないため、部分忘却はPOPRFバリアントにのみ適用されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Since the POPRF variant has a different syntax than the OPRF and VOPRF variants, i.e., y = F(k, x, info), the pseudorandomness property is generalized:",
      "ja": "POPRFバリアントはOPRFおよびVOPRFバリアントとは異なる構文を持っているため、つまりY = F（k、x、info）は、擬似ランダムネスプロパティが一般化されています。"
    },
    {
      "indent": 3,
      "text": "Pseudorandomness:",
      "ja": "疑似ランダムネス："
    },
    {
      "indent": 12,
      "text": "For a random sampling of k, F is pseudorandom if the output y = F(k, x, info) on any input pairs (x, info) is indistinguishable from uniformly sampling any element in F's range.",
      "ja": "kのランダムサンプリングの場合、入力ペア（x、info）の出力y = f（k、x、info）がfの範囲の要素を均一にサンプリングすることと見分けがつかない場合、fは擬似ランダムです。"
    },
    {
      "indent": 0,
      "text": "7.2. Security Assumptions",
      "section_title": true,
      "ja": "7.2. セキュリティの仮定"
    },
    {
      "indent": 3,
      "text": "Below, we discuss the cryptographic security of each protocol variant from Section 3, relative to the necessary cryptographic assumptions that need to be made.",
      "ja": "以下では、セクション3からの各プロトコルバリアントの暗号化のセキュリティについて、必要な暗号化された仮定を行う必要があることについて説明します。"
    },
    {
      "indent": 0,
      "text": "7.2.1. OPRF and VOPRF Assumptions",
      "section_title": true,
      "ja": "7.2.1. OPRFおよびVOPRFの仮定"
    },
    {
      "indent": 3,
      "text": "The OPRF and VOPRF protocol variants in this document are based on [JKK14]. In particular, the VOPRF construction is similar to the [JKK14] construction with the following distinguishing properties:",
      "ja": "このドキュメントのOPRFおよびVOPRFプロトコルバリアントは[JKK14]に基づいています。特に、VOPRF構造は、次の際立った特性を備えた[JKK14]構造に似ています。"
    },
    {
      "indent": 8,
      "text": "1. This document does not use session identifiers to differentiate different instances of the protocol.",
      "ja": "1. このドキュメントでは、セッション識別子を使用して、プロトコルのさまざまなインスタンスを区別しません。"
    },
    {
      "indent": 8,
      "text": "2. This document supports batching so that multiple evaluations can happen at once whilst only constructing one DLEQ proof object. This is enabled using an established batching technique [DGSTV18].",
      "ja": "2. このドキュメントはバッチングをサポートしているため、1つのDLEQプルーフオブジェクトのみを構築しながら、複数の評価が一度に発生する可能性があります。これは、確立されたバッチング手法[DGSTV18]を使用して有効になっています。"
    },
    {
      "indent": 3,
      "text": "The pseudorandomness and input secrecy (and verifiability) of the OPRF (and VOPRF) protocols in [JKK14] are based on the One-More Gap Computational Diffie-Hellman assumption that is computationally difficult to solve in the corresponding prime-order group. In [JKK14], these properties are proven for one instance (i.e., one key) of the VOPRF protocol and without batching. There is currently no security analysis available for the VOPRF protocol described in this document in a setting with multiple server keys or batching.",
      "ja": "[JKK14]のOPRF（およびVOPRF）プロトコルの擬似ランダム性と入力秘密（および検証可能性）は、対応するプライムオーダーグループで計算的に解決することが困難な1つのギャップ計算diffie-hellmanの仮定に基づいています。[JKK14]では、これらの特性は、VOPRFプロトコルの1つのインスタンス（つまり、1つのキー）で、バッチなしで証明されています。現在、このドキュメントで説明されているVOPRFプロトコルでは、複数のサーバーキーまたはバッチングを備えた設定で説明されているセキュリティ分析はありません。"
    },
    {
      "indent": 0,
      "text": "7.2.2. POPRF Assumptions",
      "section_title": true,
      "ja": "7.2.2. POPRF仮定"
    },
    {
      "indent": 3,
      "text": "The POPRF construction in this document is based on the construction known as 3HashSDHI, given by [TCRSTW21]. The construction is identical to 3HashSDHI, except that this design can optionally perform multiple POPRF evaluations in one batch, whilst only constructing one DLEQ proof object. This is enabled using an established batching technique [DGSTV18].",
      "ja": "このドキュメントのPOPRF構造は、[TCRSTW21]によって与えられた3hashsdhiとして知られる構造に基づいています。この設計は、1つのバッチで複数のPOPRF評価をオプションで実行できますが、1つのDLEQプルーフオブジェクトのみを構築することを除いて、構造は3hashsdhiと同じです。これは、確立されたバッチング手法[DGSTV18]を使用して有効になっています。"
    },
    {
      "indent": 3,
      "text": "Pseudorandomness, input secrecy, verifiability, and partial obliviousness of the POPRF variant is based on the assumption that the One-More Gap Strong Diffie-Hellman Inversion (SDHI) assumption from [TCRSTW21] is computationally difficult to solve in the corresponding prime-order group. Tyagi et al. [TCRSTW21] show that both the One-More Gap Computational Diffie-Hellman assumption and the One-More Gap SDHI assumption reduce to the q-DL (Discrete Log) assumption in the algebraic group model for some q number of BlindEvaluate queries. (The One-More Gap Computational Diffie-Hellman assumption was the hardness assumption used to evaluate the OPRF and VOPRF designs based on [JKK14], which is a predecessor to the POPRF variant in Section 3.3.3.)",
      "ja": "popRFバリアントの擬似ランダム性、入力の秘密、検証可能性、および部分的忘却は、[TCRSTW21]からの1つのギャップの強いDiffie-Hellman Inversion（SDHI）仮定が、対応するプライムオーダーグループで解決するのが計算が困難であるという仮定に基づいています。。Tyagi et al。[TCRSTW21]は、Q-DL（離散ログ）仮定が、Q-DL（離散ログ）の仮定を、Q-dl（離散ログ）の仮定を、q-dl（離散ログ）の仮定を、q-dl（離散ログ）の仮定を、q-dl（離散ログ）の仮定を、q-dl（離散ログ）仮定の両方が、q-dl（離散ログ）仮定を減少させることを示しています。（1つのギャップ計算diffie-hellmanの仮定は、セクション3.3.3のPopRFバリアントの前身である[JKK14]に基づいてOPRFおよびVOPRF設計を評価するために使用される硬度の仮定でした。）"
    },
    {
      "indent": 0,
      "text": "7.2.3. Static Diffie-Hellman Attack and Security Limits",
      "section_title": true,
      "ja": "7.2.3. 静的diffie-hellman攻撃とセキュリティ制限"
    },
    {
      "indent": 3,
      "text": "A side effect of the OPRF protocol variants in this document is that they allow instantiation of an oracle for constructing static Diffie-Hellman (DH) samples; see [BG04] and [Cheon06]. These attacks are meant to recover (bits of) the server private key. Best-known attacks reduce the security of the prime-order group instantiation by log_2(Q) / 2 bits, where Q is the number of BlindEvaluate calls made by the attacker.",
      "ja": "このドキュメントでのOPRFプロトコルバリアントの副作用は、静的diffie-hellman（DH）サンプルを構築するためにOracleのインスタンス化を可能にすることです。[BG04]および[cheon06]を参照してください。これらの攻撃は、サーバーの秘密キーを回復（ビット）することを目的としています。最もよく知られている攻撃は、LOG_2（Q） / 2ビットによるプライムオーダーグループインスタンス化のセキュリティを減らします。ここで、Qは攻撃者が作成した失明の呼び出しの数です。"
    },
    {
      "indent": 3,
      "text": "As a result of this class of attacks, choosing prime-order groups with a 128-bit security level instantiates an OPRF with a reduced security level of 128 - (log_2(Q) / 2) bits of security. Moreover, such attacks are only possible for those certain applications where the adversary can query the OPRF directly. Applications can mitigate against this problem in a variety of ways, e.g., by rate-limiting client queries to BlindEvaluate or by rotating private keys. In applications where such an oracle is not made available, this security loss does not apply.",
      "ja": "このクラスの攻撃の結果として、128ビットのセキュリティレベルでプライムオーダーグループを選択すると、セキュリティレベルが128個の（LOG_2（Q） / 2）セキュリティビットが減少してOPRFがインスタンス化されます。さらに、このような攻撃は、敵がOPRFを直接照会できる特定のアプリケーションでのみ可能です。アプリケーションは、たとえば、レート制限クライアントクエリを盲目的にするため、またはプライベートキーを回転させることにより、さまざまな方法でこの問題に対して緩和できます。そのようなオラクルが利用可能になっていないアプリケーションでは、このセキュリティ損失は適用されません。"
    },
    {
      "indent": 3,
      "text": "In most cases, it would require an informed and persistent attacker to launch a highly expensive attack to reduce security to anything much below 100 bits of security. Applications that admit the aforementioned oracle functionality and that cannot tolerate discrete logarithm security of lower than 128 bits are RECOMMENDED to choose groups that target a higher security level, such as decaf448 (used by ciphersuite decaf448-SHAKE256), P-384 (used by ciphersuite P384-SHA384), or P-521 (used by ciphersuite P521-SHA512).",
      "ja": "ほとんどの場合、セキュリティを100ビット未満のセキュリティに減らすために、非常に高価な攻撃を開始するには、情報に基づいた永続的な攻撃者が必要です。前述のOracle機能を認め、128ビット未満の離散対数セキュリティに耐えられないアプリケーションは、decaf448（Ciphersuite decaf448-shake256が使用）、P-384（Ciphersuiteuiteで使用する）などのより高いセキュリティレベルを対象とするグループを選択することをお勧めします。P384-SHA384）、またはP-521（Ciphersuite P521-Sha512が使用）。"
    },
    {
      "indent": 0,
      "text": "7.3. Domain Separation",
      "section_title": true,
      "ja": "7.3. ドメイン分離"
    },
    {
      "indent": 3,
      "text": "Applications SHOULD construct input to the protocol to provide domain separation. Any system that has multiple OPRF applications should distinguish client inputs to ensure the OPRF results are separate. Guidance for constructing info can be found in [RFC9380], Section 3.1.",
      "ja": "アプリケーションは、ドメイン分離を提供するためにプロトコルへの入力を構築する必要があります。複数のOPRFアプリケーションを備えたシステムは、OPRFの結果が個別になるようにクライアント入力を区別する必要があります。情報を構築するためのガイダンスは、[RFC9380]、セクション3.1にあります。"
    },
    {
      "indent": 0,
      "text": "7.4. Timing Leaks",
      "section_title": true,
      "ja": "7.4. タイミングリーク"
    },
    {
      "indent": 3,
      "text": "To ensure no information is leaked during protocol execution, all operations that use secret data MUST run in constant time. This includes all prime-order group operations and proof-specific operations that operate on secret data, including GenerateProof and BlindEvaluate.",
      "ja": "プロトコルの実行中に情報が漏れないようにするには、秘密データを使用するすべての操作が一定の時間で実行される必要があります。これには、すべてのプライムオーダーグループ操作と、GenerateProofやVellincevaluateなどの秘密データで動作する証明固有の操作が含まれます。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8. 参考文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[KEYAGREEMENT]\n           Barker, E., Chen, L., Roginsky, A., Vassilev, A., and R.\n           Davis, \"Recommendation for pair-wise key-establishment\n           schemes using discrete logarithm cryptography\", NIST\n           SP 800-56A (Rev. 3), DOI 10.6028/nist.sp.800-56ar3, April\n           2018, <https://doi.org/10.6028/nist.sp.800-56ar3>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,\n           \"PKCS #1: RSA Cryptography Specifications Version 2.2\",\n           RFC 8017, DOI 10.17487/RFC8017, November 2016,\n           <https://www.rfc-editor.org/info/rfc8017>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9380]  Faz-Hernandez, A., Scott, S., Sullivan, N., Wahby, R. S.,\n           and C. A. Wood, \"Hashing to Elliptic Curves\", RFC 9380,\n           DOI 10.17487/RFC9380, August 2023,\n           <https://www.rfc-editor.org/info/rfc9380>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9496]  de Valence, H., Grigg, J., Hamburg, M., Lovecruft, I.,\n           Tankersley, G., and F. Valsorda, \"The ristretto255 and\n           decaf448 Groups\", RFC 9496, DOI 10.17487/RFC9496, December\n           2023, <https://www.rfc-editor.org/info/rfc9496>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[BG04]     Brown, D. and R. Gallant, \"The Static Diffie-Hellman\n           Problem\", November 2004,\n           <https://eprint.iacr.org/2004/306>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[ChaumPedersen]\n           Chaum, D. and T. Pedersen, \"Wallet Databases with\n           Observers\", Advances in Cryptology - CRYPTO' 92, pp.\n           89-105, DOI 10.1007/3-540-48071-4_7, August 1992,\n           <https://doi.org/10.1007/3-540-48071-4_7>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Cheon06]  Cheon, J., \"Security Analysis of the Strong Diffie-Hellman\n           Problem\", Advances in Cryptology - EUROCRYPT 2006, pp.\n           1-11, DOI 10.1007/11761679_1, 2006,\n           <https://doi.org/10.1007/11761679_1>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[DGSTV18]  Davidson, A., Goldberg, I., Sullivan, N., Tankersley, G.,\n           and F. Valsorda, \"Privacy Pass: Bypassing Internet\n           Challenges Anonymously\", Proceedings on Privacy Enhancing\n           Technologies, vol. 2018, no. 3, pp. 164-180, DOI \n           10.1515/popets-2018-0026, April 2018,\n           <https://doi.org/10.1515/popets-2018-0026>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[FS00]     Fiat, A. and A. Shamir, \"How To Prove Yourself: Practical\n           Solutions to Identification and Signature Problems\",\n           Advances in Cryptology - CRYPTO' 86, pp. 186-194,\n           DOI 10.1007/3-540-47721-7_12, 1986,\n           <https://doi.org/10.1007/3-540-47721-7_12>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[JKK14]    Jarecki, S., Kiayias, A., and H. Krawczyk, \"Round-Optimal\n           Password-Protected Secret Sharing and T-PAKE in the\n           Password-Only Model\", Lecture Notes in Computer Science,\n           pp. 233-253, DOI 10.1007/978-3-662-45608-8_13, 2014,\n           <https://doi.org/10.1007/978-3-662-45608-8_13>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[JKKX16]   Jarecki, S., Kiayias, A., Krawczyk, H., and J. Xu,\n           \"Highly-Efficient and Composable Password-Protected Secret\n           Sharing (Or: How to Protect Your Bitcoin Wallet Online)\",\n           2016 IEEE European Symposium on Security and Privacy\n           (EuroS&P), DOI 10.1109/eurosp.2016.30, March 2016,\n           <https://doi.org/10.1109/eurosp.2016.30>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[NISTCurves]\n           National Institute of Standards and Technology (NIST),\n           \"Digital Signature Standard (DSS)\", FIPS PUB 186-5,\n           DOI 10.6028/NIST.FIPS.186-5, February 2023,\n           <https://doi.org/10.6028/NIST.FIPS.186-5>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[OPAQUE]   Bourdrez, D., Krawczyk, H., Lewi, K., and C. A. Wood, \"The\n           OPAQUE Asymmetric PAKE Protocol\", Work in Progress,\n           Internet-Draft, draft-irtf-cfrg-opaque-13, 18 December\n           2023, <https://datatracker.ietf.org/doc/html/draft-irtf-\n           cfrg-opaque-13>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[PRIVACY-PASS]\n           Celi, S., Davidson, A., Valdez, S., and C. A. Wood,\n           \"Privacy Pass Issuance Protocol\", Work in Progress,\n           Internet-Draft, draft-ietf-privacypass-protocol-16, 3\n           October 2023, <https://datatracker.ietf.org/doc/html/\n           draft-ietf-privacypass-protocol-16>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[PrivacyPass]\n           \"Privacy Pass\", commit 085380a, March 2018,\n           <https://github.com/privacypass/team>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7748]  Langley, A., Hamburg, M., and S. Turner, \"Elliptic Curves\n           for Security\", RFC 7748, DOI 10.17487/RFC7748, January\n           2016, <https://www.rfc-editor.org/info/rfc7748>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SEC1]     Standards for Efficient Cryptography Group (SECG), \"SEC 1:\n           Elliptic Curve Cryptography\", May 2009,\n           <https://www.secg.org/sec1-v2.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SJKS17]   Shirvanian, M., Jarecki, S., Krawczyk, H., and N. Saxena,\n           \"SPHINX: A Password Store that Perfectly Hides Passwords\n           from Itself\", 2017 IEEE 37th International Conference on\n           Distributed Computing Systems (ICDCS),\n           DOI 10.1109/ICDCS.2017.64, June 2017,\n           <https://doi.org/10.1109/ICDCS.2017.64>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[TCRSTW21] Tyagi, N., Celi, S., Ristenpart, T., Sullivan, N.,\n           Tessaro, S., and C. A. Wood, \"A Fast and Simple Partially\n           Oblivious PRF, with Applications\", Advances in Cryptology\n           - EUROCRYPT 2022 pp. 674-705,\n           DOI 10.1007/978-3-031-07085-3_23, May 2022,\n           <https://doi.org/10.1007/978-3-031-07085-3_23>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix A. Test Vectors",
      "section_title": true,
      "ja": "付録A. テストベクトル"
    },
    {
      "indent": 3,
      "text": "This section includes test vectors for the protocol variants specified in this document. For each ciphersuite specified in Section 4, there is a set of test vectors for the protocol when running the OPRF, VOPRF, and POPRF modes. Each test vector lists the batch size for the evaluation. Each test vector value is encoded as a hexadecimal byte string. The fields of each test vector are described below.",
      "ja": "このセクションには、このドキュメントで指定されたプロトコルバリアントのテストベクトルが含まれています。セクション4で指定されている各衝突器に、OPRF、VOPRF、およびPOPRFモードを実行すると、プロトコルのテストベクトルのセットがあります。各テストベクトルは、評価のバッチサイズをリストします。各テストベクトル値は、16進バイト文字列としてエンコードされます。各テストベクトルのフィールドを以下に説明します。"
    },
    {
      "indent": 3,
      "text": "\"Input\":",
      "ja": "\"入力\"："
    },
    {
      "indent": 12,
      "text": "The private client input, an opaque byte string.",
      "ja": "プライベートクライアントの入力、不透明なバイト文字列。"
    },
    {
      "indent": 3,
      "text": "\"Info\":",
      "ja": "\"情報\"："
    },
    {
      "indent": 12,
      "text": "The public info, an opaque byte string. Only present for POPRF test vectors.",
      "ja": "公開情報、不透明なバイト文字列。POPRFテストベクトルにのみ存在します。"
    },
    {
      "indent": 3,
      "text": "\"Blind\":",
      "ja": "\"盲目\"："
    },
    {
      "indent": 12,
      "text": "The blind value output by Blind(), a serialized Scalar of Ns bytes long.",
      "ja": "nsのシリアル化されたスカラーであるブラインド（）によるブラインド値出力。"
    },
    {
      "indent": 3,
      "text": "\"BlindedElement\":",
      "ja": "「ブラインドレメント」："
    },
    {
      "indent": 12,
      "text": "The blinded value output by Blind(), a serialized Element of Ne bytes long.",
      "ja": "NEの長さのNEバイトのシリアル化された要素であるBlind（）によるブラインド値出力。"
    },
    {
      "indent": 3,
      "text": "\"EvaluatedElement\":",
      "ja": "「EvaluatedElement」："
    },
    {
      "indent": 12,
      "text": "The evaluated element output by BlindEvaluate(), a serialized Element of Ne bytes long.",
      "ja": "NEバイトのシリアル化された要素であるlindvaluate（）による評価された要素出力。"
    },
    {
      "indent": 3,
      "text": "\"Proof\":",
      "ja": "\"証拠\"："
    },
    {
      "indent": 12,
      "text": "The serialized Proof output from GenerateProof() composed of two serialized Scalar values, each Ns bytes long. Only present for VOPRF and POPRF test vectors.",
      "ja": "各nsの長さの2つのシリアル化されたスカラー値で構成されるGenerateProof（）からのシリアル化された証明出力。VOPRFおよびPOPRFテストベクトルにのみ存在します。"
    },
    {
      "indent": 3,
      "text": "\"ProofRandomScalar\":",
      "ja": "「Proofrandomscalar」："
    },
    {
      "indent": 12,
      "text": "The random Scalar r computed in GenerateProof(), a serialized Scalar of Ns bytes long. Only present for VOPRF and POPRF test vectors.",
      "ja": "NSバイトのシリアル化されたスカラーであるGenerateProof（）で計算されたランダムスカラー。VOPRFおよびPOPRFテストベクトルにのみ存在します。"
    },
    {
      "indent": 3,
      "text": "\"Output\":",
      "ja": "\"出力\"："
    },
    {
      "indent": 12,
      "text": "The protocol output, an opaque byte string of Nh bytes long.",
      "ja": "プロトコル出力、NHバイトの不透明なバイト文字列。"
    },
    {
      "indent": 3,
      "text": "Test vectors with batch size B > 1 have inputs separated by a comma \",\". Applicable test vectors will have B different values for the \"Input\", \"Blind\", \"BlindedElement\", \"EvaluationElement\", and \"Output\" fields.",
      "ja": "バッチサイズb> 1のテストベクトルには、コンマで分離された入力 \"、\"。適用されるテストベクトルは、「入力」、「ブラインド」、「ブラインドレメント」、「評価エレメント」、および「出力」フィールドに対してB異なる値を持ちます。"
    },
    {
      "indent": 3,
      "text": "The server key material, pkSm and skSm, are listed under the mode for each ciphersuite. Both pkSm and skSm are the serialized values of pkS and skS, respectively, as used in the protocol. Each key pair is derived from a seed, denoted Seed, and info string, denoted KeyInfo, which are listed as well, using the DeriveKeyPair function from Section 3.2.",
      "ja": "サーバーのキーマテリアルであるPKSMとSKSMは、各ciphersuiteのモードの下にリストされています。PKSMとSKSMの両方は、プロトコルで使用されるPKSとSKSのシリアル化値です。各キーペアは、セクション3.2のderiveKeypair関数を使用して、シード、シード、および情報文字列、およびkeyInfoと表示された情報文字列に由来します。"
    },
    {
      "indent": 0,
      "text": "A.1. ristretto255-SHA512",
      "section_title": true,
      "ja": "A.1. Ristretto255-Sha512"
    },
    {
      "indent": 0,
      "text": "A.1.1. OPRF Mode",
      "section_title": true,
      "ja": "A.1.1. OPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = 5ebcea5ee37023ccb9fc2d2019f9d7737be85591ae8652ffa9ef0f4d37063\nb0e",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1.1.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.1.1.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec4c1f\n6706\nBlindedElement = 609a0ae68c15a3cf6903766461307e5c8bb2f95e7e6550e1ffa\n2dc99e412803c\nEvaluationElement = 7ec6578ae5120958eb2db1745758ff379e77cb64fe77b0b2\nd8cc917ea0869c7e\nOutput = 527759c3d9366f277d8c6020418d96bb393ba2afb20ff90df23fb770826\n4e2f3ab9135e3bd69955851de4b1f9fe8a0973396719b7912ba9ee8aa7d0b5e24bcf\n6",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1.1.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.1.1.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec4c1f\n6706\nBlindedElement = da27ef466870f5f15296299850aa088629945a17d1f5b7f5ff0\n43f76b3c06418\nEvaluationElement = b4cbf5a4f1eeda5a63ce7b77c7d23f461db3fcab0dd28e4e\n17cecb5c90d02c25\nOutput = f4a74c9c592497375e796aa837e907b1a045d34306a749db9f34221f7e7\n50cb4f2a6413a6bf6fa5e19ba6348eb673934a722a7ede2e7621306d18951e7cf2c7\n3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1.2. VOPRF Mode",
      "section_title": true,
      "ja": "A.1.2. VOPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = e6f73f344b79b379f1a0dd37e07ff62e38d9f71345ce62ae3a9bc60b04ccd\n909\npkSm = c803e2cc6b05fc15064549b5920659ca4a77b2cca6f04f6b357009335476a\nd4e",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1.2.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.1.2.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec4c1f\n6706\nBlindedElement = 863f330cc1a1259ed5a5998a23acfd37fb4351a793a5b3c090b\n642ddc439b945\nEvaluationElement = aa8fa048764d5623868679402ff6108d2521884fa138cd7f\n9c7669a9a014267e\nProof = ddef93772692e535d1a53903db24367355cc2cc78de93b3be5a8ffcc6985\ndd066d4346421d17bf5117a2a1ff0fcb2a759f58a539dfbe857a40bce4cf49ec600d\nProofRandomScalar = 222a5e897cf59db8145db8d16e597e8facb80ae7d4e26d98\n81aa6f61d645fc0e\nOutput = b58cfbe118e0cb94d79b5fd6a6dafb98764dff49c14e1770b566e42402d\na1a7da4d8527693914139caee5bd03903af43a491351d23b430948dd50cde10d32b3\nc",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1.2.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.1.2.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec4c1f\n6706\nBlindedElement = cc0b2a350101881d8a4cba4c80241d74fb7dcbfde4a61fde2f9\n1443c2bf9ef0c\nEvaluationElement = 60a59a57208d48aca71e9e850d22674b611f752bed48b36f\n7a91b372bd7ad468\nProof = 401a0da6264f8cf45bb2f5264bc31e109155600babb3cd4e5af7d181a2c9\ndc0a67154fabf031fd936051dec80b0b6ae29c9503493dde7393b722eafdf5a50b02\nProofRandomScalar = 222a5e897cf59db8145db8d16e597e8facb80ae7d4e26d98\n81aa6f61d645fc0e\nOutput = 8a9a2f3c7f085b65933594309041fc1898d42d0858e59f90814ae90571a\n6df60356f4610bf816f27afdd84f47719e480906d27ecd994985890e5f539e7ea74b\n6",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1.2.3. Test Vector 3, Batch Size 2",
      "section_title": true,
      "ja": "A.1.2.3. テストベクトル3、バッチサイズ2"
    },
    {
      "indent": 3,
      "text": "Input = 00,5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec4c1f\n6706,222a5e897cf59db8145db8d16e597e8facb80ae7d4e26d9881aa6f61d645fc0\ne\nBlindedElement = 863f330cc1a1259ed5a5998a23acfd37fb4351a793a5b3c090b\n642ddc439b945,90a0145ea9da29254c3a56be4fe185465ebb3bf2a1801f7124bbba\ndac751e654\nEvaluationElement = aa8fa048764d5623868679402ff6108d2521884fa138cd7f\n9c7669a9a014267e,cc5ac221950a49ceaa73c8db41b82c20372a4c8d63e5dded2db\n920b7eee36a2a\nProof = cc203910175d786927eeb44ea847328047892ddf8590e723c37205cb7460\n0b0a5ab5337c8eb4ceae0494c2cf89529dcf94572ed267473d567aeed6ab873dee08\nProofRandomScalar = 419c4f4f5052c53c45f3da494d2b67b220d02118e0857cdb\ncf037f9ea84bbe0c\nOutput = b58cfbe118e0cb94d79b5fd6a6dafb98764dff49c14e1770b566e42402d\na1a7da4d8527693914139caee5bd03903af43a491351d23b430948dd50cde10d32b3\nc,8a9a2f3c7f085b65933594309041fc1898d42d0858e59f90814ae90571a6df6035\n6f4610bf816f27afdd84f47719e480906d27ecd994985890e5f539e7ea74b6",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1.3. POPRF Mode",
      "section_title": true,
      "ja": "A.1.3. POPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = 145c79c108538421ac164ecbe131942136d5570b16d8bf41a24d4337da981\ne07\npkSm = c647bef38497bc6ec077c22af65b696efa43bff3b4a1975a3e8e0a1c5a79d\n631",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1.3.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.1.3.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nInfo = 7465737420696e666f\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec4c1f\n6706\nBlindedElement = c8713aa89241d6989ac142f22dba30596db635c772cbf25021f\ndd8f3d461f715\nEvaluationElement = 1a4b860d808ff19624731e67b5eff20ceb2df3c3c03b906f\n5693e2078450d874\nProof = 41ad1a291aa02c80b0915fbfbb0c0afa15a57e2970067a602ddb9e8fd6b7\n100de32e1ecff943a36f0b10e3dae6bd266cdeb8adf825d86ef27dbc6c0e30c52206\nProofRandomScalar = 222a5e897cf59db8145db8d16e597e8facb80ae7d4e26d98\n81aa6f61d645fc0e\nOutput = ca688351e88afb1d841fde4401c79efebb2eb75e7998fa9737bd5a82a15\n2406d38bd29f680504e54fd4587eddcf2f37a2617ac2fbd2993f7bdf45442ace7d22\n1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1.3.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.1.3.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nInfo = 7465737420696e666f\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec4c1f\n6706\nBlindedElement = f0f0b209dd4d5f1844dac679acc7761b91a2e704879656cb7c2\n01e82a99ab07d\nEvaluationElement = 8c3c9d064c334c6991e99f286ea2301d1bde170b54003fb9\nc44c6d7bd6fc1540\nProof = 4c39992d55ffba38232cdac88fe583af8a85441fefd7d1d4a8d0394cd1de\n77018bf135c174f20281b3341ab1f453fe72b0293a7398703384bed822bfdeec8908\nProofRandomScalar = 222a5e897cf59db8145db8d16e597e8facb80ae7d4e26d98\n81aa6f61d645fc0e\nOutput = 7c6557b276a137922a0bcfc2aa2b35dd78322bd500235eb6d6b6f91bc5b\n56a52de2d65612d503236b321f5d0bebcbc52b64b92e426f29c9b8b69f52de98ae50\n7",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1.3.3. Test Vector 3, Batch Size 2",
      "section_title": true,
      "ja": "A.1.3.3. テストベクトル3、バッチサイズ2"
    },
    {
      "indent": 3,
      "text": "Input = 00,5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nInfo = 7465737420696e666f\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec4c1f\n6706,222a5e897cf59db8145db8d16e597e8facb80ae7d4e26d9881aa6f61d645fc0\ne\nBlindedElement = c8713aa89241d6989ac142f22dba30596db635c772cbf25021f\ndd8f3d461f715,423a01c072e06eb1cce96d23acce06e1ea64a609d7ec9e9023f304\n9f2d64e50c\nEvaluationElement = 1a4b860d808ff19624731e67b5eff20ceb2df3c3c03b906f\n5693e2078450d874,aa1f16e903841036e38075da8a46655c94fc92341887eb5819f\n46312adfc0504\nProof = 43fdb53be399cbd3561186ae480320caa2b9f36cca0e5b160c4a677b8bbf\n4301b28f12c36aa8e11e5a7ef551da0781e863a6dc8c0b2bf5a149c9e00621f02006\nProofRandomScalar = 419c4f4f5052c53c45f3da494d2b67b220d02118e0857cdb\ncf037f9ea84bbe0c\nOutput = ca688351e88afb1d841fde4401c79efebb2eb75e7998fa9737bd5a82a15\n2406d38bd29f680504e54fd4587eddcf2f37a2617ac2fbd2993f7bdf45442ace7d22\n1,7c6557b276a137922a0bcfc2aa2b35dd78322bd500235eb6d6b6f91bc5b56a52de\n2d65612d503236b321f5d0bebcbc52b64b92e426f29c9b8b69f52de98ae507",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2. decaf448-SHAKE256",
      "section_title": true,
      "ja": "A.2. decaf448-shake256"
    },
    {
      "indent": 0,
      "text": "A.2.1. OPRF Mode",
      "section_title": true,
      "ja": "A.2.1. OPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = e8b1375371fd11ebeb224f832dcc16d371b4188951c438f751425699ed29e\ncc80c6c13e558ccd67634fd82eac94aa8d1f0d7fee990695d1e",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2.1.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.2.1.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec65fa\n3833a26e9388336361686ff1f83df55046504dfecad8549ba112\nBlindedElement = e0ae01c4095f08e03b19baf47ffdc19cb7d98e583160522a3c7\nd6a0b2111cd93a126a46b7b41b730cd7fc943d4e28e590ed33ae475885f6c\nEvaluationElement = 50ce4e60eed006e22e7027454b5a4b8319eb2bc8ced609eb\n19eb3ad42fb19e06ba12d382cbe7ae342a0cad6ead0ef8f91f00bb7f0cd9c0a2\nOutput = 37d3f7922d9388a15b561de5829bbf654c4089ede89c0ce0f3f85bcdba0\n9e382ce0ab3507e021f9e79706a1798ffeac68ebd5cf62e5eb9838c7068351d97ae3\n7",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2.1.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.2.1.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec65fa\n3833a26e9388336361686ff1f83df55046504dfecad8549ba112\nBlindedElement = 86a88dc5c6331ecfcb1d9aacb50a68213803c462e377577cacc\n00af28e15f0ddbc2e3d716f2f39ef95f3ec1314a2c64d940a9f295d8f13bb\nEvaluationElement = 162e9fa6e9d527c3cd734a31bf122a34dbd5bcb7bb23651f\n1768a7a9274cc116c03b58afa6f0dede3994a60066c76370e7328e7062fd5819\nOutput = a2a652290055cb0f6f8637a249ee45e32ef4667db0b4c80c0a70d2a6416\n4d01525cfdad5d870a694ec77972b9b6ec5d2596a5223e5336913f945101f0137f55\ne",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2.2. VOPRF Mode",
      "section_title": true,
      "ja": "A.2.2. VOPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = e3c01519a076a326a0eb566343e9b21c115fa18e6e85577ddbe890b33104f\ncc2835ddfb14a928dc3f5d79b936e17c76b99e0bf6a1680930e\npkSm = 945fc518c47695cf65217ace04b86ac5e4cbe26ca649d52854bb16c494ce0\n9069d6add96b20d4b0ae311a87c9a73e3a146b525763ab2f955",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2.2.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.2.2.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec65fa\n3833a26e9388336361686ff1f83df55046504dfecad8549ba112\nBlindedElement = 7261bbc335c664ba788f1b1a1a4cd5190cc30e787ef277665ac\n1d314f8861e3ec11854ce3ddd42035d9e0f5cddde324c332d8c880abc00eb\nEvaluationElement = ca1491a526c28d880806cf0fb0122222392cf495657be6e4\nc9d203bceffa46c86406caf8217859d3fb259077af68e5d41b3699410781f467\nProof = f84bbeee47aedf43558dae4b95b3853635a9fc1a9ea7eac9b454c64c66c4\nf49cd1c72711c7ac2e06c681e16ea693d5500bbd7b56455df52f69e00b76b4126961\ne1562fdbaaac40b7701065cbeece3febbfe09e00160f81775d36daed99d8a2a10be0\n759e01b7ee81217203416c9db208\nProofRandomScalar = b1b748135d405ce48c6973401d9455bb8ccd18b01d0295c0\n627f67661200dbf9569f73fbb3925daa043a070e5f953d80bb464ea369e5522b\nOutput = e2ac40b634f36cccd8262b285adff7c9dcc19cd308564a5f4e581d1a853\n5773b86fa4fc9f2203c370763695c5093aea4a7aedec4488b1340ba3bf663a23098c\n1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2.2.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.2.2.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec65fa\n3833a26e9388336361686ff1f83df55046504dfecad8549ba112\nBlindedElement = 88287e553939090b888ddc15913e1807dc4757215555e1c3a79\n488ef311594729c7fa74c772a732b78440b7d66d0aa35f3bb316f1d93e1b2\nEvaluationElement = c00978c73e8e4ee1d447ab0d3ad1754055e72cc85c08e3a0\ndb170909a9c61cbff1f1e7015f289e3038b0f341faea5d7780c130106065c231\nProof = 7a2831a6b237e11ac1657d440df93bc5ce00f552e6020a99d5c956ffc4d0\n7b5ade3e82ecdc257fd53d76239e733e0a1313e84ce16cc0d82734806092a693d7e8\nd3c420c2cb6ccd5d0ca32514fb78e9ad0973ebdcb52eba438fc73948d76339ee7101\n21d83e2fe6f001cfdf551aff9f36\nProofRandomScalar = b1b748135d405ce48c6973401d9455bb8ccd18b01d0295c0\n627f67661200dbf9569f73fbb3925daa043a070e5f953d80bb464ea369e5522b\nOutput = 862952380e07ec840d9f6e6f909c5a25d16c3dacb586d89a181b4aa7380\nc959baa8c480fe8e6c64e089d68ea7aeeb5817bd524d7577905b5bab487690048c94\n1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2.2.3. Test Vector 3, Batch Size 2",
      "section_title": true,
      "ja": "A.2.2.3. テストベクトル3、バッチサイズ2"
    },
    {
      "indent": 3,
      "text": "Input = 00,5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec65fa\n3833a26e9388336361686ff1f83df55046504dfecad8549ba112,b1b748135d405ce\n48c6973401d9455bb8ccd18b01d0295c0627f67661200dbf9569f73fbb3925daa043\na070e5f953d80bb464ea369e5522b\nBlindedElement = 7261bbc335c664ba788f1b1a1a4cd5190cc30e787ef277665ac\n1d314f8861e3ec11854ce3ddd42035d9e0f5cddde324c332d8c880abc00eb,2e15f3\n93c035492a1573627a3606e528c6294c767c8d43b8c691ef70a52cc7dc7d1b53fe45\n8350a270abb7c231b87ba58266f89164f714d9\nEvaluationElement = ca1491a526c28d880806cf0fb0122222392cf495657be6e4\nc9d203bceffa46c86406caf8217859d3fb259077af68e5d41b3699410781f467,8ec\n68e9871b296e81c55647ce64a04fe75d19932f1400544cd601468c60f998408bbb54\n6601d4a636e8be279e558d70b95c8d4a4f61892be\nProof = 167d922f0a6ffa845eed07f8aa97b6ac746d902ecbeb18f49c009adc0521\neab1e4d275b74a2dc266b7a194c854e85e7eb54a9a36376dfc04ec7f3bd55fc9618c\n3970cb548e064f8a2f06183a5702933dbc3e4c25a73438f2108ee1981c306181003c\n7ea92fce963ec7b4ba4f270e6d38\nProofRandomScalar = 63798726803c9451ba405f00ef3acb633ddf0c420574a2ec\n6cbf28f840800e355c9fbaac10699686de2724ed22e797a00f3bd93d105a7f23\nOutput = e2ac40b634f36cccd8262b285adff7c9dcc19cd308564a5f4e581d1a853\n5773b86fa4fc9f2203c370763695c5093aea4a7aedec4488b1340ba3bf663a23098c\n1,862952380e07ec840d9f6e6f909c5a25d16c3dacb586d89a181b4aa7380c959baa\n8c480fe8e6c64e089d68ea7aeeb5817bd524d7577905b5bab487690048c941",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2.3. POPRF Mode",
      "section_title": true,
      "ja": "A.2.3. POPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = 792a10dcbd3ba4a52a054f6f39186623208695301e7adb9634b74709ab22d\ne402990eb143fd7c67ac66be75e0609705ecea800992aac8e19\npkSm = 6c9d12723a5bbcf305522cc04b4a34d9ced2e12831826018ea7b5dcf54526\n47ad262113059bf0f6e4354319951b9d513c74f29cb0eec38c1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2.3.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.2.3.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nInfo = 7465737420696e666f\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec65fa\n3833a26e9388336361686ff1f83df55046504dfecad8549ba112\nBlindedElement = 161183c13c6cb33b0e4f9b7365f8c5c12d13c72f8b62d276ca0\n9368d093dce9b42198276b9e9d870ac392dda53efd28d1b7e6e8c060cdc42\nEvaluationElement = 06ec89dfde25bb2a6f0145ac84b91ac277b35de39ad1d6f4\n02a8e46414952ce0d9ea1311a4ece283e2b01558c7078b040cfaa40dd63b3e6c\nProof = 66caee75bf2460429f620f6ad3e811d524cb8ddd848a435fc5d89af48877\nabf6506ee341a0b6f67c2d76cd021e5f3d1c9abe5aa9f0dce016da746135fedba2af\n41ed1d01659bfd6180d96bc1b7f320c0cb6926011ce392ecca748662564892bae665\n16acaac6ca39aadf6fcca95af406\nProofRandomScalar = b1b748135d405ce48c6973401d9455bb8ccd18b01d0295c0\n627f67661200dbf9569f73fbb3925daa043a070e5f953d80bb464ea369e5522b\nOutput = 4423f6dcc1740688ea201de57d76824d59cd6b859e1f9884b7eebc49b0b\n971358cf9cb075df1536a8ea31bcf55c3e31c2ba9cfa8efe54448d17091daeb9924e\nd",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2.3.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.2.3.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nInfo = 7465737420696e666f\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec65fa\n3833a26e9388336361686ff1f83df55046504dfecad8549ba112\nBlindedElement = 12082b6a381c6c51e85d00f2a3d828cdeab3f5cb19a10b9c014\nc33826764ab7e7cfb8b4ff6f411bddb2d64e62a472af1cd816e5b712790c6\nEvaluationElement = f2919b7eedc05ab807c221fce2b12c4ae9e19e6909c47845\n64b690d1972d2994ca623f273afc67444d84ea40cbc58fcdab7945f321a52848\nProof = a295677c54d1bc4286330907fc2490a7de163da26f9ce03a462a452fea42\n2b19ade296ba031359b3b6841e48455d20519ad01b4ac4f0b92e76d3cf16fbef0a3f\n72791a8401ef2d7081d361e502e96b2c60608b9fa566f43d4611c2f161d83aabef7f\n8017332b26ed1daaf80440772022\nProofRandomScalar = b1b748135d405ce48c6973401d9455bb8ccd18b01d0295c0\n627f67661200dbf9569f73fbb3925daa043a070e5f953d80bb464ea369e5522b\nOutput = 8691905500510843902c44bdd9730ab9dc3925aa58ff9dd42765a2baf63\n3126de0c3adb93bef5652f38e5827b6396e87643960163a560fc4ac9738c8de4e4a8\nd",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2.3.3. Test Vector 3, Batch Size 2",
      "section_title": true,
      "ja": "A.2.3.3. テストベクトル3、バッチサイズ2"
    },
    {
      "indent": 3,
      "text": "Input = 00,5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nInfo = 7465737420696e666f\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec65fa\n3833a26e9388336361686ff1f83df55046504dfecad8549ba112,b1b748135d405ce\n48c6973401d9455bb8ccd18b01d0295c0627f67661200dbf9569f73fbb3925daa043\na070e5f953d80bb464ea369e5522b\nBlindedElement = 161183c13c6cb33b0e4f9b7365f8c5c12d13c72f8b62d276ca0\n9368d093dce9b42198276b9e9d870ac392dda53efd28d1b7e6e8c060cdc42,fc8847\nd43fb4cea4e408f585661a8f2867533fa91d22155d3127a22f18d3b007add480f7d3\n00bca93fa47fe87ae06a57b7d0f0d4c30b12f0\nEvaluationElement = 06ec89dfde25bb2a6f0145ac84b91ac277b35de39ad1d6f4\n02a8e46414952ce0d9ea1311a4ece283e2b01558c7078b040cfaa40dd63b3e6c,2e7\n4c626d07de49b1c8c21d87120fd78105f485e36816af9bde3e3efbeef76815326062\nfd333925b66c5ce5a20f100bf01770c16609f990a\nProof = fd94db736f97ea4efe9d0d4ad2933072697a6bbeb32834057b23edf7c700\n9f011dfa72157f05d2a507c2bbf0b54cad99ab99de05921c021fda7d70e65bcecdb0\n5f9a30154127ace983c74d10fd910b554c5e95f6bd1565fd1f3dbbe3c523ece5c72d\n57a559b7be1368c4786db4a3c910\nProofRandomScalar = 63798726803c9451ba405f00ef3acb633ddf0c420574a2ec\n6cbf28f840800e355c9fbaac10699686de2724ed22e797a00f3bd93d105a7f23\nOutput = 4423f6dcc1740688ea201de57d76824d59cd6b859e1f9884b7eebc49b0b\n971358cf9cb075df1536a8ea31bcf55c3e31c2ba9cfa8efe54448d17091daeb9924e\nd,8691905500510843902c44bdd9730ab9dc3925aa58ff9dd42765a2baf633126de0\nc3adb93bef5652f38e5827b6396e87643960163a560fc4ac9738c8de4e4a8d",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3. P256-SHA256",
      "section_title": true,
      "ja": "A.3. P256-SHA256"
    },
    {
      "indent": 0,
      "text": "A.3.1. OPRF Mode",
      "section_title": true,
      "ja": "A.3.1. OPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = 159749d750713afe245d2d39ccfaae8381c53ce92d098a9375ee70739c7ac\n0bf",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3.1.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.3.1.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nBlind = 3338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 03723a1e5c09b8b9c18d1dcbca29e8007e95f14f4732d9346d4\n90ffc195110368d\nEvaluationElement = 030de02ffec47a1fd53efcdd1c6faf5bdc270912b8749e78\n3c7ca75bb412958832\nOutput = a0b34de5fa4c5b6da07e72af73cc507cceeb48981b97b7285fc375345fe\n495dd",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3.1.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.3.1.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 3338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 03cc1df781f1c2240a64d1c297b3f3d16262ef5d4cf10273488\n2675c26231b0838\nEvaluationElement = 03a0395fe3828f2476ffcd1f4fe540e5a8489322d398be3c\n4e5a869db7fcb7c52c\nOutput = c748ca6dd327f0ce85f4ae3a8cd6d4d5390bbb804c9e12dcf94f853fece\n3dcce",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3.2. VOPRF Mode",
      "section_title": true,
      "ja": "A.3.2. VOPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = ca5d94c8807817669a51b196c34c1b7f8442fde4334a7121ae4736364312f\nca6\npkSm = 03e17e70604bcabe198882c0a1f27a92441e774224ed9c702e51dd17038b1\n02462",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3.2.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.3.2.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nBlind = 3338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 02dd05901038bb31a6fae01828fd8d0e49e35a486b5c5d4b499\n4013648c01277da\nEvaluationElement = 0209f33cab60cf8fe69239b0afbcfcd261af4c1c5632624f\n2e9ba29b90ae83e4a2\nProof = e7c2b3c5c954c035949f1f74e6bce2ed539a3be267d1481e9ddb178533df\n4c2664f69d065c604a4fd953e100b856ad83804eb3845189babfa5a702090d6fc5fa\nProofRandomScalar = f9db001266677f62c095021db018cd8cbb55941d4073698c\ne45c405d1348b7b1\nOutput = 0412e8f78b02c415ab3a288e228978376f99927767ff37c5718d420010a\n645a1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3.2.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.3.2.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 3338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 03cd0f033e791c4d79dfa9c6ed750f2ac009ec46cd4195ca6fd\n3800d1e9b887dbd\nEvaluationElement = 030d2985865c693bf7af47ba4d3a3813176576383d19aff0\n03ef7b0784a0d83cf1\nProof = 2787d729c57e3d9512d3aa9e8708ad226bc48e0f1750b0767aaff73482c4\n4b8d2873d74ec88aebd3504961acea16790a05c542d9fbff4fe269a77510db00abab\nProofRandomScalar = f9db001266677f62c095021db018cd8cbb55941d4073698c\ne45c405d1348b7b1\nOutput = 771e10dcd6bcd3664e23b8f2a710cfaaa8357747c4a8cbba03133967b5c\n24f18",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3.2.3. Test Vector 3, Batch Size 2",
      "section_title": true,
      "ja": "A.3.2.3. テストベクトル3、バッチサイズ2"
    },
    {
      "indent": 3,
      "text": "Input = 00,5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 3338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364,f9db001266677f62c095021db018cd8cbb55941d4073698ce45c405d1348b7b\n1\nBlindedElement = 02dd05901038bb31a6fae01828fd8d0e49e35a486b5c5d4b499\n4013648c01277da,03462e9ae64cae5b83ba98a6b360d942266389ac369b923eb3d5\n57213b1922f8ab\nEvaluationElement = 0209f33cab60cf8fe69239b0afbcfcd261af4c1c5632624f\n2e9ba29b90ae83e4a2,02bb24f4d838414aef052a8f044a6771230ca69c0a5677540\nfff738dd31bb69771\nProof = bdcc351707d02a72ce49511c7db990566d29d6153ad6f8982fad2b435d6c\ne4d60da1e6b3fa740811bde34dd4fe0aa1b5fe6600d0440c9ddee95ea7fad7a60cf2\nProofRandomScalar = 350e8040f828bf6ceca27405420cdf3d63cb3aef005f40ba\n51943c8026877963\nOutput = 0412e8f78b02c415ab3a288e228978376f99927767ff37c5718d420010a\n645a1,771e10dcd6bcd3664e23b8f2a710cfaaa8357747c4a8cbba03133967b5c24f\n18",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3.3. POPRF Mode",
      "section_title": true,
      "ja": "A.3.3. POPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = 6ad2173efa689ef2c27772566ad7ff6e2d59b3b196f00219451fb2c89ee4d\nae2\npkSm = 030d7ff077fddeec965db14b794f0cc1ba9019b04a2f4fcc1fa525dedf72e\n2a3e3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3.3.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.3.3.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nInfo = 7465737420696e666f\nBlind = 3338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 031563e127099a8f61ed51eeede05d747a8da2be329b40ba1f0\ndb0b2bd9dd4e2c0\nEvaluationElement = 02c5e5300c2d9e6ba7f3f4ad60500ad93a0157e6288eb04b\n67e125db024a2c74d2\nProof = f8a33690b87736c854eadfcaab58a59b8d9c03b569110b6f31f8bf7577f3\nfbb85a8a0c38468ccde1ba942be501654adb106167c8eb178703ccb42bccffb9231a\nProofRandomScalar = f9db001266677f62c095021db018cd8cbb55941d4073698c\ne45c405d1348b7b1\nOutput = 193a92520bd8fd1f37accb918040a57108daa110dc4f659abe212636d24\n5c592",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3.3.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.3.3.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nInfo = 7465737420696e666f\nBlind = 3338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 021a440ace8ca667f261c10ac7686adc66a12be31e3520fca31\n7643a1eee9dcd4d\nEvaluationElement = 0208ca109cbae44f4774fc0bdd2783efdcb868cb4523d521\n96f700210e777c5de3\nProof = 043a8fb7fc7fd31e35770cabda4753c5bf0ecc1e88c68d7d35a62bf2631e\n875af4613641be2d1875c31d1319d191c4bbc0d04875f4fd03c31d3d17dd8e069b69\nProofRandomScalar = f9db001266677f62c095021db018cd8cbb55941d4073698c\ne45c405d1348b7b1\nOutput = 1e6d164cfd835d88a31401623549bf6b9b306628ef03a7962921d62bc5f\nfce8c",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3.3.3. Test Vector 3, Batch Size 2",
      "section_title": true,
      "ja": "A.3.3.3. テストベクトル3、バッチサイズ2"
    },
    {
      "indent": 3,
      "text": "Input = 00,5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nInfo = 7465737420696e666f\nBlind = 3338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364,f9db001266677f62c095021db018cd8cbb55941d4073698ce45c405d1348b7b\n1\nBlindedElement = 031563e127099a8f61ed51eeede05d747a8da2be329b40ba1f0\ndb0b2bd9dd4e2c0,03ca4ff41c12fadd7a0bc92cf856732b21df652e01a3abdf0fa8\n847da053db213c\nEvaluationElement = 02c5e5300c2d9e6ba7f3f4ad60500ad93a0157e6288eb04b\n67e125db024a2c74d2,02f0b6bcd467343a8d8555a99dc2eed0215c71898c5edb77a\n3d97ddd0dbad478e8\nProof = 8fbd85a32c13aba79db4b42e762c00687d6dbf9c8cb97b2a225645ccb00d\n9d7580b383c885cdfd07df448d55e06f50f6173405eee5506c0ed0851ff718d13e68\nProofRandomScalar = 350e8040f828bf6ceca27405420cdf3d63cb3aef005f40ba\n51943c8026877963\nOutput = 193a92520bd8fd1f37accb918040a57108daa110dc4f659abe212636d24\n5c592,1e6d164cfd835d88a31401623549bf6b9b306628ef03a7962921d62bc5ffce\n8c",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4. P384-SHA384",
      "section_title": true,
      "ja": "A.4. P384-SHA384"
    },
    {
      "indent": 0,
      "text": "A.4.1. OPRF Mode",
      "section_title": true,
      "ja": "A.4.1. OPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = dfe7ddc41a4646901184f2b432616c8ba6d452f9bcd0c4f75a5150ef2b2ed\n02ef40b8b92f60ae591bcabd72a6518f188",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.1.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.4.1.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nBlind = 504650f53df8f16f6861633388936ea23338fa65ec36e0290022b48eb562\n889d89dbfa691d1cde91517fa222ed7ad364\nBlindedElement = 02a36bc90e6db34096346eaf8b7bc40ee1113582155ad379700\n3ce614c835a874343701d3f2debbd80d97cbe45de6e5f1f\nEvaluationElement = 03af2a4fc94770d7a7bf3187ca9cc4faf3732049eded2442\nee50fbddda58b70ae2999366f72498cdbc43e6f2fc184afe30\nOutput = ed84ad3f31a552f0456e58935fcc0a3039db42e7f356dcb32aa6d487b6b\n815a07d5813641fb1398c03ddab5763874357",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.1.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.4.1.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 504650f53df8f16f6861633388936ea23338fa65ec36e0290022b48eb562\n889d89dbfa691d1cde91517fa222ed7ad364\nBlindedElement = 02def6f418e3484f67a124a2ce1bfb19de7a4af568ede6a1ebb\n2733882510ddd43d05f2b1ab5187936a55e50a847a8b900\nEvaluationElement = 034e9b9a2960b536f2ef47d8608b21597ba400d5abfa1825\nfd21c36b75f927f396bf3716c96129d1fa4a77fa1d479c8d7b\nOutput = dd4f29da869ab9355d60617b60da0991e22aaab243a3460601e48b07585\n9d1c526d36597326f1b985778f781a1682e75",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.2. VOPRF Mode",
      "section_title": true,
      "ja": "A.4.2. VOPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = 051646b9e6e7a71ae27c1e1d0b87b4381db6d3595eeeb1adb41579adbf992\nf4278f9016eafc944edaa2b43183581779d\npkSm = 031d689686c611991b55f1a1d8f4305ccd6cb719446f660a30db61b7aa87b\n46acf59b7c0d4a9077b3da21c25dd482229a0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.2.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.4.2.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nBlind = 504650f53df8f16f6861633388936ea23338fa65ec36e0290022b48eb562\n889d89dbfa691d1cde91517fa222ed7ad364\nBlindedElement = 02d338c05cbecb82de13d6700f09cb61190543a7b7e2c6cd4fc\na56887e564ea82653b27fdad383995ea6d02cf26d0e24d9\nEvaluationElement = 02a7bba589b3e8672aa19e8fd258de2e6aae20101c8d7612\n46de97a6b5ee9cf105febce4327a326255a3c604f63f600ef6\nProof = bfc6cf3859127f5fe25548859856d6b7fa1c7459f0ba5712a806fc091a30\n00c42d8ba34ff45f32a52e40533efd2a03bc87f3bf4f9f58028297ccb9ccb18ae718\n2bcd1ef239df77e3be65ef147f3acf8bc9cbfc5524b702263414f043e3b7ca2e\nProofRandomScalar = 803d955f0e073a04aa5d92b3fb739f56f9db001266677f62\nc095021db018cd8cbb55941d4073698ce45c405d1348b7b1\nOutput = 3333230886b562ffb8329a8be08fea8025755372817ec969d114d1203d0\n26b4a622beab60220bf19078bca35a529b35c",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.2.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.4.2.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 504650f53df8f16f6861633388936ea23338fa65ec36e0290022b48eb562\n889d89dbfa691d1cde91517fa222ed7ad364\nBlindedElement = 02f27469e059886f221be5f2cca03d2bdc61e55221721c3b3e5\n6fc012e36d31ae5f8dc058109591556a6dbd3a8c69c433b\nEvaluationElement = 03f16f903947035400e96b7f531a38d4a07ac89a80f89d86\na1bf089c525a92c7f4733729ca30c56ce78b1ab4f7d92db8b4\nProof = d005d6daaad7571414c1e0c75f7e57f2113ca9f4604e84bc90f9be52da89\n6fff3bee496dcde2a578ae9df315032585f801fb21c6080ac05672b291e575a40295\nb306d967717b28e08fcc8ad1cab47845d16af73b3e643ddcc191208e71c64630\nProofRandomScalar = 803d955f0e073a04aa5d92b3fb739f56f9db001266677f62\nc095021db018cd8cbb55941d4073698ce45c405d1348b7b1\nOutput = b91c70ea3d4d62ba922eb8a7d03809a441e1c3c7af915cbc2226f485213\ne895942cd0f8580e6d99f82221e66c40d274f",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.2.3. Test Vector 3, Batch Size 2",
      "section_title": true,
      "ja": "A.4.2.3. テストベクトル3、バッチサイズ2"
    },
    {
      "indent": 3,
      "text": "Input = 00,5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 504650f53df8f16f6861633388936ea23338fa65ec36e0290022b48eb562\n889d89dbfa691d1cde91517fa222ed7ad364,803d955f0e073a04aa5d92b3fb739f5\n6f9db001266677f62c095021db018cd8cbb55941d4073698ce45c405d1348b7b1\nBlindedElement = 02d338c05cbecb82de13d6700f09cb61190543a7b7e2c6cd4fc\na56887e564ea82653b27fdad383995ea6d02cf26d0e24d9,02fa02470d7f151018b4\n1e82223c32fad824de6ad4b5ce9f8e9f98083c9a726de9a1fc39d7a0cb6f4f188dd9\ncea01474cd\nEvaluationElement = 02a7bba589b3e8672aa19e8fd258de2e6aae20101c8d7612\n46de97a6b5ee9cf105febce4327a326255a3c604f63f600ef6,028e9e115625ff4c2\nf07bf87ce3fd73fc77994a7a0c1df03d2a630a3d845930e2e63a165b114d98fe34e6\n1b68d23c0b50a\nProof = 6d8dcbd2fc95550a02211fb78afd013933f307d21e7d855b0b1ed0af7807\n6d8137ad8b0a1bfa05676d325249c1dbb9a52bd81b1c2b7b0efc77cf7b278e1c947f\n6283f1d4c513053fc0ad19e026fb0c30654b53d9cea4b87b037271b5d2e2d0ea\nProofRandomScalar = a097e722ed2427de86966910acba9f5c350e8040f828bf6c\neca27405420cdf3d63cb3aef005f40ba51943c8026877963\nOutput = 3333230886b562ffb8329a8be08fea8025755372817ec969d114d1203d0\n26b4a622beab60220bf19078bca35a529b35c,b91c70ea3d4d62ba922eb8a7d03809\na441e1c3c7af915cbc2226f485213e895942cd0f8580e6d99f82221e66c40d274f",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.3. POPRF Mode",
      "section_title": true,
      "ja": "A.4.3. POPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = 5b2690d6954b8fbb159f19935d64133f12770c00b68422559c65431942d72\n1ff79d47d7a75906c30b7818ec0f38b7fb2\npkSm = 02f00f0f1de81e5d6cf18140d4926ffdc9b1898c48dc49657ae36eb1e45de\nb8b951aaf1f10c82d2eaa6d02aafa3f10d2b6",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.3.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.4.3.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nInfo = 7465737420696e666f\nBlind = 504650f53df8f16f6861633388936ea23338fa65ec36e0290022b48eb562\n889d89dbfa691d1cde91517fa222ed7ad364\nBlindedElement = 03859b36b95e6564faa85cd3801175eda2949707f6aa0640ad0\n93cbf8ad2f58e762f08b56b2a1b42a64953aaf49cbf1ae3\nEvaluationElement = 0220710e2e00306453f5b4f574cb6a512453f35c45080d09\n373e190c19ce5b185914fbf36582d7e0754bb7c8b683205b91\nProof = 82a17ef41c8b57f1e3122311b4d5cd39a63df0f67443ef18d961f9b659c1\n601ced8d3c64b294f604319ca80230380d437a49c7af0d620e22116669c008ebb767\nd90283d573b49cdb49e3725889620924c2c4b047a2a6225a3ba27e640ebddd33\nProofRandomScalar = 803d955f0e073a04aa5d92b3fb739f56f9db001266677f62\nc095021db018cd8cbb55941d4073698ce45c405d1348b7b1\nOutput = 0188653cfec38119a6c7dd7948b0f0720460b4310e40824e048bf82a165\n27303ed449a08caf84272c3bbc972ede797df",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.3.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.4.3.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nInfo = 7465737420696e666f\nBlind = 504650f53df8f16f6861633388936ea23338fa65ec36e0290022b48eb562\n889d89dbfa691d1cde91517fa222ed7ad364\nBlindedElement = 03f7efcb4aaf000263369d8a0621cb96b81b3206e99876de2a0\n0699ed4c45acf3969cd6e2319215395955d3f8d8cc1c712\nEvaluationElement = 034993c818369927e74b77c400376fd1ae29b6ac6c6ddb77\n6cf10e4fbc487826531b3cf0b7c8ca4d92c7af90c9def85ce6\nProof = 693471b5dff0cd6a5c00ea34d7bf127b2795164e3bdb5f39a1e5edfbd13e\n443bc516061cd5b8449a473c2ceeccada9f3e5b57302e3d7bc5e28d38d6e3a3056e1\ne73b6cc030f5180f8a1ffa45aa923ee66d2ad0a07b500f2acc7fb99b5506465c\nProofRandomScalar = 803d955f0e073a04aa5d92b3fb739f56f9db001266677f62\nc095021db018cd8cbb55941d4073698ce45c405d1348b7b1\nOutput = ff2a527a21cc43b251a567382677f078c6e356336aec069dea8ba369953\n43ca3b33bb5d6cf15be4d31a7e6d75b30d3f5",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.3.3. Test Vector 3, Batch Size 2",
      "section_title": true,
      "ja": "A.4.3.3. テストベクトル3、バッチサイズ2"
    },
    {
      "indent": 3,
      "text": "Input = 00,5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nInfo = 7465737420696e666f\nBlind = 504650f53df8f16f6861633388936ea23338fa65ec36e0290022b48eb562\n889d89dbfa691d1cde91517fa222ed7ad364,803d955f0e073a04aa5d92b3fb739f5\n6f9db001266677f62c095021db018cd8cbb55941d4073698ce45c405d1348b7b1\nBlindedElement = 03859b36b95e6564faa85cd3801175eda2949707f6aa0640ad0\n93cbf8ad2f58e762f08b56b2a1b42a64953aaf49cbf1ae3,021a65d618d645f1a20b\nc33b06deaa7e73d6d634c8a56a3d02b53a732b69a5c53c5a207ea33d5afdcde9a22d\n59726bce51\nEvaluationElement = 0220710e2e00306453f5b4f574cb6a512453f35c45080d09\n373e190c19ce5b185914fbf36582d7e0754bb7c8b683205b91,02017657b315ec65e\nf861505e596c8645d94685dd7602cdd092a8f1c1c0194a5d0485fe47d071d972ab51\n4370174cc23f5\nProof = 4a0b2fe96d5b2a046a0447fe079b77859ef11a39a3520d6ff7c626aad9b4\n73b724fb0cf188974ec961710a62162a83e97e0baa9eeada73397032d928b3e97b1e\na92ad9458208302be3681b8ba78bcc17745bac00f84e0fdc98a6a8cba009c080\nProofRandomScalar = a097e722ed2427de86966910acba9f5c350e8040f828bf6c\neca27405420cdf3d63cb3aef005f40ba51943c8026877963\nOutput = 0188653cfec38119a6c7dd7948b0f0720460b4310e40824e048bf82a165\n27303ed449a08caf84272c3bbc972ede797df,ff2a527a21cc43b251a567382677f0\n78c6e356336aec069dea8ba36995343ca3b33bb5d6cf15be4d31a7e6d75b30d3f5",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5. P521-SHA512",
      "section_title": true,
      "ja": "A.5. P521-SHA512"
    },
    {
      "indent": 0,
      "text": "A.5.1. OPRF Mode",
      "section_title": true,
      "ja": "A.5.1. OPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = 0153441b8faedb0340439036d6aed06d1217b34c42f17f8db4c5cc610a4a9\n55d698a688831b16d0dc7713a1aa3611ec60703bffc7dc9c84e3ed673b3dbe1d5fcc\nea6",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.1.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.5.1.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nBlind = 00d1dccf7a51bafaf75d4a866d53d8cafe4d504650f53df8f16f68616333\n88936ea23338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 0300e78bf846b0e1e1a3c320e353d758583cd876df56100a3a1\ne62bacba470fa6e0991be1be80b721c50c5fd0c672ba764457acc18c6200704e9294\nfbf28859d916351\nEvaluationElement = 030166371cf827cb2fb9b581f97907121a16e2dc5d8b10ce\n9f0ede7f7d76a0d047657735e8ad07bcda824907b3e5479bd72cdef6b839b967ba5c\n58b118b84d26f2ba07\nOutput = 26232de6fff83f812adadadb6cc05d7bbeee5dca043dbb16b03488abb99\n81d0a1ef4351fad52dbd7e759649af393348f7b9717566c19a6b8856284d69375c80\n9",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.1.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.5.1.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 00d1dccf7a51bafaf75d4a866d53d8cafe4d504650f53df8f16f68616333\n88936ea23338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 0300c28e57e74361d87e0c1874e5f7cc1cc796d61f9cad50427\ncf54655cdb455613368d42b27f94bf66f59f53c816db3e95e68e1b113443d66a99b3\n693bab88afb556b\nEvaluationElement = 0301ad453607e12d0cc11a3359332a40c3a254eaa1afc642\n96528d55bed07ba322e72e22cf3bcb50570fd913cb54f7f09c17aff8787af75f6a7f\naf5640cbb2d9620a6e\nOutput = ad1f76ef939042175e007738906ac0336bbd1d51e287ebaa66901abdd32\n4ea3ffa40bfc5a68e7939c2845e0fd37a5a6e76dadb9907c6cc8579629757fd4d04b\na",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.2. VOPRF Mode",
      "section_title": true,
      "ja": "A.5.2. VOPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = 015c7fc1b4a0b1390925bae915bd9f3d72009d44d9241b962428aad5d13f2\n2803311e7102632a39addc61ea440810222715c9d2f61f03ea424ec9ab1fe5e31cf9\n238\npkSm = 0301505d646f6e4c9102451eb39730c4ba1c4087618641edbdba4a60896b0\n7fd0c9414ce553cbf25b81dfcca50a8f6724ab7a2bc4d0cf736967a287bb6084cc06\n78ac0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.2.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.5.2.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nBlind = 00d1dccf7a51bafaf75d4a866d53d8cafe4d504650f53df8f16f68616333\n88936ea23338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 0301d6e4fb545e043ddb6aee5d5ceeee1b44102615ab04430c2\n7dd0f56988dedcb1df32ef384f160e0e76e718605f14f3f582f9357553d153b99679\n5b4b3628a4f6380\nEvaluationElement = 03013fdeaf887f3d3d283a79e696a54b66ff0edcb559265e\n204a958acf840e0930cc147e2a6835148d8199eebc26c03e9394c9762a1c991dde40\nbca0f8ca003eefb045\nProof = 0077fcc8ec6d059d7759b0a61f871e7c1dadc65333502e09a51994328f79\ne5bda3357b9a4f410a1760a3612c2f8f27cb7cb032951c047cc66da60da583df7b24\n7edd0188e5eb99c71799af1d80d643af16ffa1545acd9e9233fbb370455b10eb257e\na12a1667c1b4ee5b0ab7c93d50ae89602006960f083ca9adc4f6276c0ad60440393c\nProofRandomScalar = 015e80ae32363b32cb76ad4b95a5a34e46bb803d955f0e07\n3a04aa5d92b3fb739f56f9db001266677f62c095021db018cd8cbb55941d4073698c\ne45c405d1348b7b1\nOutput = 5e003d9b2fb540b3d4bab5fedd154912246da1ee5e557afd8f56415faa1\na0fadff6517da802ee254437e4f60907b4cda146e7ba19e249eef7be405549f62954\nb",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.2.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.5.2.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 00d1dccf7a51bafaf75d4a866d53d8cafe4d504650f53df8f16f68616333\n88936ea23338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 03005b05e656cb609ce5ff5faf063bb746d662d67bbd07c0626\n38396f52f0392180cf2365cabb0ece8e19048961d35eeae5d5fa872328dce98df076\nee154dd191c615e\nEvaluationElement = 0301b19fcf482b1fff04754e282292ed736c5f0aa080d4f4\n2663cd3a416c6596f03129e8e096d8671fe5b0d19838312c511d2ce08d431e43e3ef\n06199d8cab7426238d\nProof = 01ec9fece444caa6a57032e8963df0e945286f88fbdf233fb5101f0924f7\nea89c47023f5f72f240e61991fd33a299b5b38c45a5e2dd1a67b072e59dfe86708a3\n59c701e38d383c60cf6969463bcf13251bedad47b7941f52e409a3591398e2792441\n0b18a301c0e19f527cad504fa08388050ac634e1b05c5216d337742f2754e1fc502f\nProofRandomScalar = 015e80ae32363b32cb76ad4b95a5a34e46bb803d955f0e07\n3a04aa5d92b3fb739f56f9db001266677f62c095021db018cd8cbb55941d4073698c\ne45c405d1348b7b1\nOutput = fa15eebba81ecf40954f7135cb76f69ef22c6bae394d1a4362f9b03066b\n54b6604d39f2e53369ca6762a3d9787e230e832aa85955af40ecb8deebb009a8cf47\n4",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.2.3. Test Vector 3, Batch Size 2",
      "section_title": true,
      "ja": "A.5.2.3. テストベクトル3、バッチサイズ2"
    },
    {
      "indent": 3,
      "text": "Input = 00,5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 00d1dccf7a51bafaf75d4a866d53d8cafe4d504650f53df8f16f68616333\n88936ea23338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364,015e80ae32363b32cb76ad4b95a5a34e46bb803d955f0e073a04aa5d92b3fb7\n39f56f9db001266677f62c095021db018cd8cbb55941d4073698ce45c405d1348b7b\n1\nBlindedElement = 0301d6e4fb545e043ddb6aee5d5ceeee1b44102615ab04430c2\n7dd0f56988dedcb1df32ef384f160e0e76e718605f14f3f582f9357553d153b99679\n5b4b3628a4f6380,0301403b597538b939b450c93586ba275f9711ba07e42364bac1\nd5769c6824a8b55be6f9a536df46d952b11ab2188363b3d6737635d9543d4dba14a6\ne19421b9245bf5\nEvaluationElement = 03013fdeaf887f3d3d283a79e696a54b66ff0edcb559265e\n204a958acf840e0930cc147e2a6835148d8199eebc26c03e9394c9762a1c991dde40\nbca0f8ca003eefb045,03001f96424497e38c46c904978c2fa1636c5c3dd2e634a85\nd8a7265977c5dce1f02c7e6c118479f0751767b91a39cce6561998258591b5d7c1bb\n02445a9e08e4f3e8d\nProof = 00b4d215c8405e57c7a4b53398caf55f1f1623aaeb22408ddb9ea2913090\n9b3f95dbb1ff366e81e86e918f9f2fd8b80dbb344cd498c9499d112905e585417e00\n68c600fe5dea18b389ef6c4cc062935607b8ccbbb9a84fba3143868a3e8a58efa0bf\n6ca642804d09dc06e980f64837811227c4267b217f1099a4e28b0854f4e5ee659796\nProofRandomScalar = 01ec21c7bb69b0734cb48dfd68433dd93b0fa097e722ed24\n27de86966910acba9f5c350e8040f828bf6ceca27405420cdf3d63cb3aef005f40ba\n51943c8026877963\nOutput = 5e003d9b2fb540b3d4bab5fedd154912246da1ee5e557afd8f56415faa1\na0fadff6517da802ee254437e4f60907b4cda146e7ba19e249eef7be405549f62954\nb,fa15eebba81ecf40954f7135cb76f69ef22c6bae394d1a4362f9b03066b54b6604\nd39f2e53369ca6762a3d9787e230e832aa85955af40ecb8deebb009a8cf474",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.3. POPRF Mode",
      "section_title": true,
      "ja": "A.5.3. POPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = 014893130030ce69cf714f536498a02ff6b396888f9bb507985c32928c442\n7d6d39de10ef509aca4240e8569e3a88debc0d392e3361bcd934cb9bdd59e339dff7\nb27\npkSm = 0301de8ceb9ffe9237b1bba87c320ea0bebcfc3447fe6f278065c6c69886d\n692d1126b79b6844f829940ace9b52a5e26882cf7cbc9e57503d4cca3cd834584729\nf812a",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.3.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.5.3.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nInfo = 7465737420696e666f\nBlind = 00d1dccf7a51bafaf75d4a866d53d8cafe4d504650f53df8f16f68616333\n88936ea23338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 020095cff9d7ecf65bdfee4ea92d6e748d60b02de34ad98094f\n82e25d33a8bf50138ccc2cc633556f1a97d7ea9438cbb394df612f041c485a515849\nd5ebb2238f2f0e2\nEvaluationElement = 0301408e9c5be3ffcc1c16e5ae8f8aa68446223b0804b119\n62e856af5a6d1c65ebbb5db7278c21db4e8cc06d89a35b6804fb1738a295b691638a\nf77aa1327253f26d01\nProof = 0106a89a61eee9dd2417d2849a8e2167bc5f56e3aed5a3ff23e22511fa1b\n37a29ed44d1bbfd6907d99cfbc558a56aec709282415a864a281e49dc53792a4a638\na0660034306d64be12a94dcea5a6d664cf76681911c8b9a84d49bf12d4893307ec14\n436bd05f791f82446c0de4be6c582d373627b51886f76c4788256e3da7ec8fa18a86\nProofRandomScalar = 015e80ae32363b32cb76ad4b95a5a34e46bb803d955f0e07\n3a04aa5d92b3fb739f56f9db001266677f62c095021db018cd8cbb55941d4073698c\ne45c405d1348b7b1\nOutput = 808ae5b87662eaaf0b39151dd85991b94c96ef214cb14a68bf5c1439548\n82d330da8953a80eea20788e552bc8bbbfff3100e89f9d6e341197b122c46a208733\nb",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.3.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.5.3.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nInfo = 7465737420696e666f\nBlind = 00d1dccf7a51bafaf75d4a866d53d8cafe4d504650f53df8f16f68616333\n88936ea23338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 030112ea89cf9cf589496189eafc5f9eb13c9f9e170d6ecde7c\n5b940541cb1a9c5cfeec908b67efe16b81ca00d0ce216e34b3d5f46a658d3fd8573d\n671bdb6515ed508\nEvaluationElement = 0200ebc49df1e6fa61f412e6c391e6f074400ecdd2f56c4a\n8c03fe0f91d9b551f40d4b5258fd891952e8c9b28003bcfa365122e54a5714c8949d\n5d202767b31b4bf1f6\nProof = 0082162c71a7765005cae202d4bd14b84dae63c29067e886b82506992bd9\n94a1c3aac0c1c5309222fe1af8287b6443ed6df5c2e0b0991faddd3564c73c7597ae\ncd9a003b1f1e3c65f28e58ab4e767cfb4adbcaf512441645f4c2aed8bf67d132d966\n006d35fa71a34145414bf3572c1de1a46c266a344dd9e22e7fb1e90ffba1caf556d9\nProofRandomScalar = 015e80ae32363b32cb76ad4b95a5a34e46bb803d955f0e07\n3a04aa5d92b3fb739f56f9db001266677f62c095021db018cd8cbb55941d4073698c\ne45c405d1348b7b1\nOutput = 27032e24b1a52a82ab7f4646f3c5df0f070f499db98b9c5df33972bd5af\n5762c3638afae7912a6c1acdb1ae2ab2fa670bd5486c645a0e55412e08d33a4a0d6e\n3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.3.3. Test Vector 3, Batch Size 2",
      "section_title": true,
      "ja": "A.5.3.3. テストベクトル3、バッチサイズ2"
    },
    {
      "indent": 3,
      "text": "Input = 00,5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nInfo = 7465737420696e666f\nBlind = 00d1dccf7a51bafaf75d4a866d53d8cafe4d504650f53df8f16f68616333\n88936ea23338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364,015e80ae32363b32cb76ad4b95a5a34e46bb803d955f0e073a04aa5d92b3fb7\n39f56f9db001266677f62c095021db018cd8cbb55941d4073698ce45c405d1348b7b\n1\nBlindedElement = 020095cff9d7ecf65bdfee4ea92d6e748d60b02de34ad98094f\n82e25d33a8bf50138ccc2cc633556f1a97d7ea9438cbb394df612f041c485a515849\nd5ebb2238f2f0e2,0201a328cf9f3fdeb86b6db242dd4cbb436b3a488b70b72d2fbb\nd1e5f50d7b0878b157d6f278c6a95c488f3ad52d6898a421658a82fe7ceb000b01ae\ndea7967522d525\nEvaluationElement = 0301408e9c5be3ffcc1c16e5ae8f8aa68446223b0804b119\n62e856af5a6d1c65ebbb5db7278c21db4e8cc06d89a35b6804fb1738a295b691638a\nf77aa1327253f26d01,020062ab51ac3aa829e0f5b7ae50688bcf5f63a18a83a6e0d\na538666b8d50c7ea2b4ef31f4ac669302318dbebe46660acdda695da30c22cee7ca2\n1f6984a720504502e\nProof = 00731738844f739bca0cca9d1c8bea204bed4fd00285785738b985763741\nde5cdfa275152d52b6a2fdf7792ef3779f39ba34581e56d62f78ecad5b7f8083f384\n961501cd4b43713253c022692669cf076b1d382ecd8293c1de69ea569737f37a2477\n2ab73517983c1e3db5818754ba1f008076267b8058b6481949ae346cdc17a8455fe2\nProofRandomScalar = 01ec21c7bb69b0734cb48dfd68433dd93b0fa097e722ed24\n27de86966910acba9f5c350e8040f828bf6ceca27405420cdf3d63cb3aef005f40ba\n51943c8026877963\nOutput = 808ae5b87662eaaf0b39151dd85991b94c96ef214cb14a68bf5c1439548\n82d330da8953a80eea20788e552bc8bbbfff3100e89f9d6e341197b122c46a208733\nb,27032e24b1a52a82ab7f4646f3c5df0f070f499db98b9c5df33972bd5af5762c36\n38afae7912a6c1acdb1ae2ab2fa670bd5486c645a0e55412e08d33a4a0d6e3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "section_title": true,
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This document resulted from the work of the Privacy Pass team [PrivacyPass]. The authors would also like to acknowledge helpful conversations with Hugo Krawczyk. Eli-Shaoul Khedouri provided additional review and comments on key consistency. Daniel Bourdrez, Tatiana Bradley, Sofia Celi, Frank Denis, Julia Hesse, Russ Housley, Kevin Lewi, Christopher Patton, and Bas Westerbaan also provided helpful input and contributions to the document.",
      "ja": "このドキュメントは、プライバシーパスチーム[privacypass]の作業から生じました。著者はまた、Hugo Krawczykとの役立つ会話を認めたいと思います。Eli-Shaoul Khedouriは、主要な一貫性に関する追加のレビューとコメントを提供しました。ダニエル・ブルドレス、タチアナ・ブラッドリー、ソフィア・セリ、フランク・デニス、ジュリア・ヘッセ、ラス・ハウズリー、ケビン・ルウィ、クリストファー・パットン、およびバス・ウェスターバーンも、この文書への有益な意見と貢献を提供しました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Alex Davidson\nBrave Software\nEmail: alex.davidson92@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Armando Faz-Hernandez\nCloudflare, Inc.\n101 Townsend St\nSan Francisco, CA\nUnited States of America\nEmail: armfazh@cloudflare.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Nick Sullivan\nCloudflare, Inc.\n101 Townsend St\nSan Francisco, CA\nUnited States of America\nEmail: nicholas.sullivan+ietf@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Christopher A. Wood\nCloudflare, Inc.\n101 Townsend St\nSan Francisco, CA\nUnited States of America\nEmail: caw@heapingbits.net",
      "raw": true,
      "ja": ""
    }
  ]
}