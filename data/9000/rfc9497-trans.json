{
  "title": {
    "text": "RFC 9497 - Oblivious Pseudorandom Functions (OPRFs) Using Prime-Order Groups",
    "ja": "RFC 9497 - 素数位数群を使用した無自覚擬似ランダム関数（OPRFs）"
  },
  "number": 9497,
  "created_at": "2024-03-20 21:30:40.051896+09:00",
  "updated_by": "自動生成(GPT)",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                          A. Davidson\nRequest for Comments: 9497                                Brave Software\nCategory: Informational                                 A. Faz-Hernandez\nISSN: 2070-1721                                              N. Sullivan\n                                                              C. A. Wood\n                                                        Cloudflare, Inc.\n                                                           December 2023",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Oblivious Pseudorandom Functions (OPRFs) Using Prime-Order Groups",
      "title": true,
      "section_title": true,
      "ja": "素数位数群を使用した無自覚擬似ランダム関数（OPRFs）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "An Oblivious Pseudorandom Function (OPRF) is a two-party protocol between a client and a server for computing the output of a Pseudorandom Function (PRF). The server provides the PRF private key, and the client provides the PRF input. At the end of the protocol, the client learns the PRF output without learning anything about the PRF private key, and the server learns neither the PRF input nor output. An OPRF can also satisfy a notion of 'verifiability', called a VOPRF. A VOPRF ensures clients can verify that the server used a specific private key during the execution of the protocol. A VOPRF can also be partially oblivious, called a POPRF. A POPRF allows clients and servers to provide public input to the PRF computation. This document specifies an OPRF, VOPRF, and POPRF instantiated within standard prime-order groups, including elliptic curves. This document is a product of the Crypto Forum Research Group (CFRG) in the IRTF.",
      "ja": "An Oblivious Pseudorandom Function (OPRF)は、クライアントとサーバーの間の2者間プロトコルであり、擬似ランダム関数（PRF）の出力を計算するためのものです。サーバーはPRFの秘密鍵を提供し、クライアントはPRFの入力を提供します。プロトコルの最後に、クライアントはPRFの出力を学習しますが、PRFの秘密鍵については何も学習しません。サーバーはPRFの入力や出力を学習しません。OPRFは、VOPRFと呼ばれる「検証可能性」の概念を満たすこともできます。VOPRFは、クライアントがプロトコルの実行中にサーバーが特定の秘密鍵を使用したことを検証できることを保証します。VOPRFは部分的に忘却可能な場合もあり、これをPOPFRと呼びます。POPFRは、クライアントとサーバーがPRF計算に公開入力を提供できるようにします。この文書は、標準的な素数位数群、楕円曲線を含むOPRF、VOPRF、POPFRを具体化したものです。この文書は、IRTFのCrypto Forum Research Group（CFRG）の成果です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "この文書はインターネット標準トラック仕様ではありません。情報提供のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Crypto Forum Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "この文書はInternet Research Task Force（IRTF）の製品です。IRTFは、インターネット関連の研究開発活動の結果を公表しています。これらの結果は、展開に適していない場合があります。このRFCは、Internet Research Task Force（IRTF）のCrypto Forum Research Groupの合意を表しています。IRSGによって公表が承認された文書は、インターネット標準のいかなるレベルの候補にもなりません。RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9497.",
      "ja": "この文書の現在の状況、誤植、フィードバック方法についての情報は、https://www.rfc-editor.org/info/rfc9497 で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2023 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2023 IETF Trustおよび文書の著者として特定された人々。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書は、この文書の公開日に有効なBCP 78およびIETF文書に関連するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象となります。これらの文書を注意深く確認してください。これらは、この文書に関するあなたの権利と制限を説明しています。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Requirements Language\n  1.2.  Notation and Terminology\n2.  Preliminaries\n  2.1.  Prime-Order Group\n  2.2.  Discrete Logarithm Equivalence Proofs\n    2.2.1.  Proof Generation\n    2.2.2.  Proof Verification\n3.  Protocol\n  3.1.  Configuration\n  3.2.  Key Generation and Context Setup\n    3.2.1.  Deterministic Key Generation\n  3.3.  Online Protocol\n    3.3.1.  OPRF Protocol\n    3.3.2.  VOPRF Protocol\n    3.3.3.  POPRF Protocol\n4.  Ciphersuites\n  4.1.  OPRF(ristretto255, SHA-512)\n  4.2.  OPRF(decaf448, SHAKE-256)\n  4.3.  OPRF(P-256, SHA-256)\n  4.4.  OPRF(P-384, SHA-384)\n  4.5.  OPRF(P-521, SHA-512)\n  4.6.  Future Ciphersuites\n  4.7.  Random Scalar Generation\n    4.7.1.  Rejection Sampling\n    4.7.2.  Random Number Generation Using Extra Random Bits\n5.  Application Considerations\n  5.1.  Input Limits\n  5.2.  External Interface Recommendations\n  5.3.  Error Considerations\n  5.4.  POPRF Public Input\n6.  IANA Considerations\n7.  Security Considerations\n  7.1.  Security Properties\n  7.2.  Security Assumptions\n    7.2.1.  OPRF and VOPRF Assumptions\n    7.2.2.  POPRF Assumptions\n    7.2.3.  Static Diffie-Hellman Attack and Security Limits\n  7.3.  Domain Separation\n  7.4.  Timing Leaks\n8.  References\n  8.1.  Normative References\n  8.2.  Informative References\nAppendix A.  Test Vectors\n  A.1.  ristretto255-SHA512\n    A.1.1.  OPRF Mode\n    A.1.2.  VOPRF Mode\n    A.1.3.  POPRF Mode\n  A.2.  decaf448-SHAKE256\n    A.2.1.  OPRF Mode\n    A.2.2.  VOPRF Mode\n    A.2.3.  POPRF Mode\n  A.3.  P256-SHA256\n    A.3.1.  OPRF Mode\n    A.3.2.  VOPRF Mode\n    A.3.3.  POPRF Mode\n  A.4.  P384-SHA384\n    A.4.1.  OPRF Mode\n    A.4.2.  VOPRF Mode\n    A.4.3.  POPRF Mode\n  A.5.  P521-SHA512\n    A.5.1.  OPRF Mode\n    A.5.2.  VOPRF Mode\n    A.5.3.  POPRF Mode\nAcknowledgements\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "A Pseudorandom Function (PRF) F(k, x) is an efficiently computable function taking a private key k and a value x as input. This function is pseudorandom if the keyed function K(_) = F(k, _) is indistinguishable from a randomly sampled function acting on the same domain and range as K(). An Oblivious PRF (OPRF) is a two-party protocol between a server and a client, wherein the server holds a PRF key k and the client holds some input x. The protocol allows both parties to cooperate in computing F(k, x), such that the client learns F(k, x) without learning anything about k and the server does not learn anything about x or F(k, x). A Verifiable OPRF (VOPRF) is an OPRF, wherein the server also proves to the client that F(k, x) was produced by the key k corresponding to the server's public key, which the client knows. A Partially Oblivious PRF (POPRF) is a variant of a VOPRF, where the client and server interact in computing F(k, x, y), for some PRF F with server-provided key k, client-provided input x, and public input y, and the client receives proof that F(k, x, y) was computed using k corresponding to the public key that the client knows. A POPRF with fixed input y is functionally equivalent to a VOPRF.",
      "ja": "擬似乱数関数（PRF）F(k, x)は、秘密鍵kと値xを入力とする効率的に計算可能な関数です。この関数は、キー付き関数K(_) = F(k, _) が、K()と同じドメインと範囲で作用するランダムにサンプリングされた関数と区別できない場合、擬似乱数です。無自覚PRF（OPRF）は、サーバーとクライアントの間の2者間プロトコルであり、サーバーはPRF鍵kを保持し、クライアントはいくつかの入力xを保持しています。このプロトコルにより、両者がF(k, x)を計算するために協力し、クライアントがkについて何も学ばずにF(k, x)を学び、サーバーがxまたはF(k, x)について何も学ばないようにします。検証可能OPRF（VOPRF）は、サーバーがクライアントに対して、F(k, x)がサーバーの公開鍵に対応する鍵kによって生成されたことを証明するOPRFであり、クライアントがそれを知っている公開鍵を持っています。部分的に無自覚PRF（POPRF）は、VOPRFの変種であり、クライアントとサーバーが、サーバーが提供する鍵k、クライアントが提供する入力x、および公開入力yを使用してF(k, x, y)を計算するために相互作用し、クライアントが、F(k, x, y)がクライアントが知っている公開鍵に対応するkを使用して計算されたことの証拠を受け取ります。固定入力yを持つPOPRFは、機能的にVOPRFと同等です。"
    },
    {
      "indent": 3,
      "text": "OPRFs have a variety of applications, including password-protected secret sharing schemes [JKKX16], privacy-preserving password stores [SJKS17], and password-authenticated key exchange (PAKE) [OPAQUE]. Verifiable OPRFs are necessary in some applications, such as Privacy Pass [PRIVACY-PASS]. Verifiable OPRFs have also been used for password-protected secret sharing schemes, such as that of [JKK14].",
      "ja": "OPRFには、パスワード保護された秘密共有スキーム[JKKX16]、プライバシー保護パスワードストア[SJKS17]、およびパスワード認証キー交換（PAKE）[OPAQUE]など、さまざまな応用があります。検証可能なOPRFは、Privacy Pass [PRIVACY-PASS]などの一部のアプリケーションで必要です。検証可能なOPRFは、[JKK14]のようなパスワード保護された秘密共有スキームにも使用されています。"
    },
    {
      "indent": 3,
      "text": "This document specifies OPRF, VOPRF, and POPRF protocols built upon prime-order groups. The document describes each protocol variant, along with application considerations, and their security properties.",
      "ja": "この文書は、素数位数群に基づいて構築されたOPRF、VOPRF、およびPOPRFプロトコルを指定しています。文書は各プロトコルのバリアント、アプリケーションの考慮事項、およびセキュリティプロパティを説明しています。"
    },
    {
      "indent": 3,
      "text": "This document represents the consensus of the Crypto Forum Research Group (CFRG). It is not an IETF product and is not a standard.",
      "ja": "この文書はCrypto Forum Research Group (CFRG) の合意を表しています。これはIETFの製品ではなく、標準でもありません。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書におけるキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、および「OPTIONAL」は、全て大文字で表記されている場合に限り、BCP 14 [RFC2119] [RFC8174] で説明されているように解釈されるべきです。"
    },
    {
      "indent": 0,
      "text": "1.2. Notation and Terminology",
      "section_title": true,
      "ja": "1.2. 表記と用語"
    },
    {
      "indent": 3,
      "text": "The following functions and notation are used throughout the document.",
      "ja": "この文書全体で以下の関数と表記法が使用されています。"
    },
    {
      "indent": 6,
      "text": "* For any object x, we write len(x) to denote its length in bytes.",
      "ja": "* すべてのオブジェクトxについて、そのバイト数を示すためにlen(x)と書きます。"
    },
    {
      "indent": 6,
      "text": "* For two-byte arrays x and y, write x || y to denote their concatenation.",
      "ja": "* xとyの2バイト配列について、x || y と書いてそれらの連結を示します。"
    },
    {
      "indent": 6,
      "text": "* I2OSP(x, xLen) converts a nonnegative integer x into a byte array of specified length xLen, as described in [RFC8017]. Note that this function returns a byte array in big-endian byte order.",
      "ja": "* I2OSP(x, xLen)は、非負の整数xを、指定された長さxLenのバイト配列に変換します。この関数は、ビッグエンディアンのバイト順でバイト配列を返すことに注意してください。"
    },
    {
      "indent": 6,
      "text": "* The notation T U[N] refers to an array called U, containing N items of type T. The type opaque means one single byte of uninterpreted data. Items of the array are zero-indexed and referred to as U[j], such that 0 <= j < N.",
      "ja": "* T U[N]という表記は、T型のN個のアイテムを含むUという配列を指します。不透明な型は、解釈されていないデータの1バイトを意味します。配列のアイテムはゼロベースであり、U[j]として参照されます。ここで、0 <= j < Nです。"
    },
    {
      "indent": 3,
      "text": "All algorithms and procedures described in this document are laid out in a Python-like pseudocode. Each function takes a set of inputs and parameters and produces a set of output values. Parameters become constant values once the protocol variant and the ciphersuite are fixed.",
      "ja": "この文書に記載されているすべてのアルゴリズムと手順は、Python風の疑似コードで示されています。各関数は、一連の入力とパラメータを受け取り、一連の出力値を生成します。プロトコルのバリアントとサイファースイートが固定されると、パラメータは定数値になります。"
    },
    {
      "indent": 3,
      "text": "The PrivateInput data type refers to inputs that are known only to the client in the protocol, whereas the PublicInput data type refers to inputs that are known to both the client and server in the protocol. Both PrivateInput and PublicInput are opaque byte strings of arbitrary length no larger than 2^16 - 1 bytes. This length restriction exists because PublicInput and PrivateInput values are length-prefixed with two bytes before use throughout the protocol.",
      "ja": "PrivateInputデータ型は、プロトコル内でクライアントのみが知っている入力を指し、一方、PublicInputデータ型は、プロトコル内でクライアントとサーバーの両方が知っている入力を指します。PrivateInputとPublicInputの両方は、2^16 - 1バイトより大きくない任意の長さの不透明なバイト文字列です。この長さ制限は、プロトコル全体で使用する前に、PublicInputとPrivateInputの値が2バイトで長さが先行しているため存在します。"
    },
    {
      "indent": 3,
      "text": "String values, such as \"DeriveKeyPair\", \"Seed-\", and \"Finalize\", are ASCII string literals.",
      "ja": "文字列値、例えば「DeriveKeyPair」、「Seed-」、および「Finalize」はASCII文字列リテラルです。"
    },
    {
      "indent": 3,
      "text": "The following terms are used throughout this document.",
      "ja": "この文書全体で以下の用語が使用されます。"
    },
    {
      "indent": 3,
      "text": "PRF:",
      "ja": "PRF:"
    },
    {
      "indent": 12,
      "text": "Pseudorandom Function",
      "ja": "疑似乱数関数"
    },
    {
      "indent": 3,
      "text": "OPRF:",
      "ja": "OPRF:"
    },
    {
      "indent": 12,
      "text": "Oblivious Pseudorandom Function",
      "ja": "忘却性擬似乱数関数"
    },
    {
      "indent": 3,
      "text": "VOPRF:",
      "ja": "VOPRF:"
    },
    {
      "indent": 12,
      "text": "Verifiable Oblivious Pseudorandom Function",
      "ja": "検証可能な忘却性擬似乱数関数"
    },
    {
      "indent": 3,
      "text": "POPRF:",
      "ja": "POPRF:"
    },
    {
      "indent": 12,
      "text": "Partially Oblivious Pseudorandom Function",
      "ja": "部分的に無意識の擬似乱数関数"
    },
    {
      "indent": 3,
      "text": "Client:",
      "ja": "クライアント："
    },
    {
      "indent": 12,
      "text": "Protocol initiator. Learns PRF evaluation as the output of the protocol.",
      "ja": "プロトコルのイニシエーター。プロトコルの出力としてPRF評価を学習します。"
    },
    {
      "indent": 3,
      "text": "Server:",
      "ja": "サーバ："
    },
    {
      "indent": 12,
      "text": "Computes the PRF using a private key. Learns nothing about the client's input or output.",
      "ja": "プライベートキーを使用してPRFを計算します。クライアントの入力や出力については何も学びません。"
    },
    {
      "indent": 0,
      "text": "2. Preliminaries",
      "section_title": true,
      "ja": "2. 前提条件"
    },
    {
      "indent": 3,
      "text": "The protocols in this document have two primary dependencies:",
      "ja": "この文書のプロトコルには、2つの主要な依存関係があります。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ"
    },
    {
      "indent": 12,
      "text": "A prime-order group implementing the API described below in Section 2.1. See Section 4 for specific instances of groups.",
      "ja": "セクション2.1で説明されているAPIを実装する素数次数のグループ。特定のグループのインスタンスについてはセクション4を参照してください。"
    },
    {
      "indent": 3,
      "text": "Hash:",
      "ja": "ハッシュ:"
    },
    {
      "indent": 12,
      "text": "A cryptographic hash function whose output length is Nh bytes.",
      "ja": "出力長がNhバイトである暗号学的ハッシュ関数。"
    },
    {
      "indent": 3,
      "text": "Section 4 specifies ciphersuites as combinations of Group and Hash.",
      "ja": "セクション4では、グループとハッシュの組み合わせを暗号スイートとして指定します。"
    },
    {
      "indent": 0,
      "text": "2.1. Prime-Order Group",
      "section_title": true,
      "ja": "2.1. 素数位数群"
    },
    {
      "indent": 3,
      "text": "In this document, we assume the construction of an additive, prime-order group, denoted Group, for performing all mathematical operations. In prime-order groups, any element (other than the identity) can generate the other elements of the group. Usually, one element is fixed and defined as the group generator. Such groups are uniquely determined by the choice of the prime p that defines the order of the group. (However, different representations of the group for a single p may exist. Section 4 lists specific groups that indicate both the order and representation.)",
      "ja": "この文書では、数学的操作を行うために加法的で素数次数のグループ（Groupと表記）の構築を前提としています。素数次数のグループでは、任意の要素（単位元以外）がグループの他の要素を生成できます。通常、1つの要素が固定され、グループの生成元として定義されます。このようなグループは、グループの次数を定義する素数pの選択によって一意に決まります。（ただし、同じpに対して単一の表現が異なる場合があります。セクション4には、次数と表現を示す特定のグループがリストされています。）"
    },
    {
      "indent": 3,
      "text": "The fundamental group operation is addition + with identity element I. For any elements A and B of the group, A + B = B + A is also a member of the group. Also, for any A in the group, there exists an element -A, such that A + (-A) = (-A) + A = I. Scalar multiplication by r is equivalent to the repeated application of the group operation on an element A with itself r - 1 times; this is denoted as r * A = A + ... + A. For any element A, p * A = I. The case when the scalar multiplication is performed on the group generator is denoted as ScalarMultGen(r). Given two elements A and B, the discrete logarithm problem is to find an integer k, such that B = k * A. Thus, k is the discrete logarithm of B with respect to the base A. The set of scalars corresponds to GF(p), a prime field of order p, and is represented as the set of integers defined by {0, 1, ..., p - 1}. This document uses types Element and Scalar to denote elements of the group and its set of scalars, respectively.",
      "ja": "基本的な群の演算は、単位元Iを持つ加算+です。群の任意の要素AとBに対して、A + B = B + Aも群の要素です。また、群の任意のAに対して、A + (-A) = (-A) + A = Iとなる要素-Aが存在します。スカラーrによる乗算は、要素Aに対して群の演算をr - 1回繰り返すことと等価であり、これはr * A = A + ... + Aと表されます。任意の要素Aに対して、p * A = Iです。スカラー乗算が群の生成元に対して行われる場合は、ScalarMultGen(r)と表されます。要素AとBが与えられた場合、離散対数問題は、B = k * Aとなる整数kを見つけることです。したがって、kは基底Aに関するBの離散対数です。スカラーの集合は、順序pの素体GF(p)に対応し、{0, 1, ..., p - 1}で定義される整数の集合として表されます。この文書では、群の要素とそのスカラーの集合を示すために、ElementとScalarという型を使用しています。"
    },
    {
      "indent": 3,
      "text": "We now detail a number of member functions that can be invoked on a prime-order group.",
      "ja": "私たちは、素数次数の群で呼び出すことができるいくつかのメンバー関数の詳細を説明します。"
    },
    {
      "indent": 3,
      "text": "Order():",
      "ja": "Order():"
    },
    {
      "indent": 12,
      "text": "Outputs the order of the group (i.e., p).",
      "ja": "グループの順序（つまり、p）を出力します。"
    },
    {
      "indent": 3,
      "text": "Identity():",
      "ja": "Identity():"
    },
    {
      "indent": 12,
      "text": "Outputs the identity element of the group (i.e., I).",
      "ja": "グループの単位元（すなわち、I）を出力します。"
    },
    {
      "indent": 3,
      "text": "Generator():",
      "ja": "ジェネレーター():"
    },
    {
      "indent": 12,
      "text": "Outputs the generator element of the group.",
      "ja": "グループの生成元を出力します。"
    },
    {
      "indent": 3,
      "text": "HashToGroup(x):",
      "ja": "HashToGroup(x):"
    },
    {
      "indent": 12,
      "text": "Deterministically maps an array of bytes x to an element of Group. The map must ensure that, for any adversary receiving R = HashToGroup(x), it is computationally difficult to reverse the mapping. This function is optionally parameterized by a domain separation tag (DST); see Section 4. Security properties of this function are described in [RFC9380].",
      "ja": "バイト配列 x を Group の要素に確定的にマッピングします。マップは、R = HashToGroup(x) を受信する悪意のある者に対して、マッピングを逆にすることが計算的に困難であることを保証する必要があります。この関数は、ドメイン分離タグ（DST）によってオプションでパラメータ化されます。この関数のセキュリティ特性については、[RFC9380] で説明されています。"
    },
    {
      "indent": 3,
      "text": "HashToScalar(x):",
      "ja": "ハッシュをスカラーに変換します。"
    },
    {
      "indent": 12,
      "text": "Deterministically maps an array of bytes x to an element in GF(p). This function is optionally parameterized by a DST; see Section 4. Security properties of this function are described in [RFC9380], Section 10.5.",
      "ja": "バイト配列xをGF(p)の要素に決定的にマッピングします。この関数はオプションでDSTによってパラメータ化されます。この関数のセキュリティプロパティについては、[RFC9380]のセクション10.5に記載されています。"
    },
    {
      "indent": 3,
      "text": "RandomScalar():",
      "ja": "RandomScalar():"
    },
    {
      "indent": 12,
      "text": "Chooses at random a nonzero element in GF(p).",
      "ja": "GF(p)内のゼロでない要素をランダムに選択します。"
    },
    {
      "indent": 3,
      "text": "ScalarInverse(s):",
      "ja": "スカラー逆数(s):"
    },
    {
      "indent": 12,
      "text": "Returns the inverse of input Scalar s on GF(p).",
      "ja": "GF(p)上の入力スカラーsの逆数を返します。"
    },
    {
      "indent": 3,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement(A):"
    },
    {
      "indent": 12,
      "text": "Maps an Element A to a canonical byte array buf of fixed-length Ne.",
      "ja": "要素Aを固定長Neの正準バイト配列bufにマッピングします。"
    },
    {
      "indent": 3,
      "text": "DeserializeElement(buf):",
      "ja": "DeserializeElement(buf):"
    },
    {
      "indent": 12,
      "text": "Attempts to map a byte array buf to an Element A and fails if the input is not the valid canonical byte representation of an element of the group. This function can raise a DeserializeError if deserialization fails or A is the identity element of the group; see Section 4 for group-specific input validation steps.",
      "ja": "バイト配列 buf を要素 A にマッピングしようとする試みが、グループの要素の正規バイト表現でない場合に失敗します。この関数は、デシリアライズに失敗した場合や A がグループの単位元である場合に DeserializeError を発生させる可能性があります。グループ固有の入力検証手順については、セクション 4 を参照してください。"
    },
    {
      "indent": 3,
      "text": "SerializeScalar(s):",
      "ja": "SerializeScalar(s):"
    },
    {
      "indent": 12,
      "text": "Maps Scalar s to a canonical byte array buf of fixed-length Ns.",
      "ja": "スカラー s を固定長 Ns の正準バイト配列 buf にマップします。"
    },
    {
      "indent": 3,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar(buf):"
    },
    {
      "indent": 12,
      "text": "Attempts to map a byte array buf to Scalar s. This function can raise a DeserializeError if deserialization fails; see Section 4 for group-specific input validation steps.",
      "ja": "バイト配列 buf をスカラー s にマッピングしようとする試み。この関数は、デシリアライズに失敗した場合に DeserializeError を発生させる可能性があります。グループ固有の入力検証手順については、セクション4を参照してください。"
    },
    {
      "indent": 3,
      "text": "Section 4 contains details for the implementation of this interface for different prime-order groups instantiated over elliptic curves. In particular, for some choices of elliptic curves, e.g., those detailed in [RFC7748], which require accounting for cofactors, Section 4 describes required steps necessary to ensure the resulting group is of prime order.",
      "ja": "セクション4には、楕円曲線上でインスタンス化された異なる素数次数のグループのためのこのインターフェースの実装の詳細が含まれています。特に、[RFC7748]で詳細に説明されている楕円曲線のいくつかの選択肢について、コファクターを考慮する必要がある場合、セクション4では、結果のグループが素数次数であることを確認するために必要な手順が記載されています。"
    },
    {
      "indent": 0,
      "text": "2.2. Discrete Logarithm Equivalence Proofs",
      "section_title": true,
      "ja": "2.2. 離散対数同値証明"
    },
    {
      "indent": 3,
      "text": "A proof of knowledge allows a prover to convince a verifier that some statement is true. If the prover can generate a proof without interaction with the verifier, the proof is noninteractive. If the verifier learns nothing other than whether the statement claimed by the prover is true or false, the proof is zero-knowledge.",
      "ja": "知識の証明は、証明者が検証者を納得させることができるようにする。証明者が検証者との対話なしに証明を生成できる場合、その証明は非対話型である。検証者が証明者が主張する文が真か偽か以外の情報を得ない場合、その証明はゼロ知識である。"
    },
    {
      "indent": 3,
      "text": "This section describes a noninteractive, zero-knowledge proof for discrete logarithm equivalence (DLEQ), which is used in the construction of VOPRF and POPRF. A DLEQ proof demonstrates that two pairs of group elements have the same discrete logarithm without revealing the discrete logarithm.",
      "ja": "このセクションでは、VOPRFとPOPRFの構築に使用される離散対数同値（DLEQ）の非対話型ゼロ知識証明について説明しています。DLEQ証明は、2つのグループ要素のペアが同じ離散対数を持つことを示し、その離散対数を明らかにせずに行います。"
    },
    {
      "indent": 3,
      "text": "The DLEQ proof resembles the Chaum-Pedersen [ChaumPedersen] proof, which is shown to be zero-knowledge by Jarecki, et al. [JKK14] and is noninteractive after applying the Fiat-Shamir transform [FS00]. Furthermore, Davidson, et al. [DGSTV18] showed a proof system for batching DLEQ proofs that has constant-size proofs with respect to the number of inputs. The specific DLEQ proof system presented below follows this latter construction with two modifications: (1) the transcript used to generate the seed includes more context information and (2) the individual challenges for each element in the proof is derived from a seed-prefixed hash-to-scalar invocation, rather than being sampled from a seeded Pseudorandom Number Generator (PRNG). The description is split into two subsections: one for generating the proof, which is done by servers in the verifiable protocols, and another for verifying the proof, which is done by clients in the protocol.",
      "ja": "DLEQ証明は、Chaum-Pedersen証明に似ており、Jareckiらによってゼロ知識であることが示されています。さらに、Davidsonらは、入力の数に対して定数サイズの証明を持つDLEQ証明のバッチングシステムを示しました。以下に示す特定のDLEQ証明システムは、この後者の構造に従い、2つの修正を加えています。説明は、証明を生成するためのものと、証明を検証するためのものに分かれています。"
    },
    {
      "indent": 0,
      "text": "2.2.1. Proof Generation",
      "section_title": true,
      "ja": "2.2.1. 証明生成"
    },
    {
      "indent": 3,
      "text": "Generating a proof is done with the GenerateProof function, as defined below. Given Element values A and B, two non-empty lists of Element values C and D of length m, and Scalar k, this function produces a proof that k * A == B and k * C[i] == D[i] for each i in [0, ..., m - 1]. The output is a value of type Proof, which is a tuple of two Scalar values. We use the notation proof[0] and proof[1] to denote the first and second elements in this tuple, respectively.",
      "ja": "証明を生成するには、以下で定義されたGenerateProof関数を使用します。要素値AとB、長さmの要素値の空でない2つのリストCとD、およびスカラーkが与えられた場合、この関数は、k * A == B および k * C[i] == D[i]（すべてのiについて[0, ..., m - 1]）を満たす証明を生成します。出力はProof型の値であり、2つのScalar値のタプルです。このタプルの最初の要素と2番目の要素をそれぞれproof[0]とproof[1]と表記します。"
    },
    {
      "indent": 3,
      "text": "GenerateProof accepts lists of inputs to amortize the cost of proof generation. Applications can take advantage of this functionality to produce a single, constant-sized proof for m DLEQ inputs, rather than m proofs for m DLEQ inputs.",
      "ja": "GenerateProofは、証明生成のコストを分散させるために入力リストを受け入れます。アプリケーションは、m個のDLEQ入力に対してm個の証明ではなく、1つの一定サイズの証明を生成するためにこの機能を利用できます。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  Scalar k\n  Element A\n  Element B\n  Element C[m]\n  Element D[m]\n\nOutput:\n\n  Proof proof\n\nParameters:\n\n  Group G\n\ndef GenerateProof(k, A, B, C, D):\n  (M, Z) = ComputeCompositesFast(k, B, C, D)\n\n  r = G.RandomScalar()\n  t2 = r * A\n  t3 = r * M\n\n  Bm = G.SerializeElement(B)\n  a0 = G.SerializeElement(M)\n  a1 = G.SerializeElement(Z)\n  a2 = G.SerializeElement(t2)\n  a3 = G.SerializeElement(t3)\n\n  challengeTranscript =\n    I2OSP(len(Bm), 2) || Bm ||\n    I2OSP(len(a0), 2) || a0 ||\n    I2OSP(len(a1), 2) || a1 ||\n    I2OSP(len(a2), 2) || a2 ||\n    I2OSP(len(a3), 2) || a3 ||\n    \"Challenge\"\n\n  c = G.HashToScalar(challengeTranscript)\n  s = r - c * k\n\n  return [c, s]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The helper function ComputeCompositesFast is as defined below and is an optimization of the ComputeComposites function for servers since they have knowledge of the private key.",
      "ja": "ComputeCompositesFastというヘルパー関数は以下のように定義されており、サーバー向けにComputeComposites関数の最適化が行われています。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  Scalar k\n  Element B\n  Element C[m]\n  Element D[m]\n\nOutput:\n\n  Element M\n  Element Z\n\nParameters:\n\n  Group G\n  PublicInput contextString\n\ndef ComputeCompositesFast(k, B, C, D):\n  Bm = G.SerializeElement(B)\n  seedDST = \"Seed-\" || contextString\n  seedTranscript =\n    I2OSP(len(Bm), 2) || Bm ||\n    I2OSP(len(seedDST), 2) || seedDST\n  seed = Hash(seedTranscript)\n\n  M = G.Identity()\n  for i in range(m):\n    Ci = G.SerializeElement(C[i])\n    Di = G.SerializeElement(D[i])\n    compositeTranscript =\n      I2OSP(len(seed), 2) || seed || I2OSP(i, 2) ||\n      I2OSP(len(Ci), 2) || Ci ||\n      I2OSP(len(Di), 2) || Di ||\n      \"Composite\"\n\n    di = G.HashToScalar(compositeTranscript)\n    M = di * C[i] + M\n\n  Z = k * M\n\n  return (M, Z)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When used in the protocol described in Section 3, the parameter contextString is as defined in Section 3.2.",
      "ja": "セクション3で説明されているプロトコルで使用される場合、パラメータcontextStringはセクション3.2で定義されたものとしています。"
    },
    {
      "indent": 0,
      "text": "2.2.2. Proof Verification",
      "section_title": true,
      "ja": "2.2.2. 証明の検証"
    },
    {
      "indent": 3,
      "text": "Verifying a proof is done with the VerifyProof function, as defined below. This function takes Element values A and B, two non-empty lists of Element values C and D of length m, and a Proof value output from GenerateProof. It outputs a single boolean value indicating whether or not the proof is valid for the given DLEQ inputs. Note this function can verify proofs on lists of inputs whenever the proof was generated as a batched DLEQ proof with the same inputs.",
      "ja": "証明の検証は、以下で定義されたVerifyProof関数を使用して行われます。この関数は、Element値AとB、長さmのElement値CとDの2つの空でないリスト、およびGenerateProofからのProof値を取ります。与えられたDLEQ入力に対して証明が有効かどうかを示す単一のブール値を出力します。この関数は、証明が同じ入力でバッチ処理されたDLEQ証明として生成された場合、入力リストの証明を検証できることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  Element A\n  Element B\n  Element C[m]\n  Element D[m]\n  Proof proof\n\nOutput:\n\n  boolean verified\n\nParameters:\n\n  Group G\n\ndef VerifyProof(A, B, C, D, proof):\n  (M, Z) = ComputeComposites(B, C, D)\n  c = proof[0]\n  s = proof[1]\n\n  t2 = ((s * A) + (c * B))\n  t3 = ((s * M) + (c * Z))\n\n  Bm = G.SerializeElement(B)\n  a0 = G.SerializeElement(M)\n  a1 = G.SerializeElement(Z)\n  a2 = G.SerializeElement(t2)\n  a3 = G.SerializeElement(t3)\n\n  challengeTranscript =\n    I2OSP(len(Bm), 2) || Bm ||\n    I2OSP(len(a0), 2) || a0 ||\n    I2OSP(len(a1), 2) || a1 ||\n    I2OSP(len(a2), 2) || a2 ||\n    I2OSP(len(a3), 2) || a3 ||\n    \"Challenge\"\n\n  expectedC = G.HashToScalar(challengeTranscript)\n  verified = (expectedC == c)\n\n  return verified",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The definition of ComputeComposites is given below.",
      "ja": "ComputeCompositesの定義は以下の通りです。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  Element B\n  Element C[m]\n  Element D[m]\n\nOutput:\n\n  Element M\n  Element Z\n\nParameters:\n\n  Group G\n  PublicInput contextString\n\ndef ComputeComposites(B, C, D):\n  Bm = G.SerializeElement(B)\n  seedDST = \"Seed-\" || contextString\n  seedTranscript =\n    I2OSP(len(Bm), 2) || Bm ||\n    I2OSP(len(seedDST), 2) || seedDST\n  seed = Hash(seedTranscript)\n\n  M = G.Identity()\n  Z = G.Identity()\n  for i in range(m):\n    Ci = G.SerializeElement(C[i])\n    Di = G.SerializeElement(D[i])\n    compositeTranscript =\n      I2OSP(len(seed), 2) || seed || I2OSP(i, 2) ||\n      I2OSP(len(Ci), 2) || Ci ||\n      I2OSP(len(Di), 2) || Di ||\n      \"Composite\"\n\n    di = G.HashToScalar(compositeTranscript)\n    M = di * C[i] + M\n    Z = di * D[i] + Z\n\n  return (M, Z)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When used in the protocol described in Section 3, the parameter contextString is as defined in Section 3.2.",
      "ja": "セクション3で説明されているプロトコルで使用される場合、パラメータcontextStringはセクション3.2で定義されたものとしています。"
    },
    {
      "indent": 0,
      "text": "3. Protocol",
      "section_title": true,
      "ja": "3. プロトコル"
    },
    {
      "indent": 3,
      "text": "In this section, we define and describe three protocol variants referred to as the OPRF, VOPRF, and POPRF modes. Each of these variants involves two messages between the client and server, but they differ slightly in terms of the security properties; see Section 7.1 for more information. A high-level description of the functionality of each mode follows.",
      "ja": "このセクションでは、OPRF、VOPRF、およびPOPRFモードとして言及される3つのプロトコルバリアントを定義および説明します。これらのバリアントは、クライアントとサーバー間で2つのメッセージが関与しますが、セキュリティプロパティに若干の違いがあります。各モードの機能の概要説明が続きます。"
    },
    {
      "indent": 3,
      "text": "In the OPRF mode, a client and server interact to compute output = F(skS, input), where input is the client's private input, skS is the server's private key, and output is the OPRF output. After the execution of the protocol, the client learns the output and the server learns nothing. This interaction is shown below.",
      "ja": "OPRFモードでは、クライアントとサーバーが相互作用して、output = F(skS, input) を計算します。ここで、input はクライアントのプライベート入力、skS はサーバーのプライベートキー、output は OPRF の出力です。プロトコルの実行後、クライアントは出力を知ることができ、サーバーは何も知りません。この相互作用は以下に示されています。"
    },
    {
      "indent": 5,
      "text": "  Client(input)                                        Server(skS)\n-------------------------------------------------------------------\nblind, blindedElement = Blind(input)\n\n                           blindedElement\n                             ---------->\n\n              evaluatedElement = BlindEvaluate(skS, blindedElement)\n\n                           evaluatedElement\n                             <----------\n\noutput = Finalize(input, blind, evaluatedElement)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 1: OPRF Protocol Overview",
      "ja": "図1：OPRFプロトコル概要"
    },
    {
      "indent": 3,
      "text": "In the VOPRF mode, the client additionally receives proof that the server used skS in computing the function. To achieve verifiability, as in [JKK14], the server provides a zero-knowledge proof that the key provided as input by the server in the BlindEvaluate function is the same key as is used to produce the server's public key, pkS, which the client receives as input to the protocol. This proof does not reveal the server's private key to the client. This interaction is shown below.",
      "ja": "VOPRFモードでは、クライアントはサーバーが関数を計算する際にskSを使用したことの証拠を追加で受け取ります。検証可能性を達成するために、サーバーはBlindEvaluate関数でサーバーが入力として提供したキーが、クライアントがプロトコルへの入力として受け取るサーバーの公開鍵pkSを生成するために使用される同じキーであることをゼロ知識証明で提供します。この証明はサーバーの秘密鍵をクライアントに明かしません。このやり取りは以下に示されています。"
    },
    {
      "indent": 5,
      "text": "  Client(input, pkS)       <---- pkS ------        Server(skS, pkS)\n-------------------------------------------------------------------\nblind, blindedElement = Blind(input)\n\n                           blindedElement\n                             ---------->\n\n            evaluatedElement, proof = BlindEvaluate(skS, pkS,\n                                                    blindedElement)\n\n                       evaluatedElement, proof\n                             <----------\n\noutput = Finalize(input, blind, evaluatedElement,\n                  blindedElement, pkS, proof)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Figure 2: VOPRF Protocol Overview with Additional Proof",
      "ja": "図2: 追加の証明を含むVOPRFプロトコルの概要"
    },
    {
      "indent": 3,
      "text": "The POPRF mode extends the VOPRF mode such that the client and server can additionally provide the public input info, which is used in computing the PRF. That is, the client and server interact to compute output = F(skS, input, info), as is shown below.",
      "ja": "POPRFモードは、クライアントとサーバーが追加で公開入力情報を提供できるようにVOPRFモードを拡張します。つまり、クライアントとサーバーは、以下に示すように出力を計算するためにやり取りを行います：output = F(skS, input, info)。"
    },
    {
      "indent": 5,
      "text": "  Client(input, pkS, info) <---- pkS ------  Server(skS, pkS, info)\n-------------------------------------------------------------------\nblind, blindedElement, tweakedKey = Blind(input, info, pkS)\n\n                           blindedElement\n                             ---------->\n\n       evaluatedElement, proof = BlindEvaluate(skS, blindedElement,\n                                               info)\n\n                       evaluatedElement, proof\n                             <----------\n\noutput = Finalize(input, blind, evaluatedElement,\n                  blindedElement, proof, info, tweakedKey)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 3: POPRF Protocol Overview with Additional Public Input",
      "ja": "図3：追加の公開入力を含むPOPRFプロトコルの概要"
    },
    {
      "indent": 3,
      "text": "Each protocol consists of an offline setup phase and an online phase, as described in Sections 3.2 and 3.3, respectively. Configuration details for the offline phase are described in Section 3.1.",
      "ja": "各プロトコルは、それぞれセクション3.2および3.3で説明されているオフライン設定フェーズとオンラインフェーズから構成されています。オフラインフェーズの構成詳細はセクション3.1に記載されています。"
    },
    {
      "indent": 0,
      "text": "3.1. Configuration",
      "section_title": true,
      "ja": "3.1. 構成"
    },
    {
      "indent": 3,
      "text": "Each of the three protocol variants are identified with a one-byte value (in hexadecimal):",
      "ja": "各プロトコルのバリアントは、1バイトの値（16進数）で識別されます。"
    },
    {
      "indent": 28,
      "text": "+===========+=======+\n| Mode      | Value |\n+===========+=======+\n| modeOPRF  | 0x00  |\n+-----------+-------+\n| modeVOPRF | 0x01  |\n+-----------+-------+\n| modePOPRF | 0x02  |\n+-----------+-------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": " Table 1: Identifiers for Protocol Variants",
      "ja": "表1：プロトコルバリアントの識別子"
    },
    {
      "indent": 3,
      "text": "Additionally, each protocol variant is instantiated with a ciphersuite or suite. Each ciphersuite is identified with an ASCII string identifier, referred to as identifier; see Section 4 for the set of initial ciphersuite values.",
      "ja": "さらに、各プロトコルのバリアントは、サイファースイートまたはスイートでインスタンス化されます。 各サイファースイートは、ASCII文字列識別子で識別され、識別子と呼ばれます。 初期サイファースイート値のセットについては、セクション4を参照してください。"
    },
    {
      "indent": 3,
      "text": "The mode and ciphersuite identifier values are combined to create a \"context string\" used throughout the protocol with the following function:",
      "ja": "モードとサイファースイート識別子の値は、次の関数を使用してプロトコル全体で使用される「コンテキスト文字列」を作成するために組み合わされます。"
    },
    {
      "indent": 3,
      "text": "def CreateContextString(mode, identifier):\n  return \"OPRFV1-\" || I2OSP(mode, 1) || \"-\" || identifier",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2. Key Generation and Context Setup",
      "section_title": true,
      "ja": "3.2. キー生成とコンテキストの設定"
    },
    {
      "indent": 3,
      "text": "In the offline setup phase, the server generates a fresh, random key pair (skS, pkS). There are two ways to generate this key pair. The first of which is using the GenerateKeyPair function described below.",
      "ja": "オフライン設定フェーズでは、サーバーが新しいランダムな鍵ペア（skS、pkS）を生成します。この鍵ペアを生成する方法は2つあります。最初の方法は、以下で説明されているGenerateKeyPair関数を使用することです。"
    },
    {
      "indent": 3,
      "text": "Input: None\n\nOutput:\n\n  Scalar skS\n  Element pkS\n\nParameters:\n\n  Group G\n\ndef GenerateKeyPair():\n  skS = G.RandomScalar()\n  pkS = G.ScalarMultGen(skS)\n  return skS, pkS",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The second way to generate the key pair is via the deterministic key generation function DeriveKeyPair, as described in Section 3.2.1. Applications and implementations can use either method in practice.",
      "ja": "キーペアを生成する2番目の方法は、3.2.1節で説明されている決定論的キー生成関数DeriveKeyPairを使用することです。実際のアプリケーションや実装では、どちらの方法も使用できます。"
    },
    {
      "indent": 3,
      "text": "Also during the offline setup phase, both the client and server create a context used for executing the online phase of the protocol after agreeing on a mode and ciphersuite identifier. The context, such as OPRFServerContext, is an implementation-specific data structure that stores a context string and the relevant key material for each party.",
      "ja": "オフライン設定フェーズ中に、クライアントとサーバーはモードと暗号スイート識別子に合意した後、プロトコルのオンラインフェーズを実行するために使用されるコンテキストを作成します。OPRFServerContextなどのコンテキストは、各当事者のためのコンテキスト文字列と関連するキーマテリアルを格納する実装固有のデータ構造です。"
    },
    {
      "indent": 3,
      "text": "The OPRF variant server and client contexts are created as follows:",
      "ja": "OPRFバリアントサーバーおよびクライアントコンテキストは次のように作成されます。"
    },
    {
      "indent": 3,
      "text": "def SetupOPRFServer(identifier, skS):\n  contextString = CreateContextString(modeOPRF, identifier)\n  return OPRFServerContext(contextString, skS)\n\ndef SetupOPRFClient(identifier):\n  contextString = CreateContextString(modeOPRF, identifier)\n  return OPRFClientContext(contextString)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The VOPRF variant server and client contexts are created as follows:",
      "ja": "VOPRFバリアントのサーバーおよびクライアントのコンテキストは次のように作成されます。"
    },
    {
      "indent": 3,
      "text": "def SetupVOPRFServer(identifier, skS):\n  contextString = CreateContextString(modeVOPRF, identifier)\n  return VOPRFServerContext(contextString, skS)\n\ndef SetupVOPRFClient(identifier, pkS):\n  contextString = CreateContextString(modeVOPRF, identifier)\n  return VOPRFClientContext(contextString, pkS)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The POPRF variant server and client contexts are created as follows:",
      "ja": "POPFRバリアントサーバーおよびクライアントコンテキストは次のように作成されます。"
    },
    {
      "indent": 3,
      "text": "def SetupPOPRFServer(identifier, skS):\n  contextString = CreateContextString(modePOPRF, identifier)\n  return POPRFServerContext(contextString, skS)\n\ndef SetupPOPRFClient(identifier, pkS):\n  contextString = CreateContextString(modePOPRF, identifier)\n  return POPRFClientContext(contextString, pkS)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.1. Deterministic Key Generation",
      "section_title": true,
      "ja": "3.2.1. Deterministic Key Generation"
    },
    {
      "indent": 3,
      "text": "This section describes a deterministic key generation function, DeriveKeyPair. It accepts a seed of 32 bytes generated from a cryptographically secure random number generator and an optional (possibly empty) info string. Note that, by design, knowledge of seed and info is necessary to compute this function, which means that the secrecy of the output private key (skS) depends on the secrecy of seed (since the info string is public).",
      "ja": "このセクションは、決定論的な鍵生成関数であるDeriveKeyPairについて説明しています。これは、暗号的に安全な乱数生成器から生成された32バイトのシードと、オプションの（空である可能性がある）情報文字列を受け入れます。設計上、この関数を計算するためには、シードと情報の知識が必要であり、出力の秘密鍵（skS）の機密性はシードの機密性に依存することに注意してください（情報文字列は公開されているため）。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  opaque seed[32]\n  PublicInput info\n\nOutput:\n\n  Scalar skS\n  Element pkS\n\nParameters:\n\n  Group G\n  PublicInput contextString\n\nErrors: DeriveKeyPairError\n\ndef DeriveKeyPair(seed, info):\n  deriveInput = seed || I2OSP(len(info), 2) || info\n  counter = 0\n  skS = 0\n  while skS == 0:\n    if counter > 255:\n      raise DeriveKeyPairError\n    skS = G.HashToScalar(deriveInput || I2OSP(counter, 1),\n                          DST = \"DeriveKeyPair\" || contextString)\n    counter = counter + 1\n  pkS = G.ScalarMultGen(skS)\n  return skS, pkS",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3. Online Protocol",
      "section_title": true,
      "ja": "3.3. オンラインプロトコル"
    },
    {
      "indent": 3,
      "text": "In the online phase, the client and server engage in a two-message protocol to compute the protocol output. This section describes the protocol details for each protocol variant. Throughout each description, the following parameters are assumed to exist:",
      "ja": "オンラインフェーズでは、クライアントとサーバーはプロトコルの出力を計算するために2つのメッセージプロトコルを実行します。このセクションでは、各プロトコルのバリアントについてのプロトコルの詳細を説明します。各説明の中で、以下のパラメータが存在することが前提とされています。"
    },
    {
      "indent": 3,
      "text": "G:",
      "ja": "G:"
    },
    {
      "indent": 12,
      "text": "a prime-order group implementing the API described in Section 2.1",
      "ja": "セクション2.1で説明されているAPIを実装する素数次数のグループ"
    },
    {
      "indent": 3,
      "text": "contextString:",
      "ja": "contextString:"
    },
    {
      "indent": 12,
      "text": "a PublicInput domain separation tag constructed during context setup, as created in Section 3.1",
      "ja": "コンテキスト設定中に作成されたPublicInputドメイン分離タグ、Section 3.1で作成されたもの"
    },
    {
      "indent": 3,
      "text": "skS and pkS:",
      "ja": "skSとpkS:"
    },
    {
      "indent": 12,
      "text": "a Scalar and Element representing the private and public keys configured for the client and server in Section 3.2",
      "ja": "セクション3.2でクライアントとサーバーに設定されたプライベートキーとパブリックキーを表すScalarとElement"
    },
    {
      "indent": 3,
      "text": "Applications serialize protocol messages between the client and server for transmission. Element values and Scalar values are serialized to byte arrays, and values of type Proof are serialized as the concatenation of two serialized Scalar values. Deserializing these values can fail; in which case, the application MUST abort the protocol, raising a DeserializeError failure.",
      "ja": "アプリケーションは、クライアントとサーバー間の通信のためにプロトコルメッセージをシリアル化します。要素値とスカラー値はバイト配列にシリアル化され、Proof型の値は2つのシリアル化されたスカラー値の連結としてシリアル化されます。これらの値の逆シリアル化に失敗する場合、アプリケーションはプロトコルを中止し、DeserializeErrorのエラーを発生させる必要があります。"
    },
    {
      "indent": 3,
      "text": "Applications MUST check that input Element values received over the wire are not the group identity element. This check is handled after deserializing Element values; see Section 4 for more information and requirements on input validation for each ciphersuite.",
      "ja": "アプリケーションは、ワイヤーを介して受信した入力要素の値がグループの単位元でないことを確認する必要があります。このチェックは、要素の値を逆シリアル化した後に処理されます。各サイファースイートの入力検証に関する詳細情報と要件については、セクション4を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.3.1. OPRF Protocol",
      "section_title": true,
      "ja": "3.3.1. OPRFプロトコル"
    },
    {
      "indent": 3,
      "text": "The OPRF protocol begins with the client blinding its input, as described by the Blind function below. Note that this function can fail with an InvalidInputError error for certain inputs that map to the group identity element. Dealing with this failure is an application-specific decision; see Section 5.3.",
      "ja": "OPRFプロトコルは、クライアントが以下のBlind関数で説明されるように入力をブラインド化することから始まります。この関数は、グループの単位元にマップされる特定の入力に対してInvalidInputErrorエラーで失敗する可能性があります。この失敗に対処する方法は、アプリケーション固有の決定です。セクション5.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  PrivateInput input\n\nOutput:\n\n  Scalar blind\n  Element blindedElement\n\nParameters:\n\n  Group G\n\nErrors: InvalidInputError\n\ndef Blind(input):\n  blind = G.RandomScalar()\n  inputElement = G.HashToGroup(input)\n  if inputElement == G.Identity():\n    raise InvalidInputError\n  blindedElement = blind * inputElement\n\n  return blind, blindedElement",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Clients store blind locally and send blindedElement to the server for evaluation. Upon receipt, servers process blindedElement using the BlindEvaluate function described below.",
      "ja": "クライアントはローカルにブラインドを保存し、blindedElementをサーバーに送信して評価します。受信後、サーバーは以下で説明されているBlindEvaluate関数を使用してblindedElementを処理します。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  Scalar skS\n  Element blindedElement\n\nOutput:\n\n  Element evaluatedElement\n\ndef BlindEvaluate(skS, blindedElement):\n  evaluatedElement = skS * blindedElement\n  return evaluatedElement",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Servers send the output evaluatedElement to clients for processing. Recall that servers may process multiple client inputs by applying the BlindEvaluate function to each blindedElement received and returning an array with the corresponding evaluatedElement values.",
      "ja": "サーバーは、評価された要素をクライアントに送信して処理します。サーバーは、BlindEvaluate関数を適用して受信した各ブラインドされた要素に対応する評価された要素の値を含む配列を返すことで、複数のクライアント入力を処理する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of evaluatedElement, clients process it to complete the OPRF evaluation with the Finalize function described below.",
      "ja": "受信した evaluatedElement をクライアントは処理し、以下に説明する Finalize 関数を使用して OPRF 評価を完了させます。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  PrivateInput input\n  Scalar blind\n  Element evaluatedElement\n\nOutput:\n\n  opaque output[Nh]\n\nParameters:\n\n  Group G\n\ndef Finalize(input, blind, evaluatedElement):\n  N = G.ScalarInverse(blind) * evaluatedElement\n  unblindedElement = G.SerializeElement(N)\n\n  hashInput = I2OSP(len(input), 2) || input ||\n              I2OSP(len(unblindedElement), 2) || unblindedElement ||\n              \"Finalize\"\n  return Hash(hashInput)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An entity that knows both the private key and the input can compute the PRF result using the following Evaluate function.",
      "ja": "入力と秘密鍵の両方を知っているエンティティは、次の評価関数を使用してPRFの結果を計算できます。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  Scalar skS\n  PrivateInput input\n\nOutput:\n\n  opaque output[Nh]\n\nParameters:\n\n  Group G\n\nErrors: InvalidInputError\n\ndef Evaluate(skS, input):\n  inputElement = G.HashToGroup(input)\n  if inputElement == G.Identity():\n    raise InvalidInputError\n  evaluatedElement = skS * inputElement\n  issuedElement = G.SerializeElement(evaluatedElement)\n\n  hashInput = I2OSP(len(input), 2) || input ||\n              I2OSP(len(issuedElement), 2) || issuedElement ||\n              \"Finalize\"\n  return Hash(hashInput)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3.2. VOPRF Protocol",
      "section_title": true,
      "ja": "3.3.2. VOPRFプロトコル"
    },
    {
      "indent": 3,
      "text": "The VOPRF protocol begins with the client blinding its input, using the same Blind function as in Section 3.3.1. Clients store the output blind locally and send blindedElement to the server for evaluation. Upon receipt, servers process blindedElement to compute an evaluated element and a DLEQ proof using the following BlindEvaluate function.",
      "ja": "VOPRFプロトコルは、クライアントが入力をブラインド化することから始まります。クライアントは出力ブラインドをローカルに保存し、blindedElementをサーバーに送信します。サーバーはblindedElementを処理して評価された要素とDLEQ証明を計算します。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  Scalar skS\n  Element pkS\n  Element blindedElement\n\nOutput:\n\n  Element evaluatedElement\n  Proof proof\n\nParameters:\n\n  Group G\n\ndef BlindEvaluate(skS, pkS, blindedElement):\n  evaluatedElement = skS * blindedElement\n  blindedElements = [blindedElement]     // list of length 1\n  evaluatedElements = [evaluatedElement] // list of length 1\n  proof = GenerateProof(skS, G.Generator(), pkS,\n                        blindedElements, evaluatedElements)\n  return evaluatedElement, proof",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the description above, inputs to GenerateProof are one-item lists. Using larger lists allows servers to batch the evaluation of multiple elements while producing a single batched DLEQ proof for them.",
      "ja": "上記の説明では、GenerateProofへの入力は1つのアイテムのリストです。より大きなリストを使用すると、サーバーは複数の要素の評価をバッチ処理し、それらに対して1つのバッチ処理されたDLEQ証明を生成できます。"
    },
    {
      "indent": 3,
      "text": "The server sends both evaluatedElement and proof back to the client. Upon receipt, the client processes both values to complete the VOPRF computation using the Finalize function below.",
      "ja": "サーバーは、評価された要素と証明の両方をクライアントに送信します。受信後、クライアントは両方の値を処理して、以下のFinalize関数を使用してVOPRF計算を完了します。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  PrivateInput input\n  Scalar blind\n  Element evaluatedElement\n  Element blindedElement\n  Element pkS\n  Proof proof\n\nOutput:\n\n  opaque output[Nh]\n\nParameters:\n\n  Group G\n\nErrors: VerifyError\n\ndef Finalize(input, blind, evaluatedElement,\n             blindedElement, pkS, proof):\n  blindedElements = [blindedElement]     // list of length 1\n  evaluatedElements = [evaluatedElement] // list of length 1\n  if VerifyProof(G.Generator(), pkS, blindedElements,\n                 evaluatedElements, proof) == false:\n    raise VerifyError\n\n  N = G.ScalarInverse(blind) * evaluatedElement\n  unblindedElement = G.SerializeElement(N)\n\n  hashInput = I2OSP(len(input), 2) || input ||\n              I2OSP(len(unblindedElement), 2) || unblindedElement ||\n              \"Finalize\"\n  return Hash(hashInput)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "As in BlindEvaluate, inputs to VerifyProof are one-item lists. Clients can verify multiple inputs at once whenever the server produced a batched DLEQ proof for them.",
      "ja": "BlindEvaluateと同様に、VerifyProofへの入力は1つのアイテムのリストです。サーバーがそれらのためにバッチ処理されたDLEQ証明を生成した場合、クライアントは複数の入力を一度に検証できます。"
    },
    {
      "indent": 3,
      "text": "Finally, an entity that knows both the private key and the input can compute the PRF result using the Evaluate function described in Section 3.3.1.",
      "ja": "最終的に、プライベートキーと入力の両方を知っているエンティティは、セクション3.3.1で説明されているEvaluate関数を使用してPRFの結果を計算できます。"
    },
    {
      "indent": 0,
      "text": "3.3.3. POPRF Protocol",
      "section_title": true,
      "ja": "3.3.3. POPRFプロトコル"
    },
    {
      "indent": 3,
      "text": "The POPRF protocol begins with the client blinding its input, using the following modified Blind function. In this step, the client also binds a public info value, which produces an additional tweakedKey to be used later in the protocol. Note that this function can fail with an InvalidInputError error for certain private inputs that map to the group identity element, as well as certain public inputs that, if not detected at this point, will cause server evaluation to fail. Dealing with either failure is an application-specific decision; see Section 5.3.",
      "ja": "POPRFプロトコルは、クライアントが入力をブラインド化することから始まり、次の修正されたブラインド関数を使用します。このステップでは、クライアントは後でプロトコルで使用される追加の調整された鍵を生成するために、パブリック情報値をバインドします。この関数は、特定のプライベート入力がグループの単位元にマップされる場合や、この時点で検出されないとサーバーの評価が失敗する可能性がある特定のパブリック入力に対して、InvalidInputErrorエラーで失敗することがあります。どちらの失敗に対処するかは、アプリケーション固有の決定です。セクション5.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  PrivateInput input\n  PublicInput info\n  Element pkS\n\nOutput:\n\n  Scalar blind\n  Element blindedElement\n  Element tweakedKey\n\nParameters:\n\n  Group G\n\nErrors: InvalidInputError\n\ndef Blind(input, info, pkS):\n  framedInfo = \"Info\" || I2OSP(len(info), 2) || info\n  m = G.HashToScalar(framedInfo)\n  T = G.ScalarMultGen(m)\n  tweakedKey = T + pkS\n  if tweakedKey == G.Identity():\n    raise InvalidInputError\n\n  blind = G.RandomScalar()\n  inputElement = G.HashToGroup(input)\n  if inputElement == G.Identity():\n    raise InvalidInputError\n\n  blindedElement = blind * inputElement\n\n  return blind, blindedElement, tweakedKey",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Clients store the outputs blind and tweakedKey locally and send blindedElement to the server for evaluation. Upon receipt, servers process blindedElement to compute an evaluated element and a DLEQ proof using the following BlindEvaluate function.",
      "ja": "クライアントは出力 blind と tweakedKey をローカルに保存し、blindedElement をサーバーに送信して評価を行います。サーバーは受信後、blindedElement を処理して評価された要素と DLEQ 証明を計算します。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  Scalar skS\n  Element blindedElement\n  PublicInput info\n\nOutput:\n\n  Element evaluatedElement\n  Proof proof\n\nParameters:\n\n  Group G\n\nErrors: InverseError\n\ndef BlindEvaluate(skS, blindedElement, info):\n  framedInfo = \"Info\" || I2OSP(len(info), 2) || info\n  m = G.HashToScalar(framedInfo)\n  t = skS + m\n  if t == 0:\n    raise InverseError\n\n  evaluatedElement = G.ScalarInverse(t) * blindedElement\n\n  tweakedKey = G.ScalarMultGen(t)\n  evaluatedElements = [evaluatedElement] // list of length 1\n  blindedElements = [blindedElement]     // list of length 1\n  proof = GenerateProof(t, G.Generator(), tweakedKey,\n                        evaluatedElements, blindedElements)\n\n  return evaluatedElement, proof",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the description above, inputs to GenerateProof are one-item lists. Using larger lists allows servers to batch the evaluation of multiple elements while producing a single batched DLEQ proof for them.",
      "ja": "上記の説明では、GenerateProofへの入力は1つのアイテムのリストです。より大きなリストを使用すると、サーバーは複数の要素の評価をバッチ処理し、それらに対して1つのバッチ処理されたDLEQ証明を生成できます。"
    },
    {
      "indent": 3,
      "text": "BlindEvaluate triggers InverseError when the function is about to calculate the inverse of a zero scalar, which does not exist and therefore yields a failure in the protocol. This only occurs for info values that map to the private key of the server. Thus, clients that cause this error should be assumed to know the server private key. Hence, this error can be a signal for the server to replace its private key.",
      "ja": "BlindEvaluateトリガーは、関数がゼロスカラーの逆数を計算しようとするときにInverseErrorを引き起こします。これは存在しないため、プロトコルで失敗します。これは、サーバーのプライベートキーにマップされる情報値にのみ発生します。したがって、このエラーが発生するクライアントは、サーバーのプライベートキーを知っていると見なすべきです。したがって、このエラーは、サーバーにプライベートキーを置き換えるように信号を送ることができます。"
    },
    {
      "indent": 3,
      "text": "The server sends both evaluatedElement and proof back to the client. Upon receipt, the client processes both values to complete the POPRF computation using the Finalize function below.",
      "ja": "サーバーは、評価された要素と証明の両方をクライアントに送信します。クライアントは、受信後、以下のFinalize関数を使用してPOPRF計算を完了するために両方の値を処理します。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  PrivateInput input\n  Scalar blind\n  Element evaluatedElement\n  Element blindedElement\n  Proof proof\n  PublicInput info\n  Element tweakedKey\n\nOutput:\n\n  opaque output[Nh]\n\nParameters:\n\n  Group G\n\nErrors: VerifyError\n\ndef Finalize(input, blind, evaluatedElement, blindedElement,\n             proof, info, tweakedKey):\n  evaluatedElements = [evaluatedElement] // list of length 1\n  blindedElements = [blindedElement]     // list of length 1\n  if VerifyProof(G.Generator(), tweakedKey, evaluatedElements,\n                 blindedElements, proof) == false:\n    raise VerifyError\n\n  N = G.ScalarInverse(blind) * evaluatedElement\n  unblindedElement = G.SerializeElement(N)\n\n  hashInput = I2OSP(len(input), 2) || input ||\n              I2OSP(len(info), 2) || info ||\n              I2OSP(len(unblindedElement), 2) || unblindedElement ||\n              \"Finalize\"\n  return Hash(hashInput)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "As in BlindEvaluate, inputs to VerifyProof are one-item lists. Clients can verify multiple inputs at once whenever the server produced a batched DLEQ proof for them.",
      "ja": "BlindEvaluateと同様に、VerifyProofへの入力は1つのアイテムのリストです。サーバーがそれらのためにバッチ処理されたDLEQ証明を生成した場合、クライアントは複数の入力を一度に検証できます。"
    },
    {
      "indent": 3,
      "text": "Finally, an entity that knows both the private key and the input can compute the PRF result using the Evaluate function described below.",
      "ja": "最終的に、プライベートキーと入力の両方を知っているエンティティは、以下で説明されているEvaluate関数を使用してPRFの結果を計算できます。"
    },
    {
      "indent": 3,
      "text": "Input:\n\n  Scalar skS\n  PrivateInput input\n  PublicInput info\n\nOutput:\n\n  opaque output[Nh]\n\nParameters:\n\n  Group G\n\nErrors: InvalidInputError, InverseError\n\ndef Evaluate(skS, input, info):\n  inputElement = G.HashToGroup(input)\n  if inputElement == G.Identity():\n    raise InvalidInputError\n\n  framedInfo = \"Info\" || I2OSP(len(info), 2) || info\n  m = G.HashToScalar(framedInfo)\n  t = skS + m\n  if t == 0:\n    raise InverseError\n  evaluatedElement = G.ScalarInverse(t) * inputElement\n  issuedElement = G.SerializeElement(evaluatedElement)\n\n  hashInput = I2OSP(len(input), 2) || input ||\n              I2OSP(len(info), 2) || info ||\n              I2OSP(len(issuedElement), 2) || issuedElement ||\n              \"Finalize\"\n  return Hash(hashInput)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4. Ciphersuites",
      "section_title": true,
      "ja": "4. 暗号スイート"
    },
    {
      "indent": 3,
      "text": "A ciphersuite (also referred to as 'suite' in this document) for the protocol wraps the functionality required for the protocol to take place. The ciphersuite should be available to both the client and server, and agreement on the specific instantiation is assumed throughout.",
      "ja": "プロトコルのための暗号スイート（この文書では「スイート」とも呼ばれます）は、プロトコルが実行されるために必要な機能を包含しています。 暗号スイートはクライアントとサーバーの両方で利用可能であり、特定のインスタンスについての合意が前提とされています。"
    },
    {
      "indent": 3,
      "text": "A ciphersuite contains instantiations of the following functionalities:",
      "ja": "暗号スイートには、以下の機能の実体化が含まれています。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ"
    },
    {
      "indent": 12,
      "text": "A prime-order group exposing the API detailed in Section 2.1, with the generator element defined in the corresponding reference for each group. Each group also specifies HashToGroup, HashToScalar, and serialization functionalities. For HashToGroup, the domain separation tag (DST) is constructed in accordance with the recommendations in [RFC9380], Section 3.1. For HashToScalar, each group specifies an integer order that is used in reducing integer values to a member of the corresponding scalar field.",
      "ja": "セクション2.1に詳細が記載されたAPIを公開する素数次数のグループで、各グループの対応するリファレンスで定義された生成元を持っています。各グループは、HashToGroup、HashToScalar、およびシリアライゼーション機能も指定しています。HashToGroupについては、ドメイン分離タグ（DST）は[RFC9380]の推奨事項に従って構築されます（セクション3.1）。HashToScalarについては、各グループが整数次数を指定し、整数値を対応するスカラー場のメンバーに縮小する際に使用されます。"
    },
    {
      "indent": 3,
      "text": "Hash:",
      "ja": "ハッシュ:"
    },
    {
      "indent": 12,
      "text": "A cryptographic hash function whose output length is Nh bytes long.",
      "ja": "Nhバイト長の出力を持つ暗号ハッシュ関数。"
    },
    {
      "indent": 3,
      "text": "This section includes an initial set of ciphersuites with supported groups and hash functions. It also includes implementation details for each ciphersuite, focusing on input validation. Future documents can specify additional ciphersuites as needed, provided they meet the requirements in Section 4.6.",
      "ja": "このセクションには、サポートされるグループとハッシュ関数を持つ初期のサイファースイートが含まれています。また、各サイファースイートの実装の詳細も含まれており、入力の検証に焦点を当てています。将来の文書では、セクション4.6の要件を満たす場合に限り、追加のサイファースイートを指定できます。"
    },
    {
      "indent": 3,
      "text": "For each ciphersuite, contextString is that which is computed in the Setup functions. Applications should take caution in using ciphersuites targeting P-256 and ristretto255. See Section 7.2 for related discussion.",
      "ja": "各サイファースイートについて、contextString は Setup 関数で計算されるものです。アプリケーションは P-256 および ristretto255 を対象とするサイファースイートを使用する際に注意を払う必要があります。関連する議論についてはセクション 7.2 を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.1. OPRF(ristretto255, SHA-512)",
      "section_title": true,
      "ja": "4.1. OPRF(ristretto255、SHA-512)"
    },
    {
      "indent": 3,
      "text": "This ciphersuite uses ristretto255 [RFC9496] for the Group and SHA-512 for the hash function. The value of the ciphersuite identifier is \"ristretto255-SHA512\".",
      "ja": "このサイファースイートは、グループにristretto255 [RFC9496]を使用し、ハッシュ関数にSHA-512を使用しています。サイファースイート識別子の値は「ristretto255-SHA512」です。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ"
    },
    {
      "indent": 12,
      "text": "ristretto255 [RFC9496]",
      "ja": "ristretto255 [RFC9496]"
    },
    {
      "indent": 6,
      "text": "Order():",
      "ja": "Order():"
    },
    {
      "indent": 15,
      "text": "Return 2^252 + 27742317777372353535851937790883648493 (see [RFC9496]).",
      "ja": "2^252 + 27742317777372353535851937790883648493（[RFC9496]を参照）を返します。"
    },
    {
      "indent": 6,
      "text": "Identity():",
      "ja": "Identity():"
    },
    {
      "indent": 15,
      "text": "As defined in [RFC9496].",
      "ja": "[RFC9496] で定義されています。"
    },
    {
      "indent": 6,
      "text": "Generator():",
      "ja": "ジェネレーター():"
    },
    {
      "indent": 15,
      "text": "As defined in [RFC9496].",
      "ja": "[RFC9496] で定義されています。"
    },
    {
      "indent": 6,
      "text": "HashToGroup():",
      "ja": "HashToGroup():"
    },
    {
      "indent": 15,
      "text": "Use hash_to_ristretto255 [RFC9380] with DST = \"HashToGroup-\" || contextString and expand_message = expand_message_xmd using SHA-512.",
      "ja": "hash_to_ristretto255 [RFC9380] を、DST = \"HashToGroup-\" || contextString として使用し、expand_message = SHA-512 を使用して expand_message_xmd を展開します。"
    },
    {
      "indent": 6,
      "text": "HashToScalar():",
      "ja": "HashToScalar():"
    },
    {
      "indent": 15,
      "text": "Compute uniform_bytes using expand_message = expand_message_xmd, DST = \"HashToScalar-\" || contextString, and an output length of 64 bytes, interpret uniform_bytes as a 512-bit integer in little-endian order, and reduce the integer modulo Group.Order().",
      "ja": "uniform_bytesを計算する。expand_message = expand_message_xmd、DST = \"HashToScalar-\" || contextStringを使用し、出力長は64バイトとする。uniform_bytesをリトルエンディアン順の512ビット整数として解釈し、整数をGroup.Order()で割った余りとする。"
    },
    {
      "indent": 6,
      "text": "ScalarInverse(s):",
      "ja": "スカラー逆数(s):"
    },
    {
      "indent": 15,
      "text": "Returns the multiplicative inverse of input Scalar s mod Group.Order().",
      "ja": "入力スカラー s の乗法逆数を Group.Order() で割った余りを返します。"
    },
    {
      "indent": 6,
      "text": "RandomScalar():",
      "ja": "RandomScalar():"
    },
    {
      "indent": 15,
      "text": "Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Section 4.7 for implementation guidance.",
      "ja": "実装は、範囲[0、G.Order() - 1]内の一様ランダムなスカラーを返すことで行われます。実装のガイダンスについては、セクション4.7を参照してください。"
    },
    {
      "indent": 6,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement(A):"
    },
    {
      "indent": 15,
      "text": "Implemented using the Encode function from Section 4.3.2 of [RFC9496]; Ne = 32.",
      "ja": "[RFC9496]のセクション4.3.2からのEncode関数を使用して実装されました。Ne = 32。"
    },
    {
      "indent": 6,
      "text": "DeserializeElement(buf):",
      "ja": "DeserializeElement(buf):デシリアライズ要素(buf)"
    },
    {
      "indent": 15,
      "text": "Implemented using the Decode function from Section 4.3.1 of [RFC9496]. Additionally, this function validates that the resulting element is not the group identity element. If these checks fail, deserialization returns an InputValidationError error.",
      "ja": "[RFC9496]のセクション4.3.1からのDecode関数を使用して実装されています。さらに、この関数は、結果の要素がグループの単位元でないことを検証します。これらのチェックに失敗した場合、逆シリアル化はInputValidationErrorエラーを返します。"
    },
    {
      "indent": 6,
      "text": "SerializeScalar(s):",
      "ja": "SerializeScalar(s):"
    },
    {
      "indent": 15,
      "text": "Implemented by outputting the little-endian, 32-byte encoding of the Scalar value with the top three bits set to zero; Ns = 32.",
      "ja": "実装されたものは、スカラー値のリトルエンディアン、32バイトのエンコーディングを出力することです。上位3ビットをゼロに設定します。Ns = 32。"
    },
    {
      "indent": 6,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar(buf):"
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a Scalar from a little-endian, 32-byte string. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1]. Note that this means the top three bits of the input MUST be zero.",
      "ja": "この関数は、リトルエンディアン形式の32バイト文字列からScalarをデシリアライズしようとして実装されました。入力が[0、G.Order() - 1]の範囲内のScalarを表していない場合、この関数は失敗する可能性があります。入力の上位3ビットがゼロである必要があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Hash:",
      "ja": "ハッシュ:"
    },
    {
      "indent": 12,
      "text": "SHA-512; Nh = 64.",
      "ja": "SHA-512; Nh = 64."
    },
    {
      "indent": 0,
      "text": "4.2. OPRF(decaf448, SHAKE-256)",
      "section_title": true,
      "ja": "4.2. OPRF(decaf448、SHAKE-256)"
    },
    {
      "indent": 3,
      "text": "This ciphersuite uses decaf448 [RFC9496] for the Group and SHAKE-256 for the hash function. The value of the ciphersuite identifier is \"decaf448-SHAKE256\".",
      "ja": "このサイファースイートは、グループにdecaf448 [RFC9496]を使用し、ハッシュ関数にSHAKE-256を使用しています。サイファースイート識別子の値は「decaf448-SHAKE256」です。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ"
    },
    {
      "indent": 12,
      "text": "decaf448 [RFC9496]",
      "ja": "decaf448 [RFC9496]"
    },
    {
      "indent": 6,
      "text": "Order():",
      "ja": "Order():"
    },
    {
      "indent": 15,
      "text": "Return 2^446 - 13818066809895115352007386748515426880336 692474882178609894547503885.",
      "ja": "2^446 - 13818066809895115352007386748515426880336692474882178609894547503885."
    },
    {
      "indent": 6,
      "text": "Identity():",
      "ja": "Identity():"
    },
    {
      "indent": 15,
      "text": "As defined in [RFC9496].",
      "ja": "[RFC9496] で定義されています。"
    },
    {
      "indent": 6,
      "text": "Generator():",
      "ja": "ジェネレータ():"
    },
    {
      "indent": 15,
      "text": "As defined in [RFC9496].",
      "ja": "[RFC9496] で定義されています。"
    },
    {
      "indent": 6,
      "text": "RandomScalar():",
      "ja": "RandomScalar():"
    },
    {
      "indent": 15,
      "text": "Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Section 4.7 for implementation guidance.",
      "ja": "[0, G.Order() - 1] の範囲内で一様ランダムなスカラーを返すことで実装されます。実装の手引きについてはセクション4.7を参照してください。"
    },
    {
      "indent": 6,
      "text": "HashToGroup():",
      "ja": "HashToGroup():"
    },
    {
      "indent": 15,
      "text": "Use hash_to_decaf448 [RFC9380] with DST = \"HashToGroup-\" || contextString and expand_message = expand_message_xof using SHAKE-256.",
      "ja": "hash_to_decaf448 [RFC9380] を、DST = \"HashToGroup-\" || contextString として使用し、SHAKE-256 を使用して expand_message = expand_message_xof を展開します。"
    },
    {
      "indent": 6,
      "text": "HashToScalar():",
      "ja": "HashToScalar():"
    },
    {
      "indent": 15,
      "text": "Compute uniform_bytes using expand_message = expand_message_xof, DST = \"HashToScalar-\" || contextString, and output length 64, interpret uniform_bytes as a 512-bit integer in little-endian order, and reduce the integer modulo Group.Order().",
      "ja": "uniform_bytesを計算する。expand_message = expand_message_xof、DST = \"HashToScalar-\" || contextStringを使用し、出力長を64とする。uniform_bytesをリトルエンディアン順の512ビット整数として解釈し、整数をGroup.Order()で剰余を取る。"
    },
    {
      "indent": 6,
      "text": "ScalarInverse(s):",
      "ja": "スカラー逆数(s):"
    },
    {
      "indent": 15,
      "text": "Returns the multiplicative inverse of input Scalar s mod Group.Order().",
      "ja": "入力スカラー s の乗法逆数を Group.Order() で割った余りを返します。"
    },
    {
      "indent": 6,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement(A):"
    },
    {
      "indent": 15,
      "text": "Implemented using the Encode function from Section 5.3.2 of [RFC9496]; Ne = 56.",
      "ja": "[RFC9496]のセクション5.3.2からのEncode関数を使用して実装されました。Ne = 56。"
    },
    {
      "indent": 6,
      "text": "DeserializeElement(buf):",
      "ja": "DeserializeElement(buf):"
    },
    {
      "indent": 15,
      "text": "Implemented using the Decode function from Section 5.3.1 of [RFC9496]. Additionally, this function validates that the resulting element is not the group identity element. If these checks fail, deserialization returns an InputValidationError error.",
      "ja": "[RFC9496]のセクション5.3.1からのDecode関数を使用して実装されています。さらに、この関数は、結果の要素がグループの単位元でないことを検証します。これらのチェックに失敗した場合、逆シリアル化はInputValidationErrorエラーを返します。"
    },
    {
      "indent": 6,
      "text": "SerializeScalar(s):",
      "ja": "SerializeScalar(s):"
    },
    {
      "indent": 15,
      "text": "Implemented by outputting the little-endian, 56-byte encoding of the Scalar value; Ns = 56.",
      "ja": "実装されたスカラー値のリトルエンディアン、56バイトのエンコーディングを出力することによって。Ns = 56。"
    },
    {
      "indent": 6,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar(buf): \n\nバッファをデシリアライズします。"
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a Scalar from a little-endian, 56-byte string. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1].",
      "ja": "この関数は、リトルエンディアン形式の56バイトの文字列からScalarをデシリアライズしようとして実装されました。入力が[0、G.Order() - 1]の範囲内のScalarを表していない場合、この関数は失敗する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Hash:",
      "ja": "ハッシュ:"
    },
    {
      "indent": 12,
      "text": "SHAKE-256; Nh = 64.",
      "ja": "SHAKE-256; Nh = 64."
    },
    {
      "indent": 0,
      "text": "4.3. OPRF(P-256, SHA-256)",
      "section_title": true,
      "ja": "4.3. OPRF（P-256、SHA-256）"
    },
    {
      "indent": 3,
      "text": "This ciphersuite uses P-256 [NISTCurves] for the Group and SHA-256 for the hash function. The value of the ciphersuite identifier is \"P256-SHA256\".",
      "ja": "このサイファースイートは、グループにP-256 [NISTCurves]を使用し、ハッシュ関数にSHA-256を使用しています。サイファースイート識別子の値は「P256-SHA256」です。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ"
    },
    {
      "indent": 12,
      "text": "P-256 (secp256r1) [NISTCurves]",
      "ja": "P-256 (secp256r1) [NIST曲線]"
    },
    {
      "indent": 6,
      "text": "Order():",
      "ja": "Order():"
    },
    {
      "indent": 15,
      "text": "Return 0xffffffff00000000ffffffffffffffffbce6faada7179e8 4f3b9cac2fc632551.",
      "ja": "0xffffffff00000000ffffffffffffffffbce6faada7179e8 4f3b9cac2fc632551 を返します。"
    },
    {
      "indent": 6,
      "text": "Identity():",
      "ja": "Identity():"
    },
    {
      "indent": 15,
      "text": "As defined in [NISTCurves].",
      "ja": "[NISTCurves] で定義されています。"
    },
    {
      "indent": 6,
      "text": "Generator():",
      "ja": "ジェネレータ():"
    },
    {
      "indent": 15,
      "text": "As defined in [NISTCurves].",
      "ja": "[NISTCurves] で定義されています。"
    },
    {
      "indent": 6,
      "text": "RandomScalar():",
      "ja": "RandomScalar():"
    },
    {
      "indent": 15,
      "text": "Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Section 4.7 for implementation guidance.",
      "ja": "[0、G.Order（）-1]の範囲で一様ランダムなスカラーを返すことによって実装されます。実装のガイダンスについては、セクション4.7を参照してください。"
    },
    {
      "indent": 6,
      "text": "HashToGroup():",
      "ja": "HashToGroup():"
    },
    {
      "indent": 15,
      "text": "Use hash_to_curve with suite P256_XMD:SHA-256_SSWU_RO_ [RFC9380] and DST = \"HashToGroup-\" || contextString.",
      "ja": "\"HashToGroup-\" || contextString という DST を使用して、P256_XMD:SHA-256_SSWU_RO_ [RFC9380] スイートを使って hash_to_curve を使用してください。"
    },
    {
      "indent": 6,
      "text": "HashToScalar():",
      "ja": "HashToScalar():"
    },
    {
      "indent": 15,
      "text": "Use hash_to_field from [RFC9380] using L = 48, expand_message_xmd with SHA-256, DST = \"HashToScalar-\" || contextString, and a prime modulus equal to Group.Order().",
      "ja": "[RFC9380]のhash_to_fieldを使用し、L = 48、SHA-256を使用したexpand_message_xmd、DST = \"HashToScalar-\" || contextString、およびGroup.Order()と等しい素数モジュラスを使用してください。"
    },
    {
      "indent": 6,
      "text": "ScalarInverse(s):",
      "ja": "スカラー逆数(s):"
    },
    {
      "indent": 15,
      "text": "Returns the multiplicative inverse of input Scalar s mod Group.Order().",
      "ja": "入力スカラー s の乗法逆数を Group.Order() で割った余りを返します。"
    },
    {
      "indent": 6,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement(A):"
    },
    {
      "indent": 15,
      "text": "Implemented using the compressed Elliptic-Curve-Point-to-Octet-String method according to [SEC1]; Ne = 33.",
      "ja": "[SEC1] に従って、圧縮楕円曲線ポイントからオクテット文字列への方法を使用して実装されました。 Ne = 33."
    },
    {
      "indent": 6,
      "text": "DeserializeElement(buf):",
      "ja": "DeserializeElement(buf):"
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a 33-byte input string to a public key using the compressed Octet-String-to-Elliptic-Curve-Point method according to [SEC1] and then performing partial public-key validation, as defined in Section 5.6.2.3.4 of [KEYAGREEMENT]. This includes checking that the coordinates of the resulting point are in the correct range, that the point is on the curve, and that the point is not the group identity element. If these checks fail, deserialization returns an InputValidationError error.",
      "ja": "[SEC1] に従い、圧縮されたオクテット文字列から楕円曲線上の点に逆シリアル化することで、33バイトの入力文字列を公開鍵に変換し、[KEYAGREEMENT] のセクション5.6.2.3.4で定義された部分的な公開鍵の検証を行います。これには、結果の点の座標が正しい範囲内にあること、点が曲線上にあること、点が群の単位元でないことを確認することが含まれます。これらのチェックに失敗した場合、逆シリアル化は InputValidationError エラーを返します。"
    },
    {
      "indent": 6,
      "text": "SerializeScalar(s):",
      "ja": "SerializeScalar(s):"
    },
    {
      "indent": 15,
      "text": "Implemented using the Field-Element-to-Octet-String conversion according to [SEC1]; Ns = 32.",
      "ja": "[SEC1] に従って実装された Field-Element-to-Octet-String 変換を使用します。Ns = 32。"
    },
    {
      "indent": 6,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar(buf):"
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a Scalar from a 32-byte string using Octet-String-to-Field-Element from [SEC1]. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1].",
      "ja": "[SEC1]を使用して、32バイトの文字列からScalarをデシリアライズしようとしました。この関数は、入力が範囲[0、G.Order() - 1]内のScalarを表していない場合に失敗する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Hash:",
      "ja": "ハッシュ:"
    },
    {
      "indent": 12,
      "text": "SHA-256; Nh = 32.",
      "ja": "SHA-256; Nh = 32."
    },
    {
      "indent": 0,
      "text": "4.4. OPRF(P-384, SHA-384)",
      "section_title": true,
      "ja": "4.4. OPRF（P-384、SHA-384）"
    },
    {
      "indent": 3,
      "text": "This ciphersuite uses P-384 [NISTCurves] for the Group and SHA-384 for the hash function. The value of the ciphersuite identifier is \"P384-SHA384\".",
      "ja": "このサイファースイートは、グループにP-384 [NISTCurves]を使用し、ハッシュ関数にSHA-384を使用しています。サイファースイート識別子の値は「P384-SHA384」です。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ"
    },
    {
      "indent": 12,
      "text": "P-384 (secp384r1) [NISTCurves]",
      "ja": "P-384 (secp384r1) [NISTCurves]"
    },
    {
      "indent": 6,
      "text": "Order():",
      "ja": "Order():"
    },
    {
      "indent": 15,
      "text": "Return 0xfffffffffffffffffffffffffffffffffffffffffffffff fc7634d81f4372ddf581a0db248b0a77aecec196accc52973.",
      "ja": "0xfffffffffffffffffffffffffffffffffffffffffffffff fc7634d81f4372ddf581a0db248b0a77aecec196accc52973 を返します。"
    },
    {
      "indent": 6,
      "text": "Identity():",
      "ja": "Identity():"
    },
    {
      "indent": 15,
      "text": "As defined in [NISTCurves].",
      "ja": "[NISTCurves] で定義されています。"
    },
    {
      "indent": 6,
      "text": "Generator():",
      "ja": "Generator():"
    },
    {
      "indent": 15,
      "text": "As defined in [NISTCurves].",
      "ja": "[NISTCurves] で定義されています。"
    },
    {
      "indent": 6,
      "text": "RandomScalar():",
      "ja": "RandomScalar():"
    },
    {
      "indent": 15,
      "text": "Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Section 4.7 for implementation guidance.",
      "ja": "[0, G.Order() - 1] の範囲内で一様ランダムなスカラーを返すことで実装されます。実装の手引きについてはセクション4.7を参照してください。"
    },
    {
      "indent": 6,
      "text": "HashToGroup():",
      "ja": "HashToGroup():"
    },
    {
      "indent": 15,
      "text": "Use hash_to_curve with suite P384_XMD:SHA-384_SSWU_RO_ [RFC9380] and DST = \"HashToGroup-\" || contextString.",
      "ja": "\"HashToGroup-\" || contextString という DST を使用して、suite P384_XMD:SHA-384_SSWU_RO_ [RFC9380] を使って hash_to_curve を使用してください。"
    },
    {
      "indent": 6,
      "text": "HashToScalar():",
      "ja": "HashToScalar():"
    },
    {
      "indent": 15,
      "text": "Use hash_to_field from [RFC9380] using L = 72, expand_message_xmd with SHA-384, DST = \"HashToScalar-\" || contextString, and a prime modulus equal to Group.Order().",
      "ja": "[RFC9380]のhash_to_fieldを使用し、L = 72、SHA-384を使用したexpand_message_xmd、DST = \"HashToScalar-\" || contextString、およびGroup.Order()と等しい素数モジュラスを使用してください。"
    },
    {
      "indent": 6,
      "text": "ScalarInverse(s):",
      "ja": "スカラー逆数(s):"
    },
    {
      "indent": 15,
      "text": "Returns the multiplicative inverse of input Scalar s mod Group.Order().",
      "ja": "入力スカラー s の乗法逆数を Group.Order() で割った余りを返します。"
    },
    {
      "indent": 6,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement(A):"
    },
    {
      "indent": 15,
      "text": "Implemented using the compressed Elliptic-Curve-Point-to-Octet-String method according to [SEC1]; Ne = 49.",
      "ja": "[SEC1] に従って、圧縮楕円曲線ポイントからオクテット文字列への方法を使用して実装されました。Ne = 49。"
    },
    {
      "indent": 6,
      "text": "DeserializeElement(buf):",
      "ja": "DeserializeElement(buf): \n\nDeserializeElement(buf)を実行します。"
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a 49-byte array to a public key using the compressed Octet-String-to-Elliptic-Curve-Point method according to [SEC1] and then performing partial public-key validation, as defined in Section 5.6.2.3.4 of [KEYAGREEMENT]. This includes checking that the coordinates of the resulting point are in the correct range, that the point is on the curve, and that the point is not the point at infinity. Additionally, this function validates that the resulting element is not the group identity element. If these checks fail, deserialization returns an InputValidationError error.",
      "ja": "[SEC1] に従い、圧縮されたオクテット文字列から楕円曲線上の点に逆シリアル化することで、49バイトの配列を公開鍵に変換し、[KEYAGREEMENT] のセクション5.6.2.3.4で定義された部分的な公開鍵の検証を行います。これには、結果の点の座標が正しい範囲内にあること、点が曲線上にあること、点が無限遠点でないことを確認することが含まれます。さらに、この関数は、結果の要素が群の単位元でないことを検証します。これらのチェックに失敗した場合、逆シリアル化は InputValidationError エラーを返します。"
    },
    {
      "indent": 6,
      "text": "SerializeScalar(s):",
      "ja": "SerializeScalar(s):"
    },
    {
      "indent": 15,
      "text": "Implemented using the Field-Element-to-Octet-String conversion according to [SEC1]; Ns = 48.",
      "ja": "[SEC1] に従って実装された Field-Element-to-Octet-String 変換を使用して実装されました。Ns = 48。"
    },
    {
      "indent": 6,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar(buf): \n\nバッファをデシリアライズします。"
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a Scalar from a 48-byte string using Octet-String-to-Field-Element from [SEC1]. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1].",
      "ja": "[SEC1]を使用して、48バイトの文字列からScalarをデシリアライズしようとして実装されました。この関数は、入力が範囲[0、G.Order() - 1]内のScalarを表していない場合に失敗する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Hash:",
      "ja": "ハッシュ:"
    },
    {
      "indent": 12,
      "text": "SHA-384; Nh = 48.",
      "ja": "SHA-384; Nh = 48."
    },
    {
      "indent": 0,
      "text": "4.5. OPRF(P-521, SHA-512)",
      "section_title": true,
      "ja": "4.5. OPRF(P-521、SHA-512)"
    },
    {
      "indent": 3,
      "text": "This ciphersuite uses P-521 [NISTCurves] for the Group and SHA-512 for the hash function. The value of the ciphersuite identifier is \"P521-SHA512\".",
      "ja": "このサイファースイートは、グループにP-521[NISTCurves]を使用し、ハッシュ関数にSHA-512を使用しています。サイファースイート識別子の値は「P521-SHA512」です。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ"
    },
    {
      "indent": 12,
      "text": "P-521 (secp521r1) [NISTCurves]",
      "ja": "P-521 (secp521r1) [NISTCurves]"
    },
    {
      "indent": 6,
      "text": "Order():",
      "ja": "Order():"
    },
    {
      "indent": 15,
      "text": "Return 0x01fffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b889 9c47aebb6fb71e91386409.",
      "ja": "0x01fffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b889 9c47aebb6fb71e91386409."
    },
    {
      "indent": 6,
      "text": "Identity():",
      "ja": "Identity():"
    },
    {
      "indent": 15,
      "text": "As defined in [NISTCurves].",
      "ja": "[NISTCurves] で定義されています。"
    },
    {
      "indent": 6,
      "text": "Generator():",
      "ja": "Generator():"
    },
    {
      "indent": 15,
      "text": "As defined in [NISTCurves].",
      "ja": "[NISTCurves] で定義されています。"
    },
    {
      "indent": 6,
      "text": "RandomScalar():",
      "ja": "RandomScalar():"
    },
    {
      "indent": 15,
      "text": "Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Section 4.7 for implementation guidance.",
      "ja": "[0, G.Order() - 1] の範囲内で一様ランダムなスカラーを返すことで実装されます。実装の手引きについてはセクション4.7を参照してください。"
    },
    {
      "indent": 6,
      "text": "HashToGroup():",
      "ja": "HashToGroup():"
    },
    {
      "indent": 15,
      "text": "Use hash_to_curve with suite P521_XMD:SHA-512_SSWU_RO_ [RFC9380] and DST = \"HashToGroup-\" || contextString.",
      "ja": "\"HashToGroup-\" || contextString という DST を使用して、suite P521_XMD:SHA-512_SSWU_RO_ [RFC9380] を使って hash_to_curve を使用してください。"
    },
    {
      "indent": 6,
      "text": "HashToScalar():",
      "ja": "HashToScalar():"
    },
    {
      "indent": 15,
      "text": "Use hash_to_field from [RFC9380] using L = 98, expand_message_xmd with SHA-512, DST = \"HashToScalar-\" || contextString, and a prime modulus equal to Group.Order().",
      "ja": "[RFC9380]のhash_to_fieldを使用し、L = 98、SHA-512を使用したexpand_message_xmd、DST = \"HashToScalar-\" || contextString、および素数モジュラスがGroup.Order()と等しい場合。"
    },
    {
      "indent": 6,
      "text": "ScalarInverse(s):",
      "ja": "スカラー逆数(s):"
    },
    {
      "indent": 15,
      "text": "Returns the multiplicative inverse of input Scalar s mod Group.Order().",
      "ja": "入力スカラー s の乗法逆数を Group.Order() で割った余りを返します。"
    },
    {
      "indent": 6,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement(A):"
    },
    {
      "indent": 15,
      "text": "Implemented using the compressed Elliptic-Curve-Point-to-Octet-String method according to [SEC1]; Ne = 67.",
      "ja": "[SEC1] に従って、圧縮楕円曲線ポイントからオクテット文字列への方法を使用して実装されました。Ne = 67。"
    },
    {
      "indent": 6,
      "text": "DeserializeElement(buf):",
      "ja": "DeserializeElement(buf):"
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a 67-byte input string to a public key using the compressed Octet-String-to-Elliptic-Curve-Point method according to [SEC1] and then performing partial public-key validation, as defined in Section 5.6.2.3.4 of [KEYAGREEMENT]. This includes checking that the coordinates of the resulting point are in the correct range, that the point is on the curve, and that the point is not the point at infinity. Additionally, this function validates that the resulting element is not the group identity element. If these checks fail, deserialization returns an InputValidationError error.",
      "ja": "[SEC1] に従い、圧縮されたオクテット文字列を楕円曲線ポイントに逆シリアル化することで、67バイトの入力文字列を公開鍵に変換し、[KEYAGREEMENT] のセクション5.6.2.3.4で定義された部分的な公開鍵の検証を行います。これには、結果のポイントの座標が正しい範囲内にあること、ポイントが曲線上にあること、ポイントが無限のポイントでないことを確認することが含まれます。さらに、この関数は、結果の要素がグループの単位元でないことを検証します。これらのチェックに失敗した場合、逆シリアル化は InputValidationError エラーを返します。"
    },
    {
      "indent": 6,
      "text": "SerializeScalar(s):",
      "ja": "SerializeScalar(s):"
    },
    {
      "indent": 15,
      "text": "Implemented using the Field-Element-to-Octet-String conversion according to [SEC1]; Ns = 66.",
      "ja": "[SEC1] に従って実装された Field-Element-to-Octet-String 変換を使用して実装されました。Ns = 66。"
    },
    {
      "indent": 6,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar(buf): \n\nスカラーをデシリアライズします。"
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a Scalar from a 66-byte string using Octet-String-to-Field-Element from [SEC1]. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1].",
      "ja": "[SEC1]を使用して、66バイトの文字列からScalarをデシリアライズしようとしました。入力が[0、G.Order() - 1]の範囲内のScalarを表していない場合、この関数は失敗する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Hash:",
      "ja": "ハッシュ:"
    },
    {
      "indent": 12,
      "text": "SHA-512; Nh = 64.",
      "ja": "SHA-512; Nh = 64."
    },
    {
      "indent": 0,
      "text": "4.6. Future Ciphersuites",
      "section_title": true,
      "ja": "4.6. 将来の暗号スイート"
    },
    {
      "indent": 3,
      "text": "A critical requirement of implementing the prime-order group using elliptic curves is a method to instantiate the function HashToGroup, which maps inputs to group elements. In the elliptic curve setting, this deterministically maps inputs (as byte arrays) to uniformly chosen points on the curve.",
      "ja": "楕円曲線を使用して素数位数群を実装する際の重要な要件は、関数HashToGroupをインスタンス化する方法です。この関数は、入力を群の要素にマッピングします。楕円曲線の設定では、これにより入力（バイト配列として）が曲線上で一様に選択された点にマッピングされます。"
    },
    {
      "indent": 3,
      "text": "In the security proof of the construction, Hash is modeled as a random oracle. This implies that any instantiation of HashToGroup must be pre-image and collision resistant. In Section 4, we give instantiations of this functionality based on the functions described in [RFC9380]. Consequently, any OPRF implementation must adhere to the implementation and security considerations discussed in [RFC9380] when instantiating the function.",
      "ja": "この構築のセキュリティ証明では、ハッシュはランダムオラクルとしてモデル化されています。これは、HashToGroupの任意の具体化は、逆像および衝突耐性である必要があることを意味します。セクション4では、[RFC9380]で説明された関数に基づいて、この機能の具体化を提供しています。したがって、OPRFの実装は、関数を具体化する際に[RFC9380]で議論された実装およびセキュリティに関する考慮事項に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The DeserializeElement and DeserializeScalar functions instantiated for a particular prime-order group corresponding to a ciphersuite MUST adhere to the description in Section 2.1. Future ciphersuites MUST describe how input validation is done for DeserializeElement and DeserializeScalar.",
      "ja": "特定の素数位数群に対応するDeserializeElementおよびDeserializeScalar関数は、セクション2.1の説明に従う必要があります。将来の暗号スイートは、DeserializeElementおよびDeserializeScalarの入力検証方法を記述する必要があります。"
    },
    {
      "indent": 3,
      "text": "Additionally, future ciphersuites must take care when choosing the security level of the group. See Section 7.2.3 for additional details.",
      "ja": "さらに、将来のサイファースイートは、グループのセキュリティレベルを選択する際に注意を払う必要があります。詳細については、セクション7.2.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.7. Random Scalar Generation",
      "section_title": true,
      "ja": "4.7. ランダムスカラー生成"
    },
    {
      "indent": 3,
      "text": "Two popular algorithms for generating a random integer uniformly distributed in the range [0, G.Order() - 1] are described in the following subsections.",
      "ja": "[0, G.Order() - 1] の範囲で一様分布のランダム整数を生成するための2つの人気のアルゴリズムが、以下のサブセクションで説明されています。"
    },
    {
      "indent": 0,
      "text": "4.7.1. Rejection Sampling",
      "section_title": true,
      "ja": "4.7.1. 拒絶サンプリング"
    },
    {
      "indent": 3,
      "text": "Generate a random byte array with Ns bytes and attempt to map to a Scalar by calling DeserializeScalar in constant time. If it succeeds, return the result. If it fails, try again with another random byte array until the procedure succeeds. Failure to implement DeserializeScalar in constant time can leak information about the underlying corresponding Scalar.",
      "ja": "指定されたバイト数のランダムなバイト配列を生成し、DeserializeScalar を呼び出してスカラーにマップしようとします。成功した場合は結果を返します。失敗した場合は、別のランダムなバイト配列で再試行します。DeserializeScalar を一定時間で実装できないと、対応するスカラーに関する情報が漏洩する可能性があります。"
    },
    {
      "indent": 3,
      "text": "As an optimization, if the group order is very close to a power of 2, it is acceptable to omit the rejection test completely. In particular, if the group order is p and there is an integer b such that |p - 2^b| is less than 2^(b/2), then RandomScalar can simply return a uniformly random integer of at most b bits.",
      "ja": "最適化として、グループの順序が2の累乗に非常に近い場合、拒否テストを完全に省略しても構いません。特に、グループの順序がpで、整数bが存在し、|p - 2^b|が2^(b/2)未満である場合、RandomScalarは単純に最大bビットの一様ランダムな整数を返すことができます。"
    },
    {
      "indent": 0,
      "text": "4.7.2. Random Number Generation Using Extra Random Bits",
      "section_title": true,
      "ja": "4.7.2. 余分なランダムビットを使用した乱数生成"
    },
    {
      "indent": 3,
      "text": "Generate a random byte array with L = ceil(((3 * ceil(log2(G.Order()))) / 2) / 8) bytes, and interpret it as an integer; reduce the integer modulo G.Order(), and return the result. See [RFC9380], Section 5 for the underlying derivation of L.",
      "ja": "英語のまま出力します。"
    },
    {
      "indent": 0,
      "text": "5. Application Considerations",
      "section_title": true,
      "ja": "5. アプリケーションの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section describes considerations for applications, including external interface recommendations, explicit error treatment, and public input representation for the POPRF protocol variant.",
      "ja": "このセクションでは、アプリケーションに関する考慮事項、外部インターフェースの推奨事項、明示的なエラー処理、POPRFプロトコルの変種に対する公開入力表現について説明します。"
    },
    {
      "indent": 0,
      "text": "5.1. Input Limits",
      "section_title": true,
      "ja": "5.1. 入力制限"
    },
    {
      "indent": 3,
      "text": "Application inputs, expressed as PrivateInput or PublicInput values, MUST be smaller than 2^16 - 1 bytes in length. Applications that require longer inputs can use a cryptographic hash function to map these longer inputs to a fixed-length input that fits within the PublicInput or PrivateInput length bounds. Note that some cryptographic hash functions have input length restrictions themselves, but these limits are often large enough to not be a concern in practice. For example, SHA-256 has an input limit of 2^61 bytes.",
      "ja": "アプリケーションの入力は、PrivateInputまたはPublicInputの値として表され、2^16 - 1バイトよりも短くする必要があります。より長い入力が必要なアプリケーションは、これらの長い入力をPublicInputまたはPrivateInputの長さの制限内に収まる固定長の入力にマップするために暗号ハッシュ関数を使用できます。一部の暗号ハッシュ関数には入力長の制限がありますが、これらの制限は実際には問題にならないほど大きいことが多いです。例えば、SHA-256は2^61バイトの入力制限があります。"
    },
    {
      "indent": 0,
      "text": "5.2. External Interface Recommendations",
      "section_title": true,
      "ja": "5.2. 外部インターフェースの推奨事項"
    },
    {
      "indent": 3,
      "text": "In Section 3.3, the interface of the protocol functions allows that some inputs (and outputs) to be group Element and Scalar values. However, implementations can instead operate over Element and Scalar values internally and only expose interfaces that operate with an application-specific format of messages.",
      "ja": "セクション3.3では、プロトコル関数のインターフェースが、一部の入力（および出力）をグループ要素とスカラー値にすることを許可しています。ただし、実装は代わりに内部で要素とスカラー値を操作し、アプリケーション固有のメッセージ形式で操作するインターフェースのみを公開することができます。"
    },
    {
      "indent": 0,
      "text": "5.3. Error Considerations",
      "section_title": true,
      "ja": "5.3. エラーの考慮"
    },
    {
      "indent": 3,
      "text": "Some OPRF variants specified in this document have fallible operations. For example, Finalize and BlindEvaluate can fail if any element received from the peer fails input validation. The explicit errors generated throughout this specification, along with the conditions that lead to each error, are as follows:",
      "ja": "この文書で指定されているいくつかのOPRFのバリアントには、失敗する可能性のある操作があります。たとえば、FinalizeとBlindEvaluateは、ピアから受信した要素のいずれかが入力検証に失敗した場合に失敗する可能性があります。この仕様書全体で生成される明示的なエラーと、それぞれのエラーにつながる条件は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "VerifyError:",
      "ja": "VerifyError:"
    },
    {
      "indent": 12,
      "text": "Verifiable OPRF proof verification failed (Sections 3.3.2 and 3.3.3).",
      "ja": "検証可能なOPRFプルーフの検証に失敗しました（セクション3.3.2および3.3.3）。"
    },
    {
      "indent": 3,
      "text": "DeserializeError:",
      "ja": "デシリアライズエラー:"
    },
    {
      "indent": 12,
      "text": "Group Element or Scalar deserialization failure (Sections 2.1 and 3.3).",
      "ja": "グループ要素またはスカラーの逆シリアル化の失敗（セクション2.1および3.3）。"
    },
    {
      "indent": 3,
      "text": "InputValidationError:",
      "ja": "InputValidationError:"
    },
    {
      "indent": 12,
      "text": "Validation of byte array inputs failed (Section 4).",
      "ja": "バイト配列入力の検証に失敗しました（セクション4）。"
    },
    {
      "indent": 3,
      "text": "There are other explicit errors generated in this specification; however, they occur with negligible probability in practice. We note them here for completeness.",
      "ja": "この仕様書には他にも明白なエラーが生成されますが、実際には無視できる確率で発生します。完全を期すためにここに記載しておきます。"
    },
    {
      "indent": 3,
      "text": "InvalidInputError:",
      "ja": "InvalidInputError:"
    },
    {
      "indent": 12,
      "text": "OPRF Blind input produces an invalid output element (Sections 3.3.1 and 3.3.3).",
      "ja": "OPRF Blind input produces an invalid output element (Sections 3.3.1 and 3.3.3)."
    },
    {
      "indent": 3,
      "text": "InverseError:",
      "ja": "InverseError:"
    },
    {
      "indent": 12,
      "text": "A tweaked private key is invalid, i.e., has no multiplicative inverse (Sections 2.1 and 3.3).",
      "ja": "調整された秘密鍵は無効です、つまり、乗法逆数がありません（セクション2.1および3.3）。"
    },
    {
      "indent": 3,
      "text": "In general, the errors in this document are meant as a guide to implementors. They are not an exhaustive list of all the errors an implementation might emit. For example, implementations might run out of memory and return a corresponding error.",
      "ja": "このドキュメントのエラーは、実装者のガイドとして意図されています。すべての実装が発生する可能性のあるエラーの網羅的なリストではありません。たとえば、実装がメモリ不足になり、対応するエラーを返すことがあります。"
    },
    {
      "indent": 0,
      "text": "5.4. POPRF Public Input",
      "section_title": true,
      "ja": "5.4. POPRF パブリック入力"
    },
    {
      "indent": 3,
      "text": "Functionally, the VOPRF and POPRF variants differ in that the POPRF variant admits public input, whereas the VOPRF variant does not. Public input allows clients and servers to cryptographically bind additional data to the POPRF output. A POPRF with fixed public input is functionally equivalent to a VOPRF. However, there are differences in the underlying security assumptions made about each variant; see Section 7.2 for more details.",
      "ja": "VOPRFとPOPRFのバリアントは、POPRFバリアントが公開入力を許可する一方、VOPRFバリアントは許可しないという点で機能的に異なります。公開入力により、クライアントとサーバーは追加データをPOPRFの出力に暗号的にバインドすることができます。固定された公開入力を持つPOPRFは、機能的にはVOPRFと同等です。ただし、各バリアントについての基礎となるセキュリティの仮定には違いがあります。詳細についてはセクション7.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "This public input is known to both parties at the start of the protocol. It is RECOMMENDED that this public input be constructed with some type of higher-level domain separation to avoid cross protocol attacks or related issues. For example, protocols using this construction might ensure that the public input uses a unique, prefix-free encoding. See [RFC9380], Section 10.4 for further discussion on constructing domain separation values.",
      "ja": "この公開入力はプロトコルの開始時に両当事者に知られています。この公開入力は、クロスプロトコル攻撃や関連する問題を避けるために、ある種の高レベルのドメイン分離を使用して構築されることが推奨されます。たとえば、この構築を使用するプロトコルは、公開入力が一意の接頭辞フリーエンコーディングを使用することを確認するかもしれません。ドメイン分離値の構築に関する詳細な議論については、[RFC9380]、セクション10.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "Implementations of the POPRF may choose to not let applications control info in cases where this value is fixed or otherwise not useful to the application. In this case, the resulting protocol is functionally equivalent to the VOPRF, which does not admit public input.",
      "ja": "POPFRの実装は、この値が固定されているか、アプリケーションにとって有用でない場合、アプリケーションが情報を制御することを許可しないことを選択することがあります。この場合、得られるプロトコルは、パブリック入力を許可しないVOPRFと機能的に等価です。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "この文書にはIANAのアクションはありません。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This section discusses the security of the protocols defined in this specification, along with some suggestions and trade-offs that arise from the implementation of the protocol variants in this document. Note that the syntax of the POPRF variant is different from that of the OPRF and VOPRF variants since it admits an additional public input, but the same security considerations apply.",
      "ja": "このセクションでは、この仕様で定義されたプロトコルのセキュリティについて、この文書のプロトコルのバリエーションの実装から生じるいくつかの提案とトレードオフについて議論します。POPFRバリアントの構文はOPRFおよびVOPRFバリアントと異なるため、追加の公開入力を許容しますが、同じセキュリティ上の考慮事項が適用されます。"
    },
    {
      "indent": 0,
      "text": "7.1. Security Properties",
      "section_title": true,
      "ja": "7.1. セキュリティプロパティ"
    },
    {
      "indent": 3,
      "text": "The security properties of an OPRF protocol with functionality y = F(k, x) include those of a standard PRF. Specifically:",
      "ja": "OPRFプロトコルのセキュリティ特性には、標準的なPRFの特性が含まれます。具体的には："
    },
    {
      "indent": 3,
      "text": "Pseudorandomness:",
      "ja": "疑似乱数性:"
    },
    {
      "indent": 12,
      "text": "For a random sampling of k, F is pseudorandom if the output y = F(k, x) on any input x is indistinguishable from uniformly sampling any element in F's range.",
      "ja": "ランダムサンプリングのためのkに対して、Fが疑似ランダムである場合、任意の入力xに対する出力y = F(k, x)がFの範囲内の要素を一様にサンプリングすることと区別できない。"
    },
    {
      "indent": 3,
      "text": "In other words, consider an adversary that picks inputs x from the domain of F and evaluates F on (k, x) (without knowledge of randomly sampled k). Then, the output distribution F(k, x) is indistinguishable from the output distribution of a randomly chosen function with the same domain and range.",
      "ja": "言い換えると、Fの定義域から入力xを選択し、(k, x)に対してFを評価する敵対者を考えます（ランダムに選択されたkの知識なしで）。その後、出力分布F(k, x)は、同じ定義域と値域を持つランダムに選択された関数の出力分布と区別できないものとなります。"
    },
    {
      "indent": 3,
      "text": "A consequence of showing that a function is pseudorandom is that it is necessarily nonmalleable (i.e., we cannot compute a new evaluation of F from an existing evaluation). A genuinely random function will be nonmalleable with high probability, so a pseudorandom function must be nonmalleable to maintain indistinguishability.",
      "ja": "擬似ランダム関数を示す結果としての結果は、それが必然的に非可変性であることです（つまり、既存の評価から新しい評価を計算することはできません）。真にランダムな関数は高い確率で非可変性であり、したがって、擬似ランダム関数は区別不可能性を維持するために非可変でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Unconditional input secrecy:",
      "ja": "Unconditional input secrecy: 無条件の入力秘匿"
    },
    {
      "indent": 12,
      "text": "The server does not learn anything about the client input x, even with unbounded computation.",
      "ja": "サーバーは、クライアントの入力xについて何も学習しません。計算が無制限であっても。"
    },
    {
      "indent": 3,
      "text": "In other words, an attacker with infinite computing power cannot recover any information about the client's private input x from an invocation of the protocol.",
      "ja": "言い換えると、無限の計算能力を持つ攻撃者は、プロトコルの呼び出しからクライアントの秘密入力xに関する情報を回復することはできません。"
    },
    {
      "indent": 3,
      "text": "Essentially, input secrecy is the property that, even if the server learns the client's private input x at some point in the future, the server cannot link any particular PRF evaluation to x. This property is also known as unlinkability [DGSTV18].",
      "ja": "基本的に、入力の秘匿性とは、将来のある時点でサーバーがクライアントの秘密の入力xを知っても、サーバーがxを特定のPRF評価にリンクすることができない性質です。この性質はunlinkabilityとしても知られています。"
    },
    {
      "indent": 3,
      "text": "Beyond client input secrecy, in the OPRF protocol, the server learns nothing about the output y of the function, nor does the client learn anything about the server's private key k.",
      "ja": "クライアントの入力の秘密保持を超えて、OPRFプロトコルでは、サーバーは関数の出力yについて何も学びませんし、クライアントもサーバーの秘密鍵kについて何も学びません。"
    },
    {
      "indent": 3,
      "text": "For the VOPRF and POPRF protocol variants, there is an additional security property:",
      "ja": "VOPRFおよびPOPRFプロトコルのバリアントには、追加のセキュリティプロパティがあります。"
    },
    {
      "indent": 3,
      "text": "Verifiable:",
      "ja": "検証可能"
    },
    {
      "indent": 12,
      "text": "The client must only complete execution of the protocol if it can successfully assert that the output it computes is correct. This is taken with respect to the private key held by the server.",
      "ja": "クライアントは、計算した出力が正しいことを確実に主張できる場合にのみ、プロトコルの実行を完了する必要があります。これは、サーバーが保持している秘密鍵に関連しています。"
    },
    {
      "indent": 3,
      "text": "Any VOPRF or POPRF that satisfies the 'verifiable' security property is known as 'verifiable'. In practice, the notion of verifiability requires that the server commits to the key before the actual protocol execution takes place. Then, the client verifies that the server has used the key in the protocol using this commitment. In the following, we may also refer to this commitment as a public key.",
      "ja": "'Verifiable'セキュリティプロパティを満たす任意のVOPRFまたはPOPRFは、「検証可能」として知られています。実際には、検証可能性の概念は、実際のプロトコル実行が行われる前にサーバーが鍵にコミットすることを要求します。その後、クライアントは、このコミットメントを使用してサーバーがプロトコルで鍵を使用したことを検証します。以下では、このコミットメントを公開鍵とも呼ぶことがあります。"
    },
    {
      "indent": 3,
      "text": "Finally, the POPRF variant also has the following security property:",
      "ja": "最後に、POPRF変種には以下のセキュリティプロパティもあります。"
    },
    {
      "indent": 3,
      "text": "Partial obliviousness:",
      "ja": "部分的な無自覚:"
    },
    {
      "indent": 12,
      "text": "The client and server must be able to perform the PRF on the client's private and public input. Both the client and server know the public input, but similar to the OPRF and VOPRF protocols, the server learns nothing about the client's private input or the output of the function, and the client learns nothing about the server's private key.",
      "ja": "クライアントとサーバーは、クライアントの秘密入力と公開入力に対してPRFを実行できる必要があります。クライアントとサーバーは両方とも公開入力を知っていますが、OPRFとVOPRFプロトコルと同様に、サーバーはクライアントの秘密入力や関数の出力について何も学びません。また、クライアントはサーバーの秘密鍵について何も学びません。"
    },
    {
      "indent": 3,
      "text": "This property becomes useful when dealing with key management operations, such as the rotation of the server's keys. Note that partial obliviousness only applies to the POPRF variant because neither the OPRF nor VOPRF variants accept public input to the protocol.",
      "ja": "この特性は、サーバーの鍵のローテーションなどのキー管理操作を扱う際に役立ちます。部分的な無関心は、OPRFバリアントにのみ適用されることに注意してください。なぜなら、OPRFバリアントもVOPRFバリアントもプロトコルに公開入力を受け入れないからです。"
    },
    {
      "indent": 3,
      "text": "Since the POPRF variant has a different syntax than the OPRF and VOPRF variants, i.e., y = F(k, x, info), the pseudorandomness property is generalized:",
      "ja": "POPFRバリアントは、OPRFおよびVOPRFバリアントとは異なる構文を持つため、擬似ランダム性の性質が一般化されます。"
    },
    {
      "indent": 3,
      "text": "Pseudorandomness:",
      "ja": "疑似乱数性:"
    },
    {
      "indent": 12,
      "text": "For a random sampling of k, F is pseudorandom if the output y = F(k, x, info) on any input pairs (x, info) is indistinguishable from uniformly sampling any element in F's range.",
      "ja": "ランダムサンプリングのためのkに対して、Fが疑似ランダムである場合、任意の入力ペア（x、info）に対する出力y = F(k, x, info)が、Fの範囲内の要素を一様にサンプリングすることと区別できない場合。"
    },
    {
      "indent": 0,
      "text": "7.2. Security Assumptions",
      "section_title": true,
      "ja": "7.2. セキュリティの前提条件"
    },
    {
      "indent": 3,
      "text": "Below, we discuss the cryptographic security of each protocol variant from Section 3, relative to the necessary cryptographic assumptions that need to be made.",
      "ja": "以下、セクション3の各プロトコルバリアントの暗号セキュリティについて、必要な暗号学的仮定に関して議論します。"
    },
    {
      "indent": 0,
      "text": "7.2.1. OPRF and VOPRF Assumptions",
      "section_title": true,
      "ja": "7.2.1. OPRFとVOPRFの仮定"
    },
    {
      "indent": 3,
      "text": "The OPRF and VOPRF protocol variants in this document are based on [JKK14]. In particular, the VOPRF construction is similar to the [JKK14] construction with the following distinguishing properties:",
      "ja": "この文書のOPRFおよびVOPRFプロトコルの変種は[JKK14]に基づいています。特に、VOPRF構築は[JKK14]構築に類似しており、次の特徴を持っています。"
    },
    {
      "indent": 8,
      "text": "1. This document does not use session identifiers to differentiate different instances of the protocol.",
      "ja": "1. この文書は、プロトコルの異なるインスタンスを区別するためにセッション識別子を使用していません。"
    },
    {
      "indent": 8,
      "text": "2. This document supports batching so that multiple evaluations can happen at once whilst only constructing one DLEQ proof object. This is enabled using an established batching technique [DGSTV18].",
      "ja": "2. このドキュメントは、1つのDLEQ証明オブジェクトのみを構築しながら複数の評価を一度に行うことをサポートしています。これは、確立されたバッチング技術[DGSTV18]を使用して有効になっています。"
    },
    {
      "indent": 3,
      "text": "The pseudorandomness and input secrecy (and verifiability) of the OPRF (and VOPRF) protocols in [JKK14] are based on the One-More Gap Computational Diffie-Hellman assumption that is computationally difficult to solve in the corresponding prime-order group. In [JKK14], these properties are proven for one instance (i.e., one key) of the VOPRF protocol and without batching. There is currently no security analysis available for the VOPRF protocol described in this document in a setting with multiple server keys or batching.",
      "ja": "[JKK14]のOPRF（およびVOPRF）プロトコルの擬似乱数性と入力秘匿性（および検証可能性）は、対応する素数位数群で計算的に解決が困難なOne-More Gap Computational Diffie-Hellman仮定に基づいています。[JKK14]では、これらの特性は、VOPRFプロトコルの1つのインスタンス（すなわち、1つのキー）およびバッチ処理なしで証明されています。現在、この文書で説明されているVOPRFプロトコルについて、複数のサーバーキーまたはバッチ処理を伴う環境でのセキュリティ分析は利用できません。"
    },
    {
      "indent": 0,
      "text": "7.2.2. POPRF Assumptions",
      "section_title": true,
      "ja": "7.2.2. POPRFの仮定"
    },
    {
      "indent": 3,
      "text": "The POPRF construction in this document is based on the construction known as 3HashSDHI, given by [TCRSTW21]. The construction is identical to 3HashSDHI, except that this design can optionally perform multiple POPRF evaluations in one batch, whilst only constructing one DLEQ proof object. This is enabled using an established batching technique [DGSTV18].",
      "ja": "この文書におけるPOPRF構築は、3HashSDHIとして知られる構築に基づいています。この構築は、3HashSDHIと同一であり、ただし、この設計ではオプションで複数のPOPRF評価を1つのバッチで実行し、1つのDLEQ証明オブジェクトのみを構築できます。これは、確立されたバッチング技術を使用して可能になります。"
    },
    {
      "indent": 3,
      "text": "Pseudorandomness, input secrecy, verifiability, and partial obliviousness of the POPRF variant is based on the assumption that the One-More Gap Strong Diffie-Hellman Inversion (SDHI) assumption from [TCRSTW21] is computationally difficult to solve in the corresponding prime-order group. Tyagi et al. [TCRSTW21] show that both the One-More Gap Computational Diffie-Hellman assumption and the One-More Gap SDHI assumption reduce to the q-DL (Discrete Log) assumption in the algebraic group model for some q number of BlindEvaluate queries. (The One-More Gap Computational Diffie-Hellman assumption was the hardness assumption used to evaluate the OPRF and VOPRF designs based on [JKK14], which is a predecessor to the POPRF variant in Section 3.3.3.)",
      "ja": "Pseudorandomness、input secrecy、verifiability、およびPOPFRの部分的な忘却性は、[TCRSTW21]からのOne-More Gap Strong Diffie-Hellman Inversion（SDHI）仮定に基づいています。Tyagiら[TCRSTW21]は、One-More Gap Computational Diffie-Hellman仮定とOne-More Gap SDHI仮定の両方が、ある数のBlindEvaluateクエリqに対して代数的グループモデルにおけるq-DL（離散対数）仮定に還元されることを示しています。 （One-More Gap Computational Diffie-Hellman仮定は、[JKK14]に基づくOPRFおよびVOPRF設計を評価するために使用された難問であり、これはセクション3.3.3のPOPFRの変種の前身です。）"
    },
    {
      "indent": 0,
      "text": "7.2.3. Static Diffie-Hellman Attack and Security Limits",
      "section_title": true,
      "ja": "7.2.3. 静的ディフィー・ヘルマン攻撃とセキュリティの限界"
    },
    {
      "indent": 3,
      "text": "A side effect of the OPRF protocol variants in this document is that they allow instantiation of an oracle for constructing static Diffie-Hellman (DH) samples; see [BG04] and [Cheon06]. These attacks are meant to recover (bits of) the server private key. Best-known attacks reduce the security of the prime-order group instantiation by log_2(Q) / 2 bits, where Q is the number of BlindEvaluate calls made by the attacker.",
      "ja": "この文書のOPRFプロトコルの変種の副作用は、静的Diffie-Hellman（DH）サンプルを構築するためのオラクルのインスタンス化を可能にすることです。これらの攻撃は、サーバーの秘密鍵を回復することを意図しています。最もよく知られている攻撃は、攻撃者がBlindEvaluate呼び出しを行った回数Qの対数_2(Q) / 2ビットだけ素数位数群のインスタンス化のセキュリティを低下させます。"
    },
    {
      "indent": 3,
      "text": "As a result of this class of attacks, choosing prime-order groups with a 128-bit security level instantiates an OPRF with a reduced security level of 128 - (log_2(Q) / 2) bits of security. Moreover, such attacks are only possible for those certain applications where the adversary can query the OPRF directly. Applications can mitigate against this problem in a variety of ways, e.g., by rate-limiting client queries to BlindEvaluate or by rotating private keys. In applications where such an oracle is not made available, this security loss does not apply.",
      "ja": "この攻撃クラスの結果、128ビットのセキュリティレベルを持つ素数位数群を選択することにより、セキュリティレベルが 128 - (log_2(Q) / 2) ビットの OPRF が実体化されます。さらに、このような攻撃は、敵対者が直接 OPRF にクエリを送信できる特定のアプリケーションにのみ可能です。アプリケーションは、クライアントのクエリを BlindEvaluate に対してレート制限するか、秘密鍵を回転させるなど、さまざまな方法でこの問題に対処できます。このようなオラクルが提供されていないアプリケーションでは、このセキュリティ損失は適用されません。"
    },
    {
      "indent": 3,
      "text": "In most cases, it would require an informed and persistent attacker to launch a highly expensive attack to reduce security to anything much below 100 bits of security. Applications that admit the aforementioned oracle functionality and that cannot tolerate discrete logarithm security of lower than 128 bits are RECOMMENDED to choose groups that target a higher security level, such as decaf448 (used by ciphersuite decaf448-SHAKE256), P-384 (used by ciphersuite P384-SHA384), or P-521 (used by ciphersuite P521-SHA512).",
      "ja": "ほとんどの場合、100ビット未満のセキュリティにセキュリティを低下させるために非常に高価な攻撃を実行するには、情報を持ち、粘り強い攻撃者が必要です。前述のオラクル機能を許容し、128ビット未満の離散対数セキュリティを許容できないアプリケーションは、decaf448（ciphersuite decaf448-SHAKE256で使用）、P-384（ciphersuite P384-SHA384で使用）、またはP-521（ciphersuite P521-SHA512で使用）など、より高いセキュリティレベルを目指すグループを選択することが推奨されます。"
    },
    {
      "indent": 0,
      "text": "7.3. Domain Separation",
      "section_title": true,
      "ja": "7.3. ドメイン分離"
    },
    {
      "indent": 3,
      "text": "Applications SHOULD construct input to the protocol to provide domain separation. Any system that has multiple OPRF applications should distinguish client inputs to ensure the OPRF results are separate. Guidance for constructing info can be found in [RFC9380], Section 3.1.",
      "ja": "アプリケーションは、プロトコルへの入力を構築する際に、ドメインの分離を提供する必要があります。複数のOPRFアプリケーションを持つシステムは、OPRFの結果が分離されるようにクライアントの入力を区別する必要があります。情報の構築に関するガイダンスは、[RFC9380]のセクション3.1に記載されています。"
    },
    {
      "indent": 0,
      "text": "7.4. Timing Leaks",
      "section_title": true,
      "ja": "7.4. タイミングリーク"
    },
    {
      "indent": 3,
      "text": "To ensure no information is leaked during protocol execution, all operations that use secret data MUST run in constant time. This includes all prime-order group operations and proof-specific operations that operate on secret data, including GenerateProof and BlindEvaluate.",
      "ja": "プロトコルの実行中に情報が漏洩しないようにするためには、秘密データを使用するすべての操作は一定時間で実行される必要があります。これには、すべての素数位数群操作と秘密データを操作するプルーフ固有の操作、GenerateProofおよびBlindEvaluateを含みます。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8. 参考文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[KEYAGREEMENT]\n           Barker, E., Chen, L., Roginsky, A., Vassilev, A., and R.\n           Davis, \"Recommendation for pair-wise key-establishment\n           schemes using discrete logarithm cryptography\", NIST\n           SP 800-56A (Rev. 3), DOI 10.6028/nist.sp.800-56ar3, April\n           2018, <https://doi.org/10.6028/nist.sp.800-56ar3>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,\n           \"PKCS #1: RSA Cryptography Specifications Version 2.2\",\n           RFC 8017, DOI 10.17487/RFC8017, November 2016,\n           <https://www.rfc-editor.org/info/rfc8017>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9380]  Faz-Hernandez, A., Scott, S., Sullivan, N., Wahby, R. S.,\n           and C. A. Wood, \"Hashing to Elliptic Curves\", RFC 9380,\n           DOI 10.17487/RFC9380, August 2023,\n           <https://www.rfc-editor.org/info/rfc9380>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9496]  de Valence, H., Grigg, J., Hamburg, M., Lovecruft, I.,\n           Tankersley, G., and F. Valsorda, \"The ristretto255 and\n           decaf448 Groups\", RFC 9496, DOI 10.17487/RFC9496, December\n           2023, <https://www.rfc-editor.org/info/rfc9496>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[BG04]     Brown, D. and R. Gallant, \"The Static Diffie-Hellman\n           Problem\", November 2004,\n           <https://eprint.iacr.org/2004/306>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[ChaumPedersen]\n           Chaum, D. and T. Pedersen, \"Wallet Databases with\n           Observers\", Advances in Cryptology - CRYPTO' 92, pp.\n           89-105, DOI 10.1007/3-540-48071-4_7, August 1992,\n           <https://doi.org/10.1007/3-540-48071-4_7>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Cheon06]  Cheon, J., \"Security Analysis of the Strong Diffie-Hellman\n           Problem\", Advances in Cryptology - EUROCRYPT 2006, pp.\n           1-11, DOI 10.1007/11761679_1, 2006,\n           <https://doi.org/10.1007/11761679_1>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[DGSTV18]  Davidson, A., Goldberg, I., Sullivan, N., Tankersley, G.,\n           and F. Valsorda, \"Privacy Pass: Bypassing Internet\n           Challenges Anonymously\", Proceedings on Privacy Enhancing\n           Technologies, vol. 2018, no. 3, pp. 164-180, DOI \n           10.1515/popets-2018-0026, April 2018,\n           <https://doi.org/10.1515/popets-2018-0026>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[FS00]     Fiat, A. and A. Shamir, \"How To Prove Yourself: Practical\n           Solutions to Identification and Signature Problems\",\n           Advances in Cryptology - CRYPTO' 86, pp. 186-194,\n           DOI 10.1007/3-540-47721-7_12, 1986,\n           <https://doi.org/10.1007/3-540-47721-7_12>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[JKK14]    Jarecki, S., Kiayias, A., and H. Krawczyk, \"Round-Optimal\n           Password-Protected Secret Sharing and T-PAKE in the\n           Password-Only Model\", Lecture Notes in Computer Science,\n           pp. 233-253, DOI 10.1007/978-3-662-45608-8_13, 2014,\n           <https://doi.org/10.1007/978-3-662-45608-8_13>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[JKKX16]   Jarecki, S., Kiayias, A., Krawczyk, H., and J. Xu,\n           \"Highly-Efficient and Composable Password-Protected Secret\n           Sharing (Or: How to Protect Your Bitcoin Wallet Online)\",\n           2016 IEEE European Symposium on Security and Privacy\n           (EuroS&P), DOI 10.1109/eurosp.2016.30, March 2016,\n           <https://doi.org/10.1109/eurosp.2016.30>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[NISTCurves]\n           National Institute of Standards and Technology (NIST),\n           \"Digital Signature Standard (DSS)\", FIPS PUB 186-5,\n           DOI 10.6028/NIST.FIPS.186-5, February 2023,\n           <https://doi.org/10.6028/NIST.FIPS.186-5>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[OPAQUE]   Bourdrez, D., Krawczyk, H., Lewi, K., and C. A. Wood, \"The\n           OPAQUE Asymmetric PAKE Protocol\", Work in Progress,\n           Internet-Draft, draft-irtf-cfrg-opaque-13, 18 December\n           2023, <https://datatracker.ietf.org/doc/html/draft-irtf-\n           cfrg-opaque-13>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[PRIVACY-PASS]\n           Celi, S., Davidson, A., Valdez, S., and C. A. Wood,\n           \"Privacy Pass Issuance Protocol\", Work in Progress,\n           Internet-Draft, draft-ietf-privacypass-protocol-16, 3\n           October 2023, <https://datatracker.ietf.org/doc/html/\n           draft-ietf-privacypass-protocol-16>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[PrivacyPass]\n           \"Privacy Pass\", commit 085380a, March 2018,\n           <https://github.com/privacypass/team>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7748]  Langley, A., Hamburg, M., and S. Turner, \"Elliptic Curves\n           for Security\", RFC 7748, DOI 10.17487/RFC7748, January\n           2016, <https://www.rfc-editor.org/info/rfc7748>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SEC1]     Standards for Efficient Cryptography Group (SECG), \"SEC 1:\n           Elliptic Curve Cryptography\", May 2009,\n           <https://www.secg.org/sec1-v2.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SJKS17]   Shirvanian, M., Jarecki, S., Krawczyk, H., and N. Saxena,\n           \"SPHINX: A Password Store that Perfectly Hides Passwords\n           from Itself\", 2017 IEEE 37th International Conference on\n           Distributed Computing Systems (ICDCS),\n           DOI 10.1109/ICDCS.2017.64, June 2017,\n           <https://doi.org/10.1109/ICDCS.2017.64>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[TCRSTW21] Tyagi, N., Celi, S., Ristenpart, T., Sullivan, N.,\n           Tessaro, S., and C. A. Wood, \"A Fast and Simple Partially\n           Oblivious PRF, with Applications\", Advances in Cryptology\n           - EUROCRYPT 2022 pp. 674-705,\n           DOI 10.1007/978-3-031-07085-3_23, May 2022,\n           <https://doi.org/10.1007/978-3-031-07085-3_23>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix A. Test Vectors",
      "section_title": true,
      "ja": "付録A. テストベクトル"
    },
    {
      "indent": 3,
      "text": "This section includes test vectors for the protocol variants specified in this document. For each ciphersuite specified in Section 4, there is a set of test vectors for the protocol when running the OPRF, VOPRF, and POPRF modes. Each test vector lists the batch size for the evaluation. Each test vector value is encoded as a hexadecimal byte string. The fields of each test vector are described below.",
      "ja": "このセクションには、この文書で指定されたプロトコルのバリアント用のテストベクトルが含まれています。セクション4で指定された暗号スイートごとに、OPRF、VOPRF、およびPOPRFモードでプロトコルを実行する際のテストベクトルのセットがあります。各テストベクトルには、評価のためのバッチサイズがリストされています。各テストベクトルの値は16進バイト文字列としてエンコードされています。各テストベクトルのフィールドは以下に記載されています。"
    },
    {
      "indent": 3,
      "text": "\"Input\":",
      "ja": "入力"
    },
    {
      "indent": 12,
      "text": "The private client input, an opaque byte string.",
      "ja": "プライベートクライアント入力、不透明なバイト文字列。"
    },
    {
      "indent": 3,
      "text": "\"Info\":",
      "ja": "情報"
    },
    {
      "indent": 12,
      "text": "The public info, an opaque byte string. Only present for POPRF test vectors.",
      "ja": "公開情報、不透明なバイト文字列。POPRFテストベクトルのみに存在します。"
    },
    {
      "indent": 3,
      "text": "\"Blind\":",
      "ja": "盲目"
    },
    {
      "indent": 12,
      "text": "The blind value output by Blind(), a serialized Scalar of Ns bytes long.",
      "ja": "Blind()によって出力される盲値は、Nsバイトの長さのシリアライズされたスカラーです。"
    },
    {
      "indent": 3,
      "text": "\"BlindedElement\":",
      "ja": "\"BlindedElement\""
    },
    {
      "indent": 12,
      "text": "The blinded value output by Blind(), a serialized Element of Ne bytes long.",
      "ja": "Blind()によって出力される値は、Neバイトのシリアライズされた要素です。"
    },
    {
      "indent": 3,
      "text": "\"EvaluatedElement\":",
      "ja": "\"EvaluatedElement\":"
    },
    {
      "indent": 12,
      "text": "The evaluated element output by BlindEvaluate(), a serialized Element of Ne bytes long.",
      "ja": "BlindEvaluate()によって出力された評価された要素は、長さNeバイトのシリアライズされた要素です。"
    },
    {
      "indent": 3,
      "text": "\"Proof\":",
      "ja": "証拠"
    },
    {
      "indent": 12,
      "text": "The serialized Proof output from GenerateProof() composed of two serialized Scalar values, each Ns bytes long. Only present for VOPRF and POPRF test vectors.",
      "ja": "GenerateProof()からのシリアル化されたProof出力は、それぞれNsバイト長の2つのシリアル化されたScalar値で構成されています。VOPRFおよびPOPRFのテストベクトルにのみ存在します。"
    },
    {
      "indent": 3,
      "text": "\"ProofRandomScalar\":",
      "ja": "\"ProofRandomScalar\":"
    },
    {
      "indent": 12,
      "text": "The random Scalar r computed in GenerateProof(), a serialized Scalar of Ns bytes long. Only present for VOPRF and POPRF test vectors.",
      "ja": "GenerateProof() で計算されたランダムなスカラー r は、Ns バイトのシリアライズされたスカラーです。VOPRF および POPRF テストベクトルにのみ存在します。"
    },
    {
      "indent": 3,
      "text": "\"Output\":",
      "ja": "出力"
    },
    {
      "indent": 12,
      "text": "The protocol output, an opaque byte string of Nh bytes long.",
      "ja": "プロトコルの出力は、Nhバイトの長さの不透明なバイト文字列です。"
    },
    {
      "indent": 3,
      "text": "Test vectors with batch size B > 1 have inputs separated by a comma \",\". Applicable test vectors will have B different values for the \"Input\", \"Blind\", \"BlindedElement\", \"EvaluationElement\", and \"Output\" fields.",
      "ja": "バッチサイズ B > 1 のテストベクトルは、入力がコンマ \",\" で区切られます。適用可能なテストベクトルは、\"Input\"、\"Blind\"、\"BlindedElement\"、\"EvaluationElement\"、\"Output\" フィールドに異なる B 個の値を持ちます。"
    },
    {
      "indent": 3,
      "text": "The server key material, pkSm and skSm, are listed under the mode for each ciphersuite. Both pkSm and skSm are the serialized values of pkS and skS, respectively, as used in the protocol. Each key pair is derived from a seed, denoted Seed, and info string, denoted KeyInfo, which are listed as well, using the DeriveKeyPair function from Section 3.2.",
      "ja": "サーバーキー素材、pkSmおよびskSmは、それぞれプロトコルで使用されるpkSおよびskSのシリアル化された値です。各キーペアは、Seedとして示されるシードとKeyInfoとして示される情報文字列から導出され、セクション3.2のDeriveKeyPair関数を使用してリストされています。"
    },
    {
      "indent": 0,
      "text": "A.1. ristretto255-SHA512",
      "section_title": true,
      "ja": "A.1. ristretto255-SHA512"
    },
    {
      "indent": 0,
      "text": "A.1.1. OPRF Mode",
      "section_title": true,
      "ja": "A.1.1. OPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = 5ebcea5ee37023ccb9fc2d2019f9d7737be85591ae8652ffa9ef0f4d37063\nb0e",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1.1.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.1.1.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec4c1f\n6706\nBlindedElement = 609a0ae68c15a3cf6903766461307e5c8bb2f95e7e6550e1ffa\n2dc99e412803c\nEvaluationElement = 7ec6578ae5120958eb2db1745758ff379e77cb64fe77b0b2\nd8cc917ea0869c7e\nOutput = 527759c3d9366f277d8c6020418d96bb393ba2afb20ff90df23fb770826\n4e2f3ab9135e3bd69955851de4b1f9fe8a0973396719b7912ba9ee8aa7d0b5e24bcf\n6",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1.1.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.1.1.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec4c1f\n6706\nBlindedElement = da27ef466870f5f15296299850aa088629945a17d1f5b7f5ff0\n43f76b3c06418\nEvaluationElement = b4cbf5a4f1eeda5a63ce7b77c7d23f461db3fcab0dd28e4e\n17cecb5c90d02c25\nOutput = f4a74c9c592497375e796aa837e907b1a045d34306a749db9f34221f7e7\n50cb4f2a6413a6bf6fa5e19ba6348eb673934a722a7ede2e7621306d18951e7cf2c7\n3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1.2. VOPRF Mode",
      "section_title": true,
      "ja": "A.1.2. VOPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = e6f73f344b79b379f1a0dd37e07ff62e38d9f71345ce62ae3a9bc60b04ccd\n909\npkSm = c803e2cc6b05fc15064549b5920659ca4a77b2cca6f04f6b357009335476a\nd4e",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1.2.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.1.2.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec4c1f\n6706\nBlindedElement = 863f330cc1a1259ed5a5998a23acfd37fb4351a793a5b3c090b\n642ddc439b945\nEvaluationElement = aa8fa048764d5623868679402ff6108d2521884fa138cd7f\n9c7669a9a014267e\nProof = ddef93772692e535d1a53903db24367355cc2cc78de93b3be5a8ffcc6985\ndd066d4346421d17bf5117a2a1ff0fcb2a759f58a539dfbe857a40bce4cf49ec600d\nProofRandomScalar = 222a5e897cf59db8145db8d16e597e8facb80ae7d4e26d98\n81aa6f61d645fc0e\nOutput = b58cfbe118e0cb94d79b5fd6a6dafb98764dff49c14e1770b566e42402d\na1a7da4d8527693914139caee5bd03903af43a491351d23b430948dd50cde10d32b3\nc",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1.2.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.1.2.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec4c1f\n6706\nBlindedElement = cc0b2a350101881d8a4cba4c80241d74fb7dcbfde4a61fde2f9\n1443c2bf9ef0c\nEvaluationElement = 60a59a57208d48aca71e9e850d22674b611f752bed48b36f\n7a91b372bd7ad468\nProof = 401a0da6264f8cf45bb2f5264bc31e109155600babb3cd4e5af7d181a2c9\ndc0a67154fabf031fd936051dec80b0b6ae29c9503493dde7393b722eafdf5a50b02\nProofRandomScalar = 222a5e897cf59db8145db8d16e597e8facb80ae7d4e26d98\n81aa6f61d645fc0e\nOutput = 8a9a2f3c7f085b65933594309041fc1898d42d0858e59f90814ae90571a\n6df60356f4610bf816f27afdd84f47719e480906d27ecd994985890e5f539e7ea74b\n6",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1.2.3. Test Vector 3, Batch Size 2",
      "section_title": true,
      "ja": "A.1.2.3. テストベクトル3、バッチサイズ2"
    },
    {
      "indent": 3,
      "text": "Input = 00,5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec4c1f\n6706,222a5e897cf59db8145db8d16e597e8facb80ae7d4e26d9881aa6f61d645fc0\ne\nBlindedElement = 863f330cc1a1259ed5a5998a23acfd37fb4351a793a5b3c090b\n642ddc439b945,90a0145ea9da29254c3a56be4fe185465ebb3bf2a1801f7124bbba\ndac751e654\nEvaluationElement = aa8fa048764d5623868679402ff6108d2521884fa138cd7f\n9c7669a9a014267e,cc5ac221950a49ceaa73c8db41b82c20372a4c8d63e5dded2db\n920b7eee36a2a\nProof = cc203910175d786927eeb44ea847328047892ddf8590e723c37205cb7460\n0b0a5ab5337c8eb4ceae0494c2cf89529dcf94572ed267473d567aeed6ab873dee08\nProofRandomScalar = 419c4f4f5052c53c45f3da494d2b67b220d02118e0857cdb\ncf037f9ea84bbe0c\nOutput = b58cfbe118e0cb94d79b5fd6a6dafb98764dff49c14e1770b566e42402d\na1a7da4d8527693914139caee5bd03903af43a491351d23b430948dd50cde10d32b3\nc,8a9a2f3c7f085b65933594309041fc1898d42d0858e59f90814ae90571a6df6035\n6f4610bf816f27afdd84f47719e480906d27ecd994985890e5f539e7ea74b6",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1.3. POPRF Mode",
      "section_title": true,
      "ja": "A.1.3. POPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = 145c79c108538421ac164ecbe131942136d5570b16d8bf41a24d4337da981\ne07\npkSm = c647bef38497bc6ec077c22af65b696efa43bff3b4a1975a3e8e0a1c5a79d\n631",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1.3.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.1.3.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nInfo = 7465737420696e666f\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec4c1f\n6706\nBlindedElement = c8713aa89241d6989ac142f22dba30596db635c772cbf25021f\ndd8f3d461f715\nEvaluationElement = 1a4b860d808ff19624731e67b5eff20ceb2df3c3c03b906f\n5693e2078450d874\nProof = 41ad1a291aa02c80b0915fbfbb0c0afa15a57e2970067a602ddb9e8fd6b7\n100de32e1ecff943a36f0b10e3dae6bd266cdeb8adf825d86ef27dbc6c0e30c52206\nProofRandomScalar = 222a5e897cf59db8145db8d16e597e8facb80ae7d4e26d98\n81aa6f61d645fc0e\nOutput = ca688351e88afb1d841fde4401c79efebb2eb75e7998fa9737bd5a82a15\n2406d38bd29f680504e54fd4587eddcf2f37a2617ac2fbd2993f7bdf45442ace7d22\n1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1.3.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.1.3.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nInfo = 7465737420696e666f\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec4c1f\n6706\nBlindedElement = f0f0b209dd4d5f1844dac679acc7761b91a2e704879656cb7c2\n01e82a99ab07d\nEvaluationElement = 8c3c9d064c334c6991e99f286ea2301d1bde170b54003fb9\nc44c6d7bd6fc1540\nProof = 4c39992d55ffba38232cdac88fe583af8a85441fefd7d1d4a8d0394cd1de\n77018bf135c174f20281b3341ab1f453fe72b0293a7398703384bed822bfdeec8908\nProofRandomScalar = 222a5e897cf59db8145db8d16e597e8facb80ae7d4e26d98\n81aa6f61d645fc0e\nOutput = 7c6557b276a137922a0bcfc2aa2b35dd78322bd500235eb6d6b6f91bc5b\n56a52de2d65612d503236b321f5d0bebcbc52b64b92e426f29c9b8b69f52de98ae50\n7",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1.3.3. Test Vector 3, Batch Size 2",
      "section_title": true,
      "ja": "A.1.3.3. テストベクトル3、バッチサイズ2"
    },
    {
      "indent": 3,
      "text": "Input = 00,5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nInfo = 7465737420696e666f\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec4c1f\n6706,222a5e897cf59db8145db8d16e597e8facb80ae7d4e26d9881aa6f61d645fc0\ne\nBlindedElement = c8713aa89241d6989ac142f22dba30596db635c772cbf25021f\ndd8f3d461f715,423a01c072e06eb1cce96d23acce06e1ea64a609d7ec9e9023f304\n9f2d64e50c\nEvaluationElement = 1a4b860d808ff19624731e67b5eff20ceb2df3c3c03b906f\n5693e2078450d874,aa1f16e903841036e38075da8a46655c94fc92341887eb5819f\n46312adfc0504\nProof = 43fdb53be399cbd3561186ae480320caa2b9f36cca0e5b160c4a677b8bbf\n4301b28f12c36aa8e11e5a7ef551da0781e863a6dc8c0b2bf5a149c9e00621f02006\nProofRandomScalar = 419c4f4f5052c53c45f3da494d2b67b220d02118e0857cdb\ncf037f9ea84bbe0c\nOutput = ca688351e88afb1d841fde4401c79efebb2eb75e7998fa9737bd5a82a15\n2406d38bd29f680504e54fd4587eddcf2f37a2617ac2fbd2993f7bdf45442ace7d22\n1,7c6557b276a137922a0bcfc2aa2b35dd78322bd500235eb6d6b6f91bc5b56a52de\n2d65612d503236b321f5d0bebcbc52b64b92e426f29c9b8b69f52de98ae507",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2. decaf448-SHAKE256",
      "section_title": true,
      "ja": "A.2. decaf448-SHAKE256"
    },
    {
      "indent": 0,
      "text": "A.2.1. OPRF Mode",
      "section_title": true,
      "ja": "A.2.1. OPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = e8b1375371fd11ebeb224f832dcc16d371b4188951c438f751425699ed29e\ncc80c6c13e558ccd67634fd82eac94aa8d1f0d7fee990695d1e",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2.1.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.2.1.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec65fa\n3833a26e9388336361686ff1f83df55046504dfecad8549ba112\nBlindedElement = e0ae01c4095f08e03b19baf47ffdc19cb7d98e583160522a3c7\nd6a0b2111cd93a126a46b7b41b730cd7fc943d4e28e590ed33ae475885f6c\nEvaluationElement = 50ce4e60eed006e22e7027454b5a4b8319eb2bc8ced609eb\n19eb3ad42fb19e06ba12d382cbe7ae342a0cad6ead0ef8f91f00bb7f0cd9c0a2\nOutput = 37d3f7922d9388a15b561de5829bbf654c4089ede89c0ce0f3f85bcdba0\n9e382ce0ab3507e021f9e79706a1798ffeac68ebd5cf62e5eb9838c7068351d97ae3\n7",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2.1.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.2.1.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec65fa\n3833a26e9388336361686ff1f83df55046504dfecad8549ba112\nBlindedElement = 86a88dc5c6331ecfcb1d9aacb50a68213803c462e377577cacc\n00af28e15f0ddbc2e3d716f2f39ef95f3ec1314a2c64d940a9f295d8f13bb\nEvaluationElement = 162e9fa6e9d527c3cd734a31bf122a34dbd5bcb7bb23651f\n1768a7a9274cc116c03b58afa6f0dede3994a60066c76370e7328e7062fd5819\nOutput = a2a652290055cb0f6f8637a249ee45e32ef4667db0b4c80c0a70d2a6416\n4d01525cfdad5d870a694ec77972b9b6ec5d2596a5223e5336913f945101f0137f55\ne",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2.2. VOPRF Mode",
      "section_title": true,
      "ja": "A.2.2. VOPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = e3c01519a076a326a0eb566343e9b21c115fa18e6e85577ddbe890b33104f\ncc2835ddfb14a928dc3f5d79b936e17c76b99e0bf6a1680930e\npkSm = 945fc518c47695cf65217ace04b86ac5e4cbe26ca649d52854bb16c494ce0\n9069d6add96b20d4b0ae311a87c9a73e3a146b525763ab2f955",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2.2.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.2.2.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec65fa\n3833a26e9388336361686ff1f83df55046504dfecad8549ba112\nBlindedElement = 7261bbc335c664ba788f1b1a1a4cd5190cc30e787ef277665ac\n1d314f8861e3ec11854ce3ddd42035d9e0f5cddde324c332d8c880abc00eb\nEvaluationElement = ca1491a526c28d880806cf0fb0122222392cf495657be6e4\nc9d203bceffa46c86406caf8217859d3fb259077af68e5d41b3699410781f467\nProof = f84bbeee47aedf43558dae4b95b3853635a9fc1a9ea7eac9b454c64c66c4\nf49cd1c72711c7ac2e06c681e16ea693d5500bbd7b56455df52f69e00b76b4126961\ne1562fdbaaac40b7701065cbeece3febbfe09e00160f81775d36daed99d8a2a10be0\n759e01b7ee81217203416c9db208\nProofRandomScalar = b1b748135d405ce48c6973401d9455bb8ccd18b01d0295c0\n627f67661200dbf9569f73fbb3925daa043a070e5f953d80bb464ea369e5522b\nOutput = e2ac40b634f36cccd8262b285adff7c9dcc19cd308564a5f4e581d1a853\n5773b86fa4fc9f2203c370763695c5093aea4a7aedec4488b1340ba3bf663a23098c\n1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2.2.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.2.2.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec65fa\n3833a26e9388336361686ff1f83df55046504dfecad8549ba112\nBlindedElement = 88287e553939090b888ddc15913e1807dc4757215555e1c3a79\n488ef311594729c7fa74c772a732b78440b7d66d0aa35f3bb316f1d93e1b2\nEvaluationElement = c00978c73e8e4ee1d447ab0d3ad1754055e72cc85c08e3a0\ndb170909a9c61cbff1f1e7015f289e3038b0f341faea5d7780c130106065c231\nProof = 7a2831a6b237e11ac1657d440df93bc5ce00f552e6020a99d5c956ffc4d0\n7b5ade3e82ecdc257fd53d76239e733e0a1313e84ce16cc0d82734806092a693d7e8\nd3c420c2cb6ccd5d0ca32514fb78e9ad0973ebdcb52eba438fc73948d76339ee7101\n21d83e2fe6f001cfdf551aff9f36\nProofRandomScalar = b1b748135d405ce48c6973401d9455bb8ccd18b01d0295c0\n627f67661200dbf9569f73fbb3925daa043a070e5f953d80bb464ea369e5522b\nOutput = 862952380e07ec840d9f6e6f909c5a25d16c3dacb586d89a181b4aa7380\nc959baa8c480fe8e6c64e089d68ea7aeeb5817bd524d7577905b5bab487690048c94\n1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2.2.3. Test Vector 3, Batch Size 2",
      "section_title": true,
      "ja": "A.2.2.3. テストベクトル3、バッチサイズ2"
    },
    {
      "indent": 3,
      "text": "Input = 00,5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec65fa\n3833a26e9388336361686ff1f83df55046504dfecad8549ba112,b1b748135d405ce\n48c6973401d9455bb8ccd18b01d0295c0627f67661200dbf9569f73fbb3925daa043\na070e5f953d80bb464ea369e5522b\nBlindedElement = 7261bbc335c664ba788f1b1a1a4cd5190cc30e787ef277665ac\n1d314f8861e3ec11854ce3ddd42035d9e0f5cddde324c332d8c880abc00eb,2e15f3\n93c035492a1573627a3606e528c6294c767c8d43b8c691ef70a52cc7dc7d1b53fe45\n8350a270abb7c231b87ba58266f89164f714d9\nEvaluationElement = ca1491a526c28d880806cf0fb0122222392cf495657be6e4\nc9d203bceffa46c86406caf8217859d3fb259077af68e5d41b3699410781f467,8ec\n68e9871b296e81c55647ce64a04fe75d19932f1400544cd601468c60f998408bbb54\n6601d4a636e8be279e558d70b95c8d4a4f61892be\nProof = 167d922f0a6ffa845eed07f8aa97b6ac746d902ecbeb18f49c009adc0521\neab1e4d275b74a2dc266b7a194c854e85e7eb54a9a36376dfc04ec7f3bd55fc9618c\n3970cb548e064f8a2f06183a5702933dbc3e4c25a73438f2108ee1981c306181003c\n7ea92fce963ec7b4ba4f270e6d38\nProofRandomScalar = 63798726803c9451ba405f00ef3acb633ddf0c420574a2ec\n6cbf28f840800e355c9fbaac10699686de2724ed22e797a00f3bd93d105a7f23\nOutput = e2ac40b634f36cccd8262b285adff7c9dcc19cd308564a5f4e581d1a853\n5773b86fa4fc9f2203c370763695c5093aea4a7aedec4488b1340ba3bf663a23098c\n1,862952380e07ec840d9f6e6f909c5a25d16c3dacb586d89a181b4aa7380c959baa\n8c480fe8e6c64e089d68ea7aeeb5817bd524d7577905b5bab487690048c941",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2.3. POPRF Mode",
      "section_title": true,
      "ja": "A.2.3. POPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = 792a10dcbd3ba4a52a054f6f39186623208695301e7adb9634b74709ab22d\ne402990eb143fd7c67ac66be75e0609705ecea800992aac8e19\npkSm = 6c9d12723a5bbcf305522cc04b4a34d9ced2e12831826018ea7b5dcf54526\n47ad262113059bf0f6e4354319951b9d513c74f29cb0eec38c1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2.3.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.2.3.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nInfo = 7465737420696e666f\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec65fa\n3833a26e9388336361686ff1f83df55046504dfecad8549ba112\nBlindedElement = 161183c13c6cb33b0e4f9b7365f8c5c12d13c72f8b62d276ca0\n9368d093dce9b42198276b9e9d870ac392dda53efd28d1b7e6e8c060cdc42\nEvaluationElement = 06ec89dfde25bb2a6f0145ac84b91ac277b35de39ad1d6f4\n02a8e46414952ce0d9ea1311a4ece283e2b01558c7078b040cfaa40dd63b3e6c\nProof = 66caee75bf2460429f620f6ad3e811d524cb8ddd848a435fc5d89af48877\nabf6506ee341a0b6f67c2d76cd021e5f3d1c9abe5aa9f0dce016da746135fedba2af\n41ed1d01659bfd6180d96bc1b7f320c0cb6926011ce392ecca748662564892bae665\n16acaac6ca39aadf6fcca95af406\nProofRandomScalar = b1b748135d405ce48c6973401d9455bb8ccd18b01d0295c0\n627f67661200dbf9569f73fbb3925daa043a070e5f953d80bb464ea369e5522b\nOutput = 4423f6dcc1740688ea201de57d76824d59cd6b859e1f9884b7eebc49b0b\n971358cf9cb075df1536a8ea31bcf55c3e31c2ba9cfa8efe54448d17091daeb9924e\nd",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2.3.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.2.3.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nInfo = 7465737420696e666f\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec65fa\n3833a26e9388336361686ff1f83df55046504dfecad8549ba112\nBlindedElement = 12082b6a381c6c51e85d00f2a3d828cdeab3f5cb19a10b9c014\nc33826764ab7e7cfb8b4ff6f411bddb2d64e62a472af1cd816e5b712790c6\nEvaluationElement = f2919b7eedc05ab807c221fce2b12c4ae9e19e6909c47845\n64b690d1972d2994ca623f273afc67444d84ea40cbc58fcdab7945f321a52848\nProof = a295677c54d1bc4286330907fc2490a7de163da26f9ce03a462a452fea42\n2b19ade296ba031359b3b6841e48455d20519ad01b4ac4f0b92e76d3cf16fbef0a3f\n72791a8401ef2d7081d361e502e96b2c60608b9fa566f43d4611c2f161d83aabef7f\n8017332b26ed1daaf80440772022\nProofRandomScalar = b1b748135d405ce48c6973401d9455bb8ccd18b01d0295c0\n627f67661200dbf9569f73fbb3925daa043a070e5f953d80bb464ea369e5522b\nOutput = 8691905500510843902c44bdd9730ab9dc3925aa58ff9dd42765a2baf63\n3126de0c3adb93bef5652f38e5827b6396e87643960163a560fc4ac9738c8de4e4a8\nd",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2.3.3. Test Vector 3, Batch Size 2",
      "section_title": true,
      "ja": "A.2.3.3. テストベクトル3、バッチサイズ2"
    },
    {
      "indent": 3,
      "text": "Input = 00,5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nInfo = 7465737420696e666f\nBlind = 64d37aed22a27f5191de1c1d69fadb899d8862b58eb4220029e036ec65fa\n3833a26e9388336361686ff1f83df55046504dfecad8549ba112,b1b748135d405ce\n48c6973401d9455bb8ccd18b01d0295c0627f67661200dbf9569f73fbb3925daa043\na070e5f953d80bb464ea369e5522b\nBlindedElement = 161183c13c6cb33b0e4f9b7365f8c5c12d13c72f8b62d276ca0\n9368d093dce9b42198276b9e9d870ac392dda53efd28d1b7e6e8c060cdc42,fc8847\nd43fb4cea4e408f585661a8f2867533fa91d22155d3127a22f18d3b007add480f7d3\n00bca93fa47fe87ae06a57b7d0f0d4c30b12f0\nEvaluationElement = 06ec89dfde25bb2a6f0145ac84b91ac277b35de39ad1d6f4\n02a8e46414952ce0d9ea1311a4ece283e2b01558c7078b040cfaa40dd63b3e6c,2e7\n4c626d07de49b1c8c21d87120fd78105f485e36816af9bde3e3efbeef76815326062\nfd333925b66c5ce5a20f100bf01770c16609f990a\nProof = fd94db736f97ea4efe9d0d4ad2933072697a6bbeb32834057b23edf7c700\n9f011dfa72157f05d2a507c2bbf0b54cad99ab99de05921c021fda7d70e65bcecdb0\n5f9a30154127ace983c74d10fd910b554c5e95f6bd1565fd1f3dbbe3c523ece5c72d\n57a559b7be1368c4786db4a3c910\nProofRandomScalar = 63798726803c9451ba405f00ef3acb633ddf0c420574a2ec\n6cbf28f840800e355c9fbaac10699686de2724ed22e797a00f3bd93d105a7f23\nOutput = 4423f6dcc1740688ea201de57d76824d59cd6b859e1f9884b7eebc49b0b\n971358cf9cb075df1536a8ea31bcf55c3e31c2ba9cfa8efe54448d17091daeb9924e\nd,8691905500510843902c44bdd9730ab9dc3925aa58ff9dd42765a2baf633126de0\nc3adb93bef5652f38e5827b6396e87643960163a560fc4ac9738c8de4e4a8d",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3. P256-SHA256",
      "section_title": true,
      "ja": "A.3. P256-SHA256"
    },
    {
      "indent": 0,
      "text": "A.3.1. OPRF Mode",
      "section_title": true,
      "ja": "A.3.1. OPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = 159749d750713afe245d2d39ccfaae8381c53ce92d098a9375ee70739c7ac\n0bf",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3.1.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.3.1.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nBlind = 3338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 03723a1e5c09b8b9c18d1dcbca29e8007e95f14f4732d9346d4\n90ffc195110368d\nEvaluationElement = 030de02ffec47a1fd53efcdd1c6faf5bdc270912b8749e78\n3c7ca75bb412958832\nOutput = a0b34de5fa4c5b6da07e72af73cc507cceeb48981b97b7285fc375345fe\n495dd",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3.1.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.3.1.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 3338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 03cc1df781f1c2240a64d1c297b3f3d16262ef5d4cf10273488\n2675c26231b0838\nEvaluationElement = 03a0395fe3828f2476ffcd1f4fe540e5a8489322d398be3c\n4e5a869db7fcb7c52c\nOutput = c748ca6dd327f0ce85f4ae3a8cd6d4d5390bbb804c9e12dcf94f853fece\n3dcce",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3.2. VOPRF Mode",
      "section_title": true,
      "ja": "A.3.2. VOPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = ca5d94c8807817669a51b196c34c1b7f8442fde4334a7121ae4736364312f\nca6\npkSm = 03e17e70604bcabe198882c0a1f27a92441e774224ed9c702e51dd17038b1\n02462",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3.2.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.3.2.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nBlind = 3338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 02dd05901038bb31a6fae01828fd8d0e49e35a486b5c5d4b499\n4013648c01277da\nEvaluationElement = 0209f33cab60cf8fe69239b0afbcfcd261af4c1c5632624f\n2e9ba29b90ae83e4a2\nProof = e7c2b3c5c954c035949f1f74e6bce2ed539a3be267d1481e9ddb178533df\n4c2664f69d065c604a4fd953e100b856ad83804eb3845189babfa5a702090d6fc5fa\nProofRandomScalar = f9db001266677f62c095021db018cd8cbb55941d4073698c\ne45c405d1348b7b1\nOutput = 0412e8f78b02c415ab3a288e228978376f99927767ff37c5718d420010a\n645a1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3.2.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.3.2.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 3338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 03cd0f033e791c4d79dfa9c6ed750f2ac009ec46cd4195ca6fd\n3800d1e9b887dbd\nEvaluationElement = 030d2985865c693bf7af47ba4d3a3813176576383d19aff0\n03ef7b0784a0d83cf1\nProof = 2787d729c57e3d9512d3aa9e8708ad226bc48e0f1750b0767aaff73482c4\n4b8d2873d74ec88aebd3504961acea16790a05c542d9fbff4fe269a77510db00abab\nProofRandomScalar = f9db001266677f62c095021db018cd8cbb55941d4073698c\ne45c405d1348b7b1\nOutput = 771e10dcd6bcd3664e23b8f2a710cfaaa8357747c4a8cbba03133967b5c\n24f18",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3.2.3. Test Vector 3, Batch Size 2",
      "section_title": true,
      "ja": "A.3.2.3. テストベクトル3、バッチサイズ2"
    },
    {
      "indent": 3,
      "text": "Input = 00,5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 3338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364,f9db001266677f62c095021db018cd8cbb55941d4073698ce45c405d1348b7b\n1\nBlindedElement = 02dd05901038bb31a6fae01828fd8d0e49e35a486b5c5d4b499\n4013648c01277da,03462e9ae64cae5b83ba98a6b360d942266389ac369b923eb3d5\n57213b1922f8ab\nEvaluationElement = 0209f33cab60cf8fe69239b0afbcfcd261af4c1c5632624f\n2e9ba29b90ae83e4a2,02bb24f4d838414aef052a8f044a6771230ca69c0a5677540\nfff738dd31bb69771\nProof = bdcc351707d02a72ce49511c7db990566d29d6153ad6f8982fad2b435d6c\ne4d60da1e6b3fa740811bde34dd4fe0aa1b5fe6600d0440c9ddee95ea7fad7a60cf2\nProofRandomScalar = 350e8040f828bf6ceca27405420cdf3d63cb3aef005f40ba\n51943c8026877963\nOutput = 0412e8f78b02c415ab3a288e228978376f99927767ff37c5718d420010a\n645a1,771e10dcd6bcd3664e23b8f2a710cfaaa8357747c4a8cbba03133967b5c24f\n18",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3.3. POPRF Mode",
      "section_title": true,
      "ja": "A.3.3. POPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = 6ad2173efa689ef2c27772566ad7ff6e2d59b3b196f00219451fb2c89ee4d\nae2\npkSm = 030d7ff077fddeec965db14b794f0cc1ba9019b04a2f4fcc1fa525dedf72e\n2a3e3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3.3.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.3.3.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nInfo = 7465737420696e666f\nBlind = 3338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 031563e127099a8f61ed51eeede05d747a8da2be329b40ba1f0\ndb0b2bd9dd4e2c0\nEvaluationElement = 02c5e5300c2d9e6ba7f3f4ad60500ad93a0157e6288eb04b\n67e125db024a2c74d2\nProof = f8a33690b87736c854eadfcaab58a59b8d9c03b569110b6f31f8bf7577f3\nfbb85a8a0c38468ccde1ba942be501654adb106167c8eb178703ccb42bccffb9231a\nProofRandomScalar = f9db001266677f62c095021db018cd8cbb55941d4073698c\ne45c405d1348b7b1\nOutput = 193a92520bd8fd1f37accb918040a57108daa110dc4f659abe212636d24\n5c592",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3.3.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.3.3.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nInfo = 7465737420696e666f\nBlind = 3338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 021a440ace8ca667f261c10ac7686adc66a12be31e3520fca31\n7643a1eee9dcd4d\nEvaluationElement = 0208ca109cbae44f4774fc0bdd2783efdcb868cb4523d521\n96f700210e777c5de3\nProof = 043a8fb7fc7fd31e35770cabda4753c5bf0ecc1e88c68d7d35a62bf2631e\n875af4613641be2d1875c31d1319d191c4bbc0d04875f4fd03c31d3d17dd8e069b69\nProofRandomScalar = f9db001266677f62c095021db018cd8cbb55941d4073698c\ne45c405d1348b7b1\nOutput = 1e6d164cfd835d88a31401623549bf6b9b306628ef03a7962921d62bc5f\nfce8c",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3.3.3. Test Vector 3, Batch Size 2",
      "section_title": true,
      "ja": "A.3.3.3. テストベクトル3、バッチサイズ2"
    },
    {
      "indent": 3,
      "text": "Input = 00,5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nInfo = 7465737420696e666f\nBlind = 3338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364,f9db001266677f62c095021db018cd8cbb55941d4073698ce45c405d1348b7b\n1\nBlindedElement = 031563e127099a8f61ed51eeede05d747a8da2be329b40ba1f0\ndb0b2bd9dd4e2c0,03ca4ff41c12fadd7a0bc92cf856732b21df652e01a3abdf0fa8\n847da053db213c\nEvaluationElement = 02c5e5300c2d9e6ba7f3f4ad60500ad93a0157e6288eb04b\n67e125db024a2c74d2,02f0b6bcd467343a8d8555a99dc2eed0215c71898c5edb77a\n3d97ddd0dbad478e8\nProof = 8fbd85a32c13aba79db4b42e762c00687d6dbf9c8cb97b2a225645ccb00d\n9d7580b383c885cdfd07df448d55e06f50f6173405eee5506c0ed0851ff718d13e68\nProofRandomScalar = 350e8040f828bf6ceca27405420cdf3d63cb3aef005f40ba\n51943c8026877963\nOutput = 193a92520bd8fd1f37accb918040a57108daa110dc4f659abe212636d24\n5c592,1e6d164cfd835d88a31401623549bf6b9b306628ef03a7962921d62bc5ffce\n8c",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4. P384-SHA384",
      "section_title": true,
      "ja": "A.4. P384-SHA384"
    },
    {
      "indent": 0,
      "text": "A.4.1. OPRF Mode",
      "section_title": true,
      "ja": "A.4.1. OPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = dfe7ddc41a4646901184f2b432616c8ba6d452f9bcd0c4f75a5150ef2b2ed\n02ef40b8b92f60ae591bcabd72a6518f188",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.1.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.4.1.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nBlind = 504650f53df8f16f6861633388936ea23338fa65ec36e0290022b48eb562\n889d89dbfa691d1cde91517fa222ed7ad364\nBlindedElement = 02a36bc90e6db34096346eaf8b7bc40ee1113582155ad379700\n3ce614c835a874343701d3f2debbd80d97cbe45de6e5f1f\nEvaluationElement = 03af2a4fc94770d7a7bf3187ca9cc4faf3732049eded2442\nee50fbddda58b70ae2999366f72498cdbc43e6f2fc184afe30\nOutput = ed84ad3f31a552f0456e58935fcc0a3039db42e7f356dcb32aa6d487b6b\n815a07d5813641fb1398c03ddab5763874357",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.1.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.4.1.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 504650f53df8f16f6861633388936ea23338fa65ec36e0290022b48eb562\n889d89dbfa691d1cde91517fa222ed7ad364\nBlindedElement = 02def6f418e3484f67a124a2ce1bfb19de7a4af568ede6a1ebb\n2733882510ddd43d05f2b1ab5187936a55e50a847a8b900\nEvaluationElement = 034e9b9a2960b536f2ef47d8608b21597ba400d5abfa1825\nfd21c36b75f927f396bf3716c96129d1fa4a77fa1d479c8d7b\nOutput = dd4f29da869ab9355d60617b60da0991e22aaab243a3460601e48b07585\n9d1c526d36597326f1b985778f781a1682e75",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.2. VOPRF Mode",
      "section_title": true,
      "ja": "A.4.2. VOPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = 051646b9e6e7a71ae27c1e1d0b87b4381db6d3595eeeb1adb41579adbf992\nf4278f9016eafc944edaa2b43183581779d\npkSm = 031d689686c611991b55f1a1d8f4305ccd6cb719446f660a30db61b7aa87b\n46acf59b7c0d4a9077b3da21c25dd482229a0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.2.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.4.2.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nBlind = 504650f53df8f16f6861633388936ea23338fa65ec36e0290022b48eb562\n889d89dbfa691d1cde91517fa222ed7ad364\nBlindedElement = 02d338c05cbecb82de13d6700f09cb61190543a7b7e2c6cd4fc\na56887e564ea82653b27fdad383995ea6d02cf26d0e24d9\nEvaluationElement = 02a7bba589b3e8672aa19e8fd258de2e6aae20101c8d7612\n46de97a6b5ee9cf105febce4327a326255a3c604f63f600ef6\nProof = bfc6cf3859127f5fe25548859856d6b7fa1c7459f0ba5712a806fc091a30\n00c42d8ba34ff45f32a52e40533efd2a03bc87f3bf4f9f58028297ccb9ccb18ae718\n2bcd1ef239df77e3be65ef147f3acf8bc9cbfc5524b702263414f043e3b7ca2e\nProofRandomScalar = 803d955f0e073a04aa5d92b3fb739f56f9db001266677f62\nc095021db018cd8cbb55941d4073698ce45c405d1348b7b1\nOutput = 3333230886b562ffb8329a8be08fea8025755372817ec969d114d1203d0\n26b4a622beab60220bf19078bca35a529b35c",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.2.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.4.2.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 504650f53df8f16f6861633388936ea23338fa65ec36e0290022b48eb562\n889d89dbfa691d1cde91517fa222ed7ad364\nBlindedElement = 02f27469e059886f221be5f2cca03d2bdc61e55221721c3b3e5\n6fc012e36d31ae5f8dc058109591556a6dbd3a8c69c433b\nEvaluationElement = 03f16f903947035400e96b7f531a38d4a07ac89a80f89d86\na1bf089c525a92c7f4733729ca30c56ce78b1ab4f7d92db8b4\nProof = d005d6daaad7571414c1e0c75f7e57f2113ca9f4604e84bc90f9be52da89\n6fff3bee496dcde2a578ae9df315032585f801fb21c6080ac05672b291e575a40295\nb306d967717b28e08fcc8ad1cab47845d16af73b3e643ddcc191208e71c64630\nProofRandomScalar = 803d955f0e073a04aa5d92b3fb739f56f9db001266677f62\nc095021db018cd8cbb55941d4073698ce45c405d1348b7b1\nOutput = b91c70ea3d4d62ba922eb8a7d03809a441e1c3c7af915cbc2226f485213\ne895942cd0f8580e6d99f82221e66c40d274f",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.2.3. Test Vector 3, Batch Size 2",
      "section_title": true,
      "ja": "A.4.2.3. テストベクトル3、バッチサイズ2"
    },
    {
      "indent": 3,
      "text": "Input = 00,5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 504650f53df8f16f6861633388936ea23338fa65ec36e0290022b48eb562\n889d89dbfa691d1cde91517fa222ed7ad364,803d955f0e073a04aa5d92b3fb739f5\n6f9db001266677f62c095021db018cd8cbb55941d4073698ce45c405d1348b7b1\nBlindedElement = 02d338c05cbecb82de13d6700f09cb61190543a7b7e2c6cd4fc\na56887e564ea82653b27fdad383995ea6d02cf26d0e24d9,02fa02470d7f151018b4\n1e82223c32fad824de6ad4b5ce9f8e9f98083c9a726de9a1fc39d7a0cb6f4f188dd9\ncea01474cd\nEvaluationElement = 02a7bba589b3e8672aa19e8fd258de2e6aae20101c8d7612\n46de97a6b5ee9cf105febce4327a326255a3c604f63f600ef6,028e9e115625ff4c2\nf07bf87ce3fd73fc77994a7a0c1df03d2a630a3d845930e2e63a165b114d98fe34e6\n1b68d23c0b50a\nProof = 6d8dcbd2fc95550a02211fb78afd013933f307d21e7d855b0b1ed0af7807\n6d8137ad8b0a1bfa05676d325249c1dbb9a52bd81b1c2b7b0efc77cf7b278e1c947f\n6283f1d4c513053fc0ad19e026fb0c30654b53d9cea4b87b037271b5d2e2d0ea\nProofRandomScalar = a097e722ed2427de86966910acba9f5c350e8040f828bf6c\neca27405420cdf3d63cb3aef005f40ba51943c8026877963\nOutput = 3333230886b562ffb8329a8be08fea8025755372817ec969d114d1203d0\n26b4a622beab60220bf19078bca35a529b35c,b91c70ea3d4d62ba922eb8a7d03809\na441e1c3c7af915cbc2226f485213e895942cd0f8580e6d99f82221e66c40d274f",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.3. POPRF Mode",
      "section_title": true,
      "ja": "A.4.3. POPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = 5b2690d6954b8fbb159f19935d64133f12770c00b68422559c65431942d72\n1ff79d47d7a75906c30b7818ec0f38b7fb2\npkSm = 02f00f0f1de81e5d6cf18140d4926ffdc9b1898c48dc49657ae36eb1e45de\nb8b951aaf1f10c82d2eaa6d02aafa3f10d2b6",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.3.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.4.3.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nInfo = 7465737420696e666f\nBlind = 504650f53df8f16f6861633388936ea23338fa65ec36e0290022b48eb562\n889d89dbfa691d1cde91517fa222ed7ad364\nBlindedElement = 03859b36b95e6564faa85cd3801175eda2949707f6aa0640ad0\n93cbf8ad2f58e762f08b56b2a1b42a64953aaf49cbf1ae3\nEvaluationElement = 0220710e2e00306453f5b4f574cb6a512453f35c45080d09\n373e190c19ce5b185914fbf36582d7e0754bb7c8b683205b91\nProof = 82a17ef41c8b57f1e3122311b4d5cd39a63df0f67443ef18d961f9b659c1\n601ced8d3c64b294f604319ca80230380d437a49c7af0d620e22116669c008ebb767\nd90283d573b49cdb49e3725889620924c2c4b047a2a6225a3ba27e640ebddd33\nProofRandomScalar = 803d955f0e073a04aa5d92b3fb739f56f9db001266677f62\nc095021db018cd8cbb55941d4073698ce45c405d1348b7b1\nOutput = 0188653cfec38119a6c7dd7948b0f0720460b4310e40824e048bf82a165\n27303ed449a08caf84272c3bbc972ede797df",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.3.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.4.3.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nInfo = 7465737420696e666f\nBlind = 504650f53df8f16f6861633388936ea23338fa65ec36e0290022b48eb562\n889d89dbfa691d1cde91517fa222ed7ad364\nBlindedElement = 03f7efcb4aaf000263369d8a0621cb96b81b3206e99876de2a0\n0699ed4c45acf3969cd6e2319215395955d3f8d8cc1c712\nEvaluationElement = 034993c818369927e74b77c400376fd1ae29b6ac6c6ddb77\n6cf10e4fbc487826531b3cf0b7c8ca4d92c7af90c9def85ce6\nProof = 693471b5dff0cd6a5c00ea34d7bf127b2795164e3bdb5f39a1e5edfbd13e\n443bc516061cd5b8449a473c2ceeccada9f3e5b57302e3d7bc5e28d38d6e3a3056e1\ne73b6cc030f5180f8a1ffa45aa923ee66d2ad0a07b500f2acc7fb99b5506465c\nProofRandomScalar = 803d955f0e073a04aa5d92b3fb739f56f9db001266677f62\nc095021db018cd8cbb55941d4073698ce45c405d1348b7b1\nOutput = ff2a527a21cc43b251a567382677f078c6e356336aec069dea8ba369953\n43ca3b33bb5d6cf15be4d31a7e6d75b30d3f5",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.3.3. Test Vector 3, Batch Size 2",
      "section_title": true,
      "ja": "A.4.3.3. テストベクトル3、バッチサイズ2"
    },
    {
      "indent": 3,
      "text": "Input = 00,5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nInfo = 7465737420696e666f\nBlind = 504650f53df8f16f6861633388936ea23338fa65ec36e0290022b48eb562\n889d89dbfa691d1cde91517fa222ed7ad364,803d955f0e073a04aa5d92b3fb739f5\n6f9db001266677f62c095021db018cd8cbb55941d4073698ce45c405d1348b7b1\nBlindedElement = 03859b36b95e6564faa85cd3801175eda2949707f6aa0640ad0\n93cbf8ad2f58e762f08b56b2a1b42a64953aaf49cbf1ae3,021a65d618d645f1a20b\nc33b06deaa7e73d6d634c8a56a3d02b53a732b69a5c53c5a207ea33d5afdcde9a22d\n59726bce51\nEvaluationElement = 0220710e2e00306453f5b4f574cb6a512453f35c45080d09\n373e190c19ce5b185914fbf36582d7e0754bb7c8b683205b91,02017657b315ec65e\nf861505e596c8645d94685dd7602cdd092a8f1c1c0194a5d0485fe47d071d972ab51\n4370174cc23f5\nProof = 4a0b2fe96d5b2a046a0447fe079b77859ef11a39a3520d6ff7c626aad9b4\n73b724fb0cf188974ec961710a62162a83e97e0baa9eeada73397032d928b3e97b1e\na92ad9458208302be3681b8ba78bcc17745bac00f84e0fdc98a6a8cba009c080\nProofRandomScalar = a097e722ed2427de86966910acba9f5c350e8040f828bf6c\neca27405420cdf3d63cb3aef005f40ba51943c8026877963\nOutput = 0188653cfec38119a6c7dd7948b0f0720460b4310e40824e048bf82a165\n27303ed449a08caf84272c3bbc972ede797df,ff2a527a21cc43b251a567382677f0\n78c6e356336aec069dea8ba36995343ca3b33bb5d6cf15be4d31a7e6d75b30d3f5",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5. P521-SHA512",
      "section_title": true,
      "ja": "A.5. P521-SHA512"
    },
    {
      "indent": 0,
      "text": "A.5.1. OPRF Mode",
      "section_title": true,
      "ja": "A.5.1. OPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = 0153441b8faedb0340439036d6aed06d1217b34c42f17f8db4c5cc610a4a9\n55d698a688831b16d0dc7713a1aa3611ec60703bffc7dc9c84e3ed673b3dbe1d5fcc\nea6",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.1.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.5.1.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nBlind = 00d1dccf7a51bafaf75d4a866d53d8cafe4d504650f53df8f16f68616333\n88936ea23338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 0300e78bf846b0e1e1a3c320e353d758583cd876df56100a3a1\ne62bacba470fa6e0991be1be80b721c50c5fd0c672ba764457acc18c6200704e9294\nfbf28859d916351\nEvaluationElement = 030166371cf827cb2fb9b581f97907121a16e2dc5d8b10ce\n9f0ede7f7d76a0d047657735e8ad07bcda824907b3e5479bd72cdef6b839b967ba5c\n58b118b84d26f2ba07\nOutput = 26232de6fff83f812adadadb6cc05d7bbeee5dca043dbb16b03488abb99\n81d0a1ef4351fad52dbd7e759649af393348f7b9717566c19a6b8856284d69375c80\n9",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.1.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.5.1.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 00d1dccf7a51bafaf75d4a866d53d8cafe4d504650f53df8f16f68616333\n88936ea23338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 0300c28e57e74361d87e0c1874e5f7cc1cc796d61f9cad50427\ncf54655cdb455613368d42b27f94bf66f59f53c816db3e95e68e1b113443d66a99b3\n693bab88afb556b\nEvaluationElement = 0301ad453607e12d0cc11a3359332a40c3a254eaa1afc642\n96528d55bed07ba322e72e22cf3bcb50570fd913cb54f7f09c17aff8787af75f6a7f\naf5640cbb2d9620a6e\nOutput = ad1f76ef939042175e007738906ac0336bbd1d51e287ebaa66901abdd32\n4ea3ffa40bfc5a68e7939c2845e0fd37a5a6e76dadb9907c6cc8579629757fd4d04b\na",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.2. VOPRF Mode",
      "section_title": true,
      "ja": "A.5.2. VOPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = 015c7fc1b4a0b1390925bae915bd9f3d72009d44d9241b962428aad5d13f2\n2803311e7102632a39addc61ea440810222715c9d2f61f03ea424ec9ab1fe5e31cf9\n238\npkSm = 0301505d646f6e4c9102451eb39730c4ba1c4087618641edbdba4a60896b0\n7fd0c9414ce553cbf25b81dfcca50a8f6724ab7a2bc4d0cf736967a287bb6084cc06\n78ac0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.2.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.5.2.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nBlind = 00d1dccf7a51bafaf75d4a866d53d8cafe4d504650f53df8f16f68616333\n88936ea23338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 0301d6e4fb545e043ddb6aee5d5ceeee1b44102615ab04430c2\n7dd0f56988dedcb1df32ef384f160e0e76e718605f14f3f582f9357553d153b99679\n5b4b3628a4f6380\nEvaluationElement = 03013fdeaf887f3d3d283a79e696a54b66ff0edcb559265e\n204a958acf840e0930cc147e2a6835148d8199eebc26c03e9394c9762a1c991dde40\nbca0f8ca003eefb045\nProof = 0077fcc8ec6d059d7759b0a61f871e7c1dadc65333502e09a51994328f79\ne5bda3357b9a4f410a1760a3612c2f8f27cb7cb032951c047cc66da60da583df7b24\n7edd0188e5eb99c71799af1d80d643af16ffa1545acd9e9233fbb370455b10eb257e\na12a1667c1b4ee5b0ab7c93d50ae89602006960f083ca9adc4f6276c0ad60440393c\nProofRandomScalar = 015e80ae32363b32cb76ad4b95a5a34e46bb803d955f0e07\n3a04aa5d92b3fb739f56f9db001266677f62c095021db018cd8cbb55941d4073698c\ne45c405d1348b7b1\nOutput = 5e003d9b2fb540b3d4bab5fedd154912246da1ee5e557afd8f56415faa1\na0fadff6517da802ee254437e4f60907b4cda146e7ba19e249eef7be405549f62954\nb",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.2.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.5.2.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 00d1dccf7a51bafaf75d4a866d53d8cafe4d504650f53df8f16f68616333\n88936ea23338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 03005b05e656cb609ce5ff5faf063bb746d662d67bbd07c0626\n38396f52f0392180cf2365cabb0ece8e19048961d35eeae5d5fa872328dce98df076\nee154dd191c615e\nEvaluationElement = 0301b19fcf482b1fff04754e282292ed736c5f0aa080d4f4\n2663cd3a416c6596f03129e8e096d8671fe5b0d19838312c511d2ce08d431e43e3ef\n06199d8cab7426238d\nProof = 01ec9fece444caa6a57032e8963df0e945286f88fbdf233fb5101f0924f7\nea89c47023f5f72f240e61991fd33a299b5b38c45a5e2dd1a67b072e59dfe86708a3\n59c701e38d383c60cf6969463bcf13251bedad47b7941f52e409a3591398e2792441\n0b18a301c0e19f527cad504fa08388050ac634e1b05c5216d337742f2754e1fc502f\nProofRandomScalar = 015e80ae32363b32cb76ad4b95a5a34e46bb803d955f0e07\n3a04aa5d92b3fb739f56f9db001266677f62c095021db018cd8cbb55941d4073698c\ne45c405d1348b7b1\nOutput = fa15eebba81ecf40954f7135cb76f69ef22c6bae394d1a4362f9b03066b\n54b6604d39f2e53369ca6762a3d9787e230e832aa85955af40ecb8deebb009a8cf47\n4",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.2.3. Test Vector 3, Batch Size 2",
      "section_title": true,
      "ja": "A.5.2.3. テストベクトル3、バッチサイズ2"
    },
    {
      "indent": 3,
      "text": "Input = 00,5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nBlind = 00d1dccf7a51bafaf75d4a866d53d8cafe4d504650f53df8f16f68616333\n88936ea23338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364,015e80ae32363b32cb76ad4b95a5a34e46bb803d955f0e073a04aa5d92b3fb7\n39f56f9db001266677f62c095021db018cd8cbb55941d4073698ce45c405d1348b7b\n1\nBlindedElement = 0301d6e4fb545e043ddb6aee5d5ceeee1b44102615ab04430c2\n7dd0f56988dedcb1df32ef384f160e0e76e718605f14f3f582f9357553d153b99679\n5b4b3628a4f6380,0301403b597538b939b450c93586ba275f9711ba07e42364bac1\nd5769c6824a8b55be6f9a536df46d952b11ab2188363b3d6737635d9543d4dba14a6\ne19421b9245bf5\nEvaluationElement = 03013fdeaf887f3d3d283a79e696a54b66ff0edcb559265e\n204a958acf840e0930cc147e2a6835148d8199eebc26c03e9394c9762a1c991dde40\nbca0f8ca003eefb045,03001f96424497e38c46c904978c2fa1636c5c3dd2e634a85\nd8a7265977c5dce1f02c7e6c118479f0751767b91a39cce6561998258591b5d7c1bb\n02445a9e08e4f3e8d\nProof = 00b4d215c8405e57c7a4b53398caf55f1f1623aaeb22408ddb9ea2913090\n9b3f95dbb1ff366e81e86e918f9f2fd8b80dbb344cd498c9499d112905e585417e00\n68c600fe5dea18b389ef6c4cc062935607b8ccbbb9a84fba3143868a3e8a58efa0bf\n6ca642804d09dc06e980f64837811227c4267b217f1099a4e28b0854f4e5ee659796\nProofRandomScalar = 01ec21c7bb69b0734cb48dfd68433dd93b0fa097e722ed24\n27de86966910acba9f5c350e8040f828bf6ceca27405420cdf3d63cb3aef005f40ba\n51943c8026877963\nOutput = 5e003d9b2fb540b3d4bab5fedd154912246da1ee5e557afd8f56415faa1\na0fadff6517da802ee254437e4f60907b4cda146e7ba19e249eef7be405549f62954\nb,fa15eebba81ecf40954f7135cb76f69ef22c6bae394d1a4362f9b03066b54b6604\nd39f2e53369ca6762a3d9787e230e832aa85955af40ecb8deebb009a8cf474",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.3. POPRF Mode",
      "section_title": true,
      "ja": "A.5.3. POPRFモード"
    },
    {
      "indent": 3,
      "text": "Seed = a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a\n3a3\nKeyInfo = 74657374206b6579\nskSm = 014893130030ce69cf714f536498a02ff6b396888f9bb507985c32928c442\n7d6d39de10ef509aca4240e8569e3a88debc0d392e3361bcd934cb9bdd59e339dff7\nb27\npkSm = 0301de8ceb9ffe9237b1bba87c320ea0bebcfc3447fe6f278065c6c69886d\n692d1126b79b6844f829940ace9b52a5e26882cf7cbc9e57503d4cca3cd834584729\nf812a",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.3.1. Test Vector 1, Batch Size 1",
      "section_title": true,
      "ja": "A.5.3.1. テストベクトル1、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 00\nInfo = 7465737420696e666f\nBlind = 00d1dccf7a51bafaf75d4a866d53d8cafe4d504650f53df8f16f68616333\n88936ea23338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 020095cff9d7ecf65bdfee4ea92d6e748d60b02de34ad98094f\n82e25d33a8bf50138ccc2cc633556f1a97d7ea9438cbb394df612f041c485a515849\nd5ebb2238f2f0e2\nEvaluationElement = 0301408e9c5be3ffcc1c16e5ae8f8aa68446223b0804b119\n62e856af5a6d1c65ebbb5db7278c21db4e8cc06d89a35b6804fb1738a295b691638a\nf77aa1327253f26d01\nProof = 0106a89a61eee9dd2417d2849a8e2167bc5f56e3aed5a3ff23e22511fa1b\n37a29ed44d1bbfd6907d99cfbc558a56aec709282415a864a281e49dc53792a4a638\na0660034306d64be12a94dcea5a6d664cf76681911c8b9a84d49bf12d4893307ec14\n436bd05f791f82446c0de4be6c582d373627b51886f76c4788256e3da7ec8fa18a86\nProofRandomScalar = 015e80ae32363b32cb76ad4b95a5a34e46bb803d955f0e07\n3a04aa5d92b3fb739f56f9db001266677f62c095021db018cd8cbb55941d4073698c\ne45c405d1348b7b1\nOutput = 808ae5b87662eaaf0b39151dd85991b94c96ef214cb14a68bf5c1439548\n82d330da8953a80eea20788e552bc8bbbfff3100e89f9d6e341197b122c46a208733\nb",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.3.2. Test Vector 2, Batch Size 1",
      "section_title": true,
      "ja": "A.5.3.2. テストベクトル2、バッチサイズ1"
    },
    {
      "indent": 3,
      "text": "Input = 5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nInfo = 7465737420696e666f\nBlind = 00d1dccf7a51bafaf75d4a866d53d8cafe4d504650f53df8f16f68616333\n88936ea23338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364\nBlindedElement = 030112ea89cf9cf589496189eafc5f9eb13c9f9e170d6ecde7c\n5b940541cb1a9c5cfeec908b67efe16b81ca00d0ce216e34b3d5f46a658d3fd8573d\n671bdb6515ed508\nEvaluationElement = 0200ebc49df1e6fa61f412e6c391e6f074400ecdd2f56c4a\n8c03fe0f91d9b551f40d4b5258fd891952e8c9b28003bcfa365122e54a5714c8949d\n5d202767b31b4bf1f6\nProof = 0082162c71a7765005cae202d4bd14b84dae63c29067e886b82506992bd9\n94a1c3aac0c1c5309222fe1af8287b6443ed6df5c2e0b0991faddd3564c73c7597ae\ncd9a003b1f1e3c65f28e58ab4e767cfb4adbcaf512441645f4c2aed8bf67d132d966\n006d35fa71a34145414bf3572c1de1a46c266a344dd9e22e7fb1e90ffba1caf556d9\nProofRandomScalar = 015e80ae32363b32cb76ad4b95a5a34e46bb803d955f0e07\n3a04aa5d92b3fb739f56f9db001266677f62c095021db018cd8cbb55941d4073698c\ne45c405d1348b7b1\nOutput = 27032e24b1a52a82ab7f4646f3c5df0f070f499db98b9c5df33972bd5af\n5762c3638afae7912a6c1acdb1ae2ab2fa670bd5486c645a0e55412e08d33a4a0d6e\n3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.3.3. Test Vector 3, Batch Size 2",
      "section_title": true,
      "ja": "A.5.3.3. テストベクトル3、バッチサイズ2"
    },
    {
      "indent": 3,
      "text": "Input = 00,5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\nInfo = 7465737420696e666f\nBlind = 00d1dccf7a51bafaf75d4a866d53d8cafe4d504650f53df8f16f68616333\n88936ea23338fa65ec36e0290022b48eb562889d89dbfa691d1cde91517fa222ed7a\nd364,015e80ae32363b32cb76ad4b95a5a34e46bb803d955f0e073a04aa5d92b3fb7\n39f56f9db001266677f62c095021db018cd8cbb55941d4073698ce45c405d1348b7b\n1\nBlindedElement = 020095cff9d7ecf65bdfee4ea92d6e748d60b02de34ad98094f\n82e25d33a8bf50138ccc2cc633556f1a97d7ea9438cbb394df612f041c485a515849\nd5ebb2238f2f0e2,0201a328cf9f3fdeb86b6db242dd4cbb436b3a488b70b72d2fbb\nd1e5f50d7b0878b157d6f278c6a95c488f3ad52d6898a421658a82fe7ceb000b01ae\ndea7967522d525\nEvaluationElement = 0301408e9c5be3ffcc1c16e5ae8f8aa68446223b0804b119\n62e856af5a6d1c65ebbb5db7278c21db4e8cc06d89a35b6804fb1738a295b691638a\nf77aa1327253f26d01,020062ab51ac3aa829e0f5b7ae50688bcf5f63a18a83a6e0d\na538666b8d50c7ea2b4ef31f4ac669302318dbebe46660acdda695da30c22cee7ca2\n1f6984a720504502e\nProof = 00731738844f739bca0cca9d1c8bea204bed4fd00285785738b985763741\nde5cdfa275152d52b6a2fdf7792ef3779f39ba34581e56d62f78ecad5b7f8083f384\n961501cd4b43713253c022692669cf076b1d382ecd8293c1de69ea569737f37a2477\n2ab73517983c1e3db5818754ba1f008076267b8058b6481949ae346cdc17a8455fe2\nProofRandomScalar = 01ec21c7bb69b0734cb48dfd68433dd93b0fa097e722ed24\n27de86966910acba9f5c350e8040f828bf6ceca27405420cdf3d63cb3aef005f40ba\n51943c8026877963\nOutput = 808ae5b87662eaaf0b39151dd85991b94c96ef214cb14a68bf5c1439548\n82d330da8953a80eea20788e552bc8bbbfff3100e89f9d6e341197b122c46a208733\nb,27032e24b1a52a82ab7f4646f3c5df0f070f499db98b9c5df33972bd5af5762c36\n38afae7912a6c1acdb1ae2ab2fa670bd5486c645a0e55412e08d33a4a0d6e3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "section_title": true,
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This document resulted from the work of the Privacy Pass team [PrivacyPass]. The authors would also like to acknowledge helpful conversations with Hugo Krawczyk. Eli-Shaoul Khedouri provided additional review and comments on key consistency. Daniel Bourdrez, Tatiana Bradley, Sofia Celi, Frank Denis, Julia Hesse, Russ Housley, Kevin Lewi, Christopher Patton, and Bas Westerbaan also provided helpful input and contributions to the document.",
      "ja": "この文書は、Privacy Passチーム[PrivacyPass]の作業によって作成されました。著者はHugo Krawczykとの有益な会話に感謝します。Eli-Shaoul Khedouriは主要な整合性に関する追加のレビューとコメントを提供しました。Daniel Bourdrez、Tatiana Bradley、Sofia Celi、Frank Denis、Julia Hesse、Russ Housley、Kevin Lewi、Christopher Patton、およびBas Westerbaanも文書に有益な入力と貢献をしました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "Alex Davidson\nBrave Software\nEmail: alex.davidson92@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Armando Faz-Hernandez\nCloudflare, Inc.\n101 Townsend St\nSan Francisco, CA\nUnited States of America\nEmail: armfazh@cloudflare.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Nick Sullivan\nCloudflare, Inc.\n101 Townsend St\nSan Francisco, CA\nUnited States of America\nEmail: nicholas.sullivan+ietf@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Christopher A. Wood\nCloudflare, Inc.\n101 Townsend St\nSan Francisco, CA\nUnited States of America\nEmail: caw@heapingbits.net",
      "raw": true,
      "ja": ""
    }
  ]
}