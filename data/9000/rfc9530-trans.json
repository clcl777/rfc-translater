{
  "title": {
    "text": "RFC 9530 - Digest Fields",
    "ja": "RFC 9530 - 消化フィールド"
  },
  "number": 9530,
  "created_at": "2024-02-25 22:42:24.516564+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                          R. Polli\nRequest for Comments: 9530             Team Digitale, Italian Government\nObsoletes: 3230                                                L. Pardue\nCategory: Standards Track                                     Cloudflare\nISSN: 2070-1721                                            February 2024",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 29,
      "text": "Digest Fields",
      "title": true,
      "section_title": true,
      "ja": "消化フィールド"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document defines HTTP fields that support integrity digests. The Content-Digest field can be used for the integrity of HTTP message content. The Repr-Digest field can be used for the integrity of HTTP representations. Want-Content-Digest and Want-Repr-Digest can be used to indicate a sender's interest and preferences for receiving the respective Integrity fields.",
      "ja": "このドキュメントでは、整合性ダイジェストをサポートするHTTPフィールドを定義します。コンテンツダイジェストフィールドは、HTTPメッセージコンテンツの整合性に使用できます。Repl Digestフィールドは、HTTP表現の整合性に使用できます。Want-Content-DigestとWant-Repr-Digestを使用して、それぞれの整合性分野を受信するための送信者の関心と好みを示すことができます。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes RFC 3230 and the Digest and Want-Digest HTTP fields.",
      "ja": "このドキュメントは、RFC 3230とダイジェストとディゲストのHTTPフィールドを廃止します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準トラックドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 7841のセクション2で入手できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9530.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https：//www.rfc-editor.org/info/rfc9530で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2024 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2024 IETF Trustおよび文書著者として特定された人。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、改訂されたBSDライセンスで説明されている保証なしで提供されるように、改訂されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Document Structure\n  1.2.  Concept Overview\n  1.3.  Obsoleting RFC 3230\n  1.4.  Notational Conventions\n2.  The Content-Digest Field\n3.  The Repr-Digest Field\n  3.1.  Using Repr-Digest in State-Changing Requests\n  3.2.  Repr-Digest and Content-Location in Responses\n4.  Integrity Preference Fields\n5.  Hash Algorithm Considerations and Registration\n6.  Security Considerations\n  6.1.  HTTP Messages Are Not Protected in Full\n  6.2.  End-to-End Integrity\n  6.3.  Usage in Signatures\n  6.4.  Usage in Trailer Fields\n  6.5.  Variations within Content-Encoding\n  6.6.  Algorithm Agility\n  6.7.  Resource Exhaustion\n7.  IANA Considerations\n  7.1.  HTTP Field Name Registration\n  7.2.  Creation of the Hash Algorithms for HTTP Digest Fields\n        Registry\n  7.3.  Deprecate the Hypertext Transfer Protocol (HTTP) Digest\n        Algorithm Values Registry\n8.  References\n  8.1.  Normative References\n  8.2.  Informative References\nAppendix A.  Resource Representation and Representation Data\nAppendix B.  Examples of Unsolicited Digest\n  B.1.  Server Returns Full Representation Data\n  B.2.  Server Returns No Representation Data\n  B.3.  Server Returns Partial Representation Data\n  B.4.  Client and Server Provide Full Representation Data\n  B.5.  Client Provides Full Representation Data and Server\n         Provides No Representation Data\n  B.6.  Client and Server Provide Full Representation Data\n  B.7.  POST Response Does Not Reference the Request URI\n  B.8.  POST Response Describes the Request Status\n  B.9.  Digest with PATCH\n  B.10. Error Responses\n  B.11. Use with Trailer Fields and Transfer Coding\nAppendix C.  Examples of Want-Repr-Digest Solicited Digest\n  C.1.  Server Selects Client's Least Preferred Algorithm\n  C.2.  Server Selects Algorithm Unsupported by Client\n  C.3.  Server Does Not Support Client Algorithm and Returns an\n        Error\nAppendix D.  Sample Digest Values\nAppendix E.  Migrating from RFC 3230\nAcknowledgements\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "HTTP does not define the means to protect the data integrity of content or representations. When HTTP messages are transferred between endpoints, lower-layer features or properties such as TCP checksums or TLS records [TLS] can provide some integrity protection. However, transport-oriented integrity provides a limited utility because it is opaque to the application layer and only covers the extent of a single connection. HTTP messages often travel over a chain of separate connections. In between connections, there is a possibility for data corruption. An HTTP integrity mechanism can provide the means for endpoints, or applications using HTTP, to detect data corruption and make a choice about how to act on it. An example use case is to aid fault detection and diagnosis across system boundaries.",
      "ja": "HTTPは、コンテンツまたは表現のデータ整合性を保護する手段を定義しません。HTTPメッセージがエンドポイント、低層機能、またはTCPチェックサムやTLSレコード[TLS]などのプロパティ間で転送されると、ある程度の整合性保護を提供できます。ただし、輸送指向の整合性は、アプリケーションレイヤーに不透明であり、単一の接続の範囲のみをカバーするため、限られたユーティリティを提供します。HTTPメッセージは、多くの場合、個別の接続のチェーンを越えて移動します。接続の合間に、データの腐敗の可能性があります。HTTP整合性メカニズムは、データの破損を検出し、それにどのように行動するかを選択するために、HTTPを使用したエンドポイントまたはアプリケーションの手段を提供できます。ユースケースの例は、システムの境界を越えて障害検出と診断を支援することです。"
    },
    {
      "indent": 3,
      "text": "This document defines two digest integrity mechanisms for HTTP. First, content integrity, which acts on conveyed content (Section 6.4 of [HTTP]). Second, representation data integrity, which acts on representation data (Section 8.1 of [HTTP]). This supports advanced use cases, such as validating the integrity of a resource that was reconstructed from parts retrieved using multiple requests or connections.",
      "ja": "このドキュメントでは、HTTPの2つのダイジェスト整合性メカニズムを定義しています。まず、コンテンツのコンテンツに作用するコンテンツの完全性（[HTTP]のセクション6.4）。第二に、表現データの整合性は、表現データに作用します（[http]のセクション8.1）。これは、複数のリクエストまたは接続を使用して取得した部品から再構築されたリソースの整合性を検証するなど、高度なユースケースをサポートします。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes [RFC3230] and therefore the Digest and Want-Digest HTTP fields; see Section 1.3.",
      "ja": "このドキュメントは廃止[RFC3230]、したがってダイジェストとディゲストのHTTPフィールド。セクション1.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "1.1. Document Structure",
      "section_title": true,
      "ja": "1.1. ドキュメント構造"
    },
    {
      "indent": 3,
      "text": "This document is structured as follows:",
      "ja": "このドキュメントは次のように構成されています。"
    },
    {
      "indent": 3,
      "text": "* New request and response header and trailer field definitions.",
      "ja": "* 新しいリクエストと応答のヘッダーとトレーラーのフィールドの定義。"
    },
    {
      "indent": 6,
      "text": "- Section 2 (Content-Digest),",
      "ja": "- セクション2（コンテンツダイジェスト）、"
    },
    {
      "indent": 6,
      "text": "- Section 3 (Repr-Digest), and",
      "ja": "- セクション3（再生）、および"
    },
    {
      "indent": 6,
      "text": "- Section 4 (Want-Content-Digest and Want-Repr-Digest).",
      "ja": "- セクション4（コンテンツダイゲストが必要であり、違反-REPR-Digest）。"
    },
    {
      "indent": 3,
      "text": "* Considerations specific to representation data integrity.",
      "ja": "* 表現データの整合性に固有の考慮事項。"
    },
    {
      "indent": 6,
      "text": "- Section 3.1 (State-changing requests),",
      "ja": "- セクション3.1（状態を変更するリクエスト）、"
    },
    {
      "indent": 6,
      "text": "- Section 3.2 (Content-Location),",
      "ja": "- セクション3.2（コンテンツロケーション）、"
    },
    {
      "indent": 6,
      "text": "- Appendix A contains worked examples of representation data in message exchanges, and",
      "ja": "- 付録Aには、メッセージ交換における表現データの機能例が含まれています。"
    },
    {
      "indent": 6,
      "text": "- Appendixes B and C contain worked examples of Repr-Digest and Want-Repr-Digest fields in message exchanges.",
      "ja": "- 付録BとCには、メッセージ交換におけるRepr-DigestおよびWant-REPR Digestフィールドの作業例が含まれています。"
    },
    {
      "indent": 3,
      "text": "* Section 5 presents hash algorithm considerations and defines registration procedures for future entries.",
      "ja": "* セクション5では、ハッシュアルゴリズムの考慮事項を示し、将来のエントリの登録手順を定義します。"
    },
    {
      "indent": 0,
      "text": "1.2. Concept Overview",
      "section_title": true,
      "ja": "1.2. コンセプトの概要"
    },
    {
      "indent": 3,
      "text": "The HTTP fields defined in this document can be used for HTTP integrity. Senders choose a hashing algorithm and calculate a digest from an input related to the HTTP message. The algorithm identifier and digest are transmitted in an HTTP field. Receivers can validate the digest for integrity purposes. Hashing algorithms are registered in the \"Hash Algorithms for HTTP Digest Fields\" registry (see Section 7.2).",
      "ja": "このドキュメントで定義されているHTTPフィールドは、HTTPの整合性に使用できます。送信者は、ハッシュアルゴリズムを選択し、HTTPメッセージに関連する入力からダイジェストを計算します。アルゴリズム識別子とダイジェストは、HTTPフィールドで送信されます。受信機は、完全性のためにダイジェストを検証できます。ハッシュアルゴリズムは、「HTTPダイジェストフィールドのハッシュアルゴリズム」レジストリに登録されています（セクション7.2を参照）。"
    },
    {
      "indent": 3,
      "text": "Selecting the data on which digests are calculated depends on the use case of the HTTP messages. This document provides different fields for HTTP representation data and HTTP content.",
      "ja": "ダイジェストが計算されるデータの選択は、HTTPメッセージのユースケースによって異なります。このドキュメントは、HTTP表現データとHTTPコンテンツのさまざまなフィールドを提供します。"
    },
    {
      "indent": 3,
      "text": "There are use cases where a simple digest of the HTTP content bytes is required. The Content-Digest request and response header and trailer field is defined to support digests of content (Section 6.4 of [HTTP]); see Section 2.",
      "ja": "HTTPコンテンツバイトの単純なダイジェストが必要なユースケースがあります。コンテンツダイジェストリクエストと応答ヘッダーとトレーラーフィールドは、コンテンツのダイジェストをサポートするために定義されています（[http]のセクション6.4）。セクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "For more advanced use cases, the Repr-Digest request and response header and trailer field (Section 3) is defined. It contains a digest value computed by applying a hashing algorithm to selected representation data (Section 8.1 of [HTTP]). Basing Repr-Digest on the selected representation makes it straightforward to apply it to use cases where the message content requires some sort of manipulation to be considered as representation of the resource or the content conveys a partial representation of a resource, such as range requests (see Section 14 of [HTTP]).",
      "ja": "より高度なユースケースについては、再生リクエストリクエストと応答ヘッダーとトレーラーフィールド（セクション3）が定義されています。ハッシュアルゴリズムを選択した表現データに適用して計算されたダイジェスト値が含まれています（[HTTP]のセクション8.1）。選択した表現に基づいて再生することにより、メッセージコンテンツがリソースの表現と見なされるために何らかの操作を必要とするユースケースまたはコンテンツが範囲要求などのリソースの部分的な表現を伝えることを簡単に適用することが簡単になります（[http]のセクション14を参照してください。"
    },
    {
      "indent": 3,
      "text": "Content-Digest and Repr-Digest support hashing algorithm agility. The Want-Content-Digest and Want-Repr-Digest fields allow endpoints to express interest in Content-Digest and Repr-Digest, respectively, and to express algorithm preferences in either.",
      "ja": "コンテンツダイジストおよびリプタージュートサポートハッシュアルゴリズムの俊敏性。Want-Content-DigestとWant-Repr-Digestフィールドにより、エンドポイントはそれぞれコンテンツダイジストと再生への関心を表明し、どちらでもアルゴリズムの好みを表現できます。"
    },
    {
      "indent": 3,
      "text": "Content-Digest and Repr-Digest are collectively termed \"Integrity fields\". Want-Content-Digest and Want-Repr-Digest are collectively termed \"Integrity preference fields\".",
      "ja": "コンテンツダイジストとリプリゲストは、集合的に「完全性フィールド」と呼ばれます。Want-Content-DigestとWant-Repr-Digestは、集合的に「整合性優先フィールド」と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Integrity fields are tied to the Content-Encoding and Content-Type header fields. Therefore, a given resource may have multiple different digest values when transferred with HTTP.",
      "ja": "整合性フィールドは、コンテンツエンコードおよびコンテンツタイプのヘッダーフィールドに結び付けられています。したがって、特定のリソースは、HTTPで転送されると複数の異なるダイジェスト値を持つ場合があります。"
    },
    {
      "indent": 3,
      "text": "Integrity fields apply to HTTP message content or HTTP representations. They do not apply to HTTP messages or fields. However, they can be combined with other mechanisms that protect metadata, such as digital signatures, in order to protect the phases of an HTTP exchange in whole or in part. For example, HTTP Message Signatures [SIGNATURES] could be used to sign Integrity fields, thus providing coverage for HTTP content or representation data.",
      "ja": "整合性フィールドは、HTTPメッセージコンテンツまたはHTTP表現に適用されます。それらはHTTPメッセージまたはフィールドには適用されません。ただし、HTTP交換の段階全体または一部を保護するために、デジタル署名などのメタデータを保護する他のメカニズムと組み合わせることができます。たとえば、HTTPメッセージ署名[署名]を使用して整合フィールドに署名することができ、HTTPコンテンツまたは表現データのカバレッジを提供できます。"
    },
    {
      "indent": 3,
      "text": "This specification does not define means for authentication, authorization, or privacy.",
      "ja": "この仕様は、認証、承認、またはプライバシーの手段を定義するものではありません。"
    },
    {
      "indent": 0,
      "text": "1.3. Obsoleting RFC 3230",
      "section_title": true,
      "ja": "1.3. 廃止RFC 3230"
    },
    {
      "indent": 3,
      "text": "[RFC3230] defined the Digest and Want-Digest HTTP fields for HTTP integrity. It also coined the terms \"instance\" and \"instance manipulation\" in order to explain concepts, such as selected representation data (Section 8.1 of [HTTP]), that are now more universally defined and implemented as HTTP semantics.",
      "ja": "[RFC3230]は、HTTPの整合性のためのDigestおよびWant Digest HTTPフィールドを定義しました。また、選択された表現データ（[HTTP]のセクション8.1）などの概念を説明するために、「インスタンス」と「インスタンス操作」という用語を作成しました。"
    },
    {
      "indent": 3,
      "text": "Experience has shown that implementations of [RFC3230] have interpreted the meaning of \"instance\" inconsistently, leading to interoperability issues. The most common issue relates to the mistake of calculating the digest using (what we now call) message content, rather than using (what we now call) representation data as was originally intended. Interestingly, time has also shown that a digest of message content can be beneficial for some use cases, so it is difficult to detect if non-conformance to [RFC3230] is intentional or unintentional.",
      "ja": "[RFC3230]の実装は、「インスタンス」の意味を一貫性のない意味で解釈し、相互運用性の問題につながることが経験から示されています。最も一般的な問題は、元々意図されていたように（現在私たちが現在呼んでいる）表現データを使用するのではなく、メッセージコンテンツを使用してダイジェストを計算する間違いに関連しています。興味深いことに、時間はメッセージコンテンツのダイジェストが一部のユースケースに有益であることも示しているため、[RFC3230]への不適合が意図的または意図的ではないかどうかを検出することは困難です。"
    },
    {
      "indent": 3,
      "text": "In order to address potential inconsistencies and ambiguity across implementations of Digest and Want-Digest, this document obsoletes [RFC3230]. The Integrity fields (Sections 2 and 3) and Integrity preference fields (Section 4) defined in this document are better aligned with current HTTP semantics and have names that more clearly articulate the intended usages.",
      "ja": "このドキュメントが廃止された[RFC3230]。このドキュメントで定義されている整合性フィールド（セクション2および3）および整合性選好フィールド（セクション4）は、現在のHTTPセマンティクスとより適切に整合しており、意図した使用法をより明確に明確にする名前を持っています。"
    },
    {
      "indent": 0,
      "text": "1.4. Notational Conventions",
      "section_title": true,
      "ja": "1.4. 表記規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 3,
      "text": "This document uses the Augmented BNF defined in [RFC5234] and updated by [RFC7405]. This includes the rules CR (carriage return), LF (line feed), and CRLF (CR LF).",
      "ja": "このドキュメントでは、[RFC5234]で定義され、[RFC7405]によって更新された拡張BNFを使用します。これには、ルールCR（キャリッジリターン）、LF（ラインフィード）、およびCRLF（CR LF）が含まれます。"
    },
    {
      "indent": 3,
      "text": "This document uses the following terminology from Section 3 of [STRUCTURED-FIELDS] to specify syntax and parsing: Boolean, Byte Sequence, Dictionary, Integer, and List.",
      "ja": "このドキュメントでは、[構造化場]のセクション3の次の用語を使用して、構文と解析を指定します：ブール、バイトシーケンス、辞書、整数、およびリスト。"
    },
    {
      "indent": 3,
      "text": "The definitions \"representation\", \"selected representation\", \"representation data\", \"representation metadata\", \"user agent\", and \"content\" in this document are to be interpreted as described in [HTTP].",
      "ja": "「表現」、「選択された表現」、「表現データ」、「表現メタデータ」、「ユーザーエージェント」、および「コンテンツ」の定義は、[http]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "This document uses the line folding strategies described in [FOLDING].",
      "ja": "このドキュメントでは、[折りたたみ]で説明されているライン折りたたみ戦略を使用しています。"
    },
    {
      "indent": 3,
      "text": "Hashing algorithm names respect the casing used in their definition document (e.g., SHA-1, CRC32c).",
      "ja": "ハッシュアルゴリズム名は、定義ドキュメント（SHA-1、CRC32Cなど）で使用されているケーシングを尊重します。"
    },
    {
      "indent": 3,
      "text": "HTTP messages indicate hashing algorithms using an Algorithm Key (algorithms). Where the document refers to an Algorithm Key in prose, it is quoted (e.g., \"sha\", \"crc32c\").",
      "ja": "HTTPメッセージは、アルゴリズムキー（アルゴリズム）を使用したハッシュアルゴリズムを示します。ドキュメントが散文のアルゴリズムキーを参照する場合、それは引用されています（例： \"sha\"、 \"crc32c\"）。"
    },
    {
      "indent": 3,
      "text": "The term \"checksum\" describes the output of applying an algorithm to a sequence of bytes, whereas \"digest\" is only used in relation to the value contained in the fields.",
      "ja": "「チェックサム」という用語は、アルゴリズムをバイトのシーケンスに適用する出力を説明しますが、「ダイジェスト」はフィールドに含まれる値に関連してのみ使用されます。"
    },
    {
      "indent": 3,
      "text": "\"Integrity fields\" is the collective term for Content-Digest and Repr-Digest.",
      "ja": "「Integrity Fields」は、コンテンツダイジストとリプリゲストの集合用語です。"
    },
    {
      "indent": 3,
      "text": "\"Integrity preference fields\" is the collective term for Want-Repr-Digest and Want-Content-Digest.",
      "ja": "「整合性の優先フィールド」は、Want-Repr-DigestとWant-Content-Digestの集合用語です。"
    },
    {
      "indent": 0,
      "text": "2. The Content-Digest Field",
      "section_title": true,
      "ja": "2. コンテンツダイジェストフィールド"
    },
    {
      "indent": 3,
      "text": "The Content-Digest HTTP field can be used in requests and responses to communicate digests that are calculated using a hashing algorithm applied to the actual message content (see Section 6.4 of [HTTP]). It is a Dictionary (see Section 3.2 of [STRUCTURED-FIELDS]), where each:",
      "ja": "コンテンツダイジストHTTPフィールドは、実際のメッセージコンテンツに適用されたハッシュアルゴリズムを使用して計算されるダイジェストを通信するための要求と応答で使用できます（[HTTP]のセクション6.4を参照）。それは辞書です（[構造化場]のセクション3.2を参照）、それぞれ："
    },
    {
      "indent": 3,
      "text": "* key conveys the hashing algorithm (see Section 5) used to compute the digest;",
      "ja": "* キーは、ダイジェストの計算に使用されるハッシュアルゴリズム（セクション5を参照）を伝えます。"
    },
    {
      "indent": 3,
      "text": "* value is a Byte Sequence (Section 3.3.5 of [STRUCTURED-FIELDS]) that conveys an encoded version of the byte output produced by the digest calculation.",
      "ja": "* 値は、ダイジェスト計算によって生成されるバイト出力のエンコードされたバージョンを伝えるバイトシーケンス（[構造化場]のセクション3.3.5）です。"
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nContent-Digest: \\\n  sha-512=:YMAam51Jz/jOATT6/zvHrLVgOYTGFy1d6GJiOHTohq4yP+pgk4vf2aCs\\\n  yRZOtw8MjkM7iw7yZ/WkppmM44T3qg==:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Dictionary type can be used, for example, to attach multiple digests calculated using different hashing algorithms in order to support a population of endpoints with different or evolving capabilities. Such an approach could support transitions away from weaker algorithms (see Section 6.6).",
      "ja": "辞書タイプを使用して、異なるハッシュアルゴリズムを使用して計算された複数のダイジェストを添付して、異なるまたは進化する機能を持つエンドポイントの母集団をサポートすることができます。このようなアプローチは、より弱いアルゴリズムから離れた遷移をサポートできます（セクション6.6を参照）。"
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nContent-Digest: \\\n  sha-256=:d435Qo+nKZ+gLcUHn7GQtQ72hiBVAgqoLsZnZPiTGPk=:,\\\n  sha-512=:YMAam51Jz/jOATT6/zvHrLVgOYTGFy1d6GJiOHTohq4yP+pgk4vf2aCs\\\n  yRZOtw8MjkM7iw7yZ/WkppmM44T3qg==:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A recipient MAY ignore any or all digests. Application-specific behavior or local policy MAY set additional constraints on the processing and validation practices of the conveyed digests. The security considerations cover some of the issues related to ignoring digests (see Section 6.6) and validating multiple digests (see Section 6.7).",
      "ja": "受信者は、一部またはすべての消化を無視する場合があります。アプリケーション固有の動作またはローカルポリシーは、伝達されたダイジェストの処理および検証慣行に追加の制約を設定する場合があります。セキュリティ上の考慮事項は、ダイジェストを無視し（セクション6.6を参照）、複数のダイジェストを検証することに関連する問題の一部をカバーしています（セクション6.7を参照）。"
    },
    {
      "indent": 3,
      "text": "A sender MAY send a digest without knowing whether the recipient supports a given hashing algorithm. A sender MAY send a digest if it knows the recipient will ignore it.",
      "ja": "送信者は、受信者が特定のハッシュアルゴリズムをサポートするかどうかを知らずにダイジェストを送信できます。送信者は、受信者がそれを無視することを知っている場合、ダイジェストを送信する場合があります。"
    },
    {
      "indent": 3,
      "text": "Content-Digest can be sent in a trailer section. In this case, Content-Digest MAY be merged into the header section; see Section 6.5.1 of [HTTP].",
      "ja": "コンテンツダイジストは、トレーラーセクションで送信できます。この場合、コンテンツダイジェストをヘッダーセクションにマージすることができます。[http]のセクション6.5.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "3. The Repr-Digest Field",
      "section_title": true,
      "ja": "3. 再生フィールド"
    },
    {
      "indent": 3,
      "text": "The Repr-Digest HTTP field can be used in requests and responses to communicate digests that are calculated using a hashing algorithm applied to the entire selected representation data (see Section 8.1 of [HTTP]).",
      "ja": "Rep-Digest HTTPフィールドは、選択した表現データ全体に適用されたハッシュアルゴリズムを使用して計算される通信ダイジェストを要求と応答に使用できます（[HTTP]のセクション8.1を参照）。"
    },
    {
      "indent": 3,
      "text": "Representations take into account the effect of the HTTP semantics on messages. For example, the content can be affected by range requests or methods, such as HEAD, while the way the content is transferred \"on the wire\" is dependent on other transformations (e.g., transfer codings for HTTP/1.1; see Section 6.1 of [HTTP/1.1]). To help illustrate HTTP representation concepts, several examples are provided in Appendix A.",
      "ja": "表現は、メッセージに対するHTTPセマンティクスの効果を考慮しています。たとえば、コンテンツはヘッドなどの範囲要求またはメソッドの影響を受ける可能性がありますが、コンテンツの「ワイヤー上」の転送方法は他の変換に依存します（たとえば、HTTP/1.1の転送コーディング。http/1.1]）。HTTP表現の概念を説明するために、いくつかの例を付録Aに示します。"
    },
    {
      "indent": 3,
      "text": "When a message has no representation data, it is still possible to assert that no representation data was sent by computing the digest on an empty string (see Section 6.3).",
      "ja": "メッセージに表現データがない場合、空の文字列でダイジェストを計算することによって表現データが送信されなかったと主張することができます（セクション6.3を参照）。"
    },
    {
      "indent": 3,
      "text": "Repr-Digest is a Dictionary (see Section 3.2 of [STRUCTURED-FIELDS]), where each:",
      "ja": "Repl-Digestは辞書です（[構造化場]のセクション3.2を参照）、それぞれ："
    },
    {
      "indent": 3,
      "text": "* key conveys the hashing algorithm (see Section 5) used to compute the digest;",
      "ja": "* キーは、ダイジェストの計算に使用されるハッシュアルゴリズム（セクション5を参照）を伝えます。"
    },
    {
      "indent": 3,
      "text": "* value is a Byte Sequence that conveys an encoded version of the byte output produced by the digest calculation.",
      "ja": "* 値は、ダイジェスト計算によって生成されるバイト出力のエンコードされたバージョンを伝えるバイトシーケンスです。"
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nRepr-Digest: \\\n  sha-512=:YMAam51Jz/jOATT6/zvHrLVgOYTGFy1d6GJiOHTohq4yP+pgk4vf2aCs\\\n  yRZOtw8MjkM7iw7yZ/WkppmM44T3qg==:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Dictionary type can be used to attach multiple digests calculated using different hashing algorithms in order to support a population of endpoints with different or evolving capabilities. Such an approach could support transitions away from weaker algorithms (see Section 6.6).",
      "ja": "辞書タイプを使用して、異なるハッシュアルゴリズムを使用して計算された複数のダイジェストを添付して、異なるまたは進化する機能を持つエンドポイントの集団をサポートすることができます。このようなアプローチは、より弱いアルゴリズムから離れた遷移をサポートできます（セクション6.6を参照）。"
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nRepr-Digest: \\\n  sha-256=:d435Qo+nKZ+gLcUHn7GQtQ72hiBVAgqoLsZnZPiTGPk=:,\\\n  sha-512=:YMAam51Jz/jOATT6/zvHrLVgOYTGFy1d6GJiOHTohq4yP+pgk4vf2aCs\\\n  yRZOtw8MjkM7iw7yZ/WkppmM44T3qg==:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A recipient MAY ignore any or all digests. Application-specific behavior or local policy MAY set additional constraints on the processing and validation practices of the conveyed digests. The security considerations cover some of the issues related to ignoring digests (see Section 6.6) and validating multiple digests (see Section 6.7).",
      "ja": "受信者は、一部またはすべての消化を無視する場合があります。アプリケーション固有の動作またはローカルポリシーは、伝達されたダイジェストの処理および検証慣行に追加の制約を設定する場合があります。セキュリティ上の考慮事項は、ダイジェストを無視し（セクション6.6を参照）、複数のダイジェストを検証することに関連する問題の一部をカバーしています（セクション6.7を参照）。"
    },
    {
      "indent": 3,
      "text": "A sender MAY send a digest without knowing whether the recipient supports a given hashing algorithm. A sender MAY send a digest if it knows the recipient will ignore it.",
      "ja": "送信者は、受信者が特定のハッシュアルゴリズムをサポートするかどうかを知らずにダイジェストを送信できます。送信者は、受信者がそれを無視することを知っている場合、ダイジェストを送信する場合があります。"
    },
    {
      "indent": 3,
      "text": "Repr-Digest can be sent in a trailer section. In this case, Repr-Digest MAY be merged into the header section; see Section 6.5.1 of [HTTP].",
      "ja": "リプリゲストは、トレーラーセクションで送信できます。この場合、再生はヘッダーセクションにマージされる場合があります。[http]のセクション6.5.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.1. Using Repr-Digest in State-Changing Requests",
      "section_title": true,
      "ja": "3.1. 状態を変えるリクエストでの再掘削を使用します"
    },
    {
      "indent": 3,
      "text": "When the representation enclosed in a state-changing request does not describe the target resource, the representation digest MUST be computed on the representation data. This is the only possible choice because representation digest requires complete representation metadata (see Section 3).",
      "ja": "状態変化する要求に囲まれた表現がターゲットリソースを説明していない場合、表現ダイジェストは表現データで計算する必要があります。表現ダイジェストには完全な表現メタデータが必要であるため、これは唯一の可能な選択です（セクション3を参照）。"
    },
    {
      "indent": 3,
      "text": "In responses,",
      "ja": "回答では、"
    },
    {
      "indent": 3,
      "text": "* if the representation describes the status of the request, Repr-Digest MUST be computed on the enclosed representation (see Appendix B.8);",
      "ja": "* 表現がリクエストのステータスを記述している場合、囲まれた表現でリプリダイジェストを計算する必要があります（付録B.8を参照）。"
    },
    {
      "indent": 3,
      "text": "* if there is a referenced resource, Repr-Digest MUST be computed on the selected representation of the referenced resource even if that is different from the target resource. This might or might not result in computing Repr-Digest on the enclosed representation.",
      "ja": "* 参照されたリソースがある場合、ターゲットリソースとは異なる場合でも、参照されたリソースの選択した表現でリプリダイジェストを計算する必要があります。これは、囲まれた表現のコンピューティングを再生する可能性がある場合とそうでない可能性があります。"
    },
    {
      "indent": 3,
      "text": "The latter case is done according to the HTTP semantics of the given method, for example, using the Content-Location header field (see Section 8.7 of [HTTP]). In contrast, the Location header field does not affect Repr-Digest because it is not representation metadata.",
      "ja": "後者の場合は、特定の方法のHTTPセマンティクス、たとえばコンテンツロケーションヘッダーフィールドを使用して行われます（[HTTP]のセクション8.7を参照）。対照的に、ロケーションヘッダーフィールドは、表現メタデータではないため、再生に影響しません。"
    },
    {
      "indent": 3,
      "text": "For example, in PATCH requests, the representation digest will be computed on the patch document because the representation metadata refers to the patch document and not the target resource (see Section 2 of [PATCH]). In responses, instead, the representation digest will be computed on the selected representation of the patched resource.",
      "ja": "たとえば、パッチリクエストでは、表現メタデータはターゲットリソースではなくパッチドキュメントを参照するため、表現ダイジェストはパッチドキュメントで計算されます（[パッチ]のセクション2を参照）。応答では、代わりに、パッチされたリソースの選択された表現で表現ダイジェストが計算されます。"
    },
    {
      "indent": 0,
      "text": "3.2. Repr-Digest and Content-Location in Responses",
      "section_title": true,
      "ja": "3.2. 応答の再び消化とコンテンツロケーション"
    },
    {
      "indent": 3,
      "text": "When a state-changing method returns the Content-Location header field, the enclosed representation refers to the resource identified by its value and Repr-Digest is computed accordingly. An example is given in Appendix B.7.",
      "ja": "状態を変えるメソッドがコンテンツロケーションヘッダーフィールドを返すと、囲まれた表現は、その値によって識別されたリソースと、それに応じて計算されます。例を付録B.7に示します。"
    },
    {
      "indent": 0,
      "text": "4. Integrity Preference Fields",
      "section_title": true,
      "ja": "4. 整合性選好フィールド"
    },
    {
      "indent": 3,
      "text": "Senders can indicate their interest in Integrity fields and hashing algorithm preferences using the Want-Content-Digest or Want-Repr-Digest HTTP fields. These can be used in both requests and responses.",
      "ja": "送信者は、整合性フィールドへの関心と、Want-Content-DigestまたはWant-Repr-Digest HTTPフィールドを使用して、アルゴリズムの好みをハッシュすることを示すことができます。これらは、リクエストと応答の両方で使用できます。"
    },
    {
      "indent": 3,
      "text": "Want-Content-Digest indicates that the sender would like to receive (via the Content-Digest field) a content digest on messages associated with the request URI and representation metadata. Want-Repr-Digest indicates that the sender would like to receive (via the Repr-Digest field) a representation digest on messages associated with the request URI and representation metadata.",
      "ja": "Want-Content-Digestは、送信者が（コンテンツダイジェストフィールドを介して）リクエストURIおよび表現メタデータに関連付けられたメッセージでコンテンツダイジェストを（コンテンツダイジストフィールドを介して）受信したいことを示しています。Want-Repr-Digestは、送信者が（再生フィールドを介して）リクエストURIおよび表現メタデータに関連付けられたメッセージでの表現ダイジェストを（再生フィールドを介して）受信したいことを示しています。"
    },
    {
      "indent": 3,
      "text": "If Want-Content-Digest or Want-Repr-Digest are used in a response, it indicates that the server would like the client to provide the respective Integrity field on future requests.",
      "ja": "必要なコンテンツダイゲストまたはwant-repr-digestが応答で使用される場合、サーバーは、将来の要求に応じてクライアントにそれぞれの整合性フィールドを提供することを望んでいることを示しています。"
    },
    {
      "indent": 3,
      "text": "Integrity preference fields are only a hint. The receiver of the field can ignore it and send an Integrity field using any algorithm or omit the field entirely; for example, see Appendix C.2. It is not a protocol error if preferences are ignored. Applications that use Integrity fields and Integrity preferences can define expectations or constraints that operate in addition to this specification. Ignored preferences are an application-specific concern.",
      "ja": "整合性の優先度フィールドはヒントにすぎません。フィールドの受信者は、それを無視し、あらゆるアルゴリズムを使用して整合性フィールドを送信したり、フィールドを完全に省略したりできます。たとえば、付録C.2を参照してください。設定が無視された場合、それはプロトコルエラーではありません。整合性フィールドと整合性の好みを使用するアプリケーションは、この仕様に加えて動作する期待または制約を定義できます。無視された好みは、アプリケーション固有の懸念です。"
    },
    {
      "indent": 3,
      "text": "Want-Content-Digest and Want-Repr-Digest are of type Dictionary where each:",
      "ja": "Want-Content-DigestとWant-Repr-Digestは、それぞれが次のタイプの辞書です。"
    },
    {
      "indent": 3,
      "text": "* key conveys the hashing algorithm (see Section 5);",
      "ja": "* キーはハッシュアルゴリズムを伝えます（セクション5を参照）。"
    },
    {
      "indent": 3,
      "text": "* value is an Integer (Section 3.3.1 of [STRUCTURED-FIELDS]) that conveys an ascending, relative, weighted preference. It must be in the range 0 to 10 inclusive. 1 is the least preferred, 10 is the most preferred, and a value of 0 means \"not acceptable\".",
      "ja": "* 値は、上行、相対的な、加重選好を伝える整数（[構造化場]のセクション3.3.1）です。0〜10の範囲内にある必要があります。1は最も好まれていない、10は最も好まれ、0の値は「受け入れられない」ことを意味します。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 3,
      "text": "Want-Repr-Digest: sha-256=1\nWant-Repr-Digest: sha-512=3, sha-256=10, unixsum=0\nWant-Content-Digest: sha-256=1\nWant-Content-Digest: sha-512=3, sha-256=10, unixsum=0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5. Hash Algorithm Considerations and Registration",
      "section_title": true,
      "ja": "5. ハッシュアルゴリズムの考慮事項と登録"
    },
    {
      "indent": 3,
      "text": "There are a wide variety of hashing algorithms that can be used for the purposes of integrity. The choice of algorithm depends on several factors such as the integrity use case, implementation needs or constraints, or application design and workflows.",
      "ja": "整合性の目的に使用できるさまざまなハッシュアルゴリズムがあります。アルゴリズムの選択は、整合性のユースケース、実装のニーズまたは制約、アプリケーションの設計とワークフローなどのいくつかの要因に依存します。"
    },
    {
      "indent": 3,
      "text": "An initial set of algorithms will be registered with IANA in the \"Hash Algorithms for HTTP Digest Fields\" registry; see Section 7.2. Additional algorithms can be registered in accordance with the policies set out in this section.",
      "ja": "アルゴリズムの初期セットは、「HTTP Digestフィールドのハッシュアルゴリズム」レジストリでIANAに登録されます。セクション7.2を参照してください。このセクションに記載されているポリシーに従って、追加のアルゴリズムを登録できます。"
    },
    {
      "indent": 3,
      "text": "Each algorithm has a status field that is intended to provide an aid to implementation selection.",
      "ja": "各アルゴリズムには、実装選択の援助を提供することを目的としたステータスフィールドがあります。"
    },
    {
      "indent": 3,
      "text": "Algorithms with a status value of \"Active\" are suitable for many purposes and it is RECOMMENDED that applications use these algorithms. These can be used in adversarial situations where hash functions might need to provide resistance to collision, first-preimage, and second-preimage attacks. For adversarial situations, selection of the acceptable \"Active\" algorithms will depend on the level of protection the circumstances demand. More considerations are presented in Section 6.6.",
      "ja": "「アクティブ」のステータス値を持つアルゴリズムは、多くの目的に適しており、アプリケーションがこれらのアルゴリズムを使用することをお勧めします。これらは、ハッシュ機能が衝突、第四弾症、および第二層攻撃に対する耐性を提供するために必要な敵対的な状況で使用できます。敵対的な状況では、許容可能な「アクティブな」アルゴリズムの選択は、状況の需要の保護レベルに依存します。より多くの考慮事項は、セクション6.6に示されています。"
    },
    {
      "indent": 3,
      "text": "Algorithms with a status value of \"Deprecated\" either provide none of these properties or are known to be weak (see [NO-MD5] and [NO-SHA]). These algorithms MAY be used to preserve integrity against corruption, but MUST NOT be used in a potentially adversarial setting, for example, when signing Integrity fields' values for authenticity. Permitting the use of these algorithms can help some applications (such as those that previously used [RFC3230], are migrating to this specification (Appendix E), and have existing stored collections of computed digest values) avoid undue operational overhead caused by recomputation using other more-secure algorithms. Such applications are not exempt from the requirements in this section. Furthermore, applications without such legacy or history ought to follow the guidance for using algorithms with the status value \"Active\".",
      "ja": "「非推奨」のステータス値を持つアルゴリズムは、これらのプロパティを提供しないか、弱いことが知られていません（[no-md5]および[no-sha]を参照）。これらのアルゴリズムは、腐敗に対する整合性を維持するために使用される場合がありますが、たとえば、潜在的に敵対的な環境で使用してはなりません。これらのアルゴリズムの使用を許可すると、一部のアプリケーション（以前に使用された[RFC3230]などのアプリケーションがこの仕様に移行し（付録E）、既存の消化量のコレクションが既存の消化量コレクションがあります）が、他のアプリケーションを使用した補充による過度の運用上のオーバーヘッドを避けるのに役立ちます。より安全なアルゴリズム。このようなアプリケーションは、このセクションの要件から免除されていません。さらに、そのような遺産や履歴のないアプリケーションは、ステータス値「アクティブ」でアルゴリズムを使用するためのガイダンスに従うべきです。"
    },
    {
      "indent": 3,
      "text": "Discussion of algorithm agility is presented in Section 6.6.",
      "ja": "アルゴリズムの俊敏性の議論は、セクション6.6に記載されています。"
    },
    {
      "indent": 3,
      "text": "Registration requests for the \"Hash Algorithms for HTTP Digest Fields\" registry use the Specification Required policy (Section 4.6 of [RFC8126]). Requests should use the following template:",
      "ja": "「HTTPダイジェストフィールドのハッシュアルゴリズム」レジストリの登録要求は、仕様が必要なポリシー（[RFC8126]のセクション4.6）を使用します。リクエストは次のテンプレートを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Algorithm Key:",
      "ja": "アルゴリズムキー："
    },
    {
      "indent": 12,
      "text": "The Structured Fields key value used in Content-Digest, Repr-Digest, Want-Content-Digest, or Want-Repr-Digest field Dictionary member keys.",
      "ja": "コンテンツダイジスト、リプリゲスト、希望コンテンツダイジェスト、またはwant-repr-digestフィールド辞書メンバーキーで使用される構造化されたフィールドのキー値。"
    },
    {
      "indent": 3,
      "text": "Status:",
      "ja": "状態："
    },
    {
      "indent": 12,
      "text": "The status of the algorithm. The options are:",
      "ja": "アルゴリズムのステータス。オプションは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "\"Active\":",
      "ja": "\"アクティブ\"："
    },
    {
      "indent": 12,
      "text": "Algorithms without known problems",
      "ja": "既知の問題のないアルゴリズム"
    },
    {
      "indent": 3,
      "text": "\"Provisional\":",
      "ja": "\"仮\"："
    },
    {
      "indent": 12,
      "text": "Unproven algorithms",
      "ja": "証明されていないアルゴリズム"
    },
    {
      "indent": 3,
      "text": "\"Deprecated\":",
      "ja": "「非推奨」："
    },
    {
      "indent": 12,
      "text": "Deprecated or insecure algorithms",
      "ja": "非推奨または安全なアルゴリズム"
    },
    {
      "indent": 12,
      "text": "\"Active\": Algorithms without known problems \"Provisional\": Unproven algorithms \"Deprecated\": Deprecated or insecure algorithms",
      "ja": "「アクティブ」：既知の問題のないアルゴリズム「暫定的」：証明されていないアルゴリズム「非推奨」：非推奨または安全なアルゴリズム"
    },
    {
      "indent": 3,
      "text": "Description:",
      "ja": "説明："
    },
    {
      "indent": 12,
      "text": "A short description of the algorithm.",
      "ja": "アルゴリズムの簡単な説明。"
    },
    {
      "indent": 3,
      "text": "Reference(s):",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "Pointer(s) to the primary document(s) defining the Algorithm Key and technical details of the algorithm.",
      "ja": "アルゴリズムのキーとアルゴリズムの技術的詳細を定義するプライマリドキュメントへのポインター。"
    },
    {
      "indent": 3,
      "text": "When reviewing registration requests, the designated expert(s) should pay attention to the requested status. The status value should reflect standardization status and the broad opinion of relevant interest groups such as the IETF or security-related Standards Development Organizations (SDOs). The \"Active\" status is not suitable for an algorithm that is known to be weak, broken, or experimental. If a registration request attempts to register such an algorithm as \"Active\", the designated expert(s) should suggest an alternative status of \"Deprecated\" or \"Provisional\".",
      "ja": "登録リクエストを確認するとき、指定された専門家は要求されたステータスに注意を払う必要があります。ステータス値は、IETFやセキュリティ関連標準開発組織（SDO）などの関連する利益団体の標準化ステータスと幅広い意見を反映する必要があります。「アクティブ」ステータスは、弱い、壊れた、または実験的であることが知られているアルゴリズムには適していません。登録リクエストが「アクティブ」などのアルゴリズムを登録しようとする場合、指定された専門家は「非推奨」または「暫定」の代替ステータスを提案する必要があります。"
    },
    {
      "indent": 3,
      "text": "When reviewing registration requests, the designated expert(s) cannot use a status of \"Deprecated\" or \"Provisional\" as grounds for rejection.",
      "ja": "登録リクエストを確認する場合、指定された専門家は、拒否の根拠として「非推奨」または「仮」のステータスを使用することはできません。"
    },
    {
      "indent": 3,
      "text": "Requests to update or change the fields in an existing registration are permitted. For example, this could allow for the transition of an algorithm status from \"Active\" to \"Deprecated\" as the security environment evolves.",
      "ja": "既存の登録でフィールドを更新または変更するリクエストは許可されています。たとえば、これにより、セキュリティ環境が進化するにつれて、「アクティブ」から「非推奨」へのアルゴリズムステータスの移行が可能になります。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "6.1. HTTP Messages Are Not Protected in Full",
      "section_title": true,
      "ja": "6.1. HTTPメッセージは完全に保護されていません"
    },
    {
      "indent": 3,
      "text": "This document specifies a data integrity mechanism that protects HTTP representation data or content, but not HTTP header and trailer fields, from certain kinds of corruption.",
      "ja": "このドキュメントは、特定の種類の腐敗からHTTPヘッダーとトレーラーフィールドではなく、HTTP表現データまたはコンテンツを保護するデータ整合性メカニズムを指定します。"
    },
    {
      "indent": 3,
      "text": "Integrity fields are not intended to be a general protection against malicious tampering with HTTP messages. In the absence of additional security mechanisms, an on-path malicious actor can either remove a digest value entirely or substitute it with a new digest value computed over manipulated representation data or content. This attack can be mitigated by combining mechanisms described in this document with other approaches such as Transport Layer Security (TLS) or digital signatures (for example, HTTP Message Signatures [SIGNATURES]).",
      "ja": "整合性フィールドは、HTTPメッセージの悪意のある改ざんに対する一般的な保護を意図したものではありません。追加のセキュリティメカニズムがない場合、パス上の悪意のあるアクターは、ダイジェスト値を完全に削除するか、操作された表現データまたはコンテンツを介して計算された新しいダイジェスト値で置き換えることができます。この攻撃は、このドキュメントで説明されているメカニズムと、輸送層のセキュリティ（TLS）やデジタル署名（HTTPメッセージ署名[署名]など）などの他のアプローチと組み合わせることで緩和できます。"
    },
    {
      "indent": 0,
      "text": "6.2. End-to-End Integrity",
      "section_title": true,
      "ja": "6.2. エンドツーエンドの完全性"
    },
    {
      "indent": 3,
      "text": "Integrity fields can help detect representation data or content modification due to implementation errors, undesired \"transforming proxies\" (see Section 7.7 of [HTTP]), or other actions as the data passes across multiple hops or system boundaries. Even a simple mechanism for end-to-end representation data integrity is valuable because a user agent can validate that resource retrieval succeeded before handing off to an HTML parser, video player, etc., for parsing.",
      "ja": "整合性フィールドは、実装エラー、望ましくない「プロキシの変換」（[HTTP]のセクション7.7を参照）、またはデータが複数のホップまたはシステムの境界を越えて渡されるため、表現データまたはコンテンツの変更を検出するのに役立ちます。ユーザーエージェントは、解析のためにHTMLパーサー、ビデオプレーヤーなどに引き渡す前にリソースの検索が成功したことを検証できるため、エンドツーエンドの表現データの整合性の単純なメカニズムでさえ価値があります。"
    },
    {
      "indent": 3,
      "text": "Note that using these mechanisms alone does not provide end-to-end integrity of HTTP messages over multiple hops since metadata could be manipulated at any stage. Methods to protect metadata are discussed in Section 6.3.",
      "ja": "これらのメカニズムのみを使用しても、メタデータをどの段階でも操作できるため、複数のホップでHTTPメッセージのエンドツーエンドの整合性が提供されないことに注意してください。メタデータを保護する方法については、セクション6.3で説明します。"
    },
    {
      "indent": 0,
      "text": "6.3. Usage in Signatures",
      "section_title": true,
      "ja": "6.3. 署名での使用"
    },
    {
      "indent": 3,
      "text": "Digital signatures are widely used together with checksums to provide the certain identification of the origin of a message [FIPS186-5]. Such signatures can protect one or more HTTP fields and there are additional considerations when Integrity fields are included in this set.",
      "ja": "デジタル署名は、メッセージの原点の特定の識別を提供するために、チェックサムと一緒に広く使用されています[FIPS186-5]。このような署名は、1つ以上のHTTPフィールドを保護でき、このセットに整合性フィールドが含まれている場合、追加の考慮事項があります。"
    },
    {
      "indent": 3,
      "text": "There are no restrictions placed on the type or format of digital signature that Integrity fields can be used with. One possible approach is to combine them with HTTP Message Signatures [SIGNATURES].",
      "ja": "整合性フィールドを使用できるデジタル署名のタイプまたは形式には、制限はありません。考えられるアプローチの1つは、それらをHTTPメッセージ署名[署名]と組み合わせることです。"
    },
    {
      "indent": 3,
      "text": "Digests explicitly depend on the \"representation metadata\" (e.g., the values of Content-Type, Content-Encoding, etc.). A signature that protects Integrity fields but not other \"representation metadata\" can expose the communication to tampering. For example, an actor could manipulate the Content-Type field-value and cause a digest validation failure at the recipient, preventing the application from accessing the representation. Such an attack consumes the resources of both endpoints. See also Section 3.2.",
      "ja": "消化は、「表現メタデータ」（たとえば、コンテンツタイプ、コンテンツエンコードなどの値）に明示的に依存します。他の「表現メタデータ」ではなく、整合性フィールドを保護する署名は、通信を改ざんにさらすことができます。たとえば、アクターはコンテンツタイプのフィールド値を操作し、受信者にダイジェスト検証障害を引き起こし、アプリケーションが表現にアクセスするのを防ぐことができます。このような攻撃は、両方のエンドポイントのリソースを消費します。セクション3.2も参照してください。"
    },
    {
      "indent": 3,
      "text": "Signatures are likely to be deemed an adversarial setting when applying Integrity fields; see Section 5. Repr-Digest offers an interesting possibility when combined with signatures. In the scenario where there is no content to send, the digest of an empty string can be included in the message and, if signed, can help the recipient detect if content was added either as a result of accident or purposeful manipulation. The opposite scenario is also supported; including an Integrity field for content and signing it can help a recipient detect where the content was removed.",
      "ja": "署名は、整合性フィールドを適用する際に敵対的な設定と見なされる可能性があります。セクション5を参照してください。Rep-Digestは、署名と組み合わせると興味深い可能性を提供します。送信するコンテンツがないシナリオでは、空の文字列のダイジェストをメッセージに含めることができ、署名された場合、事故または意図的な操作の結果としてコンテンツが追加されたかどうかを受信者が検出するのに役立ちます。反対のシナリオもサポートされています。コンテンツの整合性フィールドを含めて、署名すると、受信者がコンテンツが削除された場所を検出するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "Any mangling of Integrity fields might affect signature validation. Examples of such mangling include de-duplicating digests or combining different field values (see Section 5.2 of [HTTP]).",
      "ja": "整合性フィールドのマングルは、署名の検証に影響を与える可能性があります。このようなマングリングの例には、ダイジェストの重複除去または異なるフィールド値の組み合わせが含まれます（[http]のセクション5.2を参照）。"
    },
    {
      "indent": 0,
      "text": "6.4. Usage in Trailer Fields",
      "section_title": true,
      "ja": "6.4. トレーラーフィールドでの使用"
    },
    {
      "indent": 3,
      "text": "Before sending Integrity fields in a trailer section, the sender should consider that intermediaries are explicitly allowed to drop any trailer (see Section 6.5.2 of [HTTP]).",
      "ja": "トレーラーセクションに整合性フィールドを送信する前に、送信者は、仲介者がトレーラーを明示的にドロップすることを許可されていることを考慮する必要があります（[HTTP]のセクション6.5.2を参照）。"
    },
    {
      "indent": 3,
      "text": "When Integrity fields are used in a trailer section, the field-values are received after the content. Eager processing of content before the trailer section prevents digest validation, possibly leading to processing of invalid data.",
      "ja": "トレーラーセクションで整合性フィールドを使用すると、コンテンツ後にフィールド値が受信されます。トレーラーセクションの前にコンテンツを熱心に処理すると、ダイジェストの検証が防止され、おそらく無効なデータの処理につながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "One of the benefits of using Integrity fields in a trailer section is that it allows hashing of bytes as they are sent. However, it is possible to design a hashing algorithm that requires processing of content in such a way that would negate these benefits. For example, Merkle Integrity Content Encoding [MICE] requires content to be processed in reverse order. This means the complete data needs to be available, which means there is negligible processing difference in sending an Integrity field in a header versus a trailer section.",
      "ja": "トレーラーセクションで整合性フィールドを使用する利点の1つは、バイトが送信されたときにハッシュすることを可能にすることです。ただし、これらの利点を否定するような方法でコンテンツの処理を必要とするハッシュアルゴリズムを設計することは可能です。たとえば、[マウス]をエンコードするメルクルの整合性コンテンツでは、コンテンツを逆の順序で処理する必要があります。これは、完全なデータを使用できる必要があることを意味します。つまり、ヘッダーとトレーラーセクションで整合性フィールドを送信する際には、処理の違いが無視できることを意味します。"
    },
    {
      "indent": 0,
      "text": "6.5. Variations within Content-Encoding",
      "section_title": true,
      "ja": "6.5. コンテンツエンコード内のバリエーション"
    },
    {
      "indent": 3,
      "text": "Content coding mechanisms can support different encoding parameters, meaning that the same input content can produce different outputs. For example, GZIP supports multiple compression levels. Such encoding parameters are generally not communicated as representation metadata. For instance, different compression levels would all use the same \"Content-Encoding: gzip\" field. Other examples include where encoding relies on nonces or timestamps, such as the aes128gcm content coding defined in [RFC8188].",
      "ja": "コンテンツコーディングメカニズムは、異なるエンコーディングパラメーターをサポートできます。つまり、同じ入力コンテンツが異なる出力を生成できることを意味します。たとえば、GZIPは重圧縮レベルをサポートします。このようなエンコードパラメーターは、一般に表現メタデータとして通信されません。たとえば、異なる圧縮レベルはすべて、同じ「コンテンツエンコード：GZIP」フィールドを使用します。その他の例には、[RFC8188]で定義されているAES128GCMコンテンツのコーディングなど、エンコーディングがノンセースやタイムスタンプに依存している場合があります。"
    },
    {
      "indent": 3,
      "text": "Since it is possible for there to be variation within content coding, the checksum conveyed by the Integrity fields cannot be used to provide a proof of integrity \"at rest\" unless the whole content is persisted.",
      "ja": "コンテンツコーディング内にバリエーションがある可能性があるため、コンテンツ全体が持続しない限り、整合性フィールドによって伝えられるチェックサムを「安静時」の整合性の証明を提供することはできません。"
    },
    {
      "indent": 0,
      "text": "6.6. Algorithm Agility",
      "section_title": true,
      "ja": "6.6. アルゴリズムの俊敏性"
    },
    {
      "indent": 3,
      "text": "The security properties of hashing algorithms are not fixed. Algorithm agility (see [RFC7696]) is achieved by providing implementations with flexibility to choose hashing algorithms from the IANA Hash Algorithms for HTTP Digest Fields registry; see Section 7.2.",
      "ja": "ハッシュアルゴリズムのセキュリティプロパティは固定されていません。アルゴリズムのagility（[RFC7696]を参照）は、HTTP DigestフィールドレジストリのIANAハッシュアルゴリズムからハッシュアルゴリズムを選択できる柔軟性を備えた実装を提供することにより達成されます。セクション7.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Transition from weak algorithms is supported by negotiation of hashing algorithm using Want-Content-Digest or Want-Repr-Digest (see Section 4) or by sending multiple digests from which the receiver chooses. A receiver that depends on a digest for security will be vulnerable to attacks on the weakest algorithm it is willing to accept. Endpoints are advised that sending multiple values consumes resources that may be wasted if the receiver ignores them (see Section 3).",
      "ja": "弱いアルゴリズムからの遷移は、Want-Content-DigestまたはWant-Repr-Digest（セクション4を参照）を使用してハッシュアルゴリズムの交渉（セクション4を参照）または受信者が選択する複数のダイジェストを送信することによってサポートされます。セキュリティのためのダイジェストに依存するレシーバーは、受け入れようとする最も弱いアルゴリズムに対する攻撃に対して脆弱です。エンドポイントは、複数の値を送信すると、受信機がそれらを無視した場合に無駄になる可能性のあるリソースを消費することをお勧めします（セクション3を参照）。"
    },
    {
      "indent": 3,
      "text": "While algorithm agility allows the migration to stronger algorithms, it does not prevent the use of weaker algorithms. Integrity fields do not provide any mitigations for downgrade or substitution attacks (see Section 1 of [RFC6211]) of the hashing algorithm. To protect against such attacks, endpoints could restrict their set of supported algorithms to stronger ones and protect the fields' values by using TLS and/or digital signatures.",
      "ja": "アルゴリズムの俊敏性により、移行がより強力なアルゴリズムへの移行が可能になりますが、より弱いアルゴリズムの使用を妨げません。整合性フィールドは、ハッシュアルゴリズムのダウングレードまたは置換攻撃（[RFC6211]のセクション1を参照）のための緩和を提供しません。このような攻撃から保護するために、エンドポイントは、サポートされているアルゴリズムのセットをより強力なアルゴリズムに制限し、TLSおよび/またはデジタル署名を使用してフィールドの値を保護することができます。"
    },
    {
      "indent": 0,
      "text": "6.7. Resource Exhaustion",
      "section_title": true,
      "ja": "6.7. リソースの疲労"
    },
    {
      "indent": 3,
      "text": "Integrity field validation consumes computational resources. In order to avoid resource exhaustion, implementations can restrict validation of the algorithm types, the number of validations, or the size of content. In these cases, skipping validation entirely or ignoring validation failure of a more-preferred algorithm leaves the possibility of a downgrade attack (see Section 6.6).",
      "ja": "整合性フィールド検証は計算リソースを消費します。リソースの疲労を回避するために、実装は、アルゴリズムタイプ、検証の数、またはコンテンツのサイズの検証を制限できます。これらの場合、検証を完全にスキップするか、より優れたアルゴリズムの検証障害を無視することは、ダウングレード攻撃の可能性を残します（セクション6.6を参照）。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "7.1. HTTP Field Name Registration",
      "section_title": true,
      "ja": "7.1. HTTPフィールド名登録"
    },
    {
      "indent": 3,
      "text": "IANA has updated the \"Hypertext Transfer Protocol (HTTP) Field Name Registry\" [HTTP] as shown in the table below:",
      "ja": "IANAは、以下の表に示すように、「ハイパーテキスト転送プロトコル（HTTP）フィールド名レジストリ」[HTTP]を更新しました。"
    },
    {
      "indent": 7,
      "text": "+=====================+===========+========================+\n| Field Name          | Status    | Reference              |\n+=====================+===========+========================+\n| Content-Digest      | permanent | Section 2 of RFC 9530  |\n+---------------------+-----------+------------------------+\n| Repr-Digest         | permanent | Section 3 of RFC 9530  |\n+---------------------+-----------+------------------------+\n| Want-Content-Digest | permanent | Section 4 of RFC 9530  |\n+---------------------+-----------+------------------------+\n| Want-Repr-Digest    | permanent | Section 4 of RFC 9530  |\n+---------------------+-----------+------------------------+\n| Digest              | obsoleted | [RFC3230], Section 1.3 |\n|                     |           | of RFC 9530            |\n+---------------------+-----------+------------------------+\n| Want-Digest         | obsoleted | [RFC3230], Section 1.3 |\n|                     |           | of RFC 9530            |\n+---------------------+-----------+------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Table 1: Hypertext Transfer Protocol (HTTP) Field Name Registry Update",
      "ja": "表1：ハイパーテキスト転送プロトコル（HTTP）フィールド名レジストリアップデート"
    },
    {
      "indent": 0,
      "text": "7.2. Creation of the Hash Algorithms for HTTP Digest Fields Registry",
      "section_title": true,
      "ja": "7.2. httpダイジェストフィールドレジストリのハッシュアルゴリズムの作成"
    },
    {
      "indent": 3,
      "text": "IANA has created the new \"Hash Algorithms for HTTP Digest Fields\" registry at <https://www.iana.org/assignments/http-digest-hash-alg/> and populated it with the entries in Table 2. The procedure for new registrations is provided in Section 5.",
      "ja": "IANAは、<https://www.iana.org/assignments/http-digest-hash-alg/>に<https://www.iana.org/assignmentsの新しい「ハッシュアルゴリズム」レジストリを作成し、表2のエントリを入力しました。新しい登録はセクション5で提供されます。"
    },
    {
      "indent": 3,
      "text": "+===========+============+============================+============+\n| Algorithm | Status     | Description                | Reference  |\n| Key       |            |                            |            |\n+===========+============+============================+============+\n| sha-512   | Active     | The SHA-512 algorithm.     | [RFC6234], |\n|           |            |                            | [RFC4648], |\n|           |            |                            | RFC 9530   |\n+-----------+------------+----------------------------+------------+\n| sha-256   | Active     | The SHA-256 algorithm.     | [RFC6234], |\n|           |            |                            | [RFC4648], |\n|           |            |                            | RFC 9530   |\n+-----------+------------+----------------------------+------------+\n| md5       | Deprecated | The MD5 algorithm.  It is  | [RFC1321], |\n|           |            | vulnerable to collision    | [RFC4648], |\n|           |            | attacks; see [NO-MD5] and  | RFC 9530   |\n|           |            | [CMU-836068]               |            |\n+-----------+------------+----------------------------+------------+\n| sha       | Deprecated | The SHA-1 algorithm.  It   | [RFC3174], |\n|           |            | is vulnerable to collision | [RFC4648], |\n|           |            | attacks; see [NO-SHA] and  | [RFC6234], |\n|           |            | [IACR-2020-014]            | RFC 9530   |\n+-----------+------------+----------------------------+------------+\n| unixsum   | Deprecated | The algorithm used by the  | [RFC4648], |\n|           |            | UNIX \"sum\" command.        | [RFC6234], |\n|           |            |                            | [UNIX],    |\n|           |            |                            | RFC 9530   |\n+-----------+------------+----------------------------+------------+\n| unixcksum | Deprecated | The algorithm used by the  | [RFC4648], |\n|           |            | UNIX \"cksum\" command.      | [RFC6234], |\n|           |            |                            | [UNIX],    |\n|           |            |                            | RFC 9530   |\n+-----------+------------+----------------------------+------------+\n| adler     | Deprecated | The ADLER32 algorithm.     | [RFC1950], |\n|           |            |                            | RFC 9530   |\n+-----------+------------+----------------------------+------------+\n| crc32c    | Deprecated | The CRC32c algorithm.      | Appendix A |\n|           |            |                            | of         |\n|           |            |                            | [RFC9260], |\n|           |            |                            | RFC 9530   |\n+-----------+------------+----------------------------+------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Table 2: Initial Hash Algorithms",
      "ja": "表2：初期ハッシュアルゴリズム"
    },
    {
      "indent": 0,
      "text": "7.3. Deprecate the Hypertext Transfer Protocol (HTTP) Digest Algorithm Values Registry",
      "section_title": true,
      "ja": "7.3. HyperText Transfer Protocol（HTTP）DIGEST ALGORITHMVALUESレジストリを非難する"
    },
    {
      "indent": 3,
      "text": "IANA has deprecated the \"Hypertext Transfer Protocol (HTTP) Digest Algorithm Values\" registry at <https://www.iana.org/assignments/http-dig-alg/> and replaced the note on that registry with the following text:",
      "ja": "IANAは、<https://www.iana.org/assignments/http-dig-alg/>の「ハイパーテキスト転送プロトコル（http）ダイジェストアルゴリズム値」レジストリを非難し、次のテキストにそのレジストリのメモを置き換えました。"
    },
    {
      "indent": 0,
      "text": "This registry is deprecated since it lists the algorithms that can be used with the Digest and Want-Digest fields defined in [RFC3230], which has been obsoleted by RFC 9530. While registration is not closed, new registrations are encouraged to use the Hash Algorithms for HTTP Digest Fields (https://www.iana.org/assignments/http-digest-hash-alg/) registry instead.",
      "ja": "このレジストリは、[RFC3230]で定義されているダイジェストおよびウィットダイジストフィールドで使用できるアルゴリズムをリストしているため、廃止されます。これはRFC 9530によって廃止されています。httpダイジェストフィールド（https://www.iana.org/assignments/http-digest-hash-alg/）レジストリの代わりに。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8. 参考文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[FOLDING]  Watsen, K., Auerswald, E., Farrel, A., and Q. Wu,\n           \"Handling Long Lines in Content of Internet-Drafts and\n           RFCs\", RFC 8792, DOI 10.17487/RFC8792, June 2020,\n           <https://www.rfc-editor.org/info/rfc8792>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HTTP]     Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,\n           Ed., \"HTTP Semantics\", STD 97, RFC 9110,\n           DOI 10.17487/RFC9110, June 2022,\n           <https://www.rfc-editor.org/info/rfc9110>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC1321]  Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321,\n           DOI 10.17487/RFC1321, April 1992,\n           <https://www.rfc-editor.org/info/rfc1321>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC1950]  Deutsch, P. and J. Gailly, \"ZLIB Compressed Data Format\n           Specification version 3.3\", RFC 1950,\n           DOI 10.17487/RFC1950, May 1996,\n           <https://www.rfc-editor.org/info/rfc1950>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC3174]  Eastlake 3rd, D. and P. Jones, \"US Secure Hash Algorithm 1\n           (SHA1)\", RFC 3174, DOI 10.17487/RFC3174, September 2001,\n           <https://www.rfc-editor.org/info/rfc3174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC4648]  Josefsson, S., \"The Base16, Base32, and Base64 Data\n           Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006,\n           <https://www.rfc-editor.org/info/rfc4648>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5234]  Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n           Specifications: ABNF\", STD 68, RFC 5234,\n           DOI 10.17487/RFC5234, January 2008,\n           <https://www.rfc-editor.org/info/rfc5234>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6234]  Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms\n           (SHA and SHA-based HMAC and HKDF)\", RFC 6234,\n           DOI 10.17487/RFC6234, May 2011,\n           <https://www.rfc-editor.org/info/rfc6234>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7405]  Kyzivat, P., \"Case-Sensitive String Support in ABNF\",\n           RFC 7405, DOI 10.17487/RFC7405, December 2014,\n           <https://www.rfc-editor.org/info/rfc7405>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8126]  Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n           Writing an IANA Considerations Section in RFCs\", BCP 26,\n           RFC 8126, DOI 10.17487/RFC8126, June 2017,\n           <https://www.rfc-editor.org/info/rfc8126>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[STRUCTURED-FIELDS]\n           Nottingham, M. and P. Kamp, \"Structured Field Values for\n           HTTP\", RFC 8941, DOI 10.17487/RFC8941, February 2021,\n           <https://www.rfc-editor.org/info/rfc8941>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[CMU-836068]\n           Carnegie Mellon University, Software Engineering\n           Institute, \"MD5 vulnerable to collision attacks\", December\n           2008, <https://www.kb.cert.org/vuls/id/836068/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[FIPS186-5]\n           National Institute of Standards and Technology (NIST),\n           \"Digital Signature Standard (DSS)\", FIPS PUB 186-5,\n           DOI 10.6028/NIST.FIPS.186-5, February 2023,\n           <https://nvlpubs.nist.gov/nistpubs/FIPS/\n           NIST.FIPS.186-5.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HTTP/1.1] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,\n           Ed., \"HTTP/1.1\", STD 99, RFC 9112, DOI 10.17487/RFC9112,\n           June 2022, <https://www.rfc-editor.org/info/rfc9112>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[IACR-2020-014]\n           Leurent, G. and T. Peyrin, \"SHA-1 is a Shambles\", January\n           2020, <https://eprint.iacr.org/2020/014.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[MICE]     Thomson, M. and J. Yasskin, \"Merkle Integrity Content\n           Encoding\", Work in Progress, Internet-Draft, draft-\n           thomson-http-mice-03, 13 August 2018,\n           <https://datatracker.ietf.org/doc/html/draft-thomson-http-\n           mice-03>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[NO-MD5]   Turner, S. and L. Chen, \"Updated Security Considerations\n           for the MD5 Message-Digest and the HMAC-MD5 Algorithms\",\n           RFC 6151, DOI 10.17487/RFC6151, March 2011,\n           <https://www.rfc-editor.org/info/rfc6151>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[NO-SHA]   Polk, T., Chen, L., Turner, S., and P. Hoffman, \"Security\n           Considerations for the SHA-0 and SHA-1 Message-Digest\n           Algorithms\", RFC 6194, DOI 10.17487/RFC6194, March 2011,\n           <https://www.rfc-editor.org/info/rfc6194>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[PATCH]    Dusseault, L. and J. Snell, \"PATCH Method for HTTP\",\n           RFC 5789, DOI 10.17487/RFC5789, March 2010,\n           <https://www.rfc-editor.org/info/rfc5789>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC3230]  Mogul, J. and A. Van Hoff, \"Instance Digests in HTTP\",\n           RFC 3230, DOI 10.17487/RFC3230, January 2002,\n           <https://www.rfc-editor.org/info/rfc3230>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6211]  Schaad, J., \"Cryptographic Message Syntax (CMS) Algorithm\n           Identifier Protection Attribute\", RFC 6211,\n           DOI 10.17487/RFC6211, April 2011,\n           <https://www.rfc-editor.org/info/rfc6211>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7396]  Hoffman, P. and J. Snell, \"JSON Merge Patch\", RFC 7396,\n           DOI 10.17487/RFC7396, October 2014,\n           <https://www.rfc-editor.org/info/rfc7396>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7696]  Housley, R., \"Guidelines for Cryptographic Algorithm\n           Agility and Selecting Mandatory-to-Implement Algorithms\",\n           BCP 201, RFC 7696, DOI 10.17487/RFC7696, November 2015,\n           <https://www.rfc-editor.org/info/rfc7696>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8188]  Thomson, M., \"Encrypted Content-Encoding for HTTP\",\n           RFC 8188, DOI 10.17487/RFC8188, June 2017,\n           <https://www.rfc-editor.org/info/rfc8188>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9260]  Stewart, R., Tüxen, M., and K. Nielsen, \"Stream Control\n           Transmission Protocol\", RFC 9260, DOI 10.17487/RFC9260,\n           June 2022, <https://www.rfc-editor.org/info/rfc9260>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9457]  Nottingham, M., Wilde, E., and S. Dalal, \"Problem Details\n           for HTTP APIs\", RFC 9457, DOI 10.17487/RFC9457, July 2023,\n           <https://www.rfc-editor.org/info/rfc9457>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SIGNATURES]\n           Backman, A., Ed., Richer, J., Ed., and M. Sporny, \"HTTP\n           Message Signatures\", RFC 9421, DOI 10.17487/RFC9421,\n           February 2024, <https://www.rfc-editor.org/info/rfc9421>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[TLS]      Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n           Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n           <https://www.rfc-editor.org/info/rfc8446>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[UNIX]     The Open Group, \"The Single UNIX Specification, Version 2\n           - 6 Vol Set for UNIX 98\", January 1998.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix A. Resource Representation and Representation Data",
      "section_title": true,
      "ja": "付録A. リソース表現と表現データ"
    },
    {
      "indent": 3,
      "text": "The following examples show how representation metadata, content transformations, and methods impact the message and content. These examples a not exhaustive.",
      "ja": "次の例は、表現メタデータ、コンテンツの変換、および方法がメッセージとコンテンツにどのように影響するかを示しています。これらの例は網羅的ではありません。"
    },
    {
      "indent": 3,
      "text": "Unless otherwise indicated, the examples are based on the JSON object {\"hello\": \"world\"} followed by an LF. When the content contains non-printable characters (e.g., when it is encoded), it is shown as a sequence of hex-encoded bytes.",
      "ja": "特に示されない限り、例はjsonオブジェクト{\"hello\"： \"world\"}に基づいています。コンテンツに印刷不可能な文字が含まれている場合（例：エンコードされたとき）、16進エンコードされたバイトのシーケンスとして表示されます。"
    },
    {
      "indent": 3,
      "text": "Consider a client that wishes to upload a JSON object using the PUT method. It could do this using the application/json Content-Type without any content coding.",
      "ja": "PUTメソッドを使用してJSONオブジェクトをアップロードしたいクライアントを検討してください。コンテンツコーディングなしでアプリケーション/JSONコンテンツタイプを使用してこれを行うことができます。"
    },
    {
      "indent": 3,
      "text": "PUT /entries/1234 HTTP/1.1\nHost: foo.example\nContent-Type: application/json\nContent-Length: 19\n\n{\"hello\": \"world\"}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 1: Request Containing a JSON Object without Any Content Coding",
      "ja": "図1：コンテンツコーディングなしでJSONオブジェクトを含むリクエスト"
    },
    {
      "indent": 3,
      "text": "However, the use of content coding is quite common. The client could also upload the same data with a GZIP coding (Section 8.4.1.3 of [HTTP]). Note that in this case, the Content-Length contains a larger value due to the coding overheads.",
      "ja": "ただし、コンテンツコーディングの使用は非常に一般的です。クライアントは、GZIPコーディングで同じデータをアップロードすることもできます（[http]のセクション8.4.1.3）。この場合、コンテンツ長にはコーディングオーバーヘッドのために大きな値が含まれていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "PUT /entries/1234 HTTP/1.1\nHost: foo.example\nContent-Type: application/json\nContent-Encoding: gzip\nContent-Length: 39\n\n1F 8B 08 00 88 41 37 64 00 FF\nAB 56 CA 48 CD C9 C9 57 B2 52\n50 2A CF 2F CA 49 51 AA E5 02\n00 D9 E4 31 E7 13 00 00 00",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Figure 2: Request Containing a GZIP-Encoded JSON Object",
      "ja": "図2：GZIPエンコードJSONオブジェクトを含むリクエスト"
    },
    {
      "indent": 3,
      "text": "Sending the GZIP-coded data without indicating it via Content-Encoding means that the content is malformed. In this case, the server can reply with an error.",
      "ja": "コンテンツエンコードを介してそれを示さずにGZIPコード化されたデータを送信すると、コンテンツが奇形であることを意味します。この場合、サーバーはエラーで返信できます。"
    },
    {
      "indent": 3,
      "text": "PUT /entries/1234 HTTP/1.1\nHost: foo.example\nContent-Type: application/json\n\nContent-Length: 39\n\n1F 8B 08 00 88 41 37 64 00 FF\nAB 56 CA 48 CD C9 C9 57 B2 52\n50 2A CF 2F CA 49 51 AA E5 02\n00 D9 E4 31 E7 13 00 00 00",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 3: Request Containing Malformed JSON",
      "ja": "図3：不正なJSONを含むリクエスト"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 400 Bad Request",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 4: An Error Response for Malformed Content",
      "ja": "図4：奇形コンテンツのエラー応答"
    },
    {
      "indent": 3,
      "text": "A Range-Request affects the transferred message content. In this example, the client is accessing the resource at /entries/1234, which is the JSON object {\"hello\": \"world\"} followed by an LF. However, the client has indicated a preferred content coding and a specific byte range.",
      "ja": "レンジリクエストは、転送されたメッセージコンテンツに影響します。この例では、クライアントは /entries /1234のリソースにアクセスしています。ただし、クライアントは、優先コンテンツコーディングと特定のバイト範囲を示しています。"
    },
    {
      "indent": 3,
      "text": "GET /entries/1234 HTTP/1.1\nHost: foo.example\nAccept-Encoding: gzip\nRange: bytes=1-7",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Figure 5: Request for Partial Content",
      "ja": "図5：部分コンテンツのリクエスト"
    },
    {
      "indent": 3,
      "text": "The server satisfies the client request by responding with a partial representation (equivalent to the first 10 bytes of the JSON object displayed in whole in Figure 2).",
      "ja": "サーバーは、部分表現（図2に全体に表示されているJSONオブジェクトの最初の10バイトに相当する）で応答することにより、クライアント要求を満たします。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 206 Partial Content\nContent-Encoding: gzip\nContent-Type: application/json\nContent-Range: bytes 0-9/39\n\n1F 8B 08 00 A5 B4 BD 62 02 FF",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 6: Partial Response from a GZIP-Encoded Representation",
      "ja": "図6：GZIPエンコード表現からの部分的な応答"
    },
    {
      "indent": 3,
      "text": "Aside from content coding or range requests, the method can also affect the transferred message content. For example, the response to a HEAD request does not carry content, but this example case includes Content-Length; see Section 8.6 of [HTTP].",
      "ja": "コンテンツコーディングまたは範囲要求は別として、この方法は転送されたメッセージコンテンツにも影響を与える可能性があります。たとえば、ヘッドリクエストへの応答にはコンテンツが含まれていませんが、この例はコンテンツの長さが含まれています。[http]のセクション8.6を参照してください。"
    },
    {
      "indent": 3,
      "text": "HEAD /entries/1234 HTTP/1.1\nHost: foo.example\nAccept: application/json\nAccept-Encoding: gzip",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 27,
      "text": "Figure 7: HEAD Request",
      "ja": "図7：ヘッドリクエスト"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 200 OK\nContent-Type: application/json\nContent-Encoding: gzip\nContent-Length: 39",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 8: Response to HEAD Request (Empty Content)",
      "ja": "図8：ヘッドリクエストへの応答（空のコンテンツ）"
    },
    {
      "indent": 3,
      "text": "Finally, the semantics of a response might decouple the target URI from the enclosed representation. In the example below, the client issues a POST request directed to /authors/, but the response includes a Content-Location header field indicating that the enclosed representation refers to the resource available at /authors/123. Note that Content-Length is not sent in this example.",
      "ja": "最後に、応答のセマンティクスは、囲まれた表現からターゲットURIを分離する可能性があります。以下の例では、クライアントは /Authors /に向けられたPOSTリクエストを発行しますが、応答には、囲まれた表現が /著者 /123で利用可能なリソースを指していることを示すコンテンツロケーションヘッダーフィールドが含まれます。この例では、コンテンツレングスが送信されないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "POST /authors/ HTTP/1.1\nHost: foo.example\nAccept: application/json\nContent-Type: application/json\n\n{\"author\": \"Camilleri\"}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 27,
      "text": "Figure 9: POST Request",
      "ja": "図9：リクエストを投稿します"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 201 Created\nContent-Type: application/json\nContent-Location: /authors/123\nLocation: /authors/123\n\n{\"id\": \"123\", \"author\": \"Camilleri\"}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "Figure 10: Response with Content-Location Header",
      "ja": "図10：コンテンツロケーションヘッダーによる応答"
    },
    {
      "indent": 0,
      "text": "Appendix B. Examples of Unsolicited Digest",
      "section_title": true,
      "ja": "付録B. 未承諾消化の例"
    },
    {
      "indent": 3,
      "text": "The following examples demonstrate interactions where a server responds with a Content-Digest or Repr-Digest field, even though the client did not solicit one using Want-Content-Digest or Want-Repr-Digest.",
      "ja": "次の例は、クライアントがWant-Content-DigestまたはWant-Repr-Digestを使用して勧誘しなかったにもかかわらず、サーバーがコンテンツダイジストまたは再生フィールドで応答する相互作用を示しています。"
    },
    {
      "indent": 3,
      "text": "Some examples include JSON objects in the content. For presentation purposes, objects that fit completely within the line-length limits are presented on a single line using compact notation with no leading space. Objects that would exceed line-length limits are presented across multiple lines (one line per key-value pair) with two spaces of leading indentation.",
      "ja": "いくつかの例には、コンテンツ内のJSONオブジェクトが含まれます。プレゼンテーションの目的で、ラインの長さの制限内に完全に収まるオブジェクトは、先頭スペースのないコンパクトな表記を使用して単一の行に表示されます。ラインの長さの制限を超えるオブジェクトは、2つのスペースの主要なインデントを持つ複数の行（キー価値ペアごとに1行）にわたって表示されます。"
    },
    {
      "indent": 3,
      "text": "Checksum mechanisms defined in this document are media-type agnostic and do not provide canonicalization algorithms for specific formats. Examples are calculated inclusive of any space. While examples can include both fields, Content-Digest and Repr-Digest can be returned independently.",
      "ja": "このドキュメントで定義されているチェックサムメカニズムは、メディアタイプの不可知論者であり、特定の形式の標準化アルゴリズムを提供しません。例は、スペースを含めて計算されます。例には両方のフィールドを含めることができますが、コンテンツダイジストとリプリゲストは独立して返すことができます。"
    },
    {
      "indent": 0,
      "text": "B.1. Server Returns Full Representation Data",
      "section_title": true,
      "ja": "B.1. サーバーは完全な表現データを返します"
    },
    {
      "indent": 3,
      "text": "In this example, the message content conveys complete representation data. This means that in the response, Content-Digest and Repr-Digest are both computed over the JSON object {\"hello\": \"world\"} followed by an LF; thus, they have the same value.",
      "ja": "この例では、メッセージコンテンツは完全な表現データを伝えます。これは、応答では、コンテンツダイジストとリプリゲストが両方ともJSONオブジェクト{\"Hello\"： \"world\"}を介して計算されることを意味します。したがって、それらは同じ値を持っています。"
    },
    {
      "indent": 3,
      "text": "GET /items/123 HTTP/1.1\nHost: foo.example",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 11: GET Request for an Item",
      "ja": "図11：アイテムのリクエストを取得します"
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nHTTP/1.1 200 OK\nContent-Type: application/json\nContent-Length: 19\nContent-Digest: \\\n  sha-256=:RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg=:\nRepr-Digest: \\\n  sha-256=:RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg=:\n\n{\"hello\": \"world\"}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 12: Response with Identical Repr-Digest and Content-Digest",
      "ja": "図12：同一の再生とコンテンツダイジストによる応答"
    },
    {
      "indent": 0,
      "text": "B.2. Server Returns No Representation Data",
      "section_title": true,
      "ja": "B.2. サーバーは表現データを返しません"
    },
    {
      "indent": 3,
      "text": "In this example, a HEAD request is used to retrieve the checksum of a resource.",
      "ja": "この例では、ヘッドリクエストを使用して、リソースのチェックサムを取得します。"
    },
    {
      "indent": 3,
      "text": "The response Content-Digest field-value is computed on empty content. Repr-Digest is calculated over the JSON object {\"hello\": \"world\"} followed by an LF, which is not shown because there is no content.",
      "ja": "応答コンテンツダイジェストフィールド値は、空のコンテンツで計算されます。Repr-Digestは、jsonオブジェクト{\"hello\"： \"world\"}で計算されます。"
    },
    {
      "indent": 3,
      "text": "HEAD /items/123 HTTP/1.1\nHost: foo.example",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Figure 13: HEAD Request for an Item",
      "ja": "図13：アイテムのヘッドリクエスト"
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nHTTP/1.1 200 OK\nContent-Type: application/json\nContent-Digest: \\\n  sha-256=:47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=:\nRepr-Digest: \\\n  sha-256=:RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg=:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 14: Response with Both Content-Digest and Digest (Empty Content)",
      "ja": "図14：コンテンツダイジェストとダイジェストの両方の応答（空のコンテンツ）"
    },
    {
      "indent": 0,
      "text": "B.3. Server Returns Partial Representation Data",
      "section_title": true,
      "ja": "B.3. サーバーは部分表現データを返します"
    },
    {
      "indent": 3,
      "text": "In this example, the client makes a range request and the server responds with partial content.",
      "ja": "この例では、クライアントは範囲リクエストを行い、サーバーは部分的なコンテンツで応答します。"
    },
    {
      "indent": 3,
      "text": "GET /items/123 HTTP/1.1\nHost: foo.example\nRange: bytes=10-18",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Figure 15: Request for Partial Content",
      "ja": "図15：部分コンテンツのリクエスト"
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nHTTP/1.1 206 Partial Content\nContent-Type: application/json\nContent-Range: bytes 10-18/19\nContent-Digest: \\\n  sha-256=:jjcgBDWNAtbYUXI37CVG3gRuGOAjaaDRGpIUFsdyepQ=:\nRepr-Digest: \\\n  sha-256=:RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg=:\n\n\"world\"}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Figure 16: Partial Response with Both Content-Digest and Repr-Digest",
      "ja": "図16：コンテンツダイジストとリプレイズの両方を含む部分的な応答"
    },
    {
      "indent": 3,
      "text": "In the response message above, note that the Repr-Digest and Content-Digests are different. The Repr-Digest field-value is calculated across the entire JSON object {\"hello\": \"world\"} followed by an LF, and the field appears as follows:",
      "ja": "上記の応答メッセージでは、再生とコンテンツダイジストが異なることに注意してください。Repl-Digestのフィールド値は、JSONオブジェクト全体で計算されます{\"hello\"： \"world\"}に続いてLFが続き、フィールドは次のように表示されます。"
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nRepr-Digest: \\\n  sha-256=:RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg=:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "However, since the message content is constrained to bytes 10-18, the Content-Digest field-value is calculated over the sequence \"world\"} followed by an LF, thus resulting in the following:",
      "ja": "ただし、メッセージコンテンツはバイト10〜18に制約されているため、コンテンツダイジェストのフィールド値は「ワールド」}に続いてLFを使用して計算され、以下になります。"
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nContent-Digest: \\\n  sha-256=:jjcgBDWNAtbYUXI37CVG3gRuGOAjaaDRGpIUFsdyepQ=:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "B.4. Client and Server Provide Full Representation Data",
      "section_title": true,
      "ja": "B.4. クライアントとサーバーは、完全な表現データを提供します"
    },
    {
      "indent": 3,
      "text": "The request contains a Repr-Digest field-value calculated on the enclosed representation. It also includes an Accept-Encoding: br header field that advertises that the client supports Brotli encoding.",
      "ja": "リクエストには、囲まれた表現で計算された再生フィールド値が含まれています。また、クライアントがBrotliエンコードをサポートすることを宣伝するAccept-Encoding：BRヘッダーフィールドも含まれています。"
    },
    {
      "indent": 3,
      "text": "The response includes a Content-Encoding: br that indicates the selected representation is Brotli-encoded. The Repr-Digest field-value is therefore different compared to the request.",
      "ja": "応答には、選択された表現がBrotli-Encodedであることを示すコンテンツエンコード：BRが含まれます。したがって、再生消費のフィールド値は、リクエストと比較して異なります。"
    },
    {
      "indent": 3,
      "text": "For presentation purposes, the response body is displayed as a sequence of hex-encoded bytes because it contains non-printable characters.",
      "ja": "プレゼンテーションの目的で、応答本体は、印刷できない文字が含まれているため、16進コード化されたバイトのシーケンスとして表示されます。"
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nPUT /items/123 HTTP/1.1\nHost: foo.example\nContent-Type: application/json\nAccept-Encoding: br\nRepr-Digest: \\\n  sha-256=:RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg=:\n\n{\"hello\": \"world\"}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 17: PUT Request with Digest",
      "ja": "図17：ダイジェストでリクエストを入れます"
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nHTTP/1.1 200 OK\nContent-Type: application/json\nContent-Location: /items/123\nContent-Encoding: br\nContent-Length: 23\nRepr-Digest: \\\n  sha-256=:d435Qo+nKZ+gLcUHn7GQtQ72hiBVAgqoLsZnZPiTGPk=:\n\n8B 08 80 7B 22 68 65 6C 6C 6F\n22 3A 20 22 77 6F 72 6C 64 22\n7D 0A 03",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "Figure 18: Response with Digest of Encoded Response",
      "ja": "図18：エンコードされた応答のダイジェストによる応答"
    },
    {
      "indent": 0,
      "text": "B.5. Client Provides Full Representation Data and Server Provides No Representation Data",
      "section_title": true,
      "ja": "B.5. クライアントは完全な表現データを提供し、サーバーはノールプレゼンテーションデータを提供します"
    },
    {
      "indent": 3,
      "text": "The request Repr-Digest field-value is calculated on the enclosed content, which is the JSON object {\"hello\": \"world\"} followed by an LF.",
      "ja": "リクエストのリクエストフィールド値は、囲まれたコンテンツで計算されます。これは、jsonオブジェクト{\"hello\"： \"world\"}です。"
    },
    {
      "indent": 3,
      "text": "The response Repr-Digest field-value depends on the representation metadata header fields, including Content-Encoding: br, even when the response does not contain content.",
      "ja": "応答は、コンテンツエンコードを含む表現メタデータヘッダーフィールドに依存します。応答にコンテンツが含まれていない場合でも。"
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nPUT /items/123 HTTP/1.1\nHost: foo.example\nContent-Type: application/json\nContent-Length: 19\nAccept-Encoding: br\nRepr-Digest: \\\n  sha-256=:RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg==:\n\n{\"hello\": \"world\"}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 204 No Content\nContent-Type: application/json\nContent-Encoding: br\nRepr-Digest: sha-256=:d435Qo+nKZ+gLcUHn7GQtQ72hiBVAgqoLsZnZPiTGPk=:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Figure 19: Empty Response with Digest",
      "ja": "図19：ダイジェストによる空の応答"
    },
    {
      "indent": 0,
      "text": "B.6. Client and Server Provide Full Representation Data",
      "section_title": true,
      "ja": "B.6. クライアントとサーバーは、完全な表現データを提供します"
    },
    {
      "indent": 3,
      "text": "The response contains two digest values using different algorithms.",
      "ja": "応答には、異なるアルゴリズムを使用して2つのダイジェスト値が含まれています。"
    },
    {
      "indent": 3,
      "text": "For presentation purposes, the response body is displayed as a sequence of hex-encoded bytes because it contains non-printable characters.",
      "ja": "プレゼンテーションの目的で、応答本体は、印刷できない文字が含まれているため、16進コード化されたバイトのシーケンスとして表示されます。"
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nPUT /items/123 HTTP/1.1\nHost: foo.example\nContent-Type: application/json\nAccept-Encoding: br\nRepr-Digest: \\\n  sha-256=:RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg==:\n\n{\"hello\": \"world\"}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 20: PUT Request with Digest",
      "ja": "図20：ダイジェストでリクエストを入れます"
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nHTTP/1.1 200 OK\nContent-Type: application/json\nContent-Encoding: br\nContent-Location: /items/123\nRepr-Digest: \\\n  sha-256=:d435Qo+nKZ+gLcUHn7GQtQ72hiBVAgqoLsZnZPiTGPk=:,\\\n  sha-512=:db7fdBbgZMgX1Wb2MjA8zZj+rSNgfmDCEEXM8qLWfpfoNY0sCpHAzZbj\\\n  09X1/7HAb7Od5Qfto4QpuBsFbUO3dQ==:\n\n8B 08 80 7B 22 68 65 6C 6C 6F\n22 3A 20 22 77 6F 72 6C 64 22\n7D 0A 03",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 21: Response with Digest of Encoded Content",
      "ja": "図21：エンコードされたコンテンツのダイジェストによる応答"
    },
    {
      "indent": 0,
      "text": "B.7. POST Response Does Not Reference the Request URI",
      "section_title": true,
      "ja": "B.7. 投稿の応答は、リクエストURIを参照しません"
    },
    {
      "indent": 3,
      "text": "The request Repr-Digest field-value is computed on the enclosed representation (see Section 3.1), which is the JSON object {\"title\": \"New Title\"} followed by an LF.",
      "ja": "リクエストリクエストは、囲まれた表現（セクション3.1を参照）で計算されます（セクション3.1を参照）。"
    },
    {
      "indent": 3,
      "text": "The representation enclosed in the response is a multiline JSON object followed by an LF. It refers to the resource identified by Content-Location (see Section 6.4.2 of [HTTP]); thus, an application can use Repr-Digest in association with the resource referenced by Content-Location.",
      "ja": "応答に囲まれた表現は、LFが続くマルチラインJSONオブジェクトです。コンテンツロケーションで識別されたリソースを指します（[http]のセクション6.4.2を参照）。したがって、アプリケーションは、コンテンツロケーションで参照されるリソースに関連してRepl-Digestを使用できます。"
    },
    {
      "indent": 3,
      "text": "POST /books HTTP/1.1\nHost: foo.example\nContent-Type: application/json\nAccept: application/json\nAccept-Encoding: identity\nRepr-Digest: sha-256=:mEkdbO7Srd9LIOegftO0aBX+VPTVz7/CSHes2Z27gc4=:\n\n{\"title\": \"New Title\"}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Figure 22: POST Request with Digest",
      "ja": "図22：ダイジェストを使用したリクエストを投稿します"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 201 Created\nContent-Type: application/json\nContent-Location: /books/123\nLocation: /books/123\nRepr-Digest: sha-256=:uVSlinTTdQUwm2On4k8TJUikGN1bf/Ds8WPX4oe0h9I=:\n\n{\n  \"id\": \"123\",\n  \"title\": \"New Title\"\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 23: Response with Digest of Resource",
      "ja": "図23：リソースの消化による応答"
    },
    {
      "indent": 0,
      "text": "B.8. POST Response Describes the Request Status",
      "section_title": true,
      "ja": "B.8. 投稿応答では、リクエストステータスについて説明します"
    },
    {
      "indent": 3,
      "text": "The request Repr-Digest field-value is computed on the enclosed representation (see Section 3.1), which is the JSON object {\"title\": \"New Title\"} followed by an LF.",
      "ja": "リクエストリクエストは、囲まれた表現（セクション3.1を参照）で計算されます（セクション3.1を参照）。"
    },
    {
      "indent": 3,
      "text": "The representation enclosed in the response describes the status of the request, so Repr-Digest is computed on that enclosed representation. It is a multiline JSON object followed by an LF.",
      "ja": "応答に囲まれた表現は、リクエストのステータスを説明するため、その囲まれた表現で再生が計算されます。これは、LFが続くマルチラインJSONオブジェクトです。"
    },
    {
      "indent": 3,
      "text": "Response Repr-Digest has no explicit relation with the resource referenced by Location.",
      "ja": "Response Repr-Digestは、場所で参照されるリソースと明示的な関係はありません。"
    },
    {
      "indent": 3,
      "text": "POST /books HTTP/1.1\nHost: foo.example\nContent-Type: application/json\nAccept: application/json\nAccept-Encoding: identity\nRepr-Digest: sha-256=:mEkdbO7Srd9LIOegftO0aBX+VPTVz7/CSHes2Z27gc4=:\n\n{\"title\": \"New Title\"}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Figure 24: POST Request with Digest",
      "ja": "図24：ダイジェストのリクエストを投稿します"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 201 Created\nContent-Type: application/json\nRepr-Digest: sha-256=:yXIGDTN5VrfoyisKlXgRKUHHMs35SNtyC3szSz1dbO8=:\nLocation: /books/123\n\n{\n  \"status\": \"created\",\n  \"id\": \"123\",\n  \"ts\": 1569327729,\n  \"instance\": \"/books/123\"\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 25: Response with Digest of Representation",
      "ja": "図25：表現の消化による応答"
    },
    {
      "indent": 0,
      "text": "B.9. Digest with PATCH",
      "section_title": true,
      "ja": "B.9. パッチで消化します"
    },
    {
      "indent": 3,
      "text": "This case is analogous to a POST request where the target resource reflects the target URI.",
      "ja": "このケースは、ターゲットリソースがターゲットURIを反映するPOSTリクエストに類似しています。"
    },
    {
      "indent": 3,
      "text": "The PATCH request uses the application/merge-patch+json media type defined in [RFC7396]. Repr-Digest is calculated on the content that corresponds to the patch document and is the JSON object {\"title\": \"New Title\"} followed by an LF.",
      "ja": "パッチ要求では、[RFC7396]で定義されたアプリケーション/マージパッチJSONメディアタイプを使用します。REPR-DIGESTは、パッチドキュメントに対応するコンテンツで計算され、JSONオブジェクト{\"Title\"： \"new Title\"}に続いてLFが続きます。"
    },
    {
      "indent": 3,
      "text": "The response Repr-Digest field-value is computed on the complete representation of the patched resource. It is a multiline JSON object followed by an LF.",
      "ja": "応答は、フィールド値を再消化することは、パッチされたリソースの完全な表現で計算されます。これは、LFが続くマルチラインJSONオブジェクトです。"
    },
    {
      "indent": 3,
      "text": "PATCH /books/123 HTTP/1.1\nHost: foo.example\nContent-Type: application/merge-patch+json\nAccept: application/json\nAccept-Encoding: identity\nRepr-Digest: sha-256=:mEkdbO7Srd9LIOegftO0aBX+VPTVz7/CSHes2Z27gc4=:\n\n{\"title\": \"New Title\"}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Figure 26: PATCH Request with Digest",
      "ja": "図26：ダイジェストを使用したパッチリクエスト"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 200 OK\nContent-Type: application/json\nRepr-Digest: sha-256=:uVSlinTTdQUwm2On4k8TJUikGN1bf/Ds8WPX4oe0h9I=:\n\n{\n  \"id\": \"123\",\n  \"title\": \"New Title\"\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 27: Response with Digest of Representation",
      "ja": "図27：表現の消化による応答"
    },
    {
      "indent": 3,
      "text": "Note that a 204 No Content response without content, but with the same Repr-Digest field-value, would have been legitimate too. In that case, Content-Digest would have been computed on an empty content.",
      "ja": "コンテンツなしでは204のコンテンツの応答がないが、同じ再生フィールド値を使用しても、合法的であったことに注意してください。その場合、コンテンツダイジェストは空のコンテンツで計算されていました。"
    },
    {
      "indent": 0,
      "text": "B.10. Error Responses",
      "section_title": true,
      "ja": "B.10. エラー応答"
    },
    {
      "indent": 3,
      "text": "In error responses, the representation data does not necessarily refer to the target resource. Instead, it refers to the representation of the error.",
      "ja": "エラー応答では、表現データは必ずしもターゲットリソースを参照するものではありません。代わりに、エラーの表現を指します。"
    },
    {
      "indent": 3,
      "text": "In the following example, a client sends the same request from Figure 26 to patch the resource located at /books/123. However, the resource does not exist and the server generates a 404 response with a body that describes the error in accordance with [RFC9457].",
      "ja": "次の例では、クライアントが図26から同じリクエストを送信して、 /books /123にあるリソースにパッチを当てます。ただし、リソースは存在せず、サーバーは[RFC9457]に従ってエラーを記述するボディで404応答を生成します。"
    },
    {
      "indent": 3,
      "text": "The response Repr-Digest field-value is computed on this enclosed representation. It is a multiline JSON object followed by an LF.",
      "ja": "応答は、この囲まれた表現でフィールド値を再消化することが計算されます。これは、LFが続くマルチラインJSONオブジェクトです。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 404 Not Found\nContent-Type: application/problem+json\nRepr-Digest: sha-256=:EXB0S2VF2H7ijkAVJkH1Sm0pBho0iDZcvVUHHXTTZSA=:\n\n{\n  \"title\": \"Not Found\",\n  \"detail\": \"Cannot PATCH a non-existent resource\",\n  \"status\": 404\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Figure 28: Response with Digest of Error Representation",
      "ja": "図28：エラー表現の消化による応答"
    },
    {
      "indent": 0,
      "text": "B.11. Use with Trailer Fields and Transfer Coding",
      "section_title": true,
      "ja": "B.11. トレーラーフィールドと転送コーディングで使用します"
    },
    {
      "indent": 3,
      "text": "An origin server sends Repr-Digest as trailer field, so it can calculate digest-value while streaming content and thus mitigate resource consumption. The Repr-Digest field-value is the same as in Appendix B.1 because Repr-Digest is designed to be independent of the use of one or more transfer codings (see Section 3).",
      "ja": "Origin Serverは、トレーラーフィールドとしてRepl-Digestを送信するため、コンテンツのストリーミング中にDigest-Valueを計算してリソース消費を緩和できます。Repl-Digestのフィールド値は、付録B.1と同じです。なぜなら、Repl-Digestは1つ以上の転送コードの使用とは独立しているように設計されているためです（セクション3を参照）。"
    },
    {
      "indent": 3,
      "text": "In the response content below, the string \"\\r\\n\" represents the CRLF bytes.",
      "ja": "以下の応答コンテンツでは、文字列「\\ r \\ n」はCRLFバイトを表します。"
    },
    {
      "indent": 3,
      "text": "GET /items/123 HTTP/1.1\nHost: foo.example",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 27,
      "text": "Figure 29: GET Request",
      "ja": "図29：リクエストを取得します"
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nHTTP/1.1 200 OK\nContent-Type: application/json\nTransfer-Encoding: chunked\nTrailer: Repr-Digest\n\n8\\r\\n\n{\"hello\"\\r\\n\n8\\r\\n\n: \"world\\r\\n\n3\\r\\n\n\"}\\n\\r\\n\n0\\r\\n\nRepr-Digest: \\\n  sha-256=:RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg==:\\r\\n",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Figure 30: Chunked Response with Digest",
      "ja": "図30：ダイジェストによるチャンクされた応答"
    },
    {
      "indent": 0,
      "text": "Appendix C. Examples of Want-Repr-Digest Solicited Digest",
      "section_title": true,
      "ja": "付録C. Want-Repr-Digest Solicated Digestの例"
    },
    {
      "indent": 3,
      "text": "The following examples demonstrate interactions where a client solicits a Repr-Digest using Want-Repr-Digest. The behavior of Content-Digest and Want-Content-Digest is identical.",
      "ja": "次の例は、クライアントがWant-Repr-Digestを使用してReprigestを求める相互作用を示しています。コンテンツダイジェストの動作とコンテンツダイジェストが必要です。"
    },
    {
      "indent": 3,
      "text": "Some examples include JSON objects in the content. For presentation purposes, objects that fit completely within the line-length limits are presented on a single line using compact notation with no leading space. Objects that would exceed line-length limits are presented across multiple lines (one line per key-value pair) with two spaces of leading indentation.",
      "ja": "いくつかの例には、コンテンツ内のJSONオブジェクトが含まれます。プレゼンテーションの目的で、ラインの長さの制限内に完全に収まるオブジェクトは、先頭スペースのないコンパクトな表記を使用して単一の行に表示されます。ラインの長さの制限を超えるオブジェクトは、2つのスペースの主要なインデントを持つ複数の行（キー価値ペアごとに1行）にわたって表示されます。"
    },
    {
      "indent": 3,
      "text": "Checksum mechanisms described in this document are media-type agnostic and do not provide canonicalization algorithms for specific formats. Examples are calculated inclusive of any space.",
      "ja": "このドキュメントで説明されているチェックサムメカニズムは、メディア型不可知論者であり、特定の形式の標準化アルゴリズムを提供しません。例は、スペースを含めて計算されます。"
    },
    {
      "indent": 0,
      "text": "C.1. Server Selects Client's Least Preferred Algorithm",
      "section_title": true,
      "ja": "C.1. サーバーは、クライアントの最も優先されるアルゴリズムを選択します"
    },
    {
      "indent": 3,
      "text": "The client requests a digest and prefers \"sha\". The server is free to reply with \"sha-256\" anyway.",
      "ja": "クライアントはダイジェストを要求し、「sha」を好みます。とにかく、サーバーは「SHA-256」で無料で返信できます。"
    },
    {
      "indent": 3,
      "text": "GET /items/123 HTTP/1.1\nHost: foo.example\nWant-Repr-Digest: sha-256=3, sha=10",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 31: GET Request with Want-Repr-Digest",
      "ja": "図31：Want-Repr-Digestでリクエストを取得します"
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nHTTP/1.1 200 OK\nContent-Type: application/json\nRepr-Digest: \\\n  sha-256=:RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg==:\n\n{\"hello\": \"world\"}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 32: Response with Different Algorithm",
      "ja": "図32：異なるアルゴリズムによる応答"
    },
    {
      "indent": 0,
      "text": "C.2. Server Selects Algorithm Unsupported by Client",
      "section_title": true,
      "ja": "C.2. サーバーは、クライアントによるサポートされていないアルゴリズムを選択します"
    },
    {
      "indent": 3,
      "text": "The client requests a \"sha\" digest because that is the only algorithm it supports. The server is not obliged to produce a response containing a \"sha\" digest; it instead uses a different algorithm.",
      "ja": "クライアントは、それがサポートする唯一のアルゴリズムであるため、「SHA」ダイジェストを要求します。サーバーは、「SHA」ダイジェストを含む応答を作成する義務はありません。代わりに、別のアルゴリズムを使用します。"
    },
    {
      "indent": 3,
      "text": "GET /items/123 HTTP/1.1\nHost: foo.example\nWant-Repr-Digest: sha=10",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 33: GET Request with Want-Repr-Digest",
      "ja": "図33：Want-Repr-Digestでリクエストを取得します"
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nHTTP/1.1 200 OK\nContent-Type: application/json\nRepr-Digest: \\\n  sha-512=:YMAam51Jz/jOATT6/zvHrLVgOYTGFy1d6GJiOHTohq4yP+pgk4vf2aCs\\\n  yRZOtw8MjkM7iw7yZ/WkppmM44T3qg==:\n\n{\"hello\": \"world\"}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 34: Response with Unsupported Algorithm",
      "ja": "図34：サポートされていないアルゴリズムによる応答"
    },
    {
      "indent": 0,
      "text": "C.3. Server Does Not Support Client Algorithm and Returns an Error",
      "section_title": true,
      "ja": "C.3. サーバーはクライアントアルゴリズムをサポートせず、エラーを返します"
    },
    {
      "indent": 3,
      "text": "Appendix C.2 is an example where a server ignores the client's preferred digest algorithm. Alternatively, a server can also reject the request and return a response with an error status code such as 4xx or 5xx. This specification does not prescribe any requirement on status code selection; the following example illustrates one possible option.",
      "ja": "付録C.2は、サーバーがクライアントの優先ダイジェストアルゴリズムを無視する例です。または、サーバーはリクエストを拒否し、4xxや5xxなどのエラーステータスコードで応答を返すこともできます。この仕様では、ステータスコードの選択に関する要件は規定されていません。次の例は、1つの可能なオプションを示しています。"
    },
    {
      "indent": 3,
      "text": "In this example, the client requests a \"sha\" Repr-Digest, and the server returns an error with problem details [RFC9457] contained in the content. The problem details contain a list of the hashing algorithms that the server supports. This is purely an example; this specification does not define any format or requirements for such content.",
      "ja": "この例では、クライアントは「sha」のリプレイズを要求し、サーバーはコンテンツに含まれる問題の詳細[RFC9457]を使用してエラーを返します。問題の詳細には、サーバーがサポートするハッシュアルゴリズムのリストが含まれています。これは純粋に例です。この仕様は、そのようなコンテンツのフォーマットまたは要件を定義しません。"
    },
    {
      "indent": 3,
      "text": "GET /items/123 HTTP/1.1\nHost: foo.example\nWant-Repr-Digest: sha=10",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 35: GET Request with Want-Repr-Digest",
      "ja": "図35：Want-Repr-Digestでリクエストを取得します"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 400 Bad Request\nContent-Type: application/problem+json\n\n{\n  \"title\": \"Bad Request\",\n  \"detail\": \"Supported hashing algorithms: sha-256, sha-512\",\n  \"status\": 400\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Figure 36: Response Advertising the Supported Algorithms",
      "ja": "図36：応答サポートされているアルゴリズムを宣伝します"
    },
    {
      "indent": 0,
      "text": "Appendix D. Sample Digest Values",
      "section_title": true,
      "ja": "付録D. サンプルダイジェスト値"
    },
    {
      "indent": 3,
      "text": "This section shows examples of digest values for different hashing algorithms. The input value is the JSON object {\"hello\": \"world\"}. The digest values are each produced by running the relevant hashing algorithm over the input and running the output bytes through Byte Sequence serialization; see Section 4.1.8 of [STRUCTURED-FIELDS].",
      "ja": "このセクションでは、異なるハッシュアルゴリズムのダイジェスト値の例を示します。入力値はjsonオブジェクト{\"hello\"： \"world\"}です。ダイジェスト値はそれぞれ、入力上で関連するハッシュアルゴリズムを実行し、バイトシーケンスシリアル化を介して出力バイトを実行することにより生成されます。[構造化場]のセクション4.1.8を参照してください。"
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nsha-512 -   :WZDPaVn/7XgHaAy8pmojAkGWoRx2UFChF41A2svX+TaPm+\\\n            AbwAgBWnrIiYllu7BNNyealdVLvRwEmTHWXvJwew==:\n\nsha-256 -   :X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=:\n\nmd5 -       :Sd/dVLAcvNLSq16eXua5uQ==:\n\nsha -       :07CavjDP4u3/TungoUHJO/Wzr4c=:\n\nunixsum -   :GQU=:\n\nunixcksum - :7zsHAA==:\n\nadler -     :OZkGFw==:\n\ncrc32c -    :Q3lHIA==:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix E. Migrating from RFC 3230",
      "section_title": true,
      "ja": "付録E. RFC 3230からの移動"
    },
    {
      "indent": 3,
      "text": "HTTP digests are computed by applying a hashing algorithm to input data. [RFC3230] defined the input data as an \"instance\", a term it also defined. The concept of an instance has since been superseded by the HTTP semantic term \"representation\". It is understood that some implementations of [RFC3230] mistook \"instance\" to mean HTTP content. Using content for the Digest field is an error that leads to interoperability problems between peers that implement [RFC3230].",
      "ja": "HTTPダイジェストは、ハッシュアルゴリズムを入力データに適用することにより計算されます。[RFC3230]は、入力データを「インスタンス」として定義しました。これも定義された用語です。その後、インスタンスの概念は、HTTPセマンティック用語「表現」に取って代わられました。[RFC3230]のいくつかの実装は、「インスタンス」を誤ってHTTPコンテンツを意味することが理解されています。ダイジェストフィールドにコンテンツを使用することは、[RFC3230]を実装するピア間の相互運用性の問題につながるエラーです。"
    },
    {
      "indent": 3,
      "text": "[RFC3230] was only ever intended to use what HTTP now defines as selected representation data. The semantic concept of digest and representation are explained alongside the definition of the Repr-Digest field (Section 3).",
      "ja": "[RFC3230]は、HTTPが現在選択された表現データとして定義しているものを使用することを意図していました。ダイジェストと表現のセマンティックな概念は、再生フィールドの定義とともに説明されています（セクション3）。"
    },
    {
      "indent": 3,
      "text": "While the syntax of Digest and Repr-Digest are different, the considerations and examples this document gives for Repr-Digest apply equally to Digest because they operate on the same input data; see Sections 3.1, 6 and 6.3.",
      "ja": "DigestとRepr Digestの構文は異なりますが、このドキュメントが提供する考慮事項と例は、同じ入力データで動作するため、消化に等しく適用されます。セクション3.1、6、および6.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "[RFC3230] could never communicate the digest of HTTP message content in the Digest field; Content-Digest now provides that capability.",
      "ja": "[RFC3230]は、ダイジェストフィールドでHTTPメッセージコンテンツのダイジェストを通信することはできませんでした。Content-Digestはその機能を提供するようになりました。"
    },
    {
      "indent": 3,
      "text": "[RFC3230] allowed algorithms to define their output encoding format for use with the Digest field. This resulted in a mix of formats such as base64, hex, or decimal. By virtue of using Structured Fields, Content-Digest, and Repr-Digest use only a single encoding format. Further explanation and examples are provided in Appendix D.",
      "ja": "[RFC3230]により、アルゴリズムは、ダイジェストフィールドで使用するための出力エンコード形式を定義できました。これにより、base64、hex、小数などの形式が混在しました。構造化されたフィールドを使用することにより、コンテンツダイジスト、およびリプダイジェストは、単一のエンコード形式のみを使用します。詳細な説明と例は、付録Dに記載されています。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "section_title": true,
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This document is based on ideas from [RFC3230], so thanks to Jeff Mogul and Arthur Van Hoff for their great work. The original idea of refreshing [RFC3230] arose from an interesting discussion with Mark Nottingham, Jeffrey Yasskin, and Martin Thomson when reviewing the MICE content coding.",
      "ja": "このドキュメントは[RFC3230]のアイデアに基づいているため、ジェフモーグルとアーサーヴァンホフの素晴らしい仕事に感謝します。リフレッシュの元のアイデア[RFC3230]は、マークノッティンガム、ジェフリーヤスキン、マルティントムソンとの興味深い議論から生まれました。"
    },
    {
      "indent": 3,
      "text": "Thanks to Julian Reschke for his valuable contributions to this document, and to the following contributors that have helped improve this specification by reporting bugs, asking smart questions, drafting or reviewing text, and evaluating open issues: Mike Bishop, Brian Campbell, Matthew Kerwin, James Manger, Tommy Pauly, Sean Turner, Justin Richer, and Erik Wilde.",
      "ja": "この文書への貴重な貢献と、バグの報告、スマートな質問をし、テキストの起草やレビュー、未解決の問題の評価によってこの仕様を改善するのに役立った以下の貢献者に感謝しているJulian Reschkeに感謝します。ジェームズ・マナー、トミー・ポーリー、ショーン・ターナー、ジャスティン・リッチャー、エリック・ワイルド。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Roberto Polli\nTeam Digitale, Italian Government\nItaly\nEmail: robipolli@gmail.com\n",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Lucas Pardue\nCloudflare\nEmail: lucas@lucaspardue.com\n",
      "raw": true,
      "ja": ""
    }
  ]
}