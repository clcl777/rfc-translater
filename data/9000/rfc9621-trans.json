{
  "title": {
    "text": "RFC 9621 - Architecture and Requirements for Transport Services",
    "ja": "RFC 9621 - 輸送サービスのアーキテクチャと要件"
  },
  "number": 9621,
  "created_at": "2025-01-23 23:24:06.390627+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                     T. Pauly, Ed.\nRequest for Comments: 9621                                    Apple Inc.\nCategory: Standards Track                               B. Trammell, Ed.\nISSN: 2070-1721                                  Google Switzerland GmbH\n                                                            A. Brunstrom\n                                                     Karlstad University\n                                                            G. Fairhurst\n                                                  University of Aberdeen\n                                                           C. S. Perkins\n                                                   University of Glasgow\n                                                            January 2025",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Architecture and Requirements for Transport Services",
      "section_title": true,
      "ja": "輸送サービスのアーキテクチャと要件"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes an architecture that exposes transport protocol features to applications for network communication. The Transport Services Application Programming Interface (API) is based on an asynchronous, event-driven interaction pattern. This API uses Messages for representing data transfer to applications and describes how a Transport Services Implementation can use multiple IP addresses, multiple protocols, and multiple paths and can provide multiple application streams. This document provides the architecture and requirements. It defines common terminology and concepts to be used in definitions of a Transport Services API and a Transport Services Implementation.",
      "ja": "このドキュメントでは、輸送プロトコル機能をネットワーク通信のアプリケーションに公開するアーキテクチャについて説明します。トランスポートサービスアプリケーションプログラミングインターフェイス（API）は、非同期のイベント駆動型相互作用パターンに基づいています。このAPIは、アプリケーションへのデータ転送を表すためにメッセージを使用し、トランスポートサービスの実装が複数のIPアドレス、複数のプロトコル、複数のパスを使用し、複数のアプリケーションストリームを提供する方法を説明します。このドキュメントは、アーキテクチャと要件を提供します。輸送サービスAPIと輸送サービスの実装の定義で使用される一般的な用語と概念を定義します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準トラックドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 7841のセクション2で入手できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9621.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https://www.rfc-editor.org/info/rfc9621で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2025 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2025 IETF Trustおよび文書著者として特定された人。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、改訂されたBSDライセンスで説明されている保証なしで提供されるように、改訂されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Background\n  1.2.  Overview\n  1.3.  Specification of Requirements\n  1.4.  Glossary of Key Terms\n2.  API Model\n  2.1.  Event-Driven API\n  2.2.  Data Transfer Using Messages\n  2.3.  Flexible Implementation\n  2.4.  Coexistence\n3.  API and Implementation Requirements\n  3.1.  Provide Common APIs for Common Features\n  3.2.  Allow Access to Specialized Features\n  3.3.  Select Between Equivalent Protocol Stacks\n  3.4.  Maintain Interoperability\n  3.5.  Support Monitoring\n4.  Transport Services Architecture and Concepts\n  4.1.  Transport Services API Concepts\n    4.1.1.  Endpoint Objects\n    4.1.2.  Connections and Related Objects\n    4.1.3.  Preestablishment\n    4.1.4.  Establishment Actions\n    4.1.5.  Data Transfer Objects and Actions\n    4.1.6.  Event Handling\n    4.1.7.  Termination Actions\n    4.1.8.  Connection Groups\n  4.2.  Transport Services Implementation\n    4.2.1.  Candidate Gathering\n    4.2.2.  Candidate Racing\n    4.2.3.  Separating Connection Contexts\n5.  IANA Considerations\n6.  Security and Privacy Considerations\n7.  References\n  7.1.  Normative References\n  7.2.  Informative References\nAcknowledgements\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Many Application Programming Interfaces (APIs) to provide transport interfaces to networks have been deployed, perhaps the most widely known and imitated being the Socket interface (Socket API) [POSIX]. The naming of objects and functions across these APIs is not consistent and varies, depending on the protocol being used. For example, the concept of sending and receiving streams of data is the same for both an unencrypted Transmission Control Protocol (TCP) stream and operating on an encrypted Transport Layer Security (TLS) stream [RFC8446] over TCP, but applications cannot use the same socket send() and recv() calls on top of both kinds of connections. Similarly, terminology for the implementation of transport protocols varies based on the context of the protocols themselves: terms such as \"flow\", \"stream\", \"message\", and \"connection\" can take on many different meanings. This variety can lead to confusion when trying to understand the similarities and differences between protocols and how applications can use them effectively.",
      "ja": "ネットワークへの輸送インターフェイスを提供する多くのアプリケーションプログラミングインターフェイス（API）が展開されています。おそらく最も広く知られ、模倣されているのは、ソケットインターフェイス（Socket API）[POSIX]です。これらのAPIにわたるオブジェクトと関数の命名は、使用されているプロトコルによって異なり、一貫性がなく、異なります。たとえば、データのストリームを送信および受信するという概念は、暗号化されていない伝送制御プロトコル（TCP）ストリームの両方で同じであり、TCPを介して暗号化されたトランスポートレイヤーセキュリティ（TLS）ストリーム[RFC8446]で動作しますが、アプリケーションは同じを使用できません。Socket Send（）およびRecv（）は、両方の種類の接続の上に呼び出します。同様に、輸送プロトコルの実装の用語は、プロトコル自体のコンテキストに基づいて異なります。「フロー」、「ストリーム」、「メッセージ」、「接続」などの用語は、多くの異なる意味を引き受けることができます。この多様性は、プロトコルの類似性と相違点、およびアプリケーションがそれらを効果的に使用する方法を理解しようとするときに混乱につながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "The goal of the Transport Services System architecture is to provide a flexible and reusable system with a common interface for transport protocols. An application uses the Transport Services System through an abstract Connection (we use capitalization to distinguish these from the underlying connections of, for example, TCP). This provides flexible Connection establishment allowing an application to request or require a set of Properties.",
      "ja": "トランスポートサービスシステムアーキテクチャの目標は、輸送プロトコルの共通インターフェイスを備えた柔軟で再利用可能なシステムを提供することです。アプリケーションは、抽象接続を介して輸送サービスシステムを使用します（たとえば、TCPの基礎となる接続とこれらを区別するために大文字化を使用します）。これにより、アプリケーションがプロパティのセットを要求または要求できる柔軟な接続確立が提供されます。"
    },
    {
      "indent": 3,
      "text": "As applications adopt this interface, they will benefit from a wide set of transport features that can evolve over time and will ensure that the system providing the interface can optimize its behavior based on the application requirements and network conditions, without requiring changes to the applications. This flexibility enables faster deployment of new features and protocols.",
      "ja": "アプリケーションがこのインターフェイスを採用するため、時間の経過とともに進化できる幅広い輸送機能の恩恵を受け、アプリケーションの変更を必要とせずに、インターフェイスを提供するシステムがアプリケーションの要件とネットワーク条件に基づいて動作を最適化できるようにします。この柔軟性により、新機能とプロトコルをより速く展開できます。"
    },
    {
      "indent": 3,
      "text": "This architecture can also support applications by offering racing mechanisms (attempting multiple IP addresses, protocols, or network paths in parallel), which otherwise need to be implemented in each application separately (see Section 4.2.2). Racing selects one or more candidates, each with equivalent Protocol Stacks that are used to identify an optimal combination of a transport protocol instance such as TCP, UDP, or another transport, together with configuration of parameters and interfaces. A Connection represents an object that, once established, can be used to send and receive Messages. A Connection can also be created from another Connection, by cloning, and then forms a part of a Connection Group whose Connections share Properties.",
      "ja": "このアーキテクチャは、レースメカニズム（複数のIPアドレス、プロトコル、または並行してネットワークパスを試みる）を提供することでアプリケーションをサポートできます。そうでなければ、各アプリケーションで個別に実装する必要があります（セクション4.2.2を参照）。Racingは1つ以上の候補を選択し、それぞれがTCP、UDP、または別のトランスポートなどのトランスポートプロトコルインスタンスの最適な組み合わせを特定するために使用される同等のプロトコルスタックを備えたパラメーターとインターフェイスの構成とともに選択します。接続は、一度確立されると、メッセージの送信と受信に使用できるオブジェクトを表します。また、クローン化することにより、別の接続から接続を作成し、接続がプロパティを共有する接続グループの一部を形成することもできます。"
    },
    {
      "indent": 3,
      "text": "This document was developed in parallel with the specification of the Transport Services API [RFC9622] and implementation guidelines [RFC9623]. Although following the Transport Services Architecture does not require all APIs and implementations to be identical, a common minimal set of features represented in a consistent fashion will enable applications to be easily ported from one implementation of the Transport Services System to another.",
      "ja": "このドキュメントは、輸送サービスAPI [RFC9622]および実装ガイドライン[RFC9623]の仕様と並行して開発されました。トランスポートサービスアーキテクチャに従うことで、すべてのAPIと実装が同一であることは必要ありませんが、一貫した方法で表される一般的な最小限の機能セットを使用すると、アプリケーションを輸送サービスシステムのある実装から別のものに簡単に移植できます。"
    },
    {
      "indent": 0,
      "text": "1.1. Background",
      "section_title": true,
      "ja": "1.1. 背景"
    },
    {
      "indent": 3,
      "text": "The architecture of the Transport Services System is based on the survey of services provided by IETF transport protocols and congestion control mechanisms [RFC8095] and the distilled minimal set of the features offered by transport protocols [RFC8923]. These documents identified common features and patterns across all transport protocols developed thus far in the IETF.",
      "ja": "輸送サービスシステムのアーキテクチャは、IETF輸送プロトコルと輻輳制御メカニズム[RFC8095]によって提供されるサービスの調査と、輸送プロトコル[RFC8923]によって提供される機能の蒸留最小セットに基づいています。これらのドキュメントは、IETFでこれまでに開発されたすべての輸送プロトコルにわたって共通の機能とパターンを特定しました。"
    },
    {
      "indent": 3,
      "text": "Since transport security is an increasingly relevant aspect of using transport protocols on the Internet, this document also considers the impact of transport security protocols on the feature set exposed by Transport Services [RFC8922].",
      "ja": "輸送セキュリティは、インターネット上で輸送プロトコルを使用することのますます関連する側面であるため、このドキュメントでは、輸送サービス[RFC8922]によって公開された機能セットに対する輸送セキュリティプロトコルの影響も考慮しています。"
    },
    {
      "indent": 3,
      "text": "One of the key insights to come from identifying the minimal set of features provided by transport protocols [RFC8923] was that features either (1) require application interaction and guidance (referred to in that document as Functional or Optimizing Features) or (2) can be handled automatically by an implementation of the Transport Services System (referred to as Automatable Features). Among the identified Functional and Optimizing Features, some are common across all or nearly all transport protocols, while others present features that, if specified, would only be useful with a subset of protocols, but would not harm the functionality of other protocols. For example, some protocols can deliver messages more quickly for applications that do not require messages to arrive in the order in which they were sent. This functionality needs to be explicitly allowed by the application, since reordering messages would be undesirable in many cases.",
      "ja": "トランスポートプロトコル[RFC8923]によって提供される最小限の機能セットを特定することから生じる重要な洞察の1つは、（1）アプリケーションの相互作用とガイダンスを必要とすることでした（そのドキュメントでは機能的または最適化機能と呼ばれる）または（2）Can Canトランスポートサービスシステムの実装（自動機能と呼ばれる）によって自動的に処理されます。特定された機能的および最適化機能の中で、一部はすべてまたはほぼすべての輸送プロトコルで一般的なものであり、他の機能は、指定された場合、プロトコルのサブセットでのみ役立つが、他のプロトコルの機能に害を及ぼさない機能を提示します。たとえば、一部のプロトコルでは、送信された順序でメッセージが届くようにメッセージを必要としないアプリケーションに対して、より迅速にメッセージを配信できます。多くの場合、メッセージの並べ替えは望ましくないため、この機能はアプリケーションによって明示的に許可される必要があります。"
    },
    {
      "indent": 0,
      "text": "1.2. Overview",
      "section_title": true,
      "ja": "1.2. 概要"
    },
    {
      "indent": 3,
      "text": "The following sections describe the Transport Services System:",
      "ja": "次のセクションでは、輸送サービスシステムについて説明します。"
    },
    {
      "indent": 6,
      "text": "* Section 2 describes how the Transport Services API model differs from that of socket-based APIs. Specifically, it offers asynchronous event-driven interaction, the use of Messages for data transfer, and the flexibility to use different transport protocols and paths without requiring major changes to the application.",
      "ja": "* セクション2では、輸送サービスAPIモデルがソケットベースのAPIのAPIモデルとどのように異なるかを説明します。具体的には、非同期イベント駆動型の相互作用、データ転送のためのメッセージの使用、およびアプリケーションに大きな変更を必要とせずに異なる輸送プロトコルとパスを使用する柔軟性を提供します。"
    },
    {
      "indent": 6,
      "text": "* Section 3 explains the fundamental requirements for a Transport Services System. These principles are intended to make sure that transport protocols can continue to be enhanced and evolve without requiring significant changes by application developers.",
      "ja": "* セクション3では、輸送サービスシステムの基本要件について説明します。これらの原則は、アプリケーション開発者による大幅な変更を必要とせずに、輸送プロトコルを引き続き強化し、進化させることができるようにすることを目的としています。"
    },
    {
      "indent": 6,
      "text": "* Section 4 presents the Transport Services Implementation and defines the concepts that are used by the API [RFC9622] and described in the implementation guidelines [RFC9623]. This introduces the Preconnection, which allows applications to configure Connection Properties.",
      "ja": "* セクション4では、輸送サービスの実装を示し、API [RFC9622]で使用され、実装ガイドライン[RFC9623]で説明されている概念を定義します。これにより、アプリケーションが接続プロパティを構成できるようにする前提条件が導入されます。"
    },
    {
      "indent": 0,
      "text": "1.3. Specification of Requirements",
      "section_title": true,
      "ja": "1.3. 要件の仕様"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "「必須」、「必要」、「必須」、「shall」、「shall」、「suff」、 \"not\"、 \"becommended\"、 \"becommented\"、 \"may\"、 \"optional「このドキュメントでは、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.4. Glossary of Key Terms",
      "section_title": true,
      "ja": "1.4. 重要な用語の用語集"
    },
    {
      "indent": 3,
      "text": "This subsection provides a glossary of key terms related to the Transport Services Architecture. It provides a short description of key terms that are defined later in this document.",
      "ja": "このサブセクションは、トランスポートサービスアーキテクチャに関連する重要な用語の用語集を提供します。このドキュメントの後半で定義されている重要な用語の簡単な説明を提供します。"
    },
    {
      "indent": 3,
      "text": "Application:",
      "ja": "応用："
    },
    {
      "indent": 12,
      "text": "An entity that uses the transport layer for end-to-end delivery of data across the network [RFC8095].",
      "ja": "ネットワーク全体のデータのエンドツーエンドの配信に輸送層を使用するエンティティ[RFC8095]。"
    },
    {
      "indent": 3,
      "text": "Cached State:",
      "ja": "キャッシュ状態："
    },
    {
      "indent": 12,
      "text": "The state and history that the Transport Services Implementation keeps for each set of the associated Endpoints that have been used previously.",
      "ja": "輸送サービスの実装が、以前に使用されていた関連するエンドポイントの各セットに対して保持される状態と歴史。"
    },
    {
      "indent": 3,
      "text": "Candidate Path:",
      "ja": "候補パス："
    },
    {
      "indent": 12,
      "text": "One path that is available to an application and conforms to the Selection Properties and System Policy during racing.",
      "ja": "アプリケーションが利用できる1つのパスは、レース中に選択プロパティとシステムポリシーに準拠しています。"
    },
    {
      "indent": 3,
      "text": "Candidate Protocol Stack:",
      "ja": "候補プロトコルスタック："
    },
    {
      "indent": 12,
      "text": "One Protocol Stack that can be used by an application for a Connection during racing.",
      "ja": "レース中に接続のアプリケーションで使用できるプロトコルスタック。"
    },
    {
      "indent": 3,
      "text": "Client:",
      "ja": "クライアント:"
    },
    {
      "indent": 12,
      "text": "The peer responsible for initiating a Connection.",
      "ja": "接続の開始を担当するピア。"
    },
    {
      "indent": 3,
      "text": "Clone:",
      "ja": "クローン："
    },
    {
      "indent": 12,
      "text": "A Connection that was created from another Connection and that forms a part of a Connection Group.",
      "ja": "別の接続から作成され、接続グループの一部を形成する接続。"
    },
    {
      "indent": 3,
      "text": "Connection:",
      "ja": "繋がり："
    },
    {
      "indent": 12,
      "text": "Shared state of two or more Endpoints that persists across Messages that are transmitted and received between these Endpoints [RFC8303]. When this document and other Transport Services documents use the capitalized \"Connection\" term, it refers to a Connection object that is being offered by the Transport Services System, as opposed to more generic uses of the word \"connection\".",
      "ja": "これらのエンドポイント間で送信および受信されるメッセージ間で持続する2つ以上のエンドポイントの共有状態[RFC8303]。このドキュメントとその他の輸送サービスドキュメントが大文字の「接続」用語を使用する場合、「接続」という単語のより一般的な使用とは対照的に、輸送サービスシステムによって提供されている接続オブジェクトを指します。"
    },
    {
      "indent": 3,
      "text": "Connection Context:",
      "ja": "接続コンテキスト："
    },
    {
      "indent": 12,
      "text": "A set of stored Properties across Connections, such as cached protocol state, cached path state, and heuristics, which can include one or more Connection Groups.",
      "ja": "1つ以上の接続グループを含むことができる、キャッシュされたプロトコル状態、キャッシュパス状態、ヒューリスティックなど、接続全体に保存されたプロパティのセット。"
    },
    {
      "indent": 3,
      "text": "Connection Group:",
      "ja": "接続グループ："
    },
    {
      "indent": 12,
      "text": "A set of Connections that share Properties and caches.",
      "ja": "プロパティとキャッシュを共有する一連の接続。"
    },
    {
      "indent": 3,
      "text": "Connection Property:",
      "ja": "接続プロパティ："
    },
    {
      "indent": 12,
      "text": "A Transport Property that controls per-Connection behavior of a Transport Services Implementation.",
      "ja": "輸送サービスの実装の接続ごとの動作を制御する輸送プロパティ。"
    },
    {
      "indent": 3,
      "text": "Endpoint:",
      "ja": "終点："
    },
    {
      "indent": 12,
      "text": "An entity that communicates with one or more other Endpoints using a transport protocol.",
      "ja": "トランスポートプロトコルを使用して、1つ以上の他のエンドポイントと通信するエンティティ。"
    },
    {
      "indent": 3,
      "text": "Endpoint Identifier:",
      "ja": "エンドポイント識別子："
    },
    {
      "indent": 12,
      "text": "An identifier that specifies one side of a Connection (local or remote), such as a hostname or URL.",
      "ja": "ホスト名やURLなど、接続の片側（ローカルまたはリモート）を指定する識別子。"
    },
    {
      "indent": 3,
      "text": "Equivalent Protocol Stacks:",
      "ja": "同等のプロトコルスタック："
    },
    {
      "indent": 12,
      "text": "Protocol Stacks that can be safely swapped or raced in parallel during establishment of a Connection.",
      "ja": "接続の確立中に安全に交換または並行してレースすることができるプロトコルスタック。"
    },
    {
      "indent": 3,
      "text": "Event:",
      "ja": "イベント："
    },
    {
      "indent": 12,
      "text": "A primitive that is invoked by an Endpoint [RFC8303].",
      "ja": "エンドポイント[RFC8303]によって呼び出されるプリミティブ。"
    },
    {
      "indent": 3,
      "text": "Framer:",
      "ja": "フレーマ："
    },
    {
      "indent": 12,
      "text": "A data translation layer that can be added to a Connection to define how application-layer Messages are transmitted over a Protocol Stack.",
      "ja": "接続に追加できるデータ変換レイヤーは、プロトコルスタックを介してアプリケーションレイヤーメッセージが送信される方法を定義します。"
    },
    {
      "indent": 3,
      "text": "Local Endpoint:",
      "ja": "ローカルエンドポイント："
    },
    {
      "indent": 12,
      "text": "The local Endpoint.",
      "ja": "ローカルエンドポイント。"
    },
    {
      "indent": 3,
      "text": "Local Endpoint Identifier:",
      "ja": "ローカルエンドポイント識別子："
    },
    {
      "indent": 12,
      "text": "A representation of the application's identifier for itself that it uses for a Connection.",
      "ja": "接続に使用するアプリケーションの識別子自体の表現。"
    },
    {
      "indent": 3,
      "text": "Message:",
      "ja": "メッセージ："
    },
    {
      "indent": 12,
      "text": "A unit of data that can be transferred between two Endpoints over a Connection.",
      "ja": "接続を介して2つのエンドポイント間に転送できるデータの単位。"
    },
    {
      "indent": 3,
      "text": "Message Property:",
      "ja": "メッセージプロパティ："
    },
    {
      "indent": 12,
      "text": "A property that can be used to specify details about Message transmission or obtain details about the transmission after receiving a Message.",
      "ja": "メッセージ送信に関する詳細を指定したり、メッセージを受け取った後に送信に関する詳細を取得したりするために使用できるプロパティ。"
    },
    {
      "indent": 3,
      "text": "Parameter:",
      "ja": "パラメーター："
    },
    {
      "indent": 12,
      "text": "A value passed between an application and a transport protocol by a primitive [RFC8303].",
      "ja": "プリミティブ[RFC8303]によってアプリケーションと輸送プロトコルの間に渡された値。"
    },
    {
      "indent": 3,
      "text": "Path:",
      "ja": "パス："
    },
    {
      "indent": 12,
      "text": "A representation of an available set of Properties that a Local Endpoint can use to communicate with a Remote Endpoint.",
      "ja": "ローカルエンドポイントがリモートエンドポイントと通信するために使用できるプロパティの利用可能なセットの表現。"
    },
    {
      "indent": 3,
      "text": "Peer:",
      "ja": "ピア："
    },
    {
      "indent": 12,
      "text": "An Endpoint application party to a Connection.",
      "ja": "接続のエンドポイントアプリケーションパーティ。"
    },
    {
      "indent": 3,
      "text": "Preconnection:",
      "ja": "事前接続："
    },
    {
      "indent": 12,
      "text": "An object that represents a Connection that has not yet been established.",
      "ja": "まだ確立されていない接続を表すオブジェクト。"
    },
    {
      "indent": 3,
      "text": "Preference:",
      "ja": "好み："
    },
    {
      "indent": 12,
      "text": "A preference for prohibiting, avoiding, ignoring, preferring, or requiring a specific transport feature.",
      "ja": "特定の輸送機能を禁止、回避、無視、好み、または要求することを好む。"
    },
    {
      "indent": 3,
      "text": "Primitive:",
      "ja": "原生的："
    },
    {
      "indent": 12,
      "text": "A function call that is used to locally communicate between an application and an Endpoint, which is related to one or more transport features [RFC8303].",
      "ja": "アプリケーションとエンドポイントの間でローカルに通信するために使用される関数呼び出し。これは、1つ以上の輸送機能に関連しています[RFC8303]。"
    },
    {
      "indent": 3,
      "text": "Protocol Instance:",
      "ja": "プロトコルインスタンス："
    },
    {
      "indent": 12,
      "text": "A single instance of one protocol, including any state necessary to establish connectivity or send and receive Messages.",
      "ja": "接続を確立したり、メッセージを送信および受信したりするために必要な状態を含む、1つのプロトコルの単一インスタンス。"
    },
    {
      "indent": 3,
      "text": "Protocol Stack:",
      "ja": "プロトコルスタック："
    },
    {
      "indent": 12,
      "text": "A set of protocol instances that are used together to establish connectivity or send and receive Messages.",
      "ja": "接続を確立したり、メッセージを送信および受信したりするために一緒に使用される一連のプロトコルインスタンス。"
    },
    {
      "indent": 3,
      "text": "Racing:",
      "ja": "レース："
    },
    {
      "indent": 12,
      "text": "The attempt to select between multiple Protocol Stacks based on the Selection and Connection Properties communicated by the application, along with any Security Parameters.",
      "ja": "セキュリティパラメーターとともに、アプリケーションによって通信された選択と接続のプロパティに基づいて、複数のプロトコルスタックを選択しようとする試み。"
    },
    {
      "indent": 3,
      "text": "Remote Endpoint:",
      "ja": "リモートエンドポイント："
    },
    {
      "indent": 12,
      "text": "The peer that a Local Endpoint can communicate with when a Connection is established.",
      "ja": "ローカルエンドポイントが接続が確立されたときに通信できるピア。"
    },
    {
      "indent": 3,
      "text": "Remote Endpoint Identifier:",
      "ja": "リモートエンドポイント識別子："
    },
    {
      "indent": 12,
      "text": "A representation of the application's identifier for a peer that can participate in establishing a Connection.",
      "ja": "接続の確立に参加できるピアのアプリケーションの識別子の表現。"
    },
    {
      "indent": 3,
      "text": "Rendezvous:",
      "ja": "rendezvous："
    },
    {
      "indent": 12,
      "text": "The action of establishing a peer-to-peer Connection with a Remote Endpoint.",
      "ja": "リモートエンドポイントとピアツーピア接続を確立するアクション。"
    },
    {
      "indent": 3,
      "text": "Security Parameters:",
      "ja": "セキュリティパラメーター："
    },
    {
      "indent": 12,
      "text": "Parameters that define an application's requirements for authentication and encryption on a Connection.",
      "ja": "接続上の認証と暗号化に関するアプリケーションの要件を定義するパラメーター。"
    },
    {
      "indent": 3,
      "text": "Selection Property:",
      "ja": "選択プロパティ："
    },
    {
      "indent": 12,
      "text": "A Transport Property that can be set to influence the selection of paths between the Local and Remote Endpoints.",
      "ja": "ローカルエンドポイントとリモートエンドポイント間のパスの選択に影響を与えるように設定できる輸送プロパティ。"
    },
    {
      "indent": 3,
      "text": "Server:",
      "ja": "サーバ:"
    },
    {
      "indent": 12,
      "text": "The peer responsible for responding to a Connection initiation.",
      "ja": "接続開始に応答する責任者。"
    },
    {
      "indent": 3,
      "text": "Socket:",
      "ja": "ソケット："
    },
    {
      "indent": 12,
      "text": "The combination of a destination IP address and a destination port number [RFC8303].",
      "ja": "宛先IPアドレスと宛先ポート番号[RFC8303]の組み合わせ。"
    },
    {
      "indent": 3,
      "text": "System Policy:",
      "ja": "システムポリシー："
    },
    {
      "indent": 12,
      "text": "The input from an operating system or other global preferences that can constrain or influence how an implementation will gather Candidate Paths and Candidate Protocol Stacks and race the candidates during establishment of a Connection.",
      "ja": "オペレーティングシステムまたはその他のグローバル設定からの入力は、実装が候補パスと候補のプロトコルスタックを収集し、接続の確立中に候補者を競う方法を制約または影響を与える可能性があります。"
    },
    {
      "indent": 3,
      "text": "Transport Feature:",
      "ja": "輸送機能："
    },
    {
      "indent": 12,
      "text": "A specific end-to-end feature that the transport layer provides to an application.",
      "ja": "輸送層がアプリケーションに提供する特定のエンドツーエンド機能。"
    },
    {
      "indent": 3,
      "text": "Transport Property:",
      "ja": "輸送不動産："
    },
    {
      "indent": 12,
      "text": "A property of a transport protocol and the services it provides [RFC8095].",
      "ja": "輸送プロトコルのプロパティとそれが提供するサービス[RFC8095]。"
    },
    {
      "indent": 3,
      "text": "Transport Service:",
      "ja": "輸送サービス："
    },
    {
      "indent": 12,
      "text": "A set of transport features, not associated with any given framing protocol, that provides a complete service to an application.",
      "ja": "特定のフレーミングプロトコルに関連付けられていない一連の輸送機能は、アプリケーションに完全なサービスを提供します。"
    },
    {
      "indent": 3,
      "text": "Transport Services API:",
      "ja": "トランスポートサービスAPI："
    },
    {
      "indent": 12,
      "text": "The abstract interface [RFC9622] to a Transport Services Implementation [RFC9623].",
      "ja": "輸送サービスの実装[RFC9623]への要約インターフェイス[RFC9622]。"
    },
    {
      "indent": 3,
      "text": "Transport Services Implementation:",
      "ja": "輸送サービスの実装："
    },
    {
      "indent": 12,
      "text": "All objects and protocol instances used internally to a system or library to implement the functionality needed to provide a transport service across a network, as required by the abstract interface.",
      "ja": "抽象インターフェイスで要求されているように、ネットワーク全体で輸送サービスを提供するために必要な機能を実装するために、システムまたはライブラリに内部的に使用されるすべてのオブジェクトとプロトコルインスタンス。"
    },
    {
      "indent": 3,
      "text": "Transport Services System:",
      "ja": "輸送サービスシステム："
    },
    {
      "indent": 12,
      "text": "The Transport Services Implementation and the Transport Services API.",
      "ja": "輸送サービスの実装と輸送サービスAPI。"
    },
    {
      "indent": 0,
      "text": "2. API Model",
      "section_title": true,
      "ja": "2. APIモデル"
    },
    {
      "indent": 3,
      "text": "The model of using sockets can be represented as follows (see Figure 1):",
      "ja": "ソケットを使用するモデルは、次のように表現できます（図1を参照）。"
    },
    {
      "indent": 6,
      "text": "* Applications create connections and transfer data using the Socket API.",
      "ja": "* アプリケーションは、ソケットAPIを使用して接続を作成し、データを転送します。"
    },
    {
      "indent": 6,
      "text": "* The Socket API provides the interface to the implementations of TCP and UDP (typically implemented in the system's kernel).",
      "ja": "* Socket APIは、TCPとUDPの実装（通常、システムのカーネルに実装される）のインターフェイスを提供します。"
    },
    {
      "indent": 6,
      "text": "* TCP and UDP in the kernel send and receive data over the available network-layer interfaces.",
      "ja": "* カーネル内のTCPとUDPは、利用可能なネットワーク層インターフェイスを介してデータを送信および受信します。"
    },
    {
      "indent": 6,
      "text": "* Sockets are bound directly to transport-layer and network-layer addresses, obtained via a separate resolution step, usually performed by a system-provided DNS stub resolver.",
      "ja": "* ソケットは、通常、システムが提供するDNSスタブリゾルバーによって実行される別の解像度ステップで取得される輸送層およびネットワーク層アドレスに直接結合されます。"
    },
    {
      "indent": 3,
      "text": "+-----------------------------------------------------+\n|                    Application                      |\n+-----------------------------------------------------+\n        |                 |                  |\n  +------------+     +------------+    +--------------+\n  |  DNS Stub  |     | Stream API |    | Datagram API |\n  |  Resolver  |     +------------+    +--------------+\n  +------------+          |                  |\n                    +---------------------------------+\n                    |    TCP                UDP       |\n                    |    Kernel Networking Stack      |\n                    +---------------------------------+\n                                    |\n+-----------------------------------------------------+\n|               Network-Layer Interface               |\n+-----------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "Figure 1: Socket API Model",
      "ja": "図1：ソケットAPIモデル"
    },
    {
      "indent": 3,
      "text": "The architecture of the Transport Services System is an evolution of this general model of interaction. It both modernizes the API presented to applications by the transport layer and enriches the capabilities of the Transport Services Implementation below this API.",
      "ja": "輸送サービスシステムのアーキテクチャは、この相互作用の一般的なモデルの進化です。どちらも、輸送層によってアプリケーションに提示されたAPIを近代化し、このAPI以下の輸送サービスの実装の機能を強化します。"
    },
    {
      "indent": 3,
      "text": "The Transport Services API [RFC9622] defines the interface for an application to create Connections and transfer data. It combines interfaces for multiple interaction patterns into a unified whole (see Figure 2). This offers generic functions and also the protocol-specific mappings for TCP, UDP, UDP-Lite, and other protocol layers. These mappings are extensible. Future documents could define similar mappings for new layers and for other transport protocols, such as QUIC [RFC9000].",
      "ja": "Transport Services API [RFC9622]は、接続を作成してデータを転送するアプリケーションのインターフェイスを定義します。複数の相互作用パターンのインターフェイスを統一された全体に組み合わせます（図2を参照）。これにより、一般的な機能と、TCP、UDP、UDP-Lite、およびその他のプロトコル層のプロトコル固有のマッピングが提供されます。これらのマッピングは拡張可能です。将来のドキュメントは、新しいレイヤーやQUIC [RFC9000]などの他の輸送プロトコルの同様のマッピングを定義できます。"
    },
    {
      "indent": 3,
      "text": "+-----------------------------------------------------+\n|                    Application                      |\n+-----------------------------------------------------+\n                          |\n+-----------------------------------------------------+\n|              Transport Services API                 |\n+-----------------------------------------------------+\n                          |\n+-----------------------------------------------------+\n|          Transport Services Implementation          |\n|  (Using DNS, UDP, TCP, SCTP, DCCP, TLS, QUIC, etc.) |\n+-----------------------------------------------------+\n                          |\n+-----------------------------------------------------+\n|               Network-Layer Interface               |\n+-----------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Figure 2: Transport Services API Model",
      "ja": "図2：輸送サービスAPIモデル"
    },
    {
      "indent": 3,
      "text": "By combining name resolution with Connection establishment and data transfer in a single API, it allows for more flexible implementations to provide path and transport protocol agility on the application's behalf.",
      "ja": "単一のAPIでの名前の解像度と接続の確立とデータ転送を組み合わせることにより、より柔軟な実装がアプリケーションに代わってパスおよび輸送プロトコルの俊敏性を提供できるようにします。"
    },
    {
      "indent": 3,
      "text": "The Transport Services Implementation [RFC9623] is the component of the Transport Services System that implements the transport-layer protocols and other functions needed to send and receive data. It is responsible for mapping the API to a specific available transport Protocol Stack and managing the available network interfaces and paths.",
      "ja": "トランスポートサービスの実装[RFC9623]は、データの送信と受信に必要な輸送層プロトコルおよびその他の機能を実装するトランスポートサービスシステムのコンポーネントです。APIを特定の利用可能なトランスポートプロトコルスタックにマッピングし、使用可能なネットワークインターフェイスとパスを管理する責任があります。"
    },
    {
      "indent": 3,
      "text": "There are key differences between the architecture of the Transport Services System and the architecture of the Socket API. The API of the Transport Services System:",
      "ja": "トランスポートサービスシステムのアーキテクチャとソケットAPIのアーキテクチャには重要な違いがあります。輸送サービスシステムのAPI："
    },
    {
      "indent": 6,
      "text": "* is asynchronous and event-driven;",
      "ja": "* 非同期でイベント駆動型です。"
    },
    {
      "indent": 6,
      "text": "* uses Messages for representing data transfer to applications;",
      "ja": "* アプリケーションへのデータ転送を表すためにメッセージを使用します。"
    },
    {
      "indent": 6,
      "text": "* describes how a Transport Services Implementation can resolve Endpoint Identifiers to use multiple IP addresses, multiple protocols, and multiple paths and to provide multiple application streams.",
      "ja": "* トランスポートサービスの実装がエンドポイント識別子を解決して、複数のIPアドレス、複数のプロトコル、複数のパスを使用し、複数のアプリケーションストリームを提供する方法について説明します。"
    },
    {
      "indent": 0,
      "text": "2.1. Event-Driven API",
      "section_title": true,
      "ja": "2.1. イベント駆動型API"
    },
    {
      "indent": 3,
      "text": "Originally, the Socket API presented a blocking interface for establishing connections and transferring data. However, most modern applications interact with the network asynchronously. Emulation of an asynchronous interface using the Socket API can use a try-and-fail model: if the application wants to read but data has not yet been received from the peer, the call to read will fail. The application then waits and can try again later.",
      "ja": "もともと、ソケットAPIは、接続を確立してデータを転送するためのブロッキングインターフェイスを提示しました。ただし、ほとんどの最新のアプリケーションは、ネットワークと非同期的に相互作用します。ソケットAPIを使用した非同期インターフェイスのエミュレーションは、トライアンドフェイルモデルを使用できます。アプリケーションが読み取りたいが、ピアからデータがまだ受信されていない場合、読み取りコールは失敗します。その後、アプリケーションが待機し、後で再試行できます。"
    },
    {
      "indent": 3,
      "text": "In contrast to the Socket API, all interactions using the Transport Services API are expected to be asynchronous. The API is defined around an event-driven model (see Section 4.1.6), which models this asynchronous interaction. Other forms of asynchronous communication could also be available to applications, depending on the platform implementing the interface.",
      "ja": "ソケットAPIとは対照的に、トランスポートサービスAPIを使用したすべての相互作用は非同期であると予想されます。APIは、この非同期相互作用をモデル化するイベント駆動型モデル（セクション4.1.6を参照）を中心に定義されています。インターフェイスを実装するプラットフォームに応じて、アプリケーションで他の形式の非同期通信も利用できる可能性があります。"
    },
    {
      "indent": 3,
      "text": "For example, when an application that uses the Transport Services API wants to receive data, it issues an asynchronous call to receive new data from the Connection. When delivered data becomes available, this data is delivered to the application using asynchronous events that contain the data. Error handling is also asynchronous, resulting in asynchronous error events.",
      "ja": "たとえば、Transport Services APIを使用するアプリケーションがデータを受信する必要がある場合、非同期呼び出しを発行して接続から新しいデータを受信します。配信されたデータが利用可能になると、このデータはデータを含む非同期イベントを使用してアプリケーションに配信されます。エラー処理も非同期であるため、非同期エラーイベントが発生します。"
    },
    {
      "indent": 3,
      "text": "This API also delivers events regarding the lifetime of a connection and changes in the available network links, which were not previously made explicit in the Socket API.",
      "ja": "このAPIは、ソケットAPIで以前に明示的にされていなかった接続の寿命と使用可能なネットワークリンクの変更に関するイベントも提供します。"
    },
    {
      "indent": 3,
      "text": "Using asynchronous events allows for a more natural interaction model when establishing connections and transferring data. Events in time more closely reflect the nature of interactions over networks, as opposed to how the Socket API represents network resources as file system objects that may be temporarily unavailable.",
      "ja": "非同期イベントを使用すると、接続を確立してデータを転送するときに、より自然な相互作用モデルが可能になります。ソケットAPIが一時的に利用できない可能性のあるファイルシステムオブジェクトとしてネットワークリソースをどのように表すかとは対照的に、時間のイベントはネットワーク上の相互作用の性質をより密接に反映しています。"
    },
    {
      "indent": 3,
      "text": "Separate from events, callbacks are also provided for asynchronous interactions with the Transport Services API that are not directly related to events on the network or network interfaces.",
      "ja": "イベントとは別に、コールバックは、ネットワークまたはネットワークインターフェイス上のイベントに直接関係していないトランスポートサービスAPIとの非同期相互作用にも提供されます。"
    },
    {
      "indent": 0,
      "text": "2.2. Data Transfer Using Messages",
      "section_title": true,
      "ja": "2.2. メッセージを使用したデータ転送"
    },
    {
      "indent": 3,
      "text": "The Socket API provides a message interface for datagram protocols like UDP but provides an unstructured stream abstraction for TCP. While TCP has the ability to send and receive data as a byte-stream, most applications need to interpret structure within this byte-stream. For example, HTTP/1.1 uses character delimiters to segment messages over a byte-stream [RFC9112]; TLS record headers carry a version, content type, and length [RFC8446]; and HTTP/2 uses frames to segment its headers and bodies [RFC9113].",
      "ja": "Socket APIは、UDPなどのデータグラムプロトコルのメッセージインターフェイスを提供しますが、TCPの非構造化ストリーム抽象化を提供します。TCPにはバイトストリームとしてデータを送信および受信する機能がありますが、ほとんどのアプリケーションはこのバイトストリーム内の構造を解釈する必要があります。たとえば、HTTP/1.1は文字デリミターを使用して、バイトストリーム[RFC9112]を介してメッセージをセグメント化します。TLSレコードヘッダーには、バージョン、コンテンツタイプ、および長さが付いています[RFC8446]。HTTP/2はフレームを使用してヘッダーとボディをセグメント化します[RFC9113]。"
    },
    {
      "indent": 3,
      "text": "The Transport Services API represents data as Messages, so that it more closely matches the way applications use the network. A Message-based abstraction provides many benefits, such as:",
      "ja": "Transport Services APIはメッセージとしてデータを表しているため、アプリケーションがネットワークを使用する方法をより密接に一致させます。メッセージベースの抽象化は、次のような多くの利点を提供します。"
    },
    {
      "indent": 6,
      "text": "* providing additional information to the Protocol Stack;",
      "ja": "* プロトコルスタックに追加情報を提供します。"
    },
    {
      "indent": 6,
      "text": "* the ability to associate deadlines with Messages, for applications that care about timing;",
      "ja": "* タイミングを気にするアプリケーションのために、締め切りをメッセージに関連付ける能力。"
    },
    {
      "indent": 6,
      "text": "* the ability to control reliability, which Messages to retransmit when there is packet loss, and how best to make use of the data that arrived;",
      "ja": "* 信頼性を制御する能力、パケットの損失があるときに再送信するメッセージ、および到着したデータを利用するのが最善の方法。"
    },
    {
      "indent": 6,
      "text": "* the ability to automatically assign Messages and connections to underlying transport connections to utilize multistreaming and create Pooled Connections.",
      "ja": "* 基礎となるトランスポート接続にメッセージと接続を自動的に割り当てる機能は、マルチストリーミングを利用してプールされた接続を作成します。"
    },
    {
      "indent": 3,
      "text": "Allowing applications to interact with Messages is backward-compatible with existing protocols and APIs because it does not change the wire format of any protocol. Instead, it provides the Protocol Stack with additional information to allow it to make better use of modern transport protocols, while simplifying the application's role in parsing data. For protocols that inherently use a streaming abstraction, Framers (Section 4.1.5) bridge the gap between the two abstractions.",
      "ja": "アプリケーションがメッセージと対話できるようにすることは、プロトコルのワイヤ形式を変更しないため、既存のプロトコルとAPIとの後方互換性があります。代わりに、プロトコルスタックに追加情報を提供し、データの解析におけるアプリケーションの役割を簡素化しながら、最新の輸送プロトコルをより適切に使用できるようにします。ストリーミング抽象化を本質的に使用するプロトコルの場合、フレーマー（セクション4.1.5）は、2つの抽象化の間のギャップを埋めます。"
    },
    {
      "indent": 0,
      "text": "2.3. Flexible Implementation",
      "section_title": true,
      "ja": "2.3. 柔軟な実装"
    },
    {
      "indent": 3,
      "text": "The Socket API for protocols like TCP is generally limited to connecting to a single address over a single interface (IP source address). It also presents a single stream to the application. Software layers built upon this API often propagate this limitation of a single-address single-stream model. The Transport Services Architecture is designed to:",
      "ja": "TCPなどのプロトコルのソケットAPIは、一般に、単一のインターフェイス（IPソースアドレス）を介して単一のアドレスに接続することに限定されます。また、アプリケーションに単一のストリームを提示します。このAPI上に構築されたソフトウェアレイヤーは、多くの場合、単一アドレスシングルストリームモデルのこの制限を伝播します。トランスポートサービスアーキテクチャは、次のように設計されています。"
    },
    {
      "indent": 6,
      "text": "* handle multiple candidate endpoints, protocols, and paths;",
      "ja": "* 複数の候補のエンドポイント、プロトコル、およびパスを処理します。"
    },
    {
      "indent": 6,
      "text": "* support candidate protocol racing to select the most optimal stack in each situation;",
      "ja": "* 候補者のプロトコルレースをサポートして、各状況で最も最適なスタックを選択します。"
    },
    {
      "indent": 6,
      "text": "* support multipath and multistreaming protocols;",
      "ja": "* マルチパスおよびマルチストリーミングプロトコルをサポートします。"
    },
    {
      "indent": 6,
      "text": "* provide state caching and application control over it.",
      "ja": "* 州のキャッシュとアプリケーションの制御を提供します。"
    },
    {
      "indent": 3,
      "text": "A Transport Services Implementation is intended to be flexible at Connection establishment time, considering many different options and trying to select the most optimal combinations by racing them and measuring the results (see Sections 4.2.1 and 4.2.2). This requires applications to specify identifiers for the Local and Remote Endpoint that are at a higher level than IP addresses, such as a hostname or URL. These identifiers are used by a Transport Services Implementation for resolution, path selection, and racing. An implementation can further implement fallback mechanisms if connection establishment for one protocol fails or performance is determined to be unsatisfactory.",
      "ja": "トランスポートサービスの実装は、多くの異なるオプションを考慮し、それらをレースして結果を測定することにより、最も最適な組み合わせを選択しようとするために、接続の確立時間で柔軟にすることを目的としています（セクション4.2.1および4.2.2を参照）。これには、ホスト名やURLなどのIPアドレスよりも高いレベルのローカルエンドポイントとリモートエンドポイントの識別子を指定するアプリケーションが必要です。これらの識別子は、解像度、パスの選択、レースのために輸送サービスの実装によって使用されます。1つのプロトコルの接続確立が失敗した場合、またはパフォーマンスが不十分であると判断された場合、実装はフォールバックメカニズムをさらに実装できます。"
    },
    {
      "indent": 3,
      "text": "Information used in Connection establishment (e.g., cryptographic resumption tokens, information about usability of certain protocols on the path, results of racing in previous connections) is cached in the Transport Services Implementation. Applications have control over whether this information is used for a specific establishment, in order to allow trade-offs between efficiency and linkability.",
      "ja": "接続された施設で使用される情報（例：暗号化の再開トークン、パス上の特定のプロトコルの使いやすさに関する情報、以前の接続でのレースの結果）は、輸送サービスの実装でキャッシュされています。アプリケーションは、効率とリンク可能性の間のトレードオフを可能にするために、この情報が特定の施設に使用されるかどうかを制御しています。"
    },
    {
      "indent": 3,
      "text": "Flexibility after Connection establishment is also important. Transport protocols that can migrate between multiple network-layer interfaces need to be able to process and react to interface changes. Protocols that support multiple application-layer streams need to support initiating and receiving new streams using existing connections.",
      "ja": "接続の確立後の柔軟性も重要です。複数のネットワーク層インターフェイス間で移行できる輸送プロトコルは、インターフェイスの変更に処理して対応できる必要があります。複数のアプリケーション層ストリームをサポートするプロトコルは、既存の接続を使用して新しいストリームの開始と受信をサポートする必要があります。"
    },
    {
      "indent": 0,
      "text": "2.4. Coexistence",
      "section_title": true,
      "ja": "2.4. 共存"
    },
    {
      "indent": 3,
      "text": "While the architecture of the Transport Services System is designed as an enhanced replacement for the Socket API, it need not replace it entirely on a system or platform; indeed, coexistence has been recommended for incremental deployability [RFC8170]. The architecture is therefore designed such that it can run alongside (or, indeed, on top of) an existing Socket API implementation; only applications built on the Transport Services API are managed by the system's Transport Services Implementation.",
      "ja": "トランスポートサービスシステムのアーキテクチャは、ソケットAPIの拡張交換として設計されていますが、システムまたはプラットフォームに完全に置き換える必要はありません。実際、増分展開性[RFC8170]には共存が推奨されています。したがって、アーキテクチャは、既存のソケットAPI実装と一緒に（または実際には実際に）実行できるように設計されています。Transport Services API上に構築されたアプリケーションのみが、システムのトランスポートサービスの実装によって管理されます。"
    },
    {
      "indent": 0,
      "text": "3. API and Implementation Requirements",
      "section_title": true,
      "ja": "3. APIおよび実装要件"
    },
    {
      "indent": 3,
      "text": "One goal of the architecture is to redefine the interface between applications and transports in a way that allows the transport layer to evolve and improve without fundamentally changing the contract with the application. This requires careful consideration of how to expose the capabilities of protocols. The architecture also encompasses system policies that can influence and inform how transport protocols use a network path or interface.",
      "ja": "アーキテクチャの目標の1つは、アプリケーションと契約を根本的に変更せずに輸送層を進化させ、改善できるように、アプリケーションと輸送の間のインターフェイスを再定義することです。これには、プロトコルの機能を公開する方法を慎重に検討する必要があります。アーキテクチャには、輸送プロトコルがネットワークパスまたはインターフェイスを使用する方法に影響を与えて情報を提供できるシステムポリシーも含まれます。"
    },
    {
      "indent": 3,
      "text": "There are several ways the Transport Services System can offer flexibility to an application. It can:",
      "ja": "輸送サービスシステムがアプリケーションに柔軟性を提供できる方法はいくつかあります。できる："
    },
    {
      "indent": 6,
      "text": "* provide access to transport protocols and protocol features;",
      "ja": "* 輸送プロトコルとプロトコル機能へのアクセスを提供します。"
    },
    {
      "indent": 6,
      "text": "* use these protocols across multiple paths that could have different performance and functional characteristics;",
      "ja": "* 異なるパフォーマンスと機能的特性を持つ可能性のある複数のパスでこれらのプロトコルを使用します。"
    },
    {
      "indent": 6,
      "text": "* communicate with different remote systems to optimize performance, robustness to failure, or some other metric.",
      "ja": "* 異なるリモートシステムと通信して、パフォーマンス、障害への堅牢性、またはその他のメトリックを最適化します。"
    },
    {
      "indent": 3,
      "text": "Beyond these, if the Transport Services API remains the same over time, new protocols and features can be added to the Transport Services Implementation without requiring changes in applications for adoption. Similarly, this can provide a common basis for utilizing information about a network path or interface, enabling evolution below the transport layer.",
      "ja": "これらを超えて、トランスポートサービスAPIが時間の経過とともに同じままである場合、採用のためのアプリケーションの変更を必要とせずに、新しいプロトコルと機能をトランスポートサービスの実装に追加できます。同様に、これはネットワークパスまたはインターフェイスに関する情報を利用して、輸送層の下で進化を可能にするための共通の基礎を提供できます。"
    },
    {
      "indent": 3,
      "text": "The normative requirements described in this section allow Transport Services APIs and Transport Services Implementations to provide this functionality without causing incompatibility or introducing security vulnerabilities.",
      "ja": "このセクションで説明する規範的要件により、輸送サービスAPIおよび輸送サービスの実装は、非互換性を引き起こしたり、セキュリティの脆弱性を導入せずにこの機能を提供します。"
    },
    {
      "indent": 0,
      "text": "3.1. Provide Common APIs for Common Features",
      "section_title": true,
      "ja": "3.1. 一般的な機能に共通のAPIを提供します"
    },
    {
      "indent": 3,
      "text": "Any functionality that is common across multiple transport protocols SHOULD be made accessible through a unified set of calls using the Transport Services API. As a baseline, any Transport Services API SHOULD allow access to the minimal set of features offered by transport protocols [RFC8923]. If that minimal set is updated or expanded in the future, the Transport Services API ought to be extended to match.",
      "ja": "複数の輸送プロトコルで一般的な機能は、トランスポートサービスAPIを使用して統一された一連のコールを介してアクセスできるようにする必要があります。ベースラインとして、輸送サービスAPIは、輸送プロトコル[RFC8923]によって提供される最小限の機能セットへのアクセスを可能にする必要があります。その最小セットが将来更新または拡張された場合、輸送サービスAPIは一致するように拡張する必要があります。"
    },
    {
      "indent": 3,
      "text": "An application can specify constraints and preferences for the protocols, features, and network interfaces it will use via Properties. Properties are used by an application to declare its preferences for how the transport service should operate at each stage in the lifetime of a connection. Transport Properties are subdivided into the following:",
      "ja": "アプリケーションは、プロパティを介して使用するプロトコル、機能、およびネットワークインターフェイスの制約と設定を指定できます。プロパティは、接続の生涯の各段階で輸送サービスがどのように動作するかについての好みを宣言するためにアプリケーションによって使用されます。輸送プロパティは、次のように細分化されます。"
    },
    {
      "indent": 6,
      "text": "* Selection Properties, which specify which paths and Protocol Stacks can be used and are preferred by the application;",
      "ja": "* 選択プロパティは、どのパスとプロトコルスタックを使用できるかを指定し、アプリケーションで優先されるかを指定します。"
    },
    {
      "indent": 6,
      "text": "* Connection Properties, which inform decisions made during Connection establishment and fine-tune the established connection; and",
      "ja": "* 接続プロパティは、接続の確立中に行われた決定を通知し、確立された接続を微調整します。そして"
    },
    {
      "indent": 6,
      "text": "* Message Properties, which can be set on individual Messages.",
      "ja": "* 個々のメッセージで設定できるメッセージプロパティ。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that the Transport Services API offer Properties that are common to multiple transport protocols. This enables a Transport Services System to appropriately select between protocols that offer equivalent features. Similarly, it is RECOMMENDED that the Properties offered by the Transport Services API be applicable to a variety of network-layer interfaces and paths, to permit racing of different network paths without affecting the applications using the API. Each is expected to have a default value.",
      "ja": "トランスポートサービスAPIは、複数の輸送プロトコルに共通のプロパティを提供することをお勧めします。これにより、輸送サービスシステムは、同等の機能を提供するプロトコルを適切に選択できます。同様に、APIを使用してアプリケーションに影響を与えることなく、さまざまなネットワークパスのレースを許可するために、Transport Services APIが提供するプロパティをさまざまなネットワーク層インターフェイスとパスに適用することをお勧めします。それぞれにデフォルト値があると予想されます。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that the default values for Properties be selected to ensure correctness for the widest set of applications, while providing the widest set of options for selection. For example, since both applications that require reliability and those that do not require reliability can function correctly when a protocol provides reliability, reliability ought to be enabled by default. As another example, the default value for a Property regarding the selection of network interfaces ought to permit as many interfaces as possible.",
      "ja": "選択のための最も広いセットのセットを提供しながら、アプリケーションの最も広いセットの正しさを確保するために、プロパティのデフォルト値を選択することをお勧めします。たとえば、信頼性を必要とするアプリケーションと信頼性を必要としないアプリケーションは、プロトコルが信頼性を提供する場合に正しく機能できるため、信頼性をデフォルトで有効にする必要があります。別の例として、ネットワークインターフェイスの選択に関するプロパティのデフォルト値は、できるだけ多くのインターフェイスを許可する必要があります。"
    },
    {
      "indent": 3,
      "text": "Applications using the Transport Services API need to be designed to be robust to the automated selection provided by the Transport Services System. This automated selection is constrained by the preferences expressed by the application and requires applications to explicitly set Properties that define any necessary constraints on protocol, path, and interface selection.",
      "ja": "Transport Services APIを使用したアプリケーションは、トランスポートサービスシステムが提供する自動選択に堅牢であるように設計する必要があります。この自動化された選択は、アプリケーションによって表明された設定によって制約され、プロトコル、パス、およびインターフェイスの選択に必要な制約を定義するプロパティを明示的に設定するためにアプリケーションが必要です。"
    },
    {
      "indent": 0,
      "text": "3.2. Allow Access to Specialized Features",
      "section_title": true,
      "ja": "3.2. 特殊な機能へのアクセスを許可します"
    },
    {
      "indent": 3,
      "text": "There are applications that will need to control fine-grained details of transport protocols to optimize their behavior and ensure compatibility with remote systems. It is therefore RECOMMENDED that the Transport Services API and the Transport Services Implementation permit more specialized protocol features to be used.",
      "ja": "動作を最適化し、リモートシステムとの互換性を確保するために、輸送プロトコルの細かい詳細を制御する必要があるアプリケーションがあります。したがって、Transport Services APIとTransport Servicesの実装により、より専門的なプロトコル機能を使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Some specialized features could be needed by an application only when using a specific protocol and not when using others. For example, if an application is using TCP, it could require control over the User Timeout Option for TCP [RFC5482]. Such features would not take effect for other transport protocols. In such cases, the API ought to expose the features in such a way that they take effect when a particular protocol is selected but do not imply that only that protocol could be used. For example, if the API allows an application to specify a preference for using the User Timeout Option, communication would not fail when a protocol such as UDP is selected.",
      "ja": "特定のプロトコルを使用する場合のみ、他のプロトコルを使用する場合ではなく、アプリケーションではいくつかの特殊な機能が必要になる場合があります。たとえば、アプリケーションがTCPを使用している場合、TCP [RFC5482]のユーザータイムアウトオプションを制御する必要がある可能性があります。このような機能は、他の輸送プロトコルでは有効になりません。そのような場合、APIは、特定のプロトコルが選択されたときに有効になるように機能を公開する必要がありますが、そのプロトコルのみを使用できることを意味しません。たとえば、APIでアプリケーションがユーザータイムアウトオプションを使用する優先順位を指定できる場合、UDPなどのプロトコルが選択された場合、通信は失敗しません。"
    },
    {
      "indent": 3,
      "text": "Other specialized features, however, can also be strictly required by an application and thus further constrain the set of protocols that can be used. For example, if an application requires support for automatic handover or failover for a connection, only Protocol Stacks that provide this feature are eligible to be used, e.g., Protocol Stacks that include a multipath protocol or a protocol that supports connection migration. A Transport Services API needs to allow applications to define such requirements and constrain the options available to a Transport Services Implementation. Since such options are not part of the core/common features, it will generally be simple for an application to modify its set of constraints and change the set of allowable protocol features without changing the core implementation.",
      "ja": "ただし、他の専門的な機能は、アプリケーションで厳密に必要となるため、使用できるプロトコルのセットをさらに制約することもできます。たとえば、アプリケーションが接続の自動ハンドオーバーまたはフェールオーバーのサポートを必要とする場合、この機能を提供するプロトコルスタックのみが使用される資格があります。たとえば、マルチパスプロトコルまたは接続移行をサポートするプロトコルを含むプロトコルスタックなどです。Transport Services APIは、アプリケーションがそのような要件を定義し、輸送サービスの実装で利用可能なオプションを制約できるようにする必要があります。このようなオプションはコア/一般的な機能の一部ではないため、アプリケーションが制約のセットを変更し、コア実装を変更せずに許容プロトコル機能のセットを変更するのは一般に簡単です。"
    },
    {
      "indent": 3,
      "text": "To control these specialized features, the application can declare its preference: whether the presence of a specific feature is prohibited, should be avoided, can be ignored, is preferred, or is required in the preestablishment phase. An implementation of a Transport Services API would honor this preference and allow the application to query the availability of each specialized feature after successful establishment.",
      "ja": "これらの専門的な機能を制御するために、アプリケーションはその好みを宣言できます。特定の機能の存在が禁止されているか、避けられるべきか、無視されるか、好まれるか、前提条件で必要です。トランスポートサービスAPIの実装は、この好みを尊重し、設立が成功した後、アプリケーションが各専門機能の可用性を照会できるようにします。"
    },
    {
      "indent": 0,
      "text": "3.3. Select Between Equivalent Protocol Stacks",
      "section_title": true,
      "ja": "3.3. 同等のプロトコルスタックを選択します"
    },
    {
      "indent": 3,
      "text": "A Transport Services Implementation can attempt to use, and select between, multiple Protocol Stacks based on the Selection and Connection Properties communicated by the application, along with any Security Parameters. The implementation can only attempt to use multiple Protocol Stacks when they are \"equivalent\", which means that the stacks can provide the same Transport Properties and interface expectations as requested by the application. Equivalent Protocol Stacks can be safely swapped or raced in parallel (see Section 4.2.2) during Connection establishment.",
      "ja": "トランスポートサービスの実装は、セキュリティパラメーターとともに、アプリケーションによって伝達された選択および接続プロパティに基づいて、複数のプロトコルスタックを使用して選択しようとします。実装は、複数のプロトコルスタックが「同等」である場合にのみ使用しようとすることができます。つまり、スタックは、アプリケーションで要求されたのと同じ輸送プロパティとインターフェイスの期待を提供できます。同等のプロトコルスタックは、接続確立中に安全に交換または並行してレースすることができます（セクション4.2.2を参照）。"
    },
    {
      "indent": 3,
      "text": "The following two examples show non-equivalent Protocol Stacks:",
      "ja": "次の2つの例は、非等価プロトコルスタックを示しています。"
    },
    {
      "indent": 6,
      "text": "* If the application requires preservation of Message boundaries, a Protocol Stack that runs UDP as the top-level interface to the application is not equivalent to a Protocol Stack that runs TCP as the top-level interface. A UDP stack would allow an application to read out Message boundaries based on datagrams sent from the remote system, whereas TCP does not preserve Message boundaries on its own but needs a framing protocol on top to determine Message boundaries.",
      "ja": "* アプリケーションがメッセージ境界の保存を必要とする場合、アプリケーションへのトップレベルインターフェイスとしてUDPを実行するプロトコルスタックは、TCPをトップレベルインターフェイスとして実行するプロトコルスタックと同等ではありません。UDPスタックを使用すると、アプリケーションはリモートシステムから送信されたデータグラムに基づいてメッセージの境界を読み取ることができますが、TCPはそれ自体でメッセージの境界を保持していませんが、メッセージの境界を決定するためにフレーミングプロトコルが必要です。"
    },
    {
      "indent": 6,
      "text": "* If the application specifies that it requires reliable transmission of data, then a Protocol Stack using UDP without any reliability layer on top would not be allowed to replace a Protocol Stack using TCP.",
      "ja": "* アプリケーションがデータの信頼できる送信が必要であることを指定した場合、上に信頼性のあるレイヤーなしでUDPを使用したプロトコルスタックは、TCPを使用してプロトコルスタックを交換することはできません。"
    },
    {
      "indent": 3,
      "text": "The following example shows equivalent Protocol Stacks:",
      "ja": "次の例は、同等のプロトコルスタックを示しています。"
    },
    {
      "indent": 6,
      "text": "* If the application does not require reliable transmission of data, then a Protocol Stack that adds reliability could be regarded as an equivalent Protocol Stack as long as providing this would not conflict with any other application-requested Properties.",
      "ja": "* アプリケーションが信頼できるデータの送信を必要としない場合、信頼性を追加するプロトコルスタックは、これが他のアプリケーション要求プロパティと競合しない限り、同等のプロトコルスタックと見なすことができます。"
    },
    {
      "indent": 3,
      "text": "A Transport Services Implementation can race different security protocols, e.g., if the System Policy is explicitly configured to consider them equivalent. A Transport Services Implementation SHOULD only race Protocol Stacks where the transport security protocols within the stacks are identical. To ensure that security protocols are not incorrectly swapped, a Transport Services Implementation MUST only select Protocol Stacks that meet application requirements [RFC8922]. A Transport Services Implementation MUST NOT automatically fall back from secure protocols to insecure protocols or fall back to weaker versions of secure protocols. A Transport Services Implementation MAY allow applications to explicitly specify which versions of a protocol ought to be permitted, e.g., to allow a minimum version of TLS 1.2 if TLS 1.3 is not available.",
      "ja": "トランスポートサービスの実装は、システムポリシーがそれらを同等に考慮するように明示的に構成されている場合、さまざまなセキュリティプロトコルを競争することができます。トランスポートサービスの実装では、スタック内の輸送セキュリティプロトコルが同一のレースプロトコルスタックのみが必要です。セキュリティプロトコルが誤って交換されないようにするには、輸送サービスの実装は、アプリケーション要件を満たすプロトコルスタックのみを選択する必要があります[RFC8922]。トランスポートサービスの実装は、安全なプロトコルから安全なプロトコルに自動的に後退したり、安全なプロトコルのより弱いバージョンに戻ったりしてはなりません。トランスポートサービスの実装により、アプリケーションは、TLS 1.3が利用できない場合、TLS 1.2の最小バージョンを許可するために、プロトコルのバージョンを許可する必要があるかを明示的に指定できる場合があります。"
    },
    {
      "indent": 3,
      "text": "A Transport Services Implementation MAY specify security Properties relating to how the system operates (e.g., requirements, prohibitions, and preferences for the use of DNS Security Extensions (DNSSEC) or DNS over HTTPS (DoH)).",
      "ja": "トランスポートサービスの実装では、システムの動作方法に関するセキュリティプロパティ（要件、禁止、DNSセキュリティエクステンション（DNSEC）またはDNSをHTTPS（DOH）を使用するための選好）に関連する場合があります。"
    },
    {
      "indent": 0,
      "text": "3.4. Maintain Interoperability",
      "section_title": true,
      "ja": "3.4. 相互運用性を維持します"
    },
    {
      "indent": 3,
      "text": "It is important to note that neither the Transport Services API [RFC9622] nor the guidelines for implementation of the Transport Services System [RFC9623] define new protocols or protocol capabilities that affect what is communicated across the network. A Transport Services System MUST NOT require that a peer on the other side of a connection use the same API or implementation. A Transport Services Implementation acting as a connection initiator is able to communicate with any existing Endpoint that implements the transport protocol(s) and all the required Properties selected. Similarly, a Transport Services Implementation acting as a Listener can receive connections for any protocol that is supported from an existing initiator that implements the protocol, independently of whether or not the initiator uses the Transport Services System.",
      "ja": "トランスポートサービスAPI [RFC9622]も、輸送サービスシステムの実装に関するガイドライン[RFC9623]が、ネットワーク全体で伝えられるものに影響を与える新しいプロトコルまたはプロトコル機能を定義していないことに注意することが重要です。輸送サービスシステムは、接続の反対側のピアが同じAPIまたは実装を使用することを要求してはなりません。接続イニシエーターとして機能するトランスポートサービスの実装は、輸送プロトコルと選択されたすべての必要なプロパティを実装する既存のエンドポイントと通信することができます。同様に、リスナーとして機能するトランスポートサービスの実装は、イニシエーターがトランスポートサービスシステムを使用するかどうかとは無関係に、プロトコルを実装する既存のイニシエーターからサポートされるプロトコルの接続を受信できます。"
    },
    {
      "indent": 3,
      "text": "A Transport Services Implementation makes decisions that select protocols and interfaces. In normal use, a given version of a Transport Services System SHOULD result in consistent protocol and interface selection decisions for the same network conditions, given the same set of Properties. This is intended to provide predictable outcomes to the application using the API.",
      "ja": "トランスポートサービスの実装は、プロトコルとインターフェイスを選択する決定を下します。通常の使用では、輸送サービスシステムの特定のバージョンは、同じプロパティセットを考慮して、同じネットワーク条件の一貫したプロトコルとインターフェイスの選択決定をもたらすはずです。これは、APIを使用してアプリケーションに予測可能な結果を提供することを目的としています。"
    },
    {
      "indent": 0,
      "text": "3.5. Support Monitoring",
      "section_title": true,
      "ja": "3.5. サポート監視"
    },
    {
      "indent": 3,
      "text": "The Transport Services API increases the layer of abstraction for applications, and it enables greater automation below the API. Such increased abstraction comes at the cost of increased complexity when application programmers, users, or system administrators try to understand why any issues and failures may be happening. A Transport Services System should therefore offer monitoring functions that provide relevant debug and diagnostics information. For example, such monitoring functions could indicate the protocol(s) in use, the number of open connections per protocol, and any statistics that these protocols may offer.",
      "ja": "Transport Services APIは、アプリケーションの抽象化のレイヤーを増加させ、API以下のより大きな自動化を可能にします。このような抽象化の増加は、アプリケーションプログラマー、ユーザー、またはシステム管理者が問題や障害が発生している理由を理解しようとすると、複雑さが増加します。したがって、輸送サービスシステムは、関連するデバッグおよび診断情報を提供する監視機能を提供する必要があります。たとえば、このような監視関数は、使用中のプロトコル、プロトコルごとのオープン接続の数、およびこれらのプロトコルが提供する統計を示すことができます。"
    },
    {
      "indent": 0,
      "text": "4. Transport Services Architecture and Concepts",
      "section_title": true,
      "ja": "4. 輸送サービスアーキテクチャと概念"
    },
    {
      "indent": 3,
      "text": "This section describes the architecture non-normatively and explains the operation of a Transport Services Implementation. The concepts defined in this document are intended primarily for use in the documents and specifications that describe the Transport Services System. This includes the architecture, the Transport Services API, and the associated Transport Services Implementation. While the specific terminology can be used in some implementations, it is expected that there will remain a variety of terms used by running code.",
      "ja": "このセクションでは、アーキテクチャについて非規範的に説明し、輸送サービスの実装の運用について説明します。このドキュメントで定義されている概念は、主に輸送サービスシステムを説明するドキュメントと仕様で使用することを目的としています。これには、アーキテクチャ、輸送サービスAPI、および関連する輸送サービスの実装が含まれます。特定の用語はいくつかの実装で使用できますが、実行中のコードで使用されるさまざまな用語が残ることが予想されます。"
    },
    {
      "indent": 3,
      "text": "The architecture divides the concepts for the Transport Services System into two categories:",
      "ja": "アーキテクチャは、輸送サービスシステムの概念を2つのカテゴリに分割します。"
    },
    {
      "indent": 8,
      "text": "1. API concepts, which are intended to be exposed to applications; and",
      "ja": "1. アプリケーションにさらされることを目的としたAPIコンセプト。そして"
    },
    {
      "indent": 8,
      "text": "2. System-implementation concepts, which are intended to be internally used by a Transport Services Implementation.",
      "ja": "2. 輸送サービスの実装で内部的に使用することを目的としたシステム実装の概念。"
    },
    {
      "indent": 3,
      "text": "The following diagram summarizes the top-level concepts in a Transport Services System and how they relate to one another.",
      "ja": "次の図は、輸送サービスシステムのトップレベルの概念と、それらが互いにどのように関連するかをまとめたものです。"
    },
    {
      "indent": 3,
      "text": "  +-----------------------------------------------------+\n  |                    Application                      |\n  +-+----------------+------^-------+--------^----------+\n    |                |      |       |        |\n  pre-               |     data     |      events\n  establishment      |   transfer   |        |\n    |        establishment  |   termination  |\n    |                |      |       |        |\n    |             +--v------v-------v+       |\n  +-v-------------+   Connection(s)  +-------+----------+\n  |  Transport    +--------+---------+                  |\n  |  Services              |                            |\n  |  API                   |  +-------------+           |\n  +------------------------+--+  Framer(s)  |-----------+\n                           |  +-------------+\n  +------------------------|----------------------------+\n  |  Transport             |                            |\n  |  System                |        +-----------------+ |\n  |  Implementation        |        |     Cached      | |\n  |                        |        |      State      | |\n  |  (Candidate Gathering) |        +-----------------+ |\n  |                        |                            |\n  |  (Candidate Racing)    |        +-----------------+ |\n  |                        |        |     System      | |\n  |                        |        |     Policy      | |\n  |             +----------v-----+  +-----------------+ |\n  |             |    Protocol    |                      |\n  +-------------+    Stack(s)    +----------------------+\n                +-------+--------+\n                        V\n+-----------------------------------------------------+\n|               Network-Layer Interface               |\n+-----------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Figure 3: Concepts and Relationships in the Architecture of the Transport Services System",
      "ja": "図3：輸送サービスシステムのアーキテクチャにおける概念と関係"
    },
    {
      "indent": 3,
      "text": "The Transport Services Implementation includes the Cached State and System Policy.",
      "ja": "輸送サービスの実装には、キャッシュされた州とシステムのポリシーが含まれます。"
    },
    {
      "indent": 3,
      "text": "The System Policy provides input from an operating system or other global preferences that can constrain or influence how an implementation will gather Candidate Paths and Protocol Stacks and race the candidates when establishing a Connection. As the details of System Policy configuration and enforcement are largely dependent on the platform and implementation and do not affect application-level interoperability, the Transport Services API [RFC9622] does not specify an interface for reading or writing System Policy.",
      "ja": "システムポリシーは、オペレーティングシステムまたはその他のグローバル設定からの入力を提供します。これは、実装が候補パスとプロトコルスタックを収集し、接続を確立する際に候補者を競う方法を制約または影響を与える可能性があります。システムポリシーの構成と執行の詳細は、プラットフォームと実装に大きく依存しており、アプリケーションレベルの相互運用性に影響しないため、Transport Services API [RFC9622]は、システムポリシーを読み書きするためのインターフェイスを指定していません。"
    },
    {
      "indent": 3,
      "text": "The Cached State is the state and history that the Transport Services Implementation keeps for each set of associated Endpoints that have previously been used. An application ought to explicitly request any required or preferred Properties via the Transport Services API.",
      "ja": "キャッシュされた状態は、以前に使用されていた関連するエンドポイントのセットごとに輸送サービスの実装が保持される状態と歴史です。アプリケーションは、Transport Services APIを介して必要なまたは優先プロパティを明示的に要求する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.1. Transport Services API Concepts",
      "section_title": true,
      "ja": "4.1. 輸送サービスAPIコンセプト"
    },
    {
      "indent": 3,
      "text": "Fundamentally, a Transport Services API needs to provide Connection objects (Section 4.1.2) that allow applications to establish communication and then send and receive data. These could be exposed as handles or referenced objects, depending on the chosen programming language.",
      "ja": "基本的に、Transport Services APIは、アプリケーションが通信を確立し、データを送信および受信できるようにする接続オブジェクト（セクション4.1.2）を提供する必要があります。これらは、選択したプログラミング言語に応じて、ハンドルまたは参照オブジェクトとして公開することができます。"
    },
    {
      "indent": 3,
      "text": "Beyond the Connection objects, there are several high-level groups of actions that any Transport Services API needs to provide:",
      "ja": "接続オブジェクトを超えて、トランスポートサービスAPIが提供する必要があるアクションの高レベルのグループがいくつかあります。"
    },
    {
      "indent": 6,
      "text": "* Preestablishment (Section 4.1.3) encompasses the Properties that an application can pass to describe its intent, requirements, prohibitions, and preferences for its networking operations. These Properties apply to multiple transport protocols, unless otherwise specified. Properties specified during preestablishment can have a large impact on the rest of the interface: they modify how establishment occurs, influence the expectations around data transfer, and determine the set of events that will be supported.",
      "ja": "* 準備（セクション4.1.3）には、アプリケーションが渡すことができるプロパティが含まれており、ネットワーキング操作の意図、要件、禁止、および好みを記述します。これらのプロパティは、特に指定されていない限り、複数の輸送プロトコルに適用されます。事前設定中に指定されたプロパティは、インターフェイスの残りの部分に大きな影響を与える可能性があります。確立がどのように発生するかを変更し、データ転送に関する期待に影響を与え、サポートされるイベントのセットを決定します。"
    },
    {
      "indent": 6,
      "text": "* Establishment (Section 4.1.4) focuses on the actions that an application takes on the Connection objects to prepare for data transfer.",
      "ja": "* 確立（セクション4.1.4）は、データ転送の準備のためにアプリケーションが接続オブジェクトにとるアクションに焦点を当てています。"
    },
    {
      "indent": 6,
      "text": "* Data transfer (Section 4.1.5) consists of how an application represents the data to be sent and received, the functions required to send and receive that data, and how the application is notified of the status of its data transfer.",
      "ja": "* データ転送（セクション4.1.5）は、アプリケーションが送信および受信するデータをどのように表しているか、そのデータの送信と受信に必要な機能、およびデータ転送のステータスについてアプリケーションに通知する方法で構成されています。"
    },
    {
      "indent": 6,
      "text": "* Event handling (Section 4.1.6) defines categories of notifications that an application can receive during the lifetime of a Connection. Events also provide opportunities for the application to interact with the underlying transport by querying state or updating maintenance options.",
      "ja": "* イベント処理（セクション4.1.6）では、接続の存続期間中にアプリケーションが受信できる通知のカテゴリを定義します。また、イベントは、状態を照会するか、メンテナンスオプションを更新することにより、アプリケーションが基礎となる輸送と対話する機会を提供します。"
    },
    {
      "indent": 6,
      "text": "* Termination (Section 4.1.7) focuses on the methods by which data transmission is stopped and connection state is torn down.",
      "ja": "* 終了（セクション4.1.7）は、データ送信が停止し、接続状態が取り壊される方法に焦点を当てています。"
    },
    {
      "indent": 3,
      "text": "The diagram below provides a high-level view of the actions and events during the lifetime of a Connection object. Note that some actions are alternatives (e.g., whether to initiate a connection or listen for incoming connections), while others are optional (e.g., setting Connection and Message Properties in preestablishment) or have been omitted for brevity and simplicity.",
      "ja": "以下の図は、接続オブジェクトの生涯のアクションとイベントの高レベルのビューを示しています。一部のアクションは、選択肢（接続を開始するか、着信を聞くか）である場合（たとえば、事前設定で接続とメッセージのプロパティを設定するなど）、または簡潔さと単純さのために省略されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "     Preestablishment     :       Established             : Termination\n    -----------------     :       -----------             : -----------\n                          :                               :\n+-- Local Endpoint        :           Message             :\n+-- Remote Endpoint       :    Receive() |                :\n+-- Transport Properties  :       Send() |                :\n+-- Security Parameters   :              |                :\n|                         :              |                :\n|               InitiateWithSend()       |        Close() :\n|   +---------------+   Initiate() +-----+------+ Abort() :\n+---+ Preconnection |------------->| Connection |-----------> Closed\n    +---------------+ Rendezvous() +------------+         :\n   Listen() |             :           |     |             :\n            |             :           |     v             :\n            v             :           | Connection        :\n    +----------+          :           |   Ready           :\n    | Listener |----------------------+                   :\n    +----------+  Connection Received                     :\n                          :                               :",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 4: The Lifetime of a Connection Object",
      "ja": "図4：接続オブジェクトの寿命"
    },
    {
      "indent": 3,
      "text": "In this diagram, the lifetime of a Connection object is divided into three phases: preestablishment, the Established state, and termination of a Connection.",
      "ja": "この図では、接続オブジェクトの寿命は3つのフェーズに分かれています。つまり、事前設定、確立された状態、接続の終了です。"
    },
    {
      "indent": 3,
      "text": "Preestablishment is based around a Preconnection object containing various sub-objects that describe the Properties and parameters of desired Connections (Local and Remote Endpoints, Transport Properties, and Security Parameters). A Preconnection can be used to start listening for inbound connections -- in which case a Listener object is created -- or can be used to establish a new connection directly using Initiate (for outbound connections) or Rendezvous (for peer-to-peer connections).",
      "ja": "摂取は、目的の接続のプロパティとパラメーター（ローカルおよびリモートエンドポイント、輸送プロパティ、セキュリティパラメーター）を記述するさまざまなサブオブジェクトを含む事前接続オブジェクトに基づいています。事前接続を使用して、インバウンド接続のリスニングを開始できます。この場合、リスナーオブジェクトが作成されます - または、initiate（アウトバウンド接続用）またはランデブー（ピアツーピア接続用のInitiateを使用して直接新しい接続を確立するために使用できます。）。"
    },
    {
      "indent": 3,
      "text": "Once a Connection is in the Established state, an application can send and receive Message objects and can receive state updates.",
      "ja": "接続が確立された状態になると、アプリケーションはメッセージオブジェクトを送信および受信し、状態の更新を受信できます。"
    },
    {
      "indent": 3,
      "text": "Closing or aborting a Connection, either locally or from the peer, can terminate a Connection.",
      "ja": "局所的またはピアからの接続の閉鎖または中止は、接続を終了する可能性があります。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Endpoint Objects",
      "section_title": true,
      "ja": "4.1.1. エンドポイントオブジェクト"
    },
    {
      "indent": 3,
      "text": "An Endpoint Identifier specifies one side of a transport connection. Endpoints can be Local Endpoints or Remote Endpoints, and the Endpoint Identifiers can respectively represent an identity that the application uses for the source or destination of a connection. An Endpoint Identifier can be specified at various levels of abstraction. An Endpoint Identifier at a higher level of abstraction (such as a hostname) can be resolved to more concrete identities (such as IP addresses). A Remote Endpoint Identifier can also represent a multicast group or anycast address. In the case of multicast, a multicast transport will be selected for communication.",
      "ja": "エンドポイント識別子は、輸送接続の片側を指定します。エンドポイントはローカルエンドポイントまたはリモートエンドポイントにすることができ、エンドポイント識別子はそれぞれアプリケーションが接続のソースまたは宛先に使用するIDを表すことができます。エンドポイント識別子は、さまざまなレベルの抽象化で指定できます。より高いレベルの抽象化（ホスト名など）のエンドポイント識別子は、より具体的なアイデンティティ（IPアドレスなど）に解決できます。リモートエンドポイント識別子は、マルチキャストグループまたはAnycastアドレスを表すこともできます。マルチキャストの場合、通信のためにマルチキャストトランスポートが選択されます。"
    },
    {
      "indent": 3,
      "text": "Remote Endpoint Identifier:",
      "ja": "リモートエンドポイント識別子："
    },
    {
      "indent": 12,
      "text": "The Remote Endpoint Identifier represents the application's identifier for a peer that can participate in a transport connection, for example, the combination of a DNS name for the peer and a service name/port.",
      "ja": "リモートエンドポイント識別子は、たとえば、ピアのDNS名とサービス名/ポートの組み合わせなど、トランスポート接続に参加できるピアのアプリケーションの識別子を表します。"
    },
    {
      "indent": 3,
      "text": "Local Endpoint Identifier:",
      "ja": "ローカルエンドポイント識別子："
    },
    {
      "indent": 12,
      "text": "The Local Endpoint Identifier represents the application's identifier for itself that it uses for transport connections, for example, a local IP address and port.",
      "ja": "ローカルエンドポイント識別子は、たとえばローカルIPアドレスとポートなど、トランスポート接続に使用するアプリケーションの識別子を表します。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Connections and Related Objects",
      "section_title": true,
      "ja": "4.1.2. 接続と関連するオブジェクト"
    },
    {
      "indent": 3,
      "text": "Connection:",
      "ja": "繋がり："
    },
    {
      "indent": 12,
      "text": "A Connection object represents one or more active transport protocol instances that can send and/or receive Messages between Local and Remote Endpoints. It is an abstraction that represents the communication. The Connection object holds state pertaining to the underlying transport protocol instances and any ongoing data transfers. For example, an active Connection can represent a connection-oriented protocol such as TCP, or it can represent a fully specified 5-tuple for a connectionless protocol such as UDP, where the Connection remains an abstraction at the endpoints. It can also represent a pool of transport protocol instances, e.g., a set of TCP and QUIC connections to equivalent endpoints, or a stream of a multistreaming transport protocol instance. Connections can be created from a Preconnection or by a Listener.",
      "ja": "接続オブジェクトは、ローカルエンドポイントとリモートエンドポイント間でメッセージを送信および/または受信できる1つまたは複数のアクティブトランスポートプロトコルインスタンスを表します。これは、コミュニケーションを表す抽象化です。接続オブジェクトは、基礎となる輸送プロトコルインスタンスと進行中のデータ転送に関する状態を保持します。たとえば、アクティブな接続は、TCPなどの接続指向のプロトコルを表すことができます。または、接続がエンドポイントで抽象化されたままであるUDPなどの接続のないプロトコルの完全に指定された5タプルを表すことができます。また、同等のエンドポイントへのTCPおよびQUIC接続のセット、またはマルチストリーミングトランスポートプロトコルインスタンスのストリームなどの輸送プロトコルインスタンスのプールを表すこともできます。接続は、前提条件またはリスナーによって作成できます。"
    },
    {
      "indent": 3,
      "text": "Preconnection:",
      "ja": "事前接続："
    },
    {
      "indent": 12,
      "text": "A Preconnection object is a representation of a Connection that has not yet been established. It has state that describes parameters of the Connection: the Local Endpoint Identifier from which that Connection will be established, the Remote Endpoint Identifier to which it will connect, and Transport Properties that influence the paths and protocols a Connection will use. A Preconnection can be either fully specified (representing a single possible Connection) or partially specified (representing a family of possible Connections). The Local Endpoint (Section 4.1.3) is required for a Preconnection used to Listen for incoming Connections but is optional if it is used to Initiate a Connection. The Remote Endpoint Identifier is required in a Preconnection that is used to Initiate a Connection but is optional if it is used to Listen for incoming Connections. The Local Endpoint Identifier and the Remote Endpoint Identifier are both required if a peer-to-peer Rendezvous is to occur based on the Preconnection.",
      "ja": "事前接続オブジェクトは、まだ確立されていない接続の表現です。接続のパラメーターを記述する状態：その接続が確立されるローカルエンドポイント識別子、接続するリモートエンドポイント識別子、および接続が使用するパスとプロトコルに影響を与えるプロパティを輸送します。事前接続は、完全に指定（単一の可能な接続を表す）または部分的に指定された（可能な接続のファミリーを表す）のいずれかを使用できます。ローカルエンドポイント（セクション4.1.3）は、着信接続をリッスンするために使用される事前接続に必要ですが、接続を開始するために使用される場合はオプションです。リモートエンドポイント識別子は、接続を開始するために使用されるが、着信接続をリッスンするために使用される場合はオプションである前提条件で必要です。ピアツーピアのランデブーが前接続に基づいて発生する場合、ローカルエンドポイント識別子とリモートエンドポイント識別子の両方が必要です。"
    },
    {
      "indent": 3,
      "text": "Transport Properties:",
      "ja": "輸送プロパティ："
    },
    {
      "indent": 12,
      "text": "Transport Properties allow the application to express requirements, prohibitions, and preferences and configure a Transport Services Implementation. There are three kinds of Transport Properties:",
      "ja": "トランスポートプロパティにより、アプリケーションは要件、禁止、好みを表現し、輸送サービスの実装を構成できます。輸送プロパティには3種類あります。"
    },
    {
      "indent": 6,
      "text": "Selection Properties (Section 4.1.3):",
      "ja": "選択プロパティ（セクション4.1.3）："
    },
    {
      "indent": 15,
      "text": "Selection Properties can only be specified on a Preconnection.",
      "ja": "選択プロパティは、事前接続でのみ指定できます。"
    },
    {
      "indent": 6,
      "text": "Connection Properties (Section 4.1.3):",
      "ja": "接続プロパティ（セクション4.1.3）："
    },
    {
      "indent": 15,
      "text": "Connection Properties can be specified on a Preconnection and changed on the Connection.",
      "ja": "接続プロパティは、事前接続で指定し、接続で変更できます。"
    },
    {
      "indent": 6,
      "text": "Message Properties (Section 4.1.5):",
      "ja": "メッセージプロパティ（セクション4.1.5）："
    },
    {
      "indent": 15,
      "text": "Message Properties can be specified as defaults on a Preconnection or a Connection and can also be specified during data transfer to affect specific Messages.",
      "ja": "メッセージプロパティは、事前接続または接続のデフォルトとして指定でき、データ転送中に特定のメッセージに影響を与えることもできます。"
    },
    {
      "indent": 3,
      "text": "Listener:",
      "ja": "リスナー："
    },
    {
      "indent": 12,
      "text": "A Listener object accepts incoming transport protocol connections from Remote Endpoints and generates corresponding Connection objects. It is created from a Preconnection object that specifies the type of incoming Connections it will accept.",
      "ja": "リスナーオブジェクトは、リモートエンドポイントからの着信輸送プロトコル接続を受け入れ、対応する接続オブジェクトを生成します。これは、受け入れる受信接続のタイプを指定する前提条件オブジェクトから作成されます。"
    },
    {
      "indent": 0,
      "text": "4.1.3. Preestablishment",
      "section_title": true,
      "ja": "4.1.3. 摂取"
    },
    {
      "indent": 3,
      "text": "Selection Properties:",
      "ja": "選択プロパティ："
    },
    {
      "indent": 12,
      "text": "Selection Properties consist of the Properties that an application can set to influence the selection of paths between the Local and Remote Endpoints, influence the selection of transport protocols, or configure the behavior of generic transport protocol features. These Properties can take the form of requirements, prohibitions, or preferences. Examples of Properties that influence path selection include the interface type (such as a Wi-Fi connection or a Cellular LTE connection), requirements around the largest Message that can be sent, or preferences for throughput and latency. Examples of Properties that influence protocol selection and configuration of transport protocol features include reliability, multipath support, and support for TCP Fast Open.",
      "ja": "選択プロパティは、アプリケーションがローカルエンドポイントとリモートエンドポイント間のパスの選択に影響を与えるように設定できるプロパティで構成され、輸送プロトコルの選択に影響を与える、または汎用輸送プロトコル機能の動作を構成します。これらのプロパティは、要件、禁止、または好みの形をとることができます。パス選択に影響を与えるプロパティの例には、インターフェイスタイプ（Wi-Fi接続またはセルラーLTE接続など）、送信できる最大のメッセージに関する要件、またはスループットとレイテンシの設定が含まれます。プロトコルの選択と輸送プロトコル機能の構成に影響を与えるプロパティの例には、信頼性、マルチパスサポート、TCP Fast Openのサポートが含まれます。"
    },
    {
      "indent": 3,
      "text": "Connection Properties:",
      "ja": "接続プロパティ："
    },
    {
      "indent": 12,
      "text": "Connection Properties are used to configure protocol-specific options and control per-connection behavior of a Transport Services Implementation; for example, a protocol-specific Connection Property can express that if TCP is used, the implementation ought to use the User Timeout Option. Note that the presence of such a property does not require that a specific protocol be used. In general, these Properties do not explicitly determine the selection of paths or protocols but can be used by an implementation during Connection establishment. Connection Properties are specified on a Preconnection prior to Connection establishment and can be modified on the Connection later. Changes made to Connection Properties after Connection establishment take effect on a best-effort basis.",
      "ja": "接続プロパティは、プロトコル固有のオプションを構成し、輸送サービスの実装の接続ごとの動作を制御するために使用されます。たとえば、プロトコル固有の接続プロパティは、TCPが使用されている場合、実装はユーザータイムアウトオプションを使用する必要があることを表現できます。そのようなプロパティの存在は、特定のプロトコルを使用する必要はないことに注意してください。一般に、これらのプロパティは、パスまたはプロトコルの選択を明示的に決定するものではなく、接続確立中の実装によって使用できます。接続プロパティは、接続確立前の事前接続で指定されており、後で接続で変更できます。接続確立後に接続プロパティに加えられた変更は、最良のエフォルトベースで有効になります。"
    },
    {
      "indent": 3,
      "text": "Security Parameters:",
      "ja": "セキュリティパラメーター："
    },
    {
      "indent": 12,
      "text": "Security Parameters define an application's requirements for authentication and encryption on a Connection. They are used by transport security protocols (such as those described in [RFC8922]) to establish secure Connections. Examples of parameters that can be set include local identities, private keys, supported cryptographic algorithms, and requirements for validating trust of remote identities. Security Parameters are primarily associated with a Preconnection object, but Properties related to identities can be associated directly with Endpoints.",
      "ja": "セキュリティパラメータは、接続上の認証と暗号化に関するアプリケーションの要件を定義します。これらは、安全な接続を確立するために、トランスポートセキュリティプロトコル（[RFC8922]に記載されているものなど）によって使用されます。設定できるパラメーターの例には、ローカルアイデンティティ、プライベートキー、サポートされている暗号化アルゴリズム、およびリモートIDの信頼を検証するための要件が含まれます。セキュリティパラメーターは主に事前接続オブジェクトに関連付けられていますが、アイデンティティに関連するプロパティは、エンドポイントに直接関連付けることができます。"
    },
    {
      "indent": 0,
      "text": "4.1.4. Establishment Actions",
      "section_title": true,
      "ja": "4.1.4. 確立行動"
    },
    {
      "indent": 3,
      "text": "Initiate:",
      "ja": "開始する："
    },
    {
      "indent": 12,
      "text": "The primary action that an application can take to create a Connection to a Remote Endpoint and prepare any required local or remote state to enable the transmission of Messages. For some protocols, this will initiate a client-to-server-style handshake; for other protocols, this will just establish local state (e.g., with connectionless protocols such as UDP). The process of identifying options for connecting, such as resolution of the Remote Endpoint Identifier, occurs in response to calling Initiate.",
      "ja": "アプリケーションがリモートエンドポイントへの接続を作成し、メッセージの送信を有効にするために必要なローカルまたはリモート状態を準備するために取ることができる主要なアクション。一部のプロトコルでは、これによりクライアントからサーバーへのハンドシェイクが開始されます。他のプロトコルの場合、これはローカル状態を確立するだけです（たとえば、UDPなどのコネクションレスプロトコルを使用）。リモートエンドポイント識別子の解像度など、接続のオプションを識別するプロセスは、呼び出しが開始に応じて発生します。"
    },
    {
      "indent": 3,
      "text": "Listen:",
      "ja": "聞く："
    },
    {
      "indent": 12,
      "text": "Enables a Listener to accept incoming connections. The Listener will then create Connection objects as incoming connections are accepted (Section 4.1.6). Listeners by default register with multiple paths, protocols, and Local Endpoints, unless constrained by Selection Properties and/or the specified Local Endpoint Identifier(s). Connections can be accepted on any of the available paths or endpoints.",
      "ja": "リスナーが着信接続を受け入れることができます。リスナーは、着信接続が受け入れられると、接続オブジェクトを作成します（セクション4.1.6）。リスナーは、選択プロパティおよび/または指定されたローカルエンドポイント識別子によって制約されていない限り、複数のパス、プロトコル、およびローカルエンドポイントで登録します。使用可能なパスまたはエンドポイントのいずれかで接続を受け入れることができます。"
    },
    {
      "indent": 3,
      "text": "Rendezvous:",
      "ja": "rendezvous："
    },
    {
      "indent": 12,
      "text": "The action of establishing a peer-to-peer connection with a Remote Endpoint. It simultaneously attempts to initiate a connection to a Remote Endpoint while listening for an incoming connection from that Endpoint. The process of identifying options for the connection, such as resolution of the Remote Endpoint Identifier(s), occurs in response to calling Rendezvous. As with Listeners, the set of local paths and endpoints is constrained by Selection Properties. If successful, calling Rendezvous generates and asynchronously returns a Connection object to represent the established peer-to-peer connection. The processes by which connections are initiated during a Rendezvous action will depend on the set of Local and Remote Endpoints configured on the Preconnection. For example, if the Local and Remote Endpoints are TCP host candidates, then a TCP simultaneous open [RFC9293] might be performed. However, if the set of Local Endpoints includes server-reflexive candidates, such as those provided by STUN (Session Traversal Utilities for NAT) [RFC8489], a Rendezvous action will race candidates in the style of the ICE (Interactive Connectivity Establishment) algorithm [RFC8445] to perform NAT binding discovery and initiate a peer-to-peer connection.",
      "ja": "リモートエンドポイントとピアツーピア接続を確立するアクション。同時に、そのエンドポイントから着信接続を聞きながら、リモートエンドポイントへの接続を開始しようとします。リモートエンドポイント識別子の解像度など、接続のオプションを識別するプロセスは、rendezvousの呼び出しに応じて発生します。リスナーと同様に、ローカルパスとエンドポイントのセットは、選択プロパティによって制約されます。成功した場合、rendezvousを呼び出すと、接続オブジェクトを生成し、非同期に戻して、確立されたピアツーピア接続を表します。ランデブーアクション中に接続が開始されるプロセスは、事前接続で構成されたローカルエンドポイントとリモートエンドポイントのセットに依存します。たとえば、ローカルエンドポイントとリモートエンドポイントがTCPホスト候補である場合、TCP同時オープン[RFC9293]が実行される可能性があります。ただし、ローカルエンドポイントのセットに、Stun（NATのセッショントラバーサルユーティリティ）[RFC8489]によって提供されるようなサーバー反射候補が含まれている場合、ランデブーアクションは、氷（インタラクティブ接続確立）アルゴリズムのスタイルで候補者を競います[RFC8445] NAT結合発見を実行し、ピアツーピア接続を開始します。"
    },
    {
      "indent": 0,
      "text": "4.1.5. Data Transfer Objects and Actions",
      "section_title": true,
      "ja": "4.1.5. データ転送オブジェクトとアクション"
    },
    {
      "indent": 3,
      "text": "Message:",
      "ja": "メッセージ："
    },
    {
      "indent": 12,
      "text": "A Message object is a unit of data that can be represented as bytes that can be transferred between two endpoints over a transport connection. The bytes within a Message are assumed to be ordered. If an application does not care about the order in which a peer receives two distinct spans of bytes, those spans of bytes are considered independent Messages. Messages are sent in the payload of IP packets. One packet can carry one or more Messages or parts of a Message.",
      "ja": "メッセージオブジェクトは、トランスポート接続を介して2つのエンドポイント間で転送できるバイトとして表すことができるデータの単位です。メッセージ内のバイトは注文されると想定されます。アプリケーションが、ピアが2つの異なるバイトスパンを受け取る順序を気にしない場合、それらのバイトスパンは独立したメッセージと見なされます。メッセージは、IPパケットのペイロードで送信されます。1つのパケットは、1つまたは複数のメッセージまたはメッセージの一部を運ぶことができます。"
    },
    {
      "indent": 3,
      "text": "Message Properties:",
      "ja": "メッセージプロパティ："
    },
    {
      "indent": 12,
      "text": "Message Properties are used to specify details about Message transmission. They can be specified directly on individual Messages or can be set on a Preconnection or Connection as defaults. These Properties might only apply to how a Message is sent (such as how the transport will treat prioritization and reliability) but can also include Properties that specific protocols encode and communicate to the Remote Endpoint. When receiving Messages, Message Properties can contain information about the received Message, such as metadata generated at the receiver and information signaled by the Remote Endpoint. For example, a Message can be marked with a Message Property indicating that it is the final Message on a Connection.",
      "ja": "メッセージプロパティは、メッセージ伝送に関する詳細を指定するために使用されます。個々のメッセージで直接指定することも、デフォルトとして事前接続または接続で設定することもできます。これらのプロパティは、メッセージの送信方法（トランスポートが優先順位付けと信頼性をどのように扱うかなど）にのみ適用される場合がありますが、特定のプロトコルがエンコードしてリモートエンドポイントに通信するプロパティを含めることもできます。メッセージを受信するとき、メッセージプロパティには、受信したメッセージに関する情報を含めることができます。たとえば、レシーバーで生成されたメタデータや、リモートエンドポイントで合図された情報が含まれます。たとえば、メッセージは、接続の最終メッセージであることを示すメッセージプロパティでマークできます。"
    },
    {
      "indent": 3,
      "text": "Send:",
      "ja": "送信："
    },
    {
      "indent": 12,
      "text": "The Send action transmits a Message over a Connection to the Remote Endpoint. The interface to Send can accept Message Properties specific to how the Message content is to be sent. The status of the Send action is delivered back to the sending application in an event (Section 4.1.6).",
      "ja": "送信アクションは、リモートエンドポイントへの接続を介してメッセージを送信します。送信するインターフェイスは、メッセージコンテンツの送信方法に固有のメッセージプロパティを受け入れることができます。送信アクションのステータスは、イベント（セクション4.1.6）で送信アプリケーションに返信されます。"
    },
    {
      "indent": 3,
      "text": "Receive:",
      "ja": "受け取る："
    },
    {
      "indent": 12,
      "text": "The Receive action indicates that the application is ready to asynchronously accept a Message over a Connection from a Remote Endpoint, while the Message content itself will be delivered in an event (Section 4.1.6). The interface to Receive can include Message Properties specific to the Message that is to be delivered to the application.",
      "ja": "受信アクションは、アプリケーションがリモートエンドポイントからの接続を介したメッセージを非同期的に受け入れる準備ができていることを示し、メッセージコンテンツ自体はイベントで配信されます（セクション4.1.6）。受信するインターフェイスには、アプリケーションに配信されるメッセージに固有のメッセージプロパティを含めることができます。"
    },
    {
      "indent": 3,
      "text": "Framer:",
      "ja": "フレーマ："
    },
    {
      "indent": 12,
      "text": "A Framer is a data translation layer that can be added to a Connection. Framers allow extending a Connection's Protocol Stack to define how to encapsulate or encode outbound Messages and how to decapsulate or decode inbound data into Messages. In this way, Message boundaries can be preserved when using a Connection object, even with a protocol that otherwise presents unstructured streams, such as TCP. This is designed based on the fact that many of the current application protocols evolved over TCP, which does not provide Message boundary preservation, and since many of these protocols require Message boundaries to function, each application-layer protocol has defined its own framing. For example, when an HTTP application sends and receives HTTP Messages over a byte-stream transport, it must parse the boundaries of HTTP Messages from the stream of bytes.",
      "ja": "フレーマーは、接続に追加できるデータ変換レイヤーです。フレーマーは、接続のプロトコルスタックを拡張して、アウトバウンドメッセージをカプセル化またはエンコードする方法と、インバウンドデータをメッセージに脱カプセル化またはデコードする方法を定義できます。このようにして、TCPなどの非構造化されたストリームを提示するプロトコルを使用しても、接続オブジェクトを使用する場合、メッセージの境界を保存できます。これは、現在のアプリケーションプロトコルの多くがTCPを介して進化したという事実に基づいて設計されており、メッセージの境界保存を提供しません。これらのプロトコルの多くは、メッセージ境界を機能させる必要があるため、各アプリケーション層プロトコルは独自のフレーミングを定義しています。たとえば、HTTPアプリケーションがバイトストリームトランスポートを介してHTTPメッセージを送信および受信する場合、バイトのストリームからHTTPメッセージの境界を解析する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.1.6. Event Handling",
      "section_title": true,
      "ja": "4.1.6. イベント処理"
    },
    {
      "indent": 3,
      "text": "The following categories of events can be delivered to an application:",
      "ja": "次のカテゴリのイベントは、アプリケーションに配信できます。"
    },
    {
      "indent": 3,
      "text": "Connection Ready:",
      "ja": "接続準備："
    },
    {
      "indent": 12,
      "text": "Signals to an application that a given Connection is ready to send and/or receive Messages. If the Connection relies on handshakes to establish state between peers, then it is assumed that these steps have been taken.",
      "ja": "特定の接続がメッセージを送信および/または受信する準備ができているというアプリケーションへの信号。接続がハンドシェイクに依存してピア間の状態を確立する場合、これらの手順が実行されたと想定されます。"
    },
    {
      "indent": 3,
      "text": "Connection Closed:",
      "ja": "接続閉じ："
    },
    {
      "indent": 12,
      "text": "Signals to an application that a given Connection is no longer usable for sending or receiving Messages. The event delivers a reason or error to the application that describes the nature of the termination.",
      "ja": "特定の接続がメッセージの送信または受信に使用できなくなったというアプリケーションへの信号。このイベントは、終了の性質を説明するアプリケーションに理由またはエラーを提供します。"
    },
    {
      "indent": 3,
      "text": "Connection Received:",
      "ja": "受信した接続："
    },
    {
      "indent": 12,
      "text": "Signals to an application that a given Listener has received a Connection.",
      "ja": "特定のリスナーが接続を受信したというアプリケーションへの信号。"
    },
    {
      "indent": 3,
      "text": "Message Received:",
      "ja": "受信したメッセージ："
    },
    {
      "indent": 12,
      "text": "Delivers received Message content to the application, based on a Receive action. To allow an application to limit the occurrence of such events, each call to Receive will be paired with a single Receive event. This can include an error if the Receive action cannot be satisfied, e.g., due to the Connection being closed.",
      "ja": "受信アクションに基づいて、受信したメッセージコンテンツをアプリケーションに配信します。アプリケーションがそのようなイベントの発生を制限できるようにするために、受信する各呼び出しは単一の受信イベントとペアになります。これには、接続が閉じられているため、受信アクションが満たされない場合のエラーが含まれます。"
    },
    {
      "indent": 3,
      "text": "Message Sent:",
      "ja": "送信されたメッセージ："
    },
    {
      "indent": 12,
      "text": "Notifies the application of the status of its Send action. This might indicate a failure if the Message cannot be sent or might indicate that the Message has been processed by the Transport Services System.",
      "ja": "送信アクションのステータスの適用に通知します。これは、メッセージを送信できない場合に障害を示したり、メッセージが輸送サービスシステムによって処理されていることを示したりする可能性があります。"
    },
    {
      "indent": 3,
      "text": "Path Properties Changed:",
      "ja": "パスプロパティが変更されました："
    },
    {
      "indent": 12,
      "text": "Notifies the application that a Property of the Connection has changed that might influence how and where data is sent and/or received.",
      "ja": "データが送信および/または受信される方法と場所に影響を与える可能性のある接続のプロパティが変更されたというアプリケーションに通知します。"
    },
    {
      "indent": 0,
      "text": "4.1.7. Termination Actions",
      "section_title": true,
      "ja": "4.1.7. 終了アクション"
    },
    {
      "indent": 3,
      "text": "Close:",
      "ja": "近い："
    },
    {
      "indent": 12,
      "text": "The action an application takes on a Connection to indicate that it no longer intends to send data or is no longer willing to receive data. The protocol should signal this state to the Remote Endpoint if the transport protocol permits it. (Note that this is distinct from the concept of \"half-closing\" a bidirectional connection, such as when a FIN is sent in one direction of a TCP connection [RFC9293]. The end of a stream can also be indicated using Message Properties when sending.)",
      "ja": "アプリケーションが接続を取り、データを送信するつもりがなく、データを受信する意思がないことを示すために接続を行います。トランスポートプロトコルが許可する場合、プロトコルはこの状態をリモートエンドポイントに信号する必要があります。（これは、FINがTCP接続の一方向に送信される場合など、「半分閉鎖」の双方向接続の概念とは異なることに注意してください。送信。）"
    },
    {
      "indent": 3,
      "text": "Abort:",
      "ja": "アボート："
    },
    {
      "indent": 12,
      "text": "The action the application takes on a Connection to indicate that the Transport Services System should not attempt to deliver any outstanding data and that it should immediately close and drop the connection. This is intended for immediate, usually abnormal, termination of a connection.",
      "ja": "アプリケーションが接続を取り、トランスポートサービスシステムが未解決のデータを提供しようとしないことを示し、すぐに接続を閉じてドロップする必要があることを示します。これは、接続の即時、通常異常な終了を目的としています。"
    },
    {
      "indent": 0,
      "text": "4.1.8. Connection Groups",
      "section_title": true,
      "ja": "4.1.8. 接続グループ"
    },
    {
      "indent": 3,
      "text": "A Connection Group is a set of Connections that shares Connection Properties and Cached State generated by protocols. A Connection Group represents state for managing Connections within a single application and does not require end-to-end protocol signaling. For transport protocols that support multiplexing, only Connections within the same Connection Group are allowed to be multiplexed together.",
      "ja": "接続グループは、接続プロパティとプロトコルによって生成されるキャッシュ状態を共有する一連の接続です。接続グループは、単一のアプリケーション内で接続を管理するための状態を表し、エンドツーエンドのプロトコルシグナル伝達を必要としません。多重化をサポートする輸送プロトコルの場合、同じ接続グループ内の接続のみを一緒に多重化することができます。"
    },
    {
      "indent": 3,
      "text": "The API allows a Connection to be created from another Connection. This adds the new Connection to the Connection Group. A change to one of the Connection Properties on any Connection in the Connection Group automatically changes the Connection Property for all others. All Connections in a Connection Group share the same set of Connection Properties except for the Connection Priority. These Connection Properties are said to be entangled.",
      "ja": "APIを使用すると、別の接続から接続を作成できます。これにより、接続グループに新しい接続が追加されます。接続グループ内の接続の任意の接続プロパティの1つに変更すると、他のすべての接続プロパティが自動的に変更されます。接続グループ内のすべての接続は、接続の優先度を除き、接続プロパティの同じセットを共有します。これらの接続プロパティは絡み合っていると言われています。"
    },
    {
      "indent": 3,
      "text": "Passive Connections can also be added to a Connection Group, e.g., when a Listener receives a new Connection that is just a new stream of an already-active multistreaming protocol instance.",
      "ja": "パッシブ接続は、リスナーが既に活動的なマルチストリーミングプロトコルインスタンスの新しいストリームである新しい接続を受信する場合、接続グループに追加することもできます。"
    },
    {
      "indent": 3,
      "text": "While Connection Groups are managed by the Transport Services Implementation, an application can define different Connection Contexts for different Connection Groups to explicitly control caching boundaries, as discussed in Section 4.2.3.",
      "ja": "接続グループはトランスポートサービスの実装によって管理されていますが、アプリケーションは、セクション4.2.3で説明したように、キャッシュ境界を明示的に制御するために、異なる接続グループの異なる接続コンテキストを定義できます。"
    },
    {
      "indent": 0,
      "text": "4.2. Transport Services Implementation",
      "section_title": true,
      "ja": "4.2. 輸送サービスの実装"
    },
    {
      "indent": 3,
      "text": "This section defines the key architectural concepts for the Transport Services Implementation within the Transport Services System.",
      "ja": "このセクションでは、トランスポートサービスシステム内の輸送サービスの実装に関する重要なアーキテクチャの概念を定義します。"
    },
    {
      "indent": 3,
      "text": "The Transport Services System consists of the Transport Services Implementation and the Transport Services API. The Transport Services Implementation consists of all objects and protocol instances used internally to a system or library to implement the functionality needed to provide a transport service across a network, as required by the abstract interface.",
      "ja": "輸送サービスシステムは、輸送サービスの実装と輸送サービスAPIで構成されています。Transport Servicesの実装は、抽象インターフェイスで要求されるように、ネットワーク全体でトランスポートサービスを提供するために必要な機能を実装するために、システムまたはライブラリに内部的に使用されるすべてのオブジェクトとプロトコルインスタンスで構成されています。"
    },
    {
      "indent": 3,
      "text": "Path:",
      "ja": "パス："
    },
    {
      "indent": 12,
      "text": "Represents an available set of Properties that a Local Endpoint can use to communicate with a Remote Endpoint, such as routes, addresses, and physical and virtual network interfaces.",
      "ja": "ローカルエンドポイントが、ルート、アドレス、物理および仮想ネットワークインターフェイスなどのリモートエンドポイントと通信するために使用できるプロパティの利用可能なセットを表します。"
    },
    {
      "indent": 3,
      "text": "Protocol Instance:",
      "ja": "プロトコルインスタンス："
    },
    {
      "indent": 12,
      "text": "A single instance of one protocol, including any state necessary to establish connectivity or send and receive Messages.",
      "ja": "接続を確立したり、メッセージを送信および受信したりするために必要な状態を含む、1つのプロトコルの単一インスタンス。"
    },
    {
      "indent": 3,
      "text": "Protocol Stack:",
      "ja": "プロトコルスタック："
    },
    {
      "indent": 12,
      "text": "A set of protocol instances (including relevant application, security, transport, or Internet protocols) that are used together to establish connectivity or send and receive Messages. A single stack can be simple (e.g., one application stream carried over TCP running over IP) or complex (e.g,. multiple application streams carried over a multipath transport protocol using multiple subflows over IP).",
      "ja": "接続性を確立したり、メッセージを送信および受信したりするために一緒に使用される一連のプロトコルインスタンス（関連するアプリケーション、セキュリティ、トランスポート、またはインターネットプロトコルを含む）。単一のスタックは、単純な場合（例：IPを介して実行されているTCPを介して1つのアプリケーションストリーム）または複雑なもの（例えば、複数のアプリケーションストリームがIPを介して複数のサブフローを使用してマルチパストランスポートプロトコルを掲載した）を運ぶ）にすることができます。"
    },
    {
      "indent": 3,
      "text": "Candidate Path:",
      "ja": "候補パス："
    },
    {
      "indent": 12,
      "text": "One path that is available to an application and conforms to the Selection Properties and System Policy, of which there can be several. Candidate Paths are identified during the gathering phase (Section 4.2.1) and can be used during the racing phase (Section 4.2.2).",
      "ja": "アプリケーションで利用可能で、選択プロパティとシステムポリシーに準拠する1つのパスがあります。候補パスは収集段階（セクション4.2.1）で特定され、レースフェーズ（セクション4.2.2）で使用できます。"
    },
    {
      "indent": 3,
      "text": "Candidate Protocol Stack:",
      "ja": "候補プロトコルスタック："
    },
    {
      "indent": 12,
      "text": "One Protocol Stack that can be used by an application for a connection, for which there can be several candidates. Candidate Protocol Stacks are identified during the gathering phase (Section 4.2.1) and are started during the racing phase (Section 4.2.2).",
      "ja": "接続のアプリケーションで使用できる1つのプロトコルスタックで、複数の候補者がいる場合があります。候補プロトコルスタックは、収集段階（セクション4.2.1）で特定され、レースフェーズ（セクション4.2.2）で開始されます。"
    },
    {
      "indent": 3,
      "text": "System Policy:",
      "ja": "システムポリシー："
    },
    {
      "indent": 12,
      "text": "The input from an operating system or other global preferences that can constrain or influence how an implementation will gather Candidate Paths and Candidate Protocol Stacks (Section 4.2.1) and race the candidates during establishment (Section 4.2.2). Specific aspects of the System Policy apply to either all Connections or only certain Connections, depending on the runtime context and Properties of the Connection.",
      "ja": "オペレーティングシステムまたはその他のグローバル設定からの入力は、実装が候補パスと候補のプロトコルスタック（セクション4.2.1）を収集する方法を制約または影響を与え、施設中に候補者を競います（セクション4.2.2）。システムポリシーの特定の側面は、ランタイムコンテキストと接続のプロパティに応じて、すべての接続または特定の接続のみに適用されます。"
    },
    {
      "indent": 3,
      "text": "Cached State:",
      "ja": "キャッシュ状態："
    },
    {
      "indent": 12,
      "text": "The state and history that the implementation keeps for each set of associated Endpoints that have been used previously. This can include DNS results, TLS session state, previous success and quality of transport protocols over certain paths, as well as other information. This caching does not imply that the same decisions are necessarily made for subsequent connections; rather, it means that Cached State is used by a Transport Services Implementation to inform functions such as choosing the candidates to be raced, selecting appropriate transport parameters, etc. An application SHOULD NOT rely on specific caching behavior; instead, it ought to explicitly request any required or preferred Properties via the Transport Services API.",
      "ja": "以前に使用されていた関連するエンドポイントの各セットに対して実装が保持する状態と歴史。これには、DNSの結果、TLSセッション状態、以前の成功と特定のパスでの輸送プロトコルの質、およびその他の情報が含まれます。このキャッシングは、同じ決定がその後の接続に対して必ずしも行われることを意味するものではありません。むしろ、キャッシュ状態は、輸送サービスの実装によって使用され、候補者を選択する候補者の選択、適切な輸送パラメーターを選択するなどの機能を通知することを意味します。アプリケーションは、特定のキャッシュ動作に依存してはなりません。代わりに、トランスポートサービスAPIを介して必要なまたは優先プロパティを明示的に要求する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Candidate Gathering",
      "section_title": true,
      "ja": "4.2.1. 候補者の集まり"
    },
    {
      "indent": 3,
      "text": "Candidate Path Selection:",
      "ja": "候補パス選択："
    },
    {
      "indent": 12,
      "text": "Candidate Path Selection represents the act of choosing one or more paths that are available to use based on the Selection Properties and any available Local and Remote Endpoint Identifiers provided by the application, as well as the policies and heuristics of a Transport Services Implementation.",
      "ja": "候補パス選択は、選択プロパティと、アプリケーションが提供する使用可能なローカルおよびリモートエンドポイント識別子、および輸送サービスの実装のポリシーとヒューリスティックに基づいて使用できる1つ以上のパスを選択する行為を表します。"
    },
    {
      "indent": 3,
      "text": "Candidate Protocol Selection:",
      "ja": "候補プロトコルの選択："
    },
    {
      "indent": 12,
      "text": "Candidate Protocol Selection represents the act of choosing one or more sets of Protocol Stacks that are available to use based on the Transport Properties provided by the application, and the heuristics or policies within the Transport Services Implementation.",
      "ja": "候補プロトコルの選択は、アプリケーションが提供する輸送プロパティ、および輸送サービスの実装内のヒューリスティックまたはポリシーに基づいて使用できるプロトコルスタックの1つ以上を選択する行為を表します。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Candidate Racing",
      "section_title": true,
      "ja": "4.2.2. 候補者レース"
    },
    {
      "indent": 3,
      "text": "Connection establishment attempts for a set of candidates may be performed simultaneously, synchronously, serially, or using some combination of all of these. We refer to this process as racing, borrowing terminology from Happy Eyeballs [RFC8305].",
      "ja": "一連の候補者の接続確立の試みは、同時に、同期、連続的に、またはこれらすべての何らかの組み合わせを使用することができます。このプロセスをレースと呼び、ハッピーアイボールから用語を借用します[RFC8305]。"
    },
    {
      "indent": 3,
      "text": "Protocol Option Racing:",
      "ja": "プロトコルオプションレース："
    },
    {
      "indent": 12,
      "text": "Protocol Option Racing is the act of attempting to establish, or scheduling attempts to establish, multiple Protocol Stacks that differ based on the composition of protocols or the options used for protocols.",
      "ja": "プロトコルオプションレースは、プロトコルの構成またはプロトコルに使用されるオプションに基づいて異なる複数のプロトコルスタックを確立または確立しようとする試みを試みる、またはスケジューリングする行為です。"
    },
    {
      "indent": 3,
      "text": "Path Racing:",
      "ja": "パスレース："
    },
    {
      "indent": 12,
      "text": "Path Racing is the act of attempting to establish, or scheduling attempts to establish, multiple Protocol Stacks that differ based on a selection from the available paths. Since different paths will have distinct configurations (see [RFC7556]) for local addresses and DNS servers, attempts across different paths will perform separate DNS resolution steps, which can lead to further racing of the resolved Remote Endpoint Identifiers.",
      "ja": "パスレースは、利用可能なパスからの選択に基づいて異なる複数のプロトコルスタックを確立または確立しようとする試みを試みる、またはスケジューリングする行為です。異なるパスには、ローカルアドレスとDNSサーバーに対して異なる構成（[RFC7556]を参照）があるため、異なるパスを越えて試行が個別のDNS解像度ステップを実行し、解決されたリモートエンドポイント識別子のさらなるレースにつながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Remote Endpoint Racing:",
      "ja": "リモートエンドポイントレース："
    },
    {
      "indent": 12,
      "text": "Remote Endpoint Racing is the act of attempting to establish, or scheduling attempts to establish, multiple Protocol Stacks that differ based on the specific representation of the Remote Endpoint Identifier, such as a particular IP address that was resolved from a DNS hostname.",
      "ja": "リモートエンドポイントレースとは、DNSホスト名から解決された特定のIPアドレスなど、リモートエンドポイント識別子の特定の表現に基づいて異なる複数のプロトコルスタックを確立または確立しようとする試みを試みる行為です。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Separating Connection Contexts",
      "section_title": true,
      "ja": "4.2.3. 接続コンテキストの分離"
    },
    {
      "indent": 3,
      "text": "A Transport Services Implementation can by default share stored Properties across Connections within an application, such as cached protocol state, cached path state, and heuristics. This provides efficiency and convenience for the application, since the Transport Services System can automatically optimize behavior.",
      "ja": "トランスポートサービスの実装は、デフォルトでは、キャッシュされたプロトコル状態、キャッシュパス状態、ヒューリスティックなど、アプリケーション内の接続全体で保存されたプロパティを共有できます。これにより、輸送サービスシステムは動作を自動的に最適化できるため、アプリケーションに効率と利便性が提供されます。"
    },
    {
      "indent": 3,
      "text": "The Transport Services API can allow applications to explicitly define Connection Contexts that force separation of Cached State and Protocol Stacks. For example, a web browser application could use Connection Contexts with separate caches when implementing different tabs. Possible reasons to isolate Connections using separate Connection Contexts include privacy concerns regarding:",
      "ja": "Transport Services APIにより、アプリケーションは、キャッシュされた状態およびプロトコルスタックの分離を強制する接続コンテキストを明示的に定義できます。たとえば、Webブラウザーアプリケーションは、異なるタブを実装するときに、個別のキャッシュを持つ接続コンテキストを使用できます。個別の接続コンテキストを使用して接続を分離する可能性のある理由には、次のようなプライバシーの懸念が含まれます。"
    },
    {
      "indent": 6,
      "text": "* reusing cached protocol state, as this can lead to linkability. Sensitive state could include TLS session state [RFC8446] and HTTP cookies [RFC6265]. These concerns could be addressed using Connection Contexts with separate caches, such as for different browser tabs.",
      "ja": "* キャッシュされたプロトコル状態を再利用します。これは、リンク可能性につながる可能性があるためです。敏感な状態には、TLSセッション状態[RFC8446]およびHTTP Cookie [RFC6265]が含まれます。これらの懸念は、異なるブラウザタブなど、個別のキャッシュを持つ接続コンテキストを使用して対処できます。"
    },
    {
      "indent": 6,
      "text": "* allowing Connections to multiplex together, which can tell a Remote Endpoint that all of the Connections are coming from the same application. Using Connection Contexts avoids the Connections being multiplexed in an HTTP/2 or QUIC stream.",
      "ja": "* 接続がマルチプレックスを組み合わせることで、すべての接続が同じアプリケーションから来ていることをリモートエンドポイントに伝えることができます。接続コンテキストを使用すると、接続がHTTP/2またはQUICストリームで多重化されていません。"
    },
    {
      "indent": 0,
      "text": "5. IANA Considerations",
      "section_title": true,
      "ja": "5. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "このドキュメントにはIANAアクションがありません。"
    },
    {
      "indent": 0,
      "text": "6. Security and Privacy Considerations",
      "section_title": true,
      "ja": "6. セキュリティとプライバシーの考慮事項"
    },
    {
      "indent": 3,
      "text": "The Transport Services System does not recommend the use of specific security protocols or algorithms. Its goal is to offer ease of use for existing protocols by providing a generic security-related interface. Each provided interface translates to an existing protocol-specific interface provided by supported security protocols. For example, trust verification callbacks are common parts of TLS APIs; a Transport Services API exposes similar functionality [RFC8922].",
      "ja": "トランスポートサービスシステムでは、特定のセキュリティプロトコルまたはアルゴリズムの使用を推奨していません。その目標は、一般的なセキュリティ関連のインターフェイスを提供することにより、既存のプロトコルの使いやすさを提供することです。提供された各インターフェイスは、サポートされているセキュリティプロトコルによって提供される既存のプロトコル固有のインターフェイスに変換されます。たとえば、信頼検証コールバックはTLS APIの一般的な部分です。トランスポートサービスAPIは、同様の機能を公開します[RFC8922]。"
    },
    {
      "indent": 3,
      "text": "As described above in Section 3.3, if a Transport Services Implementation races between two different Protocol Stacks, both need to use the same security protocols and options. However, a Transport Services Implementation can race different security protocols, e.g., if the application explicitly specifies that it considers them equivalent.",
      "ja": "上記のセクション3.3で説明したように、トランスポートサービスの実装が2つの異なるプロトコルスタック間で競い合っている場合、どちらも同じセキュリティプロトコルとオプションを使用する必要があります。ただし、輸送サービスの実装は、アプリケーションがそれらを同等と見なすことを明示的に指定した場合、異なるセキュリティプロトコルを競うことができます。"
    },
    {
      "indent": 3,
      "text": "The application controls whether information from previous racing attempts or other information about past communications that was cached by the Transport Services System is used during establishment. This allows applications to make trade-offs between efficiency (through racing) and privacy (via information that might leak from the cache toward an on-path observer). Some applications have features (e.g., \"incognito mode\") that align with this functionality.",
      "ja": "アプリケーションは、輸送サービスシステムによってキャッシュされた過去の通信に関する以前のレースの試みからの情報または施設中に使用されるかどうかを制御します。これにより、アプリケーションは効率性（レースを通じて）とプライバシーの間にトレードオフを行うことができます（キャッシュからパスオンパスオブザーバーに漏れる可能性のある情報を介して）。一部のアプリケーションには、この機能に合わせた機能（「Incognito Mode」など）があります。"
    },
    {
      "indent": 3,
      "text": "Applications need to ensure that they use security APIs appropriately. In cases where applications use an interface to provide sensitive keying material, e.g., access to private keys or copies of pre-shared keys (PSKs), key use needs to be validated and scoped to the intended protocols and roles. For example, if an application provides a certificate to only be used as client authentication for outbound TLS and QUIC connections, the Transport Services System MUST NOT use this automatically in other contexts (such as server authentication for inbound connections or in other security protocol handshakes that are not equivalent to TLS).",
      "ja": "アプリケーションは、セキュリティAPIを適切に使用することを確認する必要があります。アプリケーションがインターフェイスを使用して、敏感なキーイング素材、たとえば、プライベートキーや事前共有キー（PSK）のコピーへのアクセスを提供する場合、キー使用を検証し、意図したプロトコルと役割に監視する必要があります。たとえば、アプリケーションがアウトバウンドTLSおよびQUIC接続のクライアント認証としてのみ使用する証明書を提供する場合、トランスポートサービスシステムは他のコンテキスト（インバウンド接続のサーバー認証など、他のセキュリティプロトコルハンドシェイクなど、これを自動的に使用してはなりません。TLSと同等ではありません）。"
    },
    {
      "indent": 3,
      "text": "A Transport Services System MUST NOT automatically fall back from secure protocols to insecure protocols or fall back to weaker versions of secure protocols (see Section 3.3). For example, if an application requests a specific version of TLS but the desired version of TLS is not available, its connection will fail. As described in Section 3.3, the Transport Services API can allow applications to specify minimum versions that are allowed to be used by the Transport Services System.",
      "ja": "トランスポートサービスシステムは、安全なプロトコルから安全なプロトコルに自動的に後退したり、安全なプロトコルの弱いバージョンに戻ったりしてはなりません（セクション3.3を参照）。たとえば、アプリケーションがTLSの特定のバージョンを要求し、目的のバージョンのTLSを使用できない場合、その接続は失敗します。セクション3.3で説明したように、Transport Services APIは、アプリケーションが輸送サービスシステムで使用できる最小バージョンを指定できるようにすることができます。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7. 参考文献"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[POSIX]    \"IEEE/Open Group Standard for Information Technology -\n           Portable Operating System Interface (POSIX(TM)) Base\n           Specifications, Issue 8\", IEEE Std 1003.1-2024,\n           DOI 10.1109/IEEESTD.2024.10555529, 2024,\n           <https://ieeexplore.ieee.org/document/10555529>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5482]  Eggert, L. and F. Gont, \"TCP User Timeout Option\",\n           RFC 5482, DOI 10.17487/RFC5482, March 2009,\n           <https://www.rfc-editor.org/info/rfc5482>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6265]  Barth, A., \"HTTP State Management Mechanism\", RFC 6265,\n           DOI 10.17487/RFC6265, April 2011,\n           <https://www.rfc-editor.org/info/rfc6265>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7556]  Anipko, D., Ed., \"Multiple Provisioning Domain\n           Architecture\", RFC 7556, DOI 10.17487/RFC7556, June 2015,\n           <https://www.rfc-editor.org/info/rfc7556>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8095]  Fairhurst, G., Ed., Trammell, B., Ed., and M. Kuehlewind,\n           Ed., \"Services Provided by IETF Transport Protocols and\n           Congestion Control Mechanisms\", RFC 8095,\n           DOI 10.17487/RFC8095, March 2017,\n           <https://www.rfc-editor.org/info/rfc8095>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8170]  Thaler, D., Ed., \"Planning for Protocol Adoption and\n           Subsequent Transitions\", RFC 8170, DOI 10.17487/RFC8170,\n           May 2017, <https://www.rfc-editor.org/info/rfc8170>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8303]  Welzl, M., Tuexen, M., and N. Khademi, \"On the Usage of\n           Transport Features Provided by IETF Transport Protocols\",\n           RFC 8303, DOI 10.17487/RFC8303, February 2018,\n           <https://www.rfc-editor.org/info/rfc8303>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8305]  Schinazi, D. and T. Pauly, \"Happy Eyeballs Version 2:\n           Better Connectivity Using Concurrency\", RFC 8305,\n           DOI 10.17487/RFC8305, December 2017,\n           <https://www.rfc-editor.org/info/rfc8305>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8445]  Keranen, A., Holmberg, C., and J. Rosenberg, \"Interactive\n           Connectivity Establishment (ICE): A Protocol for Network\n           Address Translator (NAT) Traversal\", RFC 8445,\n           DOI 10.17487/RFC8445, July 2018,\n           <https://www.rfc-editor.org/info/rfc8445>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8446]  Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n           Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n           <https://www.rfc-editor.org/info/rfc8446>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8489]  Petit-Huguenin, M., Salgueiro, G., Rosenberg, J., Wing,\n           D., Mahy, R., and P. Matthews, \"Session Traversal\n           Utilities for NAT (STUN)\", RFC 8489, DOI 10.17487/RFC8489,\n           February 2020, <https://www.rfc-editor.org/info/rfc8489>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8922]  Enghardt, T., Pauly, T., Perkins, C., Rose, K., and C.\n           Wood, \"A Survey of the Interaction between Security\n           Protocols and Transport Services\", RFC 8922,\n           DOI 10.17487/RFC8922, October 2020,\n           <https://www.rfc-editor.org/info/rfc8922>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8923]  Welzl, M. and S. Gjessing, \"A Minimal Set of Transport\n           Services for End Systems\", RFC 8923, DOI 10.17487/RFC8923,\n           October 2020, <https://www.rfc-editor.org/info/rfc8923>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9000]  Iyengar, J., Ed. and M. Thomson, Ed., \"QUIC: A UDP-Based\n           Multiplexed and Secure Transport\", RFC 9000,\n           DOI 10.17487/RFC9000, May 2021,\n           <https://www.rfc-editor.org/info/rfc9000>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9112]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,\n           Ed., \"HTTP/1.1\", STD 99, RFC 9112, DOI 10.17487/RFC9112,\n           June 2022, <https://www.rfc-editor.org/info/rfc9112>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9113]  Thomson, M., Ed. and C. Benfield, Ed., \"HTTP/2\", RFC 9113,\n           DOI 10.17487/RFC9113, June 2022,\n           <https://www.rfc-editor.org/info/rfc9113>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9293]  Eddy, W., Ed., \"Transmission Control Protocol (TCP)\",\n           STD 7, RFC 9293, DOI 10.17487/RFC9293, August 2022,\n           <https://www.rfc-editor.org/info/rfc9293>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9622]  Trammell, B., Ed., Welzl, M., Ed., Enghardt, R.,\n           Fairhurst, G., Kühlewind, M., Perkins, C. S., Tiesel,\n           P.S., and T. Pauly, \"An Abstract Application Programming\n           Interface (API) for Transport Services\", RFC 9622,\n           DOI 10.17487/RFC9622, January 2025,\n           <https://www.rfc-editor.org/info/rfc9622>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9623]  Brunstrom, A., Ed., Pauly, T., Ed., Enghardt, R., Tiesel,\n           P.S., and M. Welzl, \"Implementing Interfaces to Transport\n           Services\", RFC 9623, DOI 10.17487/RFC9623, January 2025,\n           <https://www.rfc-editor.org/info/rfc9623>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "section_title": true,
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This work has received funding from the European Union's Horizon 2020 research and innovation programme under grant agreements No. 644334 (NEAT), No. 688421 (MAMI), and No. 815178 (5GENESIS).",
      "ja": "この作業は、助成金協定No. 644334（NEAT）、No。688421（MAMI）、およびNo. 815178（5Genesis）に基づいて、欧州連合の2020年の研究およびイノベーションプログラムから資金を受け取っています。"
    },
    {
      "indent": 3,
      "text": "This work has been supported by:",
      "ja": "この作業は次のようにサポートされています。"
    },
    {
      "indent": 6,
      "text": "* Leibniz Prize project funds from the DFG - German Research Foundation: Gottfried Wilhelm Leibniz-Preis 2011 (FKZ FE 570/4-1).",
      "ja": "* DFGからのLeibniz賞プロジェクト資金 - ドイツの研究財団：Gottfried Wilhelm Leibniz-Preis 2011（FKZ FE 570/4-1）。"
    },
    {
      "indent": 6,
      "text": "* the UK Engineering and Physical Sciences Research Council under grant EP/R04144X/1.",
      "ja": "* Grant EP/R04144X/1の下での英国工学および物理科学研究評議会。"
    },
    {
      "indent": 3,
      "text": "Thanks to Reese Enghardt, Max Franke, Mirja Kühlewind, Jonathan Lennox, and Michael Welzl for the discussions and feedback that helped shape the architecture of the system described here. Particular thanks are also due to Philipp S. Tiesel and Christopher A. Wood, who were both coauthors of this specification as it progressed through the Transport Services (TAPS) Working Group. Thanks as well to Stuart Cheshire, Josh Graessley, David Schinazi, and Eric Kinnear for their implementation and design efforts, including Happy Eyeballs, that heavily influenced this work.",
      "ja": "Reese Enghardt、Max Franke、MirjaKühlewind、Jonathan Lennox、Michael Welzlに感謝します。特に感謝しています。また、フィリップS.タイリエルとクリストファーA.ウッドは、どちらもこの仕様の共著者であり、トランスポートサービス（TAPS）ワーキンググループを経て進行しました。この作品に大きな影響を与えたハッピーアイボールを含む実装とデザインの努力について、スチュアートチェシャー、ジョシュグレスリー、デビッドシナジ、エリックキニアにも感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Tommy Pauly (editor)\nApple Inc.\nOne Apple Park Way\nCupertino, CA 95014\nUnited States of America\nEmail: tpauly@apple.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Brian Trammell (editor)\nGoogle Switzerland GmbH\nGustav-Gull-Platz 1\nCH-8004 Zurich\nSwitzerland\nEmail: ietf@trammell.ch",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Anna Brunstrom\nKarlstad University\nUniversitetsgatan 2\n651 88 Karlstad\nSweden\nEmail: anna.brunstrom@kau.se",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Godred Fairhurst\nUniversity of Aberdeen\nFraser Noble Building\nAberdeen, AB24 3UE\nUnited Kingdom\nEmail: gorry@erg.abdn.ac.uk\nURI:   https://erg.abdn.ac.uk/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Colin S. Perkins\nUniversity of Glasgow\nSchool of Computing Science\nGlasgow  G12 8QQ\nUnited Kingdom\nEmail: csp@csperkins.org",
      "raw": true,
      "ja": ""
    }
  ]
}