{
  "title": {
    "text": "RFC 9440 - Client-Cert HTTP Header Field",
    "ja": "RFC 9440 - クライアントケルトHTTPヘッダーフィールド"
  },
  "number": 9440,
  "created_at": "2024-03-04 03:51:19.359945+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       B. Campbell\nRequest for Comments: 9440                                 Ping Identity\nCategory: Informational                                   M. Bishop, Ed.\nISSN: 2070-1721                                                   Akamai\n                                                               July 2023",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Client-Cert HTTP Header Field",
      "title": true,
      "section_title": true,
      "ja": "クライアントケルトHTTPヘッダーフィールド"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes HTTP extension header fields that allow a TLS terminating reverse proxy (TTRP) to convey the client certificate information of a mutually authenticated TLS connection to the origin server in a common and predictable manner.",
      "ja": "このドキュメントでは、TLSが逆プロキシ（TTRP）を終了するTLSが、相互に認証されたTLS接続のクライアント証明書情報に一般的で予測可能な方法でクライアント証明書情報を伝えることを可能にするHTTP拡張ヘッダーフィールドについて説明します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントは、インターネット標準の追跡仕様ではありません。情報目的で公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。IESGによって承認されたすべてのドキュメントが、インターネット標準のあらゆるレベルの候補者であるわけではありません。RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9440.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https：//www.rfc-editor.org/info/rfc9440で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2023 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2023 IETF Trustおよび文書著者として特定された人。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、改訂されたBSDライセンスで説明されている保証なしで提供されるように、改訂されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Requirements Notation and Conventions\n  1.2.  Terminology and Applicability\n2.  HTTP Header Fields and Processing Rules\n  2.1.  Encoding\n  2.2.  Client-Cert HTTP Header Field\n  2.3.  Client-Cert-Chain HTTP Header Field\n  2.4.  Processing Rules\n3.  Deployment Considerations\n  3.1.  Header Field Compression\n  3.2.  Message Header Size\n  3.3.  TLS Session Resumption\n4.  Security Considerations\n5.  IANA Considerations\n  5.1.  HTTP Field Name Registrations\n6.  References\n  6.1.  Normative References\n  6.2.  Informative References\nAppendix A.  Example\nAppendix B.  Select Design Considerations\n  B.1.  Field Injection\n  B.2.  The Forwarded HTTP Extension\n  B.3.  The Whole Certificate and Certificate Chain\nAcknowledgements\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "A fairly common deployment pattern for HTTPS applications is to have the origin HTTP application servers sit behind a reverse proxy that terminates TLS connections from clients. The proxy is accessible to the Internet and dispatches client requests to the appropriate origin server within a private or protected network. The origin servers are not directly accessible by clients and are only reachable through the reverse proxy. The backend details of this type of deployment are typically opaque to clients who make requests to the proxy server and see responses as though they originated from the proxy server itself. Although HTTPS is also usually employed between the proxy and the origin server, the TLS connection that the client establishes for HTTPS is only between itself and the reverse proxy server.",
      "ja": "HTTPSアプリケーションのかなり一般的な展開パターンは、クライアントからのTLS接続を終了する逆プロキシの後ろにOrigin HTTPアプリケーションサーバーを置くことです。プロキシはインターネットにアクセスでき、プライベートまたは保護されたネットワーク内の適切なOriginサーバーにクライアント要求をディスパッチします。Origin Serverは、クライアントが直接アクセスできず、逆プロキシを通じてのみ到達可能です。このタイプの展開のバックエンドの詳細は、通常、プロキシサーバーにリクエストを行い、プロキシサーバー自体から発信されたかのように応答を確認するクライアントにとって不透明です。HTTPSは通常、プロキシとOrigin Serverの間でも採用されていますが、クライアントがHTTPSに対して確立するTLS接続は、それ自体と逆プロキシサーバーの間のみです。"
    },
    {
      "indent": 3,
      "text": "The deployment pattern is found in a number of varieties such as n-tier architectures, content delivery networks, application load-balancing services, and ingress controllers.",
      "ja": "展開パターンは、n層アーキテクチャ、コンテンツ配信ネットワーク、アプリケーションの負荷バランスサービス、イングレスコントローラーなど、さまざまな種類にあります。"
    },
    {
      "indent": 3,
      "text": "Although not exceedingly prevalent, TLS client certificate authentication is sometimes employed, and in such cases the origin server often requires information about the client certificate for its application logic. Such logic might include access control decisions, audit logging, and binding issued tokens or cookies to a certificate, including the respective validation of such bindings. The specific details needed from the certificate also vary with the application requirements. In order for these types of application deployments to work in practice, the reverse proxy needs to convey information about the client certificate to the origin application server. At the time of writing, a common way this information is conveyed is by using non-standard fields to carry the certificate (in some encoding) or individual parts thereof in the HTTP request that is dispatched to the origin server. This solution works, but interoperability between independently developed components can be cumbersome or even impossible depending on the implementation choices respectively made (like what field names are used or are configurable, which parts of the certificate are exposed, or how the certificate is encoded). A well-known predictable approach to this commonly occurring functionality could improve and simplify interoperability between independent implementations.",
      "ja": "それほど一般的ではありませんが、TLSクライアント証明書認証が採用されることがあり、そのような場合、Origin Serverは多くの場合、アプリケーションロジックのクライアント証明書に関する情報を必要とします。このようなロジックには、アクセス制御の決定、監査ロギング、およびバインディングされたトークンまたはCookieが、そのようなバインディングのそれぞれの検証を含む証明書に含まれる場合があります。証明書から必要な特定の詳細は、アプリケーション要件によっても異なります。これらのタイプのアプリケーションの展開が実際に機能するためには、逆プロキシはクライアント証明書に関する情報をOrigin Application Serverに伝える必要があります。執筆時点では、この情報が伝えられる一般的な方法は、非標準フィールドを使用して、オリジンサーバーにディスパッチされたHTTPリクエストで証明書（一部のエンコード）またはその個々のパーツを携帯することです。このソリューションは機能しますが、独立して開発されたコンポーネント間の相互運用性は、実装の選択肢に応じてそれぞれ扱いにくい、または不可能になる可能性があります（フィールド名が使用されている、設定可能なもの、証明書のどの部分が公開されているか、証明書のエンコード方法など）。この一般的に発生する機能に対するよく知られている予測可能なアプローチは、独立した実装間の相互運用性を改善し、簡素化する可能性があります。"
    },
    {
      "indent": 3,
      "text": "The scope of this document is to describe existing practice while codifying specific details sufficient to facilitate improved and lower-touch interoperability. As such, this document describes two HTTP header fields, \"Client-Cert\" and \"Client-Cert-Chain\", which a TLS terminating reverse proxy (TTRP) adds to requests sent to the backend origin servers. The Client-Cert field value contains the end-entity client certificate from the mutually authenticated TLS connection between the originating client and the TTRP. Optionally, the Client-Cert-Chain field value contains the certificate chain used for validation of the end-entity certificate. This enables the backend origin server to utilize the client certificate information in its application logic. While there may be additional proxies or hops between the TTRP and the origin server (potentially even with mutually authenticated TLS connections between them), the scope of the Client-Cert header field is intentionally limited to exposing to the origin server the certificate that was presented by the originating client in its connection to the TTRP.",
      "ja": "このドキュメントの範囲は、既存の実践を記述しながら、改善されて低タッチの相互運用性を促進するのに十分な特定の詳細を成文化することです。そのため、このドキュメントでは、2つのHTTPヘッダーフィールド、「クライアントキャット」と「クライアントキャットチェーン」を説明します。これは、TLS終端リバースプロキシ（TTRP）がバックエンドオリジンサーバーに送信されたリクエストに追加します。クライアントキャットフィールド値には、発信元のクライアントとTTRPの間の相互に認証されたTLS接続からのエンドエンティティクライアント証明書が含まれています。オプションでは、クライアントケートチェーンフィールド値には、エンドエンティティ証明書の検証に使用される証明書チェーンが含まれています。これにより、バックエンドOrigin Serverは、アプリケーションロジックでクライアント証明書情報を利用できます。TTRPとOriginサーバーの間に追加のプロキシまたはホップがある場合がありますが（それらの間で相互に認証されたTLS接続がある場合でも）、クライアントキャットヘッダーフィールドの範囲は、提示された証明書をオリジンサーバーに公開することに意図的に制限されていますTTRPに関連する起源のクライアントによって。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Notation and Conventions",
      "section_title": true,
      "ja": "1.1. 要件表記と規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology and Applicability",
      "section_title": true,
      "ja": "1.2. 用語と適用性"
    },
    {
      "indent": 3,
      "text": "This document uses the following terminology from Section 3 of [STRUCTURED-FIELDS] to specify syntax and parsing: List and Byte Sequence.",
      "ja": "このドキュメントでは、[構造化場]のセクション3の次の用語を使用して、構文と解析：リストとバイトシーケンスを指定します。"
    },
    {
      "indent": 3,
      "text": "Phrases like \"TLS client certificate authentication\" or \"mutually authenticated TLS\" are used throughout this document to refer to the process whereby, in addition to the normal TLS server authentication with a certificate, a client presents its X.509 certificate [RFC5280] and proves possession of the corresponding private key to a server when negotiating a TLS connection or the resumption of such a connection. In contemporary versions of TLS [TLS] [TLS1.2], mutual authentication requires the client to send the Certificate and CertificateVerify messages during the handshake and the server to verify the CertificateVerify and Finished messages.",
      "ja": "「TLSクライアント証明書認証」や「相互に認証されたTLS」などのフレーズは、このドキュメント全体で使用され、証明書を使用した通常のTLSサーバー認証に加えて、クライアントがX.509証明書[RFC5280]とそのプロセスを参照し、TLS接続またはそのような接続の再開を交渉する際に、サーバーに対応する秘密鍵の所有を証明します。TLS [TLS] [TLS1.2]の現代バージョンでは、相互認証では、クライアントが握手中に証明書を送信し、証明書を確認してサーバーを証明書verifyと完了したメッセージを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "HTTP/2 restricts TLS 1.2 renegotiation (Section 9.2.1 of [HTTP/2]) and prohibits TLS 1.3 post-handshake authentication (Section 9.2.3 of [HTTP/2]). However, they are sometimes used to implement reactive client certificate authentication in HTTP/1.1 [HTTP/1.1] where the server decides whether to request a client certificate based on the HTTP request. HTTP application data sent on such a connection after receipt and verification of the client certificate is also mutually authenticated and thus suitable for the mechanisms described in this document. With post-handshake authentication, there is also the possibility, though unlikely in practice, of multiple certificates and certificate chains from the client on a connection. In this case, only the certificate and chain of the last post-handshake authentication are to be utilized for the header fields described herein.",
      "ja": "HTTP/2は、TLS 1.2の再交渉（[http/2]のセクション9.2.1）を制限し、TLS 1.3ポストハンドシェイク認証を禁止しています（[http/2]のセクション9.2.3）。ただし、HTTP/1.1 [HTTP/1.1]にリアクティブクライアント証明書認証を実装するために使用されることもあります。ここで、サーバーはHTTPリクエストに基づいてクライアント証明書を要求するかどうかを決定します。クライアント証明書の受領と検証後にこのような接続に送信されたHTTPアプリケーションデータも相互に認証されているため、このドキュメントで説明されているメカニズムに適しています。ポストハンドシェイク認証では、実際には、接続中のクライアントからの複数の証明書と証明書チェーンの可能性もありますが、実際にはありそうもありません。この場合、最後のポストハンドシェイク認証の証明書とチェーンのみが、本明細書に記載されているヘッダーフィールドに使用されます。"
    },
    {
      "indent": 0,
      "text": "2. HTTP Header Fields and Processing Rules",
      "section_title": true,
      "ja": "2. HTTPヘッダーフィールドと処理ルール"
    },
    {
      "indent": 3,
      "text": "This document designates the following headers, defined further in Sections 2.2 and 2.3, respectively, to carry the client certificate information of a mutually authenticated TLS connection. The headers convey the information from the reverse proxy to the origin server.",
      "ja": "このドキュメントは、相互に認証されたTLS接続のクライアント証明書情報を伝えるために、それぞれセクション2.2および2.3でさらに定義されている次のヘッダーを指定します。ヘッダーは、逆プロキシからOrigin Serverに情報を伝えます。"
    },
    {
      "indent": 3,
      "text": "Client-Cert:",
      "ja": "Client-Cert："
    },
    {
      "indent": 12,
      "text": "The end-entity certificate used by the client in the TLS handshake with the reverse proxy.",
      "ja": "逆プロキシを使用して、TLSの握手でクライアントが使用するエンドエンティティ証明書。"
    },
    {
      "indent": 3,
      "text": "Client-Cert-Chain:",
      "ja": "クライアント - キャットチェーン："
    },
    {
      "indent": 12,
      "text": "The certificate chain used for validation of the end-entity certificate provided by the client in the TLS handshake with the reverse proxy.",
      "ja": "TLSの握手でクライアントが提供するエンドエンティティ証明書の検証に使用される証明書チェーンは、逆プロキシを使用して。"
    },
    {
      "indent": 0,
      "text": "2.1. Encoding",
      "section_title": true,
      "ja": "2.1. エンコーディング"
    },
    {
      "indent": 3,
      "text": "The headers in this document encode certificates as Byte Sequences (Section 3.3.5 of [STRUCTURED-FIELDS]) where the value of the binary data is a DER-encoded [ITU.X690] X.509 certificate [RFC5280]. In effect, this means that the binary DER certificate is encoded using base64 (without line breaks, spaces, or other characters outside the base64 alphabet) and delimited with colons on either side.",
      "ja": "このドキュメントのヘッダーは、バイナリデータの値がder-Encoded [itu.x690] x.509証明書[RFC5280]であるバイトシーケンス（[構造フィールド]のセクション3.3.5）として証明書をエンコードします。実際には、これは、バイナリDER証明書がBase64（ラインブレーク、スペース、またはBase64アルファベットの外側の他の文字なし）を使用してエンコードされ、両側にコロンで区切られていることを意味します。"
    },
    {
      "indent": 3,
      "text": "Note that certificates are often stored in an encoded textual format, such as the one described in Section 5.1 of [RFC7468], which is already nearly compatible with a Byte Sequence. If certificates are encoded as such, it will be sufficient to replace \"---(BEGIN|END) CERTIFICATE---\" with \":\" and remove line breaks in order to generate an appropriate item.",
      "ja": "証明書は、[RFC7468]のセクション5.1で説明されているようなエンコードされたテキスト形式に保存されることがよくあります。これは、すでにバイトシーケンスとほぼ互換性があります。証明書がそのようにエンコードされている場合、「---（begin | end）証明書--- \"with\"： \"を置き換えるのに十分であり、適切なアイテムを生成するために行の破損を削除します。"
    },
    {
      "indent": 0,
      "text": "2.2. Client-Cert HTTP Header Field",
      "section_title": true,
      "ja": "2.2. クライアントケルトHTTPヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "In the context of a TLS terminating reverse proxy deployment, the proxy makes the TLS client certificate available to the backend application with the Client-Cert HTTP header field. This field contains the end-entity certificate used by the client in the TLS handshake.",
      "ja": "逆プロキシ展開を終了するTLSのコンテキストでは、プロキシにより、TLSクライアント証明書は、クライアントキャットHTTPヘッダーフィールドでバックエンドアプリケーションで利用可能になります。このフィールドには、TLSハンドシェイクでクライアントが使用するエンドエンティティ証明書が含まれています。"
    },
    {
      "indent": 3,
      "text": "Client-Cert is a Byte Sequence with the value of the header encoded as described in Section 2.1.",
      "ja": "Client-Certは、セクション2.1で説明されているようにエンコードされたヘッダーの値を持つバイトシーケンスです。"
    },
    {
      "indent": 3,
      "text": "The Client-Cert header field is only for use in HTTP requests and MUST NOT be used in HTTP responses. It is a singleton header field value as defined in Section 5.5 of [HTTP], which MUST NOT have a list of values or occur multiple times in a request.",
      "ja": "Client-Certヘッダーフィールドは、HTTPリクエストでのみ使用するためであり、HTTP応答で使用してはなりません。これは、[http]のセクション5.5で定義されているシングルトンヘッダーフィールド値であり、値のリストがないか、リクエストで複数回発生してはなりません。"
    },
    {
      "indent": 3,
      "text": "Figure 2 in Appendix A has an example of the Client-Cert header field.",
      "ja": "付録Aの図2には、クライアントケルトヘッダーフィールドの例があります。"
    },
    {
      "indent": 0,
      "text": "2.3. Client-Cert-Chain HTTP Header Field",
      "section_title": true,
      "ja": "2.3. クライアントケートチェーンHTTPヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "In the context of a TLS terminating reverse proxy deployment, the proxy MAY make the certificate chain available to the backend application with the Client-Cert-Chain HTTP header field.",
      "ja": "逆プロキシの展開を終了するTLSのコンテキストでは、プロキシは、クライアントケートチェーンHTTPヘッダーフィールドで証明書チェーンをバックエンドアプリケーションで利用できるようにする場合があります。"
    },
    {
      "indent": 3,
      "text": "Client-Cert-Chain is a List (Section 3.1 of [STRUCTURED-FIELDS]). Each item in the List MUST be a Byte Sequence encoded as described in Section 2.1. The order is the same as the ordering in TLS (as described in Section 4.4.2 of [TLS]).",
      "ja": "クライアント - 洞窟チェーンはリストです（[構造化場]のセクション3.1）。リスト内の各項目は、セクション2.1で説明されているようにエンコードされたバイトシーケンスでなければなりません。この順序は、TLSの順序と同じです（[TLS]のセクション4.4.2で説明されています）。"
    },
    {
      "indent": 3,
      "text": "Client-Cert-Chain MUST NOT appear unless Client-Cert is also present, and it does not itself include the end-entity certificate that is already present in Client-Cert. The root certificate MAY be omitted from Client-Cert-Chain, provided that the target origin server is known to possess the omitted trust anchor.",
      "ja": "クライアントケートも存在しない限り、クライアントキャットチェーンが表示されない必要があり、それ自体はクライアントケルトに既に存在するエンドエンティティ証明書を含めません。ターゲットオリジンサーバーが省略されたトラストアンカーを所有していることが知られている場合、ルート証明書はクライアントキャットチェーンから省略できます。"
    },
    {
      "indent": 3,
      "text": "The Client-Cert-Chain header field is only for use in HTTP requests and MUST NOT be used in HTTP responses. It MAY have a list of values or occur multiple times in a request. For header compression purposes, it might be advantageous to split lists into multiple instances.",
      "ja": "クライアント - 洞窟ヘッダーフィールドは、HTTPリクエストでのみ使用するためであり、HTTP応答で使用してはなりません。リクエストでは、値のリストがあるか、複数回発生する場合があります。ヘッダー圧縮目的の場合、リストを複数のインスタンスに分割することが有利かもしれません。"
    },
    {
      "indent": 3,
      "text": "Figure 3 in Appendix A has an example of the Client-Cert-Chain header field.",
      "ja": "付録Aの図3には、クライアントケートチェーンヘッダーフィールドの例があります。"
    },
    {
      "indent": 0,
      "text": "2.4. Processing Rules",
      "section_title": true,
      "ja": "2.4. 処理ルール"
    },
    {
      "indent": 3,
      "text": "This section outlines the applicable processing rules for a TTRP that has negotiated a mutually authenticated TLS connection to convey the client certificate from that connection to the backend origin servers. This technique is to be used as a configuration or deployment option, and the processing rules described herein are for servers operating with that option enabled.",
      "ja": "このセクションでは、相互に認証されたTLS接続をネゴシエートして、その接続からバックエンドオリジンサーバーにクライアント証明書を伝えるために交渉したTTRPの該当する処理ルールの概要を説明します。この手法は、構成または展開オプションとして使用され、本明細書に記載されている処理ルールは、そのオプションが有効になって動作するサーバー用です。"
    },
    {
      "indent": 3,
      "text": "A TTRP negotiates the use of a mutually authenticated TLS connection with the client, such as is described in [TLS] or [TLS1.2], and validates the client certificate per its policy and trusted certificate authorities. Each HTTP request on the underlying TLS connection is dispatched to the origin server with the following modifications:",
      "ja": "TTRPは、[TLS]または[TLS1.2]に記載されているような相互に認証されたTLS接続の使用をクライアントと交渉し、ポリシーおよび信頼できる証明書当局ごとにクライアント証明書を検証します。基礎となるTLS接続の各HTTP要求は、次の変更を受けてOrigin Serverに発送されます。"
    },
    {
      "indent": 8,
      "text": "1. The client certificate is placed in the Client-Cert header field of the dispatched request, as described in Section 2.2.",
      "ja": "1. クライアント証明書は、セクション2.2で説明されているように、派遣されたリクエストのクライアントキャットヘッダーフィールドに配置されます。"
    },
    {
      "indent": 8,
      "text": "2. If so configured, the validation chain of the client certificate is placed in the Client-Cert-Chain header field of the request, as described in Section 2.3.",
      "ja": "2. そのように構成されている場合、クライアント証明書の検証チェーンは、セクション2.3で説明されているように、リクエストのクライアントキャットチェーンヘッダーフィールドに配置されます。"
    },
    {
      "indent": 8,
      "text": "3. Any occurrence of the Client-Cert or Client-Cert-Chain header fields in the original incoming request MUST be removed or overwritten before forwarding the request. An incoming request that has a Client-Cert or Client-Cert-Chain header field MAY be rejected with an HTTP 400 response.",
      "ja": "3. 元の着信リクエストでクライアントケートまたはクライアントキャットチェーンヘッダーフィールドの発生は、リクエストを転送する前に削除または上書きする必要があります。クライアントケートまたはクライアントキャットチェーンヘッダーフィールドを持つ着信リクエストは、HTTP 400応答で拒否される場合があります。"
    },
    {
      "indent": 3,
      "text": "Requests to the TTRP made over a TLS connection where the use of client certificate authentication was not negotiated MUST be sanitized by removing any and all occurrences of the Client-Cert and Client-Cert-Chain header fields prior to dispatching the request to the backend server.",
      "ja": "クライアント証明書認証の使用がネゴシエートされなかったTLS接続を介して行われたTTRPへのリクエストは、バックエンドサーバーにリクエストをディスパッチする前に、クライアントとクライアントのキャットチェーンヘッダーフィールドのすべての発生を削除することで消毒する必要があります。"
    },
    {
      "indent": 3,
      "text": "Backend origin servers may then use the Client-Cert header field of the request to determine if the connection from the client to the TTRP was mutually authenticated and, if so, the certificate thereby presented by the client. Access control decisions based on the client certificate (or lack thereof) can be conveyed by selecting response content as appropriate or with an HTTP 403 response, if the certificate is deemed unacceptable for the given context. Note that TLS clients that rely on error indications at the TLS layer for an unacceptable certificate will not receive those signals.",
      "ja": "バックエンドオリジンサーバーは、リクエストのクライアントキャットヘッダーフィールドを使用して、クライアントからTTRPへの接続が相互に認証されているかどうかを判断することができます。クライアント証明書（またはその欠如）に基づくアクセス制御決定は、特定のコンテキストに対して証明書が許容できないとみなされる場合、適切に応答コンテンツを選択するか、HTTP 403応答を使用して伝えることができます。容認できない証明書のTLSレイヤーでエラー表示に依存しているTLSクライアントは、これらの信号を受信しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "When the value of the Client-Cert request header field is used to select a response (e.g., the response content is access-controlled), the response MUST either be uncacheable (e.g., by sending Cache-Control: no-store) or be designated for selective reuse only for subsequent requests with the same Client-Cert header field value by sending a \"Vary: Client-Cert\" response header. If a TTRP encounters a response with Client-Cert or Client-Cert-Chain in the Vary header field (Section 12.5.5 of [HTTP]), it SHOULD prevent the user agent from caching the response by transforming the value of the Vary response header field to \"*\".",
      "ja": "クライアントキャットリクエストヘッダーフィールドの値を使用して応答を選択する場合（例：応答コンテンツはアクセス制御されます）、応答は修正できない（例：キャッシュコントロール：ストアなし）または「Viraly：Client-Cert」Response Headerを送信することにより、同じクライアントケルトヘッダーフィールド値を持つ後続のリクエストに対してのみ選択的な再利用用に指定されます。TTRPがさまざまなヘッダーフィールド（[http]のセクション12.5.5）でクライアントケルトまたはクライアントキャットチェーンを使用して応答に遭遇した場合、さまざまな応答の値を変換することにより、ユーザーエージェントが応答をキャッシュするのを防ぐ必要があります。「*」へのヘッダーフィールド。"
    },
    {
      "indent": 3,
      "text": "Forward proxies and other intermediaries MUST NOT add the Client-Cert or Client-Cert-Chain header fields to requests or modify an existing Client-Cert or Client-Cert-Chain header field. Similarly, clients MUST NOT employ the Client-Cert or Client-Cert-Chain header field in requests.",
      "ja": "フォワードプロキシおよびその他の仲介業者は、クライアントケートまたはクライアントキャットチェーンヘッダーフィールドを追加して、既存のクライアントキャットまたはクライアントキャットチェーンヘッダーフィールドをリクエストまたは変更してはなりません。同様に、クライアントはリクエストでクライアントケルトまたはクライアントキャットチェーンヘッダーフィールドを採用してはなりません。"
    },
    {
      "indent": 0,
      "text": "3. Deployment Considerations",
      "section_title": true,
      "ja": "3. 展開の考慮事項"
    },
    {
      "indent": 0,
      "text": "3.1. Header Field Compression",
      "section_title": true,
      "ja": "3.1. ヘッダーフィールド圧縮"
    },
    {
      "indent": 3,
      "text": "If the connection between the TTRP and origin is capable of field compression (e.g., HPACK [HPACK] or QPACK [QPACK]), and the TTRP multiplexes more than one client's requests into that connection, the size and variation of Client-Cert and Client-Cert-Chain field values can reduce compression efficiency significantly. An origin could mitigate the efficiency loss by increasing the size of the dynamic table. If the TTRP determines that the origin dynamic table is not sufficiently large, it may find it beneficial to always send the field value as a literal rather than entering it into the table.",
      "ja": "TTRPとOriginの間の接続がフィールド圧縮（例：HPACK [HPACK]またはQPACK [QPACK]）と、複数のクライアントがその接続に複数のクライアントのリクエストを要求すること、クライアントキャットとクライアントのサイズとバリエーションを多重にマルチプレックスできる場合-Cert-Chainフィールド値は、圧縮効率を大幅に低下させる可能性があります。起源は、動的テーブルのサイズを増やすことにより、効率の損失を軽減できます。TTRPがOriginの動的テーブルが十分に大きくないと判断した場合、テーブルに入力するのではなく、常にフィールド値を文字通りとして送信することが有益であると思われる場合があります。"
    },
    {
      "indent": 0,
      "text": "3.2. Message Header Size",
      "section_title": true,
      "ja": "3.2. メッセージヘッダーサイズ"
    },
    {
      "indent": 3,
      "text": "A server in receipt of a larger message header than it is willing to handle can send an HTTP 431 (Request Header Fields Too Large) status code per Section 5 of [RFC6585]. Due to the typical size of the field values containing certificate data, recipients may need to be configured to allow for a larger maximum header size. An intermediary generating client certificate header fields on connections that allow for advertising the maximum acceptable header size (e.g., HTTP/2 [HTTP/2] or HTTP/3 [HTTP/3]) should account for the additional size of the header of the requests it sends, versus the requests it receives, by advertising a value to its clients that is sufficiently smaller so as to allow for the addition of certificate data.",
      "ja": "[RFC6585]のセクション5ごとに、HTTP 431（リクエストヘッダーフィールドが大きすぎる）ステータスコードを処理するよりも大きなメッセージヘッダーを受け取るサーバーを受信することができます。証明書データを含むフィールド値の典型的なサイズにより、より大きな最大ヘッダーサイズを可能にするために受信者を構成する必要がある場合があります。最大許容ヘッダーサイズ（HTTP/2 [HTTP/2]またはHTTP/3 [HTTP/3]など）を宣伝できる接続の中間生成クライアント証明書ヘッダーフィールドは、次のサイズを説明する必要があります。証明書データの追加を可能にするために十分に小さいクライアントに値を宣伝することにより、受信するリクエストに対して送信するリクエスト。"
    },
    {
      "indent": 0,
      "text": "3.3. TLS Session Resumption",
      "section_title": true,
      "ja": "3.3. TLSセッション再開"
    },
    {
      "indent": 3,
      "text": "Some TLS implementations do not retain client certificate information when resuming. Providing inconsistent values of Client-Cert and Client-Cert-Chain when resuming might lead to errors, so implementations that are unable to provide these values SHOULD either disable resumption for connections with client certificates or initially omit a Client-Cert or Client-Cert-Chain field if it might not be available after resuming.",
      "ja": "一部のTLS実装では、再開時にクライアント証明書情報を保持しません。再開時にクライアントケルトとクライアントキャットチェーンの一貫性のない値を提供する可能性があるため、これらの値を提供できない実装は、クライアント証明書との接続の再開を無効にするか、最初にクライアントキャットまたはクライアントキャットを省略する必要があります。チェーンフィールドが再開後に利用できない可能性がある場合。"
    },
    {
      "indent": 0,
      "text": "4. Security Considerations",
      "section_title": true,
      "ja": "4. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The header fields described herein enable a TTRP and backend or origin server to function together as though, from the client's perspective, they are a single logical server-side deployment of HTTPS over a mutually authenticated TLS connection. However, use of the header fields outside that intended use case may undermine the protections afforded by TLS client certificate authentication. Therefore, steps such as those described below need to be taken to prevent unintended use, both in sending the header field and in relying on its value.",
      "ja": "本明細書で説明するヘッダーフィールドは、TTRPとバックエンドまたはOrigin Serverがまるでクライアントの観点から、相互に認証されたTLS接続を介したHTTPの単一の論理的サーバー側の展開であるかのように一緒に機能できるようにすることができます。ただし、意図したユースケースの外側のヘッダーフィールドの使用は、TLSクライアント証明書認証によって提供される保護を損なう可能性があります。したがって、ヘッダーフィールドの送信とその価値に依存する際に、意図しない使用を防ぐために、以下に説明するような手順を取る必要があります。"
    },
    {
      "indent": 3,
      "text": "Producing and consuming the Client-Cert and Client-Cert-Chain header fields SHOULD be configurable options, respectively, in a TTRP and backend server (or in an individual application in that server). The default configuration for both should be to not use the header fields, thus requiring an \"opt-in\" to the functionality.",
      "ja": "クライアントとクライアントとクライアントのヘッダーヘッダーフィールドの生産と消費は、それぞれTTRPおよびバックエンドサーバー（またはそのサーバーの個別のアプリケーション）で構成可能なオプションでなければなりません。両方のデフォルトの構成は、ヘッダーフィールドを使用しないため、機能に「オプトイン」を必要とすることです。"
    },
    {
      "indent": 3,
      "text": "In order to prevent field injection, backend servers MUST only accept the Client-Cert and Client-Cert-Chain header fields from a trusted TTRP (or other proxy in a trusted path from the TTRP). A TTRP MUST sanitize the incoming request before forwarding it on by removing or overwriting any existing instances of the fields. Otherwise, arbitrary clients can control the field values as seen and used by the backend server. It is important to note that neglecting to prevent field injection does not \"fail safe\" in that the nominal functionality will still work as expected even when malicious actions are possible. As such, extra care is recommended in ensuring that proper field sanitation is in place.",
      "ja": "フィールドインジェクションを防ぐために、バックエンドサーバーは、信頼できるTTRP（またはTTRPからの信頼できるパスでの他のプロキシ）からのクライアントとクライアントの洞窟ヘッダーフィールドのみを受け入れる必要があります。TTRPは、フィールドの既存のインスタンスを削除または上書きすることにより、転送する前に着信要求を消毒する必要があります。それ以外の場合、任意のクライアントは、バックエンドサーバーで見られ、使用されるように、フィールド値を制御できます。野外噴射を防ぐことを無視することは、悪意のあるアクションが可能な場合でも公称機能が予想どおりに機能するという点で「安全に失敗する」ことはないことに注意することが重要です。そのため、適切な現場衛生が整っていることを確認するために、余分な注意が推奨されます。"
    },
    {
      "indent": 3,
      "text": "The communication between a TTRP and backend server needs to be secured against eavesdropping and modification by unintended parties.",
      "ja": "TTRPサーバーとバックエンドサーバー間の通信は、意図しない当事者による盗聴および変更に対して保護する必要があります。"
    },
    {
      "indent": 3,
      "text": "The configuration options and request sanitization are necessary functionalities of the respective servers. The other requirements can be met in a number of ways, which will vary based on specific deployments. The communication between a TTRP and backend or origin server, for example, might be authenticated in some way with the insertion and consumption of the Client-Cert and Client-Cert-Chain header fields occurring only on that connection. Appendix B.3 of [HTTPSIG] gives one example of this with an application of HTTP Message Signatures. Alternatively, the network topology might dictate a private network such that the backend application is only able to accept requests from the TTRP and the proxy can only make requests to that server. Other deployments that meet the requirements set forth herein are also possible.",
      "ja": "構成オプションと要求の消毒は、それぞれのサーバーの必要な機能です。他の要件はさまざまな方法で満たすことができます。これは、特定の展開に基づいて異なります。たとえば、TTRPとバックエンドまたはOriginサーバーの間の通信は、その接続でのみ発生するクライアントとクライアントチェーンヘッダーフィールドの挿入と消費により、何らかの方法で認証される場合があります。[httpsig]の付録B.3は、HTTPメッセージ署名のアプリケーションでこの一例を示します。あるいは、ネットワークトポロジは、バックエンドアプリケーションがTTRPからのリクエストのみを受け入れることができるようにプライベートネットワークを決定する可能性があり、プロキシはそのサーバーにのみリクエストを行うことができます。ここに記載されている要件を満たす他の展開も可能です。"
    },
    {
      "indent": 0,
      "text": "5. IANA Considerations",
      "section_title": true,
      "ja": "5. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "5.1. HTTP Field Name Registrations",
      "section_title": true,
      "ja": "5.1. HTTPフィールド名登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following entries in the \"Hypertext Transfer Protocol (HTTP) Field Name Registry\" defined by \"HTTP Semantics\" [HTTP]:",
      "ja": "IANAは、「HTTP Semantics」[HTTP]で定義された「HyperText Transfer Protocol（HTTP）フィールド名レジストリ」に次のエントリを登録しています。"
    },
    {
      "indent": 10,
      "text": "+===================+===========+=====================+\n| Field Name        | Status    | Reference           |\n+===================+===========+=====================+\n| Client-Cert       | permanent | RFC 9440, Section 2 |\n+-------------------+-----------+---------------------+\n| Client-Cert-Chain | permanent | RFC 9440, Section 2 |\n+-------------------+-----------+---------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Table 1: Hypertext Transfer Protocol (HTTP) Field Name Registry",
      "ja": "表1：ハイパーテキスト転送プロトコル（HTTP）フィールド名レジストリ"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6. 参考文献"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[HTTP]     Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,\n           Ed., \"HTTP Semantics\", STD 97, RFC 9110,\n           DOI 10.17487/RFC9110, June 2022,\n           <https://www.rfc-editor.org/info/rfc9110>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[ITU.X690] ITU-T, \"Information technology - ASN.1 encoding rules:\n           Specification of Basic Encoding Rules (BER), Canonical\n           Encoding Rules (CER) and Distinguished Encoding Rules\n           (DER)\", ITU-T Recommendation X.690, February 2021,\n           <https://www.itu.int/rec/T-REC-X.690/en>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n           Housley, R., and W. Polk, \"Internet X.509 Public Key\n           Infrastructure Certificate and Certificate Revocation List\n           (CRL) Profile\", RFC 5280, DOI 10.17487/RFC5280, May 2008,\n           <https://www.rfc-editor.org/info/rfc5280>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[STRUCTURED-FIELDS]\n           Nottingham, M. and P-H. Kamp, \"Structured Field Values for\n           HTTP\", RFC 8941, DOI 10.17487/RFC8941, February 2021,\n           <https://www.rfc-editor.org/info/rfc8941>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[HPACK]    Peon, R. and H. Ruellan, \"HPACK: Header Compression for\n           HTTP/2\", RFC 7541, DOI 10.17487/RFC7541, May 2015,\n           <https://www.rfc-editor.org/info/rfc7541>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HTTP/1.1] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,\n           Ed., \"HTTP/1.1\", STD 99, RFC 9112, DOI 10.17487/RFC9112,\n           June 2022, <https://www.rfc-editor.org/info/rfc9112>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HTTP/2]   Thomson, M., Ed. and C. Benfield, Ed., \"HTTP/2\", RFC 9113,\n           DOI 10.17487/RFC9113, June 2022,\n           <https://www.rfc-editor.org/info/rfc9113>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HTTP/3]   Bishop, M., Ed., \"HTTP/3\", RFC 9114, DOI 10.17487/RFC9114,\n           June 2022, <https://www.rfc-editor.org/info/rfc9114>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HTTPSIG]  Backman, A., Ed., Richer, J., Ed., and M. Sporny, \"HTTP\n           Message Signatures\", Work in Progress, Internet-Draft,\n           draft-ietf-httpbis-message-signatures-17, 2 May 2023,\n           <https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-\n           message-signatures-17>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[QPACK]    Krasic, C., Bishop, M., and A. Frindell, Ed., \"QPACK:\n           Field Compression for HTTP/3\", RFC 9204,\n           DOI 10.17487/RFC9204, June 2022,\n           <https://www.rfc-editor.org/info/rfc9204>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6585]  Nottingham, M. and R. Fielding, \"Additional HTTP Status\n           Codes\", RFC 6585, DOI 10.17487/RFC6585, April 2012,\n           <https://www.rfc-editor.org/info/rfc6585>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7239]  Petersson, A. and M. Nilsson, \"Forwarded HTTP Extension\",\n           RFC 7239, DOI 10.17487/RFC7239, June 2014,\n           <https://www.rfc-editor.org/info/rfc7239>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7468]  Josefsson, S. and S. Leonard, \"Textual Encodings of PKIX,\n           PKCS, and CMS Structures\", RFC 7468, DOI 10.17487/RFC7468,\n           April 2015, <https://www.rfc-editor.org/info/rfc7468>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8705]  Campbell, B., Bradley, J., Sakimura, N., and T.\n           Lodderstedt, \"OAuth 2.0 Mutual-TLS Client Authentication\n           and Certificate-Bound Access Tokens\", RFC 8705,\n           DOI 10.17487/RFC8705, February 2020,\n           <https://www.rfc-editor.org/info/rfc8705>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[TLS]      Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n           Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n           <https://www.rfc-editor.org/info/rfc8446>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[TLS1.2]   Dierks, T. and E. Rescorla, \"The Transport Layer Security\n           (TLS) Protocol Version 1.2\", RFC 5246,\n           DOI 10.17487/RFC5246, August 2008,\n           <https://www.rfc-editor.org/info/rfc5246>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix A. Example",
      "section_title": true,
      "ja": "付録A. 例"
    },
    {
      "indent": 3,
      "text": "In a hypothetical example where a TLS client would present the client and intermediate certificate from Figure 1 when establishing a mutually authenticated TLS connection with the TTRP, the proxy would send the Client-Cert field shown in Figure 2 to the backend. Note that line breaks and extra spaces have been added to the field value in Figures 2 and 3 for display and formatting purposes only.",
      "ja": "TLSクライアントがTTRPと相互に認証されたTLS接続を確立するときに図1からクライアントと中間証明書を提示する仮想的な例では、プロキシは図2に示すクライアントキャットフィールドをバックエンドに送信します。表示および書式設定のみで、図2および3のフィールド値にラインブレークと余分なスペースが追加されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "-----BEGIN CERTIFICATE-----\nMIIBqDCCAU6gAwIBAgIBBzAKBggqhkjOPQQDAjA6MRswGQYDVQQKDBJMZXQncyBB\ndXRoZW50aWNhdGUxGzAZBgNVBAMMEkxBIEludGVybWVkaWF0ZSBDQTAeFw0yMDAx\nMTQyMjU1MzNaFw0yMTAxMjMyMjU1MzNaMA0xCzAJBgNVBAMMAkJDMFkwEwYHKoZI\nzj0CAQYIKoZIzj0DAQcDQgAE8YnXXfaUgmnMtOXU/IncWalRhebrXmckC8vdgJ1p\n5Be5F/3YC8OthxM4+k1M6aEAEFcGzkJiNy6J84y7uzo9M6NyMHAwCQYDVR0TBAIw\nADAfBgNVHSMEGDAWgBRm3WjLa38lbEYCuiCPct0ZaSED2DAOBgNVHQ8BAf8EBAMC\nBsAwEwYDVR0lBAwwCgYIKwYBBQUHAwIwHQYDVR0RAQH/BBMwEYEPYmRjQGV4YW1w\nbGUuY29tMAoGCCqGSM49BAMCA0gAMEUCIBHda/r1vaL6G3VliL4/Di6YK0Q6bMje\nSkC3dFCOOB8TAiEAx/kHSB4urmiZ0NX5r5XarmPk0wmuydBVoU4hBVZ1yhk=\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\nMIIB5jCCAYugAwIBAgIBFjAKBggqhkjOPQQDAjBWMQswCQYDVQQGEwJVUzEbMBkG\nA1UECgwSTGV0J3MgQXV0aGVudGljYXRlMSowKAYDVQQDDCFMZXQncyBBdXRoZW50\naWNhdGUgUm9vdCBBdXRob3JpdHkwHhcNMjAwMTE0MjEzMjMwWhcNMzAwMTExMjEz\nMjMwWjA6MRswGQYDVQQKDBJMZXQncyBBdXRoZW50aWNhdGUxGzAZBgNVBAMMEkxB\nIEludGVybWVkaWF0ZSBDQTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABJf+aA54\nRC5pyLAR5yfXVYmNpgd+CGUTDp2KOGhc0gK91zxhHesEYkdXkpS2UN8Kati+yHtW\nCV3kkhCngGyv7RqjZjBkMB0GA1UdDgQWBBRm3WjLa38lbEYCuiCPct0ZaSED2DAf\nBgNVHSMEGDAWgBTEA2Q6eecKu9g9yb5glbkhhVINGDASBgNVHRMBAf8ECDAGAQH/\nAgEAMA4GA1UdDwEB/wQEAwIBhjAKBggqhkjOPQQDAgNJADBGAiEA5pLvaFwRRkxo\nmIAtDIwg9D7gC1xzxBl4r28EzmSO1pcCIQCJUShpSXO9HDIQMUgH69fNDEMHXD3R\nRX5gP7kuu2KGMg==\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\nMIICBjCCAaygAwIBAgIJAKS0yiqKtlhoMAoGCCqGSM49BAMCMFYxCzAJBgNVBAYT\nAlVTMRswGQYDVQQKDBJMZXQncyBBdXRoZW50aWNhdGUxKjAoBgNVBAMMIUxldCdz\nIEF1dGhlbnRpY2F0ZSBSb290IEF1dGhvcml0eTAeFw0yMDAxMTQyMTI1NDVaFw00\nMDAxMDkyMTI1NDVaMFYxCzAJBgNVBAYTAlVTMRswGQYDVQQKDBJMZXQncyBBdXRo\nZW50aWNhdGUxKjAoBgNVBAMMIUxldCdzIEF1dGhlbnRpY2F0ZSBSb290IEF1dGhv\ncml0eTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABFoaHU+Z5bPKmGzlYXtCf+E6\nHYj62fORaHDOrt+yyh3H/rTcs7ynFfGn+gyFsrSP3Ez88rajv+U2NfD0o0uZ4Pmj\nYzBhMB0GA1UdDgQWBBTEA2Q6eecKu9g9yb5glbkhhVINGDAfBgNVHSMEGDAWgBTE\nA2Q6eecKu9g9yb5glbkhhVINGDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQE\nAwIBhjAKBggqhkjOPQQDAgNIADBFAiEAmAeg1ycKHriqHnaD4M/UDBpQRpkmdcRF\nYGMg1Qyrkx4CIB4ivz3wQcQkGhcsUZ1SOImd/lq1Q0FLf09rGfLQPWDc\n-----END CERTIFICATE-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 1: Certificate Chain (with Client Certificate First)",
      "ja": "図1：証明書チェーン（最初の証明書付き）"
    },
    {
      "indent": 3,
      "text": "Client-Cert: :MIIBqDCCAU6gAwIBAgIBBzAKBggqhkjOPQQDAjA6MRswGQYDVQQKDBJ\n MZXQncyBBdXRoZW50aWNhdGUxGzAZBgNVBAMMEkxBIEludGVybWVkaWF0ZSBDQTAeFw0\n yMDAxMTQyMjU1MzNaFw0yMTAxMjMyMjU1MzNaMA0xCzAJBgNVBAMMAkJDMFkwEwYHKoZ\n Izj0CAQYIKoZIzj0DAQcDQgAE8YnXXfaUgmnMtOXU/IncWalRhebrXmckC8vdgJ1p5Be\n 5F/3YC8OthxM4+k1M6aEAEFcGzkJiNy6J84y7uzo9M6NyMHAwCQYDVR0TBAIwADAfBgN\n VHSMEGDAWgBRm3WjLa38lbEYCuiCPct0ZaSED2DAOBgNVHQ8BAf8EBAMCBsAwEwYDVR0\n lBAwwCgYIKwYBBQUHAwIwHQYDVR0RAQH/BBMwEYEPYmRjQGV4YW1wbGUuY29tMAoGCCq\n GSM49BAMCA0gAMEUCIBHda/r1vaL6G3VliL4/Di6YK0Q6bMjeSkC3dFCOOB8TAiEAx/k\n HSB4urmiZ0NX5r5XarmPk0wmuydBVoU4hBVZ1yhk=:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Figure 2: Header Field in HTTP Request to Origin Server",
      "ja": "図2：httpのヘッダーフィールドオリジンサーバーへのリクエスト"
    },
    {
      "indent": 3,
      "text": "If the proxy were configured to also include the certificate chain, it would also include the Client-Cert-Chain header field. Note that while the following example does illustrate the TTRP inserting the root certificate, many deployments will opt to omit the trust anchor.",
      "ja": "プロキシが証明書チェーンも含めるように構成されている場合、クライアントキャットチェーンヘッダーフィールドも含まれます。次の例では、ルート証明書を挿入するTTRPを示していますが、多くの展開は信頼のアンカーを省略することを選択することに注意してください。"
    },
    {
      "indent": 3,
      "text": "Client-Cert-Chain: :MIIB5jCCAYugAwIBAgIBFjAKBggqhkjOPQQDAjBWMQsw\n CQYDVQQGEwJVUzEbMBkGA1UECgwSTGV0J3MgQXV0aGVudGljYXRlMSowKAYDVQQ\n DDCFMZXQncyBBdXRoZW50aWNhdGUgUm9vdCBBdXRob3JpdHkwHhcNMjAwMTE0Mj\n EzMjMwWhcNMzAwMTExMjEzMjMwWjA6MRswGQYDVQQKDBJMZXQncyBBdXRoZW50a\n WNhdGUxGzAZBgNVBAMMEkxBIEludGVybWVkaWF0ZSBDQTBZMBMGByqGSM49AgEG\n CCqGSM49AwEHA0IABJf+aA54RC5pyLAR5yfXVYmNpgd+CGUTDp2KOGhc0gK91zx\n hHesEYkdXkpS2UN8Kati+yHtWCV3kkhCngGyv7RqjZjBkMB0GA1UdDgQWBBRm3W\n jLa38lbEYCuiCPct0ZaSED2DAfBgNVHSMEGDAWgBTEA2Q6eecKu9g9yb5glbkhh\n VINGDASBgNVHRMBAf8ECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIBhjAKBggqhkjO\n PQQDAgNJADBGAiEA5pLvaFwRRkxomIAtDIwg9D7gC1xzxBl4r28EzmSO1pcCIQC\n JUShpSXO9HDIQMUgH69fNDEMHXD3RRX5gP7kuu2KGMg==:, :MIICBjCCAaygAw\n IBAgIJAKS0yiqKtlhoMAoGCCqGSM49BAMCMFYxCzAJBgNVBAYTAlVTMRswGQYDV\n QQKDBJMZXQncyBBdXRoZW50aWNhdGUxKjAoBgNVBAMMIUxldCdzIEF1dGhlbnRp\n Y2F0ZSBSb290IEF1dGhvcml0eTAeFw0yMDAxMTQyMTI1NDVaFw00MDAxMDkyMTI\n 1NDVaMFYxCzAJBgNVBAYTAlVTMRswGQYDVQQKDBJMZXQncyBBdXRoZW50aWNhdG\n UxKjAoBgNVBAMMIUxldCdzIEF1dGhlbnRpY2F0ZSBSb290IEF1dGhvcml0eTBZM\n BMGByqGSM49AgEGCCqGSM49AwEHA0IABFoaHU+Z5bPKmGzlYXtCf+E6HYj62fOR\n aHDOrt+yyh3H/rTcs7ynFfGn+gyFsrSP3Ez88rajv+U2NfD0o0uZ4PmjYzBhMB0\n GA1UdDgQWBBTEA2Q6eecKu9g9yb5glbkhhVINGDAfBgNVHSMEGDAWgBTEA2Q6ee\n cKu9g9yb5glbkhhVINGDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBh\n jAKBggqhkjOPQQDAgNIADBFAiEAmAeg1ycKHriqHnaD4M/UDBpQRpkmdcRFYGMg\n 1Qyrkx4CIB4ivz3wQcQkGhcsUZ1SOImd/lq1Q0FLf09rGfLQPWDc:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 3: Certificate Chain in HTTP Request to Origin Server",
      "ja": "図3：HTTPのオリジンサーバーへのリクエストの証明書チェーン"
    },
    {
      "indent": 0,
      "text": "Appendix B. Select Design Considerations",
      "section_title": true,
      "ja": "付録B. 設計上の考慮事項を選択します"
    },
    {
      "indent": 0,
      "text": "B.1. Field Injection",
      "section_title": true,
      "ja": "B.1. フィールドインジェクション"
    },
    {
      "indent": 3,
      "text": "This document requires that the TTRP sanitize the fields of the incoming request by removing or overwriting any existing instances of the Client-Cert and Client-Cert-Chain header fields before dispatching that request to the backend application. Otherwise, a client could inject its own values that would appear to the backend to have come from the TTRP. Although numerous other methods of detecting and preventing field injection are possible, such as the use of a unique secret value as part of the field name or value or the application of a signature, HMAC, or AEAD, there is no common general mechanism. The potential problem of client field injection is not at all unique to the functionality of this document; therefore, it would be inappropriate for this document to define a one-off solution. Since a generic common solution does not currently exist, stripping and sanitizing the fields is the de facto means of protecting against field injection in practice. Sanitizing the fields is sufficient when properly implemented and is a normative requirement of Section 4.",
      "ja": "このドキュメントでは、TTRPが、バックエンドアプリケーションにそのリクエストを発送する前に、クライアントとクライアントの洞窟ヘッダーフィールドの既存のインスタンスを削除または上書きすることにより、着信要求のフィールドを消毒する必要があります。それ以外の場合、クライアントは、TTRPから来たとバックエンドに表示される独自の値を注入できます。フィールド名または値の一部としての一意の秘密価値の使用、署名、HMAC、またはAEADの適用など、フィールドインジェクションを検出および防止する他の多くの方法が可能ですが、一般的な一般的なメカニズムはありません。クライアントフィールドインジェクションの潜在的な問題は、このドキュメントの機能にまったく固有のものではありません。したがって、このドキュメントが1回限りのソリューションを定義することは不適切です。現在、一般的な一般的なソリューションは存在しないため、フィールドを剥ぎ取り、消毒することは、実際のフィールド注入から保護する事実上の手段です。適切に実装された場合、フィールドを消毒するだけで十分であり、セクション4の規範的要件です。"
    },
    {
      "indent": 0,
      "text": "B.2. The Forwarded HTTP Extension",
      "section_title": true,
      "ja": "B.2. 転送されたHTTP拡張"
    },
    {
      "indent": 3,
      "text": "The Forwarded HTTP header field defined in [RFC7239] allows proxy components to disclose information lost in the proxying process. The TLS client certificate information of concern to this document could have been communicated with an extension parameter to the Forwarded field; however, doing so would have had some disadvantages that this document endeavored to avoid. The Forwarded field syntax allows for information about a full chain of proxied HTTP requests, whereas the Client-Cert and Client-Cert-Chain header fields of this document are concerned only with conveying information about the certificate presented by the originating client on the TLS connection to the TTRP (which appears as the server from that client's perspective) to backend applications. The multi-hop syntax of the Forwarded field is expressive but also more complicated, which would make processing it more cumbersome and, more importantly, would make properly sanitizing its content, as required by Section 4 to prevent field injection, considerably more difficult and error-prone. Thus, this document opted for a flatter and more straightforward structure.",
      "ja": "[RFC7239]で定義されている転送されたHTTPヘッダーフィールドにより、プロキシコンポーネントはプロキシプロセスで失われた情報を開示できます。このドキュメントに対する懸念事項のTLSクライアント証明書情報は、転送フィールドへの拡張パラメーターと通信された可能性があります。しかし、そうすることで、この文書が避けるように努力したいくつかの欠点がありました。転送されたフィールド構文は、プロキシされたHTTPリクエストの完全なチェーンに関する情報を可能にしますが、このドキュメントのクライアントとクライアント - キャットチェーンヘッダーフィールドは、TLS接続で発生するクライアントが提示した証明書に関する情報を伝えることにのみ関係しています。TTRP（そのクライアントの観点からサーバーとして表示される）に、アプリケーションをバックエンドします。転送されたフィールドのマルチホップ構文は表現力がありますが、より複雑であるため、処理をより面倒にし、さらに重要なことには、セクション4で必要に応じて、フィールドインジェクションを防ぐために必要に応じて、かなり困難でエラーが発生します。 - 後に。したがって、このドキュメントは、より平坦でより単純な構造を選択しました。"
    },
    {
      "indent": 0,
      "text": "B.3. The Whole Certificate and Certificate Chain",
      "section_title": true,
      "ja": "B.3. 証明書と証明書チェーン全体"
    },
    {
      "indent": 3,
      "text": "Different applications will have varying requirements about what information from the client certificate is needed, such as the subject and/or issuer distinguished name, subject alternative name(s), serial number, subject public key info, fingerprint, etc. Furthermore, some applications, such as that described in [RFC8705], make use of the entire certificate. In order to accommodate the latter and ensure wide applicability by not trying to cherry-pick particular certificate information, this document opted to pass the full, encoded certificate as the value of the Client-Cert field.",
      "ja": "さまざまなアプリケーションには、件名や発行者の著名な名前、件名の代替名、シリアル番号、主題公開鍵情報、指紋など、件名や発行者の著名な名前など、クライアント証明書からの情報が必要なものについてさまざまな要件があります。さらに、一部のアプリケーション、[RFC8705]に記載されているような、証明書全体を利用します。後者に対応し、特定の証明書情報を選択しようとしないことで幅広い適用性を確保するために、このドキュメントは、クライアントキャットフィールドの値として完全なエンコードされた証明書を渡すことを選択しました。"
    },
    {
      "indent": 3,
      "text": "The validation of the client certificate and chain of the mutually authenticated TLS connection is typically performed by the TTRP during the handshake. With the responsibility of certificate validation falling on the TTRP, the end-entity certificate is oftentimes sufficient for the needs of the origin server. The separate Client-Cert-Chain field can convey the certificate chain for origin server deployments that require this additional information.",
      "ja": "相互に認証されたTLS接続のクライアント証明書とチェーンの検証は、通常、握手中にTTRPによって実行されます。証明書の検証の責任がTTTRPに該当するため、エンドエンティティ証明書は、Origin Serverのニーズに対してしばしば十分です。個別のクライアント - 洞窟チェーンフィールドは、この追加情報を必要とするOrigin Server展開の証明書チェーンを伝えることができます。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "section_title": true,
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank the following individuals who have contributed to this document in various ways, ranging from just being generally supportive of bringing forth the document to providing specific feedback or content:",
      "ja": "著者は、この文書をさまざまな方法で貢献した以下の個人に、一般的に文書を出すことを支持することから、特定のフィードバックまたはコンテンツを提供することに感謝します。"
    },
    {
      "indent": 6,
      "text": "* Evan Anderson",
      "ja": "* エヴァン・アンダーソン"
    },
    {
      "indent": 6,
      "text": "* Annabelle Backman",
      "ja": "* アナベルバックマン"
    },
    {
      "indent": 6,
      "text": "* Alan Frindell",
      "ja": "* アラン・フリンデル"
    },
    {
      "indent": 6,
      "text": "* Rory Hewitt",
      "ja": "* ロリー・ヒューイット"
    },
    {
      "indent": 6,
      "text": "* Fredrik Jeansson",
      "ja": "* フレドリックジーンズソン"
    },
    {
      "indent": 6,
      "text": "* Benjamin Kaduk",
      "ja": "* ベンジャミン・カドゥク"
    },
    {
      "indent": 6,
      "text": "* Torsten Lodderstedt",
      "ja": "* Torsten Lodderstedt"
    },
    {
      "indent": 6,
      "text": "* Kathleen Moriarty",
      "ja": "* キャスリーンモリアーティ"
    },
    {
      "indent": 6,
      "text": "* Mark Nottingham",
      "ja": "* マークノッティンガム"
    },
    {
      "indent": 6,
      "text": "* Erik Nygren",
      "ja": "* エリック・ニグレン"
    },
    {
      "indent": 6,
      "text": "* Mike Ounsworth",
      "ja": "* マイク・オンスワース"
    },
    {
      "indent": 6,
      "text": "* Lucas Pardue",
      "ja": "* ルーカス・パルド"
    },
    {
      "indent": 6,
      "text": "* Matt Peterson",
      "ja": "* マット・ピーターソン"
    },
    {
      "indent": 6,
      "text": "* Eric Rescorla",
      "ja": "* エリック・レスカラ"
    },
    {
      "indent": 6,
      "text": "* Justin Richer",
      "ja": "* ジャスティンリッチャー"
    },
    {
      "indent": 6,
      "text": "* Michael Richardson",
      "ja": "* マイケル・リチャードソン"
    },
    {
      "indent": 6,
      "text": "* Joe Salowey",
      "ja": "* ジョー・サロウィー"
    },
    {
      "indent": 6,
      "text": "* Rich Salz",
      "ja": "* リッチゾルツ"
    },
    {
      "indent": 6,
      "text": "* Mohit Sethi",
      "ja": "* Mohit sethi"
    },
    {
      "indent": 6,
      "text": "* Rifaat Shekh-Yusef",
      "ja": "* rifaat shekh-yusef"
    },
    {
      "indent": 6,
      "text": "* Travis Spencer",
      "ja": "* トラビススペンサー"
    },
    {
      "indent": 6,
      "text": "* Nick Sullivan",
      "ja": "* ニック・サリバン"
    },
    {
      "indent": 6,
      "text": "* Willy Tarreau",
      "ja": "* ウィリー・タロー"
    },
    {
      "indent": 6,
      "text": "* Martin Thomson",
      "ja": "* マーティン・トムソン"
    },
    {
      "indent": 6,
      "text": "* Peter Wu",
      "ja": "* ピーター・ウー"
    },
    {
      "indent": 6,
      "text": "* Hans Zandbelt",
      "ja": "* ハンス・ザンドベルト"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Brian Campbell\nPing Identity\nEmail: bcampbell@pingidentity.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Mike Bishop (editor)\nAkamai\nEmail: mbishop@evequefou.be",
      "raw": true,
      "ja": ""
    }
  ]
}