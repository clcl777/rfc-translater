{
  "title": {
    "text": "RFC 9449 - OAuth 2.0 Demonstrating Proof of Possession (DPoP)",
    "ja": "RFC 9449 - OAUTH2.0所有証明の実証（DPOP）"
  },
  "number": 9449,
  "created_at": "2023-09-08 23:47:45.660907+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                           D. Fett\nRequest for Comments: 9449                                      Authlete\nCategory: Standards Track                                    B. Campbell\nISSN: 2070-1721                                            Ping Identity\n                                                              J. Bradley\n                                                                  Yubico\n                                                          T. Lodderstedt\n                                                                 Tuconic\n                                                                M. Jones\n                                                  Self-Issued Consulting\n                                                                D. Waite\n                                                           Ping Identity\n                                                          September 2023",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "OAuth 2.0 Demonstrating Proof of Possession (DPoP)",
      "ja": "OAUTH2.0所有証明の実証（DPOP）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes a mechanism for sender-constraining OAuth 2.0 tokens via a proof-of-possession mechanism on the application level. This mechanism allows for the detection of replay attacks with access and refresh tokens.",
      "ja": "このドキュメントでは、アプリケーションレベルでのプルーフポッセッションメカニズムを介して、送信者を制御するOAUTH 2.0トークンのメカニズムについて説明します。このメカニズムにより、アクセストークンと更新されたリプレイ攻撃の検出が可能になります。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準トラックドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 7841のセクション2で入手できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9449.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https：//www.rfc-editor.org/info/rfc9449で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2023 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2023 IETF Trustおよび文書著者として特定された人。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、改訂されたBSDライセンスで説明されている保証なしで提供されるように、改訂されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Conventions and Terminology\n2.  Objectives\n3.  Concept\n4.  DPoP Proof JWTs\n  4.1.  The DPoP HTTP Header\n  4.2.  DPoP Proof JWT Syntax\n  4.3.  Checking DPoP Proofs\n5.  DPoP Access Token Request\n  5.1.  Authorization Server Metadata\n  5.2.  Client Registration Metadata\n6.  Public Key Confirmation\n  6.1.  JWK Thumbprint Confirmation Method\n  6.2.  JWK Thumbprint Confirmation Method in Token Introspection\n7.  Protected Resource Access\n  7.1.  The DPoP Authentication Scheme\n  7.2.  Compatibility with the Bearer Authentication Scheme\n  7.3.  Client Considerations\n8.  Authorization Server-Provided Nonce\n  8.1.  Nonce Syntax\n  8.2.  Providing a New Nonce Value\n9.  Resource Server-Provided Nonce\n10. Authorization Code Binding to a DPoP Key\n  10.1.  DPoP with Pushed Authorization Requests\n11. Security Considerations\n  11.1.  DPoP Proof Replay\n  11.2.  DPoP Proof Pre-generation\n  11.3.  DPoP Nonce Downgrade\n  11.4.  Untrusted Code in the Client Context\n  11.5.  Signed JWT Swapping\n  11.6.  Signature Algorithms\n  11.7.  Request Integrity\n  11.8.  Access Token and Public Key Binding\n  11.9.  Authorization Code and Public Key Binding\n  11.10. Hash Algorithm Agility\n  11.11. Binding to Client Identity\n12. IANA Considerations\n  12.1.  OAuth Access Token Types Registration\n  12.2.  OAuth Extensions Error Registration\n  12.3.  OAuth Parameters Registration\n  12.4.  HTTP Authentication Schemes Registration\n  12.5.  Media Type Registration\n  12.6.  JWT Confirmation Methods Registration\n  12.7.  JSON Web Token Claims Registration\n    12.7.1.  \"nonce\" Registration Update\n  12.8.  Hypertext Transfer Protocol (HTTP) Field Name Registration\n  12.9.  OAuth Authorization Server Metadata Registration\n  12.10. OAuth Dynamic Client Registration Metadata\n13. References\n  13.1.  Normative References\n  13.2.  Informative References\nAcknowledgements\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Demonstrating Proof of Possession (DPoP) is an application-level mechanism for sender-constraining OAuth [RFC6749] access and refresh tokens. It enables a client to prove the possession of a public/ private key pair by including a DPoP header in an HTTP request. The value of the header is a JSON Web Token (JWT) [RFC7519] that enables the authorization server to bind issued tokens to the public part of a client's key pair. Recipients of such tokens are then able to verify the binding of the token to the key pair that the client has demonstrated that it holds via the DPoP header, thereby providing some assurance that the client presenting the token also possesses the private key. In other words, the legitimate presenter of the token is constrained to be the sender that holds and proves possession of the private part of the key pair.",
      "ja": "所有証明（DPOP）の実証は、送信者が制約しているOAuth [RFC6749]アクセスと更新トークンのアプリケーションレベルのメカニズムです。これにより、クライアントは、HTTPリクエストにDPOPヘッダーを含めることにより、パブリック/プライベートキーペアの所有を証明できます。ヘッダーの値は、JSON Webトークン（JWT）[RFC7519]で、認証サーバーは発行されたトークンをクライアントのキーペアの公開部分にバインドできます。そのようなトークンの受信者は、クライアントがDPOPヘッダーを介して保持することを実証したキーペアへのトークンのバインディングを検証することができ、それにより、トークンを提示するクライアントが秘密鍵も所有していることを保証することができます。言い換えれば、トークンの合法的なプレゼンターは、キーペアの私的部分を保持し、証明する送信者に制約されています。"
    },
    {
      "indent": 3,
      "text": "The mechanism specified herein can be used in cases where other methods of sender-constraining tokens that utilize elements of the underlying secure transport layer, such as [RFC8705] or [TOKEN-BINDING], are not available or desirable. For example, due to a sub-par user experience of TLS client authentication in user agents and a lack of support for HTTP token binding, neither mechanism can be used if an OAuth client is an application that is dynamically downloaded and executed in a web browser (sometimes referred to as a \"single-page application\"). Additionally, applications that are installed and run directly on a user's device are well positioned to benefit from DPoP-bound tokens that guard against the misuse of tokens by a compromised or malicious resource. Such applications often have dedicated protected storage for cryptographic keys.",
      "ja": "本明細書で指定されているメカニズムは、[RFC8705]や[トークン結合]などの基礎となる安全な輸送層の要素を利用する他の送信者が制約するトークンの他の方法が利用可能または望ましくない場合に使用できます。たとえば、ユーザーエージェントのTLSクライアント認証のサブパーユーザーエクスペリエンスとHTTPトークンバインディングのサポートの欠如により、OAuthクライアントがWebブラウザーで動的にダウンロードおよび実行されるアプリケーションである場合、どちらのメカニズムも使用できません。（「シングルページアプリケーション」と呼ばれることもあります）。さらに、ユーザーのデバイスにインストールされて直接実行されるアプリケーションは、侵害または悪意のあるリソースによってトークンの誤用を防ぐDPOPに縛られたトークンの恩恵を受けるのに適しています。このようなアプリケーションには、多くの場合、暗号化キー用の専用保護ストレージがあります。"
    },
    {
      "indent": 3,
      "text": "DPoP can be used to sender-constrain access tokens regardless of the client authentication method employed, but DPoP itself is not used for client authentication. DPoP can also be used to sender-constrain refresh tokens issued to public clients (those without authentication credentials associated with the client_id).",
      "ja": "DPOPは、採用されたクライアント認証方法に関係なく、Sender-Constrainアクセストークンに使用できますが、DPOP自体はクライアント認証には使用されません。DPOPは、パブリッククライアント（Client_IDに関連付けられた認証資格情報のないもの）に発行された送信者とコストレーションの更新トークンにも使用できます。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions and Terminology",
      "section_title": true,
      "ja": "1.1. 慣習と用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 3,
      "text": "This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234].",
      "ja": "この仕様では、[RFC5234]の拡張されたBackus-Naurフォーム（ABNF）表記を使用します。"
    },
    {
      "indent": 3,
      "text": "This specification uses the terms \"access token\", \"refresh token\", \"authorization server\", \"resource server\", \"authorization endpoint\", \"authorization request\", \"authorization response\", \"token endpoint\", \"grant type\", \"access token request\", \"access token response\", \"client\", \"public client\", and \"confidential client\" defined by \"The OAuth 2.0 Authorization Framework\" [RFC6749].",
      "ja": "この仕様では、「アクセストークン」、「リフレッシュトークン」、「認証サーバー」、「リソースサーバー」、「認証エンドポイント」、「認証リクエスト」、「認証応答」、「トークンエンドポイント」、「グラントタイプ」という用語を使用します。「アクセストークンリクエスト」、「アクセストークン応答」、「クライアント」、「パブリッククライアント」、および「OAUTH 2.0 Authorization Framework」[RFC6749]で定義された「Confidential Client」。"
    },
    {
      "indent": 3,
      "text": "The terms \"request\", \"response\", \"header field\", and \"target URI\" are imported from [RFC9110].",
      "ja": "「要求」、「応答」、「ヘッダーフィールド」、および「ターゲットURI」という用語は、[RFC9110]からインポートされます。"
    },
    {
      "indent": 3,
      "text": "The terms \"JOSE\" and \"JOSE Header\" are imported from [RFC7515].",
      "ja": "「Jose」と「Jose Header」という用語は[RFC7515]からインポートされます。"
    },
    {
      "indent": 3,
      "text": "This document contains non-normative examples of partial and complete HTTP messages. Some examples use a single trailing backslash to indicate line wrapping for long values, as per [RFC8792]. The character and leading spaces on wrapped lines are not part of the value.",
      "ja": "このドキュメントには、部分的および完全なHTTPメッセージの非規範的な例が含まれています。いくつかの例は、[RFC8792]に従って、長い値のラインラッピングを示すために、単一の後続のバックスラッシュを使用しています。ラップラインのキャラクターと主要なスペースは、値の一部ではありません。"
    },
    {
      "indent": 0,
      "text": "2. Objectives",
      "section_title": true,
      "ja": "2. 目的"
    },
    {
      "indent": 3,
      "text": "The primary aim of DPoP is to prevent unauthorized or illegitimate parties from using leaked or stolen access tokens, by binding a token to a public key upon issuance and requiring that the client proves possession of the corresponding private key when using the token. This constrains the legitimate sender of the token to only the party with access to the private key and gives the server receiving the token added assurances that the sender is legitimately authorized to use it.",
      "ja": "DPOPの主な目的は、発行時にトークンを公開キーに拘束し、クライアントがトークンを使用するときに対応する秘密鍵の所有を証明することを要求することにより、不正なまたは違法な当事者が漏れたまたは盗まれたアクセストークンを使用することを防ぐことです。これにより、トークンの正当な送信者が秘密鍵にアクセスできるパーティーのみに制約し、トークンを受信するサーバーに、送信者がそれを使用することを合法的に許可されているという保証を追加しました。"
    },
    {
      "indent": 3,
      "text": "Access tokens that are sender-constrained via DPoP thus stand in contrast to the typical bearer token, which can be used by any party in possession of such a token. Although protections generally exist to prevent unintended disclosure of bearer tokens, unforeseen vectors for leakage have occurred due to vulnerabilities and implementation issues in other layers in the protocol or software stack (see, e.g., Compression Ratio Info-leak Made Easy (CRIME) [CRIME], Browser Reconnaissance and Exfiltration via Adaptive Compression of Hypertext (BREACH) [BREACH], Heartbleed [Heartbleed], and the Cloudflare parser bug [Cloudbleed]). There have also been numerous published token theft attacks on OAuth implementations themselves ([GitHub.Tokens] is just one high-profile example). DPoP provides a general defense in depth against the impact of unanticipated token leakage. DPoP is not, however, a substitute for a secure transport and MUST always be used in conjunction with HTTPS.",
      "ja": "したがって、DPOPを介して制御に制約されている送信者にアクセスしているアクセストークンは、このようなトークンを所持している当事者が使用できる典型的なベアラートークンとは対照的です。ベアラートークンの意図しない開示を防ぐために一般的に保護が存在しますが、プロトコルまたはソフトウェアスタックの他のレイヤーの脆弱性と実装の問題により、漏れの予期せぬベクターが発生しました（たとえば、圧縮比が簡単に作られている（犯罪）[犯罪）[犯罪を参照]、ハイパーテキスト（違反）[ブリーチ]、ハートブルド[ハートブルド]、およびクラウドフラアパーサーバグ[クラウドビード]の適応的圧縮によるブラウザ偵察と除去。また、OAuthの実装自体に対するトークン盗難攻撃が多数ありました（[github.tokens]は、1つの有名な例です）。DPOPは、予期しないトークン漏れの影響に対して、一般的な防御を深く提供します。ただし、DPOPは安全な輸送の代替品ではなく、常にHTTPSと組み合わせて使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The very nature of the typical OAuth protocol interaction necessitates that the client discloses the access token to the protected resources that it accesses. The attacker model in [SECURITY-TOPICS] describes cases where a protected resource might be counterfeit, malicious, or compromised and plays received tokens against other protected resources to gain unauthorized access. Audience-restricted access tokens (e.g., using the JWT [RFC7519] aud claim) can prevent such misuse. However, doing so in practice has proven to be prohibitively cumbersome for many deployments (despite extensions such as [RFC8707]). Sender-constraining access tokens is a more robust and straightforward mechanism to prevent such token replay at a different endpoint, and DPoP is an accessible application-layer means of doing so.",
      "ja": "典型的なOAUTHプロトコル相互作用の本質は、クライアントがアクセスする保護リソースへのアクセストークンを開示することを必要とします。[セキュリティトピック]の攻撃者モデルは、保護されたリソースが偽造、悪意、または侵害されている可能性のあるケースを説明し、他の保護されたリソースに対してトークンを受け取って許可されていないアクセスを獲得します。オーディエンス制限のアクセストークン（たとえば、JWT [RFC7519] AUDクレームを使用）は、そのような誤用を防ぐことができます。ただし、実際にそうすることは、多くの展開に対して法外に扱いにくいことが証明されています（[RFC8707]などの拡張にもかかわらず）。Sender-Constraining Access Tokenは、このようなトークンリプレイを別のエンドポイントで防ぐためのより堅牢で簡単なメカニズムであり、DPOPはアクセス可能なアプリケーション層の手段です。"
    },
    {
      "indent": 3,
      "text": "Due to the potential for cross-site scripting (XSS), browser-based OAuth clients bring to bear added considerations with respect to protecting tokens. The most straightforward XSS-based attack is for an attacker to exfiltrate a token and use it themselves completely independent of the legitimate client. A stolen access token is used for protected resource access, and a stolen refresh token is used for obtaining new access tokens. If the private key is non-extractable (as is possible with [W3C.WebCryptoAPI]), DPoP renders exfiltrated tokens alone unusable.",
      "ja": "クロスサイトスクリプト（XSS）の可能性があるため、ブラウザベースのOAUTHクライアントは、トークンの保護に関して追加の考慮事項をもたらします。最も簡単なXSSベースの攻撃は、攻撃者がトークンを除去し、正当なクライアントから完全に独立してそれを使用することです。盗まれたアクセストークンは、保護されたリソースアクセスに使用され、盗まれた更新トークンが新しいアクセストークンの取得に使用されます。秘密鍵が抽出不可能である場合（[W3C.WebCryptoapi]可能な限り）、DPOPはExflted Tokensだけを使用できません。"
    },
    {
      "indent": 3,
      "text": "XSS vulnerabilities also allow an attacker to execute code in the context of the browser-based client application and maliciously use a token indirectly through the client. That execution context has access to utilize the signing key; thus, it can produce DPoP proofs to use in conjunction with the token. At this application layer, there is most likely no feasible defense against this threat except generally preventing XSS; therefore, it is considered out of scope for DPoP.",
      "ja": "XSSの脆弱性により、攻撃者はブラウザベースのクライアントアプリケーションのコンテキストでコードを実行し、クライアントを介してトークンを間接的に使用することもできます。その実行コンテキストは、署名キーを利用するためにアクセスできます。したがって、トークンと組み合わせて使用するDPOPプルーフを生成できます。このアプリケーションレイヤーでは、一般にXSSを防ぐことを除いて、この脅威に対する実行可能な防御はおそらくない可能性が高いです。したがって、DPOPの範囲外と見なされます。"
    },
    {
      "indent": 3,
      "text": "Malicious XSS code executed in the context of the browser-based client application is also in a position to create DPoP proofs with timestamp values in the future and exfiltrate them in conjunction with a token. These stolen artifacts can later be used independent of the client application to access protected resources. To prevent this, servers can optionally require clients to include a server-chosen value into the proof that cannot be predicted by an attacker (nonce). In the absence of the optional nonce, the impact of pre-computed DPoP proofs is limited somewhat by the proof being bound to an access token on protected resource access. Because a proof covering an access token that does not yet exist cannot feasibly be created, access tokens obtained with an exfiltrated refresh token and pre-computed proofs will be unusable.",
      "ja": "ブラウザベースのクライアントアプリケーションのコンテキストで実行された悪意のあるXSSコードは、将来のタイムスタンプの値を持つDPOPプルーフを作成し、トークンと組み合わせてそれらを除去する立場にあります。これらの盗まれたアーティファクトは、クライアントアプリケーションとは無関係に保護されたリソースにアクセスするために使用できます。これを防ぐために、サーバーはオプションで、クライアントが攻撃者（NONCE）では予測できない証明にサーバーを選択した値を含めるように要求することができます。オプションのNonCEがない場合、事前に計算されたDPOPプルーフの影響は、保護されたリソースアクセスのアクセストークンにバインドされていることにより、いくらか制限されています。まだ存在しないアクセストークンをカバーするプルーフを実行可能に作成できないため、Exftlted Refreshトークンと事前計算された証明で取得したアクセストークンは使用できません。"
    },
    {
      "indent": 3,
      "text": "Additional security considerations are discussed in Section 11.",
      "ja": "追加のセキュリティ上の考慮事項については、セクション11で説明します。"
    },
    {
      "indent": 0,
      "text": "3. Concept",
      "section_title": true,
      "ja": "3. コンセプト"
    },
    {
      "indent": 3,
      "text": "The main data structure introduced by this specification is a DPoP proof JWT that is sent as a header in an HTTP request, as described in detail below. A client uses a DPoP proof JWT to prove the possession of a private key corresponding to a certain public key.",
      "ja": "この仕様で導入された主なデータ構造は、以下で詳しく説明するように、HTTP要求でヘッダーとして送信されるDPOP証明JWTです。クライアントは、DPOPプルーフJWTを使用して、特定の公開キーに対応する秘密鍵の所有を証明します。"
    },
    {
      "indent": 3,
      "text": "Roughly speaking, a DPoP proof is a signature over:",
      "ja": "大まかに言えば、DPOP証明は署名です："
    },
    {
      "indent": 3,
      "text": "* some data of the HTTP request to which it is attached,",
      "ja": "* 添付されているHTTP要求のデータ、"
    },
    {
      "indent": 3,
      "text": "* a timestamp,",
      "ja": "* タイムスタンプ、"
    },
    {
      "indent": 3,
      "text": "* a unique identifier,",
      "ja": "* 一意の識別子、"
    },
    {
      "indent": 3,
      "text": "* an optional server-provided nonce, and",
      "ja": "* オプションのサーバーが提供するNonce、および"
    },
    {
      "indent": 3,
      "text": "* a hash of the associated access token when an access token is present within the request.",
      "ja": "* リクエスト内にアクセストークンが存在するときの関連するアクセストークンのハッシュ。"
    },
    {
      "indent": 3,
      "text": "+--------+                                          +---------------+\n|        |--(A)-- Token Request ------------------->|               |\n| Client |        (DPoP Proof)                      | Authorization |\n|        |                                          |     Server    |\n|        |<-(B)-- DPoP-Bound Access Token ----------|               |\n|        |        (token_type=DPoP)                 +---------------+\n|        |\n|        |\n|        |                                          +---------------+\n|        |--(C)-- DPoP-Bound Access Token --------->|               |\n|        |        (DPoP Proof)                      |    Resource   |\n|        |                                          |     Server    |\n|        |<-(D)-- Protected Resource ---------------|               |\n|        |                                          +---------------+\n+--------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "Figure 1: Basic DPoP Flow",
      "ja": "図1：基本的なDPOPフロー"
    },
    {
      "indent": 3,
      "text": "The basic steps of an OAuth flow with DPoP (without the optional nonce) are shown in Figure 1.",
      "ja": "DPOPを使用したOAuthフローの基本的なステップ（オプションのNONCEなし）を図1に示します。"
    },
    {
      "indent": 3,
      "text": "A. In the token request, the client sends an authorization grant (e.g., an authorization code, refresh token, etc.) to the authorization server in order to obtain an access token (and potentially a refresh token). The client attaches a DPoP proof to the request in an HTTP header.",
      "ja": "A.トークンリクエストでは、クライアントは、アクセストークン（および潜在的に更新トークン）を取得するために、承認助成金（承認コード、更新トークンなど）を認証サーバーに送信します。クライアントは、HTTPヘッダーのリクエストにDPOPプルーフを添付します。"
    },
    {
      "indent": 3,
      "text": "B. The authorization server binds (sender-constrains) the access token to the public key claimed by the client in the DPoP proof; that is, the access token cannot be used without proving possession of the respective private key. If a refresh token is issued to a public client, it is also bound to the public key of the DPoP proof.",
      "ja": "B.承認サーバーは、DPOP証明でクライアントが請求した公開鍵へのアクセストークンにバインドされます（Sender-Constrains）。つまり、それぞれの秘密鍵の所有を証明せずにアクセストークンを使用することはできません。更新トークンがパブリッククライアントに発行された場合、DPOPプルーフの公開鍵にもバインドされます。"
    },
    {
      "indent": 3,
      "text": "C. To use the access token, the client has to prove possession of the private key by, again, adding a header to the request that carries a DPoP proof for that request. The resource server needs to receive information about the public key to which the access token is bound. This information may be encoded directly into the access token (for JWT-structured access tokens) or provided via token introspection endpoint (not shown). The resource server verifies that the public key to which the access token is bound matches the public key of the DPoP proof. It also verifies that the access token hash in the DPoP proof matches the access token presented in the request.",
      "ja": "C.アクセストークンを使用するには、クライアントは再び、その要求のDPOP証明を運ぶリクエストにヘッダーを追加することにより、秘密鍵の所有を証明する必要があります。リソースサーバーは、アクセストークンがバインドされている公開キーに関する情報を受信する必要があります。この情報は、アクセストークン（JWT構造のアクセストークンの場合）に直接エンコードされるか、トークン内省のエンドポイントを介して提供される場合があります（示されていません）。リソースサーバーは、アクセストークンがバインドされている公開キーがDPOPプルーフの公開キーと一致することを確認します。また、DPOPプルーフのアクセストークンハッシュが、リクエストで提示されたアクセストークンと一致することも確認します。"
    },
    {
      "indent": 3,
      "text": "D. The resource server refuses to serve the request if the signature check fails or if the data in the DPoP proof is wrong, e.g., the target URI does not match the URI claim in the DPoP proof JWT. The access token itself, of course, must also be valid in all other respects.",
      "ja": "D.リソースサーバーは、署名チェックが失敗した場合、またはDPOP証明のデータが間違っている場合、リクエストの提供を拒否します。もちろん、アクセストークン自体は、他のすべての点でも有効でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The DPoP mechanism presented herein is not a client authentication method. In fact, a primary use case of DPoP is for public clients (e.g., single-page applications and applications on a user's device) that do not use client authentication. Nonetheless, DPoP is designed to be compatible with private_key_jwt and all other client authentication methods.",
      "ja": "ここで提示されるDPOPメカニズムは、クライアント認証方法ではありません。実際、DPOPの主なユースケースは、クライアント認証を使用しないパブリッククライアント（ユーザーのデバイス上の単一ページアプリケーションとアプリケーションなど）を対象としています。それにもかかわらず、DPOPは、private_key_jwtおよび他のすべてのクライアント認証方法と互換性があるように設計されています。"
    },
    {
      "indent": 3,
      "text": "DPoP does not directly ensure message integrity, but it relies on the TLS layer for that purpose. See Section 11 for details.",
      "ja": "DPOPはメッセージの整合性を直接保証しませんが、その目的のためにTLSレイヤーに依存しています。詳細については、セクション11を参照してください。"
    },
    {
      "indent": 0,
      "text": "4. DPoP Proof JWTs",
      "section_title": true,
      "ja": "4. DPOP証明JWTS"
    },
    {
      "indent": 3,
      "text": "DPoP introduces the concept of a DPoP proof, which is a JWT created by the client and sent with an HTTP request using the DPoP header field. Each HTTP request requires a unique DPoP proof.",
      "ja": "DPOPは、クライアントによって作成されたJWTであり、DPOPヘッダーフィールドを使用してHTTP要求で送信されたDPOPプルーフの概念を紹介します。各HTTP要求には、一意のDPOPプルーフが必要です。"
    },
    {
      "indent": 3,
      "text": "A valid DPoP proof demonstrates to the server that the client holds the private key that was used to sign the DPoP proof JWT. This enables authorization servers to bind issued tokens to the corresponding public key (as described in Section 5) and enables resource servers to verify the key-binding of tokens that it receives (see Section 7.1), which prevents said tokens from being used by any entity that does not have access to the private key.",
      "ja": "有効なDPOPプルーフは、クライアントがDPOPプルーフJWTに署名するために使用された秘密鍵を保持していることをサーバーに示しています。これにより、認定サーバーは、発行されたトークンを対応する公開キーにバインドできます（セクション5で説明）。秘密鍵にアクセスできないエンティティ。"
    },
    {
      "indent": 3,
      "text": "The DPoP proof demonstrates possession of a key and, by itself, is not an authentication or access control mechanism. When presented in conjunction with a key-bound access token as described in Section 7.1, the DPoP proof provides additional assurance about the legitimacy of the client to present the access token. However, a valid DPoP proof JWT is not sufficient alone to make access control decisions.",
      "ja": "DPOPの証明は、キーの所持を示しており、それ自体が認証またはアクセス制御メカニズムではありません。セクション7.1で説明されているように、キーバウンドアクセストークンと組み合わせて提示された場合、DPOPプルーフは、アクセストークンを提示するクライアントの正当性に関する追加の保証を提供します。ただし、有効なDPOP証明JWTでは、アクセス制御の決定を下すのに十分ではありません。"
    },
    {
      "indent": 0,
      "text": "4.1. The DPoP HTTP Header",
      "section_title": true,
      "ja": "4.1. DPOP HTTPヘッダー"
    },
    {
      "indent": 3,
      "text": "A DPoP proof is included in an HTTP request using the following request header field.",
      "ja": "DPOPプルーフは、次の要求ヘッダーフィールドを使用してHTTP要求に含まれています。"
    },
    {
      "indent": 3,
      "text": "DPoP: A JWT that adheres to the structure and syntax of Section 4.2.",
      "ja": "DPOP：セクション4.2の構造と構文を順守するJWT。"
    },
    {
      "indent": 3,
      "text": "Figure 2 shows an example DPoP HTTP header field. The example uses \"\\\" line wrapping per [RFC8792].",
      "ja": "図2は、DPOP HTTPヘッダーフィールドの例を示しています。この例では、[RFC8792]ごとに「\\」ラインラップを使用します。"
    },
    {
      "indent": 3,
      "text": "DPoP: eyJ0eXAiOiJkcG9wK2p3dCIsImFsZyI6IkVTMjU2IiwiandrIjp7Imt0eSI6Ik\\ VDIiwieCI6Imw4dEZyaHgtMzR0VjNoUklDUkRZOXpDa0RscEJoRjQyVVFVZldWQVdCR\\ nMiLCJ5IjoiOVZFNGpmX09rX282NHpiVFRsY3VOSmFqSG10NnY5VERWclUwQ2R2R1JE\\ QSIsImNydiI6IlAtMjU2In19.eyJqdGkiOiItQndDM0VTYzZhY2MybFRjIiwiaHRtIj\\ oiUE9TVCIsImh0dSI6Imh0dHBzOi8vc2VydmVyLmV4YW1wbGUuY29tL3Rva2VuIiwia\\ WF0IjoxNTYyMjYyNjE2fQ.2-GxA6T8lP4vfrg8v-FdWP0A0zdrj8igiMLvqRMUvwnQg\\ 4PtFLbdLXiOSsX0x7NVY-FNyJK70nfbV37xRZT3Lg",
      "ja": "DPoP: eyJ0eXAiOiJkcG9wK2p3dCIsImFsZyI6IkVTMjU2IiwiandrIjp7Imt0eSI6Ik\\ VDIiwieCI6Imw4dEZyaHgtMzR0VjNoUklDUkRZOXpDa0RscEJoRjQyVVFVZldWQVdCR\\ nMiLCJ5IjoiOVZFNGpmX09rX282NHpiVFRsY3VOSmFqSG10NnY5VERWclUwQ2R2R1JE\\ QSIsImNydiI6IlAtMjU2In19.eyJqdGkiOiItQndDM0VTYzZhY2MybFRjIiwiaHRtIj\\ oiUE9TVCIsImh0dSI6Imh0dHBzOi8vc2VydmVyLmV4YW1wbGUuY29tL3Rva2VuIiwia\\ WF0IjoxNTYyMjYyNjE2fQ.2-GxA6T8lP4vfrg8v-FdWP0A0zdrj8igiMLvqRMUvwnQg\\ 4PtFLbdLXiOSsX0x7NVY-FNyJK70nfbV37xRZT3Lg"
    },
    {
      "indent": 23,
      "text": "Figure 2: Example DPoP Header",
      "ja": "図2：DPOPヘッダーの例"
    },
    {
      "indent": 3,
      "text": "Note that per [RFC9110], header field names are case insensitive; thus, DPoP, DPOP, dpop, etc., are all valid and equivalent header field names. However, case is significant in the header field value.",
      "ja": "[rfc9110]ごとに、ヘッダーフィールド名はケースの鈍感であることに注意してください。したがって、DPOP、DPOP、DPOPなどはすべて有効かつ同等のヘッダーフィールド名です。ただし、ヘッダーフィールド値ではケースが重要です。"
    },
    {
      "indent": 3,
      "text": "The DPoP HTTP header field value uses the token68 syntax defined in Section 11.2 of [RFC9110] and is repeated below in Figure 3 for ease of reference.",
      "ja": "DPOP HTTPヘッダーフィールド値は、[RFC9110]のセクション11.2で定義されているtoken68構文を使用し、参照を簡単にするために図3で以下に繰り返します。"
    },
    {
      "indent": 3,
      "text": "DPoP       = token68\ntoken68    = 1*( ALPHA / DIGIT /\n                 \"-\" / \".\" / \"_\" / \"~\" / \"+\" / \"/\" ) *\"=\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 3: DPoP Header Field ABNF",
      "ja": "図3：DPOPヘッダーフィールドABNF"
    },
    {
      "indent": 0,
      "text": "4.2. DPoP Proof JWT Syntax",
      "section_title": true,
      "ja": "4.2. DPOP証明JWT構文"
    },
    {
      "indent": 3,
      "text": "A DPoP proof is a JWT [RFC7519] that is signed (using JSON Web Signature (JWS) [RFC7515]) with a private key chosen by the client (see below). The JOSE Header of a DPoP JWT MUST contain at least the following parameters:",
      "ja": "DPOPプルーフは、クライアントが選択したプライベートキー（以下を参照）を備えた署名（JSON Web Signature（JWS）[RFC7515]を使用）に署名されたJWT [RFC7519]です。DPOP JWTのホセヘッダーには、少なくとも次のパラメーターが含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "typ: A field with the value dpop+jwt, which explicitly types the DPoP proof JWT as recommended in Section 3.11 of [RFC8725].",
      "ja": "型：[RFC8725]のセクション3.11で推奨されるように、DPOP証明JWTを明示的に入力する値DPOP JWTのフィールド。"
    },
    {
      "indent": 3,
      "text": "alg: An identifier for a JWS asymmetric digital signature algorithm from [IANA.JOSE.ALGS]. It MUST NOT be none or an identifier for a symmetric algorithm (Message Authentication Code (MAC)).",
      "ja": "アルグ：[iana.jose.algs]のJWS非対称デジタル署名アルゴリズムの識別子。対称アルゴリズム（メッセージ認証コード（MAC））の識別子や識別子であってはなりません。"
    },
    {
      "indent": 3,
      "text": "jwk: Represents the public key chosen by the client in JSON Web Key (JWK) [RFC7517] format as defined in Section 4.1.3 of [RFC7515]. It MUST NOT contain a private key.",
      "ja": "JWK：[RFC7515]のセクション4.1.3で定義されているように、JSON Webキー（JWK）[RFC7517]形式のクライアントが選択した公開キーを表します。秘密鍵を含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "The payload of a DPoP proof MUST contain at least the following claims:",
      "ja": "DPOP証明のペイロードには、少なくとも次のクレームが含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "jti: Unique identifier for the DPoP proof JWT. The value MUST be assigned such that there is a negligible probability that the same value will be assigned to any other DPoP proof used in the same context during the time window of validity. Such uniqueness can be accomplished by encoding (base64url or any other suitable encoding) at least 96 bits of pseudorandom data or by using a version 4 Universally Unique Identifier (UUID) string according to [RFC4122]. The jti can be used by the server for replay detection and prevention; see Section 11.1.",
      "ja": "JTI：DPOPプルーフJWTの一意の識別子。値は、有効性の時間枠で同じコンテキストで使用される他のDPOP証明に同じ値が割り当てられるという無視できる確率があるように割り当てる必要があります。このような一意性は、少なくとも96ビットの擬似ランダムデータをエンコード（base64urlまたはその他の適切なエンコード）するか、[RFC4122]に従ってバージョン4の普遍的に一意の識別子（UUID）文字列を使用することで達成できます。JTIは、リプレイの検出と予防のためにサーバーで使用できます。セクション11.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "htm: The value of the HTTP method (Section 9.1 of [RFC9110]) of the request to which the JWT is attached.",
      "ja": "HTM：JWTが添付されている要求のHTTPメソッド（[RFC9110]のセクション9.1）の値。"
    },
    {
      "indent": 3,
      "text": "htu: The HTTP target URI (Section 7.1 of [RFC9110]) of the request to which the JWT is attached, without query and fragment parts.",
      "ja": "HTU：JWTが添付されている要求のHTTPターゲットURI（[RFC9110]のセクション7.1）は、クエリとフラグメントパーツなしで。"
    },
    {
      "indent": 3,
      "text": "iat: Creation timestamp of the JWT (Section 4.1.6 of [RFC7519]).",
      "ja": "IAT：JWTの作成タイムスタンプ（[RFC7519]のセクション4.1.6）。"
    },
    {
      "indent": 3,
      "text": "When the DPoP proof is used in conjunction with the presentation of an access token in protected resource access (see Section 7), the DPoP proof MUST also contain the following claim:",
      "ja": "DPOPプルーフが、保護されたリソースアクセスでアクセストークンの提示と併せて使用される場合（セクション7を参照）、DPOPプルーフには次のクレームも含める必要があります。"
    },
    {
      "indent": 3,
      "text": "ath: Hash of the access token. The value MUST be the result of a base64url encoding (as defined in Section 2 of [RFC7515]) the SHA-256 [SHS] hash of the ASCII encoding of the associated access token's value.",
      "ja": "ATH：アクセストークンのハッシュ。値は、関連するアクセストークンの値のASCIIエンコードのSHA-256 [SHS]ハッシュのsha-256 [shs]ハッシュのbase64urlエンコードの結果でなければなりません。"
    },
    {
      "indent": 3,
      "text": "When the authentication server or resource server provides a DPoP-Nonce HTTP header in a response (see Sections 8 and 9), the DPoP proof MUST also contain the following claim:",
      "ja": "認証サーバーまたはリソースサーバーが応答でDPOP-Nonce HTTPヘッダーを提供する場合（セクション8および9を参照）、DPOPプルーフには次のクレームも含める必要があります。"
    },
    {
      "indent": 3,
      "text": "nonce: A recent nonce provided via the DPoP-Nonce HTTP header.",
      "ja": "Nonce：DPOP-Nonce HTTPヘッダーを介して提供された最近のNonCe。"
    },
    {
      "indent": 3,
      "text": "A DPoP proof MAY contain other JOSE Header Parameters or claims as defined by extension, profile, or deployment-specific requirements.",
      "ja": "DPOPプルーフには、他のホセヘッダーパラメーターまたは拡張、プロファイル、または展開固有の要件によって定義されるクレームが含まれている場合があります。"
    },
    {
      "indent": 3,
      "text": "Figure 4 is a conceptual example showing the decoded content of the DPoP proof in Figure 2. The JSON of the JWT header and payload are shown, but the signature part is omitted. As usual, line breaks and extra spaces are included for formatting and readability.",
      "ja": "図4は、図2のDPOP証明のデコードされたコンテンツを示す概念的例です。JWTヘッダーとペイロードのJSONが示されていますが、署名部分は省略されています。いつものように、フォーマットと読みやすさのために、ラインブレークと余分なスペースが含まれています。"
    },
    {
      "indent": 3,
      "text": "{\n  \"typ\":\"dpop+jwt\",\n  \"alg\":\"ES256\",\n  \"jwk\": {\n    \"kty\":\"EC\",\n    \"x\":\"l8tFrhx-34tV3hRICRDY9zCkDlpBhF42UQUfWVAWBFs\",\n    \"y\":\"9VE4jf_Ok_o64zbTTlcuNJajHmt6v9TDVrU0CdvGRDA\",\n    \"crv\":\"P-256\"\n  }\n}\n.\n{\n  \"jti\":\"-BwC3ESc6acc2lTc\",\n  \"htm\":\"POST\",\n  \"htu\":\"https://server.example.com/token\",\n  \"iat\":1562262616\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 4: Example JWT Content of a DPoP Proof",
      "ja": "図4：DPOPプルーフのJWTコンテンツの例"
    },
    {
      "indent": 3,
      "text": "Of the HTTP request, only the HTTP method and URI are included in the DPoP JWT; therefore, only these two message parts are covered by the DPoP proof. The idea is to sign just enough of the HTTP data to provide reasonable proof of possession with respect to the HTTP request. This design approach of using only a minimal subset of the HTTP header data is to avoid the substantial difficulties inherent in attempting to normalize HTTP messages. Nonetheless, DPoP proofs can be extended to contain other information of the HTTP request (see also Section 11.7).",
      "ja": "HTTP要求のうち、HTTPメソッドとURIのみがDPOP JWTに含まれています。したがって、これら2つのメッセージパーツのみがDPOPプルーフでカバーされます。アイデアは、HTTPリクエストに関して合理的な所有の証明を提供するために、HTTPデータの十分な署名に署名することです。HTTPヘッダーデータの最小限のサブセットのみを使用するこの設計アプローチは、HTTPメッセージの正規化に固有の実質的な困難を回避するためです。それにもかかわらず、DPOPプルーフを拡張して、HTTP要求の他の情報を含めることができます（セクション11.7も参照）。"
    },
    {
      "indent": 0,
      "text": "4.3. Checking DPoP Proofs",
      "section_title": true,
      "ja": "4.3. DPOPプルーフの確認"
    },
    {
      "indent": 3,
      "text": "To validate a DPoP proof, the receiving server MUST ensure the following:",
      "ja": "DPOP証明を検証するには、受信サーバーは次のことを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. There is not more than one DPoP HTTP request header field. 2. The DPoP HTTP request header field value is a single and well-formed JWT. 3. All required claims per Section 4.2 are contained in the JWT. 4. The typ JOSE Header Parameter has the value dpop+jwt. 5. The alg JOSE Header Parameter indicates a registered asymmetric digital signature algorithm [IANA.JOSE.ALGS], is not none, is supported by the application, and is acceptable per local policy. 6. The JWT signature verifies with the public key contained in the jwk JOSE Header Parameter. 7. The jwk JOSE Header Parameter does not contain a private key. 8. The htm claim matches the HTTP method of the current request. 9. The htu claim matches the HTTP URI value for the HTTP request in which the JWT was received, ignoring any query and fragment parts. 10. If the server provided a nonce value to the client, the nonce claim matches the server-provided nonce value. 11. The creation time of the JWT, as determined by either the iat claim or a server managed timestamp via the nonce claim, is within an acceptable window (see Section 11.1). 12. If presented to a protected resource in conjunction with an access token, * ensure that the value of the ath claim equals the hash of that access token, and * confirm that the public key to which the access token is bound matches the public key from the DPoP proof.",
      "ja": "1. DPOP HTTPリクエストヘッダーフィールドは1つ以下です。2. DPOP HTTPリクエストヘッダーフィールド値は、単一でよく形成されたJWTです。3.セクション4.2ごとに必要なすべての請求は、JWTに含まれています。4. Typhose Headerパラメーターには、値DPOP JWTがあります。5.アルグホセヘッダーパラメーターは、登録されている非対称デジタル署名アルゴリズム[IANA.jose.algs]を示し、いずれにせず、アプリケーションによってサポートされ、ローカルポリシーごとに受け入れられます。6. JWT署名は、JWKホセヘッダーパラメーターに含まれる公開キーで検証されます。7. JWKホセヘッダーパラメーターには、秘密鍵が含まれていません。8. HTMクレームは、現在の要求のHTTPメソッドと一致します。9. HTUクレームは、JWTが受信されたHTTP要求のHTTP URI値と一致し、クエリおよびフラグメントパーツを無視します。10.サーバーがクライアントにNonCE値を提供した場合、NonCeクレームはサーバーが提供するNonCe値と一致します。11. JWTの作成時間は、IATクレームまたはNonCEクレームを介してマネージドタイムスタンプのいずれかによって決定されるように、許容可能なウィンドウ内にあります（セクション11.1を参照）。12.アクセストークンと組み合わせて保護されたリソースに提示された場合 * ATHクレームの値がそのアクセストークンのハッシュに等しいことを確認し、アクセストークンがバインドされている公開キーが公開キーと一致することを確認しますDPOP証明から。"
    },
    {
      "indent": 3,
      "text": "To reduce the likelihood of false negatives, servers SHOULD employ syntax-based normalization (Section 6.2.2 of [RFC3986]) and scheme-based normalization (Section 6.2.3 of [RFC3986]) before comparing the htu claim.",
      "ja": "偽陰性の可能性を減らすために、サーバーは、HTUクレームを比較する前に、構文ベースの正規化（[RFC3986]のセクション6.2.2）とスキームベースの正規化（[RFC3986]のセクション6.2.3）を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "These checks may be performed in any order.",
      "ja": "これらのチェックは、任意の順序で実行できます。"
    },
    {
      "indent": 0,
      "text": "5. DPoP Access Token Request",
      "section_title": true,
      "ja": "5. DPOPアクセストークンリクエスト"
    },
    {
      "indent": 3,
      "text": "To request an access token that is bound to a public key using DPoP, the client MUST provide a valid DPoP proof JWT in a DPoP header when making an access token request to the authorization server's token endpoint. This is applicable for all access token requests regardless of grant type (e.g., the common authorization_code and refresh_token grant types and extension grants such as the JWT authorization grant [RFC7523]). The HTTP request shown in Figure 5 illustrates such an access token request using an authorization code grant with a DPoP proof JWT in the DPoP header. Figure 5 uses \"\\\" line wrapping per [RFC8792].",
      "ja": "DPOPを使用して公開キーにバインドされているアクセストークンを要求するには、クライアントは、Authorization Serverのトークンエンドポイントにアクセストークン要求を行う際に、DPOPヘッダーに有効なDPOPプルーフJWTを提供する必要があります。これは、助成金の種類に関係なく、すべてのアクセストークン要求に適用されます（たとえば、一般的なAuthorization_CodeおよびREFRESH_TOKEN GRANTタイプおよびJWT認証助成金[RFC7523]などの拡張助成金）。図5に示すHTTP要求は、DPOPヘッダーにDPOPプルーフJWTを備えた認証コード助成金を使用して、このようなアクセストークン要求を示しています。図5は、[RFC8792]ごとに「\\」ラインラッピングを使用しています。"
    },
    {
      "indent": 3,
      "text": "POST /token HTTP/1.1 Host: server.example.com Content-Type: application/x-www-form-urlencoded DPoP: eyJ0eXAiOiJkcG9wK2p3dCIsImFsZyI6IkVTMjU2IiwiandrIjp7Imt0eSI6Ik\\ VDIiwieCI6Imw4dEZyaHgtMzR0VjNoUklDUkRZOXpDa0RscEJoRjQyVVFVZldWQVdCR\\ nMiLCJ5IjoiOVZFNGpmX09rX282NHpiVFRsY3VOSmFqSG10NnY5VERWclUwQ2R2R1JE\\ QSIsImNydiI6IlAtMjU2In19.eyJqdGkiOiItQndDM0VTYzZhY2MybFRjIiwiaHRtIj\\ oiUE9TVCIsImh0dSI6Imh0dHBzOi8vc2VydmVyLmV4YW1wbGUuY29tL3Rva2VuIiwia\\ WF0IjoxNTYyMjYyNjE2fQ.2-GxA6T8lP4vfrg8v-FdWP0A0zdrj8igiMLvqRMUvwnQg\\ 4PtFLbdLXiOSsX0x7NVY-FNyJK70nfbV37xRZT3Lg",
      "ja": "FNYJK70NFBV37XRZT3LG"
    },
    {
      "indent": 3,
      "text": "grant_type=authorization_code\\ &client_id=s6BhdRkqt\\ &code=SplxlOBeZQQYbYS6WxSbIA &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb\\ &code_verifier=bEaL42izcC-o-xBk0K2vuJ6U-y1p9r_wW2dFWIWgjz-",
      "ja": "grant_type = authorization_code \\＆client_id = s6bhdrkqt \\＆code = splxlobezqqybys6wxsbia＆redirect_uri = https％3a％2f％2ffclient％2eexample％2ecom％2fcb \\＆code_verifier = beal42izcccccccccccbidpidpizcccccccccbdi-xbuj6u-xbuj6u-xbuj6u-xbuj6u-xbuj6u-xbuj6u-xbuj6u-xbuj6u-xbuj6u-xbuJ fwiwgjz-"
    },
    {
      "indent": 4,
      "text": "Figure 5: Token Request for a DPoP Sender-Constrained Token Using an Authorization Code",
      "ja": "図5：承認コードを使用したDPOP送信者に制約のトークンのトークンリクエスト"
    },
    {
      "indent": 3,
      "text": "The DPoP HTTP header field MUST contain a valid DPoP proof JWT. If the DPoP proof is invalid, the authorization server issues an error response per Section 5.2 of [RFC6749] with invalid_dpop_proof as the value of the error parameter.",
      "ja": "DPOP HTTPヘッダーフィールドには、有効なDPOPプルーフJWTが含まれている必要があります。DPOP証明が無効である場合、Authorization Serverは、[RFC6749]のセクション5.2ごとにエラー応答を発行します。"
    },
    {
      "indent": 3,
      "text": "To sender-constrain the access token after checking the validity of the DPoP proof, the authorization server associates the issued access token with the public key from the DPoP proof, which can be accomplished as described in Section 6. A token_type of DPoP MUST be included in the access token response to signal to the client that the access token was bound to its DPoP key and can be used as described in Section 7.1. The example response shown in Figure 6 illustrates such a response.",
      "ja": "DPOPプルーフの有効性を確認した後、送信者がアクセストークンを制御するために、Authorization Serverは、発行されたアクセストークンをDPOPプルーフの公開鍵と関連付けます。アクセストークンでは、アクセストークンがDPOPキーにバインドされており、セクション7.1で説明されているように使用できるというクライアントへの信号への応答。図6に示す応答の例は、そのような応答を示しています。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: no-store",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "{\n \"access_token\": \"Kz~8mXK1EalYznwH-LC-1fBAo.4Ljp~zsPE_NeO.gxU\",\n \"token_type\": \"DPoP\",\n \"expires_in\": 2677,\n \"refresh_token\": \"Q..Zkm29lexi8VnWg2zPW1x-tgGad0Ibc3s3EwM_Ni4-g\"\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 6: Access Token Response",
      "ja": "図6：アクセストークン応答"
    },
    {
      "indent": 3,
      "text": "The example response in Figure 6 includes a refresh token that the client can use to obtain a new access token when the previous one expires. Refreshing an access token is a token request using the refresh_token grant type made to the authorization server's token endpoint. As with all access token requests, the client makes it a DPoP request by including a DPoP proof, as shown in Figure 7. Figure 7 uses \"\\\" line wrapping per [RFC8792].",
      "ja": "図6の例の応答には、クライアントが前のものが期限切れになったときに新しいアクセストークンを取得するために使用できる更新トークンが含まれています。アクセストークンを更新するのは、Authorization Serverのトークンエンドポイントに作成されたREFRESH_TOKEN GRANTタイプを使用したトークンリクエストです。すべてのアクセストークン要求と同様に、図7に示すように、クライアントはDPOPプルーフを含めることによりDPOP要求になります。図7は[RFC8792]ごとに「\\」ラインラップを使用します。"
    },
    {
      "indent": 3,
      "text": "POST /token HTTP/1.1\nHost: server.example.com\nContent-Type: application/x-www-form-urlencoded\nDPoP: eyJ0eXAiOiJkcG9wK2p3dCIsImFsZyI6IkVTMjU2IiwiandrIjp7Imt0eSI6Ik\\\n VDIiwieCI6Imw4dEZyaHgtMzR0VjNoUklDUkRZOXpDa0RscEJoRjQyVVFVZldWQVdCR\\\n nMiLCJ5IjoiOVZFNGpmX09rX282NHpiVFRsY3VOSmFqSG10NnY5VERWclUwQ2R2R1JE\\\n QSIsImNydiI6IlAtMjU2In19.eyJqdGkiOiItQndDM0VTYzZhY2MybFRjIiwiaHRtIj\\\n oiUE9TVCIsImh0dSI6Imh0dHBzOi8vc2VydmVyLmV4YW1wbGUuY29tL3Rva2VuIiwia\\\n WF0IjoxNTYyMjY1Mjk2fQ.pAqut2IRDm_De6PR93SYmGBPXpwrAk90e8cP2hjiaG5Qs\\\n GSuKDYW7_X620BxqhvYC8ynrrvZLTk41mSRroapUA",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "grant_type=refresh_token\\ &client_id=s6BhdRkqt\\ &refresh_token=Q..Zkm29lexi8VnWg2zPW1x-tgGad0Ibc3s3EwM_Ni4-g",
      "ja": "grant_type = refresh_token \\＆client_id = s6bhdrkqt \\＆refresh_token = q..zkm29lexi8vnwg2zpw1x-tggad0ibc3s3ewm_ni4-g"
    },
    {
      "indent": 4,
      "text": "Figure 7: Token Request for a DPoP-Bound Token Using a Refresh Token",
      "ja": "図7：リフレッシュトークンを使用したDPOPバウンドトークンのトークンリクエスト"
    },
    {
      "indent": 3,
      "text": "When an authorization server supporting DPoP issues a refresh token to a public client that presents a valid DPoP proof at the token endpoint, the refresh token MUST be bound to the respective public key. The binding MUST be validated when the refresh token is later presented to get new access tokens. As a result, such a client MUST present a DPoP proof for the same key that was used to obtain the refresh token each time that refresh token is used to obtain a new access token. The implementation details of the binding of the refresh token are at the discretion of the authorization server. Since the authorization server both produces and validates its refresh tokens, there is no interoperability consideration in the specific details of the binding.",
      "ja": "DPOPをサポートする承認サーバーが、トークンエンドポイントで有効なDPOPプルーフを提示するパブリッククライアントに更新トークンを発行する場合、更新トークンはそれぞれの公開キーにバインドする必要があります。新しいアクセストークンを取得するために、リフレッシュトークンが後で提示されたときにバインディングを検証する必要があります。その結果、このようなクライアントは、更新トークンが新しいアクセストークンを取得するために使用されるたびに更新トークンを取得するために使用された同じキーのDPOP証明を提示する必要があります。更新トークンのバインディングの実装の詳細は、承認サーバーの裁量にあります。承認サーバーは、更新トークンを生成および検証するため、バインディングの特定の詳細に相互運用性の考慮事項はありません。"
    },
    {
      "indent": 3,
      "text": "An authorization server MAY elect to issue access tokens that are not DPoP bound, which is signaled to the client with a value of Bearer in the token_type parameter of the access token response per [RFC6750]. For a public client that is also issued a refresh token, this has the effect of DPoP-binding the refresh token alone, which can improve the security posture even when protected resources are not updated to support DPoP.",
      "ja": "Authorization Serverは、DPOPバウンドではないアクセストークンを発行することを選択できます。これは、[RFC6750]ごとにアクセストークン応答のtoken_typeパラメーターにBEARERの値でクライアントに信号を送信されます。更新トークンも発行されているパブリッククライアントの場合、これはDPOPバインドのみのリフレッシュトークンだけで、保護されたリソースがDPOPをサポートするために更新されない場合でもセキュリティ姿勢を改善できます。"
    },
    {
      "indent": 3,
      "text": "If the access token response contains a different token_type value than DPoP, the access token protection provided by DPoP is not given. The client MUST discard the response in this case if this protection is deemed important for the security of the application; otherwise, the client may continue as in a regular OAuth interaction.",
      "ja": "アクセストークン応答にDPOPとは異なるtoken_type値が含まれている場合、DPOPが提供するアクセストークン保護は与えられません。クライアントは、この保護がアプリケーションのセキュリティにとって重要であるとみなされる場合、この場合に応答を廃棄する必要があります。それ以外の場合、クライアントは通常のOAuth相互作用のように続行する場合があります。"
    },
    {
      "indent": 3,
      "text": "Refresh tokens issued to confidential clients (those having established authentication credentials with the authorization server) are not bound to the DPoP proof public key because they are already sender-constrained with a different existing mechanism. The OAuth 2.0 Authorization Framework [RFC6749] already requires that an authorization server bind refresh tokens to the client to which they were issued and that confidential clients authenticate to the authorization server when presenting a refresh token. As a result, such refresh tokens are sender-constrained by way of the client identifier and the associated authentication requirement. This existing sender-constraining mechanism is more flexible (e.g., it allows credential rotation for the client without invalidating refresh tokens) than binding directly to a particular public key.",
      "ja": "Confidential Clients（Authorization Serverで認証資格情報を確立したもの）に発行された更新トークンは、DPOPプルーフ公開キーに拘束されていません。OAUTH 2.0 Authorization Framework [RFC6749]では、承認サーバーがリフレッシュトークンを発行したクライアントにバインドし、更新トークンを提示するときに承認サーバーに認証するConfidentialクライアントが既に要求されています。その結果、このような更新トークンは、クライアントの識別子と関連する認証要件によって、送信者に制約されています。この既存の送信者制約メカニズムは、特定の公開キーに直接結合するよりも、より柔軟になります（たとえば、リフレッシュトークンを無効にすることなくクライアントの資格情報の回転を許可します）。"
    },
    {
      "indent": 0,
      "text": "5.1. Authorization Server Metadata",
      "section_title": true,
      "ja": "5.1. 承認サーバーメタデータ"
    },
    {
      "indent": 3,
      "text": "This document introduces the following authorization server metadata [RFC8414] parameter to signal support for DPoP in general and the specific JWS alg values the authorization server supports for DPoP proof JWTs.",
      "ja": "このドキュメントでは、次の承認サーバーメタデータ[RFC8414]パラメーターを導入して、一般的にDPOPのサポートを信号し、特定のJWS ALG値は、DPOPプルーフJWTSの認証サーバーがサポートしています。"
    },
    {
      "indent": 3,
      "text": "dpop_signing_alg_values_supported: A JSON array containing a list of the JWS alg values (from the [IANA.JOSE.ALGS] registry) supported by the authorization server for DPoP proof JWTs.",
      "ja": "DPOP_SINGING_ALG_VALUES_SUPPORTED：DPOP証明JWTSの認証サーバーによってサポートされているJWS ALG値のリスト（[iana.jose.algs]レジストリから）を含むJSONアレイ。"
    },
    {
      "indent": 0,
      "text": "5.2. Client Registration Metadata",
      "section_title": true,
      "ja": "5.2. クライアント登録メタデータ"
    },
    {
      "indent": 3,
      "text": "The Dynamic Client Registration Protocol [RFC7591] defines an API for dynamically registering OAuth 2.0 client metadata with authorization servers. The metadata defined by [RFC7591], and registered extensions to it, also imply a general data model for clients that is useful for authorization server implementations even when the Dynamic Client Registration Protocol isn't in play. Such implementations will typically have some sort of user interface available for managing client configuration.",
      "ja": "動的クライアント登録プロトコル[RFC7591]は、OAUTH 2.0クライアントメタデータを認証サーバーで動的に登録するためのAPIを定義します。[RFC7591]によって定義されたメタデータ、および拡張拡張機能は、ダイナミッククライアント登録プロトコルが再生されていない場合でも、承認サーバーの実装に役立つクライアントの一般的なデータモデルでもあります。このような実装では、通常、クライアント構成の管理に利用できるような種類のユーザーインターフェイスがあります。"
    },
    {
      "indent": 3,
      "text": "This document introduces the following client registration metadata [RFC7591] parameter to indicate that the client always uses DPoP when requesting tokens from the authorization server.",
      "ja": "このドキュメントでは、次のクライアント登録メタデータ[RFC7591]パラメーターを導入して、クライアントが認証サーバーからトークンを要求するときに常にDPOPを使用することを示します。"
    },
    {
      "indent": 3,
      "text": "dpop_bound_access_tokens: A boolean value specifying whether the client always uses DPoP for token requests. If omitted, the default value is false.",
      "ja": "DPOP_BOUND_ACCESS_TOKENS：クライアントが常にトークン要求にDPOPを使用するかどうかを指定するブール値。省略した場合、デフォルト値はfalseです。"
    },
    {
      "indent": 3,
      "text": "If the value is true, the authorization server MUST reject token requests from the client that do not contain the DPoP header.",
      "ja": "値が真である場合、承認サーバーは、DPOPヘッダーを含まないクライアントからトークンリクエストを拒否する必要があります。"
    },
    {
      "indent": 0,
      "text": "6. Public Key Confirmation",
      "section_title": true,
      "ja": "6. 公開鍵の確認"
    },
    {
      "indent": 3,
      "text": "Resource servers MUST be able to reliably identify whether an access token is DPoP-bound and ascertain sufficient information to verify the binding to the public key of the DPoP proof (see Section 7.1). Such a binding is accomplished by associating the public key with the token in a way that can be accessed by the protected resource, such as embedding the JWK hash in the issued access token directly, using the syntax described in Section 6.1, or through token introspection as described in Section 6.2. Other methods of associating a public key with an access token are possible per an agreement by the authorization server and the protected resource; however, they are beyond the scope of this specification.",
      "ja": "リソースサーバーは、アクセストークンがDPOPバウンドであるかどうかを確実に識別し、DPOP証明の公開鍵へのバインディングを検証するのに十分な情報を確認できる必要があります（セクション7.1を参照）。このようなバインディングは、公開鍵を、発行されたアクセストークンに直接埋め込むなど、保護されたリソースでアクセスできる方法でトークンを関連付けることによって達成されます。セクション6.2で説明されているように。公開キーをアクセストークンに関連付ける他の方法は、認証サーバーと保護されたリソースによって契約に応じて可能です。ただし、これらはこの仕様の範囲を超えています。"
    },
    {
      "indent": 3,
      "text": "Resource servers supporting DPoP MUST ensure that the public key from the DPoP proof matches the one bound to the access token.",
      "ja": "DPOPをサポートするリソースサーバーは、DPOPプルーフの公開キーがアクセストークンにバインドされたものと一致することを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1. JWK Thumbprint Confirmation Method",
      "section_title": true,
      "ja": "6.1. JWK Thumbprint確認方法"
    },
    {
      "indent": 3,
      "text": "When access tokens are represented as JWTs [RFC7519], the public key information is represented using the jkt confirmation method member defined herein. To convey the hash of a public key in a JWT, this specification introduces the following JWT Confirmation Method [RFC7800] member for use under the cnf claim.",
      "ja": "アクセストークンがJWTS [RFC7519]として表される場合、公開キー情報は、本明細書に定義されているJKT確認方法メンバーを使用して表されます。JWTの公開鍵のハッシュを伝えるために、この仕様では、CNFクレームの下で使用するための次のJWT確認方法[RFC7800]メンバーを紹介します。"
    },
    {
      "indent": 3,
      "text": "jkt: JWK SHA-256 Thumbprint confirmation method. The value of the jkt member MUST be the base64url encoding (as defined in [RFC7515]) of the JWK SHA-256 Thumbprint (according to [RFC7638]) of the DPoP public key (in JWK format) to which the access token is bound.",
      "ja": "JKT：JWK SHA-256 Thumbprint確認方法。JKTメンバーの値は、DPOP公開キー（JWK形式）のJWK SHA-256 ThumbPrint（[RFC7638]に従って）のJWK SHA-256 ThumbPrint（JWK形式）のbase64urlエンコード（[RFC7515]で定義されている）である必要があります。。"
    },
    {
      "indent": 3,
      "text": "The following example JWT in Figure 8 with a decoded JWT payload shown in Figure 9 contains a cnf claim with the jkt JWK Thumbprint confirmation method member. The jkt value in these examples is the hash of the public key from the DPoP proofs in the examples shown in Section 5. The example uses \"\\\" line wrapping per [RFC8792].",
      "ja": "図8のJWTの次の例は、図9に示すデコードされたJWTペイロードを使用して、JKT JWK ThumbPrint確認方法メンバーのCNFクレームが含まれています。これらの例のJKT値は、セクション5に示す例のDPOP証明からの公開鍵のハッシュです。この例では、[RFC8792]ごとに「\\」ラインラッピングを使用しています。"
    },
    {
      "indent": 3,
      "text": "eyJhbGciOiJFUzI1NiIsImtpZCI6IkJlQUxrYiJ9.eyJzdWIiOiJzb21lb25lQGV4YW1\\\nwbGUuY29tIiwiaXNzIjoiaHR0cHM6Ly9zZXJ2ZXIuZXhhbXBsZS5jb20iLCJuYmYiOjE\\\n1NjIyNjI2MTEsImV4cCI6MTU2MjI2NjIxNiwiY25mIjp7ImprdCI6IjBaY09DT1JaTll\\\n5LURXcHFxMzBqWnlKR0hUTjBkMkhnbEJWM3VpZ3VBNEkifX0.3Tyo8VTcn6u_PboUmAO\\\nYUY1kfAavomW_YwYMkmRNizLJoQzWy2fCo79Zi5yObpIzjWb5xW4OGld7ESZrh0fsrA",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 8: JWT Containing a JWK SHA-256 Thumbprint Confirmation",
      "ja": "図8：JWK SHA-256 Thumbprintの確認を含むJWT"
    },
    {
      "indent": 3,
      "text": "{\n  \"sub\":\"someone@example.com\",\n  \"iss\":\"https://server.example.com\",\n  \"nbf\":1562262611,\n  \"exp\":1562266216,\n  \"cnf\":\n  {\n    \"jkt\":\"0ZcOCORZNYy-DWpqq30jZyJGHTN0d2HglBV3uiguA4I\"\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Figure 9: JWT Claims Set with a JWK SHA-256 Thumbprint Confirmation",
      "ja": "図9：JWK SHA-256 Thumbprintの確認で設定されたJWTクレーム"
    },
    {
      "indent": 0,
      "text": "6.2. JWK Thumbprint Confirmation Method in Token Introspection",
      "section_title": true,
      "ja": "6.2. トークン内省におけるJWKサムプリント確認方法"
    },
    {
      "indent": 3,
      "text": "\"OAuth 2.0 Token Introspection\" [RFC7662] defines a method for a protected resource to query an authorization server about the active state of an access token. The protected resource also determines metainformation about the token.",
      "ja": "「OAuth 2.0トークン内省」[RFC7662]は、保護されたリソースがアクセストークンのアクティブな状態に関する認証サーバーに照会する方法を定義します。保護されたリソースは、トークンに関するメテイン形成も決定します。"
    },
    {
      "indent": 3,
      "text": "For a DPoP-bound access token, the hash of the public key to which the token is bound is conveyed to the protected resource as metainformation in a token introspection response. The hash is conveyed using the same cnf content with jkt member structure as the JWK Thumbprint confirmation method, described in Section 6.1, as a top-level member of the introspection response JSON. Note that the resource server does not send a DPoP proof with the introspection request, and the authorization server does not validate an access token's DPoP binding at the introspection endpoint. Rather, the resource server uses the data of the introspection response to validate the access token binding itself locally.",
      "ja": "DPOPに縛られたアクセストークンの場合、トークンがバインドされている公開鍵のハッシュは、トークン内省反応でメテン形成として保護されたリソースに伝えられます。ハッシュは、JKTメンバー構造を持つ同じCNFコンテンツを使用して、JWK Thumbprint確認方法と同じCNFコンテンツを使用して伝達されます。リソースサーバーは、内省要求を使用してDPOPプルーフを送信せず、Authorizationサーバーは内省エンドポイントでのアクセストークンのDPOPバインディングを検証しないことに注意してください。むしろ、リソースサーバーは内省応答のデータを使用して、アクセストークンバインディング自体をローカルに検証します。"
    },
    {
      "indent": 3,
      "text": "If the token_type member is included in the introspection response, it MUST contain the value DPoP.",
      "ja": "token_typeメンバーが内省応答に含まれている場合、値DPOPを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "The example introspection request in Figure 10 and corresponding response in Figure 11 illustrate an introspection exchange for the example DPoP-bound access token that was issued in Figure 6.",
      "ja": "図10の内省要求と図11の対応する応答の例は、図6で発行されたDPOPバウンドアクセストークンの例の内省交換を示しています。"
    },
    {
      "indent": 3,
      "text": "POST /as/introspect.oauth2 HTTP/1.1\nHost: server.example.com\nContent-Type: application/x-www-form-urlencoded\nAuthorization: Basic cnM6cnM6TWt1LTZnX2xDektJZHo0ZnNON2tZY3lhK1Rp",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "token=Kz~8mXK1EalYznwH-LC-1fBAo.4Ljp~zsPE_NeO.gxU",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Figure 10: Example Introspection Request",
      "ja": "図10：イントロスペクションリクエストの例"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: no-store",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "{\n  \"active\": true,\n  \"sub\": \"someone@example.com\",\n  \"iss\": \"https://server.example.com\",\n  \"nbf\": 1562262611,\n  \"exp\": 1562266216,\n  \"cnf\":\n  {\n    \"jkt\": \"0ZcOCORZNYy-DWpqq30jZyJGHTN0d2HglBV3uiguA4I\"\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 11: Example Introspection Response for a DPoP-Bound Access Token",
      "ja": "図11：DPOPバウンドアクセストークンのイントロスペクティション応答の例"
    },
    {
      "indent": 0,
      "text": "7. Protected Resource Access",
      "section_title": true,
      "ja": "7. 保護されたリソースアクセス"
    },
    {
      "indent": 3,
      "text": "Requests to DPoP-protected resources MUST include both a DPoP proof as per Section 4 and the access token as described in Section 7.1. The DPoP proof MUST include the ath claim with a valid hash of the associated access token.",
      "ja": "DPOP保護されたリソースへのリクエストには、セクション4に従ってDPOPプルーフとセクション7.1で説明されているアクセストークンの両方を含める必要があります。DPOPプルーフには、関連するアクセストークンの有効なハッシュを含むATH請求を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Binding the token value to the proof in this way prevents a proof to be used with multiple different access token values across different requests. For example, if a client holds tokens bound to two different resource owners, AT1 and AT2, and uses the same key when talking to the authorization server, it's possible that these tokens could be swapped. Without the ath field to bind it, a captured signature applied to AT1 could be replayed with AT2 instead, changing the rights and access of the intended request. This same substitution prevention remains for rotated access tokens within the same combination of client and resource owner -- a rotated token value would require the calculation of a new proof. This binding additionally ensures that a proof intended for use with the access token is not usable without an access token, or vice-versa.",
      "ja": "この方法でトークン値を証明にバインドすると、異なる要求にわたって複数の異なるアクセストークン値で使用されることが妨げられます。たとえば、クライアントがAT1とAT2の2つの異なるリソース所有者にバインドされたトークンを保持し、Authorizationサーバーと話すときに同じキーを使用すると、これらのトークンを交換する可能性があります。それをバインドするATHフィールドがなければ、AT1に適用されるキャプチャされた署名を代わりにAT2で再生し、意図した要求の権利とアクセスを変更できます。クライアントとリソース所有者の同じ組み合わせ内の回転アクセストークンのこの同じ代替防止は、回転したトークン値に新しい証明の計算が必要です。さらに、このバインディングにより、アクセストークンで使用することを目的とした証明が、アクセストークンなしでは使用できないことが保証されます。"
    },
    {
      "indent": 3,
      "text": "The resource server is required to calculate the hash of the token value presented and verify that it is the same as the hash value in the ath field as described in Section 4.3. Since the ath field value is covered by the DPoP proof's signature, its inclusion binds the access token value to the holder of the key used to generate the signature.",
      "ja": "リソースサーバーは、提示されたトークン値のハッシュを計算し、セクション4.3で説明したようにATHフィールドのハッシュ値と同じであることを確認するために必要です。ATHフィールド値はDPOPプルーフの署名でカバーされているため、その包含は署名を生成するために使用されるキーの所有者にアクセストークン値を結合します。"
    },
    {
      "indent": 3,
      "text": "Note that the ath field alone does not prevent replay of the DPoP proof or provide binding to the request in which the proof is presented, and it is still important to check the time window of the proof as well as the included message parameters, such as htm and htu.",
      "ja": "ATHフィールドだけでは、DPOP証明のリプレイを妨げたり、証明が提示されているリクエストに拘束力を与えたりしないことに注意してください。HTMとHTU。"
    },
    {
      "indent": 0,
      "text": "7.1. The DPoP Authentication Scheme",
      "section_title": true,
      "ja": "7.1. DPOP認証スキーム"
    },
    {
      "indent": 3,
      "text": "A DPoP-bound access token is sent using the Authorization request header field per Section 11.6.2 of [RFC9110] with an authentication scheme of DPoP. The syntax of the Authorization header field for the DPoP scheme uses the token68 syntax defined in Section 11.2 of [RFC9110] for credentials and is repeated below for ease of reference. The ABNF notation syntax for DPoP authentication scheme credentials is as follows:",
      "ja": "DPOPの認証スキームを使用して、[RFC9110]のセクション11.6.2ごとに、DPOPバインドアクセストークンを使用して送信されます。DPOPスキームの認証ヘッダーフィールドの構文は、資格情報について[RFC9110]のセクション11.2で定義されているtoken68構文を使用し、参照を容易にするために以下に繰り返します。DPOP認証スキームの資格情報のABNF表記構文は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "token68    = 1*( ALPHA / DIGIT /\n                 \"-\" / \".\" / \"_\" / \"~\" / \"+\" / \"/\" ) *\"=\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "credentials = \"DPoP\" 1*SP token68",
      "ja": "資格情報= \"dpop\" 1*sp token68"
    },
    {
      "indent": 17,
      "text": "Figure 12: DPoP Authentication Scheme ABNF",
      "ja": "図12：DPOP認証スキームABNF"
    },
    {
      "indent": 3,
      "text": "For such an access token, a resource server MUST check that a DPoP proof was also received in the DPoP header field of the HTTP request, check the DPoP proof according to the rules in Section 4.3, and check that the public key of the DPoP proof matches the public key to which the access token is bound per Section 6.",
      "ja": "このようなアクセストークンの場合、リソースサーバーは、HTTPリクエストのDPOPヘッダーフィールドでDPOPプルーフが受信されたことを確認する必要があります。セクション6に従ってアクセストークンがバインドされる公開キーと一致します。"
    },
    {
      "indent": 3,
      "text": "The resource server MUST NOT grant access to the resource unless all checks are successful.",
      "ja": "リソースサーバーは、すべてのチェックが成功しない限り、リソースへのアクセスを許可してはなりません。"
    },
    {
      "indent": 3,
      "text": "Figure 13 shows an example request to a protected resource with a DPoP-bound access token in the Authorization header and the DPoP proof in the DPoP header. The example uses \"\\\" line wrapping per [RFC8792]. Figure 14 shows the decoded content of that DPoP proof. The JSON of the JWT header and payload are shown, but the signature part is omitted. As usual, line breaks and indentation are included for formatting and readability.",
      "ja": "図13は、認証ヘッダーにDPOPバインドアクセストークンとDPOPヘッダーのDPOPプルーフを備えた保護されたリソースへのリクエストの例を示しています。この例では、[RFC8792]ごとに「\\」ラインラップを使用します。図14は、そのDPOPプルーフのデコードされた内容を示しています。JWTヘッダーとペイロードのJSONが表示されますが、署名部品は省略されています。いつものように、フォーマットと読みやすさのために、ラインブレークとインデントが含まれています。"
    },
    {
      "indent": 3,
      "text": "GET /protectedresource HTTP/1.1 Host: resource.example.org Authorization: DPoP Kz~8mXK1EalYznwH-LC-1fBAo.4Ljp~zsPE_NeO.gxU DPoP: eyJ0eXAiOiJkcG9wK2p3dCIsImFsZyI6IkVTMjU2IiwiandrIjp7Imt0eSI6Ik\\ VDIiwieCI6Imw4dEZyaHgtMzR0VjNoUklDUkRZOXpDa0RscEJoRjQyVVFVZldWQVdCR\\ nMiLCJ5IjoiOVZFNGpmX09rX282NHpiVFRsY3VOSmFqSG10NnY5VERWclUwQ2R2R1JE\\ QSIsImNydiI6IlAtMjU2In19.eyJqdGkiOiJlMWozVl9iS2ljOC1MQUVCIiwiaHRtIj\\ oiR0VUIiwiaHR1IjoiaHR0cHM6Ly9yZXNvdXJjZS5leGFtcGxlLm9yZy9wcm90ZWN0Z\\ WRyZXNvdXJjZSIsImlhdCI6MTU2MjI2MjYxOCwiYXRoIjoiZlVIeU8ycjJaM0RaNTNF\\ c05yV0JiMHhXWG9hTnk1OUlpS0NBcWtzbVFFbyJ9.2oW9RP35yRqzhrtNP86L-Ey71E\\ OptxRimPPToA1plemAgR6pxHF8y6-yqyVnmcw6Fy1dqd-jfxSYoMxhAJpLjA",
      "ja": "\\ optxrimpptoa1plemagr6pxhf8y6-yqyvnmcw6fy1dqd-jfxsyomxhajplja"
    },
    {
      "indent": 17,
      "text": "Figure 13: DPoP-Protected Resource Request",
      "ja": "図13：DPOP保護されたリソースリクエスト"
    },
    {
      "indent": 3,
      "text": "{\n  \"typ\":\"dpop+jwt\",\n  \"alg\":\"ES256\",\n  \"jwk\": {\n    \"kty\":\"EC\",\n    \"x\":\"l8tFrhx-34tV3hRICRDY9zCkDlpBhF42UQUfWVAWBFs\",\n    \"y\":\"9VE4jf_Ok_o64zbTTlcuNJajHmt6v9TDVrU0CdvGRDA\",\n    \"crv\":\"P-256\"\n  }\n}\n.\n{\n  \"jti\":\"e1j3V_bKic8-LAEB\",\n  \"htm\":\"GET\",\n  \"htu\":\"https://resource.example.org/protectedresource\",\n  \"iat\":1562262618,\n  \"ath\":\"fUHyO2r2Z3DZ53EsNrWBb0xWXoaNy59IiKCAqksmQEo\"\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 14: Decoded Content of the DPoP Proof JWT in Figure 13",
      "ja": "図14：図13のDPOP証明JWTのデコードされたコンテンツ"
    },
    {
      "indent": 3,
      "text": "Upon receipt of a request to a protected resource within the protection space requiring DPoP authentication, the server can respond with a challenge to the client to provide DPoP authentication information if the request does not include valid credentials or does not contain an access token sufficient for access. Such a challenge is made using the 401 (Unauthorized) response status code ([RFC9110], Section 15.5.2) and the WWW-Authenticate header field ([RFC9110], Section 11.6.1). The server MAY include the WWW-Authenticate header in response to other conditions as well.",
      "ja": "DPOP認証を必要とする保護スペース内の保護されたリソースへのリクエストを受信すると、サーバーは、リクエストに有効な資格情報が含まれていないか、アクセスに十分なアクセストークンを含めていない場合、DPOP認証情報を提供するためにクライアントに挑戦して応答できます。。このような課題は、401（不正）応答ステータスコード（[RFC9110]、セクション15.5.2）およびwww-authenticateヘッダーフィールド（[RFC9110]、セクション11.6.1）を使用して行われます。サーバーには、他の条件にも応じてwww-authenticateヘッダーを含めることができます。"
    },
    {
      "indent": 3,
      "text": "In such challenges:",
      "ja": "そのような課題で："
    },
    {
      "indent": 3,
      "text": "* The scheme name is DPoP. * The authentication parameter realm MAY be included to indicate the scope of protection in the manner described in [RFC9110], Section 11.5. * A scope authentication parameter MAY be included as defined in [RFC6750], Section 3. * An error parameter ([RFC6750], Section 3) SHOULD be included to indicate the reason why the request was declined, if the request included an access token but failed authentication. The error parameter values described in [RFC6750], Section 3.1 are suitable, as are any appropriate values defined by extension. The value use_dpop_nonce can be used as described in Section 9 to signal that a nonce is needed in the DPoP proof of a subsequent request(s). Additionally, invalid_dpop_proof is used to indicate that the DPoP proof itself was deemed invalid based on the criteria of Section 4.3. * An error_description parameter ([RFC6750], Section 3) MAY be included along with the error parameter to provide developers a human-readable explanation that is not meant to be displayed to end-users. * An algs parameter SHOULD be included to signal to the client the JWS algorithms that are acceptable for the DPoP proof JWT. The value of the parameter is a space-delimited list of JWS alg (Algorithm) header values ([RFC7515], Section 4.1.1). * Additional authentication parameters MAY be used, and unknown parameters MUST be ignored by recipients.",
      "ja": "* スキーム名はDPOPです。* [RFC9110]、セクション11.5に記載されている方法で保護の範囲を示すために、認証パラメーターの領域を含めることができます。*スコープ認証パラメーターは、[RFC6750]、セクション3で定義されているように含めることができます。しかし、認証に失敗しました。[RFC6750]で説明されているエラーパラメーター値、セクション3.1は、拡張によって定義される適切な値と同様に適切です。値USE_DPOP_NONCEは、セクション9で説明されているように使用して、後続の要求のDPOP証明で非CEが必要であることを示すことができます。さらに、Invalid_dpop_Proofは、DPOP証明自体がセクション4.3の基準に基づいて無効と見なされたことを示すために使用されます。* ERROR_Descriptionパラメーター（[RFC6750]、セクション3）をエラーパラメーターとともに含めることができ、開発者にエンドユーザーに表示されることを意図していない人間の読み取り可能な説明を提供します。* DPOPプルーフJWTに受け入れられるJWSアルゴリズムをクライアントに信号するために、ALGSパラメーターを含める必要があります。パラメーターの値は、JWSアルグ（アルゴリズム）ヘッダー値（[RFC7515]、セクション4.1.1）のスペース削除リストです。*追加の認証パラメーターが使用される場合があり、未知のパラメーターは受信者が無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Figure 15 shows a response to a protected resource request without authentication.",
      "ja": "図15は、認証なしで保護されたリソース要求に対する応答を示しています。"
    },
    {
      "indent": 4,
      "text": "HTTP/1.1 401 Unauthorized WWW-Authenticate: DPoP algs=\"ES256 PS256\"",
      "ja": "http/1.1 401不正www-authenticate：dpop algs = \"es256 ps256\""
    },
    {
      "indent": 4,
      "text": "Figure 15: HTTP 401 Response to a Protected Resource Request without Authentication",
      "ja": "図15：認証なしで保護されたリソース要求に対するHTTP 401の応答"
    },
    {
      "indent": 3,
      "text": "Figure 16 shows a response to a protected resource request that was rejected due to the failed confirmation of the DPoP binding in the access token. Figure 16 uses \"\\\" line wrapping per [RFC8792].",
      "ja": "図16は、アクセストークン内のDPOPバインディングの確認が失敗したため拒否された保護されたリソース要求に対する応答を示しています。図16は、[RFC8792]ごとに「\\」ラインラッピングを使用しています。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 401 Unauthorized WWW-Authenticate: DPoP error=\"invalid_token\", \\ error_description=\"Invalid DPoP key binding\", algs=\"ES256\"",
      "ja": "http/1.1 401不正www-authenticate：dpop error = \"invalid_token\"、\\ error_description = \"無効なdpopキーバインディング\"、algs = \"es256\""
    },
    {
      "indent": 5,
      "text": "Figure 16: HTTP 401 Response to a Protected Resource Request with an Invalid Token",
      "ja": "図16：無効なトークンを使用した保護されたリソース要求に対するHTTP 401の応答"
    },
    {
      "indent": 3,
      "text": "Note that browser-based client applications using Cross-Origin Resource Sharing (CORS) [WHATWG.Fetch] only have access to CORS-safelisted response HTTP headers by default. In order for the application to obtain and use the WWW-Authenticate HTTP response header value, the server needs to make it available to the application by including WWW-Authenticate in the Access-Control-Expose-Headers response header list value.",
      "ja": "クロスオリジンリソース共有（CORS）[Whatwg.fetch]を使用したブラウザベースのクライアントアプリケーションは、デフォルトでCORSセーフェリスト応答HTTPヘッダーにのみアクセスできることに注意してください。アプリケーションがwww-authenticate http応答ヘッダー値を取得して使用するためには、サーバーは、アクセス制御 - 拡張者ヘッダー応答ヘッダーリスト値にwww-authenticateを含めることにより、アプリケーションを利用できるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "This authentication scheme is for origin-server authentication only. Therefore, this authentication scheme MUST NOT be used with the Proxy-Authenticate or Proxy-Authorization header fields.",
      "ja": "この認証スキームは、Origin-Server認証専用です。したがって、この認証スキームは、Proxy-AuthenticateまたはProxy-Authorization Headerフィールドで使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "Note that the syntax of the Authorization header field for this authentication scheme follows the usage of the Bearer scheme defined in Section 2.1 of [RFC6750]. While it is not the preferred credential syntax of [RFC9110], it is compatible with the general authentication framework therein and is used for consistency and familiarity with the Bearer scheme.",
      "ja": "この認証スキームの認証ヘッダーフィールドの構文は、[RFC6750]のセクション2.1で定義されているベアラースキームの使用に従うことに注意してください。[RFC9110]の好ましい資格情報の構文ではありませんが、その中の一般的な認証フレームワークと互換性があり、Bearerスキームに一貫性と精通のために使用されます。"
    },
    {
      "indent": 0,
      "text": "7.2. Compatibility with the Bearer Authentication Scheme",
      "section_title": true,
      "ja": "7.2. Bearer認証スキームとの互換性"
    },
    {
      "indent": 3,
      "text": "Protected resources simultaneously supporting both the DPoP and Bearer schemes need to update how the evaluation process is performed for bearer tokens to prevent downgraded usage of a DPoP-bound access token. Specifically, such a protected resource MUST reject a DPoP-bound access token received as a bearer token per [RFC6750].",
      "ja": "DPOPとベアラーの両方のスキームをサポートする保護されたリソースは、Bearerトークンの評価プロセスの実行方法を更新して、DPOPバウンドアクセストークンの格下げの使用を防ぐ必要があります。具体的には、このような保護されたリソースは、[RFC6750]ごとにベアラートークンとして受信したDPOPバインドアクセストークンを拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "Section 11.6.1 of [RFC9110] allows a protected resource to indicate support for multiple authentication schemes (i.e., Bearer and DPoP) with the WWW-Authenticate header field of a 401 (Unauthorized) response.",
      "ja": "[RFC9110]のセクション11.6.1では、保護されたリソースが、401（不正）応答のwww-authenticateヘッダーフィールドを使用して、複数の認証スキーム（つまりBEARERおよびDPOP）のサポートを示すことができます。"
    },
    {
      "indent": 3,
      "text": "A protected resource that supports only [RFC6750] and is unaware of DPoP would most presumably accept a DPoP-bound access token as a bearer token (JWT [RFC7519] says to ignore unrecognized claims, Introspection [RFC7662] says that other parameters might be present while placing no functional requirements on their presence, and [RFC6750] is effectively silent on the content of the access token since it relates to validity). As such, a client can send a DPoP-bound access token using the Bearer scheme upon receipt of a WWW-Authenticate: Bearer challenge from a protected resource (or it can send a DPoP-bound access token if it has prior knowledge of the capabilities of the protected resource). The effect of this likely simplifies the logistics of phased upgrades to protected resources in their support DPoP or prolonged deployments of protected resources with mixed token type support.",
      "ja": "[RFC6750]のみをサポートし、DPOPを知らない保護されたリソースは、Bearer Token（JWT [RFC7519]が認識されていない主張を無視すると述べているため、DPOPに縛られたアクセストークンを最も受け入れます。存在に機能的な要件を置かず、[RFC6750]は、有効性に関連しているため、アクセストークンのコンテンツに効果的に沈黙しています）。そのため、クライアントは、www-authenticate：保護されたリソースからのBearer Challengeを受信したときにBearerスキームを使用してDPOPバウンドアクセストークンを送信できます（または、機能の事前知識がある場合はDPOPバウンドアクセストークンを送信できます保護されたリソースの）。これの効果は、サポートDPOPの保護リソースへの段階的アップグレードのロジスティクスまたは、混合トークンタイプのサポートを備えた保護されたリソースの長期展開のロジスティクスを簡素化する可能性があります。"
    },
    {
      "indent": 3,
      "text": "If a protected resource supporting both Bearer and DPoP schemes elects to respond with multiple WWW-Authenticate challenges, attention should be paid to which challenge(s) should deliver the actual error information. It is RECOMMENDED that the following rules be adhered to:",
      "ja": "BearerとDPOPスキームの両方をサポートする保護されたリソースが、複数のwww-authenticateの課題で応答することを選択する場合、実際のエラー情報を提供する課題に注意を払う必要があります。次のルールを順守することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "* If no authentication information has been included with the request, then the challenges SHOULD NOT include an error code or other error information, as per Section 3.1 of [RFC6750] (Figure 17).",
      "ja": "* リクエストに認証情報が含まれていない場合、[RFC6750]のセクション3.1に従って、課題にはエラーコードやその他のエラー情報を含めるべきではありません（図17）。"
    },
    {
      "indent": 3,
      "text": "* If the mechanism used to attempt authentication could be established unambiguously, then the corresponding challenge SHOULD be used to deliver error information (Figure 18).",
      "ja": "* 認証を試みるために使用されるメカニズムを明確に確立できる場合、対応する課題を使用してエラー情報を提供する必要があります（図18）。"
    },
    {
      "indent": 3,
      "text": "* Otherwise, both Bearer and DPoP challenges MAY be used to deliver error information (Figure 19).",
      "ja": "* それ以外の場合、ベアラーとDPOPの課題の両方を使用して、エラー情報を提供できます（図19）。"
    },
    {
      "indent": 3,
      "text": "The following examples use \"\\\" line wrapping per [RFC8792].",
      "ja": "次の例では、[RFC8792]ごとに「\\」ラインラッピングを使用します。"
    },
    {
      "indent": 3,
      "text": "GET /protectedresource HTTP/1.1 Host: resource.example.org",
      "ja": "get /protectedResource http /1.1ホスト：resource.example.org"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 401 Unauthorized WWW-Authenticate: Bearer, DPoP algs=\"ES256 PS256\"",
      "ja": "HTTP/1.1 401不正www-authenticate：bearer、dpop algs = \"es256 ps256\""
    },
    {
      "indent": 4,
      "text": "Figure 17: HTTP 401 Response to a Protected Resource Request without Authentication",
      "ja": "図17：認証なしで保護されたリソース要求に対するHTTP 401の応答"
    },
    {
      "indent": 3,
      "text": "GET /protectedresource HTTP/1.1 Host: resource.example.org Authorization: Bearer INVALID_TOKEN",
      "ja": "get /protectedResource http /1.1 host：resource.example.org承認：bearer invalid_token"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 401 Unauthorized WWW-Authenticate: Bearer error=\"invalid_token\", \\ error_description=\"Invalid token\", DPoP algs=\"ES256 PS256\"",
      "ja": "http/1.1 401不正www-authenticate：bearer error = \"invalid_token\"、\\ error_description = \"invalidトークン\"、dpop algs = \"es256 ps256\""
    },
    {
      "indent": 5,
      "text": "Figure 18: HTTP 401 Response to a Protected Resource Request with Invalid Authentication",
      "ja": "図18：HTTP 401無効な認証による保護されたリソース要求への応答"
    },
    {
      "indent": 3,
      "text": "GET /protectedresource HTTP/1.1\nHost: resource.example.org\nAuthorization: Bearer Kz~8mXK1EalYznwH-LC-1fBAo.4Ljp~zsPE_NeO.gxU\nAuthorization: DPoP Kz~8mXK1EalYznwH-LC-1fBAo.4Ljp~zsPE_NeO.gxU",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 400 Bad Request WWW-Authenticate: Bearer error=\"invalid_request\", \\ error_description=\"Multiple methods used to include access token\", \\ DPoP algs=\"ES256 PS256\", error=\"invalid_request\", \\ error_description=\"Multiple methods used to include access token\"",
      "ja": "http/1.1 400悪い要求www-authenticate：bearer error = \"invalid_request\"、\\ error_description = \"アクセストークンを含むために使用される複数の方法\"、\\ dpop algs = \"es256 ps256\"、error = \"invalid_request\"、\\ error_description = \"アクセストークンを含むために使用される方法 \""
    },
    {
      "indent": 5,
      "text": "Figure 19: HTTP 400 Response to a Protected Resource Request with Ambiguous Authentication",
      "ja": "図19：あいまいな認証を使用した保護されたリソース要求に対するHTTP 400応答"
    },
    {
      "indent": 0,
      "text": "7.3. Client Considerations",
      "section_title": true,
      "ja": "7.3. クライアントの考慮事項"
    },
    {
      "indent": 3,
      "text": "Authorization including a DPoP proof may not be idempotent (depending on server enforcement of jti, iat, and nonce claims). Consequently, all previously idempotent requests for protected resources that were previously idempotent may no longer be idempotent. It is RECOMMENDED that clients generate a unique DPoP proof, even when retrying idempotent requests in response to HTTP errors generally understood as transient.",
      "ja": "DPOPの証明を含む承認は、等隊ではない場合があります（JTI、IAT、およびNonCEクレームのサーバー施行に応じて）。したがって、以前は等隊であった保護されたリソースに対する以前の等式の要求はすべて、もはや等隊ではない可能性があります。一般に一時的に理解されるHTTPエラーに応じてiDempotent要求を再試行する場合でも、クライアントは一意のDPOP証明を生成することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Clients that encounter frequent network errors may experience additional challenges when interacting with servers with stricter nonce validation implementations.",
      "ja": "頻繁なネットワークエラーに遭遇するクライアントは、より厳格なNONCE検証実装を使用してサーバーと対話する際に追加の課題が発生する場合があります。"
    },
    {
      "indent": 0,
      "text": "8. Authorization Server-Provided Nonce",
      "section_title": true,
      "ja": "8. Authorization Serverが提供するNonce"
    },
    {
      "indent": 3,
      "text": "This section specifies a mechanism using opaque nonces provided by the server that can be used to limit the lifetime of DPoP proofs. Without employing such a mechanism, a malicious party controlling the client (potentially including the end-user) can create DPoP proofs for use arbitrarily far in the future.",
      "ja": "このセクションでは、DPOPプルーフの寿命を制限するために使用できるサーバーが提供する不透明なノンセスを使用したメカニズムを指定します。このようなメカニズムを採用することなく、クライアントを制御する悪意のあるパーティー（潜在的にエンドユーザーを含む）は、将来的に任意に遠くに使用するためのDPOPプルーフを作成できます。"
    },
    {
      "indent": 3,
      "text": "Including a nonce value contributed by the authorization server in the DPoP proof MAY be used by authorization servers to limit the lifetime of DPoP proofs. The server determines when to issue a new DPoP nonce challenge and if it is needed, thereby requiring the use of the nonce value in subsequent DPoP proofs. The logic through which the server makes that determination is out of scope of this document.",
      "ja": "DPOPプルーフに承認サーバーによって貢献したNonCE値を含むことは、承認サーバーがDPOPプルーフの寿命を制限するために使用できます。サーバーは、新しいDPOP NonCe Challengeを発行するタイミングと、それが必要な場合、それによりその後のDPOPプルーフでNonCe値を使用する必要があることを決定します。サーバーがその決定を行うロジックは、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "An authorization server MAY supply a nonce value to be included by the client in DPoP proofs sent. In this case, the authorization server responds to requests that do not include a nonce with an HTTP 400 (Bad Request) error response per Section 5.2 of [RFC6749] using use_dpop_nonce as the error code value. The authorization server includes a DPoP-Nonce HTTP header in the response supplying a nonce value to be used when sending the subsequent request. Nonce values MUST be unpredictable. This same error code is used when supplying a new nonce value when there was a nonce mismatch. The client will typically retry the request with the new nonce value supplied upon receiving a use_dpop_nonce error with an accompanying nonce value.",
      "ja": "認証サーバーは、送信されたDPOPプルーフにクライアントが含めるNonCE値を提供する場合があります。この場合、承認サーバーは、use_dpop_nonceをエラーコード値として使用して、[rfc6749]のセクション5.2ごとにHTTP 400（悪い要求）エラー応答を持つノンセを含めないリクエストに応答します。Authorization Serverには、後続のリクエストを送信するときに使用するNonCE値を提供するDPOP-Nonce HTTPヘッダーが応答に含まれています。NONCE値は予測不可能でなければなりません。この同じエラーコードは、NonCEの不一致があるときに新しいNonCE値を提供するときに使用されます。通常、クライアントは、添付されたNonCe値でuse_dpop_nonceエラーを受信すると、新しいNonce値が提供された新しいNonce値でリクエストを再試行します。"
    },
    {
      "indent": 3,
      "text": "For example, in response to a token request without a nonce when the authorization server requires one, the authorization server can respond with a DPoP-Nonce value such as the following to provide a nonce value to include in the DPoP proof:",
      "ja": "たとえば、認証サーバーが必要な場合、NonCEなしでトークン要求に応じて、承認サーバーは、DPOPプルーフに含めるNonCE値を提供するために、次のようなDPOPノンス値で応答できます。"
    },
    {
      "indent": 4,
      "text": "HTTP/1.1 400 Bad Request DPoP-Nonce: eyJ7S_zG.eyJH0-Z.HX4w-7v",
      "ja": "http/1.1 400悪い要求dpop-nonce：eyj7s_zg.eyjh0-z.hx4w-7v"
    },
    {
      "indent": 4,
      "text": "{\n \"error\": \"use_dpop_nonce\",\n \"error_description\":\n   \"Authorization server requires nonce in DPoP proof\"\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Figure 20: HTTP 400 Response to a Token Request without a Nonce",
      "ja": "図20：ノンセなしでトークンリクエストに対するHTTP 400応答"
    },
    {
      "indent": 3,
      "text": "Other HTTP headers and JSON fields MAY also be included in the error response, but there MUST NOT be more than one DPoP-Nonce header.",
      "ja": "他のHTTPヘッダーとJSONフィールドもエラー応答に含まれる場合がありますが、DPOP-Nonceヘッダーを1つ以上存在してはなりません。"
    },
    {
      "indent": 3,
      "text": "Upon receiving the nonce, the client is expected to retry its token request using a DPoP proof including the supplied nonce value in the nonce claim of the DPoP proof. An example unencoded JWT payload of such a DPoP proof including a nonce is shown below.",
      "ja": "NONCEを受信すると、クライアントは、DPOPプルーフのNONCE請求に提供されたNONCE値を含むDPOPプルーフを使用してトークンリクエストを再試行することが期待されます。以下に示すようなDPOP証明のこのようなDPOPプルーフのエンコードされていないJWTペイロードを以下に示します。"
    },
    {
      "indent": 4,
      "text": "{\n \"jti\": \"-BwC3ESc6acc2lTc\",\n \"htm\": \"POST\",\n \"htu\": \"https://server.example.com/token\",\n \"iat\": 1562262616,\n \"nonce\": \"eyJ7S_zG.eyJH0-Z.HX4w-7v\"\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Figure 21: DPoP Proof Payload including a Nonce Value",
      "ja": "図21：NonCe値を含むDPOPプルーフペイロード"
    },
    {
      "indent": 3,
      "text": "The nonce is opaque to the client.",
      "ja": "ノンセはクライアントに不透明です。"
    },
    {
      "indent": 3,
      "text": "If the nonce claim in the DPoP proof does not exactly match a nonce recently supplied by the authorization server to the client, the authorization server MUST reject the request. The rejection response MAY include a DPoP-Nonce HTTP header providing a new nonce value to use for subsequent requests.",
      "ja": "DPOPプルーフのNonCE請求が、承認サーバーからクライアントに最近提供されたNONCEと正確に一致しない場合、承認サーバーはリクエストを拒否する必要があります。拒否応答には、後続のリクエストに使用する新しいNonCE値を提供するDPOP-Nonce HTTPヘッダーが含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "The intent is that clients need to keep only one nonce value and servers need to keep a window of recent nonces. That said, transient circumstances may arise in which the stored nonce values for the server and the client differ. However, this situation is self-correcting. With any rejection message, the server can send the client the nonce value it wants to use to the client, and the client can store that nonce value and retry the request with it. Even if the client and/or server discard their stored nonce values, that situation is also self-correcting because new nonce values can be communicated when responding to or retrying failed requests.",
      "ja": "意図は、クライアントが1つのNONCE値のみを維持する必要があり、サーバーが最近のNonceのウィンドウを維持する必要があることです。とはいえ、サーバーとクライアントの保存されたNonCE値が異なる過渡状況が発生する可能性があります。ただし、この状況は自己修正されています。拒否メッセージを使用すると、サーバーはクライアントにクライアントに使用したいNonCe値を送信でき、クライアントはそのNONCE値を保存してリクエストを再試行できます。クライアントおよび/またはサーバーが保存されたNonCE値を破棄しても、その状況も自己修正されています。"
    },
    {
      "indent": 3,
      "text": "Note that browser-based client applications using CORS [WHATWG.Fetch] only have access to CORS-safelisted response HTTP headers by default. In order for the application to obtain and use the DPoP-Nonce HTTP response header value, the server needs to make it available to the application by including DPoP-Nonce in the Access-Control-Expose-Headers response header list value.",
      "ja": "CORを使用したブラウザベースのクライアントアプリケーション[Whatwg.fetch]は、デフォルトでCORSセーフェリストの応答HTTPヘッダーにのみアクセスできることに注意してください。アプリケーションがDPOP-Nonce HTTP Response Header値を取得して使用するために、サーバーはAccess-Control-Expose-Headers Response Headerリスト値にDPOP-Nonceを含めることにより、アプリケーションを利用できるようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "8.1. Nonce Syntax",
      "section_title": true,
      "ja": "8.1. NonCe構文"
    },
    {
      "indent": 3,
      "text": "The nonce syntax in ABNF as used by [RFC6749] (which is the same as the scope-token syntax) is shown below.",
      "ja": "[RFC6749]で使用されるABNFの非CE構文（スコープトークンの構文と同じ）を以下に示します。"
    },
    {
      "indent": 3,
      "text": "nonce = 1*NQCHAR",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 27,
      "text": "Figure 22: Nonce ABNF",
      "ja": "図22：nonce abnf"
    },
    {
      "indent": 0,
      "text": "8.2. Providing a New Nonce Value",
      "section_title": true,
      "ja": "8.2. 新しいNonCe値を提供します"
    },
    {
      "indent": 3,
      "text": "It is up to the authorization server when to supply a new nonce value for the client to use. The client is expected to use the existing supplied nonce in DPoP proofs until the server supplies a new nonce value.",
      "ja": "クライアントが使用する新しいNONCE値をいつ提供するかは、Authorization Server次第です。クライアントは、サーバーが新しいNONCE値を提供するまで、DPOPプルーフで既存の供給されたNonCEを使用することが期待されます。"
    },
    {
      "indent": 3,
      "text": "The authorization server MAY supply the new nonce in the same way that the initial one was supplied: by using a DPoP-Nonce HTTP header in the response. The DPoP-Nonce HTTP header field uses the nonce syntax defined in Section 8.1. Each time this happens, it requires an extra protocol round trip.",
      "ja": "Authorization Serverは、最初のものが提供されたのと同じ方法で新しいNonCEを提供する場合があります。応答でDPOP-Nonce HTTPヘッダーを使用します。DPOP-Nonce HTTPヘッダーフィールドは、セクション8.1で定義されているNonCE構文を使用します。これが発生するたびに、追加のプロトコルラウンドトリップが必要です。"
    },
    {
      "indent": 3,
      "text": "A more efficient manner of supplying a new nonce value is also defined by including a DPoP-Nonce HTTP header in the HTTP 200 (OK) response from the previous request. The client MUST use the new nonce value supplied for the next token request and for all subsequent token requests until the authorization server supplies a new nonce.",
      "ja": "新しいNonCE値を提供するより効率的な方法は、前のリクエストからHTTP 200（OK）応答にDPOP-Nonce HTTPヘッダーを含めることによって定義されます。クライアントは、承認サーバーが新しいNONCEを提供するまで、次のトークンリクエストとその後のすべてのトークンリクエストに提供された新しいNONCE値を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Responses that include the DPoP-Nonce HTTP header should be uncacheable (e.g., using Cache-Control: no-store in response to a GET request) to prevent the response from being used to serve a subsequent request and a stale nonce value from being used as a result.",
      "ja": "DPOP-Nonce HTTPヘッダーを含む応答は、その後のリクエストと古いNonCE値を使用するために応答が使用されるのを防ぐために、修復不可能（キャッシュコントロール：GETリクエストに応じてストアなし）でなければなりません結果として。"
    },
    {
      "indent": 3,
      "text": "An example 200 OK response providing a new nonce value is shown below.",
      "ja": "新しいNonCE値を提供する例200 OK応答を以下に示します。"
    },
    {
      "indent": 4,
      "text": "HTTP/1.1 200 OK Cache-Control: no-store DPoP-Nonce: eyJ7S_zG.eyJbYu3.xQmBj-1",
      "ja": "HTTP/1.1 200 OK Cache-Control：No-Store DPOP-Nonce：EYJ7S_ZG.EYJBYU3.XQMBJ-1"
    },
    {
      "indent": 8,
      "text": "Figure 23: HTTP 200 Response Providing the Next Nonce Value",
      "ja": "図23：次のノンセ値を提供するHTTP 200応答"
    },
    {
      "indent": 0,
      "text": "9. Resource Server-Provided Nonce",
      "section_title": true,
      "ja": "9. リソースサーバーが提供するノンセ"
    },
    {
      "indent": 3,
      "text": "Resource servers can also choose to provide a nonce value to be included in DPoP proofs sent to them. They provide the nonce using the DPoP-Nonce header in the same way that authorization servers do as described in Sections 8 and 8.2. The error signaling is performed as described in Section 7.1. Resource servers use an HTTP 401 (Unauthorized) error code with an accompanying WWW-Authenticate: DPoP value and DPoP-Nonce value to accomplish this.",
      "ja": "リソースサーバーは、送信されたDPOPプルーフに含まれるNonCE値を提供することもできます。セクション8および8.2で説明されているように、承認サーバーが行うのと同じ方法で、DPOP-Nonceヘッダーを使用してNONCEを提供します。エラーシグナル伝達は、セクション7.1で説明されているように実行されます。リソースサーバーは、これを達成するためにwww-authenticate：dpop値とdpop-nonce値を伴うhttp 401（不正）エラーコードを使用します。"
    },
    {
      "indent": 3,
      "text": "For example, in response to a resource request without a nonce when the resource server requires one, the resource server can respond with a DPoP-Nonce value such as the following to provide a nonce value to include in the DPoP proof. The example below uses \"\\\" line wrapping per [RFC8792].",
      "ja": "たとえば、リソースサーバーが必要な場合、NONCEのないリソース要求に応じて、リソースサーバーは、DPOPプルーフに含めるNonCE値を提供するために、次のようなDPOPノンス値で応答できます。以下の例では、[RFC8792]ごとに「\\」ラインラッピングを使用しています。"
    },
    {
      "indent": 4,
      "text": "HTTP/1.1 401 Unauthorized WWW-Authenticate: DPoP error=\"use_dpop_nonce\", \\ error_description=\"Resource server requires nonce in DPoP proof\" DPoP-Nonce: eyJ7S_zG.eyJH0-Z.HX4w-7v",
      "ja": "http/1.1 401不正www-authenticate：dpop error = \"use_dpop_nonce\"、\\ error_description = \"dpop formy\" dpop-nonce：eyj7s_zg.eyjh0-z.hx4w-7vvvvvv"
    },
    {
      "indent": 5,
      "text": "Figure 24: HTTP 401 Response to a Resource Request without a Nonce",
      "ja": "図24：HTTP 401ノンセなしのリソース要求への応答"
    },
    {
      "indent": 3,
      "text": "Note that the nonces provided by an authorization server and a resource server are different and should not be confused with one another since nonces will be only accepted by the server that issued them. Likewise, should a client use multiple authorization servers and/or resource servers, a nonce issued by any of them should be used only at the issuing server. Developers should also be careful to not confuse DPoP nonces with the OpenID Connect [OpenID.Core] ID Token nonce.",
      "ja": "認証サーバーとリソースサーバーによって提供されるNoncesは異なっており、noncesが発行したサーバーによってのみ受け入れられるため、互いに混同しないでください。同様に、クライアントが複数の承認サーバーおよび/またはリソースサーバーを使用する場合、それらのいずれかが発行したNONCEは、発行サーバーでのみ使用する必要があります。また、開発者は、DPOP NoncesをOpenID Connect [OpenID.Core] IDトークンNonceと混同しないように注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "10. Authorization Code Binding to a DPoP Key",
      "section_title": true,
      "ja": "10. DPOPキーへの承認コードバインディング"
    },
    {
      "indent": 3,
      "text": "Binding the authorization code issued to the client's proof-of-possession key can enable end-to-end binding of the entire authorization flow. This specification defines the dpop_jkt authorization request parameter for this purpose. The value of the dpop_jkt authorization request parameter is the JWK Thumbprint [RFC7638] of the proof-of-possession public key using the SHA-256 hash function, which is the same value as used for the jkt confirmation method defined in Section 6.1.",
      "ja": "クライアントのプルーフポッセッションキーに発行された承認コードをバインドすると、承認フロー全体のエンドツーエンドのバインディングが可能になります。この仕様は、この目的のためにDPOP_JKT認証要求パラメーターを定義します。DPOP_JKT認証リクエストパラメーターの値は、SHA-256ハッシュ関数を使用したPhose-of-Possession公開キーのJWK ThumbPrint [RFC7638]です。これは、セクション6.1で定義されたJKT確認方法に使用される値です。"
    },
    {
      "indent": 3,
      "text": "When a token request is received, the authorization server computes the JWK Thumbprint of the proof-of-possession public key in the DPoP proof and verifies that it matches the dpop_jkt parameter value in the authorization request. If they do not match, it MUST reject the request.",
      "ja": "トークン要求が受信されると、承認サーバーは、DPOP証明のプルーフオブポッセッション公開キーのJWKサムプリントを計算し、承認要求のDPOP_JKTパラメーター値と一致することを確認します。それらが一致しない場合、リクエストを拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "An example authorization request using the dpop_jkt authorization request parameter is shown below and uses \"\\\" line wrapping per [RFC8792].",
      "ja": "DPOP_JKT承認要求パラメーターを使用した承認要求の例を以下に示し、[RFC8792]ごとに「\\」ラインラッピングを使用します。"
    },
    {
      "indent": 3,
      "text": "GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz\\\n    &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb\\\n    &code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM\\\n    &code_challenge_method=S256\\\n    &dpop_jkt=NzbLsXh8uDCcd-6MNwXF4W_7noWXFZAfHkxZsRGC9Xs HTTP/1.1\nHost: server.example.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 25: Authorization Request Using the dpop_jkt Parameter",
      "ja": "図25：dpop_jktパラメーターを使用した承認要求"
    },
    {
      "indent": 3,
      "text": "Use of the dpop_jkt authorization request parameter is OPTIONAL. Note that the dpop_jkt authorization request parameter MAY also be used in combination with Proof Key for Code Exchange (PKCE) [RFC7636], which is recommended by [SECURITY-TOPICS] as a countermeasure to authorization code injection. The dpop_jkt authorization request parameter only provides similar protections when a unique DPoP key is used for each authorization request.",
      "ja": "DPOP_JKT認証要求パラメーターの使用はオプションです。DPOP_JKT認証リクエストパラメーターは、認証コードインジェクションの対策として[セキュリティトピック]によって推奨されるコードエクスチェンジ（PKCE）[RFC7636]の証明キーと組み合わせて使用できることに注意してください。DPOP_JKT認証要求パラメーターは、各承認要求に一意のDPOPキーが使用されている場合にのみ、同様の保護を提供します。"
    },
    {
      "indent": 0,
      "text": "10.1. DPoP with Pushed Authorization Requests",
      "section_title": true,
      "ja": "10.1. プッシュされた承認リクエストを備えたDPOP"
    },
    {
      "indent": 3,
      "text": "When Pushed Authorization Requests (PARs) [RFC9126] are used in conjunction with DPoP, there are two ways in which the DPoP key can be communicated in the PAR request:",
      "ja": "プッシュされた承認要求（PAR）[RFC9126]がDPOPと併用されると、DPOPキーをPARリクエストで通信できる2つの方法があります。"
    },
    {
      "indent": 3,
      "text": "* The dpop_jkt parameter can be used as described in Section 10 to bind the issued authorization code to a specific key. In this case, dpop_jkt MUST be included alongside other authorization request parameters in the POST body of the PAR request.\n\n* Alternatively, the DPoP header can be added to the PAR request. In this case, the authorization server MUST check the provided DPoP proof JWT as defined in Section 4.3. It MUST further behave as if the contained public key's thumbprint was provided using dpop_jkt, i.e., reject the subsequent token request unless a DPoP proof for the same key is provided. This can help to simplify the implementation of the client, as it can \"blindly\" attach the DPoP header to all requests to the authorization server regardless of the type of request. Additionally, it provides a stronger binding, as the DPoP header contains a proof of possession of the private key.",
      "ja": "* DPOP_JKTパラメーターは、セクション10で説明されているように使用して、発行された承認コードを特定のキーに結合できます。この場合、DPOP_JKTは、PARリクエストのポスト本体にある他の承認要求パラメーターとともに含める必要があります。\n\n*または、DPOPヘッダーをPARリクエストに追加できます。この場合、承認サーバーは、セクション4.3で定義されているように、提供されたDPOP証明JWTを確認する必要があります。含まれる公開キーのサムプリントがDPOP_JKTを使用して提供されたかのようにさらに動作する必要があります。つまり、同じキーのDPOP証明が提供されない限り、後続のトークン要求を拒否します。これは、クライアントの実装を簡素化するのに役立ちます。これは、リクエストの種類に関係なく、DPOPヘッダーをすべてのリクエストに認証サーバーに「盲目的に」添付できるためです。さらに、DPOPヘッダーには秘密鍵の所持の証明が含まれているため、より強力なバインディングを提供します。"
    },
    {
      "indent": 3,
      "text": "Both mechanisms MUST be supported by an authorization server that supports PAR and DPoP. If both mechanisms are used at the same time, the authorization server MUST reject the request if the JWK Thumbprint in dpop_jkt does not match the public key in the DPoP header.",
      "ja": "両方のメカニズムは、PARおよびDPOPをサポートする認証サーバーによってサポートする必要があります。両方のメカニズムが同時に使用されている場合、DPOP_JKTのJWK ThumbprintがDPOPヘッダーの公開キーと一致しない場合、承認サーバーはリクエストを拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "Allowing both mechanisms ensures that clients using dpop_jkt do not need to distinguish between front-channel and pushed authorization requests, and at the same time, clients that only have one code path for protecting all calls to authorization server endpoints do not need to distinguish between requests to the PAR endpoint and the token endpoint.",
      "ja": "両方のメカニズムを許可すると、DPOP_JKTを使用するクライアントがフロントチャネルとプッシュされた認証要求を区別する必要がないことを保証します。同時に、すべての呼び出しを許可サーバーエンドポイントに保護するためのコードパスを1つだけ持っているクライアントは、リクエストを区別する必要がありません。PARエンドポイントとトークンエンドポイントへ。"
    },
    {
      "indent": 0,
      "text": "11. Security Considerations",
      "section_title": true,
      "ja": "11. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "In DPoP, the prevention of token replay at a different endpoint (see Section 2) is achieved through authentication of the server per [RFC6125] and the binding of the DPoP proof to a certain URI and HTTP method. However, DPoP has a somewhat different nature of protection than TLS-based methods such as OAuth Mutual TLS [RFC8705] or OAuth Token Binding [TOKEN-BINDING] (see also Sections 11.1 and 11.7). TLS-based mechanisms can leverage a tight integration between the TLS layer and the application layer to achieve strong message integrity, authenticity, and replay protection.",
      "ja": "DPOPでは、別のエンドポイントでのトークンリプレイの防止（セクション2を参照）は、[RFC6125]ごとにサーバーの認証とDPOPプルーフの特定のURIおよびHTTPメソッドへの結合によって達成されます。ただし、DPOPには、OAuth相互TLS [RFC8705]やOAuthトークン結合[トークンバインディング]などのTLSベースの方法とは多少異なる保護の性質があります（セクション11.1および11.7も参照）。TLSベースのメカニズムは、TLSレイヤーとアプリケーションレイヤー間の緊密な統合を活用して、強力なメッセージの整合性、信頼性、およびリプレイ保護を実現できます。"
    },
    {
      "indent": 0,
      "text": "11.1. DPoP Proof Replay",
      "section_title": true,
      "ja": "11.1. DPOPプルーフリプレイ"
    },
    {
      "indent": 3,
      "text": "If an adversary is able to get hold of a DPoP proof JWT, the adversary could replay that token at the same endpoint (the HTTP endpoint and method are enforced via the respective claims in the JWTs). To limit this, servers MUST only accept DPoP proofs for a limited time after their creation (preferably only for a relatively brief period on the order of seconds or minutes).",
      "ja": "敵がDPOPプルーフJWTを手に入れることができる場合、敵は同じエンドポイントでトークンを再生できます（HTTPエンドポイントと方法は、JWTSのそれぞれのクレームを介して施行されます）。これを制限するには、サーバーは作成後の限られた時間のためにDPOPプルーフのみを受け入れる必要があります（できれば、秒または数分の順序で比較的短い期間のみ）。"
    },
    {
      "indent": 3,
      "text": "In the context of the target URI, servers can store the jti value of each DPoP proof for the time window in which the respective DPoP proof JWT would be accepted to prevent multiple uses of the same DPoP proof. HTTP requests to the same URI for which the jti value has been seen before would be declined. When strictly enforced, such a single-use check provides a very strong protection against DPoP proof replay, but it may not always be feasible in practice, e.g., when multiple servers behind a single endpoint have no shared state.",
      "ja": "ターゲットURIのコンテキストでは、サーバーは、同じDPOPプルーフの複数の使用を防ぐためにそれぞれのDPOP証明JWTが受け入れられる時間ウィンドウの各DPOP証明のJTI値を保存できます。HTTPは、以前にJTI値が見られたのと同じURIにリクエストされます。厳密に施行された場合、このような使い捨てチェックはDPOPプルーフリプレイに対する非常に強力な保護を提供しますが、たとえば、単一のエンドポイントの背後にある複数のサーバーに共有状態がない場合、実際には必ずしも実行可能ではない場合があります。"
    },
    {
      "indent": 3,
      "text": "In order to guard against memory exhaustion attacks, a server that is tracking jti values should reject DPoP proof JWTs with unnecessarily large jti values or store only a hash thereof.",
      "ja": "メモリの消耗攻撃を防ぐために、JTI値を追跡しているサーバーは、不必要に大きなJTI値を持つDPOP証明JWTを拒否するか、そのハッシュのみを保存する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: To accommodate for clock offsets, the server MAY accept DPoP proofs that carry an iat time in the reasonably near future (on the order of seconds or minutes). Because clock skews between servers and clients may be large, servers MAY limit DPoP proof lifetimes by using server-provided nonce values containing the time at the server rather than comparing the client-supplied iat time to the time at the server. Nonces created in this way yield the same result even in the face of arbitrarily large clock skews.",
      "ja": "注：クロックオフセットに対応するために、サーバーは、適度に近い将来（秒または数分で）にIAT時間を運ぶDPOPプルーフを受け入れる場合があります。サーバーとクライアントの間のクロックスキューは大規模である可能性があるため、サーバーは、サーバーの時間とサーバーの時間を比較するのではなく、サーバーでの時間を含むサーバーが提供するNonCE値を使用することにより、DPOP証明の寿命を制限する場合があります。このようにして作成されたノンセスは、任意に大きなクロックスキューに直面しても同じ結果をもたらします。"
    },
    {
      "indent": 3,
      "text": "Server-provided nonces are an effective means for further reducing the chances for successful DPoP proof replay. Unlike cryptographic nonces, it is acceptable for clients to use the same nonce multiple times and for the server to accept the same nonce multiple times. As long as the jti value is tracked and duplicates are rejected for the lifetime of the nonce, there is no additional risk of token replay.",
      "ja": "サーバーが提供するNoncesは、DPOPプルーフリプレイを成功させる可能性をさらに減らすための効果的な手段です。暗号化のノンセスとは異なり、クライアントは同じノンセを複数回使用し、サーバーが同じNONCEを複数回受け入れることは許容されます。JTI値が追跡され、非CEの寿命のために重複が拒否される限り、トークンリプレイの追加のリスクはありません。"
    },
    {
      "indent": 0,
      "text": "11.2. DPoP Proof Pre-generation",
      "section_title": true,
      "ja": "11.2. DPOPプルーフプレジェネレーション"
    },
    {
      "indent": 3,
      "text": "An attacker in control of the client can pre-generate DPoP proofs for specific endpoints arbitrarily far into the future by choosing the iat value in the DPoP proof to be signed by the proof-of-possession key. Note that one such attacker is the person who is the legitimate user of the client. The user may pre-generate DPoP proofs to exfiltrate from the machine possessing the proof-of-possession key upon which they were generated and copy them to another machine that does not possess the key. For instance, a bank employee might pre-generate DPoP proofs on a bank computer and then copy them to another machine for use in the future, thereby bypassing bank audit controls. When DPoP proofs can be pre-generated and exfiltrated, all that is actually being proved in DPoP protocol interactions is possession of a DPoP proof -- not of the proof-of-possession key.",
      "ja": "クライアントを制御する攻撃者は、DPOP証明のIAT値を選択することにより、特定のエンドポイントのDPOPプルーフを任意に任意に任意に任意に任命することができます。そのような攻撃者の1人は、クライアントの正当なユーザーである人であることに注意してください。ユーザーは、DPOPプルーフを事前に生成して、生成されたプルーフオブポッセッションキーを所有しているマシンから除去し、キーを所有していない別のマシンにコピーすることができます。たとえば、銀行の従業員は、銀行コンピューターでDPOPプルーフを事前に生成し、将来使用するために別のマシンにコピーして、銀行の監査管理をバイパスする場合があります。DPOPプルーフを事前に生成して拡張できる場合、DPOPプロトコルの相互作用で実際に証明されているのは、dPOP証明の所有であり、プルーフオブポッセッションキーではありません。"
    },
    {
      "indent": 3,
      "text": "Use of server-provided nonce values that are not predictable by attackers can prevent this attack. By providing new nonce values at times of its choosing, the server can limit the lifetime of DPoP proofs, preventing pre-generated DPoP proofs from being used. When server-provided nonces are used, possession of the proof-of-possession key is being demonstrated -- not just possession of a DPoP proof.",
      "ja": "攻撃者が予測できないサーバーが提供するNonCE値を使用すると、この攻撃を防ぐことができます。選択したときに新しいNonCe値を提供することにより、サーバーはDPOPプルーフの寿命を制限し、事前に生成されたDPOPプルーフが使用されないようにすることができます。サーバーが提供するNoncesが使用される場合、DPOP証明の所持だけでなく、プルーフオブポッセッションキーの所持が実証されています。"
    },
    {
      "indent": 3,
      "text": "The ath claim limits the use of pre-generated DPoP proofs to the lifetime of the access token. Deployments that do not utilize the nonce mechanism SHOULD NOT issue long-lived DPoP constrained access tokens, preferring instead to use short-lived access tokens and refresh tokens. Whilst an attacker could pre-generate DPoP proofs to use the refresh token to obtain a new access token, they would be unable to realistically pre-generate DPoP proofs to use a newly issued access token.",
      "ja": "ATH請求は、事前に生成されたDPOPプルーフの使用がアクセストークンの寿命に制限されています。NonCEメカニズムを利用していない展開は、長寿命のDPOP制約付きアクセストークンを発行しないでください。代わりに、短命のアクセストークンを使用してトークンを更新することを好みます。攻撃者はDPOPプルーフを事前に生成して更新トークンを使用して新しいアクセストークンを取得できますが、DPOPプルーフを現実的に事前に生成して、新しく発行されたアクセストークンを使用することはできません。"
    },
    {
      "indent": 0,
      "text": "11.3. DPoP Nonce Downgrade",
      "section_title": true,
      "ja": "11.3. DPOP NonCeダウングレード"
    },
    {
      "indent": 3,
      "text": "A server MUST NOT accept any DPoP proofs without the nonce claim when a DPoP nonce has been provided to the client.",
      "ja": "サーバーは、DPOP NonCeがクライアントに提供された場合、NonCeの請求なしにDPOPプルーフを受け入れてはなりません。"
    },
    {
      "indent": 0,
      "text": "11.4. Untrusted Code in the Client Context",
      "section_title": true,
      "ja": "11.4. クライアントコンテキストの信頼できないコード"
    },
    {
      "indent": 3,
      "text": "If an adversary is able to run code in the client's execution context, the security of DPoP is no longer guaranteed. Common issues in web applications leading to the execution of untrusted code are XSS and remote code inclusion attacks.",
      "ja": "敵がクライアントの実行コンテキストでコードを実行できる場合、DPOPのセキュリティは保証されなくなります。信頼されていないコードの実行につながるWebアプリケーションの一般的な問題は、XSSとリモートコードインクルージョン攻撃です。"
    },
    {
      "indent": 3,
      "text": "If the private key used for DPoP is stored in such a way that it cannot be exported, e.g., in a hardware or software security module, the adversary cannot exfiltrate the key and use it to create arbitrary DPoP proofs. The adversary can, however, create new DPoP proofs as long as the client is online and uses these proofs (together with the respective tokens) either on the victim's device or on a device under the attacker's control to send arbitrary requests that will be accepted by servers.",
      "ja": "DPOPに使用される秘密キーが、たとえばハードウェアまたはソフトウェアセキュリティモジュールでエクスポートできないように保存されている場合、敵はキーを除去して任意のDPOPプルーフを作成することができません。ただし、クライアントがオンラインである限り、敵は新しいDPOPプルーフを作成し、これらの証明を（それぞれのトークンと一緒に）被害者のデバイスまたは攻撃者の管理下にあるデバイスで使用して、任意のリクエストを送信することができます。サーバー。"
    },
    {
      "indent": 3,
      "text": "To send requests even when the client is offline, an adversary can try to pre-compute DPoP proofs using timestamps in the future and exfiltrate these together with the access or refresh token.",
      "ja": "クライアントがオフラインである場合でもリクエストを送信するには、敵は将来のタイムスタンプを使用してDPOPプルーフを事前に計算し、アクセスまたは更新トークンとともにこれらを除外しようとすることができます。"
    },
    {
      "indent": 3,
      "text": "An adversary might further try to associate tokens issued from the token endpoint with a key pair under the adversary's control. One way to achieve this is to modify existing code, e.g., by replacing cryptographic APIs. Another way is to launch a new authorization grant between the client and the authorization server in an iframe. This grant needs to be \"silent\", i.e., not require interaction with the user. With code running in the client's origin, the adversary has access to the resulting authorization code and can use it to associate their own DPoP keys with the tokens returned from the token endpoint. The adversary is then able to use the resulting tokens on their own device even if the client is offline.",
      "ja": "敵はさらに、トークンのエンドポイントから発行されたトークンを敵のコントロールの下でキーペアと関連付けることを試みるかもしれません。これを達成する1つの方法は、既存のコードを変更することです。たとえば、暗号化APIを交換することです。もう1つの方法は、IFRAMEでクライアントと承認サーバーの間に新しい承認助成金を起動することです。この助成金は「サイレント」である必要があります。つまり、ユーザーとのやり取りを必要としません。クライアントの起源でコードが実行されているため、敵は結果として生じる承認コードにアクセスでき、それを使用して、独自のDPOPキーをトークンエンドポイントから返したトークンに関連付けることができます。敵は、クライアントがオフラインである場合でも、結果のトークンを独自のデバイスで使用できます。"
    },
    {
      "indent": 3,
      "text": "Therefore, protecting clients against the execution of untrusted code is extremely important even if DPoP is used. Besides secure coding practices, Content Security Policy [W3C.CSP] can be used as a second layer of defense against XSS.",
      "ja": "したがって、DPOPを使用しても、信頼できないコードの実行からクライアントを保護することは非常に重要です。安全なコーディングプラクティスに加えて、コンテンツセキュリティポリシー[W3C.CSP]は、XSSに対する第2の防御層として使用できます。"
    },
    {
      "indent": 0,
      "text": "11.5. Signed JWT Swapping",
      "section_title": true,
      "ja": "11.5. 署名されたJWTスワッピング"
    },
    {
      "indent": 3,
      "text": "Servers accepting signed DPoP proof JWTs MUST verify that the typ field is dpop+jwt in the headers of the JWTs to ensure that adversaries cannot use JWTs created for other purposes.",
      "ja": "署名済みのDPOP証明JWTSを受け入れるサーバーは、TypフィールドがJWTSのヘッダーのDPOP JWTであることを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "11.6. Signature Algorithms",
      "section_title": true,
      "ja": "11.6. 署名アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Implementers MUST ensure that only asymmetric digital signature algorithms (such as ES256) that are deemed secure can be used for signing DPoP proofs. In particular, the algorithm none MUST NOT be allowed.",
      "ja": "実装者は、安全であるとみなされる非対称デジタル署名アルゴリズム（ES256など）のみがDPOPプルーフの署名に使用できることを確認する必要があります。特に、アルゴリズムは許可されてはなりません。"
    },
    {
      "indent": 0,
      "text": "11.7. Request Integrity",
      "section_title": true,
      "ja": "11.7. 整合性を要求します"
    },
    {
      "indent": 3,
      "text": "DPoP does not ensure the integrity of the payload or headers of requests. The DPoP proof only contains claims for the HTTP URI and method, but not the message body or general request headers, for example.",
      "ja": "DPOPは、ペイロードまたはリクエストのヘッダーの整合性を保証しません。DPOPプルーフには、HTTP URIとメソッドのクレームのみが含まれていますが、たとえばメッセージ本文または一般的な要求ヘッダーは含まれません。"
    },
    {
      "indent": 3,
      "text": "This is an intentional design decision intended to keep DPoP simple to use, but as described, it makes DPoP potentially susceptible to replay attacks where an attacker is able to modify message contents and headers. In many setups, the message integrity and confidentiality provided by TLS is sufficient to provide a good level of protection.",
      "ja": "これは、DPOPを使用できるようにすることを目的とした意図的な設計決定ですが、説明されているように、攻撃者がメッセージコンテンツとヘッダーを変更できる場合、DPOPが攻撃を再生しやすくなります。多くのセットアップでは、TLSが提供するメッセージの整合性と機密性は、適切なレベルの保護を提供するのに十分です。"
    },
    {
      "indent": 3,
      "text": "Note: While signatures covering other parts of requests are out of the scope of this specification, additional information to be signed can be added into DPoP proofs.",
      "ja": "注：リクエストの他の部分をカバーする署名はこの仕様の範囲外ではありませんが、署名する追加情報はDPOPプルーフに追加できます。"
    },
    {
      "indent": 0,
      "text": "11.8. Access Token and Public Key Binding",
      "section_title": true,
      "ja": "11.8. アクセストークンと公開キーのバインディング"
    },
    {
      "indent": 3,
      "text": "The binding of the access token to the DPoP public key, as specified in Section 6, uses a cryptographic hash of the JWK representation of the public key. It relies on the hash function having sufficient second-preimage resistance so as to make it computationally infeasible to find or create another key that produces to the same hash output value. The SHA-256 hash function was used because it meets the aforementioned requirement while being widely available.",
      "ja": "セクション6で指定されているように、DPOP公開キーへのアクセストークンの結合は、公開キーのJWK表現の暗号化ハッシュを使用しています。同じハッシュ出力値を生成する別のキーを見つけたり作成したりするために、計算上無効にするために、十分な2番目のプリメージ抵抗を持つハッシュ関数に依存しています。SHA-256ハッシュ関数は、広く利用可能である間、前述の要件を満たしているため使用されました。"
    },
    {
      "indent": 3,
      "text": "Similarly, the binding of the DPoP proof to the access token uses a hash of that access token as the value of the ath claim in the DPoP proof (see Section 4.2). This relies on the value of the hash being sufficiently unique so as to reliably identify the access token. The collision resistance of SHA-256 meets that requirement.",
      "ja": "同様に、DPOP証明のアクセストークンへの結合は、DPOPプルーフのATH請求の値としてそのアクセストークンのハッシュを使用します（セクション4.2を参照）。これは、アクセストークンを確実に識別するために、ハッシュの値が十分に一意であることに依存しています。SHA-256の衝突抵抗は、その要件を満たしています。"
    },
    {
      "indent": 0,
      "text": "11.9. Authorization Code and Public Key Binding",
      "section_title": true,
      "ja": "11.9. 承認コードと公開キーバインディング"
    },
    {
      "indent": 3,
      "text": "Cryptographic binding of the authorization code to the DPoP public key is specified in Section 10. This binding prevents attacks in which the attacker captures the authorization code and creates a DPoP proof using a proof-of-possession key other than the one held by the client and redeems the authorization code using that DPoP proof. By ensuring end to end that only the client's DPoP key can be used, this prevents captured authorization codes from being exfiltrated and used at locations other than the one to which the authorization code was issued.",
      "ja": "DPOP公開キーへの承認コードの暗号化バインディングは、セクション10で指定されています。このバインディングは、攻撃者が認証コードをキャプチャし、クライアントが保持しているもの以外のキーを使用してDPOP証明を作成する攻撃を防ぎます。そのDPOP証明を使用して認証コードを引き換えます。クライアントのDPOPキーのみを使用できることをエンドエンドで確実にすることにより、キャプチャされた認証コードが抽出され、認証コードが発行された場所以外の場所で使用されるのを防ぎます。"
    },
    {
      "indent": 3,
      "text": "Authorization codes can, for instance, be harvested by attackers from places where the HTTP messages containing them are logged. Even when efforts are made to make authorization codes one-time-use, in practice, there is often a time window during which attackers can replay them. For instance, when authorization servers are implemented as scalable replicated services, some replicas may temporarily not yet have the information needed to prevent replay. DPoP binding of the authorization code solves these problems.",
      "ja": "たとえば、承認コードは、それらを含むHTTPメッセージが記録される場所から攻撃者が収穫することができます。実際には、承認コードを1回限り使用する努力が行われた場合でも、攻撃者がそれらを再生できる時間枠がしばしばあります。たとえば、承認サーバーがスケーラブルな複製サービスとして実装されている場合、一部のレプリカは、再生を防ぐために必要な情報を一時的に持っていない場合があります。承認コードのDPOPバインディングは、これらの問題を解決します。"
    },
    {
      "indent": 3,
      "text": "If an authorization server does not (or cannot) strictly enforce the single-use limitation for authorization codes and an attacker can access the authorization code (and if PKCE is used, the code_verifier), the attacker can create a forged token request, binding the resulting token to an attacker-controlled key. For example, using XSS, attackers might obtain access to the authorization code and PKCE parameters. Use of the dpop_jkt parameter prevents this attack.",
      "ja": "承認サーバーが認証コードの単一使用制限を厳密に施行していない（またはできない）場合、攻撃者が認証コードにアクセスできる場合（およびPKCEが使用された場合、code_verifier）、攻撃者は鍛造トークンリクエストを作成し、その結果、攻撃者が制御するキーへのトークン。たとえば、XSSを使用すると、攻撃者は承認コードとPKCEパラメーターへのアクセスを取得する場合があります。DPOP_JKTパラメーターを使用すると、この攻撃が防止されます。"
    },
    {
      "indent": 3,
      "text": "The binding of the authorization code to the DPoP public key uses a JWK Thumbprint of the public key, just as the access token binding does. The same JWK Thumbprint considerations apply.",
      "ja": "DPOP公開キーへの承認コードのバインディングは、アクセストークンバインディングと同様に、公開キーのJWKサムプリントを使用します。同じJWK Thumbprintの考慮事項が適用されます。"
    },
    {
      "indent": 0,
      "text": "11.10. Hash Algorithm Agility",
      "section_title": true,
      "ja": "11.10. ハッシュアルゴリズムの俊敏性"
    },
    {
      "indent": 3,
      "text": "The jkt confirmation method member, the ath JWT claim, and the dpop_jkt authorization request parameter defined herein all use the output of the SHA-256 hash function as their value. The use of a single hash function by this specification was intentional and aimed at simplicity and avoidance of potential security and interoperability issues arising from common mistakes implementing and deploying parameterized algorithm agility schemes. However, the use of a different hash function is not precluded if future circumstances change and make SHA-256 insufficient for the requirements of this specification. Should that need arise, it is expected that a short specification will be produced that updates this one. Using the output of an appropriate hash function as the value, that specification will likely define a new confirmation method member, a new JWT claim, and a new authorization request parameter. These items will be used in place of, or alongside, their respective counterparts in the same message structures and flows of the larger protocol defined by this specification.",
      "ja": "JKT確認方法メンバー、ATH JWTクレーム、およびここで定義されているDPOP_JKT認証要求パラメーターはすべて、SHA-256ハッシュ関数の出力を値として使用します。この仕様による単一のハッシュ関数の使用は意図的であり、パラメーター化されたアルゴリズムの俊敏性スキームを実装および展開する一般的な間違いから生じる潜在的なセキュリティと相互運用性の問題のシンプルさと回避を目的としています。ただし、将来の状況が変化し、この仕様の要件にSHA-256が不十分になった場合、異なるハッシュ関数の使用は排除されません。その必要が発生した場合、これを更新する短い仕様が作成されることが予想されます。適切なハッシュ関数の出力を値として使用すると、その仕様により、新しい確認方法メンバー、新しいJWTクレーム、および新しい承認要求パラメーターが定義される可能性があります。これらの項目は、この仕様で定義されたより大きなプロトコルの同じメッセージ構造とフローの代わりに、またはそれぞれの対応物の代わりに使用されます。"
    },
    {
      "indent": 0,
      "text": "11.11. Binding to Client Identity",
      "section_title": true,
      "ja": "11.11. クライアントのアイデンティティへの拘束"
    },
    {
      "indent": 3,
      "text": "In cases where DPoP is used with client authentication, it is only bound to authentication by being coincident in the same TLS tunnel. Since the DPoP proof is not directly bound to the authentication cryptographically, it's possible that the authentication or the DPoP messages were copied into the tunnel. While including the URI in the DPoP can partially mitigate some of this risk, modifying the authentication mechanism to provide cryptographic binding between authentication and DPoP could provide better protection. However, providing additional binding with authentication through the modification of authentication mechanisms or other means is beyond the scope of this specification.",
      "ja": "DPOPがクライアント認証で使用されている場合、同じTLSトンネルに一致することにより、認証にのみ拘束されます。DPOPプルーフは認証と暗号化に直接結合していないため、認証またはDPOPメッセージがトンネルにコピーされた可能性があります。DPOPにURIを含めることは、このリスクの一部を部分的に軽減できますが、認証メカニズムを変更して認証とDPOPの間に暗号化結合を提供すると、より良い保護を提供できます。ただし、認証メカニズムまたはその他の手段の変更を通じて認証を伴う追加のバインディングを提供することは、この仕様の範囲を超えています。"
    },
    {
      "indent": 0,
      "text": "12. IANA Considerations",
      "section_title": true,
      "ja": "12. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "12.1. OAuth Access Token Types Registration",
      "section_title": true,
      "ja": "12.1. OAUTHアクセストークンタイプの登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following access token type in the \"OAuth Access Token Types\" registry [IANA.OAuth.Params] established by [RFC6749].",
      "ja": "IANAは、[RFC6749]によって確立された「OAuthアクセストークンタイプ」レジストリ[iana.oauth.params]に次のアクセストークンタイプを登録しています。"
    },
    {
      "indent": 3,
      "text": "Name: DPoP",
      "ja": "名前：DPOP"
    },
    {
      "indent": 3,
      "text": "Additional Token Endpoint Response Parameters: (none)",
      "ja": "追加のトークンエンドポイント応答パラメーター：（なし）"
    },
    {
      "indent": 3,
      "text": "HTTP Authentication Scheme(s): DPoP",
      "ja": "HTTP認証スキーム：DPOP"
    },
    {
      "indent": 3,
      "text": "Change Controller: IETF",
      "ja": "Change Controller：IETF"
    },
    {
      "indent": 3,
      "text": "Reference: RFC 9449",
      "ja": "参照：RFC 9449"
    },
    {
      "indent": 0,
      "text": "12.2. OAuth Extensions Error Registration",
      "section_title": true,
      "ja": "12.2. OAUTH拡張エラー登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following error values in the \"OAuth Extensions Error\" registry [IANA.OAuth.Params] established by [RFC6749].",
      "ja": "IANAは、[RFC6749]によって確立された「OAUTH拡張エラー」レジストリ[IANA.OAUTH.PARAMS]に次のエラー値を登録しています。"
    },
    {
      "indent": 3,
      "text": "Invalid DPoP proof:",
      "ja": "無効なDPOP証明："
    },
    {
      "indent": 6,
      "text": "Name: invalid_dpop_proof",
      "ja": "名前：Invalid_dpop_proof"
    },
    {
      "indent": 6,
      "text": "Usage Location: token error response, resource access error response",
      "ja": "使用法：トークンエラー応答、リソースアクセスエラー応答"
    },
    {
      "indent": 6,
      "text": "Protocol Extension: Demonstrating Proof of Possession (DPoP)",
      "ja": "プロトコル拡張：所有証明の実証（DPOP）"
    },
    {
      "indent": 6,
      "text": "Change Controller: IETF",
      "ja": "Change Controller：IETF"
    },
    {
      "indent": 6,
      "text": "Reference: RFC 9449",
      "ja": "参照：RFC 9449"
    },
    {
      "indent": 3,
      "text": "Use DPoP nonce:",
      "ja": "dpop nonceを使用してください："
    },
    {
      "indent": 6,
      "text": "Name: use_dpop_nonce",
      "ja": "名前：use_dpop_nonce"
    },
    {
      "indent": 6,
      "text": "Usage Location: token error response, resource access error response",
      "ja": "使用法：トークンエラー応答、リソースアクセスエラー応答"
    },
    {
      "indent": 6,
      "text": "Protocol Extension: Demonstrating Proof of Possession (DPoP)",
      "ja": "プロトコル拡張：所有証明の実証（DPOP）"
    },
    {
      "indent": 6,
      "text": "Change Controller: IETF",
      "ja": "Change Controller：IETF"
    },
    {
      "indent": 6,
      "text": "Reference: RFC 9449",
      "ja": "参照：RFC 9449"
    },
    {
      "indent": 0,
      "text": "12.3. OAuth Parameters Registration",
      "section_title": true,
      "ja": "12.3. OAuthパラメーター登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following authorization request parameter in the \"OAuth Parameters\" registry [IANA.OAuth.Params] established by [RFC6749].",
      "ja": "IANAは、[RFC6749]によって確立された「OAUTHパラメーター」レジストリ[IANA.OAUTH.PARAMS]に次の承認要求パラメーターを登録しています。"
    },
    {
      "indent": 3,
      "text": "Name: dpop_jkt",
      "ja": "名前：dpop_jkt"
    },
    {
      "indent": 3,
      "text": "Parameter Usage Location: authorization request",
      "ja": "パラメーターの使用場所：承認リクエスト"
    },
    {
      "indent": 3,
      "text": "Change Controller: IETF",
      "ja": "Change Controller：IETF"
    },
    {
      "indent": 3,
      "text": "Reference: Section 10 of RFC 9449",
      "ja": "参照：RFC 9449のセクション10"
    },
    {
      "indent": 0,
      "text": "12.4. HTTP Authentication Schemes Registration",
      "section_title": true,
      "ja": "12.4. HTTP認証スキーム登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following scheme in the \"HTTP Authentication Schemes\" registry [IANA.HTTP.AuthSchemes] established by [RFC9110], Section 16.4.1.",
      "ja": "IANAは、[RFC9110]、セクション16.4.1によって確立された「HTTP認証スキーム」レジストリ[iana.http.authschemes]に次のスキームを登録しました。"
    },
    {
      "indent": 3,
      "text": "Authentication Scheme Name: DPoP",
      "ja": "認証スキーム名：DPOP"
    },
    {
      "indent": 3,
      "text": "Reference: Section 7.1 of RFC 9449",
      "ja": "参照：RFC 9449のセクション7.1"
    },
    {
      "indent": 0,
      "text": "12.5. Media Type Registration",
      "section_title": true,
      "ja": "12.5. メディアタイプの登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered the application/dpop+jwt media type [RFC2046] in the \"Media Types\" registry [IANA.MediaTypes] in the manner described in [RFC6838], which is used to indicate that the content is a DPoP JWT.",
      "ja": "IANAは、[RFC6838]に記載されている方法で、「メディアタイプ」レジストリ[IANA.Mediatypes]にアプリケーション/DPOP JWTメディアタイプ[RFC2046]を[RFC6838]に登録しました。"
    },
    {
      "indent": 3,
      "text": "Type name: application",
      "ja": "タイプ名：アプリケーション"
    },
    {
      "indent": 3,
      "text": "Subtype name: dpop+jwt",
      "ja": "サブタイプ名：DPOP JWT"
    },
    {
      "indent": 3,
      "text": "Required parameters: n/a",
      "ja": "必要なパラメーター：n/a"
    },
    {
      "indent": 3,
      "text": "Optional parameters: n/a",
      "ja": "オプションのパラメーター：n/a"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: binary. A DPoP JWT is a JWT; JWT values are encoded as a series of base64url-encoded values (some of which may be the empty string) separated by period ('.') characters.",
      "ja": "考慮事項のエンコード：バイナリ。DPOP JWTはJWTです。JWT値は、一連のbase64urlエンコード値（その一部は空の文字列である可能性があります）としてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "Security considerations: See Section 11 of RFC 9449",
      "ja": "セキュリティ上の考慮事項：RFC 9449のセクション11を参照してください"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: n/a",
      "ja": "相互運用性の考慮事項：n/a"
    },
    {
      "indent": 3,
      "text": "Published specification: RFC 9449",
      "ja": "公開された仕様：RFC 9449"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type: Applications using RFC 9449 for application-level proof of possession",
      "ja": "このメディアタイプを使用するアプリケーション：アプリケーションレベルの所有証明にRFC 9449を使用するアプリケーション"
    },
    {
      "indent": 3,
      "text": "Fragment identifier considerations: n/a",
      "ja": "フラグメント識別子の考慮事項：n/a"
    },
    {
      "indent": 3,
      "text": "Additional information:",
      "ja": "追加情報："
    },
    {
      "indent": 6,
      "text": "File extension(s):  n/a\nMacintosh file type code(s):  n/a",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Person & email address to contact for further information: Michael B. Jones, michael_b_jones@hotmail.com",
      "ja": "詳細については、人とメールアドレスをお問い合わせ：Michael B. Jones、Michael_b_jones@hotmail.com"
    },
    {
      "indent": 3,
      "text": "Intended usage: COMMON",
      "ja": "意図された使用法：共通"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage: none",
      "ja": "使用に関する制限：なし"
    },
    {
      "indent": 3,
      "text": "Author: Michael B. Jones, michael_b_jones@hotmail.com",
      "ja": "著者：Michael B. Jones、Michael_b_jones@hotmail.com"
    },
    {
      "indent": 3,
      "text": "Change controller: IETF",
      "ja": "Change Controller：IETF"
    },
    {
      "indent": 0,
      "text": "12.6. JWT Confirmation Methods Registration",
      "section_title": true,
      "ja": "12.6. JWT確認方法登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following JWT cnf member value in the \"JWT Confirmation Methods\" registry [IANA.JWT] established by [RFC7800].",
      "ja": "IANAは、[RFC7800]によって確立された「JWT確認方法」レジストリ[IANA.JWT]に次のJWT CNFメンバー値を登録しています。"
    },
    {
      "indent": 3,
      "text": "Confirmation Method Value: jkt",
      "ja": "確認方法値：JKT"
    },
    {
      "indent": 3,
      "text": "Confirmation Method Description: JWK SHA-256 Thumbprint",
      "ja": "確認方法説明：JWK SHA-256 Thumbprint"
    },
    {
      "indent": 3,
      "text": "Change Controller: IETF",
      "ja": "Change Controller：IETF"
    },
    {
      "indent": 3,
      "text": "Reference: Section 6 of RFC 9449",
      "ja": "参照：RFC 9449のセクション6"
    },
    {
      "indent": 0,
      "text": "12.7. JSON Web Token Claims Registration",
      "section_title": true,
      "ja": "12.7. JSON Webトークンは登録を主張します"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following Claims in the \"JSON Web Token Claims\" registry [IANA.JWT] established by [RFC7519].",
      "ja": "IANAは、[RFC7519]によって確立された「JSON Webトークンクレーム」レジストリ[IANA.JWT]に次のクレームを登録しています。"
    },
    {
      "indent": 3,
      "text": "HTTP method:",
      "ja": "HTTPメソッド："
    },
    {
      "indent": 6,
      "text": "Claim Name: htm",
      "ja": "クレーム名：HTM"
    },
    {
      "indent": 6,
      "text": "Claim Description: The HTTP method of the request",
      "ja": "クレーム説明：リクエストのHTTPメソッド"
    },
    {
      "indent": 6,
      "text": "Change Controller: IETF",
      "ja": "Change Controller：IETF"
    },
    {
      "indent": 6,
      "text": "Reference: Section 4.2 of RFC 9449",
      "ja": "参照：RFC 9449のセクション4.2"
    },
    {
      "indent": 3,
      "text": "HTTP URI:",
      "ja": "http uri："
    },
    {
      "indent": 6,
      "text": "Claim Name: htu",
      "ja": "クレーム名：HTU"
    },
    {
      "indent": 6,
      "text": "Claim Description: The HTTP URI of the request (without query and fragment parts)",
      "ja": "クレームの説明：リクエストのHTTP URI（クエリとフラグメントパーツなし）"
    },
    {
      "indent": 6,
      "text": "Change Controller: IETF",
      "ja": "Change Controller：IETF"
    },
    {
      "indent": 6,
      "text": "Reference: Section 4.2 of RFC 9449",
      "ja": "参照：RFC 9449のセクション4.2"
    },
    {
      "indent": 3,
      "text": "Access token hash:",
      "ja": "アクセストークンハッシュ："
    },
    {
      "indent": 6,
      "text": "Claim Name: ath",
      "ja": "クレーム名：ath"
    },
    {
      "indent": 6,
      "text": "Claim Description: The base64url-encoded SHA-256 hash of the ASCII encoding of the associated access token's value",
      "ja": "クレームの説明：関連するアクセストークンの値のASCIIエンコードのbase64urlエンコードSHA-256ハッシュ"
    },
    {
      "indent": 6,
      "text": "Change Controller: IETF",
      "ja": "Change Controller：IETF"
    },
    {
      "indent": 6,
      "text": "Reference: Section 4.2 of RFC 9449",
      "ja": "参照：RFC 9449のセクション4.2"
    },
    {
      "indent": 0,
      "text": "12.7.1. \"nonce\" Registration Update",
      "section_title": true,
      "ja": "12.7.1. 「NonCe」登録更新"
    },
    {
      "indent": 3,
      "text": "The Internet Security Glossary [RFC4949] provides a useful definition of nonce as a random or non-repeating value that is included in data exchanged by a protocol, usually for the purpose of guaranteeing liveness and thus detecting and protecting against replay attacks.",
      "ja": "インターネットセキュリティ用語集[RFC4949]は、通常、livenivesを保証し、したがってリプレイ攻撃から検出および保護する目的で、プロトコルによって交換されるデータに含まれるランダムまたは非繰り返しの値としてのNonCEの有用な定義を提供します。"
    },
    {
      "indent": 3,
      "text": "However, the initial registration of the nonce claim by [OpenID.Core] used language that was contextually specific to that application, which was potentially limiting to its general applicability.",
      "ja": "ただし、[OpenID.Core]によるNONCE請求の初期登録は、そのアプリケーションに文脈的に固有の言語を使用しました。"
    },
    {
      "indent": 3,
      "text": "Therefore, IANA has updated the entry for nonce in the \"JSON Web Token Claims\" registry [IANA.JWT] with an expanded definition to reflect that the claim can be used appropriately in other contexts and with the addition of this document as a reference, as follows.",
      "ja": "したがって、IANAは、「JSON Webトークンクレーム」レジストリ[IANA.JWT]のNONCEのエントリを更新しました。拡張された定義で、クレームは他のコンテキストで適切に使用できることを反映し、このドキュメントを参照として追加できることを反映しています。次のように。"
    },
    {
      "indent": 3,
      "text": "Claim Name: nonce",
      "ja": "クレーム名：ノンセ"
    },
    {
      "indent": 3,
      "text": "Claim Description: Value used to associate a Client session with an ID Token (MAY also be used for nonce values in other applications of JWTs)",
      "ja": "クレームの説明：クライアントセッションをIDトークンに関連付けるために使用される値（JWTSの他のアプリケーションのNonCE値にも使用される場合があります）"
    },
    {
      "indent": 3,
      "text": "Change Controller: OpenID Foundation Artifact Binding Working Group, openid-specs-ab@lists.openid.net",
      "ja": "Change Controller：OpenID Foundation Artifact Binding Working Group、OpenID-Specs-ab@lists.openid.net"
    },
    {
      "indent": 3,
      "text": "Specification Document(s): Section 2 of [OpenID.Core] and RFC 9449",
      "ja": "仕様文書：[OpenID.Core]およびRFC 9449のセクション2"
    },
    {
      "indent": 0,
      "text": "12.8. Hypertext Transfer Protocol (HTTP) Field Name Registration",
      "section_title": true,
      "ja": "12.8. ハイパーテキスト転送プロトコル（HTTP）フィールド名登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following HTTP header fields, as specified by this document, in the \"Hypertext Transfer Protocol (HTTP) Field Name Registry\" [IANA.HTTP.Fields] established by [RFC9110]:",
      "ja": "IANAは、このドキュメントで指定された「HyperText Transfer Protocol（HTTP）フィールド名レジストリ」[IANA.http.Fields]によって[RFC9110]によって確立された「Iana.http.Fields]に次のHTTPヘッダーフィールドを登録しています。"
    },
    {
      "indent": 3,
      "text": "DPoP:",
      "ja": "DEPOP："
    },
    {
      "indent": 6,
      "text": "Field Name: DPoP",
      "ja": "フィールド名：DPOP"
    },
    {
      "indent": 6,
      "text": "Status: permanent",
      "ja": "ステータス：永続的"
    },
    {
      "indent": 6,
      "text": "Reference: RFC 9449",
      "ja": "参照：RFC 9449"
    },
    {
      "indent": 3,
      "text": "DPoP-Nonce:",
      "ja": "dpop-nonce："
    },
    {
      "indent": 6,
      "text": "Field Name: DPoP-Nonce",
      "ja": "フィールド名：dpop-nonce"
    },
    {
      "indent": 6,
      "text": "Status: permanent",
      "ja": "ステータス：永続的"
    },
    {
      "indent": 6,
      "text": "Reference: RFC 9449",
      "ja": "参照：RFC 9449"
    },
    {
      "indent": 0,
      "text": "12.9. OAuth Authorization Server Metadata Registration",
      "section_title": true,
      "ja": "12.9. OAuth Authorization Serverメタデータ登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following value in the \"OAuth Authorization Server Metadata\" registry [IANA.OAuth.Params] established by [RFC8414].",
      "ja": "IANAは、[RFC8414]によって確立された「OAuth Authorization Server Metadata」レジストリ[iana.oauth.params]に次の値を登録しています。"
    },
    {
      "indent": 3,
      "text": "Metadata Name: dpop_signing_alg_values_supported",
      "ja": "メタデータ名：dpop_singe_alg_values_supported"
    },
    {
      "indent": 3,
      "text": "Metadata Description: JSON array containing a list of the JWS algorithms supported for DPoP proof JWTs",
      "ja": "メタデータの説明：DPOP証明JWTSでサポートされているJWSアルゴリズムのリストを含むJSONアレイ"
    },
    {
      "indent": 3,
      "text": "Change Controller: IETF",
      "ja": "Change Controller：IETF"
    },
    {
      "indent": 3,
      "text": "Reference: Section 5.1 of RFC 9449",
      "ja": "参照：RFC 9449のセクション5.1"
    },
    {
      "indent": 0,
      "text": "12.10. OAuth Dynamic Client Registration Metadata",
      "section_title": true,
      "ja": "12.10. OAUTH動的クライアント登録メタデータ"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following value in the IANA \"OAuth Dynamic Client Registration Metadata\" registry [IANA.OAuth.Params] established by [RFC7591].",
      "ja": "IANAは、[RFC7591]によって確立されたIANA「OAuth Dynamic Client登録メタデータ」レジストリ[IANA.OAUTH.PARAMS]に次の値を登録しています。"
    },
    {
      "indent": 3,
      "text": "Client Metadata Name: dpop_bound_access_tokens",
      "ja": "クライアントメタデータ名：dpop_bound_access_tokens"
    },
    {
      "indent": 3,
      "text": "Client Metadata Description: Boolean value specifying whether the client always uses DPoP for token requests",
      "ja": "クライアントメタデータの説明：ブール値クライアントが常にトークンリクエストにDPOPを使用するかどうかを指定する"
    },
    {
      "indent": 3,
      "text": "Change Controller: IETF",
      "ja": "Change Controller：IETF"
    },
    {
      "indent": 3,
      "text": "Reference: Section 5.2 of RFC 9449",
      "ja": "参照：RFC 9449のセクション5.2"
    },
    {
      "indent": 0,
      "text": "13. References",
      "section_title": true,
      "ja": "13. 参考文献"
    },
    {
      "indent": 0,
      "text": "13.1. Normative References",
      "section_title": true,
      "ja": "13.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487/RFC2119、1997年3月、<https://www.rfc-editor.org/info/RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <https://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986] Berners-Lee、T.、Fielding、R。、およびL. Masinter、「Uniform Resource Identifier（URI）：Generic Syntax」、Std 66、RFC 3986、DOI 10.17487/RFC3986、2005年1月、<https：//www.rfc-editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, <https://www.rfc-editor.org/info/rfc5234>.",
      "ja": "[RFC5234] Crocker、D.、ed。P. Overell、「構文仕様のための拡張BNF：ABNF：STD 68、RFC 5234、DOI 10.17487/RFC5234、2008年1月、<https://www.rfc-editor.org/info/rfc5234>。"
    },
    {
      "indent": 3,
      "text": "[RFC6125] Saint-Andre, P. and J. Hodges, \"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)\", RFC 6125, DOI 10.17487/RFC6125, March 2011, <https://www.rfc-editor.org/info/rfc6125>.",
      "ja": "[RFC6125] Saint-Andre、P。およびJ. Hodges、「輸送層のセキュリティ（TLS）のコンテキストでX.509（PKIX）証明書を使用したインターネット公開キーインフラストラクチャ内のドメインベースのアプリケーションサービスIDの表現と検証」、RFC 6125、DOI 10.17487/RFC6125、2011年3月、<https://www.rfc-editor.org/info/rfc6125>。"
    },
    {
      "indent": 3,
      "text": "[RFC6749] Hardt, D., Ed., \"The OAuth 2.0 Authorization Framework\", RFC 6749, DOI 10.17487/RFC6749, October 2012, <https://www.rfc-editor.org/info/rfc6749>.",
      "ja": "[RFC6749] Hardt、D.、ed。、「The Oauth 2.0 Authorization Framework」、RFC 6749、DOI 10.17487/RFC6749、2012年10月、<https://www.rfc-editor.org/info/rfc6749>"
    },
    {
      "indent": 3,
      "text": "[RFC6750] Jones, M. and D. Hardt, \"The OAuth 2.0 Authorization Framework: Bearer Token Usage\", RFC 6750, DOI 10.17487/RFC6750, October 2012, <https://www.rfc-editor.org/info/rfc6750>.",
      "ja": "[RFC6750]ジョーンズ、M。およびD.ハード、「OAUTH 2.0認証フレームワーク：ベアラートークンの使用」、RFC 6750、DOI 10.17487/RFC6750、2012年10月、<https://www.rfc-editor.org/info/RFC6750>。"
    },
    {
      "indent": 3,
      "text": "[RFC7515] Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Signature (JWS)\", RFC 7515, DOI 10.17487/RFC7515, May 2015, <https://www.rfc-editor.org/info/rfc7515>.",
      "ja": "[RFC7515] Jones、M.、Bradley、J。、およびN. Sakimura、「JSON Web Signature（JWS）」、RFC 7515、DOI 10.17487/RFC7515、2015年5月、<https://www.rfc-editor.org/info/rfc7515>。"
    },
    {
      "indent": 3,
      "text": "[RFC7517] Jones, M., \"JSON Web Key (JWK)\", RFC 7517, DOI 10.17487/RFC7517, May 2015, <https://www.rfc-editor.org/info/rfc7517>.",
      "ja": "[RFC7517]ジョーンズ、M。、「JSON Webキー（JWK）」、RFC 7517、DOI 10.17487/RFC7517、2015年5月、<https://www.rfc-editor.org/info/rfc7517>。"
    },
    {
      "indent": 3,
      "text": "[RFC7519] Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Token (JWT)\", RFC 7519, DOI 10.17487/RFC7519, May 2015, <https://www.rfc-editor.org/info/rfc7519>.",
      "ja": "[RFC7519] Jones、M.、Bradley、J。、およびN. Sakimura、「JSON Web Token（JWT）」、RFC 7519、DOI 10.17487/RFC7519、2015年5月、<https://www.rfc-editor.org/info/rfc7519>。"
    },
    {
      "indent": 3,
      "text": "[RFC7638] Jones, M. and N. Sakimura, \"JSON Web Key (JWK) Thumbprint\", RFC 7638, DOI 10.17487/RFC7638, September 2015, <https://www.rfc-editor.org/info/rfc7638>.",
      "ja": "[RFC7638]ジョーンズ、M。およびN.サキムラ、「JSON Web Key（JWK）Thumbprint」、RFC 7638、DOI 10.17487/RFC7638、2015年9月、<https://www.rfc-editor.org/info/rfc7638>。"
    },
    {
      "indent": 3,
      "text": "[RFC7800] Jones, M., Bradley, J., and H. Tschofenig, \"Proof-of-Possession Key Semantics for JSON Web Tokens (JWTs)\", RFC 7800, DOI 10.17487/RFC7800, April 2016, <https://www.rfc-editor.org/info/rfc7800>.",
      "ja": "[RFC7800] Jones、M.、Bradley、J。、およびH. Tschofenig、「JSON Web Tokens（JWTS）のプルーフポッセッションキーセマンティクス」、RFC 7800、DOI 10.17487/RFC7800、2016年4月、<https：/<https：//www.rfc-editor.org/info/rfc7800>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの小文字と小文字の曖昧さ」、BCP 14、RFC 8174、DOI 10.17487/RFC8174、2017年5月、<https：//www.rfc-editor.org/info/RFC8174>。"
    },
    {
      "indent": 3,
      "text": "[SHS] National Institute of Standards and Technology, \"Secure Hash Standard (SHS)\", FIPS PUB 180-4, DOI 10.6028/NIST.FIPS.180-4, August 2015, <http://dx.doi.org/10.6028/NIST.FIPS.180-4>.",
      "ja": "[SHS]国立標準技術研究所、「Secure Hash Standard（SHS）」、Fips Pub 180-4、doi 10.6028/nist.fips.180-4、2015年8月、<http://dx.doi.org/10.6028/nist.fips.180-4>。"
    },
    {
      "indent": 0,
      "text": "13.2. Informative References",
      "section_title": true,
      "ja": "13.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[BREACH] CVE, \"CVE-2013-3587\", <https://cve.mitre.org/cgi-bin/ cvename.cgi?name=CVE-2013-3587>.",
      "ja": "[BREACH] CVE、 \"CVE-2013-3587\"、<https://cve.mitre.org/cgi-bin/ cvename.cgi？name = cve-2013-3587>。"
    },
    {
      "indent": 3,
      "text": "[Cloudbleed] Graham-Cumming, J., \"Incident report on memory leak caused by Cloudflare parser bug\", February 2017, <https://blog.cloudflare.com/incident-report-on-memory-leak-caused-by-cloudflare-parser-bug/>.",
      "ja": "[Cloudbleed] Graham-Cumming、J。、「CloudFlareパーサーバグによるメモリリークに関するインシデントレポート」、2017年2月、<https://blog.cloudflare.com/incident-report-on-memory-leak-cause-by--cloudflare-parser-bug/>。"
    },
    {
      "indent": 3,
      "text": "[CRIME] CVE, \"CVE-2012-4929\", <https://cve.mitre.org/cgi-bin/ cvename.cgi?name=cve-2012-4929>.",
      "ja": "[犯罪] CVE、 \"CVE-2012-4929\"、<https://cve.mitre.org/cgi-bin/ cvename.cgi？name = cve-2012-4929>。"
    },
    {
      "indent": 3,
      "text": "[GitHub.Tokens] Hanley, M., \"Security alert: Attack campaign involving stolen OAuth user tokens issued to two third-party integrators\", April 2022, <https://github.blog/2022-04-15- security-alert-stolen-oauth-user-tokens/>.",
      "ja": "[github.tokens] Hanley、M。、「セキュリティアラート：2つのサードパーティインテグレーターに発行された盗まれたOAuthユーザートークンを含む攻撃キャンペーン」、2022年4月、<https://github.blog/2022-04-15-セキュリティ - セキュリティ - alert-stolen-oauth-user-tokens/>。"
    },
    {
      "indent": 3,
      "text": "[Heartbleed] \"CVE-2014-0160\", <https://cve.mitre.org/cgi-bin/ cvename.cgi?name=cve-2014-0160>.",
      "ja": "[heartbleed] \"CVE-2014-0160\"、<https://cve.mitre.org/cgi-bin/ cvename.cgi？name = cve-2014-0160>。"
    },
    {
      "indent": 3,
      "text": "[IANA.HTTP.AuthSchemes] IANA, \"Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry\", <https://www.iana.org/assignments/http-authschemes/>.",
      "ja": "[iana.http.authschemes] iana、 \"HyperText Transfer Protocol（http）認証スキームレジストリ\"、<https://www.iana.org/assignments/http-authschemes/>。"
    },
    {
      "indent": 3,
      "text": "[IANA.HTTP.Fields] IANA, \"Hypertext Transfer Protocol (HTTP) Field Name Registry\", <https://www.iana.org/assignments/http-fields/>.",
      "ja": "[iana.http.fields] iana、 \"HyperText Transfer Protocol（http）フィールド名レジストリ\"、<https://www.iana.org/assignments/http-fields/>。"
    },
    {
      "indent": 3,
      "text": "[IANA.JOSE.ALGS] IANA, \"JSON Web Signature and Encryption Algorithms\", <https://www.iana.org/assignments/jose/>.",
      "ja": "[iana.jose.algs] iana、 \"json web署名および暗号化アルゴリズム\"、<https://www.iana.org/assignments/jose/>。"
    },
    {
      "indent": 3,
      "text": "[IANA.JWT] IANA, \"JSON Web Token Claims\", <https://www.iana.org/assignments/jwt/>.",
      "ja": "[iana.jwt] iana、 \"json webトークンクレーム\"、<https://www.iana.org/assignments/jwt/>。"
    },
    {
      "indent": 3,
      "text": "[IANA.MediaTypes] IANA, \"Media Types\", <https://www.iana.org/assignments/media-types/>.",
      "ja": "[iana.mediatypes] iana、 \"Media Types\"、<https://www.iana.org/assignments/media-types/>。"
    },
    {
      "indent": 3,
      "text": "[IANA.OAuth.Params] IANA, \"OAuth Parameters\", <https://www.iana.org/assignments/oauth-parameters/>.",
      "ja": "[iana.oauth.params] iana、 \"oauth parameters\"、<https://www.iana.org/assignments/oauth-parameters/>。"
    },
    {
      "indent": 3,
      "text": "[OpenID.Core] Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and C. Mortimore, \"OpenID Connect Core 1.0 incorporating errata set 1\", November 2014, <https://openid.net/specs/openid-connect-core-1_0.html>.",
      "ja": "[Openid.core] Sakimura、N.、Bradley、J.、Jones、M.、De Medeiros、B。、およびC. Mortimore、「OpenID Connect Coore 1.0 Errata Set 1を取り入れてください」、2014年11月、<https：//openid.net/specs/openid-connect-core-1_0.html>。"
    },
    {
      "indent": 3,
      "text": "[RFC2046] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types\", RFC 2046, DOI 10.17487/RFC2046, November 1996, <https://www.rfc-editor.org/info/rfc2046>.",
      "ja": "[RFC2046] Freed、N。およびN. Borenstein、「多目的インターネットメール拡張機能（MIME）パート2：メディアタイプ」、RFC 2046、DOI 10.17487/RFC2046、1996年11月、<https：//www.rfc-editor.orgg/info/rfc2046>。"
    },
    {
      "indent": 3,
      "text": "[RFC4122] Leach, P., Mealling, M., and R. Salz, \"A Universally Unique IDentifier (UUID) URN Namespace\", RFC 4122, DOI 10.17487/RFC4122, July 2005, <https://www.rfc-editor.org/info/rfc4122>.",
      "ja": "[RFC4122] Leach、P.、Mealling、M.、およびR. Salz、「普遍的にユニークな識別子（UUID）URNネームスペース」、RFC 4122、DOI 10.17487/RFC4122、2005年7月、<https：//www.rfc-editor.org/info/rfc4122>。"
    },
    {
      "indent": 3,
      "text": "[RFC4949] Shirey, R., \"Internet Security Glossary, Version 2\", FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007, <https://www.rfc-editor.org/info/rfc4949>.",
      "ja": "[RFC4949] Shirey、R。、「インターネットセキュリティ用語集、バージョン2」、FYI 36、RFC 4949、DOI 10.17487/RFC4949、2007年8月、<https://www.rfc-editor.org/info/rfc4949>"
    },
    {
      "indent": 3,
      "text": "[RFC6838] Freed, N., Klensin, J., and T. Hansen, \"Media Type Specifications and Registration Procedures\", BCP 13, RFC 6838, DOI 10.17487/RFC6838, January 2013, <https://www.rfc-editor.org/info/rfc6838>.",
      "ja": "[RFC6838] Freed、N.、Klensin、J。、およびT. Hansen、「メディアタイプの仕様と登録手順」、BCP 13、RFC 6838、DOI 10.17487/RFC6838、2013年1月、<https：//www.rfc-editor.org/info/rfc6838>。"
    },
    {
      "indent": 3,
      "text": "[RFC7523] Jones, M., Campbell, B., and C. Mortimore, \"JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants\", RFC 7523, DOI 10.17487/RFC7523, May 2015, <https://www.rfc-editor.org/info/rfc7523>.",
      "ja": "[RFC7523] Jones、M.、Campbell、B。、およびC. Mortimore、「OAUTH 2.0クライアント認証と認証助成金のJSON Webトークン（JWT）プロファイル」、RFC 7523、DOI 10.17487/RFC7523、2015年5月、<HTTPS：//www.rfc-editor.org/info/rfc7523>。"
    },
    {
      "indent": 3,
      "text": "[RFC7591] Richer, J., Ed., Jones, M., Bradley, J., Machulak, M., and P. Hunt, \"OAuth 2.0 Dynamic Client Registration Protocol\", RFC 7591, DOI 10.17487/RFC7591, July 2015, <https://www.rfc-editor.org/info/rfc7591>.",
      "ja": "[RFC7591] Richer、J.、Ed。、ed。、Jones、M.、Bradley、J.、Machulak、M.、およびP. Hunt、「OAuth 2.0 Dynamic Client Reginterration Protocol」、RFC 7591、DOI 10.17487/RFC7591、2015年7月、<https://www.rfc-editor.org/info/rfc7591>。"
    },
    {
      "indent": 3,
      "text": "[RFC7636] Sakimura, N., Ed., Bradley, J., and N. Agarwal, \"Proof Key for Code Exchange by OAuth Public Clients\", RFC 7636, DOI 10.17487/RFC7636, September 2015, <https://www.rfc-editor.org/info/rfc7636>.",
      "ja": "[RFC7636] Sakimura、N.、Ed。、Bradley、J。、およびN. Agarwal、「Oauth Public Clientsによるコード交換の証拠鍵」、RFC 7636、DOI 10.17487/RFC7636、2015年9月、<https：// wwwwwwwwwwwwwwwww.rfc-editor.org/info/rfc7636>。"
    },
    {
      "indent": 3,
      "text": "[RFC7662] Richer, J., Ed., \"OAuth 2.0 Token Introspection\", RFC 7662, DOI 10.17487/RFC7662, October 2015, <https://www.rfc-editor.org/info/rfc7662>.",
      "ja": "[RFC7662] Richer、J.、ed。、「Oauth 2.0トークン内注文」、RFC 7662、DOI 10.17487/RFC7662、2015年10月、<https://www.rfc-editor.org/info/rfc762>"
    },
    {
      "indent": 3,
      "text": "[RFC8414] Jones, M., Sakimura, N., and J. Bradley, \"OAuth 2.0 Authorization Server Metadata\", RFC 8414, DOI 10.17487/RFC8414, June 2018, <https://www.rfc-editor.org/info/rfc8414>.",
      "ja": "[RFC8414] Jones、M.、Sakimura、N。、およびJ. Bradley、 \"Oauth 2.0 Authorization Server Metadata\"、RFC 8414、DOI 10.17487/RFC8414、2018年6月、<https：//www.rfc-editor.org/情報/RFC8414>。"
    },
    {
      "indent": 3,
      "text": "[RFC8705] Campbell, B., Bradley, J., Sakimura, N., and T. Lodderstedt, \"OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens\", RFC 8705, DOI 10.17487/RFC8705, February 2020, <https://www.rfc-editor.org/info/rfc8705>.",
      "ja": "[RFC8705] Campbell、B.、Bradley、J.、Sakimura、N。、およびT. Lodderstedt、「OAUTH 2.0 Mutual-TLSクライアント認証と証明書バウンドアクセストークン」、RFC 8705、DOI 10.17487/RFC8705、February 2020、<https://www.rfc-editor.org/info/rfc8705>。"
    },
    {
      "indent": 3,
      "text": "[RFC8707] Campbell, B., Bradley, J., and H. Tschofenig, \"Resource Indicators for OAuth 2.0\", RFC 8707, DOI 10.17487/RFC8707, February 2020, <https://www.rfc-editor.org/info/rfc8707>.",
      "ja": "[RFC8707] Campbell、B.、Bradley、J。、およびH. Tschofenig、「OAUTH 2.0のリソースインジケーター」、RFC 8707、DOI 10.17487/RFC8707、2020年2月、<https：//www.rfc-editor.org/情報/RFC8707>。"
    },
    {
      "indent": 3,
      "text": "[RFC8725] Sheffer, Y., Hardt, D., and M. Jones, \"JSON Web Token Best Current Practices\", BCP 225, RFC 8725, DOI 10.17487/RFC8725, February 2020, <https://www.rfc-editor.org/info/rfc8725>.",
      "ja": "[RFC8725] Sheffer、Y.、Hardt、D。、およびM. Jones、「JSON Webトークンベスト現在のプラクティス」、BCP 225、RFC 8725、DOI 10.17487/RFC8725、2020年2月、<https：//www.rfc-editor.org/info/rfc8725>。"
    },
    {
      "indent": 3,
      "text": "[RFC8792] Watsen, K., Auerswald, E., Farrel, A., and Q. Wu, \"Handling Long Lines in Content of Internet-Drafts and RFCs\", RFC 8792, DOI 10.17487/RFC8792, June 2020, <https://www.rfc-editor.org/info/rfc8792>.",
      "ja": "[RFC8792] Watsen、K.、Auerswald、E.、Farrel、A。、およびQ. Wu、「インターネットドラフトとRFCSのコンテンツの長いラインの扱い」、RFC 8792、DOI 10.17487/RFC8792、2020年6月、<：//www.rfc-editor.org/info/rfc8792>。"
    },
    {
      "indent": 3,
      "text": "[RFC9110] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \"HTTP Semantics\", STD 97, RFC 9110, DOI 10.17487/RFC9110, June 2022, <https://www.rfc-editor.org/info/rfc9110>.",
      "ja": "[RFC9110] Fielding、R.、ed。、Nottingham、M.、ed。、およびJ. Reschke、ed。、 \"HTTP Semantics\"、Std 97、RFC 9110、DOI 10.17487/RFC9110、2022年6月、<https：//www.rfc-editor.org/info/rfc9110>。"
    },
    {
      "indent": 3,
      "text": "[RFC9126] Lodderstedt, T., Campbell, B., Sakimura, N., Tonge, D., and F. Skokan, \"OAuth 2.0 Pushed Authorization Requests\", RFC 9126, DOI 10.17487/RFC9126, September 2021, <https://www.rfc-editor.org/info/rfc9126>.",
      "ja": "[RFC9126] Lodderstedt、T.、Campbell、B.、Sakimura、N.、Tonge、D。、およびF. Skokan、「Oauth 2.0プッシュ認証要求」、RFC 9126、DOI 10.17487/RFC9126、2021年9月、<https：<https：//www.rfc-editor.org/info/rfc9126>。"
    },
    {
      "indent": 3,
      "text": "[SECURITY-TOPICS] Lodderstedt, T., Bradley, J., Labunets, A., and D. Fett, \"OAuth 2.0 Security Best Current Practice\", Work in Progress, Internet-Draft, draft-ietf-oauth-security-topics-23, 5 June 2023, <https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-23>.",
      "ja": "[Security-Topics] Lodderstedt、T.、Bradley、J.、Labunets、A。、およびD. Fett、「Oauth 2.0 Security Best Current Practice」、Work in Progress、Internet-Draft、Draft-Iitf-Oauth-Security--Topics-23、2023年6月5日、<https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-23>。"
    },
    {
      "indent": 3,
      "text": "[TOKEN-BINDING] Jones, M., Campbell, B., Bradley, J., and W. Denniss, \"OAuth 2.0 Token Binding\", Work in Progress, Internet-Draft, draft-ietf-oauth-token-binding-08, 19 October 2018, <https://datatracker.ietf.org/doc/html/draft-ietf-oauth-token-binding-08>.",
      "ja": "[トークンバインディング]ジョーンズ、M。、キャンベル、B。、ブラッドリー、J。、およびW.デニス、「OAuth 2.0トークンバインディング」、ワークインセクチン、インターネットドラフト、ドラフト-IITF-OAuth-Tokenバインディング - 08、2018年10月19日、<https://datatracker.ietf.org/doc/html/draft-ietf-oauth-token binding-08>。"
    },
    {
      "indent": 3,
      "text": "[W3C.CSP] West, M., \"Content Security Policy Level 3\", W3C Working Draft, July 2023, <https://www.w3.org/TR/CSP3/>.",
      "ja": "[W3C.CSP] West、M。、「コンテンツセキュリティポリシーレベル3」、W3Cワーキングドラフト、2023年7月、<https://www.w3.org/tr/csp3/>。"
    },
    {
      "indent": 3,
      "text": "[W3C.WebCryptoAPI] Watson, M., \"Web Cryptography API\", W3C Recommendation, January 2017, <https://www.w3.org/TR/2017/REC-WebCryptoAPI-20170126>.",
      "ja": "[w3c.webcryptoapi] Watson、M。、「Web Cryptography API」、W3C推奨、2017年1月、<https://www.w3.org/tr/2017/rec-webcryptoapi-20170126>。"
    },
    {
      "indent": 3,
      "text": "[WHATWG.Fetch] WHATWG, \"Fetch Living Standard\", July 2023, <https://fetch.spec.whatwg.org/>.",
      "ja": "[whatwg.fetch] whatwg、 \"Fetch Living Standard\"、2023年7月、<https://fetch.spec.whatwg.org/>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "We would like to thank Brock Allen, Annabelle Backman, Dominick Baier, Spencer Balogh, Vittorio Bertocci, Jeff Corrigan, Domingos Creado, Philippe De Ryck, Andrii Deinega, William Denniss, Vladimir Dzhuvinov, Mike Engan, Nikos Fotiou, Mark Haine, Dick Hardt, Joseph Heenan, Bjorn Hjelm, Jacob Ideskog, Jared Jennings, Benjamin Kaduk, Pieter Kasselman, Neil Madden, Rohan Mahy, Karsten Meyer zu Selhausen, Nicolas Mora, Steinar Noem, Mark Nottingham, Rob Otto, Aaron Parecki, Michael Peck, Roberto Polli, Paul Querna, Justin Richer, Joseph Salowey, Rifaat Shekh-Yusef, Filip Skokan, Dmitry Telegin, Dave Tonge, Jim Willeke, and others for their valuable input, feedback, and general support of this work.",
      "ja": "ブロック・アレン、アナベル・バックマン、ドミニック・バイアー、スペンサー・バログ、ヴィッツーリオ・ベルトッキ、ジェフ・コリガン、ドミンゴス・クレアド、フィリップ・デ・リック、アンドリ・デネガ、ウィリアム・デニス、ヴラジミール・dzhuvinov、マイク・エング、ニコス・フティウ、マーク・ハード・ヘイ・ヘイ・ヘイ・ヘイ・ヘイ・ヘイイン、ジョセフ・ヒーナン、ビョルン・フジェルム、ジェイコブ・イドスコグ、ジャレッド・ジェニングス、ベンジャミン・カドゥク、ピーター・カッセルマン、ニール・マッデン、ロハン・マヒー、カルステン・マイヤー・ズ・セルハウゼン、ニコラス・モラ、スタインアー・ノーム、マーク・ノッティンガム、ポール・Querna、Justin Richer、Joseph Salowey、Rifaat Shekh-Yusef、Filip Skokan、Dmitry Telegin、Dave Tonge、Jim Willekeなど、この作業の貴重なインプット、フィードバック、一般的なサポート。"
    },
    {
      "indent": 3,
      "text": "This document originated from discussions at the 4th OAuth Security Workshop in Stuttgart, Germany. We thank the organizers of this workshop (Ralf Ksters and Guido Schmitz).",
      "ja": "この文書は、ドイツのシュトゥットガルトで開催された第4 OAuthセキュリティワークショップでの議論から生じています。このワークショップの主催者（Ralf KstersとGuido Schmitz）に感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Daniel Fett Authlete Email: mail@danielfett.de",
      "ja": "Daniel Fett Authleteメール：mail@danielfett.de"
    },
    {
      "indent": 3,
      "text": "Brian Campbell Ping Identity Email: bcampbell@pingidentity.com",
      "ja": "ブライアンキャンベルピンアイデンティティメール：bcampbell@pingidentity.com"
    },
    {
      "indent": 3,
      "text": "John Bradley Yubico Email: ve7jtb@ve7jtb.com",
      "ja": "John Bradley Yubicoメール：ve7jtb@ve7jtb.com"
    },
    {
      "indent": 3,
      "text": "Torsten Lodderstedt Tuconic Email: torsten@lodderstedt.net",
      "ja": "Torsten Lodderstedt Tuconicメール：torsten@lodderstedt.net"
    },
    {
      "indent": 3,
      "text": "Michael Jones Self-Issued Consulting Email: michael_b_jones@hotmail.com URI: https://self-issued.info/",
      "ja": "マイケルジョーンズ自己発行コンサルティングメール：michael_b_jones@hotmail.com URI：https：//self-issued.info/"
    },
    {
      "indent": 3,
      "text": "David Waite Ping Identity Email: david@alkaline-solutions.com",
      "ja": "David Waite Ping Identityメール：David@alkaline-solutions.com"
    }
  ]
}