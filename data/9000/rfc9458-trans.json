{
  "title": {
    "text": "RFC 9458 - Oblivious HTTP",
    "ja": "RFC 9458 - 忘却http"
  },
  "number": 9458,
  "created_at": "2024-01-13 23:47:56.739867+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        M. Thomson\nRequest for Comments: 9458                                       Mozilla\nCategory: Standards Track                                     C. A. Wood\nISSN: 2070-1721                                               Cloudflare\n                                                            January 2024",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 29,
      "text": "Oblivious HTTP",
      "ja": "忘却http"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes Oblivious HTTP, a protocol for forwarding encrypted HTTP messages. Oblivious HTTP allows a client to make multiple requests to an origin server without that server being able to link those requests to the client or to identify the requests as having come from the same client, while placing only limited trust in the nodes used to forward the messages.",
      "ja": "このドキュメントでは、暗号化されたHTTPメッセージを転送するためのプロトコルであるOblivious HTTPについて説明します。忘却HTTPを使用すると、クライアントは、それらの要求をクライアントにリンクすることができず、同じクライアントからのリクエストを識別することなく、クライアントがオリジンサーバーに複数のリクエストを行うことができます。メッセージ。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準トラックドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 7841のセクション2で入手できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9458.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https：//www.rfc-editor.org/info/rfc9458で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2024 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2024 IETF Trustおよび文書著者として特定された人。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。 この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。 このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、改訂されたBSDライセンスで説明されている保証なしで提供されるように、改訂されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n2.  Overview\n  2.1.  Applicability\n  2.2.  Conventions and Definitions\n3.  Key Configuration\n  3.1.  Key Configuration Encoding\n  3.2.  Key Configuration Media Type\n4.  HPKE Encapsulation\n  4.1.  Request Format\n  4.2.  Response Format\n  4.3.  Encapsulation of Requests\n  4.4.  Encapsulation of Responses\n  4.5.  Request and Response Media Types\n  4.6.  Repurposing the Encapsulation Format\n5.  HTTP Usage\n  5.1.  Informational Responses\n  5.2.  Errors\n  5.3.  Signaling Key Configuration Problems\n6.  Security Considerations\n  6.1.  Client Responsibilities\n  6.2.  Relay Responsibilities\n    6.2.1.  Differential Treatment\n    6.2.2.  Denial of Service\n    6.2.3.  Traffic Analysis\n  6.3.  Server Responsibilities\n  6.4.  Key Management\n  6.5.  Replay Attacks\n    6.5.1.  Use of Date for Anti-replay\n    6.5.2.  Correcting Clock Differences\n  6.6.  Forward Secrecy\n  6.7.  Post-Compromise Security\n  6.8.  Client Clock Exposure\n  6.9.  Media Type Security\n  6.10. Separate Gateway and Target\n7.  Privacy Considerations\n8.  Operational and Deployment Considerations\n  8.1.  Performance Overhead\n  8.2.  Resource Mappings\n  8.3.  Network Management\n9.  IANA Considerations\n  9.1.  application/ohttp-keys Media Type\n  9.2.  message/ohttp-req Media Type\n  9.3.  message/ohttp-res Media Type\n  9.4.  Registration of \"date\" Problem Type\n  9.5.  Registration of \"ohttp-key\" Problem Type\n10. References\n  10.1.  Normative References\n  10.2.  Informative References\nAppendix A.  Complete Example of a Request and Response\nAcknowledgments\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "HTTP requests reveal information about client identities to servers. While the actual content of the request message is under the control of the client, other information that is more difficult to control can still be used to identify the client.",
      "ja": "HTTP要求は、クライアントのアイデンティティに関する情報をサーバーに明らかにします。リクエストメッセージの実際のコンテンツはクライアントの制御下にありますが、制御がより困難な他の情報を使用してクライアントを識別することができます。"
    },
    {
      "indent": 3,
      "text": "Even where an IP address is not directly associated with an individual, the requests made from it can be correlated over time to assemble a profile of client behavior. In particular, connection reuse improves performance but provides servers with the ability to link requests that share a connection.",
      "ja": "IPアドレスが個人に直接関連付けられていない場合でも、それから作成された要求は、クライアントの動作のプロファイルを組み立てるために時間とともに相関することができます。特に、接続の再利用はパフォーマンスを改善しますが、接続を共有するリクエストをリンクする機能をサーバーに提供します。"
    },
    {
      "indent": 3,
      "text": "In particular, the source IP address of the underlying connection reveals identifying information that the client has only limited control over. While client-configured HTTP proxies can provide a degree of protection against IP address tracking, they present an unfortunate trade-off: if they are used without TLS, the contents of communication are revealed to the proxy; if they are used with TLS, a new connection needs to be used for each request to ensure that the origin server cannot use the connection as a way to correlate requests, incurring significant performance overheads.",
      "ja": "特に、基礎となる接続のソースIPアドレスは、クライアントが制御を制限しているだけの情報を識別することを明らかにします。クライアントが構成したHTTPプロキシは、IPアドレストラッキングに対するある程度の保護を提供できますが、不幸なトレードオフを提示します。TLSなしで使用される場合、通信の内容がプロキシに明らかになります。TLSで使用されている場合、各リクエストに新しい接続を使用して、Origin Serverがリクエストを相関させる方法として接続を使用できないことを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "To overcome these limitations, this document defines Oblivious HTTP, a protocol for encrypting and sending HTTP messages from a client to a gateway. This uses a trusted relay service in a manner that mitigates the use of metadata such as IP address and connection information for client identification, with reasonable performance characteristics. This document describes:",
      "ja": "これらの制限を克服するために、このドキュメントは、クライアントからゲートウェイにHTTPメッセージを暗号化および送信するためのプロトコルである忘却のHTTPを定義します。これは、合理的なパフォーマンス特性を備えた、クライアント識別のためのIPアドレスや接続情報などのメタデータの使用を軽減する方法で、信頼できるリレーサービスを使用します。このドキュメントは次のように説明しています。"
    },
    {
      "indent": 3,
      "text": "1. an algorithm for encapsulating binary HTTP messages [BINARY] using Hybrid Public Key Encryption (HPKE) [HPKE] to protect their contents,",
      "ja": "1. ハイブリッド公開キー暗号化（HPKE）[HPKE]を使用して、バイナリHTTPメッセージをカプセル化するためのアルゴリズム[バイナリ]のアルゴリズム、コンテンツを保護します。"
    },
    {
      "indent": 3,
      "text": "2. a method for forwarding Encapsulated Requests between Clients and an Oblivious Gateway Resource through a trusted Oblivious Relay Resource using HTTP, and",
      "ja": "2. HTTPを使用した信頼できる忘れられないリレーリソースを介して、クライアントと忘却のゲートウェイリソースの間のカプセル化された要求を転送する方法、および"
    },
    {
      "indent": 3,
      "text": "3. requirements for how the Oblivious Gateway Resource handles Encapsulated Requests and produces Encapsulated Responses for the Client.",
      "ja": "3. 忘却のゲートウェイリソースがカプセル化された要求を処理し、クライアントのカプセル化された応答を生成する方法の要件。"
    },
    {
      "indent": 3,
      "text": "The combination of encapsulation and relaying ensures that Oblivious Gateway Resource never sees the Client's IP address and that the Oblivious Relay Resource never sees plaintext HTTP message content.",
      "ja": "カプセル化と中継の組み合わせにより、忘れられないゲートウェイリソースがクライアントのIPアドレスを決して表示しないこと、および忘却のリレーリソースがプレーンテキストHTTPメッセージコンテンツを表示しないことを保証します。"
    },
    {
      "indent": 3,
      "text": "Oblivious HTTP allows connection reuse between the Client and Oblivious Relay Resource, as well as between that relay and the Oblivious Gateway Resource, so this scheme represents a performance improvement over using just one request in each connection. With limited trust placed in the Oblivious Relay Resource (see Section 6), Clients are assured that requests are not uniquely attributed to them or linked to other requests.",
      "ja": "忘却HTTPを使用すると、クライアントと忘却のリレーリソース、およびそのリレーと忘却のゲートウェイリソースの間の接続の再利用を可能にするため、このスキームは、各接続で1つのリクエストを使用したパフォーマンスの改善を表します。忘れられないリレーリソースに限定された信頼が課されているため（セクション6を参照）、クライアントは、リクエストがそれらに一意に起因するものではないか、他のリクエストにリンクされていないことを保証されています。"
    },
    {
      "indent": 0,
      "text": "2. Overview",
      "section_title": true,
      "ja": "2. 概要"
    },
    {
      "indent": 3,
      "text": "An Oblivious HTTP Client must initially know the following:",
      "ja": "忘却HTTPクライアントは、最初に次のことを知っている必要があります。"
    },
    {
      "indent": 3,
      "text": "* The identity of an Oblivious Gateway Resource. This might include some information about what Target Resources the Oblivious Gateway Resource supports.",
      "ja": "* 気まぐれなゲートウェイリソースのアイデンティティ。これには、忘却のゲートウェイリソースがサポートするターゲットリソースに関する情報が含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "* The details of an HPKE public key for the Oblivious Gateway Resource, including an identifier for that key and the HPKE algorithms that are used with that key.",
      "ja": "* そのキーの識別子と、そのキーで使用されるHPKEアルゴリズムを含む、忘却のゲートウェイリソースのHPKE公開キーの詳細。"
    },
    {
      "indent": 3,
      "text": "* The identity of an Oblivious Relay Resource that will accept relay requests carrying an Encapsulated Request as its content and forward the content in these requests to a particular Oblivious Gateway Resource. Oblivious HTTP uses a one-to-one mapping between Oblivious Relay and Gateway Resources; see Section 8.2 for more details.",
      "ja": "* カプセル化された要求をそのコンテンツとして運ぶリレー要求を受け入れ、これらのリクエストのコンテンツを特定の忘れられないゲートウェイリソースに転送する忘れられないリレーリソースの身元。Oblivious HTTPは、気まぐれなリレーとゲートウェイリソースの間の1対1のマッピングを使用します。詳細については、セクション8.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "This information allows the Client to send HTTP requests to the Oblivious Gateway Resource for forwarding to a Target Resource. The Oblivious Gateway Resource does not learn the Client's IP address or any other identifying information that might be revealed from the Client at the transport layer, nor does the Oblivious Gateway Resource learn which of the requests it receives are from the same Client.",
      "ja": "この情報により、クライアントは、ターゲットリソースに転送するために、HTTPリクエストを忘却のゲートウェイリソースに送信できます。忘れられないゲートウェイリソースは、クライアントのIPアドレスや、輸送層のクライアントから明らかにされる可能性のあるその他の識別情報を学習しません。また、忘却のゲートウェイリソースは、同じクライアントから受け取ったリクエストのどれが受信しているかを知ることもありません。"
    },
    {
      "indent": 3,
      "text": "                                    .------------------------------.\n+---------+       +----------+     |  +----------+    +----------+  |\n| Client  |       | Relay    |     |  | Gateway  |    | Target   |  |\n|         |       | Resource |     |  | Resource |    | Resource |  |\n+----+----+       +----+-----+     |  +-----+----+    +----+-----+  |\n     |                 |            `-------|--------------|-------'\n     | Relay           |                    |              |\n     | Request         |                    |              |\n     | [+ Encapsulated |                    |              |\n     |    Request ]    |                    |              |\n     +---------------->| Gateway            |              |\n     |                 | Request            |              |\n     |                 | [+ Encapsulated    |              |\n     |                 |    Request ]       |              |\n     |                 +------------------->| Request      |\n     |                 |                    +------------->|\n     |                 |                    |              |\n     |                 |                    |     Response |\n     |                 |            Gateway |<-------------+\n     |                 |           Response |              |\n     |                 |    [+ Encapsulated |              |\n     |                 |         Response ] |              |\n     |           Relay |<-------------------+              |\n     |        Response |                    |              |\n     | [+ Encapsulated |                    |              |\n     |      Response ] |                    |              |\n     |<----------------+                    |              |\n     |                 |                    |              |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Figure 1: Overview of Oblivious HTTP",
      "ja": "図1：忘却のhttpの概要"
    },
    {
      "indent": 3,
      "text": "In order to forward a request for a Target Resource to the Oblivious Gateway Resource, the following steps occur, as shown in Figure 1:",
      "ja": "ターゲットリソースのリクエストを忘却のゲートウェイリソースに転送するために、図1に示すように、次の手順が発生します。"
    },
    {
      "indent": 3,
      "text": "1. The Client constructs an HTTP request for a Target Resource.",
      "ja": "1. クライアントは、ターゲットリソースのHTTP要求を構築します。"
    },
    {
      "indent": 3,
      "text": "2. The Client encodes the HTTP request in a binary HTTP message and then encapsulates that message using HPKE and the process from Section 4.3.",
      "ja": "2. クライアントは、バイナリHTTPメッセージでHTTP要求をエンコードし、HPKEを使用してそのメッセージとセクション4.3のプロセスをカプセル化します。"
    },
    {
      "indent": 3,
      "text": "3. The Client sends a POST request to the Oblivious Relay Resource with the Encapsulated Request as the content of that message.",
      "ja": "3. クライアントは、そのメッセージのコンテンツとしてカプセル化された要求を使用して、忘却のリレーションリソースにPOSTリクエストを送信します。"
    },
    {
      "indent": 3,
      "text": "4. The Oblivious Relay Resource forwards this request to the Oblivious Gateway Resource.",
      "ja": "4. 忘れられないリレーリソースは、このリクエストを忘却のゲートウェイリソースに転送します。"
    },
    {
      "indent": 3,
      "text": "5. The Oblivious Gateway Resource receives this request and removes the HPKE protection to obtain an HTTP request.",
      "ja": "5. Oblivious Gatewayリソースはこのリクエストを受信し、HPKE保護を削除してHTTP要求を取得します。"
    },
    {
      "indent": 3,
      "text": "The Oblivious Gateway Resource then handles the HTTP request. This typically involves making an HTTP request using the content of the Encapsulated Request. Once the Oblivious Gateway Resource has an HTTP response for this request, the following steps occur to return this response to the Client:",
      "ja": "忘れられないゲートウェイリソースは、HTTPリクエストを処理します。これには通常、カプセル化された要求のコンテンツを使用してHTTP要求を行うことが含まれます。この要求に対して、忘却のゲートウェイリソースがHTTP応答を持っていると、クライアントにこの応答を返すために次の手順が発生します。"
    },
    {
      "indent": 3,
      "text": "1. The Oblivious Gateway Resource encapsulates the HTTP response following the process in Section 4.4 and sends this in response to the request from the Oblivious Relay Resource.",
      "ja": "1. Oblivious Gatewayリソースは、セクション4.4のプロセスに続くHTTP応答をカプセル化し、忘却のリレーリソースからの要求に応じてこれを送信します。"
    },
    {
      "indent": 3,
      "text": "2. The Oblivious Relay Resource forwards this response to the Client.",
      "ja": "2. 気まぐれなリレーリソースは、この応答をクライアントに転送します。"
    },
    {
      "indent": 3,
      "text": "3. The Client removes the encapsulation to obtain the response to the original request.",
      "ja": "3. クライアントはカプセル化を削除して、元のリクエストに対する応答を取得します。"
    },
    {
      "indent": 3,
      "text": "This interaction provides authentication and confidentiality protection between the Client and the Oblivious Gateway, but importantly not between the Client and the Target Resource. While the Target Resource is a distinct HTTP resource from the Oblivious Gateway Resource, they are both logically under the control of the Oblivious Gateway, since the Oblivious Gateway Resource can unilaterally dictate the responses returned from the Target Resource to the Client. This arrangement is shown in Figure 1.",
      "ja": "この相互作用は、クライアントと忘却のゲートウェイ間の認証と機密保護を提供しますが、重要なことには、クライアントとターゲットリソースの間ではありません。ターゲットリソースは、忘却のゲートウェイリソースからの明確なHTTPリソースですが、ターゲットリソースからクライアントに返される応答を一方的に決定できるため、それらは両方とも忘却のゲートウェイの制御下にあります。この配置を図1に示します。"
    },
    {
      "indent": 0,
      "text": "2.1. Applicability",
      "section_title": true,
      "ja": "2.1. 適用可能性"
    },
    {
      "indent": 3,
      "text": "Oblivious HTTP has limited applicability. Importantly, it requires explicit support from a willing Oblivious Relay Resource and Oblivious Gateway Resource, thereby limiting the use of Oblivious HTTP for generic applications; see Section 6.3 for more information.",
      "ja": "忘却のHTTPの適用性は限られています。重要なことに、それは喜んで忘れられないリレーリソースと忘れられないゲートウェイリソースからの明示的なサポートが必要であり、それにより、一般的なアプリケーションへの忘却のHTTPの使用が制限されます。詳細については、セクション6.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Many uses of HTTP benefit from being able to carry state between requests, such as with cookies [COOKIES], authentication (Section 11 of [HTTP]), or even alternative services [RFC7838]. Oblivious HTTP removes linkage at the transport layer, which is only useful for an application that does not carry state between requests.",
      "ja": "HTTPの多くの用途は、Cookie [Cookie]、認証（[http]のセクション11）、または代替サービス[RFC7838]などのリクエスト間で状態を運ぶことができることから利益を得ることができます。忘却HTTPは、輸送層でのリンケージを削除します。これは、リクエストの合間に状態を運ばないアプリケーションにのみ役立ちます。"
    },
    {
      "indent": 3,
      "text": "Oblivious HTTP is primarily useful where the privacy risks associated with possible stateful treatment of requests are sufficiently large that the cost of deploying this protocol can be justified. Oblivious HTTP is simpler and less costly than more robust systems, like Prio [PRIO] or Tor [DMS2004], which can provide stronger guarantees at higher operational costs.",
      "ja": "忘却のHTTPは、このプロトコルを展開するコストを正当化できるため、リクエストのステートフルな扱いの可能性に関連するプライバシーリスクが十分に大きい場合に主に有用です。忘却HTTPは、PRIO [PRIO]やTOR [DMS2004]など、より堅牢なシステムよりも単純でコストがかかりません。これは、より高い運用コストでより強力な保証を提供できます。"
    },
    {
      "indent": 3,
      "text": "Oblivious HTTP is more costly than a direct connection to a server. Some costs, like those involved with connection setup, can be amortized, but there are several ways in which Oblivious HTTP is more expensive than a direct request:",
      "ja": "忘却HTTPは、サーバーへの直接接続よりもコストがかかります。接続セットアップに関与する人のように、一部のコストは償却できますが、直接リクエストよりも忘却HTTPが高価である方法はいくつかあります。"
    },
    {
      "indent": 3,
      "text": "* Each request requires at least two regular HTTP requests, which could increase latency.",
      "ja": "* 各リクエストには、少なくとも2つの定期的なHTTP要求が必要であるため、遅延が増加する可能性があります。"
    },
    {
      "indent": 3,
      "text": "* Each request is expanded in size with additional HTTP fields, encryption-related metadata, and Authenticated Encryption with Associated Data (AEAD) expansion.",
      "ja": "* 各リクエストは、追加のHTTPフィールド、暗号化関連メタデータ、および関連するデータ（AEAD）拡張を備えた認証暗号化によりサイズが拡張されます。"
    },
    {
      "indent": 3,
      "text": "* Deriving cryptographic keys and applying them for request and response protection takes non-negligible computational resources.",
      "ja": "* 暗号化キーを導き出し、リクエストと応答の保護に適用するには、無視できない計算リソースが必要です。"
    },
    {
      "indent": 3,
      "text": "Examples of where preventing the linking of requests might justify these costs include:",
      "ja": "リクエストのリンクを防ぐ場所の例は、これらのコストを正当化する可能性があります。"
    },
    {
      "indent": 3,
      "text": "DNS queries: DNS queries made to a recursive resolver reveal information about the requester, particularly if linked to other queries.",
      "ja": "DNSクエリ：特に他のクエリにリンクされている場合、再帰リゾルバーに作成されたDNSクエリが要求者に関する情報を明らかにします。"
    },
    {
      "indent": 3,
      "text": "Telemetry submission: Applications that submit reports about their usage to their developers might use Oblivious HTTP for some types of moderately sensitive data.",
      "ja": "テレメトリーの提出：開発者に使用に関するレポートを送信するアプリケーションは、いくつかのタイプの適度に敏感なデータに忘却HTTPを使用する場合があります。"
    },
    {
      "indent": 3,
      "text": "These are examples of requests where there is information in a request that -- if it were connected to the identity of the user -- might allow a server to learn something about that user even if the identity of the user were pseudonymous. Other examples include submitting anonymous surveys, making search queries, or requesting location-specific content (such as retrieving tiles of a map display).",
      "ja": "これらは、ユーザーのIDに接続されている場合、ユーザーの身元が仮名であってもサーバーがそのユーザーについて何かを学ぶことができるというリクエストに情報がある要求の例です。その他の例には、匿名の調査の送信、検索クエリの作成、ロケーション固有のコンテンツ（マップディスプレイのタイルの取得など）のリクエストが含まれます。"
    },
    {
      "indent": 3,
      "text": "In addition to these limitations, Section 6 describes operational constraints that are necessary to realize the goals of the protocol.",
      "ja": "これらの制限に加えて、セクション6では、プロトコルの目標を実現するために必要な運用上の制約について説明します。"
    },
    {
      "indent": 0,
      "text": "2.2. Conventions and Definitions",
      "section_title": true,
      "ja": "2.2. 慣習と定義"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 3,
      "text": "This document uses terminology from [HTTP] and defines several terms as follows:",
      "ja": "このドキュメントは[http]の用語を使用し、次のようにいくつかの用語を定義します。"
    },
    {
      "indent": 3,
      "text": "Client: A Client originates Oblivious HTTP requests. A Client is also an HTTP client in two ways: for the Target Resource and for the Oblivious Relay Resource. However, when referring to the HTTP definition of client (Section 3.3 of [HTTP]), the term \"HTTP client\" is used; see Section 5.",
      "ja": "クライアント：クライアントは、気付かないHTTPリクエストを発信します。クライアントは、ターゲットリソースと忘却のリレーリソースの2つの方法でHTTPクライアントでもあります。ただし、クライアントのHTTP定義（[HTTP]のセクション3.3）を参照する場合、「HTTPクライアント」という用語が使用されます。セクション5を参照してください。"
    },
    {
      "indent": 3,
      "text": "Encapsulated Request: An HTTP request that is encapsulated in an HPKE-encrypted message; see Section 4.3.",
      "ja": "カプセル化リクエスト：HPKE暗号化されたメッセージにカプセル化されたHTTP要求。セクション4.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Encapsulated Response: An HTTP response that is encapsulated in an HPKE-encrypted message; see Section 4.4.",
      "ja": "カプセル化された応答：HPKE暗号化されたメッセージにカプセル化されたHTTP応答。セクション4.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "Oblivious Relay Resource: An intermediary that forwards Encapsulated Requests and Responses between Clients and a single Oblivious Gateway Resource. In context, this can be referred to simply as a \"relay\".",
      "ja": "忘れられないリレーリソース：カプセル化されたリクエストとクライアントと単一の忘却のゲートウェイリソースの間で転送される仲介者。コンテキストでは、これは単に「リレー」と呼ぶことができます。"
    },
    {
      "indent": 3,
      "text": "Oblivious Gateway Resource: A resource that can receive an Encapsulated Request, extract the contents of that request, forward it to a Target Resource, receive a response, encapsulate that response, and then return the resulting Encapsulated Response. In context, this can be referred to simply as a \"gateway\".",
      "ja": "Oblivious Gatewayリソース：カプセル化された要求を受信し、その要求の内容を抽出し、ターゲットリソースに転送し、応答を受け取り、その応答をカプセル化し、結果のカプセル化された応答を返すことができるリソース。文脈では、これは単に「ゲートウェイ」と呼ぶことができます。"
    },
    {
      "indent": 3,
      "text": "Target Resource: The resource that is the target of an Encapsulated Request. This resource logically handles only regular HTTP requests and responses, so it might be ignorant of the use of Oblivious HTTP to reach it.",
      "ja": "ターゲットリソース：カプセル化された要求のターゲットであるリソース。このリソースは、通常のHTTPリクエストと応答のみを論理的に処理するため、忘却HTTPの使用に到達することは無知である可能性があります。"
    },
    {
      "indent": 3,
      "text": "This document includes pseudocode that uses the functions and conventions defined in [HPKE].",
      "ja": "このドキュメントには、[hpke]で定義されている関数と規則を使用する擬似コードが含まれています。"
    },
    {
      "indent": 3,
      "text": "Encoding an integer to a sequence of bytes in network byte order is described using the function encode(n, v), where n is the number of bytes and v is the integer value. ASCII [ASCII] encoding of a string s is indicated using the function encode_str(s).",
      "ja": "ネットワークバイト順序で一連のバイトに整数をエンコードすると、関数エンコード（n、v）を使用して説明されます。ここで、nはバイト数、vは整数値です。文字列sのエンコードは、関数encode_str（s）を使用して示されています。"
    },
    {
      "indent": 3,
      "text": "Formats are described using notation from Section 1.3 of [QUIC]. An extension to that notation expresses the number of bits in a field using a simple mathematical function.",
      "ja": "形式は、[QUIC]のセクション1.3の表記を使用して説明されています。その表記法の拡張機能は、単純な数学的関数を使用してフィールド内のビット数を表します。"
    },
    {
      "indent": 0,
      "text": "3. Key Configuration",
      "section_title": true,
      "ja": "3. キー構成"
    },
    {
      "indent": 3,
      "text": "A Client needs to acquire information about the key configuration of the Oblivious Gateway Resource in order to send Encapsulated Requests. In order to ensure that Clients do not encapsulate messages that other entities can intercept, the key configuration MUST be authenticated and have integrity protection.",
      "ja": "クライアントは、カプセル化されたリクエストを送信するために、忘却のゲートウェイリソースの重要な構成に関する情報を取得する必要があります。クライアントが他のエンティティが傍受できるメッセージをカプセル化しないようにするために、キー構成を認証し、整合性保護を持つ必要があります。"
    },
    {
      "indent": 3,
      "text": "This document does not define how that acquisition occurs. However, in order to help facilitate interoperability, it does specify a format for the keys. This ensures that different Client implementations can be configured in the same way and also enables advertising key configurations in a consistent format. This format might be used, for example, with HTTPS, as part of a system for configuring or discovering key configurations. However, note that such a system needs to consider the potential for key configuration to be used to compromise Client privacy; see Section 7.",
      "ja": "このドキュメントでは、その取得がどのように発生するかを定義しません。ただし、相互運用性を促進するために、キーの形式を指定します。これにより、異なるクライアントの実装を同じ方法で構成できるようになり、一貫した形式で主要な構成を広告することができます。この形式は、たとえば、httpsを使用して、キー構成を構成または検出するためのシステムの一部として使用できます。ただし、このようなシステムは、クライアントのプライバシーを損なうためにキー構成を使用する可能性を考慮する必要があることに注意してください。セクション7を参照してください。"
    },
    {
      "indent": 3,
      "text": "A Client might have multiple key configurations to select from when encapsulating a request. Clients are responsible for selecting a preferred key configuration from those it supports. Clients need to consider both the Key Encapsulation Method (KEM) and the combinations of the Key Derivation Function (KDF) and AEAD in this decision.",
      "ja": "クライアントには、リクエストをカプセル化するときに選択する複数のキー構成がある場合があります。クライアントは、サポートするものから優先されるキー構成を選択する責任があります。クライアントは、キーカプセル化方法（KEM）とキー導出関数（KDF）の組み合わせと、この決定のAEADの両方を考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.1. Key Configuration Encoding",
      "section_title": true,
      "ja": "3.1. キー構成エンコーディング"
    },
    {
      "indent": 3,
      "text": "A single key configuration consists of a key identifier, a public key, an identifier for the KEM that the public key uses, and a set of HPKE symmetric algorithms. Each symmetric algorithm consists of an identifier for a KDF and an identifier for an AEAD.",
      "ja": "単一のキー構成は、キー識別子、公開キー、公開キーが使用するKEMの識別子、およびHPKE対称アルゴリズムのセットで構成されています。各対称アルゴリズムは、KDFの識別子とAEADの識別子で構成されています。"
    },
    {
      "indent": 3,
      "text": "Figure 2 shows a single key configuration.",
      "ja": "図2は、単一のキー構成を示しています。"
    },
    {
      "indent": 3,
      "text": "HPKE Symmetric Algorithms {\n  HPKE KDF ID (16),\n  HPKE AEAD ID (16),\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Key Config {\n  Key Identifier (8),\n  HPKE KEM ID (16),\n  HPKE Public Key (Npk * 8),\n  HPKE Symmetric Algorithms Length (16) = 4..65532,\n  HPKE Symmetric Algorithms (32) ...,\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Figure 2: A Single Key Configuration",
      "ja": "図2：単一のキー構成"
    },
    {
      "indent": 3,
      "text": "That is, a key configuration consists of the following fields:",
      "ja": "つまり、重要な構成は次のフィールドで構成されています。"
    },
    {
      "indent": 3,
      "text": "Key Identifier: An 8-bit value that identifies the key used by the Oblivious Gateway Resource.",
      "ja": "キー識別子：Oblivious Gatewayリソースで使用されるキーを識別する8ビット値。"
    },
    {
      "indent": 3,
      "text": "HPKE KEM ID: A 16-bit value that identifies the KEM used for the identified key as defined in Section 7.1 of [HPKE] or the \"HPKE KEM Identifiers\" registry <https://www.iana.org/assignments/hpke>.",
      "ja": "HPKE KEM ID：[HPKE]のセクション7.1または「HPKE KEM識別子」レジストリ<https://www.iana.org/assignments/hpke>。"
    },
    {
      "indent": 3,
      "text": "HPKE Public Key: The public key used by the gateway. The length of the public key is Npk, which is determined by the choice of HPKE KEM as defined in Section 4 of [HPKE].",
      "ja": "HPKE公開キー：ゲートウェイで使用される公開鍵。公開キーの長さはNPKです。これは、[HPKE]のセクション4で定義されているHPKE KEMの選択によって決定されます。"
    },
    {
      "indent": 3,
      "text": "HPKE Symmetric Algorithms Length: A 16-bit integer in network byte order that encodes the length, in bytes, of the HPKE Symmetric Algorithms field that follows.",
      "ja": "HPKE対称アルゴリズムの長さ：次のHPKE対称アルゴリズムフィールドの長さをバイト単位でコードするネットワークバイトの16ビット整数。"
    },
    {
      "indent": 3,
      "text": "HPKE Symmetric Algorithms: One or more pairs of identifiers for the different combinations of HPKE KDF and AEAD that the Oblivious Gateway Resource supports:",
      "ja": "HPKE対称アルゴリズム：HPKE KDFとAEADのさまざまな組み合わせの1つ以上のペアの識別子のペアは、忘れられないゲートウェイリソースがサポートしていることを示しています。"
    },
    {
      "indent": 6,
      "text": "HPKE KDF ID: A 16-bit HPKE KDF identifier as defined in Section 7.2 of [HPKE] or the \"HPKE KDF Identifiers\" registry <https://www.iana.org/assignments/hpke>.",
      "ja": "HPKE KDF ID：[HPKE]のセクション7.2または「HPKE KDF識別子」で定義されている16ビットHPKE KDF識別子<https://www.iana.org/assignments/hpke>。"
    },
    {
      "indent": 6,
      "text": "HPKE AEAD ID: A 16-bit HPKE AEAD identifier as defined in Section 7.3 of [HPKE] or the \"HPKE AEAD Identifiers\" registry <https://www.iana.org/assignments/hpke>.",
      "ja": "HPKE AEAD ID：[HPKE]のセクション7.3または「HPKE AEAD識別子」レジストリ<https://www.iana.org/assignments/hpke>で定義されている16ビットHPKE AEAD識別子。"
    },
    {
      "indent": 0,
      "text": "3.2. Key Configuration Media Type",
      "section_title": true,
      "ja": "3.2. キー構成メディアタイプ"
    },
    {
      "indent": 3,
      "text": "The \"application/ohttp-keys\" format is a media type that identifies a serialized collection of key configurations. The content of this media type comprises one or more key configuration encodings (see Section 3.1). Each encoded configuration is prefixed with a 2-byte integer in network byte order that indicates the length of the key configuration in bytes. The length-prefixed encodings are concatenated to form a list. See Section 9.1 for a definition of the media type.",
      "ja": "「Application/Ohttp-Keys」形式は、主要な構成のシリアル化されたコレクションを識別するメディアタイプです。このメディアタイプのコンテンツは、1つ以上のキー構成エンコーディングで構成されています（セクション3.1を参照）。各エンコードされた構成には、バイトのキー構成の長さを示すネットワークバイト順序の2バイト整数が付いています。長さが埋められたエンコーディングが連結され、リストが形成されます。メディアタイプの定義については、セクション9.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Evolution of the key configuration format is supported through the definition of new formats that are identified by new media types.",
      "ja": "キー構成形式の進化は、新しいメディアタイプによって識別される新しい形式の定義を通じてサポートされています。"
    },
    {
      "indent": 3,
      "text": "A Client that receives an \"application/ohttp-keys\" object with encoding errors might be able to recover one or more key configurations. Differences in how key configurations are recovered might be exploited to segregate Clients, so Clients MUST discard incorrectly encoded key configuration collections.",
      "ja": "エンコードエラーを備えた「アプリケーション/OHTTP-Keys」オブジェクトを受信するクライアントは、1つ以上の重要な構成を回復できる可能性があります。キー構成の回復方法の違いは、クライアントを分離するために悪用される可能性があるため、クライアントは誤ってエンコードされたキー構成コレクションを破棄する必要があります。"
    },
    {
      "indent": 0,
      "text": "4. HPKE Encapsulation",
      "section_title": true,
      "ja": "4. HPKEカプセル化"
    },
    {
      "indent": 3,
      "text": "This document defines how a binary-encoded HTTP message [BINARY] is encapsulated using HPKE [HPKE]. Separate media types are defined to distinguish request and response messages:",
      "ja": "このドキュメントは、hpke [hpke]を使用してバイナリエンコードHTTPメッセージ[バイナリ]がどのようにカプセル化されるかを定義しています。リクエストと応答メッセージを区別するために、個別のメディアタイプが定義されています。"
    },
    {
      "indent": 3,
      "text": "* An Encapsulated Request format defined in Section 4.1 is identified by the \"message/ohttp-req\" media type (Section 9.2).",
      "ja": "* セクション4.1で定義されたカプセル化された要求形式は、「メッセージ/OHTTP-REQ」メディアタイプ（セクション9.2）によって識別されます。"
    },
    {
      "indent": 3,
      "text": "* An Encapsulated Response format defined in Section 4.2 is identified by the \"message/ohttp-res\" media type (Section 9.3).",
      "ja": "* セクション4.2で定義されたカプセル化された応答形式は、「メッセージ/OHTTP-RES」メディアタイプ（セクション9.3）によって識別されます。"
    },
    {
      "indent": 3,
      "text": "Alternative encapsulations or message formats are indicated using the media type; see Sections 4.5 and 4.6.",
      "ja": "メディアタイプを使用して、代替のカプセルまたはメッセージ形式が示されています。セクション4.5および4.6を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.1. Request Format",
      "section_title": true,
      "ja": "4.1. リクエスト形式"
    },
    {
      "indent": 3,
      "text": "A message in \"message/ohttp-req\" format protects a binary HTTP request message; see Figure 3.",
      "ja": "「メッセージ/HTTP-Request」形式のメッセージは、バイナリHTTP要求メッセージを保護します。図3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Request {\n  Binary HTTP Message (..),\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Figure 3: Plaintext Request Structure",
      "ja": "図3：プレーンテキスト要求構造"
    },
    {
      "indent": 3,
      "text": "This plaintext Request structure is encapsulated into a message in \"message/ohttp-req\" form by generating an Encapsulated Request. An Encapsulated Request comprises a key identifier; HPKE parameters for the chosen KEM, KDF, and AEAD; the encapsulated KEM shared secret (or enc); and an HPKE-protected binary HTTP request message.",
      "ja": "このプレーンテキストリクエスト構造は、カプセル化された要求を生成することにより、「メッセージ/Ohttp-Req」フォームのメッセージにカプセル化されます。カプセル化された要求は、キー識別子を含む。選択したKEM、KDF、およびAEADのHPKEパラメーター。カプセル化されたKEMは秘密（またはenc）を共有しました。HPKE保護されたバイナリHTTP要求メッセージ。"
    },
    {
      "indent": 3,
      "text": "An Encapsulated Request is shown in Figure 4. Section 4.3 describes the process for constructing and processing an Encapsulated Request.",
      "ja": "カプセル化された要求を図4に示します。セクション4.3は、カプセル化された要求を構築および処理するプロセスについて説明します。"
    },
    {
      "indent": 3,
      "text": "Encapsulated Request {\n  Key Identifier (8),\n  HPKE KEM ID (16),\n  HPKE KDF ID (16),\n  HPKE AEAD ID (16),\n  Encapsulated KEM Shared Secret (8 * Nenc),\n  HPKE-Protected Request (..),\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Figure 4: Encapsulated Request",
      "ja": "図4：カプセル化されたリクエスト"
    },
    {
      "indent": 3,
      "text": "That is, an Encapsulated Request comprises a Key Identifier, an HPKE KEM ID, an HPKE KDF ID, an HPKE AEAD ID, an Encapsulated KEM Shared Secret, and an HPKE-Protected Request. The Key Identifier, HPKE KEM ID, HPKE KDF ID, and HPKE AEAD ID fields are defined in Section 3.1. The Encapsulated KEM Shared Secret is the output of the Encap() function for the KEM, which is Nenc bytes in length, as defined in Section 4 of [HPKE].",
      "ja": "つまり、カプセル化された要求は、キー識別子、HPKE KEM ID、HPKE KDF ID、HPKE AEAD ID、カプセル化されたKEM共有秘密、およびHPKE保護されたリクエストを含むことです。キー識別子、HPKE KEM ID、HPKE KDF ID、およびHPKE AEAD IDフィールドは、セクション3.1で定義されています。カプセル化されたKEMの共有秘密は、[HPKE]のセクション4で定義されているように、長さがNENCバイトであるKEMのENCAP（）関数の出力です。"
    },
    {
      "indent": 0,
      "text": "4.2. Response Format",
      "section_title": true,
      "ja": "4.2. 応答形式"
    },
    {
      "indent": 3,
      "text": "A message in \"message/ohttp-res\" format protects a binary HTTP response message; see Figure 5.",
      "ja": "「Message/Ohttp-Res」形式のメッセージは、バイナリHTTP応答メッセージを保護します。図5を参照してください。"
    },
    {
      "indent": 3,
      "text": "Response {\n  Binary HTTP Message (..),\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Figure 5: Plaintext Response Structure",
      "ja": "図5：プレーンテキスト応答構造"
    },
    {
      "indent": 3,
      "text": "This plaintext Response structure is encapsulated into a message in \"message/ohttp-res\" form by generating an Encapsulated Response. An Encapsulated Response comprises a nonce and the AEAD-protected binary HTTP response message.",
      "ja": "このプレーンテキスト応答構造は、カプセル化された応答を生成することにより、「メッセージ/ohttp-res」フォームのメッセージにカプセル化されます。カプセル化された応答は、非CEとAEAD保護されたバイナリHTTP応答メッセージを含む。"
    },
    {
      "indent": 3,
      "text": "An Encapsulated Response is shown in Figure 6. Section 4.4 describes the process for constructing and processing an Encapsulated Response.",
      "ja": "カプセル化された応答を図6に示します。セクション4.4は、カプセル化された応答を構築および処理するプロセスについて説明します。"
    },
    {
      "indent": 3,
      "text": "Encapsulated Response {\n  Nonce (8 * max(Nn, Nk)),\n  AEAD-Protected Response (..),\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 6: Encapsulated Response",
      "ja": "図6：カプセル化された応答"
    },
    {
      "indent": 3,
      "text": "That is, an Encapsulated Response contains a Nonce and an AEAD-Protected Response. The Nonce field is either Nn or Nk bytes long, whichever is larger. The Nn and Nk values correspond to parameters of the AEAD used in HPKE, which is defined in Section 7.3 of [HPKE] or the \"HPKE AEAD Identifiers\" IANA registry <https://www.iana.org/assignments/hpke>. Nn and Nk refer to the size of the AEAD nonce and key, respectively, in bytes.",
      "ja": "つまり、カプセル化された応答には、非CEとAEAD保護された応答が含まれます。NonCEフィールドは、NNまたはNKバイトの長さのいずれか大きい方です。NNおよびNK値は、[HPKE]のセクション7.3または「HPKE AEAD識別子」で定義されているHPKEで使用されるAEADのパラメーターに対応します。NNとNKは、それぞれバイト単位のAEADノンセとキーのサイズを指します。"
    },
    {
      "indent": 0,
      "text": "4.3. Encapsulation of Requests",
      "section_title": true,
      "ja": "4.3. リクエストのカプセル化"
    },
    {
      "indent": 3,
      "text": "Clients encapsulate a request, identified as request, using values from a key configuration:",
      "ja": "クライアントは、キー構成からの値を使用して、要求として識別される要求をカプセル化します。"
    },
    {
      "indent": 3,
      "text": "* the key identifier from the configuration (key_id) with the corresponding KEM identified by kem_id,",
      "ja": "* KEM_IDによって識別された対応するKEMを使用した構成（key_id）のキー識別子、"
    },
    {
      "indent": 3,
      "text": "* the public key from the configuration (pkR), and",
      "ja": "* 構成（PKR）の公開鍵と"
    },
    {
      "indent": 3,
      "text": "* a combination of KDF (identified by kdf_id) and AEAD (identified by aead_id) that the Client selects from those in the key configuration.",
      "ja": "* KDF（KDF_IDで識別）とAEAD（AEAD_IDで識別）の組み合わせが、クライアントがキー構成のものから選択したものから選択します。"
    },
    {
      "indent": 3,
      "text": "The Client then constructs an Encapsulated Request, enc_request, from a binary-encoded HTTP request [BINARY] (request) as follows:",
      "ja": "次に、クライアントは、次のように、バイナリエンコードHTTPリクエスト[バイナリ]（リクエスト）からカプセル化されたリクエストec_requestを作成します。"
    },
    {
      "indent": 3,
      "text": "1. Construct a message header (hdr) by concatenating the values of key_id, kem_id, kdf_id, and aead_id as one 8-bit integer and three 16-bit integers, respectively, each in network byte order.",
      "ja": "1. Key_ID、KEM_ID、KDF_ID、およびAEAD_IDの値をそれぞれ1つの8ビット整数と3つの16ビット整数として連結して、それぞれネットワークバイトの順序でメッセージヘッダー（HDR）を作成します。"
    },
    {
      "indent": 3,
      "text": "2. Build a sequence of bytes (info) by concatenating the ASCII-encoded string \"message/bhttp request\", a zero byte, and the header. Note: Section 4.6 discusses how alternative message formats might use a different info value.",
      "ja": "2. Ascii-Encoded文字列「Message/BHTTPリクエスト」、ゼロバイト、ヘッダーを連結することにより、一連のバイト（情報）を構築します。注：セクション4.6では、代替メッセージフォーマットが異なる情報値を使用する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "3. Create a sending HPKE context by invoking SetupBaseS() (Section 5.1.1 of [HPKE]) with the public key of the receiver pkR and info. This yields the context sctxt and an encapsulation key enc.",
      "ja": "3. 受信機PKRと情報の公開鍵を使用して、setupbase（）（[hpke]のセクション5.1.1）を呼び出して送信hpkeコンテキストを作成します。これにより、コンテキストSCTXTとカプセル化キーエンクが得られます。"
    },
    {
      "indent": 3,
      "text": "4. Encrypt request by invoking the Seal() method on sctxt (Section 5.2 of [HPKE]) with empty associated data aad, yielding ciphertext ct.",
      "ja": "4. 空の関連データAADを使用して、SCTXT（[HPKE]のセクション5.2）にSEAR（）メソッドを呼び出して要求を暗号化し、暗号文CTを生成します。"
    },
    {
      "indent": 3,
      "text": "5. Concatenate the values of hdr, enc, and ct. This yields an Encapsulated Request (enc_request).",
      "ja": "5. HDR、Enc、およびCtの値を連結します。これにより、カプセル化されたリクエスト（enc_request）が得られます。"
    },
    {
      "indent": 3,
      "text": "Note that enc is of fixed length, so there is no ambiguity in parsing this structure.",
      "ja": "ENCは固定された長さであるため、この構造を解析する際のあいまいさはないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "In pseudocode, this procedure is as follows:",
      "ja": "擬似コードでは、この手順は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "hdr = concat(encode(1, key_id),\n             encode(2, kem_id),\n             encode(2, kdf_id),\n             encode(2, aead_id))\ninfo = concat(encode_str(\"message/bhttp request\"),\n              encode(1, 0),\n              hdr)\nenc, sctxt = SetupBaseS(pkR, info)\nct = sctxt.Seal(\"\", request)\nenc_request = concat(hdr, enc, ct)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An Oblivious Gateway Resource decrypts an Encapsulated Request by reversing this process. To decapsulate an Encapsulated Request, enc_request:",
      "ja": "忘れられないゲートウェイリソースは、このプロセスを逆転させることにより、カプセル化された要求を復号化します。カプセル化されたリクエストを脱カプセル化するには、enc_request："
    },
    {
      "indent": 3,
      "text": "1. Parse enc_request into key_id, kem_id, kdf_id, aead_id, enc, and ct (indicated using the function parse() in pseudocode). The Oblivious Gateway Resource is then able to find the HPKE private key, skR, corresponding to key_id.",
      "ja": "1. key_id、kem_id、kdf_id、aead_id、enc、and ctへのparse enc_request（pseudocodeの関数parse（）を使用して示されています）。その後、忘れられないゲートウェイリソースは、key_idに対応するHPKE秘密キーであるSKRを見つけることができます。"
    },
    {
      "indent": 7,
      "text": "a. If key_id does not identify a key matching the type of kem_id, the Oblivious Gateway Resource returns an error.",
      "ja": "a. key_idがKEM_IDのタイプに一致するキーを識別しない場合、忘却のゲートウェイリソースはエラーを返します。"
    },
    {
      "indent": 7,
      "text": "b. If kdf_id and aead_id identify a combination of KDF and AEAD that the Oblivious Gateway Resource is unwilling to use with skR, the Oblivious Gateway Resource returns an error.",
      "ja": "b. KDF_IDとAEAD_IDがKDFとAEADの組み合わせを識別した場合、忘れられないゲートウェイリソースがSKRで使用したくない場合、忘れられないゲートウェイリソースはエラーを返します。"
    },
    {
      "indent": 3,
      "text": "2. Build a sequence of bytes (info) by concatenating the ASCII-encoded string \"message/bhttp request\"; a zero byte; key_id as an 8-bit integer; plus kem_id, kdf_id, and aead_id as three 16-bit integers.",
      "ja": "2. Ascii-Encoded文字列「メッセージ/bhttp要求」を連結することにより、一連のバイト（情報）を構築します。ゼロバイト。8ビット整数としてのkey_id。さらに、3つの16ビット整数としてKEM_ID、KDF_ID、およびAEAD_ID。"
    },
    {
      "indent": 3,
      "text": "3. Create a receiving HPKE context, rctxt, by invoking SetupBaseR() (Section 5.1.1 of [HPKE]) with skR, enc, and info.",
      "ja": "3. SKR、ENC、および情報を使用して、setupBaser（）（[HPKE]のセクション5.1.1）を呼び出して、受信HPKEコンテキストRCTXTを作成します。"
    },
    {
      "indent": 3,
      "text": "4. Decrypt ct by invoking the Open() method on rctxt (Section 5.2 of [HPKE]), with an empty associated data aad, yielding request or an error on failure. If decryption fails, the Oblivious Gateway Resource returns an error.",
      "ja": "4. rctxt（[hpke]のセクション5.2）でopen（）メソッドを呼び出してCTを復号化し、空の関連データを使用して、障害時にリクエストまたはエラーを生成します。復号化が失敗した場合、忘却のゲートウェイリソースはエラーを返します。"
    },
    {
      "indent": 3,
      "text": "In pseudocode, this procedure is as follows:",
      "ja": "擬似コードでは、この手順は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "key_id, kem_id, kdf_id, aead_id, enc, ct = parse(enc_request)\ninfo = concat(encode_str(\"message/bhttp request\"),\n              encode(1, 0),\n              encode(1, key_id),\n              encode(2, kem_id),\n              encode(2, kdf_id),\n              encode(2, aead_id))\nrctxt = SetupBaseR(enc, skR, info)\nrequest, error = rctxt.Open(\"\", ct)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Oblivious Gateway Resource retains the HPKE context, rctxt, so that it can encapsulate a response.",
      "ja": "忘れられないゲートウェイリソースは、応答をカプセル化できるように、HPKEコンテキストRCTXTを保持します。"
    },
    {
      "indent": 0,
      "text": "4.4. Encapsulation of Responses",
      "section_title": true,
      "ja": "4.4. 応答のカプセル化"
    },
    {
      "indent": 3,
      "text": "Oblivious Gateway Resources generate an Encapsulated Response (enc_response) from a binary-encoded HTTP response [BINARY] (response). The Oblivious Gateway Resource uses the HPKE receiver context (rctxt) as the HPKE context (context) as follows:",
      "ja": "忘却のゲートウェイリソースは、バイナリエンコードHTTP応答[バイナリ]（応答）からカプセル化された応答（enc_response）を生成します。Oblivious Gatewayリソースは、次のようにHPKEレシーバーコンテキスト（RCTXT）をHPKEコンテキスト（コンテキスト）として使用します。"
    },
    {
      "indent": 3,
      "text": "1. Export a secret (secret) from context, using the string \"message/ bhttp response\" as the exporter_context parameter to context.Export; see Section 5.3 of [HPKE]. The length of this secret is max(Nn, Nk), where Nn and Nk are the length of the AEAD key and nonce that are associated with context. Note: Section 4.6 discusses how alternative message formats might use a different context value.",
      "ja": "1. 文字列「メッセージ/ bhttp応答」をExporter_ContextパラメーターとしてContext.Exportに使用して、コンテキストから秘密（秘密）をエクスポートします。[hpke]のセクション5.3を参照してください。この秘密の長さはMax（NN、NK）で、NNとNKはコンテキストに関連付けられているAEADキーとNONCEの長さです。注：セクション4.6では、代替メッセージフォーマットが異なるコンテキスト値を使用する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "2. Generate a random value of length max(Nn, Nk) bytes, called response_nonce.",
      "ja": "2. response_nonceと呼ばれる長さmax（nn、nk）バイトのランダム値を生成します。"
    },
    {
      "indent": 3,
      "text": "3. Extract a pseudorandom key (prk) using the Extract function provided by the KDF algorithm associated with context. The ikm input to this function is secret; the salt input is the concatenation of enc (from enc_request) and response_nonce.",
      "ja": "3. コンテキストに関連付けられたKDFアルゴリズムによって提供される抽出関数を使用して、擬似ランダムキー（PRK）を抽出します。この関数へのIKM入力は秘密です。塩の入力は、enc（enc_requestから）とresponse_nonceの連結です。"
    },
    {
      "indent": 3,
      "text": "4. Use the Expand function provided by the same KDF to create an AEAD key, key, of length Nk -- the length of the keys used by the AEAD associated with context. Generating aead_key uses a label of \"key\".",
      "ja": "4. 同じKDFによって提供される拡張関数を使用して、長さNKのAEADキー、キー、つまりコンテキストに関連付けられたAEADで使用されるキーの長さを作成します。AeaD_Keyの生成は、「キー」のラベルを使用します。"
    },
    {
      "indent": 3,
      "text": "5. Use the same Expand function to create a nonce, nonce, of length Nn -- the length of the nonce used by the AEAD. Generating aead_nonce uses a label of \"nonce\".",
      "ja": "5. 同じ展開関数を使用して、長さnnの非CE、非CE、非CEの長さを作成します。Aead_nonceの生成は、「Nonce」のラベルを使用します。"
    },
    {
      "indent": 3,
      "text": "6. Encrypt response, passing the AEAD function Seal the values of aead_key, aead_nonce, an empty aad, and a pt input of response. This yields ct.",
      "ja": "6. 応答を暗号化し、AEAD関数を渡すと、AEAD_KEY、AEAD_NONCE、空のAAD、および応答のPT入力の値をシールします。これにより、CTが生成されます。"
    },
    {
      "indent": 3,
      "text": "7. Concatenate response_nonce and ct, yielding an Encapsulated Response, enc_response. Note that response_nonce is of fixed length, so there is no ambiguity in parsing either response_nonce or ct.",
      "ja": "7. response_nonceとCTを連結し、カプセル化された応答、enc_responseを生成します。Response_Nonceは固定された長さであるため、Response_NonceまたはCTのいずれかを解析することにあいまいさはないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "In pseudocode, this procedure is as follows:",
      "ja": "擬似コードでは、この手順は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "secret = context.Export(\"message/bhttp response\", max(Nn, Nk))\nresponse_nonce = random(max(Nn, Nk))\nsalt = concat(enc, response_nonce)\nprk = Extract(salt, secret)\naead_key = Expand(prk, \"key\", Nk)\naead_nonce = Expand(prk, \"nonce\", Nn)\nct = Seal(aead_key, aead_nonce, \"\", response)\nenc_response = concat(response_nonce, ct)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Clients decrypt an Encapsulated Response by reversing this process. That is, Clients first parse enc_response into response_nonce and ct. Then, they follow the same process to derive values for aead_key and aead_nonce, using their sending HPKE context, sctxt, as the HPKE context, context.",
      "ja": "クライアントは、このプロセスを逆転させることにより、カプセル化された応答を復号化します。つまり、クライアントはresponse_nonceとctに最初にenc_responseを解析します。次に、同じプロセスに従って、AEAD_KEYとAEAD_NONCEの値を導き出し、HPKEコンテキストをHPKEコンテキスト、コンテキストとして送信します。"
    },
    {
      "indent": 3,
      "text": "The Client uses these values to decrypt ct using the AEAD function Open. Decrypting might produce an error, as follows:",
      "ja": "クライアントは、これらの値を使用して、AEAD関数を開いてCTを復号化します。次のように、復号化するとエラーが発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "response, error = Open(aead_key, aead_nonce, \"\", ct)",
      "ja": "応答、エラー= open（aead_key、aead_nonce、 \"\"、ct）"
    },
    {
      "indent": 0,
      "text": "4.5. Request and Response Media Types",
      "section_title": true,
      "ja": "4.5. リクエストと応答メディアタイプ"
    },
    {
      "indent": 3,
      "text": "Media types are used to identify Encapsulated Requests and Responses; see Sections 9.2 and 9.3 for definitions of these media types.",
      "ja": "メディアタイプは、カプセル化されたリクエストと応答を識別するために使用されます。これらのメディアタイプの定義については、セクション9.2および9.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Evolution of the format of Encapsulated Requests and Responses is supported through the definition of new formats that are identified by new media types. New media types might be defined to use a similar encapsulation with a different HTTP message format than in [BINARY]; see Section 4.6 for guidance on reusing this encapsulation method. Alternatively, a new encapsulation method might be defined.",
      "ja": "カプセル化されたリクエストと応答の形式の進化は、新しいメディアタイプによって識別される新しい形式の定義を通じてサポートされています。新しいメディアタイプは、[binary]よりも異なるHTTPメッセージ形式で同様のカプセル化を使用するように定義される場合があります。このカプセル化方法の再利用に関するガイダンスについては、セクション4.6を参照してください。あるいは、新しいカプセル化方法が定義される場合があります。"
    },
    {
      "indent": 0,
      "text": "4.6. Repurposing the Encapsulation Format",
      "section_title": true,
      "ja": "4.6. カプセル化形式の再利用"
    },
    {
      "indent": 3,
      "text": "The encrypted payload of an Oblivious HTTP request and response is a binary HTTP message [BINARY]. The Client and Oblivious Gateway Resource agree on this encrypted payload type by specifying the media type \"message/bhttp\" in the HPKE info string and HPKE export context string for request and response encryption, respectively.",
      "ja": "忘却HTTPリクエストと応答の暗号化されたペイロードは、バイナリHTTPメッセージ[バイナリ]です。クライアントと忘却のゲートウェイリソースは、リクエストと応答の暗号化のためにそれぞれHPKE情報文字列にメディアタイプ「メッセージ/BHTTP」とHPKEエクスポートの文字列を指定することにより、この暗号化されたペイロードタイプに同意します。"
    },
    {
      "indent": 3,
      "text": "Future specifications may repurpose the encapsulation mechanism described in this document. This requires that the specification define a new media type. The encapsulation process for that content type can follow the same process, using new constant strings for the HPKE info and exporter context inputs.",
      "ja": "将来の仕様は、このドキュメントに記載されているカプセル化メカニズムを再利用する可能性があります。これには、仕様が新しいメディアタイプを定義する必要があります。そのコンテンツタイプのカプセル化プロセスは、HPKE情報とエクスポートのコンテキスト入力に新しい定数文字列を使用して、同じプロセスに従うことができます。"
    },
    {
      "indent": 3,
      "text": "For example, a future specification might encapsulate DNS messages, which use the \"application/dns-message\" media type [RFC8484]. In creating a new, encrypted media types, specifications might define the use of string \"application/dns-message request\" (plus a zero byte and the header for the full value) for request encryption and the string \"application/dns-message response\" for response encryption.",
      "ja": "たとえば、将来の仕様では、「アプリケーション/DNSメサージ」メディアタイプ[RFC8484]を使用するDNSメッセージをカプセル化する場合があります。新しい暗号化されたメディアタイプを作成する際に、仕様は、リクエスト暗号化と文字列「アプリケーション/DNS-メッサージ応答の文字列「アプリケーション/DNS-メッサージリクエスト」（ゼロバイトとフル値のヘッダー）の使用を定義する場合があります。「応答暗号化用。"
    },
    {
      "indent": 0,
      "text": "5. HTTP Usage",
      "section_title": true,
      "ja": "5. HTTP使用"
    },
    {
      "indent": 3,
      "text": "A Client interacts with the Oblivious Relay Resource by constructing an Encapsulated Request. This Encapsulated Request is included as the content of a POST request to the Oblivious Relay Resource. This request only needs those fields necessary to carry the Encapsulated Request: a method of POST, a target URI of the Oblivious Relay Resource, a header field containing the content type (see Section 9.2), and the Encapsulated Request as the request content. In the request to the Oblivious Relay Resource, Clients MAY include additional fields. However, additional fields MUST be independent of the Encapsulated Request and MUST be fields that the Oblivious Relay Resource will remove before forwarding the Encapsulated Request towards the target, such as the Connection or Proxy-Authorization header fields [HTTP].",
      "ja": "クライアントは、カプセル化されたリクエストを作成することにより、忘れられないリレーリソースと対話します。このカプセル化されたリクエストは、忘れられないリレーリソースへのPOSTリクエストのコンテンツとして含まれています。このリクエストは、カプセル化された要求を携帯するために必要なフィールドのみを必要とします。ポストの方法、忘却のリレーリソースのターゲットURI、コンテンツタイプを含むヘッダーフィールド（セクション9.2を参照）、およびリクエストコンテンツとしてのカプセル化要求。忘れられないリレーリソースへのリクエストでは、クライアントには追加のフィールドが含まれる場合があります。ただし、追加のフィールドはカプセル化された要求とは独立している必要があり、接続またはプロキシ承認ヘッダーフィールド[HTTP]など、カプセル化された要求をターゲットに転送する前に、忘却のリレーリソースが削除するフィールドでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Client role in this protocol acts as an HTTP client both with respect to the Oblivious Relay Resource and the Target Resource. The request, which the Client makes to the Target Resource, diverges from typical HTTP assumptions about the use of a connection (see Section 3.3 of [HTTP]) in that the request and response are encrypted rather than sent over a connection. The Oblivious Relay Resource and the Oblivious Gateway Resource also act as HTTP clients toward the Oblivious Gateway Resource and Target Resource, respectively.",
      "ja": "このプロトコルにおけるクライアントの役割は、忘却のリレーリソースとターゲットリソースの両方に関してHTTPクライアントとして機能します。クライアントがターゲットリソースに対して行う要求は、リクエストと応答が接続で送信されるのではなく暗号化されるという点で、接続の使用に関する典型的なHTTP仮定（[http]のセクション3.3を参照）とは異なります。忘れられないリレーリソースと忘却のゲートウェイリソースは、それぞれ忘却のゲートウェイリソースとターゲットリソースに向けてHTTPクライアントとして機能します。"
    },
    {
      "indent": 3,
      "text": "In order to achieve the privacy and security goals of the protocol, a Client also needs to observe the guidance in Section 6.1.",
      "ja": "プロトコルのプライバシーとセキュリティの目標を達成するために、クライアントはセクション6.1のガイダンスを遵守する必要があります。"
    },
    {
      "indent": 3,
      "text": "The Oblivious Relay Resource interacts with the Oblivious Gateway Resource as an HTTP client by constructing a request using the same restrictions as the Client request, except that the target URI is the Oblivious Gateway Resource. The content of this request is copied from the Client. An Oblivious Relay Resource MAY reject requests that are obviously invalid, such as a request with no content. The Oblivious Relay Resource MUST NOT add information to the request without the Client being aware of the type of information that might be added; see Section 6.2 for more information on relay responsibilities.",
      "ja": "忘れられないリレーリソースは、クライアント要求と同じ制限を使用してリクエストを作成することにより、HTTPクライアントとして忘却のゲートウェイリソースと相互作用します。このリクエストの内容は、クライアントからコピーされます。忘れられないリレーリソースは、コンテンツのないリクエストなど、明らかに無効なリクエストを拒否する場合があります。忘れられないリレーリソースは、クライアントが追加される可能性のある情報の種類を認識しない限り、リクエストに情報を追加してはなりません。リレーの責任の詳細については、セクション6.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "When a response is received from the Oblivious Gateway Resource, the Oblivious Relay Resource forwards the response according to the rules of an HTTP proxy; see Section 7.6 of [HTTP]. In case of timeout or error, the Oblivious Relay Resource can generate a response with an appropriate status code.",
      "ja": "忘れられないゲートウェイリソースから応答が受信されると、忘れられないリレーリソースがHTTPプロキシのルールに従って応答を転送します。[http]のセクション7.6を参照してください。タイムアウトまたはエラーの場合、忘れられないリレーリソースは、適切なステータスコードで応答を生成できます。"
    },
    {
      "indent": 3,
      "text": "In order to achieve the privacy and security goals of the protocol, an Oblivious Relay Resource also needs to observe the guidance in Section 6.2.",
      "ja": "プロトコルのプライバシーとセキュリティの目標を達成するには、忘れられないリレーリソースもセクション6.2のガイダンスを遵守する必要があります。"
    },
    {
      "indent": 3,
      "text": "An Oblivious Gateway Resource acts as a gateway for requests to the Target Resource (see Section 7.6 of [HTTP]). The one exception is that any information it might forward in a response MUST be encapsulated, unless it is responding to errors that do not relate to processing the contents of the Encapsulated Request; see Section 5.2.",
      "ja": "忘れられないゲートウェイリソースは、ターゲットリソースへのリクエストのゲートウェイとして機能します（[HTTP]のセクション7.6を参照）。1つの例外は、カプセル化された要求の内容の処理に関連しないエラーに応答しない限り、応答で転送される可能性のある情報をカプセル化する必要があることです。セクション5.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "An Oblivious Gateway Resource, if it receives any response from the Target Resource, sends a single 200 response containing the Encapsulated Response. Like the request from the Client, this response MUST only contain those fields necessary to carry the Encapsulated Response: a 200 status code, a header field indicating the content type, and the Encapsulated Response as the response content. As with requests, additional fields MAY be used to convey information that does not reveal information about the Encapsulated Response.",
      "ja": "ターゲットリソースから応答を受信した場合、忘れられないゲートウェイリソースは、カプセル化された応答を含む単一の200応答を送信します。クライアントからのリクエストと同様に、この応答は、カプセル化された応答を携帯するために必要なフィールドのみを含める必要があります。200ステータスコード、コンテンツタイプを示すヘッダーフィールド、および応答コンテンツとしてのカプセル化された応答。リクエストと同様に、追加のフィールドを使用して、カプセル化された応答に関する情報を明らかにしない情報を伝えることができます。"
    },
    {
      "indent": 3,
      "text": "An Oblivious Gateway Resource that does not receive a response can itself generate a response with an appropriate error status code (such as 504 (Gateway Timeout); see Section 15.6.5 of [HTTP]), which is then encapsulated in the same way as a successful response.",
      "ja": "応答を受信しない忘れられないゲートウェイリソース自体は、適切なエラーステータスコード（504（ゲートウェイタイムアウト）など）で応答を生成できます。[HTTP]のセクション15.6.5を参照）。成功した応答。"
    },
    {
      "indent": 3,
      "text": "In order to achieve the privacy and security goals of the protocol, an Oblivious Gateway Resource also needs to observe the guidance in Section 6.3.",
      "ja": "プロトコルのプライバシーとセキュリティの目標を達成するには、忘れられないゲートウェイリソースもセクション6.3のガイダンスを遵守する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1. Informational Responses",
      "section_title": true,
      "ja": "5.1. 情報回答"
    },
    {
      "indent": 3,
      "text": "This encapsulation does not permit progressive processing of responses. Though the binary HTTP response format does support the inclusion of informational (1xx) status codes, the AEAD encapsulation cannot be removed until the entire message is received.",
      "ja": "このカプセル化は、応答の漸進的な処理を許可しません。バイナリHTTP応答形式は、情報（1XX）ステータスコードの含有をサポートしていますが、メッセージ全体が受信されるまでAEADカプセル化は削除できません。"
    },
    {
      "indent": 3,
      "text": "In particular, the Expect header field with 100-continue (see Section 10.1.1 of [HTTP]) cannot be used. Clients MUST NOT construct a request that includes a 100-continue expectation; the Oblivious Gateway Resource MUST generate an error if a 100-continue expectation is received.",
      "ja": "特に、100コントン（[http]のセクション10.1.1を参照）を持つ予想ヘッダーフィールドは使用できません。クライアントは、100コントンの期待を含むリクエストを作成してはなりません。忘れられないゲートウェイリソースは、100を獲得した期待を受け取った場合、エラーを生成する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2. Errors",
      "section_title": true,
      "ja": "5.2. エラー"
    },
    {
      "indent": 3,
      "text": "A server that receives an invalid message for any reason MUST generate an HTTP response with a 4xx status code.",
      "ja": "何らかの理由で無効なメッセージを受信するサーバーは、4XXステータスコードでHTTP応答を生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "Errors detected by the Oblivious Relay Resource and errors detected by the Oblivious Gateway Resource before removing protection (including being unable to remove encapsulation for any reason) result in the status code being sent without protection in response to the POST request made to that resource.",
      "ja": "忘れられないリレーリソースによって検出されたエラー保護を削除する前に、忘却のゲートウェイリソースによって検出されたエラー（何らかの理由でカプセル化を削除できないことを含む）により、そのリソースに行われたPOSTリクエストに応じて保護なしにステータスコードが送信されます。"
    },
    {
      "indent": 3,
      "text": "Errors detected by the Oblivious Gateway Resource after successfully removing encapsulation and errors detected by the Target Resource MUST be sent in an Encapsulated Response. This might be because the Encapsulated Request is malformed or the Target Resource does not produce a response. In either case, the Oblivious Gateway Resource can generate a response with an appropriate error status code (such as 400 (Bad Request) or 504 (Gateway Timeout); see Sections 15.5.1 and 15.6.5 of [HTTP], respectively). This response is encapsulated in the same way as a successful response.",
      "ja": "ターゲットリソースによって検出されたカプセル化とエラーを正常に削除した後、忘却のゲートウェイリソースによって検出されたエラーは、カプセル化された応答で送信する必要があります。これは、カプセル化された要求が奇形であるか、ターゲットリソースが応答を生成しないためかもしれません。どちらの場合でも、忘却のゲートウェイリソースは、適切なエラーステータスコード（400（悪い要求）または504（ゲートウェイタイムアウト）などの応答を生成できます。それぞれ[HTTP]のセクション15.5.1および15.6.5を参照）。この応答は、成功した応答と同じ方法でカプセル化されています。"
    },
    {
      "indent": 3,
      "text": "Errors in the encapsulation of requests mean that responses cannot be encapsulated. This includes cases where the key configuration is incorrect or outdated. The Oblivious Gateway Resource can generate and send a response with a 4xx status code to the Oblivious Relay Resource. This response MAY be forwarded to the Client or treated by the Oblivious Relay Resource as a failure. If a Client receives a response that is not an Encapsulated Response, this could indicate that the Client configuration used to construct the request is incorrect or out of date.",
      "ja": "リクエストのカプセル化のエラーは、応答をカプセル化できないことを意味します。これには、キー構成が間違っている、または時代遅れの場合が含まれます。忘れられないゲートウェイリソースは、4xxステータスコードを備えた応答を生成して、忘却のリレーリソースに送信できます。この応答は、クライアントに転送されるか、障害のあるリレーリソースによって障害として扱われる場合があります。クライアントがカプセル化された応答ではない応答を受信した場合、これは、リクエストの構築に使用されるクライアント構成が間違っているか、古くなっていることを示している可能性があります。"
    },
    {
      "indent": 0,
      "text": "5.3. Signaling Key Configuration Problems",
      "section_title": true,
      "ja": "5.3. キー構成の問題を信号します"
    },
    {
      "indent": 3,
      "text": "The problem type [PROBLEM] of \"https://iana.org/assignments/http-problem-types#ohttp-key\" is defined in this section. An Oblivious Gateway Resource MAY use this problem type in a response to indicate that an Encapsulated Request used an outdated or incorrect key configuration.",
      "ja": "「https://iana.org/assignments/http-problem-types#ohttp-key」の問題タイプ[問題]は、このセクションで定義されています。忘れられないゲートウェイリソースは、この問題タイプを応答で使用して、カプセル化された要求が時代遅れまたは誤ったキー構成を使用したことを示します。"
    },
    {
      "indent": 3,
      "text": "Figure 7 shows an example response in HTTP/1.1 format.",
      "ja": "図7は、HTTP/1.1形式の応答の例を示しています。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 400 Bad Request\nDate: Mon, 07 Feb 2022 00:28:05 GMT\nContent-Type: application/problem+json\nContent-Length: 106",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "{\"type\":\"https://iana.org/assignments/http-problem-types#ohttp-key\",\n\"title\": \"key identifier unknown\"}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "Figure 7: Example Rejection of Key Configuration",
      "ja": "図7：キー構成の例の拒絶"
    },
    {
      "indent": 3,
      "text": "As this response cannot be encrypted, it might not reach the Client. A Client cannot rely on the Oblivious Gateway Resource using this problem type. A Client might also be configured to disregard responses that are not encapsulated on the basis that they might be subject to observation or modification by an Oblivious Relay Resource. A Client might manage the risk of an outdated key configuration using a heuristic approach whereby it periodically refreshes its key configuration if it receives a response with an error status code that has not been encapsulated.",
      "ja": "この応答は暗号化できないため、クライアントに届かない場合があります。クライアントは、この問題タイプを使用して、忘却のゲートウェイリソースに依存することはできません。また、クライアントは、気付かないリレーリソースによる観察または変更の対象となる可能性があることに基づいてカプセル化されていない応答を無視するように構成されている場合があります。クライアントは、ヒューリスティックアプローチを使用して時代遅れのキー構成のリスクを管理する場合があります。これにより、カプセル化されていないエラーステータスコードを使用して応答を受信した場合、定期的にキー構成が再表示されます。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "In this design, a Client wishes to make a request to an Oblivious Gateway Resource that is forwarded to a Target Resource. The Client wishes to make this request without linking that request with either of the following:",
      "ja": "この設計では、クライアントは、ターゲットリソースに転送される忘れられないゲートウェイリソースにリクエストを行いたいと考えています。クライアントは、そのリクエストを次のいずれかのいずれかとリンクせずに、このリクエストを行うことを希望します。"
    },
    {
      "indent": 3,
      "text": "* The identity at the network and transport layer of the Client (that is, the Client IP address and TCP or UDP port number the Client uses to create a connection).",
      "ja": "* クライアントのネットワークおよび輸送層（つまり、クライアントIPアドレスとTCPまたはUDPポート番号がクライアントが使用して接続を作成する）のID。"
    },
    {
      "indent": 3,
      "text": "* Any other request the Client might have made in the past or might make in the future.",
      "ja": "* クライアントが過去に行ったかもしれないし、将来行ったかもしれない他の要求。"
    },
    {
      "indent": 3,
      "text": "In order to ensure this, the Client selects a relay (that serves the Oblivious Relay Resource) that it trusts will protect this information by forwarding the Encapsulated Request and Response without passing it to the server (that serves the Oblivious Gateway Resource).",
      "ja": "これを確実にするために、クライアントは、カプセル化された要求と応答をサーバーに渡すことなく転送することにより、この情報を保護するというリレー（忘却のリレーリソースを提供する）を選択します（忘れられないゲートウェイリソースを提供します）。"
    },
    {
      "indent": 3,
      "text": "In this section, a deployment where there are three entities is considered:",
      "ja": "このセクションでは、3つのエンティティがある展開を検討します。"
    },
    {
      "indent": 3,
      "text": "* A Client makes requests and receives responses.",
      "ja": "* クライアントはリクエストを行い、回答を受け取ります。"
    },
    {
      "indent": 3,
      "text": "* A relay operates the Oblivious Relay Resource.",
      "ja": "* リレーは、忘れられないリレーリソースを操作します。"
    },
    {
      "indent": 3,
      "text": "* A server operates both the Oblivious Gateway Resource and the Target Resource.",
      "ja": "* サーバーは、忘却のゲートウェイリソースとターゲットリソースの両方を操作します。"
    },
    {
      "indent": 3,
      "text": "Section 6.10 discusses the security implications for a case where different servers operate the Oblivious Gateway Resource and Target Resource.",
      "ja": "セクション6.10では、異なるサーバーが忘却のゲートウェイリソースとターゲットリソースを操作する場合のセキュリティへの影響について説明します。"
    },
    {
      "indent": 3,
      "text": "Requests from the Client to Oblivious Relay Resource and from Oblivious Relay Resource to Oblivious Gateway Resource MUST use HTTPS in order to provide unlinkability in the presence of a network observer.",
      "ja": "クライアントから、忘れられないリレーリソースへのリクエスト、および忘却のリレーリソースから、ネットワークオブザーバーの存在下でのリンク可能性を提供するために、HTTPSを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "To achieve the stated privacy goals, the Oblivious Relay Resource cannot be operated by the same entity as the Oblivious Gateway Resource. However, colocation of the Oblivious Gateway Resource and Target Resource simplifies the interactions between those resources without affecting Client privacy.",
      "ja": "指定されたプライバシーの目標を達成するために、忘れられないリレーリソースを、忘却のゲートウェイリソースと同じエンティティで運用することはできません。ただし、忘却のゲートウェイリソースとターゲットリソースのコロケーションは、クライアントのプライバシーに影響を与えることなく、これらのリソース間の相互作用を簡素化します。"
    },
    {
      "indent": 3,
      "text": "As a consequence of this configuration, Oblivious HTTP prevents linkability described above. Informally, this means:",
      "ja": "この構成の結果として、忘却HTTPは上記のリンク性を防ぎます。非公式には、これは次のことを意味します。"
    },
    {
      "indent": 3,
      "text": "1. Requests and responses are known only to Clients and Oblivious Gateway Resources. In particular, the Oblivious Relay Resource knows the origin and destination of an Encapsulated Request and Response, yet it does not know the decrypted contents. Likewise, Oblivious Gateway Resources learn only the Oblivious Relay Resource and the decrypted request. No entity other than the Client can see the plaintext request and response and can attribute them to the Client.",
      "ja": "1. リクエストと応答は、クライアントと忘れられないゲートウェイリソースのみに知られています。特に、忘れられないリレーリソースは、カプセル化されたリクエストと応答の起源と目的地を知っていますが、復号化された内容はわかりません。同様に、忘却のゲートウェイリソースは、忘却のリレーリソースと復号化されたリクエストのみを学習します。クライアント以外のエンティティは、プレーンテキストの要求と応答を見ることができず、クライアントに起因することはありません。"
    },
    {
      "indent": 3,
      "text": "2. Oblivious Gateway Resources, and therefore Target Resources, cannot link requests from the same Client in the absence of unique per-Client keys.",
      "ja": "2. 忘れられないゲートウェイリソース、したがって、ターゲットリソースは、一意のクライアントキーがない場合、同じクライアントからのリクエストをリンクすることはできません。"
    },
    {
      "indent": 3,
      "text": "Traffic analysis that might affect these properties is outside the scope of this document; see Section 6.2.3.",
      "ja": "これらのプロパティに影響を与える可能性のあるトラフィック分析は、このドキュメントの範囲外です。セクション6.2.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "A formal analysis of Oblivious HTTP is in [OHTTP-ANALYSIS].",
      "ja": "忘却のHTTPの正式な分析は[OHTTP分析]にあります。"
    },
    {
      "indent": 0,
      "text": "6.1. Client Responsibilities",
      "section_title": true,
      "ja": "6.1. クライアントの責任"
    },
    {
      "indent": 3,
      "text": "Because Clients do not authenticate the Target Resource when using Oblivious HTTP, Clients MUST have some mechanism to authorize an Oblivious Gateway Resource for use with a Target Resource. One possible means of authorization is an allowlist. This ensures that Oblivious Gateway Resources are not misused to forward traffic to arbitrary Target Resources. Section 6.3 describes similar responsibilities that apply to Oblivious Gateway Resources.",
      "ja": "クライアントは、忘却HTTPを使用するときにターゲットリソースを認証しないため、クライアントは、ターゲットリソースで使用するための忘却のゲートウェイリソースを承認するためのいくつかのメカニズムを持たなければなりません。許可の1つの可能な手段は、Allowlistです。これにより、忘却のゲートウェイリソースが任意のターゲットリソースにトラフィックを転送するために誤用されないことが保証されます。セクション6.3では、忘却のゲートウェイリソースに適用される同様の責任について説明します。"
    },
    {
      "indent": 3,
      "text": "Clients MUST ensure that the key configuration they select for generating Encapsulated Requests is integrity protected and authenticated so that it can be attributed to the Oblivious Gateway Resource; see Section 3.",
      "ja": "クライアントは、カプセル化された要求を生成するために選択する重要な構成が整合性保護および認証されていることを確認する必要があります。セクション3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Since Clients connect directly to the Oblivious Relay Resource instead of the Target Resource, application configurations wherein Clients make policy decisions about target connections, e.g., to apply certificate pinning, are incompatible with Oblivious HTTP. In such cases, alternative technologies such as HTTP CONNECT (Section 9.3.6 of [HTTP]) can be used. Applications could implement related policies on key configurations and relay connections, though these might not provide the same properties as policies enforced directly on target connections. Instead, when this difference is relevant, applications can connect directly to the target at the cost of either privacy or performance.",
      "ja": "クライアントは、ターゲットリソースの代わりに忘却のリレーリソースに直接接続するため、クライアントはターゲット接続に関するポリシー決定を行うアプリケーション構成、たとえば証明書のピン留めを適用することは、忘却のhttpと互換性がありません。このような場合、HTTP Connect（[HTTP]のセクション9.3.6）などの代替技術を使用できます。アプリケーションは、主要な構成とリレー接続に関する関連ポリシーを実装できますが、これらはターゲット接続で直接施行されたポリシーと同じプロパティを提供しない場合があります。代わりに、この違いが関連する場合、アプリケーションはプライバシーまたはパフォーマンスのいずれかのコストでターゲットに直接接続できます。"
    },
    {
      "indent": 3,
      "text": "Clients cannot carry connection-level state between requests as they only establish direct connections to the relay responsible for the Oblivious Relay Resource. However, the content of requests might be used by a server to correlate requests. Cookies [COOKIES] are the most obvious feature that might be used to correlate requests, but any identity information and authentication credentials might have the same effect. Clients also need to treat information learned from responses with similar care when constructing subsequent requests, which includes the identity of resources.",
      "ja": "クライアントは、リクエスト間で接続レベルの状態を運ぶことはできません。なぜなら、それらは、忘れられないリレーリソースの責任を負うリレーへの直接的な接続のみを確立するためです。ただし、リクエストのコンテンツは、リクエストを相関させるためにサーバーによって使用される場合があります。Cookie [Cookie]は、リクエストを相関させるために使用される可能性のある最も明白な機能ですが、ID情報と認証資格情報は同じ効果がある場合があります。また、クライアントは、リソースのアイデンティティを含む後続のリクエストを構築する際に、同様の注意を払って回答から学んだ情報を扱う必要があります。"
    },
    {
      "indent": 3,
      "text": "Clients MUST generate a new HPKE context for every request, using a good source of entropy [RANDOM] for generating keys. Key reuse not only risks requests being linked but also could expose request and response contents to the relay.",
      "ja": "クライアントは、キーを生成するためのエントロピー[ランダム]の優れたソースを使用して、リクエストごとに新しいHPKEコンテキストを生成する必要があります。キーの再利用は、リンクされるリクエストのリスクだけでなく、リクエストと応答の内容をリレーに公開する可能性もあります。"
    },
    {
      "indent": 3,
      "text": "The request the Client sends to the Oblivious Relay Resource only requires minimal information; see Section 5. The request that carries the Encapsulated Request and that is sent to the Oblivious Relay Resource MUST NOT include identifying information unless the Client can trust that this information is removed by the relay. A Client MAY include information only for the Oblivious Relay Resource in header fields identified by the Connection header field if it trusts the relay to remove these, as required by Section 7.6.1 of [HTTP]. The Client needs to trust that the relay does not replicate the source addressing information in the request it forwards.",
      "ja": "クライアントが忘れられないリレーリソースに送信するリクエストには、最小限の情報のみが必要です。セクション5を参照してください。カプセル化されたリクエストを運ぶリクエストと、クライアントがこの情報がリレーによって削除されていることを信頼できない限り、忘却のリレーリソースに送信されるリクエストは識別情報を含めてはなりません。クライアントには、[HTTP]のセクション7.6.1で要求されるように、リレーがこれらを削除することを信頼している場合、接続ヘッダーフィールドによって識別されるヘッダーフィールドの忘却のリレーリソースに関する情報のみを含めることができます。クライアントは、リレーがフォワードのリクエスト内のソースアドレス指定情報を複製しないことを信頼する必要があります。"
    },
    {
      "indent": 3,
      "text": "Clients rely on the Oblivious Relay Resource to forward Encapsulated Requests and Responses. However, the relay can only refuse to forward messages; it cannot inspect or modify the contents of Encapsulated Requests or Responses.",
      "ja": "クライアントは、カプセル化されたリクエストと応答を転送するために、気づかないリレーリソースに依存しています。ただし、リレーはメッセージを転送することのみを拒否できます。カプセル化されたリクエストまたは応答の内容を検査または変更することはできません。"
    },
    {
      "indent": 0,
      "text": "6.2. Relay Responsibilities",
      "section_title": true,
      "ja": "6.2. リレーの責任"
    },
    {
      "indent": 3,
      "text": "The relay that serves the Oblivious Relay Resource has a very simple function to perform. For each request it receives, it makes a request of the Oblivious Gateway Resource that includes the same content. When it receives a response, it sends a response to the Client that includes the content of the response from the Oblivious Gateway Resource.",
      "ja": "忘れられないリレーリソースを提供するリレーには、実行する非常に簡単な機能があります。受信するリクエストごとに、同じコンテンツを含む忘却のゲートウェイリソースのリクエストを行います。応答を受信すると、忘却のゲートウェイリソースからの応答のコンテンツを含むクライアントに応答を送信します。"
    },
    {
      "indent": 3,
      "text": "When forwarding a request, the relay MUST follow the forwarding rules in Section 7.6 of [HTTP]. A generic HTTP intermediary implementation is suitable for the purposes of serving an Oblivious Relay Resource, but additional care is needed to ensure that Client privacy is maintained.",
      "ja": "リクエストを転送する場合、リレーは[HTTP]のセクション7.6の転送ルールに従う必要があります。一般的なHTTP仲介業者の実装は、気づかないリレーリソースを提供する目的に適していますが、クライアントのプライバシーが維持されるように追加の注意が必要です。"
    },
    {
      "indent": 3,
      "text": "Firstly, a generic implementation will forward unknown fields. For Oblivious HTTP, an Oblivious Relay Resource SHOULD NOT forward unknown fields. Though Clients are not expected to include fields that might contain identifying information, removing unknown fields removes this privacy risk.",
      "ja": "第一に、一般的な実装は不明なフィールドを転送します。忘却HTTPの場合、忘れられないリレーリソースは不明なフィールドを転送してはなりません。クライアントには識別情報を含む可能性のあるフィールドには含まれることは期待されていませんが、不明なフィールドを削除すると、このプライバシーリスクが削除されます。"
    },
    {
      "indent": 3,
      "text": "Secondly, generic implementations are often configured to augment requests with information about the Client, such as the Via field or the Forwarded field [FORWARDED]. A relay MUST NOT add information when forwarding requests that might be used to identify Clients, except for information that a Client is aware of; see Section 6.2.1.",
      "ja": "第二に、一般的な実装は、VIAフィールドや転送フィールドなど、クライアントに関する情報を使用してリクエストを強化するように構成されていることがよくあります[転送]。リレーは、クライアントが認識している情報を除いて、クライアントを識別するために使用される可能性のあるリクエストを転送するときに情報を追加してはなりません。セクション6.2.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Finally, a relay can also generate responses, though it is assumed to not be able to examine the content of a request (other than to observe the choice of key identifier, KDF, and AEAD); therefore, it is also assumed that it cannot generate an Encapsulated Response.",
      "ja": "最後に、リレーは応答を生成することもできますが、リクエストの内容を調べることができないと想定されています（キー識別子、KDF、およびAEADの選択を観察する以外）。したがって、カプセル化された応答を生成できないと想定されています。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Differential Treatment",
      "section_title": true,
      "ja": "6.2.1. 微分治療"
    },
    {
      "indent": 3,
      "text": "A relay MAY add information to requests if the Client is aware of the nature of the information that could be added. Any addition MUST NOT include information that uniquely and permanently identifies the Client, including any pseudonymous identifier. Information added by the relay -- beyond what is already revealed through Encapsulated Requests from Clients -- can reduce the size of the anonymity set of Clients at a gateway.",
      "ja": "リレーは、追加できる情報の性質をクライアントが認識している場合、リクエストに情報を追加する場合があります。追加されたものは、仮名識別子を含むクライアントを一意に永続的に識別する情報を含めるべきではありません。リレーによって追加された情報 - クライアントからのカプセル化された要求を通じて既に明らかにされているものを超えて、ゲートウェイでのクライアントの匿名性セットのサイズを縮小することができます。"
    },
    {
      "indent": 3,
      "text": "A Client does not need to be aware of the exact value added for each request but needs to know the range of possible values the relay might use. How a Client might learn about added information is not defined in this document.",
      "ja": "クライアントは、各リクエストの正確な価値を認識する必要はありませんが、リレーが使用する可能性のある値の範囲を知る必要があります。追加情報についてクライアントがどのように学習するかは、このドキュメントで定義されていません。"
    },
    {
      "indent": 3,
      "text": "Moreover, relays MAY apply differential treatment to Clients that engage in abusive behavior, e.g., by sending too many requests in comparison to other Clients, or as a response to rate limits signaled from the gateway. Any such differential treatment can reveal information to the gateway that would not be revealed otherwise and therefore reduce the size of the anonymity set of Clients using a gateway. For example, if a relay chooses to rate limit or block an abusive Client, this means that any Client requests that are not treated this way are known to be non-abusive by the gateway. Clients need to consider the likelihood of such differential treatment and the privacy risks when using a relay.",
      "ja": "さらに、リレーは、たとえば、他のクライアントと比較してあまりにも多くの要求を送信すること、またはゲートウェイからのシグナルのレート制限への応答として、虐待的な行動に従事するクライアントに微分治療を適用する場合があります。このような微分処理は、別の方法で明らかにされないゲートウェイに情報を明らかにすることができ、したがって、ゲートウェイを使用してクライアントの匿名セットのサイズを縮小します。たとえば、リレーが虐待的なクライアントを制限またはブロックすることを選択した場合、これは、この方法で扱われないクライアントの要求がゲートウェイによって虐待されていないことが知られていることを意味します。クライアントは、リレーを使用する際のこのような微分治療の可能性とプライバシーのリスクを考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "Some patterns of abuse cannot be detected without access to the request that is made to the target. This means that only the gateway or the target is in a position to identify abuse. A gateway MAY send signals toward the relay to provide feedback about specific requests. For example, a gateway could respond differently to requests it cannot decapsulate, as mentioned in Section 5.2. A relay that acts on this feedback could -- either inadvertently or by design -- lead to Client deanonymization.",
      "ja": "ターゲットに行われる要求にアクセスしなくても、虐待のパターンを検出することはできません。これは、ゲートウェイまたはターゲットのみが虐待を特定する立場にあることを意味します。ゲートウェイは、特定のリクエストに関するフィードバックを提供するために、リレーに向かって信号を送信する場合があります。たとえば、セクション5.2に記載されているように、ゲートウェイは脱カプセル化できないリクエストに対して異なる反応をする可能性があります。このフィードバックに基づいて作用するリレーは、不注意にまたは設計のいずれかで、クライアントの異議につながる可能性があります。"
    },
    {
      "indent": 0,
      "text": "6.2.2. Denial of Service",
      "section_title": true,
      "ja": "6.2.2. サービス拒否"
    },
    {
      "indent": 3,
      "text": "As there are privacy benefits from having a large rate of requests forwarded by the same relay (see Section 6.2.3), servers that operate the Oblivious Gateway Resource might need an arrangement with Oblivious Relay Resources. This arrangement might be necessary to prevent having the large volume of requests being classified as an attack by the server.",
      "ja": "同じリレーによって転送されるリクエストの大きなレートを持つことでプライバシーのメリットがあるため（セクション6.2.3を参照）、忘却のゲートウェイリソースを操作するサーバーには、忘却のリレーリソースを備えた配置が必要になる場合があります。この配置は、サーバーによる攻撃として大量のリクエストが分類されるのを防ぐために必要な場合があります。"
    },
    {
      "indent": 3,
      "text": "If a server accepts a larger volume of requests from a relay, it needs to trust that the relay does not allow abusive levels of request volumes from Clients. That is, if a server allows requests from the relay to be exempt from rate limits, the server might want to ensure that the relay applies a rate-limiting policy that is acceptable to the server.",
      "ja": "サーバーがリレーからのより多くのリクエストを受け入れる場合、リレーがクライアントからの虐待的なレベルのリクエストボリュームを許可しないことを信頼する必要があります。つまり、サーバーがリレーからのリクエストをレート制限から免除することを許可した場合、サーバーはリレーがサーバーに受け入れられるレート制限ポリシーを適用することを保証する場合があります。"
    },
    {
      "indent": 3,
      "text": "Servers that enter into an agreement with a relay that enables a higher request rate might choose to authenticate the relay to enable the higher rate.",
      "ja": "より高いリクエストレートを有効にするリレーと契約を締結するサーバーは、より高いレートを有効にするためにリレーを認証することを選択する可能性があります。"
    },
    {
      "indent": 0,
      "text": "6.2.3. Traffic Analysis",
      "section_title": true,
      "ja": "6.2.3. トラフィック分析"
    },
    {
      "indent": 3,
      "text": "Using HTTPS protects information about which resources are the subject of request and prevents a network observer from being able to trivially correlate messages on either side of a relay. However, using HTTPS does not prevent traffic analysis by such network observers.",
      "ja": "HTTPSを使用すると、どのリソースがリクエストの対象であるかに関する情報を保護し、ネットワークオブザーバーがリレーの両側のメッセージを簡単に相関させることができなくなります。ただし、HTTPSを使用しても、このようなネットワークオブザーバーによるトラフィック分析が妨げられません。"
    },
    {
      "indent": 3,
      "text": "The time at which Encapsulated Request or Response messages are sent can reveal information to a network observer. Though messages exchanged between the Oblivious Relay Resource and the Oblivious Gateway Resource might be sent in a single connection, traffic analysis could be used to match messages that are forwarded by the relay.",
      "ja": "カプセル化されたリクエストまたは応答メッセージが送信される時間は、ネットワークオブザーバーに情報を明らかにすることができます。忘れられないリレーリソースと忘却のゲートウェイリソースとの間に交換されたメッセージは、単一の接続で送信される場合がありますが、トラフィック分析を使用して、リレーによって転送されるメッセージを一致させることができます。"
    },
    {
      "indent": 3,
      "text": "A relay could, as part of its function, delay requests before forwarding them. Delays might increase the anonymity set into which each request is attributed. Any delay also increases the time that a Client waits for a response, so delays SHOULD only be added with the consent -- or at least awareness -- of Clients.",
      "ja": "リレーは、その機能の一部として、それらを転送する前にリクエストを遅らせる可能性があります。遅延は、各要求が起因する匿名性セットを増やす可能性があります。また、遅延はクライアントが応答を待つ時間を増やすため、クライアントの同意または少なくとも認識を持つだけで遅延を追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "A relay that forwards large volumes of exchanges can provide better privacy by providing larger sets of messages that need to be matched.",
      "ja": "大量の交換を転送するリレーは、一致する必要があるメッセージを大幅に提供することにより、より良いプライバシーを提供できます。"
    },
    {
      "indent": 3,
      "text": "Traffic analysis is not restricted to network observers. A malicious Oblivious Relay Resource could use traffic analysis to learn information about otherwise encrypted requests and responses relayed between Clients and gateways. An Oblivious Relay Resource terminates TLS connections from Clients, so they see message boundaries. This privileged position allows for richer feature extraction from encrypted data, which might improve traffic analysis.",
      "ja": "トラフィック分析は、ネットワークオブザーバーに制限されていません。悪意のある忘却のリレーリソースは、トラフィック分析を使用して、クライアントとゲートウェイの間で中継された暗号化された要求と応答に関する情報を学習できます。忘れられないリレーリソースは、クライアントからのTLS接続を終了するため、メッセージの境界が表示されます。この特権的な位置により、暗号化されたデータからのより豊富な機能抽出が可能になり、トラフィック分析が改善される可能性があります。"
    },
    {
      "indent": 3,
      "text": "Clients and Oblivious Gateway Resources can use padding to reduce the effectiveness of traffic analysis. Padding is a capability provided by binary HTTP messages; see Section 3.8 of [BINARY]. If the encapsulation method described in this document is used to protect a different message type (see Section 4.6), that message format might need to include padding support. Oblivious Relay Resources can also use padding for the same reason but need to operate at the HTTP layer since they cannot manipulate binary HTTP messages; for example, see Section 10.7 of [HTTP/2] or Section 10.7 of [HTTP/3]).",
      "ja": "クライアントと忘れられないゲートウェイリソースは、パディングを使用して、トラフィック分析の有効性を減らすことができます。パディングは、バイナリHTTPメッセージによって提供される機能です。[バイナリ]のセクション3.8を参照してください。このドキュメントで説明されているカプセル化方法が、異なるメッセージタイプを保護するために使用されている場合（セクション4.6を参照）、そのメッセージ形式にはパディングサポートが含まれる必要がある場合があります。忘れられないリレーリソースは、同じ理由でパディングを使用することもできますが、バイナリHTTPメッセージを操作できないため、HTTPレイヤーで操作する必要があります。たとえば、[http/2]のセクション10.7または[http/3]のセクション10.7を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.3. Server Responsibilities",
      "section_title": true,
      "ja": "6.3. サーバーの責任"
    },
    {
      "indent": 3,
      "text": "The Oblivious Gateway Resource can be operated by a different entity than the Target Resource. However, this means that the Client needs to trust the Oblivious Gateway Resource not to modify requests or responses. This analysis concerns itself with a deployment scenario where a single server provides both the Oblivious Gateway Resource and Target Resource.",
      "ja": "忘れられないゲートウェイリソースは、ターゲットリソースとは異なるエンティティによって操作できます。ただし、これは、クライアントがリクエストや応答を変更しないために、忘れられないゲートウェイリソースを信頼する必要があることを意味します。この分析は、単一のサーバーが忘却のゲートウェイリソースとターゲットリソースの両方を提供する展開シナリオに関係しています。"
    },
    {
      "indent": 3,
      "text": "A server that operates both Oblivious Gateway and Target Resources is responsible for removing request encryption, generating a response to the Encapsulated Request, and encrypting the response.",
      "ja": "忘却のゲートウェイとターゲットリソースの両方を操作するサーバーは、要求の暗号化を削除し、カプセル化された要求に対する応答を生成し、応答を暗号化する責任があります。"
    },
    {
      "indent": 3,
      "text": "Servers should account for traffic analysis based on response size or generation time. Techniques such as padding or timing delays can help protect against such attacks; see Section 6.2.3.",
      "ja": "サーバーは、応答サイズまたは生成時間に基づいてトラフィック分析を考慮する必要があります。パディングやタイミングの遅延などの技術は、そのような攻撃から保護するのに役立ちます。セクション6.2.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "If separate entities provide the Oblivious Gateway Resource and Target Resource, these entities might need an arrangement similar to that between server and relay for managing denial of service; see Section 6.2.2. Moreover, the Oblivious Gateway Resource SHOULD have some mechanism to ensure that the Oblivious Gateway Resource is not misused as a relay for HTTP messages to an arbitrary Target Resource, such as an allowlist.",
      "ja": "個別のエンティティが忘れられないゲートウェイリソースとターゲットリソースを提供する場合、これらのエンティティは、サービスの拒否を管理するためにサーバーとリレーの間の配置と同様の配置を必要とする場合があります。セクション6.2.2を参照してください。さらに、忘却のゲートウェイリソースには、Alowlistなどの任意のターゲットリソースへのHTTPメッセージのリレーとして、忘却のゲートウェイリソースが誤用されないようにするためのいくつかのメカニズムが必要です。"
    },
    {
      "indent": 3,
      "text": "Non-secure requests -- such as those with the \"http\" scheme as opposed to the \"https\" scheme -- SHOULD NOT be used if the Oblivious Gateway and Target Resources are not on the same origin. If messages are forwarded between these resources without the protections afforded by HTTPS, they could be inspected or modified by a network attacker. Note that a request could be forwarded without protection if the two resources share an origin.",
      "ja": "「HTTPS」スキームとは対照的に「HTTP」スキームを持つものなどの非セキュアリクエストは、忘却のゲートウェイとターゲットリソースが同じ起源にない場合は使用しないでください。HTTPSによって提供される保護なしにこれらのリソース間でメッセージが転送される場合、ネットワーク攻撃者によって検査または変更される可能性があります。2つのリソースが起源を共有している場合、リクエストは保護なしで転送できることに注意してください。"
    },
    {
      "indent": 0,
      "text": "6.4. Key Management",
      "section_title": true,
      "ja": "6.4. キー管理"
    },
    {
      "indent": 3,
      "text": "An Oblivious Gateway Resource needs to have a plan for replacing keys. This might include regular replacement of keys, which can be assigned new key identifiers. If an Oblivious Gateway Resource receives a request that contains a key identifier that it does not understand or that corresponds to a key that has been replaced, the server can respond with an HTTP 422 (Unprocessable Content) status code.",
      "ja": "気まぐれなゲートウェイリソースには、キーを交換する計画が必要です。これには、新しいキー識別子を割り当てることができるキーの定期的な交換が含まれる場合があります。気まぐれなゲートウェイリソースが、理解できないキー識別子を含む、または交換されたキーに対応するキー識別子を含むリクエストを受信した場合、サーバーはHTTP 422（処理できないコンテンツ）ステータスコードで応答できます。"
    },
    {
      "indent": 3,
      "text": "A server can also use a 422 status code if the server has a key that corresponds to the key identifier, but the Encapsulated Request cannot be successfully decrypted using the key.",
      "ja": "サーバーにキー識別子に対応するキーがある場合、サーバーは422ステータスコードを使用することもできますが、キーを使用してカプセル化された要求を正常に復号化することはできません。"
    },
    {
      "indent": 3,
      "text": "A server MUST ensure that the HPKE keys it uses are not valid for any other protocol that uses HPKE with the \"message/bhttp request\" label. Designers of protocols that reuse this encryption format, especially new versions of this protocol, can ensure key diversity by choosing a different label in their use of HPKE. The \"message/bhttp response\" label was chosen for symmetry only as it provides key diversity only within the HPKE context created using the \"message/bhttp request\" label; see Section 4.6.",
      "ja": "サーバーは、使用するHPKEキーが、「メッセージ/BHTTPリクエスト」ラベルを使用してHPKEを使用する他のプロトコルに対して有効でないことを確認する必要があります。この暗号化形式、特にこのプロトコルの新しいバージョンを再利用するプロトコルの設計者は、HPKEの使用に異なるラベルを選択することにより、重要な多様性を確保できます。「メッセージ/BHTTP応答」ラベルは、「メッセージ/BHTTPリクエスト」ラベルを使用して作成されたHPKEコンテキスト内でのみ重要な多様性を提供するため、対称性のためにのみ選択されました。セクション4.6を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.5. Replay Attacks",
      "section_title": true,
      "ja": "6.5. リプレイ攻撃"
    },
    {
      "indent": 3,
      "text": "A server is responsible for either rejecting replayed requests or ensuring that the effect of replays does not adversely affect Clients or resources.",
      "ja": "サーバーは、リプレイされたリクエストを拒否するか、リプレイの効果がクライアントやリソースに悪影響を与えないようにすることを担当します。"
    },
    {
      "indent": 3,
      "text": "Encapsulated Requests can be copied and replayed by the Oblivious Relay Resource. The threat model for Oblivious HTTP allows the possibility that an Oblivious Relay Resource might replay requests. Furthermore, if a Client sends an Encapsulated Request in TLS early data (see Section 8 of [TLS] and [RFC8470]), a network-based adversary might be able to cause the request to be replayed. In both cases, the effect of a replay attack and the mitigations that might be employed are similar to TLS early data.",
      "ja": "カプセル化されたリクエストは、忘れられないリレーリソースによってコピーおよび再生できます。忘却HTTPの脅威モデルにより、忘却のリレーリソースがリクエストを再生する可能性があります。さらに、クライアントがTLSの早期データでカプセル化された要求を送信する場合（[TLS]および[RFC8470]のセクション8を参照）、ネットワークベースの敵がリクエストを再生することができる可能性があります。どちらの場合も、リプレイ攻撃の効果と採用される可能性のある緩和は、TLSの初期データに似ています。"
    },
    {
      "indent": 3,
      "text": "It is the responsibility of the application that uses Oblivious HTTP to either reject replayed requests or ensure that replayed requests have no adverse effect on their operation. This section describes some approaches that are universally applicable and suggestions for more targeted techniques.",
      "ja": "忘却HTTPを使用して、再生されたリクエストを拒否するか、再生されたリクエストが操作に悪影響を与えないことを確認するのは、アプリケーションの責任です。このセクションでは、普遍的に適用可能ないくつかのアプローチと、よりターゲットを絞った手法のための提案について説明します。"
    },
    {
      "indent": 3,
      "text": "A Client or Oblivious Relay Resource MUST NOT automatically attempt to retry a failed request unless it receives a positive signal indicating that the request was not processed or forwarded. The HTTP/2 REFUSED_STREAM error code (Section 8.1.4 of [HTTP/2]), the HTTP/3 H3_REQUEST_REJECTED error code (Section 8.1 of [HTTP/3]), or a GOAWAY frame with a low enough identifier (in either protocol version) are all sufficient signals that no processing occurred. HTTP/1.1 [HTTP/1.1] provides no equivalent signal. Connection failures or interruptions are not sufficient signals that no processing occurred.",
      "ja": "クライアントまたは忘れられないリレーリソースは、リクエストが処理または転送されていないことを示す正の信号を受信しない限り、失敗した要求を自動的に再試行しようとしてはなりません。http/2拒否_streamエラーコード（[http/2]のセクション8.1.4）、http/3 h3_request_rejectedエラーコード（[http/3]のセクション8.1）、または十分に低い識別子を持つgoawayフレームプロトコルバージョン）はすべて、処理が発生しないという十分な信号です。HTTP/1.1 [HTTP/1.1]は等価信号を提供しません。接続の障害または中断は、処理が発生しなかったという十分な信号ではありません。"
    },
    {
      "indent": 3,
      "text": "The anti-replay mechanisms described in Section 8 of [TLS] are generally applicable to Oblivious HTTP requests. The encapsulated keying material (or enc) can be used in place of a nonce to uniquely identify a request. This value is a high-entropy value that is freshly generated for every request, so two valid requests will have different values with overwhelming probability.",
      "ja": "[TLS]のセクション8で説明されているアンチレプレイメカニズムは、一般に、忘却HTTP要求に適用できます。カプセル化されたキーイング材料（またはENC）は、ノンセの代わりにリクエストを一意に識別するために使用できます。この値は、リクエストごとに新たに生成される高エントロピー値であるため、2つの有効なリクエストには、圧倒的な確率で異なる値があります。"
    },
    {
      "indent": 3,
      "text": "The mechanism used in TLS for managing differences in Client and server clocks cannot be used as it depends on being able to observe previous interactions. Oblivious HTTP explicitly prevents such linkability.",
      "ja": "クライアントクロックとサーバークロックの違いを管理するためにTLSで使用されるメカニズムは、以前の相互作用を観察できることに依存するため、使用できません。忘却HTTPは、そのようなリンク可能性を明示的に防止します。"
    },
    {
      "indent": 3,
      "text": "The considerations in [RFC8470] as they relate to managing the risk of replay also apply, though there is no option to delay the processing of a request.",
      "ja": "リクエストの処理を遅らせるオプションはありませんが、リプレイのリスクの管理に関連する[RFC8470]の考慮事項も適用されます。"
    },
    {
      "indent": 3,
      "text": "Limiting requests to those with safe methods might not be satisfactory for some applications, particularly those that involve the submission of data to a server. The use of idempotent methods might be of some use in managing replay risk, though it is important to recognize that different idempotent requests can be combined to be not idempotent.",
      "ja": "安全な方法を持つ人々へのリクエストを制限することは、特にサーバーへのデータの提出を伴うアプリケーションでは満足のいくものではないかもしれません。iDempotentメソッドの使用は、リプレイリスクの管理にはある程度使用される可能性がありますが、さまざまなiDEMPOTENTリクエストを組み合わせて等身ではないことを認識することが重要です。"
    },
    {
      "indent": 3,
      "text": "Even without replay prevention, the server-chosen response_nonce field ensures that responses have unique AEAD keys and nonces even when requests are replayed.",
      "ja": "リプレイの予防がなくても、サーバーを選択するResponse_Nonceフィールドは、リクエストが再生された場合でも、応答が一意のAEADキーとノンセスを持つことを保証します。"
    },
    {
      "indent": 0,
      "text": "6.5.1. Use of Date for Anti-replay",
      "section_title": true,
      "ja": "6.5.1. アンチレプレイの日付の使用"
    },
    {
      "indent": 3,
      "text": "Clients SHOULD include a Date header field in Encapsulated Requests, unless the Client has prior knowledge that indicates that the Oblivious Gateway Resource does not use Date for anti-replay purposes.",
      "ja": "クライアントは、カプセル化されたリクエストに日付ヘッダーフィールドを含める必要があります。クライアントが、忘れられないゲートウェイリソースがレプレイ防止目的で日付を使用していないことを示す事前の知識を持っている場合を除きます。"
    },
    {
      "indent": 3,
      "text": "Though HTTP requests often do not include a Date header field, the value of this field might be used by a server to limit the amount of requests it needs to track if it needs to prevent replay attacks.",
      "ja": "HTTPリクエストには日付ヘッダーフィールドが含まれていないことがよくありますが、このフィールドの値は、リプレイ攻撃を防ぐ必要がある場合に追跡するために必要なリクエストの量をサーバーによって使用する場合があります。"
    },
    {
      "indent": 3,
      "text": "An Oblivious Gateway Resource can maintain state for requests for a small window of time over which it wishes to accept requests. The Oblivious Gateway Resource can store all requests it processes within this window. Storing just the enc field of a request, which should be unique to each request, is sufficient. The Oblivious Gateway Resource can reject any request that is the same as one that was previously answered within that time window or if the Date header field from the decrypted request is outside of the current time window.",
      "ja": "忘れられないゲートウェイリソースは、リクエストを受け入れたいという小さな時間のリクエストのために状態を維持できます。忘れられないゲートウェイリソースは、このウィンドウ内にすべてのリクエストを保存できます。リクエストのENCフィールドのみを保存することは、各リクエストに固有のものである必要があります。忘れられないゲートウェイリソースは、その時間ウィンドウ内で以前に回答されたものと同じリクエストを拒否できます。または、復号化された要求からの日付ヘッダーフィールドが現在のタイムウィンドウの外側にある場合。"
    },
    {
      "indent": 3,
      "text": "Oblivious Gateway Resources might need to allow for the time it takes requests to arrive from the Client, with a time window that is large enough to allow for differences in clocks. Insufficient tolerance of time differences could result in valid requests being unnecessarily rejected. Beyond allowing for multiple round-trip times -- to account for retransmission -- network delays are unlikely to be significant in determining the size of the window, unless all potential Clients are known to have excellent timekeeping. A specific window size might need to be determined experimentally.",
      "ja": "気まぐれなゲートウェイリソースは、クライアントからのリクエストが必要な時間を確保する必要があるかもしれません。時間ウィンドウは、時計の違いを可能にするのに十分な大きさです。時間の違いに対する耐性が不十分な場合、有効な要求が不必要に拒否される可能性があります。すべての潜在的なクライアントが優れたタイムキーピングを持っていることが知られていない限り、複数の往復時間を再送信することを許可する以外に、再送信を考慮して、ネットワークの遅延がウィンドウのサイズを決定する上で重要ではない可能性は低いです。特定のウィンドウサイズを実験的に決定する必要がある場合があります。"
    },
    {
      "indent": 3,
      "text": "Oblivious Gateway Resources MUST NOT treat the time window as secret information. An attacker can actively probe with different values for the Date field to determine the time window over which the server will accept responses.",
      "ja": "忘れられないゲートウェイリソースは、タイムウィンドウを秘密情報として扱ってはなりません。攻撃者は、日付フィールドの異なる値で積極的にプローブして、サーバーが応答を受け入れる時間ウィンドウを決定できます。"
    },
    {
      "indent": 0,
      "text": "6.5.2. Correcting Clock Differences",
      "section_title": true,
      "ja": "6.5.2. 時計の違いを修正します"
    },
    {
      "indent": 3,
      "text": "An Oblivious Gateway Resource can reject requests that contain a Date value that is outside of its active window with a 400 series status code. The problem type [PROBLEM] of \"https://iana.org/assignments/ http-problem-types#date\" is defined to allow the server to signal that the Date value in the request was unacceptable.",
      "ja": "忘れられないゲートウェイリソースは、400シリーズステータスコードを備えたアクティブウィンドウの外側にある日付値を含むリクエストを拒否できます。「https://iana.org/assignments/ http-problem-types＃date」の問題タイプ[問題]は、リクエストの日付値が受け入れられないことをサーバーが信号できるように定義されています。"
    },
    {
      "indent": 3,
      "text": "Figure 8 shows an example response in HTTP/1.1 format.",
      "ja": "図8は、HTTP/1.1形式の応答の例を示しています。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 400 Bad Request\nDate: Mon, 07 Feb 2022 00:28:05 GMT\nContent-Type: application/problem+json\nContent-Length: 128",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "{\"type\":\"https://iana.org/assignments/http-problem-types#date\",\n\"title\": \"date field in request outside of acceptable range\"}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 8: Example Rejection of Request Date Field",
      "ja": "図8：リクエスト日付フィールドの拒否の例"
    },
    {
      "indent": 3,
      "text": "Disagreements about time are unlikely if both Client and Oblivious Gateway Resource have a good source of time; see [NTP]. However, clock differences are known to be commonplace; see Section 7.1 of [CLOCKSKEW].",
      "ja": "クライアントと忘却のゲートウェイリソースの両方が時間の源を持っている場合、時間についての意見の相違はありそうにありません。[NTP]を参照してください。ただし、時計の違いは一般的であることが知られています。[Clockskew]のセクション7.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Including a Date header field in the response allows the Client to correct clock errors by retrying the same request using the value of the Date field provided by the Oblivious Gateway Resource. The value of the Date field can be copied if the response is fresh, with an adjustment based on the Age field otherwise; see Section 4.2 of [HTTP-CACHING]. When retrying a request, the Client MUST create a fresh encryption of the modified request, using a new HPKE context.",
      "ja": "応答に日付ヘッダーフィールドを含めることで、クライアントは、忘却のゲートウェイリソースによって提供される日付フィールドの値を使用して同じ要求を再試行することにより、クロックエラーを修正できます。応答が新鮮である場合、日付フィールドの値をコピーでき、それ以外の場合は年齢フィールドに基づいて調整します。[httpキャッシング]のセクション4.2を参照してください。リクエストを再試行するとき、クライアントは、新しいHPKEコンテキストを使用して、変更された要求の新しい暗号化を作成する必要があります。"
    },
    {
      "indent": 3,
      "text": "+---------+       +-------------------+      +----------+\n| Client  |       | Relay and Gateway |      | Target   |\n|         |       |     Resources     |      | Resource |\n+----+----+       +----+-----------+--+      +----+-----+\n     |                 |           |              |\n     |                 |           |              |\n     |  Request        |           |              |\n     +============================>+------------->|\n     |                 |           |              |\n     |                 |           | 400 Response |\n     |                 |           |       + Date |\n     |<============================+<-------------+\n     |                 |           |              |\n     |  Request        |           |              |\n     |  + Updated Date |           |              |\n     +============================>+------------->|\n     |                 |           |              |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 9: Retrying with an Updated Date Field",
      "ja": "図9：更新された日付フィールドで再試行"
    },
    {
      "indent": 3,
      "text": "Retrying immediately allows the Oblivious Gateway Resource to measure the round-trip time to the Client. The observed delay might reveal something about the location of the Client. Clients could delay retries to add some uncertainty to any observed delay.",
      "ja": "すぐに再試行することで、忘れられないゲートウェイリソースがクライアントへの往復時間を測定できるようになります。観察された遅延は、クライアントの位置について何かを明らかにする可能性があります。クライアントはレトリを遅らせて、観察された遅延に不確実性を追加する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Intermediaries can sometimes rewrite the Date field when forwarding responses. This might cause problems if the Oblivious Gateway Resource and intermediary clocks differ by enough to cause the retry to be rejected. Therefore, Clients MUST NOT retry a request with an adjusted date more than once.",
      "ja": "仲介者は、応答を転送するときに日付フィールドを書き換えることがあります。これは、忘れられないゲートウェイリソースと中間クロックが再試行を拒否するのに十分なほど異なる場合に問題を引き起こす可能性があります。したがって、クライアントは調整された日付で複数回リクエストを再試行してはなりません。"
    },
    {
      "indent": 3,
      "text": "Oblivious Gateway Resources that condition their responses on the Date header field SHOULD either ensure that intermediaries do not cache responses (by including a Cache-Control directive of no-store) or designate the response as conditional on the value of the Date request header field (by including the token \"date\" in a Vary header field).",
      "ja": "日付ヘッダーフィールドに応答を条件付ける忘却のゲートウェイリソースは、仲介者が（ストアのないキャッシュコントロール指令を含めることによって）応答をキャッシュしないことを確認するか、日付要求ヘッダーフィールドの値（さまざまなヘッダーフィールドにトークン「日付」を含めることにより）。"
    },
    {
      "indent": 3,
      "text": "Clients MUST NOT use the date provided by the Oblivious Gateway Resource for any other purpose, including future requests to any resource. Any request that uses information provided by the Oblivious Gateway Resource might be correlated using that information.",
      "ja": "クライアントは、任意のリソースへの将来のリクエストを含め、他の目的のために、忘却のゲートウェイリソースによって提供される日付を使用してはなりません。忘れられないゲートウェイリソースによって提供される情報を使用するリクエストは、その情報を使用して相関する場合があります。"
    },
    {
      "indent": 0,
      "text": "6.6. Forward Secrecy",
      "section_title": true,
      "ja": "6.6. フォワード秘密"
    },
    {
      "indent": 3,
      "text": "This document does not provide forward secrecy for either requests or responses during the lifetime of the key configuration. A measure of forward secrecy can be provided by generating a new key configuration then deleting the old keys after a suitable period.",
      "ja": "このドキュメントは、キー構成の寿命の間に、リクエストまたは応答のいずれかの前向きな秘密を提供しません。新しいキー構成を生成し、適切な期間後に古いキーを削除することにより、将来の秘密の尺度を提供できます。"
    },
    {
      "indent": 0,
      "text": "6.7. Post-Compromise Security",
      "section_title": true,
      "ja": "6.7. 妥協後のセキュリティ"
    },
    {
      "indent": 3,
      "text": "This design does not provide post-compromise security for responses.",
      "ja": "この設計は、応答のために妥協後のセキュリティを提供しません。"
    },
    {
      "indent": 3,
      "text": "A Client only needs to retain keying material that might be used to compromise the confidentiality and integrity of a response until that response is consumed, so there is negligible risk associated with a Client compromise.",
      "ja": "クライアントは、その応答が消費されるまで、応答の機密性と整合性を妥協するために使用される可能性のあるキーイング素材を保持する必要があるため、クライアントの妥協に関連するリスクは無視できます。"
    },
    {
      "indent": 3,
      "text": "A server retains a secret key that might be used to remove protection from messages over much longer periods. A server compromise that provided access to the Oblivious Gateway Resource secret key could allow an attacker to recover the plaintext of all requests sent toward affected keys and all of the responses that were generated.",
      "ja": "サーバーは、はるかに長い期間にわたってメッセージから保護を削除するために使用される可能性のある秘密キーを保持します。忘れられないゲートウェイリソースシークレットキーへのアクセスを提供したサーバーの妥協により、攻撃者は、影響を受けるキーと生成されたすべての応答に送られたすべての要求のプレーンテキストを回復することができます。"
    },
    {
      "indent": 3,
      "text": "Even if server keys are compromised, an adversary cannot access messages exchanged by the Client with the Oblivious Relay Resource as messages are protected by TLS. Use of a compromised key also requires that the Oblivious Relay Resource cooperate with the attacker or that the attacker is able to compromise these TLS connections.",
      "ja": "サーバーキーが侵害されたとしても、敵は、TLSによって保護されているため、誤ったリレーリソースでクライアントが交換するメッセージにアクセスできません。侵害されたキーを使用するには、忘れられないリレーリソースが攻撃者と協力するか、攻撃者がこれらのTLS接続を妥協できることも必要です。"
    },
    {
      "indent": 3,
      "text": "The total number of messages affected by server key compromise can be limited by regular rotation of server keys.",
      "ja": "サーバーキーの妥協の影響を受けるメッセージの総数は、サーバーキーの定期的な回転によって制限される可能性があります。"
    },
    {
      "indent": 0,
      "text": "6.8. Client Clock Exposure",
      "section_title": true,
      "ja": "6.8. クライアントクロック露出"
    },
    {
      "indent": 3,
      "text": "Including a Date field in requests reveals some information about the Client clock. This might be used to fingerprint Clients [UWT] or to identify Clients that are vulnerable to attacks that depend on incorrect clocks.",
      "ja": "リクエストに日付フィールドを含めると、クライアントクロックに関する情報が明らかになります。これは、クライアント[UWT]を指紋するか、誤ったクロックに依存する攻撃に対して脆弱なクライアントを特定するために使用される場合があります。"
    },
    {
      "indent": 3,
      "text": "Clients can randomize the value that they provide for Date to obscure the true value of their clock and reduce the chance of linking requests over time. However, this increases the risk that their request is rejected as outside the acceptable window.",
      "ja": "クライアントは、時計の真の価値を不明瞭にし、時間の経過とともにリクエストをリンクする機会を減らすために、日付に提供する価値をランダム化できます。ただし、これにより、許容可能なウィンドウの外側としてリクエストが拒否されるリスクが高まります。"
    },
    {
      "indent": 0,
      "text": "6.9. Media Type Security",
      "section_title": true,
      "ja": "6.9. メディアタイプのセキュリティ"
    },
    {
      "indent": 3,
      "text": "The key configuration media type defined in Section 3.2 represents keying material. The content of this media type is not active (see Section 4.6 of [RFC6838]), but it governs how a Client might interact with an Oblivious Gateway Resource. The security implications of processing it are described in Section 6.1; privacy implications are described in Section 7.",
      "ja": "セクション3.2で定義されているキー構成メディアタイプは、キーイング素材を表しています。このメディアタイプの内容はアクティブではありません（[RFC6838]のセクション4.6を参照）が、クライアントが忘れられないゲートウェイリソースと対話する方法を管理します。処理のセキュリティへの影響は、セクション6.1で説明されています。プライバシーへの影響は、セクション7で説明されています。"
    },
    {
      "indent": 3,
      "text": "The security implications of handling the message media types defined in Section 4.5 is covered in other parts of this section in more detail. However, these message media types are also encrypted encapsulations of HTTP requests and responses.",
      "ja": "セクション4.5で定義されているメッセージメディアタイプを処理することのセキュリティへの影響については、このセクションの他の部分で詳細に説明します。ただし、これらのメッセージメディアタイプは、HTTPリクエストと応答の暗号化されたカプセルでもあります。"
    },
    {
      "indent": 3,
      "text": "HTTP messages contain content, which can use any media type. In particular, requests are processed by an Oblivious Target Resource, which -- as an HTTP resource -- defines how content is processed; see Section 3.1 of [HTTP]. HTTP clients can also use resource identity and response content to determine how content is processed. Consequently, the security considerations of Section 17 of [HTTP] also apply to the handling of the content of these media types.",
      "ja": "HTTPメッセージには、任意のメディアタイプを使用できるコンテンツが含まれています。特に、リクエストは、HTTPリソースとして、コンテンツの処理方法を定義する忘却のターゲットリソースによって処理されます。[http]のセクション3.1を参照してください。HTTPクライアントは、リソースIDと応答コンテンツを使用して、コンテンツの処理方法を決定することもできます。その結果、[HTTP]のセクション17のセキュリティ上の考慮事項は、これらのメディアタイプのコンテンツの処理にも適用されます。"
    },
    {
      "indent": 0,
      "text": "6.10. Separate Gateway and Target",
      "section_title": true,
      "ja": "6.10. 個別のゲートウェイとターゲット"
    },
    {
      "indent": 3,
      "text": "This document generally assumes that the same entity operates the Oblivious Gateway Resource and the Target Resource. However, as the Oblivious Gateway Resource performs generic HTTP processing, the use of forwarding cannot be completely precluded.",
      "ja": "このドキュメントは、一般に、同じエンティティが忘却のゲートウェイリソースとターゲットリソースを運用することを前提としています。ただし、忘れられないゲートウェイリソースが汎用HTTP処理を実行するため、転送の使用を完全に排除することはできません。"
    },
    {
      "indent": 3,
      "text": "The scheme specified in the Encapsulated Request determines the security requirements for any protocol that is used between the Oblivious Gateway and Target Resources. Using HTTPS is RECOMMENDED; see Section 6.3.",
      "ja": "カプセル化された要求で指定されたスキームは、忘却のゲートウェイとターゲットリソースの間で使用されるプロトコルのセキュリティ要件を決定します。HTTPSを使用することをお勧めします。セクション6.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "A Target Resource that is operated on a different server from the Oblivious Gateway Resource is an ordinary HTTP resource. A Target Resource can privilege requests that are forwarded by a given Oblivious Gateway Resource if it trusts the operator of the Oblivious Gateway Resource to only forward requests that meet the expectations of the Target Resource. Otherwise, the Target Resource treats requests from an Oblivious Gateway Resource no differently than any other HTTP client.",
      "ja": "忘れられないゲートウェイリソースとは異なるサーバーで動作するターゲットリソースは、通常のHTTPリソースです。ターゲットリソースは、ターゲットリソースの期待を満たすリクエストのみを忘れているゲートウェイリソースのオペレーターに信頼する場合、特定の忘却のゲートウェイリソースによって転送されるリクエストを特権化できます。それ以外の場合、ターゲットリソースは、他のどのHTTPクライアントとは違うゲートウェイリソースからのリクエストを除外します。"
    },
    {
      "indent": 3,
      "text": "For instance, an Oblivious Gateway Resource might -- possibly with the help of Oblivious Relay Resources -- be trusted not to forward an excessive volume of requests. This might allow the Target Resource to accept a greater volume of requests from that Oblivious Gateway Resource relative to other HTTP clients.",
      "ja": "たとえば、気づかないゲートウェイリソースは、おそらく忘れられないリレーリソースの助けを借りて、過剰な量のリクエストを転送しないと信頼される可能性があります。これにより、ターゲットリソースは、他のHTTPクライアントと比較して、その忘れられないゲートウェイリソースからのより多くのリクエストを受け入れることができます。"
    },
    {
      "indent": 3,
      "text": "An Oblivious Gateway Resource could implement policies that improve the ability of the Target Resource to implement policy exemptions, such as only forwarding requests toward specific Target Resources according to an allowlist; see Section 6.3.",
      "ja": "忘れられないゲートウェイリソースは、ターゲットリソースの能力を向上させるポリシーを実装できます。これには、Allowlistに従って特定のターゲットリソースにリクエストのみを転送するなど、ポリシーの免除を実装できます。セクション6.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "7. Privacy Considerations",
      "section_title": true,
      "ja": "7. プライバシーに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "One goal of this design is that independent Client requests are only linkable by their content. However, the choice of Client configuration might be used to correlate requests. A Client configuration includes the Oblivious Relay Resource URI, the Oblivious Gateway key configuration, and the Oblivious Gateway Resource URI. A configuration is active if Clients can successfully use it for interacting with a target.",
      "ja": "このデザインの目標の1つは、独立したクライアントリクエストがコンテンツによってのみリンクできることです。ただし、クライアント構成の選択は、リクエストを相関させるために使用される場合があります。クライアント構成には、忘却のリレーリソースURI、忘却のゲートウェイキー構成、および忘却のゲートウェイリソースURIが含まれます。クライアントがターゲットとの対話に正常に使用できる場合、構成はアクティブです。"
    },
    {
      "indent": 3,
      "text": "Oblivious Relay and Gateway Resources can identify when requests use the same configuration by matching the key identifier from the key configuration or the Oblivious Gateway Resource URI. The Oblivious Gateway Resource might use the source address of requests to correlate requests that use an Oblivious Relay Resource run by the same operator. If the Oblivious Gateway Resource is willing to use trial decryption, requests can be further separated into smaller groupings based on active configurations that clients use.",
      "ja": "忘却のリレーとゲートウェイリソースは、キー構成または忘却のゲートウェイリソースURIのキー識別子を一致させることにより、要求が同じ構成を使用する場合を識別できます。忘れられないゲートウェイリソースは、リクエストのソースアドレスを使用して、同じオペレーターが実行する忘れられないリレーリソースを使用するリクエストを相関させる場合があります。忘れられないゲートウェイリソースが試行復号化を使用する意思がある場合、クライアントが使用するアクティブな構成に基づいて、リクエストをより小さなグループにさらに分離できます。"
    },
    {
      "indent": 3,
      "text": "Each active Client configuration partitions the Client anonymity set. In practice, it is infeasible to reduce the number of active configurations to one. Enabling diversity in choice of Oblivious Relay Resource naturally increases the number of active configurations. More than one configuration might need to be active to allow for key rotation and server maintenance.",
      "ja": "各アクティブなクライアント構成は、クライアントの匿名セットをパーティション化します。実際には、アクティブな構成の数を1つに減らすことは不可能です。忘れられないリレーリソースを選択する多様性を有効にすると、アクティブな構成の数が自然に増加します。キーローテーションとサーバーのメンテナンスを可能にするために、複数の構成がアクティブである必要がある場合があります。"
    },
    {
      "indent": 3,
      "text": "Client privacy depends on having each configuration used by many other Clients. It is critical to prevent the use of unique Client configurations, which might be used to track individual Clients, but it is also important to avoid creating small groupings of Clients that might weaken privacy protections.",
      "ja": "クライアントのプライバシーは、他の多くのクライアントが各構成を使用することに依存します。個々のクライアントを追跡するために使用される可能性のある一意のクライアント構成の使用を防ぐことが重要ですが、プライバシー保護を弱める可能性のあるクライアントの小さなグループの作成を避けることも重要です。"
    },
    {
      "indent": 3,
      "text": "A specific method for a Client to acquire configurations is not included in this specification. Applications using this design MUST provide accommodations to mitigate tracking using Client configurations. [CONSISTENCY] provides options for ensuring that Client configurations are consistent between Clients.",
      "ja": "クライアントが構成を取得するための特定の方法は、この仕様には含まれていません。この設計を使用するアプリケーションは、クライアント構成を使用して追跡を緩和するための宿泊施設を提供する必要があります。[一貫性]は、クライアント間でクライアントの構成が一貫していることを保証するためのオプションを提供します。"
    },
    {
      "indent": 3,
      "text": "The content of requests or responses, if used in forming new requests, can be used to correlate requests. This includes obvious methods of linking requests, like cookies [COOKIES], but it also includes any information in either message that might affect how subsequent requests are formulated. For example, [FIELDING] describes how interactions that are individually stateless can be used to build a stateful system when a Client acts on the content of a response.",
      "ja": "リクエストまたは応答の内容は、新しいリクエストの形成に使用される場合、リクエストを相関させるために使用できます。これには、Cookie [Cookie]などのリクエストをリンクする明白な方法が含まれますが、以降のリクエストの策定方法に影響を与える可能性のあるメッセージにも含まれています。たとえば、[フィールド]は、クライアントが応答の内容に基づいて行動するときに、個別にステートレスの相互作用を使用してステートフルシステムを構築する方法を説明します。"
    },
    {
      "indent": 0,
      "text": "8. Operational and Deployment Considerations",
      "section_title": true,
      "ja": "8. 運用および展開の考慮事項"
    },
    {
      "indent": 3,
      "text": "This section discusses various operational and deployment considerations.",
      "ja": "このセクションでは、さまざまな運用および展開の考慮事項について説明します。"
    },
    {
      "indent": 0,
      "text": "8.1. Performance Overhead",
      "section_title": true,
      "ja": "8.1. パフォーマンスオーバーヘッド"
    },
    {
      "indent": 3,
      "text": "Using Oblivious HTTP adds both cryptographic overhead and latency to requests relative to a simple HTTP request-response exchange. Deploying relay services that are on path between Clients and servers avoids adding significant additional delay due to network topology. A study of a similar system [ODOH-PETS] found that deploying proxies close to servers was most effective in minimizing additional latency.",
      "ja": "忘却HTTPを使用すると、単純なHTTPリクエスト応答交換に関連する要求に暗号化オーバーヘッドとレイテンシの両方が追加されます。クライアントとサーバーの間のパス上にあるリレーサービスを展開すると、ネットワークトポロジによる大幅な追加遅延が追加されません。同様のシステム[ODOH-PETS]の調査では、サーバーの近くにプロキシを展開することが追加のレイテンシを最小限に抑えるのに最も効果的であることがわかりました。"
    },
    {
      "indent": 0,
      "text": "8.2. Resource Mappings",
      "section_title": true,
      "ja": "8.2. リソースマッピング"
    },
    {
      "indent": 3,
      "text": "This protocol assumes a fixed, one-to-one mapping between the Oblivious Relay Resource and the Oblivious Gateway Resource. This means that any Encapsulated Request sent to the Oblivious Relay Resource will always be forwarded to the Oblivious Gateway Resource. This constraint was imposed to simplify relay configuration and mitigate against the Oblivious Relay Resource being used as a generic relay for unknown Oblivious Gateway Resources. The relay will only forward for Oblivious Gateway Resources that it has explicitly configured and allowed.",
      "ja": "このプロトコルは、忘却のリレーリソースと忘却のゲートウェイリソースの間の固定された1対1のマッピングを想定しています。これは、忘れられないリレーリソースに送信されたカプセル化された要求が常に忘却のゲートウェイリソースに転送されることを意味します。この制約は、リレーの構成を簡素化し、不明な忘却のゲートウェイリソースの一般的なリレーとして使用される忘却のリレーリソースに対して緩和するために課されました。リレーは、明示的に構成および許可されている忘却のゲートウェイリソースに対してのみ転送されます。"
    },
    {
      "indent": 3,
      "text": "It is possible for a server to be configured with multiple Oblivious Relay Resources, each for a different Oblivious Gateway Resource as needed. If the goal is to support a large number of Oblivious Gateway Resources, Clients might be provided with a URI template [TEMPLATE], from which multiple Oblivious Relay Resources could be constructed.",
      "ja": "必要に応じて、それぞれ異なる忘れられないゲートウェイリソース用に、複数の忘れられないリレーリソースでサーバーを構成することができます。目標が多数の忘れられないゲートウェイリソースをサポートすることである場合、クライアントにURIテンプレート[テンプレート]が提供される場合があり、そこから複数の忘れられないリレーリソースを構築できます。"
    },
    {
      "indent": 0,
      "text": "8.3. Network Management",
      "section_title": true,
      "ja": "8.3. ネットワーク管理"
    },
    {
      "indent": 3,
      "text": "Oblivious HTTP might be incompatible with network interception regimes, such as those that rely on configuring Clients with trust anchors and intercepting TLS connections. While TLS might be intercepted successfully, interception middlebox devices might not receive updates that would allow Oblivious HTTP to be correctly identified using the media types defined in Sections 9.2 and 9.3.",
      "ja": "忘却HTTPは、信頼できるアンカーでクライアントの構成やTLS接続を傍受することに依存するものなど、ネットワーク傍受レジームと互換性がない場合があります。TLSは正常に傍受される可能性がありますが、インターセプトミドルボックスデバイスは、セクション9.2および9.3で定義されたメディアタイプを使用して、忘却HTTPを正しく識別できるようにする更新を受信しない場合があります。"
    },
    {
      "indent": 3,
      "text": "Oblivious HTTP has a simple key management design that is not trivially altered to enable interception by intermediaries. Clients that are configured to enable interception might choose to disable Oblivious HTTP in order to ensure that content is accessible to middleboxes.",
      "ja": "忘却のHTTPには、仲介者による傍受を可能にするために簡単に変更されていない単純なキー管理設計があります。インターセプトを有効にするように構成されているクライアントは、コンテンツがミドルボックスにアクセスできるように、忘却HTTPを無効にすることを選択する場合があります。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following media types in the \"Media Types\" registry at <https://iana.org/assignments/media-types>, following the procedures of [RFC6838]: \"application/ohttp-keys\" (Section 9.1), \"message/ohttp-req\" (Section 9.2), and \"message/ohttp-res\" (Section 9.3).",
      "ja": "IANAは、[rfc6838]の手順に従って、<https://iana.org/assignments/media-types>の「メディアタイプ」レジストリに次のメディアタイプを登録しています。、「メッセージ/ohttp-req」（セクション9.2）、および「メッセージ/ohttp-res」（セクション9.3）。"
    },
    {
      "indent": 3,
      "text": "IANA has added the following types to the \"HTTP Problem Types\" registry at <https://iana.org/assignments/http-problem-types>: \"date\" (Section 9.4) and \"ohttp-key\" (Section 9.5).",
      "ja": "IANAは、「HTTP問題タイプ」レジストリに次のタイプを<https://iana.org/assignments/http-problem-types>： \"date\"（section 9.4）および \"ohttp-key\"（セクション9.5）に追加しました。。"
    },
    {
      "indent": 0,
      "text": "9.1. application/ohttp-keys Media Type",
      "section_title": true,
      "ja": "9.1. アプリケーション/OHTTP-Keysメディアタイプ"
    },
    {
      "indent": 3,
      "text": "The \"application/ohttp-keys\" media type identifies a key configuration used by Oblivious HTTP.",
      "ja": "「Application/Ohttp-Keys」メディアタイプは、忘却のHTTPで使用される重要な構成を識別します。"
    },
    {
      "indent": 3,
      "text": "Type name: application Subtype name: ohttp-keys Required parameters: N/A Optional parameters: N/A Encoding considerations: \"binary\" Security considerations: See Section 6.9 Interoperability considerations: N/A Published specification: RFC 9458 Applications that use this media type: This type identifies a key configuration as used by Oblivious HTTP and applications that use Oblivious HTTP. Fragment identifier considerations: N/A Additional information: Magic number(s): N/A Deprecated alias names for this type: N/A File extension(s): N/A Macintosh file type code(s): N/A Person and email address to contact for further information: See Authors' Addresses section Intended usage: COMMON Restrictions on usage: N/A Author: See Authors' Addresses section Change controller: IETF",
      "ja": "タイプ名：アプリケーションサブタイプ名：OHTTP-Keys必要なパラメーター：N/Aオプションパラメーター：N/Aエンコーディング考慮事項：「バイナリ」セキュリティ上の考慮事項：セクション6.9相互運用性の考慮事項を参照：N/A公開された仕様：RFC 9458このメディアを使用するアプリケーションタイプ：このタイプは、忘却のhttpと忘却のhttpを使用するアプリケーションで使用されるキー構成を識別します。フラグメント識別子の考慮事項：n/a追加情報：マジック番号：n/aこのタイプの非推奨エイリアス名：n/aファイル拡張機能：n/a macintoshファイルタイプコード：n/a人詳細については連絡先へのメールアドレス：著者のアドレスセクションを参照してください使用法：使用に関する一般的な制限：n/a著者：著者のアドレスセクション変更コントローラー：ietf"
    },
    {
      "indent": 0,
      "text": "9.2. message/ohttp-req Media Type",
      "section_title": true,
      "ja": "9.2. メッセージ/http-requestメディアタイプ"
    },
    {
      "indent": 3,
      "text": "The \"message/ohttp-req\" identifies an encrypted binary HTTP request. This is a binary format that is defined in Section 4.3.",
      "ja": "「メッセージ/ohttp-req」は、暗号化されたバイナリHTTP要求を識別します。これは、セクション4.3で定義されているバイナリ形式です。"
    },
    {
      "indent": 3,
      "text": "Type name: message Subtype name: ohttp-req Required parameters: N/A Optional parameters: N/A Encoding considerations: \"binary\" Security considerations: See Section 6.9 Interoperability considerations: N/A Published specification: RFC 9458 Applications that use this media type: Oblivious HTTP and applications that use Oblivious HTTP use this media type to identify encapsulated binary HTTP requests. Fragment identifier considerations: N/A Additional information: Magic number(s): N/A Deprecated alias names for this type: N/A File extension(s): N/A Macintosh file type code(s): N/A Person and email address to contact for further information: See Authors' Addresses section Intended usage: COMMON Restrictions on usage: N/A Author: See Authors' Addresses section Change controller: IETF",
      "ja": "タイプ名：メッセージサブタイプ名：OHTTP-REQ必要パラメーター：n/aオプションパラメーター：n/aエンコード考慮事項：「バイナリ」セキュリティ上の考慮事項：セクション6.9相互運用性の考慮事項を参照：N/A公開された仕様：RFC 9458このメディアを使用するアプリケーションタイプ：忘却HTTPと忘却HTTPを使用するアプリケーションこのメディアタイプを使用して、カプセル化されたバイナリHTTP要求を識別します。フラグメント識別子の考慮事項：n/a追加情報：マジック番号：n/aこのタイプの非推奨エイリアス名：n/aファイル拡張機能：n/a macintoshファイルタイプコード：n/a人詳細については連絡先へのメールアドレス：著者のアドレスセクションを参照してください使用法：使用に関する一般的な制限：n/a著者：著者のアドレスセクション変更コントローラー：ietf"
    },
    {
      "indent": 0,
      "text": "9.3. message/ohttp-res Media Type",
      "section_title": true,
      "ja": "9.3. メッセージ/OHTTP-RESメディアタイプ"
    },
    {
      "indent": 3,
      "text": "The \"message/ohttp-res\" identifies an encrypted binary HTTP response. This is a binary format that is defined in Section 4.4.",
      "ja": "「メッセージ/ohttp-res」は、暗号化されたバイナリHTTP応答を識別します。これは、セクション4.4で定義されているバイナリ形式です。"
    },
    {
      "indent": 3,
      "text": "Type name: message Subtype name: ohttp-res Required parameters: N/A Optional parameters: N/A Encoding considerations: \"binary\" Security considerations: See Section 6.9 Interoperability considerations: N/A Published specification: RFC 9458 Applications that use this media type: Oblivious HTTP and applications that use Oblivious HTTP use this media type to identify encapsulated binary HTTP responses. Fragment identifier considerations: N/A Additional information: Magic number(s): N/A Deprecated alias names for this type: N/A File extension(s): N/A Macintosh file type code(s): N/A Person and email address to contact for further information: See Authors' Addresses section Intended usage: COMMON Restrictions on usage: N/A Author: See Authors' Addresses section Change controller: IETF",
      "ja": "タイプ名：メッセージサブタイプ名：OHTTP-RES必須パラメーター：n/aオプションパラメーター：n/aエンコーディング考慮事項：「バイナリ」セキュリティに関する考慮事項：セクション6.9相互運用性の考慮事項を参照：N/A公開された仕様：RFC 9458このメディアを使用するアプリケーションこのメディアを使用するアプリケーションタイプ：忘却HTTPと忘却HTTPを使用するアプリケーションこのメディアタイプを使用して、カプセル化されたバイナリHTTP応答を識別します。フラグメント識別子の考慮事項：n/a追加情報：マジック番号：n/aこのタイプの非推奨エイリアス名：n/aファイル拡張機能：n/a macintoshファイルタイプコード：n/a人詳細については連絡先へのメールアドレス：著者のアドレスセクションを参照してください使用法：使用に関する一般的な制限：n/a著者：著者のアドレスセクション変更コントローラー：ietf"
    },
    {
      "indent": 0,
      "text": "9.4. Registration of \"date\" Problem Type",
      "section_title": true,
      "ja": "9.4. 「日付」の問題タイプの登録"
    },
    {
      "indent": 3,
      "text": "IANA has added a new entry in the \"HTTP Problem Types\" registry established by [PROBLEM].",
      "ja": "IANAは、[問題]によって確立された「HTTP問題タイプ」レジストリに新しいエントリを追加しました。"
    },
    {
      "indent": 3,
      "text": "Type URI:  https://iana.org/assignments/http-problem-types#date\nTitle:  Date Not Acceptable\nRecommended HTTP Status Code:  400\nReference:  Section 6.5.2 of RFC 9458",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.5. Registration of \"ohttp-key\" Problem Type",
      "section_title": true,
      "ja": "9.5. 「Ohttp-Key」問題タイプの登録"
    },
    {
      "indent": 3,
      "text": "IANA has added a new entry in the \"HTTP Problem Types\" registry established by [PROBLEM].",
      "ja": "IANAは、[問題]によって確立された「HTTP問題タイプ」レジストリに新しいエントリを追加しました。"
    },
    {
      "indent": 3,
      "text": "Type URI:  https://iana.org/assignments/http-problem-types#ohttp-key\nTitle:  Oblivious HTTP key configuration not acceptable\nRecommended HTTP Status Code:  400\nReference:  Section 5.3 of RFC 9458",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[ASCII] Cerf, V., \"ASCII format for network interchange\", STD 80, RFC 20, DOI 10.17487/RFC0020, October 1969, <https://www.rfc-editor.org/info/rfc20>.",
      "ja": "[ASCII] Cerf、V。、「ネットワークインターチェンジ用ASCII形式」、STD 80、RFC 20、DOI 10.17487/RFC0020、1969年10月、<https://www.rfc-editor.org/info/rfc20>"
    },
    {
      "indent": 3,
      "text": "[BINARY] Thomson, M. and C. A. Wood, \"Binary Representation of HTTP Messages\", RFC 9292, DOI 10.17487/RFC9292, August 2022, <https://www.rfc-editor.org/info/rfc9292>.",
      "ja": "[バイナリ] Thomson、M。and C. A. Wood、「HTTPメッセージのバイナリ表現」、RFC 9292、DOI 10.17487/RFC9292、2022年8月、<https://www.rfc-editor.org/info/rfc92>。"
    },
    {
      "indent": 3,
      "text": "[HPKE] Barnes, R., Bhargavan, K., Lipp, B., and C. Wood, \"Hybrid Public Key Encryption\", RFC 9180, DOI 10.17487/RFC9180, February 2022, <https://www.rfc-editor.org/info/rfc9180>.",
      "ja": "[Hpke] Barnes、R.、Bhargavan、K.、Lipp、B。、およびC. Wood、「ハイブリッド公開キー暗号化」、RFC 9180、DOI 10.17487/RFC9180、2022年2月、<https：//www.rfc-editor.org/info/rfc9180>。"
    },
    {
      "indent": 3,
      "text": "[HTTP] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \"HTTP Semantics\", STD 97, RFC 9110, DOI 10.17487/RFC9110, June 2022, <https://www.rfc-editor.org/info/rfc9110>.",
      "ja": "[HTTP] Fielding、R.、Ed。、Nottingham、M.、Ed。、およびJ. Reschke、ed。、 \"HTTP Semantics\"、Std 97、RFC 9110、DOI 10.17487/RFC9110、2022年6月、<https：//www.rfc-editor.org/info/rfc9110>。"
    },
    {
      "indent": 3,
      "text": "[HTTP-CACHING] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \"HTTP Caching\", STD 98, RFC 9111, DOI 10.17487/RFC9111, June 2022, <https://www.rfc-editor.org/info/rfc9111>.",
      "ja": "[HTTPキャッシング] Fielding、R.、ed。、ed。、Nottingham、M.、ed。、およびJ. Reschke、ed。、 \"Http Caching\"、Std 98、RFC 9111、doi 10.17487/RFC9111、2022年6月、<https：//www.rfc-editor.org/info/rfc9111>。"
    },
    {
      "indent": 3,
      "text": "[PROBLEM] Nottingham, M., Wilde, E., and S. Dalal, \"Problem Details for HTTP APIs\", RFC 9457, DOI 10.17487/RFC9457, July 2023, <https://www.rfc-editor.org/info/rfc9457>.",
      "ja": "[問題]ノッティンガム、M。、ワイルド、E。、およびS.ダラル、「HTTP APIの問題の詳細」、RFC 9457、DOI 10.17487/RFC9457、2023年7月、<https://www.rfc-editor.org/情報/RFC9457>。"
    },
    {
      "indent": 3,
      "text": "[QUIC] Iyengar, J., Ed. and M. Thomson, Ed., \"QUIC: A UDP-Based Multiplexed and Secure Transport\", RFC 9000, DOI 10.17487/RFC9000, May 2021, <https://www.rfc-editor.org/info/rfc9000>.",
      "ja": "[quic] iyengar、J.、ed。and M. Thomson、ed。、「Quic：UDPベースの多重化された安全な輸送」、RFC 9000、DOI 10.17487/RFC9000、2021年5月、<https://www.rfc-editor.org/info/rfc9000>"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487/RFC2119、1997年3月、<https://www.rfc-editor.org/info/RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC6838] Freed, N., Klensin, J., and T. Hansen, \"Media Type Specifications and Registration Procedures\", BCP 13, RFC 6838, DOI 10.17487/RFC6838, January 2013, <https://www.rfc-editor.org/info/rfc6838>.",
      "ja": "[RFC6838] Freed、N.、Klensin、J。、およびT. Hansen、「メディアタイプの仕様と登録手順」、BCP 13、RFC 6838、DOI 10.17487/RFC6838、2013年1月、<https：//www.rfc-editor.org/info/rfc6838>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字の曖昧さ」、BCP 14、RFC 8174、DOI 10.17487/RFC8174、2017年5月、<https：//www.rfc-editor.org/info/RFC8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8470] Thomson, M., Nottingham, M., and W. Tarreau, \"Using Early Data in HTTP\", RFC 8470, DOI 10.17487/RFC8470, September 2018, <https://www.rfc-editor.org/info/rfc8470>.",
      "ja": "[RFC8470] Thomson、M.、Nottingham、M.、およびW. Tarreau、「HTTPで初期データを使用」、RFC 8470、DOI 10.17487/RFC8470、2018年9月、<https://www.rfc-edtion.org/g/情報/RFC8470>。"
    },
    {
      "indent": 3,
      "text": "[TLS] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.",
      "ja": "[TLS] Rescorla、E。、「輸送層セキュリティ（TLS）プロトコルバージョン1.3」、RFC 8446、DOI 10.17487/RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc846>"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[CLOCKSKEW] Acer, M., Stark, E., Felt, A., Fahl, S., Bhargava, R., Dev, B., Braithwaite, M., Sleevi, R., and P. Tabriz, \"Where the Wild Warnings Are: Root Causes of Chrome HTTPS Certificate Errors\", Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security, DOI 10.1145/3133956.3134007, October 2017, <https://doi.org/10.1145/3133956.3134007>.",
      "ja": "[Clockskew] Acer、M.、Stark、E.、Felt、A.、Fahl、S.、Bhargava、R.、Dev、B.、Braithwaite、M.、Sleevi、R.、およびP. Tabriz、 \"Where野生の警告は、Chrome HTTPS証明書エラーの根本原因」、コンピューターおよび通信セキュリティに関する2017 ACM SIGSAC会議の議事録、DOI 10.1145/3133956.3134007、2017年10月、<https://doi.org/10.1145/313333956.3134007>"
    },
    {
      "indent": 3,
      "text": "[CONSISTENCY] Davidson, A., Finkel, M., Thomson, M., and C. A. Wood, \"Key Consistency and Discovery\", Work in Progress, Internet-Draft, draft-ietf-privacypass-key-consistency-01, 10 July 2023, <https://datatracker.ietf.org/doc/html/ draft-ietf-privacypass-key-consistency-01>.",
      "ja": "[一貫性] Davidson、A.、Finkel、M.、Thomson、M.、およびC. A. Wood、「キーの一貫性と発見」、作業中の作業、インターネットドラフト、Draft-Itetf-Privacypass-Key-Consistency-01、102023年7月、<https://datatracker.ietf.org/doc/html/ draft-ietf-privacypass-key-consistency-01>。"
    },
    {
      "indent": 3,
      "text": "[COOKIES] Barth, A., \"HTTP State Management Mechanism\", RFC 6265, DOI 10.17487/RFC6265, April 2011, <https://www.rfc-editor.org/info/rfc6265>.",
      "ja": "[Cookies] Barth、A。、「HTTP状態管理メカニズム」、RFC 6265、DOI 10.17487/RFC6265、2011年4月、<https://www.rfc-editor.org/info/rfc6265>。"
    },
    {
      "indent": 3,
      "text": "[DMS2004] Dingledine, R., Mathewson, N., and P. Syverson, \"Tor: The Second-Generation Onion Router\", May 2004, <https://svn.torproject.org/svn/projects/design-paper/tor-design.html>.",
      "ja": "[DMS2004] Dingledine、R.、Mathewson、N。、およびP. Syverson、「Tor：The The The The The The The The Onion Router」、2004年5月、<https://svn.torproject.org/svn/projects/design-paper/tor-design.html>。"
    },
    {
      "indent": 3,
      "text": "[FIELDING] Fielding, R. T., \"Architectural Styles and the Design of Network-based Software Architectures\", January 2000, <https://www.ics.uci.edu/~fielding/pubs/dissertation/ fielding_dissertation.pdf>.",
      "ja": "[フィールディング]フィールディング、R。T。、「アーキテクチャスタイルとネットワークベースのソフトウェアアーキテクチャの設計」、2000年1月、<https://www.ics.edu/~fielding/pubs/dissertation/ fielding_dissertation.pdf>。"
    },
    {
      "indent": 3,
      "text": "[FORWARDED] Petersson, A. and M. Nilsson, \"Forwarded HTTP Extension\", RFC 7239, DOI 10.17487/RFC7239, June 2014, <https://www.rfc-editor.org/info/rfc7239>.",
      "ja": "[転送]ピーターソン、A。およびM.ニルソン、「転送されたHTTP拡張」、RFC 7239、DOI 10.17487/RFC7239、2014年6月、<https://www.rfc-editor.org/info/rfc7239>。"
    },
    {
      "indent": 3,
      "text": "[HTTP/1.1] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \"HTTP/1.1\", STD 99, RFC 9112, DOI 10.17487/RFC9112, June 2022, <https://www.rfc-editor.org/info/rfc9112>.",
      "ja": "[HTTP/1.1] Fielding、R.、Ed。、Nottingham、M.、ed。、およびJ. Reschke、ed。、 \"Http/1.1\"、Std 99、RFC 9112、DOI 10.17487/RFC9112、2022年6月、<<https://www.rfc-editor.org/info/rfc9112>。"
    },
    {
      "indent": 3,
      "text": "[HTTP/2] Thomson, M., Ed. and C. Benfield, Ed., \"HTTP/2\", RFC 9113, DOI 10.17487/RFC9113, June 2022, <https://www.rfc-editor.org/info/rfc9113>.",
      "ja": "[HTTP/2] Thomson、M.、ed。and C. Benfield、ed。、「HTTP/2」、RFC 9113、DOI 10.17487/RFC9113、2022年6月、<https://www.rfc-editor.org/info/rfc9113>。"
    },
    {
      "indent": 3,
      "text": "[HTTP/3] Bishop, M., Ed., \"HTTP/3\", RFC 9114, DOI 10.17487/RFC9114, June 2022, <https://www.rfc-editor.org/info/rfc9114>.",
      "ja": "[HTTP/3] Bishop、M.、ed。、 \"HTTP/3\"、RFC 9114、DOI 10.17487/RFC9114、2022年6月、<https://www.rfc-editor.org/info/rfc9114>。"
    },
    {
      "indent": 3,
      "text": "[NTP] Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch, \"Network Time Protocol Version 4: Protocol and Algorithms Specification\", RFC 5905, DOI 10.17487/RFC5905, June 2010, <https://www.rfc-editor.org/info/rfc5905>.",
      "ja": "[NTP] Mills、D.、Martin、J.、Ed。、Burbank、J.、およびW. Kasch、「ネットワークタイムプロトコルバージョン4：プロトコルとアルゴリズムの仕様」、RFC 5905、DOI 10.17487/RFC5905、2010年6月、<https://www.rfc-editor.org/info/rfc5905>。"
    },
    {
      "indent": 3,
      "text": "[ODOH] Kinnear, E., McManus, P., Pauly, T., Verma, T., and C.A. Wood, \"Oblivious DNS over HTTPS\", RFC 9230, DOI 10.17487/RFC9230, June 2022, <https://www.rfc-editor.org/info/rfc9230>.",
      "ja": "[Odoh] Kinnear、E.、McManus、P.、Pauly、T.、Verma、T.、およびC.A.Wood、「HTTPS上の忘却DNS」、RFC 9230、DOI 10.17487/RFC9230、2022年6月、<https://www.rfc-editor.org/info/rfc9230>。"
    },
    {
      "indent": 3,
      "text": "[ODOH-PETS] Singanamalla, S., Chunhapanya, S., Hoyland, J., Vavrua, M., Verma, T., Wu, P., Fayed, M., Heimerl, K., Sullivan, N., and C. A. Wood, \"Oblivious DNS over HTTPS (ODoH): A Practical Privacy Enhancement to DNS\", PoPETS Proceedings Volume 2021, Issue 4, pp. 575-592, DOI 10.2478/popets-2021-0085, January 2021, <https://www.petsymposium.org/2021/files/papers/issue4/ popets-2021-0085.pdf>.",
      "ja": "[Odoh-Pets] Singanamalla、S.、Chunhapanya、S.、Hoyland、J.、Vavrua、M.、Verma、T.、Wu、P.、Fayed、M.、Heimerl、K.、Sullivan、N。、およびC. A. Wood、「HTTPS（ODOH）上の忘却DNS：DNSへの実用的なプライバシー強化」、Popets Proceedings Volume 2021、Issue 4、pp。575-592、DOI 10.2478/Popets-2021-0085、1月2021年、<HTTPS：//www.petsymposium.org/2021/files/papers/issue4/ popets-2021-0085.pdf>。"
    },
    {
      "indent": 3,
      "text": "[OHTTP-ANALYSIS] Hoyland, J., \"Tamarin Model of Oblivious HTTP\", commit 6824eee, October 2022, <https://github.com/cloudflare/ohttp-analysis>.",
      "ja": "[Ohttp-analysis] Hoyland、J。、「Oblivious Httpのタマリンモデル」、commit 6824eee、2022年10月、<https://github.com/cloudflare/ohttp-analysis>。"
    },
    {
      "indent": 3,
      "text": "[PRIO] Corrigan-Gibbs, H. and D. Boneh, \"Prio: Private, Robust, and Scalable Computation of Aggregate Statistics\", March 2017, <https://crypto.stanford.edu/prio/paper.pdf>.",
      "ja": "[Prio] Corrigan-Gibbs、H。and D. Boneh、「Prio：Private、Robust、およびScalable scalable scalable Computation of Grogregate Statistics」、2017年3月、<https://crypto.stanford.edu/pher/paper.pdf>。"
    },
    {
      "indent": 3,
      "text": "[RANDOM] Eastlake 3rd, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, <https://www.rfc-editor.org/info/rfc4086>.",
      "ja": "[ランダム]イーストレイク3rd、D.、シラー、J。、およびS.クロッカー、「セキュリティのランダム性要件」、BCP 106、RFC 4086、DOI 10.17487/RFC4086、2005年6月、<https：//www.rfc-editor.org/info/rfc4086>。"
    },
    {
      "indent": 3,
      "text": "[RFC7838] Nottingham, M., McManus, P., and J. Reschke, \"HTTP Alternative Services\", RFC 7838, DOI 10.17487/RFC7838, April 2016, <https://www.rfc-editor.org/info/rfc7838>.",
      "ja": "[RFC7838]ノッティンガム、M.、McManus、P。、およびJ. Reschke、「HTTP代替サービス」、RFC 7838、DOI 10.17487/RFC7838、2016年4月、<https://www.rfc-editor.org/info/RFC7838>。"
    },
    {
      "indent": 3,
      "text": "[RFC8484] Hoffman, P. and P. McManus, \"DNS Queries over HTTPS (DoH)\", RFC 8484, DOI 10.17487/RFC8484, October 2018, <https://www.rfc-editor.org/info/rfc8484>.",
      "ja": "[RFC8484] Hoffman、P。and P. McManus、「DNS Queries over HTTPS（DOH）（DOH）（DOH）（DOH）（DOH））、RFC 8484、DOI 10.17487/RFC8484、2018年10月、<https://www.rfc-editor.org/info/rfc8484>。"
    },
    {
      "indent": 3,
      "text": "[TEMPLATE] Gregorio, J., Fielding, R., Hadley, M., Nottingham, M., and D. Orchard, \"URI Template\", RFC 6570, DOI 10.17487/RFC6570, March 2012, <https://www.rfc-editor.org/info/rfc6570>.",
      "ja": "[テンプレート]グレゴリオ、J。、フィールディング、R。、ハドリー、M。、ノッティンガム、M。、およびD.オーチャード、「URIテンプレート」、RFC 6570、DOI 10.17487/RFC6570、2012年3月、<https：// wwww.rfc-editor.org/info/rfc6570>。"
    },
    {
      "indent": 3,
      "text": "[UWT] Nottingham, M., \"Unsanctioned Web Tracking\", W3C TAG Finding, July 2015, <https://www.w3.org/2001/tag/doc/unsanctioned-tracking/>.",
      "ja": "[UWT]ノッティンガム、M。、「認可されていないWebトラッキング」、W3Cタグ発見、2015年7月、<https://www.w3.org/2001/tag/doc/unsanctioned-tracking/>。"
    },
    {
      "indent": 3,
      "text": "[X25519] Langley, A., Hamburg, M., and S. Turner, \"Elliptic Curves for Security\", RFC 7748, DOI 10.17487/RFC7748, January 2016, <https://www.rfc-editor.org/info/rfc7748>.",
      "ja": "[X25519] Langley、A.、Hamburg、M.、およびS. Turner、「セキュリティのための楕円曲線」、RFC 7748、DOI 10.17487/RFC7748、2016年1月、<https://www.rfc-editor.org/info/RFC7748>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Complete Example of a Request and Response",
      "section_title": true,
      "ja": "付録A. リクエストと応答の完全な例"
    },
    {
      "indent": 3,
      "text": "A single request and response exchange is shown here. Binary values (key configuration, secret keys, the content of messages, and intermediate values) are shown in hexadecimal. The request and response here are minimal; the purpose of this example is to show the cryptographic operations. In this example, the Client is configured with the Oblivious Relay Resource URI of https://proxy.example.org/request.example.net/proxy, and the proxy is configured to map requests to this URI to the Oblivious Gateway Resource URI https://example.com/oblivious/request. The Target Resource URI, i.e., the resource the Client ultimately wishes to query, is https://example.com.",
      "ja": "ここには、単一のリクエストと応答の交換が表示されます。バイナリ値（キー構成、シークレットキー、メッセージの内容、および中間値）が16進数で表示されます。ここでのリクエストと応答は最小限です。この例の目的は、暗号化操作を示すことです。この例では、クライアントはhttps://proxy.example.org/request.example.net/proxyの忘れられないリレーリソースURIで構成されており、プロキシはこのURIへのリクエストを忘れられないゲートウェイリソースURIにマッピングするように構成されています。https://example.com/oblivious/request。ターゲットリソースURI、つまり、クライアントが最終的に照会したいリソースは、https：//example.comです。"
    },
    {
      "indent": 3,
      "text": "To begin the process, the Oblivious Gateway Resource generates a key pair. In this example, the server chooses DHKEM(X25519, HKDF-SHA256) and generates an X25519 key pair [X25519]. The X25519 secret key is:",
      "ja": "プロセスを開始するために、忘却のゲートウェイリソースがキーペアを生成します。この例では、サーバーはDHKEM（X25519、HKDF-SHA256）を選択し、X25519キーペア[X25519]を生成します。X25519シークレットキーは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "3c168975674b2fa8e465970b79c8dcf09f1c741626480bd4c6162fc5b6a98e1a",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Oblivious Gateway Resource constructs a key configuration that includes the corresponding public key as follows:",
      "ja": "Oblivious Gatewayリソースは、次のように対応する公開キーを含むキー構成を構築します。"
    },
    {
      "indent": 3,
      "text": "01002031e1f05a740102115220e9af918f738674aec95f54db6e04eb705aae8e 79815500080001000100010003",
      "ja": "01002031E1F05A740102115220E9AF918F738674AEC95F54DB6E04EB705AAE8E79815500080001000100010003"
    },
    {
      "indent": 3,
      "text": "This key configuration is somehow obtained by the Client. Then, when a Client wishes to send an HTTP GET request to the target https://example.com, it constructs the following binary HTTP message:",
      "ja": "このキー構成は、クライアントによって何らかの形で取得されます。次に、クライアントがターゲットhttps://example.comにhttp get requestを送信したい場合、次のバイナリhttpメッセージを作成します。"
    },
    {
      "indent": 3,
      "text": "00034745540568747470730b6578616d706c652e636f6d012f",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Client then reads the Oblivious Gateway Resource key configuration and selects a mutually supported KDF and AEAD. In this example, the Client selects HKDF-SHA256 and AES-128-GCM. The Client then generates an HPKE sending context that uses the server public key. This context is constructed from the following ephemeral secret key:",
      "ja": "次に、クライアントは、忘れられないゲートウェイリソースキー構成を読み取り、相互にサポートされているKDFとAEADを選択します。この例では、クライアントはHKDF-SHA256とAES-128-GCMを選択します。次に、クライアントは、サーバーの公開キーを使用するHPKE送信コンテキストを生成します。このコンテキストは、次の一時的な秘密の鍵から構築されています。"
    },
    {
      "indent": 3,
      "text": "bc51d5e930bda26589890ac7032f70ad12e4ecb37abb1b65b1256c9c48999c73",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The corresponding public key is:",
      "ja": "対応する公開キーは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "4b28f881333e7c164ffc499ad9796f877f4e1051ee6d31bad19dec96c208b472",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The context is created with an info parameter of:",
      "ja": "コンテキストは、次の情報パラメーターで作成されます。"
    },
    {
      "indent": 3,
      "text": "6d6573736167652f626874747020726571756573740001002000010001",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Applying the Seal operation from the HPKE context produces an encrypted message, allowing the Client to construct the following Encapsulated Request:",
      "ja": "HPKEコンテキストからシール操作を適用すると、暗号化されたメッセージが生成され、クライアントが次のカプセル化されたリクエストを作成できます。"
    },
    {
      "indent": 3,
      "text": "010020000100014b28f881333e7c164ffc499ad9796f877f4e1051ee6d31bad1\n9dec96c208b4726374e469135906992e1268c594d2a10c695d858c40a026e796\n5e7d86b83dd440b2c0185204b4d63525",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Client then sends this to the Oblivious Relay Resource in a POST request, which might look like the following HTTP/1.1 request:",
      "ja": "次に、クライアントはこれをPOSTリクエストで忘却のリレーリソースに送信します。これは、次のHTTP/1.1リクエストのように見える場合があります。"
    },
    {
      "indent": 3,
      "text": "POST /request.example.net/proxy HTTP/1.1 Host: proxy.example.org Content-Type: message/ohttp-req Content-Length: 78",
      "ja": "post/request.example.net/proxy http/1.1 host：proxy.example.org content-type：message/ohttp-req content-length：78"
    },
    {
      "indent": 3,
      "text": "<content is the Encapsulated Request above>",
      "ja": "<コンテンツは、上記のカプセル化されたリクエストです>"
    },
    {
      "indent": 3,
      "text": "The Oblivious Relay Resource receives this request and forwards it to the Oblivious Gateway Resource, which might look like:",
      "ja": "気まぐれなリレーリソースはこのリクエストを受け取り、次のように見えるかもしれません。"
    },
    {
      "indent": 3,
      "text": "POST /oblivious/request HTTP/1.1 Host: example.com Content-Type: message/ohttp-req Content-Length: 78",
      "ja": "投稿/忘却/リクエストhttp/1.1ホスト：example.com content-type：message/ohttp-req content-length：78"
    },
    {
      "indent": 3,
      "text": "<content is the Encapsulated Request above>",
      "ja": "<コンテンツは、上記のカプセル化されたリクエストです>"
    },
    {
      "indent": 3,
      "text": "The Oblivious Gateway Resource receives this request, selects the key it generated previously using the key identifier from the message, and decrypts the message. As this request is directed to the same server, the Oblivious Gateway Resource does not need to initiate an HTTP request to the Target Resource. The request can be served directly by the Target Resource, which generates a minimal response (consisting of just a 200 status code) as follows:",
      "ja": "Oblivious Gatewayリソースは、このリクエストを受信し、メッセージからキー識別子を使用して以前に生成したキーを選択し、メッセージを復号化します。このリクエストは同じサーバーに向けられているため、ターゲットリソースへのHTTP要求を開始する必要はありません。リクエストは、次のように、最小限の応答（200ステータスコードで構成される）を生成するターゲットリソースによって直接送信できます。"
    },
    {
      "indent": 3,
      "text": "0140c8",
      "ja": "0140C8"
    },
    {
      "indent": 3,
      "text": "The response is constructed by exporting a secret from the HPKE context:",
      "ja": "応答は、HPKEコンテキストから秘密をエクスポートすることによって構築されます。"
    },
    {
      "indent": 3,
      "text": "62d87a6ba569ee81014c2641f52bea36",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The key derivation for the Encapsulated Response uses both the encapsulated KEM key from the request and a randomly selected nonce. This produces a salt of:",
      "ja": "カプセル化された応答のキー派生は、リクエストからカプセル化されたKEMキーとランダムに選択されたNonCEの両方を使用します。これは次の塩を生成します："
    },
    {
      "indent": 3,
      "text": "4b28f881333e7c164ffc499ad9796f877f4e1051ee6d31bad19dec96c208b472\nc789e7151fcba46158ca84b04464910d",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The salt and secret are both passed to the Extract function of the selected KDF (HKDF-SHA256) to produce a pseudorandom key of:",
      "ja": "塩と秘密は両方とも選択したKDF（HKDF-SHA256）の抽出関数に渡され、次の擬似ランダムの鍵を生成します。"
    },
    {
      "indent": 3,
      "text": "979aaeae066cf211ab407b31ae49767f344e1501e475c84e8aff547cc5a683db",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The pseudorandom key is used with the Expand function of the KDF and an info field of \"key\" to produce a 16-byte key for the selected AEAD (AES-128-GCM):",
      "ja": "擬似ランダムキーは、KDFの拡張関数と「キー」の情報フィールドとともに使用され、選択したAEAD（AES-128-GCM）の16バイトキーを生成します。"
    },
    {
      "indent": 3,
      "text": "5d0172a080e428b16d298c4ea0db620d",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "With the same KDF and pseudorandom key, an info field of \"nonce\" is used to generate a 12-byte nonce:",
      "ja": "同じKDFと擬似ランダムキーを使用すると、「NonCe」の情報フィールドを使用して、12バイトのnonceを生成します。"
    },
    {
      "indent": 3,
      "text": "f6bf1aeb88d6df87007fa263",
      "ja": "F6BF1AEB88D6DF87007FA263"
    },
    {
      "indent": 3,
      "text": "The AEAD Seal() function is then used to encrypt the response, which is added to the randomized nonce value to produce the Encapsulated Response:",
      "ja": "次に、AEAD SEAL（）関数を使用して応答を暗号化します。これは、ランダム化されたNonCe値に追加され、カプセル化された応答を生成します。"
    },
    {
      "indent": 3,
      "text": "c789e7151fcba46158ca84b04464910d86f9013e404feea014e7be4a441f234f 857fbd",
      "ja": "C789E7151FCBA46158CA84B04444910D86F9013E404FEEA014E7BE4A441F234F 857FBD"
    },
    {
      "indent": 3,
      "text": "The Oblivious Gateway Resource constructs a response with the same content:",
      "ja": "忘れられないゲートウェイリソースは、同じコンテンツで応答を構築します。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 200 OK Date: Wed, 27 Jan 2021 04:45:07 GMT Cache-Control: private, no-store Content-Type: message/ohttp-res Content-Length: 38",
      "ja": "HTTP/1.1 200 OK日付：水曜日、2021年1月27日04:45:07 GMTキャッシュコントロール：プライベート、ストアなしコンテンツタイプ：メッセージ/OHTTP-RESコンテンツレングス：38"
    },
    {
      "indent": 3,
      "text": "<content is the Encapsulated Response>",
      "ja": "<コンテンツはカプセル化された応答>です"
    },
    {
      "indent": 3,
      "text": "The same response might then be generated by the Oblivious Relay Resource, which might change as little as the Date header. The Client is then able to use the HPKE context it created and the nonce from the Encapsulated Response to construct the AEAD key and nonce and decrypt the response.",
      "ja": "その後、同じ応答が、日付ヘッダーほど変更される可能性のある忘れられないリレーリソースによって生成される可能性があります。クライアントは、作成したHPKEコンテキストと、カプセル化された応答からNonCEを使用して、AEADキーとNonCEを構築し、応答を復号化することができます。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This design is based on a design for Oblivious DNS (queries) over HTTPS (DoH), described in [ODOH]. David Benjamin, Mark Nottingham, and Eric Rescorla made technical contributions. The authors also thank Ralph Giles, Lucas Pardue, and Tommy Pauly for invaluable assistance.",
      "ja": "この設計は、[ODOH]に記載されているHTTPS（DOH）を介した忘れられないDNS（クエリ）の設計に基づいています。デビッド・ベンジャミン、マーク・ノッティンガム、エリック・レスコルラは技術的な貢献をしました。著者はまた、Ralph Giles、Lucas Pardue、Tommy Paulyに、貴重な支援をしてくれたことにも感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Martin Thomson Mozilla Email: mt@lowentropy.net",
      "ja": "Martin Thomson Mozillaメール：mt@lowentropy.net"
    },
    {
      "indent": 3,
      "text": "Christopher A. Wood Cloudflare Email: caw@heapingbits.net",
      "ja": "Christopher A. Wood Cloudflareメール：caw@heapingbits.net"
    }
  ]
}