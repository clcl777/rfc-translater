{
  "title": {
    "text": "RFC 9605 - Secure Frame (SFrame): Lightweight Authenticated Encryption for Real‑Time Media",
    "ja": "RFC 9605 - セキュアフレーム（SFRAME）：リアルタイムメディア用の軽量認証暗号化"
  },
  "number": 9605,
  "created_at": "2024-08-29 23:24:27.848555+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                          E. Omara\nRequest for Comments: 9605                                         Apple\nCategory: Standards Track                                      J. Uberti\nISSN: 2070-1721                                                 Fixie.ai\n                                                           S. G. Murillo\n                                                          CoSMo Software\n                                                          R. Barnes, Ed.\n                                                                   Cisco\n                                                               Y. Fablet\n                                                                   Apple\n                                                             August 2024",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Secure Frame (SFrame): Lightweight Authenticated Encryption for Real-Time Media",
      "section_title": true,
      "ja": "セキュアフレーム（SFRAME）：リアルタイムメディア用の軽量認証暗号化"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes the Secure Frame (SFrame) end-to-end encryption and authentication mechanism for media frames in a multiparty conference call, in which central media servers (Selective Forwarding Units or SFUs) can access the media metadata needed to make forwarding decisions without having access to the actual media.",
      "ja": "このドキュメントでは、マルチパーティ間の電話会議でのメディアフレームのセキュアフレーム（SFRAME）エンドツーエンドの暗号化と認証メカニズムについて説明します。このドキュメントでは、セントラルメディアサーバー（選択的転送ユニットまたはSFU）が、転送の決定を下すために必要なメタデータにアクセスできます。実際のメディアにアクセスできます。"
    },
    {
      "indent": 3,
      "text": "This mechanism differs from the Secure Real-Time Protocol (SRTP) in that it is independent of RTP (thus compatible with non-RTP media transport) and can be applied to whole media frames in order to be more bandwidth efficient.",
      "ja": "このメカニズムは、RTP（したがって非RTPメディアトランスポートと互換性がある）に依存しないという点で、安全なリアルタイムプロトコル（SRTP）とは異なり、帯域幅効率を高めるためにメディアフレーム全体に適用できます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準トラックドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 7841のセクション2で入手できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9605.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https://www.rfc-editor.org/info/rfc9605で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2024 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2024 IETF Trustおよび文書著者として特定された人。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、改訂されたBSDライセンスで説明されている保証なしで提供されるように、改訂されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n2.  Terminology\n3.  Goals\n4.  SFrame\n  4.1.  Application Context\n  4.2.  SFrame Ciphertext\n  4.3.  SFrame Header\n  4.4.  Encryption Schema\n    4.4.1.  Key Selection\n    4.4.2.  Key Derivation\n    4.4.3.  Encryption\n    4.4.4.  Decryption\n  4.5.  Cipher Suites\n    4.5.1.  AES-CTR with SHA2\n5.  Key Management\n  5.1.  Sender Keys\n  5.2.  MLS\n6.  Media Considerations\n  6.1.  Selective Forwarding Units\n    6.1.1.  RTP Stream Reuse\n    6.1.2.  Simulcast\n    6.1.3.  Scalable Video Coding (SVC)\n  6.2.  Video Key Frames\n  6.3.  Partial Decoding\n7.  Security Considerations\n  7.1.  No Header Confidentiality\n  7.2.  No Per-Sender Authentication\n  7.3.  Key Management\n  7.4.  Replay\n  7.5.  Risks Due to Short Tags\n8.  IANA Considerations\n  8.1.  SFrame Cipher Suites\n9.  Application Responsibilities\n  9.1.  Header Value Uniqueness\n  9.2.  Key Management Framework\n  9.3.  Anti-Replay\n  9.4.  Metadata\n10. References\n  10.1.  Normative References\n  10.2.  Informative References\nAppendix A.  Example API\nAppendix B.  Overhead Analysis\n  B.1.  Assumptions\n  B.2.  Audio\n  B.3.  Video\n  B.4.  Conferences\n  B.5.  SFrame over RTP\nAppendix C.  Test Vectors\n  C.1.  Header Encoding/Decoding\n  C.2.  AEAD Encryption/Decryption Using AES-CTR and HMAC\n  C.3.  SFrame Encryption/Decryption\nAcknowledgements\nContributors\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Modern multiparty video call systems use Selective Forwarding Unit (SFU) servers to efficiently route media streams to call endpoints based on factors such as available bandwidth, desired video size, codec support, and other factors. An SFU typically does not need access to the media content of the conference, which allows the media to be encrypted \"end to end\" so that it cannot be decrypted by the SFU. In order for the SFU to work properly, though, it usually needs to be able to access RTP metadata and RTCP feedback messages, which is not possible if all RTP/RTCP traffic is end-to-end encrypted.",
      "ja": "最新のマルチパーティビデオコールシステムは、選択的転送ユニット（SFU）サーバーを使用して、利用可能な帯域幅、望ましいビデオサイズ、コーデックサポート、その他の要因などの要因に基づいてエンドポイントを効率的にルーティングします。通常、SFUは会議のメディアコンテンツにアクセスする必要はありません。これにより、メディアを「エンドツーエンド」で暗号化できるため、SFUが解読できません。ただし、SFUが適切に機能するためには、通常、RTPメタデータとRTCPフィードバックメッセージにアクセスできる必要があります。これは、すべてのRTP/RTCPトラフィックがエンドツーエンドの暗号化されている場合は不可能です。"
    },
    {
      "indent": 3,
      "text": "As such, two layers of encryption and authentication are required:",
      "ja": "そのため、暗号化と認証の2層が必要です。"
    },
    {
      "indent": 8,
      "text": "1. Hop-by-hop (HBH) encryption of media, metadata, and feedback messages between the endpoints and SFU",
      "ja": "1. エンドポイントとSFUの間のメディア、メタデータ、およびフィードバックメッセージの暗号化（HBH）"
    },
    {
      "indent": 8,
      "text": "2. End-to-end (E2E) encryption (E2EE) of media between the endpoints",
      "ja": "2. エンドポイント間のメディアのエンドツーエンド（E2E）暗号化（E2E）"
    },
    {
      "indent": 3,
      "text": "The Secure Real-Time Protocol (SRTP) is already widely used for HBH encryption [RFC3711]. The SRTP \"double encryption\" scheme defines a way to do E2E encryption in SRTP [RFC8723]. Unfortunately, this scheme has poor efficiency and high complexity, and its entanglement with RTP makes it unworkable in several realistic SFU scenarios.",
      "ja": "安全なリアルタイムプロトコル（SRTP）は、すでにHBH暗号化に広く使用されています[RFC3711]。SRTP「二重暗号化」スキームは、SRTP [RFC8723]でE2E暗号化を行う方法を定義します。残念ながら、このスキームは効率が悪く、複雑さが高く、RTPとの絡み合いにより、いくつかの現実的なSFUシナリオでは実行できません。"
    },
    {
      "indent": 3,
      "text": "This document proposes a new E2EE protection scheme known as SFrame, specifically designed to work in group conference calls with SFUs. SFrame is a general encryption framing that can be used to protect media payloads, agnostic of transport.",
      "ja": "このドキュメントは、SFUSとのグループ会議通話で機能するように特別に設計されたSFRAMEとして知られる新しいE2EE保護スキームを提案しています。SFRAMEは、輸送の不可知論者であるメディアペイロードを保護するために使用できる一般的な暗号化フレーミングです。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "「必須」、「必要」、「必須」、「shall」、「shall」、「suff」、 \"not\"、 \"becommended\"、 \"becommented\"、 \"may\"、 \"optional「このドキュメントでは、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "MAC:",
      "ja": "MAC:"
    },
    {
      "indent": 12,
      "text": "Message Authentication Code",
      "ja": "メッセージ認証コード"
    },
    {
      "indent": 3,
      "text": "E2EE:",
      "ja": "E2EE："
    },
    {
      "indent": 12,
      "text": "End-to-End Encryption",
      "ja": "エンドツーエンド暗号化"
    },
    {
      "indent": 3,
      "text": "HBH:",
      "ja": "HBH:"
    },
    {
      "indent": 12,
      "text": "Hop-by-Hop",
      "ja": "ホップバイホップ"
    },
    {
      "indent": 3,
      "text": "We use \"Selective Forwarding Unit (SFU)\" and \"media stream\" in a less formal sense than in [RFC7656]. An SFU is a selective switching function for media payloads, and a media stream is a sequence of media payloads, regardless of whether those media payloads are transported over RTP or some other protocol.",
      "ja": "[RFC7656]よりも、「選択的転送ユニット（SFU）」と「メディアストリーム」をそれほど形式的ではない意味で使用します。SFUは、メディアペイロードの選択的スイッチング関数であり、メディアストリームは、これらのメディアペイロードがRTPまたは他のプロトコルを介して輸送されるかどうかにかかわらず、メディアペイロードのシーケンスです。"
    },
    {
      "indent": 0,
      "text": "3. Goals",
      "section_title": true,
      "ja": "3. 目標"
    },
    {
      "indent": 3,
      "text": "SFrame is designed to be a suitable E2EE protection scheme for conference call media in a broad range of scenarios, as outlined by the following goals:",
      "ja": "SFRAMEは、次の目標で概説されているように、幅広いシナリオで電話会議メディアに適したE2EE保護スキームになるように設計されています。"
    },
    {
      "indent": 8,
      "text": "1. Provide a secure E2EE mechanism for audio and video in conference calls that can be used with arbitrary SFU servers.",
      "ja": "1. 任意のSFUサーバーで使用できる電話会議でオーディオとビデオの安全なE2EEメカニズムを提供します。"
    },
    {
      "indent": 8,
      "text": "2. Decouple media encryption from key management to allow SFrame to be used with an arbitrary key management system.",
      "ja": "2. 主要な管理からメディア暗号化を分離して、任意のキー管理システムでSFRAMEを使用できるようにします。"
    },
    {
      "indent": 8,
      "text": "3. Minimize packet expansion to allow successful conferencing in as many network conditions as possible.",
      "ja": "3. パケットの拡張を最小限に抑えて、できるだけ多くのネットワーク条件で会議を成功させることができます。"
    },
    {
      "indent": 8,
      "text": "4. Decouple the media encryption framework from the underlying transport, allowing use in non-RTP scenarios, e.g., WebTransport [WEBTRANSPORT].",
      "ja": "4. メディア暗号化フレームワークを基礎となるトランスポートから切り離し、非RTPシナリオでの使用を可能にします。たとえば、WebTransport [WebTransport]。"
    },
    {
      "indent": 8,
      "text": "5. When used with RTP and its associated error-resilience mechanisms, i.e., RTX and Forward Error Correction (FEC), require no special handling for RTX and FEC packets.",
      "ja": "5. RTPおよびそれに関連するエラー抵抗性メカニズム、つまりRTXおよびフォワードエラー補正（FEC）で使用される場合、RTXおよびFECパケットの特別な取り扱いは必要ありません。"
    },
    {
      "indent": 8,
      "text": "6. Minimize the changes needed in SFU servers.",
      "ja": "6. SFUサーバーで必要な変更を最小限に抑えます。"
    },
    {
      "indent": 8,
      "text": "7. Minimize the changes needed in endpoints.",
      "ja": "7. エンドポイントで必要な変更を最小限に抑えます。"
    },
    {
      "indent": 8,
      "text": "8. Work with the most popular audio and video codecs used in conferencing scenarios.",
      "ja": "8. 会議シナリオで使用される最も人気のあるオーディオおよびビデオコーデックを使用します。"
    },
    {
      "indent": 0,
      "text": "4. SFrame",
      "section_title": true,
      "ja": "4. sframe"
    },
    {
      "indent": 3,
      "text": "This document defines an encryption mechanism that provides effective E2EE, is simple to implement, has no dependencies on RTP, and minimizes encryption bandwidth overhead. This section describes how the mechanism works and includes details of how applications utilize SFrame for media protection as well as the actual mechanics of E2EE for protecting media.",
      "ja": "このドキュメントでは、効果的なE2EEを提供し、実装が簡単で、RTPに依存関係がなく、暗号化の帯域幅の架空を最小限に抑える暗号化メカニズムを定義しています。このセクションでは、メカニズムがどのように機能するかについて説明し、アプリケーションがメディア保護のためにSFRAMEを利用する方法の詳細と、メディアを保護するためのE2EEの実際のメカニズムについて説明します。"
    },
    {
      "indent": 0,
      "text": "4.1. Application Context",
      "section_title": true,
      "ja": "4.1. アプリケーションコンテキスト"
    },
    {
      "indent": 3,
      "text": "SFrame is a general encryption framing, intended to be used as an E2EE layer over an underlying HBH-encrypted transport such as SRTP or QUIC [RFC3711][MOQ-TRANSPORT].",
      "ja": "SFRAMEは一般的な暗号化フレーミングであり、SRTPやQUIC [RFC3711] [MOQ-Transport]などの基礎となるHBH暗号化された輸送の上でE2EE層として使用することを目的としています。"
    },
    {
      "indent": 3,
      "text": "The scale at which SFrame encryption is applied to media determines the overall amount of overhead that SFrame adds to the media stream as well as the engineering complexity involved in integrating SFrame into a particular environment. Two patterns are common: using SFrame to encrypt either whole media frames (per frame) or individual transport-level media payloads (per packet).",
      "ja": "SFRAME暗号化がメディアに適用されるスケールは、SFRAMEがメディアストリームに追加するオーバーヘッドの全体的な量と、SFRAMEを特定の環境に統合することに関与するエンジニアリングの複雑さを決定します。2つのパターンが一般的です。SFRAMEを使用して、メディアフレーム全体（フレームごと）または個々のトランスポートレベルメディアペイロード（パケットごと）のいずれかを暗号化します。"
    },
    {
      "indent": 3,
      "text": "For example, Figure 1 shows a typical media sender stack that takes media from some source, encodes it into frames, divides those frames into media packets, and then sends those payloads in SRTP packets. The receiver stack performs the reverse operations, reassembling frames from SRTP packets and decoding. Arrows indicate two different ways that SFrame protection could be integrated into this media stack: to encrypt whole frames or individual media packets.",
      "ja": "たとえば、図1は、一部のソースからメディアを取得し、フレームにエンコードし、それらのフレームをメディアパケットに分割し、それらのペイロードをSRTPパケットに送信する典型的なメディア送信者スタックを示しています。レシーバースタックは、SRTPパケットからフレームを再構築し、デコードする逆操作を実行します。矢印は、SFRAME保護をこのメディアスタックに統合できる2つの異なる方法を示しています。全体のフレームまたは個々のメディアパケットを暗号化することです。"
    },
    {
      "indent": 3,
      "text": "Applying SFrame per frame in this system offers higher efficiency but may require a more complex integration in environments where depacketization relies on the content of media packets. Applying SFrame per packet avoids this complexity at the cost of higher bandwidth consumption. Some quantitative discussion of these trade-offs is provided in Appendix B.",
      "ja": "このシステムでフレームごとのSFRAMEを適用すると、効率が高くなりますが、デパケットがメディアパケットの内容に依存する環境でより複雑な統合が必要になる場合があります。パケットごとにSFRAMEを適用すると、帯域幅の消費量が高いほどこの複雑さが回避されます。これらのトレードオフに関するいくつかの定量的議論は、付録Bに記載されています。"
    },
    {
      "indent": 3,
      "text": "As noted above, however, SFrame is a general media encapsulation and can be applied in other scenarios. The important thing is that the sender and receivers of an SFrame-encrypted object agree on that object's semantics. SFrame does not provide this agreement; it must be arranged by the application.",
      "ja": "ただし、上記のように、SFRAMEは一般的なメディアのカプセル化であり、他のシナリオに適用できます。重要なことは、SFRAME暗号化されたオブジェクトの送信者と受信機がそのオブジェクトのセマンティクスに同意することです。SFRAMEはこの契約を提供しません。アプリケーションによって配置する必要があります。"
    },
    {
      "indent": 3,
      "text": "      +------------------------------------------------------+\n      |                                                      |\n      |  +--------+      +-------------+      +-----------+  |\n .-.  |  |        |      |             |      |    HBH    |  |\n|   | |  | Encode |----->|  Packetize  |----->|  Protect  |----------+\n '+'  |  |        |   ^  |             |  ^   |           |  |       |\n /|\\  |  +--------+   |  +-------------+  |   +-----------+  |       |\n/ + \\ |               |                   |         ^        |       |\n / \\  |            SFrame              SFrame       |        |       |\n/   \\ |            Protect             Protect      |        |       |\nAlice |          (per frame)         (per packet)   |        |       |\n      |               ^                   ^         |        |       |\n      |               |                   |         |        |       |\n      +---------------|-------------------|---------|--------+       |\n                      |                   |         |                v\n                      |                   |         |         +------+-+\n                      |      E2E Key      |       HBH Key     | Media  |\n                      +---- Management ---+      Management   | Server |\n                      |                   |         |         +------+-+\n                      |                   |         |                |\n      +---------------|-------------------|---------|--------+       |\n      |               |                   |         |        |       |\n      |               V                   V         |        |       |\n .-.  |            SFrame               SFrame      |        |       |\n|   | |           Unprotect            Unprotect    |        |       |\n '+'  |          (per frame)          (per packet)  |        |       |\n /|\\  |               |                    |        V        |       |\n/ + \\ |  +--------+   |  +-------------+   |  +-----------+  |       |\n / \\  |  |        |   V  |             |   V  |    HBH    |  |       |\n/   \\ |  | Decode |<-----| Depacketize |<-----| Unprotect |<---------+\n Bob  |  |        |      |             |      |           |  |\n      |  +--------+      +-------------+      +-----------+  |\n      |                                                      |\n      +------------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 1: Two Options for Integrating SFrame in a Typical Media Stack",
      "ja": "図1：SFRAMEを典型的なメディアスタックに統合するための2つのオプション"
    },
    {
      "indent": 3,
      "text": "Like SRTP, SFrame does not define how the keys used for SFrame are exchanged by the parties in the conference. Keys for SFrame might be distributed over an existing E2E-secure channel (see Section 5.1) or derived from an E2E-secure shared secret (see Section 5.2). The key management system MUST ensure that each key used for encrypting media is used by exactly one media sender in order to avoid reuse of nonces.",
      "ja": "SRTPと同様に、SFRAMEは、SFRAMEに使用されるキーが会議の当事者によってどのように交換されるかを定義していません。SFRAMEのキーは、既存のE2Eセキュアチャネル（セクション5.1を参照）に分布しているか、E2Eセキュアの共有秘密（セクション5.2を参照）から派生している場合があります。主要な管理システムは、暗号化に使用される各キーが、Noncesの再利用を避けるために、1つのメディア送信者が正確に1つのメディア送信者によって使用することを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2. SFrame Ciphertext",
      "section_title": true,
      "ja": "4.2. sFrame ciphertext"
    },
    {
      "indent": 3,
      "text": "An SFrame ciphertext comprises an SFrame header followed by the output of an Authenticated Encryption with Associated Data (AEAD) encryption of the plaintext [RFC5116], with the header provided as additional authenticated data (AAD).",
      "ja": "SFRAME暗号文は、SFRAMEヘッダーに続いて、関連するデータ（AEAD）とプレーンテキスト[RFC5116]を使用した認証された暗号化の出力を含み、ヘッダーは追加の認証データ（AAD）として提供されます。"
    },
    {
      "indent": 3,
      "text": "The SFrame header is a variable-length structure described in detail in Section 4.3. The structure of the encrypted data and authentication tag are determined by the AEAD algorithm in use.",
      "ja": "SFRAMEヘッダーは、セクション4.3で詳細に説明されている可変長構造です。暗号化されたデータと認証タグの構造は、使用中のAEADアルゴリズムによって決定されます。"
    },
    {
      "indent": 3,
      "text": "   +-+----+-+----+--------------------+--------------------+<-+\n   |K|KLEN|C|CLEN|       Key ID       |      Counter       |  |\n+->+-+----+-+----+--------------------+--------------------+  |\n|  |                                                       |  |\n|  |                                                       |  |\n|  |                                                       |  |\n|  |                                                       |  |\n|  |                   Encrypted Data                      |  |\n|  |                                                       |  |\n|  |                                                       |  |\n|  |                                                       |  |\n|  |                                                       |  |\n+->+-------------------------------------------------------+<-+\n|  |                 Authentication Tag                    |  |\n|  +-------------------------------------------------------+  |\n|                                                             |\n|                                                             |\n+--- Encrypted Portion               Authenticated Portion ---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 2: Structure of an SFrame Ciphertext",
      "ja": "図2：SFRAME暗号文の構造"
    },
    {
      "indent": 3,
      "text": "When SFrame is applied per packet, the payload of each packet will be an SFrame ciphertext. When SFrame is applied per frame, the SFrame ciphertext representing an encrypted frame will span several packets, with the header appearing in the first packet and the authentication tag in the last packet. It is the responsibility of the application to reassemble an encrypted frame from individual packets, accounting for packet loss and reordering as necessary.",
      "ja": "パケットごとにSFRAMEが適用されると、各パケットのペイロードはSFRAME暗号文になります。SFRAMEがフレームごとに適用されると、暗号化されたフレームを表すSFRAME暗号文がいくつかのパケットにまたがり、ヘッダーが最初のパケットに表示され、最後のパケットに認証タグが表示されます。個々のパケットから暗号化されたフレームを再組み立てし、必要に応じてパケットの損失と並べ替えを説明することは、アプリケーションの責任です。"
    },
    {
      "indent": 0,
      "text": "4.3. SFrame Header",
      "section_title": true,
      "ja": "4.3. SFRAMEヘッダー"
    },
    {
      "indent": 3,
      "text": "The SFrame header specifies two values from which encryption parameters are derived:",
      "ja": "SFRAMEヘッダーは、暗号化パラメーターが導出される2つの値を指定します。"
    },
    {
      "indent": 6,
      "text": "* A Key ID (KID) that determines which encryption key should be used",
      "ja": "* どの暗号化キーを使用するかを決定するキーID（KID）"
    },
    {
      "indent": 6,
      "text": "* A Counter (CTR) that is used to construct the nonce for the encryption",
      "ja": "* 暗号化のノンセを構築するために使用されるカウンター（CTR）"
    },
    {
      "indent": 3,
      "text": "Applications MUST ensure that each (KID, CTR) combination is used for exactly one SFrame encryption operation. A typical approach to achieve this guarantee is outlined in Section 9.1.",
      "ja": "アプリケーションは、それぞれ（KID、CTR）の組み合わせが正確に1つのSFRAME暗号化操作に使用されるようにする必要があります。この保証を達成するための典型的なアプローチは、セクション9.1で概説されています。"
    },
    {
      "indent": 3,
      "text": "   Config Byte\n        |\n .-----' '-----.\n|               |\n 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+------------+------------+\n|X|  K  |Y|  C  |   KID...   |   CTR...   |\n+-+-+-+-+-+-+-+-+------------+------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 26,
      "text": "Figure 3: SFrame Header",
      "ja": "図3：SFRAMEヘッダー"
    },
    {
      "indent": 3,
      "text": "The SFrame header has the overall structure shown in Figure 3. The first byte is a \"config byte\", with the following fields:",
      "ja": "SFRAMEヘッダーには、図3に示す全体的な構造があります。最初のバイトは、次のフィールドを備えた「構成バイト」です。"
    },
    {
      "indent": 3,
      "text": "Extended KID Flag (X, 1 bit):",
      "ja": "拡張キッドフラグ（x、1ビット）："
    },
    {
      "indent": 12,
      "text": "Indicates if the K field contains the KID or the KID length.",
      "ja": "Kフィールドに子供と子供の長さが含まれているかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "KID or KID Length (K, 3 bits):",
      "ja": "子供または子供の長さ（K、3ビット）："
    },
    {
      "indent": 12,
      "text": "If the X flag is set to 0, this field contains the KID. If the X flag is set to 1, then it contains the length of the KID, minus one.",
      "ja": "Xフラグが0に設定されている場合、このフィールドには子供が含まれています。Xフラグが1に設定されている場合、子供の長さ、マイナス1を含みます。"
    },
    {
      "indent": 3,
      "text": "Extended CTR Flag (Y, 1 bit):",
      "ja": "拡張CTRフラグ（Y、1ビット）："
    },
    {
      "indent": 12,
      "text": "Indicates if the C field contains the CTR or the CTR length.",
      "ja": "CフィールドにCTRまたはCTRの長さが含まれているかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "CTR or CTR Length (C, 3 bits):",
      "ja": "CTRまたはCTRの長さ（C、3ビット）："
    },
    {
      "indent": 12,
      "text": "This field contains the CTR if the Y flag is set to 0, or the CTR length, minus one, if set to 1.",
      "ja": "このフィールドには、yフラグが0に設定されている場合はCTR、またはCTRの長さが1を引いた場合、1に設定されている場合はCTRが含まれます。"
    },
    {
      "indent": 3,
      "text": "The KID and CTR fields are encoded as compact unsigned integers in network (big-endian) byte order. If the value of one of these fields is in the range 0-7, then the value is carried in the corresponding bits of the config byte (K or C) and the corresponding flag (X or Y) is set to zero. Otherwise, the value MUST be encoded with the minimum number of bytes required and appended after the config byte, with the KID first and CTR second. The header field (K or C) is set to the number of bytes in the encoded value, minus one. The value 000 represents a length of 1, 001 a length of 2, etc. This allows a 3-bit length field to represent the value lengths 1-8.",
      "ja": "KIDおよびCTRフィールドは、ネットワーク（ビッグエンディアン）バイトの順序でコンパクトな署名されていない整数としてエンコードされています。これらのフィールドのいずれかの値が0〜7の範囲にある場合、値はconfig byte（kまたはc）の対応するビットに運ばれ、対応するフラグ（xまたはy）がゼロに設定されます。それ以外の場合、値は、必要なバイトの最小バイト数でエンコードされ、構成バイトの後に追加され、KIDは最初に2番目にCTRを使用する必要があります。ヘッダーフィールド（kまたはc）は、エンコードされた値のバイト数（マイナス）に設定されます。値000は、長さ1、001の長さ2などを表します。これにより、3ビットの長さフィールドは値の長さ1〜8を表すことができます。"
    },
    {
      "indent": 3,
      "text": "The SFrame header can thus take one of the four forms shown in Figure 4, depending on which of the X and Y flags are set.",
      "ja": "したがって、SFRAMEヘッダーは、XフラグとYフラグのどれが設定されているかに応じて、図4に示す4つのフォームのいずれかを取得できます。"
    },
    {
      "indent": 3,
      "text": "KID < 8, CTR < 8:\n+-+-----+-+-----+\n|0| KID |0| CTR |\n+-+-----+-+-----+\n\nKID < 8, CTR >= 8:\n+-+-----+-+-----+------------------------+\n|0| KID |1|CLEN |  CTR... (length=CLEN)  |\n+-+-----+-+-----+------------------------+\n\nKID >= 8, CTR < 8:\n+-+-----+-+-----+------------------------+\n|1|KLEN |0| CTR |  KID... (length=KLEN)  |\n+-+-----+-+-----+------------------------+\n\nKID >= 8, CTR >= 8:\n+-+-----+-+-----+------------------------+------------------------+\n|1|KLEN |1|CLEN |  KID... (length=KLEN)  |  CTR... (length=CLEN)  |\n+-+-----+-+-----+------------------------+------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Figure 4: Forms of Encoded SFrame Header",
      "ja": "図4：エンコードされたSFRAMEヘッダーのフォーム"
    },
    {
      "indent": 0,
      "text": "4.4. Encryption Schema",
      "section_title": true,
      "ja": "4.4. 暗号化スキーマ"
    },
    {
      "indent": 3,
      "text": "SFrame encryption uses an AEAD encryption algorithm and hash function defined by the cipher suite in use (see Section 4.5). We will refer to the following aspects of the AEAD and the hash algorithm below:",
      "ja": "SFRAME暗号化は、使用中の暗号スイートによって定義されたAEAD暗号化アルゴリズムとハッシュ関数を使用します（セクション4.5を参照）。以下のAEADおよびハッシュアルゴリズムの次の側面を参照します。"
    },
    {
      "indent": 6,
      "text": "* AEAD.Encrypt and AEAD.Decrypt - The encryption and decryption functions for the AEAD. We follow the convention of RFC 5116 [RFC5116] and consider the authentication tag part of the ciphertext produced by AEAD.Encrypt (as opposed to a separate field as in SRTP [RFC3711]).",
      "ja": "* aead.encrypt and aead.decrypt- AEADの暗号化と復号化機能。RFC 5116 [RFC5116]の規則に従い、Aead.Encryptによって生成されたCiphertextの認証タグ部分を検討します（SRTP [RFC3711]のように別のフィールドとは対照的に）。"
    },
    {
      "indent": 6,
      "text": "* AEAD.Nk - The size in bytes of a key for the encryption algorithm",
      "ja": "* aead.nk-暗号化アルゴリズムのキーのバイト単位のサイズ"
    },
    {
      "indent": 6,
      "text": "* AEAD.Nn - The size in bytes of a nonce for the encryption algorithm",
      "ja": "* aead.nn-暗号化アルゴリズムのノンセのバイト単位のサイズ"
    },
    {
      "indent": 6,
      "text": "* AEAD.Nt - The overhead in bytes of the encryption algorithm (typically the size of a \"tag\" that is added to the plaintext)",
      "ja": "* aead.nt-暗号化アルゴリズムのバイトのオーバーヘッド（通常、プレーンテキストに追加される「タグ」のサイズ）"
    },
    {
      "indent": 6,
      "text": "* AEAD.Nka - For cipher suites using the compound AEAD described in Section 4.5.1, the size in bytes of a key for the underlying encryption algorithm",
      "ja": "* aead.nka-セクション4.5.1で説明する複合AEADを使用した暗号スイートの場合、基礎となる暗号化アルゴリズムのキーのバイトのサイズ"
    },
    {
      "indent": 6,
      "text": "* Hash.Nh - The size in bytes of the output of the hash function",
      "ja": "* HASH.NH-ハッシュ関数の出力のバイト単位のサイズ"
    },
    {
      "indent": 0,
      "text": "4.4.1. Key Selection",
      "section_title": true,
      "ja": "4.4.1. キー選択"
    },
    {
      "indent": 3,
      "text": "Each SFrame encryption or decryption operation is premised on a single secret base_key, which is labeled with an integer KID value signaled in the SFrame header.",
      "ja": "各SFRAME暗号化または復号化操作は、SFRAMEヘッダーに合図された整数KID値でラベル付けされている単一の秘密のBase_Keyで前提とされています。"
    },
    {
      "indent": 3,
      "text": "The sender and receivers need to agree on which base_key should be used for a given KID. Moreover, senders and receivers need to agree on whether a base_key will be used for encryption or decryption only. The process for provisioning base_key values and their KID values is beyond the scope of this specification, but its security properties will bound the assurances that SFrame provides. For example, if SFrame is used to provide E2E security against intermediary media nodes, then SFrame keys need to be negotiated in a way that does not make them accessible to these intermediaries.",
      "ja": "送信者とレシーバーは、特定の子供にどのbase_keyを使用するかに同意する必要があります。さらに、送信者と受信者は、base_keyが暗号化または復号化にのみ使用されるかどうかに同意する必要があります。Base_Key値とその子供の値をプロビジョニングするプロセスは、この仕様の範囲を超えていますが、そのセキュリティプロパティはSFRAMEが提供する保証をバインドします。たとえば、SFRAMEを使用して中間メディアノードに対してE2Eセキュリティを提供する場合、SFRAMEキーは、これらの仲介者がアクセスできない方法で交渉する必要があります。"
    },
    {
      "indent": 3,
      "text": "For each known KID value, the client stores the corresponding symmetric key base_key. For keys that can be used for encryption, the client also stores the next CTR value to be used when encrypting (initially 0).",
      "ja": "既知の各子供の価値について、クライアントは対応する対称キーBase_keyを保存します。暗号化に使用できるキーの場合、クライアントは、暗号化時に使用する次のCTR値も保存します（最初は0）。"
    },
    {
      "indent": 3,
      "text": "When encrypting a plaintext, the application specifies which KID is to be used, and the CTR value is incremented after successful encryption. When decrypting, the base_key for decryption is selected from the available keys using the KID value in the SFrame header.",
      "ja": "プレーンテキストを暗号化するとき、アプリケーションはどの子供を使用するかを指定し、暗号化が成功した後にCTR値が増加します。復号化するとき、SFRAMEヘッダーのKID値を使用して、利用可能なキーからbase_keyが使用可能なキーから選択されます。"
    },
    {
      "indent": 3,
      "text": "A given base_key MUST NOT be used for encryption by multiple senders. Such reuse would result in multiple encrypted frames being generated with the same (key, nonce) pair, which harms the protections provided by many AEAD algorithms. Implementations MUST mark each base_key as usable for encryption or decryption, never both.",
      "ja": "特定のbase_keyは、複数の送信者が暗号化に使用してはなりません。このような再利用は、同じ（key、nonce）ペアで複数の暗号化されたフレームが生成され、多くのAEADアルゴリズムによって提供される保護に害を及ぼすことになります。実装は、各base_keyを暗号化または復号化に使用できるものとしてマークする必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that the set of available keys might change over the lifetime of a real-time session. In such cases, the client will need to manage key usage to avoid media loss due to a key being used to encrypt before all receivers are able to use it to decrypt. For example, an application may make decryption-only keys available immediately, but delay the use of keys for encryption until (a) all receivers have acknowledged receipt of the new key, or (b) a timeout expires.",
      "ja": "利用可能なキーのセットは、リアルタイムセッションの寿命にわたって変化する可能性があることに注意してください。そのような場合、クライアントは、すべての受信機がそれを使用して復号化する前に暗号化に使用されるために、メディアの損失を回避するために重要な使用法を管理する必要があります。たとえば、アプリケーションは復号化のみのキーをすぐに利用できるようにする場合がありますが、（a）すべてのレシーバーが新しいキーの受領を認めているか、（b）タイムアウトの有効期限が切れるまで、暗号化のためのキーの使用を遅らせます。"
    },
    {
      "indent": 0,
      "text": "4.4.2. Key Derivation",
      "section_title": true,
      "ja": "4.4.2. キー派生"
    },
    {
      "indent": 3,
      "text": "SFrame encryption and decryption use a key and salt derived from the base_key associated with a KID. Given a base_key value, the key and salt are derived using HMAC-based Key Derivation Function (HKDF) [RFC5869] as follows:",
      "ja": "SFRAMEの暗号化と復号化は、子供に関連付けられたbase_keyから派生したキーと塩を使用します。base_key値が与えられると、キーと塩は、次のようにHMACベースのキー導入関数（HKDF）[RFC5869]を使用して導出されます。"
    },
    {
      "indent": 3,
      "text": "def derive_key_salt(KID, base_key):\n  sframe_secret = HKDF-Extract(\"\", base_key)\n\n  sframe_key_label = \"SFrame 1.0 Secret key \" + KID + cipher_suite\n  sframe_key =\n    HKDF-Expand(sframe_secret, sframe_key_label, AEAD.Nk)\n\n  sframe_salt_label = \"SFrame 1.0 Secret salt \" + KID + cipher_suite\n  sframe_salt =\n    HKDF-Expand(sframe_secret, sframe_salt_label, AEAD.Nn)\n\n  return sframe_key, sframe_salt",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the derivation of sframe_secret:",
      "ja": "sframe_secretの派生："
    },
    {
      "indent": 6,
      "text": "* The + operator represents concatenation of byte strings.",
      "ja": "* +演算子は、バイト文字列の連結を表します。"
    },
    {
      "indent": 6,
      "text": "* The KID value is encoded as an 8-byte big-endian integer, not the compressed form used in the SFrame header.",
      "ja": "* KID値は、SFRAMEヘッダーで使用されている圧縮フォームではなく、8バイトのビッグエンディアン整数としてエンコードされます。"
    },
    {
      "indent": 6,
      "text": "* The cipher_suite value is a 2-byte big-endian integer representing the cipher suite in use (see Section 8.1).",
      "ja": "* CIPHER_SUITE値は、使用中の暗号スイートを表す2バイトのビッグエンディアン整数です（セクション8.1を参照）。"
    },
    {
      "indent": 3,
      "text": "The hash function used for HKDF is determined by the cipher suite in use.",
      "ja": "HKDFに使用されるハッシュ関数は、使用中の暗号スイートによって決定されます。"
    },
    {
      "indent": 0,
      "text": "4.4.3. Encryption",
      "section_title": true,
      "ja": "4.4.3. 暗号化"
    },
    {
      "indent": 3,
      "text": "SFrame encryption uses the AEAD encryption algorithm for the cipher suite in use. The key for the encryption is the sframe_key. The nonce is formed by first XORing the sframe_salt with the current CTR value, and then encoding the result as a big-endian integer of length AEAD.Nn.",
      "ja": "SFRAME暗号化は、使用中のCipherスイートにAEAD暗号化アルゴリズムを使用します。暗号化の鍵はSFRAME_KEYです。NonCeは、最初のSFRAME_SALTを現在のCTR値でXriangでXripingし、次に結果を長さのaead.nnのビッグエンディアン整数としてエンコードすることにより形成されます。"
    },
    {
      "indent": 3,
      "text": "The encryptor forms an SFrame header using the CTR and KID values provided. The encoded header is provided as AAD to the AEAD encryption operation, together with application-provided metadata about the encrypted media (see Section 9.4).",
      "ja": "暗号化業者は、提供されたCTRとKID値を使用してSFRAMEヘッダーを形成します。エンコードされたヘッダーは、暗号化されたメディアに関するアプリケーションが提供するメタデータとともに、AAD暗号化操作のAADとして提供されます（セクション9.4を参照）。"
    },
    {
      "indent": 3,
      "text": "def encrypt(CTR, KID, metadata, plaintext):\n  sframe_key, sframe_salt = key_store[KID]\n\n  # encode_big_endian(x, n) produces an n-byte string encoding the\n  # integer x in big-endian byte order.\n  ctr = encode_big_endian(CTR, AEAD.Nn)\n  nonce = xor(sframe_salt, CTR)\n\n  # encode_sframe_header produces a byte string encoding the\n  # provided KID and CTR values into an SFrame header.\n  header = encode_sframe_header(CTR, KID)\n  aad = header + metadata\n\n  ciphertext = AEAD.Encrypt(sframe_key, nonce, aad, plaintext)\n  return header + ciphertext",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For example, the metadata input to encryption allows for frame metadata to be authenticated when SFrame is applied per frame. After encoding the frame and before packetizing it, the necessary media metadata will be moved out of the encoded frame buffer to be sent in some channel visible to the SFU (e.g., an RTP header extension).",
      "ja": "たとえば、暗号化へのメタデータ入力により、SFRAMEがフレームごとに適用されると、フレームメタデータを認証できます。フレームをエンコードした後、パケット化する前に、必要なメディアメタデータをエンコードされたフレームバッファーから移動して、SFUに表示されるチャネルで送信されます（たとえば、RTPヘッダー拡張機能）。"
    },
    {
      "indent": 3,
      "text": "                                  +---------------+\n                                  |               |\n                                  |               |\n                                  |   plaintext   |\n                                  |               |\n                                  |               |\n                                  +-------+-------+\n                                          |\n        .- +-----+                        |\n       |   |     +--+--> sframe_key ----->| Key\nHeader |   | KID |  |                     |\n       |   |     |  +--> sframe_salt --+  |\n    +--+   +-----+                     |  |\n    |  |   |     +---------------------+->| Nonce\n    |  |   | CTR |                        |\n    |  |   |     |                        |\n    |   '- +-----+                        |\n    |                                     |\n    |          +----------------+         |\n    |          |    metadata    |         |\n    |          +-------+--------+         |\n    |                  |                  |\n    +------------------+----------------->| AAD\n    |                                     |\n    |                                AEAD.Encrypt\n    |                                     |\n    |               SFrame Ciphertext     |\n    |               +---------------+     |\n    +-------------->| SFrame Header |     |\n                    +---------------+     |\n                    |               |     |\n                    |               |<----+\n                    |   ciphertext  |\n                    |               |\n                    |               |\n                    +---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 5: Encrypting an SFrame Ciphertext",
      "ja": "図5：SFRAME暗号の暗号化"
    },
    {
      "indent": 0,
      "text": "4.4.4. Decryption",
      "section_title": true,
      "ja": "4.4.4. 復号化"
    },
    {
      "indent": 3,
      "text": "Before decrypting, a receiver needs to assemble a full SFrame ciphertext. When an SFrame ciphertext is fragmented into multiple parts for transport (e.g., a whole encrypted frame sent in multiple SRTP packets), the receiving client collects all the fragments of the ciphertext, using appropriate sequencing and start/end markers in the transport. Once all of the required fragments are available, the client reassembles them into the SFrame ciphertext and passes the ciphertext to SFrame for decryption.",
      "ja": "復号化する前に、受信者は完全なSFRAME暗号文を組み立てる必要があります。SFRAME暗号文が輸送用に複数の部分に断片化されている場合（たとえば、複数のSRTPパケットで送信された暗号化されたフレーム全体）、受信クライアントは、適切なシーケンスと輸送の開始/終了マーカーを使用して、暗号文のすべてのフラグメントを収集します。必要なすべてのフラグメントが利用可能になると、クライアントはそれらをSFRAME暗号文に再組み立てし、復号化のためにciphertextをSFRAMEに渡します。"
    },
    {
      "indent": 3,
      "text": "The KID field in the SFrame header is used to find the right key and salt for the encrypted frame, and the CTR field is used to construct the nonce. The SFrame decryption procedure is as follows:",
      "ja": "SFRAMEヘッダーのKIDフィールドは、暗号化されたフレームの適切なキーと塩を見つけるために使用され、CTRフィールドはNonCEを構築するために使用されます。SFRAME復号化手順は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "def decrypt(metadata, sframe_ciphertext):\n  KID, CTR, header, ciphertext = parse_ciphertext(sframe_ciphertext)\n\n  sframe_key, sframe_salt = key_store[KID]\n\n  ctr = encode_big_endian(CTR, AEAD.Nn)\n  nonce = xor(sframe_salt, ctr)\n  aad = header + metadata\n\n  return AEAD.Decrypt(sframe_key, nonce, aad, ciphertext)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If a ciphertext fails to decrypt because there is no key available for the KID in the SFrame header, the client MAY buffer the ciphertext and retry decryption once a key with that KID is received. If a ciphertext fails to decrypt for any other reason, the client MUST discard the ciphertext. Invalid ciphertexts SHOULD be discarded in a way that is indistinguishable (to an external observer) from having processed a valid ciphertext. In other words, the SFrame decrypt operation should take the same amount of time regardless of whether decryption succeeds or fails.",
      "ja": "SFRAMEヘッダーにKIDが利用できるキーがないために暗号文が解読に失敗した場合、クライアントは、その子供のキーを受け取った後、暗号文をバッファリングし、再結合を再生することができます。ciphertextが他の理由で解読に失敗した場合、クライアントは暗号文を破棄する必要があります。無効な暗号文は、（外部の観測者にとって）有効な暗号文を処理することを区別できない方法で破棄する必要があります。言い換えれば、SFRAME Decrypt操作は、復号化が成功するか失敗するかに関係なく、同じ時間を要するはずです。"
    },
    {
      "indent": 7,
      "text": "                SFrame Ciphertext\n                +---------------+\n+---------------| SFrame Header |\n|               +---------------+\n|               |               |\n|               |               |-----+\n|               |   ciphertext  |     |\n|               |               |     |\n|               |               |     |\n|               +---------------+     |\n|                                     |\n|   .- +-----+                        |\n|  |   |     +--+--> sframe_key ----->| Key\n|  |   | KID |  |                     |\n|  |   |     |  +--> sframe_salt --+  |\n+->+   +-----+                     |  |\n|  |   |     +---------------------+->| Nonce\n|  |   | CTR |                        |\n|  |   |     |                        |\n|   '- +-----+                        |\n|                                     |\n|          +----------------+         |\n|          |    metadata    |         |\n|          +-------+--------+         |\n|                  |                  |\n+------------------+----------------->| AAD\n                                      |\n                                 AEAD.Decrypt\n                                      |\n                                      V\n                              +---------------+\n                              |               |\n                              |               |\n                              |   plaintext   |\n                              |               |\n                              |               |\n                              +---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 6: Decrypting an SFrame Ciphertext",
      "ja": "図6：SFRAME暗号の復号化"
    },
    {
      "indent": 0,
      "text": "4.5. Cipher Suites",
      "section_title": true,
      "ja": "4.5. 暗号スイート"
    },
    {
      "indent": 3,
      "text": "Each SFrame session uses a single cipher suite that specifies the following primitives:",
      "ja": "各SFRAMEセッションでは、次のプリミティブを指定する単一の暗号スイートを使用しています。"
    },
    {
      "indent": 6,
      "text": "* A hash function used for key derivation",
      "ja": "* キー派生に使用されるハッシュ関数"
    },
    {
      "indent": 6,
      "text": "* An AEAD encryption algorithm [RFC5116] used for frame encryption, optionally with a truncated authentication tag",
      "ja": "* フレーム暗号化に使用されるAEAD暗号化アルゴリズム[RFC5116]、オプションで切り取られた認証タグを使用して"
    },
    {
      "indent": 3,
      "text": "This document defines the following cipher suites, with the constants defined in Section 4.4:",
      "ja": "このドキュメントでは、次の暗号スイートを定義し、セクション4.4で定数を定義しています。"
    },
    {
      "indent": 9,
      "text": "+============================+====+=====+====+====+====+\n| Name                       | Nh | Nka | Nk | Nn | Nt |\n+============================+====+=====+====+====+====+\n| AES_128_CTR_HMAC_SHA256_80 | 32 | 16  | 48 | 12 | 10 |\n+----------------------------+----+-----+----+----+----+\n| AES_128_CTR_HMAC_SHA256_64 | 32 | 16  | 48 | 12 | 8  |\n+----------------------------+----+-----+----+----+----+\n| AES_128_CTR_HMAC_SHA256_32 | 32 | 16  | 48 | 12 | 4  |\n+----------------------------+----+-----+----+----+----+\n| AES_128_GCM_SHA256_128     | 32 | n/a | 16 | 12 | 16 |\n+----------------------------+----+-----+----+----+----+\n| AES_256_GCM_SHA512_128     | 64 | n/a | 32 | 12 | 16 |\n+----------------------------+----+-----+----+----+----+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Table 1: SFrame Cipher Suite Constants",
      "ja": "表1：SFRAME暗号スイート定数"
    },
    {
      "indent": 3,
      "text": "Numeric identifiers for these cipher suites are defined in the IANA registry created in Section 8.1.",
      "ja": "これらの暗号スイートの数値識別子は、セクション8.1で作成されたIANAレジストリで定義されています。"
    },
    {
      "indent": 3,
      "text": "In the suite names, the length of the authentication tag is indicated by the last value: \"_128\" indicates a 128-bit tag, \"_80\" indicates an 80-bit tag, \"_64\" indicates a 64-bit tag, and \"_32\" indicates a 32-bit tag.",
      "ja": "スイート名では、認証タグの長さは最後の値で示されます。「_128」は128ビットタグを示し、「_80」は80ビットタグを示し、「_64」は64ビットタグを示し、」_32 \"は32ビットタグを示します。"
    },
    {
      "indent": 3,
      "text": "In a session that uses multiple media streams, different cipher suites might be configured for different media streams. For example, in order to conserve bandwidth, a session might use a cipher suite with 80-bit tags for video frames and another cipher suite with 32-bit tags for audio frames.",
      "ja": "複数のメディアストリームを使用するセッションでは、さまざまなメディアストリームに対して異なる暗号スイートを構成することができます。たとえば、帯域幅を保存するために、セッションでは、ビデオフレームに80ビットタグを備えた暗号スイートと、オーディオフレームに32ビットタグを備えた別の暗号スイートを使用する場合があります。"
    },
    {
      "indent": 0,
      "text": "4.5.1. AES-CTR with SHA2",
      "section_title": true,
      "ja": "4.5.1. SHA2を使用したAES-CTR"
    },
    {
      "indent": 3,
      "text": "In order to allow very short tag sizes, we define a synthetic AEAD function using the authenticated counter mode of AES together with HMAC for authentication. We use an encrypt-then-MAC approach, as in SRTP [RFC3711].",
      "ja": "非常に短いタグサイズを許可するために、認証のためにHMACとともにASの認証されたカウンターモードを使用して合成AEAD関数を定義します。SRTP [RFC3711]のように、暗号化 -  Then-Macアプローチを使用します。"
    },
    {
      "indent": 3,
      "text": "Before encryption or decryption, encryption and authentication subkeys are derived from the single AEAD key. The overall length of the AEAD key is Nka + Nh, where Nka represents the key size for the AES block cipher in use and Nh represents the output size of the hash function (as in Section 4.4). The encryption subkey comprises the first Nka bytes and the authentication subkey comprises the remaining Nh bytes.",
      "ja": "暗号化または復号化の前に、暗号化と認証サブキーは単一のAEADキーから派生します。AEADキーの全長はNKA + NHで、NKAは使用中のAESブロック暗号のキーサイズを表し、NHはハッシュ関数の出力サイズを表します（セクション4.4のように）。暗号化サブキーは最初のNKAバイトで構成され、認証サブキーは残りのNHバイトで構成されます。"
    },
    {
      "indent": 3,
      "text": "def derive_subkeys(sframe_key):\n  # The encryption key comprises the first Nka bytes\n  enc_key = sframe_key[..Nka]\n\n  # The authentication key comprises Nh remaining bytes\n  auth_key = sframe_key[Nka..]\n\n  return enc_key, auth_key",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The AEAD encryption and decryption functions are then composed of individual calls to the CTR encrypt function and HMAC. The resulting MAC value is truncated to a number of bytes Nt fixed by the cipher suite.",
      "ja": "AEAD暗号化と復号化関数は、CTR暗号化関数とHMACへの個別の呼び出しで構成されます。結果のMac値は、Cipherスイートによって固定された多数のバイトに切り捨てられます。"
    },
    {
      "indent": 3,
      "text": "def truncate(tag, n):\n  # Take the first `n` bytes of `tag`\n  return tag[..n]\n\ndef compute_tag(auth_key, nonce, aad, ct):\n  aad_len = encode_big_endian(len(aad), 8)\n  ct_len = encode_big_endian(len(ct), 8)\n  tag_len = encode_big_endian(Nt, 8)\n  auth_data = aad_len + ct_len + tag_len + nonce + aad + ct\n  tag = HMAC(auth_key, auth_data)\n  return truncate(tag, Nt)\n\ndef AEAD.Encrypt(key, nonce, aad, pt):\n  enc_key, auth_key = derive_subkeys(key)\n  initial_counter = nonce + 0x00000000 # append four zero bytes\n  ct = AES-CTR.Encrypt(enc_key, initial_counter, pt)\n  tag = compute_tag(auth_key, nonce, aad, ct)\n  return ct + tag\n\ndef AEAD.Decrypt(key, nonce, aad, ct):\n  inner_ct, tag = split_ct(ct, tag_len)\n\n  enc_key, auth_key = derive_subkeys(key)\n  candidate_tag = compute_tag(auth_key, nonce, aad, inner_ct)\n  if !constant_time_equal(tag, candidate_tag):\n    raise Exception(\"Authentication Failure\")\n\n  initial_counter = nonce + 0x00000000 # append four zero bytes\n  return AES-CTR.Decrypt(enc_key, initial_counter, inner_ct)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5. Key Management",
      "section_title": true,
      "ja": "5. キー管理"
    },
    {
      "indent": 3,
      "text": "SFrame must be integrated with an E2E key management framework to exchange and rotate the keys used for SFrame encryption. The key management framework provides the following functions:",
      "ja": "SFRAMEは、SFRAME暗号化に使用されるキーを交換および回転させるために、E2Eキー管理フレームワークと統合する必要があります。主要な管理フレームワークは、次の機能を提供します。"
    },
    {
      "indent": 6,
      "text": "* Provisioning KID / base_key mappings to participating clients",
      "ja": "* 参加クライアントへのKid / Base_Keyマッピングのプロビジョニング"
    },
    {
      "indent": 6,
      "text": "* Updating the above data as clients join or leave",
      "ja": "* クライアントが参加または去るときに上記のデータを更新します"
    },
    {
      "indent": 3,
      "text": "It is the responsibility of the application to provide the key management framework, as described in Section 9.2.",
      "ja": "セクション9.2で説明されているように、主要な管理フレームワークを提供することは、アプリケーションの責任です。"
    },
    {
      "indent": 0,
      "text": "5.1. Sender Keys",
      "section_title": true,
      "ja": "5.1. 送信キー"
    },
    {
      "indent": 3,
      "text": "If the participants in a call have a preexisting E2E-secure channel, they can use it to distribute SFrame keys. Each client participating in a call generates a fresh base_key value that it will use to encrypt media. The client then uses the E2E-secure channel to send their encryption key to the other participants.",
      "ja": "通話の参加者が既存のE2Eセキュアチャネルを持っている場合、それを使用してSFRAMEキーを配布できます。コールに参加している各クライアントは、メディアを暗号化するために使用する新しいbase_key値を生成します。その後、クライアントはE2Eセキュアチャネルを使用して、暗号化キーを他の参加者に送信します。"
    },
    {
      "indent": 3,
      "text": "In this scheme, it is assumed that receivers have a signal outside of SFrame for which client has sent a given frame (e.g., an RTP synchronization source (SSRC)). SFrame KID values are then used to distinguish between versions of the sender's base_key.",
      "ja": "このスキームでは、受信機には、クライアントが特定のフレームを送信したSFRAME以外の信号があると想定されています（例：RTP同期ソース（SSRC））。次に、SFRAME KID値を使用して、送信者のBase_Keyのバージョンを区別します。"
    },
    {
      "indent": 3,
      "text": "KID values in this scheme have two parts: a \"key generation\" and a \"ratchet step\". Both are unsigned integers that begin at zero. The key generation increments each time the sender distributes a new key to receivers. The ratchet step is incremented each time the sender ratchets their key forward for forward secrecy:",
      "ja": "このスキームの子供の値には、「キー生成」と「ラチェットステップ」の2つの部分があります。どちらもゼロで始まる署名されていない整数です。キー生成は、送信者がレシーバーに新しいキーを配布するたびに増加します。ラチェットステップは、送信者が将来の秘密のためにキーを前方にラチェットするたびに増加します。"
    },
    {
      "indent": 3,
      "text": "base_key[i+1] = HKDF-Expand(\n                  HKDF-Extract(\"\", base_key[i]),\n                  \"SFrame 1.0 Ratchet\", CipherSuite.Nh)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For compactness, we do not send the whole ratchet step. Instead, we send only its low-order R bits, where R is a value set by the application. Different senders may use different values of R, but each receiver of a given sender needs to know what value of R is used by the sender so that they can recognize when they need to ratchet (vs. expecting a new key). R effectively defines a reordering window, since no more than 2^R ratchet steps can be active at a given time. The key generation is sent in the remaining 64 - R bits of the KID.",
      "ja": "コンパクトさのために、ラチェット全体のステップを送信しません。代わりに、低次のRビットのみを送信します。ここで、Rはアプリケーションによって設定された値です。異なる送信者はRの異なる値を使用する場合がありますが、特定の送信者の各受信者は、Ratchetが必要なときに認識できるように、送信者がRのどの値を使用しているかを知る必要があります（新しいキーを期待します）。rは、特定の時間に2^rラチェットステップがアクティブになる可能性があるため、並べ替えウィンドウを効果的に定義します。キージェネレーションは、子供の残りの64 -Rビットに送信されます。"
    },
    {
      "indent": 3,
      "text": "KID = (key_generation << R) + (ratchet_step % (1 << R))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "     64-R bits         R bits\n <---------------> <------------>\n+-----------------+--------------+\n| Key Generation  | Ratchet Step |\n+-----------------+--------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Figure 7: Structure of a KID in the Sender Keys Scheme",
      "ja": "図7：送信者キーズスキームの子供の構造"
    },
    {
      "indent": 3,
      "text": "The sender signals such a ratchet step update by sending with a KID value in which the ratchet step has been incremented. A receiver who receives from a sender with a new KID computes the new key as above. The old key may be kept for some time to allow for out-of-order delivery, but should be deleted promptly.",
      "ja": "送信者は、ラチェットステップが増加した子供の価値を送信することにより、このようなラチェットステップの更新を信号します。新しいKIDを使用して送信者から受信するレシーバーは、上記のように新しいキーを計算します。古いキーはしばらくの間保持される場合がありますが、注文不定の配達を可能にしますが、迅速に削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a new participant joins in the middle of a session, they will need to receive from each sender (a) the current sender key for that sender and (b) the current KID value for the sender. Evicting a participant requires each sender to send a fresh sender key to all receivers.",
      "ja": "新しい参加者がセッションの途中で参加する場合、各送信者から受け取る必要があります（a）その送信者の現在の送信者キー、および（b）送信者の現在の子供価値。参加者を追い出すには、各送信者がすべてのレシーバーに新しい送信者キーを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "It is the application's responsibility to decide when sender keys are updated. A sender key may be updated by sending a new base_key (updating the key generation) or by hashing the current base_key (updating the ratchet step). Ratcheting the key forward is useful when adding new receivers to an SFrame-based interaction, since it ensures that the new receivers can't decrypt any media encrypted before they were added. If a sender wishes to assure the opposite property when removing a receiver (i.e., ensuring that the receiver can't decrypt media after they are removed), then the sender will need to distribute a new sender key.",
      "ja": "送信者キーがいつ更新されるかを決定することは、アプリケーションの責任です。送信者キーは、新しいbase_key（キー生成の更新）を送信するか、現在のbase_key（ラチェットステップの更新）をハッシュすることで更新できます。キーフォワードのラチェットは、新しい受信機をSFRAMEベースのインタラクションに追加するときに役立ちます。これは、新しいレシーバーが追加される前に暗号化されたメディアを復号化できないことを保証するためです。送信者がレシーバーを削除するときに反対のプロパティを保証したい場合（つまり、レシーバーが削除された後にメディアを解読できないことを確認する）、送信者は新しい送信者キーを配布する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2. MLS",
      "section_title": true,
      "ja": "5.2. MLS"
    },
    {
      "indent": 3,
      "text": "The Messaging Layer Security (MLS) protocol provides group authenticated key exchange [MLS-ARCH] [MLS-PROTO]. In principle, it could be used to instantiate the sender key scheme above, but it can also be used more efficiently directly.",
      "ja": "メッセージングレイヤーセキュリティ（MLS）プロトコルは、グループ認証されたキーエクスチェンジ[MLS-ARCH] [MLS-Proto]を提供します。原則として、上記のSender Keyスキームをインスタンス化するために使用できますが、より効率的に直接使用することもできます。"
    },
    {
      "indent": 3,
      "text": "MLS creates a linear sequence of keys, each of which is shared among the members of a group at a given point in time. When a member joins or leaves the group, a new key is produced that is known only to the augmented or reduced group. Each step in the lifetime of the group is known as an \"epoch\", and each member of the group is assigned an \"index\" that is constant for the time they are in the group.",
      "ja": "MLSはキーの線形シーケンスを作成します。各キーは、特定の時点でグループのメンバー間で共有されます。メンバーがグループに参加または出発すると、拡張または還元グループにのみ知られている新しいキーが生成されます。グループの生涯の各ステップは「エポック」として知られており、グループの各メンバーには、グループにいる間、一定の「インデックス」が割り当てられます。"
    },
    {
      "indent": 3,
      "text": "To generate keys and nonces for SFrame, we use the MLS exporter function to generate a base_key value for each MLS epoch. Each member of the group is assigned a set of KID values so that each member has a unique sframe_key and sframe_salt that it uses to encrypt with. Senders may choose any KID value within their assigned set of KID values, e.g., to allow a single sender to send multiple, uncoordinated outbound media streams.",
      "ja": "SFRAME用のキーとNoncesを生成するには、MLS Exporter関数を使用して、各MLSエポックのbase_key値を生成します。グループの各メンバーには、各メンバーが暗号化するために使用する一意のSFRAME_KEYとSFRAME_SALTを持っているようにKID値のセットが割り当てられます。送信者は、1人の送信者が複数の無調整されていないアウトバウンドメディアストリームを送信できるようにするために、割り当てられた子供の価値のセット内で任意の子供の価値を選択できます。"
    },
    {
      "indent": 3,
      "text": "base_key = MLS-Exporter(\"SFrame 1.0 Base Key\", \"\", AEAD.Nk)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For compactness, we do not send the whole epoch number. Instead, we send only its low-order E bits, where E is a value set by the application. E effectively defines a reordering window, since no more than 2^E epochs can be active at a given time. To handle rollover of the epoch counter, receivers MUST remove an old epoch when a new epoch with the same low-order E bits is introduced.",
      "ja": "コンパクトさのために、エポック数全体を送信しません。代わりに、eはアプリケーションによって設定された値である低次のEビットのみを送信します。eは、並べ替えウィンドウを効果的に定義します。これは、特定の時間に2^eエポック以下がアクティブになる可能性があるためです。エポックカウンターのロールオーバーを処理するには、同じ低次のEビットを持つ新しいエポックが導入されたときに、レシーバーが古いエポックを削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "Let S be the number of bits required to encode a member index in the group, i.e., the smallest value such that group_size <= (1 << S). The sender index is encoded in the S bits above the epoch. The remaining 64 - S - E bits of the KID value are a context value chosen by the sender (context value 0 will produce the shortest encoded KID).",
      "ja": "Sをグループ内のメンバーインデックスをエンコードするために必要なビット数、つまりGroup_size <=（1 << s）のような最小値を使用します。送信者インデックスは、エポックの上のSビットでエンコードされます。KID値の残りの64 -S -Eビットは、送信者によって選択されたコンテキスト値です（コンテキスト値0は、最も短いエンコードされた子供を生成します）。"
    },
    {
      "indent": 3,
      "text": "KID = (context << (S + E)) + (sender_index << E) + (epoch % (1 << E))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  64-S-E bits   S bits   E bits\n <-----------> <------> <------>\n+-------------+--------+-------+\n| Context ID  | Index  | Epoch |\n+-------------+--------+-------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 8: Structure of a KID for an MLS Sender",
      "ja": "図8：MLS送信者の子供の構造"
    },
    {
      "indent": 3,
      "text": "Once an SFrame stack has been provisioned with the sframe_epoch_secret for an epoch, it can compute the required KID values on demand (as well as the resulting SFrame keys/nonces derived from the base_key and KID) as it needs to encrypt or decrypt for a given member.",
      "ja": "SFRAMEスタックがエポックのSFRAME_EPOCH_SECRETでプロビジョニングされると、必要なKID値（および結果のSFRAMEキー/base_KeyとKIDに由来するSFRAMEキー/非セース）を計算できます。メンバー。"
    },
    {
      "indent": 3,
      "text": "  ...\n         |\n         |\nEpoch 14 +--+-- index=3 ---> KID = 0x3e\n         |  |\n         |  +-- index=7 ---> KID = 0x7e\n         |  |\n         |  +-- index=20 --> KID = 0x14e\n         |\n         |\nEpoch 15 +--+-- index=3 ---> KID = 0x3f\n         |  |\n         |  +-- index=5 ---> KID = 0x5f\n         |\n         |\nEpoch 16 +----- index=2 --+--> context = 2 --> KID = 0x820\n         |                |\n         |                +--> context = 3 --> KID = 0xc20\n         |\n         |\nEpoch 17 +--+-- index=33 --> KID = 0x211\n         |  |\n         |  +-- index=51 --> KID = 0x331\n         |\n         |\n  ...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 9: An Example Sequence of KIDs for an MLS-based SFrame Session (E=4; S=6, Allowing for 64 Group Members)",
      "ja": "図9：MLSベースのSFRAMEセッションの子供の例のシーケンス（E = 4; S = 6、64人のグループメンバーが可能です）"
    },
    {
      "indent": 0,
      "text": "6. Media Considerations",
      "section_title": true,
      "ja": "6. メディアの考慮事項"
    },
    {
      "indent": 0,
      "text": "6.1. Selective Forwarding Units",
      "section_title": true,
      "ja": "6.1. 選択的転送ユニット"
    },
    {
      "indent": 3,
      "text": "SFUs (e.g., those described in Section 3.7 of [RFC7667]) receive the media streams from each participant and select which ones should be forwarded to each of the other participants. There are several approaches for stream selection, but in general, the SFU needs to access metadata associated with each frame and modify the RTP information of the incoming packets when they are transmitted to the received participants.",
      "ja": "SFU（たとえば、[RFC7667]のセクション3.7で説明されているもの）は、各参加者からメディアストリームを受け取り、他の各参加者に転送する必要があるものを選択します。ストリーム選択にはいくつかのアプローチがありますが、一般に、SFUは各フレームに関連付けられたメタデータにアクセスし、受信した参加者に送信されたときに着信パケットのRTP情報を変更する必要があります。"
    },
    {
      "indent": 3,
      "text": "This section describes how these normal SFU modes of operation interact with the E2EE provided by SFrame.",
      "ja": "このセクションでは、これらの通常のSFU操作モードがSFRAMEによって提供されるE2EEとどのように相互作用するかについて説明します。"
    },
    {
      "indent": 0,
      "text": "6.1.1. RTP Stream Reuse",
      "section_title": true,
      "ja": "6.1.1. RTPストリームの再利用"
    },
    {
      "indent": 3,
      "text": "The SFU may choose to send only a certain number of streams based on the voice activity of the participants. To avoid the overhead involved in establishing new transport streams, the SFU may decide to reuse previously existing streams or even pre-allocate a predefined number of streams and choose in each moment in time which participant media will be sent through it.",
      "ja": "SFUは、参加者の音声アクティビティに基づいて、特定の数のストリームのみを送信することを選択できます。新しい輸送ストリームの確立に伴うオーバーヘッドを回避するために、SFUは、以前に既存のストリームを再利用するか、事前定義された数のストリームを事前に割り当てて、各瞬間にどの参加者メディアが送信されるかを選択することを決定する場合があります。"
    },
    {
      "indent": 3,
      "text": "This means that the same transport-level stream (e.g., an RTP stream defined by either SSRC or Media Identification (MID)) may carry media from different streams of different participants. Because each participant uses a different key to encrypt their media, the receiver will be able to verify the sender of the media within the RTP stream at any given point in time. Thus the receiver will correctly associate the media with the sender indicated by the authenticated SFrame KID value, irrespective of how the SFU transmits the media to the client.",
      "ja": "これは、同じトランスポートレベルのストリーム（たとえば、SSRCまたはメディア識別（MID）によって定義されたRTPストリーム）が、異なる参加者の異なるストリームからメディアを運ぶ可能性があることを意味します。各参加者は別のキーを使用してメディアを暗号化するため、受信者は任意の時点でRTPストリーム内のメディアの送信者を確認できます。したがって、受信者は、SFUがメディアをクライアントにどのように送信するかに関係なく、認証されたSFRAME KID価値によって示される送信者とメディアを正しく関連付けます。"
    },
    {
      "indent": 3,
      "text": "Note that in order to prevent impersonation by a malicious participant (not the SFU), a mechanism based on digital signature would be required. SFrame does not protect against such attacks.",
      "ja": "悪意のある参加者（SFUではなく）によるなりすましを防ぐためには、デジタル署名に基づくメカニズムが必要であることに注意してください。SFRAMEはそのような攻撃から保護しません。"
    },
    {
      "indent": 0,
      "text": "6.1.2. Simulcast",
      "section_title": true,
      "ja": "6.1.2. 同時放送"
    },
    {
      "indent": 3,
      "text": "When using simulcast, the same input image will produce N different encoded frames (one per simulcast layer), which would be processed independently by the frame encryptor and assigned an unique CTR value for each.",
      "ja": "Simulcastを使用すると、同じ入力画像がn異なるエンコードされたフレーム（Simulcastレイヤーごとに1つ）を生成します。これは、フレーム暗号化装置によって個別に処理され、それぞれに一意のCTR値を割り当てます。"
    },
    {
      "indent": 0,
      "text": "6.1.3. Scalable Video Coding (SVC)",
      "section_title": true,
      "ja": "6.1.3. スケーラブルなビデオコーディング（SVC）"
    },
    {
      "indent": 3,
      "text": "In both temporal and spatial scalability, the SFU may choose to drop layers in order to match a certain bitrate or to forward specific media sizes or frames per second. In order to support the SFU selectively removing layers, the sender MUST encapsulate each layer in a different SFrame ciphertext.",
      "ja": "時間的および空間的スケーラビリティの両方で、SFUは、特定のビットレートを一致させるためにレイヤーをドロップするか、特定のメディアサイズまたはフレームを毎秒転送することを選択できます。SFUを選択的に除去するSFUをサポートするために、送信者は異なるSFRAME暗号文で各レイヤーをカプセル化する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2. Video Key Frames",
      "section_title": true,
      "ja": "6.2. ビデオキーフレーム"
    },
    {
      "indent": 3,
      "text": "Forward security and post-compromise security require that the E2EE keys (base keys) are updated any time a participant joins or leaves the call.",
      "ja": "フォワードセキュリティと競合後のセキュリティでは、参加者が電話に参加または出発するたびに、E2EEキー（ベースキー）が更新される必要があります。"
    },
    {
      "indent": 3,
      "text": "The key exchange happens asynchronously and on a different path than the SFU signaling and media. So it may happen that when a new participant joins the call and the SFU side requests a key frame, the sender generates the E2EE frame with a key that is not known by the receiver, so it will be discarded. When the sender updates his sending key with the new key, it will send it in a non-key frame, so the receiver will be able to decrypt it, but not decode it.",
      "ja": "キー交換は、SFUシグナル伝達や媒体とは異なる経路で非同期に発生します。したがって、新しい参加者がコールに参加し、SFU側がキーフレームを要求すると、送信者がレシーバーに知られていないキーでE2EEフレームを生成するため、破棄されます。送信者が送信キーを新しいキーで更新すると、キー以外のフレームで送信されるため、受信者はそれを解読できますが、デコードすることはできません。"
    },
    {
      "indent": 3,
      "text": "The new receiver will then re-request a key frame, but due to sender and SFU policies, that new key frame could take some time to be generated.",
      "ja": "その後、新しいレシーバーはキーフレームを再Questしますが、送信者とSFUポリシーにより、新しいキーフレームが生成されるまでに時間がかかる可能性があります。"
    },
    {
      "indent": 3,
      "text": "If the sender sends a key frame after the new E2EE key is in use, the time required for the new participant to display the video is minimized.",
      "ja": "新しいE2EEキーが使用された後に送信者がキーフレームを送信した場合、新しい参加者がビデオを表示するのに必要な時間が最小限に抑えられます。"
    },
    {
      "indent": 3,
      "text": "Note that this issue does not arise for media streams that do not have dependencies among frames, e.g., audio streams. In these streams, each frame is independently decodable, so a frame never depends on another frame that might be on the other side of a key rotation.",
      "ja": "この問題は、フレームの間に依存関係がないメディアストリーム、たとえばオーディオストリームでは発生しないことに注意してください。これらのストリームでは、各フレームは独立してデコード可能であるため、キー回転の反対側にある可能性のある別のフレームにフレームが依存することはありません。"
    },
    {
      "indent": 0,
      "text": "6.3. Partial Decoding",
      "section_title": true,
      "ja": "6.3. 部分的なデコード"
    },
    {
      "indent": 3,
      "text": "Some codecs support partial decoding, where individual packets can be decoded without waiting for the full frame to arrive. When SFrame is applied per frame, partial decoding is not possible because the decoder cannot access data until an entire frame has arrived and has been decrypted.",
      "ja": "一部のコーデックは、フルフレームが到着するのを待たずに個々のパケットをデコードできる部分的なデコードをサポートしています。SFRAMEがフレームごとに適用される場合、デコーダーが到着して復号化されるまでデコーダーがデータにアクセスできないため、部分的なデコードは不可能です。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "7.1. No Header Confidentiality",
      "section_title": true,
      "ja": "7.1. ヘッダーの機密性はありません"
    },
    {
      "indent": 3,
      "text": "SFrame provides integrity protection to the SFrame header (the KID and CTR values), but it does not provide confidentiality protection. Parties that can observe the SFrame header may learn, for example, which parties are sending SFrame payloads (from KID values) and at what rates (from CTR values). In cases where SFrame is used for end-to-end security on top of hop-by-hop protections (e.g., running over SRTP as described in Appendix B.5), the hop-by-hop security mechanisms provide confidentiality protection of the SFrame header between hops.",
      "ja": "SFRAMEは、SFRAMEヘッダー（子供とCTRの値）に整合性保護を提供しますが、機密保護を提供しません。SFRAMEヘッダーを観察できる当事者は、たとえば、どの当事者がSFRAMEペイロードを（KID値から）送信しているか（CTR値から）学習している場合があります。SFRAMEがホップバイホップ保護に加えてエンドツーエンドのセキュリティに使用されている場合（例：付録B.5で説明したようにSRTPを介して実行）、ホップバイホップセキュリティメカニズムは、ホップ間のsframeヘッダー。"
    },
    {
      "indent": 0,
      "text": "7.2. No Per-Sender Authentication",
      "section_title": true,
      "ja": "7.2. センダーごとの認証はありません"
    },
    {
      "indent": 3,
      "text": "SFrame does not provide per-sender authentication of media data. Any sender in a session can send media that will be associated with any other sender. This is because SFrame uses symmetric encryption to protect media data, so that any receiver also has the keys required to encrypt packets for the sender.",
      "ja": "SFRAMEは、メディアデータのセンダーごとの認証を提供しません。セッションの送信者は、他の送信者に関連付けられるメディアを送信できます。これは、SFRAMEが対称暗号化を使用してメディアデータを保護するため、受信機には送信者用のパケットを暗号化するために必要なキーも持っているためです。"
    },
    {
      "indent": 0,
      "text": "7.3. Key Management",
      "section_title": true,
      "ja": "7.3. キー管理"
    },
    {
      "indent": 3,
      "text": "The specifics of key management are beyond the scope of this document. However, every client SHOULD change their keys when new clients join or leave the call for forward secrecy and post-compromise security.",
      "ja": "主要な管理の詳細は、このドキュメントの範囲を超えています。ただし、新しいクライアントが参加したときにすべてのクライアントがキーを変更するか、フォワードの秘密と競争後のセキュリティを求めて任せる必要があります。"
    },
    {
      "indent": 0,
      "text": "7.4. Replay",
      "section_title": true,
      "ja": "7.4. リプレイ"
    },
    {
      "indent": 3,
      "text": "The handling of replay is out of the scope of this document. However, senders MUST reject requests to encrypt multiple times with the same key and nonce since several AEAD algorithms fail badly in such cases (see, e.g., Section 5.1.1 of [RFC5116]).",
      "ja": "リプレイの処理は、このドキュメントの範囲外です。ただし、送信者は、いくつかのAEADアルゴリズムがそのような場合にはひどく失敗するため、同じキーとNonCEで複数回暗号化するリクエストを拒否する必要があります（たとえば、[RFC5116]のセクション5.1.1を参照）。"
    },
    {
      "indent": 0,
      "text": "7.5. Risks Due to Short Tags",
      "section_title": true,
      "ja": "7.5. 短いタグによるリスク"
    },
    {
      "indent": 3,
      "text": "The SFrame cipher suites based on AES-CTR allow for the use of short authentication tags, which bring a higher risk that an attacker will be able to cause an SFrame receiver to accept an SFrame ciphertext of the attacker's choosing.",
      "ja": "AES-CTRに基づいたSFRAME暗号スイートにより、短い認証タグを使用できるようになり、攻撃者がSFRAMEレシーバーにSFRAMEの選択肢の選択を受け入れることができるリスクが高くなります。"
    },
    {
      "indent": 3,
      "text": "Assuming that the authentication properties of the cipher suite are robust, the only attack that an attacker can mount is an attempt to find an acceptable (ciphertext, tag) combination through brute force. Such a brute-force attack will have an expected success rate of the following form:",
      "ja": "暗号スイートの認証プロパティが堅牢であると仮定すると、攻撃者が取り付けることができる唯一の攻撃は、ブルートフォースを介した許容可能な（ciphertext、タグ）組み合わせを見つける試みです。このようなブルートフォース攻撃は、次の形式の予想される成功率を持ちます。"
    },
    {
      "indent": 3,
      "text": "attacker_success_rate = attempts_per_second / 2^(8*Nt)",
      "ja": "Attecer_success_rate = dirgions_per_second / 2^（8*nt）"
    },
    {
      "indent": 3,
      "text": "For example, a gigabit Ethernet connection is able to transmit roughly 2^20 packets per second. If an attacker saturated such a link with guesses against a 32-bit authentication tag (Nt=4), then the attacker would succeed on average roughly once every 2^12 seconds, or about once an hour.",
      "ja": "たとえば、ギガビットイーサネット接続では、約2^20パケットを1秒あたり送信できます。攻撃者が32ビット認証タグ（NT = 4）に対して推測でそのようなリンクを飽和させた場合、攻撃者は平均して2^12秒ごとに、または1時間に約1回成功します。"
    },
    {
      "indent": 3,
      "text": "In a typical SFrame usage in a real-time media application, there are a few approaches to mitigating this risk:",
      "ja": "リアルタイムメディアアプリケーションでの典型的なSFRAMEの使用では、このリスクを緩和するためのいくつかのアプローチがあります。"
    },
    {
      "indent": 6,
      "text": "* Receivers only accept SFrame ciphertexts over HBH-secure channels (e.g., SRTP security associations or QUIC connections). If this is the case, only an entity that is part of such a channel can mount the above attack.",
      "ja": "* 受信者は、HBHセクュアチャネル（例えば、SRTPセキュリティ関連またはQUIC接続）を介したSFRAME暗号のみを受け入れます。この場合、そのようなチャネルの一部であるエンティティのみが上記の攻撃を取り付けることができます。"
    },
    {
      "indent": 6,
      "text": "* The expected packet rate for a media stream is very predictable (and typically far lower than the above example). On the one hand, attacks at this rate will succeed even less often than the high-rate attack described above. On the other hand, the application may use an elevated packet arrival rate as a signal of a brute-force attack. This latter approach is common in other settings, e.g., mitigating brute-force attacks on passwords.",
      "ja": "* メディアストリームの予想されるパケットレートは非常に予測可能です（通常、上記の例よりもはるかに低い）。一方では、この速度での攻撃は、上記の高速攻撃よりもさらに頻繁に成功します。一方、アプリケーションは、ブルートフォース攻撃の信号として、上昇したパケット到着率を使用する場合があります。この後者のアプローチは、他の設定で一般的です。たとえば、パスワードに対するブルートフォース攻撃の緩和。"
    },
    {
      "indent": 6,
      "text": "* Media applications typically do not provide feedback to media senders as to which media packets failed to decrypt. When media-quality feedback mechanisms are used, decryption failures will typically appear as packet losses, but only at an aggregate level.",
      "ja": "* メディアアプリケーションは通常、メディアパケットがどのメディアパケットが復号化できなかったかについて、メディア送信者にフィードバックを提供しません。メディア品質のフィードバックメカニズムを使用すると、復号化の障害は通常、パケット損失として表示されますが、総レベルでのみ表示されます。"
    },
    {
      "indent": 6,
      "text": "* Anti-replay mechanisms (see Section 7.4) prevent the attacker from reusing valid ciphertexts (either observed or guessed by the attacker). A receiver applying anti-replay controls will only accept one valid plaintext per CTR value. Since the CTR value is covered by SFrame authentication, an attacker has to do a fresh search for a valid tag for every forged ciphertext, even if the encrypted content is unchanged. In other words, when the above brute-force attack succeeds, it only allows the attacker to send a single SFrame ciphertext; the ciphertext cannot be reused because either it will have the same CTR value and be discarded as a replay, or else it will have a different CTR value and its tag will no longer be valid.",
      "ja": "* アンチレプレイメカニズム（セクション7.4を参照）は、攻撃者が有効な暗号文を再利用することを防ぎます（攻撃者によって観察または推測されます）。反レプレイコントロールを適用するレシーバーは、CTR値ごとに1つの有効なプレーンテキストのみを受け入れます。CTR値はSFRAME認証によってカバーされているため、攻撃者は、暗号化されたコンテンツが変更されていなくても、偽造された暗号文ごとに有効なタグを新たに検索する必要があります。言い換えれば、上記のブルートフォース攻撃が成功すると、攻撃者は単一のSFRAME暗号文を送信することのみを可能にします。ciphertextは、同じCTR値を持ち、リプレイとして破棄されるか、異なるCTR値を持ち、そのタグが有効でないため、再利用できません。"
    },
    {
      "indent": 3,
      "text": "Nonetheless, without these mitigations, an application that makes use of short tags will be at heightened risk of forgery attacks. In many cases, it is simpler to use full-size tags and tolerate slightly higher bandwidth usage rather than to add the additional defenses necessary to safely use short tags.",
      "ja": "それにもかかわらず、これらの緩和がなければ、短いタグを使用するアプリケーションは、偽造攻撃のリスクが高まります。多くの場合、フルサイズのタグを使用して、短いタグを安全に使用するために必要な追加の防御を追加するよりも、わずかに高い帯域幅の使用を許容する方が簡単です。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has created a new registry called \"SFrame Cipher Suites\" (Section 8.1) under the \"SFrame\" group registry heading.",
      "ja": "IANAは、「SFRAME」グループレジストリの見出しの下に「SFRAME暗号スイート」（セクション8.1）と呼ばれる新しいレジストリを作成しました。"
    },
    {
      "indent": 0,
      "text": "8.1. SFrame Cipher Suites",
      "section_title": true,
      "ja": "8.1. SFRAME暗号スイート"
    },
    {
      "indent": 3,
      "text": "The \"SFrame Cipher Suites\" registry lists identifiers for SFrame cipher suites as defined in Section 4.5. The cipher suite field is two bytes wide, so the valid cipher suites are in the range 0x0000 to 0xFFFF. Except as noted below, assignments are made via the Specification Required policy [RFC8126].",
      "ja": "セクション4.5で定義されているように、「SFRAME暗号スイート」レジストリはSFRAME暗号スイートの識別子をリストします。暗号スイートフィールドは幅2バイトであるため、有効な暗号スイートは0x0000〜0xffffの範囲にあります。以下の場合を除き、割り当ては、必要なポリシー[RFC8126]を介して行われます。"
    },
    {
      "indent": 3,
      "text": "The registration template is as follows:",
      "ja": "登録テンプレートは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* Value: The numeric value of the cipher suite",
      "ja": "* 値：暗号スイートの数値"
    },
    {
      "indent": 6,
      "text": "* Name: The name of the cipher suite",
      "ja": "* 名前：暗号スイートの名前"
    },
    {
      "indent": 6,
      "text": "* Recommended: Whether support for this cipher suite is recommended by the IETF. Valid values are \"Y\", \"N\", and \"D\" as described in Section 17.1 of [MLS-PROTO]. The default value of the \"Recommended\" column is \"N\". Setting the Recommended item to \"Y\" or \"D\", or changing an item whose current value is \"Y\" or \"D\", requires Standards Action [RFC8126].",
      "ja": "* 推奨：この暗号スイートのサポートがIETFによって推奨されるかどうか。有効な値は、[MLS-Proto]のセクション17.1で説明されているように、「Y」、「N」、および「D」です。「推奨」列のデフォルト値は「n」です。推奨されるアイテムを「Y」または「D」に設定するか、現在の値が「Y」または「D」であるアイテムを変更するには、標準アクション[RFC8126]が必要です。"
    },
    {
      "indent": 6,
      "text": "* Reference: The document where this cipher suite is defined",
      "ja": "* 参照：この暗号スイートが定義されているドキュメント"
    },
    {
      "indent": 6,
      "text": "* Change Controller: Who is authorized to update the row in the registry",
      "ja": "* Change Controller：レジストリで行を更新する権限がある人"
    },
    {
      "indent": 3,
      "text": "Initial contents:",
      "ja": "最初の内容："
    },
    {
      "indent": 3,
      "text": "+========+============================+===+===========+============+\n| Value  | Name                       | R | Reference | Change     |\n|        |                            |   |           | Controller |\n+========+============================+===+===========+============+\n| 0x0000 | Reserved                   | - | RFC 9605  | IETF       |\n+--------+----------------------------+---+-----------+------------+\n| 0x0001 | AES_128_CTR_HMAC_SHA256_80 | Y | RFC 9605  | IETF       |\n+--------+----------------------------+---+-----------+------------+\n| 0x0002 | AES_128_CTR_HMAC_SHA256_64 | Y | RFC 9605  | IETF       |\n+--------+----------------------------+---+-----------+------------+\n| 0x0003 | AES_128_CTR_HMAC_SHA256_32 | Y | RFC 9605  | IETF       |\n+--------+----------------------------+---+-----------+------------+\n| 0x0004 | AES_128_GCM_SHA256_128     | Y | RFC 9605  | IETF       |\n+--------+----------------------------+---+-----------+------------+\n| 0x0005 | AES_256_GCM_SHA512_128     | Y | RFC 9605  | IETF       |\n+--------+----------------------------+---+-----------+------------+\n| 0xF000 | Reserved for Private Use   | - | RFC 9605  | IETF       |\n| -      |                            |   |           |            |\n| 0xFFFF |                            |   |           |            |\n+--------+----------------------------+---+-----------+------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Table 2: SFrame Cipher Suites",
      "ja": "表2：SFRAME暗号スイート"
    },
    {
      "indent": 0,
      "text": "9. Application Responsibilities",
      "section_title": true,
      "ja": "9. アプリケーションの責任"
    },
    {
      "indent": 3,
      "text": "To use SFrame, an application needs to define the inputs to the SFrame encryption and decryption operations, and how SFrame ciphertexts are delivered from sender to receiver (including any fragmentation and reassembly). In this section, we lay out additional requirements that an application must meet in order for SFrame to operate securely.",
      "ja": "SFRAMEを使用するには、アプリケーションでは、SFRAME暗号化と復号化操作への入力を定義する必要があります。SFRAME暗号文が送信者からレシーバーに配信される方法（断片化と再組み立てを含む）。このセクションでは、SFRAMEが安全に動作するためにアプリケーションが満たさなければならないという追加要件をレイアウトします。"
    },
    {
      "indent": 3,
      "text": "In general, an application using SFrame is responsible for configuring SFrame. The application must first define when SFrame is applied at all. When SFrame is applied, the application must define which cipher suite is to be used. If new versions of SFrame are defined in the future, it will be the application's responsibility to determine which version should be used.",
      "ja": "一般に、SFRAMEを使用したアプリケーションは、SFRAMEの構成を担当します。アプリケーションは、最初にSFRAMEがいつ適用されるかを定義する必要があります。SFRAMEが適用される場合、アプリケーションは使用するCipherスイートを定義する必要があります。SFRAMEの新しいバージョンが将来定義されている場合、使用するバージョンを決定することはアプリケーションの責任です。"
    },
    {
      "indent": 3,
      "text": "This division of responsibilities is similar to the way other media parameters (e.g., codecs) are typically handled in media applications, in the sense that they are set up in some signaling protocol and not described in the media. Applications might find it useful to extend the protocols used for negotiating other media parameters (e.g., Session Description Protocol (SDP) [RFC8866]) to also negotiate parameters for SFrame.",
      "ja": "この責任の分割は、他のメディアパラメーター（例：コーデック）が通常、メディアアプリケーションで処理される方法に似ています。アプリケーションは、他のメディアパラメーター（セッション説明プロトコル（SDP）[RFC8866]など）の交渉に使用されるプロトコルを拡張して、SFRAMEのパラメーターも交渉することが有用であると判断される場合があります。"
    },
    {
      "indent": 0,
      "text": "9.1. Header Value Uniqueness",
      "section_title": true,
      "ja": "9.1. ヘッダー値の一意性"
    },
    {
      "indent": 3,
      "text": "Applications MUST ensure that each (base_key, KID, CTR) combination is used for at most one SFrame encryption operation. This ensures that the (key, nonce) pairs used by the underlying AEAD algorithm are never reused. Typically this is done by assigning each sender a KID or set of KIDs, then having each sender use the CTR field as a monotonic counter, incrementing for each plaintext that is encrypted. In addition to its simplicity, this scheme minimizes overhead by keeping CTR values as small as possible.",
      "ja": "アプリケーションは、それぞれ（base_key、kid、ctr）の組み合わせが最大1つのSFRAME暗号化操作に使用されるようにする必要があります。これにより、基礎となるAEADアルゴリズムで使用される（鍵、nonce）ペアが再利用されないことが保証されます。通常、これは各送信者に子供または子供のセットを割り当ててから、各送信者にCTRフィールドを単調なカウンターとして使用させ、暗号化された各プレーンテキストの増加にします。その単純さに加えて、このスキームは、CTRの値を可能な限り小さく保つことにより、オーバーヘッドを最小限に抑えます。"
    },
    {
      "indent": 3,
      "text": "In applications where an SFrame context might be written to persistent storage, this context needs to include the last-used CTR value. When the context is used later, the application should use the stored CTR value to determine the next CTR value to be used in an encryption operation, and then write the next CTR value back to storage before using the CTR value for encryption. Storing the CTR value before usage (vs. after) helps ensure that a storage failure will not cause reuse of the same (base_key, KID, CTR) combination.",
      "ja": "SFRAMEコンテキストが永続的なストレージに書き込まれる可能性のあるアプリケーションでは、このコンテキストには最終使用されたCTR値を含める必要があります。コンテキストを後で使用する場合、アプリケーションは保存されたCTR値を使用して、暗号化操作で使用する次のCTR値を決定し、暗号化にCTR値を使用する前に次のCTR値をストレージに戻します。使用前にCTR値を保存する（vs. after）は、ストレージ障害が同じ（base_key、kid、ctr）の組み合わせの再利用を引き起こさないようにするのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "9.2. Key Management Framework",
      "section_title": true,
      "ja": "9.2. 主要な管理フレームワーク"
    },
    {
      "indent": 3,
      "text": "The application is responsible for provisioning SFrame with a mapping of KID values to base_key values and the resulting keys and salts. More importantly, the application specifies which KID values are used for which purposes (e.g., by which senders). An application's KID assignment strategy MUST be structured to assure the non-reuse properties discussed in Section 9.1.",
      "ja": "このアプリケーションは、Base_Key値と結果のキーと塩へのKID値のマッピングを使用して、SFRAMEをプロビジョニングする責任があります。さらに重要なことは、アプリケーションは、どの子供の価値がどの目的で使用されるか（たとえば、送信者）を指定することです。アプリケーションのKID割り当て戦略は、セクション9.1で議論されている非繰り返し特性を保証するために構成する必要があります。"
    },
    {
      "indent": 3,
      "text": "The application is also responsible for defining a rotation schedule for keys. For example, one application might have an ephemeral group for every call and keep rotating keys when endpoints join or leave the call, while another application could have a persistent group that can be used for multiple calls and simply derives ephemeral symmetric keys for a specific call.",
      "ja": "アプリケーションは、キーの回転スケジュールを定義する責任も担当しています。たとえば、1つのアプリケーションには、呼び出しごとに一時的なグループがあり、エンドポイントが結合またはコールを去るときに回転キーを保持しますが、別のアプリケーションには複数の呼び出しに使用できる永続的なグループがあり、特定の呼び出しのために単純な対称キーを導き出すことができます。。"
    },
    {
      "indent": 3,
      "text": "It should be noted that KID values are not encrypted by SFrame and are thus visible to any application-layer intermediaries that might handle an SFrame ciphertext. If there are application semantics included in KID values, then this information would be exposed to intermediaries. For example, in the scheme of Section 5.1, the number of ratchet steps per sender is exposed, and in the scheme of Section 5.2, the number of epochs and the MLS sender ID of the SFrame sender are exposed.",
      "ja": "KID値はSFRAMEによって暗号化されていないため、SFRAMEの暗号文を処理する可能性のあるアプリケーション層の仲介者に表示されることに注意する必要があります。KID値にアプリケーションセマンティクスが含まれている場合、この情報は仲介者にさらされます。たとえば、セクション5.1のスキームでは、送信者あたりのラチェットステップの数が公開され、セクション5.2のスキームでは、SFRAME送信者のエポックの数とMLS送信者IDが公開されます。"
    },
    {
      "indent": 0,
      "text": "9.3. Anti-Replay",
      "section_title": true,
      "ja": "9.3. アンチレプレイ"
    },
    {
      "indent": 3,
      "text": "It is the responsibility of the application to handle anti-replay. Replay by network attackers is assumed to be prevented by network-layer facilities (e.g., TLS, SRTP). As mentioned in Section 7.4, senders MUST reject requests to encrypt multiple times with the same key and nonce.",
      "ja": "アンチレプレイを処理することは、アプリケーションの責任です。ネットワーク攻撃者によるリプレイは、ネットワーク層施設（TLS、SRTPなど）によって防止されると想定されています。セクション7.4で述べたように、送信者は同じキーとノンセを使用して複数回暗号化するリクエストを拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "It is not mandatory to implement anti-replay on the receiver side. Receivers MAY apply time- or counter-based anti-replay mitigations. For example, Section 3.3.2 of [RFC3711] specifies a counter-based anti-replay mitigation, which could be adapted to use with SFrame, using the CTR field as the counter.",
      "ja": "レシーバー側にアンチレプレイを実装することは必須ではありません。受信者は、時間またはカウンターベースのアンチレプレイ緩和を適用する場合があります。たとえば、[RFC3711]のセクション3.3.2は、CTRフィールドをカウンターとして使用して、SFRAMEで使用するように適合させることができるカウンターベースのアンチレプレイ緩和を指定しています。"
    },
    {
      "indent": 0,
      "text": "9.4. Metadata",
      "section_title": true,
      "ja": "9.4. メタデータ"
    },
    {
      "indent": 3,
      "text": "The metadata input to SFrame operations is an opaque byte string specified by the application. As such, the application needs to define what information should go in the metadata input and ensure that it is provided to the encryption and decryption functions at the appropriate points. A receiver MUST NOT use SFrame-authenticated metadata until after the SFrame decrypt function has authenticated it, unless the purpose of such usage is to prepare an SFrame ciphertext for SFrame decryption. Essentially, metadata may be used \"upstream of SFrame\" in a processing pipeline, but only to prepare for SFrame decryption.",
      "ja": "SFRAME操作へのメタデータ入力は、アプリケーションによって指定された不透明なバイト文字列です。そのため、アプリケーションは、メタデータ入力にどのような情報を入力するかを定義し、適切なポイントで暗号化と復号化機能に提供されることを確認する必要があります。受信者は、SFRAME復号化関数がSFRAME復号化のためにSFRAME暗号文を準備することでない限り、SFRAME復号化関数が認証されるまで、SFRAMEを認証したメタデータを使用してはなりません。基本的に、メタデータは、処理パイプラインで「SFRAMEの上流」を使用することができますが、SFRAMEの復号化の準備にのみ使用できます。"
    },
    {
      "indent": 3,
      "text": "For example, consider an application where SFrame is used to encrypt audio frames that are sent over SRTP, with some application data included in the RTP header extension. Suppose the application also includes this application data in the SFrame metadata, so that the SFU is allowed to read, but not modify, the application data. A receiver can use the application data in the RTP header extension as part of the standard SRTP decryption process since this is required to recover the SFrame ciphertext carried in the SRTP payload. However, the receiver MUST NOT use the application data for other purposes before SFrame decryption has authenticated the application data.",
      "ja": "たとえば、SRTPを介して送信されるオーディオフレームを暗号化するためにSFRAMEを使用して、RTPヘッダー拡張機能にいくつかのアプリケーションデータが含まれているアプリケーションを検討してください。アプリケーションにSFRAMEメタデータにこのアプリケーションデータが含まれているため、SFUがアプリケーションデータの読み取りを許可されているが変更できないと仮定します。レシーバーは、標準のSRTP復号化プロセスの一部としてRTPヘッダー拡張機能のアプリケーションデータを使用できます。これは、SRTPペイロードで運ばれるSFRAME暗号文を回復するために必要です。ただし、SFRAME復号化がアプリケーションデータを認証する前に、受信者は他の目的でアプリケーションデータを使用してはなりません。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[MLS-PROTO]\n           Barnes, R., Beurdouche, B., Robert, R., Millican, J.,\n           Omara, E., and K. Cohn-Gordon, \"The Messaging Layer\n           Security (MLS) Protocol\", RFC 9420, DOI 10.17487/RFC9420,\n           July 2023, <https://www.rfc-editor.org/info/rfc9420>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5116]  McGrew, D., \"An Interface and Algorithms for Authenticated\n           Encryption\", RFC 5116, DOI 10.17487/RFC5116, January 2008,\n           <https://www.rfc-editor.org/info/rfc5116>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5869]  Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand\n           Key Derivation Function (HKDF)\", RFC 5869,\n           DOI 10.17487/RFC5869, May 2010,\n           <https://www.rfc-editor.org/info/rfc5869>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8126]  Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n           Writing an IANA Considerations Section in RFCs\", BCP 26,\n           RFC 8126, DOI 10.17487/RFC8126, June 2017,\n           <https://www.rfc-editor.org/info/rfc8126>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[MLS-ARCH] Beurdouche, B., Rescorla, E., Omara, E., Inguva, S., and\n           A. Duric, \"The Messaging Layer Security (MLS)\n           Architecture\", Work in Progress, Internet-Draft, draft-\n           ietf-mls-architecture-15, 3 August 2024,\n           <https://datatracker.ietf.org/doc/html/draft-ietf-mls-\n           architecture-15>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[MOQ-TRANSPORT]\n           Curley, L., Pugin, K., Nandakumar, S., Vasiliev, V., and\n           I. Swett, Ed., \"Media over QUIC Transport\", Work in\n           Progress, Internet-Draft, draft-ietf-moq-transport-05, 8\n           July 2024, <https://datatracker.ietf.org/doc/html/draft-\n           ietf-moq-transport-05>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC3711]  Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K.\n           Norrman, \"The Secure Real-time Transport Protocol (SRTP)\",\n           RFC 3711, DOI 10.17487/RFC3711, March 2004,\n           <https://www.rfc-editor.org/info/rfc3711>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6716]  Valin, JM., Vos, K., and T. Terriberry, \"Definition of the\n           Opus Audio Codec\", RFC 6716, DOI 10.17487/RFC6716,\n           September 2012, <https://www.rfc-editor.org/info/rfc6716>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7656]  Lennox, J., Gross, K., Nandakumar, S., Salgueiro, G., and\n           B. Burman, Ed., \"A Taxonomy of Semantics and Mechanisms\n           for Real-Time Transport Protocol (RTP) Sources\", RFC 7656,\n           DOI 10.17487/RFC7656, November 2015,\n           <https://www.rfc-editor.org/info/rfc7656>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7667]  Westerlund, M. and S. Wenger, \"RTP Topologies\", RFC 7667,\n           DOI 10.17487/RFC7667, November 2015,\n           <https://www.rfc-editor.org/info/rfc7667>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8723]  Jennings, C., Jones, P., Barnes, R., and A.B. Roach,\n           \"Double Encryption Procedures for the Secure Real-Time\n           Transport Protocol (SRTP)\", RFC 8723,\n           DOI 10.17487/RFC8723, April 2020,\n           <https://www.rfc-editor.org/info/rfc8723>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8866]  Begen, A., Kyzivat, P., Perkins, C., and M. Handley, \"SDP:\n           Session Description Protocol\", RFC 8866,\n           DOI 10.17487/RFC8866, January 2021,\n           <https://www.rfc-editor.org/info/rfc8866>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RTP-PAYLOAD]\n           Murillo, S. G., Fablet, Y., and A. Gouaillard, \"Codec\n           agnostic RTP payload format for video\", Work in Progress,\n           Internet-Draft, draft-gouaillard-avtcore-codec-agn-rtp-\n           payload-01, 9 March 2021,\n           <https://datatracker.ietf.org/doc/html/draft-gouaillard-\n           avtcore-codec-agn-rtp-payload-01>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[TestVectors]\n           \"SFrame Test Vectors\", commit 025d568, September 2023,\n           <https://github.com/sframe-wg/sframe/blob/025d568/test-\n           vectors/test-vectors.json>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[WEBTRANSPORT]\n           Vasiliev, V., \"The WebTransport Protocol Framework\", Work\n           in Progress, Internet-Draft, draft-ietf-webtrans-overview-\n           08, 25 August 2024,\n           <https://datatracker.ietf.org/api/v1/doc/document/draft-\n           ietf-webtrans-overview/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix A. Example API",
      "section_title": true,
      "ja": "付録A. APIの例"
    },
    {
      "indent": 3,
      "text": "*This section is not normative.*",
      "ja": "*このセクションは規範的ではありません。*"
    },
    {
      "indent": 3,
      "text": "This section describes a notional API that an SFrame implementation might expose. The core concept is an \"SFrame context\", within which KID values are meaningful. In the key management scheme described in Section 5.1, each sender has a different context; in the scheme described in Section 5.2, all senders share the same context.",
      "ja": "このセクションでは、SFRAMEの実装が公開される可能性のある概念的APIについて説明します。コアコンセプトは「SFRAMEコンテキスト」であり、その中は子供の価値が意味があります。セクション5.1で説明されている主要な管理スキームでは、各送信者には異なるコンテキストがあります。セクション5.2で説明したスキームでは、すべての送信者が同じコンテキストを共有しています。"
    },
    {
      "indent": 3,
      "text": "An SFrame context stores mappings from KID values to \"key contexts\", which are different depending on whether the KID is to be used for sending or receiving (an SFrame key should never be used for both operations). A key context tracks the key and salt associated to the KID, and the current CTR value. A key context to be used for sending also tracks the next CTR value to be used.",
      "ja": "SFRAMEコンテキストは、子供の値から「キーコンテキスト」へのマッピングを保存します。これは、子供が送信または受信に使用されるかどうかによって異なります（SFRAMEキーは両方の操作に使用してはなりません）。キーコンテキストは、子供に関連するキーと塩、および現在のCTR値を追跡します。送信に使用される重要なコンテキストは、使用する次のCTR値も追跡します。"
    },
    {
      "indent": 3,
      "text": "The primary operations on an SFrame context are as follows:",
      "ja": "SFRAMEコンテキストでの主要な操作は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* *Create an SFrame context:* The context is initialized with a cipher suite and no KID mappings.",
      "ja": "* * SFRAMEコンテキストの作成：*コンテキストは、暗号スイートとキッドマッピングなしで初期化されます。"
    },
    {
      "indent": 6,
      "text": "* *Add a key for sending:* The key and salt are derived from the base key and used to initialize a send context, together with a zero CTR value.",
      "ja": "* *次のキーを追加します。*キーと塩はベースキーから派生し、ゼロCTR値とともに送信コンテキストを初期化するために使用されます。"
    },
    {
      "indent": 6,
      "text": "* *Add a key for receiving:* The key and salt are derived from the base key and used to initialize a send context.",
      "ja": "* *受信のキーを追加します。*キーと塩はベースキーから派生し、送信コンテキストの初期化に使用されます。"
    },
    {
      "indent": 6,
      "text": "* *Encrypt a plaintext:* Encrypt a given plaintext using the key for a given KID, including the specified metadata.",
      "ja": "* *プレーンテキストを暗号化します。"
    },
    {
      "indent": 6,
      "text": "* *Decrypt an SFrame ciphertext:* Decrypt an SFrame ciphertext with the KID and CTR values specified in the SFrame header, and the provided metadata.",
      "ja": "* * sframe ciphertextを復号化します。"
    },
    {
      "indent": 3,
      "text": "Figure 10 shows an example of the types of structures and methods that could be used to create an SFrame API in Rust.",
      "ja": "図10は、錆のSFRAME APIを作成するために使用できる構造の種類と方法の例を示しています。"
    },
    {
      "indent": 3,
      "text": "type KeyId = u64;\ntype Counter = u64;\ntype CipherSuite = u16;\n\nstruct SendKeyContext {\n  key: Vec<u8>,\n  salt: Vec<u8>,\n  next_counter: Counter,\n}\n\nstruct RecvKeyContext {\n  key: Vec<u8>,\n  salt: Vec<u8>,\n}\n\nstruct SFrameContext {\n  cipher_suite: CipherSuite,\n  send_keys: HashMap<KeyId, SendKeyContext>,\n  recv_keys: HashMap<KeyId, RecvKeyContext>,\n}\n\ntrait SFrameContextMethods {\n  fn create(cipher_suite: CipherSuite) -> Self;\n  fn add_send_key(&self, kid: KeyId, base_key: &[u8]);\n  fn add_recv_key(&self, kid: KeyId, base_key: &[u8]);\n  fn encrypt(&mut self, kid: KeyId, metadata: &[u8],\n             plaintext: &[u8]) -> Vec<u8>;\n  fn decrypt(&self, metadata: &[u8], ciphertext: &[u8]) -> Vec<u8>;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 10: An Example SFrame API",
      "ja": "図10：SFRAME APIの例"
    },
    {
      "indent": 0,
      "text": "Appendix B. Overhead Analysis",
      "section_title": true,
      "ja": "付録B. オーバーヘッド分析"
    },
    {
      "indent": 3,
      "text": "Any use of SFrame will impose overhead in terms of the amount of bandwidth necessary to transmit a given media stream. Exactly how much overhead will be added depends on several factors:",
      "ja": "SFRAMEを使用すると、特定のメディアストリームを送信するのに必要な帯域幅の量の観点から頭上が課されます。正確にオーバーヘッドが追加されるかは、いくつかの要因によって異なります。"
    },
    {
      "indent": 6,
      "text": "* The number of senders involved in a conference (length of KID)",
      "ja": "* 会議に関与する送信者の数（子供の長さ）"
    },
    {
      "indent": 6,
      "text": "* The duration of the conference (length of CTR)",
      "ja": "* 会議の期間（CTRの長さ）"
    },
    {
      "indent": 6,
      "text": "* The cipher suite in use (length of authentication tag)",
      "ja": "* 使用中の暗号スイート（認証タグの長さ）"
    },
    {
      "indent": 6,
      "text": "* Whether SFrame is used to encrypt packets, whole frames, or some other unit",
      "ja": "* SFRAMEがパケット、全体のフレーム、またはその他のユニットを暗号化するために使用されるかどうか"
    },
    {
      "indent": 3,
      "text": "Overall, the overhead rate in kilobits per second can be estimated as:",
      "ja": "全体として、1秒あたりのキロビットのオーバーヘッドレートは、次のように推定できます。"
    },
    {
      "indent": 3,
      "text": "OverheadKbps = (1 + |CTR| + |KID| + |TAG|) * 8 * CTPerSecond / 1024",
      "ja": "anuverheadkbps =（1 + | ctr | + | kid | + | tag |） * 8 * ctpersecond / 1024"
    },
    {
      "indent": 3,
      "text": "Here the constant value 1 reflects the fixed SFrame header; |CTR| and |KID| reflect the lengths of those fields; |TAG| reflects the cipher overhead; and CTPerSecond reflects the number of SFrame ciphertexts sent per second (e.g., packets or frames per second).",
      "ja": "ここでは、定数値1が固定されたSFRAMEヘッダーを反映しています。| ctr |そして|キッド|これらのフィールドの長さを反映します。|タグ|暗号のオーバーヘッドを反映します。また、CTPERSECONDは、1秒あたりの送信されたSFRAME暗号文の数（たとえば、1秒あたりのパケットまたはフレームなど）を反映しています。"
    },
    {
      "indent": 3,
      "text": "In the remainder of this section, we compute overhead estimates for a collection of common scenarios.",
      "ja": "このセクションの残りの部分では、一般的なシナリオのコレクションのオーバーヘッド推定値を計算します。"
    },
    {
      "indent": 0,
      "text": "B.1. Assumptions",
      "section_title": true,
      "ja": "B.1. 仮定"
    },
    {
      "indent": 3,
      "text": "In the below calculations, we make conservative assumptions about SFrame overhead so that the overhead amounts we compute here are likely to be an upper bound of those seen in practice.",
      "ja": "以下の計算では、SFRAMEオーバーヘッドについて保守的な仮定を行い、ここで計算するオーバーヘッド量は実際に見られるものの上限である可能性があります。"
    },
    {
      "indent": 11,
      "text": "+==============+=======+============================+\n| Field        | Bytes | Explanation                |\n+==============+=======+============================+\n| Config byte  |     1 | Fixed                      |\n+--------------+-------+----------------------------+\n| Key ID (KID) |     2 | >255 senders; or MLS epoch |\n|              |       | (E=4) and >16 senders      |\n+--------------+-------+----------------------------+\n| Counter      |     3 | More than 24 hours of      |\n| (CTR)        |       | media in common cases      |\n+--------------+-------+----------------------------+\n| Cipher       |    16 | Full authentication tag    |\n| overhead     |       | (longest defined here)     |\n+--------------+-------+----------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Table 3: Overhead Analysis Assumptions",
      "ja": "表3：オーバーヘッド分析の仮定"
    },
    {
      "indent": 3,
      "text": "In total, then, we assume that each SFrame encryption will add 22 bytes of overhead.",
      "ja": "合計で、各SFRAME暗号化が22バイトのオーバーヘッドを追加すると仮定します。"
    },
    {
      "indent": 3,
      "text": "We consider two scenarios: applying SFrame per frame and per packet. In each scenario, we compute the SFrame overhead in absolute terms (kbps) and as a percentage of the base bandwidth.",
      "ja": "2つのシナリオを検討します。フレームごととパケットごとにSFRAMEを適用することです。各シナリオでは、SFRAMEオーバーヘッドを絶対用語（KBPS）で計算し、ベース帯域幅の一部として計算します。"
    },
    {
      "indent": 0,
      "text": "B.2. Audio",
      "section_title": true,
      "ja": "B.2. オーディオ"
    },
    {
      "indent": 3,
      "text": "In audio streams, there is typically a one-to-one relationship between frames and packets, so the overhead is the same whether one uses SFrame at a per-packet or per-frame level.",
      "ja": "オーディオストリームでは、通常、フレームとパケットの間に1対1の関係があるため、オーバーヘッドは、パケットごとのレベルでSFRAMEを使用するか、フレームごとのレベルで使用するかどうかと同じです。"
    },
    {
      "indent": 3,
      "text": "Table 4 considers three scenarios that are based on recommended configurations of the Opus codec [RFC6716] (where \"fps\" stands for \"frames per second\"):",
      "ja": "表4では、OPUSコーデックの推奨構成[RFC6716]（「FPS」は「フレームあたりのフレーム」を表す）に基づいた3つのシナリオを検討します。"
    },
    {
      "indent": 4,
      "text": "+==============+==============+=====+======+==========+==========+\n| Scenario     | Frame length | fps | Base | Overhead | Overhead |\n|              |              |     | kbps |   kbps   |    %     |\n+==============+==============+=====+======+==========+==========+\n| Narrow-band  |    120 ms    | 8.3 |  8   |   1.4    |  17.9%   |\n| speech       |              |     |      |          |          |\n+--------------+--------------+-----+------+----------+----------+\n| Full-band    |    20 ms     |  50 |  32  |   8.6    |  26.9%   |\n| speech       |              |     |      |          |          |\n+--------------+--------------+-----+------+----------+----------+\n| Full-band    |    10 ms     | 100 | 128  |   17.2   |  13.4%   |\n| stereo music |              |     |      |          |          |\n+--------------+--------------+-----+------+----------+----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Table 4: SFrame Overhead for Audio Streams",
      "ja": "表4：オーディオストリームのSFRAMEオーバーヘッド"
    },
    {
      "indent": 0,
      "text": "B.3. Video",
      "section_title": true,
      "ja": "B.3. ビデオ"
    },
    {
      "indent": 3,
      "text": "Video frames can be larger than an MTU and thus are commonly split across multiple frames. Tables 5 and 6 show the estimated overhead of encrypting a video stream, where SFrame is applied per frame and per packet, respectively. The choices of resolution, frames per second, and bandwidth roughly reflect the capabilities of modern video codecs across a range from very low to very high quality.",
      "ja": "ビデオフレームはMTUよりも大きくなる可能性があるため、一般的に複数のフレームに分割されます。表5と6は、ビデオストリームを暗号化する推定オーバーヘッドを示しています。ここでは、SFRAMEがそれぞれフレームとパケットごとに適用されます。解像度の選択、1秒あたりのフレーム、および帯域幅は、非常に低いものから非常に高品質までの範囲にわたる最新のビデオコーデックの機能をほぼ反映しています。"
    },
    {
      "indent": 6,
      "text": "+=============+=====+===========+===============+============+\n| Scenario    | fps | Base kbps | Overhead kbps | Overhead % |\n+=============+=====+===========+===============+============+\n| 426 x 240   | 7.5 |     45    |      1.3      |    2.9%    |\n+-------------+-----+-----------+---------------+------------+\n| 640 x 360   |  15 |    200    |      2.6      |    1.3%    |\n+-------------+-----+-----------+---------------+------------+\n| 640 x 360   |  30 |    400    |      5.2      |    1.3%    |\n+-------------+-----+-----------+---------------+------------+\n| 1280 x 720  |  30 |    1500   |      5.2      |    0.3%    |\n+-------------+-----+-----------+---------------+------------+\n| 1920 x 1080 |  60 |    7200   |      10.3     |    0.1%    |\n+-------------+-----+-----------+---------------+------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Table 5: SFrame Overhead for a Video Stream Encrypted per Frame",
      "ja": "表5：フレームごとに暗号化されたビデオストリームのSFRAMEオーバーヘッド"
    },
    {
      "indent": 6,
      "text": "+==========+=====+==============+======+==========+==========+\n| Scenario | fps | Packets per  | Base | Overhead | Overhead |\n|          |     | Second (pps) | kbps |   kbps   |    %     |\n+==========+=====+==============+======+==========+==========+\n| 426 x    | 7.5 |     7.5      |  45  |   1.3    |   2.9%   |\n| 240      |     |              |      |          |          |\n+----------+-----+--------------+------+----------+----------+\n| 640 x    |  15 |      30      | 200  |   5.2    |   2.6%   |\n| 360      |     |              |      |          |          |\n+----------+-----+--------------+------+----------+----------+\n| 640 x    |  30 |      60      | 400  |   10.3   |   2.6%   |\n| 360      |     |              |      |          |          |\n+----------+-----+--------------+------+----------+----------+\n| 1280 x   |  30 |     180      | 1500 |   30.9   |   2.1%   |\n| 720      |     |              |      |          |          |\n+----------+-----+--------------+------+----------+----------+\n| 1920 x   |  60 |     780      | 7200 |  134.1   |   1.9%   |\n| 1080     |     |              |      |          |          |\n+----------+-----+--------------+------+----------+----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Table 6: SFrame Overhead for a Video Stream Encrypted per Packet",
      "ja": "表6：パケットごとに暗号化されたビデオストリームのSFRAMEオーバーヘッド"
    },
    {
      "indent": 3,
      "text": "In the per-frame case, the SFrame percentage overhead approaches zero as the quality of the video improves since bandwidth is driven more by picture size than frame rate. In the per-packet case, the SFrame percentage overhead approaches the ratio between the SFrame overhead per packet and the MTU (here 22 bytes of SFrame overhead divided by an assumed 1200-byte MTU, or about 1.8%).",
      "ja": "フラームごとの場合、帯域幅はフレームレートよりも画像サイズによって駆動されるため、ビデオの品質が向上するにつれて、SFRAMEパーセンテージのオーバーヘッドはゼロに近づきます。パケットごとの場合、SFRAMEパーセンテージのオーバーヘッドは、パケットごとのSFRAMEオーバーヘッドとMTUの比率に近づきます（ここでは、想定される1200バイトMTU、つまり約1.8％でSFRAMEオーバーヘッドを22バイトで割ったもの）。"
    },
    {
      "indent": 0,
      "text": "B.4. Conferences",
      "section_title": true,
      "ja": "B.4. 会議"
    },
    {
      "indent": 3,
      "text": "Real conferences usually involve several audio and video streams. The overhead of SFrame in such a conference is the aggregate of the overhead across all the individual streams. Thus, while SFrame incurs a large percentage overhead on an audio stream, if the conference also involves a video stream, then the audio overhead is likely negligible relative to the overall bandwidth of the conference.",
      "ja": "実際の会議には、通常、いくつかのオーディオおよびビデオストリームが含まれます。このような会議でのSFRAMEのオーバーヘッドは、すべての個々のストリームにわたるオーバーヘッドの集合体です。したがって、SFRAMEはオーディオストリームに大きな割合のオーバーヘッドを発生させますが、会議にビデオストリームも含まれる場合、オーディオオーバーヘッドは会議の全体的な帯域幅に比べて無視できる可能性があります。"
    },
    {
      "indent": 3,
      "text": "For example, Table 7 shows the overhead estimates for a two-person conference where one person is sending low-quality media and the other is sending high-quality media. (And we assume that SFrame is applied per frame.) The video streams dominate the bandwidth at the SFU, so the total bandwidth overhead is only around 1%.",
      "ja": "たとえば、表7は、1人の人が低品質のメディアを送信し、もう1人が高品質のメディアを送信している2人の会議のオーバーヘッド推定値を示しています。（そして、SFRAMEがフレームごとに適用されると仮定します。）ビデオストリームはSFUの帯域幅を支配しているため、帯域幅の合計オーバーヘッドは約1％に過ぎません。"
    },
    {
      "indent": 5,
      "text": "+=====================+===========+===============+============+\n| Stream              | Base Kbps | Overhead Kbps | Overhead % |\n+=====================+===========+===============+============+\n| Participant 1 audio |     8     |      1.4      |   17.9%    |\n+---------------------+-----------+---------------+------------+\n| Participant 1 video |     45    |      1.3      |    2.9%    |\n+---------------------+-----------+---------------+------------+\n| Participant 2 audio |     32    |       9       |   26.9%    |\n+---------------------+-----------+---------------+------------+\n| Participant 2 video |    1500   |       5       |    0.3%    |\n+---------------------+-----------+---------------+------------+\n| Total at SFU        |    1585   |      16.5     |    1.0%    |\n+---------------------+-----------+---------------+------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Table 7: SFrame Overhead for a Two-Person Conference",
      "ja": "表7：2人の会議のSFRAMEオーバーヘッド"
    },
    {
      "indent": 0,
      "text": "B.5. SFrame over RTP",
      "section_title": true,
      "ja": "B.5. rtpを超えるsframe"
    },
    {
      "indent": 3,
      "text": "SFrame is a generic encapsulation format, but many of the applications in which it is likely to be integrated are based on RTP. This section discusses how an integration between SFrame and RTP could be done, and some of the challenges that would need to be overcome.",
      "ja": "SFRAMEは一般的なカプセル化形式ですが、統合される可能性が高いアプリケーションの多くはRTPに基づいています。このセクションでは、SFRAMEとRTPの統合がどのように行われるか、および克服する必要がある課題のいくつかについて説明します。"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 4.1, there are two natural patterns for integrating SFrame into an application: applying SFrame per frame or per packet. In RTP-based applications, applying SFrame per packet means that the payload of each RTP packet will be an SFrame ciphertext, starting with an SFrame header, as shown in Figure 11. Applying SFrame per frame means that different RTP payloads will have different formats: The first payload of a frame will contain the SFrame headers, and subsequent payloads will contain further chunks of the ciphertext, as shown in Figure 12.",
      "ja": "セクション4.1で説明したように、SFRAMEをアプリケーションに統合するための2つの自然なパターンがあります。フレームごとまたはパケットごとのSFRAMEを適用します。RTPベースのアプリケーションでは、パケットごとのSFRAMEを適用することは、図11に示すように、各RTPパケットのペイロードがSFRAMEヘッダーから始まるSFRAME暗号文になることを意味します。フレームの最初のペイロードにはSFRAMEヘッダーが含まれ、その後のペイロードには、図12に示すように、暗号文のさらなるチャンクが含まれます。"
    },
    {
      "indent": 3,
      "text": "In order for these media payloads to be properly interpreted by receivers, receivers will need to be configured to know which of the above schemes the sender has applied to a given sequence of RTP packets. SFrame does not provide a mechanism for distributing this configuration information. In applications that use SDP for negotiating RTP media streams [RFC8866], an appropriate extension to SDP could provide this function.",
      "ja": "これらのメディアペイロードを受信機によって適切に解釈するためには、受信者を構成する必要があります。SFRAMEは、この構成情報を配布するためのメカニズムを提供しません。RTPメディアストリーム[RFC8866]の交渉にSDPを使用するアプリケーションでは、SDPへの適切な拡張がこの機能を提供する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Applying SFrame per frame also requires that packetization and depacketization be done in a generic manner that does not depend on the media content of the packets, since the content being packetized or depacketized will be opaque ciphertext (except for the SFrame header). In order for such a generic packetization scheme to work interoperably, one would have to be defined, e.g., as proposed in [RTP-PAYLOAD].",
      "ja": "フレームごとのSFRAMEを適用するには、パケット化またはデパケット化されたコンテンツが不透明な暗号文であるため、パケットのメディアコンテンツに依存しない一般的な方法でパケット化とデパケット化を行う必要があります（SFRAMEヘッダーを除く）。このような一般的なパケット化スキームが相互に動作するためには、[RTP-Payload]で提案されているように、たとえば定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "   +---+-+-+-------+-+-----------+------------------------------+<-+\n   |V=2|P|X|  CC   |M|     PT    |       sequence number        |  |\n   +---+-+-+-------+-+-----------+------------------------------+  |\n   |                          timestamp                         |  |\n   +------------------------------------------------------------+  |\n   |          synchronization source (SSRC) identifier          |  |\n   +============================================================+  |\n   |           contributing source (CSRC) identifiers           |  |\n   |                              ....                          |  |\n   +------------------------------------------------------------+  |\n   |                  RTP extension(s) (OPTIONAL)               |  |\n+->+-------------------+----------------------------------------+  |\n|  |  SFrame header    |                                        |  |\n|  +-------------------+                                        |  |\n|  |                                                            |  |\n|  |         SFrame encrypted and authenticated payload         |  |\n|  |                                                            |  |\n+->+------------------------------------------------------------+<-+\n|  |                   SRTP authentication tag                  |  |\n|  +------------------------------------------------------------+  |\n|                                                                  |\n+--- SRTP Encrypted Portion          SRTP Authenticated Portion ---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "Figure 11: SRTP Packet with SFrame-Protected Payload",
      "ja": "図11：SFRAME保護されたペイロードを備えたSRTPパケット"
    },
    {
      "indent": 3,
      "text": "   +----------------+  +---------------+\n   | frame metadata |  |               |\n   +-------+--------+  |               |\n           |           |     frame     |\n           |           |               |\n           |           |               |\n           |           +-------+-------+\n           |                   |\n           |                   |\n           V                   V\n+--------------------------------------+\n|            SFrame Encrypt            |\n+--------------------------------------+\n   |                           |\n   |                           |\n   |                           V\n   |                   +-------+-------+\n   |                   |               |\n   |                   |               |\n   |                   |   encrypted   |\n   |                   |     frame     |\n   |                   |               |\n   |                   |               |\n   |                   +-------+-------+\n   |                           |\n   |                  generic RTP packetize\n   |                           |\n   |    +----------------------+--------.....--------+\n   |    |                      |                     |\n   V    V                      V                     V\n+---------------+      +---------------+     +---------------+\n| SFrame header |      |               |     |               |\n+---------------+      |               |     |               |\n|               |      |  payload 2/N  | ... |  payload N/N  |\n|  payload 1/N  |      |               |     |               |\n|               |      |               |     |               |\n+---------------+      +---------------+     +---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 12: Encryption Flow with per-Frame Encryption for RTP",
      "ja": "図12：RTPのフレームごとの暗号化による暗号化フロー"
    },
    {
      "indent": 0,
      "text": "Appendix C. Test Vectors",
      "section_title": true,
      "ja": "付録C. テストベクトル"
    },
    {
      "indent": 3,
      "text": "This section provides a set of test vectors that implementations can use to verify that they correctly implement SFrame encryption and decryption. In addition to test vectors for the overall process of SFrame encryption/decryption, we also provide test vectors for header encoding/decoding, and for AEAD encryption/decryption using the AES-CTR construction defined in Section 4.5.1.",
      "ja": "このセクションでは、実装がSFRAME暗号化と復号化を正しく実装することを確認するために使用できる一連のテストベクトルを提供します。SFRAME暗号化/復号化の全体的なプロセスのテストベクトルに加えて、ヘッダーエンコード/デコード、およびセクション4.5.1で定義されたAES-CTR構造を使用したAEAD暗号化/復号化のテストベクトルも提供します。"
    },
    {
      "indent": 3,
      "text": "All values are either numeric or byte strings. Numeric values are represented as hex values, prefixed with 0x. Byte strings are represented in hex encoding.",
      "ja": "すべての値は、数値またはバイト文字列のいずれかです。数値は、0xが付いた16進値として表されます。バイト文字列はヘックスエンコーディングで表されます。"
    },
    {
      "indent": 3,
      "text": "Line breaks and whitespace within values are inserted to conform to the width requirements of the RFC format. They should be removed before use.",
      "ja": "RFC形式の幅要件に準拠するために、値内のラインブレークとホワイトスペースが挿入されます。使用する前に削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "These test vectors are also available in JSON format at [TestVectors]. In the JSON test vectors, numeric values are JSON numbers and byte string values are JSON strings containing the hex encoding of the byte strings.",
      "ja": "これらのテストベクトルは、[TestVectors]でJSON形式でも利用できます。JSONテストベクトルでは、数値はJSON番号であり、バイト文字列値はバイト文字列のヘックスエンコードを含むJSON文字列です。"
    },
    {
      "indent": 0,
      "text": "C.1. Header Encoding/Decoding",
      "section_title": true,
      "ja": "C.1. ヘッダーエンコード/デコード"
    },
    {
      "indent": 3,
      "text": "For each case, we provide:",
      "ja": "各ケースについて、次のことを提供します。"
    },
    {
      "indent": 6,
      "text": "* kid: A KID value",
      "ja": "* 子供：子供の価値"
    },
    {
      "indent": 6,
      "text": "* ctr: A CTR value",
      "ja": "* CTR：CTR値"
    },
    {
      "indent": 6,
      "text": "* header: An encoded SFrame header",
      "ja": "* ヘッダー：エンコードされたSFRAMEヘッダー"
    },
    {
      "indent": 3,
      "text": "An implementation should verify that:",
      "ja": "実装はそれを確認する必要があります："
    },
    {
      "indent": 6,
      "text": "* Encoding a header with the KID and CTR results in the provided header value",
      "ja": "* 子供とCTRとヘッダーをエンコードすると、提供されたヘッダー値が得られます"
    },
    {
      "indent": 6,
      "text": "* Decoding the provided header value results in the provided KID and CTR values",
      "ja": "* 提供されたヘッダー値をデコードすると、提供された子供とCTRの値が得られます"
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000000\nctr: 0x0000000000000000\nheader: 00",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000000\nctr: 0x0000000000000001\nheader: 01",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000000\nctr: 0x00000000000000ff\nheader: 08ff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000000\nctr: 0x0000000000000100\nheader: 090100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000000\nctr: 0x000000000000ffff\nheader: 09ffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000000\nctr: 0x0000000000010000\nheader: 0a010000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000000\nctr: 0x0000000000ffffff\nheader: 0affffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000000\nctr: 0x0000000001000000\nheader: 0b01000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000000\nctr: 0x00000000ffffffff\nheader: 0bffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000000\nctr: 0x0000000100000000\nheader: 0c0100000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000000\nctr: 0x000000ffffffffff\nheader: 0cffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000000\nctr: 0x0000010000000000\nheader: 0d010000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000000\nctr: 0x0000ffffffffffff\nheader: 0dffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000000\nctr: 0x0001000000000000\nheader: 0e01000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000000\nctr: 0x00ffffffffffffff\nheader: 0effffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000000\nctr: 0x0100000000000000\nheader: 0f0100000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000000\nctr: 0xffffffffffffffff\nheader: 0fffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000001\nctr: 0x0000000000000000\nheader: 10",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000001\nctr: 0x0000000000000001\nheader: 11",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000001\nctr: 0x00000000000000ff\nheader: 18ff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000001\nctr: 0x0000000000000100\nheader: 190100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000001\nctr: 0x000000000000ffff\nheader: 19ffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000001\nctr: 0x0000000000010000\nheader: 1a010000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000001\nctr: 0x0000000000ffffff\nheader: 1affffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000001\nctr: 0x0000000001000000\nheader: 1b01000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000001\nctr: 0x00000000ffffffff\nheader: 1bffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000001\nctr: 0x0000000100000000\nheader: 1c0100000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000001\nctr: 0x000000ffffffffff\nheader: 1cffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000001\nctr: 0x0000010000000000\nheader: 1d010000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000001\nctr: 0x0000ffffffffffff\nheader: 1dffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000001\nctr: 0x0001000000000000\nheader: 1e01000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000001\nctr: 0x00ffffffffffffff\nheader: 1effffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000001\nctr: 0x0100000000000000\nheader: 1f0100000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000001\nctr: 0xffffffffffffffff\nheader: 1fffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000000000ff\nctr: 0x0000000000000000\nheader: 80ff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000000000ff\nctr: 0x0000000000000001\nheader: 81ff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000000000ff\nctr: 0x00000000000000ff\nheader: 88ffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000000000ff\nctr: 0x0000000000000100\nheader: 89ff0100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000000000ff\nctr: 0x000000000000ffff\nheader: 89ffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000000000ff\nctr: 0x0000000000010000\nheader: 8aff010000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000000000ff\nctr: 0x0000000000ffffff\nheader: 8affffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000000000ff\nctr: 0x0000000001000000\nheader: 8bff01000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000000000ff\nctr: 0x00000000ffffffff\nheader: 8bffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000000000ff\nctr: 0x0000000100000000\nheader: 8cff0100000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000000000ff\nctr: 0x000000ffffffffff\nheader: 8cffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000000000ff\nctr: 0x0000010000000000\nheader: 8dff010000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000000000ff\nctr: 0x0000ffffffffffff\nheader: 8dffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000000000ff\nctr: 0x0001000000000000\nheader: 8eff01000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000000000ff\nctr: 0x00ffffffffffffff\nheader: 8effffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000000000ff\nctr: 0x0100000000000000\nheader: 8fff0100000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000000000ff\nctr: 0xffffffffffffffff\nheader: 8fffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000100\nctr: 0x0000000000000000\nheader: 900100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000100\nctr: 0x0000000000000001\nheader: 910100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000100\nctr: 0x00000000000000ff\nheader: 980100ff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000100\nctr: 0x0000000000000100\nheader: 9901000100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000100\nctr: 0x000000000000ffff\nheader: 990100ffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000100\nctr: 0x0000000000010000\nheader: 9a0100010000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000100\nctr: 0x0000000000ffffff\nheader: 9a0100ffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000100\nctr: 0x0000000001000000\nheader: 9b010001000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000100\nctr: 0x00000000ffffffff\nheader: 9b0100ffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000100\nctr: 0x0000000100000000\nheader: 9c01000100000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000100\nctr: 0x000000ffffffffff\nheader: 9c0100ffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000100\nctr: 0x0000010000000000\nheader: 9d0100010000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000100\nctr: 0x0000ffffffffffff\nheader: 9d0100ffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000100\nctr: 0x0001000000000000\nheader: 9e010001000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000100\nctr: 0x00ffffffffffffff\nheader: 9e0100ffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000100\nctr: 0x0100000000000000\nheader: 9f01000100000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000000100\nctr: 0xffffffffffffffff\nheader: 9f0100ffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000000000ffff\nctr: 0x0000000000000000\nheader: 90ffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000000000ffff\nctr: 0x0000000000000001\nheader: 91ffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000000000ffff\nctr: 0x00000000000000ff\nheader: 98ffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000000000ffff\nctr: 0x0000000000000100\nheader: 99ffff0100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000000000ffff\nctr: 0x000000000000ffff\nheader: 99ffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000000000ffff\nctr: 0x0000000000010000\nheader: 9affff010000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000000000ffff\nctr: 0x0000000000ffffff\nheader: 9affffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000000000ffff\nctr: 0x0000000001000000\nheader: 9bffff01000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000000000ffff\nctr: 0x00000000ffffffff\nheader: 9bffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000000000ffff\nctr: 0x0000000100000000\nheader: 9cffff0100000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000000000ffff\nctr: 0x000000ffffffffff\nheader: 9cffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000000000ffff\nctr: 0x0000010000000000\nheader: 9dffff010000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000000000ffff\nctr: 0x0000ffffffffffff\nheader: 9dffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000000000ffff\nctr: 0x0001000000000000\nheader: 9effff01000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000000000ffff\nctr: 0x00ffffffffffffff\nheader: 9effffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000000000ffff\nctr: 0x0100000000000000\nheader: 9fffff0100000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000000000ffff\nctr: 0xffffffffffffffff\nheader: 9fffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000010000\nctr: 0x0000000000000000\nheader: a0010000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000010000\nctr: 0x0000000000000001\nheader: a1010000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000010000\nctr: 0x00000000000000ff\nheader: a8010000ff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000010000\nctr: 0x0000000000000100\nheader: a90100000100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000010000\nctr: 0x000000000000ffff\nheader: a9010000ffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000010000\nctr: 0x0000000000010000\nheader: aa010000010000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000010000\nctr: 0x0000000000ffffff\nheader: aa010000ffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000010000\nctr: 0x0000000001000000\nheader: ab01000001000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000010000\nctr: 0x00000000ffffffff\nheader: ab010000ffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000010000\nctr: 0x0000000100000000\nheader: ac0100000100000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000010000\nctr: 0x000000ffffffffff\nheader: ac010000ffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000010000\nctr: 0x0000010000000000\nheader: ad010000010000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000010000\nctr: 0x0000ffffffffffff\nheader: ad010000ffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000010000\nctr: 0x0001000000000000\nheader: ae01000001000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000010000\nctr: 0x00ffffffffffffff\nheader: ae010000ffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000010000\nctr: 0x0100000000000000\nheader: af0100000100000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000010000\nctr: 0xffffffffffffffff\nheader: af010000ffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000ffffff\nctr: 0x0000000000000000\nheader: a0ffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000ffffff\nctr: 0x0000000000000001\nheader: a1ffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000ffffff\nctr: 0x00000000000000ff\nheader: a8ffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000ffffff\nctr: 0x0000000000000100\nheader: a9ffffff0100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000ffffff\nctr: 0x000000000000ffff\nheader: a9ffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000ffffff\nctr: 0x0000000000010000\nheader: aaffffff010000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000ffffff\nctr: 0x0000000000ffffff\nheader: aaffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000ffffff\nctr: 0x0000000001000000\nheader: abffffff01000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000ffffff\nctr: 0x00000000ffffffff\nheader: abffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000ffffff\nctr: 0x0000000100000000\nheader: acffffff0100000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000ffffff\nctr: 0x000000ffffffffff\nheader: acffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000ffffff\nctr: 0x0000010000000000\nheader: adffffff010000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000ffffff\nctr: 0x0000ffffffffffff\nheader: adffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000ffffff\nctr: 0x0001000000000000\nheader: aeffffff01000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000ffffff\nctr: 0x00ffffffffffffff\nheader: aeffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000ffffff\nctr: 0x0100000000000000\nheader: afffffff0100000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000000ffffff\nctr: 0xffffffffffffffff\nheader: afffffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000001000000\nctr: 0x0000000000000000\nheader: b001000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000001000000\nctr: 0x0000000000000001\nheader: b101000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000001000000\nctr: 0x00000000000000ff\nheader: b801000000ff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000001000000\nctr: 0x0000000000000100\nheader: b9010000000100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000001000000\nctr: 0x000000000000ffff\nheader: b901000000ffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000001000000\nctr: 0x0000000000010000\nheader: ba01000000010000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000001000000\nctr: 0x0000000000ffffff\nheader: ba01000000ffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000001000000\nctr: 0x0000000001000000\nheader: bb0100000001000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000001000000\nctr: 0x00000000ffffffff\nheader: bb01000000ffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000001000000\nctr: 0x0000000100000000\nheader: bc010000000100000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000001000000\nctr: 0x000000ffffffffff\nheader: bc01000000ffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000001000000\nctr: 0x0000010000000000\nheader: bd01000000010000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000001000000\nctr: 0x0000ffffffffffff\nheader: bd01000000ffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000001000000\nctr: 0x0001000000000000\nheader: be0100000001000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000001000000\nctr: 0x00ffffffffffffff\nheader: be01000000ffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000001000000\nctr: 0x0100000000000000\nheader: bf010000000100000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000001000000\nctr: 0xffffffffffffffff\nheader: bf01000000ffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000ffffffff\nctr: 0x0000000000000000\nheader: b0ffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000ffffffff\nctr: 0x0000000000000001\nheader: b1ffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000ffffffff\nctr: 0x00000000000000ff\nheader: b8ffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000ffffffff\nctr: 0x0000000000000100\nheader: b9ffffffff0100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000ffffffff\nctr: 0x000000000000ffff\nheader: b9ffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000ffffffff\nctr: 0x0000000000010000\nheader: baffffffff010000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000ffffffff\nctr: 0x0000000000ffffff\nheader: baffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000ffffffff\nctr: 0x0000000001000000\nheader: bbffffffff01000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000ffffffff\nctr: 0x00000000ffffffff\nheader: bbffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000ffffffff\nctr: 0x0000000100000000\nheader: bcffffffff0100000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000ffffffff\nctr: 0x000000ffffffffff\nheader: bcffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000ffffffff\nctr: 0x0000010000000000\nheader: bdffffffff010000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000ffffffff\nctr: 0x0000ffffffffffff\nheader: bdffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000ffffffff\nctr: 0x0001000000000000\nheader: beffffffff01000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000ffffffff\nctr: 0x00ffffffffffffff\nheader: beffffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000ffffffff\nctr: 0x0100000000000000\nheader: bfffffffff0100000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00000000ffffffff\nctr: 0xffffffffffffffff\nheader: bfffffffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000100000000\nctr: 0x0000000000000000\nheader: c00100000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000100000000\nctr: 0x0000000000000001\nheader: c10100000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000100000000\nctr: 0x00000000000000ff\nheader: c80100000000ff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000100000000\nctr: 0x0000000000000100\nheader: c901000000000100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000100000000\nctr: 0x000000000000ffff\nheader: c90100000000ffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000100000000\nctr: 0x0000000000010000\nheader: ca0100000000010000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000100000000\nctr: 0x0000000000ffffff\nheader: ca0100000000ffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000100000000\nctr: 0x0000000001000000\nheader: cb010000000001000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000100000000\nctr: 0x00000000ffffffff\nheader: cb0100000000ffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000100000000\nctr: 0x0000000100000000\nheader: cc01000000000100000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000100000000\nctr: 0x000000ffffffffff\nheader: cc0100000000ffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000100000000\nctr: 0x0000010000000000\nheader: cd0100000000010000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000100000000\nctr: 0x0000ffffffffffff\nheader: cd0100000000ffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000100000000\nctr: 0x0001000000000000\nheader: ce010000000001000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000100000000\nctr: 0x00ffffffffffffff\nheader: ce0100000000ffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000100000000\nctr: 0x0100000000000000\nheader: cf01000000000100000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000000100000000\nctr: 0xffffffffffffffff\nheader: cf0100000000ffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000ffffffffff\nctr: 0x0000000000000000\nheader: c0ffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000ffffffffff\nctr: 0x0000000000000001\nheader: c1ffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000ffffffffff\nctr: 0x00000000000000ff\nheader: c8ffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000ffffffffff\nctr: 0x0000000000000100\nheader: c9ffffffffff0100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000ffffffffff\nctr: 0x000000000000ffff\nheader: c9ffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000ffffffffff\nctr: 0x0000000000010000\nheader: caffffffffff010000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000ffffffffff\nctr: 0x0000000000ffffff\nheader: caffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000ffffffffff\nctr: 0x0000000001000000\nheader: cbffffffffff01000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000ffffffffff\nctr: 0x00000000ffffffff\nheader: cbffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000ffffffffff\nctr: 0x0000000100000000\nheader: ccffffffffff0100000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000ffffffffff\nctr: 0x000000ffffffffff\nheader: ccffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000ffffffffff\nctr: 0x0000010000000000\nheader: cdffffffffff010000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000ffffffffff\nctr: 0x0000ffffffffffff\nheader: cdffffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000ffffffffff\nctr: 0x0001000000000000\nheader: ceffffffffff01000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000ffffffffff\nctr: 0x00ffffffffffffff\nheader: ceffffffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000ffffffffff\nctr: 0x0100000000000000\nheader: cfffffffffff0100000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x000000ffffffffff\nctr: 0xffffffffffffffff\nheader: cfffffffffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000010000000000\nctr: 0x0000000000000000\nheader: d0010000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000010000000000\nctr: 0x0000000000000001\nheader: d1010000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000010000000000\nctr: 0x00000000000000ff\nheader: d8010000000000ff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000010000000000\nctr: 0x0000000000000100\nheader: d90100000000000100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000010000000000\nctr: 0x000000000000ffff\nheader: d9010000000000ffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000010000000000\nctr: 0x0000000000010000\nheader: da010000000000010000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000010000000000\nctr: 0x0000000000ffffff\nheader: da010000000000ffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000010000000000\nctr: 0x0000000001000000\nheader: db01000000000001000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000010000000000\nctr: 0x00000000ffffffff\nheader: db010000000000ffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000010000000000\nctr: 0x0000000100000000\nheader: dc0100000000000100000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000010000000000\nctr: 0x000000ffffffffff\nheader: dc010000000000ffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000010000000000\nctr: 0x0000010000000000\nheader: dd010000000000010000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000010000000000\nctr: 0x0000ffffffffffff\nheader: dd010000000000ffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000010000000000\nctr: 0x0001000000000000\nheader: de01000000000001000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000010000000000\nctr: 0x00ffffffffffffff\nheader: de010000000000ffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000010000000000\nctr: 0x0100000000000000\nheader: df0100000000000100000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000010000000000\nctr: 0xffffffffffffffff\nheader: df010000000000ffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000ffffffffffff\nctr: 0x0000000000000000\nheader: d0ffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000ffffffffffff\nctr: 0x0000000000000001\nheader: d1ffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000ffffffffffff\nctr: 0x00000000000000ff\nheader: d8ffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000ffffffffffff\nctr: 0x0000000000000100\nheader: d9ffffffffffff0100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000ffffffffffff\nctr: 0x000000000000ffff\nheader: d9ffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000ffffffffffff\nctr: 0x0000000000010000\nheader: daffffffffffff010000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000ffffffffffff\nctr: 0x0000000000ffffff\nheader: daffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000ffffffffffff\nctr: 0x0000000001000000\nheader: dbffffffffffff01000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000ffffffffffff\nctr: 0x00000000ffffffff\nheader: dbffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000ffffffffffff\nctr: 0x0000000100000000\nheader: dcffffffffffff0100000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000ffffffffffff\nctr: 0x000000ffffffffff\nheader: dcffffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000ffffffffffff\nctr: 0x0000010000000000\nheader: ddffffffffffff010000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000ffffffffffff\nctr: 0x0000ffffffffffff\nheader: ddffffffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000ffffffffffff\nctr: 0x0001000000000000\nheader: deffffffffffff01000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000ffffffffffff\nctr: 0x00ffffffffffffff\nheader: deffffffffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000ffffffffffff\nctr: 0x0100000000000000\nheader: dfffffffffffff0100000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0000ffffffffffff\nctr: 0xffffffffffffffff\nheader: dfffffffffffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0001000000000000\nctr: 0x0000000000000000\nheader: e001000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0001000000000000\nctr: 0x0000000000000001\nheader: e101000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0001000000000000\nctr: 0x00000000000000ff\nheader: e801000000000000ff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0001000000000000\nctr: 0x0000000000000100\nheader: e9010000000000000100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0001000000000000\nctr: 0x000000000000ffff\nheader: e901000000000000ffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0001000000000000\nctr: 0x0000000000010000\nheader: ea01000000000000010000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0001000000000000\nctr: 0x0000000000ffffff\nheader: ea01000000000000ffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0001000000000000\nctr: 0x0000000001000000\nheader: eb0100000000000001000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0001000000000000\nctr: 0x00000000ffffffff\nheader: eb01000000000000ffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0001000000000000\nctr: 0x0000000100000000\nheader: ec010000000000000100000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0001000000000000\nctr: 0x000000ffffffffff\nheader: ec01000000000000ffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0001000000000000\nctr: 0x0000010000000000\nheader: ed01000000000000010000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0001000000000000\nctr: 0x0000ffffffffffff\nheader: ed01000000000000ffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0001000000000000\nctr: 0x0001000000000000\nheader: ee0100000000000001000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0001000000000000\nctr: 0x00ffffffffffffff\nheader: ee01000000000000ffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0001000000000000\nctr: 0x0100000000000000\nheader: ef010000000000000100000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0001000000000000\nctr: 0xffffffffffffffff\nheader: ef01000000000000ffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00ffffffffffffff\nctr: 0x0000000000000000\nheader: e0ffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00ffffffffffffff\nctr: 0x0000000000000001\nheader: e1ffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00ffffffffffffff\nctr: 0x00000000000000ff\nheader: e8ffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00ffffffffffffff\nctr: 0x0000000000000100\nheader: e9ffffffffffffff0100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00ffffffffffffff\nctr: 0x000000000000ffff\nheader: e9ffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00ffffffffffffff\nctr: 0x0000000000010000\nheader: eaffffffffffffff010000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00ffffffffffffff\nctr: 0x0000000000ffffff\nheader: eaffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00ffffffffffffff\nctr: 0x0000000001000000\nheader: ebffffffffffffff01000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00ffffffffffffff\nctr: 0x00000000ffffffff\nheader: ebffffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00ffffffffffffff\nctr: 0x0000000100000000\nheader: ecffffffffffffff0100000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00ffffffffffffff\nctr: 0x000000ffffffffff\nheader: ecffffffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00ffffffffffffff\nctr: 0x0000010000000000\nheader: edffffffffffffff010000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00ffffffffffffff\nctr: 0x0000ffffffffffff\nheader: edffffffffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00ffffffffffffff\nctr: 0x0001000000000000\nheader: eeffffffffffffff01000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00ffffffffffffff\nctr: 0x00ffffffffffffff\nheader: eeffffffffffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00ffffffffffffff\nctr: 0x0100000000000000\nheader: efffffffffffffff0100000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x00ffffffffffffff\nctr: 0xffffffffffffffff\nheader: efffffffffffffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0100000000000000\nctr: 0x0000000000000000\nheader: f00100000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0100000000000000\nctr: 0x0000000000000001\nheader: f10100000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0100000000000000\nctr: 0x00000000000000ff\nheader: f80100000000000000ff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0100000000000000\nctr: 0x0000000000000100\nheader: f901000000000000000100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0100000000000000\nctr: 0x000000000000ffff\nheader: f90100000000000000ffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0100000000000000\nctr: 0x0000000000010000\nheader: fa0100000000000000010000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0100000000000000\nctr: 0x0000000000ffffff\nheader: fa0100000000000000ffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0100000000000000\nctr: 0x0000000001000000\nheader: fb010000000000000001000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0100000000000000\nctr: 0x00000000ffffffff\nheader: fb0100000000000000ffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0100000000000000\nctr: 0x0000000100000000\nheader: fc01000000000000000100000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0100000000000000\nctr: 0x000000ffffffffff\nheader: fc0100000000000000ffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0100000000000000\nctr: 0x0000010000000000\nheader: fd0100000000000000010000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0100000000000000\nctr: 0x0000ffffffffffff\nheader: fd0100000000000000ffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0100000000000000\nctr: 0x0001000000000000\nheader: fe010000000000000001000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0100000000000000\nctr: 0x00ffffffffffffff\nheader: fe0100000000000000ffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0100000000000000\nctr: 0x0100000000000000\nheader: ff010000000000000001000000000000\n        00",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0x0100000000000000\nctr: 0xffffffffffffffff\nheader: ff0100000000000000ffffffffffffff\n        ff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0xffffffffffffffff\nctr: 0x0000000000000000\nheader: f0ffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0xffffffffffffffff\nctr: 0x0000000000000001\nheader: f1ffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0xffffffffffffffff\nctr: 0x00000000000000ff\nheader: f8ffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0xffffffffffffffff\nctr: 0x0000000000000100\nheader: f9ffffffffffffffff0100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0xffffffffffffffff\nctr: 0x000000000000ffff\nheader: f9ffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0xffffffffffffffff\nctr: 0x0000000000010000\nheader: faffffffffffffffff010000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0xffffffffffffffff\nctr: 0x0000000000ffffff\nheader: faffffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0xffffffffffffffff\nctr: 0x0000000001000000\nheader: fbffffffffffffffff01000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0xffffffffffffffff\nctr: 0x00000000ffffffff\nheader: fbffffffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0xffffffffffffffff\nctr: 0x0000000100000000\nheader: fcffffffffffffffff0100000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0xffffffffffffffff\nctr: 0x000000ffffffffff\nheader: fcffffffffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0xffffffffffffffff\nctr: 0x0000010000000000\nheader: fdffffffffffffffff010000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0xffffffffffffffff\nctr: 0x0000ffffffffffff\nheader: fdffffffffffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0xffffffffffffffff\nctr: 0x0001000000000000\nheader: feffffffffffffffff01000000000000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0xffffffffffffffff\nctr: 0x00ffffffffffffff\nheader: feffffffffffffffffffffffffffffff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0xffffffffffffffff\nctr: 0x0100000000000000\nheader: ffffffffffffffffff01000000000000\n        00",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kid: 0xffffffffffffffff\nctr: 0xffffffffffffffff\nheader: ffffffffffffffffffffffffffffffff\n        ff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.2. AEAD Encryption/Decryption Using AES-CTR and HMAC",
      "section_title": true,
      "ja": "C.2. AES-CTRおよびHMACを使用したAEAD暗号化/復号化"
    },
    {
      "indent": 3,
      "text": "For each case, we provide:",
      "ja": "各ケースについて、次のことを提供します。"
    },
    {
      "indent": 6,
      "text": "* cipher_suite: The index of the cipher suite in use (see Section 8.1)",
      "ja": "* cipher_suite：使用中の暗号スイートのインデックス（セクション8.1を参照）"
    },
    {
      "indent": 6,
      "text": "* key: The key input to encryption/decryption",
      "ja": "* キー：暗号化/復号化へのキー入力"
    },
    {
      "indent": 6,
      "text": "* enc_key: The encryption subkey produced by the derive_subkeys() algorithm",
      "ja": "* enc_key：derive_subkeys（）アルゴリズムによって生成される暗号化サブキー"
    },
    {
      "indent": 6,
      "text": "* auth_key: The encryption subkey produced by the derive_subkeys() algorithm",
      "ja": "* auth_key：derive_subkeys（）アルゴリズムによって生成される暗号化サブキー"
    },
    {
      "indent": 6,
      "text": "* nonce: The nonce input to encryption/decryption",
      "ja": "* NONCE：暗号化/復号化へのNonCe入力"
    },
    {
      "indent": 6,
      "text": "* aad: The aad input to encryption/decryption",
      "ja": "* AAD：暗号化/復号化へのAAD入力"
    },
    {
      "indent": 6,
      "text": "* pt: The plaintext",
      "ja": "* PT：プレーンテキスト"
    },
    {
      "indent": 6,
      "text": "* ct: The ciphertext",
      "ja": "* CT：暗号文"
    },
    {
      "indent": 3,
      "text": "An implementation should verify that the following are true, where AEAD.Encrypt and AEAD.Decrypt are as defined in Section 4.5.1:",
      "ja": "実装では、以下が真実であることを確認する必要があります。ここで、Aead.Encryptとaead.decryptはセクション4.5.1で定義されています。"
    },
    {
      "indent": 6,
      "text": "* AEAD.Encrypt(key, nonce, aad, pt) == ct",
      "ja": "* aead.encrypt（key、nonce、aad、pt）== ct"
    },
    {
      "indent": 6,
      "text": "* AEAD.Decrypt(key, nonce, aad, ct) == pt",
      "ja": "* aead.decrypt（key、nonce、aad、ct）== pt"
    },
    {
      "indent": 3,
      "text": "The other values in the test vector are intermediate values provided to facilitate debugging of test failures.",
      "ja": "テストベクトルの他の値は、テスト障害のデバッグを容易にするために提供される中間値です。"
    },
    {
      "indent": 3,
      "text": "cipher_suite: 0x0001\nkey: 000102030405060708090a0b0c0d0e0f\n     101112131415161718191a1b1c1d1e1f\n     202122232425262728292a2b2c2d2e2f\nenc_key: 000102030405060708090a0b0c0d0e0f\nauth_key: 101112131415161718191a1b1c1d1e1f\n          202122232425262728292a2b2c2d2e2f\nnonce: 101112131415161718191a1b\naad: 4945544620534672616d65205747\npt: 64726166742d696574662d736672616d\n    652d656e63\nct: 6339af04ada1d064688a442b8dc69d5b\n    6bfa40f4bef0583e8081069cc60705",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "cipher_suite: 0x0002\nkey: 000102030405060708090a0b0c0d0e0f\n     101112131415161718191a1b1c1d1e1f\n     202122232425262728292a2b2c2d2e2f\nenc_key: 000102030405060708090a0b0c0d0e0f\nauth_key: 101112131415161718191a1b1c1d1e1f\n          202122232425262728292a2b2c2d2e2f\nnonce: 101112131415161718191a1b\naad: 4945544620534672616d65205747\npt: 64726166742d696574662d736672616d\n    652d656e63\nct: 6339af04ada1d064688a442b8dc69d5b\n    6bfa40f4be6e93b7da076927bb",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "cipher_suite: 0x0003\nkey: 000102030405060708090a0b0c0d0e0f\n     101112131415161718191a1b1c1d1e1f\n     202122232425262728292a2b2c2d2e2f\nenc_key: 000102030405060708090a0b0c0d0e0f\nauth_key: 101112131415161718191a1b1c1d1e1f\n          202122232425262728292a2b2c2d2e2f\nnonce: 101112131415161718191a1b\naad: 4945544620534672616d65205747\npt: 64726166742d696574662d736672616d\n    652d656e63\nct: 6339af04ada1d064688a442b8dc69d5b\n    6bfa40f4be09480509",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.3. SFrame Encryption/Decryption",
      "section_title": true,
      "ja": "C.3. SFRAME暗号化/復号化"
    },
    {
      "indent": 3,
      "text": "For each case, we provide:",
      "ja": "各ケースについて、次のことを提供します。"
    },
    {
      "indent": 6,
      "text": "* cipher_suite: The index of the cipher suite in use (see Section 8.1)",
      "ja": "* cipher_suite：使用中の暗号スイートのインデックス（セクション8.1を参照）"
    },
    {
      "indent": 6,
      "text": "* kid: A KID value",
      "ja": "* 子供：子供の価値"
    },
    {
      "indent": 6,
      "text": "* ctr: A CTR value",
      "ja": "* CTR：CTR値"
    },
    {
      "indent": 6,
      "text": "* base_key: The base_key input to the derive_key_salt algorithm",
      "ja": "* base_key：derive_key_saltアルゴリズムへのbase_key入力"
    },
    {
      "indent": 6,
      "text": "* sframe_key_label: The label used to derive sframe_key in the derive_key_salt algorithm",
      "ja": "* sframe_key_label：derive_key_salt algorithmでsframe_keyを導出するために使用されるラベル"
    },
    {
      "indent": 6,
      "text": "* sframe_salt_label: The label used to derive sframe_salt in the derive_key_salt algorithm",
      "ja": "* sframe_salt_label：derive_key_salt algorithmでsframe_saltを導出するために使用されるラベル"
    },
    {
      "indent": 6,
      "text": "* sframe_secret: The sframe_secret variable in the derive_key_salt algorithm",
      "ja": "* sframe_secret：derive_key_salt algorithmのsframe_secret変数"
    },
    {
      "indent": 6,
      "text": "* sframe_key: The sframe_key value produced by the derive_key_salt algorithm",
      "ja": "* sframe_key：derive_key_salt algorithmによって作成されたsframe_key値"
    },
    {
      "indent": 6,
      "text": "* sframe_salt: The sframe_salt value produced by the derive_key_salt algorithm",
      "ja": "* sframe_salt：derive_key_salt algorithmによって作成されたsframe_salt値"
    },
    {
      "indent": 6,
      "text": "* metadata: The metadata input to the SFrame encrypt algorithm",
      "ja": "* メタデータ：SFRAMEへのメタデータ入力はアルゴリズムを暗号化します"
    },
    {
      "indent": 6,
      "text": "* pt: The plaintext",
      "ja": "* PT：プレーンテキスト"
    },
    {
      "indent": 6,
      "text": "* ct: The SFrame ciphertext",
      "ja": "* CT：SFRAME ciphertext"
    },
    {
      "indent": 3,
      "text": "An implementation should verify that the following are true, where encrypt and decrypt are as defined in Section 4.4, using an SFrame context initialized with base_key assigned to kid:",
      "ja": "実装では、次のものが真であることを確認する必要があります。ここでは、暗号化と復号がセクション4.4で定義されています。"
    },
    {
      "indent": 6,
      "text": "* encrypt(ctr, kid, metadata, plaintext) == ct",
      "ja": "* 暗号化（CTR、KID、メタデータ、プレーンテキスト）== CT"
    },
    {
      "indent": 6,
      "text": "* decrypt(metadata, ct) == pt",
      "ja": "* Decrypt（メタデータ、CT）== Pt"
    },
    {
      "indent": 3,
      "text": "The other values in the test vector are intermediate values provided to facilitate debugging of test failures.",
      "ja": "テストベクトルの他の値は、テスト障害のデバッグを容易にするために提供される中間値です。"
    },
    {
      "indent": 3,
      "text": "cipher_suite: 0x0001\nkid: 0x0000000000000123\nctr: 0x0000000000004567\nbase_key: 000102030405060708090a0b0c0d0e0f\nsframe_key_label: 534672616d6520312e30205365637265\n                  74206b65792000000000000001230001\nsframe_salt_label: 534672616d6520312e30205365637265\n                   742073616c7420000000000000012300\n                   01\nsframe_secret: d926952ca8b7ec4a95941d1ada3a5203\n               ceff8cceee34f574d23909eb314c40c0\nsframe_key: 3f7d9a7c83ae8e1c8a11ae695ab59314\n            b367e359fadac7b9c46b2bc6f81f46e1\n            6b96f0811868d59402b7e870102720b3\nsframe_salt: 50b29329a04dc0f184ac3168\nmetadata: 4945544620534672616d65205747\nnonce: 50b29329a04dc0f184ac740f\naad: 99012345674945544620534672616d65\n     205747\npt: 64726166742d696574662d736672616d\n    652d656e63\nct: 9901234567449408b6f490086165b9d6\n    f62b24ae1a59a56486b4ae8ed036b889\n    12e24f11",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "cipher_suite: 0x0002\nkid: 0x0000000000000123\nctr: 0x0000000000004567\nbase_key: 000102030405060708090a0b0c0d0e0f\nsframe_key_label: 534672616d6520312e30205365637265\n                  74206b65792000000000000001230002\nsframe_salt_label: 534672616d6520312e30205365637265\n                   742073616c7420000000000000012300\n                   02\nsframe_secret: d926952ca8b7ec4a95941d1ada3a5203\n               ceff8cceee34f574d23909eb314c40c0\nsframe_key: e2ec5c797540310483b16bf6e7a570d2\n            a27d192fe869c7ccd8584a8d9dab9154\n            9fbe553f5113461ec6aa83bf3865553e\nsframe_salt: e68ac8dd3d02fbcd368c5577\nmetadata: 4945544620534672616d65205747\nnonce: e68ac8dd3d02fbcd368c1010\naad: 99012345674945544620534672616d65\n     205747\npt: 64726166742d696574662d736672616d\n    652d656e63\nct: 99012345673f31438db4d09434e43afa\n    0f8a2f00867a2be085046a9f5cb4f101\n    d607",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "cipher_suite: 0x0003\nkid: 0x0000000000000123\nctr: 0x0000000000004567\nbase_key: 000102030405060708090a0b0c0d0e0f\nsframe_key_label: 534672616d6520312e30205365637265\n                  74206b65792000000000000001230003\nsframe_salt_label: 534672616d6520312e30205365637265\n                   742073616c7420000000000000012300\n                   03\nsframe_secret: d926952ca8b7ec4a95941d1ada3a5203\n               ceff8cceee34f574d23909eb314c40c0\nsframe_key: 2c5703089cbb8c583475e4fc461d97d1\n            8809df79b6d550f78eb6d50ffa80d892\n            11d57909934f46f5405e38cd583c69fe\nsframe_salt: 38c16e4f5159700c00c7f350\nmetadata: 4945544620534672616d65205747\nnonce: 38c16e4f5159700c00c7b637\naad: 99012345674945544620534672616d65\n     205747\npt: 64726166742d696574662d736672616d\n    652d656e63\nct: 990123456717fc8af28a5a695afcfc6c\n    8df6358a17e26b2fcb3bae32e443",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "cipher_suite: 0x0004\nkid: 0x0000000000000123\nctr: 0x0000000000004567\nbase_key: 000102030405060708090a0b0c0d0e0f\nsframe_key_label: 534672616d6520312e30205365637265\n                  74206b65792000000000000001230004\nsframe_salt_label: 534672616d6520312e30205365637265\n                   742073616c7420000000000000012300\n                   04\nsframe_secret: d926952ca8b7ec4a95941d1ada3a5203\n               ceff8cceee34f574d23909eb314c40c0\nsframe_key: d34f547f4ca4f9a7447006fe7fcbf768\nsframe_salt: 75234edefe07819026751816\nmetadata: 4945544620534672616d65205747\nnonce: 75234edefe07819026755d71\naad: 99012345674945544620534672616d65\n     205747\npt: 64726166742d696574662d736672616d\n    652d656e63\nct: 9901234567b7412c2513a1b66dbb4884\n    1bbaf17f598751176ad847681a69c6d0\n    b091c07018ce4adb34eb",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "cipher_suite: 0x0005\nkid: 0x0000000000000123\nctr: 0x0000000000004567\nbase_key: 000102030405060708090a0b0c0d0e0f\nsframe_key_label: 534672616d6520312e30205365637265\n                  74206b65792000000000000001230005\nsframe_salt_label: 534672616d6520312e30205365637265\n                   742073616c7420000000000000012300\n                   05\nsframe_secret: 0fc3ea6de6aac97a35f194cf9bed94d4\n               b5230f1cb45a785c9fe5dce9c188938a\n               b6ba005bc4c0a19181599e9d1bcf7b74\n               aca48b60bf5e254e546d809313e083a3\nsframe_key: d3e27b0d4a5ae9e55df01a70e6d4d28d\n            969b246e2936f4b7a5d9b494da6b9633\nsframe_salt: 84991c167b8cd23c93708ec7\nmetadata: 4945544620534672616d65205747\nnonce: 84991c167b8cd23c9370cba0\naad: 99012345674945544620534672616d65\n     205747\npt: 64726166742d696574662d736672616d\n    652d656e63\nct: 990123456794f509d36e9beacb0e261d\n    99c7d1e972f1fed787d4049f17ca2135\n    3c1cc24d56ceabced279",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "section_title": true,
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors wish to specially thank Dr. Alex Gouaillard as one of the early contributors to the document. His passion and energy were key to the design and development of SFrame.",
      "ja": "著者は、文書への初期の貢献者の一人として、アレックス・グアイヤール博士に特別に感謝したいと考えています。彼の情熱とエネルギーは、SFRAMEの設計と開発の鍵でした。"
    },
    {
      "indent": 0,
      "text": "Contributors",
      "section_title": true,
      "ja": "貢献者"
    },
    {
      "indent": 3,
      "text": "Frédéric Jacobs\nApple\nEmail: frederic.jacobs@apple.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Marta Mularczyk\nAmazon\nEmail: mulmarta@amazon.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Suhas Nandakumar\nCisco\nEmail: snandaku@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Tomas Rigaux\nCisco\nEmail: trigaux@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Raphael Robert\nPhoenix R&D\nEmail: ietf@raphaelrobert.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Emad Omara\nApple\nEmail: eomara@apple.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Justin Uberti\nFixie.ai\nEmail: justin@fixie.ai",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Sergio Garcia Murillo\nCoSMo Software\nEmail: sergio.garcia.murillo@cosmosoftware.io",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Richard Barnes (editor)\nCisco\nEmail: rlb@ipv.sx",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Youenn Fablet\nApple\nEmail: youenn@apple.com",
      "raw": true,
      "ja": ""
    }
  ]
}