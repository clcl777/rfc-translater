{
  "title": {
    "text": "RFC 9019 - A Firmware Update Architecture for Internet of Things",
    "ja": "RFC 9019 - IoTのためのファームウェア更新アーキテクチャ"
  },
  "number": 9019,
  "created_at": "2024-03-23 12:35:58.239823+09:00",
  "updated_by": "自動生成(GPT)",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                          B. Moran\nRequest for Comments: 9019                                 H. Tschofenig\nCategory: Informational                                      Arm Limited\nISSN: 2070-1721                                                 D. Brown\n                                                                  Linaro\n                                                               M. Meriac\n                                                              Consultant\n                                                              April 2021",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "A Firmware Update Architecture for Internet of Things",
      "title": true,
      "section_title": true,
      "ja": "IoTのためのファームウェア更新アーキテクチャ"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "Vulnerabilities in Internet of Things (IoT) devices have raised the need for a reliable and secure firmware update mechanism suitable for devices with resource constraints. Incorporating such an update mechanism is a fundamental requirement for fixing vulnerabilities, but it also enables other important capabilities such as updating configuration settings and adding new functionality.",
      "ja": "インターネット・オブ・シングス（IoT）デバイスの脆弱性は、リソース制約のあるデバイスに適した信頼性の高いセキュアなファームウェア更新メカニズムの必要性を高めています。このような更新メカニズムを組み込むことは、脆弱性の修正のための基本的な要件ですが、構成設定の更新や新機能の追加など、他の重要な機能も可能にします。"
    },
    {
      "indent": 3,
      "text": "In addition to the definition of terminology and an architecture, this document provides the motivation for the standardization of a manifest format as a transport-agnostic means for describing and protecting firmware updates.",
      "ja": "用語の定義とアーキテクチャに加えて、この文書は、ファームウェアの更新を記述し保護するための輸送に依存しない手段としてマニフェスト形式の標準化の動機を提供します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "この文書はインターネット標準トラック仕様ではありません。情報提供のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "この文書は、Internet Engineering Task Force（IETF）の製品です。これは、IETFコミュニティの合意を表しています。公開レビューを受け、Internet Engineering Steering Group（IESG）によって出版が承認されました。IESGによって承認されたすべての文書がインターネット標準のいずれかの候補となるわけではありません。RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9019.",
      "ja": "この文は以下のように翻訳されます：「この文書の現在の状況、誤植、およびフィードバックの方法に関する情報は、https://www.rfc-editor.org/info/rfc9019 で入手できます。」"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2021 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2021 IETF Trustおよび文書の著者として特定された人々。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、この文書の公開日に有効なBCP 78およびIETF文書に関連するIETF Trustの法的規定（https://trustee.ietf.org/license-info）の対象となります。この文書に関するあなたの権利と制限を説明しているため、これらの文書を注意深く確認してください。この文書から抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されている保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n2.  Conventions and Terminology\n  2.1.  Terms\n  2.2.  Stakeholders\n  2.3.  Functions\n3.  Architecture\n4.  Invoking the Firmware\n  4.1.  The Bootloader\n5.  Types of IoT Devices\n  5.1.  Single MCU\n  5.2.  Single CPU with Partitioning between Secure Mode and Normal\n        Mode\n  5.3.  Symmetric Multiple CPUs\n  5.4.  Dual CPU, Shared Memory\n  5.5.  Dual CPU, Other Bus\n6.  Manifests\n7.  Securing Firmware Updates\n8.  Example\n9.  IANA Considerations\n10. Security Considerations\n11. Informative References\nAcknowledgements\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Firmware updates can help to fix security vulnerabilities, and performing updates is an important building block in securing IoT devices. Due to rising concerns about insecure IoT devices, the Internet Architecture Board (IAB) organized the Internet of Things Software Update (IoTSU) Workshop [RFC8240] to take a look at the bigger picture. The workshop revealed a number of challenges for developers and led to the formation of the IETF Software Updates for Internet of Things (SUIT) Working Group.",
      "ja": "ファームウェアの更新はセキュリティの脆弱性を修正するのに役立ち、更新を行うことはIoTデバイスを保護するための重要な基盤です。不安定なIoTデバイスに対する懸念が高まっているため、Internet Architecture Board（IAB）はInternet of Things Software Update（IoTSU）ワークショップ[RFC8240]を開催し、全体像を見直しました。そのワークショップでは、開発者にとっていくつかの課題が明らかになり、IETF Software Updates for Internet of Things（SUIT）ワーキンググループの形成につながりました。"
    },
    {
      "indent": 3,
      "text": "Developing secure IoT devices is not an easy task, and supporting a firmware update solution requires skillful engineers. Once devices are deployed, firmware updates play a critical part in their life-cycle management, particularly when devices have a long lifetime or are deployed in remote or inaccessible areas where manual intervention is cost prohibitive or otherwise difficult. Firmware updates for IoT devices are expected to work automatically, i.e., without user involvement. Conversely, non-IoT devices are expected to account for user preferences and consent when scheduling updates. Automatic updates that do not require human intervention are key to a scalable solution for fixing software vulnerabilities.",
      "ja": "セキュアなIoTデバイスを開発することは簡単なことではなく、ファームウェアの更新ソリューションをサポートするには熟練したエンジニアが必要です。デバイスが展開されると、ファームウェアの更新は、特にデバイスの寿命が長い場合や手動介入が費用面で困難または困難な場所に展開されている場合に、ライフサイクル管理において重要な役割を果たします。 IoTデバイスのファームウェア更新は、ユーザーの介入なしに自動的に動作することが期待されています。逆に、非IoTデバイスは、更新のスケジュールを立てる際にユーザーの好みや同意を考慮することが期待されています。人間の介入を必要としない自動更新は、ソフトウェアの脆弱性を修正するためのスケーラブルなソリューションにとって重要です。"
    },
    {
      "indent": 3,
      "text": "Firmware updates are done not only to fix bugs but also to add new functionality and to reconfigure the device to work in new environments or to behave differently in an already-deployed context.",
      "ja": "ファームウェアの更新は、バグを修正するだけでなく、新しい機能を追加したり、デバイスを新しい環境で動作させたり、すでに展開されたコンテキストで異なる動作をさせるために行われます。"
    },
    {
      "indent": 3,
      "text": "The manifest specification has to allow the following:",
      "ja": "マニフェスト仕様は以下を許可する必要があります。"
    },
    {
      "indent": 6,
      "text": "* The firmware image is authenticated and integrity protected. Attempts to flash a maliciously modified firmware image or an image from an unknown, untrusted source must be prevented. This document uses asymmetric cryptography in examples because it is the preferred approach by many IoT deployments. The use of symmetric credentials is also supported and can be used by very constrained IoT devices.",
      "ja": "* ファームウェアイメージは認証され、整合性が保護されています。悪意のある改ざんされたファームウェアイメージや未知の、信頼できないソースからのイメージをフラッシュしようとする試みは防止されなければなりません。この文書では、多くのIoT展開において好ましいアプローチである非対称暗号を例として使用しています。対称認証情報の使用もサポートされており、非常に制約の多いIoTデバイスで使用することができます。"
    },
    {
      "indent": 6,
      "text": "* The firmware image can be confidentiality protected so that attempts by an adversary to recover the plaintext binary can be mitigated or at least made more difficult. Obtaining the firmware is often one of the first steps to mounting an attack since it gives the adversary valuable insights into the software libraries used, configuration settings, and generic functionality. Even though reverse engineering the binary can be a tedious process, modern reverse engineering frameworks have made this task a lot easier.",
      "ja": "* ファームウェアイメージは機密保護されている可能性があり、敵対者が平文バイナリを回復しようとする試みを緩和するか、少なくとも困難にすることができます。ファームウェアを入手することは、攻撃を行う最初のステップの1つであることがよくあります。なぜなら、それによって敵対者は使用されているソフトウェアライブラリ、構成設定、および一般的な機能に関する貴重な洞察を得るからです。バイナリのリバースエンジニアリングは手間のかかるプロセスであるかもしれませんが、現代のリバースエンジニアリングフレームワークはこのタスクをはるかに容易にしました。"
    },
    {
      "indent": 3,
      "text": "Authentication and integrity protection of firmware images must be used in a deployment, but the confidential protection of firmware is optional.",
      "ja": "ファームウェアイメージの認証と整合性保護は展開時に使用する必要がありますが、ファームウェアの機密保護は任意です。"
    },
    {
      "indent": 3,
      "text": "While the standardization work has been informed by and optimized for firmware update use cases of Class 1 devices (according to the device class definitions in RFC 7228 [RFC7228]), there is nothing in the architecture that restricts its use to only these constrained IoT devices. Moreover, this architecture is not limited to managing firmware and software updates but can also be applied to managing the delivery of arbitrary data, such as configuration information and keys. Unlike higher-end devices, like laptops and desktop PCs, many IoT devices do not have user interfaces; therefore, support for unattended updates is essential for the design of a practical solution. Constrained IoT devices often use a software engineering model where a developer is responsible for creating and compiling all software running on the device into a single, monolithic firmware image. On higher-end devices, application software is, on the other hand, often downloaded separately and even obtained from developers different from the developers of the lower-level software. The details for how to obtain those application-layer software binaries then depend heavily on the platform, the programming language used, and the sandbox in which the software is executed.",
      "ja": "標準化作業は、Class 1デバイスのファームウェア更新ユースケースに基づいて情報提供され、最適化されています（RFC 7228 [RFC7228]のデバイスクラス定義に従って）。ただし、このアーキテクチャには、これらの制約のあるIoTデバイスにのみ使用を制限するものはありません。さらに、このアーキテクチャはファームウェアおよびソフトウェアの更新の管理に限定されるものではなく、構成情報やキーなどの任意のデータの配信を管理するためにも適用できます。ラップトップやデスクトップPCなどの高級デバイスとは異なり、多くのIoTデバイスにはユーザーインターフェースがありません。そのため、無人更新のサポートは実用的なソリューションの設計に不可欠です。制約のあるIoTデバイスでは、開発者がデバイス上で実行されるすべてのソフトウェアを単一のモノリシックなファームウェアイメージに作成およびコンパイルする責任があるソフトウェアエンジニアリングモデルがよく使用されます。一方、高級デバイスでは、アプリケーションソフトウェアは別々にダウンロードされ、さらに下位ソフトウェアの開発者とは異なる開発者から取得されることがよくあります。そのアプリケーションレイヤーソフトウェアバイナリを取得する方法の詳細は、プラットフォーム、使用されるプログラミング言語、およびソフトウェアが実行されるサンドボックスに大きく依存します。"
    },
    {
      "indent": 3,
      "text": "While the IETF standardization work has been focused on the manifest format, a fully interoperable solution needs more than a standardized manifest. For example, protocols for transferring firmware images and manifests to the device need to be available, as well as the status tracker functionality. Devices also require a mechanism to discover the status tracker(s) and/or firmware servers, for example, using preconfigured hostnames or DNS-based Service Discovery (DNS-SD) [RFC6763]. These building blocks have been developed by various organizations under the umbrella of an IoT device management solution. The Lightweight Machine-to-Machine (LwM2M) protocol [LwM2M] is one IoT device management protocol.",
      "ja": "IETFの標準化作業はマニフェスト形式に焦点を当てていますが、完全に相互運用可能なソリューションには標準化されたマニフェスト以上のものが必要です。たとえば、ファームウェアイメージとマニフェストをデバイスに転送するためのプロトコルが利用可能である必要があります。また、ステータストラッカー機能も必要です。デバイスはまた、ステータストラッカーおよび/またはファームウェアサーバーを発見するメカニズムが必要です。たとえば、事前に設定されたホスト名やDNSベースのサービスディスカバリ（DNS-SD）[RFC6763]を使用することができます。これらのビルディングブロックは、さまざまな組織によってIoTデバイス管理ソリューションの枠組みの下で開発されています。Lightweight Machine-to-Machine（LwM2M）プロトコル[LwM2M]は、1つのIoTデバイス管理プロトコルです。"
    },
    {
      "indent": 3,
      "text": "However, there are several areas that (partially) fall outside the scope of the IETF and other standards organizations but need to be considered by firmware authors as well as device and network operators. Here are some of them, as highlighted during the IoTSU workshop:",
      "ja": "ただし、IETFや他の標準化団体の範囲外に(部分的に)含まれるいくつかの領域がありますが、ファームウェアの開発者やデバイスおよびネットワークの運用者が考慮する必要があります。以下に、IoTSUワークショップで強調されたいくつかの項目が示されています。"
    },
    {
      "indent": 6,
      "text": "* Installing firmware updates in a robust fashion so that the update does not break the device functionality of the environment in which this device operates. This requires proper testing and offering of recovery strategies when a firmware update is unsuccessful.",
      "ja": "* ファームウェアの更新を頑丈な方法でインストールし、その更新がこのデバイスが動作する環境のデバイス機能を壊さないようにします。これには適切なテストと、ファームウェアの更新が失敗した場合の回復戦略の提供が必要です。"
    },
    {
      "indent": 6,
      "text": "* Making firmware updates available in a timely fashion considering the complexity of the decision-making process for updating devices, potential recertification requirements, the length of a supply chain an update needs to go through before it reaches the end customer, and the need for user consent to install updates.",
      "ja": "* デバイスの更新に関する意思決定プロセスの複雑さ、再認証要件、更新が最終顧客に届くまでに通過するサプライチェーンの長さ、および更新をインストールするためのユーザーの同意の必要性を考慮して、タイムリーにファームウェアの更新を提供することが重要です。"
    },
    {
      "indent": 6,
      "text": "* Ensuring an energy-efficient design of a battery-powered IoT device; a firmware update, particularly radio communication and writing the firmware image to flash, is an energy-intensive task for a device.",
      "ja": "* バッテリー駆動のIoTデバイスのエネルギー効率の高い設計を確保するために、特に無線通信とファームウェアイメージをフラッシュに書き込むことは、デバイスにとってエネルギーを多く消費する作業です。"
    },
    {
      "indent": 6,
      "text": "* Creating incentives for device operators to use a firmware update mechanism and to require its integration from IoT device vendors.",
      "ja": "* デバイスオペレーターがファームウェア更新メカニズムを使用するように促し、IoTデバイスベンダーにその統合を要求するためのインセンティブを作成する。"
    },
    {
      "indent": 6,
      "text": "* Ensuring that firmware updates addressing critical flaws can be obtained even after a product is discontinued or a vendor goes out of business.",
      "ja": "* 重要な欠陥に対処するファームウェアの更新が、製品が廃止された後やベンダーが廃業した後でも入手できるようにすることを確認します。"
    },
    {
      "indent": 3,
      "text": "This document starts with a terminology list followed by a description of the architecture. We then explain the bootloader and how it integrates with the firmware update mechanism. Subsequently, we offer a categorization of IoT devices in terms of their hardware capabilities relevant for firmware updates. Next, we talk about the manifest structure and how to use it to secure firmware updates. We conclude with a more detailed example of a message flow for distributing a firmware image to a device.",
      "ja": "この文書は用語リストで始まり、その後にアーキテクチャの説明が続きます。次に、ブートローダーとファームウェア更新メカニズムとの統合方法を説明します。その後、ファームウェア更新に関連するハードウェア機能に基づいてIoTデバイスを分類します。次に、マニフェスト構造について説明し、ファームウェア更新を保護するためにそれを使用する方法について説明します。最後に、ファームウェアイメージをデバイスに配布するためのメッセージフローのより詳細な例について説明します。"
    },
    {
      "indent": 0,
      "text": "2. Conventions and Terminology",
      "section_title": true,
      "ja": "2. 規則と用語"
    },
    {
      "indent": 0,
      "text": "2.1. Terms",
      "section_title": true,
      "ja": "2.1. 用語"
    },
    {
      "indent": 3,
      "text": "This document uses the following terms:",
      "ja": "この文書は次の用語を使用しています。"
    },
    {
      "indent": 3,
      "text": "Firmware Image:",
      "ja": "ファームウェアイメージ:"
    },
    {
      "indent": 12,
      "text": "The firmware image, or simply the \"image\", is a binary that may contain the complete software of a device or a subset of it. The firmware image may consist of multiple images if the device contains more than one microcontroller. Often, it is also a compressed archive that contains code, configuration data, and even the entire file system. The image may consist of a differential update for performance reasons.",
      "ja": "ファームウェアイメージ、または単に「イメージ」と呼ばれるものは、デバイスの完全なソフトウェアまたはその一部を含む可能性があるバイナリです。デバイスに複数のマイクロコントローラが含まれている場合、ファームウェアイメージは複数のイメージで構成される場合があります。しばしば、コード、設定データ、さらにはファイルシステム全体を含む圧縮アーカイブでもあります。パフォーマンス上の理由から、イメージは差分更新で構成される場合があります。"
    },
    {
      "indent": 12,
      "text": "The terms \"firmware image\", \"firmware\", and \"image\" are used in this document and are interchangeable. We use the term \"application firmware image\" to differentiate it from a firmware image that contains the bootloader. An application firmware image, as the name indicates, contains the application program often including all the necessary code to run it (such as protocol stacks and an embedded operating system (OS)).",
      "ja": "この文書では、「firmware image」、「firmware」、および「image」という用語が使用され、互換性があります。私たちは、ブートローダーを含むファームウェアイメージと区別するために、「アプリケーションファームウェアイメージ」という用語を使用しています。アプリケーションファームウェアイメージは、その名前が示すように、アプリケーションプログラムを含み、しばしばそれを実行するために必要なすべてのコード（プロトコルスタックや組み込みオペレーティングシステム（OS）など）を含んでいます。"
    },
    {
      "indent": 3,
      "text": "Manifest:",
      "ja": "マニフェスト:"
    },
    {
      "indent": 12,
      "text": "The manifest contains metadata about the firmware image. The manifest is protected against modification and provides information about the author.",
      "ja": "マニフェストにはファームウェアイメージに関するメタデータが含まれています。マニフェストは改変を防ぎ、著者に関する情報を提供します。"
    },
    {
      "indent": 3,
      "text": "Microcontroller:",
      "ja": "マイクロコントローラー:"
    },
    {
      "indent": 12,
      "text": "A microcontroller unit (MCU) is a compact integrated circuit designed for use in embedded systems. A typical microcontroller includes a processor, memory (RAM and flash), input/output (I/O) ports, and other features connected via some bus on a single chip. The term \"system on chip\" (SoC) is often used interchangeably with MCU, but MCU tends to imply more limited peripheral functions.",
      "ja": "マイクロコントローラーユニット（MCU）は、組み込みシステムで使用するために設計されたコンパクトな集積回路です。典型的なマイクロコントローラーには、プロセッサ、メモリ（RAMとフラッシュ）、入出力（I/O）ポート、および他の機能が、単一のチップ上でバスを介して接続されています。\"システムオンチップ\"（SoC）という用語は、MCUと同義に使われることがありますが、MCUはより限られた周辺機能を意味する傾向があります。"
    },
    {
      "indent": 3,
      "text": "Rich Execution Environment (REE):",
      "ja": "リッチ実行環境（REE）:"
    },
    {
      "indent": 12,
      "text": "An environment that is provided and governed by a typical OS (e.g., Linux, Windows, Android, iOS), potentially in conjunction with other supporting operating systems and hypervisors; it is outside of the Trusted Execution Environment (TEE). This environment and the applications running on it are considered untrusted.",
      "ja": "Typical OS（例：Linux、Windows、Android、iOS）によって提供および管理される環境であり、他のサポートオペレーティングシステムやハイパーバイザーと連携している可能性があります。これは、信頼実行環境（TEE）の外側にあります。この環境とその上で実行されるアプリケーションは信頼されていないと見なされます。"
    },
    {
      "indent": 3,
      "text": "Software:",
      "ja": "ソフトウェア:"
    },
    {
      "indent": 12,
      "text": "Similar to firmware but typically dynamically loaded by an OS. Used interchangeably with firmware in this document.",
      "ja": "「ファームウェアに類似していますが、通常はOSによって動的にロードされます。 この文書ではファームウェアと同じくらい使われます。」"
    },
    {
      "indent": 3,
      "text": "System on Chip (SoC):",
      "ja": "システムオンチップ（SoC）:"
    },
    {
      "indent": 12,
      "text": "An SoC is an integrated circuit that contains all components of a computer, such as the CPU, memory, I/O ports, secondary storage, a bus to connect the components, and other hardware blocks of logic.",
      "ja": "SoCは、コンピュータのすべてのコンポーネント、例えばCPU、メモリ、I/Oポート、セカンダリストレージ、コンポーネントを接続するためのバス、およびその他のハードウェアブロックを含む集積回路です。"
    },
    {
      "indent": 3,
      "text": "Trust Anchor:",
      "ja": "信頼アンカー:"
    },
    {
      "indent": 12,
      "text": "A trust anchor, as defined in RFC 6024 [RFC6024], represents an authoritative entity via a public key and associated data. The public key is used to verify digital signatures, and the associated data is used to constrain the types of information for which the trust anchor is authoritative.",
      "ja": "RFC 6024 [RFC6024] で定義されている信頼アンカーは、公開鍵と関連データを介して権威あるエンティティを表します。公開鍵はデジタル署名を検証するために使用され、関連データは信頼アンカーが権威を持つ情報の種類を制限するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Trust Anchor Store:",
      "ja": "信頼アンカーストア:"
    },
    {
      "indent": 12,
      "text": "A trust anchor store, as defined in [RFC6024], is a set of one or more trust anchors stored in a device. A device may have more than one trust anchor store, each of which may be used by one or more applications. A trust anchor store must resist modification against unauthorized insertion, deletion, and modification.",
      "ja": "[RFC6024]で定義されている信頼アンカーストアとは、デバイスに格納されている1つ以上の信頼アンカーのセットです。デバイスには複数の信頼アンカーストアが存在する可能性があり、それぞれが1つ以上のアプリケーションによって使用されることがあります。信頼アンカーストアは、未承認の挿入、削除、および変更に対して変更を抵抗しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Trusted Applications (TAs):",
      "ja": "信頼されたアプリケーション（TAs）:"
    },
    {
      "indent": 12,
      "text": "An application component that runs in a TEE.",
      "ja": "信頼実行環境（TEE）で実行されるアプリケーションコンポーネント。"
    },
    {
      "indent": 3,
      "text": "Trusted Execution Environments (TEEs):",
      "ja": "信頼された実行環境（TEEs）:"
    },
    {
      "indent": 12,
      "text": "An execution environment that runs alongside of, but is isolated from, an REE. For more information about TEEs, see [TEEP-ARCH].",
      "ja": "リアルエンドエンド（REE）とは隔離された環境で実行される実行環境です。TEEsについての詳細は、[TEEP-ARCH]を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.2. Stakeholders",
      "section_title": true,
      "ja": "2.2. 利害関係者"
    },
    {
      "indent": 3,
      "text": "The following stakeholders are used in this document:",
      "ja": "この文書では、以下のステークホルダーが使用されます:"
    },
    {
      "indent": 3,
      "text": "Author:",
      "ja": "著者:"
    },
    {
      "indent": 12,
      "text": "The author is the entity that creates the firmware image. There may be multiple authors involved in producing firmware running on an IoT device. Section 5 talks about those IoT device deployment cases.",
      "ja": "著者はファームウェアイメージを作成するエンティティです。IoTデバイスで実行されるファームウェアの制作に関与する複数の著者がいるかもしれません。セクション5では、それらのIoTデバイスの展開ケースについて説明しています。"
    },
    {
      "indent": 3,
      "text": "Device Operator:",
      "ja": "デバイスオペレーター:"
    },
    {
      "indent": 12,
      "text": "The device operator is responsible for the day-to-day operation of a fleet of IoT devices. Customers of IoT devices, as the owners of IoT devices (such as enterprise customers or end users), interact with their IoT devices indirectly through the device operator via the Web or smartphone apps.",
      "ja": "デバイスオペレーターは、IoTデバイスの日常運用に責任を持ちます。IoTデバイスの顧客は、IoTデバイスの所有者として（企業顧客やエンドユーザーなど）、Webやスマートフォンアプリを介してデバイスオペレーターを通じて間接的にIoTデバイスとやり取りします。"
    },
    {
      "indent": 3,
      "text": "Network Operator:",
      "ja": "ネットワークオペレーター:"
    },
    {
      "indent": 12,
      "text": "The network operator is responsible for the operation of a network to which IoT devices connect.",
      "ja": "ネットワークオペレーターは、IoTデバイスが接続するネットワークの運用に責任を持ちます。"
    },
    {
      "indent": 3,
      "text": "Trust Provisioning Authority (TPA):",
      "ja": "信頼プロビジョニング機関（TPA）:"
    },
    {
      "indent": 12,
      "text": "The TPA distributes trust anchors and authorization policies to devices and various stakeholders. The TPA may also delegate rights to stakeholders. Typically, the original equipment manufacturer (OEM) or original design manufacturer (ODM) will act as a TPA; however, complex supply chains may require a different design. In some cases, the TPA may decide to remain in full control over the firmware update process of their products.",
      "ja": "TPAは信頼アンカーと認可ポリシーをデバイスやさまざまな利害関係者に配布します。TPAは利害関係者に権利を委任することもあります。通常、オリジナル機器メーカー（OEM）またはオリジナル設計製造業者（ODM）がTPAとして機能しますが、複雑なサプライチェーンでは異なる設計が必要となる場合もあります。一部の場合、TPAは自社製品のファームウェア更新プロセスに対して完全な制御を維持することを決定するかもしれません。"
    },
    {
      "indent": 3,
      "text": "User:",
      "ja": "ユーザー:"
    },
    {
      "indent": 12,
      "text": "The end user of a device. The user may interact with devices via the Web or smartphone apps, as well as through direct user interfaces.",
      "ja": "デバイスの最終ユーザー。ユーザーは、Webやスマートフォンアプリを介してデバイスとやり取りすることができます。また、直接的なユーザーインターフェースを通じてもやり取りすることができます。"
    },
    {
      "indent": 0,
      "text": "2.3. Functions",
      "section_title": true,
      "ja": "2.3. 機能"
    },
    {
      "indent": 3,
      "text": "(IoT) Device:",
      "ja": "(IoT) デバイス:"
    },
    {
      "indent": 12,
      "text": "A device refers to the entire IoT product, which consists of one or many MCUs, sensors, and/or actuators. Many IoT devices sold today contain multiple MCUs; therefore, a single device may need to obtain more than one firmware image and manifest to successfully perform an update.",
      "ja": "デバイスは、1つまたは複数のMCU、センサー、および/またはアクチュエータから構成される、完全なIoT製品を指します。今日販売されている多くのIoTデバイスには複数のMCUが含まれているため、1つのデバイスが更新を正常に実行するためには、複数のファームウェアイメージとマニフェストを取得する必要がある場合があります。"
    },
    {
      "indent": 3,
      "text": "Status Tracker:",
      "ja": "ステータス トラッカー:"
    },
    {
      "indent": 12,
      "text": "The status tracker has a client and a server component and performs three tasks:",
      "ja": "ステータストラッカーにはクライアントとサーバーのコンポーネントがあり、3つのタスクを実行します。"
    },
    {
      "indent": 8,
      "text": "1. It communicates the availability of a new firmware version. This information will flow from the server to the client.",
      "ja": "1. 新しいファームウェアバージョンの利用可能性を伝えます。この情報はサーバーからクライアントに流れます。"
    },
    {
      "indent": 8,
      "text": "2. It conveys information about the software and hardware characteristics of the device. The information flow is from the client to the server.",
      "ja": "2. デバイスのソフトウェアおよびハードウェアの特性に関する情報を伝えます。情報の流れはクライアントからサーバーへです。"
    },
    {
      "indent": 8,
      "text": "3. It can remotely trigger the firmware update process. The information flow is from the server to the client.",
      "ja": "3. リモートでファームウェア更新プロセスをトリガーできます。情報の流れはサーバーからクライアントへです。"
    },
    {
      "indent": 12,
      "text": "For example, a device operator may want to read the installed firmware version number running on the device and information about available flash memory. Once an update has been triggered, the device operator may want to obtain information about the state of the firmware update. If errors occurred, the device operator may want to troubleshoot problems by first obtaining diagnostic information (typically using a device management protocol).",
      "ja": "たとえば、デバイスのオペレーターは、デバイス上で実行されているインストールされたファームウェアバージョン番号や利用可能なフラッシュメモリに関する情報を読み取りたい場合があります。アップデートがトリガーされた後、デバイスのオペレーターはファームウェアアップデートの状態に関する情報を取得したい場合があります。エラーが発生した場合、デバイスのオペレーターはまず診断情報を取得して問題をトラブルシューティングしたい場合があります（通常、デバイス管理プロトコルを使用して）。"
    },
    {
      "indent": 12,
      "text": "We make no assumptions about where the server-side component is deployed. The deployment of status trackers is flexible: they may be found at cloud-based servers or on-premise servers, or they may be embedded in edge computing devices. A status tracker server component may even be deployed on an IoT device. For example, if the IoT device contains multiple MCUs, then the main MCU may act as a status tracker towards the other MCUs. Such deployment is useful when updates have to be synchronized across MCUs.",
      "ja": "サーバーサイドコンポーネントが展開されている場所については、何も仮定していません。ステータストラッカーの展開は柔軟であり、クラウドベースのサーバー、オンプレミスのサーバー、またはエッジコンピューティングデバイスに見られるかもしれません。ステータストラッカーサーバーコンポーネントは、IoTデバイスに展開されることさえあります。たとえば、IoTデバイスに複数のMCUが含まれている場合、メインMCUは他のMCUに対してステータストラッカーとして機能するかもしれません。このような展開は、更新をMCU全体で同期する必要がある場合に便利です。"
    },
    {
      "indent": 12,
      "text": "The status tracker may be operated by any suitable stakeholder, typically the author, device operator, or network operator.",
      "ja": "ステータストラッカーは、通常、著者、デバイスオペレーター、またはネットワークオペレーターなど、適任なステークホルダーによって操作される可能性があります。"
    },
    {
      "indent": 3,
      "text": "Firmware Consumer:",
      "ja": "ファームウェア消費者:"
    },
    {
      "indent": 12,
      "text": "The firmware consumer is the recipient of the firmware image and the manifest. It is responsible for parsing and verifying the received manifest and for storing the obtained firmware image. The firmware consumer plays the role of the update component on the IoT device, typically running in the application firmware. It interacts with the firmware server and the status tracker client (locally).",
      "ja": "ファームウェアコンシューマーは、ファームウェアイメージとマニフェストの受信者です。受信したマニフェストの解析と検証、取得したファームウェアイメージの保存を担当します。ファームウェアコンシューマーは、通常、アプリケーションファームウェアで実行されるIoTデバイス上の更新コンポーネントの役割を果たします。ファームウェアコンシューマーは、ファームウェアサーバーとステータストラッカークライアント（ローカル）とやり取りします。"
    },
    {
      "indent": 3,
      "text": "Firmware Server:",
      "ja": "ファームウェアサーバー:"
    },
    {
      "indent": 12,
      "text": "The firmware server stores firmware images and manifests and distributes them to IoT devices. Some deployments may require a store-and-forward concept, which requires storing the firmware images and/or manifests on more than one entity before they reach the device. There is typically some interaction between the firmware server and the status tracker, and these two entities are often physically separated on different devices for scalability reasons.",
      "ja": "ファームウェアサーバーはファームウェアイメージとマニフェストを保存し、それらをIoTデバイスに配布します。一部の展開では、ファームウェアイメージやマニフェストをデバイスに到達する前に複数のエンティティに保存する必要があるストア・アンド・フォワードの概念が必要とされる場合があります。通常、ファームウェアサーバーとステータストラッカーの間にはいくつかのやり取りがあり、これらの2つのエンティティは、スケーラビリティの理由で通常、異なるデバイスに物理的に分離されています。"
    },
    {
      "indent": 3,
      "text": "Bootloader:",
      "ja": "ブートローダー:"
    },
    {
      "indent": 12,
      "text": "A bootloader is a piece of software that is executed once a microcontroller has been reset. It is responsible for deciding what code to execute.",
      "ja": "ブートローダーは、マイクロコントローラーがリセットされた後に実行されるソフトウェアです。実行するコードを決定する責任があります。"
    },
    {
      "indent": 0,
      "text": "3. Architecture",
      "section_title": true,
      "ja": "3. 建築"
    },
    {
      "indent": 3,
      "text": "More devices than ever before are connected to the Internet, which drives the need for firmware updates to be provided over the Internet rather than through traditional interfaces, such as USB or RS-232. Sending updates over the Internet requires the device to fetch the new firmware image as well as the manifest.",
      "ja": "インターネットに接続されているデバイスが今まで以上に多くなっており、ファームウェアの更新が従来のUSBやRS-232などの伝統的なインターフェースではなく、インターネット経由で提供される必要があります。インターネット経由で更新を送信するには、デバイスが新しいファームウェアイメージとマニフェストを取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "Hence, the following components are necessary on a device for a firmware update solution:",
      "ja": "したがって、ファームウェア更新ソリューションには、デバイス上で次のコンポーネントが必要です。"
    },
    {
      "indent": 6,
      "text": "* The Internet protocol stack for firmware downloads. Firmware images are often multiple kilobytes, sometimes exceeding one hundred kilobytes, for low-end IoT devices and can even be several megabytes for IoT devices running full-fledged operating systems like Linux. The protocol mechanism for retrieving these images needs to offer features like congestion control, flow control, fragmentation and reassembly, and mechanisms to resume interrupted or corrupted transfers.",
      "ja": "* ファームウェアのダウンロードのためのインターネットプロトコルスタック。ファームウェアイメージは、低価格のIoTデバイスではしばしば複数キロバイトであり、Linuxなどのフル機能のオペレーティングシステムを実行するIoTデバイスでは数メガバイトに達することさえあります。これらのイメージを取得するためのプロトコルメカニズムは、過負荷制御、フロー制御、フラグメンテーションと再結合、および中断または破損した転送を再開するメカニズムなどの機能を提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "* The capability to write the received firmware image to persistent storage (most likely flash memory).",
      "ja": "* 受信したファームウェアイメージを永続ストレージ（おそらくフラッシュメモリ）に書き込む能力。"
    },
    {
      "indent": 6,
      "text": "* A manifest parser with code to verify a digital signature or a message authentication code (MAC).",
      "ja": "* デジタル署名またはメッセージ認証コード（MAC）を検証するコードを持つマニフェストパーサー。"
    },
    {
      "indent": 6,
      "text": "* The ability to unpack, decompress, and/or decrypt the received firmware image.",
      "ja": "* 受信したファームウェアイメージを展開、解凍、および/または復号化する能力。"
    },
    {
      "indent": 6,
      "text": "* A status tracker.",
      "ja": "* ステータス トラッカー。"
    },
    {
      "indent": 3,
      "text": "The features listed above are most likely provided by code in the application firmware image running on the device rather than by the bootloader itself. Note that cryptographic algorithms will likely run in a trusted execution environment on a separate MCU in a hardware security module or in a secure element rather than in the same context as the application code.",
      "ja": "上記にリストされている機能は、おそらくブートローダー自体ではなく、デバイス上で実行されているアプリケーションファームウェアイメージ内のコードによって提供される可能性が高いことに注意してください。暗号アルゴリズムは、おそらく、ハードウェアセキュリティモジュール内の別のMCUで実行される信頼された実行環境で動作するか、セキュアエレメント内で動作する可能性が高いです。アプリケーションコードとは別のコンテキストで実行される可能性が高いです。"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows the architecture where a firmware image is created by an author and made available to a firmware server. For security reasons, the author will not have the permissions to upload firmware images to the firmware server and to initiate an update directly. Instead, authors will make firmware images available to the device operators. Note that there may be a longer supply chain involved to pass software updates from the author all the way to the authorizing party, which can then finally make a decision to deploy it with IoT devices.",
      "ja": "図1は、ファームウェアイメージが著者によって作成され、ファームウェアサーバーに提供されるアーキテクチャを示しています。セキュリティ上の理由から、著者はファームウェアイメージをファームウェアサーバーにアップロードしたり、直接アップデートを開始したりする権限を持ちません。代わりに、著者はファームウェアイメージをデバイスオペレーターに提供します。著者から承認パーティーまでソフトウェアアップデートを渡すために、より長いサプライチェーンが関与する可能性があることに注意してください。その後、最終的にIoTデバイスと一緒に展開するかどうかを決定することができます。"
    },
    {
      "indent": 3,
      "text": "As a first step in the firmware update process, the status tracker server needs to inform the status tracker client that a new firmware update is available. This can be accomplished via polling (client initiated), push notifications (server initiated), or more complex mechanisms (such as a hybrid approach):",
      "ja": "ファームウェアの更新プロセスの最初のステップとして、ステータストラッカーサーバーはステータストラッカークライアントに新しいファームウェアの更新が利用可能であることを通知する必要があります。これは、ポーリング（クライアント起動）、プッシュ通知（サーバー起動）、またはより複雑なメカニズム（ハイブリッドアプローチなど）を介して達成できます。"
    },
    {
      "indent": 6,
      "text": "* Client-initiated updates take the form of a status tracker client proactively checking (polling) for updates.",
      "ja": "* クライアントがイニシアチブを取った更新は、ステータス トラッカー クライアントが更新を積極的にチェック（ポーリング）する形で行われます。"
    },
    {
      "indent": 6,
      "text": "* With server-initiated updates, the server-side component of the status tracker learns about a new firmware version and determines which devices qualify for a firmware update. Once the relevant devices have been selected, the status tracker informs these devices, and the firmware consumers obtain those images and manifests. Server-initiated updates are important because they allow a quick response time. Note that in this mode, the client-side status tracker needs to be reachable by the server-side component. This may require devices to keep reachability information on the server side up to date and the state at NATs and stateful packet filtering firewalls alive.",
      "ja": "* サーバーからの更新通知では、ステータストラッカーのサーバーサイドコンポーネントが新しいファームウェアバージョンについて学び、どのデバイスがファームウェアの更新対象となるかを判断します。該当するデバイスが選択されると、ステータストラッカーはこれらのデバイスに通知し、ファームウェアの消費者はそれらのイメージとマニフェストを取得します。サーバーからの更新通知は迅速な応答時間を可能にするため重要です。このモードでは、クライアントサイドのステータストラッカーがサーバーサイドコンポーネントから到達可能である必要があります。これには、デバイスがサーバーサイドの到達可能情報を最新の状態に保ち、NATやステートフルパケットフィルタリングファイアウォールの状態を維持する必要がある場合があります。"
    },
    {
      "indent": 6,
      "text": "* Using a hybrid approach, the server side of the status tracker pushes update availability notifications to the client side and requests that the firmware consumer pull the manifest and the firmware image from the firmware server.",
      "ja": "* ハイブリッドアプローチを使用して、ステータストラッカーのサーバーサイドは、更新可能な通知をクライアントサイドにプッシュし、ファームウェアコンシューマーにマニフェストとファームウェアイメージをファームウェアサーバーから取得するよう要求します。"
    },
    {
      "indent": 3,
      "text": "Once the device operator triggers an update via the status tracker, it will keep track of the update process on the device. This allows the device operator to know what devices have received an update and which of them are still pending an update.",
      "ja": "デバイスオペレーターがステータストラッカーを介して更新をトリガーすると、デバイス上で更新プロセスを追跡します。これにより、デバイスオペレーターは、どのデバイスが更新を受信したか、そしてまだ更新が保留中であるかを知ることができます。"
    },
    {
      "indent": 3,
      "text": "Firmware images can be conveyed to devices in a variety of ways, including USB, Universal Asynchronous Receiver Transmitter (UART), WiFi, Bluetooth Low Energy (BLE), low-power WAN technologies, mesh networks and many more. At the application layer, a variety of protocols are also available: Message Queuing Telemetry Transport (MQTT), Constrained Application Protocol (CoAP), and HTTP are the most popular application-layer protocols used by IoT devices. This architecture does not make assumptions about how the firmware images are distributed to the devices and therefore aims to support all these technologies.",
      "ja": "ファームウェアイメージは、USB、Universal Asynchronous Receiver Transmitter（UART）、WiFi、Bluetooth Low Energy（BLE）、低電力WAN技術、メッシュネットワークなど、さまざまな方法でデバイスに伝達できます。アプリケーション層では、さまざまなプロトコルも利用可能です。Message Queuing Telemetry Transport（MQTT）、Constrained Application Protocol（CoAP）、HTTPは、IoTデバイスで使用される最も一般的なアプリケーション層プロトコルです。このアーキテクチャは、ファームウェアイメージがデバイスにどのように配布されるかについての仮定を行わず、したがってすべてのこれらの技術をサポートすることを目指しています。"
    },
    {
      "indent": 3,
      "text": "In some cases, it may be desirable to distribute firmware images using a multicast or broadcast protocol. This architecture does not make recommendations for any such protocol. However, given that broadcast may be desirable for some networks, updates must cause the least disruption possible both in the metadata and firmware transmission. For an update to be broadcast friendly, it cannot rely on link-layer, network-layer, or transport-layer security. A solution has to rely on security protection applied to the manifest and firmware image instead. In addition, the same manifest must be deliverable to many devices, both those to which it applies and those to which it does not, without a chance that the wrong device will accept the update. Considerations that apply to network broadcasts apply equally to the use of third-party content distribution networks for payload distribution.",
      "ja": "いくつかのケースでは、ファームウェアイメージをマルチキャストまたはブロードキャストプロトコルを使用して配布することが望ましい場合があります。このアーキテクチャはそのようなプロトコルについての推奨事項を提供していません。ただし、ブロードキャストが一部のネットワークで望ましい場合、更新はメタデータとファームウェアの送信の両方でできるだけ少ない障害を引き起こさなければなりません。アップデートがブロードキャストに適しているためには、リンク層、ネットワーク層、またはトランスポート層のセキュリティに依存してはいけません。解決策は、マニフェストとファームウェアイメージに適用されるセキュリティ保護に依存しなければなりません。さらに、同じマニフェストは、適用されるデバイスと適用されないデバイスの両方に配信できなければならず、誤ったデバイスがアップデートを受け入れる可能性がないようにしなければなりません。ネットワークブロードキャストに適用される考慮事項は、ペイロード配布のためのサードパーティのコンテンツ配信ネットワークの使用にも同様に適用されます。"
    },
    {
      "indent": 3,
      "text": "                                                      +----------+\n                                                      |          |\n                                                      |  Author  |\n                                                      |          |\n                                                      +----------+\n                       Firmware + Manifest                 |\n              +----------------------------------+         | Firmware +\n              |                                  |         | Manifest\n              |                               ---+-------  |\n              |                           ----   |       --|-\n              |                         //+----------+     | \\\\\n             -+--                      // |          |     |   \\\n        ----/ |  ----                |/   | Firmware |<-+  |    \\\n      //      |      \\\\              |    | Server   |  |  |     \\\n     /        |        \\             /    |          |  +  +      \\\n    /         |         \\           /     +----------+   \\ /       |\n   / +--------+--------+ \\         /                      |        |\n  /  |        v        |  \\       /                       v        |\n |   | +------------+  |   |     |          +----------------+      |\n |   | |  Firmware  |  |   |     |          |     Device     |      |\n |   | |  Consumer  |  |   |     |          |     Management |      |\n|    | +------------+  |    |    |          |                |      |\n|    | +------------+  |    |    |          |    +--------+  |      |\n|    | |  Status    |<-+--------------------+->  |        |  |      |\n|    | |  Tracker   |  |    |    |          |    | Status |  |      |\n|    | |  Client    |  |    |    |          |    | Tracker|  |     |\n |   | +------------+  |   |     |          |    | Server |  |     |\n |   |    Device       |   |      |         |    +--------+  |     |\n |   +-----------------+   |       \\        |                |    /\n  \\                       /         \\       +----------------+   /\n   \\       Network       /           \\                          /\n    \\     Operator      /             \\     Device Operator    /\n     \\\\               //               \\\\                    //\n        ----     ----                     ----           ----\n            -----                             -----------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 27,
      "text": "Figure 1: Architecture",
      "ja": "図1：アーキテクチャ"
    },
    {
      "indent": 3,
      "text": "Firmware images and manifests may be conveyed as a bundle or detached. The manifest format must support both approaches.",
      "ja": "ファームウェアイメージとマニフェストは、バンドルまたは切り離しの形で伝達される場合があります。マニフェスト形式は両方のアプローチをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "For distribution as a bundle, the firmware image is embedded into the manifest. This is a useful approach for deployments where devices are not connected to the Internet and cannot contact a dedicated firmware server for the firmware download. It is also applicable when the firmware update happens via USB sticks or short-range radio technologies (such as Bluetooth Smart).",
      "ja": "バンドルとして配布するために、ファームウェアイメージはマニフェストに埋め込まれます。これは、デバイスがインターネットに接続されておらず、ファームウェアのダウンロードのために専用のファームウェアサーバに接続できない展開において有用なアプローチです。また、ファームウェアの更新がUSBスティックや短距離無線技術（Bluetooth Smartなど）を介して行われる場合にも適用されます。"
    },
    {
      "indent": 3,
      "text": "Alternatively, the manifest is distributed detached from the firmware image. Using this approach, the firmware consumer is presented with the manifest first and then needs to obtain one or more firmware images as dictated in the manifest.",
      "ja": "代わりに、マニフェストはファームウェアイメージから分離して配布されます。このアプローチを使用すると、ファームウェアの消費者はまずマニフェストを受け取り、その後、マニフェストで指示された1つ以上のファームウェアイメージを取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "The pre-authorization step involves verifying whether the entity signing the manifest is indeed authorized to perform an update. The firmware consumer must also determine whether it should fetch and process a firmware image, which is referenced in a manifest.",
      "ja": "事前承認手順には、マニフェストに署名するエンティティが更新を実行する権限を持っているかどうかを検証する作業が含まれます。ファームウェアの消費者は、また、マニフェストで参照されているファームウェアイメージを取得して処理すべきかどうかを決定する必要があります。"
    },
    {
      "indent": 3,
      "text": "A dependency resolution phase is needed when more than one component can be updated or when a differential update is used. The necessary dependencies must be available prior to installation.",
      "ja": "依存関係の解決フェーズは、複数のコンポーネントが更新可能な場合や差分更新が使用される場合に必要となります。インストール前に必要な依存関係が利用可能である必要があります。"
    },
    {
      "indent": 3,
      "text": "The download step is the process of acquiring a local copy of the firmware image. When the download is client initiated, this means that the firmware consumer chooses when a download occurs and initiates the download process. When a download is server initiated, this means that the status tracker tells the device when to download or that it initiates the transfer directly to the firmware consumer. For example, a download from an HTTP/1.1-based firmware server is client initiated. Pushing a manifest and firmware image to the Package Resource of the LwM2M Firmware Update Object [LwM2M] is a server-initiated update.",
      "ja": "ダウンロードステップはファームウェアイメージのローカルコピーを取得するプロセスです。ダウンロードがクライアント起動の場合、これはファームウェアの消費者がダウンロードが発生するタイミングを選択し、ダウンロードプロセスを開始することを意味します。ダウンロードがサーバー起動の場合、ステータストラッカーがデバイスにダウンロードのタイミングを伝えるか、またはファームウェアの消費者に直接転送を開始することを意味します。例えば、HTTP/1.1ベースのファームウェアサーバーからのダウンロードはクライアント起動です。LwM2Mファームウェア更新オブジェクト[LwM2M]のパッケージリソースにマニフェストとファームウェアイメージをプッシュすることはサーバー起動の更新です。"
    },
    {
      "indent": 3,
      "text": "If the firmware consumer has downloaded a new firmware image and is ready to install it, to initiate the installation, it may",
      "ja": "ファームウェアの消費者が新しいファームウェアイメージをダウンロードし、インストールの準備ができている場合、インストールを開始するためには、それが可能です。"
    },
    {
      "indent": 6,
      "text": "* need to wait for a trigger from the status tracker,",
      "ja": "* 「ステータストラッカーからのトリガーを待つ必要があります。」"
    },
    {
      "indent": 6,
      "text": "* trigger the update automatically, or",
      "ja": "* 自動的に更新をトリガーする、または"
    },
    {
      "indent": 6,
      "text": "* go through a more complex decision-making process to determine the appropriate timing for an update.",
      "ja": "* 更新の適切なタイミングを決定するために、より複雑な意思決定プロセスを経る。"
    },
    {
      "indent": 3,
      "text": "Sometimes the final decision may require confirmation of the user of the device for safety reasons.",
      "ja": "時々、安全上の理由で最終的な決定にはデバイスのユーザーの確認が必要になる場合があります。"
    },
    {
      "indent": 3,
      "text": "Installation is the act of processing the payload into a format that the IoT device can recognize, and the bootloader is responsible for then booting from the newly installed firmware image. This process is different when a bootloader is not involved. For example, when an application is updated in a full-featured OS, the updater may halt and restart the application in isolation. Devices must not fail when a disruption, such as a power failure or network interruption, occurs during the update process.",
      "ja": "インストールは、IoTデバイスが認識できる形式にペイロードを処理する行為であり、その後、ブートローダーが新しくインストールされたファームウェアイメージから起動する責任があります。このプロセスは、ブートローダーが関与しない場合と異なります。たとえば、フル機能のOSでアプリケーションが更新される場合、更新プログラムはアプリケーションを孤立して停止して再起動する場合があります。デバイスは、更新プロセス中に電源障害やネットワークの中断などの中断が発生した場合に失敗してはなりません。"
    },
    {
      "indent": 0,
      "text": "4. Invoking the Firmware",
      "section_title": true,
      "ja": "4. ファームウェアを呼び出す"
    },
    {
      "indent": 3,
      "text": "Section 3 describes the steps for getting the firmware image and the manifest from the author to the firmware consumer on the IoT device. Once the firmware consumer has retrieved and successfully processed the manifest and the firmware image, it needs to invoke the new firmware image. This is managed in many different ways depending on the type of device, but it typically involves halting the current version of the firmware, handing over control to firmware with a higher privilege or trust level (the firmware verifier), verifying the new firmware's authenticity and integrity, and then invoking it.",
      "ja": "セクション3では、IoTデバイス上のファームウェア消費者にファームウェアイメージとマニフェストを著者から取得する手順が記載されています。ファームウェア消費者がマニフェストとファームウェアイメージを取得し、正常に処理した後、新しいファームウェアイメージを呼び出す必要があります。これはデバイスの種類によって異なる方法で管理されますが、通常は現在のファームウェアバージョンを停止し、より高い特権や信頼レベルを持つファームウェア（ファームウェア検証者）に制御を移し、新しいファームウェアの信頼性と整合性を検証し、それを呼び出すことが含まれます。"
    },
    {
      "indent": 3,
      "text": "In an execute-in-place microcontroller, this is often done by rebooting into a bootloader (simultaneously halting the application and handing over control to the higher privilege level) then executing a secure boot process (verifying and invoking the new image).",
      "ja": "実行インプレースマイクロコントローラーでは、これはしばしばブートローダーに再起動して行われます（アプリケーションを停止し、制御をより高い特権レベルに移行する）その後、セキュアブートプロセスを実行して新しいイメージを検証および起動します。"
    },
    {
      "indent": 3,
      "text": "In a rich OS, this may be done by halting one or more processes and then invoking new applications. In some OSes, this implicitly involves the kernel verifying the code signatures on the new applications.",
      "ja": "リッチなOSでは、これは1つ以上のプロセスを停止させ、その後新しいアプリケーションを起動することで行われるかもしれません。一部のOSでは、これは新しいアプリケーションのコード署名をカーネルが暗黙的に検証することを含むことがあります。"
    },
    {
      "indent": 3,
      "text": "The invocation process is security sensitive. An attacker will typically try to retrieve a firmware image from the device for reverse engineering or will try to get the firmware verifier to execute an attacker-modified firmware image. Therefore, firmware verifier will have to perform security checks on the firmware image before it can be invoked. These security checks by the firmware verifier happen in addition to the security checks that took place when the firmware image and the manifest were downloaded by the firmware consumer.",
      "ja": "呼び出しプロセスはセキュリティに敏感です。攻撃者は通常、デバイスからファームウェアイメージを取得してリバースエンジニアリングを試みるか、ファームウェア検証者に攻撃者が変更したファームウェアイメージを実行させようとします。したがって、ファームウェア検証者は、ファームウェアイメージを呼び出す前にセキュリティチェックを実行する必要があります。ファームウェア検証者によるこれらのセキュリティチェックは、ファームウェアイメージとマニフェストがファームウェアコンシューマによってダウンロードされたときに行われたセキュリティチェックに加えて行われます。"
    },
    {
      "indent": 3,
      "text": "The overlap between the firmware consumer and the firmware verifier functionality comes in two forms, namely:",
      "ja": "ファームウェアの消費者とファームウェア検証機能の重複は、次の2つの形で現れます。"
    },
    {
      "indent": 6,
      "text": "* A firmware verifier must verify the firmware image it boots as part of the secure boot process. Doing so requires metadata to be stored alongside the firmware image so that the firmware verifier can cryptographically verify the firmware image before booting it to ensure it has not been tampered with or replaced. This metadata used by the firmware verifier may well be the same manifest obtained with the firmware image during the update process.",
      "ja": "* ファームウェア検証プログラムは、セキュアブートプロセスの一環としてブートするファームウェアイメージを検証する必要があります。これを行うには、ファームウェアイメージと共にメタデータを保存する必要があります。これにより、ファームウェア検証プログラムがファームウェアイメージをブートする前に、改ざんされていないか、または置き換えられていないかを暗号的に検証できます。ファームウェア検証プログラムが使用するこのメタデータは、更新プロセス中にファームウェアイメージと共に取得される可能性があります。"
    },
    {
      "indent": 6,
      "text": "* An IoT device needs a recovery strategy in case the firmware update/invocation process fails. The recovery strategy may include storing two or more application firmware images on the device or offering the ability to invoke a recovery image to perform the firmware update process again using firmware updates over serial, USB, or even wireless connectivity like Bluetooth Smart. In the latter case, the firmware consumer functionality is contained in the recovery image and requires the necessary functionality for executing the firmware update process, including manifest parsing.",
      "ja": "* IoTデバイスは、ファームウェアの更新/起動プロセスが失敗した場合の回復戦略が必要です。回復戦略には、デバイスに2つ以上のアプリケーションファームウェアイメージを保存するか、回復イメージを起動してファームウェア更新プロセスを再度実行する能力を提供することが含まれる場合があります。後者の場合、ファームウェアの消費者機能は回復イメージに含まれており、マニフェストの解析を含むファームウェア更新プロセスを実行するための必要な機能が必要です。"
    },
    {
      "indent": 3,
      "text": "While this document assumes that the firmware verifier itself is distinct from the role of the firmware consumer and therefore does not manage the firmware update process, this is not a requirement, and these roles may be combined in practice.",
      "ja": "この文書は、ファームウェア検証プログラム自体がファームウェアの消費者の役割とは異なり、したがってファームウェアの更新プロセスを管理しないと仮定していますが、これは必須ではなく、これらの役割は実際には組み合わされる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Using a bootloader as the firmware verifier requires some special considerations, particularly when the bootloader implements the robustness requirements identified by the IoTSU workshop [RFC8240].",
      "ja": "ブートローダーをファームウェア検証プログラムとして使用する場合、特にIoTSUワークショップ[RFC8240]で特定された堅牢性要件を実装している場合には、いくつかの特別な考慮が必要です。"
    },
    {
      "indent": 0,
      "text": "4.1. The Bootloader",
      "section_title": true,
      "ja": "4.1. ブートローダー"
    },
    {
      "indent": 3,
      "text": "In most cases, the MCU must restart in order to hand over control to the bootloader. Once the MCU has initiated a restart, the bootloader determines whether a newly available firmware image should be executed. If the bootloader concludes that the newly available firmware image is invalid, a recovery strategy is necessary. There are only two approaches for recovering from invalid firmware: either the bootloader must be able to select different, valid firmware or it must be able to obtain new, valid firmware. Both of these approaches have implications for the architecture of the update system.",
      "ja": "ほとんどの場合、MCUはブートローダーに制御を引き渡すために再起動する必要があります。MCUが再起動を開始すると、ブートローダーは新しく利用可能なファームウェアイメージを実行すべきかどうかを判断します。ブートローダーが新しく利用可能なファームウェアイメージが無効であると結論付けた場合、回復戦略が必要です。無効なファームウェアからの回復には、2つのアプローチしかありません。ブートローダーが異なる有効なファームウェアを選択できるようにするか、新しい有効なファームウェアを取得できるようにするかです。これらのアプローチの両方が更新システムのアーキテクチャに影響を与えます。"
    },
    {
      "indent": 3,
      "text": "Assuming the first approach, there are (at least) three firmware images available on the device:",
      "ja": "最初のアプローチを仮定すると、デバイスには（少なくとも）3つのファームウェアイメージが利用可能です。"
    },
    {
      "indent": 6,
      "text": "* First, the bootloader is also firmware. If a bootloader is updatable, then its firmware image is treated like any other application firmware image.",
      "ja": "* 最初に、ブートローダーもファームウェアです。ブートローダーが更新可能な場合、そのファームウェアイメージは他のアプリケーションファームウェアイメージと同様に扱われます。"
    },
    {
      "indent": 6,
      "text": "* Second, the firmware image that has to be replaced is still available on the device as a backup in case the freshly downloaded firmware image does not boot or operate correctly.",
      "ja": "* 次に、交換する必要があるファームウェアイメージは、新しくダウンロードしたファームウェアイメージが正しく起動または動作しない場合のバックアップとして、デバイスにまだ利用可能です。"
    },
    {
      "indent": 6,
      "text": "* Third, there is the newly downloaded firmware image.",
      "ja": "* 三番目に、新しくダウンロードされたファームウェアイメージがあります。"
    },
    {
      "indent": 3,
      "text": "Therefore, the firmware consumer must know where to store the new firmware. In some cases, this may be implicit (for example, replacing the least recently used firmware image). In other cases, the storage location of the new firmware must be explicit, for example, when a device has one or more application firmware images and a recovery image with limited functionality, sufficient only to perform an update.",
      "ja": "したがって、ファームウェアの消費者は新しいファームウェアをどこに保存するかを知っている必要があります。場合によっては、これが暗黙的になることがあります（たとえば、最近使用されていないファームウェアイメージを置き換える場合など）。他の場合では、新しいファームウェアの保存場所を明示的に指定する必要があります。たとえば、デバイスに1つ以上のアプリケーションファームウェアイメージと機能が限定されたリカバリイメージがある場合など、アップデートを実行するのに十分な機能しかない場合など。"
    },
    {
      "indent": 3,
      "text": "Since many low-end IoT devices do not use position-independent code, either the bootloader needs to copy the newly downloaded application firmware image into the location of the old application firmware image and vice versa or multiple versions of the firmware need to be prepared for different locations.",
      "ja": "多くの低価格のIoTデバイスは位置に依存しないコードを使用していないため、ブートローダーは新しくダウンロードされたアプリケーションファームウェアイメージを古いアプリケーションファームウェアイメージの場所にコピーする必要があり、その逆も同様です。または、ファームウェアの複数のバージョンを異なる場所用に準備する必要があります。"
    },
    {
      "indent": 3,
      "text": "In general, it is assumed that the bootloader itself, or a minimal part of it, will not be updated since a failed update of the bootloader poses a reliability risk.",
      "ja": "一般的に、ブートローダー自体、またはその最小限の部分は更新されないと仮定されています。ブートローダーの更新に失敗すると信頼性のリスクが生じるためです。"
    },
    {
      "indent": 3,
      "text": "For a bootloader to offer a secure boot functionality, it needs to implement the following functionality:",
      "ja": "ブートローダーがセキュアブート機能を提供するためには、次の機能を実装する必要があります。"
    },
    {
      "indent": 6,
      "text": "* The bootloader needs to fetch the manifest from nonvolatile storage and parse its contents for subsequent cryptographic verification.",
      "ja": "* ブートローダーは、不揮発性ストレージからマニフェストを取得し、その内容を後続の暗号検証のために解析する必要があります。"
    },
    {
      "indent": 6,
      "text": "* Cryptographic libraries with hash functions, digital signatures (for asymmetric crypto), and message authentication codes (for symmetric crypto) need to be accessible.",
      "ja": "* ハッシュ関数、デジタル署名（非対称暗号用）、およびメッセージ認証コード（対称暗号用）を備えた暗号ライブラリはアクセス可能である必要があります。"
    },
    {
      "indent": 6,
      "text": "* The device needs to have a trust anchor store to verify the digital signature. Alternatively, access to a key store for use with the message authentication code may be used.",
      "ja": "* デバイスにはデジタル署名を検証するための信頼アンカーストアが必要です。また、メッセージ認証コードに使用するためのキーストアへのアクセスを代替として使用することもできます。"
    },
    {
      "indent": 6,
      "text": "* There must be an ability to expose boot-process-related data to the application firmware (such as the status tracker). This allows information sharing about the current firmware version and the status of the firmware update process and whether errors have occurred.",
      "ja": "* アプリケーションファームウェアにブートプロセス関連のデータを公開する機能が必要です（たとえば、ステータストラッカーなど）。これにより、現在のファームウェアバージョンやファームウェア更新プロセスの状態、エラーが発生したかどうかについて情報共有が可能になります。"
    },
    {
      "indent": 6,
      "text": "* Produce boot measurements as part of an attestation solution; see [RATS-ARCH] for more information (optional).",
      "ja": "* アテステーションソリューションの一環としてブートの測定値を生成します。詳細については[RATS-ARCH]を参照してください（オプション）。"
    },
    {
      "indent": 6,
      "text": "* The bootloader must be able to decrypt firmware images in case confidentiality protection was applied. This requires a solution for key management (optional).",
      "ja": "* ブートローダーは、機密保護が適用された場合にファームウェアイメージを復号化できる必要があります。これには、キー管理の解決策が必要です（オプション）。"
    },
    {
      "indent": 0,
      "text": "5. Types of IoT Devices",
      "section_title": true,
      "ja": "5. IoTデバイスの種類"
    },
    {
      "indent": 3,
      "text": "Today, there are billions of MCUs used in devices produced by a large number of silicon manufacturers. While MCUs can vary significantly in their characteristics, there are a number of similarities that allow us to categorize them into groups.",
      "ja": "今日、多くのシリコンメーカーによって製造されたデバイスで使用されているMCUは数十億個あります。MCUは特性にかなりの違いがあることがありますが、いくつかの類似点があり、それによってグループに分類することができます。"
    },
    {
      "indent": 3,
      "text": "The firmware update architecture, and the manifest format in particular, needs to offer enough flexibility to cover these common deployment cases.",
      "ja": "ファームウェアの更新アーキテクチャ、特にマニフェスト形式は、これらの一般的な展開ケースをカバーするために十分な柔軟性を提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1. Single MCU",
      "section_title": true,
      "ja": "5.1. 単一の MCU"
    },
    {
      "indent": 3,
      "text": "The simplest and currently most common architecture consists of a single MCU along with its own peripherals. These SoCs generally contain some amount of flash memory for code and fixed data, as well as RAM for working storage. A notable characteristic of these SoCs is that the primary code is generally execute in place (XIP). Due to the non-relocatable nature of the code, the firmware image needs to be placed in a specific location in flash memory since the code cannot be executed from an arbitrary location therein. Hence, when the firmware image is updated, it is necessary to swap the old and the new image.",
      "ja": "最も単純で現在最も一般的なアーキテクチャは、単一のMCUとその固有の周辺機器で構成されています。これらのSoCには、通常、コードと固定データ用の一定量のフラッシュメモリと、作業用のRAMが含まれています。これらのSoCの特徴の1つは、主要なコードが一般的に実行中にあることです（XIP）。コードの移動できない性質のため、ファームウェアイメージは、コードを任意の場所から実行できないため、フラッシュメモリ内の特定の場所に配置する必要があります。したがって、ファームウェアイメージを更新する際には、古いイメージと新しいイメージを交換する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2. Single CPU with Partitioning between Secure Mode and Normal Mode",
      "section_title": true,
      "ja": "5.2. セキュアモードと通常モードの間でパーティションを持つ単一のCPU"
    },
    {
      "indent": 3,
      "text": "Another configuration consists of a similar architecture to the one previously discussed: it contains a single CPU. However, this CPU supports a security partitioning scheme that allows memory and other system components to be divided into secure and normal mode. There will generally be two images: one for secure mode and one for normal mode. In this configuration, firmware upgrades will generally be done by the CPU in secure mode, which is able to write to both areas of the flash device. In addition, there are requirements to be able to update either image independently as well as to update them together atomically, as specified in the associated manifests.",
      "ja": "別の構成は、以前に議論されたものと類似したアーキテクチャで構成されています：単一のCPUを含んでいます。ただし、このCPUはセキュリティパーティショニングスキームをサポートしており、メモリや他のシステムコンポーネントをセキュアモードと通常モードに分割することができます。通常、2つのイメージが存在します：セキュアモード用の1つと通常モード用の1つです。この構成では、ファームウェアのアップグレードは通常、フラッシュデバイスの両方の領域に書き込むことができるセキュアモードのCPUによって行われます。さらに、関連するマニフェストで指定されているように、各イメージを独立して更新したり、それらを一緒にアトミックに更新したりする要件があります。"
    },
    {
      "indent": 0,
      "text": "5.3. Symmetric Multiple CPUs",
      "section_title": true,
      "ja": "5.3. 対称的な複数のCPU"
    },
    {
      "indent": 3,
      "text": "In more complex SoCs with symmetric multiprocessing support, advanced operating systems, such as Linux, are often used. These SoCs frequently use an external storage medium, such as raw NAND flash or an embedded Multimedia Card (eMMC). Due to the higher quantity of resources, these devices are often capable of storing multiple copies of their firmware images and selecting the most appropriate one to boot. Many SoCs also support bootloaders that are capable of updating the firmware image; however, this is typically a last resort because it requires the device to be held in the bootloader while the new firmware is downloaded and installed, which results in downtime for the device. Firmware updates in this class of device are typically not done in place.",
      "ja": "より複雑なSoC（System on Chip）では、対称マルチプロセッシングをサポートするために、Linuxなどの高度なオペレーティングシステムがよく使用されます。これらのSoCは、通常、raw NANDフラッシュや組み込みマルチメディアカード（eMMC）などの外部ストレージメディアを使用します。リソースの量が多いため、これらのデバイスは通常、複数のファームウェアイメージを保存し、最適なものをブートすることができます。多くのSoCは、ファームウェアイメージを更新できるブートローダーもサポートしていますが、これは通常最終手段とされます。なぜなら、新しいファームウェアがダウンロードされてインストールされる間、デバイスをブートローダーで保持する必要があり、その結果、デバイスのダウンタイムが発生します。このクラスのデバイスでのファームウェアの更新は、通常、その場で行われません。"
    },
    {
      "indent": 0,
      "text": "5.4. Dual CPU, Shared Memory",
      "section_title": true,
      "ja": "5.4. デュアルCPU、共有メモリ"
    },
    {
      "indent": 3,
      "text": "This configuration has two or more heterogeneous CPUs in a single SoC that share memory (flash and RAM). Generally, there will be a mechanism to prevent one CPU from unintentionally accessing memory currently allocated to the other. Upgrades in this case will typically be done by one of the CPUs and is similar to the single CPU with secure mode.",
      "ja": "この構成には、1つのSoC内に2つ以上の異種CPUがあり、メモリ（フラッシュおよびRAM）を共有しています。一般的に、1つのCPUが他のCPUに割り当てられているメモリに意図せずアクセスすることを防ぐメカニズムがあります。この場合、アップグレードは通常、1つのCPUによって行われ、セキュアモードを備えた単一CPUと類似しています。"
    },
    {
      "indent": 0,
      "text": "5.5. Dual CPU, Other Bus",
      "section_title": true,
      "ja": "5.5. デュアルCPU、その他のバス"
    },
    {
      "indent": 3,
      "text": "This configuration has two or more heterogeneous CPUs, each having their own memory. There will be a communication channel between them, but it will be used as a peripheral, not via shared memory. In this case, each CPU will have to be responsible for its own firmware upgrade. It is likely that one of the CPUs will be considered the primary CPU and will direct the other CPU to do the upgrade. This configuration is commonly used to offload specific work to other CPUs. Firmware dependencies are similar to the other solutions above: sometimes allowing only one image to be upgraded, other times requiring several to be upgraded atomically. Because the updates are happening on multiple CPUs, upgrading the two images atomically is challenging.",
      "ja": "この構成には、それぞれが独自のメモリを持つ2つ以上の異種CPUがあります。それらの間に通信チャネルがありますが、それは周辺機器として使用され、共有メモリを介してではありません。この場合、各CPUは独自のファームウェアのアップグレードに責任を持たなければなりません。おそらく、CPUの1つが主CPUと見なされ、他のCPUにアップグレードを指示するでしょう。この構成は、特定の作業を他のCPUにオフロードするために一般的に使用されます。ファームウェアの依存関係は、上記の他のソリューションと同様です：時には1つのイメージのみをアップグレードできる場合もあり、他の場合は複数のイメージを原子的にアップグレードする必要がある場合もあります。複数のCPUで更新が行われるため、2つのイメージを原子的にアップグレードすることは難しいです。"
    },
    {
      "indent": 0,
      "text": "6. Manifests",
      "section_title": true,
      "ja": "6. マニフェスト"
    },
    {
      "indent": 3,
      "text": "In order for a firmware consumer to apply an update, it has to make several decisions using manifest-provided information and data available on the device itself. For more detailed information and a longer list of information elements in the manifest, consult the information model specification [SUIT-INFO-MODEL], which offers justifications for each element, and the manifest specification [SUIT-MANIFEST] for details about how this information is included in the manifest.",
      "ja": "ファームウェアの消費者が更新を適用するためには、マニフェストで提供される情報とデバイス自体で利用可能なデータを使用して、いくつかの決定をする必要があります。マニフェスト内の情報要素の詳細や長いリストについては、情報モデル仕様[SUIT-INFO-MODEL]を参照してください。この仕様では、各要素の正当性が説明されており、マニフェスト仕様[SUIT-MANIFEST]では、この情報がマニフェストにどのように含まれるかの詳細が記載されています。"
    },
    {
      "indent": 4,
      "text": "+==========================+=====================================+\n|                 Decision | Information Elements                |\n+==========================+=====================================+\n|       Should I trust the | Trust anchors and authorization     |\n|  author of the firmware? | policies on the device              |\n+--------------------------+-------------------------------------+\n|    Has the firmware been | Digital signature and MAC covering  |\n|               corrupted? | the firmware image                  |\n+--------------------------+-------------------------------------+\n| Does the firmware update | Conditions with Vendor ID, Class    |\n|    apply to this device? | ID, and Device ID                   |\n+--------------------------+-------------------------------------+\n| Is the update older than | Sequence number in the manifest (1) |\n|     the active firmware? |                                     |\n+--------------------------+-------------------------------------+\n|   When should the device | Wait directive                      |\n|        apply the update? |                                     |\n+--------------------------+-------------------------------------+\n|    How should the device | Manifest commands                   |\n|        apply the update? |                                     |\n+--------------------------+-------------------------------------+\n|    What kind of firmware | Unpack algorithms to interpret a    |\n|            binary is it? | format                              |\n+--------------------------+-------------------------------------+\n|  Where should the update | Dependencies on other manifests and |\n|             be obtained? | firmware image URI in the manifest  |\n+--------------------------+-------------------------------------+\n|         Where should the | Storage location and component      |\n|      firmware be stored? | identifier                          |\n+--------------------------+-------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Table 1: Example Firmware Update Decisions",
      "ja": "テーブル1：ファームウェア更新の例"
    },
    {
      "indent": 3,
      "text": "(1):",
      "ja": "(1):"
    },
    {
      "indent": 12,
      "text": "A device presented with an old but valid manifest and firmware must not be tricked into installing such firmware since a vulnerability in the old firmware image may allow an attacker to gain control of the device.",
      "ja": "古いが有効なマニフェストとファームウェアが提示されたデバイスは、古いファームウェアイメージの脆弱性により攻撃者がデバイスの制御を取得する可能性があるため、そのようなファームウェアをインストールするようにだまされてはなりません。"
    },
    {
      "indent": 3,
      "text": "Keeping the code size and complexity of a manifest parser small is important for constrained IoT devices. Since the manifest parsing code may also be used by the bootloader, it can be part of the trusted computing base.",
      "ja": "制約のあるIoTデバイスにとって、マニフェストパーサーのコードサイズと複雑さを小さく保つことは重要です。マニフェスト解析コードはブートローダーでも使用される可能性があるため、信頼できるコンピューティングベースの一部となることがあります。"
    },
    {
      "indent": 3,
      "text": "A manifest may be used to protect not only firmware images but also configuration data such as network credentials or personalization data related to the firmware or software. Personalization data demonstrates the need for confidentiality to be maintained between two or more stakeholders that deliver images to the same device. Personalization data is used with TEEs, which benefit from a protocol for managing the life cycle of TAs running inside a TEE. TEEs may obtain TAs from different authors, and those TAs may require personalization data, such as payment information, to be securely conveyed to the TEE. The TA's author does not want to expose the TA's code to any other stakeholder or third party. The user does not want to expose the payment information to any other stakeholder or third party.",
      "ja": "マニフェストは、ファームウェアイメージだけでなく、ネットワークの資格情報やファームウェアやソフトウェアに関連する個人化データなどの構成データを保護するために使用できます。個人化データは、同じデバイスにイメージを提供する2つ以上の利害関係者の間で機密性を維持する必要があることを示しています。個人化データはTEE（信頼実行環境）と共に使用され、TEE内で実行されるTA（信頼されたアプリケーション）のライフサイクルを管理するためのプロトコルから利益を得ます。TEEは異なる著者からTAを取得することがあり、それらのTAには支払い情報などの個人化データがTEEに安全に伝達される必要があります。TAの著者はTAのコードを他の利害関係者や第三者に公開したくありません。ユーザーは支払い情報を他の利害関係者や第三者に公開したくありません。"
    },
    {
      "indent": 0,
      "text": "7. Securing Firmware Updates",
      "section_title": true,
      "ja": "7. ファームウェアの更新を保護する"
    },
    {
      "indent": 3,
      "text": "Using firmware updates to fix vulnerabilities in devices is important, but securing this update mechanism is equally important since security problems are exacerbated by the update mechanism. An update is essentially authorized remote code execution, so any security problems in the update process expose that remote code execution system. Failure to secure the firmware update process will help attackers take control of devices.",
      "ja": "デバイスの脆弱性を修正するためにファームウェアの更新を使用することは重要ですが、この更新メカニズムを保護することも同様に重要です。セキュリティの問題は更新メカニズムによって悪化するためです。更新は基本的に認可されたリモートコード実行であり、更新プロセスのセキュリティの問題はそのリモートコード実行システムをさらけ出します。ファームウェア更新プロセスを保護しないと、攻撃者がデバイスを制御するのを助けることになります。"
    },
    {
      "indent": 3,
      "text": "End-to-end security mechanisms are used to protect the firmware image and the manifest. The following assumptions are made to allow the firmware consumer to verify the received firmware image and manifest before updating the software:",
      "ja": "ファームウェアイメージとマニフェストを保護するためにエンドツーエンドのセキュリティメカニズムが使用されています。ソフトウェアを更新する前に、ファームウェアの受信イメージとマニフェストを確認するために、次の前提がなされています。"
    },
    {
      "indent": 6,
      "text": "* Authentication ensures that the device can cryptographically identify the author(s) creating firmware images and manifests. Authenticated identities may be used as input to the authorization process. Not all entities creating and signing manifests have the same permissions. A device needs to determine whether the requested action is indeed covered by the permission of the party that signed the manifest. Informing the device about the permissions of the different parties also happens in an out-of-band fashion and is a duty of the Trust Provisioning Authority.",
      "ja": "* 認証は、デバイスがファームウェアイメージやマニフェストを作成する著者を暗号的に識別できることを保証します。認証されたアイデンティティは、認可プロセスの入力として使用される可能性があります。マニフェストを作成し署名するすべてのエンティティが同じ権限を持っているわけではありません。デバイスは、要求されたアクションが実際にマニフェストを署名した当事者の権限によってカバーされているかどうかを判断する必要があります。さまざまな当事者の権限についてデバイスに通知することも、アウトオブバンドの方法で行われ、信頼プロビジョニング機関の責務です。"
    },
    {
      "indent": 6,
      "text": "* Integrity protection ensures that no third party can modify the manifest or the firmware image. To accept an update, a device needs to verify the signature covering the manifest. There may be one or multiple manifests that need to be validated, potentially signed by different parties. The device needs to be in possession of the trust anchors to verify those signatures. Installing trust anchors to devices via the Trust Provisioning Authority happens in an out-of-band fashion prior to the firmware update process.",
      "ja": "* 整合性保護は、第三者がマニフェストやファームウェアイメージを変更できないようにします。アップデートを受け入れるために、デバイスはマニフェストをカバーする署名を検証する必要があります。検証する必要があるマニフェストは1つまたは複数あり、異なる当事者によって署名されている可能性があります。デバイスは、これらの署名を検証するための信頼アンカーを所有している必要があります。信頼アンカーをデバイスにインストールすることは、ファームウェアアップデートプロセスの前に、信頼プロビジョニング機関を介してアウトオブバンドで行われます。"
    },
    {
      "indent": 6,
      "text": "* Confidentiality protection of the firmware image must be done in such a way that no one aside from the intended firmware consumer(s) and other authorized parties can decrypt it. The information that is encrypted individually for each device/ recipient must be done in a way that is usable with Content Distribution Networks (CDNs), bulk storage, and broadcast protocols. For confidentiality protection of firmware images, the author needs to be in possession of the certificate/public key or a pre-shared key of a device. The use of confidentiality protection of firmware images is optional.",
      "ja": "* ファームウェアイメージの機密保護は、意図されたファームウェアの消費者以外の誰もがそれを復号化できないように行われなければなりません。個々のデバイス/受信者ごとに暗号化された情報は、コンテンツ配信ネットワーク（CDN）、大容量ストレージ、および放送プロトコルと互換性のある方法で行われなければなりません。ファームウェアイメージの機密保護のために、著者はデバイスの証明書/公開鍵または事前共有鍵を所有している必要があります。ファームウェアイメージの機密保護の使用は任意です。"
    },
    {
      "indent": 3,
      "text": "A manifest specification must support different cryptographic algorithms and algorithm extensibility. Moreover, since signature schemes based on RSA and Elliptic Curve Cryptography (ECC) may become vulnerable to quantum-accelerated key extraction in the future, unchangeable bootloader code in ROM is recommended to use post-quantum secure signature schemes such as hash-based signatures [RFC8778]. A bootloader author must carefully consider the service lifetime of their product and the time horizon for quantum-accelerated key extraction. At the time of writing, the worst-case estimate for the time horizon to key extraction with quantum acceleration is approximately 2030, based on current research [quantum-factorization].",
      "ja": "マニフェスト仕様は、異なる暗号アルゴリズムとアルゴリズムの拡張性をサポートする必要があります。さらに、RSAおよび楕円曲線暗号（ECC）に基づく署名スキームは、将来的には量子加速鍵抽出に対して脆弱になる可能性があるため、ROM内の変更できないブートローダーコードには、ハッシュベースの署名などの量子後の安全な署名スキーム[RFC8778]を使用することが推奨されます。ブートローダーの作成者は、製品のサービス寿命と量子加速鍵抽出の時間軸を慎重に考慮する必要があります。執筆時点では、量子加速による鍵抽出の時間軸の最悪の見積もりは、現在の研究に基づいて約2030年です[量子因数分解]。"
    },
    {
      "indent": 3,
      "text": "When a device obtains a monolithic firmware image from a single author without any additional approval steps, the authorization flow is relatively simple. However, there are other cases where more complex policy decisions need to be made before updating a device.",
      "ja": "デバイスが単一の著者からモノリシックファームウェアイメージを取得し、追加の承認手続きがない場合、認証フローは比較的単純です。ただし、デバイスを更新する前により複雑なポリシー決定が必要な他のケースもあります。"
    },
    {
      "indent": 3,
      "text": "In this architecture, the authorization policy is separated from the underlying communication architecture. This is accomplished by separating the entities from their permissions. For example, an author may not have the authority to install a firmware image on a device in critical infrastructure without the authorization of a device operator. In this case, the device may be programmed to reject firmware updates unless they are signed both by the firmware author and by the device operator.",
      "ja": "このアーキテクチャでは、認可ポリシーが基礎となる通信アーキテクチャから分離されています。これは、エンティティをその権限から分離することによって達成されます。例えば、著者は、重要なインフラストラクチャのデバイスにファームウェアイメージをインストールする権限を持っていないかもしれません。その場合、デバイスは、ファームウェアの更新がファームウェアの著者とデバイスオペレーターの両方によって署名されていない限り、更新を拒否するようにプログラムされているかもしれません。"
    },
    {
      "indent": 3,
      "text": "Alternatively, a device may trust precisely one entity that does all permission management and coordination. This entity allows the device to offload complex permissions calculations for the device.",
      "ja": "代わりに、デバイスは、すべての許可管理と調整を行う1つのエンティティを信頼することができます。このエンティティは、デバイスが複雑な許可計算をオフロードすることを可能にします。"
    },
    {
      "indent": 0,
      "text": "8. Example",
      "section_title": true,
      "ja": "8. ### Translation ###\n\nExample: 例"
    },
    {
      "indent": 3,
      "text": "Figure 2 illustrates an example message flow for distributing a firmware image to a device. The firmware and manifest are stored on the same firmware server and distributed in a detached manner.",
      "ja": "図2は、ファームウェアイメージをデバイスに配信するためのメッセージフローの例を示しています。ファームウェアとマニフェストは同じファームウェアサーバーに保存され、切り離された方法で配布されます。"
    },
    {
      "indent": 3,
      "text": "+--------+    +-----------------+    +-----------------------------+\n|        |    | Firmware Server |    |         IoT Device          |\n| Author |    | Status Tracker  |    | +------------+ +----------+ |\n+--------+    | Server          |    | |  Firmware  | |Bootloader| |\n  |           +-----------------+    | |  Consumer  | |          | |\n  |                   |              | +------------+ +----------+ |\n  |                   |              |      |                |     |\n  |                   |              |  +-----------------------+  |\n  | Create Firmware   |              |  | Status Tracker Client |  |\n  |--------------+    |              |  +-----------------------+  |\n  |              |    |               `''''''''''''''''''''''''''''\n  |<-------------+    |                     |        |       |\n  |                   |                     |        |       |\n  | Upload Firmware   |                     |        |       |\n  |------------------>|                     |        |       |\n  |                   |                     |        |       |\n  | Create Manifest   |                     |        |       |\n  |---------------+   |                     |        |       |\n  |               |   |                     |        |       |\n  |<--------------+   |                     |        |       |\n  |                   |                     |        |       |\n  | Sign Manifest     |                     |        |       |\n  |-------------+     |                     |        |       |\n  |             |     |                     |        |       |\n  |<------------+     |                     |        |       |\n  |                   |                     |        |       |\n  | Upload Manifest   |                     |        |       |\n  |------------------>|  Notification of    |        |       |\n  |                   |  new firmware image |        |       |\n  |                   |----------------------------->|       |\n  |                   |                     |        |       |\n  |                   |                     |Initiate|       |\n  |                   |                     | Update |       |\n  |                   |                     |<-------|       |\n  |                   |                     |        |       |\n  |                   |   Query Manifest    |        |       |\n  |                   |<--------------------|        .       |\n  |                   |                     |        .       |\n  |                   |   Send Manifest     |        .       |\n  |                   |-------------------->|        .       |\n  |                   |                     | Validate       |\n  |                   |                     | Manifest       |\n  |                   |                     |--------+       |\n  |                   |                     |        |       |\n  |                   |                     |<-------+       |\n  |                   |                     |        .       |\n  |                   |  Request Firmware   |        .       |\n  |                   |<--------------------|        .       |\n  |                   |                     |        .       |\n  |                   | Send Firmware       |        .       |\n  |                   |-------------------->|        .       |\n  |                   |                     | Verify .       |\n  |                   |                     | Firmware       |\n  |                   |                     |--------+       |\n  |                   |                     |        |       |\n  |                   |                     |<-------+       |\n  |                   |                     |        .       |\n  |                   |                     | Store  .       |\n  |                   |                     | Firmware       |\n  |                   |                     |--------+       |\n  |                   |                     |        |       |\n  |                   |                     |<-------+       |\n  |                   |                     |        .       |\n  |                   |                     |        .       |\n  |                   |                     |        .       |\n  |                   |                     |        |       |\n  |                   |                     | Update |       |\n  |                   |                     |Complete|       |\n  |                   |                     |------->|       |\n  |                   |                              |       |\n  |                   |  Firmware Update Completed   |       |\n  |                   |<-----------------------------|       |\n  |                   |                              |       |\n  |                   |  Reboot                      |       |\n  |                   |----------------------------->|       |\n  |                   |                     |        |       |\n  |                   |                     |        |       |\n  |                   |                     |        |Reboot |\n  |                   |                     |        |------>|\n  |                   |                     |        |       |\n  |                   |                     |        .       |\n  |                   |                 +---+----------------+--+\n  |                   |                S|   |                |  |\n  |                   |                E|   | Verify         |  |\n  |                   |                C|   | Firmware       |  |\n  |                   |                U|   | +--------------|  |\n  |                   |                R|   | |              |  |\n  |                   |                E|   | +------------->|  |\n  |                   |                 |   |                |  |\n  |                   |                B|   | Activate new   |  |\n  |                   |                O|   | Firmware       |  |\n  |                   |                O|   | +--------------|  |\n  |                   |                T|   | |              |  |\n  |                   |                 |   | +------------->|  |\n  |                   |                P|   |                |  |\n  |                   |                R|   | Boot new       |  |\n  |                   |                O|   | Firmware       |  |\n  |                   |                C|   | +--------------|  |\n  |                   |                E|   | |              |  |\n  |                   |                S|   | +------------->|  |\n  |                   |                S|   |                |  |\n  |                   |                 +---+----------------+--+\n  |                   |                     |        .       |\n  |                   |                     |        |       |\n  |                   |                     .        |       |\n  |                   |  Device running new firmware |       |\n  |                   |<-----------------------------|       |\n  |                   |                     .        |       |\n  |                   |                              |       |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 2: First Example Flow for a Firmware Update",
      "ja": "図2：ファームウェアアップデートの最初の例のフロー"
    },
    {
      "indent": 3,
      "text": "Figure 3 shows an exchange that starts with the status tracker querying the device for its current firmware version. Later, a new firmware version becomes available, and since this device is running an older version, the status tracker server interacts with the device to initiate an update.",
      "ja": "図3は、ステータストラッカーがデバイスに現在のファームウェアバージョンを問い合わせることから始まる交換を示しています。後に新しいファームウェアバージョンが利用可能になり、このデバイスが古いバージョンを実行しているため、ステータストラッカーサーバーはデバイスとやり取りして更新を開始します。"
    },
    {
      "indent": 3,
      "text": "The manifest and the firmware are stored on different servers in this example. When the device processes the manifest, it learns where to download the new firmware version. The firmware consumer downloads the firmware image with the newer version X.Y.Z after successful validation of the manifest. Subsequently, a reboot is initiated, and the secure boot process starts. Finally, the device reports the successful boot of the new firmware version.",
      "ja": "この例では、マニフェストとファームウェアは異なるサーバーに保存されています。デバイスがマニフェストを処理すると、新しいファームウェアバージョンをダウンロードする場所がわかります。ファームウェアの消費者は、マニフェストの正常な検証後に新しいバージョンX.Y.Zのファームウェアイメージをダウンロードします。その後、再起動が開始され、セキュアブートプロセスが開始されます。最後に、デバイスは新しいファームウェアバージョンの正常な起動を報告します。"
    },
    {
      "indent": 4,
      "text": "+---------+   +-----------------+    +-----------------------------+\n| Status  |   | Firmware Server |    | +------------+ +----------+ |\n| Tracker |   | Status Tracker  |    | |  Firmware  | |Bootloader| |\n| Server  |   | Server          |    | |  Consumer  | |          | |\n+---------+   +-----------------+    | |  +Status   | +----------+ |\n     |                |              | |  Tracker   |        |     |\n     |                |              | |  Client    |        |     |\n     |                |              | +------------+        |     |\n     |                |              |      |  IoT Device    |     |\n     |                |               `''''''''''''''''''''''''''''\n     |                |                     |                |\n     |        Query Firmware Version        |                |\n     |------------------------------------->|                |\n     |        Firmware Version A.B.C        |                |\n     |<-------------------------------------|                |\n     |                |                     |                |\n     |         <<some time later>>          |                |\n     |                |                     |                |\n   _,...._         _,...._                  |                |\n ,'       `.     ,'       `.                |                |\n|   New     |   |   New     |               |                |\n\\ Manifest  /   \\ Firmware  /               |                |\n `.._   _,,'     `.._   _,,'                |                |\n     `''             `''                    |                |\n     |            Push manifest             |                |\n     |----------------+-------------------->|                |\n     |                |                     |                |\n     |                '                     |                '\n     |                |                     | Validate       |\n     |                |                     | Manifest       |\n     |                |                     |---------+      |\n     |                |                     |         |      |\n     |                |                     |<--------+      |\n     |                | Request firmware    |                |\n     |                | X.Y.Z               |                |\n     |                |<--------------------|                |\n     |                |                     |                |\n     |                | Firmware X.Y.Z      |                |\n     |                |-------------------->|                |\n     |                |                     |                |\n     |                |                     | Verify         |\n     |                |                     | Firmware       |\n     |                |                     |--------------+ |\n     |                |                     |              | |\n     |                |                     |<-------------+ |\n     |                |                     |                |\n     |                |                     | Store          |\n     |                |                     | Firmware       |\n     |                |                     |-------------+  |\n     |                |                     |             |  |\n     |                |                     |<------------+  |\n     |                |                     |                |\n     |                |                     |                |\n     |                |                     | Trigger Reboot |\n     |                |                     |--------------->|\n     |                |                     |                |\n     |                |                     |                |\n     |                |                     | __..-------..._'\n     |                |                    ,-'               `-.\n     |                |                   |      Secure Boot    |\n     |                |                   `-.                 _/\n     |                |                     |`--..._____,,.,-'\n     |                |                     |                |\n     | Device running firmware X.Y.Z        |                |\n     |<-------------------------------------|                |\n     |                |                     |                |\n     |                |                     |                |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "Figure 3: Second Example Flow for a Firmware Update",
      "ja": "図3：ファームウェアアップデートのための2番目の例のフロー"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "この文書には IANA のアクションはありません。"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document describes the terminology, requirements, and an architecture for firmware updates of IoT devices. The content of the document is thereby focused on improving the security of IoT devices via firmware update mechanisms and informs the standardization of a manifest format.",
      "ja": "この文書は、IoTデバイスのファームウェア更新の用語、要件、およびアーキテクチャについて説明しています。文書の内容は、ファームウェア更新メカニズムを通じてIoTデバイスのセキュリティを向上させることに焦点を当てており、マニフェスト形式の標準化に関する情報を提供しています。"
    },
    {
      "indent": 3,
      "text": "An in-depth examination of the security considerations of the architecture is presented in [SUIT-INFO-MODEL].",
      "ja": "アーキテクチャのセキュリティに関する詳細な検討は、[SUIT-INFO-MODEL]で示されています。"
    },
    {
      "indent": 0,
      "text": "11. Informative References",
      "section_title": true,
      "ja": "11. 参考引用"
    },
    {
      "indent": 3,
      "text": "[LwM2M]    Open Mobile Alliance, \"Lightweight Machine to Machine\n           Technical Specification\", Version 1.0.2, February 2018,\n           <http://www.openmobilealliance.org/release/LightweightM2M/\n           V1_0_2-20180209-A/OMA-TS-LightweightM2M-\n           V1_0_2-20180209-A.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[quantum-factorization]\n           Jiang, S., Britt, K.A., McCaskey, A.J., Humble, T.S., and\n           S. Kais, \"Quantum Annealing for Prime Factorization\",\n           Scientific Reports 8, December 2018,\n           <https://www.nature.com/articles/s41598-018-36058-z>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RATS-ARCH]\n           Birkholz, H., Thaler, D., Richardson, M., Smith, N., and\n           W. Pan, \"Remote Attestation Procedures Architecture\", Work\n           in Progress, Internet-Draft, draft-ietf-rats-architecture-\n           12, 23 April 2021, <https://tools.ietf.org/html/draft-\n           ietf-rats-architecture-12>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6024]  Reddy, R. and C. Wallace, \"Trust Anchor Management\n           Requirements\", RFC 6024, DOI 10.17487/RFC6024, October\n           2010, <https://www.rfc-editor.org/info/rfc6024>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6763]  Cheshire, S. and M. Krochmal, \"DNS-Based Service\n           Discovery\", RFC 6763, DOI 10.17487/RFC6763, February 2013,\n           <https://www.rfc-editor.org/info/rfc6763>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7228]  Bormann, C., Ersue, M., and A. Keranen, \"Terminology for\n           Constrained-Node Networks\", RFC 7228,\n           DOI 10.17487/RFC7228, May 2014,\n           <https://www.rfc-editor.org/info/rfc7228>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8240]  Tschofenig, H. and S. Farrell, \"Report from the Internet\n           of Things Software Update (IoTSU) Workshop 2016\",\n           RFC 8240, DOI 10.17487/RFC8240, September 2017,\n           <https://www.rfc-editor.org/info/rfc8240>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8778]  Housley, R., \"Use of the HSS/LMS Hash-Based Signature\n           Algorithm with CBOR Object Signing and Encryption (COSE)\",\n           RFC 8778, DOI 10.17487/RFC8778, April 2020,\n           <https://www.rfc-editor.org/info/rfc8778>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SUIT-INFO-MODEL]\n           Moran, B., Tschofenig, H., and H. Birkholz, \"A Manifest\n           Information Model for Firmware Updates in IoT Devices\",\n           Work in Progress, Internet-Draft, draft-ietf-suit-\n           information-model-11, 6 April 2021,\n           <https://tools.ietf.org/html/draft-ietf-suit-information-\n           model-11>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SUIT-MANIFEST]\n           Moran, B., Tschofenig, H., Birkholz, H., and K. Zandberg,\n           \"A Concise Binary Object Representation (CBOR)-based\n           Serialization Format for the Software Updates for Internet\n           of Things (SUIT) Manifest\", Work in Progress, Internet-\n           Draft, draft-ietf-suit-manifest-12, 22 February 2021,\n           <https://tools.ietf.org/html/draft-ietf-suit-manifest-12>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[TEEP-ARCH]\n           Pei, M., Tschofenig, H., Thaler, D., and D. Wheeler,\n           \"Trusted Execution Environment Provisioning (TEEP)\n           Architecture\", Work in Progress, Internet-Draft, draft-\n           ietf-teep-architecture-14, 22 February 2021,\n           <https://tools.ietf.org/html/draft-ietf-teep-architecture-\n           14>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "section_title": true,
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "We would like to thank the following individuals for their feedback:",
      "ja": "次の個人に感謝したいと思います。彼らのフィードバックに感謝します。"
    },
    {
      "indent": 6,
      "text": "* Geraint Luff",
      "ja": "* ゲレイン・ラフ"
    },
    {
      "indent": 6,
      "text": "* Amyas Phillips",
      "ja": "* アミアス・フィリップス"
    },
    {
      "indent": 6,
      "text": "* Dan Ros",
      "ja": "* ダン・ロス"
    },
    {
      "indent": 6,
      "text": "* Thomas Eichinger",
      "ja": "* トーマス・アイキンガー"
    },
    {
      "indent": 6,
      "text": "* Michael Richardson",
      "ja": "* マイケル・リチャードソン"
    },
    {
      "indent": 6,
      "text": "* Emmanuel Baccelli",
      "ja": "* エマニュエル・バチェリ"
    },
    {
      "indent": 6,
      "text": "* Ned Smith",
      "ja": "* ネッド・スミス"
    },
    {
      "indent": 6,
      "text": "* Jim Schaad",
      "ja": "* ジム・シャード"
    },
    {
      "indent": 6,
      "text": "* Carsten Bormann",
      "ja": "* カーステン・ボルマン"
    },
    {
      "indent": 6,
      "text": "* Cullen Jennings",
      "ja": "* Cullen Jennings"
    },
    {
      "indent": 6,
      "text": "* Olaf Bergmann",
      "ja": "* オラフ・ベルグマン"
    },
    {
      "indent": 6,
      "text": "* Suhas Nandakumar",
      "ja": "* スハス・ナンダクマール"
    },
    {
      "indent": 6,
      "text": "* Phillip Hallam-Baker",
      "ja": "* フィリップ・ハラム＝ベイカー"
    },
    {
      "indent": 6,
      "text": "* Marti Bolivar",
      "ja": "* マルティ・ボリバール"
    },
    {
      "indent": 6,
      "text": "* Andrzej Puzdrowski",
      "ja": "* Andrzej Puzdrowski"
    },
    {
      "indent": 6,
      "text": "* Markus Gueller",
      "ja": "* Markus Gueller"
    },
    {
      "indent": 6,
      "text": "* Henk Birkholz",
      "ja": "* ヘンク・ビルクホルツ"
    },
    {
      "indent": 6,
      "text": "* Jintao Zhu",
      "ja": "* Jintao Zhu"
    },
    {
      "indent": 6,
      "text": "* Takeshi Takahashi",
      "ja": "* Takeshi Takahashi"
    },
    {
      "indent": 6,
      "text": "* Jacob Beningo",
      "ja": "* ジェイコブ・ベニンゴ"
    },
    {
      "indent": 6,
      "text": "* Kathleen Moriarty",
      "ja": "* Kathleen Moriarty"
    },
    {
      "indent": 6,
      "text": "* Bob Briscoe",
      "ja": "* Bob Briscoe"
    },
    {
      "indent": 6,
      "text": "* Roman Danyliw",
      "ja": "* Roman Danyliw"
    },
    {
      "indent": 6,
      "text": "* Brian Carpenter",
      "ja": "* Brian Carpenter --> ブライアン・カーペンター"
    },
    {
      "indent": 6,
      "text": "* Theresa Enghardt",
      "ja": "* テレサ・エンガルト"
    },
    {
      "indent": 6,
      "text": "* Rich Salz",
      "ja": "* リッチ・サルツ"
    },
    {
      "indent": 6,
      "text": "* Mohit Sethi",
      "ja": "* モヒット・セティ"
    },
    {
      "indent": 6,
      "text": "* Éric Vyncke",
      "ja": "* Éric Vyncke"
    },
    {
      "indent": 6,
      "text": "* Alvaro Retana",
      "ja": "* アルバロ・レタナ"
    },
    {
      "indent": 6,
      "text": "* Barry Leiba",
      "ja": "* バリー・ライバ"
    },
    {
      "indent": 6,
      "text": "* Benjamin Kaduk",
      "ja": "* ベンジャミン・カダック"
    },
    {
      "indent": 6,
      "text": "* Martin Duke",
      "ja": "* マーティン・デューク"
    },
    {
      "indent": 6,
      "text": "* Robert Wilton",
      "ja": "* ロバート・ウィルトン"
    },
    {
      "indent": 3,
      "text": "We would also like to thank the WG chairs, Russ Housley, David Waltermire, and Dave Thaler for their support and review.",
      "ja": "私たちは、WGチェアのRuss Housley、David Waltermire、およびDave Thalerに対して、彼らのサポートとレビューに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "Brendan Moran\nArm Limited\nEmail: Brendan.Moran@arm.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hannes Tschofenig\nArm Limited\nEmail: hannes.tschofenig@arm.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "David Brown\nLinaro\nEmail: david.brown@linaro.org",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Milosch Meriac\nConsultant\nEmail: milosch@meriac.com",
      "raw": true,
      "ja": ""
    }
  ]
}