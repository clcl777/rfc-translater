{
  "title": {
    "text": "RFC 9591 - The Flexible Round-Optimized Schnorr Threshold (FROST) Protocol for Two‑Round Schnorr Signatures",
    "ja": "RFC 9591 - 2ラウンドSchnorr署名のための柔軟な丸く最適化されたSchnorrしきい値（Frost）プロトコル"
  },
  "number": 9591,
  "created_at": "2024-06-30 13:21:35.457553+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                          D. Connolly\nRequest for Comments: 9591                              Zcash Foundation\nCategory: Informational                                         C. Komlo\nISSN: 2070-1721                 University of Waterloo, Zcash Foundation\n                                                             I. Goldberg\n                                                  University of Waterloo\n                                                              C. A. Wood\n                                                              Cloudflare\n                                                               June 2024",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "The Flexible Round-Optimized Schnorr Threshold (FROST) Protocol for Two-Round Schnorr Signatures",
      "section_title": true,
      "ja": "2ラウンドSchnorr署名のための柔軟な丸く最適化されたSchnorrしきい値（Frost）プロトコル"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document specifies the Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. FROST signatures can be issued after a threshold number of entities cooperate to compute a signature, allowing for improved distribution of trust and redundancy with respect to a secret key. FROST depends only on a prime-order group and cryptographic hash function. This document specifies a number of ciphersuites to instantiate FROST using different prime-order groups and hash functions. This document is a product of the Crypto Forum Research Group (CFRG) in the IRTF.",
      "ja": "このドキュメントは、柔軟な丸く最適化されたSchnorrしきい値（Frost）署名プロトコルを指定します。霜の署名は、署名を計算するために協力してしきい値数のエンティティの数を発行し、秘密の鍵に関する信頼と冗長性の分布を改善できるようにすることができます。霜は、プライムオーダーグループと暗号化ハッシュ関数にのみ依存します。このドキュメントは、さまざまなプライムオーダーグループとハッシュ関数を使用して霜をインスタンス化するために、多くのCiphersuitesを指定しています。このドキュメントは、IRTFのCrypto Forum Research Group（CFRG）の製品です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントは、インターネット標準の追跡仕様ではありません。情報目的で公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Crypto Forum Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネット研究タスクフォース（IRTF）の製品です。IRTFは、インターネット関連の研究開発活動の結果を公開しています。これらの結果は、展開に適していない場合があります。このRFCは、インターネット研究タスクフォース（IRTF）の暗号フォーラム研究グループのコンセンサスを表しています。IRSGによって公開されたことが承認された文書は、インターネット標準のレベルの候補者ではありません。RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9591.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https://www.rfc-editor.org/info/rfc9591で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2024 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2024 IETF Trustおよび文書著者として特定された人。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n2.  Conventions and Definitions\n3.  Cryptographic Dependencies\n  3.1.  Prime-Order Group\n  3.2.  Cryptographic Hash Function\n4.  Helper Functions\n  4.1.  Nonce Generation\n  4.2.  Polynomials\n  4.3.  List Operations\n  4.4.  Binding Factors Computation\n  4.5.  Group Commitment Computation\n  4.6.  Signature Challenge Computation\n5.  Two-Round FROST Signing Protocol\n  5.1.  Round One - Commitment\n  5.2.  Round Two - Signature Share Generation\n  5.3.  Signature Share Aggregation\n  5.4.  Identifiable Abort\n6.  Ciphersuites\n  6.1.  FROST(Ed25519, SHA-512)\n  6.2.  FROST(ristretto255, SHA-512)\n  6.3.  FROST(Ed448, SHAKE256)\n  6.4.  FROST(P-256, SHA-256)\n  6.5.  FROST(secp256k1, SHA-256)\n  6.6.  Ciphersuite Requirements\n7.  Security Considerations\n  7.1.  Side-Channel Mitigations\n  7.2.  Optimizations\n  7.3.  Nonce Reuse Attacks\n  7.4.  Protocol Failures\n  7.5.  Removing the Coordinator Role\n  7.6.  Input Message Hashing\n  7.7.  Input Message Validation\n8.  IANA Considerations\n9.  References\n  9.1.  Normative References\n  9.2.  Informative References\nAppendix A.  Schnorr Signature Encoding\nAppendix B.  Schnorr Signature Generation and Verification for\n        Prime-Order Groups\nAppendix C.  Trusted Dealer Key Generation\n  C.1.  Shamir Secret Sharing\n    C.1.1.  Additional Polynomial Operations\n  C.2.  Verifiable Secret Sharing\nAppendix D.  Random Scalar Generation\n  D.1.  Rejection Sampling\n  D.2.  Wide Reduction\nAppendix E.  Test Vectors\n  E.1.  FROST(Ed25519, SHA-512)\n  E.2.  FROST(Ed448, SHAKE256)\n  E.3.  FROST(ristretto255, SHA-512)\n  E.4.  FROST(P-256, SHA-256)\n  E.5.  FROST(secp256k1, SHA-256)\nAcknowledgments\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Unlike signatures in a single-party setting, threshold signatures require cooperation among a threshold number of signing participants, each holding a share of a common private key. The security of threshold schemes in general assumes that an adversary can corrupt strictly fewer than a threshold number of signer participants.",
      "ja": "単一パーティの設定の署名とは異なり、しきい値の署名には、それぞれが共通の秘密鍵のシェアを保持している署名参加者のしきい値数間の協力が必要です。一般に、しきい値スキームのセキュリティは、敵が署名者の参加者のしきい値数よりも厳密に少ない腐敗を遂行できると想定しています。"
    },
    {
      "indent": 3,
      "text": "This document specifies the Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol based on the original work in [FROST20]. FROST reduces network overhead during threshold signing operations while employing a novel technique to protect against forgery attacks applicable to prior Schnorr-based threshold signature constructions. FROST requires two rounds to compute a signature. Single-round signing variants based on [FROST20] are out of scope.",
      "ja": "このドキュメントは、[FROST20]の元の研究に基づいて、柔軟な円形最適化Schnorrしきい値（FROST）署名プロトコルを指定しています。Frostは、以前のSchnorrベースのしきい値の署名構造に適用される偽造攻撃から保護するために、新しい手法を使用しながら、しきい値署名操作中にネットワークオーバーヘッドを減らします。フロストでは、署名を計算するために2ラウンドが必要です。[FROST20]に基づくシングルラウンドの署名バリアントは範囲外です。"
    },
    {
      "indent": 3,
      "text": "FROST depends only on a prime-order group and cryptographic hash function. This document specifies a number of ciphersuites to instantiate FROST using different prime-order groups and hash functions. Two ciphersuites can be used to produce signatures that are compatible with Edwards-Curve Digital Signature Algorithm (EdDSA) variants Ed25519 and Ed448 as specified in [RFC8032], i.e., the signatures can be verified with a verifier that is compliant with [RFC8032]. However, unlike EdDSA, the signatures produced by FROST are not deterministic, since deriving nonces deterministically allows for a complete key-recovery attack in multi-party, discrete logarithm-based signatures.",
      "ja": "霜は、プライムオーダーグループと暗号化ハッシュ関数にのみ依存します。このドキュメントは、さまざまなプライムオーダーグループとハッシュ関数を使用して霜をインスタンス化するために、多くのCiphersuitesを指定しています。[RFC8032]で指定されているように、[RFC8032]で指定されているように、Edwards-Curve Digital Signature Algorithm（EDDSA）バリアントED25519およびED448と互換性のある署名を生成するために、2つのciphersuitesを使用できます。ただし、EDDSAとは異なり、フロストによって生成される署名は決定論的ではありません。なぜなら、Noncesを導き出すことは、マルチパーティの個別の対数ベースの署名での完全なキー回復攻撃を決定的に可能にするためです。"
    },
    {
      "indent": 3,
      "text": "Key generation for FROST signing is out of scope for this document. However, for completeness, key generation with a trusted dealer is specified in Appendix C.",
      "ja": "霜の署名の重要な生成は、このドキュメントの範囲外です。ただし、完全性のために、信頼できるディーラーを使用したキー生成は付録Cで指定されています。"
    },
    {
      "indent": 3,
      "text": "This document represents the consensus of the Crypto Forum Research Group (CFRG). It is not an IETF product and is not a standard.",
      "ja": "このドキュメントは、Crypto Forum Research Group（CFRG）のコンセンサスを表しています。IETF製品ではなく、標準でもありません。"
    },
    {
      "indent": 0,
      "text": "2. Conventions and Definitions",
      "section_title": true,
      "ja": "2. 慣習と定義"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "「必須」、「必要」、「必須」、「shall」、「shall」、「suff」、 \"not\"、 \"becommended\"、 \"becommented\"、 \"may\"、 \"optional「このドキュメントでは、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "The following notation is used throughout the document.",
      "ja": "次の表記は、ドキュメント全体で使用されます。"
    },
    {
      "indent": 3,
      "text": "byte:",
      "ja": "バイト："
    },
    {
      "indent": 12,
      "text": "A sequence of eight bits.",
      "ja": "8ビットのシーケンス。"
    },
    {
      "indent": 3,
      "text": "random_bytes(n):",
      "ja": "random_bytes（n）："
    },
    {
      "indent": 12,
      "text": "Outputs n bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG).",
      "ja": "nバイト出力は、暗号化された擬似ランダム数ジェネレーター（CSPRNG）を使用して、ランダムに均一にサンプリングされます。"
    },
    {
      "indent": 3,
      "text": "count(i, L):",
      "ja": "count（i、l）："
    },
    {
      "indent": 12,
      "text": "Outputs the number of times the element i is represented in the list L.",
      "ja": "リストLに表示されている要素Iの回数を出力します。"
    },
    {
      "indent": 3,
      "text": "len(l):",
      "ja": "レン（L）："
    },
    {
      "indent": 12,
      "text": "Outputs the length of list l, e.g., len([1,2,3]) = 3.",
      "ja": "リストLの長さを出力します。たとえば、LEN（[1,2,3]）= 3。"
    },
    {
      "indent": 3,
      "text": "reverse(l):",
      "ja": "逆（l）："
    },
    {
      "indent": 12,
      "text": "Outputs the list l in reverse order, e.g., reverse([1,2,3]) = [3,2,1].",
      "ja": "リストlを逆順に出力します。例えば、逆（[1,2,3]）= [3,2,1]。"
    },
    {
      "indent": 3,
      "text": "range(a, b):",
      "ja": "範囲（a、b）："
    },
    {
      "indent": 12,
      "text": "Outputs a list of integers from a to b-1 in ascending order, e.g., range(1, 4) = [1,2,3].",
      "ja": "AからB-1の整数のリストを昇順で出力します。たとえば、範囲（1、4）= [1,2,3]。"
    },
    {
      "indent": 3,
      "text": "pow(a, b):",
      "ja": "捕虜（a、b）："
    },
    {
      "indent": 12,
      "text": "Outputs the result, a Scalar, of a to the power of b, e.g., pow(2, 3) = 8 modulo the relevant group order p.",
      "ja": "結果、bのパワー、aのスカラー、たとえば、pow（2、3）= 8関連するグループ順序p。"
    },
    {
      "indent": 3,
      "text": "||:",
      "ja": "||："
    },
    {
      "indent": 12,
      "text": "Denotes concatenation of byte strings, i.e., x || y denotes the byte string x, immediately followed by the byte string y, with no extra separator, yielding xy.",
      "ja": "バイト文字列の連結、つまりx ||yはバイト文字列xを示し、すぐにバイト文字列yが続き、余分なセパレーターがなく、xyが生成されます。"
    },
    {
      "indent": 3,
      "text": "nil:",
      "ja": "nil:"
    },
    {
      "indent": 12,
      "text": "Denotes an empty byte string.",
      "ja": "空のバイト文字列を示します。"
    },
    {
      "indent": 3,
      "text": "Unless otherwise stated, we assume that secrets are sampled uniformly at random using a CSPRNG; see [RFC4086] for additional guidance on the generation of random numbers.",
      "ja": "特に明記しない限り、秘密はCSPRNGを使用してランダムに均一にサンプリングされると仮定します。乱数の生成に関する追加のガイダンスについては、[RFC4086]を参照してください。"
    },
    {
      "indent": 0,
      "text": "3. Cryptographic Dependencies",
      "section_title": true,
      "ja": "3. 暗号化依存関係"
    },
    {
      "indent": 3,
      "text": "FROST signing depends on the following cryptographic constructs:",
      "ja": "霜の署名は、次の暗号化構造に依存します。"
    },
    {
      "indent": 6,
      "text": "* Prime-order group (Section 3.1)",
      "ja": "* プライムオーダーグループ（セクション3.1）"
    },
    {
      "indent": 6,
      "text": "* Cryptographic hash function (Section 3.2)",
      "ja": "* 暗号化ハッシュ関数（セクション3.2）"
    },
    {
      "indent": 3,
      "text": "The following sections describe these constructs in more detail.",
      "ja": "次のセクションでは、これらの構成要素についてさらに詳しく説明しています。"
    },
    {
      "indent": 0,
      "text": "3.1. Prime-Order Group",
      "section_title": true,
      "ja": "3.1. プライムオーダーグループ"
    },
    {
      "indent": 3,
      "text": "FROST depends on an abelian group of prime order p. We represent this group as the object G that additionally defines helper functions described below. The group operation for G is addition + with identity element I. For any elements A and B of the group G, A + B = B + A is also a member of G. Also, for any A in G, there exists an element -A such that A + (-A) = (-A) + A = I. For convenience, we use - to denote subtraction, e.g., A - B = A + (-B). Integers, taken modulo the group order p, are called \"Scalars\"; arithmetic operations on Scalars are implicitly performed modulo p. Since p is prime, Scalars form a finite field. Scalar multiplication is equivalent to the repeated application of the group operation on an element A with itself r-1 times, denoted as ScalarMult(A, r). We denote the sum, difference, and product of two Scalars using the +, -, and * operators, respectively. (Note that this means + may refer to group element addition or Scalar addition, depending on the type of the operands.) For any element A, ScalarMult(A, p) = I. We denote B as a fixed generator of the group. Scalar base multiplication is equivalent to the repeated application of the group operation on B with itself r-1 times, denoted as ScalarBaseMult(r). The set of Scalars corresponds to GF(p), which we refer to as the Scalar field. It is assumed that group element addition, negation, and equality comparison can be efficiently computed for arbitrary group elements.",
      "ja": "霜は、プライムオーダーのアベルのグループに依存します。このグループは、以下で説明するヘルパー関数をさらに定義するオブジェクトGとして表します。gのグループ操作は、IDの要素Iを備えた追加 +です。グループGの要素AおよびBについては、A + B = B + AもGのメンバーです。-a +（-a）=（-a） + a = Iのように、便宜上、a-b = a +（-b）などの減算を示すために使用します。整数は、グループの注文pを測定し、「スカラー」と呼ばれます。スカラー上の算術操作は、暗黙的に実行されますmodulo p。Pはプライムなので、スカラーは有限フィールドを形成します。スカラー乗算は、scalarmult（a、r）として示されるR-1回の要素Aでのグループ操作の繰り返し適用と同等です。それぞれ +、 - 、および *演算子を使用して、2つのスカラーの合計、差、および積を示します。（これは、オペランドのタイプに応じて、グループ要素の追加またはスカラーの追加を意味することに注意してください。）任意の要素A、scalarmult（a、p）= Iについては、グループの固定ジェネレーターとしてBを示します。スカラーベースの乗算は、scalarbasemult（r）として示されるr-1タイムを使用して、bでのグループ操作の繰り返し適用と同等です。スカラーのセットはGF（P）に対応し、これをスカラーフィールドと呼びます。グループ要素の追加、否定、および平等比較は、任意のグループ要素に対して効率的に計算できると想定されています。"
    },
    {
      "indent": 3,
      "text": "This document uses types Element and Scalar to denote elements of the group G and its set of Scalars, respectively. We denote Scalar(x) as the conversion of integer input x to the corresponding Scalar value with the same numeric value. For example, Scalar(1) yields a Scalar representing the value 1. Moreover, we use the type NonZeroScalar to denote a Scalar value that is not equal to zero, i.e., Scalar(0). We denote equality comparison of these types as == and assignment of values by =. When comparing Scalar values, e.g., for the purposes of sorting lists of Scalar values, the least nonnegative representation mod p is used.",
      "ja": "このドキュメントでは、タイプ要素とスカラーを使用して、それぞれグループGとそのスカラーのセットの要素を示します。Scalar（x）は、同じ数値で整数入力xの対応するスカラー値への変換として示されます。たとえば、スカラー（1）は値1を表すスカラーを生成します。さらに、ゼロ、つまりスカラー（0）に等しくないスカラー値を示すために、タイプの非ゼロスカラーを使用します。これらのタイプの平等比較は、==および==の割り当てを示します。たとえば、スカラー値をスカラー値のソートリストの目的で比較する場合、最小の非陰性表現mod pが使用されます。"
    },
    {
      "indent": 3,
      "text": "We now detail a number of member functions that can be invoked on G.",
      "ja": "Gで呼び出すことができる多くのメンバー関数について詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "Order():",
      "ja": "注文（）："
    },
    {
      "indent": 12,
      "text": "Outputs the order of G (i.e., p).",
      "ja": "g（すなわち、p）の順序を出力します。"
    },
    {
      "indent": 3,
      "text": "Identity():",
      "ja": "身元（）："
    },
    {
      "indent": 12,
      "text": "Outputs the identity Element of the group (i.e., I).",
      "ja": "グループのアイデンティティ要素（つまり、i）を出力します。"
    },
    {
      "indent": 3,
      "text": "RandomScalar():",
      "ja": "randomscalar（）："
    },
    {
      "indent": 12,
      "text": "Outputs a random Scalar element in GF(p), i.e., a random Scalar in [0, p - 1].",
      "ja": "GF（P）のランダムスカラー要素、つまり[0、p -1]のランダムスカラーを出力します。"
    },
    {
      "indent": 3,
      "text": "ScalarMult(A, k):",
      "ja": "Scalarmult（A、K）："
    },
    {
      "indent": 12,
      "text": "Outputs the Scalar multiplication between Element A and Scalar k.",
      "ja": "要素Aとスカラーkの間にスカラー乗算を出力します。"
    },
    {
      "indent": 3,
      "text": "ScalarBaseMult(k):",
      "ja": "Scalarbasemult（k）："
    },
    {
      "indent": 12,
      "text": "Outputs the Scalar multiplication between Scalar k and the group generator B.",
      "ja": "スカラーKとグループジェネレーターBの間にスカラー乗算を出力します。"
    },
    {
      "indent": 3,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement（a）："
    },
    {
      "indent": 12,
      "text": "Maps an Element A to a canonical byte array buf of fixed length Ne. This function raises an error if A is the identity element of the group.",
      "ja": "固定長neの標準バイト配列bufに要素aをマップします。この関数は、AがグループのID要素である場合、エラーを発生させます。"
    },
    {
      "indent": 3,
      "text": "DeserializeElement(buf):",
      "ja": "DeserializeElement（BUF）："
    },
    {
      "indent": 12,
      "text": "Attempts to map a byte array buf to an Element A and fails if the input is not the valid canonical byte representation of an element of the group. This function raises an error if deserialization fails or if A is the identity element of the group; see Section 6 for group-specific input validation steps.",
      "ja": "バイト配列BUFを要素Aにマッピングしようとする試みは、入力がグループの要素の有効な標準バイト表現ではない場合に故障します。この関数は、脱必要性が失敗した場合、またはAがグループのID要素である場合、エラーを発生させます。グループ固有の入力検証手順については、セクション6を参照してください。"
    },
    {
      "indent": 3,
      "text": "SerializeScalar(s):",
      "ja": "serializescalar（s）："
    },
    {
      "indent": 12,
      "text": "Maps a Scalar s to a canonical byte array buf of fixed length Ns.",
      "ja": "スカラーを固定長nの標準バイト配列bufにマップします。"
    },
    {
      "indent": 3,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar（BUF）："
    },
    {
      "indent": 12,
      "text": "Attempts to map a byte array buf to a Scalar s. This function raises an error if deserialization fails; see Section 6 for group-specific input validation steps.",
      "ja": "バイト配列BUFをスカラーにマッピングしようとします。この関数は、脱力化が失敗した場合にエラーを発生させます。グループ固有の入力検証手順については、セクション6を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.2. Cryptographic Hash Function",
      "section_title": true,
      "ja": "3.2. 暗号化ハッシュ関数"
    },
    {
      "indent": 3,
      "text": "FROST requires the use of a cryptographically secure hash function, generically written as H, which is modeled as a random oracle in security proofs for the protocol (see [FROST20] and [StrongerSec22]). For concrete recommendations on hash functions that SHOULD be used in practice, see Section 6. Using H, we introduce distinct domain-separated hashes H1, H2, H3, H4, and H5:",
      "ja": "Frostは、プロトコルのセキュリティ証明のランダムオラクルとしてモデル化されているHとして一般的に書かれた暗号化的に安全なハッシュ関数の使用を必要とします（[Frost20]および[Strongersec22]を参照）。実際に使用する必要があるハッシュ関数に関する具体的な推奨事項については、セクション6を参照してください。Hを使用して、異なるドメイン分離ハッシュH1、H2、H3、H4、およびH5を導入します。"
    },
    {
      "indent": 6,
      "text": "* H1, H2, and H3 map arbitrary byte strings to Scalar elements associated with the prime-order group.",
      "ja": "* H1、H2、およびH3は、プライムオーダーグループに関連付けられたスカラー要素に任意のバイト文字列をマップします。"
    },
    {
      "indent": 6,
      "text": "* H4 and H5 are aliases for H with distinct domain separators.",
      "ja": "* H4とH5は、異なるドメインセパレータを持つHのエイリアスです。"
    },
    {
      "indent": 3,
      "text": "The details of H1, H2, H3, H4, and H5 vary based on the ciphersuite used. See Section 6 for more details about each.",
      "ja": "H1、H2、H3、H4、およびH5の詳細は、使用されるCiphersuiteによって異なります。それぞれの詳細については、セクション6を参照してください。"
    },
    {
      "indent": 0,
      "text": "4. Helper Functions",
      "section_title": true,
      "ja": "4. ヘルパー機能"
    },
    {
      "indent": 3,
      "text": "Beyond the core dependencies, the protocol in this document depends on the following helper operations:",
      "ja": "コア依存関係を超えて、このドキュメントのプロトコルは、次のヘルパー操作に依存します。"
    },
    {
      "indent": 6,
      "text": "* Nonce generation (Section 4.1);",
      "ja": "* NonCe Generation（セクション4.1）;"
    },
    {
      "indent": 6,
      "text": "* Polynomials (Section 4.2);",
      "ja": "* 多項式（セクション4.2）;"
    },
    {
      "indent": 6,
      "text": "* List operations (Section 4.3);",
      "ja": "* リスト操作（セクション4.3）;"
    },
    {
      "indent": 6,
      "text": "* Binding factors computation (Section 4.4);",
      "ja": "* 結合因子計算（セクション4.4）;"
    },
    {
      "indent": 6,
      "text": "* Group commitment computation (Section 4.5); and",
      "ja": "* グループコミットメント計算（セクション4.5）;そして"
    },
    {
      "indent": 6,
      "text": "* Signature challenge computation (Section 4.6).",
      "ja": "* 署名チャレンジ計算（セクション4.6）。"
    },
    {
      "indent": 3,
      "text": "The following sections describe these operations in more detail.",
      "ja": "次のセクションでは、これらの操作について詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "4.1. Nonce Generation",
      "section_title": true,
      "ja": "4.1. ノンセジェネレーション"
    },
    {
      "indent": 3,
      "text": "To hedge against a bad random number generator (RNG) that outputs predictable values, nonces are generated with the nonce_generate function by combining fresh randomness with the secret key as input to a domain-separated hash function built from the ciphersuite hash function H. This domain-separated hash function is denoted as H3. This function always samples 32 bytes of fresh randomness to ensure that the probability of nonce reuse is at most 2^-128 as long as no more than 2^64 signatures are computed by a given signing participant.",
      "ja": "予測可能な値を出力する悪い乱数ジェネレーター（RNG）に対してヘッジするために、非速度は、秘密のキーと新鮮なランダム性と秘密のキーを、Ciphersuite Hash Function Hから構築したドメイン分離ハッシュ関数への入力として組み合わせることにより生成されます。- 分離されたハッシュ関数はH3として示されます。この関数は常に32バイトの新鮮なランダム性をサンプリングして、特定の署名参加者によって2^64以下の署名が計算されている限り、非CEの再利用の確率が最大2^-128であることを保証します。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- secret, a Scalar.\n\nOutputs:\n- nonce, a Scalar.\n\ndef nonce_generate(secret):\n  random_bytes = random_bytes(32)\n  secret_enc = G.SerializeScalar(secret)\n  return H3(random_bytes || secret_enc)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.2. Polynomials",
      "section_title": true,
      "ja": "4.2. 多項式"
    },
    {
      "indent": 3,
      "text": "This section defines polynomials over Scalars that are used in the main protocol. A polynomial of maximum degree t is represented as a list of t+1 coefficients, where the constant term of the polynomial is in the first position and the highest-degree coefficient is in the last position. For example, the polynomial x^2 + 2x + 3 has degree 2 and is represented as a list of three coefficients [3, 2, 1]. A point on the polynomial f is a tuple (x, y), where y = f(x).",
      "ja": "このセクションでは、メインプロトコルで使用されるスカラー上の多項式を定義します。最大度Tの多項式は、T+1係数のリストとして表され、多項式の定数項が最初の位置にあり、最高級係数は最後の位置にあります。たとえば、多項式x^2 + 2x + 3には度2があり、3つの係数のリストとして表されます[3、2、1]。多項式Fのポイントはタプル（x、y）で、ここでy = f（x）です。"
    },
    {
      "indent": 3,
      "text": "The function derive_interpolating_value derives a value that is used for polynomial interpolation. It is provided a list of x-coordinates as input, each of which cannot equal 0.",
      "ja": "関数derive_interpolating_valueは、多項式補間に使用される値を導き出します。入力としてX座標のリストが提供されますが、それぞれが0に等しくなりません。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- L, the list of x-coordinates, each a NonZeroScalar.\n- x_i, an x-coordinate contained in L, a NonZeroScalar.\n\nOutputs:\n- value, a Scalar.\n\nErrors:\n- \"invalid parameters\", if 1) x_i is not in L, or if 2) any\n  x-coordinate is represented more than once in L.\n\ndef derive_interpolating_value(L, x_i):\n  if x_i not in L:\n    raise \"invalid parameters\"\n  for x_j in L:\n    if count(x_j, L) > 1:\n      raise \"invalid parameters\"\n\n  numerator = Scalar(1)\n  denominator = Scalar(1)\n  for x_j in L:\n    if x_j == x_i: continue\n    numerator *= x_j\n    denominator *= x_j - x_i\n\n  value = numerator / denominator\n  return value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.3. List Operations",
      "section_title": true,
      "ja": "4.3. リスト操作をリストします"
    },
    {
      "indent": 3,
      "text": "This section describes helper functions that work on lists of values produced during the FROST protocol. The following function encodes a list of participant commitments into a byte string for use in the FROST protocol.",
      "ja": "このセクションでは、霜プロトコル中に生成された値のリストで機能するヘルパー関数について説明します。次の関数は、霜プロトコルで使用するためのバイト文字列に参加者のコミットメントのリストをエンコードします。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- commitment_list = [(i, hiding_nonce_commitment_i,\n  binding_nonce_commitment_i), ...], a list of commitments issued by\n  each participant, where each element in the list indicates a\n  NonZeroScalar identifier i and two commitment Element values\n  (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list\n  MUST be sorted in ascending order by identifier.\n\nOutputs:\n- encoded_group_commitment, the serialized representation of\n  commitment_list, a byte string.\n\ndef encode_group_commitment_list(commitment_list):\n  encoded_group_commitment = nil\n  for (identifier, hiding_nonce_commitment,\n       binding_nonce_commitment) in commitment_list:\n    encoded_commitment = (\n        G.SerializeScalar(identifier) ||\n        G.SerializeElement(hiding_nonce_commitment) ||\n        G.SerializeElement(binding_nonce_commitment))\n    encoded_group_commitment = (\n        encoded_group_commitment ||\n        encoded_commitment)\n  return encoded_group_commitment",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following function is used to extract identifiers from a commitment list.",
      "ja": "次の関数は、コミットメントリストから識別子を抽出するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- commitment_list = [(i, hiding_nonce_commitment_i,\n  binding_nonce_commitment_i), ...], a list of commitments issued by\n  each participant, where each element in the list indicates a\n  NonZeroScalar identifier i and two commitment Element values\n  (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list\n  MUST be sorted in ascending order by identifier.\n\nOutputs:\n- identifiers, a list of NonZeroScalar values.\n\ndef participants_from_commitment_list(commitment_list):\n  identifiers = []\n  for (identifier, _, _) in commitment_list:\n    identifiers.append(identifier)\n  return identifiers",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following function is used to extract a binding factor from a list of binding factors.",
      "ja": "次の関数を使用して、結合因子のリストから結合係数を抽出します。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- binding_factor_list = [(i, binding_factor), ...],\n  a list of binding factors for each participant, where each element\n  in the list indicates a NonZeroScalar identifier i and Scalar\n  binding factor.\n- identifier, participant identifier, a NonZeroScalar.\n\nOutputs:\n- binding_factor, a Scalar.\n\nErrors:\n- \"invalid participant\", when the designated participant is\n  not known.\n\ndef binding_factor_for_participant(binding_factor_list, identifier):\n  for (i, binding_factor) in binding_factor_list:\n    if identifier == i:\n      return binding_factor\n  raise \"invalid participant\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.4. Binding Factors Computation",
      "section_title": true,
      "ja": "4.4. 結合因子の計算"
    },
    {
      "indent": 3,
      "text": "This section describes the subroutine for computing binding factors based on the participant commitment list, message to be signed, and group public key.",
      "ja": "このセクションでは、参加者のコミットメントリスト、署名されるメッセージ、およびグループ公開鍵に基づいて、バインディング因子を計算するためのサブルーチンについて説明します。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- group_public_key, the public key corresponding to the group signing\n  key, an Element.\n- commitment_list = [(i, hiding_nonce_commitment_i,\n  binding_nonce_commitment_i), ...], a list of commitments issued by\n  each participant, where each element in the list indicates a\n  NonZeroScalar identifier i and two commitment Element values\n  (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list\n  MUST be sorted in ascending order by identifier.\n- msg, the message to be signed.\n\nOutputs:\n- binding_factor_list, a list of (NonZeroScalar, Scalar) tuples\n  representing the binding factors.\n\ndef compute_binding_factors(group_public_key, commitment_list, msg):\n  group_public_key_enc = G.SerializeElement(group_public_key)\n  // Hashed to a fixed length.\n  msg_hash = H4(msg)\n  // Hashed to a fixed length.\n  encoded_commitment_hash =\n      H5(encode_group_commitment_list(commitment_list))\n  // The encoding of the group public key is a fixed length\n  // within a ciphersuite.\n  rho_input_prefix = group_public_key_enc || msg_hash ||\n   encoded_commitment_hash\n\n  binding_factor_list = []\n  for (identifier, hiding_nonce_commitment,\n       binding_nonce_commitment) in commitment_list:\n    rho_input = rho_input_prefix || G.SerializeScalar(identifier)\n    binding_factor = H1(rho_input)\n    binding_factor_list.append((identifier, binding_factor))\n  return binding_factor_list",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.5. Group Commitment Computation",
      "section_title": true,
      "ja": "4.5. グループコミットメント計算"
    },
    {
      "indent": 3,
      "text": "This section describes the subroutine for creating the group commitment from a commitment list.",
      "ja": "このセクションでは、コミットメントリストからグループコミットメントを作成するためのサブルーチンについて説明します。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- commitment_list = [(i, hiding_nonce_commitment_i,\n  binding_nonce_commitment_i), ...], a list of commitments issued by\n  each participant, where each element in the list indicates a\n  NonZeroScalar identifier i and two commitment Element values\n  (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list\n  MUST be sorted in ascending order by identifier.\n- binding_factor_list = [(i, binding_factor), ...],\n  a list of (NonZeroScalar, Scalar) tuples representing the binding\n  factor Scalar for the given identifier.\n\nOutputs:\n- group_commitment, an Element.\n\ndef compute_group_commitment(commitment_list, binding_factor_list):\n  group_commitment = G.Identity()\n  for (identifier, hiding_nonce_commitment,\n       binding_nonce_commitment) in commitment_list:\n    binding_factor = binding_factor_for_participant(\n        binding_factor_list, identifier)\n    binding_nonce = G.ScalarMult(\n        binding_nonce_commitment,\n        binding_factor)\n    group_commitment = (\n        group_commitment +\n        hiding_nonce_commitment +\n        binding_nonce)\n  return group_commitment",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that the performance of this algorithm is defined naively and scales linearly relative to the number of signers. For improved performance, the group commitment can be computed using multi-exponentiation techniques such as Pippinger's algorithm; see [MultExp] for more details.",
      "ja": "このアルゴリズムのパフォーマンスは、署名者の数を比較して素朴に定義され、直線的にスケーリングされることに注意してください。パフォーマンスを改善するために、グループコミットメントは、Pippingerのアルゴリズムなどのマルチエクセレンステクニックを使用して計算できます。詳細については、[Multexp]を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.6. Signature Challenge Computation",
      "section_title": true,
      "ja": "4.6. 署名チャレンジの計算"
    },
    {
      "indent": 3,
      "text": "This section describes the subroutine for creating the per-message challenge.",
      "ja": "このセクションでは、精度ごとの課題を作成するためのサブルーチンについて説明します。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- group_commitment, the group commitment, an Element.\n- group_public_key, the public key corresponding to the group signing\n  key, an Element.\n- msg, the message to be signed, a byte string.\n\nOutputs:\n- challenge, a Scalar.\n\ndef compute_challenge(group_commitment, group_public_key, msg):\n  group_comm_enc = G.SerializeElement(group_commitment)\n  group_public_key_enc = G.SerializeElement(group_public_key)\n  challenge_input = group_comm_enc || group_public_key_enc || msg\n  challenge = H2(challenge_input)\n  return challenge",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5. Two-Round FROST Signing Protocol",
      "section_title": true,
      "ja": "5. 2ラウンドのフロスト署名プロトコル"
    },
    {
      "indent": 3,
      "text": "This section describes the two-round FROST signing protocol for producing Schnorr signatures. The protocol is configured to run with a selection of NUM_PARTICIPANTS signer participants and a Coordinator. NUM_PARTICIPANTS is a positive and non-zero integer that MUST be at least MIN_PARTICIPANTS, but MUST NOT be larger than MAX_PARTICIPANTS, where MIN_PARTICIPANTS <= MAX_PARTICIPANTS and MIN_PARTICIPANTS is a positive and non-zero integer. Additionally, MAX_PARTICIPANTS MUST be a positive integer less than the group order. A signer participant, or simply \"participant\", is an entity that is trusted to hold and use a signing key share. The Coordinator is an entity with the following responsibilities:",
      "ja": "このセクションでは、Schnorrの署名を作成するための2ラウンドの霜に署名するプロトコルについて説明します。このプロトコルは、num_particationの署名者参加者とコーディネーターの選択で実行されるように構成されています。num_participantsは、少なくともmin_particationantでなければならない肯定的でゼロ以外の整数ですが、max_particantsよりも大きくないはずです。min_particants<= max_particationsおよびmin_particationsは肯定的および非ゼロ整数です。さらに、MAX_PARTICTICANTSは、グループ順序よりも肯定的な整数でなければなりません。署名者の参加者、または単に「参加者」は、署名キーシェアを保持して使用すると信頼されているエンティティです。コーディネーターは、次の責任を持つエンティティです。"
    },
    {
      "indent": 8,
      "text": "1. Determining the participants that will participate (at least MIN_PARTICIPANTS in number);",
      "ja": "1. 参加する参加者を決定する（少なくともmin_particantants in number）;"
    },
    {
      "indent": 8,
      "text": "2. Coordinating rounds (receiving and forwarding inputs among participants);",
      "ja": "2. ラウンドの調整（参加者間の入力の受信および転送）;"
    },
    {
      "indent": 8,
      "text": "3. Aggregating signature shares output by each participant; and",
      "ja": "3. 各参加者による署名株式出力を集約する。そして"
    },
    {
      "indent": 8,
      "text": "4. Publishing the resulting signature.",
      "ja": "4. 結果の署名を公開します。"
    },
    {
      "indent": 3,
      "text": "FROST assumes that the Coordinator and the set of signer participants are chosen externally to the protocol. Note that it is possible to deploy the protocol without designating a single Coordinator; see Section 7.5 for more information.",
      "ja": "Frostは、コーディネーターと署名者参加者のセットがプロトコルの外部から選択されると想定しています。単一のコーディネーターを指定せずにプロトコルを展開することが可能であることに注意してください。詳細については、セクション7.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "FROST produces signatures that can be verified as if they were produced from a single signer using a signing key s with corresponding public key PK, where s is a Scalar value and PK = G.ScalarBaseMult(s). As a threshold signing protocol, the group signing key s is Shamir secret-shared amongst each of the MAX_PARTICIPANTS participants and is used to produce signatures; see Appendix C.1 for more information about Shamir secret sharing. In particular, FROST assumes each participant is configured with the following information:",
      "ja": "Frostは、対応する公開キーPKを使用した署名キーSを使用して単一の署名者から生成されたかのように検証できる署名を生成します。Sはスカラー値とPK = G.ScalarBasemult（S）です。署名プロトコルとしてのしきい値として、キーSに署名するグループは、各MAX_PARTIctiventの参加者の間でShamir Secret-Sharedであり、署名を作成するために使用されます。Shamir Secret共有の詳細については、付録C.1を参照してください。特に、Frostは、各参加者が次の情報で構成されていると想定しています。"
    },
    {
      "indent": 6,
      "text": "* An identifier, which is a NonZeroScalar value denoted as i in the range [1, MAX_PARTICIPANTS] and MUST be distinct from the identifier of every other participant.",
      "ja": "* 識別子。これは、範囲[1、max_particantant]のIとして示されている非ゼロスカラー値であり、他のすべての参加者の識別子とは異なる必要があります。"
    },
    {
      "indent": 6,
      "text": "* A signing key sk_i, which is a Scalar value representing the i-th Shamir secret share of the group signing key s. In particular, sk_i is the value f(i) on a secret polynomial f of degree (MIN_PARTICIPANTS - 1), where s is f(0). The public key corresponding to this signing key share is PK_i = G.ScalarBaseMult(sk_i).",
      "ja": "* 署名キーSK_I。これは、キーに署名するグループのIth Shamir Secret Shareを表すスカラー値です。特に、SK_Iは、程度の秘密の多項式f（min_partication -1）の値f（i）です。ここで、sはf（0）です。この署名キー共有に対応する公開鍵は、PK_I = G.ScalarBaseMult（SK_I）です。"
    },
    {
      "indent": 3,
      "text": "Additionally, the Coordinator and each participant are configured with common group information, denoted as \"group info,\" which consists of the following:",
      "ja": "さらに、コーディネーターと各参加者は、「グループ情報」として示される共通のグループ情報で構成されています。これは以下で構成されています。"
    },
    {
      "indent": 6,
      "text": "* Group public key, which is an Element in G denoted as PK.",
      "ja": "* グループの公開鍵。これは、PKとして示されるGの要素です。"
    },
    {
      "indent": 6,
      "text": "* Public keys PK_i for each participant, which are Element values in G denoted as PK_i for each i in [1, MAX_PARTICIPANTS].",
      "ja": "* 各参加者のパブリックキーPK_Iは、[1、MAX_PARTICANTS]の各IのPK_Iとして示されるGの要素値です。"
    },
    {
      "indent": 3,
      "text": "This document does not specify how this information, including the signing key shares, are configured and distributed to participants. In general, two configuration mechanisms are possible: one that requires a single trusted dealer and one that requires performing a distributed key generation protocol. We highlight the key generation mechanism by a trusted dealer in Appendix C for reference.",
      "ja": "このドキュメントでは、署名キー共有を含むこの情報が参加者に設定され、配布される方法を指定していません。一般に、2つの構成メカニズムが可能です。1つは単一の信頼できるディーラーと、分散キー生成プロトコルを実行する必要があるものです。参照のために、付録Cの信頼できるディーラーによる重要な生成メカニズムを強調します。"
    },
    {
      "indent": 3,
      "text": "FROST requires two rounds to complete. In the first round, participants generate and publish one-time-use commitments to be used in the second round. In the second round, each participant produces a share of the signature over the Coordinator-chosen message and the other participant commitments. After the second round is completed, the Coordinator aggregates the signature shares to produce a final signature. The Coordinator SHOULD abort the protocol if the signature is invalid; see Section 5.4 for more information about dealing with invalid signatures and misbehaving participants. This complete interaction (without being aborted) is shown in Figure 1.",
      "ja": "フロストでは、完了するには2ラウンドが必要です。第1ラウンドでは、参加者は第2ラウンドで使用される1回限りのコミットメントを生成および公開します。第2ラウンドでは、各参加者は、コーディネーターが選択したメッセージと他の参加者のコミットメントよりも署名のシェアを作成します。2回目のラウンドが完了した後、コーディネーターは署名株を集約して最終的な署名を作成します。署名が無効である場合、コーディネーターはプロトコルを中止する必要があります。無効な署名と不正行為の参加者への対処の詳細については、セクション5.4を参照してください。この完全な相互作用（中止されることなく）を図1に示します。"
    },
    {
      "indent": 3,
      "text": "        (group info)            (group info,     (group info,\n            |               signing key share)   signing key share)\n            |                         |                |\n            v                         v                v\n        Coordinator               Signer-1   ...   Signer-n\n    ------------------------------------------------------------\n   signing request\n------------>\n            |\n      == Round 1 (Commitment) ==\n            | participant commitment |                 |\n            |<-----------------------+                 |\n            |          ...                             |\n            | participant commitment            (commit state) ==\\\n            |<-----------------------------------------+         |\n                                                                 |\n      == Round 2 (Signature Share Generation) ==                 |\n   message\n------------>\n            |                                                    |\n            |   participant input    |                 |         |\n            +------------------------>                 |         |\n            |     signature share    |                 |         |\n            |<-----------------------+                 |         |\n            |          ...                             |         |\n            |    participant input                     |         |\n            +------------------------------------------>         /\n            |     signature share                      |<=======/\n            <------------------------------------------+\n            |\n      == Aggregation ==\n            |\n  signature |\n<-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 1: FROST Protocol Overview",
      "ja": "図1：霜プロトコルの概要"
    },
    {
      "indent": 3,
      "text": "Details for round one are described in Section 5.1 and details for round two are described in Section 5.2. Note that each participant persists some state between the two rounds; this state is deleted as described in Section 5.2. The final Aggregation step is described in Section 5.3.",
      "ja": "ラウンド1の詳細については、セクション5.1で説明し、ラウンド2の詳細についてはセクション5.2で説明します。各参加者は、2ラウンドの間にある状態を持続していることに注意してください。この状態は、セクション5.2で説明されているように削除されます。最終的な集約ステップについては、セクション5.3で説明します。"
    },
    {
      "indent": 3,
      "text": "FROST assumes that all inputs to each round, especially those that are received over the network, are validated before use. In particular, this means that any value of type Element or Scalar received over the network MUST be deserialized using DeserializeElement and DeserializeScalar, respectively, as these functions perform the necessary input validation steps. Additionally, all messages sent over the wire MUST be encoded using their respective functions, e.g., Scalars and Elements are encoded using SerializeScalar and SerializeElement.",
      "ja": "Frostは、各ラウンドへのすべての入力、特にネットワークを介して受信されるものが使用前に検証されると想定しています。特に、これは、ネットワークを介して受信したタイプ要素またはスカラーの値は、これらの関数が必要な入力検証手順を実行するため、それぞれDeserializeElementとDeserializecalarを使用してDeserializedを使用する必要があることを意味します。さらに、ワイヤー上で送信されるすべてのメッセージは、それぞれの関数を使用してエンコードする必要があります。たとえば、スカラーと要素は、SerializeCalarおよびSerializeElementを使用してエンコードされます。"
    },
    {
      "indent": 3,
      "text": "FROST assumes reliable message delivery between the Coordinator and participants in order for the protocol to complete. An attacker masquerading as another participant will result only in an invalid signature; see Section 7. However, in order to identify misbehaving participants, we assume that the network channel is additionally authenticated; confidentiality is not required.",
      "ja": "Frostは、プロトコルが完了するために、コーディネーターと参加者との間の信頼できるメッセージ配信を想定しています。別の参加者を装った攻撃者は、無効な署名のみになります。ただし、セクション7を参照してください。ただし、誤動作の参加者を特定するために、ネットワークチャネルがさらに認証されていると仮定します。機密性は必要ありません。"
    },
    {
      "indent": 0,
      "text": "5.1. Round One - Commitment",
      "section_title": true,
      "ja": "5.1. ラウンド1-コミットメント"
    },
    {
      "indent": 3,
      "text": "Round one involves each participant generating nonces and their corresponding public commitments. A nonce is a pair of Scalar values, and a commitment is a pair of Element values. Each participant's behavior in this round is described by the commit function below. Note that this function invokes nonce_generate twice, once for each type of nonce produced. The output of this function is a pair of secret nonces (hiding_nonce, binding_nonce) and their corresponding public commitments (hiding_nonce_commitment, binding_nonce_commitment).",
      "ja": "ラウンド1には、各参加者がノンセと対応する公開を生成することが含まれます。非CEはスカラー値のペアであり、コミットメントは一対の要素値です。このラウンドでの各参加者の行動は、以下のコミット関数で説明されています。この関数は、生成されたNonCEのタイプごとに1回、NonCE_Generateを2回呼び出すことに注意してください。この関数の出力は、Secret Nonces（Hiding_Nonce、Binding_Nonce）とそれに対応する公開（HIDING_NONCE_COMMITMENT、Binding_Nonce_Commitment）のペアです。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- sk_i, the secret key share, a Scalar.\n\nOutputs:\n- (nonce, comm), a tuple of nonce and nonce commitment pairs,\n  where each value in the nonce pair is a Scalar and each value in\n  the nonce commitment pair is an Element.\n\ndef commit(sk_i):\n  hiding_nonce = nonce_generate(sk_i)\n  binding_nonce = nonce_generate(sk_i)\n  hiding_nonce_commitment = G.ScalarBaseMult(hiding_nonce)\n  binding_nonce_commitment = G.ScalarBaseMult(binding_nonce)\n  nonces = (hiding_nonce, binding_nonce)\n  comms = (hiding_nonce_commitment, binding_nonce_commitment)\n  return (nonces, comms)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The outputs nonce and comm from participant P_i are both stored locally and kept for use in the second round. The nonce value is secret and MUST NOT be shared, whereas the public output comm is sent to the Coordinator. The nonce values produced by this function MUST NOT be used in more than one invocation of sign, and the nonces MUST be generated from a source of secure randomness.",
      "ja": "参加者P_Iからの出力NonCEおよびCOMMは両方ともローカルに保存され、第2ラウンドで使用するために保持されます。ノンセの値は秘密であり、共有してはなりませんが、パブリック出力コムはコーディネーターに送信されます。この関数によって生成された非CE値は、符号の複数の呼び出しで使用する必要はなく、非速度を安全なランダム性のソースから生成する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2. Round Two - Signature Share Generation",
      "section_title": true,
      "ja": "5.2. ラウンド2-署名株式生成"
    },
    {
      "indent": 3,
      "text": "In round two, the Coordinator is responsible for sending the message to be signed and choosing the participants that will participate (a number of at least MIN_PARTICIPANTS). Signers additionally require locally held data, specifically their private key and the nonces corresponding to their commitment issued in round one.",
      "ja": "ラウンド2では、コーディネーターは、署名するメッセージを送信し、参加する参加者（少なくとも多数のMIN_PARTICANTES）を選択する責任があります。署名者はさらに、ローカルに保持されているデータ、特に秘密鍵と、ラウンド1で発行されたコミットメントに対応する非速度を必要とします。"
    },
    {
      "indent": 3,
      "text": "The Coordinator begins by sending each participant the message to be signed along with the set of signing commitments for all participants in the participant list. Each participant MUST validate the inputs before processing the Coordinator's request. In particular, the signer MUST validate commitment_list, deserializing each group Element in the list using DeserializeElement from Section 3.1. If deserialization fails, the signer MUST abort the protocol. Moreover, each participant MUST ensure that its identifier and commitments (from the first round) appear in commitment_list. Applications that restrict participants from processing arbitrary input messages are also required to perform relevant application-layer input validation checks; see Section 7.7 for more details.",
      "ja": "コーディネーターは、各参加者に参加者リストのすべての参加者の署名コミットメントのセットとともに署名されるメッセージを送信することから始めます。各参加者は、コーディネーターの要求を処理する前に、入力を検証する必要があります。特に、署名者はCommitment_Listを検証し、セクション3.1のDeserializeElementを使用してリスト内の各グループ要素を脱上化する必要があります。スターリア化が失敗した場合、署名者はプロトコルを中止する必要があります。さらに、各参加者は、その識別子とコミットメント（最初のラウンドから）がCommitment_Listに表示されることを確認する必要があります。参加者が任意の入力メッセージの処理を制限するアプリケーションは、関連するアプリケーション層入力検証チェックを実行するためにも必要です。詳細については、セクション7.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "Upon receipt and successful input validation, each signer then runs the following procedure to produce its own signature share.",
      "ja": "入力検証を受け取って成功したとき、各署名者は次の手順を実行して、独自の署名シェアを作成します。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- identifier, identifier i of the participant, a NonZeroScalar.\n- sk_i, signer secret key share, a Scalar.\n- group_public_key, public key corresponding to the group signing\n  key, an Element.\n- nonce_i, pair of Scalar values (hiding_nonce, binding_nonce)\n  generated in round one.\n- msg, the message to be signed, a byte string.\n- commitment_list = [(i, hiding_nonce_commitment_i,\n  binding_nonce_commitment_i), ...], a list of commitments issued by\n  each participant, where each element in the list indicates a\n  NonZeroScalar identifier i and two commitment Element values\n  (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list\n  MUST be sorted in ascending order by identifier.\n\n\nOutputs:\n- sig_share, a signature share, a Scalar.\n\ndef sign(identifier, sk_i, group_public_key,\n         nonce_i, msg, commitment_list):\n  # Compute the binding factor(s)\n  binding_factor_list = compute_binding_factors(group_public_key,\n   commitment_list, msg)\n  binding_factor = binding_factor_for_participant(\n      binding_factor_list, identifier)\n\n  # Compute the group commitment\n  group_commitment = compute_group_commitment(\n      commitment_list, binding_factor_list)\n\n  # Compute the interpolating value\n  participant_list = participants_from_commitment_list(\n      commitment_list)\n  lambda_i = derive_interpolating_value(participant_list, identifier)\n\n  # Compute the per-message challenge\n  challenge = compute_challenge(\n      group_commitment, group_public_key, msg)\n\n  # Compute the signature share\n  (hiding_nonce, binding_nonce) = nonce_i\n  sig_share = hiding_nonce + (binding_nonce * binding_factor) +\n      (lambda_i * sk_i * challenge)\n\n  return sig_share",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The output of this procedure is a signature share. Each participant sends these shares back to the Coordinator. Each participant MUST delete the nonce and corresponding commitment after completing sign and MUST NOT use the nonce as input more than once to sign.",
      "ja": "この手順の出力は署名共有です。各参加者は、これらの株式をコーディネーターに送り返します。各参加者は、サインを完了した後にNONCEと対応するコミットメントを削除する必要があり、署名するためにNONCEを入力として複数回使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "Note that the lambda_i value derived during this procedure does not change across FROST signing operations for the same signing group. As such, participants can compute it once and store it for reuse across signing sessions.",
      "ja": "この手順中に導出されたLambda_I値は、同じ署名グループの霜の署名業務全体で変わらないことに注意してください。そのため、参加者はそれを一度計算し、署名セッション全体で再利用するために保存できます。"
    },
    {
      "indent": 0,
      "text": "5.3. Signature Share Aggregation",
      "section_title": true,
      "ja": "5.3. 署名共有集約"
    },
    {
      "indent": 3,
      "text": "After participants perform round two and send their signature shares to the Coordinator, the Coordinator aggregates each share to produce a final signature. Before aggregating, the Coordinator MUST validate each signature share using DeserializeScalar. If validation fails, the Coordinator MUST abort the protocol, as the resulting signature will be invalid. If all signature shares are valid, the Coordinator aggregates them to produce the final signature using the following procedure.",
      "ja": "参加者がラウンド2を実行し、署名株をコーディネーターに送信した後、コーディネーターは各共有を集約して最終的な署名を作成します。集約する前に、コーディネーターはDeserializeScalarを使用して各署名共有を検証する必要があります。検証が失敗した場合、結果の署名が無効になるため、コーディネーターはプロトコルを中止する必要があります。すべての署名株式が有効な場合、コーディネーターはそれらを集計して、次の手順を使用して最終的な署名を作成します。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- commitment_list = [(i, hiding_nonce_commitment_i,\n  binding_nonce_commitment_i), ...], a list of commitments issued by\n  each participant, where each element in the list indicates a\n  NonZeroScalar identifier i and two commitment Element values\n  (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list\n  MUST be sorted in ascending order by identifier.\n- msg, the message to be signed, a byte string.\n- group_public_key, public key corresponding to the group signing\n  key, an Element.\n- sig_shares, a set of signature shares z_i, Scalar values, for each\n  participant, of length NUM_PARTICIPANTS, where\n  MIN_PARTICIPANTS <= NUM_PARTICIPANTS <= MAX_PARTICIPANTS.\n\nOutputs:\n- (R, z), a Schnorr signature consisting of an Element R and\n  Scalar z.\n\ndef aggregate(commitment_list, msg, group_public_key, sig_shares):\n  # Compute the binding factors\n  binding_factor_list = compute_binding_factors(group_public_key,\n   commitment_list, msg)\n\n  # Compute the group commitment\n  group_commitment = compute_group_commitment(\n      commitment_list, binding_factor_list)\n\n  # Compute aggregated signature\n  z = Scalar(0)\n  for z_i in sig_shares:\n    z = z + z_i\n  return (group_commitment, z)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The output from the aggregation step is the output signature (R, z). The canonical encoding of this signature is specified in Section 6.",
      "ja": "集約ステップからの出力は、出力署名（R、Z）です。この署名の標準エンコーディングは、セクション6で指定されています。"
    },
    {
      "indent": 3,
      "text": "The Coordinator SHOULD verify this signature using the group public key before publishing or releasing the signature. Signature verification is as specified for the corresponding ciphersuite; see Section 6 for details. The aggregate signature will verify successfully if all signature shares are valid. Moreover, subsets of valid signature shares will not yield a valid aggregate signature themselves.",
      "ja": "コーディネーターは、署名を公開またはリリースする前に、グループ公開キーを使用してこの署名を確認する必要があります。署名検証は、対応する暗号化されているように指定されているとおりです。詳細については、セクション6を参照してください。すべての署名株式が有効である場合、集約署名は正常に検証されます。さらに、有効な署名株のサブセットは、有効な集計署名自体を生成しません。"
    },
    {
      "indent": 3,
      "text": "If the aggregate signature verification fails, the Coordinator MAY verify each signature share individually to identify and act on misbehaving participants. The mechanism for acting on a misbehaving participant is out of scope for this specification; see Section 5.4 for more information about dealing with invalid signatures and misbehaving participants.",
      "ja": "集計署名検証が失敗した場合、コーディネーターは各署名共有を個別に検証して、誤動作の参加者を特定し、行動することができます。不正行為の参加者に基づいて行動するメカニズムは、この仕様の範囲外です。無効な署名と不正行為の参加者への対処の詳細については、セクション5.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "The function for verifying a signature share, denoted as verify_signature_share, is described below. Recall that the Coordinator is configured with \"group info\" that contains the group public key PK and public keys PK_i for each participant. The group_public_key and PK_i function arguments MUST come from that previously stored group info.",
      "ja": "Verify_signature_shareとして示される署名共有を検証する機能を以下に説明します。コーディネーターは、各参加者のグループ公開キーPKとパブリックキーPK_Iを含む「グループ情報」で構成されていることを思い出してください。Group_public_keyおよびpk_i関数の引数は、以前に保存されていたグループ情報から来る必要があります。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- identifier, identifier i of the participant, a NonZeroScalar.\n- PK_i, the public key for the i-th participant, where\n  PK_i = G.ScalarBaseMult(sk_i), an Element.\n- comm_i, pair of Element values in G\n  (hiding_nonce_commitment, binding_nonce_commitment) generated in\n  round one from the i-th participant.\n- sig_share_i, a Scalar value indicating the signature share as\n  produced in round two from the i-th participant.\n- commitment_list = [(i, hiding_nonce_commitment_i,\n  binding_nonce_commitment_i), ...], a list of commitments issued by\n  each participant, where each element in the list indicates a\n  NonZeroScalar identifier i and two commitment Element values\n  (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list\n  MUST be sorted in ascending order by identifier.\n- group_public_key, public key corresponding to the group signing\n  key, an Element.\n- msg, the message to be signed, a byte string.\n\nOutputs:\n- True if the signature share is valid, and False otherwise.\n\ndef verify_signature_share(\n        identifier, PK_i, comm_i, sig_share_i, commitment_list,\n        group_public_key, msg):\n  # Compute the binding factors\n  binding_factor_list = compute_binding_factors(group_public_key,\n   commitment_list, msg)\n  binding_factor = binding_factor_for_participant(\n      binding_factor_list, identifier)\n\n  # Compute the group commitment\n  group_commitment = compute_group_commitment(\n      commitment_list, binding_factor_list)\n\n  # Compute the commitment share\n  (hiding_nonce_commitment, binding_nonce_commitment) = comm_i\n  comm_share = hiding_nonce_commitment + G.ScalarMult(\n      binding_nonce_commitment, binding_factor)\n\n  # Compute the challenge\n  challenge = compute_challenge(\n      group_commitment, group_public_key, msg)\n\n  # Compute the interpolating value\n  participant_list = participants_from_commitment_list(\n      commitment_list)\n  lambda_i = derive_interpolating_value(participant_list, identifier)\n\n  # Compute relation values\n  l = G.ScalarBaseMult(sig_share_i)\n  r = comm_share + G.ScalarMult(PK_i, challenge * lambda_i)\n\n  return l == r",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Coordinator can verify each signature share before aggregating and verifying the signature under the group public key. However, since the aggregate signature is valid if all signature shares are valid, this order of operations is more expensive if the signature is valid.",
      "ja": "コーディネーターは、グループ公開キーの下で署名を集約および検証する前に、各署名共有を検証できます。ただし、すべての署名株式が有効である場合、集約署名は有効であるため、署名が有効な場合、この運用順序はより高価になります。"
    },
    {
      "indent": 0,
      "text": "5.4. Identifiable Abort",
      "section_title": true,
      "ja": "5.4. 識別可能な中止"
    },
    {
      "indent": 3,
      "text": "FROST does not provide robustness; i.e, all participants are required to complete the protocol honestly in order to generate a valid signature. When the signing protocol does not produce a valid signature, the Coordinator SHOULD abort; see Section 7 for more information about FROST's security properties and the threat model.",
      "ja": "霜は堅牢性を提供しません。つまり、すべての参加者は、有効な署名を生成するために、プロトコルを正直に完了する必要があります。署名プロトコルが有効な署名を作成しない場合、コーディネーターは中止する必要があります。Frostのセキュリティプロパティと脅威モデルの詳細については、セクション7を参照してください。"
    },
    {
      "indent": 3,
      "text": "As a result of this property, a misbehaving participant can cause a denial of service (DoS) on the signing protocol by contributing malformed signature shares or refusing to participate. Identifying misbehaving participants that produce invalid shares can be done by checking signature shares from each participant using verify_signature_share as described in Section 5.3. FROST assumes the network channel is authenticated to identify the signer that misbehaved. FROST allows for identifying misbehaving participants that produce invalid signature shares as described in Section 5.3. FROST does not provide accommodations for identifying participants that refuse to participate, though applications are assumed to detect when participants fail to engage in the signing protocol.",
      "ja": "このプロパティの結果、不正行為の参加者は、不正な署名株式を貢献したり、参加を拒否したりすることにより、署名プロトコルのサービス拒否（DOS）を引き起こす可能性があります。無効な株式を生成する誤動作の参加者を特定することは、セクション5.3で説明されているverify_signature_shareを使用して、各参加者の署名株式をチェックすることで実行できます。Frostは、ネットワークチャネルが認証され、不正行為が行われた署名者を識別することを想定しています。Frostは、セクション5.3で説明されているように、無効な署名株式を生成する不正行為の参加者を特定することができます。Frostは、参加者が署名プロトコルに従事できなかったときに検出するとアプリケーションが検出されると想定されていますが、参加を拒否する参加者を特定するための宿泊施設を提供しません。"
    },
    {
      "indent": 3,
      "text": "In both cases, preventing this type of attack requires the Coordinator to identify misbehaving participants such that applications can take corrective action. The mechanism for acting on misbehaving participants is out of scope for this specification. However, one reasonable approach would be to remove the misbehaving participant from the set of allowed participants in future runs of FROST.",
      "ja": "どちらの場合も、このタイプの攻撃を防ぐには、コーディネーターが誤動作の参加者を特定する必要があり、アプリケーションが是正措置を講じることができます。不正行為の参加者に基づいて行動するメカニズムは、この仕様の範囲外です。ただし、1つの合理的なアプローチは、将来の霜の実行における許可された参加者のセットから、誤動作の参加者を削除することです。"
    },
    {
      "indent": 0,
      "text": "6. Ciphersuites",
      "section_title": true,
      "ja": "6. ciphersuites"
    },
    {
      "indent": 3,
      "text": "A FROST ciphersuite must specify the underlying prime-order group details and cryptographic hash function. Each ciphersuite is denoted as (Group, Hash), e.g., (ristretto255, SHA-512). This section contains some ciphersuites. Each ciphersuite also includes a context string, denoted as contextString, which is an ASCII string literal (with no terminating NUL character).",
      "ja": "霜暗号は、基礎となるプライムオーダーグループの詳細と暗号化ハッシュ関数を指定する必要があります。各ciphersuiteは（グループ、ハッシュ）として示されます。このセクションには、いくつかのciphersuitesが含まれています。各ciphersuiteには、コンテキストストリングとして示されるコンテキスト文字列も含まれています。"
    },
    {
      "indent": 3,
      "text": "The RECOMMENDED ciphersuite is (ristretto255, SHA-512) as described in Section 6.2. The (Ed25519, SHA-512) and (Ed448, SHAKE256) ciphersuites are included for compatibility with Ed25519 and Ed448 as defined in [RFC8032].",
      "ja": "推奨されるCiphersuiteは、セクション6.2で説明されているように（Ristretto255、SHA-512）です。[RFC8032]で定義されているように、（ED25519、SHA-512）および（ED448、Shake256）ciphersuitesは、ED25519およびED448との互換性のために含まれています。"
    },
    {
      "indent": 3,
      "text": "The DeserializeElement and DeserializeScalar functions instantiated for a particular prime-order group corresponding to a ciphersuite MUST adhere to the description in Section 3.1. Validation steps for these functions are described for each of the ciphersuites below. Future ciphersuites MUST describe how input validation is done for DeserializeElement and DeserializeScalar.",
      "ja": "deserializeElementおよびDeserializecalar機能は、Ciphersuiteに対応する特定のプライムオーダーグループにインスタンス化された機能を、セクション3.1の説明に付着させる必要があります。これらの関数の検証手順は、以下の各透過剤について説明します。将来のシファースーツは、DeserializeElementとDeserializecalarの入力検証がどのように行われるかを説明する必要があります。"
    },
    {
      "indent": 3,
      "text": "Each ciphersuite includes explicit instructions for verifying signatures produced by FROST. Note that these instructions are equivalent to those produced by a single participant.",
      "ja": "各Ciphersuiteには、Frostによって生成された署名を検証するための明示的な指示が含まれています。これらの指示は、1人の参加者が作成した指示と同等であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Each ciphersuite adheres to the requirements in Section 6.6. Future ciphersuites MUST also adhere to these requirements.",
      "ja": "各ciphersuiteは、セクション6.6の要件に準拠しています。将来のciphersuitesもこれらの要件を遵守する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1. FROST(Ed25519, SHA-512)",
      "section_title": true,
      "ja": "6.1. 霜（ED25519、SHA-512）"
    },
    {
      "indent": 3,
      "text": "This ciphersuite uses edwards25519 for the Group and SHA-512 for the hash function H meant to produce Ed25519-compliant signatures as specified in Section 5.1 of [RFC8032]. The value of the contextString parameter is \"FROST-ED25519-SHA512-v1\".",
      "ja": "このciphersuiteは、[RFC8032]のセクション5.1で指定されているように、ED25519に準拠した署名を生成することを目的とした、グループにEdwards25519、Hash関数HにはSHA-512を使用します。コンテキストストリングパラメーターの値は「frost-ed25519-sha512-v1」です。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ："
    },
    {
      "indent": 12,
      "text": "edwards25519 [RFC8032], where Ne = 32 and Ns = 32.",
      "ja": "Edwards25519 [RFC 8032]、ここで、ne = 32ndおよびns = 32。"
    },
    {
      "indent": 6,
      "text": "Order():",
      "ja": "注文（）："
    },
    {
      "indent": 15,
      "text": "Return 2^252 + 27742317777372353535851937790883648493 (see [RFC7748]).",
      "ja": "2^252 + 277423177777235353585193779083648493（[rfc7748]を参照）を返します。"
    },
    {
      "indent": 6,
      "text": "Identity():",
      "ja": "身元（）："
    },
    {
      "indent": 15,
      "text": "As defined in [RFC7748].",
      "ja": "[RFC7748]で定義されています。"
    },
    {
      "indent": 6,
      "text": "RandomScalar():",
      "ja": "randomscalar（）："
    },
    {
      "indent": 15,
      "text": "Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Appendix D for implementation guidance.",
      "ja": "範囲[0、g.order（）-1]に均一にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、付録Dを参照してください。"
    },
    {
      "indent": 6,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement（a）："
    },
    {
      "indent": 15,
      "text": "Implemented as specified in [RFC8032], Section 5.1.2. Additionally, this function validates that the input element is not the group identity element.",
      "ja": "[RFC8032]で指定されているように実装されている、セクション5.1.2。さらに、この関数は、入力要素がグループID要素ではないことを検証します。"
    },
    {
      "indent": 6,
      "text": "DeserializeElement(buf):",
      "ja": "DeserializeElement（BUF）："
    },
    {
      "indent": 15,
      "text": "Implemented as specified in [RFC8032], Section 5.1.3. Additionally, this function validates that the resulting element is not the group identity element and is in the prime-order subgroup. If any of these checks fail, deserialization returns an error. The latter check can be implemented by multiplying the resulting point by the order of the group and checking that the result is the identity element. Note that optimizations for this check exist; see [Pornin22].",
      "ja": "[RFC8032]で指定されているように実装されています。セクション5.1.3。さらに、この関数は、結果の要素がグループアイデンティティ要素ではなく、プライムオーダーサブグループにあることを検証します。これらのチェックのいずれかが失敗した場合、脱介入はエラーを返します。後者のチェックは、結果のポイントにグループの順序を掛け、結果がID要素であることを確認することで実装できます。このチェックの最適化が存在することに注意してください。[Pornin22]を参照してください。"
    },
    {
      "indent": 6,
      "text": "SerializeScalar(s):",
      "ja": "serializescalar（s）："
    },
    {
      "indent": 15,
      "text": "Implemented by outputting the little-endian 32-byte encoding of the Scalar value with the top three bits set to zero.",
      "ja": "スカラー値のリトルエンディアン32バイトエンコードを出力することで実装され、上位3ビットがゼロに設定されています。"
    },
    {
      "indent": 6,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar（BUF）："
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a Scalar from a little-endian 32-byte string. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1]. Note that this means the top three bits of the input MUST be zero.",
      "ja": "リトルエンディアンの32バイトの文字列からスカラーを脱着しようとすることにより実装されます。入力が範囲のスカラーを表していない場合、この関数は故障する可能性があります[0、g.order（）-1]。これは、入力の上位3ビットがゼロでなければならないことを意味することに注意してください。"
    },
    {
      "indent": 3,
      "text": "Hash (H):",
      "ja": "ハッシュ（H）："
    },
    {
      "indent": 12,
      "text": "SHA-512, which has an output of 64 bytes.",
      "ja": "SHA-512。出力は64バイトです。"
    },
    {
      "indent": 6,
      "text": "H1(m):",
      "ja": "H1（M）："
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"rho\" || m), interpreting the 64-byte digest as a little-endian integer, and reducing the resulting integer modulo 2^252 + 27742317777372353535851937790883648493.",
      "ja": "H（ContextString || \"Rho\" || M）の計算により実装され、64バイトのダイジェストを小さなエンディアン整数として解釈し、結果として得られる整数252 + 277423177777777235353535851937790883648493。"
    },
    {
      "indent": 6,
      "text": "H2(m):",
      "ja": "H2（M）："
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(m), interpreting the 64-byte digest as a little-endian integer, and reducing the resulting integer modulo 2^252 + 27742317777372353535851937790883648493.",
      "ja": "H（M）を計算することで実装され、64バイトダイジェストをリトルエンディアン整数として解釈し、結果として得られた整数モジュロ2^252 + 27742317777372353535358519377990883648493を減らします。"
    },
    {
      "indent": 6,
      "text": "H3(m):",
      "ja": "H3（m）："
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"nonce\" || m), interpreting the 64-byte digest as a little-endian integer, and reducing the resulting integer modulo 2^252 + 27742317777372353535851937790883648493.",
      "ja": "h（コンテキストストリング|| \"nonce\" || m）を計算し、64バイトのダイジェストを小さなエンディアン整数として解釈し、結果として得られた整数2^252 + 277423177777777235353535851937790883648493を減らします。"
    },
    {
      "indent": 6,
      "text": "H4(m):",
      "ja": "H4（M）："
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"msg\" || m).",
      "ja": "コンピューティングH（ContextString || \"MSG\" || M）によって実装されます。"
    },
    {
      "indent": 6,
      "text": "H5(m):",
      "ja": "H5（m）："
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"com\" || m).",
      "ja": "h（contextString || \"com\" || m）を計算することによって実装されます。"
    },
    {
      "indent": 3,
      "text": "Normally, H2 would also include a domain separator; however, for compatibility with [RFC8032], it is omitted.",
      "ja": "通常、H2にはドメインセパレーターも含まれます。ただし、[RFC8032]との互換性のためには、省略されています。"
    },
    {
      "indent": 3,
      "text": "Signature verification is as specified in Section 5.1.7 of [RFC8032] with the constraint that implementations MUST check the group equation [8][z]B = [8]R + [8][c]PK (changed to use the notation in this document).",
      "ja": "署名検証は、[RFC8032]のセクション5.1.7で指定されているとおり、実装はグループ方程式[8] [Z] b = [8] [8] [c] PKを確認する必要があるという制約を伴う（表記の使用に変更されたこのドキュメントで）。"
    },
    {
      "indent": 3,
      "text": "Canonical signature encoding is as specified in Appendix A.",
      "ja": "標準的な署名エンコーディングは、付録Aで指定されています。"
    },
    {
      "indent": 0,
      "text": "6.2. FROST(ristretto255, SHA-512)",
      "section_title": true,
      "ja": "6.2. 霜（Ristretto255、Sha-512）"
    },
    {
      "indent": 3,
      "text": "This ciphersuite uses ristretto255 for the Group and SHA-512 for the hash function H. The value of the contextString parameter is \"FROST-RISTRETTO255-SHA512-v1\".",
      "ja": "このCiphersuiteは、グループにRistretto255を使用し、Hash関数HにはSHA-512を使用します。コンテキストストリングパラメーターの値は「Frost-Ristretto255-Sha512-V1」です。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ："
    },
    {
      "indent": 12,
      "text": "ristretto255 [RISTRETTO], where Ne = 32 and Ns = 32.",
      "ja": "ristretto255 [ristretto]、ここでne = 32およびns = 32。"
    },
    {
      "indent": 6,
      "text": "Order():",
      "ja": "注文（）："
    },
    {
      "indent": 15,
      "text": "Return 2^252 + 27742317777372353535851937790883648493 (see [RISTRETTO]).",
      "ja": "2^252 + 2774231777772353535851937790883648493（[Ristretto]を参照）を返します。"
    },
    {
      "indent": 6,
      "text": "Identity():",
      "ja": "身元（）："
    },
    {
      "indent": 15,
      "text": "As defined in [RISTRETTO].",
      "ja": "[Ristretto]で定義されています。"
    },
    {
      "indent": 6,
      "text": "RandomScalar():",
      "ja": "randomscalar（）："
    },
    {
      "indent": 15,
      "text": "Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Appendix D for implementation guidance.",
      "ja": "範囲[0、g.order（）-1]に均一にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、付録Dを参照してください。"
    },
    {
      "indent": 6,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement（a）："
    },
    {
      "indent": 15,
      "text": "Implemented using the \"Encode\" function from [RISTRETTO]. Additionally, this function validates that the input element is not the group identity element.",
      "ja": "[Ristretto]の「エンコード」関数を使用して実装されました。さらに、この関数は、入力要素がグループID要素ではないことを検証します。"
    },
    {
      "indent": 6,
      "text": "DeserializeElement(buf):",
      "ja": "DeserializeElement（BUF）："
    },
    {
      "indent": 15,
      "text": "Implemented using the \"Decode\" function from [RISTRETTO]. Additionally, this function validates that the resulting element is not the group identity element. If either the \"Decode\" function or the check fails, deserialization returns an error.",
      "ja": "[Ristretto]の「デコード」関数を使用して実装されました。さらに、この関数は、結果の要素がグループアイデンティティ要素ではないことを検証します。「デコード」関数またはチェックが失敗した場合、脱介入はエラーを返します。"
    },
    {
      "indent": 6,
      "text": "SerializeScalar(s):",
      "ja": "serializescalar（s）："
    },
    {
      "indent": 15,
      "text": "Implemented by outputting the little-endian 32-byte encoding of the Scalar value with the top three bits set to zero.",
      "ja": "スカラー値のリトルエンディアン32バイトエンコードを出力することで実装され、上位3ビットがゼロに設定されています。"
    },
    {
      "indent": 6,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar（BUF）："
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a Scalar from a little-endian 32-byte string. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1]. Note that this means the top three bits of the input MUST be zero.",
      "ja": "リトルエンディアンの32バイトの文字列からスカラーを脱着しようとすることにより実装されます。入力が範囲のスカラーを表していない場合、この関数は故障する可能性があります[0、g.order（）-1]。これは、入力の上位3ビットがゼロでなければならないことを意味することに注意してください。"
    },
    {
      "indent": 3,
      "text": "Hash (H):",
      "ja": "ハッシュ（H）："
    },
    {
      "indent": 12,
      "text": "SHA-512, which has 64 bytes of output.",
      "ja": "SHA-512、64バイトの出力があります。"
    },
    {
      "indent": 6,
      "text": "H1(m):",
      "ja": "H1（M）："
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"rho\" || m) and mapping the output to a Scalar as described in [RISTRETTO], Section 4.4.",
      "ja": "[コンテキストストリング|| \"rho\" || m）を計算し、[Ristretto]、セクション4.4で説明されているように、出力をスカラーにマッピングすることによって実装されます。"
    },
    {
      "indent": 6,
      "text": "H2(m):",
      "ja": "H2（M）："
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"chal\" || m) and mapping the output to a Scalar as described in [RISTRETTO], Section 4.4.",
      "ja": "[ContextString || \"Chal\" || M）のコンピューティングによって実装され、[Ristretto]、セクション4.4で説明されているように、出力をスカラーにマッピングします。"
    },
    {
      "indent": 6,
      "text": "H3(m):",
      "ja": "H3（m）："
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"nonce\" || m) and mapping the output to a Scalar as described in [RISTRETTO], Section 4.4.",
      "ja": "[コンテキストストリング|| \"nonce\" || m）のコンピューティングによって実装され、[Ristretto]、セクション4.4で説明されているように、出力をスカラーにマッピングします。"
    },
    {
      "indent": 6,
      "text": "H4(m):",
      "ja": "H4（M）："
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"msg\" || m).",
      "ja": "コンピューティングH（ContextString || \"MSG\" || M）によって実装されます。"
    },
    {
      "indent": 6,
      "text": "H5(m):",
      "ja": "H5（m）："
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"com\" || m).",
      "ja": "h（contextString || \"com\" || m）を計算することによって実装されます。"
    },
    {
      "indent": 3,
      "text": "Signature verification is as specified in Appendix B.",
      "ja": "署名検証は、付録Bで指定されています。"
    },
    {
      "indent": 3,
      "text": "Canonical signature encoding is as specified in Appendix A.",
      "ja": "標準的な署名エンコーディングは、付録Aで指定されています。"
    },
    {
      "indent": 0,
      "text": "6.3. FROST(Ed448, SHAKE256)",
      "section_title": true,
      "ja": "6.3. フロスト（ED448、Shake256）"
    },
    {
      "indent": 3,
      "text": "This ciphersuite uses edwards448 for the Group and SHAKE256 for the hash function H meant to produce Ed448-compliant signatures as specified in Section 5.2 of [RFC8032]. Unlike Ed448 in [RFC8032], this ciphersuite does not allow applications to specify a context string and always sets the context of [RFC8032] to the empty string. Note that this ciphersuite does not allow applications to specify a context string as is allowed for Ed448 in [RFC8032], and always sets the [RFC8032] context string to the empty string. The value of the (internal to FROST) contextString parameter is \"FROST-ED448-SHAKE256-v1\".",
      "ja": "このCiphersuiteは、グループにEdwards448を使用し、Hash関数HにSake256を使用して、[RFC8032]のセクション5.2で指定されているED48準拠の署名を生成することを目的としています。[RFC8032]のED448とは異なり、このCiphersuiteはアプリケーションがコンテキスト文字列を指定することを許可せず、常に[RFC8032]のコンテキストを空の文字列に設定します。このciphersuiteでは、[RFC8032]のED448に許可されているようにアプリケーションがコンテキスト文字列を指定することを許可しておらず、常に[RFC8032]コンテキスト文字列を空の文字列に設定します。（霜から）コンテキストストリングパラメーターの値は「frost-ed448-shake256-v1」です。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ："
    },
    {
      "indent": 12,
      "text": "edwards448 [RFC8032], where Ne = 57 and Ns = 57.",
      "ja": "エドワーズ448 [RFC 8032]、ここで、ne = 57thおよびns = 57。"
    },
    {
      "indent": 6,
      "text": "Order():",
      "ja": "注文（）："
    },
    {
      "indent": 15,
      "text": "Return 2^446 - 13818066809895115352007386748515426880336 692474882178609894547503885.",
      "ja": "2^446-1381806809895115352007386748515426880336 692474882178609894547503885。"
    },
    {
      "indent": 6,
      "text": "Identity():",
      "ja": "身元（）："
    },
    {
      "indent": 15,
      "text": "As defined in [RFC7748].",
      "ja": "[RFC7748]で定義されています。"
    },
    {
      "indent": 6,
      "text": "RandomScalar():",
      "ja": "randomscalar（）："
    },
    {
      "indent": 15,
      "text": "Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Appendix D for implementation guidance.",
      "ja": "範囲[0、g.order（）-1]に均一にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、付録Dを参照してください。"
    },
    {
      "indent": 6,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement（a）："
    },
    {
      "indent": 15,
      "text": "Implemented as specified in [RFC8032], Section 5.2.2. Additionally, this function validates that the input element is not the group identity element.",
      "ja": "[RFC8032]で指定されているように実装されている、セクション5.2.2。さらに、この関数は、入力要素がグループID要素ではないことを検証します。"
    },
    {
      "indent": 6,
      "text": "DeserializeElement(buf):",
      "ja": "DeserializeElement（BUF）："
    },
    {
      "indent": 15,
      "text": "Implemented as specified in [RFC8032], Section 5.2.3. Additionally, this function validates that the resulting element is not the group identity element and is in the prime-order subgroup. If any of these checks fail, deserialization returns an error. The latter check can be implemented by multiplying the resulting point by the order of the group and checking that the result is the identity element. Note that optimizations for this check exist; see [Pornin22].",
      "ja": "[RFC8032]で指定されているように実装されています。セクション5.2.3。さらに、この関数は、結果の要素がグループアイデンティティ要素ではなく、プライムオーダーサブグループにあることを検証します。これらのチェックのいずれかが失敗した場合、脱介入はエラーを返します。後者のチェックは、結果のポイントにグループの順序を掛け、結果がID要素であることを確認することで実装できます。このチェックの最適化が存在することに注意してください。[Pornin22]を参照してください。"
    },
    {
      "indent": 6,
      "text": "SerializeScalar(s):",
      "ja": "serializescalar（s）："
    },
    {
      "indent": 15,
      "text": "Implemented by outputting the little-endian 57-byte encoding of the Scalar value.",
      "ja": "スカラー値のリトルエンディアン57バイトエンコードを出力することにより実装されます。"
    },
    {
      "indent": 6,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar（BUF）："
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a Scalar from a little-endian 57-byte string. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1].",
      "ja": "リトルエンディアン57バイトの文字列からスカラーを脱着しようとすることにより実装されます。入力が範囲のスカラーを表していない場合、この関数は故障する可能性があります[0、g.order（）-1]。"
    },
    {
      "indent": 3,
      "text": "Hash (H):",
      "ja": "ハッシュ（H）："
    },
    {
      "indent": 12,
      "text": "SHAKE256 with 114 bytes of output.",
      "ja": "114バイトの出力を備えたShake256。"
    },
    {
      "indent": 6,
      "text": "H1(m):",
      "ja": "H1（M）："
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"rho\" || m), interpreting the 114-byte digest as a little-endian integer, and reducing the resulting integer modulo 2^446 - 1381806680989 5115352007386748515426880336692474882178609894547503885.",
      "ja": "H（コンテキストストリング|| \"rho\" || m）を計算し、114バイトのダイジェストを小さなエンディアン整数として解釈し、結果として得られた整数2^446-138180680989 。"
    },
    {
      "indent": 6,
      "text": "H2(m):",
      "ja": "H2（M）："
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(\"SigEd448\" || 0 || 0 || m), interpreting the 114-byte digest as a little-endian integer, and reducing the resulting integer modulo 2^446 - 1381806680989 5115352007386748515426880336692474882178609894547503885.",
      "ja": "h（ \"siged448\" || 0 || 0 || m）を計算し、114バイトのダイジェストを小さなエンディアン整数として解釈し、結果の整数modulo 2^446-1381806680989 511552007388885154268888888888888888824824882 503885。"
    },
    {
      "indent": 6,
      "text": "H3(m):",
      "ja": "H3（m）："
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"nonce\" || m), interpreting the 114-byte digest as a little-endian integer, and reducing the resulting integer modulo 2^446 - 1381806680989 5115352007386748515426880336692474882178609894547503885.",
      "ja": "h（コンテキストストリング|| \"nonce\" || m）を計算し、114バイトのダイジェストを小さなエンディアン整数として解釈し、結果として生じる整数^446-138180680989 。"
    },
    {
      "indent": 6,
      "text": "H4(m):",
      "ja": "H4（M）："
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"msg\" || m).",
      "ja": "コンピューティングH（ContextString || \"MSG\" || M）によって実装されます。"
    },
    {
      "indent": 6,
      "text": "H5(m):",
      "ja": "H5（m）："
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"com\" || m).",
      "ja": "h（contextString || \"com\" || m）を計算することによって実装されます。"
    },
    {
      "indent": 3,
      "text": "Normally, H2 would also include a domain separator. However, it is omitted for compatibility with [RFC8032].",
      "ja": "通常、H2にはドメインセパレーターも含まれます。ただし、[RFC8032]との互換性のために省略されています。"
    },
    {
      "indent": 3,
      "text": "Signature verification is as specified in Section 5.2.7 of [RFC8032] with the constraint that implementations MUST check the group equation [4][z]B = [4]R + [4][c]PK (changed to use the notation in this document).",
      "ja": "署名検証は、[RFC8032]のセクション5.2.7で指定されているとおり、実装はグループ方程式[4] [z] b = [4] r + [c] pkをチェックする必要があるという制約を伴う（表記の使用に変更されたこのドキュメントで）。"
    },
    {
      "indent": 3,
      "text": "Canonical signature encoding is as specified in Appendix A.",
      "ja": "標準的な署名エンコーディングは、付録Aで指定されています。"
    },
    {
      "indent": 0,
      "text": "6.4. FROST(P-256, SHA-256)",
      "section_title": true,
      "ja": "6.4. 霜（P-256、SHA-256）"
    },
    {
      "indent": 3,
      "text": "This ciphersuite uses P-256 for the Group and SHA-256 for the hash function H. The value of the contextString parameter is \"FROST-P256-SHA256-v1\".",
      "ja": "このciphersuiteは、グループにP-256、ハッシュ関数HにSHA-256を使用します。コンテキストストリングパラメーターの値は「frost-p256-sha256-v1」です。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ："
    },
    {
      "indent": 12,
      "text": "P-256 (secp256r1) [x9.62], where Ne = 33 and Ns = 32.",
      "ja": "P-256（SECP256R1）[x9.62]、ここでne = 33およびns = 32。"
    },
    {
      "indent": 6,
      "text": "Order():",
      "ja": "注文（）："
    },
    {
      "indent": 15,
      "text": "Return 0xffffffff00000000ffffffffffffffffbce6faada7179e8 4f3b9cac2fc632551.",
      "ja": "0xfffffffff0000000000fffffffffffffffbbce6faada7179e8 4f3b9cac2ffc632551を返します。"
    },
    {
      "indent": 6,
      "text": "Identity():",
      "ja": "身元（）："
    },
    {
      "indent": 15,
      "text": "As defined in [x9.62].",
      "ja": "[x9.62]で定義されています。"
    },
    {
      "indent": 6,
      "text": "RandomScalar():",
      "ja": "randomscalar（）："
    },
    {
      "indent": 15,
      "text": "Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Appendix D for implementation guidance.",
      "ja": "範囲[0、g.order（）-1]に均一にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、付録Dを参照してください。"
    },
    {
      "indent": 6,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement（a）："
    },
    {
      "indent": 15,
      "text": "Implemented using the compressed Elliptic-Curve-Point-to-Octet-String method according to [SEC1], yielding a 33-byte output. Additionally, this function validates that the input element is not the group identity element.",
      "ja": "[SEC1]に従って圧縮された楕円曲線からオクセットのストリング方法を使用して実装され、33バイトの出力が得られます。さらに、この関数は、入力要素がグループID要素ではないことを検証します。"
    },
    {
      "indent": 6,
      "text": "DeserializeElement(buf):",
      "ja": "DeserializeElement（BUF）："
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a 33-byte input string to a public key using the compressed Octet-String-to-Elliptic-Curve-Point method according to [SEC1] and then performing public key validation as defined in Section 3.2.2.1 of [SEC1]. This includes checking that the coordinates of the resulting point are in the correct range, that the point is on the curve, and that the point is not the point at infinity. (As noted in the specification, validation of the point order is not required since the cofactor is 1.) If any of these checks fail, deserialization returns an error.",
      "ja": "[SEC1]に従って圧縮されたオクテットストリングからエリプチからエリプチ - カーブポイントメソッドを使用して、33バイトの入力文字列を公開キーに脱着しようとすることにより実装され、[[SEC1]のセクション3.2.2.1で定義されている公開キー検証を実行します。Sec1]。これには、結果のポイントの座標が正しい範囲にあること、ポイントが曲線上にあること、およびポイントが無限のポイントではないことを確認することが含まれます。（仕様に記載されているように、補助因子が1であるため、ポイント順序の検証は必要ありません。）これらのチェックのいずれかが失敗した場合、脱介入はエラーを返します。"
    },
    {
      "indent": 6,
      "text": "SerializeScalar(s):",
      "ja": "serializescalar（s）："
    },
    {
      "indent": 15,
      "text": "Implemented using the Field-Element-to-Octet-String conversion according to [SEC1].",
      "ja": "[SEC1]に従って、フィールドエレメントからオクセットのストリング変換を使用して実装されました。"
    },
    {
      "indent": 6,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar（BUF）："
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a Scalar from a 32-byte string using Octet-String-to-Field-Element from [SEC1]. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1].",
      "ja": "[SEC1]からのオクテットストリングからフィールドエレメントを使用して、32バイトの文字列からスカラーを脱派化しようとすることにより実装されます。入力が範囲のスカラーを表していない場合、この関数は故障する可能性があります[0、g.order（）-1]。"
    },
    {
      "indent": 3,
      "text": "Hash (H):",
      "ja": "ハッシュ（H）："
    },
    {
      "indent": 12,
      "text": "SHA-256, which has 32 bytes of output.",
      "ja": "SHA-256、32バイトの出力があります。"
    },
    {
      "indent": 6,
      "text": "H1(m):",
      "ja": "H1（M）："
    },
    {
      "indent": 15,
      "text": "Implemented as hash_to_field(m, 1) (see [HASH-TO-CURVE], Section 5.2) using expand_message_xmd with SHA-256 with parameters DST = contextString || \"rho\", F set to the Scalar field, p set to G.Order(), m = 1, and L = 48.",
      "ja": "hash_to_field（m、1）として実装されています（[hash-to-curve]、セクション5.2を参照）を使用してsha-256を使用してexpand_message_xmdを使用します。「rho」、fはスカラーフィールドに設定され、pはg.order（）、m = 1、およびl = 48に設定されています。"
    },
    {
      "indent": 6,
      "text": "H2(m):",
      "ja": "H2（M）："
    },
    {
      "indent": 15,
      "text": "Implemented as hash_to_field(m, 1) (see [HASH-TO-CURVE], Section 5.2) using expand_message_xmd with SHA-256 with parameters DST = contextString || \"chal\", F set to the Scalar field, p set to G.Order(), m = 1, and L = 48.",
      "ja": "hash_to_field（m、1）として実装されています（[hash-to-curve]、セクション5.2を参照）を使用してsha-256を使用してexpand_message_xmdを使用します。「Chal」、fはスカラーフィールドに設定され、pはg.order（）、m = 1、およびl = 48に設定されています。"
    },
    {
      "indent": 6,
      "text": "H3(m):",
      "ja": "H3（m）："
    },
    {
      "indent": 15,
      "text": "Implemented as hash_to_field(m, 1) (see [HASH-TO-CURVE], Section 5.2) using expand_message_xmd with SHA-256 with parameters DST = contextString || \"nonce\", F set to the Scalar field, p set to G.Order(), m = 1, and L = 48.",
      "ja": "hash_to_field（m、1）として実装されています（[hash-to-curve]、セクション5.2を参照）を使用してsha-256を使用してexpand_message_xmdを使用します。「nonce」、fはスカラーフィールドに設定され、pはg.order（）、m = 1、およびl = 48に設定されています。"
    },
    {
      "indent": 6,
      "text": "H4(m):",
      "ja": "H4（M）："
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"msg\" || m).",
      "ja": "コンピューティングH（ContextString || \"MSG\" || M）によって実装されます。"
    },
    {
      "indent": 6,
      "text": "H5(m):",
      "ja": "H5（m）："
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"com\" || m).",
      "ja": "h（contextString || \"com\" || m）を計算することによって実装されます。"
    },
    {
      "indent": 3,
      "text": "Signature verification is as specified in Appendix B.",
      "ja": "署名検証は、付録Bで指定されています。"
    },
    {
      "indent": 3,
      "text": "Canonical signature encoding is as specified in Appendix A.",
      "ja": "標準的な署名エンコーディングは、付録Aで指定されています。"
    },
    {
      "indent": 0,
      "text": "6.5. FROST(secp256k1, SHA-256)",
      "section_title": true,
      "ja": "6.5. 霜（SECP256K1、SHA-256）"
    },
    {
      "indent": 3,
      "text": "This ciphersuite uses secp256k1 for the Group and SHA-256 for the hash function H. The value of the contextString parameter is \"FROST-secp256k1-SHA256-v1\".",
      "ja": "このciphersuiteは、グループにSECP256K1、ハッシュ関数HにSHA-256を使用します。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ："
    },
    {
      "indent": 12,
      "text": "secp256k1 [SEC2], where Ne = 33 and Ns = 32.",
      "ja": "SECP256K1 [SEC2]、ここでNE = 33およびNS = 32。"
    },
    {
      "indent": 6,
      "text": "Order():",
      "ja": "注文（）："
    },
    {
      "indent": 15,
      "text": "Return 0xfffffffffffffffffffffffffffffffebaaedce6af48a03 bbfd25e8cd0364141.",
      "ja": "0xfffffffffffffffffffffffffffffffffebaedce6af48a03 bbfd25e8cd0364141を返します。"
    },
    {
      "indent": 6,
      "text": "Identity():",
      "ja": "身元（）："
    },
    {
      "indent": 15,
      "text": "As defined in [SEC2].",
      "ja": "[Sec2]で定義されているとおり。"
    },
    {
      "indent": 6,
      "text": "RandomScalar():",
      "ja": "randomscalar（）："
    },
    {
      "indent": 15,
      "text": "Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Appendix D for implementation guidance.",
      "ja": "範囲[0、g.order（）-1]に均一にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、付録Dを参照してください。"
    },
    {
      "indent": 6,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement（a）："
    },
    {
      "indent": 15,
      "text": "Implemented using the compressed Elliptic-Curve-Point-to-Octet-String method according to [SEC1], yielding a 33-byte output. Additionally, this function validates that the input element is not the group identity element.",
      "ja": "[SEC1]に従って圧縮された楕円曲線からオクセットのストリング方法を使用して実装され、33バイトの出力が得られます。さらに、この関数は、入力要素がグループID要素ではないことを検証します。"
    },
    {
      "indent": 6,
      "text": "DeserializeElement(buf):",
      "ja": "DeserializeElement（BUF）："
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a 33-byte input string to a public key using the compressed Octet-String-to-Elliptic-Curve-Point method according to [SEC1] and then performing public key validation as defined in Section 3.2.2.1 of [SEC1]. This includes checking that the coordinates of the resulting point are in the correct range, the point is on the curve, and the point is not the point at infinity. (As noted in the specification, validation of the point order is not required since the cofactor is 1.) If any of these checks fail, deserialization returns an error.",
      "ja": "[SEC1]に従って圧縮されたオクテットストリングからエリプチからエリプチ - カーブポイントメソッドを使用して、33バイトの入力文字列を公開キーに脱着しようとすることにより実装され、[[SEC1]のセクション3.2.2.1で定義されている公開キー検証を実行します。Sec1]。これには、結果のポイントの座標が正しい範囲にあること、ポイントが曲線上にあること、ポイントが無限のポイントではないことを確認することが含まれます。（仕様に記載されているように、補助因子が1であるため、ポイント順序の検証は必要ありません。）これらのチェックのいずれかが失敗した場合、脱介入はエラーを返します。"
    },
    {
      "indent": 6,
      "text": "SerializeScalar(s):",
      "ja": "serializescalar（s）："
    },
    {
      "indent": 15,
      "text": "Implemented using the Field-Element-to-Octet-String conversion according to [SEC1].",
      "ja": "[SEC1]に従って、フィールドエレメントからオクセットのストリング変換を使用して実装されました。"
    },
    {
      "indent": 6,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar（BUF）："
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a Scalar from a 32-byte string using Octet-String-to-Field-Element from [SEC1]. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1].",
      "ja": "[SEC1]からのオクテットストリングからフィールドエレメントを使用して、32バイトの文字列からスカラーを脱派化しようとすることにより実装されます。入力が範囲のスカラーを表していない場合、この関数は故障する可能性があります[0、g.order（）-1]。"
    },
    {
      "indent": 3,
      "text": "Hash (H):",
      "ja": "ハッシュ（H）："
    },
    {
      "indent": 12,
      "text": "SHA-256, which has 32 bytes of output.",
      "ja": "SHA-256、32バイトの出力があります。"
    },
    {
      "indent": 6,
      "text": "H1(m):",
      "ja": "H1（M）："
    },
    {
      "indent": 15,
      "text": "Implemented as hash_to_field(m, 1) (see [HASH-TO-CURVE], Section 5.2) using expand_message_xmd with SHA-256 with parameters DST = contextString || \"rho\", F set to the Scalar field, p set to G.Order(), m = 1, and L = 48.",
      "ja": "hash_to_field（m、1）として実装されています（[hash-to-curve]、セクション5.2を参照）を使用してsha-256を使用してexpand_message_xmdを使用します。「rho」、fはスカラーフィールドに設定され、pはg.order（）、m = 1、およびl = 48に設定されています。"
    },
    {
      "indent": 6,
      "text": "H2(m):",
      "ja": "H2（M）："
    },
    {
      "indent": 15,
      "text": "Implemented as hash_to_field(m, 1) (see [HASH-TO-CURVE], Section 5.2) using expand_message_xmd with SHA-256 with parameters DST = contextString || \"chal\", F set to the Scalar field, p set to G.Order(), m = 1, and L = 48.",
      "ja": "hash_to_field（m、1）として実装されています（[hash-to-curve]、セクション5.2を参照）を使用してsha-256を使用してexpand_message_xmdを使用します。「Chal」、fはスカラーフィールドに設定され、pはg.order（）、m = 1、およびl = 48に設定されています。"
    },
    {
      "indent": 6,
      "text": "H3(m):",
      "ja": "H3（m）："
    },
    {
      "indent": 15,
      "text": "Implemented as hash_to_field(m, 1) (see [HASH-TO-CURVE], Section 5.2) using expand_message_xmd with SHA-256 with parameters DST = contextString || \"nonce\", F set to the Scalar field, p set to G.Order(), m = 1, and L = 48.",
      "ja": "hash_to_field（m、1）として実装されています（[hash-to-curve]、セクション5.2を参照）を使用してsha-256を使用してexpand_message_xmdを使用します。「nonce」、fはスカラーフィールドに設定され、pはg.order（）、m = 1、およびl = 48に設定されています。"
    },
    {
      "indent": 6,
      "text": "H4(m):",
      "ja": "H4（M）："
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"msg\" || m).",
      "ja": "コンピューティングH（ContextString || \"MSG\" || M）によって実装されます。"
    },
    {
      "indent": 6,
      "text": "H5(m):",
      "ja": "H5（m）："
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"com\" || m).",
      "ja": "h（contextString || \"com\" || m）を計算することによって実装されます。"
    },
    {
      "indent": 3,
      "text": "Signature verification is as specified in Appendix B.",
      "ja": "署名検証は、付録Bで指定されています。"
    },
    {
      "indent": 3,
      "text": "Canonical signature encoding is as specified in Appendix A.",
      "ja": "標準的な署名エンコーディングは、付録Aで指定されています。"
    },
    {
      "indent": 0,
      "text": "6.6. Ciphersuite Requirements",
      "section_title": true,
      "ja": "6.6. ciphersuite要件"
    },
    {
      "indent": 3,
      "text": "Future documents that introduce new ciphersuites MUST adhere to the following requirements.",
      "ja": "新しいCiphersuitesを導入する将来の文書は、以下の要件を遵守する必要があります。"
    },
    {
      "indent": 8,
      "text": "1. H1, H2, and H3 all have output distributions that are close to (indistinguishable from) the uniform distribution.",
      "ja": "1. H1、H2、およびH3にはすべて、均一な分布に近い（区別できない）出力分布があります。"
    },
    {
      "indent": 8,
      "text": "2. All hash functions MUST be domain-separated with a per-suite context string. Note that the FROST(Ed25519, SHA-512) ciphersuite does not adhere to this requirement for H2 alone in order to maintain compatibility with [RFC8032].",
      "ja": "2. すべてのハッシュ関数は、スイートごとのコンテキスト文字列でドメイン分離されている必要があります。霜（ED25519、SHA-512）Ciphersuiteは、[RFC8032]との互換性を維持するために、H2のみのこの要件を順守していないことに注意してください。"
    },
    {
      "indent": 8,
      "text": "3. The group MUST be of prime order and all deserialization functions MUST output elements that belong to their respective sets of Elements or Scalars, or else fail.",
      "ja": "3. グループは主要な秩序である必要があり、すべての脱出機能は、それぞれの要素またはスカラーのセットに属する要素を出力する必要があります。そうしないと、失敗します。"
    },
    {
      "indent": 8,
      "text": "4. The canonical signature encoding details are clearly specified.",
      "ja": "4. 標準的な署名エンコードの詳細が明確に指定されています。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "A security analysis of FROST is documented in [FROST20] and [StrongerSec22]. At a high level, FROST provides security against Existential Unforgeability Under Chosen Message Attacks (EUF-CMA) as defined in [StrongerSec22]. To satisfy this requirement, the ciphersuite needs to adhere to the requirements in Section 6.6 and the following assumptions must hold.",
      "ja": "霜のセキュリティ分析は、[frost20]および[strongersec22]に文書化されています。高レベルでは、Frostは、[Strongersec22]で定義されているように、選択されたメッセージ攻撃（EUF-CMA）の下での実存的な容赦のないセキュリティを提供します。この要件を満たすには、Ciphersuiteはセクション6.6の要件を遵守する必要があり、次の仮定を保持する必要があります。"
    },
    {
      "indent": 6,
      "text": "* The signer key shares are generated and distributed securely, e.g., via a trusted dealer that performs key generation (see Appendix C.2) or through a distributed key generation protocol.",
      "ja": "* 署名者のキー株は、たとえば、キー生成を実行する信頼できるディーラー（付録C.2を参照）または分散キー生成プロトコルを介して、安全に生成および配布されます。"
    },
    {
      "indent": 6,
      "text": "* The Coordinator and at most (MIN_PARTICIPANTS-1) participants may be corrupted.",
      "ja": "* コーディネーターとせいぜい（min_partication-1）参加者が破損する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Note that the Coordinator is not trusted with any private information, and communication at the time of signing can be performed over a public channel as long as it is authenticated and reliable.",
      "ja": "コーディネーターは個人情報に信頼されておらず、署名時のコミュニケーションは公開チャネルで認証されて信頼できる限り実行できることに注意してください。"
    },
    {
      "indent": 3,
      "text": "FROST provides security against DoS attacks under the following assumptions:",
      "ja": "Frostは、次の仮定の下でDOS攻撃に対するセキュリティを提供します。"
    },
    {
      "indent": 6,
      "text": "* The Coordinator does not perform a DoS attack.",
      "ja": "* コーディネーターはDOS攻撃を実行しません。"
    },
    {
      "indent": 6,
      "text": "* The Coordinator identifies misbehaving participants such that they can be removed from future invocations of FROST. The Coordinator may also abort upon detecting a misbehaving participant to ensure that invalid signatures are not produced.",
      "ja": "* コーディネーターは、frostの将来の呼び出しから削除できるように、誤動作の参加者を特定します。また、コーディネーターは、不正行為の参加者を検出して、無効な署名が生成されないことを確認することで中止する場合があります。"
    },
    {
      "indent": 3,
      "text": "FROST does not aim to achieve the following goals:",
      "ja": "フロストは、次の目標を達成することを目指していません。"
    },
    {
      "indent": 6,
      "text": "* Post-quantum security. FROST, like plain Schnorr signatures, requires the hardness of the Discrete Logarithm Problem.",
      "ja": "* 質量セキュリティ。Frostは、単純なSchnorrの署名のように、離散対数問題の硬度を必要とします。"
    },
    {
      "indent": 6,
      "text": "* Robustness. Preventing DoS attacks against misbehaving participants requires the Coordinator to identify and act on misbehaving participants; see Section 5.4 for more information. While FROST does not provide robustness, [ROAST] is a wrapper protocol around FROST that does.",
      "ja": "* 堅牢性。不正行為の参加者に対するDOS攻撃を防ぐには、コーディネーターが誤動作の参加者を特定し、行動する必要があります。詳細については、セクション5.4を参照してください。フロストは堅牢性を提供しませんが、[ロースト]は霜に関するラッパープロトコルです。"
    },
    {
      "indent": 6,
      "text": "* Downgrade prevention. All participants in the protocol are assumed to agree on which algorithms to use.",
      "ja": "* 格下げ予防。プロトコルのすべての参加者は、どのアルゴリズムを使用するかに同意すると想定されています。"
    },
    {
      "indent": 6,
      "text": "* Metadata protection. If protection for metadata is desired, a higher-level communication channel can be used to facilitate key generation and signing.",
      "ja": "* メタデータ保護。メタデータの保護が必要な場合は、重要な生成と署名を促進するために、高レベルの通信チャネルを使用できます。"
    },
    {
      "indent": 3,
      "text": "The rest of this section documents issues particular to implementations or deployments.",
      "ja": "このセクションの残りの部分は、実装または展開に特化した問題を文書化します。"
    },
    {
      "indent": 0,
      "text": "7.1. Side-Channel Mitigations",
      "section_title": true,
      "ja": "7.1. サイドチャネル緩和"
    },
    {
      "indent": 3,
      "text": "Several routines process secret values (nonces, signing keys / shares), and depending on the implementation and deployment environment, mitigating side-channels may be pertinent. Mitigating these side-channels requires implementing G.ScalarMult(), G.ScalarBaseMult(), G.SerializeScalar(), and G.DeserializeScalar() in constant (value-independent) time. The various ciphersuites lend themselves differently to specific implementation techniques and ease of achieving side-channel resistance, though ultimately avoiding value-dependent computation or branching is the goal.",
      "ja": "いくつかのルーチンは秘密の値（NONCES、署名キー /共有）を処理し、実装と展開環境に応じて、サイドチャネルの緩和が適切な場合があります。これらのサイドチャネルを緩和するには、g.scalarmult（）、g.scalarbasemult（）、g.serializescalar（）、およびg.deserializescalar（）を一定（値に依存しない）時間で実装する必要があります。さまざまなシファースーツは、特定の実装技術とサイドチャネル抵抗の達成の容易さとは異なる方法で異なりますが、最終的には価値依存の計算または分岐を回避することが目標です。"
    },
    {
      "indent": 0,
      "text": "7.2. Optimizations",
      "section_title": true,
      "ja": "7.2. 最適化"
    },
    {
      "indent": 3,
      "text": "[StrongerSec22] presented an optimization to FROST that reduces the total number of Scalar multiplications from linear in the number of signing participants to a constant. However, as described in [StrongerSec22], this optimization removes the guarantee that the set of signer participants that started round one of the protocol is the same set of signing participants that produced the signature output by round two. As such, the optimization is NOT RECOMMENDED and is not covered in this document.",
      "ja": "[Strongersec22]は、署名参加者の数の線形からスカラー乗算の総数を減少させる霜の最適化を提示しました。ただし、[Strongersec22]で説明されているように、この最適化により、プロトコルの1つを開始した署名者参加者のセットが、ラウンド2で署名出力を生成した署名参加者と同じセットであるという保証が削除されます。そのため、最適化は推奨されず、このドキュメントではカバーされていません。"
    },
    {
      "indent": 0,
      "text": "7.3. Nonce Reuse Attacks",
      "section_title": true,
      "ja": "7.3. ノンセの再利用攻撃"
    },
    {
      "indent": 3,
      "text": "Section 4.1 describes the procedure that participants use to produce nonces during the first round of signing. The randomness produced in this procedure MUST be sampled uniformly at random. The resulting nonces produced via nonce_generate are indistinguishable from values sampled uniformly at random. This requirement is necessary to avoid replay attacks initiated by other participants that allow for a complete key-recovery attack. The Coordinator MAY further hedge against nonce reuse attacks by tracking participant nonce commitments used for a given group key at the cost of additional state.",
      "ja": "セクション4.1では、参加者が署名の最初のラウンド中にノンセを作成するために使用する手順について説明します。この手順で生成されたランダム性は、ランダムに均一にサンプリングする必要があります。非CE_Generateを介して生成される結果の非能力は、ランダムに均一にサンプリングされた値と区別できません。この要件は、完全なキー回復攻撃を可能にする他の参加者によって開始されたリプレイ攻撃を避けるために必要です。コーディネーターは、追加の状態を犠牲にして特定のグループキーに使用された参加者NonCEコミットメントを追跡することにより、NonCEの再利用攻撃に対してさらにヘッジすることができます。"
    },
    {
      "indent": 0,
      "text": "7.4. Protocol Failures",
      "section_title": true,
      "ja": "7.4. プロトコル障害"
    },
    {
      "indent": 3,
      "text": "We do not specify what implementations should do when the protocol fails other than requiring the protocol to abort. Examples of viable failures include when a verification check returns invalid or the underlying transport failed to deliver the required messages.",
      "ja": "プロトコルが中止することを要求する以外に、プロトコルが失敗した場合、実装が行うべきものを指定しません。実行可能な障害の例には、検証チェックが無効な場合、または基礎となる輸送が必要なメッセージの配信に失敗した場合が含まれます。"
    },
    {
      "indent": 0,
      "text": "7.5. Removing the Coordinator Role",
      "section_title": true,
      "ja": "7.5. コーディネーターの役割の削除"
    },
    {
      "indent": 3,
      "text": "In some settings, it may be desirable to omit the role of the Coordinator entirely. Doing so does not change the security implications of FROST; instead, it simply requires each participant to communicate with all other participants. We loosely describe how to perform FROST signing among participants without this coordinator role. We assume that every participant receives a message to be signed from an external source as input prior to performing the protocol.",
      "ja": "一部の設定では、コーディネーターの役割を完全に省略することが望ましい場合があります。そうすることは、霜のセキュリティへの影響を変えません。代わりに、各参加者に他のすべての参加者と通信する必要があります。このコーディネーターの役割なしで、参加者間で霜の署名を実行する方法を大まかに説明します。すべての参加者が、プロトコルを実行する前に、外部ソースから入力として署名するメッセージを受け取ると想定しています。"
    },
    {
      "indent": 3,
      "text": "Every participant begins by performing commit() as is done in the setting where a Coordinator is used. However, instead of sending the commitment to the Coordinator, every participant will publish this commitment to every other participant. In the second round, participants will already have sufficient information to perform signing, and they will directly perform sign(). All participants will then publish their signature shares to one another. After having received all signature shares from all other participants, each participant will then perform verify_signature_share and then aggregate directly.",
      "ja": "すべての参加者は、コーディネーターが使用される設定で行われるように、compid（）を実行することから始めます。ただし、コーディネーターにコミットメントを送信する代わりに、すべての参加者は他のすべての参加者にこのコミットメントを公開します。第2ラウンドでは、参加者はすでに署名を実行するのに十分な情報を持っており、Sign（）を直接実行します。その後、すべての参加者が署名株を互いに公開します。他のすべての参加者からすべての署名株式を受け取った後、各参加者はverify_signature_shareを実行し、直接集計します。"
    },
    {
      "indent": 3,
      "text": "The requirements for the underlying network channel remain the same in the setting where all participants play the role of the Coordinator, in that all exchanged messages are public and the channel must be reliable. However, in the setting where a player attempts to split the view of all other players by sending disjoint values to a subset of players, the signing operation will output an invalid signature. To avoid this DoS, implementations may wish to define a mechanism where messages are authenticated so that cheating players can be identified and excluded.",
      "ja": "基礎となるネットワークチャネルの要件は、すべての参加者がコーディネーターの役割を果たしている設定では同じままです。ただし、プレイヤーが他のすべてのプレイヤーのビューをプレーヤーのサブセットに送信することで他のすべてのプレイヤーのビューを分割しようとする設定では、署名操作が無効な署名を出力します。このDOSを回避するために、実装は、不正行為者を特定して除外できるように、メッセージが認証されているメカニズムを定義したい場合があります。"
    },
    {
      "indent": 0,
      "text": "7.6. Input Message Hashing",
      "section_title": true,
      "ja": "7.6. 入力メッセージのハッシュ"
    },
    {
      "indent": 3,
      "text": "FROST signatures do not pre-hash message inputs. This means that the entire message must be known in advance of invoking the signing protocol. Applications can apply pre-hashing in settings where storing the full message is prohibitively expensive. In such cases, pre-hashing MUST use a collision-resistant hash function with a security level commensurate with the security inherent to the ciphersuite chosen. For applications that choose to apply pre-hashing, it is RECOMMENDED that they use the hash function (H) associated with the chosen ciphersuite in a manner similar to how H4 is defined. In particular, a different prefix SHOULD be used to differentiate this pre-hash from H4. For example, if a fictional protocol Quux decided to pre-hash its input messages, one possible way to do so is via H(contextString || \"Quux-pre-hash\" || m).",
      "ja": "霜の署名は、メッセージ入力を事前に投げかけることはありません。これは、署名プロトコルを呼び出す前に、メッセージ全体が知られている必要があることを意味します。アプリケーションは、完全なメッセージを保存することが法外に高価である設定で事前ハッシュを適用できます。そのような場合、事前ハッシュは、選択した衝突器に固有のセキュリティに見合ったセキュリティレベルを持つ衝突耐性ハッシュ関数を使用する必要があります。事前ハッシュを適用することを選択したアプリケーションの場合、選択したシファースイートに関連付けられたハッシュ関数（H）を使用することをお勧めします。H4の定義方法と同様の方法です。特に、このプレハッシュをH4と区別するために、別のプレフィックスを使用する必要があります。たとえば、架空のプロトコルQuuxが入力メッセージを事前にハッシュすることを決定した場合、それを行うための1つの可能な方法は、h（contextString || \"quux-pre-hash\" || m）を介してです。"
    },
    {
      "indent": 0,
      "text": "7.7. Input Message Validation",
      "section_title": true,
      "ja": "7.7. 入力メッセージの検証"
    },
    {
      "indent": 3,
      "text": "Message validation varies by application. For example, some applications may require that participants only process messages of a certain structure. In digital currency applications, wherein multiple participants may collectively sign a transaction, it is reasonable to require each participant to check that the input message is a syntactically valid transaction.",
      "ja": "メッセージの検証は、アプリケーションによって異なります。たとえば、一部のアプリケーションでは、参加者が特定の構造のメッセージのみを処理する必要がある場合があります。複数の参加者が集合的にトランザクションに署名する可能性のあるデジタル通貨アプリケーションでは、各参加者に入力メッセージが構文的に有効なトランザクションであることを確認することが妥当です。"
    },
    {
      "indent": 3,
      "text": "As another example, some applications may require that participants only process messages with permitted content according to some policy. In digital currency applications, this might mean that a transaction being signed is allowed and intended by the relevant stakeholders. Another instance of this type of message validation is in the context of [TLS], wherein implementations may use threshold signing protocols to produce signatures of transcript hashes. In this setting, signing participants might require the raw TLS handshake messages to validate before computing the transcript hash that is signed.",
      "ja": "別の例として、一部のアプリケーションでは、参加者が何らかのポリシーに従って許可されたコンテンツを使用してメッセージを処理することを要求する場合があります。デジタル通貨アプリケーションでは、これは署名されている取引が許可され、関連する利害関係者によって意図されていることを意味する場合があります。このタイプのメッセージ検証の別のインスタンスは、[TLS]のコンテキストにあります。この場合、実装はしきい値署名プロトコルを使用して、トランスクリプトハッシュの署名を作成する場合があります。この設定では、参加者に署名することで、署名されているトランスクリプトハッシュを計算する前に、生のTLSハンドシェイクメッセージを検証する必要がある場合があります。"
    },
    {
      "indent": 3,
      "text": "In general, input message validation is an application-specific consideration that varies based on the use case and threat model. However, it is RECOMMENDED that applications take additional precautions and validate inputs so that participants do not operate as signing oracles for arbitrary messages.",
      "ja": "一般に、入力メッセージの検証は、ユースケースと脅威モデルに基づいて異なるアプリケーション固有の考慮事項です。ただし、アプリケーションは追加の予防措置を講じて入力を検証して、参加者が任意のメッセージのオラクル署名として動作しないようにすることをお勧めします。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "このドキュメントにはIANAアクションがありません。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9. 参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[HASH-TO-CURVE]\n           Faz-Hernandez, A., Scott, S., Sullivan, N., Wahby, R. S.,\n           and C. A. Wood, \"Hashing to Elliptic Curves\", RFC 9380,\n           DOI 10.17487/RFC9380, August 2023,\n           <https://www.rfc-editor.org/info/rfc9380>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8032]  Josefsson, S. and I. Liusvaara, \"Edwards-Curve Digital\n           Signature Algorithm (EdDSA)\", RFC 8032,\n           DOI 10.17487/RFC8032, January 2017,\n           <https://www.rfc-editor.org/info/rfc8032>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RISTRETTO]\n           de Valence, H., Grigg, J., Hamburg, M., Lovecruft, I.,\n           Tankersley, G., and F. Valsorda, \"The ristretto255 and\n           decaf448 Groups\", RFC 9496, DOI 10.17487/RFC9496, December\n           2023, <https://www.rfc-editor.org/info/rfc9496>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SEC1]     Standards for Efficient Cryptography, \"SEC 1: Elliptic\n           Curve Cryptography\", Version 2.0, May 2009,\n           <https://secg.org/sec1-v2.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SEC2]     Standards for Efficient Cryptography, \"SEC 2: Recommended\n           Elliptic Curve Domain Parameters\", Version 2.0, January\n           2010, <https://secg.org/sec2-v2.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[x9.62]    American National Standards Institute, \"Public Key\n           Cryptography for the Financial Services Industry: the\n           Elliptic Curve Digital Signature Algorithm (ECDSA)\",\n           ANSI X9.62-2005, November 2005.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[FeldmanSecretSharing]\n           Feldman, P., \"A practical scheme for non-interactive\n           verifiable secret sharing\", IEEE, 28th Annual Symposium on\n           Foundations of Computer Science (sfcs 1987),\n           DOI 10.1109/sfcs.1987.4, October 1987,\n           <https://doi.org/10.1109/sfcs.1987.4>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[FROST20]  Komlo, C. and I. Goldberg, \"FROST: Flexible Round-\n           Optimized Schnorr Threshold Signatures\", December 2020,\n           <https://eprint.iacr.org/2020/852.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[MultExp]  Connolly, D. and C. Gouvea, \"Speeding up FROST with multi-\n           scalar multiplication\", June 2023, <https://zfnd.org/\n           speeding-up-frost-with-multi-scalar-multiplication/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Pornin22] Pornin, T., \"Point-Halving and Subgroup Membership in\n           Twisted Edwards Curves\", September 2022,\n           <https://eprint.iacr.org/2022/1164.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,\n           \"Randomness Requirements for Security\", BCP 106, RFC 4086,\n           DOI 10.17487/RFC4086, June 2005,\n           <https://www.rfc-editor.org/info/rfc4086>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7748]  Langley, A., Hamburg, M., and S. Turner, \"Elliptic Curves\n           for Security\", RFC 7748, DOI 10.17487/RFC7748, January\n           2016, <https://www.rfc-editor.org/info/rfc7748>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[ROAST]    Ruffing, T., Ronge, V., Jin, E., Schneider-Bensch, J., and\n           D. Schröder, \"ROAST: Robust Asynchronous Schnorr Threshold\n           Signatures\", Paper 2022/550, DOI 10.1145/3548606, November\n           2022, <https://eprint.iacr.org/2022/550>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[ShamirSecretSharing]\n           Shamir, A., \"How to share a secret\", Association for\n           Computing Machinery (ACM), Communications of the ACM, Vol.\n           22, Issue 11, pp. 612-613, DOI 10.1145/359168.359176,\n           November 1979, <https://doi.org/10.1145/359168.359176>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[StrongerSec22]\n           Bellare, M., Crites, E., Komlo, C., Maller, M., Tessaro,\n           S., and C. Zhu, \"Better than Advertised Security for Non-\n           interactive Threshold Signatures\",\n           DOI 10.1007/978-3-031-15985-5_18, August 2022,\n           <https://crypto.iacr.org/2022/\n           papers/538806_1_En_18_Chapter_OnlinePDF.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[TLS]      Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n           Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n           <https://www.rfc-editor.org/info/rfc8446>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix A. Schnorr Signature Encoding",
      "section_title": true,
      "ja": "付録A. Schnorr署名エンコーディング"
    },
    {
      "indent": 3,
      "text": "This section describes one possible canonical encoding of FROST signatures. Using notation from Section 3 of [TLS], the encoding of a FROST signature (R, z) is as follows:",
      "ja": "このセクションでは、霜の署名の1つの可能な標準エンコーディングについて説明します。[TLS]のセクション3の表記法を使用して、霜の署名（R、Z）のエンコードは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "struct {\n  opaque R_encoded[Ne];\n  opaque z_encoded[Ns];\n} Signature;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where Signature.R_encoded is G.SerializeElement(R), Signature.z_encoded is G.SerializeScalar(z), and G is determined by ciphersuite.",
      "ja": "signature.r_encodedはG.SerializeElement（r）、signature.z_encodedはG.SerializeScalar（z）、GはCiphersuiteによって決定されます。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Schnorr Signature Generation and Verification for Prime- Order Groups",
      "section_title": true,
      "ja": "付録B. プライムオーダーグループのSchnorr署名生成と検証"
    },
    {
      "indent": 3,
      "text": "This section contains descriptions of functions for generating and verifying Schnorr signatures. It is included to complement the routines present in [RFC8032] for prime-order groups, including ristretto255, P-256, and secp256k1. The functions for generating and verifying signatures are prime_order_sign and prime_order_verify, respectively.",
      "ja": "このセクションには、Schnorrの署名を生成および検証するための関数の説明が含まれています。Ristretto255、P-256、およびSECP256K1を含むプライムオーダーグループの[RFC8032]に存在するルーチンを補完するために含まれています。署名を生成および検証するための関数は、それぞれPRIME_ORDER_SIGNとPRIME_ORDER_VERIFYです。"
    },
    {
      "indent": 3,
      "text": "The function prime_order_sign produces a Schnorr signature over a message given a full secret signing key as input (as opposed to a key share).",
      "ja": "関数prime_order_signは、入力として（キー共有とは対照的に）完全な秘密署名キーを与えられたメッセージに対してschnorr署名を作成します。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- msg, message to sign, a byte string.\n- sk, secret key, a Scalar.\n\nOutputs:\n- (R, z), a Schnorr signature consisting of an Element R and\n  Scalar z.\n\ndef prime_order_sign(msg, sk):\n  r = G.RandomScalar()\n  R = G.ScalarBaseMult(r)\n  PK = G.ScalarBaseMult(sk)\n  comm_enc = G.SerializeElement(R)\n  pk_enc = G.SerializeElement(PK)\n  challenge_input = comm_enc || pk_enc || msg\n  c = H2(challenge_input)\n  z = r + (c * sk) // Scalar addition and multiplication\n  return (R, z)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The function prime_order_verify verifies Schnorr signatures with validated inputs. Specifically, it assumes that the signature R component and public key belong to the prime-order group.",
      "ja": "関数prime_order_verifyは、検証済みの入力を使用してSchnorr署名を検証します。具体的には、署名Rコンポーネントと公開キーがプライムオーダーグループに属していると想定しています。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- msg, signed message, a byte string.\n- sig, a tuple (R, z) output from signature generation.\n- PK, public key, an Element.\n\nOutputs:\n- True if signature is valid, and False otherwise.\n\ndef prime_order_verify(msg, sig = (R, z), PK):\n  comm_enc = G.SerializeElement(R)\n  pk_enc = G.SerializeElement(PK)\n  challenge_input = comm_enc || pk_enc || msg\n  c = H2(challenge_input)\n\n  l = G.ScalarBaseMult(z)\n  r = R + G.ScalarMult(PK, c)\n  return l == r",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix C. Trusted Dealer Key Generation",
      "section_title": true,
      "ja": "付録C. 信頼できるディーラーキージェネレーション"
    },
    {
      "indent": 3,
      "text": "One possible key generation mechanism is to depend on a trusted dealer, wherein the dealer generates a group secret s uniformly at random and uses Shamir and Verifiable Secret Sharing [ShamirSecretSharing] as described in Appendices C.1 and C.2 to create secret shares of s, denoted as s_i for i = 1, ..., MAX_PARTICIPANTS, to be sent to all MAX_PARTICIPANTS participants. This operation is specified in the trusted_dealer_keygen algorithm. The mathematical relation between the secret key s and the MAX_PARTICIPANTS secret shares is formalized in the secret_share_combine(shares) algorithm, defined in Appendix C.1.",
      "ja": "考えられる重要な生成メカニズムの1つは、信頼できるディーラーに依存することです。ディーラーは、グループ秘密をランダムに均一に生成し、付録C.1およびC.2で説明したShamirと検証可能な秘密共有[ShamirseCretsharing]を使用して、shamirと検証可能な秘密共有を使用します。s、i = 1、...、max_particantantのS_iとして示され、すべてのmax_particantの参加者に送られます。この操作は、trusted_dealer_keygen algorithmで指定されています。Secret Key SとMAX_PARTICANTS SECRET株式との数学的関係は、付録C.1で定義されているSecret_share_combine（Shares）アルゴリズムで正式化されています。"
    },
    {
      "indent": 3,
      "text": "The dealer that performs trusted_dealer_keygen is trusted to 1) generate good randomness, 2) delete secret values after distributing shares to each participant, and 3) keep secret values confidential.",
      "ja": "Trusted_dealer_keygenを実行するディーラーは、1）良好なランダム性を生成し、2）各参加者に株式を配布した後に秘密の値を削除し、3）秘密の値を秘密にしてください。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- secret_key, a group secret, a Scalar, that MUST be derived from at\n  least Ns bytes of entropy.\n- MAX_PARTICIPANTS, the number of shares to generate, an integer.\n- MIN_PARTICIPANTS, the threshold of the secret sharing scheme,\n  an integer.\n\nOutputs:\n- participant_private_keys, MAX_PARTICIPANTS shares of the secret\n  key s, each a tuple consisting of the participant identifier\n  (a NonZeroScalar) and the key share (a Scalar).\n- group_public_key, public key corresponding to the group signing\n  key, an Element.\n- vss_commitment, a vector commitment of Elements in G, to each of\n  the coefficients in the polynomial defined by secret_key_shares and\n  whose first element is G.ScalarBaseMult(s).\n\ndef trusted_dealer_keygen(\n        secret_key, MAX_PARTICIPANTS, MIN_PARTICIPANTS):\n  # Generate random coefficients for the polynomial\n  coefficients = []\n  for i in range(0, MIN_PARTICIPANTS - 1):\n    coefficients.append(G.RandomScalar())\n  participant_private_keys, coefficients = secret_share_shard(\n      secret_key, coefficients, MAX_PARTICIPANTS)\n  vss_commitment = vss_commit(coefficients):\n  return participant_private_keys, vss_commitment[0], vss_commitment",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "It is assumed that the dealer then sends one secret key share to each of the NUM_PARTICIPANTS participants, along with vss_commitment. After receiving their secret key share and vss_commitment, participants MUST abort if they do not have the same view of vss_commitment. The dealer can use a secure broadcast channel to ensure each participant has a consistent view of this commitment. Furthermore, each participant MUST perform vss_verify(secret_key_share_i, vss_commitment) and abort if the check fails. The trusted dealer MUST delete the secret_key and secret_key_shares upon completion.",
      "ja": "ディーラーは、vss_commitmentとともに、num_particationの各参加者に1つの秘密キー共有を送信すると想定されています。Secret Key ShareとVSS_Commitmentを受け取った後、参加者はVSS_Commitmentと同じ見解を持っていない場合は中止する必要があります。ディーラーは、安全なブロードキャストチャネルを使用して、各参加者がこのコミットメントについて一貫した見解を持っていることを確認できます。さらに、各参加者はvss_verify（secret_key_share_i、vss_commitment）を実行し、チェックが失敗した場合に中止する必要があります。信頼できるディーラーは、完了時にSecret_keyとSecret_key_sharesを削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "Use of this method for key generation requires a mutually authenticated secure channel between the dealer and participants to send secret key shares, wherein the channel provides confidentiality and integrity. Mutually authenticated TLS is one possible deployment option.",
      "ja": "キー生成にこの方法を使用するには、ディーラーと参加者の間で相互に認証された安全なチャネルが必要であり、シークレットキーシェアを送信し、チャンネルが機密性と整合性を提供します。相互に認証されたTLSは、展開オプションの1つです。"
    },
    {
      "indent": 0,
      "text": "C.1. Shamir Secret Sharing",
      "section_title": true,
      "ja": "C.1. Shamir Secret共有"
    },
    {
      "indent": 3,
      "text": "In Shamir secret sharing, a dealer distributes a secret Scalar s to n participants in such a way that any cooperating subset of at least MIN_PARTICIPANTS participants can recover the secret. There are two basic steps in this scheme: 1) splitting a secret into multiple shares and 2) combining shares to reveal the resulting secret.",
      "ja": "Shamir Secret共有では、ディーラーは、少なくともMIN_PARTIctiventの参加者の協力的なサブセットが秘密を回復できるように、秘密のスカラーをN参加者に配布します。このスキームには2つの基本的な手順があります。1）秘密を複数の共有に分割し、2）株を組み合わせて結果として生じる秘密を明らかにします。"
    },
    {
      "indent": 3,
      "text": "This secret sharing scheme works over any field F. In this specification, F is the Scalar field of the prime-order group G.",
      "ja": "この秘密共有スキームは、任意のフィールドFで機能します。この仕様では、FはプライムオーダーグループGのスカラーフィールドです。"
    },
    {
      "indent": 3,
      "text": "The procedure for splitting a secret into shares is as follows. The algorithm polynomial_evaluate is defined in Appendix C.1.1.",
      "ja": "秘密を株式に分割する手順は次のとおりです。アルゴリズムPolynomial_Evaluateは、付録C.1.1で定義されています。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- s, secret value to be shared, a Scalar.\n- coefficients, an array of size MIN_PARTICIPANTS - 1 with randomly\n  generated Scalars, not including the 0th coefficient of the\n  polynomial.\n- MAX_PARTICIPANTS, the number of shares to generate, an integer less\n  than the group order.\n\nOutputs:\n- secret_key_shares, A list of MAX_PARTICIPANTS number of secret\n  shares, each a tuple consisting of the participant identifier\n  (a NonZeroScalar) and the key share (a Scalar).\n- coefficients, a vector of MIN_PARTICIPANTS coefficients which\n  uniquely determine a polynomial f.\n\ndef secret_share_shard(s, coefficients, MAX_PARTICIPANTS):\n  # Prepend the secret to the coefficients\n  coefficients = [s] + coefficients\n\n  # Evaluate the polynomial for each point x=1,...,n\n  secret_key_shares = []\n  for x_i in range(1, MAX_PARTICIPANTS + 1):\n    y_i = polynomial_evaluate(Scalar(x_i), coefficients)\n    secret_key_share_i = (x_i, y_i)\n    secret_key_shares.append(secret_key_share_i)\n  return secret_key_shares, coefficients",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Let points be the output of this function. The i-th element in points is the share for the i-th participant, which is the randomly generated polynomial evaluated at coordinate i. We denote a secret share as the tuple (i, points[i]) and the list of these shares as shares. i MUST never equal 0; recall that f(0) = s, where f is the polynomial defined in a Shamir secret sharing operation.",
      "ja": "ポイントをこの関数の出力とします。ポイントのi第th要素は、ITH参加者の共有であり、これは座標iで評価されたランダムに生成された多項式です。秘密のシェアをタプル（i、ポイント[i]）として、およびこれらの株式のリストを株式として示します。私は決して0に等しくてはいけません。f（0）= s、fはshamir秘密共有操作で定義されている多項式であることを思い出してください。"
    },
    {
      "indent": 3,
      "text": "The procedure for combining a shares list of length MIN_PARTICIPANTS to recover the secret s is as follows; the algorithm polynomial_interpolate_constant is defined in Appendix C.1.1.",
      "ja": "秘密のsを回復するために長さのmin_particantantの共有リストを組み合わせる手順は次のとおりです。アルゴリズムpolynomial_interpolate_constantは、付録C.1.1で定義されています。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- shares, a list of at minimum MIN_PARTICIPANTS secret shares, each a\n  tuple (i, f(i)) where i and f(i) are Scalars.\n\nOutputs:\n- s, the resulting secret that was previously split into shares,\n  a Scalar.\n\nErrors:\n- \"invalid parameters\", if fewer than MIN_PARTICIPANTS input shares\n  are provided.\n\ndef secret_share_combine(shares):\n  if len(shares) < MIN_PARTICIPANTS:\n    raise \"invalid parameters\"\n  s = polynomial_interpolate_constant(shares)\n  return s",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.1.1. Additional Polynomial Operations",
      "section_title": true,
      "ja": "C.1.1. 追加の多項式操作"
    },
    {
      "indent": 3,
      "text": "This section describes two functions. One function, denoted as polynomial_evaluate, is for evaluating a polynomial f(x) at a particular point x using Horner's method, i.e., computing y = f(x). The other function, polynomial_interpolate_constant, is for recovering the constant term of an interpolating polynomial defined by a set of points.",
      "ja": "このセクションでは、2つの機能について説明します。Polynomial_evaluateとして示される1つの関数は、Hornerの方法を使用して特定のポイントxで多項式f（x）を評価するため、つまりy = f（x）を計算するためです。もう1つの関数であるPolynomial_interpolate_constantは、一連のポイントで定義される補間多項式の定数項を回復するためです。"
    },
    {
      "indent": 3,
      "text": "The function polynomial_evaluate is defined as follows.",
      "ja": "関数多項式_evaluateは次のように定義されます。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- x, input at which to evaluate the polynomial, a Scalar\n- coeffs, the polynomial coefficients, a list of Scalars\n\nOutputs: Scalar result of the polynomial evaluated at input x\n\ndef polynomial_evaluate(x, coeffs):\n  value = Scalar(0)\n  for coeff in reverse(coeffs):\n    value *= x\n    value += coeff\n  return value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The function polynomial_interpolate_constant is defined as follows.",
      "ja": "関数polynomial_interpolate_constantは次のように定義されています。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- points, a set of t points with distinct x coordinates on\n  a polynomial f, each a tuple of two Scalar values representing the\n  x and y coordinates.\n\nOutputs:\n- f_zero, the constant term of f, i.e., f(0), a Scalar.\n\ndef polynomial_interpolate_constant(points):\n  x_coords = []\n  for (x, y) in points:\n    x_coords.append(x)\n\n  f_zero = Scalar(0)\n  for (x, y) in points:\n    delta = y * derive_interpolating_value(x_coords, x)\n    f_zero += delta\n\n  return f_zero",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.2. Verifiable Secret Sharing",
      "section_title": true,
      "ja": "C.2. 検証可能な秘密共有"
    },
    {
      "indent": 3,
      "text": "Feldman's Verifiable Secret Sharing (VSS) [FeldmanSecretSharing] builds upon Shamir secret sharing, adding a verification step to demonstrate the consistency of a participant's share with a public commitment to the polynomial f for which the secret s is the constant term. This check ensures that all participants have a point (their share) on the same polynomial, ensuring that they can reconstruct the correct secret later.",
      "ja": "Feldmanの検証可能な秘密共有（VSS）[Feldmansecretsharing]はShamir Secret共有に基づいて構築され、検証ステップを追加して、秘密が定期的である多項式Fへの公的コミットメントと参加者の共有の一貫性を実証します。このチェックにより、すべての参加者が同じ多項式にポイント（シェア）があることを保証し、後で正しい秘密を再構築できるようにします。"
    },
    {
      "indent": 3,
      "text": "The procedure for committing to a polynomial f of degree at most MIN_PARTICIPANTS-1 is as follows.",
      "ja": "MIN_PARTICANTS-1の最大での多項式Fにコミットする手順は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- coeffs, a vector of the MIN_PARTICIPANTS coefficients that\n  uniquely determine a polynomial f.\n\nOutputs:\n- vss_commitment, a vector commitment to each of the coefficients in\n  coeffs, where each item of the vector commitment is an Element.\n\ndef vss_commit(coeffs):\n  vss_commitment = []\n  for coeff in coeffs:\n    A_i = G.ScalarBaseMult(coeff)\n    vss_commitment.append(A_i)\n  return vss_commitment",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The procedure for verification of a participant's share is as follows. If vss_verify fails, the participant MUST abort the protocol, and the failure should be investigated out of band.",
      "ja": "参加者の共有を検証する手順は次のとおりです。vss_verifyが失敗した場合、参加者はプロトコルを中止する必要があり、障害をバンドから調査する必要があります。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- share_i: A tuple of the form (i, sk_i), where i indicates the\n  participant identifier (a NonZeroScalar), and sk_i the\n  participant's secret key, a secret share of the constant term of f,\n  where sk_i is a Scalar.\n- vss_commitment, a VSS commitment to a secret polynomial f, a vector\n  commitment to each of the coefficients in coeffs, where each\n  element of the vector commitment is an Element.\n\nOutputs:\n- True if sk_i is valid, and False otherwise.\n\ndef vss_verify(share_i, vss_commitment)\n  (i, sk_i) = share_i\n  S_i = G.ScalarBaseMult(sk_i)\n  S_i' = G.Identity()\n  for j in range(0, MIN_PARTICIPANTS):\n    S_i' += G.ScalarMult(vss_commitment[j], pow(i, j))\n  return S_i == S_i'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "We now define how the Coordinator and participants can derive group info, which is an input into the FROST signing protocol.",
      "ja": "ここで、コーディネーターと参加者がグループ情報をどのように導き出すことができるかを定義します。これは、霜に署名するプロトコルへの入力です。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- MAX_PARTICIPANTS, the number of shares to generate, an integer.\n- MIN_PARTICIPANTS, the threshold of the secret sharing scheme,\n  an integer.\n- vss_commitment, a VSS commitment to a secret polynomial f, a vector\n  commitment to each of the coefficients in coeffs, where each\n  element of the vector commitment is an Element.\n\nOutputs:\n- PK, the public key representing the group, an Element.\n- participant_public_keys, a list of MAX_PARTICIPANTS public keys\n  PK_i for i=1,...,MAX_PARTICIPANTS, where each PK_i is the public\n  key, an Element, for participant i.\n\ndef derive_group_info(MAX_PARTICIPANTS, MIN_PARTICIPANTS,\n vss_commitment):\n  PK = vss_commitment[0]\n  participant_public_keys = []\n  for i in range(1, MAX_PARTICIPANTS+1):\n    PK_i = G.Identity()\n    for j in range(0, MIN_PARTICIPANTS):\n      PK_i += G.ScalarMult(vss_commitment[j], pow(i, j))\n    participant_public_keys.append(PK_i)\n  return PK, participant_public_keys",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix D. Random Scalar Generation",
      "section_title": true,
      "ja": "付録D. ランダムスカラー生成"
    },
    {
      "indent": 3,
      "text": "Two popular algorithms for generating a random integer uniformly distributed in the range [0, G.Order() -1] are described in the sections that follow.",
      "ja": "範囲[0、g.order（）-1]に均一に分布したランダム整数を生成するための2つの一般的なアルゴリズムは、以下のセクションで説明されています。"
    },
    {
      "indent": 0,
      "text": "D.1. Rejection Sampling",
      "section_title": true,
      "ja": "D.1. 拒否サンプリング"
    },
    {
      "indent": 3,
      "text": "Generate a random byte array with Ns bytes and attempt to map to a Scalar by calling DeserializeScalar in constant time. If it succeeds, return the result. If it fails, try again with another random byte array, until the procedure succeeds. Failure to implement DeserializeScalar in constant time can leak information about the underlying corresponding Scalar.",
      "ja": "NSバイトを使用してランダムなバイト配列を生成し、一定の時間でDeserializecalarを呼び出すことにより、スカラーにマッピングしようとします。成功した場合は、結果を返します。失敗した場合は、手順が成功するまで、別のランダムバイト配列で再試行してください。一定の時間にdeserializecalarを実装しないと、基礎となる対応するスカラーに関する情報が漏れます。"
    },
    {
      "indent": 3,
      "text": "As an optimization, if the group order is very close to a power of 2, it is acceptable to omit the rejection test completely. In particular, if the group order is p and there is an integer b such that |p - 2^b| is less than 2^(b/2), then RandomScalar can simply return a uniformly random integer of at most b bits.",
      "ja": "最適化として、グループの順序が2のパワーに非常に近い場合、拒否テストを完全に省略することは許容されます。特に、グループの順序がpで、| p -2^b |のような整数Bがある場合2^（b/2）未満である場合、Randomscalarは、ほとんどのBビットの均一にランダムな整数を単純に返すことができます。"
    },
    {
      "indent": 0,
      "text": "D.2. Wide Reduction",
      "section_title": true,
      "ja": "D.2. 大幅に減少します"
    },
    {
      "indent": 3,
      "text": "Generate a random byte array with l = ceil(((3 * ceil(log2(G.Order()))) / 2) / 8) bytes and interpret it as an integer; reduce the integer modulo G.Order() and return the result. See Section 5 of [HASH-TO-CURVE] for the underlying derivation of l.",
      "ja": "l = ceil（（3 * ceil（g.order（））） / 8） / 8）でl = ceil（（3 * ceil（g.order（））） / 8）でランダムなバイト配列を生成し、整数として解釈します。整数modulo g.order（）を減らし、結果を返します。Lの基礎となる導出については、[ハッシュツーカーブ]のセクション5を参照してください。"
    },
    {
      "indent": 0,
      "text": "Appendix E. Test Vectors",
      "section_title": true,
      "ja": "付録E. テストベクトル"
    },
    {
      "indent": 3,
      "text": "This section contains test vectors for all ciphersuites listed in Section 6. All Element and Scalar values are represented in serialized form and encoded in hexadecimal strings. Signatures are represented as the concatenation of their constituent parts. The input message to be signed is also encoded as a hexadecimal string.",
      "ja": "このセクションには、セクション6にリストされているすべてのciphersuitesのテストベクトルが含まれています。すべての要素値とスカラー値は、シリアルされた形式で表され、16進列にエンコードされています。署名は、構成部品の連結として表されます。署名される入力メッセージは、16進文字列としてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "Each test vector consists of the following information.",
      "ja": "各テストベクトルは、次の情報で構成されています。"
    },
    {
      "indent": 6,
      "text": "* Configuration. This lists the fixed parameters for the particular instantiation of FROST, including MAX_PARTICIPANTS, MIN_PARTICIPANTS, and NUM_PARTICIPANTS.",
      "ja": "* 構成。これには、MAX_PARTICANTS、MIN_PARTICANTS、およびNUM_PARTICTINGANTSを含む、霜の特定のインスタンス化の固定パラメーターがリストされています。"
    },
    {
      "indent": 6,
      "text": "* Group input parameters. This lists the group secret key and shared public key, generated by a trusted dealer as described in Appendix C, as well as the input message to be signed. The randomly generated coefficients produced by the trusted dealer to share the group signing secret are also listed. Each coefficient is identified by its index, e.g., share_polynomial_coefficients[1] is the coefficient of the first term in the polynomial. Note that the 0-th coefficient is omitted, as this is equal to the group secret key. All values are encoded as hexadecimal strings.",
      "ja": "* グループ入力パラメーター。これには、付録Cで説明されている信頼できるディーラーによって生成されたグループシークレットキーと共有公開鍵と、署名する入力メッセージがリストされています。信頼できるディーラーによって生成されたランダムに生成された係数は、署名シークレットを共有するためにリストされています。各係数は、そのインデックスによって識別されます。たとえば、share_polynomial_coefficients [1]は、多項式の最初の項の係数です。これはグループシークレットキーに等しいため、0番目の係数は省略されていることに注意してください。すべての値は、16進列としてエンコードされます。"
    },
    {
      "indent": 6,
      "text": "* Signer input parameters. This lists the signing key share for each of the NUM_PARTICIPANTS participants.",
      "ja": "* 署名者の入力パラメーター。これには、各num_particationの参加者の各署名キー共有がリストされています。"
    },
    {
      "indent": 6,
      "text": "* Round one parameters and outputs. This lists the NUM_PARTICIPANTS participants engaged in the protocol, identified by their NonZeroScalar identifier, and the following for each participant: the hiding and binding commitment values produced in Section 5.1; the randomness values used to derive the commitment nonces in nonce_generate; the resulting group binding factor input computed in part from the group commitment list encoded as described in Section 4.3; and the group binding factor as computed in Section 5.2.",
      "ja": "* ラウンド1つのパラメーターと出力。これには、非ゼロスカラー識別子によって識別されるプロトコルに従事するNUM_PARTICTICANTSの参加者がリストされ、各参加者について以下が記載されています。NonCE_GenerateのコミットメントNoncesを導出するために使用されるランダム性値。結果のグループバインディング因子入力は、セクション4.3で説明されているようにエンコードされたグループコミットメントリストから一部計算されました。セクション5.2で計算されたグループ結合因子。"
    },
    {
      "indent": 6,
      "text": "* Round two parameters and outputs. This lists the NUM_PARTICIPANTS participants engaged in the protocol, identified by their NonZeroScalar identifier, along with their corresponding output signature share as produced in Section 5.2.",
      "ja": "* ラウンド2パラメーターと出力。これには、セクション5.2で生成された対応する出力署名共有とともに、非ゼロスカラー識別子によって識別されるプロトコルに従事するNUM_PARTICTICANTSの参加者がリストされています。"
    },
    {
      "indent": 6,
      "text": "* Final output. This lists the aggregate signature as produced in Section 5.3.",
      "ja": "* 最終出力。これには、セクション5.3で作成された集約署名がリストされています。"
    },
    {
      "indent": 0,
      "text": "E.1. FROST(Ed25519, SHA-512)",
      "section_title": true,
      "ja": "E.1. 霜（ED25519、SHA-512）"
    },
    {
      "indent": 3,
      "text": "// Configuration information\nMAX_PARTICIPANTS: 3\nMIN_PARTICIPANTS: 2\nNUM_PARTICIPANTS: 2\n\n// Group input parameters\nparticipant_list: 1,3\ngroup_secret_key: 7b1c33d3f5291d85de664833beb1ad469f7fb6025a0ec78b3a7\n90c6e13a98304\ngroup_public_key: 15d21ccd7ee42959562fc8aa63224c8851fb3ec85a3faf66040\nd380fb9738673\nmessage: 74657374\nshare_polynomial_coefficients[1]: 178199860edd8c62f5212ee91eff1295d0d\n670ab4ed4506866bae57e7030b204\n\n// Signer input parameters\nP1 participant_share: 929dcc590407aae7d388761cddb0c0db6f5627aea8e217f\n4a033f2ec83d93509\nP2 participant_share: a91e66e012e4364ac9aaa405fcafd370402d9859f7b6685\nc07eed76bf409e80d\nP3 participant_share: d3cb090a075eb154e82fdb4b3cb507f110040905468bb9c\n46da8bdea643a9a02\n\n// Signer round one outputs\nP1 hiding_nonce_randomness: 0fd2e39e111cdc266f6c0f4d0fd45c947761f1f5d\n3cb583dfcb9bbaf8d4c9fec\nP1 binding_nonce_randomness: 69cd85f631d5f7f2721ed5e40519b1366f340a87\nc2f6856363dbdcda348a7501\nP1 hiding_nonce: 812d6104142944d5a55924de6d49940956206909f2acaeedecda\n2b726e630407\nP1 binding_nonce: b1110165fc2334149750b28dd813a39244f315cff14d4e89e61\n42f262ed83301\nP1 hiding_nonce_commitment: b5aa8ab305882a6fc69cbee9327e5a45e54c08af6\n1ae77cb8207be3d2ce13de3\nP1 binding_nonce_commitment: 67e98ab55aa310c3120418e5050c9cf76cf387cb\n20ac9e4b6fdb6f82a469f932\nP1 binding_factor_input: 15d21ccd7ee42959562fc8aa63224c8851fb3ec85a3f\naf66040d380fb9738673504df914fa965023fb75c25ded4bb260f417de6d32e5c442c\n6ba313791cc9a4948d6273e8d3511f93348ea7a708a9b862bc73ba2a79cfdfe07729a\n193751cbc973af46d8ac3440e518d4ce440a0e7d4ad5f62ca8940f32de6d8dc00fc12\nc660b817d587d82f856d277ce6473cae6d2f5763f7da2e8b4d799a3f3e725d4522ec7\n0100000000000000000000000000000000000000000000000000000000000000\nP1 binding_factor: f2cb9d7dd9beff688da6fcc83fa89046b3479417f47f55600b\n106760eb3b5603\nP3 hiding_nonce_randomness: 86d64a260059e495d0fb4fcc17ea3da7452391baa\n494d4b00321098ed2a0062f\nP3 binding_nonce_randomness: 13e6b25afb2eba51716a9a7d44130c0dbae0004a\n9ef8d7b5550c8a0e07c61775\nP3 hiding_nonce: c256de65476204095ebdc01bd11dc10e57b36bc96284595b8215\n222374f99c0e\nP3 binding_nonce: 243d71944d929063bc51205714ae3c2218bd3451d0214dfb5ae\nec2a90c35180d\nP3 hiding_nonce_commitment: cfbdb165bd8aad6eb79deb8d287bcc0ab6658ae57\nfdcc98ed12c0669e90aec91\nP3 binding_nonce_commitment: 7487bc41a6e712eea2f2af24681b58b1cf1da278\nea11fe4e8b78398965f13552\nP3 binding_factor_input: 15d21ccd7ee42959562fc8aa63224c8851fb3ec85a3f\naf66040d380fb9738673504df914fa965023fb75c25ded4bb260f417de6d32e5c442c\n6ba313791cc9a4948d6273e8d3511f93348ea7a708a9b862bc73ba2a79cfdfe07729a\n193751cbc973af46d8ac3440e518d4ce440a0e7d4ad5f62ca8940f32de6d8dc00fc12\nc660b817d587d82f856d277ce6473cae6d2f5763f7da2e8b4d799a3f3e725d4522ec7\n0300000000000000000000000000000000000000000000000000000000000000\nP3 binding_factor: b087686bf35a13f3dc78e780a34b0fe8a77fef1b9938c563f5\n573d71d8d7890f\n\n// Signer round two outputs\nP1 sig_share: 001719ab5a53ee1a12095cd088fd149702c0720ce5fd2f29dbecf24\nb7281b603\nP3 sig_share: bd86125de990acc5e1f13781d8e32c03a9bbd4c53539bbc106058bf\nd14326007\n\nsig: 36282629c383bb820a88b71cae937d41f2f2adfcc3d02e55507e2fb9e2dd3cbe\nbd9d2b0844e49ae0f3fa935161e1419aab7b47d21a37ebeae1f17d4987b3160b",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "E.2. FROST(Ed448, SHAKE256)",
      "section_title": true,
      "ja": "E.2. フロスト（ED448、Shake256）"
    },
    {
      "indent": 3,
      "text": "// Configuration information\nMAX_PARTICIPANTS: 3\nMIN_PARTICIPANTS: 2\nNUM_PARTICIPANTS: 2\n\n// Group input parameters\nparticipant_list: 1,3\ngroup_secret_key: 6298e1eef3c379392caaed061ed8a31033c9e9e3420726f23b4\n04158a401cd9df24632adfe6b418dc942d8a091817dd8bd70e1c72ba52f3c00\ngroup_public_key: 3832f82fda00ff5365b0376df705675b63d2a93c24c6e81d408\n01ba265632be10f443f95968fadb70d10786827f30dc001c8d0f9b7c1d1b000\nmessage: 74657374\nshare_polynomial_coefficients[1]: dbd7a514f7a731976620f0436bd135fe8dd\ndc3fadd6e0d13dbd58a1981e587d377d48e0b7ce4e0092967c5e85884d0275a7a740b\n6abdcd0500\n\n// Signer input parameters\nP1 participant_share: 4a2b2f5858a932ad3d3b18bd16e76ced3070d72fd79ae44\n02df201f525e754716a1bc1b87a502297f2a99d89ea054e0018eb55d39562fd0100\nP2 participant_share: 2503d56c4f516444a45b080182b8a2ebbe4d9b2ab509f25\n308c88c0ea7ccdc44e2ef4fc4f63403a11b116372438a1e287265cadeff1fcb0700\nP3 participant_share: 00db7a8146f995db0a7cf844ed89d8e94c2b5f259378ff6\n6e39d172828b264185ac4decf7219e4aa4478285b9c0eef4fccdf3eea69dd980d00\n\n// Signer round one outputs\nP1 hiding_nonce_randomness: 9cda90c98863ef3141b75f09375757286b4bc323d\nd61aeb45c07de45e4937bbd\nP1 binding_nonce_randomness: 781bf4881ffe1aa06f9341a747179f07a49745f8\ncd37d4696f226aa065683c0a\nP1 hiding_nonce: f922beb51a5ac88d1e862278d89e12c05263b945147db04b9566\nacb2b5b0f7422ccea4f9286f4f80e6b646e72143eeaecc0e5988f8b2b93100\nP1 binding_nonce: 1890f16a120cdeac092df29955a29c7cf29c13f6f7be60e63d6\n3f3824f2d37e9c3a002dfefc232972dc08658a8c37c3ec06a0c5dc146150500\nP1 hiding_nonce_commitment: 3518c2246c874569e54ab254cb1da666ca30f7879\n605cc43b4d2c47a521f8b5716080ab723d3a0cd04b7e41f3cc1d3031c94ccf3829b23\nfe80\nP1 binding_nonce_commitment: 11b3d5220c57d02057497de3c4eebab384900206\n592d877059b0a5f1d5250d002682f0e22dff096c46bb81b46d60fcfe7752ed47cea76\nc3900\nP1 binding_factor_input: 3832f82fda00ff5365b0376df705675b63d2a93c24c6\ne81d40801ba265632be10f443f95968fadb70d10786827f30dc001c8d0f9b7c1d1b00\n0e9a0f30b97fe77ef751b08d4e252a3719ae9135e7f7926f7e3b7dd6656b27089ca35\n4997fe5a633aa0946c89f022462e7e9d50fd6ef313f72d956ea4571089427daa1862f\n623a41625177d91e4a8f350ce9c8bd3bc7c766515dc1dd3a0eab93777526b616cccb1\n48fe1e5992dc1ae705c8ba2f97ca8983328d41d375ed1e5fde5c9d672121c9e8f177f\n4a1a9b2575961531b33f054451363c8f27618382cd66ce14ad93b68dac6a09f5edcbc\ncc813906b3fc50b8fef1cc09757b06646f38ceed1674cd6ced28a59c93851b325c6a9\nef6a4b3b88860b7138ee246034561c7460db0b3fae501000000000000000000000000\n000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000\nP1 binding_factor: 71966390dfdbed73cf9b79486f3b70e23b243e6c40638fb559\n98642a60109daecbfcb879eed9fe7dbbed8d9e47317715a5740f772173342e00\nP3 hiding_nonce_randomness: b3adf97ceea770e703ab295babf311d77e956a20d\n3452b4b3344aa89a828e6df\nP3 binding_nonce_randomness: 81dbe7742b0920930299197322b255734e52bbb9\n1f50cfe8ce689f56fadbce31\nP3 hiding_nonce: ccb5c1e82f23e0a4b966b824dbc7b0ef1cc5f56eeac2a4126e2b\n2143c5f3a4d890c52d27803abcf94927faf3fc405c0b2123a57a93cefa3b00\nP3 binding_nonce: e089df9bf311cf711e2a24ea27af53e07b846d09692fe11035a\n1112f04d8b7462a62f34d8c01493a22b57a1cbf1f0a46c77d64d46449a90100\nP3 hiding_nonce_commitment: 1254546d7d104c04e4fbcf29e05747e2edd392f67\n87d05a6216f3713ef859efe573d180d291e48411e5e3006e9f90ee986ccc26b7a4249\n0b80\nP3 binding_nonce_commitment: 3ef0cec20be15e56b3ddcb6f7b956fca0c8f7199\n0f45316b537b4f64c5e8763e6629d7262ff7cd0235d0781f23be97bf8fa8817643ea1\n9cd00\nP3 binding_factor_input: 3832f82fda00ff5365b0376df705675b63d2a93c24c6\ne81d40801ba265632be10f443f95968fadb70d10786827f30dc001c8d0f9b7c1d1b00\n0e9a0f30b97fe77ef751b08d4e252a3719ae9135e7f7926f7e3b7dd6656b27089ca35\n4997fe5a633aa0946c89f022462e7e9d50fd6ef313f72d956ea4571089427daa1862f\n623a41625177d91e4a8f350ce9c8bd3bc7c766515dc1dd3a0eab93777526b616cccb1\n48fe1e5992dc1ae705c8ba2f97ca8983328d41d375ed1e5fde5c9d672121c9e8f177f\n4a1a9b2575961531b33f054451363c8f27618382cd66ce14ad93b68dac6a09f5edcbc\ncc813906b3fc50b8fef1cc09757b06646f38ceed1674cd6ced28a59c93851b325c6a9\nef6a4b3b88860b7138ee246034561c7460db0b3fae503000000000000000000000000\n000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000\nP3 binding_factor: 236a6f7239ac2019334bad21323ec93bef2fead37bd5511435\n6419f3fc1fb59f797f44079f28b1a64f51dd0a113f90f2c3a1c27d2faa4f1300\n\n// Signer round two outputs\nP1 sig_share: e1eb9bfbef792776b7103891032788406c070c5c315e3bf5d64acd4\n6ea8855e85b53146150a09149665cbfec71626810b575e6f4dbe9ba3700\nP3 sig_share: 815434eb0b9f9242d54b8baf2141fe28976cabe5f441ccfcd5ee7cd\nb4b52185b02b99e6de28e2ab086c7764068c5a01b5300986b9f084f3e00\n\nsig: cd642cba59c449dad8e896a78a60e8edfcbd9040df524370891ff8077d47ce72\n1d683874483795f0d85efcbd642c4510614328605a19c6ed806ffb773b6956419537c\ndfdb2b2a51948733de192dcc4b82dc31580a536db6d435e0cb3ce322fbcf9ec23362d\nda27092c08767e607bf2093600",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "E.3. FROST(ristretto255, SHA-512)",
      "section_title": true,
      "ja": "E.3. 霜（Ristretto255、Sha-512）"
    },
    {
      "indent": 3,
      "text": "// Configuration information\nMAX_PARTICIPANTS: 3\nMIN_PARTICIPANTS: 2\nNUM_PARTICIPANTS: 2\n\n// Group input parameters\nparticipant_list: 1,3\ngroup_secret_key: 1b25a55e463cfd15cf14a5d3acc3d15053f08da49c8afcf3ab2\n65f2ebc4f970b\ngroup_public_key: e2a62f39eede11269e3bd5a7d97554f5ca384f9f6d3dd9c3c0d\n05083c7254f57\nmessage: 74657374\nshare_polynomial_coefficients[1]: 410f8b744b19325891d73736923525a4f59\n6c805d060dfb9c98009d34e3fec02\n\n// Signer input parameters\nP1 participant_share: 5c3430d391552f6e60ecdc093ff9f6f4488756aa6cebdba\nd75a768010b8f830e\nP2 participant_share: b06fc5eac20b4f6e1b271d9df2343d843e1e1fb03c4cbb6\n73f2872d459ce6f01\nP3 participant_share: f17e505f0e2581c6acfe54d3846a622834b5e7b50cad9a2\n109a97ba7a80d5c04\n\n// Signer round one outputs\nP1 hiding_nonce_randomness: f595a133b4d95c6e1f79887220c8b275ce6277e7f\n68a6640e1e7140f9be2fb5c\nP1 binding_nonce_randomness: 34dd1001360e3513cb37bebfabe7be4a32c5bb91\nba19fbd4360d039111f0fbdc\nP1 hiding_nonce: 214f2cabb86ed71427ea7ad4283b0fae26b6746c801ce824b83c\neb2b99278c03\nP1 binding_nonce: c9b8f5e16770d15603f744f8694c44e335e8faef00dad182b8d\n7a34a62552f0c\nP1 hiding_nonce_commitment: 965def4d0958398391fc06d8c2d72932608b1e625\n5226de4fb8d972dac15fd57\nP1 binding_nonce_commitment: ec5170920660820007ae9e1d363936659ef622f9\n9879898db86e5bf1d5bf2a14\nP1 binding_factor_input: e2a62f39eede11269e3bd5a7d97554f5ca384f9f6d3d\nd9c3c0d05083c7254f572889dde2854e26377a16caf77dfee5f6be8fe5b4c80318da8\n4698a4161021b033911db5ef8205362701bc9ecd983027814abee94f46d094943a2f4\nb79a6e4d4603e52c435d8344554942a0a472d8ad84320585b8da3ae5b9ce31cd1903f\n795c1af66de22af1a45f652cd05ee446b1b4091aaccc91e2471cd18a85a659cecd11f\n0100000000000000000000000000000000000000000000000000000000000000\nP1 binding_factor: 8967fd70fa06a58e5912603317fa94c77626395a695a0e4e4e\nfc4476662eba0c\nP3 hiding_nonce_randomness: daa0cf42a32617786d390e0c7edfbf2efbd428037\n069357b5173ae61d6dd5d5e\nP3 binding_nonce_randomness: b4387e72b2e4108ce4168931cc2c7fcce5f345a5\n297368952c18b5fc8473f050\nP3 hiding_nonce: 3f7927872b0f9051dd98dd73eb2b91494173bbe0feb65a3e7e58\nd3e2318fa40f\nP3 binding_nonce: ffd79445fb8030f0a3ddd3861aa4b42b618759282bfe24f1f93\n04c7009728305\nP3 hiding_nonce_commitment: 480e06e3de182bf83489c45d7441879932fd7b434\na26af41455756264fbd5d6e\nP3 binding_nonce_commitment: 3064746dfd3c1862ef58fc68c706da287dd92506\n6865ceacc816b3a28c7b363b\nP3 binding_factor_input: e2a62f39eede11269e3bd5a7d97554f5ca384f9f6d3d\nd9c3c0d05083c7254f572889dde2854e26377a16caf77dfee5f6be8fe5b4c80318da8\n4698a4161021b033911db5ef8205362701bc9ecd983027814abee94f46d094943a2f4\nb79a6e4d4603e52c435d8344554942a0a472d8ad84320585b8da3ae5b9ce31cd1903f\n795c1af66de22af1a45f652cd05ee446b1b4091aaccc91e2471cd18a85a659cecd11f\n0300000000000000000000000000000000000000000000000000000000000000\nP3 binding_factor: f2c1bb7c33a10511158c2f1766a4a5fadf9f86f2a92692ed33\n3128277cc31006\n\n// Signer round two outputs\nP1 sig_share: 9285f875923ce7e0c491a592e9ea1865ec1b823ead4854b48c8a462\n87749ee09\nP3 sig_share: 7cb211fe0e3d59d25db6e36b3fb32344794139602a7b24f1ae0dc4e\n26ad7b908\n\nsig: fc45655fbc66bbffad654ea4ce5fdae253a49a64ace25d9adb62010dd9fb2555\n2164141787162e5b4cab915b4aa45d94655dbb9ed7c378a53b980a0be220a802",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "E.4. FROST(P-256, SHA-256)",
      "section_title": true,
      "ja": "E.4. 霜（P-256、SHA-256）"
    },
    {
      "indent": 3,
      "text": "// Configuration information\nMAX_PARTICIPANTS: 3\nMIN_PARTICIPANTS: 2\nNUM_PARTICIPANTS: 2\n\n// Group input parameters\nparticipant_list: 1,3\ngroup_secret_key: 8ba9bba2e0fd8c4767154d35a0b7562244a4aaf6f36c8fb8735\nfa48b301bd8de\ngroup_public_key: 023a309ad94e9fe8a7ba45dfc58f38bf091959d3c99cfbd02b4\ndc00585ec45ab70\nmessage: 74657374\nshare_polynomial_coefficients[1]: 80f25e6c0709353e46bfbe882a11bdbb1f8\n097e46340eb8673b7e14556e6c3a4\n\n// Signer input parameters\nP1 participant_share: 0c9c1a0fe806c184add50bbdcac913dda73e482daf95dcb\n9f35dbb0d8a9f7731\nP2 participant_share: 8d8e787bef0ff6c2f494ca45f4dad198c6bee01212d6c84\n067159c52e1863ad5\nP3 participant_share: 0e80d6e8f6192c003b5488ce1eec8f5429587d48cf00154\n1e713b2d53c09d928\n\n// Signer round one outputs\nP1 hiding_nonce_randomness: ec4c891c85fee802a9d757a67d1252e7f4e5efb8a\n538991ac18fbd0e06fb6fd3\nP1 binding_nonce_randomness: 9334e29d09061223f69a09421715a347e4e6deba\n77444c8f42b0c833f80f4ef9\nP1 hiding_nonce: 9f0542a5ba879a58f255c09f06da7102ef6a2dec6279700c656d\n58394d8facd4\nP1 binding_nonce: 6513dfe7429aa2fc972c69bb495b27118c45bbc6e654bb9dc9b\ne55385b55c0d7\nP1 hiding_nonce_commitment: 0213b3e6298bf8ad46fd5e9389519a8665d63d98f\n4ec6a1fcca434e809d2d8070e\nP1 binding_nonce_commitment: 02188ff1390bf69374d7b272e454b1878ef10a6b\n6ea3ff36f114b300b4dbd5233b\nP1 binding_factor_input: 023a309ad94e9fe8a7ba45dfc58f38bf091959d3c99c\nfbd02b4dc00585ec45ab70825371853e974bc30ac5b947b216d70461919666584c70c\n51f9f56f117736c5d178dd0b521ad9c1abe98048419cbdec81504c85e12eb40e3bcb6\nec73d3fc4afd000000000000000000000000000000000000000000000000000000000\n0000001\nP1 binding_factor: 7925f0d4693f204e6e59233e92227c7124664a99739d2c06b8\n1cf64ddf90559e\nP3 hiding_nonce_randomness: c0451c5a0a5480d6c1f860e5db7d655233dca2669\nfd90ff048454b8ce983367b\nP3 binding_nonce_randomness: 2ba5f7793ae700e40e78937a82f407dd35e847e3\n3d1e607b5c7eb6ed2a8ed799\nP3 hiding_nonce: f73444a8972bcda9e506bbca3d2b1c083c10facdf4bb5d47fef7\nc2dc1d9f2a0d\nP3 binding_nonce: 44c6a29075d6e7e4f8b97796205f9e22062e7835141470afe94\n17fd317c1c303\nP3 hiding_nonce_commitment: 033ac9a5fe4a8b57316ba1c34e8a6de453033b750\ne8984924a984eb67a11e73a3f\nP3 binding_nonce_commitment: 03a7a2480ee16199262e648aea3acab628a53e9b\n8c1945078f2ddfbdc98b7df369\nP3 binding_factor_input: 023a309ad94e9fe8a7ba45dfc58f38bf091959d3c99c\nfbd02b4dc00585ec45ab70825371853e974bc30ac5b947b216d70461919666584c70c\n51f9f56f117736c5d178dd0b521ad9c1abe98048419cbdec81504c85e12eb40e3bcb6\nec73d3fc4afd000000000000000000000000000000000000000000000000000000000\n0000003\nP3 binding_factor: e10d24a8a403723bcb6f9bb4c537f316593683b472f7a89f16\n6630dde11822c4\n\n// Signer round two outputs\nP1 sig_share: 400308eaed7a2ddee02a265abe6a1cfe04d946ee8720768899619cf\nabe7a3aeb\nP3 sig_share: 561da3c179edbb0502d941bb3e3ace3c37d122aaa46fb54499f15f3\na3331de44\n\nsig: 026d8d434874f87bdb7bc0dfd239b2c00639044f9dcb195e9a04426f70bfa4b7\n0d9620acac6767e8e3e3036815fca4eb3a3caa69992b902bcd3352fc34f1ac192f",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "E.5. FROST(secp256k1, SHA-256)",
      "section_title": true,
      "ja": "E.5. 霜（SECP256K1、SHA-256）"
    },
    {
      "indent": 3,
      "text": "// Configuration information\nMAX_PARTICIPANTS: 3\nMIN_PARTICIPANTS: 2\nNUM_PARTICIPANTS: 2\n\n// Group input parameters\nparticipant_list: 1,3\ngroup_secret_key: 0d004150d27c3bf2a42f312683d35fac7394b1e9e318249c1bf\ne7f0795a83114\ngroup_public_key: 02f37c34b66ced1fb51c34a90bdae006901f10625cc06c4f646\n63b0eae87d87b4f\nmessage: 74657374\nshare_polynomial_coefficients[1]: fbf85eadae3058ea14f19148bb72b45e439\n9c0b16028acaf0395c9b03c823579\n\n// Signer input parameters\nP1 participant_share: 08f89ffe80ac94dcb920c26f3f46140bfc7f95b493f8310\nf5fc1ea2b01f4254c\nP2 participant_share: 04f0feac2edcedc6ce1253b7fab8c86b856a797f44d83d8\n2a385554e6e401984\nP3 participant_share: 00e95d59dd0d46b0e303e500b62b7ccb0e555d49f5b849f\n5e748c071da8c0dbc\n\n// Signer round one outputs\nP1 hiding_nonce_randomness: 7ea5ed09af19f6ff21040c07ec2d2adbd35b759da\n5a401d4c99dd26b82391cb2\nP1 binding_nonce_randomness: 47acab018f116020c10cb9b9abdc7ac10aae1b48\nca6e36dc15acb6ec9be5cdc5\nP1 hiding_nonce: 841d3a6450d7580b4da83c8e618414d0f024391f2aeb511d7579\n224420aa81f0\nP1 binding_nonce: 8d2624f532af631377f33cf44b5ac5f849067cae2eacb88680a\n31e77c79b5a80\nP1 hiding_nonce_commitment: 03c699af97d26bb4d3f05232ec5e1938c12f1e6ae\n97643c8f8f11c9820303f1904\nP1 binding_nonce_commitment: 02fa2aaccd51b948c9dc1a325d77226e98a5a3fe\n65fe9ba213761a60123040a45e\nP1 binding_factor_input: 02f37c34b66ced1fb51c34a90bdae006901f10625cc0\n6c4f64663b0eae87d87b4fff9b5210ffbb3c07a73a7c8935be4a8c62cf015f6cf7ade\n6efac09a6513540fc3f5a816aaebc2114a811a415d7a55db7c5cbc1cf27183e79dd9d\nef941b5d4801000000000000000000000000000000000000000000000000000000000\n0000001\nP1 binding_factor: 3e08fe561e075c653cbfd46908a10e7637c70c74f0a77d5fd4\n5d1a750c739ec6\nP3 hiding_nonce_randomness: e6cc56ccbd0502b3f6f831d91e2ebd01c4de0479e\n0191b66895a4ffd9b68d544\nP3 binding_nonce_randomness: 7203d55eb82a5ca0d7d83674541ab55f6e76f1b8\n5391d2c13706a89a064fd5b9\nP3 hiding_nonce: 2b19b13f193f4ce83a399362a90cdc1e0ddcd83e57089a7af0bd\nca71d47869b2\nP3 binding_nonce: 7a443bde83dc63ef52dda354005225ba0e553243402a4705ce2\n8ffaafe0f5b98\nP3 hiding_nonce_commitment: 03077507ba327fc074d2793955ef3410ee3f03b82\nb4cdc2370f71d865beb926ef6\nP3 binding_nonce_commitment: 02ad53031ddfbbacfc5fbda3d3b0c2445c8e3e99\ncbc4ca2db2aa283fa68525b135\nP3 binding_factor_input: 02f37c34b66ced1fb51c34a90bdae006901f10625cc0\n6c4f64663b0eae87d87b4fff9b5210ffbb3c07a73a7c8935be4a8c62cf015f6cf7ade\n6efac09a6513540fc3f5a816aaebc2114a811a415d7a55db7c5cbc1cf27183e79dd9d\nef941b5d4801000000000000000000000000000000000000000000000000000000000\n0000003\nP3 binding_factor: 93f79041bb3fd266105be251adaeb5fd7f8b104fb554a4ba9a\n0becea48ddbfd7\n\n// Signer round two outputs\nP1 sig_share: c4fce1775a1e141fb579944166eab0d65eefe7b98d480a569bbbfcb\n14f91c197\nP3 sig_share: 0160fd0d388932f4826d2ebcd6b9eaba734f7c71cf25b4279a4ca25\n81e47b18d\n\nsig: 0205b6d04d3774c8929413e3c76024d54149c372d57aae62574ed74319b5ea14\nd0c65dde8492a7471437e6c2fe3da49b90d23f642b5c6dbe7e36089f096dd97324",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "section_title": true,
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This document was improved based on input and contributions by the Zcash Foundation engineering team. In addition, the authors of this document would like to thank Isis Lovecruft, Alden Torres, T. Wilson-Brown, and Conrado Gouvea for their input and contributions.",
      "ja": "このドキュメントは、ZCASH Foundation Engineeringチームの入力と貢献に基づいて改善されました。さらに、この文書の著者は、ISIS Lovecruft、Alden Torres、T。Wilson-Brown、およびConrado Gouveaの意見と貢献に感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Deirdre Connolly\nZcash Foundation\nEmail: durumcrustulum@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chelsea Komlo\nUniversity of Waterloo, Zcash Foundation\nEmail: ckomlo@uwaterloo.ca",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Ian Goldberg\nUniversity of Waterloo\nEmail: iang@uwaterloo.ca",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Christopher A. Wood\nCloudflare\nEmail: caw@heapingbits.net",
      "raw": true,
      "ja": ""
    }
  ]
}