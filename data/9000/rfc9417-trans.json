{
  "title": {
    "text": "RFC 9417 - Service Assurance for Intent-Based Networking Architecture",
    "ja": "RFC 9417 - 意図ベースのネットワーキングアーキテクチャのサービス保証"
  },
  "number": 9417,
  "created_at": "2024-03-08 11:51:55.570915+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         B. Claise\nRequest for Comments: 9417                                   J. Quilbeuf\nCategory: Informational                                           Huawei\nISSN: 2070-1721                                                 D. Lopez\n                                                          Telefonica I+D\n                                                                D. Voyer\n                                                             Bell Canada\n                                                             T. Arumugam\n                                                              Consultant\n                                                               July 2023",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Service Assurance for Intent-Based Networking Architecture",
      "title": true,
      "section_title": true,
      "ja": "意図ベースのネットワーキングアーキテクチャのサービス保証"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes an architecture that provides some assurance that service instances are running as expected. As services rely upon multiple subservices provided by a variety of elements, including the underlying network devices and functions, getting the assurance of a healthy service is only possible with a holistic view of all involved elements. This architecture not only helps to correlate the service degradation with symptoms of a specific network component but, it also lists the services impacted by the failure or degradation of a specific network component.",
      "ja": "このドキュメントでは、サービスインスタンスが予想どおりに実行されているという保証を提供するアーキテクチャについて説明します。サービスは、基礎となるネットワークデバイスや機能を含むさまざまな要素によって提供される複数のサブサービスに依存しているため、健康なサービスの保証を取得することは、関係するすべての要素の全体的な見方でのみ可能です。このアーキテクチャは、サービスの劣化を特定のネットワークコンポーネントの症状と相関させるのに役立つだけでなく、特定のネットワークコンポーネントの故障または劣化によって影響を受けるサービスもリストします。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントは、インターネット標準の追跡仕様ではありません。情報目的で公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。IESGによって承認されたすべてのドキュメントが、インターネット標準のあらゆるレベルの候補者であるわけではありません。RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9417.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https：//www.rfc-editor.org/info/rfc9417で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2023 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2023 IETF Trustおよび文書著者として特定された人。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、改訂されたBSDライセンスで説明されている保証なしで提供されるように、改訂されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n2.  Terminology\n3.  A Functional Architecture\n  3.1.  Translating a Service Instance Configuration into an\n        Assurance Graph\n    3.1.1.  Circular Dependencies\n  3.2.  Intent and Assurance Graph\n  3.3.  Subservices\n  3.4.  Building the Expression Graph from the Assurance Graph\n  3.5.  Open Interfaces with YANG Modules\n  3.6.  Handling Maintenance Windows\n  3.7.  Flexible Functional Architecture\n  3.8.  Time Window for Symptoms' History\n  3.9.  New Assurance Graph Generation\n4.  IANA Considerations\n5.  Security Considerations\n6.  References\n  6.1.  Normative References\n  6.2.  Informative References\nAcknowledgements\nContributors\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Network Service YANG Modules [RFC8199] describe the configuration, state data, operations, and notifications of abstract representations of services implemented on one or multiple network elements.",
      "ja": "ネットワークサービスYangモジュール[RFC8199]は、1つまたは複数のネットワーク要素に実装されたサービスの抽象表現の構成、状態データ、操作、および通知を説明します。"
    },
    {
      "indent": 3,
      "text": "Service orchestrators use Network Service YANG Modules that will infer network-wide configuration and, therefore, the invocation of the appropriate device modules (Section 3 of [RFC8969]). Knowing that a configuration is applied doesn't imply that the provisioned service instance is up and running as expected. For instance, the service might be degraded because of a failure in the network, the service quality may be degraded, or a service function may be reachable at the IP level but does not provide its intended function. Thus, the network operator must monitor the service's operational data at the same time as the configuration (Section 3.3 of [RFC8969]). To fuel that task, the industry has been standardizing on telemetry to push network element performance information (e.g., [RFC9375]).",
      "ja": "サービスオーケストレーターは、ネットワーク全体の構成を推測するネットワークサービスYangモジュールを使用し、したがって、適切なデバイスモジュールの呼び出し（[RFC8969]のセクション3）を使用します。構成が適用されていることを知ることは、プロビジョニングされたサービスインスタンスが予想どおりに稼働していることを意味するわけではありません。たとえば、ネットワークの障害、サービスの品質が低下したり、IPレベルでサービス機能に到達できる場合もありますが、意図した機能を提供しないため、サービスは低下する可能性があります。したがって、ネットワークオペレーターは、構成と同時にサービスの運用データを監視する必要があります（[RFC8969]のセクション3.3）。そのタスクを促進するために、業界はネットワーク要素のパフォーマンス情報をプッシュするためにテレメトリを標準化しています（例：[RFC9375]）。"
    },
    {
      "indent": 3,
      "text": "A network administrator needs to monitor its network and services as a whole, independently of the management protocols. With different protocols come different data models and different ways to model the same type of information. When network administrators deal with multiple management protocols, the network management entities have to perform the difficult and time-consuming job of mapping data models, e.g., the model used for configuration with the model used for monitoring when separate models or protocols are used. This problem is compounded by a large, disparate set of data sources (e.g., MIB modules, YANG data models [RFC7950], IP Flow Information Export (IPFIX) information elements [RFC7011], syslog plain text [RFC5424], Terminal Access Controller Access-Control System Plus (TACACS+) [RFC8907], RADIUS [RFC2865], etc.). In order to avoid this data model mapping, the industry converged on model-driven telemetry to stream the service operational data, reusing the YANG data models used for configuration. Model-driven telemetry greatly facilitates the notion of closed-loop automation, whereby events and updated operational states streamed from the network drive remediation change back into the network.",
      "ja": "ネットワーク管理者は、管理プロトコルとは無関係に、ネットワークとサービス全体を監視する必要があります。異なるプロトコルでは、異なるデータモデルと同じタイプの情報をモデル化するさまざまな方法があります。ネットワーク管理者が複数の管理プロトコルを扱う場合、ネットワーク管理エンティティは、データモデルをマッピングする困難で時間のかかるジョブを実行する必要があります。この問題は、データソースの大規模で異なるセット（MIBモジュール、Yangデータモデル[RFC7950]、IPフロー情報エクスポート（IPFIX）情報要素[RFC7011]、Syslog Plain Text [RFC5424]、端子アクセスコントロール者アクセスによってさらに悪化します。-Control System Plus（TACACS）[RFC8907]、半径[RFC2865]など）。このデータモデルマッピングを回避するために、業界はモデル駆動型のテレメトリに収束してサービス運用データをストリーミングし、構成に使用されるYangデータモデルを再利用しました。モデル駆動型のテレメトリは、閉ループの自動化の概念を大幅に促進します。これにより、ネットワークドライブの修復変更からストリーミングされたイベントや更新された運用状態がネットワークに戻ります。"
    },
    {
      "indent": 3,
      "text": "However, it proves difficult for network operators to correlate the service degradation with the network root cause, for example, \"Why does my layer 3 virtual private network (L3VPN) fail to connect?\" or \"Why is this specific service not highly responsive?\" The reverse, i.e., which services are impacted when a network component fails or degrades, is also important for operators, for example, \"Which services are impacted when this specific optic decibel milliwatt (dBm) begins to degrade?\", \"Which applications are impacted by an imbalance in this Equal-Cost Multipath (ECMP) bundle?\", or \"Is that issue actually impacting any other customers?\" This task usually falls under the so-called \"Service Impact Analysis\" functional block.",
      "ja": "ただし、ネットワークオペレーターがサービスの劣化をネットワークの根本原因と相関させることは困難であることがわかります。たとえば、「なぜ私のレイヤー3仮想プライベートネットワーク（L3VPN）が接続できないのですか？」または「なぜこの特定のサービスがあまり反応しないのですか？」逆、つまり、ネットワークコンポーネントが故障または劣化したときにどのサービスが影響を受けるかは、たとえば、「この特定の光学デシベルmilliwatt（dbm）が劣化し始めたときにどのようなサービスが影響を受けますか？」、「どのサービスが影響を受けますか？」この等しいコストのマルチパス（ECMP）バンドルの不均衡の影響を受けますか？」または「その問題は実際に他の顧客に影響を与えますか？」このタスクは通常、いわゆる「サービスインパクト分析」機能ブロックに該当します。"
    },
    {
      "indent": 3,
      "text": "This document defines an architecture implementing Service Assurance for Intent-based Networking (SAIN). Intent-based approaches are often declarative, starting from a statement of \"The service works as expected\" and trying to enforce it. However, some already-defined services might have been designed using a different approach. Aligned with Section 3.3 of [RFC7149], and instead of requiring a declarative intent as a starting point, this architecture focuses on already-defined services and tries to infer the meaning of \"The service works as expected\". To do so, the architecture works from an assurance graph, deduced from the configuration pushed to the device for enabling the service instance. If the SAIN orchestrator supports it, the service model (Section 2 of [RFC8309]) or the network model (Section 2.1 of [RFC8969]) can also be used to build the assurance graph. In that case and if the service model includes the declarative intent as well, the SAIN orchestrator can rely on the declared intent instead of inferring it. The assurance graph may also be explicitly completed to add an intent not exposed in the service model itself.",
      "ja": "このドキュメントでは、意図ベースのネットワーキング（SAIN）のサービス保証を実装するアーキテクチャを定義しています。意図ベースのアプローチは、「サービスが期待どおりに機能する」という声明から始まり、それを実施しようとすることから、多くの場合宣言的です。ただし、すでに定義されたサービスの一部は、別のアプローチを使用して設計されている可能性があります。[RFC7149]のセクション3.3と整合し、出発点として宣言的な意図を要求する代わりに、このアーキテクチャはすでに定義されたサービスに焦点を当て、「サービスは期待どおりに機能する」という意味を推測しようとします。そのために、アーキテクチャは、サービスインスタンスを有効にするためにデバイスにプッシュされた構成から推定された保証グラフから機能します。Sain Orchestratorがサポートする場合、サービスモデル（[RFC8309]のセクション2）またはネットワークモデル（[RFC8969]のセクション2.1）を使用して保証グラフを構築することもできます。その場合、およびサービスモデルに宣言的な意図も含まれている場合、Sain Orchestratorはそれを推測する代わりに宣言された意図に依存することができます。保証グラフは、サービスモデル自体に公開されていない意図を追加するために明示的に完了することもできます。"
    },
    {
      "indent": 3,
      "text": "The assurance graph of a service instance is decomposed into components, which are then assured independently. The top of the assurance graph represents the service instance to assure, and its children represent components identified as its direct dependencies; each component can have dependencies as well. Components involved in the assurance graph of a service are called subservices. The SAIN orchestrator updates the assurance graph automatically when the service instance is modified.",
      "ja": "サービスインスタンスの保証グラフはコンポーネントに分解され、独立して保証されます。保証グラフの上部は、保証するサービスインスタンスを表し、その子供はその直接的な依存関係として特定されたコンポーネントを表します。各コンポーネントにも依存関係があります。サービスの保証グラフに関与するコンポーネントは、サブサービスと呼ばれます。Sain Orchestratorは、サービスインスタンスが変更されたときに保証グラフを自動的に更新します。"
    },
    {
      "indent": 3,
      "text": "When a service is degraded, the SAIN architecture will highlight where in the assurance service graph to look, as opposed to going hop by hop to troubleshoot the issue. More precisely, the SAIN architecture will associate to each service instance a list of symptoms originating from specific subservices, corresponding to components of the network. These components are good candidates for explaining the source of a service degradation. Not only can this architecture help to correlate service degradation with network root cause/symptoms, but it can deduce from the assurance graph the list of service instances impacted by a component degradation/failure. This added value informs the operational team where to focus its attention for maximum return. Indeed, the operational team is likely to focus their priority on the degrading/failing components impacting the highest number of their customers, especially the ones with the Service-Level Agreement (SLA) contracts involving penalties in case of failure.",
      "ja": "サービスが劣化すると、Sain Architectureは、問題のトラブルシューティングでホップに行くのではなく、保証サービスグラフのどこを見るかを強調します。より正確には、Sainアーキテクチャは、各サービスインスタンスに、ネットワークのコンポーネントに対応する特定のサブサービスに由来する症状のリストを関連付けます。これらのコンポーネントは、サービスの劣化の原因を説明するための優れた候補です。このアーキテクチャは、サービスの劣化をネットワークの根本原因/症状と相関させるのに役立つだけでなく、コンポーネントの劣化/障害の影響を受けたサービスインスタンスのリストを保証グラフから推測することができます。この付加価値は、運用チームに、最大の収益のためにその注意を集中する場所を通知します。実際、運用チームは、顧客の数が最も多く、特に失敗の場合に罰則を伴うサービスレベル契約（SLA）契約を持つ顧客の数に影響を与える劣化/故障コンポーネントに優先順位を集中する可能性があります。"
    },
    {
      "indent": 3,
      "text": "This architecture provides the building blocks to assure both physical and virtual entities and is flexible with respect to services and subservices of (distributed) graphs and components (Section 3.7).",
      "ja": "このアーキテクチャは、物理エンティティと仮想エンティティの両方を保証するためにビルディングブロックを提供し、（分散）グラフとコンポーネントのサービスとサブサービスに関して柔軟です（セクション3.7）。"
    },
    {
      "indent": 3,
      "text": "The architecture presented in this document is implemented by a set of YANG modules defined in a companion document [RFC9418]. These YANG modules properly define the interfaces between the various components of the architecture to foster interoperability.",
      "ja": "このドキュメントに示されているアーキテクチャは、コンパニオンドキュメント[RFC9418]で定義された一連のヤンモジュールによって実装されています。これらのYangモジュールは、相互運用性を促進するために、アーキテクチャのさまざまなコンポーネント間のインターフェイスを適切に定義します。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "SAIN agent:",
      "ja": "セインエージェント："
    },
    {
      "indent": 12,
      "text": "A functional component that communicates with a device, a set of devices, or another agent to build an expression graph from a received assurance graph and perform the corresponding computation of the health status and symptoms. A SAIN agent might be running directly on the device it monitors.",
      "ja": "デバイス、デバイスのセット、または別のエージェントと通信する機能コンポーネントは、受信した保証グラフから式グラフを構築し、健康状態と症状の対応する計算を実行します。Sainエージェントがモニターするデバイスで直接実行されている可能性があります。"
    },
    {
      "indent": 3,
      "text": "Assurance case:",
      "ja": "保証ケース："
    },
    {
      "indent": 12,
      "text": "\"An assurance case is a structured argument, supported by evidence, intended to justify that a system is acceptably assured relative to a concern (such as safety or security) in the intended operating environment\" [Piovesan2017].",
      "ja": "「保証ケースは、意図した運用環境における懸念（安全性やセキュリティなど）に比べてシステムが許容できるほど保証されることを正当化することを意図した証拠によって裏付けられた構造化された議論です」[Piovesan2017]。"
    },
    {
      "indent": 3,
      "text": "Service instance:",
      "ja": "サービスインスタンス："
    },
    {
      "indent": 12,
      "text": "A specific instance of a service.",
      "ja": "サービスの特定のインスタンス。"
    },
    {
      "indent": 3,
      "text": "Intent:",
      "ja": "意図："
    },
    {
      "indent": 12,
      "text": "\"A set of operational goals (that a network should meet) and outcomes (that a network is supposed to deliver) defined in a declarative manner without specifying how to achieve or implement them\" [RFC9315].",
      "ja": "「一連の運用目標（ネットワークが満たすべき）と結果（ネットワークが提供することになっている）は、それらを達成または実装する方法を指定することなく宣言的な方法で定義されています」[RFC9315]。"
    },
    {
      "indent": 3,
      "text": "Subservice:",
      "ja": "サブサービス："
    },
    {
      "indent": 12,
      "text": "A part or functionality of the network system that can be independently assured as a single entity in an assurance graph.",
      "ja": "保証グラフ内の単一のエンティティとして独立して保証できるネットワークシステムの部分または機能。"
    },
    {
      "indent": 3,
      "text": "Assurance graph:",
      "ja": "保証グラフ："
    },
    {
      "indent": 12,
      "text": "A Directed Acyclic Graph (DAG) representing the assurance case for one or several service instances. The nodes (also known as vertices in the context of DAG) are the service instances themselves and the subservices; the edges indicate a dependency relation.",
      "ja": "1つまたは複数のサービスインスタンスの保証ケースを表す指向性の環状グラフ（DAG）。ノード（DAGのコンテキストでも頂点とも呼ばれます）は、サービスインスタンス自体とサブサービスです。エッジは依存関係の関係を示します。"
    },
    {
      "indent": 3,
      "text": "SAIN collector:",
      "ja": "セインコレクター："
    },
    {
      "indent": 12,
      "text": "A functional component that fetches or receives the computer-consumable output of the SAIN agent(s) and processes it locally (including displaying it in a user-friendly form).",
      "ja": "SAINエージェントのコンピューターに適した出力を取得または受信し、ローカルで処理する機能的コンポーネント（ユーザーフレンドリーな形式で表示することを含む）。"
    },
    {
      "indent": 3,
      "text": "DAG:",
      "ja": "ダグ："
    },
    {
      "indent": 12,
      "text": "Directed Acyclic Graph.",
      "ja": "指示された非環式グラフ。"
    },
    {
      "indent": 3,
      "text": "ECMP:",
      "ja": "ECMP："
    },
    {
      "indent": 12,
      "text": "Equal-Cost Multipath.",
      "ja": "等しいコストマルチパス。"
    },
    {
      "indent": 3,
      "text": "Expression graph:",
      "ja": "式グラフ："
    },
    {
      "indent": 12,
      "text": "A generic term for a DAG representing a computation in SAIN. More specific terms are listed below:",
      "ja": "Sainの計算を表すDAGの一般的な用語。より具体的な用語を以下に示します。"
    },
    {
      "indent": 6,
      "text": "Subservice expressions:",
      "ja": "サブサービス式："
    },
    {
      "indent": 15,
      "text": "An expression graph representing all the computations to execute for a subservice.",
      "ja": "サブサービスを実行するすべての計算を表す式グラフ。"
    },
    {
      "indent": 6,
      "text": "Service expressions:",
      "ja": "サービス表現："
    },
    {
      "indent": 15,
      "text": "An expression graph representing all the computations to execute for a service instance, i.e., including the computations for all dependent subservices.",
      "ja": "サービスインスタンスに対して実行するすべての計算を表す式グラフ、つまり、すべての従属サブサービスの計算を含む。"
    },
    {
      "indent": 6,
      "text": "Global computation graph:",
      "ja": "グローバル計算グラフ："
    },
    {
      "indent": 15,
      "text": "An expression graph representing all the computations to execute for all services instances (i.e., all computations performed).",
      "ja": "すべてのサービスインスタンス（つまり、実行されるすべての計算）に対して実行するすべての計算を表す式グラフ。"
    },
    {
      "indent": 3,
      "text": "Dependency:",
      "ja": "依存："
    },
    {
      "indent": 12,
      "text": "The directed relationship between subservice instances in the assurance graph.",
      "ja": "保証グラフのサブサービスインスタンス間の指示された関係。"
    },
    {
      "indent": 3,
      "text": "Metric:",
      "ja": "メトリック："
    },
    {
      "indent": 12,
      "text": "A piece of information retrieved from the network running the assured service.",
      "ja": "保証されたサービスを実行しているネットワークから取得された情報。"
    },
    {
      "indent": 3,
      "text": "Metric engine:",
      "ja": "メトリックエンジン："
    },
    {
      "indent": 12,
      "text": "A functional component, part of the SAIN agent, that maps metrics to a list of candidate metric implementations, depending on the network element.",
      "ja": "ネットワーク要素に応じて、メトリックを候補のメトリック実装のリストにマップするSAINエージェントの一部である機能コンポーネント。"
    },
    {
      "indent": 3,
      "text": "Metric implementation:",
      "ja": "メトリックの実装："
    },
    {
      "indent": 12,
      "text": "The actual way of retrieving a metric from a network element.",
      "ja": "ネットワーク要素からメトリックを取得する実際の方法。"
    },
    {
      "indent": 3,
      "text": "Network Service YANG Module:",
      "ja": "ネットワークサービスYangモジュール："
    },
    {
      "indent": 12,
      "text": "The characteristics of a service, as agreed upon with consumers of that service [RFC8199].",
      "ja": "そのサービスの消費者と合意したサービスの特性[RFC8199]。"
    },
    {
      "indent": 3,
      "text": "Service orchestrator:",
      "ja": "サービスオーケストレーター："
    },
    {
      "indent": 12,
      "text": "\"Network Service YANG Modules describe the characteristics of a service, as agreed upon with consumers of that service. That is, a service module does not expose the detailed configuration parameters of all participating network elements and features but describes an abstract model that allows instances of the service to be decomposed into instance data according to the Network Element YANG Modules of the participating network elements. The service-to-element decomposition is a separate process; the details depend on how the network operator chooses to realize the service. For the purpose of this document, the term \"orchestrator\" is used to describe a system implementing such a process\" [RFC8199].",
      "ja": "「ネットワークサービスYangモジュールは、そのサービスの消費者と合意したサービスの特性を説明しています。つまり、サービスモジュールは、参加しているすべてのネットワーク要素と機能の詳細な構成パラメーターを公開しませんが、インスタンスを可能にする抽象モデルを説明します。サービスは、参加ネットワーク要素のネットワーク要素YANGモジュールに従ってインスタンスデータに分解されます。サービスから要素間の分解は個別のプロセスです。詳細は、ネットワークオペレーターがサービスを実現する方法に依存します。このドキュメントの「オーケストレーター」という用語は、そのようなプロセスを実装するシステムを記述するために使用されます」[RFC8199]。"
    },
    {
      "indent": 3,
      "text": "SAIN orchestrator:",
      "ja": "セインオーケストレーター："
    },
    {
      "indent": 12,
      "text": "A functional component that is in charge of fetching the configuration specific to each service instance and converting it into an assurance graph.",
      "ja": "各サービスインスタンスに固有の構成を取得し、保証グラフに変換することを担当する機能的なコンポーネント。"
    },
    {
      "indent": 3,
      "text": "Health status:",
      "ja": "健康状態："
    },
    {
      "indent": 12,
      "text": "The score and symptoms indicating whether a service instance or a subservice is \"healthy\". A non-maximal score must always be explained by one or more symptoms.",
      "ja": "サービスインスタンスまたはサブサービスが「健康」であるかどうかを示すスコアと症状。最大スコア以外のスコアは、常に1つ以上の症状で説明する必要があります。"
    },
    {
      "indent": 3,
      "text": "Health score:",
      "ja": "健康スコア："
    },
    {
      "indent": 12,
      "text": "An integer ranging from 0 to 100 that indicates the health of a subservice. A score of 0 means that the subservice is broken, a score of 100 means that the subservice in question is operating as expected, and the special value -1 can be used to specify that no value could be computed for that health score, for instance, if some metric needed for that computation could not be collected.",
      "ja": "0〜100の範囲の整数は、サブサービスの健康を示しています。0のスコアは、サブサービスが壊れていることを意味し、100のスコアは、問題のサブサービスが予想どおりに動作していることを意味し、特別な値-1を使用して、たとえばその健康スコアの値を計算できないことを指定できます。、その計算に必要なメトリックを収集できなかった場合。"
    },
    {
      "indent": 3,
      "text": "Strongly connected component:",
      "ja": "強く接続されたコンポーネント："
    },
    {
      "indent": 12,
      "text": "A subset of a directed graph such that there is a (directed) path from any node of the subset to any other node. A DAG does not contain any strongly connected component.",
      "ja": "サブセットの任意のノードから他のノードへの（指示された）パスがあるように、指示されたグラフのサブセット。DAGには、強く接続されたコンポーネントは含まれていません。"
    },
    {
      "indent": 3,
      "text": "Symptom:",
      "ja": "症状："
    },
    {
      "indent": 12,
      "text": "A reason explaining why a service instance or a subservice is not completely healthy.",
      "ja": "サービスインスタンスまたはサブサービスが完全に健康ではない理由を説明する理由。"
    },
    {
      "indent": 0,
      "text": "3. A Functional Architecture",
      "section_title": true,
      "ja": "3. 機能アーキテクチャ"
    },
    {
      "indent": 3,
      "text": "The goal of SAIN is to assure that service instances are operating as expected (i.e., the observed service is matching the expected service) and, if not, to pinpoint what is wrong. More precisely, SAIN computes a score for each service instance and outputs symptoms explaining that score. The only valid situation where no symptoms are returned is when the score is maximal, indicating that no issues were detected for that service instance. The score augmented with the symptoms is called the health status. The exact meaning of the health score value is out of scope of this document. However, the following constraints should be followed: the higher the score, the better the service health is and the two extrema are 0 meaning the service is completely broken, and 100 meaning the service is completely operational.",
      "ja": "Sainの目標は、サービスインスタンスが予想どおりに動作していること（つまり、観測されたサービスが予想されるサービスと一致している）を保証し、そうでない場合、何が間違っているのかを特定することです。より正確には、Sainは各サービスインスタンスのスコアを計算し、そのスコアを説明する症状を出力します。症状が返されない唯一の有効な状況は、スコアが最大の場合であり、そのサービスインスタンスで問題が検出されなかったことを示しています。症状で増強されたスコアは、健康状態と呼ばれます。ヘルススコア値の正確な意味は、このドキュメントの範囲外です。ただし、次の制約に従う必要があります。スコアが高いほど、サービスの健康が優れており、2つの極値は0が0であり、サービスは完全に壊れていることを意味し、100はサービスが完全に動作していることを意味します。"
    },
    {
      "indent": 3,
      "text": "The SAIN architecture is a generic architecture, which generates an assurance graph from service instance(s), as specified in Section 3.1. This architecture is applicable to not only multiple environments (e.g., wireline and wireless) but also different domains (e.g., 5G network function virtualization (NFV) domain with a virtual infrastructure manager (VIM), etc.) and, as already noted, for physical or virtual devices, as well as virtual functions. Thanks to the distributed graph design principle, graphs from different environments and orchestrators can be combined to obtain the graph of a service instance that spans over multiple domains.",
      "ja": "Sainアーキテクチャは、セクション3.1で指定されているように、サービスインスタンスから保証グラフを生成する一般的なアーキテクチャです。このアーキテクチャは、複数の環境（ワイヤーラインやワイヤレスなど）だけでなく、異なるドメイン（例：仮想インフラストラクチャマネージャー（VIM）などを備えた5Gネットワーク機能仮想化（NFV）ドメイン）にも適用できます。物理的または仮想デバイス、および仮想関数。分散グラフ設計の原則のおかげで、さまざまな環境とオーケストレーターのグラフを組み合わせて、複数のドメインにまたがるサービスインスタンスのグラフを取得できます。"
    },
    {
      "indent": 3,
      "text": "As an example of a service, let us consider a point-to-point layer 2 virtual private network (L2VPN). [RFC8466] specifies the parameters for such a service. Examples of symptoms might be symptoms reported by specific subservices, including \"Interface has high error rate\", \"Interface flapping\", or \"Device almost out of memory\", as well as symptoms more specific to the service (such as \"Site disconnected from VPN\").",
      "ja": "サービスの例として、ポイントツーポイントレイヤー2仮想プライベートネットワーク（L2VPN）を考えてみましょう。[RFC8466]このようなサービスのパラメーターを指定します。症状の例は、「インターフェイスのエラー率が高い」、「インターフェイスの羽ばたき」、または「ほとんどメモリのないデバイス」、およびサービスにより特有の症状（「サイトから切り離されたサイトなど」など、特定のサブサービスによって報告された症状が報告される場合があります。vpn \"）。"
    },
    {
      "indent": 3,
      "text": "To compute the health status of an instance of such a service, the service definition is decomposed into an assurance graph formed by subservices linked through dependencies. Each subservice is then turned into an expression graph that details how to fetch metrics from the devices and compute the health status of the subservice. The subservice expressions are combined according to the dependencies between the subservices in order to obtain the expression graph that computes the health status of the service instance.",
      "ja": "このようなサービスのインスタンスの健康状態を計算するために、サービス定義は、依存関係を通じてリンクされたサブサービスによって形成された保証グラフに分解されます。次に、各サブサービスは、デバイスからメトリックを取得し、サブサービスの健康状態を計算する方法を詳述する式グラフに変換されます。サブサービス式は、サービスインスタンスの健康状態を計算する式グラフを取得するために、サブサービス間の依存関係に従って組み合わされます。"
    },
    {
      "indent": 3,
      "text": "The overall SAIN architecture is presented in Figure 1. Based on the service configuration provided by the service orchestrator, the SAIN orchestrator decomposes the assurance graph. It then sends to the SAIN agents the assurance graph along with some other configuration options. The SAIN agents are responsible for building the expression graph and computing the health statuses in a distributed manner. The collector is in charge of collecting and displaying the current inferred health status of the service instances and subservices. The collector also detects changes in the assurance graph structures (e.g., an occurrence of a switchover from primary to backup path) and forwards the information to the orchestrator, which reconfigures the agents. Finally, the automation loop is closed by having the SAIN collector provide feedback to the network/service orchestrator.",
      "ja": "全体的なSAINアーキテクチャを図1に示します。サービスオーケストレーターが提供するサービス構成に基づいて、SAINオーケストレーターは保証グラフを分解します。次に、他のいくつかの構成オプションとともに、Sainエージェントに保証グラフを送信します。SAINエージェントは、式グラフを構築し、分散的に健康状態を計算する責任があります。コレクターは、サービスインスタンスとサブサービスの現在の推定された健康状態の収集と表示を担当しています。コレクターはまた、保証グラフ構造の変化（例えば、プライマリからバックアップパスへのスイッチオーバーの発生）を検出し、情報をオーケストレーターに転送し、エージェントを再構成します。最後に、Sainコレクターにネットワーク/サービスオーケストレーターにフィードバックを提供することにより、自動化ループが閉じられます。"
    },
    {
      "indent": 3,
      "text": "In order to make agents, orchestrators, and collectors from different vendors interoperable, their interface is defined as a YANG module in a companion document [RFC9418]. In Figure 1, the communications that are normalized by this YANG module are tagged with a \"Y\". The use of this YANG module is further explained in Section 3.5.",
      "ja": "さまざまなベンダーのエージェント、オーケストレーター、およびコレクターを相互運用可能にするために、そのインターフェイスはコンパニオンドキュメントのYangモジュールとして定義されます[RFC9418]。図1では、このYangモジュールによって正規化された通信には「Y」がタグ付けされています。このYangモジュールの使用については、セクション3.5でさらに説明しています。"
    },
    {
      "indent": 7,
      "text": " +-----------------+\n | Service         |\n | Orchestrator    |<----------------------+\n |                 |                       |\n +-----------------+                       |\n    |            ^                         |\n    |            | Network                 |\n    |            | Service                 | Feedback\n    |            | Instance                | Loop\n    |            | Configuration           |\n    |            |                         |\n    |            V                         |\n    |        +-----------------+  Graph  +-------------------+\n    |        | SAIN            | Updates | SAIN              |\n    |        | Orchestrator    |<--------| Collector         |\n    |        +-----------------+         +-------------------+\n    |            |                          ^\n    |           Y| Configuration            | Health Status\n    |            | (Assurance Graph)       Y| (Score + Symptoms)\n    |            V                          | Streamed\n    |     +-------------------+             | via Telemetry\n    |     |+-------------------+            |\n    |     ||+-------------------+           |\n    |     +|| SAIN              |-----------+\n    |      +| Agent             |\n    |       +-------------------+\n    |               ^ ^ ^\n    |               | | |\n    |               | | |  Metric Collection\n    V               V V V\n+-------------------------------------------------------------+\n|           (Network) System                                  |\n|                                                             |\n+-------------------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "Figure 1: SAIN Architecture",
      "ja": "図1：セインアーキテクチャ"
    },
    {
      "indent": 3,
      "text": "In order to produce the score assigned to a service instance, the various involved components perform the following tasks:",
      "ja": "サービスインスタンスに割り当てられたスコアを作成するために、さまざまな関係するコンポーネントが次のタスクを実行します。"
    },
    {
      "indent": 6,
      "text": "* Analyze the configuration pushed to the network device(s) for configuring the service instance. From there, determine which information (called a metric) must be collected from the device(s) and which operations to apply to the metrics to compute the health status.",
      "ja": "* サービスインスタンスを構成するために、ネットワークデバイスに押し込まれた構成を分析します。そこから、どの情報（メトリックと呼ばれる）をデバイスから収集する必要があるか、どの操作がメトリックに適用して健康状態を計算するかを決定します。"
    },
    {
      "indent": 6,
      "text": "* Stream (via telemetry, such as YANG-Push [RFC8641]) operational and config metric values when possible, else continuously poll.",
      "ja": "* ストリーム（Yang-Push [RFC8641]などのテレメトリを介して）可能な場合は、動作および構成メトリック値を継続的に投票します。"
    },
    {
      "indent": 6,
      "text": "* Continuously compute the health status of the service instances based on the metric values.",
      "ja": "* メトリック値に基づいて、サービスインスタンスの健康状態を継続的に計算します。"
    },
    {
      "indent": 3,
      "text": "The SAIN architecture requires time synchronization, with the Network Time Protocol (NTP) [RFC5905] as a candidate, between all elements: monitored entities, SAIN agents, service orchestrator, the SAIN collector, as well as the SAIN orchestrator. This guarantees the correlations of all symptoms in the system, correlated with the right assurance graph version.",
      "ja": "SAINアーキテクチャには、ネットワークタイムプロトコル（NTP）[RFC5905]を候補として、すべての要素間の時間同期を必要とします。監視対象エンティティ、セインエージェント、サービスオーケストレーター、セインコレクター、およびセインオーケストレーター。これにより、システム内のすべての症状の相関関係が保証され、適切な保証グラフバージョンと相関しています。"
    },
    {
      "indent": 0,
      "text": "3.1. Translating a Service Instance Configuration into an Assurance Graph",
      "section_title": true,
      "ja": "3.1. サービスインスタンスの構成をAssuranceGraphに変換します"
    },
    {
      "indent": 3,
      "text": "In order to structure the assurance of a service instance, the SAIN orchestrator decomposes the service instance into so-called subservice instances. Each subservice instance focuses on a specific feature or subpart of the service.",
      "ja": "サービスインスタンスの保証を構築するために、Sain Orchestratorはサービスインスタンスをいわゆるサブサービスインスタンスに分解します。各サブサービスインスタンスは、サービスの特定の機能またはサブパートに焦点を当てています。"
    },
    {
      "indent": 3,
      "text": "The decomposition into subservices is an important function of the architecture for the following reasons:",
      "ja": "サブサービスへの分解は、次の理由でアーキテクチャの重要な機能です。"
    },
    {
      "indent": 6,
      "text": "* The result of this decomposition provides a relational picture of a service instance, which can be represented as a graph (called an assurance graph) to the operator.",
      "ja": "* この分解の結果は、サービスインスタンスのリレーショナル画像を提供します。これは、オペレーターにグラフ（保証グラフと呼ばれる）として表すことができます。"
    },
    {
      "indent": 6,
      "text": "* Subservices provide a scope for particular expertise and thereby enable contribution from external experts. For instance, the subservice dealing with the optic's health should be reviewed and extended by an expert in optical interfaces.",
      "ja": "* サブサービスは、特定の専門知識の範囲を提供し、それにより外部の専門家からの貢献を可能にします。たとえば、光学インターフェイスの専門家が視覚の健康を扱うサブサービスをレビューし、拡張する必要があります。"
    },
    {
      "indent": 6,
      "text": "* Subservices that are common to several service instances are reused for reducing the amount of computation needed. For instance, the subservice assuring a given interface is reused by any service instance relying on that interface.",
      "ja": "* いくつかのサービスインスタンスに共通のサブサービスは、必要な計算量を減らすために再利用されます。たとえば、特定のインターフェイスを保証するサブサービスは、そのインターフェイスに依存するサービスインスタンスによって再利用されます。"
    },
    {
      "indent": 3,
      "text": "The assurance graph of a service instance is a DAG representing the structure of the assurance case for the service instance. The nodes of this graph are service instances or subservice instances. Each edge of this graph indicates a dependency between the two nodes at its extremities, i.e., the service or subservice at the source of the edge depends on the service or subservice at the destination of the edge.",
      "ja": "サービスインスタンスの保証グラフは、サービスインスタンスの保証ケースの構造を表すDAGです。このグラフのノードは、サービスインスタンスまたはサブサービスインスタンスです。このグラフの各エッジは、その四肢の2つのノード間の依存関係を示します。つまり、エッジのソースでのサービスまたはサブサービスは、エッジの宛先のサービスまたはサブサービスに依存します。"
    },
    {
      "indent": 3,
      "text": "Figure 2 depicts a simplistic example of the assurance graph for a tunnel service. The node at the top is the service instance; the nodes below are its dependencies. In the example, the tunnel service instance depends on the \"peer1\" and \"peer2\" tunnel interfaces (the tunnel interfaces created on the peer1 and peer2 devices, respectively), which in turn depend on the respective physical interfaces, which finally depend on the respective \"peer1\" and \"peer2\" devices. The tunnel service instance also depends on the IP connectivity that depends on the IS-IS routing protocol.",
      "ja": "図2は、トンネルサービスの保証グラフの単純な例を示しています。上部のノードはサービスインスタンスです。以下のノードはその依存関係です。この例では、トンネルサービスインスタンスは、「PEER1」および「PEER2」トンネルインターフェイス（それぞれPEER1およびPEER2デバイスで作成されたトンネルインターフェイス）に依存し、それぞれの物理インターフェイスに依存します。それぞれの「PEER1」および「PEER2」デバイス。トンネルサービスインスタンスは、IS-ISルーティングプロトコルに依存するIP接続にも依存します。"
    },
    {
      "indent": 12,
      "text": "                +------------------+\n                | Tunnel           |\n                | Service Instance |\n                +------------------+\n                          |\n     +--------------------+-------------------+\n     |                    |                   |\n     v                    v                   v\n+-------------+    +--------------+    +-------------+\n| Peer1       |    | IP           |    | Peer2       |\n| Tunnel      |    | Connectivity |    | Tunnel      |\n| Interface   |    |              |    | Interface   |\n+-------------+    +--------------+    +-------------+\n       |                  |                  |\n       |    +-------------+--------------+   |\n       |    |             |              |   |\n       v    v             v              v   v\n+-------------+    +-------------+     +-------------+\n| Peer1       |    | IS-IS       |     | Peer2       |\n| Physical    |    | Routing     |     | Physical    |\n| Interface   |    | Protocol    |     | Interface   |\n+-------------+    +-------------+     +-------------+\n       |                                     |\n       v                                     v\n+-------------+                        +-------------+\n|             |                        |             |\n| Peer1       |                        | Peer2       |\n| Device      |                        | Device      |\n+-------------+                        +-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 2: Assurance Graph Example",
      "ja": "図2：保証グラフの例"
    },
    {
      "indent": 3,
      "text": "Depicting the assurance graph helps the operator to understand (and assert) the decomposition. The assurance graph shall be maintained during normal operation with addition, modification, and removal of service instances. A change in the network configuration or topology shall automatically be reflected in the assurance graph. As a first example, a change of the routing protocol from IS-IS to OSPF would change the assurance graph accordingly. As a second example, assume that the ECMP is in place for the source router for that specific tunnel; in that case, multiple interfaces must now be monitored, in addition to monitoring the ECMP health itself.",
      "ja": "保証グラフを描くことは、オペレーターが分解を理解（および主張する）のに役立ちます。保証グラフは、サービスインスタンスの追加、変更、および削除により、通常の動作中に維持されます。ネットワーク構成またはトポロジの変更は、自動的に保証グラフに反映されなければなりません。最初の例として、IS-ISからOSPFへのルーティングプロトコルの変更により、それに応じて保証グラフが変更されます。2番目の例として、その特定のトンネルのソースルーターのECMPが整っていると仮定します。その場合、ECMPの健康自体の監視に加えて、複数のインターフェイスを監視する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.1.1. Circular Dependencies",
      "section_title": true,
      "ja": "3.1.1. 回覧依存関係"
    },
    {
      "indent": 3,
      "text": "The edges of the assurance graph represent dependencies. An assurance graph is a DAG if and only if there are no circular dependencies among the subservices, and every assurance graph should avoid circular dependencies. However, in some cases, circular dependencies might appear in the assurance graph.",
      "ja": "保証グラフのエッジは依存関係を表します。保証グラフは、サブサービス間に円形の依存関係がない場合にのみDAGであり、すべての保証グラフは円形の依存関係を避ける必要があります。ただし、場合によっては、循環依存関係が保証グラフに表示される場合があります。"
    },
    {
      "indent": 3,
      "text": "First, the assurance graph of a whole system is obtained by combining the assurance graph of every service running on that system. Here, combining means that two subservices having the same type and the same parameters are in fact the same subservice and thus a single node in the graph. For instance, the subservice of type \"device\" with the only parameter (the device ID) set to \"PE1\" will appear only once in the whole assurance graph, even if several service instances rely on that device. Now, if two engineers design assurance graphs for two different services, and Engineer A decides that an interface depends on the link it is connected to, but Engineer B decides that the link depends on the interface it is connected to, then when combining the two assurance graphs, we will have a circular dependency interface -> link -> interface.",
      "ja": "まず、システム全体の保証グラフは、そのシステムで実行されているすべてのサービスの保証グラフを組み合わせることにより取得されます。ここで、組み合わせて、同じタイプと同じパラメーターを持つ2つのサブサービスが実際に同じサブサービスであり、したがってグラフ内の単一のノードであることを意味します。たとえば、「PE1」に設定された唯一のパラメーター（デバイスID）を使用したタイプ「デバイス」のサブサービスは、いくつかのサービスインスタンスがそのデバイスに依存していても、保証グラフ全体に1回だけ表示されます。ここで、2つのエンジニアが2つの異なるサービスに保証グラフを設計し、エンジニアAがインターフェイスが接続されているリンクに依存することを決定しますが、エンジニアBは、リンクが接続されているインターフェイスに依存することを決定します。保証グラフでは、循環依存関係インターフェイス - > link->インターフェイスがあります。"
    },
    {
      "indent": 3,
      "text": "Another case possibly resulting in circular dependencies is when subservices are not properly identified. Assume that we want to assure a cloud-based computing cluster that runs containers. We could represent the cluster by a subservice and the network service connecting containers on the cluster by another subservice. We would likely model that as the network service depending on the cluster, because the network service runs in a container supported by the cluster. Conversely, the cluster depends on the network service for connectivity between containers, which creates a circular dependency. A finer decomposition might distinguish between the resources for executing containers (a part of our cluster subservice) and the communication between the containers (which could be modeled in the same way as communication between routers).",
      "ja": "おそらく循環依存性をもたらす別のケースは、サブサービスが適切に識別されない場合です。コンテナを実行するクラウドベースのコンピューティングクラスターを保証したいと仮定します。サブサービスでクラスターを表すことができ、クラスター上のコンテナを別のサブサービスで接続するネットワークサービスを表すことができます。ネットワークサービスはクラスターでサポートされているコンテナで実行されるため、クラスターに応じてネットワークサービスとしてモデル化する可能性があります。逆に、クラスターは、コンテナ間の接続のネットワークサービスに依存し、円形の依存性が生成されます。細かい分解は、コンテナを実行するためのリソース（クラスターサブサービスの一部）とコンテナ間の通信（ルーター間の通信と同じ方法でモデル化できる）を区別する場合があります。"
    },
    {
      "indent": 3,
      "text": "In any case, it is likely that circular dependencies will show up in the assurance graph. A first step would be to detect circular dependencies as soon as possible in the SAIN architecture. Such a detection could be carried out by the SAIN orchestrator. Whenever a circular dependency is detected, the newly added service would not be monitored until more careful modeling or alignment between the different teams (Engineers A and B) remove the circular dependency.",
      "ja": "いずれにせよ、循環依存関係が保証グラフに表示される可能性があります。最初のステップは、Sainアーキテクチャでできるだけ早く循環依存関係を検出することです。このような検出は、Sain Orchestratorによって実行される可能性があります。循環依存関係が検出されるたびに、新しく追加されたサービスは、異なるチーム（エンジニアAとB）間のより慎重なモデリングまたはアライメントが円形の依存関係を削除するまで監視されません。"
    },
    {
      "indent": 3,
      "text": "As a more elaborate solution, we could consider a graph transformation:",
      "ja": "より精巧な解決策として、グラフ変換を考慮することができます。"
    },
    {
      "indent": 6,
      "text": "* Decompose the graph into strongly connected components.",
      "ja": "* グラフを強く接続されたコンポーネントに分解します。"
    },
    {
      "indent": 6,
      "text": "* For each strongly connected component:",
      "ja": "* 強く接続されたコンポーネントごとに："
    },
    {
      "indent": 12,
      "text": "- remove all edges between nodes of the strongly connected component;",
      "ja": "- 強く接続されたコンポーネントのノード間のすべてのエッジを削除します。"
    },
    {
      "indent": 12,
      "text": "- add a new \"synthetic\" node for the strongly connected component;",
      "ja": "- 強く接続されたコンポーネントに新しい「合成」ノードを追加します。"
    },
    {
      "indent": 12,
      "text": "- for each edge pointing to a node in the strongly connected component, change the destination to the \"synthetic\" node; and",
      "ja": "- 強く接続されたコンポーネントのノードを指す各エッジについて、宛先を「合成」ノードに変更します。そして"
    },
    {
      "indent": 12,
      "text": "- add a dependency from the \"synthetic\" node to every node in the strongly connected component.",
      "ja": "- 「合成」ノードから強く接続されたコンポーネントのすべてのノードに依存関係を追加します。"
    },
    {
      "indent": 3,
      "text": "Such an algorithm would include all symptoms detected by any subservice in one of the strongly connected components and make it available to any subservice that depends on it. Figure 3 shows an example of such a transformation. On the left-hand side, the nodes c, d, e, and f form a strongly connected component. The status of node a should depend on the status of nodes c, d, e, f, g, and h, but this is hard to compute because of the circular dependency. On the right-hand side, node a depends on all these nodes as well, but the circular dependency has been removed.",
      "ja": "このようなアルゴリズムには、強く接続されたコンポーネントのいずれかのサブサービスで検出されたすべての症状が含まれ、それに依存する任意のサブサービスが利用可能になります。図3は、そのような変換の例を示しています。左側では、ノードC、D、E、およびFが強く接続されたコンポーネントを形成します。ノードAのステータスは、ノードc、d、e、f、g、およびhのステータスに依存する必要がありますが、これは円形の依存性のために計算するのが困難です。右側では、ノードAはこれらすべてのノードにも依存しますが、円形の依存性は削除されています。"
    },
    {
      "indent": 9,
      "text": "+---+    +---+          |                +---+    +---+\n| a |    | b |          |                | a |    | b |\n+---+    +---+          |                +---+    +---+\n  |        |            |                  |        |\n  v        v            |                  v        v\n+---+    +---+          |                +------------+\n| c |--->| d |          |                |  synthetic |\n+---+    +---+          |                +------------+\n  ^        |            |               /   |      |   \\\n  |        |            |              /    |      |    \\\n  |        v            |             v     v      v     v\n+---+    +---+          |          +---+  +---+  +---+  +---+\n| f |<---| e |          |          | f |  | c |  | d |  | e |\n+---+    +---+          |          +---+  +---+  +---+  +---+\n  |        |            |            |                    |\n  v        v            |            v                    v\n+---+    +---+          |          +---+                +---+\n| g |    | h |          |          | g |                | h |\n+---+    +---+          |          +---+                +---+\n\n   Before                                     After\nTransformation                           Transformation",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Figure 3: Graph Transformation",
      "ja": "図3：グラフ変換"
    },
    {
      "indent": 3,
      "text": "We consider a concrete example to illustrate this transformation. Let's assume that Engineer A is building an assurance graph dealing with IS-IS and Engineer B is building an assurance graph dealing with OSPF. The graph from Engineer A could contain the following:",
      "ja": "この変換を説明する具体的な例を検討します。Engineer AはIS-ISを扱う保証グラフを構築しており、Engineer BがOSPFを扱う保証グラフを構築していると仮定しましょう。Engineer Aのグラフには、以下を含めることができます。"
    },
    {
      "indent": 10,
      "text": "         +------------+\n         | IS-IS Link |\n         +------------+\n               |\n               v\n         +------------+\n         | Phys. Link |\n         +------------+\n           |       |\n           v       v\n+-------------+  +-------------+\n| Interface 1 |  | Interface 2 |\n+-------------+  +-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Figure 4: Fragment of the Assurance Graph from Engineer A",
      "ja": "図4：エンジニアからの保証グラフの断片"
    },
    {
      "indent": 3,
      "text": "The graph from Engineer B could contain the following:",
      "ja": "Engineer Bのグラフには、以下を含めることができます。"
    },
    {
      "indent": 8,
      "text": "           +------------+\n           | OSPF Link  |\n           +------------+\n             |   |   |\n             v   |   v\n+-------------+  |  +-------------+\n| Interface 1 |  |  | Interface 2 |\n+-------------+  |  +-------------+\n              |  |   |\n              v  v   v\n           +------------+\n           | Phys. Link |\n           +------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Figure 5: Fragment of the Assurance Graph from Engineer B",
      "ja": "図5：エンジニアBからの保証グラフの断片"
    },
    {
      "indent": 3,
      "text": "The Interface subservices and the Physical Link subservice are common to both fragments above. Each of these subservices appear only once in the graph merging the two fragments. Dependencies from both fragments are included in the merged graph, resulting in a circular dependency:",
      "ja": "インターフェイスサブサービスと物理リンクサブサービスは、上記の両方のフラグメントに共通しています。これらの各サブサービスは、2つのフラグメントをマージするグラフに1回だけ表示されます。両方のフラグメントからの依存関係は、マージされたグラフに含まれているため、円形の依存性が得られます。"
    },
    {
      "indent": 9,
      "text": "+------------+      +------------+\n| IS-IS Link |      | OSPF Link  |---+\n+------------+      +------------+   |\n      |               |     |        |\n      |     +-------- +     |        |\n      v     v               |        |\n+------------+              |        |\n| Phys. Link |<-------+     |        |\n+------------+        |     |        |\n  |  ^     |          |     |        |\n  |  |     +-------+  |     |        |\n  v  |             v  |     v        |\n+-------------+  +-------------+     |\n| Interface 1 |  | Interface 2 |     |\n+-------------+  +-------------+     |\n      ^                              |\n      |                              |\n      +------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "Figure 6: Merging Graphs from Engineers A and B",
      "ja": "図6：エンジニアAとBからのグラフのマージ"
    },
    {
      "indent": 3,
      "text": "The solution presented above would result in a graph looking as follows, where a new \"synthetic\" node is included. Using that transformation, all dependencies are indirectly satisfied for the nodes outside the circular dependency, in the sense that both IS-IS and OSPF links have indirect dependencies to the two interfaces and the link. However, the dependencies between the link and the interfaces are lost since they were causing the circular dependency.",
      "ja": "上記のソリューションでは、新しい「合成」ノードが含まれているグラフが次のように見えます。その変換を使用して、すべての依存関係は、IS-ISリンクとOSPFリンクの両方が2つのインターフェイスとリンクへの間接的な依存関係を持っているという意味で、円形依存関係の外側のノードに対して間接的に満たされます。ただし、リンクとインターフェイスの間の依存関係は、循環依存性を引き起こしているため失われます。"
    },
    {
      "indent": 9,
      "text": "      +------------+      +------------+\n      | IS-IS Link |      | OSPF Link  |\n      +------------+      +------------+\n                 |          |\n                 v          v\n                +------------+\n                |  synthetic |\n                +------------+\n                      |\n          +-----------+-------------+\n          |           |             |\n          v           v             v\n+-------------+ +------------+ +-------------+\n| Interface 1 | | Phys. Link | | Interface 2 |\n+-------------+ +------------+ +-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 7: Removing Circular Dependencies after Merging Graphs from Engineers A and B",
      "ja": "図7：エンジニアAとBからグラフをマージした後の円形依存関係の削除"
    },
    {
      "indent": 0,
      "text": "3.2. Intent and Assurance Graph",
      "section_title": true,
      "ja": "3.2. 意図と保証グラフ"
    },
    {
      "indent": 3,
      "text": "The SAIN orchestrator analyzes the configuration of a service instance to do the following:",
      "ja": "Sain Orchestratorは、サービスインスタンスの構成を分析して、以下を実行します。"
    },
    {
      "indent": 6,
      "text": "* Try to capture the intent of the service instance, i.e., What is the service instance trying to achieve? At a minimum, this requires the SAIN orchestrator to know the YANG modules that are being configured on the devices to enable the service. Note that, if the service model or the network model is known to the SAIN orchestrator, the latter can exploit it. In that case, the intent could be directly extracted and include more details, such as the notion of sites for a VPN, which is out of scope of the device configuration.",
      "ja": "* サービスインスタンスの意図をキャプチャしてみてください。つまり、サービスインスタンスは何を達成しようとしていますか？少なくとも、これにより、Sain Orchestratorは、サービスを有効にするためにデバイス上で構成されているYangモジュールを知る必要があります。サービスモデルまたはネットワークモデルがSain Orchestratorに知られている場合、後者はそれを悪用できることに注意してください。その場合、意図を直接抽出し、デバイス構成の範囲外であるVPNのサイトの概念などの詳細を含めることができます。"
    },
    {
      "indent": 6,
      "text": "* Decompose the service instance into subservices representing the network features on which the service instance relies.",
      "ja": "* サービスインスタンスがサービスインスタンスに依存しているネットワーク機能を表すサブサービスにサービスインスタンスを分解します。"
    },
    {
      "indent": 3,
      "text": "The SAIN orchestrator must be able to analyze the configuration pushed to various devices of a service instance and produce the assurance graph for that service instance.",
      "ja": "Sain Orchestratorは、サービスインスタンスのさまざまなデバイスにプッシュされた構成を分析し、そのサービスインスタンスの保証グラフを作成できる必要があります。"
    },
    {
      "indent": 3,
      "text": "To schematize what a SAIN orchestrator does, assume that a service instance touches two devices and configures a virtual tunnel interface on each device. Then:",
      "ja": "Sain Orchestratorが行うことを概略するために、サービスインスタンスが2つのデバイスに触れ、各デバイスに仮想トンネルインターフェイスを構成すると仮定します。それから："
    },
    {
      "indent": 6,
      "text": "* Capturing the intent would start by detecting that the service instance is actually a tunnel between the two devices and stating that this tunnel must be operational. This solution is minimally invasive, as it does not require modifying nor knowing the service model. If the service model or network model is known by the SAIN orchestrator, it can be used to further capture the intent and include more information, such as Service-Level Objectives (e.g., the latency and bandwidth requirements for the tunnel) if present in the service model.",
      "ja": "* 意図をキャプチャすることは、サービスインスタンスが実際に2つのデバイス間のトンネルであることを検出し、このトンネルが動作しなければならないことを検出することから始めます。このソリューションは、サービスモデルの変更や知識を必要としないため、最小限の侵襲性です。サービスモデルまたはネットワークモデルがSain Orchestratorによって知られている場合、意図をさらにキャプチャし、サービスレベルの目標（トンネルのレイテンシおよび帯域幅要件など）などのより多くの情報を含めるために使用できます。サービスモデル。"
    },
    {
      "indent": 6,
      "text": "* Decomposing the service instance into subservices would result in the assurance graph depicted in Figure 2, for instance.",
      "ja": "* サービスインスタンスをサブサービスに分解すると、たとえば図2に示す保証グラフが表示されます。"
    },
    {
      "indent": 3,
      "text": "The assurance graph, or more precisely the subservices and dependencies that a SAIN orchestrator can instantiate, should be curated. The organization of such a process (i.e., ensure that existing subservices are reused as much as possible and avoid circular dependencies) is out-of-scope for this document.",
      "ja": "保証グラフ、またはより正確には、セインオーケストレーターがインスタンス化できるサブサービスと依存関係をキュレーションする必要があります。このようなプロセスの組織（つまり、既存のサブサービスが可能な限り再利用され、円形の依存関係を回避することを保証します）は、このドキュメントのスコープ外です。"
    },
    {
      "indent": 3,
      "text": "To be applied, SAIN requires a mechanism mapping a service instance to the configuration actually required on the devices for that service instance to run. While Figure 1 makes a distinction between the SAIN orchestrator and a different component providing the service instance configuration, in practice those two components are most likely combined. The internals of the orchestrator are out of scope of this document.",
      "ja": "適用するには、Sainは、そのサービスインスタンスが実行されるために、デバイスで実際に必要な構成にサービスインスタンスをマッピングするメカニズムを必要とします。図1は、SAINオーケストレーターとサービスインスタンスの構成を提供する異なるコンポーネントを区別していますが、実際には、これらの2つのコンポーネントが組み合わされている可能性が最も高いです。オーケストレーターの内部は、この文書の範囲外です。"
    },
    {
      "indent": 0,
      "text": "3.3. Subservices",
      "section_title": true,
      "ja": "3.3. サブサービス"
    },
    {
      "indent": 3,
      "text": "A subservice corresponds to a subpart or a feature of the network system that is needed for a service instance to function properly. In the context of SAIN, a subservice is associated to its assurance, which is the method for assuring that a subservice behaves correctly.",
      "ja": "サブサービスは、サービスインスタンスが適切に機能するために必要なネットワークシステムのサブパートまたは機能に対応します。Sainの文脈では、サブサービスはその保証に関連付けられています。これは、サブサービスが正しく動作することを保証する方法です。"
    },
    {
      "indent": 3,
      "text": "Subservices, just as with services, have high-level parameters that specify the instance to be assured. The needed parameters depend on the subservice type. For example, assuring a device requires a specific deviceId as a parameter and assuring an interface requires a specific combination of deviceId and interfaceId.",
      "ja": "サービスと同様に、サブサービスは、保証するインスタンスを指定する高レベルのパラメーターを持っています。必要なパラメーターは、サブサービスタイプに依存します。たとえば、デバイスを保証するには、特定のDeviceIDがパラメーターとして必要であり、インターフェイスを保証するには、DeviceIDとInterfaceIDの特定の組み合わせが必要です。"
    },
    {
      "indent": 3,
      "text": "When designing a new type of subservice, one should carefully define what is the assured object or functionality. Then, the parameters must be chosen as a minimal set that completely identifies the object (see examples from the previous paragraph). Parameters cannot change during the life cycle of a subservice. For instance, an IP address is a good parameter when assuring a connectivity towards that address (i.e., a given device can reach a given IP address); however, it's not a good parameter to identify an interface, as the IP address assigned to that interface can be changed.",
      "ja": "新しいタイプのサブサービスを設計するとき、保証されたオブジェクトまたは機能を慎重に定義する必要があります。次に、オブジェクトを完全に識別する最小セットとしてパラメーターを選択する必要があります（前の段落の例を参照）。パラメーターは、サブサービスのライフサイクル中に変更できません。たとえば、IPアドレスは、そのアドレスへの接続性を保証する場合の良いパラメーターです（つまり、特定のデバイスは特定のIPアドレスに到達できます）。ただし、そのインターフェイスに割り当てられたIPアドレスを変更できるため、インターフェイスを識別するのは良いパラメーターではありません。"
    },
    {
      "indent": 3,
      "text": "A subservice is also characterized by a list of metrics to fetch and a list of operations to apply to these metrics in order to infer a health status.",
      "ja": "サブサービスは、健康状態を推測するために、フェッチするメトリックのリストとこれらのメトリックに適用する操作のリストも特徴です。"
    },
    {
      "indent": 0,
      "text": "3.4. Building the Expression Graph from the Assurance Graph",
      "section_title": true,
      "ja": "3.4. 保証グラフから式グラフを構築します"
    },
    {
      "indent": 3,
      "text": "From the assurance graph, a so-called global computation graph is derived. First, each subservice instance is transformed into a set of subservice expressions that take metrics and constants as input (i.e., sources of the DAG) and produce the status of the subservice based on some heuristics. For instance, the health of an interface is 0 (minimal score) with the symptom \"interface admin-down\" if the interface is disabled in the configuration. Then, for each service instance, the service expressions are constructed by combining the subservice expressions of its dependencies. The way service expressions are combined depends on the dependency types (impacting or informational). Finally, the global computation graph is built by combining the service expressions to get a global view of all subservices. In other words, the global computation graph encodes all the operations needed to produce health statuses from the collected metrics.",
      "ja": "保証グラフから、いわゆるグローバル計算グラフが導出されます。まず、各サブサービスインスタンスは、入力（つまり、DAGのソース）としてメトリックと定数を採取し、いくつかのヒューリスティックに基づいてサブサービスのステータスを生成する一連のサブサービス式に変換されます。たとえば、インターフェイスの健康は、構成内でインターフェイスが無効になっている場合、症状「インターフェイス管理者」で0（最小スコア）です。次に、各サービスインスタンスについて、サービス式は、その依存関係のサブサービス式を組み合わせて構築されます。サービス表現の組み合わせ方法は、依存関係の種類（影響または情報）によって異なります。最後に、グローバルな計算グラフは、サービス式を組み合わせてすべてのサブサービスのグローバルビューを取得することにより構築されます。言い換えれば、グローバル計算グラフは、収集されたメトリックから健康状態を生成するために必要なすべての操作をエンコードします。"
    },
    {
      "indent": 3,
      "text": "The two types of dependencies for combining subservices are:",
      "ja": "サブサービスを組み合わせるための2種類の依存関係は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Informational Dependency:",
      "ja": "情報依存関係："
    },
    {
      "indent": 12,
      "text": "The type of dependency whose health score does not impact the health score of its parent subservice or service instance(s) in the assurance graph. However, the symptoms should be taken into account in the parent service instance or subservice instance(s) for informational reasons.",
      "ja": "保証グラフの親サブサービスまたはサービスインスタンスの健康スコアに健康スコアが影響を与えない依存関係のタイプ。ただし、情報上の理由から、親サービスインスタンスまたはサブサービスインスタンスで症状を考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "Impacting Dependency:",
      "ja": "依存に影響を与える："
    },
    {
      "indent": 12,
      "text": "The type of dependency whose health score impacts the health score of its parent subservice or service instance(s) in the assurance graph. The symptoms are taken into account in the parent service instance or subservice instance(s) as the impacting reasons.",
      "ja": "保証グラフの親サブサービスまたはサービスインスタンスの健康スコアに健康スコアが影響する依存関係のタイプ。症状は、影響を与える理由として、親サービスインスタンスまたはサブサービスインスタンスで考慮されます。"
    },
    {
      "indent": 3,
      "text": "The set of dependency types presented here is not exhaustive. More specific dependency types can be defined by extending the YANG module. For instance, a connectivity subservice depending on several path subservices is partially impacted if only one of these paths fails. Adding these new dependency types requires defining the corresponding operation for combining statuses of subservices.",
      "ja": "ここに示されている依存関係タイプのセットは網羅的ではありません。より具体的な依存関係タイプは、Yangモジュールを拡張することで定義できます。たとえば、これらのパスの1つだけが故障した場合、いくつかのパスサブサービスに応じて接続のサブサービスが部分的に影響を受けます。これらの新しい依存関係タイプを追加するには、サブサービスのステータスを組み合わせるために対応する操作を定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "Subservices shall not be dependent on the protocol used to retrieve the metrics. To justify this, let's consider the interface operational status. Depending on the device capabilities, this status can be collected by an industry-accepted YANG module (e.g., IETF or Openconfig [OpenConfig]), by a vendor-specific YANG module, or even by a MIB module. If the subservice was dependent on the mechanism to collect the operational status, then we would need multiple subservice definitions in order to support all different mechanisms. This also implies that, while waiting for all the metrics to be available via standard YANG modules, SAIN agents might have to retrieve metric values via nonstandard YANG data models, MIB modules, the Command-Line Interface (CLI), etc., effectively implementing a normalization layer between data models and information models.",
      "ja": "サブサービスは、メトリックの取得に使用されるプロトコルに依存してはなりません。これを正当化するには、インターフェイスの動作ステータスを考えてみましょう。デバイスの機能に応じて、このステータスは、業界が受け入れたYangモジュール（IETFまたはOpenConFig [OpenConfig]など）、ベンダー固有のYangモジュール、またはMIBモジュールによっても収集できます。サブサービスが運用ステータスを収集するメカニズムに依存している場合、すべての異なるメカニズムをサポートするために複数のサブサービス定義が必要になります。これはまた、すべてのメトリックが標準ヤンモジュールを介して利用可能になるのを待っている間、SAINエージェントは非標準ヤンデータモデル、MIBモジュール、コマンドラインインターフェイス（CLI）などを介してメトリック値を取得する必要がある可能性があることを意味します。データモデルと情報モデルの間の正規化レイヤー。"
    },
    {
      "indent": 3,
      "text": "In order to keep subservices independent of metric collection method (or, expressed differently, to support multiple combinations of platforms, OSes, and even vendors), the architecture introduces the concept of \"metric engine\". The metric engine maps each device-independent metric used in the subservices to a list of device-specific metric implementations that precisely define how to fetch values for that metric. The mapping is parameterized by the characteristics (i.e., model, OS version, etc.) of the device from which the metrics are fetched. This metric engine is included in the SAIN agent.",
      "ja": "メトリックコレクション方法から独立したサブサービスを維持するため（または、プラットフォーム、OS、さらにはベンダーの複数の組み合わせをサポートするために異なる方法で表現するため）、アーキテクチャは「メトリックエンジン」の概念を紹介します。メトリックエンジンは、サブサービスで使用される各デバイスに依存しないメトリックをマップし、そのメトリックの値を取得する方法を正確に定義するデバイス固有のメトリック実装のリストにマップします。マッピングは、メトリックが取得されるデバイスの特性（つまり、モデル、OSバージョンなど）によってパラメーター化されます。このメトリックエンジンは、Sainエージェントに含まれています。"
    },
    {
      "indent": 0,
      "text": "3.5. Open Interfaces with YANG Modules",
      "section_title": true,
      "ja": "3.5. Yangモジュールでインターフェイスを開きます"
    },
    {
      "indent": 3,
      "text": "The interfaces between the architecture components are open thanks to the YANG modules specified in [RFC9418]; they specify objects for assuring network services based on their decomposition into so-called subservices, according to the SAIN architecture.",
      "ja": "[RFC9418]で指定されたヤンモジュールのおかげで、アーキテクチャコンポーネント間のインターフェイスが開いています。Sain Architectureによると、いわゆるサブサービスへの分解に基づいてネットワークサービスを保証するためのオブジェクトを指定しています。"
    },
    {
      "indent": 3,
      "text": "These modules are intended for the following use cases:",
      "ja": "これらのモジュールは、次のユースケースを対象としています。"
    },
    {
      "indent": 6,
      "text": "* Assurance graph configuration:",
      "ja": "* 保証グラフの構成："
    },
    {
      "indent": 12,
      "text": "- Subservices: Configure a set of subservices to assure by specifying their types and parameters.",
      "ja": "- サブサービス：タイプとパラメーターを指定して保証するサブサービスのセットを構成します。"
    },
    {
      "indent": 12,
      "text": "- Dependencies: Configure the dependencies between the subservices, along with their types.",
      "ja": "- 依存関係：サブサービス間の依存関係をそのタイプとともに構成します。"
    },
    {
      "indent": 6,
      "text": "* Assurance telemetry: Export the health status of the subservices, along with the observed symptoms.",
      "ja": "* 保証テレメトリ：観察された症状とともに、サブサービスの健康状態をエクスポートします。"
    },
    {
      "indent": 3,
      "text": "Some examples of YANG instances can be found in Appendix A of [RFC9418].",
      "ja": "Yangインスタンスのいくつかの例は、[RFC9418]の付録Aに記載されています。"
    },
    {
      "indent": 0,
      "text": "3.6. Handling Maintenance Windows",
      "section_title": true,
      "ja": "3.6. メンテナンスウィンドウの処理"
    },
    {
      "indent": 3,
      "text": "Whenever network components are under maintenance, the operator wants to inhibit the emission of symptoms from those components. A typical use case is device maintenance, during which the device is not supposed to be operational. As such, symptoms related to the device health should be ignored. Symptoms related to the device-specific subservices, such as the interfaces, might also be ignored because their state changes are probably the consequence of the maintenance.",
      "ja": "ネットワークコンポーネントがメンテナンスを受けているときはいつでも、オペレーターはこれらのコンポーネントからの症状の放出を阻害したいと考えています。典型的なユースケースは、デバイスのメンテナンスであり、その間にデバイスが動作しているはずです。そのため、デバイスの健康に関連する症状は無視する必要があります。インターフェイスなどのデバイス固有のサブサービスに関連する症状も、その状態の変更がおそらくメンテナンスの結果であるため、無視される場合があります。"
    },
    {
      "indent": 3,
      "text": "The ietf-service-assurance model described in [RFC9418] enables flagging subservices as under maintenance and, in that case, requires a string that identifies the person or process that requested the maintenance. When a service or subservice is flagged as under maintenance, it must report a generic \"Under Maintenance\" symptom for propagation towards subservices that depend on this specific subservice. Any other symptom from this service or by one of its impacting dependencies must not be reported.",
      "ja": "[RFC9418]で説明されているIETF-Service-Assunsuranceモデルは、メンテナンスの下でサブサービスにフラグを立てることができ、その場合、メンテナンスを要求する人またはプロセスを識別する文字列が必要です。サービスまたはサブサービスがメンテナンス中のものとしてフラグが付けられている場合、この特定のサブサービスに依存するサブサービスへの伝播のための一般的な「メンテナンス下」の症状を報告する必要があります。このサービスからのその他の症状またはその影響の依存関係の1つによって報告されてはなりません。"
    },
    {
      "indent": 3,
      "text": "We illustrate this mechanism on three independent examples based on the assurance graph depicted in Figure 2:",
      "ja": "このメカニズムは、図2に示す保証グラフに基づいて、3つの独立した例に基づいて説明します。"
    },
    {
      "indent": 6,
      "text": "* Device maintenance, for instance, upgrading the device OS. The operator flags the subservice \"Peer1\" device as under maintenance. This inhibits the emission of symptoms, except \"Under Maintenance\" from \"Peer1 Physical Interface\", \"Peer1 Tunnel Interface\", and \"Tunnel Service Instance\". All other subservices are unaffected.",
      "ja": "* たとえば、デバイスのメンテナンス、デバイスOSのアップグレード。オペレーターは、メンテナンス中のサブサービス「PEER1」デバイスにフラグを立てます。これは、「PEER1物理インターフェイス」、「PEER1トンネルインターフェイス」、および「トンネルサービスインスタンス」からの「メンテナンス中」を除き、症状の放出を阻害します。他のすべてのサブサービスは影響を受けません。"
    },
    {
      "indent": 6,
      "text": "* Interface maintenance, for instance, replacing a broken optic. The operator flags the subservice \"Peer1 Physical Interface\" as under maintenance. This inhibits the emission of symptoms, except \"Under Maintenance\" from \"Peer 1 Tunnel Interface\" and \"Tunnel Service Instance\". All other subservices are unaffected.",
      "ja": "* たとえば、インターフェイスメンテナンスは、壊れた光学系を置き換えます。オペレーターは、メンテナンス中のサブサービス「PEER1物理インターフェイス」にフラグを立てます。これは、「ピア1トンネルインターフェイス」と「トンネルサービスインスタンス」からの「メンテナンス中」を除き、症状の放出を阻害します。他のすべてのサブサービスは影響を受けません。"
    },
    {
      "indent": 6,
      "text": "* Routing protocol maintenance, for instance, modifying parameters or redistribution. The operator marks the subservice \"IS-IS Routing Protocol\" as under maintenance. This inhibits the emission of symptoms, except \"Under Maintenance\" from \"IP connectivity\" and \"Tunnel Service Instance\". All other subservices are unaffected.",
      "ja": "* たとえば、ルーティングプロトコルのメンテナンスは、パラメーターや再配布の変更です。オペレーターは、メンテナンス中のサブサービス「IS-ISルーティングプロトコル」をマークします。これは、「IP接続性」と「トンネルサービスインスタンス」からの「メンテナンス中」を除き、症状の放出を阻害します。他のすべてのサブサービスは影響を受けません。"
    },
    {
      "indent": 3,
      "text": "In each example above, the subservice under maintenance is completely impacting the service instance, putting it under maintenance as well. There are use cases where the subservice under maintenance only partially impacts the service instance. For instance, consider a service instance supported by both a primary and backup path. If a subservice impacting the primary path is under maintenance, the service instance might still be functional but degraded. In that case, the status of the service instance might include \"Primary path Under Maintenance\", \"No redundancy\", as well as other symptoms from the backup path to explain the lower health score. In general, the computation of the service instance status from the subservices is done in the SAIN collector whose implementation is out of scope for this document.",
      "ja": "上記の各例では、メンテナンス中のサブサービスがサービスインスタンスに完全に影響を与えており、同様にメンテナンスの下に置かれています。メンテナンス中のサブサービスがサービスインスタンスに部分的にのみ影響する場合のユースケースがあります。たとえば、プライマリパスとバックアップパスの両方でサポートされているサービスインスタンスを検討してください。主要なパスに影響を与えるサブサービスがメンテナンスを受けている場合、サービスインスタンスは依然として機能的であるが劣化する可能性があります。その場合、サービスインスタンスのステータスには、「メンテナンス中のプライマリパス」、「冗長性なし」、および低い健康スコアを説明するためのバックアップパスからのその他の症状が含まれる場合があります。一般に、サブサービスからのサービスインスタンスステータスの計算は、このドキュメントの実装が範囲外であるSainコレクターで行われます。"
    },
    {
      "indent": 3,
      "text": "The maintenance of a subservice might modify or hide modifications of the structure of the assurance graph. Therefore, unflagging a subservice as under maintenance should trigger an update of the assurance graph.",
      "ja": "サブサービスのメンテナンスは、保証グラフの構造の変更を変更または非表示にする場合があります。したがって、メンテナンス中のサブサービスを解き、保証グラフの更新をトリガーするはずです。"
    },
    {
      "indent": 0,
      "text": "3.7. Flexible Functional Architecture",
      "section_title": true,
      "ja": "3.7. 柔軟な機能アーキテクチャ"
    },
    {
      "indent": 3,
      "text": "The SAIN architecture is flexible in terms of components. While the SAIN architecture in Figure 1 makes a distinction between two components, the service orchestrator and the SAIN orchestrator, in practice the two components are most likely combined. Similarly, the SAIN agents are displayed in Figure 1 as being separate components. In practice, the SAIN agents could be either independent components or directly integrated in monitored entities. A practical example is an agent in a router.",
      "ja": "セインアーキテクチャは、コンポーネントの点で柔軟です。図1のセインアーキテクチャは、サービスオーケストレーターとセインオーケストレーターである2つのコンポーネントを区別していますが、実際には2つのコンポーネントが組み合わされている可能性が高いです。同様に、SAINエージェントは、図1に別々のコンポーネントとして表示されます。実際には、SAINエージェントは、独立したコンポーネントであるか、監視対象のエンティティに直接統合されている可能性があります。実用的な例は、ルーターのエージェントです。"
    },
    {
      "indent": 3,
      "text": "The SAIN architecture is also flexible in terms of services and subservices. In the defined architecture, the SAIN orchestrator is coupled to a service orchestrator, which defines the kinds of services that the architecture handles. Most examples in this document deal with the notion of Network Service YANG Modules with well-known services, such as L2VPN or tunnels. However, the concept of services is general enough to cross into different domains. One of them is the domain of service management on network elements, which also require their own assurance. Examples include a DHCP server on a Linux server, a data plane, an IPFIX export, etc. The notion of \"service\" is generic in this architecture and depends on the service orchestrator and underlying network system, as illustrated by the following examples:",
      "ja": "Sainアーキテクチャは、サービスやサブサービスの点でも柔軟です。定義されたアーキテクチャでは、Sain Orchestratorは、アーキテクチャが処理するサービスの種類を定義するサービスオーケストレーターと結合されています。このドキュメントのほとんどの例は、L2VPNやトンネルなどのよく知られたサービスを備えたネットワークサービスYangモジュールの概念を扱っています。ただし、サービスの概念は、異なるドメインに渡るのに十分な一般的です。そのうちの1つは、ネットワーク要素のサービス管理の領域であり、独自の保証も必要です。例には、Linuxサーバー上のDHCPサーバー、データプレーン、IPFIXエクスポートなどが含まれます。「サービス」の概念は、このアーキテクチャでは一般的であり、以下の例に示すように、サービスオーケストレーターと基礎となるネットワークシステムに依存します。"
    },
    {
      "indent": 6,
      "text": "* If a main service orchestrator coordinates several lower-level controllers, a service for the controller can be a subservice from the point of view of the orchestrator.",
      "ja": "* メインサービスオーケストレーターがいくつかの低レベルのコントローラーを調整する場合、コントローラーのサービスはオーケストレーターの観点からのサブサービスになります。"
    },
    {
      "indent": 6,
      "text": "* A DHCP server / data plane / IPFIX export can be considered subservices for a device.",
      "ja": "* DHCPサーバー /データプレーン / IPFIXのエクスポートは、デバイスのサブサービスと見なすことができます。"
    },
    {
      "indent": 6,
      "text": "* A routing instance can be considered a subservice for an L3VPN.",
      "ja": "* ルーティングインスタンスは、L3VPNのサブサービスと見なすことができます。"
    },
    {
      "indent": 6,
      "text": "* A tunnel can be considered a subservice for an application in the cloud.",
      "ja": "* トンネルは、クラウド内のアプリケーションのサブサービスと見なすことができます。"
    },
    {
      "indent": 6,
      "text": "* A service function can be considered a subservice for a service function chain [RFC7665].",
      "ja": "* サービス機能は、サービス関数チェーン[RFC7665]のサブサービスと見なすことができます。"
    },
    {
      "indent": 3,
      "text": "The assurance graph is created to be flexible and open, regardless of the subservice types, locations, or domains.",
      "ja": "保証グラフは、サブサービスの種類、場所、またはドメインに関係なく、柔軟でオープンになるように作成されます。"
    },
    {
      "indent": 3,
      "text": "The SAIN architecture is also flexible in terms of distributed graphs. As shown in Figure 1, the architecture comprises several agents. Each agent is responsible for handling a subgraph of the assurance graph. The collector is responsible for fetching the subgraphs from the different agents and gluing them together. As an example, in the graph from Figure 2, the subservices relative to Peer 1 might be handled by a different agent than the subservices relative to Peer 2, and the Connectivity and IS-IS subservices might be handled by yet another agent. The agents will export their partial graph, and the collector will stitch them together as dependencies of the service instance.",
      "ja": "Sainアーキテクチャは、分散グラフの点でも柔軟です。図1に示すように、アーキテクチャはいくつかのエージェントで構成されています。各エージェントは、保証グラフのサブグラフを処理する責任があります。コレクターは、さまざまなエージェントからサブグラフを取得し、それらを接着する責任があります。例として、図2のグラフでは、ピア1に関連するサブサービスは、ピア2に比べてサブサービスとは異なるエージェントによって処理される場合があり、接続性とISサブサービスはさらに別のエージェントによって処理される場合があります。エージェントは部分グラフをエクスポートし、コレクターはサービスインスタンスの依存関係としてそれらを縫い合わせます。"
    },
    {
      "indent": 3,
      "text": "And finally, the SAIN architecture is flexible in terms of what it monitors. Most, if not all, examples in this document refer to physical components, but this is not a constraint. Indeed, the assurance of virtual components would follow the same principles, and an assurance graph composed of virtualized components (or a mix of virtualized and physical ones) is supported by this architecture.",
      "ja": "そして最後に、Sainアーキテクチャは、監視するものの観点から柔軟です。すべてではないにしても、ほとんどの場合、このドキュメントの例は物理コンポーネントを指しますが、これは制約ではありません。実際、仮想コンポーネントの保証は同じ原則に従い、仮想化されたコンポーネント（または仮想化されたものと物理的なコンポーネントの組み合わせ）で構成される保証グラフは、このアーキテクチャによってサポートされています。"
    },
    {
      "indent": 0,
      "text": "3.8. Time Window for Symptoms' History",
      "section_title": true,
      "ja": "3.8. 症状の歴史の時間枠"
    },
    {
      "indent": 3,
      "text": "The health status reported via the YANG modules contains, for each subservice, the list of symptoms. Symptoms have a start and end date, making it is possible to report symptoms that are no longer occurring.",
      "ja": "Yangモジュールを介して報告されている健康状態には、各サブサービスについて、症状のリストが含まれています。症状には開始日と終了日があり、発生していない症状を報告することができます。"
    },
    {
      "indent": 3,
      "text": "The SAIN agent might have to remove some symptoms for specific subservice symptoms because they are outdated and no longer relevant or simply because the SAIN agent needs to free up some space. Regardless of the reason, it's important for a SAIN collector connecting/reconnecting to a SAIN agent to understand the effect of this garbage collection.",
      "ja": "SAINエージェントは、特定の下着症状の症状を除去する必要がある場合があります。なぜなら、それらは時代遅れであり、もはや関連性がないか、SAINエージェントがいくつかのスペースを解放する必要があるからです。理由に関係なく、SAINコレクターがSainエージェントに接続/再接続して、このゴミ収集の効果を理解することが重要です。"
    },
    {
      "indent": 3,
      "text": "Therefore, the SAIN agent contains a YANG object specifying the date and time at which the symptoms' history starts for the subservice instances. The subservice reports only symptoms that are occurring or that have been occurring after the history start date.",
      "ja": "したがって、SAINエージェントには、症状の歴史がサブサービスインスタンスの日付と時刻を指定するヤンオブジェクトが含まれています。サブサービスは、発生している、または履歴開始日以降に発生している症状のみを報告します。"
    },
    {
      "indent": 0,
      "text": "3.9. New Assurance Graph Generation",
      "section_title": true,
      "ja": "3.9. 新しい保証グラフ生成"
    },
    {
      "indent": 3,
      "text": "The assurance graph will change over time, because services and subservices come and go (changing the dependencies between subservices) or as a result of resolving maintenance issues. Therefore, an assurance graph version must be maintained, along with the date and time of its last generation. The date and time of a particular subservice instance (again dependencies or under maintenance) might be kept. From a client point of view, an assurance graph change is triggered by the value of the assurance-graph-version and assurance-graph-last-change YANG leaves. At that point in time, the client (collector) follows the following process:",
      "ja": "サービスとサブサービスが出入りするため（サブサービス間の依存関係を変更する）、またはメンテナンスの問題を解決した結果として、保証グラフは時間とともに変化します。したがって、最後の世代の日付と時刻とともに、保証グラフバージョンを維持する必要があります。特定のサブサービスインスタンスの日付と時刻（再び依存関係またはメンテナンス中）が保持される場合があります。クライアントの観点から、保証グラフの変更は、保証グラフバージョンと保証グラフの変化のヤンの葉の価値によって引き起こされます。その時点で、クライアント（コレクター）は次のプロセスに従います。"
    },
    {
      "indent": 6,
      "text": "* Keep the previous assurance-graph-last-change value (let's call it time T).",
      "ja": "* 以前のAssurance-Graph-Last-Change値を保持します（Time Tと呼びましょう）。"
    },
    {
      "indent": 6,
      "text": "* Run through all the subservice instances and process the subservice instances for which the last-change is newer than the time T.",
      "ja": "* すべてのサブサービスインスタンスを介して実行し、最後の変化がThe Time Tよりも新しいサブサービスインスタンスを処理します。"
    },
    {
      "indent": 6,
      "text": "* Keep the new assurance-graph-last-change as the new referenced date and time.",
      "ja": "* 新しいAssurance-Graph-last-changeを新しい参照日時として維持します。"
    },
    {
      "indent": 0,
      "text": "4. IANA Considerations",
      "section_title": true,
      "ja": "4. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "このドキュメントにはIANAアクションがありません。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The SAIN architecture helps operators to reduce the mean time to detect and the mean time to repair. However, the SAIN agents must be secured; a compromised SAIN agent may be sending incorrect root causes or symptoms to the management systems. Securing the agents falls back to ensuring the integrity and confidentiality of the assurance graph. This can be partially achieved by correctly setting permissions of each node in the YANG data model, as described in Section 6 of [RFC9418].",
      "ja": "セインアーキテクチャは、オペレーターが検出する平均時間と修復の平均時間を短縮するのに役立ちます。ただし、Sainエージェントは確保する必要があります。妥協したSAINエージェントは、管理システムに誤った根本原因または症状を送信している可能性があります。エージェントを保護することは、保証グラフの完全性と機密性を確保することに戻ります。これは、[RFC9418]のセクション6で説明されているように、Yangデータモデルの各ノードの権限を正しく設定することで部分的に実現できます。"
    },
    {
      "indent": 3,
      "text": "Except for the configuration of telemetry, the agents do not need \"write access\" to the devices they monitor. This configuration is applied with a YANG module, whose protection is covered by Secure Shell (SSH) [RFC6242] for the Network Configuration Protocol (NETCONF) or TLS [RFC8446] for RESTCONF. Devices should be configured so that agents have their own credentials with write access only for the YANG nodes configuring the telemetry.",
      "ja": "テレメトリの構成を除き、エージェントは監視するデバイスへの「書き込みアクセス」を必要としません。この構成は、ネットワーク構成プロトコル（NetConf）またはTLS [RFC8446]のセキュアシェル（SSH）[RFC6242]で保護が補償されているYangモジュールで適用されます。エージェントがテレメトリを構成するYangノードに対してのみ書き込みアクセスを備えた独自の資格情報を持つように、デバイスを構成する必要があります。"
    },
    {
      "indent": 3,
      "text": "The data collected by SAIN could potentially be compromising to the network or provide more insight into how the network is designed. Considering the data that SAIN requires (including CLI access in some cases), one should weigh data access concerns with the impact that reduced visibility will have on being able to rapidly identify root causes.",
      "ja": "Sainによって収集されたデータは、ネットワークに侵害される可能性があるか、ネットワークの設計方法についてより多くの洞察を提供する可能性があります。Sainが必要とするデータ（場合によってはCLIアクセスを含む）を考慮すると、視認性の低下が根本原因を迅速に特定できるようになる影響について、データアクセスの懸念を検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "For building the assurance graph, the SAIN orchestrator needs to obtain the configuration from the service orchestrator. The latter should restrict access of the SAIN orchestrator to information needed to build the assurance graph.",
      "ja": "保証グラフを構築するには、Sain Orchestratorがサービスオーケストレーターから構成を取得する必要があります。後者は、Sain Orchestratorのアクセスを保証グラフの構築に必要な情報に制限する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a closed loop system relies on this architecture, then the well-known issue of those systems also applies, i.e., a lying device or compromised agent could trigger partial reconfiguration of the service or network. The SAIN architecture neither augments nor reduces this risk. An extension of SAIN, which is out of scope for this document, could detect discrepancies between symptoms reported by different agents, and thus detect anomalies if an agent or a device is lying.",
      "ja": "閉ループシステムがこのアーキテクチャに依存している場合、これらのシステムのよく知られた問題も適用されます。つまり、嘘をついているデバイスまたは侵害されたエージェントが、サービスまたはネットワークの部分的な再構成をトリガーする可能性があります。セインアーキテクチャは、このリスクを増強したり減らしたりしません。この文書の範囲外であるSainの拡張は、異なる薬剤によって報告された症状間の不一致を検出し、エージェントまたはデバイスが嘘をついている場合に異常を検出する可能性があります。"
    },
    {
      "indent": 3,
      "text": "If NTP service goes down, the devices clocks might lose their synchronization. In that case, correlating information from different devices, such as detecting symptoms about a link or correlating symptoms from different devices, will give inaccurate results.",
      "ja": "NTPサービスがダウンすると、デバイスのクロックが同期を失う可能性があります。その場合、リンクに関する症状を検出したり、異なるデバイスからの症状を相関させるなど、さまざまなデバイスから情報を相関させると、不正確な結果が得られます。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6. 参考文献"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC8309]  Wu, Q., Liu, W., and A. Farrel, \"Service Models\n           Explained\", RFC 8309, DOI 10.17487/RFC8309, January 2018,\n           <https://www.rfc-editor.org/info/rfc8309>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8969]  Wu, Q., Ed., Boucadair, M., Ed., Lopez, D., Xie, C., and\n           L. Geng, \"A Framework for Automating Service and Network\n           Management with YANG\", RFC 8969, DOI 10.17487/RFC8969,\n           January 2021, <https://www.rfc-editor.org/info/rfc8969>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9418]  Claise, B., Quilbeuf, J., Lucente, P., Fasano, P., and T.\n           Arumugam, \"A YANG Data Model for Service Assurance\",\n           RFC 9418, DOI 10.17487/RFC9418, July 2023,\n           <https://www.rfc-editor.org/info/rfc9418>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[OpenConfig]\n           \"OpenConfig\", <https://openconfig.net>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Piovesan2017]\n           Piovesan, A. and E. Griffor, \"7 - Reasoning About Safety\n           and Security: The Logic of Assurance\",\n           DOI 10.1016/B978-0-12-803773-7.00007-3, 2017,\n           <https://doi.org/10.1016/B978-0-12-803773-7.00007-3>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2865]  Rigney, C., Willens, S., Rubens, A., and W. Simpson,\n           \"Remote Authentication Dial In User Service (RADIUS)\",\n           RFC 2865, DOI 10.17487/RFC2865, June 2000,\n           <https://www.rfc-editor.org/info/rfc2865>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5424]  Gerhards, R., \"The Syslog Protocol\", RFC 5424,\n           DOI 10.17487/RFC5424, March 2009,\n           <https://www.rfc-editor.org/info/rfc5424>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5905]  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,\n           \"Network Time Protocol Version 4: Protocol and Algorithms\n           Specification\", RFC 5905, DOI 10.17487/RFC5905, June 2010,\n           <https://www.rfc-editor.org/info/rfc5905>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6242]  Wasserman, M., \"Using the NETCONF Protocol over Secure\n           Shell (SSH)\", RFC 6242, DOI 10.17487/RFC6242, June 2011,\n           <https://www.rfc-editor.org/info/rfc6242>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7011]  Claise, B., Ed., Trammell, B., Ed., and P. Aitken,\n           \"Specification of the IP Flow Information Export (IPFIX)\n           Protocol for the Exchange of Flow Information\", STD 77,\n           RFC 7011, DOI 10.17487/RFC7011, September 2013,\n           <https://www.rfc-editor.org/info/rfc7011>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7149]  Boucadair, M. and C. Jacquenet, \"Software-Defined\n           Networking: A Perspective from within a Service Provider\n           Environment\", RFC 7149, DOI 10.17487/RFC7149, March 2014,\n           <https://www.rfc-editor.org/info/rfc7149>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7665]  Halpern, J., Ed. and C. Pignataro, Ed., \"Service Function\n           Chaining (SFC) Architecture\", RFC 7665,\n           DOI 10.17487/RFC7665, October 2015,\n           <https://www.rfc-editor.org/info/rfc7665>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7950]  Bjorklund, M., Ed., \"The YANG 1.1 Data Modeling Language\",\n           RFC 7950, DOI 10.17487/RFC7950, August 2016,\n           <https://www.rfc-editor.org/info/rfc7950>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8199]  Bogdanovic, D., Claise, B., and C. Moberg, \"YANG Module\n           Classification\", RFC 8199, DOI 10.17487/RFC8199, July\n           2017, <https://www.rfc-editor.org/info/rfc8199>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8446]  Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n           Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n           <https://www.rfc-editor.org/info/rfc8446>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8466]  Wen, B., Fioccola, G., Ed., Xie, C., and L. Jalil, \"A YANG\n           Data Model for Layer 2 Virtual Private Network (L2VPN)\n           Service Delivery\", RFC 8466, DOI 10.17487/RFC8466, October\n           2018, <https://www.rfc-editor.org/info/rfc8466>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8641]  Clemm, A. and E. Voit, \"Subscription to YANG Notifications\n           for Datastore Updates\", RFC 8641, DOI 10.17487/RFC8641,\n           September 2019, <https://www.rfc-editor.org/info/rfc8641>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8907]  Dahm, T., Ota, A., Medway Gash, D.C., Carrel, D., and L.\n           Grant, \"The Terminal Access Controller Access-Control\n           System Plus (TACACS+) Protocol\", RFC 8907,\n           DOI 10.17487/RFC8907, September 2020,\n           <https://www.rfc-editor.org/info/rfc8907>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9315]  Clemm, A., Ciavaglia, L., Granville, L. Z., and J.\n           Tantsura, \"Intent-Based Networking - Concepts and\n           Definitions\", RFC 9315, DOI 10.17487/RFC9315, October\n           2022, <https://www.rfc-editor.org/info/rfc9315>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9375]  Wu, B., Ed., Wu, Q., Ed., Boucadair, M., Ed., Gonzalez de\n           Dios, O., and B. Wen, \"A YANG Data Model for Network and\n           VPN Service Performance Monitoring\", RFC 9375,\n           DOI 10.17487/RFC9375, April 2023,\n           <https://www.rfc-editor.org/info/rfc9375>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "section_title": true,
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Stephane Litkowski, Charles Eckel, Rob Wilton, Vladimir Vassiliev, Gustavo Alburquerque, Stefan Vallin, Éric Vyncke, Mohamed Boucadair, Dhruv Dhody, Michael Richardson, and Rob Wilton for their reviews and feedback.",
      "ja": "著者は、ステファン・リトコフスキー、チャールズ・エッケル、ロブ・ウィルトン、ウラジミール・ヴァシリエフ、グスタボ・アルバカーキ、ステファン・ヴァリン、エリック・ヴィンケ、モハメド・ブーカデア、ドゥルフ・ドディ、マイケル・リチャードソン、ロブ・ウィルトンのレビューとフィードバックに感謝します。"
    },
    {
      "indent": 0,
      "text": "Contributors",
      "section_title": true,
      "ja": "貢献者"
    },
    {
      "indent": 6,
      "text": "* Youssef El Fathi",
      "ja": "* youssef el fathi"
    },
    {
      "indent": 6,
      "text": "* Éric Vyncke",
      "ja": "* エリック・ヴィンケ"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Benoit Claise\nHuawei\nEmail: benoit.claise@huawei.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jean Quilbeuf\nHuawei\nEmail: jean.quilbeuf@huawei.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Diego R. Lopez\nTelefonica I+D\nDon Ramon de la Cruz, 82\n28006 Madrid\nSpain\nEmail: diego.r.lopez@telefonica.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dan Voyer\nBell Canada\nCanada\nEmail: daniel.voyer@bell.ca",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Thangavelu Arumugam\nConsultant\nMilpitas, California\nUnited States of America\nEmail: thangavelu@yahoo.com",
      "raw": true,
      "ja": ""
    }
  ]
}