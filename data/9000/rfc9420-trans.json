{
  "title": {
    "text": "RFC 9420 - The Messaging Layer Security (MLS) Protocol",
    "ja": "RFC 9420 - メッセージング レイヤー セキュリティ（MLS）プロトコル"
  },
  "number": 9420,
  "created_at": "2024-03-17 21:14:26.724805+09:00",
  "updated_by": "自動生成(GPT)",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         R. Barnes\nRequest for Comments: 9420                                         Cisco\nCategory: Standards Track                                  B. Beurdouche\nISSN: 2070-1721                                          Inria & Mozilla\n                                                               R. Robert\n                                                             Phoenix R&D\n                                                             J. Millican\n                                                          Meta Platforms\n                                                                E. Omara\n\n                                                          K. Cohn-Gordon\n                                                    University of Oxford\n                                                               July 2023",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "The Messaging Layer Security (MLS) Protocol",
      "section_title": true,
      "ja": "メッセージング レイヤー セキュリティ（MLS）プロトコル"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "要約"
    },
    {
      "indent": 3,
      "text": "Messaging applications are increasingly making use of end-to-end security mechanisms to ensure that messages are only accessible to the communicating endpoints, and not to any servers involved in delivering messages. Establishing keys to provide such protections is challenging for group chat settings, in which more than two clients need to agree on a key but may not be online at the same time. In this document, we specify a key establishment protocol that provides efficient asynchronous group key establishment with forward secrecy (FS) and post-compromise security (PCS) for groups in size ranging from two to thousands.",
      "ja": "メッセージングアプリケーションは、メッセージが通信エンドポイントのみアクセス可能であり、メッセージの配信に関与するサーバーにはアクセスできないようにするために、エンドツーエンドのセキュリティメカニズムを増やしています。このような保護を提供するための鍵の確立は、2つ以上のクライアントが鍵に同意する必要があるグループチャット設定では、同時にオンラインになっていないかもしれないため、課題となります。この文書では、2人から数千人までのグループに対して、前方秘匿性（FS）と事後妥協セキュリティ（PCS）を備えた効率的な非同期グループ鍵確立プロトコルを指定します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはインターネット標準トラックの文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "この文書は、Internet Engineering Task Force（IETF）の成果です。これは、IETFコミュニティの合意を表しています。公開レビューを受け、Internet Engineering Steering Group（IESG）によって出版が承認されました。Internet Standardsに関する詳細情報は、RFC 7841のセクション2で入手できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9420.",
      "ja": "この文書の現在の状況、誤り訂正、およびフィードバックの方法に関する情報は、https://www.rfc-editor.org/info/rfc9420 で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2023 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2023 IETF トラストおよび文書の著者として特定された個人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "この文書は、この文書の公開日に有効なBCP 78およびIETF文書に関するIETF信託の法的規定（https://trustee.ietf.org/license-info）の対象となります。この文書に関するあなたの権利と制限を説明しているため、これらの文書を注意深く確認してください。この文書から抽出されたコードコンポーネントには、信託法的規定のセクション4.eに記載されている改訂BSDライセンステキストを含める必要があり、改訂BSDライセンスに記載されている保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n2.  Terminology\n  2.1.  Presentation Language\n    2.1.1.  Optional Value\n    2.1.2.  Variable-Size Vector Length Headers\n3.  Protocol Overview\n  3.1.  Cryptographic State and Evolution\n  3.2.  Example Protocol Execution\n  3.3.  External Joins\n  3.4.  Relationships between Epochs\n4.  Ratchet Tree Concepts\n  4.1.  Ratchet Tree Terminology\n    4.1.1.  Ratchet Tree Nodes\n    4.1.2.  Paths through a Ratchet Tree\n  4.2.  Views of a Ratchet Tree\n5.  Cryptographic Objects\n  5.1.  Cipher Suites\n    5.1.1.  Public Keys\n    5.1.2.  Signing\n    5.1.3.  Public Key Encryption\n  5.2.  Hash-Based Identifiers\n  5.3.  Credentials\n    5.3.1.  Credential Validation\n    5.3.2.  Credential Expiry and Revocation\n    5.3.3.  Uniquely Identifying Clients\n6.  Message Framing\n  6.1.  Content Authentication\n  6.2.  Encoding and Decoding a Public Message\n  6.3.  Encoding and Decoding a Private Message\n    6.3.1.  Content Encryption\n    6.3.2.  Sender Data Encryption\n7.  Ratchet Tree Operations\n  7.1.  Parent Node Contents\n  7.2.  Leaf Node Contents\n  7.3.  Leaf Node Validation\n  7.4.  Ratchet Tree Evolution\n  7.5.  Synchronizing Views of the Tree\n  7.6.  Update Paths\n  7.7.  Adding and Removing Leaves\n  7.8.  Tree Hashes\n  7.9.  Parent Hashes\n    7.9.1.  Using Parent Hashes\n    7.9.2.  Verifying Parent Hashes\n8.  Key Schedule\n  8.1.  Group Context\n  8.2.  Transcript Hashes\n  8.3.  External Initialization\n  8.4.  Pre-Shared Keys\n  8.5.  Exporters\n  8.6.  Resumption PSK\n  8.7.  Epoch Authenticators\n9.  Secret Tree\n  9.1.  Encryption Keys\n  9.2.  Deletion Schedule\n10. Key Packages\n  10.1.  KeyPackage Validation\n11. Group Creation\n  11.1.  Required Capabilities\n  11.2.  Reinitialization\n  11.3.  Subgroup Branching\n12. Group Evolution\n  12.1.  Proposals\n    12.1.1.  Add\n    12.1.2.  Update\n    12.1.3.  Remove\n    12.1.4.  PreSharedKey\n    12.1.5.  ReInit\n    12.1.6.  ExternalInit\n    12.1.7.  GroupContextExtensions\n    12.1.8.  External Proposals\n  12.2.  Proposal List Validation\n  12.3.  Applying a Proposal List\n  12.4.  Commit\n    12.4.1.  Creating a Commit\n    12.4.2.  Processing a Commit\n    12.4.3.  Adding Members to the Group\n13. Extensibility\n  13.1.  Additional Cipher Suites\n  13.2.  Proposals\n  13.3.  Credential Extensibility\n  13.4.  Extensions\n  13.5.  GREASE\n14. Sequencing of State Changes\n15. Application Messages\n  15.1.  Padding\n  15.2.  Restrictions\n  15.3.  Delayed and Reordered Application Messages\n16. Security Considerations\n  16.1.  Transport Security\n  16.2.  Confidentiality of Group Secrets\n  16.3.  Confidentiality of Sender Data\n  16.4.  Confidentiality of Group Metadata\n    16.4.1.  GroupID, Epoch, and Message Frequency\n    16.4.2.  Group Extensions\n    16.4.3.  Group Membership\n  16.5.  Authentication\n  16.6.  Forward Secrecy and Post-Compromise Security\n  16.7.  Uniqueness of Ratchet Tree Key Pairs\n  16.8.  KeyPackage Reuse\n  16.9.  Delivery Service Compromise\n  16.10. Authentication Service Compromise\n  16.11. Additional Policy Enforcement\n  16.12. Group Fragmentation by Malicious Insiders\n17. IANA Considerations\n  17.1.  MLS Cipher Suites\n  17.2.  MLS Wire Formats\n  17.3.  MLS Extension Types\n  17.4.  MLS Proposal Types\n  17.5.  MLS Credential Types\n  17.6.  MLS Signature Labels\n  17.7.  MLS Public Key Encryption Labels\n  17.8.  MLS Exporter Labels\n  17.9.  MLS Designated Expert Pool\n  17.10. The \"message/mls\" Media Type\n18. References\n  18.1.  Normative References\n  18.2.  Informative References\nAppendix A.  Protocol Origins of Example Trees\nAppendix B.  Evolution of Parent Hashes\nAppendix C.  Array-Based Trees\nAppendix D.  Link-Based Trees\nContributors\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "A group of users who want to send each other encrypted messages needs a way to derive shared symmetric encryption keys. For two parties, this problem has been studied thoroughly, with the Double Ratchet emerging as a common solution [DoubleRatchet] [Signal]. Channels implementing the Double Ratchet enjoy fine-grained forward secrecy as well as post-compromise security, but are nonetheless efficient enough for heavy use over low-bandwidth networks.",
      "ja": "暗号化されたメッセージをお互いに送りたいユーザーのグループは、共有対称暗号化キーを導出する方法が必要です。2つの当事者に対して、この問題は徹底的に研究されており、ダブルラチェットが一般的な解決策として浮上しています。ダブルラチェットを実装したチャネルは、細かい粒度の前方秘匿性と、犠牲後のセキュリティを享受しますが、それでも低帯域幅ネットワーク上での重い使用に十分効率的です。"
    },
    {
      "indent": 3,
      "text": "For a group of size greater than two, a common strategy is to distribute symmetric \"sender keys\" over existing 1:1 secure channels, and then for each member to send messages to the group encrypted with their own sender key. On the one hand, using sender keys improves efficiency relative to pairwise transmission of individual messages, and it provides forward secrecy (with the addition of a hash ratchet). On the other hand, it is difficult to achieve post-compromise security with sender keys, requiring a number of key update messages that scales as the square of the group size. An adversary who learns a sender key can often indefinitely and passively eavesdrop on that member's messages. Generating and distributing a new sender key provides a form of post-compromise security with regard to that sender. However, it requires computation and communications resources that scale linearly with the size of the group.",
      "ja": "サイズが2よりも大きいグループに対して一般的な戦略は、対称的な「送信者鍵」を既存の1:1の安全なチャネルに分配し、それぞれのメンバーが自分自身の送信者鍵で暗号化されたメッセージをグループに送信することです。一方で、送信者鍵を使用することは、個々のメッセージのペアワイズな送信に比べて効率が向上し、ハッシュラチェットの追加により前方秘匿性を提供します。しかし、送信者鍵を使用してポストコンプロマイズセキュリティを達成するのは難しく、グループサイズの2乗に比例する数のキー更新メッセージが必要です。送信者鍵を学習した敵対者は、しばしばそのメンバーのメッセージを無期限に受動的に盗聴することができます。新しい送信者鍵を生成および配布することは、その送信者に関するポストコンプロマイズセキュリティの形態を提供します。ただし、グループのサイズに比例して計算および通信リソースが線形に増加する必要があります。"
    },
    {
      "indent": 3,
      "text": "In this document, we describe a protocol based on tree structures that enables asynchronous group keying with forward secrecy and post-compromise security. Based on earlier work on \"asynchronous ratcheting trees\" [ART], the protocol presented here uses an asynchronous key-encapsulation mechanism for tree structures. This mechanism allows the members of the group to derive and update shared keys with costs that scale as the log of the group size.",
      "ja": "この文書では、非同期グループ鍵付けを実現するツリー構造に基づくプロトコルについて説明します。このプロトコルは、前方秘匿性と事後妥協セキュリティを備えています。以前の「非同期ラチェットツリー」[ART] に基づいて、ここで提示されるプロトコルは、ツリー構造のための非同期鍵カプセル化メカニズムを使用しています。このメカニズムにより、グループのメンバーは、グループサイズの対数に比例するコストで共有鍵を導出および更新することができます。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 3,
      "text": "Client:",
      "ja": "クライアント:"
    },
    {
      "indent": 12,
      "text": "An agent that uses this protocol to establish shared cryptographic state with other clients. A client is defined by the cryptographic keys it holds.",
      "ja": "このプロトコルを使用して他のクライアントと共有暗号状態を確立するエージェントです。クライアントは保持している暗号鍵によって定義されます。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ"
    },
    {
      "indent": 12,
      "text": "A group represents a logical collection of clients that share a common secret value at any given time. Its state is represented as a linear sequence of epochs in which each epoch depends on its predecessor.",
      "ja": "グループは、任意の時点で共通の秘密値を共有するクライアントの論理的な集合を表します。その状態は、それぞれのエポックが直前のエポックに依存する線形のシーケンスとして表されます。"
    },
    {
      "indent": 3,
      "text": "Epoch:",
      "ja": "エポック:"
    },
    {
      "indent": 12,
      "text": "A state of a group in which a specific set of authenticated clients hold shared cryptographic state.",
      "ja": "特定の一連の認証されたクライアントが共有された暗号状態を保持するグループの状態。"
    },
    {
      "indent": 3,
      "text": "Member:",
      "ja": "メンバー"
    },
    {
      "indent": 12,
      "text": "A client that is included in the shared state of a group and hence has access to the group's secrets.",
      "ja": "グループの共有状態に含まれるクライアントであり、したがってグループの秘密にアクセスできるもの。"
    },
    {
      "indent": 3,
      "text": "Key Package:",
      "ja": "キーパッケージ"
    },
    {
      "indent": 12,
      "text": "A signed object describing a client's identity and capabilities, including a hybrid public key encryption (HPKE) [RFC9180] public key that can be used to encrypt to that client. Other clients can use a client's KeyPackage to introduce the client to a new group.",
      "ja": "クライアントの身元と機能を記述した署名付きオブジェクトで、ハイブリッド公開鍵暗号（HPKE）[RFC9180]の公開鍵が含まれており、そのクライアントに対して暗号化に使用できます。他のクライアントは、クライアントのKeyPackageを使用して、クライアントを新しいグループに紹介することができます。"
    },
    {
      "indent": 3,
      "text": "Group Context:",
      "ja": "グループの文脈:"
    },
    {
      "indent": 12,
      "text": "An object that summarizes the shared, public state of the group. The group context is typically distributed in a signed GroupInfo message, which is provided to new members to help them join a group.",
      "ja": "グループの共有された公開状態を要約するオブジェクト。グループのコンテキストは通常、署名付きのGroupInfoメッセージで配布され、新しいメンバーがグループに参加するのを支援します。"
    },
    {
      "indent": 3,
      "text": "Signature Key:",
      "ja": "署名キー:"
    },
    {
      "indent": 12,
      "text": "A signing key pair used to authenticate the sender of a message.",
      "ja": "メッセージの送信者を認証するために使用される署名キーペア。"
    },
    {
      "indent": 3,
      "text": "Proposal:",
      "ja": "提案:"
    },
    {
      "indent": 12,
      "text": "A message that proposes a change to the group, e.g., adding or removing a member.",
      "ja": "グループに変更を提案するメッセージ、例えばメンバーの追加や削除など。"
    },
    {
      "indent": 3,
      "text": "Commit:",
      "ja": "コミット:"
    },
    {
      "indent": 12,
      "text": "A message that implements the changes to the group proposed in a set of Proposals.",
      "ja": "一連の提案で提案されたグループへの変更を実装するメッセージ。"
    },
    {
      "indent": 3,
      "text": "PublicMessage:",
      "ja": "公開メッセージ:"
    },
    {
      "indent": 12,
      "text": "An MLS protocol message that is signed by its sender and authenticated as coming from a member of the group in a particular epoch, but not encrypted.",
      "ja": "特定のエポックのグループのメンバーから送信され、送信者によって署名され、認証されたが暗号化されていないMLSプロトコルメッセージ。"
    },
    {
      "indent": 3,
      "text": "PrivateMessage:",
      "ja": "プライベートメッセージ:"
    },
    {
      "indent": 12,
      "text": "An MLS protocol message that is signed by its sender, authenticated as coming from a member of the group in a particular epoch, and encrypted so that it is confidential to the members of the group in that epoch.",
      "ja": "特定のエポックのグループのメンバーから送信されたことが確認され、グループのメンバーに機密性を保つように暗号化された、送信者によって署名されたMLSプロトコルメッセージ。"
    },
    {
      "indent": 3,
      "text": "Handshake Message:",
      "ja": "握手メッセージ:"
    },
    {
      "indent": 12,
      "text": "A PublicMessage or PrivateMessage carrying an MLS Proposal or Commit object, as opposed to application data.",
      "ja": "MLS提案またはコミットオブジェクトを運ぶPublicMessageまたはPrivateMessageは、アプリケーションデータとは対照的です。"
    },
    {
      "indent": 3,
      "text": "Application Message:",
      "ja": "アプリケーションメッセージ:"
    },
    {
      "indent": 12,
      "text": "A PrivateMessage carrying application data.",
      "ja": "アプリケーションデータを運ぶプライベートメッセージ。"
    },
    {
      "indent": 3,
      "text": "Terminology specific to tree computations is described in Section 4.1.",
      "ja": "木の計算に特有の用語は、セクション4.1に記載されています。"
    },
    {
      "indent": 3,
      "text": "In general, symmetric values are referred to as \"keys\" or \"secrets\" interchangeably. Either term denotes a value that MUST be kept confidential to a client. When labeling individual values, we typically use \"secret\" to refer to a value that is used to derive further secret values and \"key\" to refer to a value that is used with an algorithm such as Hashed Message Authentication Code (HMAC) or an Authenticated Encryption with Associated Data (AEAD) algorithm.",
      "ja": "一般的に、対称値は「鍵」または「秘密」として同義に使われます。どちらの用語も、クライアントにとって機密情報である値を指します。個々の値をラベル付けする際には、通常、「秘密」という用語はさらなる秘密値を導出するために使用される値を指し、「鍵」という用語は、ハッシュメッセージ認証コード（HMAC）や認証付き暗号化と関連データ（AEAD）アルゴリズムなどのアルゴリズムと共に使用される値を指します。"
    },
    {
      "indent": 3,
      "text": "The PublicMessage and PrivateMessage formats are defined in Section 6. Security notions such as forward secrecy and post-compromise security are defined in Section 16.",
      "ja": "PublicMessageとPrivateMessageの形式は、セクション6で定義されています。フォワードセクレシーなどのセキュリティ概念は、セクション16で定義されています。"
    },
    {
      "indent": 3,
      "text": "As detailed in Section 13.5, MLS uses the \"Generate Random Extensions And Sustain Extensibility\" (GREASE) approach to maintaining extensibility, where senders insert random values into fields in which receivers are required to ignore unknown values. Specific \"GREASE values\" for this purpose are registered in the appropriate IANA registries.",
      "ja": "セクション13.5で詳細に説明されているように、MLSは拡張性を維持するために「ランダムな拡張値を生成し、拡張性を維持する」（GREASE）アプローチを使用しており、送信者は受信者が未知の値を無視する必要があるフィールドにランダムな値を挿入します。この目的のための特定の「GREASE値」は、適切なIANAレジストリに登録されています。"
    },
    {
      "indent": 0,
      "text": "2.1. Presentation Language",
      "section_title": true,
      "ja": "2.1. プレゼンテーション言語"
    },
    {
      "indent": 3,
      "text": "We use the TLS presentation language [RFC8446] to describe the structure of protocol messages. In addition to the base syntax, we add two additional features: the ability for fields to be optional and the ability for vectors to have variable-size length headers.",
      "ja": "プロトコルメッセージの構造を説明するために、私たちはTLSプレゼンテーション言語[RFC8446]を使用しています。基本構文に加えて、フィールドがオプションである機能と、ベクターが可変サイズの長さヘッダーを持つ機能を追加しています。"
    },
    {
      "indent": 0,
      "text": "2.1.1. Optional Value",
      "section_title": true,
      "ja": "2.1.1. オプショナル値"
    },
    {
      "indent": 3,
      "text": "An optional value is encoded with a presence-signaling octet, followed by the value itself if present. When decoding, a presence octet with a value other than 0 or 1 MUST be rejected as malformed.",
      "ja": "オプションの値は、存在を示すオクテットでエンコードされ、その後に値自体が存在する場合に続きます。デコードする際、0または1以外の値を持つ存在オクテットは、形式が正しくないとして拒否されなければなりません。"
    },
    {
      "indent": 3,
      "text": "struct {\n    uint8 present;\n    select (present) {\n        case 0: struct{};\n        case 1: T value;\n    };\n} optional<T>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.1.2. Variable-Size Vector Length Headers",
      "section_title": true,
      "ja": "2.1.2. 可変サイズのベクトル長ヘッダー"
    },
    {
      "indent": 3,
      "text": "In the TLS presentation language, vectors are encoded as a sequence of encoded elements prefixed with a length. The length field has a fixed size set by specifying the minimum and maximum lengths of the encoded sequence of elements.",
      "ja": "TLSプレゼンテーション言語では、ベクトルは、長さが先頭に付加されたエンコードされた要素のシーケンスとしてエンコードされます。長さフィールドは、エンコードされた要素のシーケンスの最小および最大長を指定して固定サイズに設定されます。"
    },
    {
      "indent": 3,
      "text": "In MLS, there are several vectors whose sizes vary over significant ranges. So instead of using a fixed-size length field, we use a variable-size length using a variable-length integer encoding based on the one described in Section 16 of [RFC9000]. They differ only in that the one here requires a minimum-size encoding. Instead of presenting min and max values, the vector description simply includes a V. For example:",
      "ja": "MLSでは、サイズが大きく異なる複数のベクトルがあります。そのため、固定サイズの長さフィールドを使用する代わりに、[RFC9000]のセクション16で説明されているものに基づいた可変長整数エンコーディングを使用します。ここでの違いは、こちらの方が最小サイズのエンコーディングが必要であるという点です。最小値と最大値を提示する代わりに、ベクトルの説明には単にVが含まれています。例えば："
    },
    {
      "indent": 3,
      "text": "struct {\n    uint32 fixed<0..255>;\n    opaque variable<V>;\n} StructWithVectors;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Such a vector can represent values with length from 0 bytes to 2^30 bytes. The variable-length integer encoding reserves the two most significant bits of the first byte to encode the base 2 logarithm of the integer encoding length in bytes. The integer value is encoded on the remaining bits, so that the overall value is in network byte order. The encoded value MUST use the smallest number of bits required to represent the value. When decoding, values using more bits than necessary MUST be treated as malformed.",
      "ja": "そのようなベクトルは、0バイトから2^30バイトまでの長さの値を表すことができます。可変長整数エンコーディングは、最初のバイトの最も上位の2ビットを使用して、バイト単位の整数エンコーディングの長さの底2の対数をエンコードします。整数値は残りのビットにエンコードされ、全体の値はネットワークバイトオーダーになります。エンコードされた値は、値を表すのに必要な最小限のビット数を使用する必要があります。デコード時に、必要以上のビットを使用している値は不正なものとして扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "This means that integers are encoded in 1, 2, or 4 bytes and can encode 6-, 14-, or 30-bit values, respectively.",
      "ja": "整数は1、2、または4バイトでエンコードされ、それぞれ6ビット、14ビット、または30ビットの値をエンコードできることを意味します。"
    },
    {
      "indent": 10,
      "text": "+========+=========+=============+=======+============+\n| Prefix | Length  | Usable Bits | Min   | Max        |\n+========+=========+=============+=======+============+\n| 00     | 1       | 6           | 0     | 63         |\n+--------+---------+-------------+-------+------------+\n| 01     | 2       | 14          | 64    | 16383      |\n+--------+---------+-------------+-------+------------+\n| 10     | 4       | 30          | 16384 | 1073741823 |\n+--------+---------+-------------+-------+------------+\n| 11     | invalid | -           | -     | -          |\n+--------+---------+-------------+-------+------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Table 1: Summary of Integer Encodings",
      "ja": "表1：整数エンコーディングの概要"
    },
    {
      "indent": 3,
      "text": "Vectors that start with the prefix \"11\" are invalid and MUST be rejected.",
      "ja": "「11」で始まるベクトルは無効であり、拒否されなければなりません。"
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば:"
    },
    {
      "indent": 6,
      "text": "* The four-byte length value 0x9d7f3e7d decodes to 494878333.",
      "ja": "* 4バイトの長さ値0x9d7f3e7dは494878333にデコードされます。"
    },
    {
      "indent": 6,
      "text": "* The two-byte length value 0x7bbd decodes to 15293.",
      "ja": "* 2バイトの長さ値0x7bbdは15293にデコードされます。"
    },
    {
      "indent": 6,
      "text": "* The single-byte length value 0x25 decodes to 37.",
      "ja": "* 単一バイトの長さ値0x25は、37にデコードされます。"
    },
    {
      "indent": 3,
      "text": "The following figure adapts the pseudocode provided in [RFC9000] to add a check for minimum-length encoding:",
      "ja": "次の図は、[RFC9000]で提供された疑似コードを適応して、最小長エンコーディングのチェックを追加します。"
    },
    {
      "indent": 3,
      "text": "ReadVarint(data):\n  // The length of variable-length integers is encoded in the\n  // first two bits of the first byte.\n  v = data.next_byte()\n  prefix = v >> 6\n  if prefix == 3:\n    raise Exception('invalid variable length integer prefix')\n\n  length = 1 << prefix\n\n  // Once the length is known, remove these bits and read any\n  // remaining bytes.\n  v = v & 0x3f\n  repeat length-1 times:\n    v = (v << 8) + data.next_byte()\n\n  // Check if the value would fit in half the provided length.\n  if prefix >= 1 && v < (1 << (8*(length/2) - 2)):\n    raise Exception('minimum encoding was not used')\n\n  return v",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The use of variable-size integers for vector lengths allows vectors to grow very large, up to 2^30 bytes. Implementations should take care not to allow vectors to overflow available storage. To facilitate debugging of potential interoperability problems, implementations SHOULD provide a clear error when such an overflow condition occurs.",
      "ja": "可変サイズの整数を使用してベクトルの長さを拡張することで、ベクトルを非常に大きく（最大2^30バイトまで）成長させることができます。実装では、ベクトルが利用可能なストレージをオーバーフローさせないように注意を払う必要があります。潜在的な相互運用性の問題のデバッグを容易にするために、実装はそのようなオーバーフロー状態が発生した場合に明確なエラーを提供するべきです。"
    },
    {
      "indent": 0,
      "text": "3. Protocol Overview",
      "section_title": true,
      "ja": "3. プロトコルの概要"
    },
    {
      "indent": 3,
      "text": "MLS is designed to operate in the context described in [MLS-ARCH]. In particular, we assume that the following services are provided:",
      "ja": "MLSは[MLS-ARCH]で説明された文脈で動作するように設計されています。特に、以下のサービスが提供されていると仮定しています。"
    },
    {
      "indent": 6,
      "text": "* An Authentication Service (AS) that enables group members to authenticate the credentials presented by other group members.",
      "ja": "* 他のグループメンバーが提示した資格情報を認証することを可能にする認証サービス（AS）。"
    },
    {
      "indent": 6,
      "text": "* A Delivery Service (DS) that routes MLS messages among the participants in the protocol.",
      "ja": "* プロトコルの参加者間でMLSメッセージをルーティングする配信サービス（DS）。"
    },
    {
      "indent": 3,
      "text": "MLS assumes a trusted AS but a largely untrusted DS. Section 16.10 describes the impact of compromise or misbehavior of an AS. MLS is designed to protect the confidentiality and integrity of the group data even in the face of a compromised DS; in general, the DS is only expected to reliably deliver messages. Section 16.9 describes the impact of compromise or misbehavior of a DS.",
      "ja": "MLSは信頼されたASを前提としていますが、主に信頼されていないDSを前提としています。セクション16.10では、ASの侵害や不正行為の影響について説明しています。MLSは、総じてDSがメッセージを信頼性を持って配信することが期待されるだけであり、侵害されたDSに直面してもグループデータの機密性と整合性を保護するよう設計されています。セクション16.9では、DSの侵害や不正行為の影響について説明しています。"
    },
    {
      "indent": 3,
      "text": "The core functionality of MLS is continuous group authenticated key exchange (AKE). As with other authenticated key exchange protocols (such as TLS), the participants in the protocol agree on a common secret value, and each participant can verify the identity of the other participants. That secret can then be used to protect messages sent from one participant in the group to the other participants using the MLS framing layer or can be exported for use with other protocols. MLS provides group AKE in the sense that there can be more than two participants in the protocol, and continuous group AKE in the sense that the set of participants in the protocol can change over time.",
      "ja": "MLSの中核機能は連続的なグループ認証キー交換（AKE）です。TLSなどの他の認証キー交換プロトコルと同様に、プロトコルの参加者は共通の秘密値に合意し、各参加者は他の参加者の正体を確認できます。その秘密は、MLSフレーミング層を使用してグループ内の1人の参加者から他の参加者に送信されるメッセージを保護するために使用されるか、他のプロトコルで使用するためにエクスポートされることができます。MLSは、プロトコルに2人以上の参加者がいることを意味するグループAKEを提供し、プロトコルの参加者のセットが時間とともに変化することを意味する連続的なグループAKEを提供します。"
    },
    {
      "indent": 3,
      "text": "The core organizing principles of MLS are _groups_ and _epochs_. A group represents a logical collection of clients that share a common secret value at any given time. The history of a group is divided into a linear sequence of epochs. In each epoch, a set of authenticated _members_ agree on an _epoch secret_ that is known only to the members of the group in that epoch. The set of members involved in the group can change from one epoch to the next, and MLS ensures that only the members in the current epoch have access to the epoch secret. From the epoch secret, members derive further shared secrets for message encryption, group membership authentication, and so on.",
      "ja": "MLSの中核となる組織原則は「グループ」と「エポック」です。グループは、任意の時点で共通の秘密値を共有するクライアントの論理的な集合を表します。グループの履歴は、直線的なエポックの連続に分割されます。各エポックでは、認証された「メンバー」の集合が、そのエポックのグループのメンバーだけが知っている「エポック秘密」に合意します。グループに関与するメンバーの集合は、次のエポックに移る際に変更される可能性があり、MLSは現在のエポックのメンバーだけがエポック秘密にアクセスできることを保証します。エポック秘密から、メンバーはメッセージの暗号化、グループメンバーシップの認証などのためのさらなる共有秘密を導出します。"
    },
    {
      "indent": 3,
      "text": "The creator of an MLS group creates the group's first epoch unilaterally, with no protocol interactions. Thereafter, the members of the group advance their shared cryptographic state from one epoch to another by exchanging MLS messages.",
      "ja": "MLSグループの作成者は、プロトコルの相互作用なしに、グループの最初のエポックを一方的に作成します。その後、グループのメンバーはMLSメッセージを交換することで、共有された暗号状態を1つのエポックから別のエポックに進めます。"
    },
    {
      "indent": 6,
      "text": "* A _KeyPackage_ object describes a client's capabilities and provides keys that can be used to add the client to a group.",
      "ja": "* _KeyPackage_ オブジェクトは、クライアントの機能を記述し、クライアントをグループに追加するために使用できるキーを提供します。"
    },
    {
      "indent": 6,
      "text": "* A _Proposal_ message proposes a change to be made in the next epoch, such as adding or removing a member.",
      "ja": "* _Proposal_ メッセージは、次のエポックで行われる変更を提案します。例えば、メンバーの追加や削除などです。"
    },
    {
      "indent": 6,
      "text": "* A _Commit_ message initiates a new epoch by instructing members of the group to implement a collection of proposals.",
      "ja": "* _Commit_ メッセージは、グループのメンバーに一連の提案を実装するよう指示して、新しい時代を開始します。"
    },
    {
      "indent": 6,
      "text": "* A _Welcome_ message provides a new member to the group with the information to initialize their state for the epoch in which they were added or in which they want to add themselves to the group.",
      "ja": "* _Welcome_ メッセージは、グループの新しいメンバーに、自分が追加されたエポックまたは自分自身をグループに追加したいエポックの状態を初期化するための情報を提供します。"
    },
    {
      "indent": 3,
      "text": "KeyPackage and Welcome messages are used to initiate a group or introduce new members, so they are exchanged between group members and clients not yet in the group. A client publishes a KeyPackage via the DS, thus enabling other clients to add it to groups. When a group member wants to add a new member to a group, it uses the new member's KeyPackage to add them and constructs a Welcome message with which the new member can initialize their local state.",
      "ja": "KeyPackageとWelcomeメッセージは、グループを開始したり新しいメンバーを紹介するために使用されるため、グループメンバーとまだグループにいないクライアントの間で交換されます。クライアントはDSを介してKeyPackageを公開し、他のクライアントがそれをグループに追加できるようにします。グループメンバーが新しいメンバーをグループに追加したい場合、新しいメンバーのKeyPackageを使用して追加し、新しいメンバーがローカル状態を初期化できるようにWelcomeメッセージを構築します。"
    },
    {
      "indent": 3,
      "text": "Proposal and Commit messages are sent from one member of a group to the others. MLS provides a common framing layer for sending messages within a group: A _PublicMessage_ provides sender authentication for unencrypted Proposal and Commit messages. A _PrivateMessage_ provides encryption and authentication for both Proposal/Commit messages as well as any application data.",
      "ja": "提案とコミットメッセージは、グループの一員から他のメンバーに送信されます。MLSは、グループ内でメッセージを送信するための共通のフレーミングレイヤーを提供します：_PublicMessage_は、暗号化されていない提案とコミットメッセージの送信者認証を提供します。_PrivateMessage_は、提案/コミットメッセージだけでなく、アプリケーションデータに対する暗号化と認証を提供します。"
    },
    {
      "indent": 0,
      "text": "3.1. Cryptographic State and Evolution",
      "section_title": true,
      "ja": "3.1. 暗号状態と進化"
    },
    {
      "indent": 3,
      "text": "The cryptographic state at the core of MLS is divided into three areas of responsibility:",
      "ja": "MLSの中核となる暗号状態は、3つの責任領域に分かれています。"
    },
    {
      "indent": 3,
      "text": "                          .-    ...    -.\n                         |               |\n                         |       |       |\n                         |       |       | Key Schedule\n                         |       V       |\n                         |  epoch_secret |\n.                        |       |       |                             .\n|\\ Ratchet               |       |       |                     Secret /|\n| \\ Tree                 |       |       |                      Tree / |\n|  \\                     |       |       |                          /  |\n|   \\                    |       V       |                         /   |\n|    +--> commit_secret --> epoch_secret --> encryption_secret -->+    |\n|   /                    |       |       |                         \\   |\n|  /                     |       |       |                          \\  |\n| /                      |       |       |                           \\ |\n|/                       |       |       |                            \\|\n'                        |       V       |                             '\n                         |  epoch_secret |\n                         |       |       |\n                         |       |       |\n                         |       V       |\n                         |               |\n                          '-    ...    -'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 1: Overview of MLS Group Evolution",
      "ja": "図1：MLSグループの進化概要"
    },
    {
      "indent": 6,
      "text": "* A _ratchet tree_ that represents the membership of the group, providing group members a way to authenticate each other and efficiently encrypt messages to subsets of the group. Each epoch has a distinct ratchet tree. It seeds the _key schedule_.",
      "ja": "* グループのメンバーシップを表す _ラチェットツリー_ は、グループメンバーがお互いを認証し、グループのサブセットに効率的にメッセージを暗号化する方法を提供します。各エポックには異なるラチェットツリーがあります。それは _鍵スケジュール_ に種を蒔きます。"
    },
    {
      "indent": 6,
      "text": "* A _key schedule_ that describes the chain of key derivations used to progress from epoch to epoch (mainly using the _init_secret_ and _epoch_secret_), as well as the derivation of a variety of other secrets (see Table 4). For example:",
      "ja": "* エポックからエポックへ進むために使用される鍵の派生の連鎖を記述する「鍵スケジュール」（主に「init_secret」と「epoch_secret」を使用）、およびさまざまな他の秘密情報の派生を記述します（表4を参照）。例えば："
    },
    {
      "indent": 12,
      "text": "- An _encryption secret_ that is used to initialize the secret tree for the epoch.",
      "ja": "- エポックのための秘密ツリーを初期化するために使用される「暗号化秘密」。"
    },
    {
      "indent": 12,
      "text": "- An _exporter secret_ that allows other protocols to leverage MLS as a generic authenticated group key exchange.",
      "ja": "- 他のプロトコルがMLSを一般的な認証済みグループ鍵交換として活用できるようにする「エクスポーターシークレット」。"
    },
    {
      "indent": 12,
      "text": "- A _resumption secret_ that members can use to prove their membership in the group, e.g., when creating a subgroup or a successor group.",
      "ja": "- メンバーがグループへの所属を証明するために使用できる「再開秘密」、例えば、サブグループや後継グループを作成する際に使用します。"
    },
    {
      "indent": 6,
      "text": "* A _secret tree_ derived from the key schedule that represents shared secrets used by the members of the group for encrypting and authenticating messages. Each epoch has a distinct secret tree.",
      "ja": "* グループのメンバーがメッセージを暗号化および認証するために使用される共有秘密を表すキースケジュールから派生した「秘密ツリー」。各エポックには異なる秘密ツリーがあります。"
    },
    {
      "indent": 3,
      "text": "Each member of the group maintains a partial view of these components of the group's state. MLS messages are used to initialize these views and keep them in sync as the group transitions between epochs.",
      "ja": "グループの各メンバーは、グループの状態のこれらのコンポーネントの部分的なビューを維持します。MLSメッセージは、これらのビューを初期化し、グループがエポック間を移行する際に同期させるために使用されます。"
    },
    {
      "indent": 3,
      "text": "Each new epoch is initiated with a Commit message. The Commit instructs existing members of the group to update their views of the ratchet tree by applying a set of Proposals, and uses the updated ratchet tree to distribute fresh entropy to the group. This fresh entropy is provided only to members in the new epoch and not to members who have been removed. Commits thus maintain the property that the epoch secret is confidential to the members in the current epoch.",
      "ja": "新しいエポックは、Commit メッセージで開始されます。Commit は、グループの既存メンバーに、一連の提案を適用してラチェットツリーのビューを更新するよう指示し、更新されたラチェットツリーを使用してグループに新鮮なエントロピーを配布します。この新鮮なエントロピーは、新しいエポックのメンバーにのみ提供され、削除されたメンバーには提供されません。したがって、Commits は、エポックの秘密が現在のエポックのメンバーに機密であるという特性を維持します。"
    },
    {
      "indent": 3,
      "text": "For each Commit that adds one or more members to the group, there are one or more corresponding Welcome messages. Each Welcome message provides new members with the information they need to initialize their views of the key schedule and ratchet tree, so that these views align with the views held by other members of the group in this epoch.",
      "ja": "グループに1人以上のメンバーを追加するコミットごとに、1つ以上の対応する歓迎メッセージがあります。各歓迎メッセージは、新しいメンバーが主要なスケジュールとラチェットツリーのビューを初期化するために必要な情報を提供し、これらのビューがこのエポックの他のメンバーのビューと一致するようにします。"
    },
    {
      "indent": 0,
      "text": "3.2. Example Protocol Execution",
      "section_title": true,
      "ja": "3.2. 例のプロトコル実行"
    },
    {
      "indent": 3,
      "text": "There are three major operations in the life of a group:",
      "ja": "グループの生活には3つの主要な活動があります："
    },
    {
      "indent": 6,
      "text": "* Adding a member, initiated by a current member;",
      "ja": "* 現在のメンバーによって開始されたメンバーの追加;"
    },
    {
      "indent": 6,
      "text": "* Updating the keys that represent a member in the tree; and",
      "ja": "* 木構造内のメンバーを表すキーを更新しています。"
    },
    {
      "indent": 6,
      "text": "* Removing a member.",
      "ja": "* メンバーを削除する。"
    },
    {
      "indent": 3,
      "text": "Each of these operations is \"proposed\" by sending a message of the corresponding type (Add / Update / Remove). The state of the group is not changed, however, until a Commit message is sent to provide the group with fresh entropy. In this section, we show each proposal being committed immediately, but in more advanced deployment cases, an application might gather several proposals before committing them all at once. In the illustrations below, we show the Proposal and Commit messages directly, while in reality they would be sent encapsulated in PublicMessage or PrivateMessage objects.",
      "ja": "これらの操作のそれぞれは、対応するタイプ（追加/更新/削除）のメッセージを送信することで「提案」されます。ただし、グループの状態は、新鮮なエントロピーを提供するためにコミットメッセージが送信されるまで変更されません。このセクションでは、各提案が直ちにコミットされる様子を示していますが、より高度な展開ケースでは、アプリケーションはすべてを一度にコミットする前に複数の提案を収集するかもしれません。以下の図では、提案とコミットメッセージを直接示していますが、実際にはPublicMessageまたはPrivateMessageオブジェクトにカプセル化されて送信されます。"
    },
    {
      "indent": 3,
      "text": "Before the initialization of a group, clients publish KeyPackages to a directory provided by the DS (see Figure 2).",
      "ja": "グループの初期化の前に、クライアントはDSによって提供されるディレクトリにKeyPackagesを公開します（図2を参照）。"
    },
    {
      "indent": 3,
      "text": "                                                  Delivery Service\n                                                          |\n                                                .--------' '--------.\n                                               |                     |\n                                                               Group\nA                B                C            Directory       Channel\n|                |                |                |              |\n| KeyPackageA    |                |                |              |\n+------------------------------------------------->|              |\n|                |                |                |              |\n|                | KeyPackageB    |                |              |\n|                +-------------------------------->|              |\n|                |                |                |              |\n|                |                | KeyPackageC    |              |\n|                |                +--------------->|              |\n|                |                |                |              |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 2: Clients A, B, and C publish KeyPackages to the directory",
      "ja": "図2：クライアントA、B、およびCはKeyPackagesをディレクトリに公開します。"
    },
    {
      "indent": 3,
      "text": "Figure 3 shows how these pre-published KeyPackages are used to create a group. When client A wants to establish a group with clients B and C, it first initializes a group state containing only itself and downloads KeyPackages for B and C. For each member, A generates an Add proposal and a Commit message to add that member and then broadcasts the two messages to the group. Client A also generates a Welcome message and sends it directly to the new member (there's no need to send it to the group). Only after A has received its Commit message back from the Delivery Service does it update its state to reflect the new member's addition.",
      "ja": "図3は、これらの事前公開されたKeyPackagesがグループを作成する際にどのように使用されるかを示しています。クライアントAがクライアントBとCとグループを設立したい場合、まず自分だけを含むグループ状態を初期化し、BとCのKeyPackagesをダウンロードします。各メンバーに対して、Aはそのメンバーを追加するためのAdd提案とCommitメッセージを生成し、それらの2つのメッセージをグループにブロードキャストします。クライアントAはまた、Welcomeメッセージを生成し、新しいメンバーに直接送信します（グループに送信する必要はありません）。Aが配信サービスから自分のCommitメッセージを受け取った後に、新しいメンバーの追加を反映するために状態を更新します。"
    },
    {
      "indent": 3,
      "text": "Once A has updated its state, the new member has processed the Welcome, and any other group members have processed the Commit, they will all have consistent representations of the group state, including a group secret that is known only to the members the group. The new member will be able to read and send new messages to the group, but messages sent before they were added to the group will not be accessible.",
      "ja": "Aが状態を更新した後、新しいメンバーがWelcomeを処理し、他のグループメンバーがCommitを処理したら、グループ状態の一貫した表現を持つようになります。グループの秘密は、グループのメンバーだけが知っているものとなります。新しいメンバーはグループに新しいメッセージを読み取り、送信することができますが、グループに追加される前に送信されたメッセージにはアクセスできません。"
    },
    {
      "indent": 3,
      "text": "                                                               Group\nA              B              C          Directory            Channel\n|              |              |              |                   |\n|         KeyPackageB, KeyPackageC           |                   |\n|<-------------------------------------------+                   |\n|              |              |              |                   |\n|              |              |              | Add(A->AB)        |\n|              |              |              | Commit(Add)       |\n+--------------------------------------------------------------->|\n|              |              |              |                   |\n|  Welcome(B)  |              |              |                   |\n+------------->|              |              |                   |\n|              |              |              |                   |\n|              |              |              | Add(A->AB)        |\n|              |              |              | Commit(Add)       |\n|<---------------------------------------------------------------+\n|              |              |              |                   |\n|              |              |              |                   |\n|              |              |              | Add(AB->ABC)      |\n|              |              |              | Commit(Add)       |\n+--------------------------------------------------------------->|\n|              |              |              |                   |\n|              |  Welcome(C)  |              |                   |\n+---------------------------->|              |                   |\n|              |              |              |                   |\n|              |              |              | Add(AB->ABC)      |\n|              |              |              | Commit(Add)       |\n|<---------------------------------------------------------------+\n|              |<------------------------------------------------+\n|              |              |              |                   |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Figure 3: Client A creates a group with clients B and C",
      "ja": "図3：クライアントAがクライアントBとCとのグループを作成します。"
    },
    {
      "indent": 3,
      "text": "Subsequent additions of group members proceed in the same way. Any member of the group can download a KeyPackage for a new client, broadcast Add and Commit messages that the current group will use to update their state, and send a Welcome message that the new client can use to initialize its state and join the group.",
      "ja": "グループメンバーの追加は同じ方法で進行します。グループのメンバーは新しいクライアントのためのKeyPackageをダウンロードし、現在のグループが状態を更新するために使用するAddおよびCommitメッセージをブロードキャストし、新しいクライアントが状態を初期化してグループに参加するために使用できるWelcomeメッセージを送信できます。"
    },
    {
      "indent": 3,
      "text": "To enforce the forward secrecy and post-compromise security of messages, each member periodically updates the keys that represent them to the group. A member does this by sending a Commit (possibly with no proposals) or by sending an Update message that is committed by another member (see Figure 4). Once the other members of the group have processed these messages, the group's secrets will be unknown to an attacker that had compromised the secrets corresponding to the sender's leaf in the tree. At the end of the scenario shown in Figure 4, the group has post-compromise security with respect to both A and B.",
      "ja": "メッセージの前方秘匿性と攻撃後のセキュリティを強化するために、各メンバーは定期的にグループを表す鍵を更新します。メンバーは、コミット（提案がない場合もあります）を送信するか、他のメンバーによってコミットされたアップデートメッセージを送信することでこれを行います（図4を参照）。グループの他のメンバーがこれらのメッセージを処理した後、グループの秘密は、ツリー内の送信者のリーフに対応する秘密が侵害された攻撃者には不明になります。図4に示されているシナリオの終わりには、グループはAとBの両方に対して攻撃後のセキュリティを持っています。"
    },
    {
      "indent": 3,
      "text": "Update messages SHOULD be sent at regular intervals of time as long as the group is active, and members that don't update SHOULD eventually be removed from the group. It's left to the application to determine an appropriate amount of time between Updates. Since the purpose of sending an Update is to proactively constrain a compromise window, the right frequency is usually on the order of hours or days, not milliseconds. For example, an application might send an Update each time a member sends an application message after receiving any message from another member, or daily if no application messages are sent.",
      "ja": "更新メッセージは、グループがアクティブである限り、定期的な間隔で送信されるべきであり、更新を行わないメンバーは最終的にグループから削除されるべきです。更新の間隔はアプリケーションが適切な時間を決定することに任されています。更新を送信する目的は、積極的に妥協ウィンドウを制限することであるため、適切な頻度は通常、時間や日数の単位であり、ミリ秒ではありません。例えば、アプリケーションは、メンバーが他のメンバーからメッセージを受信した後にアプリケーションメッセージを送信するたびに更新を送信するか、アプリケーションメッセージが送信されない場合は毎日更新を送信するかもしれません。"
    },
    {
      "indent": 3,
      "text": "The MLS architecture recommends that MLS be operated over a secure transport (see Section 7.1 of [MLS-ARCH]). Such transport protocols will typically provide functions such as congestion control that manage the impact of an MLS-using application on other applications sharing the same network. Applications should take care that they do not send MLS messages at a rate that will cause problems such as network congestion, especially if they are not following the above recommendation (e.g., sending MLS directly over UDP instead).",
      "ja": "MLSアーキテクチャは、MLSが安全なトランスポート上で運用されることを推奨しています（[MLS-ARCH]のセクション7.1を参照）。このようなトランスポートプロトコルは、通常、MLSを使用するアプリケーションが同じネットワークを共有する他のアプリケーションに与える影響を管理する過負荷制御などの機能を提供します。アプリケーションは、ネットワークの過負荷などの問題を引き起こす可能性のあるレートでMLSメッセージを送信しないように注意を払う必要があります、特に上記の推奨事項に従っていない場合（例：MLSを直接UDP経由で送信する場合など）。"
    },
    {
      "indent": 3,
      "text": "                                                          Group\nA              B     ...      Z          Directory        Channel\n|              |              |              |              |\n|              | Update(B)    |              |              |\n|              +------------------------------------------->|\n|              |              |              | Update(B)    |\n|<----------------------------------------------------------+\n|              |<-------------------------------------------+\n|              |              |<----------------------------+\n|              |              |              |              |\n| Commit(Upd)  |              |              |              |\n+---------------------------------------------------------->|\n|              |              |              | Commit(Upd)  |\n|<----------------------------------------------------------+\n|              |<-------------------------------------------+\n|              |              |<----------------------------+\n|              |              |              |              |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 4: Client B proposes to update its key, and client A commits the proposal",
      "ja": "図4：クライアントBはキーを更新する提案をし、クライアントAはその提案を承認します。"
    },
    {
      "indent": 3,
      "text": "Members are removed from the group in a similar way, as shown in Figure 5. Any member of the group can send a Remove proposal followed by a Commit message. The Commit message provides new entropy to all members of the group except the removed member. This new entropy is added to the epoch secret for the new epoch so that it is not known to the removed member. Note that this does not necessarily imply that any member is actually allowed to evict other members; groups can enforce access control policies on top of these basic mechanisms.",
      "ja": "メンバーは、図5に示されているように、同様の方法でグループから削除されます。グループのメンバーは誰でも、削除提案を送信した後にコミットメッセージを送ることができます。コミットメッセージは、削除されたメンバーを除くすべてのグループのメンバーに新しいエントロピーを提供します。この新しいエントロピーは、新しいエポックのためのエポックシークレットに追加されるため、削除されたメンバーには知られません。なお、これは必ずしもどのメンバーも他のメンバーを追放することを許可されているということを意味するものではありません。グループは、これらの基本的なメカニズムの上にアクセス制御ポリシーを強制することができます。"
    },
    {
      "indent": 3,
      "text": "                                                          Group\nA              B     ...      Z          Directory       Channel\n|              |              |              |              |\n|              |              | Remove(B)    |              |\n|              |              | Commit(Rem)  |              |\n|              |              +---------------------------->|\n|              |              |              |              |\n|              |              |              | Remove(B)    |\n|              |              |              | Commit(Rem)  |\n|<----------------------------------------------------------+\n|              |<-------------------------------------------+\n|              |              |<----------------------------+\n|              |              |              |              |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 5: Client Z removes client B from the group",
      "ja": "図5：クライアントZがクライアントBをグループから削除します。"
    },
    {
      "indent": 3,
      "text": "Note that the flows in this section are examples; applications can arrange message flows in other ways. For example:",
      "ja": "このセクションのフローは例です。アプリケーションはメッセージのフローを他の方法で配置することができます。例えば："
    },
    {
      "indent": 6,
      "text": "* Welcome messages don't necessarily need to be sent directly to new joiners. Since they are encrypted to new joiners, they could be distributed more broadly, say if the application only had access to a broadcast channel for the group.",
      "ja": "* ウェルカムメッセージは必ずしも新規参加者に直接送信する必要はありません。新規参加者には暗号化されているため、グループに対して放送チャンネルへのアクセスしかない場合、より広く配布される可能性があります。"
    },
    {
      "indent": 6,
      "text": "* Proposal messages don't need to be immediately sent to all group members. They need to be available to the committer before generating a Commit, and to other members before processing the Commit.",
      "ja": "* 提案メッセージはすぐにすべてのグループメンバーに送信する必要はありません。コミットを生成する前にコミッターが利用できる必要があり、他のメンバーがコミットを処理する前に利用できる必要があります。"
    },
    {
      "indent": 6,
      "text": "* The sender of a Commit doesn't necessarily have to wait to receive its own Commit back before advancing its state. It only needs to know that its Commit will be the next one applied by the group, say based on a promise from an orchestration server.",
      "ja": "* Commitの送信者は、自分のCommitを受け取るのを待つ必要はありません。状態を進める前に。グループによって適用される次のCommitが自分のものであることを知っていれば十分であり、たとえばオーケストレーションサーバーからの約束に基づいているとします。"
    },
    {
      "indent": 0,
      "text": "3.3. External Joins",
      "section_title": true,
      "ja": "3.3. 外部結合"
    },
    {
      "indent": 3,
      "text": "In addition to the Welcome-based flow for adding a new member to the group, it is also possible for a new member to join by means of an \"external Commit\". This mechanism can be used when the existing members don't have a KeyPackage for the new member, for example, in the case of an \"open\" group that can be joined by new members without asking permission from existing members.",
      "ja": "新しいメンバーをグループに追加するためのウェルカムベースのフローに加えて、新しいメンバーが「外部コミット」を通じて参加することも可能です。このメカニズムは、既存のメンバーが新しいメンバーのためのキーパッケージを持っていない場合に使用できます。例えば、「オープン」グループの場合、既存のメンバーの許可を求めることなく新しいメンバーが参加できる場合があります。"
    },
    {
      "indent": 3,
      "text": "Figure 6 shows a typical message flow for an external join. To enable a new member to join the group in this way, a member of the group (A, B) publishes a GroupInfo object that includes the GroupContext for the group as well as a public key that can be used to encrypt a secret to the existing members of the group. When the new member Z wishes to join, they download the GroupInfo object and use it to form a Commit of a special form that adds Z to the group (as detailed in Section 12.4.3.2). The existing members of the group process this external Commit in a similar way to a normal Commit, advancing to a new epoch in which Z is now a member of the group.",
      "ja": "図6は外部結合の典型的なメッセージフローを示しています。この方法で新しいメンバーがグループに参加できるようにするために、グループのメンバー（A、B）は、グループのGroupContextと、グループの既存メンバーに秘密を暗号化するために使用できる公開鍵を含むGroupInfoオブジェクトを公開します。新しいメンバーZが参加したいとき、彼らはGroupInfoオブジェクトをダウンロードし、Zをグループに追加する特別な形式のCommitを形成するために使用します（詳細は12.4.3.2節に記載）。グループの既存メンバーは、この外部Commitを通常のCommitと同様の方法で処理し、Zがグループのメンバーである新しいエポックに進みます。"
    },
    {
      "indent": 3,
      "text": "                                                          Group\nA              B              Z          Directory        Channel\n|              |              |              |              |\n| GroupInfo    |              |              |              |\n+------------------------------------------->|              |\n|              |              | GroupInfo    |              |\n|              |              |<-------------+              |\n|              |              |              |              |\n|              |              | Commit(ExtZ) |              |\n|              |              +---------------------------->|\n|              |              |              | Commit(ExtZ) |\n|<----------------------------------------------------------+\n|              |<-------------------------------------------+\n|              |              |<----------------------------+\n|              |              |              |              |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 6: Client A publishes a GroupInfo object, and Client Z uses it to join the group",
      "ja": "図6：クライアントAがGroupInfoオブジェクトを公開し、クライアントZがそれを使用してグループに参加します。"
    },
    {
      "indent": 0,
      "text": "3.4. Relationships between Epochs",
      "section_title": true,
      "ja": "3.4. 時代間の関係"
    },
    {
      "indent": 3,
      "text": "A group has a single linear sequence of epochs. Groups and epochs are generally independent of one another. However, it can sometimes be useful to link epochs cryptographically, either within a group or across groups. MLS derives a resumption pre-shared key (PSK) from each epoch to allow entropy extracted from one epoch to be injected into a future epoch. A group member that wishes to inject a PSK issues a PreSharedKey proposal (Section 12.1.4) describing the PSK to be injected. When this proposal is committed, the corresponding PSK will be incorporated into the key schedule as described in Section 8.4.",
      "ja": "グループには単一の時代の線形シーケンスがあります。 グループと時代は一般的には互いに独立しています。 ただし、時々、時代を暗号的にリンクすることが役立つことがあります。 これは、MLSが各時代から再開事前共有キー（PSK）を導出し、1つの時代から抽出されたエントロピーを将来の時代に注入することを可能にします。 PSKを注入したいグループメンバーは、注入するPSKを記述したPreSharedKey提案（12.1.4節）を発行します。 この提案が確定されると、対応するPSKは、8.4節で説明されているように、キースケジュールに組み込まれます。"
    },
    {
      "indent": 3,
      "text": "Linking epochs in this way guarantees that members entering the new epoch agree on a key if and only if they were members of the group during the epoch from which the resumption key was extracted.",
      "ja": "この方法でエポックをリンクさせることにより、新しいエポックに参加するメンバーが、再開キーが抽出されたエポック中にグループのメンバーであった場合にのみ、キーに同意することが保証されます。"
    },
    {
      "indent": 3,
      "text": "MLS supports two ways to tie a new group to an existing group, which are illustrated in Figures 7 and 8. Reinitialization closes one group and creates a new group comprising the same members with different parameters. Branching starts a new group with a subset of the original group's participants (with no effect on the original group). In both cases, the new group is linked to the old group via a resumption PSK.",
      "ja": "MLSは、既存のグループに新しいグループを関連付ける2つの方法をサポートしており、それは図7と図8で示されています。再初期化は1つのグループを閉じ、異なるパラメータを持つ同じメンバーからなる新しいグループを作成します。ブランチングは、元のグループの参加者のサブセットで新しいグループを開始します（元のグループに影響はありません）。どちらの場合も、新しいグループは再開PSKを介して古いグループにリンクされています。"
    },
    {
      "indent": 3,
      "text": "epoch_A_[n-1]\n     |\n     |\n     |<-- ReInit\n     |\n     V\nepoch_A_[n]           epoch_B_[0]\n     .                     |\n     .  PSK(usage=reinit)  |\n     .....................>|\n                           |\n                           V\n                      epoch_B_[1]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 7: Reinitializing a Group",
      "ja": "図7：グループの再初期化"
    },
    {
      "indent": 3,
      "text": "epoch_A_[n]           epoch_B_[0]\n     |                     |\n     |  PSK(usage=branch)  |\n     |....................>|\n     |                     |\n     V                     V\nepoch_A_[n+1]         epoch_B_[1]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "Figure 8: Branching a Group",
      "ja": "図8：グループの分岐"
    },
    {
      "indent": 3,
      "text": "Applications may also choose to use resumption PSKs to link epochs in other ways. For example, Figure 9 shows a case where a resumption PSK from epoch n is injected into epoch n+k. This demonstrates that the members of the group at epoch n+k were also members at epoch n, irrespective of any changes to these members' keys due to Updates or Commits.",
      "ja": "アプリケーションは、他の方法でエポックをリンクするために再開PSKを使用することも選択できます。たとえば、図9は、エポックnからの再開PSKがエポックn+kに挿入されるケースを示しています。これにより、エポックn+kのグループのメンバーが、アップデートやコミットによるこれらのメンバーのキーの変更に関係なく、エポックnでもメンバーであったことが示されます。"
    },
    {
      "indent": 3,
      "text": "epoch_A_[n]\n     |\n     |  PSK(usage=application)\n     |.....................\n     |                    .\n     |                    .\n    ...                  ...\n     |                    .\n     |                    .\n     V                    .\nepoch_A_[n+k-1]           .\n     |                    .\n     |                    .\n     |<....................\n     |\n     V\nepoch_A_[n+k]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "Figure 9: Reinjecting Entropy from an Earlier Epoch",
      "ja": "図9：以前のエポックからエントロピーを再注入"
    },
    {
      "indent": 0,
      "text": "4. Ratchet Tree Concepts",
      "section_title": true,
      "ja": "4. ラチェットツリーコンセプト"
    },
    {
      "indent": 3,
      "text": "The protocol uses \"ratchet trees\" for deriving shared secrets among a group of clients. A ratchet tree is an arrangement of secrets and key pairs among the members of a group in a way that allows for secrets to be efficiently updated to reflect changes in the group.",
      "ja": "プロトコルは、クライアントグループの間で共有される秘密を導出するために「ラチェットツリー」を使用します。 ラチェットツリーは、グループのメンバー間で秘密と鍵のペアが配置されたものであり、グループ内の変更を反映するために効率的に秘密を更新できるようになっています。"
    },
    {
      "indent": 3,
      "text": "Ratchet trees allow a group to efficiently remove any member by encrypting new entropy to a subset of the group. A ratchet tree assigns shared keys to subgroups of the overall group, so that, for example, encrypting to all but one member of the group requires only log(N) encryptions to subtrees, instead of the N-1 encryptions that would be needed to encrypt to each participant individually (where N is the number of members in the group).",
      "ja": "ラチェットツリーは、グループが新しいエントロピーを一部のグループに暗号化することで、効率的にメンバーを取り除くことを可能にします。ラチェットツリーは、全体のグループのサブグループに共有キーを割り当てるため、例えば、グループの一部のメンバーを除いて暗号化する場合、個々の参加者に暗号化するために必要なN-1の暗号化ではなく、サブツリーへのlog(N)の暗号化のみが必要です（ここで、Nはグループのメンバー数です）。"
    },
    {
      "indent": 3,
      "text": "This remove operation allows MLS to efficiently achieve post-compromise security. In an Update proposal or a full Commit message, an old (possibly compromised) representation of a member is efficiently removed from the group and replaced with a freshly generated instance.",
      "ja": "この削除操作により、MLSは効率的にポストコンプロマイズセキュリティを実現できます。更新提案または完全なコミットメッセージにおいて、メンバーの古い（可能性があるが、侵害されている可能性がある）表現が効率的にグループから削除され、新しく生成されたインスタンスで置き換えられます。"
    },
    {
      "indent": 0,
      "text": "4.1. Ratchet Tree Terminology",
      "section_title": true,
      "ja": "4.1. ラチェットツリー用語"
    },
    {
      "indent": 3,
      "text": "Trees consist of _nodes_. A node is a _leaf_ if it has no children; otherwise, it is a _parent_. All parents in our trees have precisely two children, a _left_ child and a _right_ child. A node is the _root_ of a tree if it has no parent, and _intermediate_ if it has both children and a parent. The _descendants_ of a node are that node's children, and the descendants of its children. We say a tree _contains_ a node if that node is a descendant of the root of the tree, or if the node itself is the root of the tree. Nodes are _siblings_ if they share the same parent.",
      "ja": "木は _ノード_ で構成されています。ノードが子を持たない場合、それは _葉_ です。それ以外の場合、それは _親_ です。私たちの木のすべての親は正確に2つの子、_左_の子と_右_の子を持っています。ノードが親を持たない場合、そのノードは木の _根_ であり、子と親の両方を持つ場合は _中間_ です。ノードの _子孫_ はそのノードの子と、その子の子孫です。ツリーがノードを _含む_ と言うのは、そのノードがツリーのルートの子孫である場合、またはノード自体がツリーのルートである場合です。ノードが同じ親を共有している場合、それらは _兄弟_ です。"
    },
    {
      "indent": 3,
      "text": "A _subtree_ of a tree is the tree given by any node (the _head_ of the subtree) and its descendants. The _size_ of a tree or subtree is the number of leaf nodes it contains. For a given parent node, its _left subtree_ is the subtree with its left child as head and its _right subtree_ is the subtree with its right child as head.",
      "ja": "木の _部分木_ とは、任意のノード（部分木の _根_）とその子孫からなる木です。木や部分木の _サイズ_ とは、含まれる葉ノードの数です。与えられた親ノードに対して、その _左部分木_ は左の子を根とする部分木であり、_右部分木_ は右の子を根とする部分木です。"
    },
    {
      "indent": 3,
      "text": "Every tree used in this protocol is a perfect binary tree, that is, a complete balanced binary tree with 2^d leaves all at the same depth d. This structure is unique for a given depth d.",
      "ja": "このプロトコルで使用されるすべての木は完全なバイナリ木であり、つまり、深さdで全ての葉が2^d個ある完全なバランスの取れたバイナリ木です。この構造は特定の深さdに対してユニークです。"
    },
    {
      "indent": 3,
      "text": "There are multiple ways that an implementation might represent a ratchet tree in memory. A convenient property of left-balanced binary trees (including the complete trees used here) is that they can be represented as an array of nodes, with node relationships computed based on the nodes' indices in the array. A more traditional representation based on linked node objects may also be used. Appendices C and D provide some details on how to implement the tree operations required for MLS in these representations. MLS places no requirements on implementations' internal representations of ratchet trees. An implementation may use any tree representation and associated algorithms, as long as they produce correct protocol messages.",
      "ja": "実装がメモリ内でラチェットツリーを表現する方法は複数あります。ここで使用されている完全ツリーを含む左バランスのバイナリツリーの便利な特性は、ノードの配列として表現できることです。ノード間の関係は、配列内のノードのインデックスに基づいて計算されます。リンクされたノードオブジェクトに基づくより伝統的な表現も使用できます。付録CおよびDでは、これらの表現でMLSに必要なツリー操作を実装する方法について詳細が提供されています。MLSは、ラチェットツリーの内部表現に対して要件を課しません。実装は、正しいプロトコルメッセージを生成する限り、任意のツリー表現と関連するアルゴリズムを使用できます。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Ratchet Tree Nodes",
      "section_title": true,
      "ja": "4.1.1. ラチェットツリーノード"
    },
    {
      "indent": 3,
      "text": "Each leaf node in a ratchet tree is given an _index_ (or _leaf index_), starting at 0 from the left to 2^d - 1 at the right (for a tree with 2^d leaves). A tree with 2^d leaves has 2^(d+1) - 1 nodes, including parent nodes.",
      "ja": "ラチェットツリーの各葉ノードには、左から0から2^d - 1までの _インデックス_（または _葉のインデックス_）が割り当てられます（2^d個の葉を持つツリーの場合）。2^d個の葉を持つツリーには、親ノードを含む2^(d+1) - 1個のノードがあります。"
    },
    {
      "indent": 3,
      "text": "Each node in a ratchet tree is either _blank_ (containing no value) or it holds an HPKE public key with some associated data:",
      "ja": "ラチェットツリー内の各ノードは、値を持たない（空白）か、関連データを持つHPKE公開鍵を保持しています。"
    },
    {
      "indent": 6,
      "text": "* A public key (for the HPKE scheme in use; see Section 5.1)",
      "ja": "* 使用中のHPKEスキームの公開鍵（セクション5.1を参照）"
    },
    {
      "indent": 6,
      "text": "* A credential (only for leaf nodes; see Section 5.3)",
      "ja": "* 資格情報（葉ノードのみ対象；セクション5.3を参照）"
    },
    {
      "indent": 6,
      "text": "* An ordered list of \"unmerged\" leaves (see Section 4.2)",
      "ja": "* 「未マージの葉の順序付きリスト（セクション4.2を参照）」"
    },
    {
      "indent": 6,
      "text": "* A hash of certain information about the node's parent, as of the last time the node was changed (see Section 7.9).",
      "ja": "* ノードの親に関する特定の情報のハッシュ。最後にノードが変更された時点のもの（セクション7.9を参照）。"
    },
    {
      "indent": 3,
      "text": "As described in Section 4.2, different members know different subsets of the set of private keys corresponding to the public keys in nodes in the tree. The private key corresponding to a parent node is known only to members at leaf nodes that are descendants of that node. The private key corresponding to a leaf node is known only to the member at that leaf node. A leaf node is _unmerged_ relative to one of its ancestor nodes if the member at the leaf node does not know the private key corresponding to the ancestor node.",
      "ja": "セクション4.2に記載されているように、異なるメンバーはツリー内のノードに対応する公開鍵に対応する秘密鍵のセットの異なるサブセットを知っています。親ノードに対応する秘密鍵は、そのノードの子孫である葉ノードのメンバーのみが知っています。葉ノードに対応する秘密鍵は、その葉ノードのメンバーのみが知っています。葉ノードは、その祖先ノードに対応する秘密鍵を知らない場合、その祖先ノードに対して「未統合」です。"
    },
    {
      "indent": 3,
      "text": "Every node, regardless of whether the node is blank or populated, has a corresponding _hash_ that summarizes the contents of the subtree below that node. The rules for computing these hashes are described in Section 7.8.",
      "ja": "すべてのノードは、そのノードが空白であるかどうかに関係なく、そのノードの下の部分木の内容を要約する対応するハッシュを持っています。これらのハッシュを計算するルールは、セクション7.8で説明されています。"
    },
    {
      "indent": 3,
      "text": "The _resolution_ of a node is an ordered list of non-blank nodes that collectively cover all non-blank descendants of the node. The resolution of the root contains the set of keys that are collectively necessary to encrypt to every node in the group. The resolution of a node is effectively a depth-first, left-first enumeration of the nearest non-blank nodes below the node:",
      "ja": "ノードの解決策は、ノードのすべての非空の子孫を網羅するために共同でカバーする非空のノードの順序付きリストです。ルートの解決策には、グループ内のすべてのノードを暗号化するために共同で必要なキーのセットが含まれています。ノードの解決策は、実質的には、ノードの下にある最も近い非空のノードを深さ優先、左から列挙したものです。"
    },
    {
      "indent": 6,
      "text": "* The resolution of a non-blank node comprises the node itself, followed by its list of unmerged leaves, if any.",
      "ja": "* 非空ノードの解像度は、ノード自体と、その未マージの葉のリスト（あれば）で構成されます。"
    },
    {
      "indent": 6,
      "text": "* The resolution of a blank leaf node is the empty list.",
      "ja": "* 空の葉ノードの解像度は空のリストです。"
    },
    {
      "indent": 6,
      "text": "* The resolution of a blank intermediate node is the result of concatenating the resolution of its left child with the resolution of its right child, in that order.",
      "ja": "* 空の中間ノードの解像度は、その左の子の解像度と右の子の解像度をその順序で連結した結果です。"
    },
    {
      "indent": 3,
      "text": "For example, consider the following subtree, where the _ character represents a blank node and unmerged leaves are indicated in square brackets:",
      "ja": "例えば、次の部分木を考えてみてください。ここで、_文字は空のノードを表し、マージされていない葉は角かっこで示されています。"
    },
    {
      "indent": 3,
      "text": "               ...\n               /\n              _\n        ______|______\n       /             \\\n      X[B]            _\n    __|__           __|__\n   /     \\         /     \\\n  _       _       Y       _\n / \\     / \\     / \\     / \\\nA   B   _   D   E   F   _   H\n\n0   1   2   3   4   5   6   7",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 10: A Tree with Blanks and Unmerged Leaves",
      "ja": "図10：空欄と統合されていない葉を持つ木"
    },
    {
      "indent": 3,
      "text": "In this tree, we can see all of the above rules in play:",
      "ja": "この木の中で、私たちは上記のすべてのルールが適用されているのを見ることができます："
    },
    {
      "indent": 6,
      "text": "* The resolution of node X is the list [X, B].",
      "ja": "* ノードXの解像度はリスト[X, B]です。"
    },
    {
      "indent": 6,
      "text": "* The resolution of leaf 2 or leaf 6 is the empty list [].",
      "ja": "* 葉2または葉6の解像度は空のリスト[]です。"
    },
    {
      "indent": 6,
      "text": "* The resolution of top node is the list [X, B, Y, H].",
      "ja": "* トップノードの解像度は、リスト[X、B、Y、H]です。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Paths through a Ratchet Tree",
      "section_title": true,
      "ja": "4.1.2. ラチェットツリーを通る経路"
    },
    {
      "indent": 3,
      "text": "The _direct path_ of a root is the empty list. The direct path of any other node is the concatenation of that node's parent along with the parent's direct path.",
      "ja": "根の「直接のパス」は空のリストです。他のノードの直接のパスは、そのノードの親と親の直接のパスを連結したものです。"
    },
    {
      "indent": 3,
      "text": "The _copath_ of a node is the node's sibling concatenated with the list of siblings of all the nodes in its direct path, excluding the root.",
      "ja": "ノードの_copath_は、そのノードの兄弟ノードと、ルートを除く直接のパス内のすべてのノードの兄弟ノードのリストを連結したものです。"
    },
    {
      "indent": 3,
      "text": "The _filtered direct path_ of a leaf node L is the node's direct path, with any node removed whose child on the copath of L has an empty resolution (keeping in mind that any unmerged leaves of the copath child count toward its resolution). The removed nodes do not need their own key pairs because encrypting to the node's key pair would be equivalent to encrypting to its non-copath child.",
      "ja": "葉ノード L の _filtered direct path_ とは、L のコパス上の子ノードが空の解決策を持つ場合には、そのノードを除いた直接パスのことです（コパス上の未マージの葉ノードも解決策にカウントされることに注意してください）。 除去されたノードには、自分自身の鍵ペアが必要ではなく、そのノードの鍵ペアに暗号化することは、そのコパス上の子ノードに暗号化するのと同等です。"
    },
    {
      "indent": 3,
      "text": "For example, consider the following tree (where blank nodes are indicated with _, but also assigned a label for reference):",
      "ja": "例えば、以下の木を考えてみてください（空のノードは_で示されますが、参照のためにラベルも割り当てられています）:"
    },
    {
      "indent": 3,
      "text": "              W = root\n              |\n        .-----+-----.\n       /             \\\n      _=U             Y\n      |               |\n    .-+-.           .-+-.\n   /     \\         /     \\\n  T       _=V     X       _=Z\n / \\     / \\     / \\     / \\\nA   B   _   _   E   F   G   _=H\n\n0   1   2   3   4   5   6   7",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 11: A Complete Tree with Five Members, with Labels for Blank Parent Nodes",
      "ja": "図11：ラベルの付いた空の親ノードを持つ5つのメンバーを持つ完全な木"
    },
    {
      "indent": 3,
      "text": "In this tree, the direct paths, copaths, and filtered direct paths for the leaf nodes are as follows:",
      "ja": "この木構造において、葉ノードの直接パス、共通パス、およびフィルタリングされた直接パスは次の通りです："
    },
    {
      "indent": 14,
      "text": "+======+=============+=========+======================+\n| Node | Direct path | Copath  | Filtered Direct Path |\n+======+=============+=========+======================+\n| A    | T, U, W     | B, V, Y | T, W                 |\n+------+-------------+---------+----------------------+\n| B    | T, U, W     | A, V, Y | T, W                 |\n+------+-------------+---------+----------------------+\n| E    | X, Y, W     | F, Z, U | X, Y, W              |\n+------+-------------+---------+----------------------+\n| F    | X, Y, W     | E, Z, U | X, Y, W              |\n+------+-------------+---------+----------------------+\n| G    | Z, Y, W     | H, X, U | Y, W                 |\n+------+-------------+---------+----------------------+\n\n                        Table 2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.2. Views of a Ratchet Tree",
      "section_title": true,
      "ja": "4.2. ラチェットツリーの景色"
    },
    {
      "indent": 3,
      "text": "We generally assume that each participant maintains a complete and up-to-date view of the public state of the group's ratchet tree, including the public keys for all nodes and the credentials associated with the leaf nodes.",
      "ja": "一般的に、各参加者がグループのラチェットツリーの公開状態に関する完全かつ最新のビューを維持していると仮定しています。これには、すべてのノードの公開鍵とリーフノードに関連する資格情報が含まれます。"
    },
    {
      "indent": 3,
      "text": "No participant in an MLS group knows the private key associated with every node in the tree. Instead, each member is assigned to a leaf of the tree, which determines the subset of private keys it knows. The credential stored at that leaf is one provided by the member.",
      "ja": "MLSグループの参加者は、ツリー内のすべてのノードに関連付けられたプライベートキーを知りません。代わりに、各メンバーはツリーの葉に割り当てられ、それによって彼らが知っているプライベートキーのサブセットが決まります。その葉に格納されている資格情報は、メンバーが提供したものです。"
    },
    {
      "indent": 3,
      "text": "In particular, MLS maintains the members' views of the tree in such a way as to maintain the _tree invariant_:",
      "ja": "特に、MLSは、メンバーの木に関する見解を維持するために、_木の不変条件_を維持する方法で維持します。"
    },
    {
      "indent": 0,
      "text": "The private key for a node in the tree is known to a member of the group only if the node's subtree contains that member's leaf.",
      "ja": "そのツリー内のノードのプライベートキーは、そのノードの部分木にそのメンバーの葉が含まれている場合にのみ、グループのメンバーにのみ知られています。"
    },
    {
      "indent": 3,
      "text": "In other words, if a node is not blank, then it holds a public key. The corresponding private key is known only to members occupying leaves below that node.",
      "ja": "言い換えると、ノードが空白でない場合、そのノードは公開鍵を保持しています。対応する秘密鍵は、そのノードの下にある葉を占めるメンバーだけが知っています。"
    },
    {
      "indent": 3,
      "text": "The reverse implication is not true: A member may not know the private key of an intermediate node above them. Such a member has an _unmerged_ leaf at the intermediate node. Encrypting to an intermediate node requires encrypting to the node's public key, as well as the public keys of all the unmerged leaves below it. A leaf is unmerged with regard to all of its ancestors when it is first added, because the process of adding the leaf does not give it access to the private keys for all of the nodes above it in the tree. Leaves are \"merged\" as they receive the private keys for nodes, as described in Section 7.4.",
      "ja": "逆の含意は真ではありません：メンバーは、自分の上にある中間ノードの秘密鍵を知らない場合があります。そのようなメンバーは、中間ノードにおいて「未統合」の葉を持っています。中間ノードに暗号化するには、ノードの公開鍵だけでなく、それ以下のすべての未統合の葉の公開鍵に暗号化する必要があります。葉は最初に追加されたとき、その祖先全体に対して未統合であるため、その葉には木構造の上位のすべてのノードの秘密鍵へのアクセス権が与えられません。葉は、セクション7.4で説明されているように、ノードの秘密鍵を受け取ると「統合」されます。"
    },
    {
      "indent": 3,
      "text": "For example, consider a four-member group (A, B, C, D) where the node above the right two members is blank. (This is what it would look like if A created a group with B, C, and D.) Then the public state of the tree and the views of the private keys of the tree held by each participant would be as follows, where _ represents a blank node, ? represents an unknown private key, and pk(X) represents the public key corresponding to the private key X:",
      "ja": "例えば、4人のグループ（A、B、C、D）を考えてみましょう。右側の2人のメンバーの上にあるノードが空白です。（これは、AがB、C、Dとグループを作成した場合の見た目です。）その後、ツリーの公開状態と各参加者が保持するツリーの秘密鍵のビューは次のようになります。ここで、_ は空白ノードを、? は未知の秘密鍵を、pk(X) は秘密鍵 X に対応する公開鍵を表します。"
    },
    {
      "indent": 3,
      "text": "         Public Tree\n============================\n            pk(ABCD)\n          /          \\\n    pk(AB)            _\n     / \\             / \\\npk(A)   pk(B)   pk(C)   pk(D)\n\n\n Private @ A       Private @ B       Private @ C       Private @ D\n=============     =============     =============     =============\n     ABCD              ABCD              ABCD              ABCD\n    /   \\             /   \\             /   \\             /   \\\n  AB      _         AB      _         ?       _         ?       _\n / \\     / \\       / \\     / \\       / \\     / \\       / \\     / \\\nA   ?   ?   ?     ?   B   ?   ?     ?   ?   C   ?     ?   ?   ?   D",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note how the tree invariant applies: Each member knows only their own leaf, the private key AB is known only to A and B, and the private key ABCD is known to all four members. This also illustrates another important point: it is possible for there to be \"holes\" on the path from a member's leaf to the root in which the member knows the key both above and below a given node, but not for that node, as in the case with D.",
      "ja": "木の不変条件が適用される方法に注目してください：各メンバーは自分の葉のみを知っており、秘密鍵ABはAとBのみが知っており、秘密鍵ABCDは4人のメンバー全員が知っています。これはもう1つの重要な点を示しています：メンバーの葉からルートまでのパスに「穴」がある可能性があることを示しています。メンバーは、特定のノードの上と下の鍵を知っているが、そのノード自体の鍵を知らない場合があります。Dの場合のように。"
    },
    {
      "indent": 0,
      "text": "5. Cryptographic Objects",
      "section_title": true,
      "ja": "5. 暗号化オブジェクト"
    },
    {
      "indent": 0,
      "text": "5.1. Cipher Suites",
      "section_title": true,
      "ja": "5.1. 暗号スイート"
    },
    {
      "indent": 3,
      "text": "Each MLS session uses a single cipher suite that specifies the following primitives to be used in group key computations:",
      "ja": "各MLSセッションは、グループ鍵計算に使用される以下のプリミティブを指定する単一の暗号スイートを使用します。"
    },
    {
      "indent": 6,
      "text": "* HPKE parameters:",
      "ja": "* HPKE パラメータ："
    },
    {
      "indent": 12,
      "text": "- A Key Encapsulation Mechanism (KEM)",
      "ja": "- 鍵カプセル化メカニズム（KEM）"
    },
    {
      "indent": 12,
      "text": "- A Key Derivation Function (KDF)",
      "ja": "- 鍵導出関数（KDF）"
    },
    {
      "indent": 12,
      "text": "- An Authenticated Encryption with Associated Data (AEAD) encryption algorithm",
      "ja": "- 認証付き暗号化と関連データ（AEAD）暗号化アルゴリズム"
    },
    {
      "indent": 6,
      "text": "* A hash algorithm",
      "ja": "* ハッシュアルゴリズム"
    },
    {
      "indent": 6,
      "text": "* A Message Authentication Code (MAC) algorithm",
      "ja": "* メッセージ認証コード（MAC）アルゴリズム"
    },
    {
      "indent": 6,
      "text": "* A signature algorithm",
      "ja": "* 署名アルゴリズム"
    },
    {
      "indent": 3,
      "text": "MLS uses HPKE for public key encryption [RFC9180]. The DeriveKeyPair function associated to the KEM for the cipher suite maps octet strings to HPKE key pairs. As in HPKE, MLS assumes that an AEAD algorithm produces a single ciphertext output from AEAD encryption (aligning with [RFC5116]), as opposed to a separate ciphertext and tag.",
      "ja": "MLSは公開鍵暗号化のためにHPKEを使用しています[RFC9180]。暗号スイートに関連付けられたKEMのDeriveKeyPair関数は、オクテット文字列をHPKE鍵ペアにマッピングします。HPKEと同様に、MLSはAEADアルゴリズムがAEAD暗号化から単一の暗号文出力を生成することを前提としています（[RFC5116]と一致しています）、別々の暗号文とタグではなく。"
    },
    {
      "indent": 3,
      "text": "Cipher suites are represented with the CipherSuite type. The cipher suites are defined in Section 17.1.",
      "ja": "Cipher suites are represented with the CipherSuite type. The cipher suites are defined in Section 17.1.\n暗号スイートはCipherSuiteタイプで表されます。暗号スイートはセクション17.1で定義されています。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Public Keys",
      "section_title": true,
      "ja": "5.1.1. 公開鍵"
    },
    {
      "indent": 3,
      "text": "HPKE public keys are opaque values in a format defined by the underlying protocol (see Section 4 of [RFC9180] for more information).",
      "ja": "HPKEの公開鍵は、基礎となるプロトコルで定義された形式の不透明な値です（詳細については[RFC9180]のセクション4を参照してください）。"
    },
    {
      "indent": 3,
      "text": "opaque HPKEPublicKey<V>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Signature public keys are likewise represented as opaque values in a format defined by the cipher suite's signature scheme.",
      "ja": "署名公開鍵も、暗号スイートの署名方式で定義された形式の不透明な値として表されます。"
    },
    {
      "indent": 3,
      "text": "opaque SignaturePublicKey<V>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For cipher suites using the Edwards-curve Digital Signature Algorithm (EdDSA) signature schemes (Ed25519 or Ed448), the public key is in the format specified in [RFC8032].",
      "ja": "EdDSA署名スキーム（Ed25519またはEd448）を使用する暗号スイートの場合、公開鍵は[RFC8032]で指定された形式である必要があります。"
    },
    {
      "indent": 3,
      "text": "For cipher suites using the Elliptic Curve Digital Signature Algorithm (ECDSA) with the NIST curves (P-256, P-384, or P-521), the public key is represented as an encoded UncompressedPointRepresentation struct, as defined in [RFC8446].",
      "ja": "楕円曲線デジタル署名アルゴリズム（ECDSA）を使用する暗号スイートの場合、NIST曲線（P-256、P-384、またはP-521）を使用して、公開鍵は[RFC8446]で定義されているエンコードされたUncompressedPointRepresentation構造体として表されます。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Signing",
      "section_title": true,
      "ja": "5.1.2. 署名"
    },
    {
      "indent": 3,
      "text": "The signature algorithm specified in a group's cipher suite is the mandatory algorithm to be used for signing messages within the group. It MUST be the same as the signature algorithm specified in the credentials in the leaves of the tree (including the leaf node information in KeyPackages used to add new members).",
      "ja": "グループの暗号スイートで指定された署名アルゴリズムは、グループ内でのメッセージの署名に使用される必須のアルゴリズムです。これは、木の葉に指定された署名アルゴリズムと同じでなければなりません（新しいメンバーを追加するために使用されるKeyPackages内の葉ノード情報を含む）。"
    },
    {
      "indent": 3,
      "text": "The signatures used in this document are encoded as specified in [RFC8446]. In particular, ECDSA signatures are DER encoded, and EdDSA signatures are defined as the concatenation of R and S, as specified in [RFC8032].",
      "ja": "この文書で使用されている署名は、[RFC8446] で指定された形式でエンコードされています。特に、ECDSA 署名は DER エンコードされ、EdDSA 署名は [RFC8032] で指定されたように R と S の連結として定義されています。"
    },
    {
      "indent": 3,
      "text": "To disambiguate different signatures used in MLS, each signed value is prefixed by a label as shown below:",
      "ja": "MLSで使用される異なる署名を明確にするために、各署名された値は以下に示すようにラベルで接頭辞が付けられます："
    },
    {
      "indent": 3,
      "text": "SignWithLabel(SignatureKey, Label, Content) =\n    Signature.Sign(SignatureKey, SignContent)\n\nVerifyWithLabel(VerificationKey, Label, Content, SignatureValue) =\n    Signature.Verify(VerificationKey, SignContent, SignatureValue)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where SignContent is specified as:",
      "ja": "SignContent が指定されている場合："
    },
    {
      "indent": 3,
      "text": "struct {\n    opaque label<V>;\n    opaque content<V>;\n} SignContent;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "And its fields are set to:",
      "ja": "そして、そのフィールドは次のように設定されています："
    },
    {
      "indent": 3,
      "text": "label = \"MLS 1.0 \" + Label;\ncontent = Content;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The functions Signature.Sign and Signature.Verify are defined by the signature algorithm. If MLS extensions require signatures by group members, they should reuse the SignWithLabel construction, using a distinct label. To avoid collisions in these labels, an IANA registry is defined in Section 17.6.",
      "ja": "関数Signature.SignとSignature.Verifyは署名アルゴリズムによって定義されます。MLS拡張がグループメンバーによる署名を必要とする場合、異なるラベルを使用してSignWithLabel構築を再利用する必要があります。これらのラベルでの衝突を避けるために、IANAレジストリがセクション17.6で定義されています。"
    },
    {
      "indent": 0,
      "text": "5.1.3. Public Key Encryption",
      "section_title": true,
      "ja": "5.1.3. 公開鍵暗号化"
    },
    {
      "indent": 3,
      "text": "As with signing, MLS includes a label and context in encryption operations to avoid confusion between ciphertexts produced for different purposes. Encryption and decryption including this label and context are done as follows:",
      "ja": "署名と同様に、MLSは暗号化操作にラベルとコンテキストを含めて、異なる目的のために生成された暗号文の混乱を避けます。このラベルとコンテキストを含む暗号化および復号化は、以下のように行われます："
    },
    {
      "indent": 3,
      "text": "EncryptWithLabel(PublicKey, Label, Context, Plaintext) =\n  SealBase(PublicKey, EncryptContext, \"\", Plaintext)\n\nDecryptWithLabel(PrivateKey, Label, Context, KEMOutput, Ciphertext) =\n  OpenBase(KEMOutput, PrivateKey, EncryptContext, \"\", Ciphertext)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where EncryptContext is specified as:",
      "ja": "EncryptContext が指定されている場所:"
    },
    {
      "indent": 3,
      "text": "struct {\n  opaque label<V>;\n  opaque context<V>;\n} EncryptContext;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "And its fields are set to:",
      "ja": "そして、そのフィールドは次のように設定されています："
    },
    {
      "indent": 3,
      "text": "label = \"MLS 1.0 \" + Label;\ncontext = Context;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The functions SealBase and OpenBase are defined in Section 6.1 of [RFC9180] (with \"Base\" as the MODE), using the HPKE algorithms specified by the group's cipher suite. If MLS extensions require HPKE encryption operations, they should reuse the EncryptWithLabel construction, using a distinct label. To avoid collisions in these labels, an IANA registry is defined in Section 17.7.",
      "ja": "関数SealBaseとOpenBaseは、[RFC9180]のセクション6.1で定義されており（\"Base\"をMODEとして使用）、グループの暗号スイートで指定されたHPKEアルゴリズムを使用しています。MLS拡張がHPKE暗号化操作を必要とする場合、異なるラベルを使用してEncryptWithLabel構築を再利用する必要があります。これらのラベルでの衝突を避けるために、IANAレジストリがセクション17.7で定義されています。"
    },
    {
      "indent": 0,
      "text": "5.2. Hash-Based Identifiers",
      "section_title": true,
      "ja": "5.2. ハッシュベースの識別子"
    },
    {
      "indent": 3,
      "text": "Some MLS messages refer to other MLS objects by hash. For example, Welcome messages refer to KeyPackages for the members being welcomed, and Commits refer to Proposals they cover. These identifiers are computed as follows:",
      "ja": "一部のMLSメッセージは、ハッシュによって他のMLSオブジェクトを参照します。例えば、Welcomeメッセージは歓迎されるメンバーのKeyPackagesを参照し、Commitsはカバーする提案を参照します。これらの識別子は以下のように計算されます："
    },
    {
      "indent": 3,
      "text": "opaque HashReference<V>;\n\nHashReference KeyPackageRef;\nHashReference ProposalRef;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "MakeKeyPackageRef(value)\n  = RefHash(\"MLS 1.0 KeyPackage Reference\", value)\n\nMakeProposalRef(value)\n  = RefHash(\"MLS 1.0 Proposal Reference\", value)\n\nRefHash(label, value) = Hash(RefHashInput)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where RefHashInput is defined as:",
      "ja": "RefHashInputが次のように定義されている場合:"
    },
    {
      "indent": 3,
      "text": "struct {\n  opaque label<V>;\n  opaque value<V>;\n} RefHashInput;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "And its fields are set to:",
      "ja": "そして、そのフィールドは次のように設定されています："
    },
    {
      "indent": 3,
      "text": "label = label;\nvalue = value;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For a KeyPackageRef, the value input is the encoded KeyPackage, and the cipher suite specified in the KeyPackage determines the KDF used. For a ProposalRef, the value input is the AuthenticatedContent carrying the Proposal. In the latter two cases, the KDF is determined by the group's cipher suite.",
      "ja": "KeyPackageRefについて、値の入力はエンコードされたKeyPackageであり、KeyPackageで指定された暗号スイートが使用されるKDFが決定されます。ProposalRefについて、値の入力はProposalを運ぶAuthenticatedContentです。後者の2つの場合、KDFはグループの暗号スイートによって決定されます。"
    },
    {
      "indent": 0,
      "text": "5.3. Credentials",
      "section_title": true,
      "ja": "5.3. 資格"
    },
    {
      "indent": 3,
      "text": "Each member of a group presents a credential that provides one or more identities for the member and associates them with the member's signing key. The identities and signing key are verified by the Authentication Service in use for a group.",
      "ja": "グループの各メンバーは、そのメンバーの1つ以上のアイデンティティを提供し、それらをメンバーの署名キーと関連付ける資格証明書を提示します。アイデンティティと署名キーは、グループに使用されている認証サービスによって検証されます。"
    },
    {
      "indent": 3,
      "text": "It is up to the application to decide which identifiers to use at the application level. For example, a certificate in an X509Credential may attest to several domain names or email addresses in its subjectAltName extension. An application may decide to present all of these to a user, or if it knows a \"desired\" domain name or email address, it can check that the desired identifier is among those attested. Using the terminology from [RFC6125], a credential provides \"presented identifiers\", and it is up to the application to supply a \"reference identifier\" for the authenticated client, if any.",
      "ja": "アプリケーションは、アプリケーションレベルでどの識別子を使用するかを決定することになります。たとえば、X509Credential内の証明書は、そのsubjectAltName拡張で複数のドメイン名やメールアドレスを証明できます。アプリケーションは、これらすべてをユーザーに提示するか、または「希望する」ドメイン名やメールアドレスを知っている場合は、その希望する識別子が証明されたものの中に含まれているかどうかを確認できます。[RFC6125]からの用語を使用すると、資格情報は「提示された識別子」を提供し、認証されたクライアントに対して必要な場合はアプリケーションが「参照識別子」を提供することになります。"
    },
    {
      "indent": 3,
      "text": "// See the \"MLS Credential Types\" IANA registry for values\nuint16 CredentialType;\n\nstruct {\n    opaque cert_data<V>;\n} Certificate;\n\nstruct {\n    CredentialType credential_type;\n    select (Credential.credential_type) {\n        case basic:\n            opaque identity<V>;\n\n        case x509:\n            Certificate certificates<V>;\n    };\n} Credential;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A \"basic\" credential is a bare assertion of an identity, without any additional information. The format of the encoded identity is defined by the application.",
      "ja": "「基本的な」資格情報は、追加情報なしでのアイデンティティの単なる主張です。エンコードされたアイデンティティの形式は、アプリケーションによって定義されます。"
    },
    {
      "indent": 3,
      "text": "For an X.509 credential, each entry in the certificates field represents a single DER-encoded X.509 certificate. The chain is ordered such that the first entry (certificates[0]) is the end-entity certificate. The public key encoded in the subjectPublicKeyInfo of the end-entity certificate MUST be identical to the signature_key in the LeafNode containing this credential. A chain MAY omit any non-leaf certificates that supported peers are known to already possess.",
      "ja": "X.509資格情報について、certificatesフィールド内の各エントリは単一のDERエンコードされたX.509証明書を表します。チェーンは、最初のエントリ（certificates[0]）がエンドエンティティ証明書であるように順序付けされます。エンドエンティティ証明書のsubjectPublicKeyInfoにエンコードされた公開鍵は、この資格情報を含むLeafNodeのsignature_keyと同一でなければなりません。チェーンは、既に所有しているサポートされるピアが既知の非リーフ証明書を省略することができます。"
    },
    {
      "indent": 0,
      "text": "5.3.1. Credential Validation",
      "section_title": true,
      "ja": "5.3.1. 資格の検証"
    },
    {
      "indent": 3,
      "text": "The application using MLS is responsible for specifying which identifiers it finds acceptable for each member in a group. In other words, following the model that [RFC6125] describes for TLS, the application maintains a list of \"reference identifiers\" for the members of a group, and the credentials provide \"presented identifiers\". A member of a group is authenticated by first validating that the member's credential legitimately represents some presented identifiers, and then ensuring that the reference identifiers for the member are authenticated by those presented identifiers.",
      "ja": "MLSを使用するアプリケーションは、グループ内の各メンバーに対して受け入れ可能な識別子を指定する責任があります。言い換えると、TLSのために[RFC6125]が説明するモデルに従い、アプリケーションはグループのメンバーのための「参照識別子」のリストを維持し、資格情報は「提示された識別子」を提供します。グループのメンバーは、まずそのメンバーの資格情報がいくつかの提示された識別子を正当に表していることを検証し、次に、そのメンバーの参照識別子がそれらの提示された識別子によって認証されていることを確認することによって認証されます。"
    },
    {
      "indent": 3,
      "text": "The parts of the system that perform these functions are collectively referred to as the Authentication Service (AS) [MLS-ARCH]. A member's credential is said to be _validated with the AS_ when the AS verifies that the credential's presented identifiers are correctly associated with the signature_key field in the member's LeafNode, and that those identifiers match the reference identifiers for the member.",
      "ja": "これらの機能を実行するシステムの部分は、総称して認証サービス（AS）[MLS-ARCH]と呼ばれます。メンバーの資格情報がASによって検証されるとき、ASは資格情報の提示された識別子がメンバーのLeafNodeのsignature_keyフィールドと正しく関連付けられていることを検証し、それらの識別子がメンバーの参照識別子と一致していることを確認します。"
    },
    {
      "indent": 3,
      "text": "Whenever a new credential is introduced in the group, it MUST be validated with the AS. In particular, at the following events in the protocol:",
      "ja": "グループに新しい資格情報が導入されるたびに、それはASで検証されなければなりません。特に、プロトコル内の以下のイベントで検証されます："
    },
    {
      "indent": 6,
      "text": "* When a member receives a KeyPackage that it will use in an Add proposal to add a new member to the group",
      "ja": "* メンバーがKeyPackageを受け取り、新しいメンバーをグループに追加するための追加提案に使用する場合"
    },
    {
      "indent": 6,
      "text": "* When a member receives a GroupInfo object that it will use to join a group, either via a Welcome or via an external Commit",
      "ja": "* メンバーがグループに参加するために使用するGroupInfoオブジェクトを受け取るとき、それは歓迎メッセージを介してでも、外部のコミットを介してでも、です。"
    },
    {
      "indent": 6,
      "text": "* When a member receives an Add proposal adding a member to the group",
      "ja": "* メンバーがグループにメンバーを追加する提案を受け取った場合"
    },
    {
      "indent": 6,
      "text": "* When a member receives an Update proposal whose LeafNode has a new credential for the member",
      "ja": "* メンバーが、そのLeafNodeに新しい資格情報を持つUpdate提案を受け取った場合"
    },
    {
      "indent": 6,
      "text": "* When a member receives a Commit with an UpdatePath whose LeafNode has a new credential for the committer",
      "ja": "* メンバーが、LeafNode に新しい資格情報を持つ Commit を受け取った場合"
    },
    {
      "indent": 6,
      "text": "* When an external_senders extension is added to the group",
      "ja": "* グループにexternal_senders拡張機能が追加された場合"
    },
    {
      "indent": 6,
      "text": "* When an existing external_senders extension is updated",
      "ja": "* 既存のexternal_senders拡張機能が更新されるとき"
    },
    {
      "indent": 3,
      "text": "In cases where a member's credential is being replaced, such as the Update and Commit cases above, the AS MUST also verify that the set of presented identifiers in the new credential is valid as a successor to the set of presented identifiers in the old credential, according to the application's policy.",
      "ja": "メンバーの資格情報が更新される場合（上記の更新とコミットの場合など）、ASは新しい資格情報に提示された識別子のセットが、アプリケーションのポリシーに従い、古い資格情報に提示された識別子のセットの後継として有効であることも検証しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Credential Expiry and Revocation",
      "section_title": true,
      "ja": "5.3.2. 資格の有効期限と取り消し"
    },
    {
      "indent": 3,
      "text": "In some credential schemes, a valid credential can \"expire\" or become invalid after a certain point in time. For example, each X.509 certificate has a notAfter field, expressing a time after which the certificate is not valid.",
      "ja": "一部の資格情報スキームでは、有効な資格情報は特定の時点を過ぎると「期限切れ」となるか無効になることがあります。例えば、各X.509証明書には、証明書が無効となる時刻を表すnotAfterフィールドがあります。"
    },
    {
      "indent": 3,
      "text": "Expired credentials can cause operational problems in light of the validation requirements of Section 5.3.1. Applications can apply some operational practices and adaptations to Authentication Service policies to moderate these impacts.",
      "ja": "期限切れの資格情報は、セクション5.3.1の検証要件を考慮すると、運用上の問題を引き起こす可能性があります。アプリケーションは、これらの影響を緩和するために、運用上の慣行や認証サービスポリシーの適応をいくつか適用することができます。"
    },
    {
      "indent": 3,
      "text": "In general, to avoid operational problems such as new joiners rejecting expired credentials in a group, applications that use such credentials should ensure to the extent practical that all of the credentials in use in a group are valid at all times.",
      "ja": "一般的に、新規参加者がグループ内の有効期限切れの資格情報を拒否するなどの運用上の問題を避けるために、そのような資格情報を使用するアプリケーションは、実用的な範囲で、グループ内で使用されているすべての資格情報が常に有効であることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a member finds that its credential has expired (or will soon), it should issue an Update or Commit that replaces it with a valid credential. For this reason, members SHOULD accept Update proposals and Commits issued by members with expired credentials, if the credential in the Update or Commit is valid.",
      "ja": "メンバーが資格情報の有効期限が切れていることを発見した場合（またはまもなく切れる場合）、有効な資格情報でそれを置き換えるUpdateまたはCommitを発行するべきです。このため、メンバーは、有効な資格情報がUpdateまたはCommitに含まれている場合、資格情報の有効期限が切れているメンバーから発行されたUpdate提案およびCommitを受け入れるべきです。"
    },
    {
      "indent": 3,
      "text": "Similarly, when a client is processing messages sent some time in the past (e.g., syncing up with a group after being offline), the client SHOULD accept signatures from members with expired credentials, since the credential may have been valid at the time the message was sent.",
      "ja": "同様に、クライアントが過去に送信されたメッセージを処理している場合（たとえば、オフラインの後にグループと同期する場合）、クライアントは有効期限切れの資格情報を持つメンバーからの署名を受け入れるべきです。なぜなら、メッセージが送信された時点で資格情報が有効であった可能性があるからです。"
    },
    {
      "indent": 3,
      "text": "If a member finds that another member's credential has expired, they may issue a Remove that removes that member. For example, an application could require a member preparing to issue a Commit to check the tree for expired credentials and include Remove proposals for those members in its Commit. In situations where the group tree is known to the DS, the DS could also monitor the tree for expired credentials and issue external Remove proposals.",
      "ja": "もしメンバーが他のメンバーの資格証明書が期限切れであることを発見した場合、そのメンバーはそのメンバーを削除する「Remove」を発行することができます。例えば、アプリケーションは、Commitを発行する準備をしているメンバーが期限切れの資格証明書をチェックし、そのメンバーのためにRemove提案を含めることができます。グループツリーがDSに知られている状況では、DSは期限切れの資格証明書を監視し、外部のRemove提案を発行することもできます。"
    },
    {
      "indent": 3,
      "text": "Some credential schemes also allow credentials to be revoked. Revocation is similar to expiry in that a previously valid credential becomes invalid. As such, most of the considerations above also apply to revoked credentials. However, applications may want to treat revoked credentials differently, e.g., by removing members with revoked credentials while allowing members with expired credentials time to update.",
      "ja": "一部の資格スキームでは、資格情報を取り消すことも可能です。取り消しは、以前有効だった資格情報が無効になるという点で有効期限と似ています。そのため、上記の考慮事項のほとんどは取り消された資格情報にも適用されます。ただし、アプリケーションは、取り消された資格情報を異なる方法で扱いたい場合があります。例えば、取り消された資格情報を持つメンバーを削除する一方で、有効期限切れの資格情報を持つメンバーには更新する時間を与えるなどです。"
    },
    {
      "indent": 0,
      "text": "5.3.3. Uniquely Identifying Clients",
      "section_title": true,
      "ja": "5.3.3. クライアントを一意に識別する"
    },
    {
      "indent": 3,
      "text": "MLS implementations will presumably provide applications with a way to request protocol operations with regard to other clients (e.g., removing clients). Such functions will need to refer to the other clients using some identifier. MLS clients have a few types of identifiers, with different operational properties.",
      "ja": "MLSの実装はおそらく、他のクライアントに関するプロトコル操作をリクエストするアプリケーションに方法を提供します（例：クライアントの削除）。そのような機能は、他のクライアントを識別するためにいくつかの識別子を使用する必要があります。MLSクライアントには、異なる操作特性を持ついくつかのタイプの識別子があります。"
    },
    {
      "indent": 3,
      "text": "Internally to the protocol, group members are uniquely identified by their leaf index. However, a leaf index is only valid for referring to members in a given epoch. The same leaf index may represent a different member, or no member at all, in a subsequent epoch.",
      "ja": "プロトコル内部では、グループメンバーはそれぞれの葉インデックスによって一意に識別されます。ただし、葉インデックスは特定のエポック内のメンバーを参照するためにのみ有効です。同じ葉インデックスが、後続のエポックでは異なるメンバーを表すか、あるいは全くメンバーを表さないことがあります。"
    },
    {
      "indent": 3,
      "text": "The Credentials presented by the clients in a group authenticate application-level identifiers for the clients. However, these identifiers may not uniquely identify clients. For example, if a user has multiple devices that are all present in an MLS group, then those devices' clients could all present the user's application-layer identifiers.",
      "ja": "クライアントがグループ内で提示する資格情報は、クライアントのアプリケーションレベルの識別子を認証します。ただし、これらの識別子がクライアントを一意に識別しない場合があります。たとえば、ユーザーが複数のデバイスを所有し、それらのデバイスがすべてMLSグループに存在する場合、それらのデバイスのクライアントはすべてユーザーのアプリケーションレイヤーの識別子を提示できます。"
    },
    {
      "indent": 3,
      "text": "If needed, applications may add application-specific identifiers to the extensions field of a LeafNode object with the application_id extension.",
      "ja": "必要に応じて、アプリケーションは、application_id拡張機能を使用して、LeafNodeオブジェクトのextensionsフィールドにアプリケーション固有の識別子を追加できます。"
    },
    {
      "indent": 3,
      "text": "opaque application_id<V>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "However, applications MUST NOT rely on the data in an application_id extension as if it were authenticated by the Authentication Service, and SHOULD gracefully handle cases where the identifier presented is not unique.",
      "ja": "ただし、アプリケーションは、application_id 拡張機能内のデータが認証サービスによって認証されたかのように依存してはならず、提示された識別子が一意でない場合に優雅に処理する必要があります。"
    },
    {
      "indent": 0,
      "text": "6. Message Framing",
      "section_title": true,
      "ja": "6. メッセージフレーミング"
    },
    {
      "indent": 3,
      "text": "Handshake and application messages use a common framing structure. This framing provides encryption to ensure confidentiality within the group, as well as signing to authenticate the sender.",
      "ja": "ハンドシェイクとアプリケーションメッセージは共通のフレーミング構造を使用します。このフレーミングは、グループ内の機密性を確保するための暗号化を提供し、送信者を認証するための署名も行います。"
    },
    {
      "indent": 3,
      "text": "In most of the protocol, messages are handled in the form of AuthenticatedContent objects. These structures contain the content of the message itself as well as information to authenticate the sender (see Section 6.1). The additional protections required to transmit these messages over an untrusted channel (group membership authentication or AEAD encryption) are added by encoding the AuthenticatedContent as a PublicMessage or PrivateMessage message, which can then be sent as an MLSMessage. Likewise, these protections are enforced (via membership verification or AEAD decryption) when decoding a PublicMessage or PrivateMessage into an AuthenticatedContent object.",
      "ja": "ほとんどのプロトコルでは、メッセージは AuthenticatedContent オブジェクトの形式で処理されます。これらの構造体には、メッセージ自体の内容と送信者を認証する情報が含まれています（セクション6.1を参照）。これらのメッセージを信頼できないチャネルを介して送信するために必要な追加の保護（グループメンバーシップ認証またはAEAD暗号化）は、AuthenticatedContentをPublicMessageまたはPrivateMessageメッセージとしてエンコードすることで追加され、それらはMLSMessageとして送信されます。同様に、これらの保護は、PublicMessageまたはPrivateMessageをAuthenticatedContentオブジェクトにデコードする際に（メンバーシップの検証またはAEADの復号化を介して）強制されます。"
    },
    {
      "indent": 3,
      "text": "PrivateMessage represents a signed and encrypted message, with protections for both the content of the message and related metadata. PublicMessage represents a message that is only signed, and not encrypted. Applications MUST use PrivateMessage to encrypt application messages and SHOULD use PrivateMessage to encode handshake messages, but they MAY transmit handshake messages encoded as PublicMessage objects in cases where it is necessary for the Delivery Service to examine such messages.",
      "ja": "PrivateMessageは、メッセージの内容と関連するメタデータの両方を保護した署名付きおよび暗号化されたメッセージを表します。PublicMessageは、署名のみが付されて暗号化されていないメッセージを表します。アプリケーションは、アプリケーションメッセージを暗号化するためにPrivateMessageを使用する必要があり、ハンドシェイクメッセージをエンコードするためにPrivateMessageを使用することが望ましいですが、配信サービスがそのようなメッセージを調査する必要がある場合には、PublicMessageオブジェクトとしてエンコードされたハンドシェイクメッセージを送信しても構いません。"
    },
    {
      "indent": 3,
      "text": "enum {\n    reserved(0),\n    mls10(1),\n    (65535)\n} ProtocolVersion;\n\nenum {\n    reserved(0),\n    application(1),\n    proposal(2),\n    commit(3),\n    (255)\n} ContentType;\n\nenum {\n    reserved(0),\n    member(1),\n    external(2),\n    new_member_proposal(3),\n    new_member_commit(4),\n    (255)\n} SenderType;\n\nstruct {\n    SenderType sender_type;\n    select (Sender.sender_type) {\n        case member:\n            uint32 leaf_index;\n        case external:\n            uint32 sender_index;\n        case new_member_commit:\n        case new_member_proposal:\n            struct{};\n    };\n} Sender;\n\n// See the \"MLS Wire Formats\" IANA registry for values\nuint16 WireFormat;\n\nstruct {\n    opaque group_id<V>;\n    uint64 epoch;\n    Sender sender;\n    opaque authenticated_data<V>;\n\n    ContentType content_type;\n    select (FramedContent.content_type) {\n        case application:\n          opaque application_data<V>;\n        case proposal:\n          Proposal proposal;\n        case commit:\n          Commit commit;\n    };\n} FramedContent;\n\nstruct {\n    ProtocolVersion version = mls10;\n    WireFormat wire_format;\n    select (MLSMessage.wire_format) {\n        case mls_public_message:\n            PublicMessage public_message;\n        case mls_private_message:\n            PrivateMessage private_message;\n        case mls_welcome:\n            Welcome welcome;\n        case mls_group_info:\n            GroupInfo group_info;\n        case mls_key_package:\n            KeyPackage key_package;\n    };\n} MLSMessage;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Messages from senders that aren't in the group are sent as PublicMessage. See Sections 12.1.8 and 12.4.3.2 for more details.",
      "ja": "グループにいない送信者からのメッセージは、PublicMessageとして送信されます。詳細については、12.1.8節と12.4.3.2節を参照してください。"
    },
    {
      "indent": 3,
      "text": "The following structure is used to fully describe the data transmitted in plaintexts or ciphertexts.",
      "ja": "次の構造は、平文または暗号文で送信されるデータを完全に記述するために使用されます。"
    },
    {
      "indent": 3,
      "text": "struct {\n    WireFormat wire_format;\n    FramedContent content;\n    FramedContentAuthData auth;\n} AuthenticatedContent;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following figure illustrates how the various structures described in this section relate to each other, and the high-level operations used to produce and consume them:",
      "ja": "次の図は、このセクションで説明されているさまざまな構造物がお互いに関連している様子と、それらを生成および消費するために使用される高レベルの操作を示しています。"
    },
    {
      "indent": 3,
      "text": "    Proposal        Commit     Application Data\n       |              |              |\n       +--------------+--------------+\n                      |\n                      V\n               FramedContent\n                   |  |                -.\n          +--------+  |                  |\n          |           |                  |\n          V           |                  +-- Asymmetric\nFramedContentAuthData |                  |   Sign / Verify\n          |           |                  |\n          +--------+  |                  |\n                   |  |                  |\n                   V  V                -'\n             AuthenticatedContent\n                      |                -.\n             +--------+--------+         |\n             |                 |         +-- Symmetric\n             V                 V         |   Protect / Unprotect\n       PublicMessage    PrivateMessage -'\n             |                 |\n             |                 |  Welcome  KeyPackage  GroupInfo\n             |                 |     |          |          |\n             +-----------------+-----+----------+----------+\n                               |\n                               V\n                           MLSMessage",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 12: Relationships among MLS Objects",
      "ja": "図12：MLSオブジェクト間の関係"
    },
    {
      "indent": 0,
      "text": "6.1. Content Authentication",
      "section_title": true,
      "ja": "6.1. コンテンツ認証"
    },
    {
      "indent": 3,
      "text": "FramedContent is authenticated using the FramedContentAuthData structure.",
      "ja": "FramedContentは、FramedContentAuthData構造を使用して認証されます。"
    },
    {
      "indent": 3,
      "text": "struct {\n    ProtocolVersion version = mls10;\n    WireFormat wire_format;\n    FramedContent content;\n    select (FramedContentTBS.content.sender.sender_type) {\n        case member:\n        case new_member_commit:\n            GroupContext context;\n        case external:\n        case new_member_proposal:\n            struct{};\n    };\n} FramedContentTBS;\n\nopaque MAC<V>;\n\nstruct {\n    /* SignWithLabel(., \"FramedContentTBS\", FramedContentTBS) */\n    opaque signature<V>;\n    select (FramedContent.content_type) {\n        case commit:\n            /*\n              MAC(confirmation_key,\n                  GroupContext.confirmed_transcript_hash)\n            */\n            MAC confirmation_tag;\n        case application:\n        case proposal:\n            struct{};\n    };\n} FramedContentAuthData;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The signature is computed using SignWithLabel with label \"FramedContentTBS\" and with a content that covers the message content and the wire format that will be used for this message. If the sender's sender_type is member, the content also covers the GroupContext for the current epoch so that signatures are specific to a given group and epoch.",
      "ja": "署名は、ラベルが「FramedContentTBS」でSignWithLabelを使用して計算され、メッセージの内容とこのメッセージに使用されるワイヤーフォーマットをカバーするコンテンツを使用します。送信者のsender_typeがメンバーの場合、コンテンツには現在のエポックのGroupContextも含まれるため、署名は特定のグループとエポックに固有です。"
    },
    {
      "indent": 3,
      "text": "The sender MUST use the private key corresponding to the following signature key depending on the sender's sender_type:",
      "ja": "送信者は、送信者のsender_typeに応じて、次の署名キーに対応する秘密キーを使用しなければなりません。"
    },
    {
      "indent": 6,
      "text": "* member: The signature key contained in the LeafNode at the index indicated by leaf_index in the ratchet tree.",
      "ja": "* メンバー：ラチェットツリー内のleaf_indexで示されるインデックスに含まれるLeafNodeにある署名キー。"
    },
    {
      "indent": 6,
      "text": "* external: The signature key at the index indicated by sender_index in the external_senders group context extension (see Section 12.1.8.1). The content_type of the message MUST be proposal and the proposal_type MUST be a value that is allowed for external senders.",
      "ja": "* external: external_senders グループコンテキスト拡張機能で示される sender_index によって示されるインデックスの署名キー（詳細はセクション12.1.8.1を参照）。メッセージの content_type は proposal でなければならず、proposal_type は external senders に許可されている値でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* new_member_commit: The signature key in the LeafNode in the Commit's path (see Section 12.4.3.2). The content_type of the message MUST be commit.",
      "ja": "* new_member_commit: Commitのパス内のLeafNodeにある署名キー（セクション12.4.3.2を参照）。メッセージのcontent_typeはcommitでなければなりません。"
    },
    {
      "indent": 6,
      "text": "* new_member_proposal: The signature key in the LeafNode in the KeyPackage embedded in an external Add proposal. The content_type of the message MUST be proposal and the proposal_type of the Proposal MUST be add.",
      "ja": "* new_member_proposal: 外部のAdd提案に埋め込まれたKeyPackage内のLeafNodeにある署名キー。メッセージのcontent_typeは提案でなければならず、提案のproposal_typeはaddでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Recipients of an MLSMessage MUST verify the signature with the key depending on the sender_type of the sender as described above.",
      "ja": "MLSMessageの受信者は、送信者のsender_typeに応じて、上記のキーで署名を検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "The confirmation tag value confirms that the members of the group have arrived at the same state of the group. A FramedContentAuthData is said to be valid when both the signature and confirmation_tag fields are valid.",
      "ja": "確認タグの値は、グループのメンバーがグループの同じ状態に到達したことを確認します。FramedContentAuthData は、署名と確認タグの両方が有効な場合に有効であると言われています。"
    },
    {
      "indent": 0,
      "text": "6.2. Encoding and Decoding a Public Message",
      "section_title": true,
      "ja": "6.2. 公開メッセージのエンコードとデコード"
    },
    {
      "indent": 3,
      "text": "Messages that are authenticated but not encrypted are encoded using the PublicMessage structure.",
      "ja": "認証されているが暗号化されていないメッセージは、PublicMessage構造を使用してエンコードされます。"
    },
    {
      "indent": 3,
      "text": "struct {\n    FramedContent content;\n    FramedContentAuthData auth;\n    select (PublicMessage.content.sender.sender_type) {\n        case member:\n            MAC membership_tag;\n        case external:\n        case new_member_commit:\n        case new_member_proposal:\n            struct{};\n    };\n} PublicMessage;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The membership_tag field in the PublicMessage object authenticates the sender's membership in the group. For messages sent by members, it MUST be set to the following value:",
      "ja": "PublicMessageオブジェクトのmembership_tagフィールドは、送信者がグループに所属していることを認証します。メンバーが送信するメッセージの場合、次の値に設定する必要があります："
    },
    {
      "indent": 3,
      "text": "struct {\n  FramedContentTBS content_tbs;\n  FramedContentAuthData auth;\n} AuthenticatedContentTBM;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "membership_tag = MAC(membership_key, AuthenticatedContentTBM)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When decoding a PublicMessage into an AuthenticatedContent, the application MUST check membership_tag and MUST check that the FramedContentAuthData is valid.",
      "ja": "PublicMessageをAuthenticatedContentにデコードする際、アプリケーションはmembership_tagをチェックし、FramedContentAuthDataが有効であることをチェックする必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3. Encoding and Decoding a Private Message",
      "section_title": true,
      "ja": "6.3. プライベートメッセージのエンコードとデコード"
    },
    {
      "indent": 3,
      "text": "Authenticated and encrypted messages are encoded using the PrivateMessage structure.",
      "ja": "認証された暗号化されたメッセージは、PrivateMessage構造を使用してエンコードされます。"
    },
    {
      "indent": 3,
      "text": "struct {\n    opaque group_id<V>;\n    uint64 epoch;\n    ContentType content_type;\n    opaque authenticated_data<V>;\n    opaque encrypted_sender_data<V>;\n    opaque ciphertext<V>;\n} PrivateMessage;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "encrypted_sender_data and ciphertext are encrypted using the AEAD function specified by the cipher suite in use, using the SenderData and PrivateMessageContent structures as input.",
      "ja": "encrypted_sender_dataとciphertextは、使用中の暗号スイートで指定されたAEAD関数を使用して、SenderDataとPrivateMessageContentの構造を入力として暗号化されます。"
    },
    {
      "indent": 0,
      "text": "6.3.1. Content Encryption",
      "section_title": true,
      "ja": "6.3.1. コンテンツの暗号化"
    },
    {
      "indent": 3,
      "text": "Content to be encrypted is encoded in a PrivateMessageContent structure.",
      "ja": "暗号化されるコンテンツは、PrivateMessageContent構造体にエンコードされます。"
    },
    {
      "indent": 3,
      "text": "struct {\n    select (PrivateMessage.content_type) {\n        case application:\n          opaque application_data<V>;\n\n        case proposal:\n          Proposal proposal;\n\n        case commit:\n          Commit commit;\n    };\n\n    FramedContentAuthData auth;\n    opaque padding[length_of_padding];\n} PrivateMessageContent;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The padding field is set by the sender, by first encoding the content (via the select) and the auth field, and then appending the chosen number of zero bytes. A receiver identifies the padding field in a plaintext decoded from PrivateMessage.ciphertext by first decoding the content and the auth field; then the padding field comprises any remaining octets of plaintext. The padding field MUST be filled with all zero bytes. A receiver MUST verify that there are no non-zero bytes in the padding field, and if this check fails, the enclosing PrivateMessage MUST be rejected as malformed. This check ensures that the padding process is deterministic, so that, for example, padding cannot be used as a covert channel.",
      "ja": "パディングフィールドは、送信者によって設定されます。まず、コンテンツ（selectを介して）と認証フィールドをエンコードし、その後選択された数のゼロバイトを追加します。受信者は、PrivateMessage.ciphertextから復号化された平文でパディングフィールドを識別します。これは、まずコンテンツと認証フィールドを復号化し、その後パディングフィールドが平文の残りのオクテットを構成することを意味します。パディングフィールドにはすべてのゼロバイトが含まれている必要があります。受信者は、パディングフィールドに非ゼロバイトがないことを確認する必要があり、このチェックに失敗した場合、包含されているPrivateMessageは不正な形式として拒否される必要があります。このチェックにより、パディングプロセスが決定論的であることが確認され、たとえば、パディングを隠しチャネルとして使用することができないようになります。"
    },
    {
      "indent": 3,
      "text": "In the MLS key schedule, the sender creates two distinct key ratchets for handshake and application messages for each member of the group. When encrypting a message, the sender looks at the ratchets it derived for its own member and chooses an unused generation from either the handshake ratchet or the application ratchet, depending on the content type of the message. This generation of the ratchet is used to derive a provisional nonce and key.",
      "ja": "MLSキースケジュールでは、送信者はグループの各メンバーに対して、ハンドシェイクメッセージとアプリケーションメッセージ用に2つの異なるキーラチェットを作成します。メッセージを暗号化する際、送信者は自分のメンバー用に導出したラチェットを見て、メッセージのコンテンツタイプに応じて、ハンドシェイクラチェットまたはアプリケーションラチェットから未使用の世代を選択します。このラチェットの世代は、仮のノンスとキーを導出するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Before use in the encryption operation, the nonce is XORed with a fresh random value to guard against reuse. Because the key schedule generates nonces deterministically, a client MUST keep persistent state as to where in the key schedule it is; if this persistent state is lost or corrupted, a client might reuse a generation that has already been used, causing reuse of a key/nonce pair.",
      "ja": "暗号化操作の前に、ノンスは再利用を防ぐために新しいランダムな値とXOR演算されます。キースケジュールがノンスを決定論的に生成するため、クライアントはキースケジュール内のどこにいるかを持続的に把握する必要があります。もし持続的な状態が失われたり破損したりすると、クライアントはすでに使用された生成を再利用する可能性があり、キー/ノンスのペアが再利用されることになります。"
    },
    {
      "indent": 3,
      "text": "To avoid this situation, the sender of a message MUST generate a fresh random four-byte \"reuse guard\" value and XOR it with the first four bytes of the nonce from the key schedule before using the nonce for encryption. The sender MUST include the reuse guard in the reuse_guard field of the sender data object, so that the recipient of the message can use it to compute the nonce to be used for decryption.",
      "ja": "この状況を避けるために、メッセージの送信者は、暗号化に使用する前に、メッセージの最初の4バイトのナンスとキースケジュールからの新しいランダムな4バイトの「再利用ガード」値を生成し、XOR演算する必要があります。送信者は、メッセージの受信者がそれを使用して復号化に使用するナンスを計算できるように、再利用ガードを送信者データオブジェクトのreuse_guardフィールドに含める必要があります。"
    },
    {
      "indent": 3,
      "text": "+-+-+-+-+---------...---+\n|   Key Schedule Nonce  |\n+-+-+-+-+---------...---+\n           XOR\n+-+-+-+-+---------...---+\n| Guard |       0       |\n+-+-+-+-+---------...---+\n           ===\n+-+-+-+-+---------...---+\n| Encrypt/Decrypt Nonce |\n+-+-+-+-+---------...---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Additional Authenticated Data (AAD) input to the encryption contains an object of the following form, with the values used to identify the key and nonce:",
      "ja": "暗号化に対する追加認証データ（AAD）の入力には、次の形式のオブジェクトが含まれており、キーとナンスを識別するために使用される値が含まれています。"
    },
    {
      "indent": 3,
      "text": "struct {\n    opaque group_id<V>;\n    uint64 epoch;\n    ContentType content_type;\n    opaque authenticated_data<V>;\n} PrivateContentAAD;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When decoding a PrivateMessageContent, the application MUST check that the FramedContentAuthData is valid.",
      "ja": "PrivateMessageContentをデコードする際、アプリケーションはFramedContentAuthDataが有効であることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "It is up to the application to decide what authenticated_data to provide and how much padding to add to a given message (if any). The overall size of the AAD and ciphertext MUST fit within the limits established for the group's AEAD algorithm in [CFRG-AEAD-LIMITS].",
      "ja": "アプリケーションが提供する認証データと、与えられたメッセージにどれだけのパディングを追加するか（あれば）は、アプリケーション次第です。AADと暗号文の全体サイズは、[CFRG-AEAD-LIMITS]で設定されたグループのAEADアルゴリズムの制限内に収まる必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3.2. Sender Data Encryption",
      "section_title": true,
      "ja": "6.3.2. 送信者データの暗号化"
    },
    {
      "indent": 3,
      "text": "The \"sender data\" used to look up the key for content encryption is encrypted with the cipher suite's AEAD with a key and nonce derived from both the sender_data_secret and a sample of the encrypted content. Before being encrypted, the sender data is encoded as an object of the following form:",
      "ja": "「送信元データ」は、コンテンツの暗号化キーを検索するために、暗号スイートのAEADで暗号化されます。この際、キーとノンスは、送信元データシークレットと暗号化されたコンテンツのサンプルから派生します。送信元データは、暗号化される前に、以下の形式のオブジェクトとしてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "struct {\n    uint32 leaf_index;\n    uint32 generation;\n    opaque reuse_guard[4];\n} SenderData;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When constructing a SenderData object from a Sender object, the sender MUST verify Sender.sender_type is member and use Sender.leaf_index for SenderData.leaf_index.",
      "ja": "SenderオブジェクトからSenderDataオブジェクトを構築する際、送信者はSender.sender_typeがメンバーであることを確認し、SenderData.leaf_indexにSender.leaf_indexを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The reuse_guard field contains a fresh random value used to avoid nonce reuse in the case of state loss or corruption, as described in Section 6.3.1.",
      "ja": "reuse_guardフィールドには、状態の損失や破損の場合に再利用されることを避けるために使用される新しいランダムな値が含まれています。これは、セクション6.3.1で説明されています。"
    },
    {
      "indent": 3,
      "text": "The key and nonce provided to the AEAD are computed as the KDF of the first KDF.Nh bytes of the ciphertext generated in the previous section. If the length of the ciphertext is less than KDF.Nh, the whole ciphertext is used. In pseudocode, the key and nonce are derived as:",
      "ja": "AEADに提供される鍵とナンスは、前のセクションで生成された暗号文の最初のKDF.NhバイトのKDFとして計算されます。暗号文の長さがKDF.Nh未満の場合、全体の暗号文が使用されます。疑似コードでは、鍵とナンスは次のように導出されます："
    },
    {
      "indent": 3,
      "text": "ciphertext_sample = ciphertext[0..KDF.Nh-1]\n\nsender_data_key = ExpandWithLabel(sender_data_secret, \"key\",\n                      ciphertext_sample, AEAD.Nk)\nsender_data_nonce = ExpandWithLabel(sender_data_secret, \"nonce\",\n                      ciphertext_sample, AEAD.Nn)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The AAD for the SenderData ciphertext is the first three fields of PrivateMessage:",
      "ja": "SenderDataの暗号文のAADは、PrivateMessageの最初の3つのフィールドです。"
    },
    {
      "indent": 3,
      "text": "struct {\n    opaque group_id<V>;\n    uint64 epoch;\n    ContentType content_type;\n} SenderDataAAD;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When parsing a SenderData struct as part of message decryption, the recipient MUST verify that the leaf index indicated in the leaf_index field identifies a non-blank node.",
      "ja": "メッセージの復号化の一環としてSenderData構造体を解析する際、受信者はleaf_indexフィールドで示された葉のインデックスが空でないノードを識別していることを必ず確認しなければなりません。"
    },
    {
      "indent": 0,
      "text": "7. Ratchet Tree Operations",
      "section_title": true,
      "ja": "7. ラチェットツリーオペレーションズ"
    },
    {
      "indent": 3,
      "text": "The ratchet tree for an epoch describes the membership of a group in that epoch, providing public key encryption (HPKE) keys that can be used to encrypt to subsets of the group as well as information to authenticate the members. In order to reflect changes to the membership of the group from one epoch to the next, corresponding changes are made to the ratchet tree. In this section, we describe the content of the tree and the required operations.",
      "ja": "エポックのためのラチェットツリーは、そのエポック内のグループのメンバーシップを記述し、サブセットのグループに暗号化に使用できる公開鍵暗号（HPKE）キーと、メンバーを認証する情報を提供します。次のエポックにおけるグループのメンバーシップの変更を反映するために、ラチェットツリーに対応する変更が行われます。このセクションでは、ツリーの内容と必要な操作について説明します。"
    },
    {
      "indent": 0,
      "text": "7.1. Parent Node Contents",
      "section_title": true,
      "ja": "7.1. 親ノードの内容"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 4.1.1, the nodes of a ratchet tree contain several types of data describing individual members (for leaf nodes) or subgroups of the group (for parent nodes). Parent nodes are simpler:",
      "ja": "セクション4.1.1で議論されたように、ラチェットツリーのノードには、個々のメンバーを記述するいくつかの種類のデータ（葉ノードの場合）またはグループのサブグループを記述するデータ（親ノードの場合）が含まれています。親ノードはより単純です："
    },
    {
      "indent": 3,
      "text": "struct {\n    HPKEPublicKey encryption_key;\n    opaque parent_hash<V>;\n    uint32 unmerged_leaves<V>;\n} ParentNode;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The encryption_key field contains an HPKE public key whose private key is held only by the members at the leaves among its descendants. The parent_hash field contains a hash of this node's parent node, as described in Section 7.9. The unmerged_leaves field lists the leaves under this parent node that are unmerged, according to their indices among all the leaves in the tree. The entries in the unmerged_leaves vector MUST be sorted in increasing order.",
      "ja": "encryption_keyフィールドには、その子孫のうち葉にいるメンバーだけが保持しているHPKE公開鍵が含まれています。parent_hashフィールドには、セクション7.9で説明されているように、このノードの親ノードのハッシュが含まれています。unmerged_leavesフィールドには、この親ノードの下にある未マージされた葉が、ツリー内のすべての葉のインデックスに従ってリストされています。unmerged_leavesベクトル内のエントリは、昇順でソートされている必要があります。"
    },
    {
      "indent": 0,
      "text": "7.2. Leaf Node Contents",
      "section_title": true,
      "ja": "7.2. 葉ノードの内容"
    },
    {
      "indent": 3,
      "text": "A leaf node in the tree describes all the details of an individual client's appearance in the group, signed by that client. It is also used in client KeyPackage objects to store the information that will be needed to add a client to a group.",
      "ja": "木構造の葉ノードは、グループ内の個々のクライアントの外見の詳細を記述し、そのクライアントによって署名されます。また、クライアントのKeyPackageオブジェクトで使用され、クライアントをグループに追加するために必要な情報を格納します。"
    },
    {
      "indent": 3,
      "text": "enum {\n    reserved(0),\n    key_package(1),\n    update(2),\n    commit(3),\n    (255)\n} LeafNodeSource;\n\nstruct {\n    ProtocolVersion versions<V>;\n    CipherSuite cipher_suites<V>;\n    ExtensionType extensions<V>;\n    ProposalType proposals<V>;\n    CredentialType credentials<V>;\n} Capabilities;\n\nstruct {\n    uint64 not_before;\n    uint64 not_after;\n} Lifetime;\n\n// See the \"MLS Extension Types\" IANA registry for values\nuint16 ExtensionType;\n\nstruct {\n    ExtensionType extension_type;\n    opaque extension_data<V>;\n} Extension;\n\nstruct {\n    HPKEPublicKey encryption_key;\n    SignaturePublicKey signature_key;\n    Credential credential;\n    Capabilities capabilities;\n\n    LeafNodeSource leaf_node_source;\n    select (LeafNode.leaf_node_source) {\n        case key_package:\n            Lifetime lifetime;\n\n        case update:\n            struct{};\n\n        case commit:\n            opaque parent_hash<V>;\n    };\n\n    Extension extensions<V>;\n    /* SignWithLabel(., \"LeafNodeTBS\", LeafNodeTBS) */\n    opaque signature<V>;\n} LeafNode;\n\nstruct {\n    HPKEPublicKey encryption_key;\n    SignaturePublicKey signature_key;\n    Credential credential;\n    Capabilities capabilities;\n\n    LeafNodeSource leaf_node_source;\n    select (LeafNodeTBS.leaf_node_source) {\n        case key_package:\n            Lifetime lifetime;\n\n        case update:\n            struct{};\n\n        case commit:\n            opaque parent_hash<V>;\n    };\n\n    Extension extensions<V>;\n\n    select (LeafNodeTBS.leaf_node_source) {\n        case key_package:\n            struct{};\n\n        case update:\n            opaque group_id<V>;\n            uint32 leaf_index;\n\n        case commit:\n            opaque group_id<V>;\n            uint32 leaf_index;\n    };\n} LeafNodeTBS;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The encryption_key field contains an HPKE public key whose private key is held only by the member occupying this leaf (or in the case of a LeafNode in a KeyPackage object, the issuer of the KeyPackage). The signature_key field contains the member's public signing key. The credential field contains information authenticating both the member's identity and the provided signing key, as described in Section 5.3.",
      "ja": "encryption_keyフィールドには、この葉を占めるメンバーだけが保持するHPKE公開鍵が含まれています（またはKeyPackageオブジェクト内のLeafNodeの場合、KeyPackageの発行者）。signature_keyフィールドには、メンバーの公開署名鍵が含まれています。credentialフィールドには、セクション5.3で説明されているように、メンバーの身元と提供された署名鍵を認証する情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "The capabilities field indicates the protocol features that the client supports, including protocol versions, cipher suites, credential types, non-default proposal types, and non-default extension types. The following proposal and extension types are considered \"default\" and MUST NOT be listed:",
      "ja": "capabilities フィールドは、クライアントがサポートするプロトコルの機能を示し、プロトコルのバージョン、暗号スイート、資格情報の種類、デフォルトでない提案の種類、およびデフォルトでない拡張の種類を含みます。以下の提案と拡張の種類は「デフォルト」と見なされ、リストされてはなりません："
    },
    {
      "indent": 6,
      "text": "* Proposal types:",
      "ja": "* 提案の種類:"
    },
    {
      "indent": 12,
      "text": "- 0x0001 - add",
      "ja": "- 0x0001 - 加算"
    },
    {
      "indent": 12,
      "text": "- 0x0002 - update",
      "ja": "- 0x0002 - 更新"
    },
    {
      "indent": 12,
      "text": "- 0x0003 - remove",
      "ja": "- 0x0003 - 削除"
    },
    {
      "indent": 12,
      "text": "- 0x0004 - psk",
      "ja": "- 0x0004 - psk"
    },
    {
      "indent": 12,
      "text": "- 0x0005 - reinit",
      "ja": "- 0x0005 - 再初期化"
    },
    {
      "indent": 12,
      "text": "- 0x0006 - external_init",
      "ja": "- 0x0006 - external_init\n0x0006 - 外部初期化"
    },
    {
      "indent": 12,
      "text": "- 0x0007 - group_context_extensions",
      "ja": "- 0x0007 - group_context_extensions\n0x0007 - グループコンテキスト拡張"
    },
    {
      "indent": 6,
      "text": "* Extension types:",
      "ja": "* 拡張タイプ:"
    },
    {
      "indent": 12,
      "text": "- 0x0001 - application_id",
      "ja": "- 0x0001 - application_id\n0x0001 - アプリケーションID"
    },
    {
      "indent": 12,
      "text": "- 0x0002 - ratchet_tree",
      "ja": "- 0x0002 - ラチェットツリー"
    },
    {
      "indent": 12,
      "text": "- 0x0003 - required_capabilities",
      "ja": "- 0x0003 - required_capabilities\n0x0003 - 必要な機能"
    },
    {
      "indent": 12,
      "text": "- 0x0004 - external_pub",
      "ja": "- 0x0004 - external_pub\n0x0004 - 外部公開"
    },
    {
      "indent": 12,
      "text": "- 0x0005 - external_senders",
      "ja": "- 0x0005 - 外部送信者"
    },
    {
      "indent": 3,
      "text": "There are no default values for the other fields of a capabilities object. The client MUST list all values for the respective parameters that it supports.",
      "ja": "capabilitiesオブジェクトの他のフィールドにはデフォルト値がありません。クライアントは、サポートする各パラメータのすべての値をリストする必要があります。"
    },
    {
      "indent": 3,
      "text": "The types of any non-default extensions that appear in the extensions field of a LeafNode MUST be included in the extensions field of the capabilities field, and the credential type used in the LeafNode MUST be included in the credentials field of the capabilities field.",
      "ja": "LeafNodeのextensionsフィールドに表示される任意の非デフォルト拡張機能の種類は、capabilitiesフィールドのextensionsフィールドに含まれている必要があり、LeafNodeで使用される資格情報の種類は、capabilitiesフィールドのcredentialsフィールドに含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 13, unknown values in capabilities MUST be ignored, and the creator of a capabilities field SHOULD include some random GREASE values to help ensure that other clients correctly ignore unknown values.",
      "ja": "セクション13で議論されたように、機能における未知の値は無視されなければならず、機能フィールドの作成者は他のクライアントが未知の値を正しく無視するようにするためにいくつかのランダムなGREASE値を含めるべきです。"
    },
    {
      "indent": 3,
      "text": "The leaf_node_source field indicates how this LeafNode came to be added to the tree. This signal tells other members of the group whether the leaf node is required to have a lifetime or parent_hash, and whether the group_id is added as context to the signature. These fields are included selectively because the client creating a LeafNode is not always able to compute all of them. For example, a KeyPackage is created before the client knows which group it will be used with, so its signature can't bind to a group_id.",
      "ja": "leaf_node_source フィールドは、この LeafNode がツリーに追加された経緯を示しています。このシグナルは、グループの他のメンバーに、そのリーフノードがライフタイムまたは親ハッシュを持つ必要があるか、および group_id が署名のコンテキストとして追加されるかを伝えます。これらのフィールドは、LeafNode を作成するクライアントが常にすべてを計算できるわけではないため、選択的に含まれています。たとえば、KeyPackage は、クライアントがどのグループで使用されるかを知る前に作成されるため、その署名は group_id にバインドできません。"
    },
    {
      "indent": 3,
      "text": "In the case where the leaf was added to the tree based on a pre-published KeyPackage, the lifetime field represents the times between which clients will consider a LeafNode valid. These times are represented as absolute times, measured in seconds since the Unix epoch (1970-01-01T00:00:00Z). Applications MUST define a maximum total lifetime that is acceptable for a LeafNode, and reject any LeafNode where the total lifetime is longer than this duration. In order to avoid disagreements about whether a LeafNode has a valid lifetime, the clients in a group SHOULD maintain time synchronization (e.g., using the Network Time Protocol [RFC5905]).",
      "ja": "葉が事前に公開されたKeyPackageに基づいて木に追加された場合、lifetimeフィールドはクライアントがLeafNodeを有効と見なす期間を表します。これらの期間は、Unixエポック（1970-01-01T00:00:00Z）以降の秒数で表された絶対時間として表されます。アプリケーションは、LeafNodeに許容される最大の総寿命を定義し、その期間よりも長い総寿命を持つLeafNodeを拒否する必要があります。LeafNodeの有効な寿命についての意見の相違を避けるために、グループ内のクライアントは時間同期を維持すべきです（たとえば、ネットワークタイムプロトコル[RFC5905]を使用）。"
    },
    {
      "indent": 3,
      "text": "In the case where the leaf node was inserted into the tree via a Commit message, the parent_hash field contains the parent hash for this leaf node (see Section 7.9).",
      "ja": "葉ノードがコミットメッセージを介してツリーに挿入された場合、parent_hashフィールドにはこの葉ノードの親ハッシュが含まれています（セクション7.9を参照）。"
    },
    {
      "indent": 3,
      "text": "The LeafNodeTBS structure covers the fields above the signature in the LeafNode. In addition, when the leaf node was created in the context of a group (the update and commit cases), the group ID of the group is added as context to the signature.",
      "ja": "LeafNodeTBS構造体は、LeafNode内の署名の上にあるフィールドをカバーしています。さらに、葉ノードがグループのコンテキストで作成された場合（更新およびコミットの場合）、グループのグループIDが署名のコンテキストとして追加されます。"
    },
    {
      "indent": 3,
      "text": "LeafNode objects stored in the group's ratchet tree are updated according to the evolution of the tree. Each modification of LeafNode content MUST be reflected by a change in its signature. This allows other members to verify the validity of the LeafNode at any time, particularly in the case of a newcomer joining the group.",
      "ja": "グループのラチェットツリーに格納されているLeafNodeオブジェクトは、ツリーの進化に応じて更新されます。LeafNodeコンテンツの変更は、その署名の変更によって反映されなければなりません。これにより、他のメンバーはLeafNodeの有効性をいつでも検証できるようになります。特に、新しくグループに参加する場合に重要です。"
    },
    {
      "indent": 0,
      "text": "7.3. Leaf Node Validation",
      "section_title": true,
      "ja": "7.3. リーフノードの検証"
    },
    {
      "indent": 3,
      "text": "The validity of a LeafNode needs to be verified at the following stages:",
      "ja": "LeafNodeの有効性は、次の段階で検証する必要があります："
    },
    {
      "indent": 6,
      "text": "* When a LeafNode is downloaded in a KeyPackage, before it is used to add the client to the group",
      "ja": "* LeafNode が KeyPackage でダウンロードされるとき、クライアントをグループに追加する前に使用される前に"
    },
    {
      "indent": 6,
      "text": "* When a LeafNode is received by a group member in an Add, Update, or Commit message",
      "ja": "* LeafNode がグループメンバーによって Add、Update、または Commit メッセージで受信された場合"
    },
    {
      "indent": 6,
      "text": "* When a client validates a ratchet tree, e.g., when joining a group or after processing a Commit",
      "ja": "* クライアントがラチェットツリーを検証する場合、例えば、グループに参加する際やCommitを処理した後など"
    },
    {
      "indent": 3,
      "text": "The client verifies the validity of a LeafNode using the following steps:",
      "ja": "クライアントは、LeafNode の有効性を次の手順で検証します："
    },
    {
      "indent": 6,
      "text": "* Verify that the credential in the LeafNode is valid, as described in Section 5.3.1.",
      "ja": "* セクション5.3.1で説明されているように、LeafNodeの資格情報が有効であることを確認してください。"
    },
    {
      "indent": 6,
      "text": "* Verify that the signature on the LeafNode is valid using signature_key.",
      "ja": "* LeafNodeの署名がsignature_keyを使用して有効であることを確認してください。"
    },
    {
      "indent": 6,
      "text": "* Verify that the LeafNode is compatible with the group's parameters. If the GroupContext has a required_capabilities extension, then the required extensions, proposals, and credential types MUST be listed in the LeafNode's capabilities field.",
      "ja": "* LeafNodeがグループのパラメータと互換性があることを確認してください。GroupContextにrequired_capabilities拡張機能がある場合、LeafNodeのcapabilitiesフィールドに必要な拡張機能、提案、および資格情報タイプをリストする必要があります。"
    },
    {
      "indent": 6,
      "text": "* Verify that the credential type is supported by all members of the group, as specified by the capabilities field of each member's LeafNode, and that the capabilities field of this LeafNode indicates support for all the credential types currently in use by other members.",
      "ja": "* グループのすべてのメンバーが指定された各メンバーのLeafNodeの機能フィールドによってサポートされている資格情報タイプを確認し、このLeafNodeの機能フィールドが他のメンバーが現在使用しているすべての資格情報タイプをサポートしていることを確認してください。"
    },
    {
      "indent": 6,
      "text": "* Verify the lifetime field:",
      "ja": "* ライフタイムフィールドを確認してください。"
    },
    {
      "indent": 12,
      "text": "- If the LeafNode appears in a message being sent by the client, e.g., a Proposal or a Commit, then the client MUST verify that the current time is within the range of the lifetime field.",
      "ja": "- LeafNode がクライアントから送信されるメッセージに現れた場合、例えば、Proposal や Commit の場合、クライアントは現在の時間が lifetime フィールドの範囲内にあることを検証しなければなりません。"
    },
    {
      "indent": 12,
      "text": "- If instead the LeafNode appears in a message being received by the client, e.g., a Proposal, a Commit, or a ratchet tree of the group the client is joining, it is RECOMMENDED that the client verifies that the current time is within the range of the lifetime field. (This check is not mandatory because the LeafNode might have expired in the time between when the message was sent and when it was received.)",
      "ja": "- もしLeafNodeがクライアントが受信したメッセージに現れた場合、例えば、提案、コミット、またはクライアントが参加しているグループのラチェットツリーなど、現在の時間がlifetimeフィールドの範囲内にあることをクライアントが検証することが推奨されます。（このチェックは必須ではありません。なぜならLeafNodeはメッセージが送信された時点と受信された時点の間に期限切れになっている可能性があるからです。）"
    },
    {
      "indent": 6,
      "text": "* Verify that the extensions in the LeafNode are supported by checking that the ID for each extension in the extensions field is listed in the capabilities.extensions field of the LeafNode.",
      "ja": "* LeafNode内の拡張機能がサポートされていることを確認するには、LeafNodeのcapabilities.extensionsフィールドに拡張機能ごとのIDがリストされているかを確認してください。"
    },
    {
      "indent": 6,
      "text": "* Verify the leaf_node_source field:",
      "ja": "* leaf_node_sourceフィールドを確認してください。"
    },
    {
      "indent": 12,
      "text": "- If the LeafNode appears in a KeyPackage, verify that leaf_node_source is set to key_package.",
      "ja": "- LeafNode が KeyPackage に表示される場合は、leaf_node_source が key_package に設定されていることを確認してください。"
    },
    {
      "indent": 12,
      "text": "- If the LeafNode appears in an Update proposal, verify that leaf_node_source is set to update and that encryption_key represents a different public key than the encryption_key in the leaf node being replaced by the Update proposal.",
      "ja": "- LeafNode が Update 提案に現れた場合、leaf_node_source が update に設定されていることを確認し、encryption_key が Update 提案によって置き換えられる LeafNode 内の encryption_key と異なる公開鍵を表していることを確認してください。"
    },
    {
      "indent": 12,
      "text": "- If the LeafNode appears in the leaf_node value of the UpdatePath in a Commit, verify that leaf_node_source is set to commit.",
      "ja": "- もしLeafNodeがCommit内のUpdatePathのleaf_node値に現れた場合は、leaf_node_sourceがcommitに設定されていることを確認してください。"
    },
    {
      "indent": 6,
      "text": "* Verify that the following fields are unique among the members of the group:",
      "ja": "* 次のフィールドがグループのメンバーの間で一意であることを確認してください。"
    },
    {
      "indent": 12,
      "text": "- signature_key",
      "ja": "- 署名キー"
    },
    {
      "indent": 12,
      "text": "- encryption_key",
      "ja": "- 暗号化キー"
    },
    {
      "indent": 0,
      "text": "7.4. Ratchet Tree Evolution",
      "section_title": true,
      "ja": "7.4. ラチェットツリーエボリューション"
    },
    {
      "indent": 3,
      "text": "Whenever a member initiates an epoch change (i.e., commits; see Section 12.4), they may need to refresh the key pairs of their leaf and of the nodes on their leaf's direct path in order to maintain forward secrecy and post-compromise security.",
      "ja": "メンバーがエポックの変更を開始するたびに（つまり、コミットする場合；セクション12.4を参照）、前方秘匿性とコンプロミス後のセキュリティを維持するために、そのメンバーは、自分のリーフとリーフの直接パス上のノードのキーペアを更新する必要があります。"
    },
    {
      "indent": 3,
      "text": "The member initiating the epoch change generates the fresh key pairs using the following procedure. The procedure is designed in a way that allows group members to efficiently communicate the fresh secret keys to other group members, as described in Section 7.6.",
      "ja": "エポック変更を開始するメンバーは、次の手順を使用して新しいキーペアを生成します。この手順は、セクション7.6で説明されているように、グループメンバーが効率的に新しい秘密キーを他のグループメンバーに伝達できるように設計されています。"
    },
    {
      "indent": 3,
      "text": "A member updates the nodes along its direct path as follows:",
      "ja": "メンバーは、直接のパスに沿ってノードを更新します。"
    },
    {
      "indent": 6,
      "text": "* Blank all the nodes on the direct path from the leaf to the root.",
      "ja": "* 葉から根に至る直接のパス上のすべてのノードを空白にしてください。"
    },
    {
      "indent": 6,
      "text": "* Generate a fresh HPKE key pair for the leaf.",
      "ja": "* 葉のために新しいHPKEキーペアを生成してください。"
    },
    {
      "indent": 6,
      "text": "* Generate a sequence of path secrets, one for each node on the leaf's filtered direct path, as follows. In this setting, path_secret[0] refers to the first parent node in the filtered direct path, path_secret[1] to the second parent node, and so on.",
      "ja": "* 次のように、葉のフィルタリングされた直接パス上の各ノードに対してパスシークレットのシーケンスを生成します。この設定では、path_secret[0] はフィルタリングされた直接パス内の最初の親ノードを指し、path_secret[1] は2番目の親ノードを指し、以降となります。"
    },
    {
      "indent": 3,
      "text": "path_secret[0] is sampled at random\npath_secret[n] = DeriveSecret(path_secret[n-1], \"path\")",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "* Compute the sequence of HPKE key pairs (node_priv,node_pub), one for each node on the leaf's direct path, as follows.",
      "ja": "* 以下のように、葉の直接のパス上の各ノードについて、HPKE鍵ペア（node_priv、node_pub）のシーケンスを計算してください。"
    },
    {
      "indent": 3,
      "text": "node_secret[n] = DeriveSecret(path_secret[n], \"node\")\nnode_priv[n], node_pub[n] = KEM.DeriveKeyPair(node_secret[n])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The node secret is derived as a temporary intermediate secret so that each secret is only used with one algorithm: The path secret is used as an input to DeriveSecret, and the node secret is used as an input to DeriveKeyPair.",
      "ja": "ノードの秘密は一時的な中間秘密として導出されるため、各秘密は1つのアルゴリズムのみで使用されます：パスの秘密はDeriveSecretの入力として使用され、ノードの秘密はDeriveKeyPairの入力として使用されます。"
    },
    {
      "indent": 3,
      "text": "For example, suppose there is a group with four members, with C an unmerged leaf at Z:",
      "ja": "例えば、4人のメンバーからなるグループがあり、CがZで未統合の葉であるとします。"
    },
    {
      "indent": 3,
      "text": "      Y\n      |\n    .-+-.\n   /     \\\n  X       Z[C]\n / \\     / \\\nA   B   C   D\n\n0   1   2   3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 13: A Full Tree with One Unmerged Leaf",
      "ja": "図13：1つの未マージされた葉を持つ完全な木"
    },
    {
      "indent": 3,
      "text": "If member B subsequently generates an UpdatePath based on a secret \"leaf_secret\", then it would generate the following sequence of path secrets:",
      "ja": "もしメンバーBがその後に秘密の「leaf_secret」に基づいてUpdatePathを生成した場合、次のパスシークレットのシーケンスが生成されます："
    },
    {
      "indent": 3,
      "text": "path_secret[1] ---> node_secret[1] -------> node_priv[1], node_pub[1]\n\n     ^\n     |\n     |\npath_secret[0] ---> node_secret[0] -------> node_priv[0], node_pub[0]\n\n     ^\n     |\n     |\nleaf_secret ------> leaf_node_secret --+--> leaf_priv, leaf_pub\n                                           |                   |\n                                            '-------. .-------'\n                                                     |\n                                                 leaf_node",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 14: Derivation of Ratchet Tree Keys along a Direct Path",
      "ja": "図14：直接パスに沿ったラチェットツリーキーの導出"
    },
    {
      "indent": 3,
      "text": "After applying the UpdatePath, the tree will have the following structure:",
      "ja": "UpdatePathを適用した後、木の構造は次のようになります："
    },
    {
      "indent": 3,
      "text": "node_priv[1] --------> Y'\n                       |\n                     .-+-.\n                    /     \\\nnode_priv[0] ----> X'      Z[C]\n                  / \\     / \\\n                 A   B   C   D\n                     ^\nleaf_priv -----------+\n                 0   1   2   3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 15: Placement of Keys in a Ratchet Tree",
      "ja": "図15：ラチェットツリー内のキーの配置"
    },
    {
      "indent": 0,
      "text": "7.5. Synchronizing Views of the Tree",
      "section_title": true,
      "ja": "7.5. 木のビューを同期させる"
    },
    {
      "indent": 3,
      "text": "After generating fresh key material and applying it to update their local tree state as described in Section 7.4, the generator broadcasts this update to other members of the group in a Commit message, who apply it to keep their local views of the tree in sync with the sender's. More specifically, when a member commits a change to the tree (e.g., to add or remove a member), it transmits an UpdatePath containing a set of public keys and encrypted path secrets for intermediate nodes in the filtered direct path of its leaf. The other members of the group use these values to update their view of the tree, aligning their copy of the tree to the sender's.",
      "ja": "新しい鍵素材を生成し、セクション7.4で説明されているようにそれを適用してローカルツリー状態を更新した後、発生器はこの更新をコミットメッセージでグループの他のメンバーにブロードキャストします。他のメンバーはこれを適用して、送信者と同期したツリーのローカルビューを維持します。より具体的には、メンバーがツリーに変更をコミットするとき（例：メンバーを追加または削除するとき）、そのメンバーは、その葉のフィルタリングされた直接パスの中間ノードのための一連の公開鍵と暗号化されたパスシークレットを含むUpdatePathを送信します。グループの他のメンバーはこれらの値を使用して、ツリーのビューを更新し、自分のコピーを送信者のものに合わせます。"
    },
    {
      "indent": 3,
      "text": "An UpdatePath contains the following information for each node in the filtered direct path of the sender's leaf, including the root:",
      "ja": "UpdatePathには、送信元の葉のフィルタリングされた直接パス内の各ノードについて、ルートを含む以下の情報が含まれています。"
    },
    {
      "indent": 6,
      "text": "* The public key for the node",
      "ja": "* ノードの公開鍵"
    },
    {
      "indent": 6,
      "text": "* One or more encrypted copies of the path secret corresponding to the node",
      "ja": "* ノードに対応するパスの秘密の1つ以上の暗号化されたコピー"
    },
    {
      "indent": 3,
      "text": "The path secret value for a given node is encrypted to the subtree rooted at the parent's non-updated child, i.e., the child on the copath of the sender's leaf node. There is one encryption of the path secret to each public key in the resolution of the non-updated child.",
      "ja": "与えられたノードのパス秘密値は、親の非更新子にルート付けされたサブツリーに暗号化されます。つまり、送信者の葉ノードのコパスにある子ノードです。非更新子の解決において、パス秘密値は各公開鍵に対して1つの暗号化が行われます。"
    },
    {
      "indent": 3,
      "text": "A member of the group _updates their direct path_ by computing new values for their leaf node and the nodes along their filtered direct path as follows:",
      "ja": "グループのメンバーは、次のようにして、葉ノードとフィルタされた直接パスに沿ったノードの新しい値を計算して、自分の直接パスを更新します："
    },
    {
      "indent": 8,
      "text": "1. Blank all nodes along the direct path of the sender's leaf.",
      "ja": "1. 送信者の葉の直接のパスに沿ってすべてのノードを空白にしてください。"
    },
    {
      "indent": 8,
      "text": "2. Compute updated path secrets and public keys for the nodes on the sender's filtered direct path.",
      "ja": "2. 送信元のフィルタリングされた直接パス上のノードの更新されたパスシークレットと公開鍵を計算してください。"
    },
    {
      "indent": 14,
      "text": "* Generate a sequence of path secrets of the same length as the filtered direct path, as defined in Section 7.4.",
      "ja": "* セクション7.4で定義されているフィルタリングされた直接パスと同じ長さのパスシークレットのシーケンスを生成してください。"
    },
    {
      "indent": 14,
      "text": "* For each node in the filtered direct path, replace the node's public key with the node_pub[n] value derived from the corresponding path secret path_secret[n].",
      "ja": "* フィルターされた直接パス内の各ノードについて、ノードの公開鍵を対応するパス秘密パス_secret[n]から導出されたnode_pub[n]の値で置き換えてください。"
    },
    {
      "indent": 8,
      "text": "3. Compute the new parent hashes for the nodes along the filtered direct path and the sender's leaf node.",
      "ja": "3. フィルターされた直接パスと送信者の葉ノードに沿ったノードの新しい親ハッシュを計算してください。"
    },
    {
      "indent": 8,
      "text": "4. Update the leaf node for the sender.",
      "ja": "4. 送信者の葉ノードを更新してください。"
    },
    {
      "indent": 14,
      "text": "* Set the leaf_node_source to commit.",
      "ja": "* leaf_node_sourceをcommitに設定してください。"
    },
    {
      "indent": 14,
      "text": "* Set the encryption_key to the public key of a freshly sampled key pair.",
      "ja": "* 暗号化キーを新しくサンプリングされたキーペアの公開鍵に設定してください。"
    },
    {
      "indent": 14,
      "text": "* Set the parent hash to the parent hash for the leaf.",
      "ja": "* 葉の親ハッシュを親ハッシュに設定してください。"
    },
    {
      "indent": 14,
      "text": "* Re-sign the leaf node with its new contents.",
      "ja": "* 新しい内容で葉ノードを再署名してください。"
    },
    {
      "indent": 3,
      "text": "Since the new leaf node effectively updates an existing leaf node in the group, it MUST adhere to the same restrictions as LeafNodes used in Update proposals (aside from leaf_node_source). The application MAY specify other changes to the leaf node, e.g., providing a new signature key, updated capabilities, or different extensions.",
      "ja": "新しいリーフノードは、グループ内の既存のリーフノードを効果的に更新するため、リーフノードがUpdate提案で使用される際の制限に従う必要があります（leaf_node_sourceを除く）。アプリケーションは、リーフノードに他の変更を指定することができます。例えば、新しい署名キーの提供、更新された機能、または異なる拡張機能などです。"
    },
    {
      "indent": 3,
      "text": "The member then _encrypts path secrets to the group_. For each node in the member's filtered direct path, the member takes the following steps:",
      "ja": "メンバーはその後、グループにパスの秘密を暗号化します。メンバーのフィルタリングされた直接パス内の各ノードに対して、メンバーは以下の手順を踏みます。"
    },
    {
      "indent": 8,
      "text": "1. Compute the resolution of the node's child that is on the copath of the sender (the child that is not in the direct path of the sender). Any new member (from an Add proposal) added in the same Commit MUST be excluded from this resolution.",
      "ja": "1. 送信者のコパス上にあるノードの子の解像度を計算します（送信者の直接のパスにない子）。同じコミットに追加された新しいメンバー（Add提案から）は、この解像度から除外されなければなりません。"
    },
    {
      "indent": 8,
      "text": "2. For each node in the resolution, encrypt the path secret for the direct path node using the public key of the resolution node, as defined in Section 7.6.",
      "ja": "2. 解決策内の各ノードについて、セクション7.6で定義された解決ノードの公開鍵を使用して、直接パスノードのパスシークレットを暗号化してください。"
    },
    {
      "indent": 3,
      "text": "The recipient of an UpdatePath performs the corresponding steps. First, the recipient _merges UpdatePath into the tree_:",
      "ja": "UpdatePathの受信者は対応する手順を実行します。まず、受信者はUpdatePathをツリーにマージします。"
    },
    {
      "indent": 8,
      "text": "1. Blank all nodes on the direct path of the sender's leaf.",
      "ja": "1. 送信者の葉の直接のパス上のすべてのノードを空白にしてください。"
    },
    {
      "indent": 8,
      "text": "2. For all nodes on the filtered direct path of the sender's leaf,",
      "ja": "2. 送信元の葉のフィルタリングされた直接パス上のすべてのノードに対して、"
    },
    {
      "indent": 14,
      "text": "* Set the public key to the public key in the UpdatePath.",
      "ja": "* UpdatePath内の公開鍵を公開鍵に設定してください。"
    },
    {
      "indent": 14,
      "text": "* Set the list of unmerged leaves to the empty list.",
      "ja": "* 未マージの葉のリストを空のリストに設定してください。"
    },
    {
      "indent": 8,
      "text": "3. Compute parent hashes for the nodes in the sender's filtered direct path, and verify that the parent_hash field of the leaf node matches the parent hash for the first node in its filtered direct path.",
      "ja": "3. 送信元のフィルタリングされた直接パス内のノードの親ハッシュを計算し、葉ノードのparent_hashフィールドがそのフィルタリングされた直接パス内の最初のノードの親ハッシュと一致することを検証してください。"
    },
    {
      "indent": 14,
      "text": "* Note that these hashes are computed from root to leaf, so that each hash incorporates all the non-blank nodes above it. The root node always has a zero-length hash for its parent hash.",
      "ja": "* これらのハッシュは、根から葉まで計算されることに注意してください。そのため、各ハッシュはそれより上のすべての空でないノードを組み込みます。根ノードは常に親ハッシュの長さがゼロのハッシュを持ちます。"
    },
    {
      "indent": 3,
      "text": "Second, the recipient _decrypts the path secrets_:",
      "ja": "次に、受信者はパスの秘密を復号化します。"
    },
    {
      "indent": 8,
      "text": "1. Identify a node in the filtered direct path for which the recipient is in the subtree of the non-updated child.",
      "ja": "1. 更新されていない子ノードのサブツリー内に受信者がいるフィルタリングされた直接パスのノードを特定してください。"
    },
    {
      "indent": 8,
      "text": "2. Identify a node in the resolution of the copath node for which the recipient has a private key.",
      "ja": "2. 受信者がプライベートキーを持っているコパスノードの解決中にノードを特定してください。"
    },
    {
      "indent": 8,
      "text": "3. Decrypt the path secret for the parent of the copath node using the private key from the resolution node.",
      "ja": "3. 解決ノードからの秘密鍵を使用して、コパスノードの親のパスの秘密を復号化してください。"
    },
    {
      "indent": 8,
      "text": "4. Derive path secrets for ancestors of that node in the sender's filtered direct path using the algorithm described above.",
      "ja": "4. 上記のアルゴリズムを使用して、送信者のフィルタリングされた直接パス内のそのノードの祖先のパスシークレットを導出します。"
    },
    {
      "indent": 8,
      "text": "5. Derive the node secrets and node key pairs from the path secrets.",
      "ja": "5. パスの秘密からノードの秘密とノードの鍵ペアを導出してください。"
    },
    {
      "indent": 8,
      "text": "6. Verify that the derived public keys are the same as the corresponding public keys sent in the UpdatePath.",
      "ja": "6. UpdatePath で送信された対応する公開鍵と導出された公開鍵が同じであることを確認してください。"
    },
    {
      "indent": 8,
      "text": "7. Store the derived private keys in the corresponding ratchet tree nodes.",
      "ja": "7. 対応するラチェットツリーノードに導出されたプライベートキーを保存してください。"
    },
    {
      "indent": 3,
      "text": "For example, in order to communicate the example update described in Section 7.4, the member at node B would transmit the following values:",
      "ja": "例えば、セクション7.4で説明されている更新例を伝えるために、ノードBのメンバーは以下の値を送信します："
    },
    {
      "indent": 0,
      "text": "+=============+====================================================+\n| Public Key  | Ciphertext(s)                                      |\n+=============+====================================================+\n| node_pub[1] | E(pk(Z), path_secret[1]), E(pk(C), path_secret[1]) |\n+-------------+----------------------------------------------------+\n| node_pub[0] | E(pk(A), path_secret[0])                           |\n+-------------+----------------------------------------------------+\n\n                              Table 3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In this table, the value node_pub[i] represents the public key derived from node_secret[i], pk(X) represents the current public key of node X, and E(K, S) represents the public key encryption of the path secret S to the public key K (using HPKE).",
      "ja": "この表では、値 node_pub[i] は node_secret[i] から導出された公開鍵を表し、pk(X) はノード X の現在の公開鍵を表し、E(K, S) はパスの秘密情報 S を公開鍵 K に対して公開鍵暗号化したものを表します（HPKE を使用）。"
    },
    {
      "indent": 3,
      "text": "A recipient at node A would decrypt E(pk(A), path_secret\\[0\\]) to obtain path_secret\\[0\\], then use it to derive path_secret[1] and the resulting node secrets and key pairs. Thus, A would have the private keys to nodes X' and Y', in accordance with the tree invariant.",
      "ja": "ノードAの受信者は、path_secret\\[0\\]を取得するために E(pk(A), path_secret\\[0\\]) を復号化し、その後それを使用して path_secret[1] およびその結果のノードの秘密情報と鍵ペアを導出します。したがって、Aはツリー不変条件に従って、ノードX'とY'の秘密鍵を持つことになります。"
    },
    {
      "indent": 3,
      "text": "Similarly, a recipient at node D would decrypt E(pk(Z), path_secret[1]) to obtain path_secret[1], then use it to derive the node secret and key pair for the node Y'. As required to maintain the tree invariant, node D does not receive the private key for the node X', since X' is not an ancestor of D.",
      "ja": "同様に、ノードDの受信者は、E(pk(Z), path_secret[1])を復号してpath_secret[1]を取得し、それを使用してノードY'のノードシークレットとキーペアを導出します。ツリー不変条件を維持するために、ノードDは、Dの祖先でないX'のノードの秘密鍵を受け取りません。"
    },
    {
      "indent": 3,
      "text": "After processing the update, each recipient MUST delete outdated key material, specifically:",
      "ja": "更新を処理した後、各受信者は特に古いキーマテリアルを削除しなければなりません。"
    },
    {
      "indent": 6,
      "text": "* The path secrets and node secrets used to derive each updated node key pair.",
      "ja": "* 更新されたノードキーペアを導出するために使用されるパスの秘密とノードの秘密。"
    },
    {
      "indent": 6,
      "text": "* Each outdated node key pair that was replaced by the update.",
      "ja": "* 更新によって置き換えられた各古いノードのキー・ペア。"
    },
    {
      "indent": 0,
      "text": "7.6. Update Paths",
      "section_title": true,
      "ja": "7.6. パスを更新します。"
    },
    {
      "indent": 3,
      "text": "As described in Section 12.4, each Commit message may optionally contain an UpdatePath, with a new LeafNode and set of parent nodes for the sender's filtered direct path. For each parent node, the UpdatePath contains a new public key and encrypted path secret. The parent nodes are kept in the same order as the filtered direct path.",
      "ja": "セクション12.4に記載されているように、各Commitメッセージには、送信者のフィルタリングされた直接パスの新しいLeafNodeと親ノードのセットを含むUpdatePathがオプションで含まれる場合があります。各親ノードには、UpdatePathに新しい公開鍵と暗号化されたパスの秘密が含まれています。親ノードは、フィルタリングされた直接パスと同じ順序で保持されます。"
    },
    {
      "indent": 3,
      "text": "struct {\n    opaque kem_output<V>;\n    opaque ciphertext<V>;\n} HPKECiphertext;\n\nstruct {\n    HPKEPublicKey encryption_key;\n    HPKECiphertext encrypted_path_secret<V>;\n} UpdatePathNode;\n\nstruct {\n    LeafNode leaf_node;\n    UpdatePathNode nodes<V>;\n} UpdatePath;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For each UpdatePathNode, the resolution of the corresponding copath node MUST exclude all new leaf nodes added as part of the current Commit. The length of the encrypted_path_secret vector MUST be equal to the length of the resolution of the copath node (excluding new leaf nodes), with each ciphertext being the encryption to the respective resolution node.",
      "ja": "各UpdatePathNodeについて、対応するcopathノードの解決は、現在のCommitの一部として追加されたすべての新しい葉ノードを除外する必要があります。encrypted_path_secretベクトルの長さは、copathノードの解決の長さ（新しい葉ノードを除く）と等しくなければならず、各暗号文はそれぞれの解決ノードへの暗号化です。"
    },
    {
      "indent": 3,
      "text": "The HPKECiphertext values are encrypted and decrypted as follows:",
      "ja": "HPKECiphertextの値は、次のように暗号化および復号化されます："
    },
    {
      "indent": 3,
      "text": "(kem_output, ciphertext) =\n  EncryptWithLabel(node_public_key, \"UpdatePathNode\",\n                   group_context, path_secret)\n\npath_secret =\n  DecryptWithLabel(node_private_key, \"UpdatePathNode\",\n                   group_context, kem_output, ciphertext)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Here node_public_key is the public key of the node for which the path secret is encrypted, group_context is the provisional GroupContext object for the group, and the EncryptWithLabel function is as defined in Section 5.1.3.",
      "ja": "ここで、node_public_keyはパスの秘密が暗号化されるノードの公開鍵であり、group_contextはグループの仮のGroupContextオブジェクトであり、EncryptWithLabel関数は5.1.3節で定義されているものとします。"
    },
    {
      "indent": 0,
      "text": "7.7. Adding and Removing Leaves",
      "section_title": true,
      "ja": "7.7. 葉の追加と削除"
    },
    {
      "indent": 3,
      "text": "In addition to the path-based updates to the tree described above, it is also necessary to add and remove leaves of the tree in order to reflect changes to the membership of the group (see Sections 12.1.1 and 12.1.3). Since the tree is always full, adding or removing leaves corresponds to increasing or decreasing the depth of the tree, resulting in the number of leaves being doubled or halved. These operations are also known as _extending_ and _truncating_ the tree.",
      "ja": "上記で説明したツリーへのパスベースの更新に加えて、グループのメンバーシップの変更を反映するためにツリーの葉を追加および削除する必要があります（12.1.1節および12.1.3節を参照）。ツリーは常に満杯であるため、葉を追加または削除することはツリーの深さを増減させることに対応し、葉の数が倍増または半減することになります。これらの操作は、ツリーを「拡張」または「切り詰める」とも呼ばれています。"
    },
    {
      "indent": 3,
      "text": "Leaves are always added and removed at the right edge of the tree. When the size of the tree needs to be increased, a new blank root node is added, whose left subtree is the existing tree and right subtree is a new all-blank subtree. This operation is typically done when adding a member to the group.",
      "ja": "葉は常に木の右端に追加および削除されます。木のサイズを増やす必要がある場合、新しい空の根ノードが追加され、その左部分木は既存の木であり、右部分木は新しい全て空の部分木です。この操作は通常、グループにメンバーを追加する際に行われます。"
    },
    {
      "indent": 3,
      "text": "                  _ <-- new blank root                    _\n                __|__                                   __|__\n               /     \\                                 /     \\\n  X    ===>   X       _ <-- new blank subtree ===>    X       _\n / \\         / \\     / \\                             / \\     / \\\nA   B       A   B   _   _                           A   B   C   _\n                                                            ^\n                                                            |\n                                               new member --+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 16: Extending the Tree to Make Room for a Third Member",
      "ja": "図16：3人目のメンバーのために木を拡張する"
    },
    {
      "indent": 3,
      "text": "When the right subtree of the tree no longer has any non-blank nodes, it can be safely removed. The root of the tree and the right subtree are discarded (whether or not the root node is blank). The left child of the root becomes the new root node, and the left subtree becomes the new tree. This operation is typically done after removing a member from the group.",
      "ja": "木の右部分木に非空のノードがもう存在しない場合、安全に削除できます。木の根と右部分木は破棄されます（根ノードが空であるかどうかに関わらず）。根の左の子が新しい根ノードとなり、左部分木が新しい木となります。この操作は通常、グループからメンバーを削除した後に行われます。"
    },
    {
      "indent": 3,
      "text": "               Y                  Y\n             __|__              __|__\n            /     \\            /     \\\n           X       _   ===>   X       _   ==>   X <-- new root\n          / \\     / \\        / \\     / \\       / \\\n         A   B   C   _      A   B   _   _     A   B\n                 ^\n                 |\nremoved member --+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 17: Cleaning Up after Removing Member C",
      "ja": "図17：メンバーCを削除した後のクリーンアップ"
    },
    {
      "indent": 3,
      "text": "Concrete algorithms for these operations on array-based and link-based trees are provided in Appendices C and D. The concrete algorithms are non-normative. An implementation may use any algorithm that produces the correct tree in its internal representation.",
      "ja": "配列ベースおよびリンクベースの木構造に対するこれらの操作の具体的なアルゴリズムは、付録CおよびDに提供されています。これらの具体的なアルゴリズムは非規範的です。実装は、内部表現で正しい木構造を生成する任意のアルゴリズムを使用することができます。"
    },
    {
      "indent": 0,
      "text": "7.8. Tree Hashes",
      "section_title": true,
      "ja": "7.8. 木のハッシュ"
    },
    {
      "indent": 3,
      "text": "MLS hashes the contents of the tree in two ways to authenticate different properties of the tree. _Tree hashes_ are defined in this section, and _parent hashes_ are defined in Section 7.9.",
      "ja": "MLSは、ツリーの内容を2つの方法でハッシュ化して、ツリーの異なるプロパティを認証します。このセクションでは「ツリーハッシュ」が定義されており、セクション7.9では「親ハッシュ」が定義されています。"
    },
    {
      "indent": 3,
      "text": "Each node in a ratchet tree has a tree hash that summarizes the subtree below that node. The tree hash of the root is used in the GroupContext to confirm that the group agrees on the whole tree. Tree hashes are computed recursively from the leaves up to the root.",
      "ja": "各ノードは、そのノードの下の部分木を要約するツリーハッシュを持っています。ルートのツリーハッシュは、グループ全体が同意していることを確認するためにGroupContextで使用されます。ツリーハッシュは、葉からルートに向かって再帰的に計算されます。"
    },
    {
      "indent": 3,
      "text": "P --> th(P)\n      ^ ^\n     /   \\\n    /     \\\nth(L)     th(R)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Figure 18: Composition of the Tree Hash",
      "ja": "図18：ツリーハッシュの構成"
    },
    {
      "indent": 3,
      "text": "The tree hash of an individual node is the hash of the node's TreeHashInput object, which may contain either a LeafNodeHashInput or a ParentNodeHashInput depending on the type of node. LeafNodeHashInput objects contain the leaf_index and the LeafNode (if any). ParentNodeHashInput objects contain the ParentNode (if any) and the tree hash of the node's left and right children. For both parent and leaf nodes, the optional node value MUST be absent if the node is blank and present if the node contains a value.",
      "ja": "個々のノードのツリーハッシュは、ノードのTreeHashInputオブジェクトのハッシュであり、ノードの種類に応じてLeafNodeHashInputまたはParentNodeHashInputを含むことがあります。LeafNodeHashInputオブジェクトには、leaf_indexとLeafNode（あれば）が含まれます。ParentNodeHashInputオブジェクトには、ParentNode（あれば）とノードの左右の子のツリーハッシュが含まれます。親ノードと葉ノードの両方において、ノードが空白の場合はオプションのノード値は存在してはならず、ノードに値が含まれている場合は存在していなければなりません。"
    },
    {
      "indent": 3,
      "text": "enum {\n    reserved(0),\n    leaf(1),\n    parent(2),\n    (255)\n} NodeType;\n\nstruct {\n  NodeType node_type;\n  select (TreeHashInput.node_type) {\n    case leaf:   LeafNodeHashInput leaf_node;\n    case parent: ParentNodeHashInput parent_node;\n  };\n} TreeHashInput;\n\nstruct {\n    uint32 leaf_index;\n    optional<LeafNode> leaf_node;\n} LeafNodeHashInput;\n\nstruct {\n    optional<ParentNode> parent_node;\n    opaque left_hash<V>;\n    opaque right_hash<V>;\n} ParentNodeHashInput;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The tree hash of an entire tree corresponds to the tree hash of the root node, which is computed recursively by starting at the leaf nodes and building up.",
      "ja": "木全体のツリーハッシュは、根ノードのツリーハッシュに対応しており、葉ノードから再帰的に計算され、構築されます。"
    },
    {
      "indent": 0,
      "text": "7.9. Parent Hashes",
      "section_title": true,
      "ja": "7.9. 親ハッシュ"
    },
    {
      "indent": 3,
      "text": "While tree hashes summarize the state of a tree at point in time, parent hashes capture information about how keys in the tree were populated.",
      "ja": "木のハッシュは特定の時点での木の状態を要約しますが、親ハッシュは木の中のキーがどのように設定されたかに関する情報を捉えます。"
    },
    {
      "indent": 3,
      "text": "When a client sends a Commit to change a group, it can include an UpdatePath to assign new keys to the nodes along its filtered direct path. When a client computes an UpdatePath (as defined in Section 7.5), it computes and signs a parent hash that summarizes the state of the tree after the UpdatePath has been applied. These summaries are constructed in a chain from the root to the member's leaf so that the part of the chain closer to the root can be overwritten as nodes set in one UpdatePath are reset by a later UpdatePath.",
      "ja": "クライアントがグループを変更するためにCommitを送信すると、フィルタリングされた直接パスに沿ってノードに新しいキーを割り当てるためのUpdatePathを含めることができます。クライアントがUpdatePathを計算するとき（セクション7.5で定義されているように）、UpdatePathが適用された後のツリーの状態を要約する親ハッシュを計算して署名します。これらの要約は、ルートからメンバーの葉までのチェーンで構築されるため、ルートに近いチェーンの部分は、1つのUpdatePathで設定されたノードが後のUpdatePathによってリセットされることによって上書きされることができます。"
    },
    {
      "indent": 3,
      "text": "                     ph(Q)\n                     /\n                    /\n                   V\nP.public_key --> ph(P)\n                 / ^\n                /   \\\n               V     \\\n   N.parent_hash     th(S)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 19: Inputs to a Parent Hash",
      "ja": "図19：親ハッシュへの入力"
    },
    {
      "indent": 3,
      "text": "As a result, the signature over the parent hash in each member's leaf effectively signs the subtree of the tree that hasn't been changed since that leaf was last changed in an UpdatePath. A new member joining the group uses these parent hashes to verify that the parent nodes in the tree were set by members of the group, not chosen by an external attacker. For an example of how this works, see Appendix B.",
      "ja": "その結果、各メンバーのリーフでの親ハッシュ上の署名は、そのリーフが最後にUpdatePathで変更されてから変更されていないツリーのサブツリーに効果的に署名します。 グループに新しいメンバーが参加すると、この親ハッシュを使用して、ツリー内の親ノードがグループのメンバーによって設定されたものであり、外部の攻撃者によって選択されたものではないことを検証します。 これがどのように機能するかの例については、付録Bを参照してください。"
    },
    {
      "indent": 3,
      "text": "Consider a ratchet tree with a non-blank parent node P and children D and S (for \"parent\", \"direct path\", and \"sibling\"), with D and P in the direct path of a leaf node L (for \"leaf\"):",
      "ja": "葉ノードL（\"leaf\"）の直接パスにあるDとPを持つ、空でない親ノードPと子ノードDとS（\"parent\"、\"direct path\"、\"sibling\"）を持つラチェットツリーを考えてみましょう。"
    },
    {
      "indent": 3,
      "text": "         ...\n         /\n        P\n      __|__\n     /     \\\n    D       S\n   / \\     / \\\n ... ... ... ...\n /\nL",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Figure 20: Nodes Involved in a Parent Hash Computation",
      "ja": "図20：親ハッシュ計算に関与するノード"
    },
    {
      "indent": 3,
      "text": "The parent hash of P changes whenever an UpdatePath object is applied to the ratchet tree along a path from a leaf L traversing node D (and hence also P). The new \"Parent hash of P (with copath child S)\" is obtained by hashing P's ParentHashInput struct.",
      "ja": "Pの親ハッシュは、葉LからノードD（そしてPも含む）を通るパスにUpdatePathオブジェクトが適用されるたびに変更されます。新しい「Pの親ハッシュ（共経路の子Sを持つ）」は、PのParentHashInput構造体をハッシュ化して得られます。"
    },
    {
      "indent": 3,
      "text": "struct {\n    HPKEPublicKey encryption_key;\n    opaque parent_hash<V>;\n    opaque original_sibling_tree_hash<V>;\n} ParentHashInput;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The field encryption_key contains the HPKE public key of P. If P is the root, then the parent_hash field is set to a zero-length octet string. Otherwise, parent_hash is the parent hash of the next node after P on the filtered direct path of the leaf L. This way, P's parent hash fixes the new HPKE public key of each non-blank node on the path from P to the root. Note that the path from P to the root may contain some blank nodes that are not fixed by P's parent hash. However, for each node that has an HPKE key, this key is fixed by P's parent hash.",
      "ja": "フィールド encryption_key には、P の HPKE 公開鍵が含まれています。P がルートである場合、parent_hash フィールドは長さゼロのオクテット文字列に設定されます。それ以外の場合、parent_hash は、葉 L のフィルタリングされた直接パス上の P の次のノードの親ハッシュです。この方法により、P の親ハッシュは、P からルートまでのパス上の各非空ノードの新しい HPKE 公開鍵を固定します。P からルートまでのパスには、P の親ハッシュによって固定されないいくつかの空白ノードが含まれる可能性があることに注意してください。ただし、HPKE キーを持つ各ノードについては、そのキーが P の親ハッシュによって固定されます。"
    },
    {
      "indent": 3,
      "text": "Finally, original_sibling_tree_hash is the tree hash of S in the ratchet tree modified as follows: For each leaf L in P.unmerged_leaves, blank L and remove it from the unmerged_leaves sets of all parent nodes.",
      "ja": "最終的に、original_sibling_tree_hash は、次のように修正されたラチェットツリーの S のツリーハッシュです：P.unmerged_leaves 内の各葉 L について、L を空白にし、そしてすべての親ノードの unmerged_leaves セットから L を削除します。"
    },
    {
      "indent": 3,
      "text": "Observe that original_sibling_tree_hash does not change between updates of P. This property is crucial for the correctness of the protocol.",
      "ja": "original_sibling_tree_hash が P の更新の間に変化しないことに注意してください。この性質はプロトコルの正確性にとって重要です。"
    },
    {
      "indent": 3,
      "text": "Note that original_sibling_tree_hash is the tree hash of S, not the parent hash. The parent_hash field in ParentHashInput captures information about the nodes above P. the original_sibling_tree_hash captures information about the subtree under S that is not being updated (and thus the subtree to which a path secret for P would be encrypted according to Section 7.5).",
      "ja": "original_sibling_tree_hash は S のツリーハッシュであり、親ハッシュではありません。ParentHashInput の parent_hash フィールドは、P より上のノードに関する情報を収集します。original_sibling_tree_hash は、更新されていない S のサブツリーに関する情報を収集します（したがって、P のパスシークレットが暗号化されるサブツリーに関する情報になります、セクション 7.5 に従って）。"
    },
    {
      "indent": 3,
      "text": "For example, in the following tree:",
      "ja": "例えば、次の木構造では："
    },
    {
      "indent": 3,
      "text": "              W [F]\n        ______|_____\n       /             \\\n      U               Y [F]\n    __|__           __|__\n   /     \\         /     \\\n  T       _       _       _\n / \\     / \\     / \\     / \\\nA   B   C   D   E   F   G   _",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Figure 21: A Tree Illustrating Parent Hash Computations",
      "ja": "図21：親ハッシュ計算を示す木"
    },
    {
      "indent": 3,
      "text": "With P = W and S = Y, original_sibling_tree_hash is the tree hash of the following tree:",
      "ja": "P = W および S = Y の場合、original_sibling_tree_hash は次のツリーのツリーハッシュです："
    },
    {
      "indent": 3,
      "text": "      Y\n    __|__\n   /     \\\n  _       _\n / \\     / \\\nE   _   G   _",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Because W.unmerged_leaves includes F, F is blanked and removed from Y.unmerged_leaves.",
      "ja": "W.unmerged_leavesにはFが含まれているため、Fは空白にされ、Y.unmerged_leavesから削除されます。"
    },
    {
      "indent": 3,
      "text": "Note that no recomputation is needed if the tree hash of S is unchanged since the last time P was updated. This is the case for computing or processing a Commit whose UpdatePath traverses P, since the Commit itself resets P. (In other words, it is only necessary to recompute the original sibling tree hash when validating a group's tree on joining.) More generally, if none of the entries in P.unmerged_leaves are in the subtree under S (and thus no leaves were blanked), then the original tree hash at S is the tree hash of S in the current tree.",
      "ja": "Sが最後にPが更新されたとき以来変更されていない場合、再計算は必要ありません。これは、UpdatePathがPを横断するCommitを計算または処理する場合に当てはまります。なぜなら、Commit自体がPをリセットするからです。（言い換えると、グループのツリーを結合する際にツリーの検証を行うときに元の兄弟ツリーハッシュを再計算する必要があるだけです。）より一般的には、P.unmerged_leavesのエントリのいずれもSの下のサブツリーに含まれていない場合（つまり、どの葉も空白にされていない場合）、Sにおける元のツリーハッシュは現在のツリーにおけるSのツリーハッシュです。"
    },
    {
      "indent": 3,
      "text": "If it is necessary to recompute the original tree hash of a node, the efficiency of recomputation can be improved by caching intermediate tree hashes, to avoid recomputing over the subtree when the subtree is included in multiple parent hashes. A subtree hash can be reused as long as the intersection of the parent's unmerged leaves with the subtree is the same as in the earlier computation.",
      "ja": "ノードの元のツリーハッシュを再計算する必要がある場合、再計算の効率を向上させるために、中間ツリーハッシュをキャッシュしておくことで、サブツリーが複数の親ハッシュに含まれる場合に再計算を回避できます。サブツリーハッシュは、親の未マージの葉とサブツリーの交差部分が以前の計算と同じである限り再利用できます。"
    },
    {
      "indent": 0,
      "text": "7.9.1. Using Parent Hashes",
      "section_title": true,
      "ja": "7.9.1. 親ハッシュを使用する"
    },
    {
      "indent": 3,
      "text": "In ParentNode objects and LeafNode objects with leaf_node_source set to commit, the value of the parent_hash field is the parent hash of the next non-blank parent node above the node in question (the next node in the filtered direct path). Using the node labels in Figure 20, the parent_hash field of D is equal to the parent hash of P with copath child S. This is the case even when the node D is a leaf node.",
      "ja": "ParentNodeオブジェクトとleaf_node_sourceがcommitに設定されたLeafNodeオブジェクトでは、parent_hashフィールドの値は、対象のノードの上にある次の空でない親ノードの親ハッシュです（フィルタリングされた直接パス内の次のノード）。図20のノードラベルを使用すると、Dのparent_hashフィールドは、copath子Sを持つPの親ハッシュと等しいです。この場合、ノードDが葉ノードである場合でも同様です。"
    },
    {
      "indent": 3,
      "text": "The parent_hash field of a LeafNode is signed by the member. The signature of such a LeafNode thus attests to which keys the group member introduced into the ratchet tree and to whom the corresponding secret keys were sent, in addition to the other contents of the LeafNode. This prevents malicious insiders from constructing artificial ratchet trees with a node D whose HPKE secret key is known to the insider, yet where the insider isn't assigned a leaf in the subtree rooted at D. Indeed, such a ratchet tree would violate the tree invariant.",
      "ja": "LeafNodeのparent_hashフィールドはメンバーによって署名されます。そのようなLeafNodeの署名は、ラチェットツリーに導入されたキーと対応する秘密キーが誰に送信されたかを証明します。LeafNodeの他の内容に加えて、これにより悪意のある内部者が、インサイダーに知られているノードDのHPKE秘密キーを持つ人工的なラチェットツリーを構築することを防ぎます。ただし、そのインサイダーがDを根とするサブツリーに葉を割り当てられていない場合でも。実際、そのようなラチェットツリーはツリー不変条件に違反します。"
    },
    {
      "indent": 0,
      "text": "7.9.2. Verifying Parent Hashes",
      "section_title": true,
      "ja": "7.9.2. 親ハッシュの検証"
    },
    {
      "indent": 3,
      "text": "Parent hashes are verified at two points in the protocol: When joining a group and when processing a Commit.",
      "ja": "親ハッシュは、プロトコル内の2つのポイントで検証されます：グループに参加するときと、Commitを処理するとき。"
    },
    {
      "indent": 3,
      "text": "The parent hash in a node D is valid with respect to a parent node P if the following criteria hold. Here C and S are the children of P (for \"child\" and \"sibling\"), with C being the child that is on the direct path of D (possibly D itself) and S being the other child:",
      "ja": "ノードDの親ハッシュが親ノードPに対して有効である場合、次の基準が満たされます。ここで、CとSはPの子供（\"child\"と\"sibling\"の略）であり、CはDの直接のパス上にある子供（おそらくD自体）であり、Sはもう一方の子供です。"
    },
    {
      "indent": 6,
      "text": "* D is a descendant of P in the tree.",
      "ja": "* Dは木構造においてPの子孫です。"
    },
    {
      "indent": 6,
      "text": "* The parent_hash field of D is equal to the parent hash of P with copath child S.",
      "ja": "* Dのparent_hashフィールドは、Pの親ハッシュとcopath子Sが等しいです。"
    },
    {
      "indent": 6,
      "text": "* D is in the resolution of C, and the intersection of P's unmerged_leaves with the subtree under C is equal to the resolution of C with D removed.",
      "ja": "* DはCの解像度にあり、Pのunmerged_leavesとCのサブツリーの交差部分は、Dを除いたCの解像度と等しいです。"
    },
    {
      "indent": 3,
      "text": "These checks verify that D and P were updated at the same time (in the same UpdatePath), and that they were neighbors in the UpdatePath because the nodes in between them would have omitted from the filtered direct path.",
      "ja": "これらのチェックは、DとPが同時に更新されたことを確認し、また、それらがUpdatePath内で隣接していたことを確認します。なぜなら、それらの間にあるノードはフィルタリングされた直接パスから省かれていたからです。"
    },
    {
      "indent": 3,
      "text": "A parent node P is \"parent-hash valid\" if it can be chained back to a leaf node in this way. That is, if there is leaf node L and a sequence of parent nodes P_1, ..., P_N such that P_N = P and each step in the chain is authenticated by a parent hash, then L's parent hash is valid with respect to P_1, P_1's parent hash is valid with respect to P_2, and so on.",
      "ja": "親ノードPが「親ハッシュが有効」であるとは、この方法で葉ノードに連結できる場合を指します。つまり、葉ノードLと親ノードP_1、...、P_Nのシーケンスが存在し、P_N = Pであり、連鎖の各ステップが親ハッシュによって認証されている場合、Lの親ハッシュはP_1に対して有効であり、P_1の親ハッシュはP_2に対して有効であり、以降も同様です。"
    },
    {
      "indent": 3,
      "text": "When joining a group, the new member MUST authenticate that each non-blank parent node P is parent-hash valid. This can be done \"bottom up\" by building chains up from leaves and verifying that all non-blank parent nodes are covered by exactly one such chain, or \"top down\" by verifying that there is exactly one descendant of each non-blank parent node for which the parent node is parent-hash valid.",
      "ja": "グループに参加する際、新しいメンバーは、各空でない親ノード P が親ハッシュが有効であることを認証する必要があります。これは、葉から上に向かってチェーンを構築し、すべての空でない親ノードが正確に1つのそのようなチェーンによってカバーされていることを検証することによって「下から上」で行うこともできます。または、「上から下」で、各空でない親ノードに対して親ノードが親ハッシュが有効であることを検証することによって、各空でない親ノードの各子孫が正確に1つ存在することを検証することもできます。"
    },
    {
      "indent": 3,
      "text": "When processing a Commit message that includes an UpdatePath, clients MUST recompute the expected value of parent_hash for the committer's new leaf and verify that it matches the parent_hash value in the supplied leaf_node. After being merged into the tree, the nodes in the UpdatePath form a parent-hash chain from the committer's leaf to the root.",
      "ja": "UpdatePathを含むCommitメッセージを処理する際、クライアントは、コミッターの新しいリーフのparent_hashの期待値を再計算し、提供されたleaf_node内のparent_hashの値と一致するかを検証する必要があります。ツリーにマージされた後、UpdatePath内のノードは、コミッターのリーフからルートまでのparent-hashチェーンを形成します。"
    },
    {
      "indent": 0,
      "text": "8. Key Schedule",
      "section_title": true,
      "ja": "8. キースケジュール"
    },
    {
      "indent": 3,
      "text": "Group keys are derived using the Extract and Expand functions from the KDF for the group's cipher suite, as well as the functions defined below:",
      "ja": "グループキーは、グループの暗号スイートのKDFからのExtractおよびExpand関数を使用して導出されます。また、以下で定義された関数も使用されます。"
    },
    {
      "indent": 3,
      "text": "ExpandWithLabel(Secret, Label, Context, Length) =\n    KDF.Expand(Secret, KDFLabel, Length)\n\nDeriveSecret(Secret, Label) =\n    ExpandWithLabel(Secret, Label, \"\", KDF.Nh)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where KDFLabel is specified as:",
      "ja": "KDFLabel が指定されている場合:"
    },
    {
      "indent": 3,
      "text": "struct {\n    uint16 length;\n    opaque label<V>;\n    opaque context<V>;\n} KDFLabel;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "And its fields are set to:",
      "ja": "そして、そのフィールドは次のように設定されています："
    },
    {
      "indent": 3,
      "text": "length = Length;\nlabel = \"MLS 1.0 \" + Label;\ncontext = Context;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The value KDF.Nh is the size of an output from KDF.Extract, in bytes. In the below diagram:",
      "ja": "値KDF.Nhは、KDF.Extractからの出力のサイズ（バイト単位）です。以下の図に示す通り："
    },
    {
      "indent": 6,
      "text": "* KDF.Extract takes its salt argument from the top and its Input Keying Material (IKM) argument from the left.",
      "ja": "* KDF.Extractは、塩の引数を上から取得し、入力鍵素材（IKM）の引数を左から取得します。"
    },
    {
      "indent": 6,
      "text": "* DeriveSecret takes its Secret argument from the incoming arrow.",
      "ja": "* DeriveSecretは、入力矢印からそのSecret引数を取得します。"
    },
    {
      "indent": 6,
      "text": "* 0 represents an all-zero byte string of length KDF.Nh.",
      "ja": "* 0 は、長さ KDF.Nh のすべてがゼロのバイト列を表します。"
    },
    {
      "indent": 3,
      "text": "When processing a handshake message, a client combines the following information to derive new epoch secrets:",
      "ja": "ハンドシェイクメッセージを処理する際、クライアントは次の情報を組み合わせて新しいエポックシークレットを導出します："
    },
    {
      "indent": 6,
      "text": "* The init secret from the previous epoch",
      "ja": "* 前のエポックからの初期シークレット"
    },
    {
      "indent": 6,
      "text": "* The commit secret for the current epoch",
      "ja": "* 現在のエポックのコミットシークレット"
    },
    {
      "indent": 6,
      "text": "* The GroupContext object for current epoch",
      "ja": "* 現在のエポックのGroupContextオブジェクト"
    },
    {
      "indent": 3,
      "text": "Given these inputs, the derivation of secrets for an epoch proceeds as shown in the following diagram:",
      "ja": "これらの入力を考慮すると、エポックの秘密の導出は、次の図に示すように進行します。"
    },
    {
      "indent": 3,
      "text": "                    init_secret_[n-1]\n                          |\n                          |\n                          V\n    commit_secret --> KDF.Extract\n                          |\n                          |\n                          V\n                  ExpandWithLabel(., \"joiner\", GroupContext_[n], KDF.Nh)\n                          |\n                          |\n                          V\n                     joiner_secret\n                          |\n                          |\n                          V\npsk_secret (or 0) --> KDF.Extract\n                          |\n                          |\n                          +--> DeriveSecret(., \"welcome\")\n                          |    = welcome_secret\n                          |\n                          V\n                  ExpandWithLabel(., \"epoch\", GroupContext_[n], KDF.Nh)\n                          |\n                          |\n                          V\n                     epoch_secret\n                          |\n                          |\n                          +--> DeriveSecret(., <label>)\n                          |    = <secret>\n                          |\n                          V\n                    DeriveSecret(., \"init\")\n                          |\n                          |\n                          V\n                    init_secret_[n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 22: The MLS Key Schedule",
      "ja": "図22：MLSキースケジュール"
    },
    {
      "indent": 3,
      "text": "A number of values are derived from the epoch secret for different purposes:",
      "ja": "さまざまな目的のために、いくつかの値がエポックシークレットから派生しています。"
    },
    {
      "indent": 4,
      "text": "+==================+=====================+=======================+\n| Label            | Secret              | Purpose               |\n+==================+=====================+=======================+\n| \"sender data\"    | sender_data_secret  | Deriving keys to      |\n|                  |                     | encrypt sender data   |\n+------------------+---------------------+-----------------------+\n| \"encryption\"     | encryption_secret   | Deriving message      |\n|                  |                     | encryption keys (via  |\n|                  |                     | the secret tree)      |\n+------------------+---------------------+-----------------------+\n| \"exporter\"       | exporter_secret     | Deriving exported     |\n|                  |                     | secrets               |\n+------------------+---------------------+-----------------------+\n| \"external\"       | external_secret     | Deriving the external |\n|                  |                     | init key              |\n+------------------+---------------------+-----------------------+\n| \"confirm\"        | confirmation_key    | Computing the         |\n|                  |                     | confirmation MAC for  |\n|                  |                     | an epoch              |\n+------------------+---------------------+-----------------------+\n| \"membership\"     | membership_key      | Computing the         |\n|                  |                     | membership MAC for a  |\n|                  |                     | PublicMessage         |\n+------------------+---------------------+-----------------------+\n| \"resumption\"     | resumption_psk      | Proving membership in |\n|                  |                     | this epoch (via a PSK |\n|                  |                     | injected later)       |\n+------------------+---------------------+-----------------------+\n| \"authentication\" | epoch_authenticator | Confirming that two   |\n|                  |                     | clients have the same |\n|                  |                     | view of the group     |\n+------------------+---------------------+-----------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Table 4: Epoch-Derived Secrets",
      "ja": "表4：エポック由来の秘密"
    },
    {
      "indent": 3,
      "text": "The external_secret is used to derive an HPKE key pair whose private key is held by the entire group:",
      "ja": "external_secretは、グループ全体が保持するHPKE鍵ペアの秘密鍵を導出するために使用されます。"
    },
    {
      "indent": 3,
      "text": "external_priv, external_pub = KEM.DeriveKeyPair(external_secret)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The public key external_pub can be published as part of the GroupInfo struct in order to allow non-members to join the group using an external Commit.",
      "ja": "公開鍵 external_pub は、非メンバーが外部 Commit を使用してグループに参加できるようにするために、GroupInfo 構造体の一部として公開することができます。"
    },
    {
      "indent": 0,
      "text": "8.1. Group Context",
      "section_title": true,
      "ja": "8.1. グループの文脈"
    },
    {
      "indent": 3,
      "text": "Each member of the group maintains a GroupContext object that summarizes the state of the group:",
      "ja": "グループの各メンバーは、グループの状態を要約するGroupContextオブジェクトを保持しています。"
    },
    {
      "indent": 3,
      "text": "struct {\n    ProtocolVersion version = mls10;\n    CipherSuite cipher_suite;\n    opaque group_id<V>;\n    uint64 epoch;\n    opaque tree_hash<V>;\n    opaque confirmed_transcript_hash<V>;\n    Extension extensions<V>;\n} GroupContext;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The fields in this state have the following semantics:",
      "ja": "この州のフィールドには、次の意味論があります。"
    },
    {
      "indent": 6,
      "text": "* The cipher_suite is the cipher suite used by the group.",
      "ja": "* cipher_suite は、グループで使用される 暗号スイート です。"
    },
    {
      "indent": 6,
      "text": "* The group_id field is an application-defined identifier for the group.",
      "ja": "* group_id フィールドは、グループのためのアプリケーション定義の識別子です。"
    },
    {
      "indent": 6,
      "text": "* The epoch field represents the current version of the group.",
      "ja": "* epochフィールドは、グループの現在のバージョンを表します。"
    },
    {
      "indent": 6,
      "text": "* The tree_hash field contains a commitment to the contents of the group's ratchet tree and the credentials for the members of the group, as described in Section 7.8.",
      "ja": "* tree_hashフィールドには、セクション7.8で説明されているグループのラチェットツリーの内容とグループのメンバーの資格情報へのコミットメントが含まれています。"
    },
    {
      "indent": 6,
      "text": "* The confirmed_transcript_hash field contains a running hash over the messages that led to this state.",
      "ja": "* confirmed_transcript_hashフィールドには、この状態に至ったメッセージに対するハッシュが含まれています。"
    },
    {
      "indent": 6,
      "text": "* The extensions field contains the details of any protocol extensions that apply to the group.",
      "ja": "* extensionsフィールドには、グループに適用されるプロトコル拡張の詳細が含まれています。"
    },
    {
      "indent": 3,
      "text": "When a new member is added to the group, an existing member of the group provides the new member with a Welcome message. The Welcome message provides the information the new member needs to initialize its GroupContext.",
      "ja": "新しいメンバーがグループに追加されると、既存のメンバーが新しいメンバーに歓迎メッセージを提供します。歓迎メッセージには、新しいメンバーがGroupContextを初期化するために必要な情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "Different changes to the group will have different effects on the group state. These effects are described in their respective subsections of Section 12.1. The following general rules apply:",
      "ja": "グループへの異なる変更は、グループの状態に異なる影響を与えます。これらの影響は、セクション12.1のそれぞれのサブセクションで説明されています。以下の一般的なルールが適用されます："
    },
    {
      "indent": 6,
      "text": "* The group_id field is constant.",
      "ja": "* group_id フィールドは一定です。"
    },
    {
      "indent": 6,
      "text": "* The epoch field increments by one for each Commit message that is processed.",
      "ja": "* 処理される各コミットメッセージごとに、エポックフィールドが1ずつ増加します。"
    },
    {
      "indent": 6,
      "text": "* The tree_hash is updated to represent the current tree and credentials.",
      "ja": "* tree_hash は、現在のツリーと資格情報を表すように更新されます。"
    },
    {
      "indent": 6,
      "text": "* The confirmed_transcript_hash field is updated with the data for an AuthenticatedContent encoding a Commit message, as described below.",
      "ja": "* confirmed_transcript_hashフィールドは、以下で説明されるCommitメッセージをエンコードするAuthenticatedContentのデータで更新されます。"
    },
    {
      "indent": 6,
      "text": "* The extensions field changes when a GroupContextExtensions proposal is committed.",
      "ja": "* 「GroupContextExtensions提案が承認されると、拡張フィールドが変更されます。」"
    },
    {
      "indent": 0,
      "text": "8.2. Transcript Hashes",
      "section_title": true,
      "ja": "8.2. トランスクリプトハッシュ"
    },
    {
      "indent": 3,
      "text": "The transcript hashes computed in MLS represent a running hash over all Proposal and Commit messages that have ever been sent in a group. Commit messages are included directly. Proposal messages are indirectly included via the Commit that applied them. Messages of both types are included by hashing the AuthenticatedContent object in which they were sent.",
      "ja": "MLSで計算されるトランスクリプトハッシュは、グループに送信されたすべての提案とコミットメッセージに対する実行中のハッシュを表します。コミットメッセージは直接含まれます。提案メッセージは、それらを適用したコミットを介して間接的に含まれます。両方のタイプのメッセージは、それらが送信されたAuthenticatedContentオブジェクトをハッシュ化することで含まれます。"
    },
    {
      "indent": 3,
      "text": "The transcript hash comprises two individual hashes:",
      "ja": "「トランスクリプトハッシュは2つの個々のハッシュから構成されています。」"
    },
    {
      "indent": 6,
      "text": "* A confirmed_transcript_hash that represents a transcript over the whole history of Commit messages, up to and including the signature of the most recent Commit.",
      "ja": "* 最新のCommitの署名を含む、Commitメッセージの全履歴を表すconfirmed_transcript_hash。"
    },
    {
      "indent": 6,
      "text": "* An interim_transcript_hash that covers the confirmed transcript hash plus the confirmation_tag of the most recent Commit.",
      "ja": "* 最新のCommitの確認タグと確認されたトランスクリプトハッシュを含む仮のトランスクリプトハッシュ。"
    },
    {
      "indent": 3,
      "text": "New members compute the interim transcript hash using the confirmation_tag field of the GroupInfo struct, while existing members can compute it directly.",
      "ja": "新しいメンバーは、GroupInfo構造体のconfirmation_tagフィールドを使用して中間トランスクリプトハッシュを計算しますが、既存のメンバーは直接計算できます。"
    },
    {
      "indent": 3,
      "text": "Each Commit message updates these hashes by way of its enclosing AuthenticatedContent. The AuthenticatedContent struct is split into ConfirmedTranscriptHashInput and InterimTranscriptHashInput. The former is used to update the confirmed transcript hash and the latter is used to update the interim transcript hash.",
      "ja": "各コミットメッセージは、その囲む認証コンテンツを介してこれらのハッシュを更新します。認証コンテンツ構造体は、ConfirmedTranscriptHashInputとInterimTranscriptHashInputに分割されています。前者は確認済みのトランスクリプトハッシュを更新するために使用され、後者は仮のトランスクリプトハッシュを更新するために使用されます。"
    },
    {
      "indent": 3,
      "text": "struct {\n    WireFormat wire_format;\n    FramedContent content; /* with content_type == commit */\n    opaque signature<V>;\n} ConfirmedTranscriptHashInput;\n\nstruct {\n    MAC confirmation_tag;\n} InterimTranscriptHashInput;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "confirmed_transcript_hash_[0] = \"\"; /* zero-length octet string */\ninterim_transcript_hash_[0] = \"\"; /* zero-length octet string */\n\nconfirmed_transcript_hash_[epoch] =\n    Hash(interim_transcript_hash_[epoch - 1] ||\n        ConfirmedTranscriptHashInput_[epoch]);\n\ninterim_transcript_hash_[epoch] =\n    Hash(confirmed_transcript_hash_[epoch] ||\n        InterimTranscriptHashInput_[epoch]);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In this notation, ConfirmedTranscriptHashInput_[epoch] and InterimTranscriptHashInput_[epoch] are based on the Commit that initiated the epoch with epoch number epoch. (Note that theepochfield in this Commit will be set toepoch - 1`, since it is sent within the previous epoch.)",
      "ja": "この表記法では、ConfirmedTranscriptHashInput_[epoch] と InterimTranscriptHashInput_[epoch] は、エポック番号 epoch で始まった Commit に基づいています。 (この Commit の epoch フィールドは、前のエポック内で送信されるため、epoch - 1 に設定されます。)"
    },
    {
      "indent": 3,
      "text": "The transcript hash ConfirmedTranscriptHashInput_[epoch] is used as the confirmed_transcript_hash input to the confirmation_tag field for this Commit. Each Commit thus confirms the whole transcript of Commits up to that point, except for the latest Commit's confirmation tag.",
      "ja": "TranscriptハッシュConfirmedTranscriptHashInput_[epoch]は、このCommitのconfirmation_tagフィールドへのconfirmed_transcript_hash入力として使用されます。したがって、各Commitは、最新のCommitの確認タグを除く、その時点までのすべてのCommitのトランスクリプトを確認します。"
    },
    {
      "indent": 4,
      "text": "                                                            ...\n\n                                                             |\n                                                             |\n                                                             V\n                                                    +-----------------+\n                                                    |  interim_[N-1]  |\n                                                    +--------+--------+\n                                                             |\n    .--------------.         +------------------+            |\n   |  Ratchet Tree  |        | wire_format      |            |\n   |  Key Schedule  |<-------+ content          |            |\n    '-------+------'         |   epoch = N-1    +------------+\n            |                |   commit         |            |\n            V                | signature        |            V\n+------------------------+   +------------------+   +-----------------+\n|  confirmation_key_[N]  +-->| confirmation_tag |<--+  confirmed_[N]  |\n+------------------------+   +--------+---------+   +--------+--------+\n                                      |                      |\n                                      |                      V\n                                      |             +-----------------+\n                                      +------------>|   interim_[N]   |\n                                                    +--------+--------+\n                                                             |\n    .--------------.         +------------------+            |\n   |  Ratchet Tree  |        | wire_format      |            |\n   |  Key Schedule  |<-------+ content          |            |\n    '-------+------'         |   epoch = N      +------------+\n            |                |   commit         |            |\n            V                | signature        |            V\n+------------------------+   +------------------+   +-----------------+\n| confirmation_key_[N+1] +-->| confirmation_tag |<--+ confirmed_[N+1] |\n+------------------------+   +--------+---------+   +--------+--------+\n                                      |                      |\n                                      |                      V\n                                      |             +-----------------+\n                                      +------------>|  interim_[N+1]  |\n                                                    +--------+--------+\n                                                             |\n                                                             V\n\n                                                            ...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Figure 23: Evolution of the Transcript Hashes through Two Epoch Changes",
      "ja": "図23：2つのエポック変更を通じたトランスクリプトハッシュの進化"
    },
    {
      "indent": 0,
      "text": "8.3. External Initialization",
      "section_title": true,
      "ja": "8.3. 外部初期化"
    },
    {
      "indent": 3,
      "text": "In addition to initializing a new epoch via KDF invocations as described above, an MLS group can also initialize a new epoch via an asymmetric interaction using the external key pair for the previous epoch. This is done when a new member is joining via an external commit.",
      "ja": "上記のようにKDF呼び出しを介して新しいエポックを初期化することに加えて、MLSグループは、前のエポックの外部キーペアを使用した非対称な相互作用を介しても新しいエポックを初期化することができます。これは、新しいメンバーが外部コミットを介して参加する場合に行われます。"
    },
    {
      "indent": 3,
      "text": "In this process, the joiner sends a new init_secret value to the group using the HPKE export method. The joiner then uses that init_secret with information provided in the GroupInfo and an external Commit to initialize their copy of the key schedule for the new epoch.",
      "ja": "このプロセスでは、参加者はHPKEエクスポートメソッドを使用して、新しいinit_secret値をグループに送信します。その後、参加者はGroupInfoで提供された情報と外部のCommitと一緒にそのinit_secretを使用して、新しいエポックのキースケジュールのコピーを初期化します。"
    },
    {
      "indent": 3,
      "text": "kem_output, context = SetupBaseS(external_pub, \"\")\ninit_secret = context.export(\"MLS 1.0 external init secret\", KDF.Nh)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Members of the group receive the kem_output in an ExternalInit proposal and perform the corresponding calculation to retrieve the init_secret value.",
      "ja": "グループのメンバーは、ExternalInit提案でkem_outputを受け取り、対応する計算を行ってinit_secretの値を取得します。"
    },
    {
      "indent": 3,
      "text": "context = SetupBaseR(kem_output, external_priv, \"\")\ninit_secret = context.export(\"MLS 1.0 external init secret\", KDF.Nh)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.4. Pre-Shared Keys",
      "section_title": true,
      "ja": "8.4. 事前共有キー"
    },
    {
      "indent": 3,
      "text": "Groups that already have an out-of-band mechanism to generate shared group secrets can inject them into the MLS key schedule to incorporate this external entropy in the computation of MLS group secrets.",
      "ja": "すでに共有グループシークレットを生成するためのオフバンドメカニズムを持っているグループは、MLSキースケジュールにそれらを注入して、MLSグループシークレットの計算にこの外部エントロピーを取り込むことができます。"
    },
    {
      "indent": 3,
      "text": "Injecting an external PSK can improve security in the case where having a full run of Updates across members is too expensive, or if the external group key establishment mechanism provides stronger security against classical or quantum adversaries.",
      "ja": "外部PSKを注入することで、メンバー全体にアップデートを行うことがコストがかかりすぎる場合や、外部のグループ鍵確立メカニズムが古典的または量子的な敵対者に対してより強力なセキュリティを提供する場合に、セキュリティを向上させることができます。"
    },
    {
      "indent": 3,
      "text": "Note that, as a PSK may have a different lifetime than an Update, it does not necessarily provide the same forward secrecy or post-compromise security guarantees as a Commit message. Unlike the key pairs populated in the tree by an Update or Commit, which are always freshly generated, PSKs may be pre-distributed and stored. This creates the risk that a PSK may be compromised in the process of distribution and storage. The security that the group gets from injecting a PSK thus depends on both the entropy of the PSK and the risk of compromise. These factors are outside of the scope of this document, but they should be considered by application designers relying on PSKs.",
      "ja": "PSKが更新とは異なる寿命を持つ可能性があるため、必ずしもCommitメッセージと同じ前方秘匿性やコンプロマイズ後のセキュリティ保証を提供するわけではありません。更新またはCommitによってツリーに配置される鍵ペアが常に新しく生成されるのに対し、PSKは事前に配布されたり保存されたりする可能性があります。これにより、PSKが配布や保存の過程で危険にさらされるリスクが生じます。グループがPSKを導入することで得るセキュリティは、PSKのエントロピーと危険にさらされるリスクの両方に依存します。これらの要因はこの文書の範囲外ですが、PSKに依存するアプリケーション設計者によって考慮されるべきです。"
    },
    {
      "indent": 3,
      "text": "Each PSK in MLS has a type that designates how it was provisioned. External PSKs are provided by the application, while resumption PSKs are derived from the MLS key schedule and used in cases where it is necessary to authenticate a member's participation in a prior epoch.",
      "ja": "MLSの各PSKには、それがどのようにプロビジョニングされたかを示すタイプがあります。外部PSKはアプリケーションによって提供され、再開PSKはMLSキースケジュールから派生し、以前のエポックでメンバーの参加を認証する必要がある場合に使用されます。"
    },
    {
      "indent": 3,
      "text": "The injection of one or more PSKs into the key schedule is signaled in two ways: Existing members are informed via PreSharedKey proposals covered by a Commit, and new members added in the Commit are informed by the GroupSecrets object in the Welcome message corresponding to the Commit. To ensure that existing and new members compute the same PSK input to the key schedule, the Commit and GroupSecrets objects MUST indicate the same set of PSKs, in the same order.",
      "ja": "1つ以上のPSKをキースケジュールに挿入することは、2つの方法で通知されます。既存のメンバーは、CommitでカバーされたPreSharedKey提案によって通知され、Commitに追加された新しいメンバーは、Commitに対応するWelcomeメッセージのGroupSecretsオブジェクトによって通知されます。既存のメンバーと新しいメンバーが同じPSK入力をキースケジュールに計算するようにするためには、CommitとGroupSecretsオブジェクトは、同じ順序で同じPSKのセットを示さなければなりません。"
    },
    {
      "indent": 3,
      "text": "enum {\n  reserved(0),\n  external(1),\n  resumption(2),\n  (255)\n} PSKType;\n\nenum {\n  reserved(0),\n  application(1),\n  reinit(2),\n  branch(3),\n  (255)\n} ResumptionPSKUsage;\n\nstruct {\n  PSKType psktype;\n  select (PreSharedKeyID.psktype) {\n    case external:\n      opaque psk_id<V>;\n\n    case resumption:\n      ResumptionPSKUsage usage;\n      opaque psk_group_id<V>;\n      uint64 psk_epoch;\n  };\n  opaque psk_nonce<V>;\n} PreSharedKeyID;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each time a client injects a PSK into a group, the psk_nonce of its PreSharedKeyID MUST be set to a fresh random value of length KDF.Nh, where KDF is the KDF for the cipher suite of the group into which the PSK is being injected. This ensures that even when a PSK is used multiple times, the value used as an input into the key schedule is different each time.",
      "ja": "クライアントがPSKをグループに挿入するたびに、そのPreSharedKeyIDのpsk_nonceは、KDFがグループの暗号スイートのKDFである場合、長さKDF.Nhの新しいランダムな値に設定されなければなりません。これにより、PSKが複数回使用されても、キースケジュールへの入力として使用される値が毎回異なることが保証されます。"
    },
    {
      "indent": 3,
      "text": "Upon receiving a Commit with a PreSharedKey proposal or a GroupSecrets object with the psks field set, the receiving client includes them in the key schedule in the order listed in the Commit, or in the psks field, respectively. For resumption PSKs, the PSK is defined as the resumption_psk of the group and epoch specified in the PreSharedKeyID object. Specifically, psk_secret is computed as follows:",
      "ja": "PreSharedKey提案またはpsksフィールドが設定されたGroupSecretsオブジェクトを受信した場合、受信クライアントはそれらを、Commitにリストされた順序またはそれぞれのpsksフィールドに含めます。再開PSKの場合、PSKはPreSharedKeyIDオブジェクトで指定されたグループとエポックのresumption_pskとして定義されます。具体的には、psk_secretは以下のように計算されます："
    },
    {
      "indent": 3,
      "text": "struct {\n    PreSharedKeyID id;\n    uint16 index;\n    uint16 count;\n} PSKLabel;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "psk_extracted_[i] = KDF.Extract(0, psk_[i])\npsk_input_[i] = ExpandWithLabel(psk_extracted_[i], \"derived psk\",\n                  PSKLabel, KDF.Nh)\n\npsk_secret_[0] = 0\npsk_secret_[i] = KDF.Extract(psk_input_[i-1], psk_secret_[i-1])\npsk_secret     = psk_secret_[n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Here 0 represents the all-zero vector of length KDF.Nh. The index field in PSKLabel corresponds to the index of the PSK in the psk array, while the count field contains the total number of PSKs. In other words, the PSKs are chained together with KDF.Extract invocations (labeled \"Extract\" for brevity in the diagram), as follows:",
      "ja": "ここでは、0は長さKDF.Nhの全ゼロベクトルを表します。PSKLabelのインデックスフィールドは、psk配列内のPSKのインデックスに対応し、countフィールドにはPSKの総数が含まれています。言い換えると、PSKはKDF.Extract呼び出し（図中では簡潔に「Extract」とラベル付けされています）で連鎖されます。"
    },
    {
      "indent": 3,
      "text": "                 0                               0    = psk_secret_[0]\n                 |                               |\n                 V                               V\npsk_[0]   --> Extract --> ExpandWithLabel --> Extract = psk_secret_[1]\n                                                 |\n                 0                               |\n                 |                               |\n                 V                               V\npsk_[1]   --> Extract --> ExpandWithLabel --> Extract = psk_secret_[2]\n                                                 |\n                 0                              ...\n                 |                               |\n                 V                               V\npsk_[n-1] --> Extract --> ExpandWithLabel --> Extract = psk_secret_[n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Figure 24: Computation of a PSK Secret from a Set of PSKs",
      "ja": "図24：PSKセットからのPSKシークレットの計算"
    },
    {
      "indent": 3,
      "text": "In particular, if there are no PreSharedKey proposals in a given Commit, then the resulting psk_secret is psk_secret_[0], the all-zero vector.",
      "ja": "特に、与えられたコミットにPreSharedKeyの提案がない場合、結果として得られるpsk_secretはpsk_secret_[0]、すべてのゼロのベクトルです。"
    },
    {
      "indent": 0,
      "text": "8.5. Exporters",
      "section_title": true,
      "ja": "8.5. 輸出業者"
    },
    {
      "indent": 3,
      "text": "The main MLS key schedule provides an exporter_secret that can be used by an application to derive new secrets for use outside of MLS.",
      "ja": "主要なMLSキースケジュールは、アプリケーションがMLSの外で使用するための新しいシークレットを導出するために使用できるexporter_secretを提供します。"
    },
    {
      "indent": 3,
      "text": "MLS-Exporter(Label, Context, Length) =\n       ExpandWithLabel(DeriveSecret(exporter_secret, Label),\n                         \"exported\", Hash(Context), Length)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Applications SHOULD provide a unique label to MLS-Exporter that identifies the secret's intended purpose. This is to help prevent the same secret from being generated and used in two different places. To help avoid the same label being used in different applications, an IANA registry for these labels has been defined in Section 17.8.",
      "ja": "アプリケーションは、MLS-Exporterに対して、シークレットの意図された目的を識別するユニークなラベルを提供する必要があります。これは、同じシークレットが2つの異なる場所で生成および使用されるのを防ぐためです。異なるアプリケーションで同じラベルが使用されるのを避けるために、これらのラベルのためのIANAレジストリが第17.8節で定義されています。"
    },
    {
      "indent": 3,
      "text": "The exported values are bound to the group epoch from which the exporter_secret is derived, and hence reflect a particular state of the group.",
      "ja": "エクスポートされた値は、エクスポーターシークレットが派生するグループエポックにバインドされており、したがってグループの特定の状態を反映しています。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED for the application generating exported values to refresh those values after a Commit is processed.",
      "ja": "コミットが処理された後、エクスポートされた値を生成するアプリケーションがそれらの値を更新することが推奨されています。"
    },
    {
      "indent": 0,
      "text": "8.6. Resumption PSK",
      "section_title": true,
      "ja": "8.6. 再開 PSK"
    },
    {
      "indent": 3,
      "text": "The main MLS key schedule provides a resumption_psk that is used as a PSK to inject entropy from one epoch into another. This functionality is used in the reinitialization and branching processes described in Sections 11.2 and 11.3, but it may be used by applications for other purposes.",
      "ja": "主要なMLSキースケジュールは、エントロピーを1つのエポックから別のエポックに注入するために使用されるresumption_pskを提供します。この機能は、セクション11.2および11.3で説明されている再初期化および分岐プロセスで使用されますが、他の目的でアプリケーションによって使用される可能性があります。"
    },
    {
      "indent": 3,
      "text": "Some uses of resumption PSKs might call for the use of PSKs from historical epochs. The application SHOULD specify an upper limit on the number of past epochs for which the resumption_psk may be stored.",
      "ja": "一部の再開PSKの使用法では、歴史的な時代のPSKの使用が求められる場合があります。アプリケーションは、再開PSKが保存される過去の時代の数に上限を指定する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.7. Epoch Authenticators",
      "section_title": true,
      "ja": "8.7. エポック認証者"
    },
    {
      "indent": 3,
      "text": "The main MLS key schedule provides a per-epoch epoch_authenticator. If one member of the group is being impersonated by an active attacker, the epoch_authenticator computed by their client will differ from those computed by the other group members.",
      "ja": "主要なMLSキースケジュールは、エポックごとのエポック認証子を提供します。グループのメンバーの1人がアクティブな攻撃者によってなりすまされている場合、そのクライアントによって計算されたエポック認証子は、他のグループメンバーによって計算されたものと異なります。"
    },
    {
      "indent": 3,
      "text": "This property can be used to construct defenses against impersonation attacks that are effective even if members' signature keys are compromised. As a trivial example, if the users of the clients in an MLS group were to meet in person and reliably confirm that their epoch authenticator values were equal (using some suitable user interface), then each user would be assured that the others were not being impersonated in the current epoch. As soon as the epoch changed, though, they would need to redo this confirmation. The state of the group would have changed, possibly introducing an attacker.",
      "ja": "この特性は、メンバーの署名キーが侵害された場合でも効果的ななりすまし攻撃に対する防御を構築するために使用できます。些細な例として、MLSグループのクライアントのユーザーが直接会って、適切なユーザーインターフェースを使用してエポック認証子の値が等しいことを確認することができれば、各ユーザーは他のユーザーが現在のエポックでなりすまされていないことを保証されます。ただし、エポックが変わるとすぐにこの確認をやり直す必要があります。グループの状態が変わると、攻撃者が導入される可能性があります。"
    },
    {
      "indent": 3,
      "text": "More generally, in order for the members of an MLS group to obtain concrete authentication protections using the epoch_authenticator, they will need to use it in some secondary protocol (such as the face-to-face protocol above). The details of that protocol will then determine the specific authentication protections provided to the MLS group.",
      "ja": "より一般的には、MLS グループのメンバーが epoch_authenticator を使用して具体的な認証保護を得るためには、それをいくつかの二次プロトコル（上記の対面プロトコルなど）で使用する必要があります。そのプロトコルの詳細は、MLS グループに提供される具体的な認証保護を決定します。"
    },
    {
      "indent": 0,
      "text": "9. Secret Tree",
      "section_title": true,
      "ja": "9. 秘密の木"
    },
    {
      "indent": 3,
      "text": "For the generation of encryption keys and nonces, the key schedule begins with the encryption_secret at the root and derives a tree of secrets with the same structure as the group's ratchet tree. Each leaf in the secret tree is associated with the same group member as the corresponding leaf in the ratchet tree.",
      "ja": "暗号化キーとナンスの生成には、キースケジュールが暗号化秘密から始まり、グループのラチェットツリーと同じ構造の秘密のツリーを派生させます。秘密ツリーの各葉は、ラチェットツリーの対応する葉と同じグループメンバーに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "If N is a parent node in the secret tree, then the secrets of the children of N are defined as follows (where left(N) and right(N) denote the children of N):",
      "ja": "もしNが秘密の木で親ノードである場合、Nの子供たちの秘密は以下のように定義されます（ここでleft(N)とright(N)はNの子供を示します）:"
    },
    {
      "indent": 3,
      "text": "tree_node_[N]_secret\n        |\n        |\n        +--> ExpandWithLabel(., \"tree\", \"left\", KDF.Nh)\n        |    = tree_node_[left(N)]_secret\n        |\n        +--> ExpandWithLabel(., \"tree\", \"right\", KDF.Nh)\n             = tree_node_[right(N)]_secret",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 25: Derivation of Secrets from Parent to Children within a Secret Tree",
      "ja": "図25：秘密ツリー内で親から子への秘密の派生"
    },
    {
      "indent": 3,
      "text": "The secret in the leaf of the secret tree is used to initiate two symmetric hash ratchets, from which a sequence of single-use keys and nonces are derived, as described in Section 9.1. The root of each ratchet is computed as:",
      "ja": "秘密の木の葉にある秘密を使って、2つの対称ハッシュラチェットを開始し、その中から1回限りの鍵とナンスのシーケンスが導出されます。これは9.1節で説明されています。各ラチェットのルートは次のように計算されます："
    },
    {
      "indent": 3,
      "text": "tree_node_[N]_secret\n        |\n        |\n        +--> ExpandWithLabel(., \"handshake\", \"\", KDF.Nh)\n        |    = handshake_ratchet_secret_[N]_[0]\n        |\n        +--> ExpandWithLabel(., \"application\", \"\", KDF.Nh)\n             = application_ratchet_secret_[N]_[0]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 26: Initialization of the Hash Ratchets from the Leaves of a Secret Tree",
      "ja": "図26：秘密の木の葉からハッシュラチェットの初期化"
    },
    {
      "indent": 0,
      "text": "9.1. Encryption Keys",
      "section_title": true,
      "ja": "9.1. 暗号化キー"
    },
    {
      "indent": 3,
      "text": "As described in Section 6, MLS encrypts three different types of information:",
      "ja": "セクション6に記載されているように、MLSは3種類の異なる情報を暗号化します。"
    },
    {
      "indent": 6,
      "text": "* Metadata (sender information)",
      "ja": "* メタデータ（送信者情報）"
    },
    {
      "indent": 6,
      "text": "* Handshake messages (Proposal and Commit)",
      "ja": "* ハンドシェイクメッセージ（提案とコミット）"
    },
    {
      "indent": 6,
      "text": "* Application messages",
      "ja": "* アプリケーションメッセージ"
    },
    {
      "indent": 3,
      "text": "The sender information used to look up the key for content encryption is encrypted with an AEAD where the key and nonce are derived from both sender_data_secret and a sample of the encrypted message content.",
      "ja": "送信元情報は、コンテンツの暗号化キーを検索するために使用され、送信元データシークレットと暗号化されたメッセージコンテンツのサンプルから導出されたキーとナンスを使用して暗号化されます。"
    },
    {
      "indent": 3,
      "text": "For handshake and application messages, a sequence of keys is derived via a \"sender ratchet\". Each sender has their own sender ratchet, and each step along the ratchet is called a \"generation\".",
      "ja": "ハンドシェイクとアプリケーションメッセージについては、「送信者ラチェット」を介してキーのシーケンスが派生します。各送信者には独自の送信者ラチェットがあり、ラチェットの各ステップを「ジェネレーション」と呼びます。"
    },
    {
      "indent": 3,
      "text": "The following figure shows a secret tree for a four-member group, with the handshake and application ratchets that member D will use for sending and the first two application keys and nonces.",
      "ja": "次の図は、4人のグループのための秘密の木を示しており、メンバーDが送信に使用するハンドシェイクとアプリケーションラチェット、および最初の2つのアプリケーションキーとナンスが含まれています。"
    },
    {
      "indent": 4,
      "text": "      G\n      |\n    .-+-.\n   /     \\\n  E       F\n / \\     / \\\nA   B   C   D\n           / \\\n         HR0  AR0--+--K0\n               |   |\n               |   +--N0\n               |\n              AR1--+--K1\n               |   |\n               |   +--N1\n               |\n              AR2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 27: Secret Tree for a Four-Member Group",
      "ja": "図27：4人グループ用の秘密の木"
    },
    {
      "indent": 3,
      "text": "A sender ratchet starts from a per-sender base secret derived from a Secret Tree, as described in Section 9. The base secret initiates a symmetric hash ratchet, which generates a sequence of keys and nonces. The sender uses the j-th key/nonce pair in the sequence to encrypt (using the AEAD) the j-th message they send during that epoch. Each key/nonce pair MUST NOT be used to encrypt more than one message.",
      "ja": "送信者ラチェットは、セクション9で説明されている秘密ツリーから派生した送信者ベース秘密から始まります。ベース秘密は対称ハッシュラチェットを開始し、キーとノンスのシーケンスを生成します。送信者はそのエポック中に送信するj番目のメッセージを暗号化するために、シーケンス内のj番目のキー/ノンスペアを使用します（AEADを使用）。各キー/ノンスペアは1つ以上のメッセージを暗号化するために使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "Keys, nonces, and the secrets in ratchets are derived using DeriveTreeSecret. The context in a given call consists of the current position in the ratchet.",
      "ja": "鍵、ナンス、およびラチェット内の秘密は、DeriveTreeSecretを使用して導出されます。特定の呼び出しでのコンテキストは、ラチェット内の現在の位置で構成されます。"
    },
    {
      "indent": 3,
      "text": "DeriveTreeSecret(Secret, Label, Generation, Length) =\n    ExpandWithLabel(Secret, Label, Generation, Length)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where Generation is encoded as a big endian uint32.",
      "ja": "世代はビッグエンディアンのuint32としてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "ratchet_secret_[N]_[j]\n      |\n      +--> DeriveTreeSecret(., \"nonce\", j, AEAD.Nn)\n      |    = ratchet_nonce_[N]_[j]\n      |\n      +--> DeriveTreeSecret(., \"key\", j,  AEAD.Nk)\n      |    = ratchet_key_[N]_[j]\n      |\n      V\nDeriveTreeSecret(., \"secret\", j, KDF.Nh)\n= ratchet_secret_[N]_[j+1]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Here AEAD.Nn and AEAD.Nk denote the lengths in bytes of the nonce and key for the AEAD scheme defined by the cipher suite.",
      "ja": "ここで、AEAD.Nn と AEAD.Nk は、暗号スイートによって定義された AEAD スキームのノンスとキーのバイト長を示しています。"
    },
    {
      "indent": 0,
      "text": "9.2. Deletion Schedule",
      "section_title": true,
      "ja": "9.2. 削除スケジュール"
    },
    {
      "indent": 3,
      "text": "It is important to delete all security-sensitive values as soon as they are _consumed_. A sensitive value S is said to be _consumed_ if:",
      "ja": "重要なのは、セキュリティに敏感な値が「消費」されるとすぐに削除することです。センシティブな値Sが「消費」されるとは、以下の場合を指します："
    },
    {
      "indent": 6,
      "text": "* S was used to encrypt or (successfully) decrypt a message, or",
      "ja": "* Sはメッセージを暗号化または（成功して）復号化するために使用されました。"
    },
    {
      "indent": 6,
      "text": "* a key, nonce, or secret derived from S has been consumed. (This goes for values derived via DeriveSecret as well as ExpandWithLabel.)",
      "ja": "* 鍵、ナンス、またはSから派生した秘密が消費されました。（これは、DeriveSecretを介して派生した値にもExpandWithLabelを介して派生した値にも適用されます。）"
    },
    {
      "indent": 3,
      "text": "Here S may be the init_secret, commit_secret, epoch_secret, or encryption_secret as well as any secret in a secret tree or one of the ratchets.",
      "ja": "ここでのSは、init_secret、commit_secret、epoch_secret、またはencryption_secret、および秘密ツリーやラチェットのいずれかの秘密である可能性があります。"
    },
    {
      "indent": 3,
      "text": "As soon as a group member consumes a value, they MUST immediately delete (all representations of) that value. This is crucial to ensuring forward secrecy for past messages. Members MAY keep unconsumed values around for some reasonable amount of time to handle out-of-order message delivery.",
      "ja": "グループメンバーが値を消費するとすぐに、その値のすべての表現を即座に削除しなければなりません。これは、過去のメッセージのための前方秘匿性を確保するために重要です。メンバーは、メッセージの順序が入れ替わった場合に対応するために、未消費の値をある程度の時間保持しておくことができます。"
    },
    {
      "indent": 3,
      "text": "For example, suppose a group member encrypts or (successfully) decrypts an application message using the j-th key and nonce in the ratchet of leaf node L in some epoch n. Then, for that member, at least the following values have been consumed and MUST be deleted:",
      "ja": "例えば、あるグループメンバーが、あるエポックnにおいて、葉ノードLのラチェット内でj番目のキーとナンスを使用してアプリケーションメッセージを暗号化または（成功して）復号化したとします。そのメンバーにとって、少なくとも以下の値が消費され、削除される必要があります："
    },
    {
      "indent": 6,
      "text": "* the commit_secret, joiner_secret, epoch_secret, and encryption_secret of that epoch n as well as the init_secret of the previous epoch n-1,",
      "ja": "* そのエポックnのcommit_secret、joiner_secret、epoch_secret、encryption_secret、および前のエポックn-1のinit_secret、"
    },
    {
      "indent": 6,
      "text": "* all node secrets in the secret tree on the path from the root to the leaf with node L,",
      "ja": "* 根からノードLまでのパス上の秘密ツリー内のすべてのノードの秘密"
    },
    {
      "indent": 6,
      "text": "* the first j secrets in the application data ratchet of node L, and",
      "ja": "* アプリケーションデータのノードLの最初のj個の秘密を、データラチェットに格納します。"
    },
    {
      "indent": 6,
      "text": "* application_ratchet_nonce_[L]_[j] and application_ratchet_key_[L]_[j].",
      "ja": "* application_ratchet_nonce_[L]_[j] と application_ratchet_key_[L]_[j]"
    },
    {
      "indent": 3,
      "text": "Concretely, consider the secret tree shown in Figure 27. Client A, B, or C would generate the illustrated values on receiving a message from D with generation equal to 1, having not received a message with generation 0 (e.g., due to out-of-order delivery). In such a case, the following values would be consumed:",
      "ja": "具体的には、図27に示されている秘密のツリーを考えてください。クライアントA、B、またはCは、Dから世代が1であるメッセージを受け取った場合に、図示された値を生成します。彼らは、世代0のメッセージを受け取っていないため（たとえば、順不同の配信のため）、次の値が消費されます："
    },
    {
      "indent": 6,
      "text": "* The key K1 and nonce N1 used to decrypt the message",
      "ja": "* 暗号化されたメッセージを復号するために使用される鍵K1とナンスN1"
    },
    {
      "indent": 6,
      "text": "* The application ratchet secrets AR1 and AR0",
      "ja": "* アプリケーションのラチェットシークレットAR1とAR0"
    },
    {
      "indent": 6,
      "text": "* The tree secrets D, F, and G (recall that G is the encryption_secret for the epoch)",
      "ja": "* 木の秘密D、F、およびG（Gがエポックの暗号化秘密であることを思い出してください）"
    },
    {
      "indent": 6,
      "text": "* The epoch_secret, commit_secret, psk_secret, and joiner_secret for the current epoch",
      "ja": "* 現在のエポックの epoch_secret、commit_secret、psk_secret、および joiner_secret"
    },
    {
      "indent": 3,
      "text": "Other values may be retained (not consumed):",
      "ja": "他の値は保持される可能性があります（消費されません）。"
    },
    {
      "indent": 6,
      "text": "* K0 and N0 for decryption of an out-of-order message with generation 0",
      "ja": "* 世代0の順序が乱れたメッセージの復号化のためのK0およびN0"
    },
    {
      "indent": 6,
      "text": "* AR2 for derivation of further message decryption keys and nonces",
      "ja": "* さらなるメッセージの復号化キーとナンスの導出のためのAR2"
    },
    {
      "indent": 6,
      "text": "* HR0 for protection of handshake messages from D",
      "ja": "* HR0は、握手メッセージをDから保護するためのものです。"
    },
    {
      "indent": 6,
      "text": "* E and C for deriving secrets used by senders A, B, and C",
      "ja": "* A、B、およびCの送信者が使用する秘密を導出するためのEおよびC"
    },
    {
      "indent": 0,
      "text": "10. Key Packages",
      "section_title": true,
      "ja": "10. キーパッケージ"
    },
    {
      "indent": 3,
      "text": "In order to facilitate the asynchronous addition of clients to a group, clients can pre-publish KeyPackage objects that provide some public information about a user. A KeyPackage object specifies:",
      "ja": "クライアントをグループに非同期に追加するために、クライアントはユーザーに関する一部の公開情報を提供するKeyPackageオブジェクトを事前に公開することができます。KeyPackageオブジェクトは次のように指定されます："
    },
    {
      "indent": 8,
      "text": "1. a protocol version and cipher suite that the client supports,",
      "ja": "1. クライアントがサポートしているプロトコルバージョンと暗号スイート"
    },
    {
      "indent": 8,
      "text": "2. a public key that others can use to encrypt a Welcome message to this client (an \"init key\"), and",
      "ja": "2. 他の人がこのクライアントに暗号化された「ようこそメッセージ」を送るために使用できる公開鍵（「初期キー」）"
    },
    {
      "indent": 8,
      "text": "3. the content of the leaf node that should be added to the tree to represent this client.",
      "ja": "3. このクライアントを表すために木に追加すべき葉ノードの内容。"
    },
    {
      "indent": 3,
      "text": "KeyPackages are intended to be used only once and SHOULD NOT be reused except in the case of a \"last resort\" KeyPackage (see Section 16.8). Clients MAY generate and publish multiple KeyPackages to support multiple cipher suites.",
      "ja": "KeyPackagesは1度だけ使用することを意図しており、\"最終手段\"のKeyPackageの場合を除いて再利用してはいけません（セクション16.8を参照）。クライアントは複数の暗号スイートをサポートするために複数のKeyPackagesを生成して公開することができます。"
    },
    {
      "indent": 3,
      "text": "The value for init_key MUST be a public key for the asymmetric encryption scheme defined by cipher_suite, and it MUST be unique among the set of KeyPackages created by this client. Likewise, the leaf_node field MUST be valid for the cipher suite, including both the encryption_key and signature_key fields. The whole structure is signed using the client's signature key. A KeyPackage object with an invalid signature field MUST be considered malformed.",
      "ja": "init_keyの値は、cipher_suiteで定義された非対称暗号化スキームの公開鍵でなければならず、このクライアントによって作成されたKeyPackagesのセットの中で一意でなければなりません。同様に、leaf_nodeフィールドは、encryption_keyとsignature_keyの両方を含む暗号スイートに対して有効でなければなりません。全体の構造は、クライアントの署名キーを使用して署名されます。無効な署名フィールドを持つKeyPackageオブジェクトは、不正なものと見なされなければなりません。"
    },
    {
      "indent": 3,
      "text": "The signature is computed by the function SignWithLabel with a label \"KeyPackageTBS\" and a Content input comprising all of the fields except for the signature field.",
      "ja": "署名は、ラベルが「KeyPackageTBS」で、署名フィールドを除くすべてのフィールドからなるコンテンツ入力を使用して、関数SignWithLabelによって計算されます。"
    },
    {
      "indent": 3,
      "text": "struct {\n    ProtocolVersion version;\n    CipherSuite cipher_suite;\n    HPKEPublicKey init_key;\n    LeafNode leaf_node;\n    Extension extensions<V>;\n    /* SignWithLabel(., \"KeyPackageTBS\", KeyPackageTBS) */\n    opaque signature<V>;\n} KeyPackage;\n\nstruct {\n    ProtocolVersion version;\n    CipherSuite cipher_suite;\n    HPKEPublicKey init_key;\n    LeafNode leaf_node;\n    Extension extensions<V>;\n} KeyPackageTBS;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If a client receives a KeyPackage carried within an MLSMessage object, then it MUST verify that the version field of the KeyPackage has the same value as the version field of the MLSMessage. The version field in the KeyPackage provides an explicit signal of the intended version to the other members of group when they receive the KeyPackage in an Add proposal.",
      "ja": "クライアントがMLSMessageオブジェクト内に含まれるKeyPackageを受け取った場合、そのクライアントはKeyPackageのversionフィールドがMLSMessageのversionフィールドと同じ値であることを必ず検証しなければなりません。KeyPackage内のversionフィールドは、他のグループメンバーがAdd提案でKeyPackageを受け取った際に、意図されたバージョンを明示的に示すシグナルを提供します。"
    },
    {
      "indent": 3,
      "text": "The field leaf_node.capabilities indicates what protocol versions, cipher suites, credential types, and non-default proposal/extension types are supported by the client. (As discussed in Section 7.2, some proposal and extension types defined in this document are considered \"default\" and thus are not listed.) This information allows MLS session establishment to be safe from downgrade attacks on the parameters described (as discussed in Section 11), while still only advertising one version and one cipher suite per KeyPackage.",
      "ja": "フィールド leaf_node.capabilities は、クライアントがサポートしているプロトコルバージョン、暗号スイート、資格情報タイプ、およびデフォルト以外の提案/拡張タイプを示します（本文書で定義された一部の提案および拡張タイプは「デフォルト」と見なされ、したがってリストされません）。 この情報により、MLSセッションの確立が、記述されたパラメータに対するダウングレード攻撃から安全になります（セクション11で説明されているように）、それでも1つのバージョンと1つの暗号スイートのみをKeyPackageごとに広告することができます。"
    },
    {
      "indent": 3,
      "text": "The field leaf_node.leaf_node_source of the LeafNode in a KeyPackage MUST be set to key_package.",
      "ja": "LeafNode内のLeafNodeのフィールドleaf_node_sourceは、KeyPackage内のkey_packageに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Extensions included in the extensions or leaf_node.extensions fields MUST be included in the leaf_node.capabilities field. As discussed in Section 13, unknown extensions in KeyPackage.extensions MUST be ignored, and the creator of a KeyPackage object SHOULD include some random GREASE extensions to help ensure that other clients correctly ignore unknown extensions.",
      "ja": "extensions フィールドまたは leaf_node.extensions フィールドに含まれる拡張機能は、leaf_node.capabilities フィールドに含まれている必要があります。セクション 13 で議論されているように、KeyPackage.extensions 内の未知の拡張機能は無視される必要があり、KeyPackage オブジェクトの作成者は、他のクライアントが未知の拡張機能を正しく無視するようにするために、いくつかのランダムな GREASE 拡張機能を含めるべきです。"
    },
    {
      "indent": 0,
      "text": "10.1. KeyPackage Validation",
      "section_title": true,
      "ja": "10.1. キーパッケージの検証"
    },
    {
      "indent": 3,
      "text": "The validity of a KeyPackage needs to be verified at a few stages:",
      "ja": "KeyPackageの有効性はいくつかの段階で検証する必要があります。"
    },
    {
      "indent": 6,
      "text": "* When a KeyPackage is downloaded by a group member, before it is used to add the client to the group",
      "ja": "* グループメンバーがKeyPackageをダウンロードした場合、クライアントをグループに追加する前に使用されます。"
    },
    {
      "indent": 6,
      "text": "* When a KeyPackage is received by a group member in an Add message",
      "ja": "* AddメッセージでグループメンバーがKeyPackageを受信した場合"
    },
    {
      "indent": 3,
      "text": "The client verifies the validity of a KeyPackage using the following steps:",
      "ja": "クライアントは、次の手順を使用してKeyPackageの有効性を検証します："
    },
    {
      "indent": 6,
      "text": "* Verify that the cipher suite and protocol version of the KeyPackage match those in the GroupContext.",
      "ja": "* KeyPackageの暗号スイートとプロトコルバージョンがGroupContext内のものと一致していることを確認してください。"
    },
    {
      "indent": 6,
      "text": "* Verify that the leaf_node of the KeyPackage is valid for a KeyPackage according to Section 7.3.",
      "ja": "* KeyPackageのleaf_nodeがセクション7.3に従ってKeyPackageに有効であることを確認してください。"
    },
    {
      "indent": 6,
      "text": "* Verify that the signature on the KeyPackage is valid using the public key in leaf_node.credential.",
      "ja": "* leaf_node.credential内の公開鍵を使用して、KeyPackageの署名が有効であることを検証してください。"
    },
    {
      "indent": 6,
      "text": "* Verify that the value of leaf_node.encryption_key is different from the value of the init_key field.",
      "ja": "* leaf_node.encryption_keyの値がinit_keyフィールドの値と異なることを確認してください。"
    },
    {
      "indent": 0,
      "text": "11. Group Creation",
      "section_title": true,
      "ja": "11. グループ作成"
    },
    {
      "indent": 3,
      "text": "A group is always created with a single member, the \"creator\". Other members are then added to the group using the usual Add/Commit mechanism.",
      "ja": "グループは常に1人のメンバー、つまり「作成者」で作成されます。その後、通常の追加/コミットメカニズムを使用して他のメンバーがグループに追加されます。"
    },
    {
      "indent": 3,
      "text": "The creator of a group is responsible for setting the group ID, cipher suite, and initial extensions for the group. If the creator intends to add other members at the time of creation, then it SHOULD fetch KeyPackages for the members to be added, and select a cipher suite and extensions according to the capabilities of the members. To protect against downgrade attacks, the creator MUST use the capabilities information in these KeyPackages to verify that the chosen version and cipher suite is the best option supported by all members.",
      "ja": "グループの作成者は、グループID、暗号スイート、およびグループの初期拡張機能を設定する責任があります。作成者が作成時に他のメンバーを追加する意図がある場合、その時点で追加されるメンバーのためにKeyPackagesを取得し、メンバーの能力に応じて暗号スイートと拡張機能を選択する必要があります。ダウングレード攻撃に対抗するため、作成者はこれらのKeyPackages内の能力情報を使用して、選択したバージョンと暗号スイートがすべてのメンバーによってサポートされる最適なオプションであることを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "Group IDs SHOULD be constructed in such a way that there is an overwhelmingly low probability of honest group creators generating the same group ID, even without assistance from the Delivery Service. This can be done, for example, by making the group ID a freshly generated random value of size KDF.Nh. The Delivery Service MAY attempt to ensure that group IDs are globally unique by rejecting the creation of new groups with a previously used ID.",
      "ja": "グループIDは、配信サービスの支援なしでも、正直なグループ作成者が同じグループIDを生成する可能性が非常に低いように構築されるべきです。たとえば、グループIDをKDF.Nhのサイズの新しく生成されたランダムな値にすることでこれを実現できます。配信サービスは、以前に使用されたIDを持つ新しいグループの作成を拒否することで、グループIDがグローバルに一意であることを確認しようとすることができます。"
    },
    {
      "indent": 3,
      "text": "To initialize a group, the creator of the group MUST take the following steps:",
      "ja": "グループを初期化するには、グループの作成者が次の手順を取らなければなりません："
    },
    {
      "indent": 6,
      "text": "* Initialize a one-member group with the following initial values:",
      "ja": "* 以下の初期値を持つ1人のグループを初期化してください："
    },
    {
      "indent": 12,
      "text": "- Ratchet tree: A tree with a single node, a leaf node containing an HPKE public key and credential for the creator",
      "ja": "- ラチェットツリー：単一のノードを持つツリーで、作成者のHPKE公開鍵と資格情報を含む葉ノードがあります。"
    },
    {
      "indent": 12,
      "text": "- Group ID: A value set by the creator",
      "ja": "- グループID：作成者によって設定された値"
    },
    {
      "indent": 12,
      "text": "- Epoch: 0",
      "ja": "- エポック：0"
    },
    {
      "indent": 12,
      "text": "- Tree hash: The root hash of the above ratchet tree",
      "ja": "- ツリーハッシュ：上記のラチェットツリーのルートハッシュ"
    },
    {
      "indent": 12,
      "text": "- Confirmed transcript hash: The zero-length octet string",
      "ja": "- 確認されたトランスクリプトハッシュ：ゼロ長のオクテット文字列"
    },
    {
      "indent": 12,
      "text": "- Epoch secret: A fresh random value of size KDF.Nh",
      "ja": "- エポックの秘密：サイズKDF.Nhの新しいランダムな値"
    },
    {
      "indent": 12,
      "text": "- Extensions: Any values of the creator's choosing",
      "ja": "- 拡張機能：作成者が選択した任意の値"
    },
    {
      "indent": 6,
      "text": "* Calculate the interim transcript hash:",
      "ja": "* 中間のトランスクリプトハッシュを計算してください。"
    },
    {
      "indent": 12,
      "text": "- Derive the confirmation_key for the epoch as described in Section 8.",
      "ja": "- セクション8で説明されているように、エポックの確認キーを導出してください。"
    },
    {
      "indent": 12,
      "text": "- Compute a confirmation_tag over the empty confirmed_transcript_hash using the confirmation_key as described in Section 6.1.",
      "ja": "- セクション6.1で説明されているように、確認キーを使用して空の確認済みトランスクリプトハッシュ上に確認タグを計算してください。"
    },
    {
      "indent": 12,
      "text": "- Compute the updated interim_transcript_hash from the confirmed_transcript_hash and the confirmation_tag as described in Section 8.2.",
      "ja": "- セクション8.2で説明されている通り、確認されたトランスクリプトハッシュと確認タグから更新された interim_transcript_hash を計算してください。"
    },
    {
      "indent": 3,
      "text": "At this point, the creator's state represents a one-member group with a fully initialized key schedule, transcript hashes, etc. Proposals and Commits can be generated for this group state just like any other state of the group, such as Add proposals and Commits to add other members to the group. A GroupInfo object for this group state can also be published to facilitate external joins.",
      "ja": "この時点で、作成者の状態は、完全に初期化されたキースケジュール、トランスクリプトハッシュなどを持つ1人のメンバーグループを表します。提案やコミットは、このグループの状態に対して他のグループの状態と同様に生成できます。たとえば、他のメンバーをグループに追加するための追加提案やコミットなどです。このグループ状態のためのGroupInfoオブジェクトも公開され、外部からの参加を容易にすることができます。"
    },
    {
      "indent": 3,
      "text": "Members other than the creator join either by being sent a Welcome message (as described in Section 12.4.3.1) or by sending an external Commit (see Section 12.4.3.2).",
      "ja": "作成者以外のメンバーは、Section 12.4.3.1 で説明されているようにウェルカムメッセージを受け取るか、Section 12.4.3.2 を参照して外部コミットを送信することで参加します。"
    },
    {
      "indent": 3,
      "text": "In principle, the above process could be streamlined by having the creator directly create a tree and choose a random value for first epoch's epoch secret. We follow the steps above because it removes unnecessary choices, by which, for example, bad randomness could be introduced. The only choices the creator makes here are its own KeyPackage and the leaf secret from which the Commit is built.",
      "ja": "原則として、上記のプロセスは、作成者が直接ツリーを作成し、最初のエポックのエポックシークレットのランダムな値を選択することで合理化できます。上記の手順に従う理由は、不要な選択肢を取り除くためであり、例えば悪いランダム性が導入される可能性があるためです。作成者が行う唯一の選択肢は、自身のKeyPackageと、Commitが構築されるリーフシークレットです。"
    },
    {
      "indent": 0,
      "text": "11.1. Required Capabilities",
      "section_title": true,
      "ja": "11.1. 必要な能力"
    },
    {
      "indent": 3,
      "text": "The configuration of a group imposes certain requirements on clients in the group. At a minimum, all members of the group need to support the cipher suite and protocol version in use. Additional requirements can be imposed by including a required_capabilities extension in the GroupContext.",
      "ja": "グループの構成は、グループ内のクライアントに特定の要件を課します。最低限、グループのすべてのメンバーは使用中の暗号スイートとプロトコルバージョンをサポートする必要があります。さらに要件を課すためには、GroupContextにrequired_capabilities拡張を含めることができます。"
    },
    {
      "indent": 3,
      "text": "struct {\n    ExtensionType extension_types<V>;\n    ProposalType proposal_types<V>;\n    CredentialType credential_types<V>;\n} RequiredCapabilities;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This extension lists the extensions, proposals, and credential types that must be supported by all members of the group. The \"default\" proposal and extension types defined in this document are assumed to be implemented by all clients, and need not be listed in RequiredCapabilities in order to be safely used. Note that this is not true for credential types.",
      "ja": "この拡張機能は、グループのすべてのメンバーによってサポートされる必要がある拡張機能、提案、および資格情報タイプをリストします。この文書で定義された「デフォルト」の提案と拡張機能タイプは、すべてのクライアントによって実装されていると想定され、RequiredCapabilitiesにリストされる必要はありません。ただし、資格情報タイプについてはこれは当てはまりません。"
    },
    {
      "indent": 3,
      "text": "For new members, support for required capabilities is enforced by existing members during the application of Add commits. Existing members should of course be in compliance already. In order to ensure this continues to be the case even as the group's extensions are updated, a GroupContextExtensions proposal is deemed invalid if it contains a required_capabilities extension that requires non-default capabilities not supported by all current members.",
      "ja": "新しいメンバーに対して、必要な機能のサポートは、Addコミットの適用中に既存のメンバーによって強制されます。既存のメンバーはもちろん、すでに準拠している必要があります。グループの拡張が更新されてもこれが継続するようにするために、GroupContextExtensionsの提案は、すべての現在のメンバーによってサポートされていない非デフォルトの機能を必要とするrequired_capabilities拡張を含む場合には無効と見なされます。"
    },
    {
      "indent": 0,
      "text": "11.2. Reinitialization",
      "section_title": true,
      "ja": "11.2. 再初期化"
    },
    {
      "indent": 3,
      "text": "A group may be reinitialized by creating a new group with the same membership and different parameters, and linking it to the old group via a resumption PSK. The members of a group reinitialize it using the following steps:",
      "ja": "グループは、同じメンバーシップを持ち、異なるパラメータを持つ新しいグループを作成し、再開PSKを介して古いグループにリンクすることで再初期化される可能性があります。グループのメンバーは、以下の手順を使用してグループを再初期化します。"
    },
    {
      "indent": 8,
      "text": "1. A member of the old group sends a ReInit proposal (see Section 12.1.5).",
      "ja": "1. 古いグループのメンバーが再初期化提案を送信します（セクション12.1.5を参照）。"
    },
    {
      "indent": 8,
      "text": "2. A member of the old group sends a Commit covering the ReInit proposal.",
      "ja": "2. 古いグループのメンバーが、ReInit提案をカバーするCommitを送信します。"
    },
    {
      "indent": 8,
      "text": "3. A member of the old group creates an initial Commit that sets up a new group that matches the ReInit and sends a Welcome message:",
      "ja": "3. 古いグループのメンバーが、新しいグループを設定する最初のコミットを作成し、ReInitに一致する新しいグループを設定し、ウェルカムメッセージを送信します。"
    },
    {
      "indent": 14,
      "text": "* The version, cipher_suite, group_id, and extensions fields of the GroupContext object in the Welcome message MUST be the same as the corresponding fields in the ReInit proposal. The epoch in the Welcome message MUST be 1.",
      "ja": "* WelcomeメッセージのGroupContextオブジェクトのversion、cipher_suite、group_id、およびextensionsフィールドは、ReInit提案の対応するフィールドと同じでなければなりません。Welcomeメッセージのエポックは1でなければなりません。"
    },
    {
      "indent": 14,
      "text": "* The Welcome message MUST specify a PreSharedKeyID of type resumption with usage reinit, where the group_id field matches the old group and the epoch field indicates the epoch after the Commit covering the ReInit.",
      "ja": "* ウェルカムメッセージは、グループIDフィールドが古いグループと一致し、エポックフィールドがReInitをカバーするコミットの後のエポックを示す、再開の使用法を持つPreSharedKeyIDのタイプを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that these three steps may be done by the same group member or different members. For example, if a group member sends a Commit with an inline ReInit proposal (steps 1 and 2) but then goes offline, another group member may recreate the group instead. This flexibility avoids situations where a group gets stuck between steps 2 and 3.",
      "ja": "これらの3つのステップは、同じグループメンバーまたは異なるメンバーが行うことができることに注意してください。たとえば、グループメンバーがインラインのReInit提案を含むCommitを送信する（ステップ1および2）が、その後オフラインになった場合、別のグループメンバーが代わりにグループを再作成することができます。この柔軟性により、グループがステップ2と3の間で立ち往生する状況を回避できます。"
    },
    {
      "indent": 3,
      "text": "Resumption PSKs with usage reinit MUST NOT be used in other contexts. A PreSharedKey proposal with type resumption and usage reinit MUST be considered invalid.",
      "ja": "再開PSKの使用再初期化を伴うPSKは他の文脈で使用してはいけません。再開と使用再初期化を持つPreSharedKey提案は無効と見なされなければなりません。"
    },
    {
      "indent": 0,
      "text": "11.3. Subgroup Branching",
      "section_title": true,
      "ja": "11.3. サブグループ分岐"
    },
    {
      "indent": 3,
      "text": "A new group can be formed from a subset of an existing group's members, using the same parameters as the old group.",
      "ja": "既存のグループのメンバーのサブセットを使用して、同じパラメーターを使用して新しいグループを形成することができます。"
    },
    {
      "indent": 3,
      "text": "A member can create a subgroup by performing the following steps:",
      "ja": "メンバーは、次の手順を実行することでサブグループを作成することができます："
    },
    {
      "indent": 8,
      "text": "1. Fetch a new KeyPackage for each group member that should be included in the subgroup.",
      "ja": "1. サブグループに含まれる各グループメンバーのために新しいKeyPackageを取得してください。"
    },
    {
      "indent": 8,
      "text": "2. Create an initial Commit message that sets up the new group and contains a PreSharedKey proposal of type resumption with usage branch. To avoid key reuse, the psk_nonce included in the PreSharedKeyID object MUST be a randomly sampled nonce of length KDF.Nh.",
      "ja": "2. 新しいグループを設定し、使用ブランチを持つ再開のタイプのPreSharedKey提案を含む初期のコミットメッセージを作成してください。鍵の再利用を避けるために、PreSharedKeyIDオブジェクトに含まれるpsk_nonceは、長さKDF.Nhのランダムにサンプリングされたノンスでなければなりません。"
    },
    {
      "indent": 8,
      "text": "3. Send the corresponding Welcome message to the subgroup members.",
      "ja": "3. サブグループのメンバーに対応する歓迎メッセージを送信してください。"
    },
    {
      "indent": 3,
      "text": "A client receiving a Welcome message including a PreSharedKey of type resumption with usage branch MUST verify that the new group reflects a subgroup branched from the referenced group by checking that:",
      "ja": "「ウェルカムメッセージを受信するクライアントは、使用ブランチが再開タイプのPreSharedKeyを含む場合、新しいグループが参照されたグループから分岐したサブグループを反映していることを確認する必要があります。これは、次のようにチェックすることで行います：」"
    },
    {
      "indent": 6,
      "text": "* The version and cipher_suite values in the Welcome message are the same as those used by the old group.",
      "ja": "* ウェルカムメッセージのバージョンとcipher_suiteの値は、古いグループで使用されていたものと同じです。"
    },
    {
      "indent": 6,
      "text": "* The epoch in the Welcome message MUST be 1.",
      "ja": "* ウェルカムメッセージのエポックは必ず1でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* Each LeafNode in a new subgroup MUST match some LeafNode in the original group. In this context, a pair of LeafNodes is said to \"match\" if the identifiers presented by their respective credentials are considered equivalent by the application.",
      "ja": "* 新しいサブグループの各LeafNodeは、元のグループのいずれかのLeafNodeと一致する必要があります。この文脈では、LeafNodesのペアが「一致する」とは、それぞれの資格情報によって提示される識別子がアプリケーションによって等価と見なされる場合を指します。"
    },
    {
      "indent": 3,
      "text": "Resumption PSKs with usage branch MUST NOT be used in other contexts. A PreSharedKey proposal with type resumption and usage branch MUST be considered invalid.",
      "ja": "使用ブランチを持つ再開PSKは他の文脈で使用してはいけません。再開と使用ブランチを持つPreSharedKey提案は無効と見なされなければなりません。"
    },
    {
      "indent": 0,
      "text": "12. Group Evolution",
      "section_title": true,
      "ja": "12. グループ進化"
    },
    {
      "indent": 3,
      "text": "Over the lifetime of a group, its membership can change, and existing members might want to change their keys in order to achieve post-compromise security. In MLS, each such change is accomplished by a two-step process:",
      "ja": "グループの寿命を通じて、そのメンバーシップは変化する可能性があり、既存のメンバーはポストコンプロマイズセキュリティを実現するためにキーを変更したい場合があります。MLSでは、そのような変更は2段階のプロセスによって達成されます。"
    },
    {
      "indent": 8,
      "text": "1. A proposal to make the change is broadcast to the group in a Proposal message.",
      "ja": "1. 変更を行う提案は、提案メッセージでグループに放送されます。"
    },
    {
      "indent": 8,
      "text": "2. A member of the group or a new member broadcasts a Commit message that causes one or more proposed changes to enter into effect.",
      "ja": "2. グループのメンバーまたは新しいメンバーがコミットメッセージを送信し、提案された1つ以上の変更が有効になるようにします。"
    },
    {
      "indent": 3,
      "text": "In cases where the Proposal and Commit are sent by the same member, these two steps can be combined by sending the proposals in the commit.",
      "ja": "提案とコミットが同じメンバーから送信される場合、これら2つのステップは、提案をコミットで送信することで組み合わせることができます。"
    },
    {
      "indent": 3,
      "text": "The group thus evolves from one cryptographic state to another each time a Commit message is sent and processed. These states are referred to as \"epochs\" and are uniquely identified among states of the group by eight-octet epoch values. When a new group is initialized, its initial state epoch is 0x0000000000000000. Each time a state transition occurs, the epoch number is incremented by one.",
      "ja": "グループは、Commitメッセージが送信され処理されるたびに、暗号状態から別の暗号状態へ進化します。これらの状態は「エポック」と呼ばれ、グループの状態の中で8オクテットのエポック値によって一意に識別されます。新しいグループが初期化されると、その初期状態のエポックは0x0000000000000000です。状態遷移が発生するたびに、エポック番号は1ずつ増加します。"
    },
    {
      "indent": 0,
      "text": "12.1. Proposals",
      "section_title": true,
      "ja": "12.1. 提案"
    },
    {
      "indent": 3,
      "text": "Proposals are included in a FramedContent by way of a Proposal structure that indicates their type:",
      "ja": "提案は、そのタイプを示す提案構造を介して、フレーム付きコンテンツに含まれています。"
    },
    {
      "indent": 3,
      "text": "// See the \"MLS Proposal Types\" IANA registry for values\nuint16 ProposalType;\n\nstruct {\n    ProposalType proposal_type;\n    select (Proposal.proposal_type) {\n        case add:                      Add;\n        case update:                   Update;\n        case remove:                   Remove;\n        case psk:                      PreSharedKey;\n        case reinit:                   ReInit;\n        case external_init:            ExternalInit;\n        case group_context_extensions: GroupContextExtensions;\n    };\n} Proposal;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "On receiving a FramedContent containing a Proposal, a client MUST verify the signature inside FramedContentAuthData and that the epoch field of the enclosing FramedContent is equal to the epoch field of the current GroupContext object. If the verification is successful, then the Proposal should be cached in such a way that it can be retrieved by hash (as a ProposalOrRef object) in a later Commit message.",
      "ja": "FramedContentを含む提案を受け取った場合、クライアントはFramedContentAuthData内の署名と、FramedContentのエポックフィールドが現在のGroupContextオブジェクトのエポックフィールドと等しいことを検証しなければなりません。検証が成功した場合、提案は後のCommitメッセージでProposalOrRefオブジェクトとしてハッシュによって取得できるようにキャッシュされるべきです。"
    },
    {
      "indent": 0,
      "text": "12.1.1. Add",
      "section_title": true,
      "ja": "12.1.1. 追加"
    },
    {
      "indent": 3,
      "text": "An Add proposal requests that a client with a specified KeyPackage be added to the group.",
      "ja": "Add提案は、指定されたKeyPackageを持つクライアントがグループに追加されるように要求します。"
    },
    {
      "indent": 3,
      "text": "struct {\n    KeyPackage key_package;\n} Add;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An Add proposal is invalid if the KeyPackage is invalid according to Section 10.1.",
      "ja": "10.1節に従って、KeyPackageが無効な場合、追加提案は無効です。"
    },
    {
      "indent": 3,
      "text": "An Add is applied after being included in a Commit message. The position of the Add in the list of proposals determines the leaf node where the new member will be added. For the first Add in the Commit, the corresponding new member will be placed in the leftmost empty leaf in the tree, for the second Add, the next empty leaf to the right, etc. If no empty leaf exists, the tree is extended to the right.",
      "ja": "Add は Commit メッセージに含まれた後に適用されます。提案リスト内での Add の位置が、新しいメンバーが追加される葉ノードを決定します。Commit 内の最初の Add では、対応する新メンバーはツリー内の左端の空の葉に配置されます。2番目の Add では、右隣の次の空の葉に配置されます。空の葉が存在しない場合、ツリーは右に拡張されます。"
    },
    {
      "indent": 6,
      "text": "* Identify the leaf L for the new member: if there are empty leaves in the tree, L is the leftmost empty leaf. Otherwise, the tree is extended to the right as described in Section 7.7, and L is assigned the leftmost new blank leaf.",
      "ja": "* 新しいメンバーのために葉Lを特定します：木に空の葉がある場合、Lは左端の空の葉です。それ以外の場合、木はセクション7.7で説明されているように右に拡張され、Lは左端の新しい空白の葉に割り当てられます。"
    },
    {
      "indent": 6,
      "text": "* For each non-blank intermediate node along the path from the leaf L to the root, add L's leaf index to the unmerged_leaves list for the node.",
      "ja": "* 葉ノード L からルートまでのパス上にある空でない中間ノードごとに、そのノードの unmerged_leaves リストに L の葉インデックスを追加してください。"
    },
    {
      "indent": 6,
      "text": "* Set the leaf node L to a new node containing the LeafNode object carried in the leaf_node field of the KeyPackage in the Add.",
      "ja": "* KeyPackage内のleaf_nodeフィールドに含まれるLeafNodeオブジェクトを持つ新しいノードLを設定してください。"
    },
    {
      "indent": 0,
      "text": "12.1.2. Update",
      "section_title": true,
      "ja": "12.1.2. 更新"
    },
    {
      "indent": 3,
      "text": "An Update proposal is a similar mechanism to Add with the distinction that it replaces the sender's LeafNode in the tree instead of adding a new leaf to the tree.",
      "ja": "更新提案は、追加と同様のメカニズムであり、異なる点は、新しい葉を木に追加するのではなく、送信者のLeafNodeを木の中で置き換えることです。"
    },
    {
      "indent": 3,
      "text": "struct {\n    LeafNode leaf_node;\n} Update;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An Update proposal is invalid if the LeafNode is invalid for an Update proposal according to Section 7.3.",
      "ja": "更新提案は、セクション7.3に従って、更新提案のLeafNodeが無効である場合に無効です。"
    },
    {
      "indent": 3,
      "text": "A member of the group applies an Update message by taking the following steps:",
      "ja": "グループのメンバーは、次の手順を取ることで更新メッセージを適用します："
    },
    {
      "indent": 6,
      "text": "* Replace the sender's LeafNode with the one contained in the Update proposal.",
      "ja": "* 送信者のLeafNodeを、更新提案に含まれるLeafNodeで置き換えてください。"
    },
    {
      "indent": 6,
      "text": "* Blank the intermediate nodes along the path from the sender's leaf to the root.",
      "ja": "* 送信元の葉からルートまでのパスに沿って中間ノードを空白にしてください。"
    },
    {
      "indent": 0,
      "text": "12.1.3. Remove",
      "section_title": true,
      "ja": "12.1.3. 削除"
    },
    {
      "indent": 3,
      "text": "A Remove proposal requests that the member with the leaf index removed be removed from the group.",
      "ja": "葉のインデックスが削除されたメンバーがグループから削除されるように、削除提案リクエストを行います。"
    },
    {
      "indent": 3,
      "text": "struct {\n    uint32 removed;\n} Remove;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A Remove proposal is invalid if the removed field does not identify a non-blank leaf node.",
      "ja": "削除提案は、削除されるフィールドが空でないリーフノードを識別しない場合に無効です。"
    },
    {
      "indent": 3,
      "text": "A member of the group applies a Remove message by taking the following steps:",
      "ja": "グループのメンバーは、次の手順を取ることで「削除」メッセージを適用します："
    },
    {
      "indent": 6,
      "text": "* Identify the leaf node matching removed. Let L be this leaf node.",
      "ja": "* 削除された葉ノードに一致する葉ノードを特定します。この葉ノードをLとします。"
    },
    {
      "indent": 6,
      "text": "* Replace the leaf node L with a blank node.",
      "ja": "* 葉ノード L を空のノードで置き換えてください。"
    },
    {
      "indent": 6,
      "text": "* Blank the intermediate nodes along the path from L to the root.",
      "ja": "* Lからルートまでのパス上の中間ノードを空白にしてください。"
    },
    {
      "indent": 6,
      "text": "* Truncate the tree by removing the right subtree until there is at least one non-blank leaf node in the right subtree. If the rightmost non-blank leaf has index L, then this will result in the tree having 2^d leaves, where d is the smallest value such that 2^d > L.",
      "ja": "* 右部分木を削除して、右部分木に少なくとも1つの空でない葉ノードがあるまで木を切り詰めます。もし右端の空でない葉のインデックスがLであるなら、この操作により木は2^d個の葉を持つようになります。ここで、dは2^d > Lを満たす最小の値です。"
    },
    {
      "indent": 0,
      "text": "12.1.4. PreSharedKey",
      "section_title": true,
      "ja": "12.1.4. 事前共有キー"
    },
    {
      "indent": 3,
      "text": "A PreSharedKey proposal can be used to request that a pre-shared key be injected into the key schedule in the process of advancing the epoch.",
      "ja": "PreSharedKey提案は、エポックの進行過程で事前共有キーがキースケジュールに挿入されるよう要求するために使用できます。"
    },
    {
      "indent": 3,
      "text": "struct {\n    PreSharedKeyID psk;\n} PreSharedKey;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A PreSharedKey proposal is invalid if any of the following is true:",
      "ja": "もし以下のいずれかが真実である場合、PreSharedKey提案は無効です。"
    },
    {
      "indent": 6,
      "text": "* The PreSharedKey proposal is not being processed as part of a reinitialization of the group (see Section 11.2), and the PreSharedKeyID has psktype set to resumption and usage set to reinit.",
      "ja": "* PreSharedKey提案は、グループの再初期化の一部として処理されていない（11.2節を参照）、そしてPreSharedKeyIDはpsktypeが再開、usageが再初期化に設定されています。"
    },
    {
      "indent": 6,
      "text": "* The PreSharedKey proposal is not being processed as part of a subgroup branching operation (see Section 11.3), and the PreSharedKeyID has psktype set to resumption and usage set to branch.",
      "ja": "* PreSharedKey提案は、サブグループの分岐操作の一部として処理されていません（11.3節を参照）。また、PreSharedKeyIDは、psktypeが再開、usageが分岐に設定されています。"
    },
    {
      "indent": 6,
      "text": "* The psk_nonce is not of length KDF.Nh.",
      "ja": "* psk_nonceは長さKDF.Nhではありません。"
    },
    {
      "indent": 3,
      "text": "The psk_nonce MUST be randomly sampled. When processing a Commit message that includes one or more PreSharedKey proposals, group members derive psk_secret as described in Section 8.4, where the order of the PSKs corresponds to the order of the PreSharedKey proposals in the Commit.",
      "ja": "psk_nonceはランダムにサンプリングされる必要があります。1つ以上のPreSharedKey提案を含むCommitメッセージを処理する際、グループメンバーは、PSKの順序がCommit内のPreSharedKey提案の順序に対応するように、セクション8.4で説明されているようにpsk_secretを導出します。"
    },
    {
      "indent": 0,
      "text": "12.1.5. ReInit",
      "section_title": true,
      "ja": "12.1.5. 再初期化"
    },
    {
      "indent": 3,
      "text": "A ReInit proposal represents a request to reinitialize the group with different parameters, for example, to increase the version number or to change the cipher suite. The reinitialization is done by creating a completely new group and shutting down the old one.",
      "ja": "ReInit提案は、異なるパラメータでグループを再初期化するリクエストを表します。たとえば、バージョン番号を増やしたり、暗号スイートを変更したりすることができます。再初期化は、完全に新しいグループを作成し、古いグループをシャットダウンすることで行われます。"
    },
    {
      "indent": 3,
      "text": "struct {\n    opaque group_id<V>;\n    ProtocolVersion version;\n    CipherSuite cipher_suite;\n    Extension extensions<V>;\n} ReInit;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A ReInit proposal is invalid if the version field is less than the version for the current group.",
      "ja": "「ReInit提案は、バージョンフィールドが現在のグループのバージョンよりも小さい場合に無効です。」"
    },
    {
      "indent": 3,
      "text": "A member of the group applies a ReInit proposal by waiting for the committer to send the Welcome message that matches the ReInit, according to the criteria in Section 11.2.",
      "ja": "グループのメンバーは、11.2節の基準に従って、コミッターがReInitに一致するウェルカムメッセージを送信するのを待って、ReInit提案を適用します。"
    },
    {
      "indent": 0,
      "text": "12.1.6. ExternalInit",
      "section_title": true,
      "ja": "12.1.6. 外部初期化"
    },
    {
      "indent": 3,
      "text": "An ExternalInit proposal is used by new members that want to join a group by using an external commit. This proposal can only be used in that context.",
      "ja": "新しいメンバーが外部コミットを使用してグループに参加したい場合に使用されるExternalInit提案です。この提案はそのコンテキストでのみ使用できます。"
    },
    {
      "indent": 3,
      "text": "struct {\n  opaque kem_output<V>;\n} ExternalInit;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A member of the group applies an ExternalInit message by initializing the next epoch using an init secret computed as described in Section 8.3. The kem_output field contains the required KEM output.",
      "ja": "グループのメンバーは、セクション8.3で説明されているように計算された初期化秘密を使用して次のエポックを初期化するExternalInitメッセージを適用します。kem_outputフィールドには必要なKEM出力が含まれています。"
    },
    {
      "indent": 0,
      "text": "12.1.7. GroupContextExtensions",
      "section_title": true,
      "ja": "12.1.7. グループコンテキスト拡張機能"
    },
    {
      "indent": 3,
      "text": "A GroupContextExtensions proposal is used to update the list of extensions in the GroupContext for the group.",
      "ja": "GroupContextExtensionsの提案は、グループのGroupContext内の拡張機能のリストを更新するために使用されます。"
    },
    {
      "indent": 3,
      "text": "struct {\n  Extension extensions<V>;\n} GroupContextExtensions;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A GroupContextExtensions proposal is invalid if it includes a required_capabilities extension and some members of the group do not support some of the required capabilities (including those added in the same Commit, and excluding those removed).",
      "ja": "GroupContextExtensionsの提案は、必要な機能拡張を含む場合、かつグループの一部のメンバーが必要な機能のいくつかをサポートしていない場合に無効です（同じコミットで追加されたものを含み、削除されたものを除く）。"
    },
    {
      "indent": 3,
      "text": "A member of the group applies a GroupContextExtensions proposal with the following steps:",
      "ja": "グループのメンバーが、次の手順でGroupContextExtensions提案を適用します："
    },
    {
      "indent": 6,
      "text": "* Remove all of the existing extensions from the GroupContext object for the group and replace them with the list of extensions in the proposal. (This is a wholesale replacement, not a merge. An extension is only carried over if the sender of the proposal includes it in the new list.)",
      "ja": "* グループのGroupContextオブジェクトからすべての既存の拡張機能を削除し、提案の拡張機能リストでそれらを置き換えます。（これは卸売りの置換であり、マージではありません。提案の送信者が新しいリストにそれを含める場合にのみ、拡張機能が引き継がれます。）"
    },
    {
      "indent": 3,
      "text": "Note that once the GroupContext is updated, its inclusion in the confirmation_tag by way of the key schedule will confirm that all members of the group agree on the extensions in use.",
      "ja": "GroupContext が更新されると、そのキー スケジュールを通じて確認タグに含まれることに注意してください。これにより、グループのすべてのメンバーが使用されている拡張機能に同意していることが確認されます。"
    },
    {
      "indent": 0,
      "text": "12.1.8. External Proposals",
      "section_title": true,
      "ja": "12.1.8. 外部提案"
    },
    {
      "indent": 3,
      "text": "Proposals can be constructed and sent to the group by a party that is outside the group in two cases. One case, indicated by the external SenderType, allows an entity outside the group to submit proposals to the group. For example, an automated service might propose removing a member of a group who has been inactive for a long time, or propose adding a newly hired staff member to a group representing a real-world team. An external sender might send a ReInit proposal to enforce a changed policy regarding MLS versions or cipher suites.",
      "ja": "提案は、グループ外の当事者によって2つのケースで構築およびグループに送信されることができます。外部のSenderTypeによって示される1つのケースでは、グループ外のエンティティがグループに提案を提出することができます。たとえば、自動サービスが、長期間非アクティブであるグループのメンバーを削除することを提案したり、実際のチームを表すグループに新しく雇われたスタッフメンバーを追加することを提案したりすることができます。外部の送信者は、MLSバージョンや暗号スイートに関する変更されたポリシーを強制するためにReInit提案を送信するかもしれません。"
    },
    {
      "indent": 3,
      "text": "The external SenderType requires that signers are pre-provisioned to the clients within a group and can only be used if the external_senders extension is present in the group's GroupContext.",
      "ja": "外部のSenderTypeは、署名者がグループ内のクライアントに事前にプロビジョニングされている必要があり、外部送信者拡張機能がグループのGroupContextに存在する場合にのみ使用できます。"
    },
    {
      "indent": 3,
      "text": "The other case, indicated by the new_member_proposal SenderType, is useful when existing members of the group can independently verify that an Add proposal sent by the new joiner itself (not an existing member) is authorized. External proposals that are not authorized are considered invalid.",
      "ja": "新しいメンバー提案のSenderTypeによって示されるもう1つのケースは、グループの既存メンバーが新規参加者自体（既存メンバーではなく）によって送信された追加提案が承認されていることを独自に確認できる場合に有用です。 承認されていない外部提案は無効と見なされます。"
    },
    {
      "indent": 3,
      "text": "An external proposal MUST be sent as a PublicMessage object, since the sender will not have the keys necessary to construct a PrivateMessage object.",
      "ja": "外部提案は、送信者がプライベートメッセージオブジェクトを構築するために必要なキーを持っていないため、PublicMessageオブジェクトとして送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Proposals of some types cannot be sent by an external sender. Among the proposal types defined in this document, only the following types may be sent by an external sender:",
      "ja": "いくつかの種類の提案は外部の送信者によって送信することができません。この文書で定義されている提案の種類の中で、外部の送信者によって送信することができるのは以下の種類のみです："
    },
    {
      "indent": 6,
      "text": "* add",
      "ja": "* 追加"
    },
    {
      "indent": 6,
      "text": "* remove",
      "ja": "* 削除します。"
    },
    {
      "indent": 6,
      "text": "* psk",
      "ja": "* psk"
    },
    {
      "indent": 6,
      "text": "* reinit",
      "ja": "* 再初期化"
    },
    {
      "indent": 6,
      "text": "* group_context_extensions",
      "ja": "* グループコンテキスト拡張"
    },
    {
      "indent": 3,
      "text": "Messages from external senders containing proposal types other than the above MUST be rejected as malformed. New proposal types defined in the future MUST define whether they may be sent by external senders. The \"Ext\" column in the \"MLS Proposal Types\" registry (Section 17.4) reflects this property.",
      "ja": "上記以外の提案タイプを含む外部送信者からのメッセージは、不正な形式として拒否されなければなりません。将来定義される新しい提案タイプは、外部送信者から送信されるかどうかを定義しなければなりません。 「MLS提案タイプ」レジストリ（セクション17.4）の「Ext」列がこのプロパティを反映しています。"
    },
    {
      "indent": 0,
      "text": "12.1.8.1. External Senders Extension",
      "section_title": true,
      "ja": "12.1.8.1. 外部送信者拡張機能"
    },
    {
      "indent": 3,
      "text": "The external_senders extension is a group context extension that contains the credentials and signature keys of senders that are permitted to send external proposals to the group.",
      "ja": "external_senders拡張機能は、グループに外部提案を送信することが許可されている送信者の資格情報と署名キーを含むグループコンテキスト拡張機能です。"
    },
    {
      "indent": 3,
      "text": "struct {\n  SignaturePublicKey signature_key;\n  Credential credential;\n} ExternalSender;\n\nExternalSender external_senders<V>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "12.2. Proposal List Validation",
      "section_title": true,
      "ja": "12.2. 提案リストの検証"
    },
    {
      "indent": 3,
      "text": "A group member creating a Commit and a group member processing a Commit MUST verify that the list of committed proposals is valid using one of the following procedures, depending on whether the Commit is external or not. If the list of proposals is invalid, then the Commit message MUST be rejected as invalid.",
      "ja": "グループメンバーがコミットを作成する場合と、グループメンバーがコミットを処理する場合は、コミットされた提案のリストが有効であることを確認する必要があります。コミットが外部のものかどうかに応じて、次の手順のいずれかを使用してください。提案のリストが無効な場合、コミットメッセージは無効として拒否されなければなりません。"
    },
    {
      "indent": 3,
      "text": "For a regular, i.e., not external, Commit, the list is invalid if any of the following occurs:",
      "ja": "通常の、つまり外部のコミットでない場合、次のいずれかが発生した場合、リストは無効です："
    },
    {
      "indent": 6,
      "text": "* It contains an individual proposal that is invalid as specified in Section 12.1.",
      "ja": "* セクション12.1で指定された通りに無効な個別提案が含まれています。"
    },
    {
      "indent": 6,
      "text": "* It contains an Update proposal generated by the committer.",
      "ja": "* それには、コミッターによって生成された更新提案が含まれています。"
    },
    {
      "indent": 6,
      "text": "* It contains a Remove proposal that removes the committer.",
      "ja": "* それには、コミッターを削除する削除提案が含まれています。"
    },
    {
      "indent": 6,
      "text": "* It contains multiple Update and/or Remove proposals that apply to the same leaf. If the committer has received multiple such proposals they SHOULD prefer any Remove received, or the most recent Update if there are no Removes.",
      "ja": "* 同じ葉に適用される複数の更新および/または削除提案が含まれています。コミッターが複数のこのような提案を受け取った場合、削除があればそれを優先し、削除がない場合は最新の更新を選択するべきです。"
    },
    {
      "indent": 6,
      "text": "* It contains multiple Add proposals that contain KeyPackages that represent the same client according to the application (for example, identical signature keys).",
      "ja": "* このアプリケーションによれば、同じクライアントを表すKeyPackagesを含む複数のAdd提案が含まれています（例：同一の署名キー）。"
    },
    {
      "indent": 6,
      "text": "* It contains an Add proposal with a KeyPackage that represents a client already in the group according to the application, unless there is a Remove proposal in the list removing the matching client from the group.",
      "ja": "* アプリケーションによると、グループ内のクライアントを表すKeyPackageを含むAdd提案が含まれています。ただし、一致するクライアントをグループから削除するリスト内のRemove提案がない限りです。"
    },
    {
      "indent": 6,
      "text": "* It contains multiple PreSharedKey proposals that reference the same PreSharedKeyID.",
      "ja": "* 同じ PreSharedKeyID を参照する複数の PreSharedKey 提案が含まれています。"
    },
    {
      "indent": 6,
      "text": "* It contains multiple GroupContextExtensions proposals.",
      "ja": "* 複数のGroupContextExtensions提案が含まれています。"
    },
    {
      "indent": 6,
      "text": "* It contains a ReInit proposal together with any other proposal. If the committer has received other proposals during the epoch, they SHOULD prefer them over the ReInit proposal, allowing the ReInit to be resent and applied in a subsequent epoch.",
      "ja": "* それには、他の提案と一緒にReInit提案が含まれています。もしコミッターがエポック中に他の提案を受け取った場合、彼らはReInit提案よりもそれらを優先すべきであり、ReInitが再送信されて次のエポックで適用されることを許可すべきです。"
    },
    {
      "indent": 6,
      "text": "* It contains an ExternalInit proposal.",
      "ja": "* それにはExternalInit提案が含まれています。"
    },
    {
      "indent": 6,
      "text": "* It contains a Proposal with a non-default proposal type that is not supported by some members of the group that will process the Commit (i.e., members being added or removed by the Commit do not need to support the proposal type).",
      "ja": "* コミットを処理するグループの一部のメンバーがサポートしていない非デフォルトの提案タイプを含む提案が含まれています（つまり、コミットによって追加または削除されるメンバーは、提案タイプをサポートする必要はありません）。"
    },
    {
      "indent": 6,
      "text": "* After processing the Commit the ratchet tree is invalid, in particular, if it contains any leaf node that is invalid according to Section 7.3.",
      "ja": "* 処理が完了した後、ラチェットツリーが無効になります。特に、セクション7.3に従って無効な葉ノードが含まれている場合です。"
    },
    {
      "indent": 3,
      "text": "An application may extend the above procedure by additional rules, for example, requiring application-level permissions to add members, or rules concerning non-default proposal types.",
      "ja": "上記の手順を追加のルールで拡張することができます。例えば、メンバーを追加する際にアプリケーションレベルの権限が必要など、追加のルールが適用されることがあります。"
    },
    {
      "indent": 3,
      "text": "For an external Commit, the list is valid if it contains only the following proposals (not necessarily in this order):",
      "ja": "外部コミットの場合、リストが次の提案のみを含む場合に有効です（必ずしもこの順序である必要はありません）："
    },
    {
      "indent": 6,
      "text": "* Exactly one ExternalInit",
      "ja": "* 正確に1つのExternalInit"
    },
    {
      "indent": 6,
      "text": "* At most one Remove proposal, with which the joiner removes an old version of themselves. If a Remove proposal is present, then the LeafNode in the path field of the external Commit MUST meet the same criteria as would the LeafNode in an Update for the removed leaf (see Section 12.1.2). In particular, the credential in the LeafNode MUST present a set of identifiers that is acceptable to the application for the removed participant.",
      "ja": "* 最大1つの削除提案があります。この提案により、参加者は自分自身の古いバージョンを削除します。削除提案が存在する場合、外部コミットのパスフィールドにあるLeafNodeは、削除されたリーフの場合と同じ基準を満たさなければなりません（詳細は12.1.2節を参照）。特に、LeafNode内の資格情報は、削除された参加者に対してアプリケーションが受け入れ可能な識別子のセットを提示しなければなりません。"
    },
    {
      "indent": 6,
      "text": "* Zero or more PreSharedKey proposals",
      "ja": "* ゼロ個以上の PreSharedKey 提案"
    },
    {
      "indent": 6,
      "text": "* No other proposals",
      "ja": "* 他の提案はありません。"
    },
    {
      "indent": 3,
      "text": "Proposal types defined in the future may make updates to the above validation logic to incorporate considerations related to proposals of the new type.",
      "ja": "将来定義される提案タイプは、上記の検証ロジックを更新し、新しいタイプの提案に関連する考慮事項を取り入れる可能性があります。"
    },
    {
      "indent": 0,
      "text": "12.3. Applying a Proposal List",
      "section_title": true,
      "ja": "12.3. 提案リストの適用"
    },
    {
      "indent": 3,
      "text": "The sections above defining each proposal type describe how each individual proposal is applied. When creating or processing a Commit, a client applies a list of proposals to the ratchet tree and GroupContext. The client MUST apply the proposals in the list in the following order:",
      "ja": "各提案タイプを定義する上記のセクションは、各個々の提案が適用される方法を説明しています。 Commit を作成または処理する際、クライアントは提案のリストをラチェットツリーと GroupContext に適用します。 クライアントは、リスト内の提案を以下の順序で適用しなければなりません："
    },
    {
      "indent": 6,
      "text": "* If there is a GroupContextExtensions proposal, replace the extensions field of the GroupContext for the group with the contents of the proposal. The new extensions MUST be used when evaluating other proposals in this list. For example, if a GroupContextExtensions proposal adds a required_capabilities extension, then any Add proposals need to indicate support for those capabilities.",
      "ja": "* もしGroupContextExtensionsの提案がある場合、その提案の内容でグループのGroupContextの拡張フィールドを置き換えてください。新しい拡張は、このリスト内の他の提案を評価する際に使用しなければなりません。例えば、もしGroupContextExtensionsの提案がrequired_capabilities拡張を追加した場合、Addの提案はそれらの機能をサポートすることを示さなければなりません。"
    },
    {
      "indent": 6,
      "text": "* Apply any Update proposals to the ratchet tree, in any order.",
      "ja": "* いかなる順番でも、更新提案をラチェットツリーに適用してください。"
    },
    {
      "indent": 6,
      "text": "* Apply any Remove proposals to the ratchet tree, in any order.",
      "ja": "* どんな順番でも、リatchetツリーにあるいかなる削除提案も適用してください。"
    },
    {
      "indent": 6,
      "text": "* Apply any Add proposals to the ratchet tree, in the order they appear in the list.",
      "ja": "* リストに表示される順番に、どんな追加提案もラチェットツリーに適用してください。"
    },
    {
      "indent": 6,
      "text": "* Look up the PSK secrets for any PreSharedKey proposals, in the order they appear in the list. These secrets are then used to advance the key schedule later in Commit processing.",
      "ja": "* リスト内のPreSharedKey提案のPSKシークレットを順番に調べてください。これらのシークレットは、後でCommit処理中にキースケジュールを進めるために使用されます。"
    },
    {
      "indent": 6,
      "text": "* If there is an ExternalInit proposal, use it to derive the init_secret for use later in Commit processing.",
      "ja": "* もしExternalInit提案があれば、それを使用して後でCommit処理で使用するinit_secretを導出してください。"
    },
    {
      "indent": 6,
      "text": "* If there is a ReInit proposal, note its parameters for application later in Commit processing.",
      "ja": "* ReInit提案がある場合は、後でCommit処理での適用のためにそのパラメータを記録してください。"
    },
    {
      "indent": 3,
      "text": "Proposal types defined in the future MUST specify how the above steps are to be adjusted to accommodate the application of proposals of the new type.",
      "ja": "将来定義される提案タイプは、新しいタイプの提案の適用を受け入れるために上記の手順がどのように調整されるかを明確にする必要があります。"
    },
    {
      "indent": 0,
      "text": "12.4. Commit",
      "section_title": true,
      "ja": "12.4. コミット"
    },
    {
      "indent": 3,
      "text": "A Commit message initiates a new epoch for the group, based on a collection of Proposals. It instructs group members to update their representation of the state of the group by applying the proposals and advancing the key schedule.",
      "ja": "コミットメッセージは、提案のコレクションに基づいてグループの新しいエポックを開始します。これは、グループメンバーに対して、提案を適用し、キースケジュールを進めることでグループの状態の表現を更新するよう指示します。"
    },
    {
      "indent": 3,
      "text": "Each proposal covered by the Commit is included by a ProposalOrRef value, which identifies the proposal to be applied by value or by reference. Commits that refer to new Proposals from the committer can be included by value. Commits for previously sent proposals from anyone (including the committer) can be sent by reference. Proposals sent by reference are specified by including the hash of the AuthenticatedContent object in which the proposal was sent (see Section 5.2).",
      "ja": "各コミットでカバーされる提案は、提案を値または参照によって適用する提案または参照値によって含まれています。コミッターからの新しい提案を参照するコミットは、値によって含めることができます。以前に送信された提案に対するコミットは、誰からでも（コミッターを含む）参照によって送信することができます。参照によって送信された提案は、提案が送信された AuthenticatedContent オブジェクトのハッシュを含めることで指定されます（5.2 節を参照）。"
    },
    {
      "indent": 3,
      "text": "enum {\n  reserved(0),\n  proposal(1),\n  reference(2),\n  (255)\n} ProposalOrRefType;\n\nstruct {\n  ProposalOrRefType type;\n  select (ProposalOrRef.type) {\n    case proposal:  Proposal proposal;\n    case reference: ProposalRef reference;\n  };\n} ProposalOrRef;\n\nstruct {\n    ProposalOrRef proposals<V>;\n    optional<UpdatePath> path;\n} Commit;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A group member that has observed one or more valid proposals within an epoch MUST send a Commit message before sending application data. This ensures, for example, that any members whose removal was proposed during the epoch are actually removed before any application data is transmitted.",
      "ja": "1つ以上の有効な提案を観察したグループメンバーは、アプリケーションデータを送信する前にコミットメッセージを送信する必要があります。これにより、例えば、エポック中に削除が提案されたメンバーが実際に削除されてからアプリケーションデータが送信されることが保証されます。"
    },
    {
      "indent": 3,
      "text": "A sender and a receiver of a Commit MUST verify that the committed list of proposals is valid as specified in Section 12.2. A list is invalid if, for example, it includes an Update and a Remove for the same member, or an Add when the sender does not have the application-level permission to add new users.",
      "ja": "コミットの送信者と受信者は、12.2節で指定されている通り、コミットされた提案のリストが有効であることを確認する必要があります。たとえば、同じメンバーに対する更新と削除が含まれている場合や、送信者が新しいユーザーを追加するアプリケーションレベルの権限を持っていない場合、リストは無効です。"
    },
    {
      "indent": 3,
      "text": "The sender of a Commit SHOULD include all proposals that it has received during the current epoch that are valid according to the rules for their proposal types and according to application policy, as long as this results in a valid proposal list.",
      "ja": "現在のエポック中に受信したすべての提案を、その提案タイプのルールとアプリケーションポリシーに従って有効であると判断されるものを含めるべきです。これにより有効な提案リストが得られる限り、Commitの送信者はそれらを含めるべきです。"
    },
    {
      "indent": 3,
      "text": "Due to the asynchronous nature of proposals, receivers of a Commit SHOULD NOT enforce that all valid proposals sent within the current epoch are referenced by the next Commit. In the event that a valid proposal is omitted from the next Commit, and that proposal is still valid in the current epoch, the sender of the proposal MAY resend it after updating it to reflect the current epoch.",
      "ja": "提案の非同期性により、Commitの受信者は、現在のエポック内で送信されたすべての有効な提案が次のCommitで参照されることを強制してはいけません。次のCommitから有効な提案が省略された場合、かつその提案が現在のエポックでまだ有効である場合、提案の送信者は、それを更新して現在のエポックを反映させた後、再送信しても構いません。"
    },
    {
      "indent": 3,
      "text": "A member of the group MAY send a Commit that references no proposals at all, which would thus have an empty proposals vector. Such a Commit resets the sender's leaf and the nodes along its direct path, and provides forward secrecy and post-compromise security with regard to the sender of the Commit. An Update proposal can be regarded as a \"lazy\" version of this operation, where only the leaf changes and intermediate nodes are blanked out.",
      "ja": "グループのメンバーは、提案を一切参照しないCommitを送信することができます。そのため、提案ベクトルが空になります。このようなCommitは、送信者のリーフとその直接パスにあるノードをリセットし、Commitの送信者に関して前方秘匿性とコンプロマイズ後のセキュリティを提供します。Update提案は、この操作の「怠惰な」バージョンと見なすことができます。ここでは、リーフのみが変更され、中間ノードは空白になります。"
    },
    {
      "indent": 3,
      "text": "By default, the path field of a Commit MUST be populated. The path field MAY be omitted if (a) it covers at least one proposal and (b) none of the proposals covered by the Commit are of \"path required\" types. A proposal type requires a path if it cannot change the group membership in a way that requires the forward secrecy and post-compromise security guarantees that an UpdatePath provides. The only proposal types defined in this document that do not require a path are:",
      "ja": "デフォルトでは、Commitのパスフィールドは必ず入力されている必要があります。パスフィールドは、(a) 少なくとも1つの提案をカバーしており、(b) Commitでカバーされている提案のいずれもが「パスが必要」とされていない場合には省略することができます。提案タイプがパスを必要とするのは、UpdatePathが提供する前方秘匿性とコンプロミス後のセキュリティ保証が必要なグループメンバーシップの変更を行うことができない場合です。この文書で定義されている唯一のパスが不要な提案タイプは以下の通りです："
    },
    {
      "indent": 6,
      "text": "* add",
      "ja": "* 追加"
    },
    {
      "indent": 6,
      "text": "* psk",
      "ja": "* psk"
    },
    {
      "indent": 6,
      "text": "* reinit",
      "ja": "* 再初期化"
    },
    {
      "indent": 3,
      "text": "New proposal types MUST state whether they require a path. If any instance of a proposal type requires a path, then the proposal type requires a path. This attribute of a proposal type is reflected in the \"Path Required\" field of the \"MLS Proposal Types\" registry defined in Section 17.4.",
      "ja": "新しい提案タイプは、パスが必要かどうかを明記する必要があります。提案タイプのいずれかのインスタンスがパスを必要とする場合、その提案タイプはパスが必要です。提案タイプのこの属性は、セクション17.4で定義された「MLS提案タイプ」レジストリの「パスが必要」フィールドに反映されています。"
    },
    {
      "indent": 3,
      "text": "Update and Remove proposals are the clearest examples of proposals that require a path. An UpdatePath is required to evict the removed member or the old appearance of the updated member.",
      "ja": "UpdateとRemoveの提案は、パスが必要な提案の最も明確な例です。UpdatePathは、削除されたメンバーまたは更新されたメンバーの古い外観を排除するために必要です。"
    },
    {
      "indent": 3,
      "text": "In pseudocode, the logic for validating the path field of a Commit is as follows:",
      "ja": "疑似コードでは、Commitのパスフィールドを検証するためのロジックは次のようになります："
    },
    {
      "indent": 3,
      "text": "pathRequiredTypes = [\n    update,\n    remove,\n    external_init,\n    group_context_extensions\n]\n\npathRequired = false\n\nfor proposal in commit.proposals:\n    pathRequired = pathRequired ||\n                   (proposal.msg_type in pathRequiredTypes)\n\nif len(commit.proposals) == 0 || pathRequired:\n    assert(commit.path != null)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "To summarize, a Commit can have three different configurations, with different uses:",
      "ja": "要約すると、コミットには異なる用途を持つ3つの異なる構成があります。"
    },
    {
      "indent": 8,
      "text": "1. An \"empty\" Commit that references no proposals, which updates the committer's contribution to the group and provides PCS with regard to the committer.",
      "ja": "1. 提案を参照しない「空の」コミットで、コミッターのグループへの貢献を更新し、コミッターに関するPCSを提供します。"
    },
    {
      "indent": 8,
      "text": "2. A \"partial\" Commit that references proposals that do not require a path, and where the path is empty. Such a Commit doesn't provide PCS with regard to the committer.",
      "ja": "2. 「パスが不要で、パスが空の提案を参照する「部分」のコミット。このようなコミットは、コミッターに関してPCSを提供しません。」"
    },
    {
      "indent": 8,
      "text": "3. A \"full\" Commit that references proposals of any type, which provides FS with regard to any removed members and PCS for the committer and any updated members.",
      "ja": "3. どのような種類の提案も参照する「完全な」コミットで、削除されたメンバーに関するFSを提供し、コミッターと更新されたメンバーに対するPCSを提供します。"
    },
    {
      "indent": 0,
      "text": "12.4.1. Creating a Commit",
      "section_title": true,
      "ja": "12.4.1. コミットを作成する"
    },
    {
      "indent": 3,
      "text": "When creating or processing a Commit, a client updates the ratchet tree and GroupContext for the group. These values advance from an \"old\" state reflecting the current epoch to a \"new\" state reflecting the new epoch initiated by the Commit. When the Commit includes an UpdatePath, a \"provisional\" group context is constructed that reflects changes due to the proposals and UpdatePath, but with the old confirmed transcript hash.",
      "ja": "コミットを作成または処理する際、クライアントはラチェットツリーとグループコンテキストを更新します。これらの値は、現在のエポックを反映した「古い」状態から、コミットによって開始された新しいエポックを反映した「新しい」状態に進みます。コミットにUpdatePathが含まれる場合、提案とUpdatePathによる変更を反映した「仮の」グループコンテキストが構築されますが、古い確認済みトランスクリプトハッシュが使用されます。"
    },
    {
      "indent": 3,
      "text": "A member of the group creates a Commit message and the corresponding Welcome message at the same time, by taking the following steps:",
      "ja": "グループのメンバーは、以下の手順に従って、コミットメッセージと対応するウェルカムメッセージを同時に作成します："
    },
    {
      "indent": 6,
      "text": "* Verify that the list of proposals to be committed is valid as specified in Section 12.2.",
      "ja": "* 提案のリストが、12.2節で指定された通りに有効であることを確認してください。"
    },
    {
      "indent": 6,
      "text": "* Construct an initial Commit object with the proposals field populated from Proposals received during the current epoch, and with the path field empty.",
      "ja": "* 現在のエポック中に受信した提案からプロポーザルフィールドが入力された初期のCommitオブジェクトを構築し、パスフィールドが空になるようにしてください。"
    },
    {
      "indent": 6,
      "text": "* Create the new ratchet tree and GroupContext by applying the list of proposals to the old ratchet tree and GroupContext, as defined in Section 12.3.",
      "ja": "* セクション12.3で定義されている提案のリストを古いラチェットツリーとGroupContextに適用して、新しいラチェットツリーとGroupContextを作成してください。"
    },
    {
      "indent": 6,
      "text": "* Decide whether to populate the path field: If the path field is required based on the proposals that are in the Commit (see above), then it MUST be populated. Otherwise, the sender MAY omit the path field at its discretion.",
      "ja": "* パスフィールドを入力するかどうかを決定してください：コミットに含まれる提案に基づいてパスフィールドが必要かどうかを判断します（上記を参照）。必要な場合は、必ず入力する必要があります。それ以外の場合、送信者は自己の裁量でパスフィールドを省略することができます。"
    },
    {
      "indent": 6,
      "text": "* If populating the path field:",
      "ja": "* パスフィールドに値を入力する場合："
    },
    {
      "indent": 12,
      "text": "- If this is an external Commit, assign the sender the leftmost blank leaf node in the new ratchet tree. If there are no blank leaf nodes in the new ratchet tree, expand the tree to the right as defined in Section 7.7 and assign the leftmost new blank leaf to the sender.",
      "ja": "- もし外部コミットである場合、送信者に新しいラチェットツリーの左端の空の葉ノードを割り当てます。新しいラチェットツリーに空の葉ノードがない場合は、セクション7.7で定義された通りにツリーを右に拡張し、送信者に左端の新しい空の葉を割り当てます。"
    },
    {
      "indent": 12,
      "text": "- Update the sender's direct path in the ratchet tree as described in Section 7.5. Define commit_secret as the value path_secret[n+1] derived from the last path secret value (path_secret[n]) derived for the UpdatePath.",
      "ja": "- セクション7.5で説明されているように、ラチェットツリー内の送信者の直接パスを更新します。最後のパスシークレット値（UpdatePathのために導出されたpath_secret[n]）から導出された値path_secret[n+1]をcommit_secretと定義します。"
    },
    {
      "indent": 12,
      "text": "- Construct a provisional GroupContext object containing the following values:",
      "ja": "- 以下の値を含む仮のGroupContextオブジェクトを構築してください。"
    },
    {
      "indent": 18,
      "text": "o group_id: Same as the old GroupContext",
      "ja": "o group_id: 古いGroupContextと同じ"
    },
    {
      "indent": 18,
      "text": "o epoch: The epoch number for the new epoch",
      "ja": "o エポック：新しいエポックのエポック番号"
    },
    {
      "indent": 18,
      "text": "o tree_hash: The tree hash of the new ratchet tree",
      "ja": "o tree_hash: 新しいラチェットツリーのツリーハッシュ"
    },
    {
      "indent": 18,
      "text": "o confirmed_transcript_hash: Same as the old GroupContext",
      "ja": "o confirmed_transcript_hash: 古いGroupContextと同じ"
    },
    {
      "indent": 18,
      "text": "o extensions: The new GroupContext extensions (possibly updated by a GroupContextExtensions proposal)",
      "ja": "o 拡張機能：新しいGroupContextの拡張機能（GroupContextExtensions提案によって更新される可能性があります）"
    },
    {
      "indent": 12,
      "text": "- Encrypt the path secrets resulting from the tree update to the group as described in Section 7.5, using the provisional group context as the context for HPKE encryption.",
      "ja": "- セクション7.5で説明されているように、木の更新によって生じるパスの秘密を、HPKE暗号化のための仮のグループコンテキストとして使用して、グループに暗号化してください。"
    },
    {
      "indent": 12,
      "text": "- Create an UpdatePath containing the sender's new leaf node and the new public keys and encrypted path secrets along the sender's filtered direct path. Assign this UpdatePath to the path field in the Commit.",
      "ja": "- 送信者の新しいリーフノードと新しい公開鍵、および送信者のフィルタリングされた直接パスに沿った暗号化されたパスシークレットを含むUpdatePathを作成してください。 このUpdatePathをCommitのpathフィールドに割り当ててください。"
    },
    {
      "indent": 6,
      "text": "* If not populating the path field: Set the path field in the Commit to the null optional. Define commit_secret as the all-zero vector of length KDF.Nh (the same length as a path_secret value would be).",
      "ja": "* パスフィールドを入力しない場合：Commit内のパスフィールドをnullオプションに設定します。 commit_secretをKDF.Nhの長さのすべてのゼロベクトルとして定義します（パスシークレットの値と同じ長さです）。"
    },
    {
      "indent": 6,
      "text": "* Derive the psk_secret as specified in Section 8.4, where the order of PSKs in the derivation corresponds to the order of PreSharedKey proposals in the proposals vector.",
      "ja": "* 8.4節で指定されているように、psk_secretを導出します。導出の際のPSKの順序は、提案ベクトル内のPreSharedKey提案の順序に対応しています。"
    },
    {
      "indent": 6,
      "text": "* Construct a FramedContent object containing the Commit object. Sign the FramedContent using the old GroupContext as context.",
      "ja": "* Commitオブジェクトを含むFramedContentオブジェクトを構築します。古いGroupContextをコンテキストとして使用して、FramedContentに署名します。"
    },
    {
      "indent": 12,
      "text": "- Use the FramedContent to update the confirmed transcript hash and update the new GroupContext.",
      "ja": "- FramedContentを使用して、確認されたトランスクリプトハッシュを更新し、新しいGroupContextを更新します。"
    },
    {
      "indent": 12,
      "text": "- Use the init_secret from the previous epoch, the commit_secret and psk_secret defined in the previous steps, and the new GroupContext to compute the new joiner_secret, welcome_secret, epoch_secret, and derived secrets for the new epoch.",
      "ja": "- 前のエポックからinit_secretを使用し、前のステップで定義されたcommit_secretとpsk_secret、および新しいGroupContextを使用して、新しいjoiner_secret、welcome_secret、epoch_secret、および新しいエポックの派生シークレットを計算します。"
    },
    {
      "indent": 12,
      "text": "- Use the confirmation_key for the new epoch to compute the confirmation_tag value.",
      "ja": "- 新しいエポックの確認キーを使用して、確認タグの値を計算してください。"
    },
    {
      "indent": 12,
      "text": "- Calculate the interim transcript hash using the new confirmed transcript hash and the confirmation_tag from the FramedContentAuthData.",
      "ja": "- FramedContentAuthDataからの新しい確認されたトランスクリプトハッシュと確認タグを使用して、中間トランスクリプトハッシュを計算してください。"
    },
    {
      "indent": 6,
      "text": "* Protect the AuthenticatedContent object using keys from the old epoch:",
      "ja": "* 認証済みコンテンツオブジェクトを、古いエポックからのキーを使用して保護してください。"
    },
    {
      "indent": 12,
      "text": "- If encoding as PublicMessage, compute the membership_tag value using the membership_key.",
      "ja": "- PublicMessageとしてエンコードする場合、membership_keyを使用してmembership_tagの値を計算してください。"
    },
    {
      "indent": 12,
      "text": "- If encoding as a PrivateMessage, encrypt the message using the sender_data_secret and the next (key, nonce) pair from the sender's handshake ratchet.",
      "ja": "- もしPrivateMessageとしてエンコードする場合は、送信者のハンドシェイクラチェットから次の（鍵、ナンス）ペアを使用して、メッセージをsender_data_secretを使って暗号化してください。"
    },
    {
      "indent": 6,
      "text": "* Construct a GroupInfo reflecting the new state:",
      "ja": "* 新しい状態を反映したGroupInfoを構築してください。"
    },
    {
      "indent": 12,
      "text": "- Set the group_id, epoch, tree, confirmed_transcript_hash, interim_transcript_hash, and group_context_extensions fields to reflect the new state.",
      "ja": "- 新しい状態を反映するために、group_id、epoch、tree、confirmed_transcript_hash、interim_transcript_hash、およびgroup_context_extensionsフィールドを設定してください。"
    },
    {
      "indent": 12,
      "text": "- Set the confirmation_tag field to the value of the corresponding field in the FramedContentAuthData object.",
      "ja": "- FramedContentAuthDataオブジェクト内の対応するフィールドの値をconfirmation_tagフィールドに設定してください。"
    },
    {
      "indent": 12,
      "text": "- Add any other extensions as defined by the application.",
      "ja": "- アプリケーションで定義された他の拡張機能を追加してください。"
    },
    {
      "indent": 12,
      "text": "- Optionally derive an external key pair as described in Section 8. (required for external Commits, see Section 12.4.3.2).",
      "ja": "- セクション8に記載されているように、外部キーペアを任意で派生させることができます（外部コミットに必要、セクション12.4.3.2を参照）。"
    },
    {
      "indent": 12,
      "text": "- Sign the GroupInfo using the member's private signing key.",
      "ja": "- メンバーの秘密署名キーを使用して、GroupInfoに署名してください。"
    },
    {
      "indent": 12,
      "text": "- Encrypt the GroupInfo using the key and nonce derived from the joiner_secret. for the new epoch (see Section 12.4.3.1).",
      "ja": "- joiner_secret から派生した鍵とナンスを使用して、GroupInfo を暗号化します。新しいエポック用（12.4.3.1 節を参照）。"
    },
    {
      "indent": 6,
      "text": "* For each new member in the group:",
      "ja": "* グループの新しいメンバーごとに："
    },
    {
      "indent": 12,
      "text": "- Identify the lowest common ancestor in the tree of the new member's leaf node and the member sending the Commit.",
      "ja": "- 新メンバーの葉ノードとCommitを送信しているメンバーのツリーにおける最も低い共通の祖先を特定してください。"
    },
    {
      "indent": 12,
      "text": "- If the path field was populated above: Compute the path secret corresponding to the common ancestor node.",
      "ja": "- もしパスフィールドが上記で埋められていた場合：共通の祖先ノードに対応するパスシークレットを計算してください。"
    },
    {
      "indent": 12,
      "text": "- Compute an EncryptedGroupSecrets object that encapsulates the init_secret for the current epoch and the path secret (if present).",
      "ja": "- 現在のエポックのinit_secretと（存在する場合は）path secretをカプセル化するEncryptedGroupSecretsオブジェクトを計算してください。"
    },
    {
      "indent": 6,
      "text": "* Construct one or more Welcome messages from the encrypted GroupInfo object, the encrypted key packages, and any PSKs for which a proposal was included in the Commit. The order of the psks MUST be the same as the order of PreSharedKey proposals in the proposals vector. As discussed in Section 12.4.3.1, the committer is free to choose how many Welcome messages to construct. However, the set of Welcome messages produced in this step MUST cover every new member added in the Commit.",
      "ja": "* Commitに含まれる暗号化されたGroupInfoオブジェクト、暗号化された鍵パッケージ、およびCommitに含まれる提案に対応するPSK（PreSharedKey）から1つ以上のウェルカムメッセージを作成してください。psksの順序は、提案ベクトル内のPreSharedKey提案の順序と同じでなければなりません。12.4.3.1節で議論されているように、コミッターは作成するウェルカムメッセージの数を自由に選択できます。ただし、このステップで生成されるウェルカムメッセージのセットは、Commitに追加されたすべての新メンバーをカバーしなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If a ReInit proposal was part of the Commit, the committer MUST create a new group with the parameters specified in the ReInit proposal, and with the same members as the original group. The Welcome message MUST include a PreSharedKeyID with the following parameters:",
      "ja": "* もしReInit提案がCommitの一部であった場合、コミッターはReInit提案で指定されたパラメータを持つ新しいグループを作成しなければならず、元のグループと同じメンバーを持たなければなりません。ウェルカムメッセージには、以下のパラメータを持つPreSharedKeyIDを含めなければなりません。"
    },
    {
      "indent": 12,
      "text": "- psktype: resumption",
      "ja": "- psktype: 再開"
    },
    {
      "indent": 12,
      "text": "- usage: reinit",
      "ja": "- 使用法：再初期化"
    },
    {
      "indent": 12,
      "text": "- group_id: The group ID for the current group",
      "ja": "- group_id: 現在のグループのグループID"
    },
    {
      "indent": 12,
      "text": "- epoch: The epoch that the group will be in after this Commit",
      "ja": "- エポック：このコミット後にグループがいるエポック"
    },
    {
      "indent": 0,
      "text": "12.4.2. Processing a Commit",
      "section_title": true,
      "ja": "12.4.2. コミットの処理"
    },
    {
      "indent": 3,
      "text": "A member of the group applies a Commit message by taking the following steps:",
      "ja": "グループのメンバーは、次の手順を取ることでコミットメッセージを適用します："
    },
    {
      "indent": 6,
      "text": "* Verify that the epoch field of the enclosing FramedContent is equal to the epoch field of the current GroupContext object.",
      "ja": "* 囲むFramedContentのエポックフィールドが現在のGroupContextオブジェクトのエポックフィールドと等しいことを確認してください。"
    },
    {
      "indent": 6,
      "text": "* Unprotect the Commit using the keys from the current epoch:",
      "ja": "* 現在のエポックから鍵を使用してコミットの保護を解除します。"
    },
    {
      "indent": 12,
      "text": "- If the message is encoded as PublicMessage, verify the membership MAC using the membership_key.",
      "ja": "- メッセージがPublicMessageとしてエンコードされている場合は、membership_keyを使用してメンバーシップMACを検証してください。"
    },
    {
      "indent": 12,
      "text": "- If the message is encoded as PrivateMessage, decrypt the message using the sender_data_secret and the (key, nonce) pair from the step on the sender's hash ratchet indicated by the generation field.",
      "ja": "- もしメッセージがPrivateMessageとしてエンコードされている場合は、sender_data_secretとsenderのハッシュラチェットのステップで指定されたgenerationフィールドによる(key, nonce)ペアを使用してメッセージを復号化してください。"
    },
    {
      "indent": 6,
      "text": "* Verify the signature on the FramedContent message as described in Section 6.1.",
      "ja": "* セクション6.1で説明されているFramedContentメッセージの署名を検証してください。"
    },
    {
      "indent": 6,
      "text": "* Verify that the proposals vector is valid according to the rules in Section 12.2.",
      "ja": "* 12.2節のルールに従って、提案ベクトルが有効であることを確認してください。"
    },
    {
      "indent": 6,
      "text": "* Verify that all PreSharedKey proposals in the proposals vector are available.",
      "ja": "* 提案ベクトル内のすべてのPreSharedKey提案が利用可能であることを確認してください。"
    },
    {
      "indent": 6,
      "text": "* Create the new ratchet tree and GroupContext by applying the list of proposals to the old ratchet tree and GroupContext, as defined in Section 12.3.",
      "ja": "* セクション12.3で定義されている提案のリストを古いラチェットツリーとGroupContextに適用して、新しいラチェットツリーとGroupContextを作成してください。"
    },
    {
      "indent": 6,
      "text": "* Verify that the path value is populated if the proposals vector contains any Update or Remove proposals, or if it's empty. Otherwise, the path value MAY be omitted.",
      "ja": "* 提案ベクトルに更新または削除の提案が含まれている場合、または空の場合、パス値が入力されていることを確認してください。それ以外の場合、パス値は省略しても構いません。"
    },
    {
      "indent": 6,
      "text": "* If the path value is populated, validate it and apply it to the tree:",
      "ja": "* パスの値が入力されている場合は、それを検証してツリーに適用してください。"
    },
    {
      "indent": 12,
      "text": "- If this is an external Commit, assign the sender the leftmost blank leaf node in the new ratchet tree. If there are no blank leaf nodes in the new ratchet tree, add a blank leaf to the right side of the new ratchet tree and assign it to the sender.",
      "ja": "- もし外部コミットである場合、送信者に新しいラチェットツリーの左端の空の葉ノードを割り当てます。新しいラチェットツリーに空の葉ノードがない場合は、新しいラチェットツリーの右側に空の葉を追加し、送信者に割り当てます。"
    },
    {
      "indent": 12,
      "text": "- Validate the LeafNode as specified in Section 7.3. The leaf_node_source field MUST be set to commit.",
      "ja": "- セクション7.3で指定された通りにLeafNodeを検証してください。leaf_node_sourceフィールドはcommitに設定する必要があります。"
    },
    {
      "indent": 12,
      "text": "- Verify that the encryption_key value in the LeafNode is different from the committer's current leaf node.",
      "ja": "- LeafNode内のencryption_key値がコミッターの現在のリーフノードと異なることを確認してください。"
    },
    {
      "indent": 12,
      "text": "- Verify that none of the public keys in the UpdatePath appear in any node of the new ratchet tree.",
      "ja": "- UpdatePath内の公開鍵が新しいラチェットツリーのノードのいずれにも含まれていないことを確認してください。"
    },
    {
      "indent": 12,
      "text": "- Merge the UpdatePath into the new ratchet tree, as described in Section 7.5.",
      "ja": "- セクション7.5で説明されているように、UpdatePathを新しいラチェットツリーにマージしてください。"
    },
    {
      "indent": 12,
      "text": "- Construct a provisional GroupContext object containing the following values:",
      "ja": "- 以下の値を含む仮のGroupContextオブジェクトを構築してください。"
    },
    {
      "indent": 18,
      "text": "o group_id: Same as the old GroupContext",
      "ja": "o group_id: 古いGroupContextと同じ"
    },
    {
      "indent": 18,
      "text": "o epoch: The epoch number for the new epoch",
      "ja": "o エポック：新しいエポックのエポック番号"
    },
    {
      "indent": 18,
      "text": "o tree_hash: The tree hash of the new ratchet tree",
      "ja": "o tree_hash: 新しいラチェットツリーのツリーハッシュ"
    },
    {
      "indent": 18,
      "text": "o confirmed_transcript_hash: Same as the old GroupContext",
      "ja": "o confirmed_transcript_hash: 古いGroupContextと同じ"
    },
    {
      "indent": 18,
      "text": "o extensions: The new GroupContext extensions (possibly updated by a GroupContextExtensions proposal)",
      "ja": "o 拡張機能：新しいGroupContextの拡張機能（GroupContextExtensions提案によって更新される可能性があります）"
    },
    {
      "indent": 12,
      "text": "- Decrypt the path secrets for UpdatePath as described in Section 7.5, using the provisional GroupContext as the context for HPKE decryption.",
      "ja": "- セクション7.5で説明されているように、仮のGroupContextをHPKEの復号化のコンテキストとして使用して、UpdatePathのパスの秘密を復号化してください。"
    },
    {
      "indent": 12,
      "text": "- Define commit_secret as the value path_secret[n+1] derived from the last path secret value (path_secret[n]) derived for the UpdatePath.",
      "ja": "- commit_secretを、UpdatePathのために導出された最後のパスシークレット値（path_secret[n]）から導出された値path_secret[n+1]と定義します。"
    },
    {
      "indent": 6,
      "text": "* If the path value is not populated, define commit_secret as the all-zero vector of length KDF.Nh (the same length as a path_secret value would be).",
      "ja": "* パスの値が設定されていない場合、commit_secretをKDF.Nhの長さの全ゼロベクトルとして定義します（パスの値と同じ長さ）。"
    },
    {
      "indent": 6,
      "text": "* Update the confirmed and interim transcript hashes using the new Commit, and generate the new GroupContext.",
      "ja": "* 新しいコミットを使用して確認済みおよび仮のトランスクリプトハッシュを更新し、新しいグループコンテキストを生成してください。"
    },
    {
      "indent": 6,
      "text": "* Derive the psk_secret as specified in Section 8.4, where the order of PSKs in the derivation corresponds to the order of PreSharedKey proposals in the proposals vector.",
      "ja": "* 8.4節で指定されているように、psk_secretを導出します。導出におけるPSKの順序は、提案ベクトル内のPreSharedKey提案の順序に対応しています。"
    },
    {
      "indent": 6,
      "text": "* Use the init_secret from the previous epoch, the commit_secret and psk_secret defined in the previous steps, and the new GroupContext to compute the new joiner_secret, welcome_secret, epoch_secret, and derived secrets for the new epoch.",
      "ja": "* 前のエポックからのinit_secret、前のステップで定義されたcommit_secretとpsk_secret、および新しいGroupContextを使用して、新しいjoiner_secret、welcome_secret、epoch_secret、および新しいエポックの派生シークレットを計算してください。"
    },
    {
      "indent": 6,
      "text": "* Use the confirmation_key for the new epoch to compute the confirmation tag for this message, as described below, and verify that it is the same as the confirmation_tag field in the FramedContentAuthData object.",
      "ja": "* 新しいエポックの確認キーを使用して、以下に記載されているようにこのメッセージの確認タグを計算し、FramedContentAuthDataオブジェクトの確認タグフィールドと同じであることを確認してください。"
    },
    {
      "indent": 6,
      "text": "* If the above checks are successful, consider the new GroupContext object as the current state of the group.",
      "ja": "* もし上記のチェックが成功した場合は、新しいGroupContextオブジェクトをグループの現在の状態として考えてください。"
    },
    {
      "indent": 6,
      "text": "* If the Commit included a ReInit proposal, the client MUST NOT use the group to send messages anymore. Instead, it MUST wait for a Welcome message from the committer meeting the requirements of Section 11.2.",
      "ja": "* もしCommitにReInit提案が含まれている場合、クライアントはもはやグループを使ってメッセージを送信してはいけません。代わりに、Section 11.2の要件を満たすコミッターからのWelcomeメッセージを待たなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that clients need to be prepared to receive a valid Commit message that removes them from the group. In this case, the client cannot send any more messages in the group and SHOULD promptly delete its group state and secret tree. (A client might keep the secret tree for a short time to decrypt late messages in the previous epoch.)",
      "ja": "クライアントは、グループから削除される有効なコミットメッセージを受け取る準備をしておく必要があることに注意してください。この場合、クライアントはグループ内でのメッセージの送信を続けることはできず、迅速にグループの状態と秘密ツリーを削除する必要があります。（クライアントは、以前のエポックでの遅れて届いたメッセージを復号化するために、一時的に秘密ツリーを保持することがあります。）"
    },
    {
      "indent": 0,
      "text": "12.4.3. Adding Members to the Group",
      "section_title": true,
      "ja": "12.4.3. グループにメンバーを追加する"
    },
    {
      "indent": 3,
      "text": "New members can join the group in two ways: by being added by a group member or by adding themselves through an external Commit. In both cases, the new members need information to bootstrap their local group state.",
      "ja": "新しいメンバーは2つの方法でグループに参加できます：グループメンバーによって追加されるか、外部のコミットを通じて自分自身を追加することによってです。どちらの場合も、新しいメンバーはローカルグループの状態を初期化するための情報が必要です。"
    },
    {
      "indent": 3,
      "text": "struct {\n    GroupContext group_context;\n    Extension extensions<V>;\n    MAC confirmation_tag;\n    uint32 signer;\n    /* SignWithLabel(., \"GroupInfoTBS\", GroupInfoTBS) */\n    opaque signature<V>;\n} GroupInfo;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The group_context field represents the current state of the group. The extensions field allows the sender to provide additional data that might be useful to new joiners. The confirmation_tag represents the confirmation tag from the Commit that initiated the current epoch, or for epoch 0, the confirmation tag computed in the creation of the group (see Section 11). (In either case, the creator of a GroupInfo may recompute the confirmation tag as MAC(confirmation_key, confirmed_transcript_hash).)",
      "ja": "group_contextフィールドは、グループの現在の状態を表します。extensionsフィールドは、送信者が新規参加者に有用な追加データを提供することを可能にします。confirmation_tagは、現在のエポックを開始したCommitからの確認タグを表し、またはエポック0の場合は、グループの作成時に計算された確認タグを表します（詳細は11節を参照）。 （いずれの場合も、GroupInfoの作成者は確認タグをMAC（確認キー、確認済みトランスクリプトハッシュ）として再計算できます。）"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 13, unknown extensions in GroupInfo.extensions MUST be ignored, and the creator of a GroupInfo object SHOULD include some random GREASE extensions to help ensure that other clients correctly ignore unknown extensions. Extensions in GroupInfo.group_context.extensions, however, MUST be supported by the new joiner.",
      "ja": "セクション13で議論されたように、GroupInfo.extensions内の未知の拡張機能は無視されなければならず、GroupInfoオブジェクトの作成者は他のクライアントが未知の拡張機能を正しく無視するようにするためにいくつかのランダムなGREASE拡張機能を含めるべきです。ただし、GroupInfo.group_context.extensions内の拡張機能は、新規参加者によってサポートされなければなりません。"
    },
    {
      "indent": 3,
      "text": "New members MUST verify that group_id is unique among the groups they are currently participating in.",
      "ja": "新しいメンバーは、現在参加しているグループの中でgroup_idが一意であることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "New members also MUST verify the signature using the public key taken from the leaf node of the ratchet tree with leaf index signer. The signature covers the following structure, comprising all the fields in the GroupInfo above signature:",
      "ja": "新しいメンバーは、署名者の葉ノードから取得した公開鍵を使用して署名を検証しなければなりません。署名は、署名の上にあるGroupInfoのすべてのフィールドを含む構造をカバーしています。"
    },
    {
      "indent": 3,
      "text": "struct {\n    GroupContext group_context;\n    Extension extensions<V>;\n    MAC confirmation_tag;\n    uint32 signer;\n} GroupInfoTBS;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "12.4.3.1. Joining via Welcome Message",
      "section_title": true,
      "ja": "12.4.3.1. ウェルカムメッセージを介して参加します。"
    },
    {
      "indent": 3,
      "text": "The sender of a Commit message is responsible for sending a Welcome message to each new member added via Add proposals. The format of the Welcome message allows a single Welcome message to be encrypted for multiple new members. It is up to the committer to decide how many Welcome messages to create for a given Commit. The committer could create one Welcome that is encrypted for all new members, a different Welcome for each new member, or Welcome messages for batches of new members (according to some batching scheme that works well for the application). The processes for creating and processing the Welcome are the same in all cases, aside from the set of new members for whom a given Welcome is encrypted.",
      "ja": "Commitメッセージの送信者は、Add提案を介して追加された各新メンバーに対してウェルカムメッセージを送信する責任があります。ウェルカムメッセージの形式は、複数の新メンバーに対して暗号化された単一のウェルカムメッセージを可能にします。特定のCommitに対して何個のウェルカムメッセージを作成するかは、コミッター次第です。コミッターは、すべての新メンバーに対して暗号化された1つのウェルカムメッセージ、それぞれの新メンバーに異なるウェルカムメッセージ、または新メンバーのバッチごとにウェルカムメッセージを作成することができます（アプリケーションに適したバッチングスキームに従って）。特定のウェルカムメッセージが暗号化される新メンバーのセットを除いて、ウェルカムの作成および処理のプロセスはすべての場合において同じです。"
    },
    {
      "indent": 3,
      "text": "The Welcome message provides the new members with the current state of the group after the application of the Commit message. The new members will not be able to decrypt or verify the Commit message, but they will have the secrets they need to participate in the epoch initiated by the Commit message.",
      "ja": "ウェルカムメッセージは、コミットメッセージの適用後のグループの現在の状態を新メンバーに提供します。新メンバーはコミットメッセージを復号化または検証することはできませんが、コミットメッセージによって開始されたエポックに参加するために必要な秘密情報を持っています。"
    },
    {
      "indent": 3,
      "text": "In order to allow the same Welcome message to be sent to multiple new members, information describing the group is encrypted with a symmetric key and nonce derived from the joiner_secret for the new epoch. The joiner_secret is then encrypted to each new member using HPKE. In the same encrypted package, the committer transmits the path secret for the lowest (closest to the leaf) node that is contained in the direct paths of both the committer and the new member. This allows the new member to compute private keys for nodes in its direct path that are being reset by the corresponding Commit.",
      "ja": "新しいメンバーに同じウェルカムメッセージを送信するために、グループを説明する情報は、新しいエポックのjoiner_secretから派生した対称鍵とナンスで暗号化されます。その後、joiner_secretはHPKEを使用して各新メンバーに暗号化されます。同じ暗号化されたパッケージ内で、コミッターは、コミッターと新メンバーの直接パスに含まれる最も低い（リーフに最も近い）ノードのパスシークレットを送信します。これにより、新メンバーは、対応するCommitによってリセットされる直接パス内のノードのためのプライベートキーを計算できます。"
    },
    {
      "indent": 3,
      "text": "If the sender of the Welcome message wants the receiving member to include a PSK in the derivation of the epoch_secret, they can populate the psks field indicating which PSK to use.",
      "ja": "ウェルカムメッセージの送信者が受信メンバーにエポックシークレットの派生にPSKを含めるように希望する場合、使用するPSKを示すpsksフィールドを入力することができます。"
    },
    {
      "indent": 3,
      "text": "struct {\n  opaque path_secret<V>;\n} PathSecret;\n\nstruct {\n  opaque joiner_secret<V>;\n  optional<PathSecret> path_secret;\n  PreSharedKeyID psks<V>;\n} GroupSecrets;\n\nstruct {\n  KeyPackageRef new_member;\n  HPKECiphertext encrypted_group_secrets;\n} EncryptedGroupSecrets;\n\nstruct {\n  CipherSuite cipher_suite;\n  EncryptedGroupSecrets secrets<V>;\n  opaque encrypted_group_info<V>;\n} Welcome;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The client processing a Welcome message will need to have a copy of the group's ratchet tree. The tree can be provided in the Welcome message, in an extension of type ratchet_tree. If it is sent otherwise (e.g., provided by a caching service on the Delivery Service), then the client MUST download the tree before processing the Welcome.",
      "ja": "ウェルカムメッセージを処理するクライアントは、グループのラチェットツリーのコピーを持っている必要があります。ツリーはウェルカムメッセージ内で提供されることがあり、その拡張機能のタイプはratchet_treeです。それ以外の方法で送信された場合（例：配信サービスのキャッシュサービスによって提供された場合）、クライアントはウェルカムを処理する前にツリーをダウンロードする必要があります。"
    },
    {
      "indent": 3,
      "text": "On receiving a Welcome message, a client processes it using the following steps:",
      "ja": "「ウェルカムメッセージを受信すると、クライアントは次の手順で処理します：」"
    },
    {
      "indent": 6,
      "text": "* Identify an entry in the secrets array where the new_member value corresponds to one of this client's KeyPackages, using the hash indicated by the cipher_suite field. If no such field exists, or if the cipher suite indicated in the KeyPackage does not match the one in the Welcome message, return an error.",
      "ja": "* 新しいメンバーの値がこのクライアントのKeyPackagesの1つに対応するシークレット配列内のエントリを特定し、cipher_suiteフィールドで示されたハッシュを使用します。そのようなフィールドが存在しない場合、またはKeyPackageで示された暗号スイートがWelcomeメッセージ内のものと一致しない場合は、エラーを返します。"
    },
    {
      "indent": 6,
      "text": "* Decrypt the encrypted_group_secrets value with the algorithms indicated by the cipher suite and the private key init_key_priv corresponding to init_key in the referenced KeyPackage.",
      "ja": "* 参照されているKeyPackage内のinit_keyに対応するprivate key init_key_privと、暗号スイートで示されたアルゴリズムを使用して、encrypted_group_secretsの値を復号化してください。"
    },
    {
      "indent": 3,
      "text": "encrypted_group_secrets =\n  EncryptWithLabel(init_key, \"Welcome\",\n                   encrypted_group_info, group_secrets)\n\ngroup_secrets =\n  DecryptWithLabel(init_key_priv, \"Welcome\",\n                   encrypted_group_info, kem_output, ciphertext)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "* If a PreSharedKeyID is part of the GroupSecrets and the client is not in possession of the corresponding PSK, return an error. Additionally, if a PreSharedKeyID has type resumption with usage reinit or branch, verify that it is the only such PSK.",
      "ja": "* もしPreSharedKeyIDがGroupSecretsの一部であり、クライアントが対応するPSKを持っていない場合は、エラーを返します。さらに、PreSharedKeyIDが再開またはブランチの使用法を持つタイプのリサンプルである場合は、それが唯一のそのようなPSKであることを確認してください。"
    },
    {
      "indent": 6,
      "text": "* From the joiner_secret in the decrypted GroupSecrets object and the PSKs specified in the GroupSecrets, derive the welcome_secret and then the welcome_key and welcome_nonce. Use the key and nonce to decrypt the encrypted_group_info field.",
      "ja": "* 復号化されたGroupSecretsオブジェクト内のjoiner_secretとGroupSecretsで指定されたPSKから、welcome_secretを導出し、その後welcome_keyとwelcome_nonceを導出します。鍵とnonceを使用して、encrypted_group_infoフィールドを復号化してください。"
    },
    {
      "indent": 3,
      "text": "welcome_nonce = ExpandWithLabel(welcome_secret, \"nonce\", \"\", AEAD.Nn)\nwelcome_key = ExpandWithLabel(welcome_secret, \"key\", \"\", AEAD.Nk)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "* Verify the signature on the GroupInfo object. The signature input comprises all of the fields in the GroupInfo object except the signature field. The public key is taken from the LeafNode of the ratchet tree with leaf index signer. If the node is blank or if signature verification fails, return an error.",
      "ja": "* GroupInfoオブジェクトの署名を検証してください。署名入力は、署名フィールドを除くGroupInfoオブジェクトのすべてのフィールドから構成されます。公開鍵は、ratchetツリーのLeafNodeから取得され、葉のインデックスが署名者であるものです。ノードが空白であるか、署名の検証に失敗した場合は、エラーを返します。"
    },
    {
      "indent": 6,
      "text": "* Verify that the group_id is unique among the groups that the client is currently participating in.",
      "ja": "* クライアントが現在参加しているグループの中で、group_id が一意であることを確認してください。"
    },
    {
      "indent": 6,
      "text": "* Verify that the cipher_suite in the GroupInfo matches the cipher_suite in the KeyPackage.",
      "ja": "* GroupInfo内のcipher_suiteがKeyPackage内のcipher_suiteと一致していることを確認してください。"
    },
    {
      "indent": 6,
      "text": "* Verify the integrity of the ratchet tree.",
      "ja": "* ラチェットツリーの整合性を確認してください。"
    },
    {
      "indent": 12,
      "text": "- Verify that the tree hash of the ratchet tree matches the tree_hash field in GroupInfo.",
      "ja": "- ラチェットツリーのツリーハッシュが、GroupInfo内のtree_hashフィールドと一致することを確認してください。"
    },
    {
      "indent": 12,
      "text": "- For each non-empty parent node, verify that it is \"parent-hash valid\", as described in Section 7.9.2.",
      "ja": "- 各空でない親ノードについて、セクション7.9.2で説明されているように、「親ハッシュが有効である」ことを検証してください。"
    },
    {
      "indent": 12,
      "text": "- For each non-empty leaf node, validate the LeafNode as described in Section 7.3.",
      "ja": "- 各空でない葉ノードについて、セクション7.3で説明されているようにLeafNodeを検証してください。"
    },
    {
      "indent": 12,
      "text": "- For each non-empty parent node and each entry in the node's unmerged_leaves field:",
      "ja": "- 各空でない親ノードと、ノードのunmerged_leavesフィールド内の各エントリについて:"
    },
    {
      "indent": 18,
      "text": "o Verify that the entry represents a non-blank leaf node that is a descendant of the parent node.",
      "ja": "o 入力が親ノードの子孫であり、空白でない葉ノードを表していることを確認してください。"
    },
    {
      "indent": 18,
      "text": "o Verify that every non-blank intermediate node between the leaf node and the parent node also has an entry for the leaf node in its unmerged_leaves.",
      "ja": "o 葉ノードと親ノードの間のすべての空でない中間ノードが、そのunmerged_leavesにも葉ノードのエントリを持っていることを確認してください。"
    },
    {
      "indent": 18,
      "text": "o Verify that the encryption key in the parent node does not appear in any other node of the tree.",
      "ja": "o 親ノードの暗号化キーが、木の他のノードには現れていないことを確認してください。"
    },
    {
      "indent": 6,
      "text": "* Identify a leaf whose LeafNode is identical to the one in the KeyPackage. If no such field exists, return an error. Let my_leaf represent this leaf in the tree.",
      "ja": "* KeyPackage内のLeafNodeと同一のLeafを特定します。そのようなフィールドが存在しない場合はエラーを返します。my_leafは、この木構造内のその葉を表します。"
    },
    {
      "indent": 6,
      "text": "* Construct a new group state using the information in the GroupInfo object.",
      "ja": "* GroupInfoオブジェクトの情報を使用して、新しいグループ状態を構築してください。"
    },
    {
      "indent": 12,
      "text": "- Initialize the GroupContext for the group from the group_context field from the GroupInfo object.",
      "ja": "- GroupInfoオブジェクトのgroup_contextフィールドからグループのGroupContextを初期化します。"
    },
    {
      "indent": 12,
      "text": "- Update the leaf my_leaf with the private key corresponding to the public key in the node, where my_leaf is the new member's leaf node in the ratchet tree, as defined above.",
      "ja": "- 上記で定義されたラチェットツリー内の新しいメンバーのリーフノードである my_leaf を、ノード内の公開鍵に対応するプライベートキーで更新してください。"
    },
    {
      "indent": 12,
      "text": "- If the path_secret value is set in the GroupSecrets object: Identify the lowest common ancestor of the leaf node my_leaf and of the node of the member with leaf index GroupInfo.signer. Set the private key for this node to the private key derived from the path_secret.",
      "ja": "- GroupSecretsオブジェクトにpath_secret値が設定されている場合：my_leafとGroupInfo.signerのleafインデックスを持つメンバーのノードの最も低い共通の祖先を特定します。このノードのプライベートキーを、path_secretから派生したプライベートキーに設定します。"
    },
    {
      "indent": 12,
      "text": "- For each parent of the common ancestor, up to the root of the tree, derive a new path secret, and set the private key for the node to the private key derived from the path secret. The private key MUST be the private key that corresponds to the public key in the node.",
      "ja": "- 共通の祖先の各親について、木の根まで新しいパスの秘密を導出し、ノードのプライベートキーをそのパスの秘密から導出したプライベートキーに設定してください。プライベートキーは、ノード内の公開鍵に対応するプライベートキーでなければなりません。"
    },
    {
      "indent": 6,
      "text": "* Use the joiner_secret from the GroupSecrets object to generate the epoch secret and other derived secrets for the current epoch.",
      "ja": "* GroupSecretsオブジェクトからjoiner_secretを使用して、現在のエポックのエポックシークレットおよび他の派生シークレットを生成します。"
    },
    {
      "indent": 6,
      "text": "* Set the confirmed transcript hash in the new state to the value of the confirmed_transcript_hash in the GroupInfo.",
      "ja": "* 新しい状態の確認済みトランスクリプトハッシュを、GroupInfo内のconfirmed_transcript_hashの値に設定してください。"
    },
    {
      "indent": 6,
      "text": "* Verify the confirmation tag in the GroupInfo using the derived confirmation key and the confirmed_transcript_hash from the GroupInfo.",
      "ja": "* GroupInfo内の確認タグを、派生した確認キーとGroupInfoからのconfirmed_transcript_hashを使用して検証してください。"
    },
    {
      "indent": 6,
      "text": "* Use the confirmed transcript hash and confirmation tag to compute the interim transcript hash in the new state.",
      "ja": "* 確認されたトランスクリプトハッシュと確認タグを使用して、新しい状態で中間トランスクリプトハッシュを計算してください。"
    },
    {
      "indent": 6,
      "text": "* If a PreSharedKeyID was used that has type resumption with usage reinit or branch, verify that the epoch field in the GroupInfo is equal to 1.",
      "ja": "* もし、再開のタイプで使用された PreSharedKeyID が再初期化またはブランチの使用を持っている場合は、GroupInfo の epoch フィールドが 1 と等しいことを確認してください。"
    },
    {
      "indent": 12,
      "text": "- For usage reinit, verify that the last Commit to the referenced group contains a ReInit proposal and that the group_id, version, cipher_suite, and group_context.extensions fields of the GroupInfo match the ReInit proposal. Additionally, verify that all the members of the old group are also members of the new group, according to the application.",
      "ja": "- 再初期化の使用について、参照されたグループへの最後のコミットに再初期化提案が含まれていること、およびGroupInfoのgroup_id、version、cipher_suite、およびgroup_context.extensionsフィールドが再初期化提案と一致していることを確認してください。さらに、アプリケーションによると、古いグループのすべてのメンバーが新しいグループのメンバーでもあることを確認してください。"
    },
    {
      "indent": 12,
      "text": "- For usage branch, verify that the version and cipher_suite of the new group match those of the old group, and that the members of the new group compose a subset of the members of the old group, according to the application.",
      "ja": "- 使用ブランチについて、新しいグループのバージョンとcipher_suiteが古いグループと一致していること、および新しいグループのメンバーがアプリケーションに従って古いグループのメンバーの部分集合を構成していることを確認してください。"
    },
    {
      "indent": 0,
      "text": "12.4.3.2. Joining via External Commits",
      "section_title": true,
      "ja": "12.4.3.2. 外部コミットを介して参加"
    },
    {
      "indent": 3,
      "text": "External Commits are a mechanism for new members (external parties that want to become members of the group) to add themselves to a group, without requiring that an existing member has to come online to issue a Commit that references an Add proposal.",
      "ja": "External Commitsは、新しいメンバー（グループのメンバーになりたい外部の関係者）が、既存のメンバーがオンラインになる必要がなく、Add提案を参照するCommitを発行する必要がないまま、グループに自分自身を追加するための仕組みです。"
    },
    {
      "indent": 3,
      "text": "Whether existing members of the group will accept or reject an external Commit follows the same rules that are applied to other handshake messages.",
      "ja": "グループの既存メンバーが外部のコミットを受け入れるか拒否するかは、他のハンドシェイクメッセージに適用される同じルールに従います。"
    },
    {
      "indent": 3,
      "text": "New members can create and issue an external Commit if they have access to the following information for the group's current epoch:",
      "ja": "新しいメンバーは、グループの現在のエポックに関する以下の情報にアクセスできる場合、外部のコミットを作成および発行することができます。"
    },
    {
      "indent": 6,
      "text": "* group ID",
      "ja": "* グループID"
    },
    {
      "indent": 6,
      "text": "* epoch ID",
      "ja": "* エポックID"
    },
    {
      "indent": 6,
      "text": "* cipher suite",
      "ja": "* 暗号スイート"
    },
    {
      "indent": 6,
      "text": "* public tree hash",
      "ja": "* 公開ツリーハッシュ"
    },
    {
      "indent": 6,
      "text": "* confirmed transcript hash",
      "ja": "* 確認されたトランスクリプトハッシュ"
    },
    {
      "indent": 6,
      "text": "* confirmation tag of the most recent Commit",
      "ja": "* 最新のコミットの確認タグ"
    },
    {
      "indent": 6,
      "text": "* group extensions",
      "ja": "* グループ拡張"
    },
    {
      "indent": 6,
      "text": "* external public key",
      "ja": "* 外部公開鍵"
    },
    {
      "indent": 3,
      "text": "In other words, to join a group via an external Commit, a new member needs a GroupInfo with an external_pub extension present in its extensions field.",
      "ja": "言い換えると、外部のコミットを介してグループに参加するためには、新しいメンバーが拡張フィールドにexternal_pub拡張機能を持つGroupInfoが必要です。"
    },
    {
      "indent": 3,
      "text": "struct {\n    HPKEPublicKey external_pub;\n} ExternalPub;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Thus, a member of the group can enable new clients to join by making a GroupInfo object available to them. Note that because a GroupInfo object is specific to an epoch, it will need to be updated as the group advances. In particular, each GroupInfo object can be used for one external join, since that external join will cause the epoch to change.",
      "ja": "したがって、グループのメンバーは、GroupInfoオブジェクトを新しいクライアントに提供することで、新しいクライアントが参加できるようにすることができます。 GroupInfoオブジェクトはエポックに固有であるため、グループが進むにつれて更新する必要があります。特に、各GroupInfoオブジェクトは1つの外部参加に使用できます。なぜなら、その外部参加によってエポックが変わるからです。"
    },
    {
      "indent": 3,
      "text": "Note that the tree_hash field is used the same way as in the Welcome message. The full tree can be included via the ratchet_tree extension (see Section 12.4.3.3).",
      "ja": "tree_hashフィールドは、ウェルカムメッセージと同じ方法で使用されます。完全なツリーは、ラチェットツリー拡張機能を介して含めることができます（セクション12.4.3.3を参照）。"
    },
    {
      "indent": 3,
      "text": "The information in a GroupInfo is not generally public information, but applications can choose to make it available to new members in order to allow External Commits.",
      "ja": "GroupInfo内の情報は一般的に公開情報ではありませんが、アプリケーションは、外部コミットを許可するために新しいメンバーに利用可能にすることを選択することができます。"
    },
    {
      "indent": 3,
      "text": "In principle, external Commits work like regular Commits. However, their content has to meet a specific set of requirements:",
      "ja": "原則として、外部コミットは通常のコミットと同様に機能します。ただし、その内容は特定の要件を満たさなければなりません。"
    },
    {
      "indent": 6,
      "text": "* External Commits MUST contain a path field (and is therefore a \"full\" Commit). The joiner is added at the leftmost free leaf node (just as if they were added with an Add proposal), and the path is calculated relative to that leaf node.",
      "ja": "* External Commitsはパスフィールドを含まなければならず（したがって「完全な」Commitである）、結合子は左端の空き葉ノードに追加されます（まるでAdd提案で追加されたかのように）、そしてパスはその葉ノードに対して相対的に計算されます。"
    },
    {
      "indent": 6,
      "text": "* The Commit MUST NOT include any proposals by reference, since an external joiner cannot determine the validity of proposals sent within the group.",
      "ja": "* コミットには、外部の参加者がグループ内で送信された提案の妥当性を判断できないため、参照による提案を含めてはいけません。"
    },
    {
      "indent": 6,
      "text": "* External Commits MUST be signed by the new member. In particular, the signature on the enclosing AuthenticatedContent MUST verify using the public key for the credential in the leaf_node of the path field.",
      "ja": "* 外部のコミットは新メンバーによって署名される必要があります。特に、包含される AuthenticatedContent の署名は、path フィールドの leaf_node にある資格情報の公開鍵を使用して検証する必要があります。"
    },
    {
      "indent": 6,
      "text": "* When processing a Commit, both existing and new members MUST use the external init secret as described in Section 8.3.",
      "ja": "* コミットを処理する際には、既存のメンバーと新規メンバーの両方が、セクション8.3で説明されている外部初期化シークレットを使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "* The sender type for the AuthenticatedContent encapsulating the external Commit MUST be new_member_commit.",
      "ja": "* 外部のCommitをカプセル化するAuthenticatedContentの送信者タイプは、new_member_commitである必要があります。"
    },
    {
      "indent": 3,
      "text": "External Commits come in two \"flavors\" -- a \"join\" Commit that adds the sender to the group or a \"resync\" Commit that replaces a member's prior appearance with a new one.",
      "ja": "外部コミットには2つの「フレーバー」があります。送信者をグループに追加する「参加」コミットと、メンバーの以前の出現を新しいもので置き換える「再同期」コミットです。"
    },
    {
      "indent": 3,
      "text": "Note that the \"resync\" operation allows an attacker that has compromised a member's signature private key to introduce themselves into the group and remove the prior, legitimate member in a single Commit. Without resync, this can still be done, but it requires two operations: the external Commit to join and a second Commit to remove the old appearance. Applications for whom this distinction is salient can choose to disallow external commits that contain a Remove, or to allow such resync commits only if they contain a \"reinit\" PSK proposal that demonstrates the joining member's presence in a prior epoch of the group. With the latter approach, the attacker would need to compromise the PSK as well as the signing key, but the application will need to ensure that continuing, non-resynchronizing members have the required PSK.",
      "ja": "「resync」操作によって、メンバーの署名秘密鍵を侵害した攻撃者がグループに自分自身を導入し、以前の正当なメンバーを1つのCommitで削除することができることに注意してください。resyncがない場合、これはまだ行うことができますが、2つの操作が必要です：参加するための外部Commitと、古い外観を削除するための2番目のCommit。この違いが重要なアプリケーションは、Removeを含む外部コミットを許可しないか、参加メンバーが以前のグループのエポックに存在を示す「reinit」PSK提案を含む場合にのみそのようなresyncコミットを許可することができます。後者のアプローチでは、攻撃者はPSKだけでなく署名鍵も侵害する必要がありますが、アプリケーションは継続して非再同期化メンバーが必要なPSKを持っていることを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "12.4.3.3. Ratchet Tree Extension",
      "section_title": true,
      "ja": "12.4.3.3. ラチェットツリーエクステンション"
    },
    {
      "indent": 3,
      "text": "By default, a GroupInfo message only provides the joiner with a hash of the group's ratchet tree. In order to process or generate handshake messages, the joiner will need to get a copy of the ratchet tree from some other source. (For example, the DS might provide a cached copy.) The inclusion of the tree hash in the GroupInfo message means that the source of the ratchet tree need not be trusted to maintain the integrity of the tree.",
      "ja": "デフォルトでは、GroupInfoメッセージは参加者にグループのラチェットツリーのハッシュのみを提供します。ハンドシェイクメッセージを処理または生成するためには、参加者は他のソースからラチェットツリーのコピーを取得する必要があります。（たとえば、DSがキャッシュされたコピーを提供するかもしれません。）GroupInfoメッセージにツリーハッシュを含めることで、ラチェットツリーのソースはツリーの整合性を維持するために信頼される必要はありません。"
    },
    {
      "indent": 3,
      "text": "In cases where the application does not wish to provide such an external source, the whole public state of the ratchet tree can be provided in an extension of type ratchet_tree, containing a ratchet_tree object of the following form:",
      "ja": "アプリケーションが外部ソースを提供したくない場合、ラチェットツリーの全公開状態を提供することができます。その際、次の形式のratchet_treeオブジェクトを含むratchet_tree型の拡張が使用されます。"
    },
    {
      "indent": 3,
      "text": "struct {\n    NodeType node_type;\n    select (Node.node_type) {\n        case leaf:   LeafNode leaf_node;\n        case parent: ParentNode parent_node;\n    };\n} Node;\n\noptional<Node> ratchet_tree<V>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each entry in the ratchet_tree vector provides the value for a node in the tree, or the null optional for a blank node.",
      "ja": "ratchet_treeベクター内の各エントリーは、ツリー内のノードの値を提供するか、空のノードのためのnullオプションを提供します。"
    },
    {
      "indent": 3,
      "text": "The nodes are listed in the order specified by a left-to-right in-order traversal of the ratchet tree. Each node is listed between its left subtree and its right subtree. (This is the same ordering as specified for the array-based trees outlined in Appendix C.)",
      "ja": "ノードは、ラチェットツリーの左から右への中間順の順序で指定された順序でリストされています。各ノードは、その左部分木と右部分木の間にリストされています。（これは、付録Cで概説されている配列ベースの木に指定されている順序と同じです。）"
    },
    {
      "indent": 3,
      "text": "If the tree has 2^d leaves, then it has 2^(d+1) - 1 nodes. The ratchet_tree vector logically has this number of entries, but the sender MUST NOT include blank nodes after the last non-blank node. The receiver MUST check that the last node in ratchet_tree is non-blank, and then extend the tree to the right until it has a length of the form 2^(d+1) - 1, adding the minimum number of blank values possible. (Obviously, this may be done \"virtually\", by synthesizing blank nodes when required, as opposed to actually changing the structure in memory.)",
      "ja": "木が2^dの葉を持っている場合、その木は2^(d+1) - 1個のノードを持っています。ratchet_treeベクトルは論理的にこの数のエントリを持っていますが、送信者は最後の非空ノードの後に空のノードを含めてはいけません。受信者はratchet_treeの最後のノードが非空であることを確認し、その後、ツリーを右に拡張して2^(d+1) - 1の形になるまで長さを調整し、可能な限り最小限の空の値を追加する必要があります。（明らかに、これはメモリ内の構造を実際に変更するのではなく、必要に応じて空のノードを合成することで「仮想的に」行われるかもしれません。）"
    },
    {
      "indent": 3,
      "text": "The leaves of the tree are stored in even-numbered entries in the array (the leaf with index L in array position 2*L). The root node of the tree is at position 2^d - 1 of the array. Intermediate parent nodes can be identified by performing the same calculation to the subarrays to the left and right of the root, following something like the following algorithm:",
      "ja": "その木の葉は、配列内の偶数番目のエントリに格納されています（配列位置2*LにインデックスLの葉があります）。木の根ノードは、配列の位置2^d - 1にあります。中間の親ノードは、根の左右のサブ配列に同じ計算を行うことで特定できます。以下はそのようなアルゴリズムの例です："
    },
    {
      "indent": 3,
      "text": "# Assuming a class Node that has left and right members\ndef subtree_root(nodes):\n    # If there is only one node in the array, return it\n    if len(nodes) == 1:\n        return Node(nodes[0])\n\n    # Otherwise, the length of the array MUST be odd\n    if len(nodes) % 2 == 0:\n        raise Exception(\"Malformed node array {}\", len(nodes))\n\n    # Identify the root of the subtree\n    d = 0\n    while (2**(d+1)) < len(nodes):\n       d += 1\n    R = 2**d - 1\n    root = Node(nodes[R])\n    root.left = subtree_root(nodes[:R])\n    root.right = subtree_root(nodes[(R+1):])\n    return root",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(Note that this is the same ordering of nodes as in the array-based tree representation described in Appendix C. The algorithms in that section may be used to simplify decoding this extension into other representations.)",
      "ja": "（注：これは、付録Cで説明されている配列ベースの木の表現と同じノードの順序です。そのセクションのアルゴリズムを使用して、この拡張を他の表現にデコードすることができます。）"
    },
    {
      "indent": 3,
      "text": "For example, the following tree with six non-blank leaves would be represented as an array of eleven elements, [A, W, B, X, C, _, D, Y, E, Z, F]. The above decoding procedure would identify the subtree roots as follows (using R to represent a subtree root):",
      "ja": "例えば、6つの空でない葉を持つ以下の木は、11要素の配列として表されます。[A, W, B, X, C, _, D, Y, E, Z, F] 上記のデコード手順では、サブツリーのルートを以下のように特定します（サブツリールートを表すためにRを使用）:"
    },
    {
      "indent": 3,
      "text": "              Y\n              |\n        .-----+-----.\n       /             \\\n      X               _\n      |               |\n    .-+-.           .-+-.\n   /     \\         /     \\\n  W       _       Z       _\n / \\     / \\     / \\     / \\\nA   B   C   D   E   F   _   _\n\n                    1\n0 1 2 3 4 5 6 7 8 9 0\n<-----------> R <----------->\n<---> R <--->   <---> R <--->\n- R -   - R -   - R -   - R -",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Figure 28: Left-to-Right In-Order Traversal of a Six-Member Tree",
      "ja": "図28：6つのメンバーを持つ木の左から右への順序通りの走査"
    },
    {
      "indent": 3,
      "text": "The presence of a ratchet_tree extension in a GroupInfo message does not result in any changes to the GroupContext extensions for the group. The ratchet tree provided is simply stored by the client and used for MLS operations.",
      "ja": "GroupInfoメッセージにratchet_tree拡張機能が存在しても、グループのGroupContext拡張機能に変更は生じません。提供されたラチェットツリーは単にクライアントによって保存され、MLS操作に使用されます。"
    },
    {
      "indent": 3,
      "text": "If this extension is not provided in a Welcome message, then the client will need to fetch the ratchet tree over some other channel before it can generate or process Commit messages. Applications should ensure that this out-of-band channel is provided with security protections equivalent to the protections that are afforded to Proposal and Commit messages. For example, an application that encrypts Proposal and Commit messages might distribute ratchet trees encrypted using a key exchanged over the MLS channel.",
      "ja": "もしウェルカムメッセージにこの拡張機能が提供されていない場合、クライアントはコミットメッセージを生成または処理する前に、ラチェットツリーを他のチャネル経由で取得する必要があります。アプリケーションは、この帯域外チャネルが、提案とコミットメッセージに提供される保護と同等のセキュリティ保護が提供されるようにする必要があります。例えば、提案とコミットメッセージを暗号化するアプリケーションは、MLSチャネルを介して交換されたキーを使用して暗号化されたラチェットツリーを配布するかもしれません。"
    },
    {
      "indent": 3,
      "text": "Regardless of how the client obtains the tree, the client MUST verify that the root hash of the ratchet tree matches the tree_hash of the GroupContext before using the tree for MLS operations.",
      "ja": "クライアントがツリーを取得する方法に関わらず、MLS操作に使用する前に、クライアントは必ずラチェットツリーのルートハッシュがGroupContextのtree_hashと一致することを確認しなければなりません。"
    },
    {
      "indent": 0,
      "text": "13. Extensibility",
      "section_title": true,
      "ja": "13. 拡張性"
    },
    {
      "indent": 3,
      "text": "The base MLS protocol can be extended in a few ways. New cipher suites can be added to enable the use of new cryptographic algorithms. New types of proposals can be used to perform new actions within an epoch. Extension fields can be used to add additional information to the protocol. In this section, we discuss some constraints on these extensibility mechanisms that are necessary to ensure broad interoperability.",
      "ja": "基本のMLSプロトコルはいくつかの方法で拡張することができます。新しい暗号スイートを追加して新しい暗号アルゴリズムの使用を可能にすることができます。新しい提案の種類を使用して、エポック内で新しいアクションを実行することができます。拡張フィールドを使用してプロトコルに追加情報を追加することができます。このセクションでは、これらの拡張性メカニズムに対するいくつかの制約について議論します。これらの制約は、広範な相互運用性を確保するために必要です。"
    },
    {
      "indent": 0,
      "text": "13.1. Additional Cipher Suites",
      "section_title": true,
      "ja": "13.1. 追加の暗号スイート"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 5.1, MLS allows the participants in a group to negotiate the cryptographic algorithms used within the group. This extensibility is important for maintaining the security of the protocol over time [RFC7696]. It also creates a risk of interoperability failure due to clients not supporting a common cipher suite.",
      "ja": "セクション5.1で議論されたように、MLSはグループ内の参加者がグループ内で使用される暗号アルゴリズムを交渉することを可能にします。この拡張性は、プロトコルのセキュリティを時間とともに維持するために重要です[RFC7696]。しかし、クライアントが共通の暗号スイートをサポートしていないために相互運用性の失敗のリスクも生じます。"
    },
    {
      "indent": 3,
      "text": "The cipher suite registry defined in Section 17.1 attempts to strike a balance on this point. On the one hand, the base policy for the registry is Specification Required, a fairly low bar designed to avoid the need for standards work in cases where different ciphers are needed for niche applications. On the other hand, there is a higher bar (Standards Action) for ciphers to set the Recommended field in the registry. This higher bar is there in part to ensure that the interoperability implications of new cipher suites are considered.",
      "ja": "セクション17.1で定義された暗号スイートレジストリは、この点でバランスを取ろうとしています。一方で、レジストリの基本ポリシーは「Specification Required」であり、これは異なる暗号がニッチなアプリケーションに必要な場合に標準化作業を回避するために設計された比較的低い基準です。一方で、レジストリの「Recommended」フィールドを設定するためには、より高い基準（Standards Action）があります。この高い基準は、新しい暗号スイートの相互運用性の影響が考慮されることを一部確保するために存在しています。"
    },
    {
      "indent": 3,
      "text": "MLS cipher suites are defined independent of MLS versions, so that in principle, the same cipher suite can be used across versions. Standards work defining new versions of MLS should consider whether it is desirable for the new version to be compatible with existing cipher suites, or whether the new version should rule out some cipher suites. For example, a new version could follow the example of HTTP/2, which restricted the set of allowed TLS ciphers (see Section 9.2.2 of [RFC9113]).",
      "ja": "MLSの暗号スイートはMLSのバージョンとは独立して定義されているため、原則として、同じ暗号スイートが異なるバージョン間で使用される可能性があります。MLSの新しいバージョンを定義する標準作業では、新しいバージョンが既存の暗号スイートと互換性があることが望ましいか、あるいは新しいバージョンが一部の暗号スイートを排除すべきかを検討すべきです。たとえば、新しいバージョンは、許可されるTLS暗号のセットを制限したHTTP/2の例に続くことができます（[RFC9113]のセクション9.2.2を参照）。"
    },
    {
      "indent": 0,
      "text": "13.2. Proposals",
      "section_title": true,
      "ja": "13.2. 提案"
    },
    {
      "indent": 3,
      "text": "Commit messages do not have an extension field because the set of proposals is extensible. As discussed in Section 12.4, Proposals with a non-default proposal type MUST NOT be included in a commit unless the proposal type is supported by all the members of the group that will process the Commit.",
      "ja": "コミットメッセージには拡張フィールドがありません。提案のセットは拡張可能です。12.4節で議論されたように、デフォルトでない提案タイプを持つ提案は、その提案タイプがコミットを処理するグループのすべてのメンバーによってサポートされている場合を除き、コミットに含めてはいけません。"
    },
    {
      "indent": 0,
      "text": "13.3. Credential Extensibility",
      "section_title": true,
      "ja": "13.3. 資格拡張性"
    },
    {
      "indent": 3,
      "text": "In order to ensure that MLS provides meaningful authentication, it is important that each member is able to authenticate some identity information for each other member. Identity information is encoded in Credentials, so this property is provided by ensuring that members use compatible credential types.",
      "ja": "MLSが有意義な認証を提供するためには、各メンバーが他のメンバーのいくつかの身元情報を認証できることが重要です。身元情報は資格情報にエンコードされているため、この特性は、メンバーが互換性のある資格情報タイプを使用することを確認することで提供されます。"
    },
    {
      "indent": 3,
      "text": "The only types of credential that may be used in a group are those that all members of the group support, as specified by the capabilities field of each LeafNode in the ratchet tree. An application can introduce new credential types by choosing an unallocated identifier from the registry in Section 17.5 and indicating support for the credential type in published LeafNodes, whether in Update proposals to existing groups or KeyPackages that are added to new groups. Once all members in a group indicate support for the credential type, members can start using LeafNodes with the new credential. Application may enforce that certain credential types always remain supported by adding a required_capabilities extension to the group's GroupContext, which would prevent any member from being added to the group that doesn't support them.",
      "ja": "グループで使用できる資格情報の種類は、ラチェットツリー内の各LeafNodeのcapabilitiesフィールドで指定されたものである必要があります。アプリケーションは、セクション17.5の登録から未割り当ての識別子を選択し、既存のグループへの更新提案または新しいグループに追加されるKeyPackagesで、資格情報タイプのサポートを示すことで新しい資格情報タイプを導入できます。グループのすべてのメンバーが資格情報タイプをサポートすることを示すと、メンバーは新しい資格情報を使用できるようになります。アプリケーションは、必要な_capabilities拡張機能をグループのGroupContextに追加することで、特定の資格情報タイプが常にサポートされ続けるように強制することができます。これにより、それらをサポートしていないメンバーをグループに追加することができなくなります。"
    },
    {
      "indent": 3,
      "text": "In future extensions to MLS, it may be useful to allow a member to present more than one credential. For example, such credentials might present different attributes attested by different authorities. To be consistent with the general principle stated at the beginning of this section, such an extension would need to ensure that each member can authenticate some identity for each other member. For each pair of members (Alice, Bob), Alice would need to present at least one credential of a type that Bob supports.",
      "ja": "MLSの将来の拡張では、1人のメンバーが複数の資格情報を提示できるようにすると便利かもしれません。例えば、そのような資格情報は、異なる機関によって証明された異なる属性を提示するかもしれません。このセクションの冒頭で述べられた一般的な原則に一貫性を持たせるために、そのような拡張機能は、各メンバーが他のメンバーのいずれかの身元を認証できるようにする必要があります。各メンバーのペア（Alice、Bob）ごとに、AliceはBobがサポートする少なくとも1つの資格情報を提示する必要があります。"
    },
    {
      "indent": 0,
      "text": "13.4. Extensions",
      "section_title": true,
      "ja": "13.4. 拡張機能"
    },
    {
      "indent": 3,
      "text": "This protocol includes a mechanism for negotiating extension parameters similar to the one in TLS [RFC8446]. In TLS, extension negotiation is one-to-one: The client offers extensions in its ClientHello message, and the server expresses its choices for the session with extensions in its ServerHello and EncryptedExtensions messages. In MLS, extensions appear in the following places:",
      "ja": "このプロトコルには、TLS [RFC8446] と同様の拡張パラメータを交渉するメカニズムが含まれています。TLSでは、拡張機能の交渉は一対一です。クライアントはClientHelloメッセージで拡張機能を提供し、サーバーはServerHelloおよびEncryptedExtensionsメッセージで拡張機能を使用してセッションの選択肢を示します。MLSでは、拡張機能は次の場所に表示されます："
    },
    {
      "indent": 6,
      "text": "* In KeyPackages, to describe additional information related to the client",
      "ja": "* KeyPackagesにおいて、クライアントに関連する追加情報を記述するため"
    },
    {
      "indent": 6,
      "text": "* In LeafNodes, to describe additional information about the client or its participation in the group (once in the ratchet tree)",
      "ja": "* LeafNodesでは、クライアントやグループへの参加に関する追加情報を記述するために（ラチェットツリー内で）"
    },
    {
      "indent": 6,
      "text": "* In the GroupInfo, to tell new members of a group what parameters are being used by the group, and to provide any additional details required to join the group",
      "ja": "* GroupInfoでは、グループの新メンバーに、グループで使用されているパラメーターを伝え、グループに参加するために必要な追加情報を提供します。"
    },
    {
      "indent": 6,
      "text": "* In the GroupContext object, to ensure that all members of the group have the same view of the parameters in use",
      "ja": "* GroupContextオブジェクトでは、グループのすべてのメンバーが使用されているパラメータについて同じ見解を持つようにするために"
    },
    {
      "indent": 3,
      "text": "In other words, an application can use GroupContext extensions to ensure that all members of the group agree on a set of parameters. Clients indicate their support for parameters in the capabilities field of their LeafNode. New members of a group are informed of the group's GroupContext extensions via the extensions field in the group_context field of the GroupInfo object. The extensions field in a GroupInfo object (outside of the group_context field) can be used to provide additional parameters to new joiners that are used to join the group.",
      "ja": "言い換えると、アプリケーションはGroupContext拡張機能を使用して、グループのすべてのメンバーが一連のパラメータに同意することを確認できます。クライアントはLeafNodeのcapabilitiesフィールドでパラメータへのサポートを示します。グループの新しいメンバーは、GroupInfoオブジェクトのgroup_contextフィールド内のextensionsフィールドを介して、グループのGroupContext拡張機能について通知されます。GroupInfoオブジェクトのextensionsフィールド（group_contextフィールドの外側）は、グループに参加するために使用される新しい参加者に追加のパラメータを提供するために使用できます。"
    },
    {
      "indent": 3,
      "text": "This extension mechanism is designed to allow for the secure and forward-compatible negotiation of extensions. For this to work, implementations MUST correctly handle extensible fields:",
      "ja": "この拡張メカニズムは、拡張の安全かつ将来互換な交渉を可能にするよう設計されています。これを実現するためには、実装は拡張可能なフィールドを正しく処理する必要があります。"
    },
    {
      "indent": 6,
      "text": "* A client that posts a KeyPackage MUST support all parameters advertised in it. Otherwise, another client might fail to interoperate by selecting one of those parameters.",
      "ja": "* KeyPackageを投稿するクライアントは、それに宣伝されているすべてのパラメータをサポートする必要があります。そうでないと、別のクライアントがそのパラメータの1つを選択することで相互運用性に失敗する可能性があります。"
    },
    {
      "indent": 6,
      "text": "* A client processing a KeyPackage object MUST ignore all unrecognized values in the capabilities field of the LeafNode and all unknown extensions in the extensions and leaf_node.extensions fields. Otherwise, it could fail to interoperate with newer clients.",
      "ja": "* KeyPackageオブジェクトを処理するクライアントは、LeafNodeのcapabilitiesフィールド内のすべての認識されない値と、extensionsおよびleaf_node.extensionsフィールド内の未知の拡張機能を無視しなければなりません。そうしないと、新しいクライアントとの相互運用性が失われる可能性があります。"
    },
    {
      "indent": 6,
      "text": "* A client processing a GroupInfo object MUST ignore all unrecognized extensions in the extensions field.",
      "ja": "* GroupInfoオブジェクトを処理しているクライアントは、extensionsフィールド内のすべての認識されない拡張機能を無視しなければなりません。"
    },
    {
      "indent": 6,
      "text": "* Any field containing a list of extensions MUST NOT have more than one extension of any given type.",
      "ja": "* 指定された型の拡張子を複数含むことはできません。"
    },
    {
      "indent": 6,
      "text": "* A client adding a new member to a group MUST verify that the LeafNode for the new member is compatible with the group's extensions. The capabilities field MUST indicate support for each extension in the GroupContext.",
      "ja": "* クライアントがグループに新しいメンバーを追加する場合、新しいメンバーのLeafNodeがグループの拡張機能と互換性があることを確認する必要があります。capabilitiesフィールドは、GroupContext内の各拡張機能のサポートを示さなければなりません。"
    },
    {
      "indent": 6,
      "text": "* A client joining a group MUST verify that it supports every extension in the GroupContext for the group. Otherwise, it MUST treat the enclosing GroupInfo message as invalid and not join the group.",
      "ja": "* クライアントがグループに参加する場合、そのグループの GroupContext 内のすべての拡張機能をサポートしていることを確認する必要があります。そうでない場合、そのクライアントは、包含されている GroupInfo メッセージを無効と見なし、グループに参加しない必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that the latter two requirements mean that all MLS GroupContext extensions are mandatory, in the sense that an extension in use by the group MUST be supported by all members of the group.",
      "ja": "後者の2つの要件は、すべてのMLS GroupContext拡張機能が必須であることを意味することに注意してください。つまり、グループで使用されている拡張機能は、グループのすべてのメンバーによってサポートされる必要があります。"
    },
    {
      "indent": 3,
      "text": "The parameters of a group may be changed by sending a GroupContextExtensions proposal to enable additional extensions (Section 12.1.7), or by reinitializing the group (Section 11.2).",
      "ja": "グループのパラメータは、追加の拡張機能を有効にするためにGroupContextExtensions提案を送信することによって変更することができます（セクション12.1.7）、またはグループを再初期化することによって変更することができます（セクション11.2）。"
    },
    {
      "indent": 0,
      "text": "13.5. GREASE",
      "section_title": true,
      "ja": "13.5. GREASE"
    },
    {
      "indent": 3,
      "text": "As described in Section 13.4, clients are required to ignore unknown values for certain parameters. To help ensure that other clients implement this behavior, a client can follow the \"Generate Random Extensions And Sustain Extensibility\" or GREASE approach described in [RFC8701]. In the context of MLS, this means that a client generating a KeyPackage, LeafNode, or GroupInfo object includes random values in certain fields which would be ignored by a correctly implemented client processing the message. A client that incorrectly rejects unknown code points will fail to process such a message, providing a signal to its implementer that the client needs to be fixed.",
      "ja": "セクション13.4に記載されているように、クライアントは特定のパラメータの未知の値を無視する必要があります。他のクライアントがこの動作を実装することを確実にするために、クライアントは[RFC8701]で説明されている「Generate Random Extensions And Sustain Extensibility」またはGREASEアプローチに従うことができます。MLSの文脈では、KeyPackage、LeafNode、またはGroupInfoオブジェクトを生成するクライアントは、メッセージを処理する際に無視される特定のフィールドにランダムな値を含めることを意味します。未知のコードポイントを誤って拒否するクライアントは、そのようなメッセージを処理できず、その実装者にクライアントを修正する必要があることを示します。"
    },
    {
      "indent": 3,
      "text": "When generating the following fields, an MLS client SHOULD include a random selection of values chosen from these GREASE values:",
      "ja": "以下のフィールドを生成する際、MLSクライアントはこれらのGREASE値から選択されたランダムな値を含めるべきです。"
    },
    {
      "indent": 6,
      "text": "* LeafNode.capabilities.cipher_suites",
      "ja": "* LeafNode.capabilities.cipher_suites"
    },
    {
      "indent": 6,
      "text": "* LeafNode.capabilities.extensions",
      "ja": "* LeafNode.capabilities.extensions"
    },
    {
      "indent": 6,
      "text": "* LeafNode.capabilities.proposals",
      "ja": "* LeafNode.capabilities.proposals"
    },
    {
      "indent": 6,
      "text": "* LeafNode.capabilities.credentials",
      "ja": "* LeafNode.capabilities.credentials"
    },
    {
      "indent": 6,
      "text": "* LeafNode.extensions",
      "ja": "* LeafNode.extensions"
    },
    {
      "indent": 6,
      "text": "* KeyPackage.extensions",
      "ja": "* KeyPackage.extensions"
    },
    {
      "indent": 6,
      "text": "* GroupInfo.extensions",
      "ja": "* GroupInfo.extensions"
    },
    {
      "indent": 3,
      "text": "For the KeyPackage and GroupInfo extensions, the extension_data for GREASE extensions MAY have any contents selected by the sender, since they will be ignored by a correctly implemented receiver. For example, a sender might populate these extensions with a randomly sized amount of random data.",
      "ja": "KeyPackageおよびGroupInfo拡張機能について、GREASE拡張機能のextension_dataには、送信者が選択した任意の内容が含まれていても構いません。なぜなら、正しく実装された受信者によって無視されるからです。例えば、送信者はこれらの拡張機能にランダムな量のランダムデータを入れることがあります。"
    },
    {
      "indent": 3,
      "text": "Note that any GREASE values added to LeafNode.extensions need to be reflected in LeafNode.capabilities.extensions, since the LeafNode validation process described in Section 7.3 requires that these two fields be consistent.",
      "ja": "LeafNode.extensions に追加された GREASE 値は、LeafNode.capabilities.extensions にも反映される必要があることに注意してください。なぜなら、セクション 7.3 で説明されている LeafNode の検証プロセスでは、これらの2つのフィールドが一貫している必要があるからです。"
    },
    {
      "indent": 3,
      "text": "GREASE values MUST NOT be sent in the following fields, because an unsupported value in one these fields (including a GREASE value) will cause the enclosing message to be rejected:",
      "ja": "以下のフィールドにはGREASE値を送信してはいけません。なぜなら、これらのフィールドのいずれかにサポートされていない値（GREASE値を含む）が含まれていると、そのメッセージ全体が拒否される可能性があるからです。"
    },
    {
      "indent": 6,
      "text": "* Proposal.proposal_type",
      "ja": "* Proposal.proposal_type"
    },
    {
      "indent": 6,
      "text": "* Credential.credential_type",
      "ja": "* Credential.credential_type"
    },
    {
      "indent": 6,
      "text": "* GroupContext.extensions",
      "ja": "* GroupContext.extensions"
    },
    {
      "indent": 6,
      "text": "* GroupContextExtensions.extensions",
      "ja": "* GroupContextExtensions.extensions"
    },
    {
      "indent": 3,
      "text": "Values reserved for GREASE have been registered in the various registries in Section 17. This prevents conflict between GREASE and real future values. The following values are reserved in each registry: 0x0A0A, 0x1A1A, 0x2A2A, 0x3A3A, 0x4A4A, 0x5A5A, 0x6A6A, 0x7A7A, 0x8A8A, 0x9A9A, 0xAAAA, 0xBABA, 0xCACA, 0xDADA, and 0xEAEA. (The value 0xFAFA falls within the private use range.) These values MUST only appear in the fields listed above, and not, for example, in the proposal_type field of a Proposal. Clients MUST NOT implement any special processing rules for how to handle these values when receiving them, since this negates their utility for detecting extensibility failures.",
      "ja": "GREASE用に予約された値は、セクション17のさまざまなレジストリに登録されています。これにより、GREASEと実際の将来の値との間での競合を防ぎます。各レジストリには次の値が予約されています：0x0A0A、0x1A1A、0x2A2A、0x3A3A、0x4A4A、0x5A5A、0x6A6A、0x7A7A、0x8A8A、0x9A9A、0xAAAA、0xBABA、0xCACA、0xDADA、および0xEAEA。（値0xFAFAはプライベート使用範囲内に含まれます。）これらの値は、上記にリストされたフィールドにのみ表示される必要があり、例えば、提案のproposal_typeフィールドには表示されてはいけません。これらの値を受信した際にこれらを処理する方法に特別な処理ルールをクライアントが実装してはいけません。なぜなら、これは拡張性の失敗を検出するための有用性を無効にするからです。"
    },
    {
      "indent": 3,
      "text": "GREASE values MUST be handled using normal logic for processing unsupported values. When comparing lists of capabilities to identify mutually supported capabilities, clients MUST represent their own capabilities with a list containing only the capabilities actually supported, without any GREASE values. In other words, lists including GREASE values are only sent to other clients; representations of a client's own capabilities MUST NOT contain GREASE values.",
      "ja": "GREASE値は、サポートされていない値を処理するための通常のロジックを使用して取り扱わなければなりません。相互にサポートされている機能を特定するために機能のリストを比較する際、クライアントは自身の機能を実際にサポートされている機能のみを含むリストで表現しなければなりません。つまり、GREASE値を含むリストは他のクライアントにのみ送信されます。クライアント自身の機能の表現にはGREASE値を含めてはいけません。"
    },
    {
      "indent": 0,
      "text": "14. Sequencing of State Changes",
      "section_title": true,
      "ja": "14. 状態変化のシーケンス"
    },
    {
      "indent": 3,
      "text": "Each Commit message is premised on a given starting state, indicated by the epoch field of the enclosing FramedContent. If the changes implied by a Commit message are made starting from a different state, the results will be incorrect.",
      "ja": "各コミットメッセージは、その中に含まれるFramedContentのエポックフィールドによって示される特定の開始状態を前提としています。コミットメッセージによって暗示される変更が異なる状態から行われた場合、結果は正しくありません。"
    },
    {
      "indent": 3,
      "text": "This need for sequencing is not a problem as long as each time a group member sends a Commit message, it is based on the most current state of the group. In practice, however, there is a risk that two members will generate Commit messages simultaneously based on the same state.",
      "ja": "このシーケンス化の必要性は、グループメンバーがコミットメッセージを送信するたびに、そのメッセージがグループの最新の状態に基づいている限り、問題ではありません。しかし、実際には、同じ状態に基づいて2人のメンバーが同時にコミットメッセージを生成するリスクがあります。"
    },
    {
      "indent": 3,
      "text": "Applications MUST have an established way to resolve conflicting Commit messages for the same epoch. They can do this either by preventing conflicting messages from occurring in the first place, or by developing rules for deciding which Commit out of several sent in an epoch will be canonical. The approach chosen MUST minimize the amount of time that forked or previous group states are kept in memory, and promptly delete them once they're no longer necessary to ensure forward secrecy.",
      "ja": "アプリケーションは、同じエポックにおける競合するコミットメッセージを解決する確立された方法を持っている必要があります。これは、競合するメッセージが最初から発生しないようにするか、1つのエポックに複数の送信されたコミットの中からどのコミットが正規となるかを決定するためのルールを開発することによって行うことができます。選択されたアプローチは、フォークしたり以前のグループ状態がメモリに保持される時間を最小限に抑え、前方秘匿性を確保するために不要になったらすぐに削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "The generation of Commit messages MUST NOT modify a client's state, since the client doesn't know at that time whether the changes implied by the Commit message will conflict with another Commit or not. Similarly, the Welcome message corresponding to a Commit MUST NOT be delivered to a new joiner until it's clear that the Commit has been accepted.",
      "ja": "Commit メッセージの生成は、クライアントの状態を変更してはいけません。なぜなら、その時点では Commit メッセージによって暗示される変更が別の Commit と競合するかどうかはクライアントがわからないからです。同様に、Commit に対応する Welcome メッセージは、Commit が受け入れられたことが明確になるまで新規参加者には配信してはいけません。"
    },
    {
      "indent": 3,
      "text": "Regardless of how messages are kept in sequence, there is a risk that in a sufficiently busy group, a given member may never be able to send a Commit message because they always lose to other members. The degree to which this is a practical problem will depend on the dynamics of the application.",
      "ja": "メッセージが順序通りに保持されているかどうかに関わらず、十分に忙しいグループでは、特定のメンバーが常に他のメンバーに負けてしまい、Commitメッセージを送信できないリスクがあります。これが実際の問題となる程度は、アプリケーションのダイナミクスに依存します。"
    },
    {
      "indent": 0,
      "text": "15. Application Messages",
      "section_title": true,
      "ja": "15. アプリケーションメッセージ"
    },
    {
      "indent": 3,
      "text": "The primary purpose of handshake messages is to provide an authenticated group key exchange to clients. In order to protect application messages sent among the members of a group, the encryption_secret provided by the key schedule is used to derive a sequence of nonces and keys for message encryption. Every epoch moves the key schedule forward, which triggers the creation of a new secret tree, as described in Section 9, along with a new set of symmetric ratchets of nonces and keys for each member.",
      "ja": "ハンドシェイクメッセージの主な目的は、クライアントに認証されたグループ鍵交換を提供することです。グループのメンバー間で送信されるアプリケーションメッセージを保護するために、キースケジュールによって提供される暗号化秘密を使用して、メッセージの暗号化のためのノンスとキーのシーケンスを導出します。各エポックはキースケジュールを前に進め、新しい秘密ツリーの作成をトリガーし、セクション9で説明されているように、各メンバーに対して新しい対称ラチェットのノンスとキーのセットを作成します。"
    },
    {
      "indent": 3,
      "text": "Each client maintains their own local copy of the key schedule for each epoch during which they are a group member. They derive new keys, nonces, and secrets as needed while deleting old ones as soon as they have been used.",
      "ja": "各クライアントは、グループメンバーである期間中、各エポックのキースケジュールのローカルコピーを維持します。必要に応じて新しいキー、ナンス、およびシークレットを導出し、使用された古いものはすぐに削除します。"
    },
    {
      "indent": 3,
      "text": "The group identifier and epoch allow a recipient to know which group secrets should be used and from which epoch_secret to start computing other secrets. The sender identifier and content type are used to identify which symmetric ratchet to use from the secret tree. The generation counter determines how far into the ratchet to iterate in order to produce the required nonce and key for encryption or decryption.",
      "ja": "グループ識別子とエポックは、受信者がどのグループ秘密を使用すべきか、および他の秘密の計算を開始するためにどのエポック秘密を使用すべきかを知ることを可能にします。 送信者識別子とコンテンツタイプは、秘密ツリーからどの対称ラチェットを使用するかを識別するために使用されます。 生成カウンターは、必要なノンスと暗号化または復号化のためのキーを生成するために、どの程度のラチェットを繰り返すかを決定します。"
    },
    {
      "indent": 0,
      "text": "15.1. Padding",
      "section_title": true,
      "ja": "15.1. パディング"
    },
    {
      "indent": 3,
      "text": "Application messages MAY be padded to provide some resistance against traffic analysis techniques over encrypted traffic [CLINIC] [HCJ16]. While MLS might deliver the same payload less frequently across a lot of ciphertexts than traditional web servers, it might still provide the attacker enough information to mount an attack. If Alice asks Bob \"When are we going to the movie?\", then the answer \"Wednesday\" could be leaked to an adversary solely by the ciphertext length.",
      "ja": "アプリケーションメッセージは、暗号化されたトラフィック上でのトラフィック解析技術に対するある程度の耐性を提供するためにパディングされる可能性があります[CLINIC] [HCJ16]。MLSは、従来のWebサーバーよりも多くの暗号文を通じて同じペイロードをより頻繁に提供するかもしれませんが、それでも攻撃者に十分な情報を提供する可能性があります。たとえば、AliceがBobに「映画に行くのはいつですか？」と尋ねた場合、その答えである「水曜日」という情報が、暗号文の長さだけで敵対者に漏洩する可能性があります。"
    },
    {
      "indent": 3,
      "text": "The length of the padding field in PrivateMessageContent can be chosen by the sender at the time of message encryption. Senders may use padding to reduce the ability of attackers outside the group to infer the size of the encrypted content. Note, however, that the transports used to carry MLS messages may have maximum message sizes, so padding schemes SHOULD avoid increasing message size beyond any such limits that exist in a given deployment scenario.",
      "ja": "PrivateMessageContent内のパディングフィールドの長さは、メッセージの暗号化時に送信者が選択できます。送信者は、パディングを使用して、グループ外の攻撃者が暗号化されたコンテンツのサイズを推測する能力を低下させることができます。ただし、MLSメッセージを運ぶために使用されるトランスポートには、最大メッセージサイズがある場合があるため、パディングスキームは、特定の展開シナリオで存在するそのような制限を超えてメッセージサイズを増やすことを避けるべきです。"
    },
    {
      "indent": 0,
      "text": "15.2. Restrictions",
      "section_title": true,
      "ja": "15.2. 制限"
    },
    {
      "indent": 3,
      "text": "During each epoch, senders MUST NOT encrypt more data than permitted by the security bounds of the AEAD scheme used [CFRG-AEAD-LIMITS].",
      "ja": "各エポック中、送信者は使用されているAEADスキームのセキュリティ境界で許可されているデータよりも多くのデータを暗号化してはいけません [CFRG-AEAD-LIMITS]。"
    },
    {
      "indent": 3,
      "text": "Note that each change to the group through a handshake message will also set a new encryption_secret. Hence this change MUST be applied before encrypting any new application message. This is required both to ensure that any users removed from the group can no longer receive messages and to (potentially) recover confidentiality and authenticity for future messages despite a past state compromise.",
      "ja": "グループへの各変更は、ハンドシェイクメッセージを介して新しいencryption_secretを設定します。したがって、新しいアプリケーションメッセージを暗号化する前に、この変更を適用する必要があります。これは、グループから削除されたユーザーがメッセージを受信できなくなるようにするためだけでなく、過去の状態の妥協にもかかわらず、将来のメッセージの機密性と信頼性を回復するために必要です。"
    },
    {
      "indent": 0,
      "text": "15.3. Delayed and Reordered Application Messages",
      "section_title": true,
      "ja": "15.3. 遅延および再注文されたアプリケーションメッセージ"
    },
    {
      "indent": 3,
      "text": "Since each application message contains the group identifier, the epoch, and a generation counter, a client can receive messages out of order. When messages are received out of order, the client moves the sender ratchet forward to match the received generation counter. Any unused nonce and key pairs from the ratchet are potentially stored so that they can be used to decrypt the messages that were delayed or reordered.",
      "ja": "各アプリケーションメッセージには、グループ識別子、エポック、および世代カウンターが含まれているため、クライアントはメッセージを順番に受信することができます。メッセージが順番通りでない場合、クライアントは送信者のラチェットを前に進めて受信した世代カウンターに合わせます。ラチェットから未使用のナンスとキーペアは、遅延や順序が入れ替わったメッセージを復号化するために使用できるように潜在的に保存されます。"
    },
    {
      "indent": 3,
      "text": "Applications SHOULD define a policy on how long to keep unused nonce and key pairs for a sender, and the maximum number to keep. This is in addition to ensuring that these secrets are deleted according to the deletion schedule defined in Section 9.2. Applications SHOULD also define a policy limiting the maximum number of steps that clients will move the ratchet forward in response to a new message. Messages received with a generation counter that is too much higher than the last message received would then be rejected. This avoids causing a denial-of-service attack by requiring the recipient to perform an excessive number of key derivations. For example, a malicious group member could send a message with generation = 0xffffffff at the beginning of a new epoch, forcing recipients to perform billions of key derivations unless they apply limits of the type discussed above.",
      "ja": "アプリケーションは、送信者の未使用のナンスとキーペアを保持する期間と最大数を定義するポリシーを定義すべきです。これは、セクション9.2で定義された削除スケジュールに従ってこれらの秘密が削除されることを確認するためのものです。アプリケーションは、新しいメッセージに応答してクライアントがラチェットを前進させる最大ステップ数を制限するポリシーも定義すべきです。最後に受信したメッセージよりもはるかに高い世代カウンターを持つメッセージは拒否されるべきです。これにより、受信者に過剰な数のキー派生を実行させることで、サービス拒否攻撃を引き起こすことが避けられます。例えば、悪意のあるグループメンバーが新しいエポックの開始時に世代= 0xffffffffのメッセージを送信し、受信者が上記で議論されたタイプの制限を適用しない限り、数十億のキー派生を実行させることができます。"
    },
    {
      "indent": 0,
      "text": "16. Security Considerations",
      "section_title": true,
      "ja": "16. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The security goals of MLS are described in [MLS-ARCH]. We describe here how the protocol achieves its goals at a high level, though a complete security analysis is outside of the scope of this document. The Security Considerations section of [MLS-ARCH] provides some citations to detailed security analyses.",
      "ja": "MLSのセキュリティ目標は[MLS-ARCH]で説明されています。ここでは、プロトコルがその目標をどのように達成するかを高レベルで説明しますが、完全なセキュリティ分析はこの文書の範囲外です。[MLS-ARCH]のセキュリティに関する考慮事項セクションには、詳細なセキュリティ分析への参照がいくつか提供されています。"
    },
    {
      "indent": 0,
      "text": "16.1. Transport Security",
      "section_title": true,
      "ja": "16.1. 輸送セキュリティ"
    },
    {
      "indent": 3,
      "text": "Because MLS messages are protected at the message level, the confidentiality and integrity of the group state do not depend on those messages being protected in transit. However, an attacker who can observe those messages in transit will be able to learn about the group state, including potentially the group membership (see Section 16.4.3 below). Such an attacker might also be able to mount denial-of-service attacks on the group or exclude new members by selectively removing messages in transit. In order to prevent this form of attack, it is RECOMMENDED that all MLS messages be carried over a secure transport such as TLS [RFC8446] or QUIC [RFC9000].",
      "ja": "MLSメッセージはメッセージレベルで保護されているため、グループ状態の機密性と整合性は、それらのメッセージが転送中に保護されているかどうかに依存しません。ただし、転送中にこれらのメッセージを観察できる攻撃者は、グループ状態について学習することができ、可能性としてはグループメンバーシップも含まれます（以下のセクション16.4.3を参照）。このような攻撃者は、転送中のメッセージを選択的に削除することで、グループに対するサービス拒否攻撃を行ったり、新しいメンバーを除外したりすることができるかもしれません。この種の攻撃を防ぐためには、すべてのMLSメッセージがTLS[RFC8446]やQUIC[RFC9000]などの安全な輸送手段を介して運ばれることが推奨されています。"
    },
    {
      "indent": 0,
      "text": "16.2. Confidentiality of Group Secrets",
      "section_title": true,
      "ja": "16.2. グループの秘密の機密保持"
    },
    {
      "indent": 3,
      "text": "Group secrets are partly derived from the output of a ratchet tree. Ratchet trees work by assigning each member of the group to a leaf in the tree and maintaining the following property: the private key of a node in the tree is known only to members of the group that are assigned a leaf in the node's subtree. This is called the _tree invariant_, and it makes it possible to encrypt to all group members except one, with a number of ciphertexts that is logarithmic in the number of group members.",
      "ja": "グループの秘密は、ラチェットツリーの出力から一部派生しています。ラチェットツリーは、グループの各メンバーをツリー内の葉に割り当て、次の特性を維持することで機能します：ツリー内のノードの秘密鍵は、そのノードの部分木に割り当てられたグループのメンバーだけが知っています。これを「ツリー不変条件」と呼び、グループメンバーを除くすべてのメンバーに対して暗号化することが可能になります。暗号文の数は、グループメンバーの数の対数になります。"
    },
    {
      "indent": 3,
      "text": "The ability to efficiently encrypt to all members except one allows members to be securely removed from a group. It also allows a member to rotate their key pair such that the old private key can no longer be used to decrypt new messages.",
      "ja": "一人を除いて全員に効率的に暗号化する能力は、メンバーをグループから安全に削除することを可能にします。また、メンバーは古い秘密鍵を使用して新しいメッセージを復号化することができなくなるように、自分の鍵ペアを回転させることも可能です。"
    },
    {
      "indent": 0,
      "text": "16.3. Confidentiality of Sender Data",
      "section_title": true,
      "ja": "16.3. 送信者データの機密保持"
    },
    {
      "indent": 3,
      "text": "The PrivateMessage framing encrypts \"sender data\" that identifies which group member sent an encrypted message, as described in Section 6.3.2. As with the QUIC header protection scheme [RFC9001], Section 5.4, this scheme is a variant of the HN1 construction analyzed in [NAN]. A sample of the ciphertext is combined with a sender_data_secret to derive a key and nonce that are used for AEAD encryption of the sender data.",
      "ja": "PrivateMessage フレーミングは、暗号化されたメッセージを送信したグループメンバーを識別する「送信者データ」を暗号化します。これは、セクション6.3.2で説明されています。QUIC ヘッダー保護スキーム[RFC9001]、セクション5.4と同様に、このスキームは[NAN]で分析された HN1 構築の変種です。暗号文のサンプルは sender_data_secret と組み合わされ、送信者データの AEAD 暗号化に使用される鍵とノンスが導出されます。"
    },
    {
      "indent": 3,
      "text": "(key, nonce) = PRF(sender_data_secret, sample)\nencrypted_sender_data =\n  AEAD.Seal(key, nonce, sender_data_aad, sender_data)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The only differences between this construction and HN1 as described in [NAN] are that it (1) uses authenticated encryption instead of unauthenticated encryption and (2) protects information used to derive a nonce instead of the nonce itself.",
      "ja": "この構築と[NAN]で説明されているHN1との唯一の違いは、(1) 認証付き暗号化を使用する点と、(2) ノンスそのものではなく、ノンスを導出するために使用される情報を保護する点です。"
    },
    {
      "indent": 3,
      "text": "Since the sender_data_secret is distinct from the content encryption key, it follows that the sender data encryption scheme achieves AE2 security as defined in [NAN], and therefore guarantees the confidentiality of the sender data.",
      "ja": "送信者データシークレットはコンテンツ暗号化キーとは異なるため、送信者データ暗号化スキームは[NAN]で定義されたAE2セキュリティを達成し、したがって送信者データの機密性を保証します。"
    },
    {
      "indent": 3,
      "text": "Use of the same sender_data_secret and ciphertext sample more than once risks compromising sender data protection by reusing an AEAD (key, nonce) pair. For example, in many AEAD schemes, reusing a key and nonce reveals the exclusive OR of the two plaintexts. Assuming the ciphertext output of the AEAD algorithm is indistinguishable from random data (i.e., the AEAD is AE1-secure in the phrasing of [NAN]), the odds of two ciphertext samples being identical is roughly 2^(-L/2), i.e., the birthday bound.",
      "ja": "同じsender_data_secretとciphertextサンプルを複数回使用すると、AEAD（鍵、ノンス）ペアを再利用することでsenderデータの保護が危険にさらされる可能性があります。たとえば、多くのAEADスキームでは、鍵とノンスを再利用すると、2つの平文の排他的論理和が明らかになります。AEADアルゴリズムの暗号文出力がランダムデータと区別できないと仮定すると（つまり、AEADが[NAN]の表現でAE1-secureであるとする）、2つの暗号文サンプルが同一である確率はおおよそ2^(-L/2)、つまり、誕生日攻撃の限界です。"
    },
    {
      "indent": 3,
      "text": "The AEAD algorithms for cipher suites defined in this document all provide this property. The size of the sample depends on the cipher suite's hash function, but in all cases, the probability of collision is no more than 2^-128. Any future cipher suite MUST use an AE1-secure AEAD algorithm.",
      "ja": "この文書で定義された暗号スイートのAEADアルゴリズムはすべてこの特性を提供します。サンプルのサイズは暗号スイートのハッシュ関数に依存しますが、いずれの場合も衝突の確率は2^-128を超えません。将来の暗号スイートはすべてAE1-secure AEADアルゴリズムを使用しなければなりません。"
    },
    {
      "indent": 0,
      "text": "16.4. Confidentiality of Group Metadata",
      "section_title": true,
      "ja": "16.4. グループメタデータの機密保持"
    },
    {
      "indent": 3,
      "text": "MLS does not provide confidentiality protection to some messages and fields within messages:",
      "ja": "MLSは、一部のメッセージやメッセージ内のフィールドに機密保護を提供しません。"
    },
    {
      "indent": 6,
      "text": "* KeyPackage messages",
      "ja": "* キーパッケージメッセージ"
    },
    {
      "indent": 6,
      "text": "* GroupInfo messages",
      "ja": "* グループ情報メッセージ"
    },
    {
      "indent": 6,
      "text": "* The unencrypted portion of a Welcome message",
      "ja": "* ウェルカムメッセージの暗号化されていない部分"
    },
    {
      "indent": 6,
      "text": "* Any Proposal or Commit messages sent as PublicMessage messages",
      "ja": "* 公開メッセージとして送信された提案またはコミットメッセージ"
    },
    {
      "indent": 6,
      "text": "* The unencrypted header fields in PrivateMessage messages",
      "ja": "* PrivateMessage メッセージ内の暗号化されていないヘッダーフィールド"
    },
    {
      "indent": 6,
      "text": "* The lengths of encrypted Welcome and PrivateMessage messages",
      "ja": "* 暗号化された「Welcome」と「PrivateMessage」メッセージの長さ"
    },
    {
      "indent": 3,
      "text": "The only mechanism MLS provides for confidentially distributing a group's ratchet tree to new members is to send it in a Welcome message as a ratchet_tree extension. If an application distributes the tree in some other way, its security will depend on that application mechanism.",
      "ja": "MLSが新しいメンバーにグループのラチェットツリーを機密に配布する唯一のメカニズムは、それをラチェットツリー拡張としてウェルカムメッセージで送信することです。アプリケーションが他の方法でツリーを配布する場合、そのセキュリティはそのアプリケーションのメカニズムに依存します。"
    },
    {
      "indent": 3,
      "text": "A party observing these fields might be able to infer certain properties of the group:",
      "ja": "これらの分野を観察するパーティーは、グループの特定の特性を推測することができるかもしれません："
    },
    {
      "indent": 6,
      "text": "* Group ID",
      "ja": "* グループID"
    },
    {
      "indent": 6,
      "text": "* Current epoch and frequency of epoch changes",
      "ja": "* 現在のエポックとエポック変更の頻度"
    },
    {
      "indent": 6,
      "text": "* Frequency of messages within an epoch",
      "ja": "* エポック内のメッセージの頻度"
    },
    {
      "indent": 6,
      "text": "* Group extensions",
      "ja": "* グループ拡張"
    },
    {
      "indent": 6,
      "text": "* Group membership",
      "ja": "* グループメンバーシップ"
    },
    {
      "indent": 3,
      "text": "The amount of metadata exposed to parties outside the group, and thus the ability of these parties to infer the group's properties, depends on several aspects of the DS design, such as:",
      "ja": "グループ外の関係者に露出されるメタデータの量、そしてこれらの関係者がグループの特性を推測する能力は、DSデザインのいくつかの側面に依存します。"
    },
    {
      "indent": 6,
      "text": "* How KeyPackages are distributed",
      "ja": "* KeyPackagesの配布方法"
    },
    {
      "indent": 6,
      "text": "* How the ratchet tree is distributed",
      "ja": "* ラチェットツリーはどのように分布していますか。"
    },
    {
      "indent": 6,
      "text": "* How prospective external joiners get a GroupInfo object for the group",
      "ja": "* 見込みのある外部参加者がグループのGroupInfoオブジェクトを取得する方法"
    },
    {
      "indent": 6,
      "text": "* Whether Proposal and Commit messages are sent as PublicMessage or PrivateMessage",
      "ja": "* 提案とコミットメッセージがPublicMessageまたはPrivateMessageとして送信されるかどうか"
    },
    {
      "indent": 3,
      "text": "In the remainder of this section, we note the ways that the above properties of the group are reflected in unprotected group messages, as a guide to understanding how they might be exposed or protected in a given application.",
      "ja": "このセクションの残りの部分では、未保護のグループメッセージにおいて、グループの上記の特性がどのように反映されるかを指摘し、それが特定のアプリケーションでどのように露出されるか、または保護されるかを理解するためのガイドとして示します。"
    },
    {
      "indent": 0,
      "text": "16.4.1. GroupID, Epoch, and Message Frequency",
      "section_title": true,
      "ja": "16.4.1. GroupID、Epoch、およびメッセージ頻度"
    },
    {
      "indent": 3,
      "text": "MLS provides no mechanism to protect the group ID and epoch of a message from the DS, so the group ID and the frequency of messages and epoch changes are not protected against inspection by the DS. However, any modifications to these will cause decryption failure.",
      "ja": "MLSは、メッセージのグループIDとエポックをDSから保護するメカニズムを提供していませんので、グループIDやメッセージの頻度、エポックの変更はDSによる検査から保護されていません。ただし、これらに対する変更は復号化の失敗を引き起こします。"
    },
    {
      "indent": 0,
      "text": "16.4.2. Group Extensions",
      "section_title": true,
      "ja": "16.4.2. グループ拡張"
    },
    {
      "indent": 3,
      "text": "A group's extensions are first set by the group's creator and then updated by GroupContextExtensions proposals. A GroupContextExtensions proposal sent as a PublicMessage leaks the group's extensions.",
      "ja": "グループの拡張機能は、まずグループの作成者によって設定され、その後、GroupContextExtensionsの提案によって更新されます。 PublicMessageとして送信されたGroupContextExtensionsの提案は、グループの拡張機能を漏洩させます。"
    },
    {
      "indent": 3,
      "text": "A new member learns the group's extensions via a GroupInfo object. When the new member joins via a Welcome message, the Welcome message's encryption protects the GroupInfo message. When the new member joins via an external join, they must be provided with a GroupInfo object. Protection of this GroupInfo object is up to the application -- if it is transmitted over a channel that is not confidential to the group and the new joiner, then it will leak the group's extensions.",
      "ja": "新しいメンバーは、GroupInfoオブジェクトを介してグループの拡張機能を学びます。新しいメンバーがウェルカムメッセージを介して参加するとき、ウェルカムメッセージの暗号化がGroupInfoメッセージを保護します。新しいメンバーが外部参加を通じて参加する場合、GroupInfoオブジェクトが提供される必要があります。このGroupInfoオブジェクトの保護はアプリケーションに委ねられています。もし、それがグループや新規参加者にとって機密性のないチャンネルを介して送信された場合、グループの拡張機能が漏洩します。"
    },
    {
      "indent": 0,
      "text": "16.4.3. Group Membership",
      "section_title": true,
      "ja": "16.4.3. グループメンバーシップ"
    },
    {
      "indent": 3,
      "text": "The group's membership is represented directly by its ratchet tree, since each member's LeafNode contains members' cryptographic keys, a credential that contains information about the member's identity, and possibly other identifiers. Applications that expose the group's ratchet tree outside the group also leak the group's membership.",
      "ja": "グループのメンバーシップは、それぞれのメンバーのLeafNodeにメンバーの暗号鍵、メンバーの身元に関する情報を含む資格情報、および他の識別子が含まれているため、直接グループのラチェットツリーによって表されます。グループのラチェットツリーをグループ外に公開するアプリケーションは、グループのメンバーシップも漏洩させます。"
    },
    {
      "indent": 3,
      "text": "Changes to the group's membership are made by means of Add and Remove proposals. If these proposals are sent as PublicMessage, then information will be leaked about the corresponding changes to the group's membership. A party that sees all of these changes can reconstruct the group membership.",
      "ja": "グループのメンバーシップの変更は、追加と削除の提案によって行われます。これらの提案がPublicMessageとして送信された場合、グループのメンバーシップに関する対応する変更について情報が漏洩します。これらの変更をすべて見ることができる者は、グループのメンバーシップを再構築することができます。"
    },
    {
      "indent": 3,
      "text": "Welcome messages contain a hash of each KeyPackage for which the Welcome message is encrypted. If a party has access to a pool of KeyPackages and observes a Welcome message, then they can identify the KeyPackage representing the new member. If the party can also associate the Welcome with a group, then the party can infer that the identified new member was added to that group.",
      "ja": "ウェルカムメッセージには、そのウェルカムメッセージが暗号化されている各KeyPackageのハッシュが含まれています。ある当事者がKeyPackagesのプールにアクセスし、ウェルカムメッセージを観察した場合、その当事者は新メンバーを表すKeyPackageを特定することができます。当事者がウェルカムメッセージをグループに関連付けることもできる場合、当事者は特定された新メンバーがそのグループに追加されたことを推測することができます。"
    },
    {
      "indent": 3,
      "text": "Note that these information leaks reveal the group's membership only to the degree that membership is revealed by the contents of a member's LeafNode in the ratchet tree. In some cases, this may be quite direct, e.g., due to credentials attesting to identifiers such as email addresses. An application could construct a member's leaf node to be less identifying, e.g., by using a pseudonymous credential and frequently rotating encryption and signature keys.",
      "ja": "これらの情報漏洩は、メンバーシップがラチェットツリーのメンバーのLeafNodeの内容によって明らかにされる程度にのみ、グループのメンバーシップを明らかにします。場合によっては、これはかなり直接的なものである可能性があります。たとえば、電子メールアドレスなどの識別子を証明する資格情報によるものです。アプリケーションは、メンバーのリーフノードを識別しにくくするように構築することができます。たとえば、匿名の資格情報を使用し、暗号化キーと署名キーを頻繁にローテーションさせることで。"
    },
    {
      "indent": 0,
      "text": "16.5. Authentication",
      "section_title": true,
      "ja": "16.5. 認証"
    },
    {
      "indent": 3,
      "text": "The first form of authentication we provide is that group members can verify a message originated from one of the members of the group. For encrypted messages, this is guaranteed because messages are encrypted with an AEAD under a key derived from the group secrets. For plaintext messages, this is guaranteed by the use of a membership_tag, which constitutes a MAC over the message, under a key derived from the group secrets.",
      "ja": "私たちが提供する最初の認証形式は、グループメンバーがメッセージがグループのメンバーの1人から発信されたことを確認できることです。暗号化されたメッセージの場合、これはメッセージがグループの秘密から派生したキーでAEADで暗号化されているため保証されます。平文のメッセージの場合、これはグループの秘密から派生したキーでメッセージ上のMACを構成するmembership_tagの使用によって保証されます。"
    },
    {
      "indent": 3,
      "text": "The second form of authentication is that group members can verify a message originated from a particular member of the group. This is guaranteed by a digital signature on each message from the sender's signature key.",
      "ja": "第二の認証形式は、グループメンバーが特定のグループメンバーから発信されたメッセージを検証できることです。これは、送信者の署名キーによる各メッセージのデジタル署名によって保証されます。"
    },
    {
      "indent": 3,
      "text": "The signature keys held by group members are critical to the security of MLS against active attacks. If a member's signature key is compromised, then an attacker can create LeafNodes and KeyPackages impersonating the member; depending on the application, this can then allow the attacker to join the group with the compromised member's identity. For example, if a group has enabled external parties to join via external commits, then an attacker that has compromised a member's signature key could use an external Commit to insert themselves into the group -- even using a \"resync\"-style external Commit to replace the compromised member in the group.",
      "ja": "グループメンバーが保持する署名キーは、アクティブ攻撃に対するMLSのセキュリティにとって重要です。メンバーの署名キーが危険にさらされると、攻撃者はメンバーをなりすましてLeafNodesやKeyPackagesを作成することができます。アプリケーションによっては、これにより攻撃者が危険にさらされたメンバーの身元でグループに参加することが可能になります。たとえば、外部の当事者が外部のコミットを介して参加できるようにしたグループの場合、メンバーの署名キーが危険にさらされた攻撃者は、外部コミットを使用してグループに自分自身を挿入することができます。さらに、危険にさらされたメンバーをグループから取り除くために「resync」スタイルの外部コミットを使用することも可能です。"
    },
    {
      "indent": 3,
      "text": "Applications can mitigate the risks of signature key compromise using pre-shared keys. If a group requires joiners to know a PSK in addition to authenticating with a credential, then in order to mount an impersonation attack, the attacker would need to compromise the relevant PSK as well as the victim's signature key. The cost of this mitigation is that the application needs some external arrangement that ensures that the legitimate members of the group have the required PSKs.",
      "ja": "アプリケーションは、事前共有キーを使用して署名キーの危険を軽減することができます。グループが参加者に、資格情報での認証に加えてPSKを知っている必要がある場合、なりすまし攻撃を行うためには、攻撃者は被害者の署名キーだけでなく関連するPSKも妥協する必要があります。この軽減のコストは、アプリケーションが、グループの正規メンバーが必要なPSKを持っていることを確認する外部の手配が必要であるということです。"
    },
    {
      "indent": 0,
      "text": "16.6. Forward Secrecy and Post-Compromise Security",
      "section_title": true,
      "ja": "16.6. Forward SecrecyとPost-Compromise Security"
    },
    {
      "indent": 3,
      "text": "Forward secrecy and post-compromise security are important security notions for long-lived MLS groups. Forward secrecy means that messages sent at a certain point in time are secure in the face of later compromise of a group member. Post-compromise security means that messages are secure even if a group member was compromised at some point in the past.",
      "ja": "フォワードセクレシーとポストコンプロマイズセキュリティは、長期間存続するMLSグループにとって重要なセキュリティ概念です。フォワードセクレシーとは、ある時点で送信されたメッセージが後にグループメンバーが妥協された場合でも安全であることを意味します。ポストコンプロマイズセキュリティとは、過去のある時点でグループメンバーが妥協された場合でもメッセージが安全であることを意味します。"
    },
    {
      "indent": 3,
      "text": "                   Compromise\n                       |\n                       |\n                  |    V    |\n------------------|---------|------------------------->\n                  |         |                     Time\n<-----------------|         |---------------->\n  Forward Secrecy |         | Post-Compromise\n                  |         |   Security",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Figure 29: Forward Secrecy and Post-Compromise Security",
      "ja": "図29：フォワードセクレシーとポストコンプロマイズセキュリティ"
    },
    {
      "indent": 3,
      "text": "Post-compromise security is provided between epochs by members regularly updating their leaf key in the ratchet tree. Updating their leaf key prevents group secrets from continuing to be encrypted to public keys whose private keys had previously been compromised. Note that sending an Update proposal does not achieve PCS until another member includes it in a Commit. Members can achieve immediate PCS by sending their own Commit and populating the path field, as described in Section 12.4. To be clear, in all these cases, the PCS guarantees come into effect when the members of the group process the relevant Commit, not when the sender creates it.",
      "ja": "エポック間に提供される妥協後のセキュリティは、メンバーがラチェットツリー内のリーフキーを定期的に更新することによって提供されます。リーフキーを更新することで、以前に秘密鍵が侵害された公開鍵に対してグループの秘密が引き続き暗号化されるのを防ぎます。Update提案を送信しても、他のメンバーがそれをCommitに含めるまでPCSは達成されません。メンバーは、セクション12.4で説明されているように、自分自身のCommitを送信し、パスフィールドを埋めることで即時のPCSを達成できます。これらすべての場合において、PCSの保証は、送信者がそれを作成するときではなく、グループのメンバーが関連するCommitを処理するときに発効します。"
    },
    {
      "indent": 3,
      "text": "Forward secrecy between epochs is provided by deleting private keys from past versions of the ratchet tree, as this prevents old group secrets from being re-derived. Forward secrecy _within_ an epoch is provided by deleting message encryption keys once they've been used to encrypt or decrypt a message. Note that group secrets and message encryption keys are shared by the group. There is thus a risk to forward secrecy as long as any member has not deleted these keys. This is a particular risk if a member is offline for a long period of time. Applications SHOULD have mechanisms for evicting group members that are offline for too long (i.e., have not changed their key within some period).",
      "ja": "エポック間のフォワードセクリシーは、ラチェットツリーの過去のバージョンからプライベートキーを削除することによって提供されます。これにより、古いグループシークレットが再派生されるのを防ぎます。エポック内のフォワードセクリシーは、メッセージの暗号化キーがメッセージの暗号化または復号に使用された後に削除されることで提供されます。グループシークレットとメッセージの暗号化キーはグループで共有されていることに注意してください。したがって、メンバーがこれらのキーを削除していない限り、フォワードセクリシーにリスクがあります。メンバーが長期間オフラインの場合、特にリスクがあります。アプリケーションは、長期間オフラインのグループメンバーを排除するメカニズムを持つべきです（つまり、一定期間内にキーを変更していないメンバー）。"
    },
    {
      "indent": 3,
      "text": "New groups are also at risk of using previously compromised keys (as with post-compromise security) if a member is added to a new group via an old KeyPackage whose corresponding private key has been compromised. This risk can be mitigated by having clients regularly generate new KeyPackages and upload them to the Delivery Service. This way, the key material used to add a member to a new group is more likely to be fresh and less likely to be compromised.",
      "ja": "新しいグループも以前に侵害されたキーを使用するリスクにさらされています（ポスト侵害セキュリティの場合と同様）、古いKeyPackageを介して新しいグループにメンバーが追加された場合、対応する秘密鍵が侵害されている可能性があります。このリスクは、クライアントが定期的に新しいKeyPackageを生成し、それらを配信サービスにアップロードすることで軽減できます。これにより、新しいグループにメンバーを追加するために使用される鍵素材が新鮮であり、侵害される可能性が低くなります。"
    },
    {
      "indent": 0,
      "text": "16.7. Uniqueness of Ratchet Tree Key Pairs",
      "section_title": true,
      "ja": "16.7. ラチェットツリーキーペアの独自性"
    },
    {
      "indent": 3,
      "text": "The encryption and signature keys stored in the encryption_key and signature_key fields of ratchet tree nodes MUST be distinct from one another. If two members' leaf nodes have the same signature key, for example, then the data origin authentication properties afforded by signatures within the group are degraded.",
      "ja": "暗号化キーと署名キーは、ラチェットツリーノードのencryption_keyフィールドとsignature_keyフィールドに格納されている必要があります。2人のメンバーのリーフノードが同じ署名キーを持っている場合、グループ内の署名によるデータの出所認証の特性が低下しますので、これらのキーは互いに異なる必要があります。"
    },
    {
      "indent": 3,
      "text": "Uniqueness of keys in leaf nodes is assured by explicitly checking each leaf node as it is added to the tree, whether in an Add proposal, in an Update proposal, or in the path field of a Commit. Details can be found in Sections 7.3, 12.2, and 12.4.2. Uniqueness of encryption keys in parent nodes is assured by checking that the keys in an UpdatePath are not found elsewhere in the tree (see Section 12.4.2).",
      "ja": "葉ノードのキーの一意性は、ツリーに追加される際に各葉ノードを明示的にチェックすることによって保証されます。これは、Add提案、Update提案、またはCommitのパスフィールドで行われます。詳細は、セクション7.3、12.2、および12.4.2に記載されています。親ノードの暗号化キーの一意性は、UpdatePath内のキーがツリーの他の場所に存在しないことを確認することによって保証されます（セクション12.4.2を参照）。"
    },
    {
      "indent": 0,
      "text": "16.8. KeyPackage Reuse",
      "section_title": true,
      "ja": "16.8. キーパッケージ再利用"
    },
    {
      "indent": 3,
      "text": "KeyPackages are intended to be used only once. That is, once a KeyPackage has been used to introduce the corresponding client to a group, it SHOULD be deleted from the KeyPackage publication system. Reuse of KeyPackages can lead to replay attacks.",
      "ja": "KeyPackagesは一度だけ使用することを意図しています。つまり、KeyPackageが対応するクライアントをグループに紹介するために使用された後は、KeyPackageの公開システムから削除されるべきです。KeyPackagesの再利用はリプレイ攻撃を引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "An application MAY allow for reuse of a \"last resort\" KeyPackage in order to prevent denial-of-service attacks. Since a KeyPackage is needed to add a client to a new group, an attacker could prevent a client from being added to new groups by exhausting all available KeyPackages. To prevent such a denial-of-service attack, the KeyPackage publication system SHOULD rate-limit KeyPackage requests, especially if not authenticated.",
      "ja": "アプリケーションは、サービス拒否攻撃を防ぐために、「最終手段」としてのKeyPackageの再利用を許可する場合があります。KeyPackageは新しいグループにクライアントを追加するために必要ですので、攻撃者は利用可能なすべてのKeyPackageを使い果たすことで、クライアントが新しいグループに追加されるのを防ぐことができます。このようなサービス拒否攻撃を防ぐために、KeyPackageの公開システムは、特に認証されていない場合にはKeyPackageのリクエストをレート制限すべきです。"
    },
    {
      "indent": 0,
      "text": "16.9. Delivery Service Compromise",
      "section_title": true,
      "ja": "16.9. 配達サービスの妥協"
    },
    {
      "indent": 3,
      "text": "MLS is designed to protect the confidentiality and integrity of the group data even in the face of a compromised DS. However, a compromised DS can still mount some attacks. While it cannot forge messages, it can selectively delay or remove them. In some cases, this can be observed by detecting gaps in the per-sender generation counter, though it may not always be possible to distinguish an attack from message loss. In addition, the DS can permanently block messages to and from a group member. This will not always be detectable by other members. If an application uses the DS to resolve conflicts between simultaneous Commits (see Section 14), it is also possible for the DS to influence which Commit is applied, even to the point of preventing a member from ever having its Commits applied.",
      "ja": "MLSは、犠牲になったDSの状況でも、グループデータの機密性と整合性を保護するように設計されています。ただし、犠牲になったDSはいくつかの攻撃を行うことができます。メッセージを偽造することはできませんが、選択的に遅延させたり削除したりすることができます。一部の場合、これは送信者ごとの生成カウンターにギャップを検出することで観察されるかもしれませんが、攻撃とメッセージの損失を区別することが常に可能とは限りません。さらに、DSはグループメンバー間のメッセージの送受信を永久的にブロックすることができます。これは他のメンバーには常に検出可能とは限りません。アプリケーションが同時に行われるコミットの競合を解決するためにDSを使用する場合（セクション14を参照）、DSが適用されるコミットを影響する可能性があり、メンバーがそのコミットが適用されないようにすることさえ可能です。"
    },
    {
      "indent": 3,
      "text": "When put together, these abilities potentially allow a DS to collude with an attacker who has compromised a member's state to defeat PCS by suppressing the valid Update and Commit messages from the member that would lock out the attacker and update the member's leaf to a new, uncompromised state. Aside from the SenderData.generation value, MLS leaves loss detection up to the application.",
      "ja": "これらの能力を組み合わせると、DSは、メンバーの状態を侵害した攻撃者と共謀して、有効な更新およびコミットメッセージを抑制し、攻撃者を排除し、メンバーのリーフを新しい、侵害されていない状態に更新することでPCSを打ち負かす可能性があります。SenderData.generation値以外に、MLSは損失検出をアプリケーションに任せています。"
    },
    {
      "indent": 0,
      "text": "16.10. Authentication Service Compromise",
      "section_title": true,
      "ja": "16.10. 認証サービスの侵害"
    },
    {
      "indent": 3,
      "text": "Authentication Service compromise is much more serious than compromise of the Delivery Service. A compromised AS can assert a binding for a signature key and identity pair of its choice, thus allowing impersonation of a given user. This ability is sufficient to allow the AS to join new groups as if it were that user. Depending on the application architecture, it may also be sufficient to allow the compromised AS to join the group as an existing user, for instance, as if it were a new device associated with the same user. If the application uses a transparency mechanism such as CONIKS [CONIKS] or Key Transparency [KT], then it may be possible for end users to detect this kind of misbehavior by the AS. It is also possible to construct schemes in which the various clients owned by a user vouch for each other, e.g., by signing each others' keys.",
      "ja": "認証サービスの侵害は、配信サービスの侵害よりもはるかに深刻です。侵害された認証サービスは、自分の選択した署名キーとアイデンティティのペアに対するバインディングを主張することができ、したがって特定のユーザーのなりすましを許可します。この能力は、認証サービスがそのユーザーであるかのように新しいグループに参加することを可能にします。アプリケーションのアーキテクチャによっては、侵害された認証サービスが既存のユーザーとしてグループに参加することも可能であり、たとえば、同じユーザーに関連付けられた新しいデバイスであるかのようになります。アプリケーションがCONIKSやKey Transparencyなどの透明性メカニズムを使用している場合、エンドユーザーがこの種の認証サービスの不正行為を検出することが可能かもしれません。また、各ユーザーがお互いのキーに署名することによって、ユーザーが所有するさまざまなクライアントがお互いを保証するスキームを構築することも可能です。"
    },
    {
      "indent": 0,
      "text": "16.11. Additional Policy Enforcement",
      "section_title": true,
      "ja": "16.11. 追加のポリシー執行"
    },
    {
      "indent": 3,
      "text": "The DS and AS may also apply additional policies to MLS operations to obtain additional security properties. For example, MLS enables any participant to add or remove members of a group; a DS could enforce a policy that only certain members are allowed to perform these operations. MLS authenticates all members of a group; a DS could help ensure that only clients with certain types of credentials are admitted. MLS provides no inherent protection against denial of service; a DS could also enforce rate limits in order to mitigate these risks.",
      "ja": "DSおよびASは、追加のセキュリティプロパティを取得するためにMLS操作に追加のポリシーを適用することもできます。たとえば、MLSは任意の参加者がグループのメンバーを追加または削除できるようにしますが、DSは特定のメンバーのみがこれらの操作を実行できるようにポリシーを強制することができます。MLSはグループのすべてのメンバーを認証しますが、DSは特定の資格情報を持つクライアントのみが認められるようにするのを支援できます。MLSはサービス拒否に対して固有の保護を提供しませんが、DSはこれらのリスクを緩和するためにレート制限を強制することもできます。"
    },
    {
      "indent": 0,
      "text": "16.12. Group Fragmentation by Malicious Insiders",
      "section_title": true,
      "ja": "16.12. 悪意のある内部者によるグループの分裂"
    },
    {
      "indent": 3,
      "text": "It is possible for a malicious member of a group to \"fragment\" the group by crafting an invalid UpdatePath. Recall that an UpdatePath encrypts a sequence of path secrets to different subtrees of the group's ratchet trees. These path secrets should be derived in a sequence as described in Section 7.4, but the UpdatePath syntax allows the sender to encrypt arbitrary, unrelated secrets. The syntax also does not guarantee that the encrypted path secret for a given node corresponds to the public key provided for that node.",
      "ja": "グループの悪意のあるメンバーが無効なUpdatePathを作成することで、グループを「分断」することが可能です。 UpdatePathは、グループのラチェットツリーの異なるサブツリーへのパスシークレットのシーケンスを暗号化します。 これらのパスシークレットは、セクション7.4で説明されているようにシーケンスで派生するべきですが、UpdatePathの構文では送信者が任意の関連のないシークレットを暗号化することができます。 また、構文は、特定のノードに対応する暗号化されたパスシークレットがそのノードに提供された公開鍵と一致することを保証しません。"
    },
    {
      "indent": 3,
      "text": "Both of these types of corruption will cause processing of a Commit to fail for some members of the group. If the public key for a node does not match the path secret, then the members that decrypt that path secret will reject the Commit based on this mismatch. If the path secret sequence is incorrect at some point, then members that can decrypt nodes before that point will compute a different public key for the mismatched node than the one in the UpdatePath, which also causes the Commit to fail. Applications SHOULD provide mechanisms for failed commits to be reported, so that group members who were not able to recognize the error themselves can reinitialize the group if necessary.",
      "ja": "これらの種類の不正行為の両方が、グループの一部のメンバーに対して Commit の処理に失敗を引き起こします。ノードの公開鍵がパスシークレットと一致しない場合、そのパスシークレットを復号化するメンバーはこの不一致に基づいて Commit を拒否します。パスシークレットのシーケンスがある時点で正しくない場合、その時点より前のノードを復号化できるメンバーは、UpdatePath に含まれるものとは異なる公開鍵を不一致のノードに対して計算し、これも Commit の失敗を引き起こします。アプリケーションは、失敗した Commit を報告するためのメカニズムを提供すべきであり、自らエラーを認識できなかったグループメンバーが必要に応じてグループを再初期化できるようにすべきです。"
    },
    {
      "indent": 3,
      "text": "Even with such an error reporting mechanism in place, however, it is still possible for members to get locked out of the group by a malformed Commit. Since malformed Commits can only be recognized by certain members of the group, in an asynchronous application, it may be the case that all members that could detect a fault in a Commit are offline. In such a case, the Commit will be accepted by the group, and the resulting state will possibly be used as the basis for further Commits. When the affected members come back online, they will reject the first Commit, and thus be unable to catch up with the group. These members will need to either add themselves back with an external Commit or reinitialize the group from scratch.",
      "ja": "このようなエラー報告メカニズムがあるにもかかわらず、不正なコミットによってグループからロックアウトされる可能性があります。不正なコミットはグループの特定のメンバーにしか認識されないため、非同期アプリケーションでは、コミットの欠陥を検出できるメンバーがすべてオフラインの場合があります。そのような場合、グループはコミットを受け入れ、その結果の状態がさらなるコミットの基礎として使用される可能性があります。影響を受けたメンバーがオンラインに戻ったとき、最初のコミットを拒否し、グループに追いつくことができなくなります。これらのメンバーは、外部コミットで自分自身を追加するか、グループをゼロから再初期化する必要があります。"
    },
    {
      "indent": 3,
      "text": "Applications can address this risk by requiring certain members of the group to acknowledge successful processing of a Commit before the group regards the Commit as accepted. The minimum set of acknowledgements necessary to verify that a Commit is well-formed comprises an acknowledgement from one member per node in the UpdatePath, that is, one member from each subtree rooted in the copath node corresponding to the node in the UpdatePath. MLS does not provide a built-in mechanism for such acknowledgements, but they can be added at the application layer.",
      "ja": "アプリケーションは、グループがCommitを受け入れる前に、グループの特定のメンバーに成功した処理を認識させることで、このリスクに対処できます。Commitが適切に形成されていることを確認するために必要な最小限の認識セットは、UpdatePath内の各ノードに対応するcopathノードにルートを持つ各サブツリーから1人のメンバーの認識を含みます。MLSはこのような認識のための組み込みメカニズムを提供していませんが、アプリケーションレイヤーで追加することができます。"
    },
    {
      "indent": 0,
      "text": "17. IANA Considerations",
      "section_title": true,
      "ja": "17. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has created the following registries:",
      "ja": "IANAは以下の登録を作成しました："
    },
    {
      "indent": 6,
      "text": "* MLS Cipher Suites (Section 17.1)",
      "ja": "* MLS暗号スイート（セクション17.1）"
    },
    {
      "indent": 6,
      "text": "* MLS Wire Formats (Section 17.2)",
      "ja": "* MLSワイヤーフォーマット（セクション17.2）"
    },
    {
      "indent": 6,
      "text": "* MLS Extension Types (Section 17.3)",
      "ja": "* MLS拡張タイプ（セクション17.3）"
    },
    {
      "indent": 6,
      "text": "* MLS Proposal Types (Section 17.4)",
      "ja": "* MLS提案タイプ（セクション17.4）"
    },
    {
      "indent": 6,
      "text": "* MLS Credential Types (Section 17.5)",
      "ja": "* MLS資格の種類（セクション17.5）"
    },
    {
      "indent": 6,
      "text": "* MLS Signature Labels (Section 17.6)",
      "ja": "* MLS シグネチャ ラベル（セクション 17.6）"
    },
    {
      "indent": 6,
      "text": "* MLS Public Key Encryption Labels (Section 17.7)",
      "ja": "* MLS公開鍵暗号化ラベル（セクション17.7）"
    },
    {
      "indent": 6,
      "text": "* MLS Exporter Labels (Section 17.8)",
      "ja": "* MLSエクスポーターラベル（セクション17.8）"
    },
    {
      "indent": 3,
      "text": "All of these registries are under the \"Messaging Layer Security\" group registry heading, and assignments are made via the Specification Required policy [RFC8126]. See Section 17.9 for additional information about the MLS Designated Experts (DEs).",
      "ja": "これらのレジストリはすべて、「Messaging Layer Security」グループのレジストリ見出しの下にあり、割り当ては仕様に基づいて行われます[RFC8126]。MLS指定専門家（DEs）に関する追加情報については、セクション17.9を参照してください。"
    },
    {
      "indent": 0,
      "text": "17.1. MLS Cipher Suites",
      "section_title": true,
      "ja": "17.1. MLS 暗号スイート"
    },
    {
      "indent": 3,
      "text": "A cipher suite is a combination of a protocol version and the set of cryptographic algorithms that should be used.",
      "ja": "暗号スイートとは、使用すべきプロトコルバージョンと暗号アルゴリズムのセットの組み合わせです。"
    },
    {
      "indent": 3,
      "text": "Cipher suite names follow the naming convention:",
      "ja": "暗号スイートの名前は、命名規則に従います："
    },
    {
      "indent": 3,
      "text": "CipherSuite MLS_LVL_KEM_AEAD_HASH_SIG = VALUE;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where VALUE is represented as a 16-bit integer:",
      "ja": "VALUE が16ビット整数として表される場合:"
    },
    {
      "indent": 3,
      "text": "uint16 CipherSuite;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "+===========+==================================+\n| Component | Contents                         |\n+===========+==================================+\n| LVL       | The security level (in bits)     |\n+-----------+----------------------------------+\n| KEM       | The KEM algorithm used for HPKE  |\n|           | in ratchet tree operations       |\n+-----------+----------------------------------+\n| AEAD      | The AEAD algorithm used for HPKE |\n|           | and message protection           |\n+-----------+----------------------------------+\n| HASH      | The hash algorithm used for HPKE |\n|           | and the MLS transcript hash      |\n+-----------+----------------------------------+\n| SIG       | The signature algorithm used for |\n|           | message authentication           |\n+-----------+----------------------------------+\n\n                    Table 5",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The columns in the registry are as follows:",
      "ja": "登録簿の列は次のようになります："
    },
    {
      "indent": 6,
      "text": "* Value: The numeric value of the cipher suite",
      "ja": "* 値： 暗号スイートの数値値"
    },
    {
      "indent": 6,
      "text": "* Name: The name of the cipher suite",
      "ja": "* 名前： 暗号スイートの名前"
    },
    {
      "indent": 6,
      "text": "* Recommended: Whether support for this cipher suite is recommended by the IETF. Valid values are \"Y\", \"N\", and \"D\", as described below. The default value of the \"Recommended\" column is \"N\". Setting the Recommended item to \"Y\" or \"D\", or changing an item whose current value is \"Y\" or \"D\", requires Standards Action [RFC8126].",
      "ja": "* 推奨: この暗号スイートのサポートがIETFによって推奨されているかどうか。有効な値は、以下で説明されているように、\"Y\"、\"N\"、および\"D\"です。 \"Recommended\"列のデフォルト値は\"N\"です。 推奨されるアイテムを\"Y\"または\"D\"に設定するか、現在の値が\"Y\"または\"D\"であるアイテムを変更するには、標準アクション[RFC8126]が必要です。"
    },
    {
      "indent": 12,
      "text": "- Y: Indicates that the IETF has consensus that the item is RECOMMENDED. This only means that the associated mechanism is fit for the purpose for which it was defined. Careful reading of the documentation for the mechanism is necessary to understand the applicability of that mechanism. The IETF could recommend mechanisms that have limited applicability, but it will provide applicability statements that describe any limitations of the mechanism or necessary constraints on its use.",
      "ja": "- Y: IETFがそのアイテムを推奨しているということを示しています。これは、関連するメカニズムが定義された目的に適していることを意味します。メカニズムのドキュメントを注意深く読むことで、そのメカニズムの適用範囲を理解する必要があります。IETFは、適用範囲が限定されているメカニズムを推奨することがありますが、そのメカニズムの制約や使用上の必要条件を記述した適用性の文書を提供します。"
    },
    {
      "indent": 12,
      "text": "- N: Indicates that the item has not been evaluated by the IETF and that the IETF has made no statement about the suitability of the associated mechanism. This does not necessarily mean that the mechanism is flawed, only that no consensus exists. The IETF might have consensus to leave an item marked as \"N\" on the basis of it having limited applicability or usage constraints.",
      "ja": "- N: この項目はIETFによって評価されておらず、IETFが関連メカニズムの適合性について発言していないことを示しています。これは、メカニズムに欠陥があることを意味するわけではありません。ただし、合意がないということを示しています。IETFは、適用範囲が限られているか使用制約があるために、項目を「N」としてマークしたままにすることに合意している可能性があります。"
    },
    {
      "indent": 12,
      "text": "- D: Indicates that the item is discouraged and SHOULD NOT or MUST NOT be used. This marking could be used to identify mechanisms that might result in problems if they are used, such as a weak cryptographic algorithm or a mechanism that might cause interoperability problems in deployment.",
      "ja": "- D: このアイテムは非推奨であり、使用してはいけないか、使用してはいけないことを示しています。このマーキングは、使用すると問題が発生する可能性があるメカニズムを識別するために使用されることがあります。例えば、弱い暗号化アルゴリズムや、展開時に相互運用性の問題を引き起こす可能性があるメカニズムなどが該当します。"
    },
    {
      "indent": 6,
      "text": "* Reference: The document where this cipher suite is defined",
      "ja": "* 参照：この暗号スイートが定義されている文書"
    },
    {
      "indent": 3,
      "text": "Initial contents:",
      "ja": "初期内容:"
    },
    {
      "indent": 3,
      "text": "+========+===================================================+=+====+\n| Value  |Name                                               |R|Ref |\n+========+===================================================+=+====+\n| 0x0000 |RESERVED                                           |-|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0x0001 |MLS_128_DHKEMX25519_AES128GCM_SHA256_Ed25519       |Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0x0002 |MLS_128_DHKEMP256_AES128GCM_SHA256_P256            |Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0x0003 |MLS_128_DHKEMX25519_CHACHA20POLY1305_SHA256_Ed25519|Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0x0004 |MLS_256_DHKEMX448_AES256GCM_SHA512_Ed448           |Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0x0005 |MLS_256_DHKEMP521_AES256GCM_SHA512_P521            |Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0x0006 |MLS_256_DHKEMX448_CHACHA20POLY1305_SHA512_Ed448    |Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0x0007 |MLS_256_DHKEMP384_AES256GCM_SHA384_P384            |Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0x0A0A |GREASE                                             |Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0x1A1A |GREASE                                             |Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0x2A2A |GREASE                                             |Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0x3A3A |GREASE                                             |Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0x4A4A |GREASE                                             |Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0x5A5A |GREASE                                             |Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0x6A6A |GREASE                                             |Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0x7A7A |GREASE                                             |Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0x8A8A |GREASE                                             |Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0x9A9A |GREASE                                             |Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0xAAAA |GREASE                                             |Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0xBABA |GREASE                                             |Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0xCACA |GREASE                                             |Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0xDADA |GREASE                                             |Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0xEAEA |GREASE                                             |Y|RFC |\n|        |                                                   | |9420|\n+--------+---------------------------------------------------+-+----+\n| 0xF000 |Reserved for Private Use                           |-|RFC |\n| -      |                                                   | |9420|\n| 0xFFFF |                                                   | |    |\n+--------+---------------------------------------------------+-+----+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Table 6: MLS Extension Types Registry",
      "ja": "表6：MLS拡張タイプレジストリ"
    },
    {
      "indent": 3,
      "text": "All of the non-GREASE cipher suites use HMAC [RFC2104] as their MAC function, with different hashes per cipher suite. The mapping of cipher suites to HPKE primitives [RFC9180], HMAC hash functions, and TLS signature schemes [RFC8446] is as follows:",
      "ja": "非GREASE暗号スイートはすべて、それぞれの暗号スイートごとに異なるハッシュを使用してMAC関数としてHMAC [RFC2104] を使用します。暗号スイートとHPKEプリミティブ [RFC9180]、HMACハッシュ関数、およびTLS署名スキーム [RFC8446] のマッピングは次のとおりです："
    },
    {
      "indent": 2,
      "text": "+======+======+========+========+========+========================+\n|Value |KEM   | KDF    | AEAD   | Hash   | Signature              |\n+======+======+========+========+========+========================+\n|0x0001|0x0020| 0x0001 | 0x0001 | SHA256 | ed25519                |\n+------+------+--------+--------+--------+------------------------+\n|0x0002|0x0010| 0x0001 | 0x0001 | SHA256 | ecdsa_secp256r1_sha256 |\n+------+------+--------+--------+--------+------------------------+\n|0x0003|0x0020| 0x0001 | 0x0003 | SHA256 | ed25519                |\n+------+------+--------+--------+--------+------------------------+\n|0x0004|0x0021| 0x0003 | 0x0002 | SHA512 | ed448                  |\n+------+------+--------+--------+--------+------------------------+\n|0x0005|0x0012| 0x0003 | 0x0002 | SHA512 | ecdsa_secp521r1_sha512 |\n+------+------+--------+--------+--------+------------------------+\n|0x0006|0x0021| 0x0003 | 0x0003 | SHA512 | ed448                  |\n+------+------+--------+--------+--------+------------------------+\n|0x0007|0x0011| 0x0002 | 0x0002 | SHA384 | ecdsa_secp384r1_sha384 |\n+------+------+--------+--------+--------+------------------------+\n\n                              Table 7",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The hash used for the MLS transcript hash is the one referenced in the cipher suite name. In the cipher suites defined above, \"SHA256\", \"SHA384\", and \"SHA512\" refer, respectively, to the SHA-256, SHA-384, and SHA-512 functions defined in [SHS].",
      "ja": "MLSトランスクリプトハッシュに使用されるハッシュは、暗号スイート名で参照されるものです。上記で定義された暗号スイートでは、「SHA256」、「SHA384」、および「SHA512」は、それぞれ[SHS]で定義されたSHA-256、SHA-384、およびSHA-512関数を指します。"
    },
    {
      "indent": 3,
      "text": "In addition to the general requirements of Section 13.1, future cipher suites MUST meet the requirements of Section 16.3.",
      "ja": "セクション13.1の一般的な要件に加えて、将来の暗号スイートはセクション16.3の要件を満たさなければなりません。"
    },
    {
      "indent": 3,
      "text": "It is advisable to keep the number of cipher suites low to increase the likelihood that clients can interoperate in a federated environment. The cipher suites therefore include only modern, yet well-established algorithms. Depending on their requirements, clients can choose between two security levels (roughly 128-bit and 256-bit). Within the security levels, clients can choose between faster X25519/X448 curves and curves compliant with FIPS 140-2 for Diffie-Hellman key negotiations. Clients may also choose ChaCha20Poly1305 or AES-GCM, e.g., for performance reasons. Since ChaCha20Poly1305 is not listed by FIPS 140-2, it is not paired with curves compliant with FIPS 140-2. The security level of symmetric encryption algorithms and hash functions is paired with the security level of the curves.",
      "ja": "暗号スイートの数を少なく保つことが望ましいため、クライアントがフェデレーテッド環境で相互運用できる可能性を高めることができます。したがって、暗号スイートには、現代的でありながら確立されたアルゴリズムのみが含まれています。クライアントは、要件に応じて、2つのセキュリティレベル（おおよそ128ビットと256ビット）の間で選択できます。セキュリティレベル内で、クライアントは、より高速なX25519/X448曲線とDiffie-Hellman鍵交渉に準拠したFIPS 140-2に準拠した曲線の間で選択できます。クライアントは、パフォーマンスの理由などで、ChaCha20Poly1305またはAES-GCMを選択することもできます。ChaCha20Poly1305はFIPS 140-2にリストされていないため、FIPS 140-2に準拠した曲線とペアになっていません。対称暗号アルゴリズムとハッシュ関数のセキュリティレベルは、曲線のセキュリティレベルとペアになります。"
    },
    {
      "indent": 3,
      "text": "The mandatory-to-implement cipher suite for MLS 1.0 is MLS_128_DHKEMX25519_AES128GCM_SHA256_Ed25519, which uses Curve25519 for key exchange, AES-128-GCM for HPKE, HKDF over SHA2-256, and Ed25519 for signatures. MLS clients MUST implement this cipher suite.",
      "ja": "MLS 1.0の実装が必須となる暗号スイートは、MLS_128_DHKEMX25519_AES128GCM_SHA256_Ed25519です。この暗号スイートは、鍵交換にCurve25519、HPKEにAES-128-GCM、SHA2-256上のHKDF、署名にEd25519を使用しています。MLSクライアントは、この暗号スイートを実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "17.2. MLS Wire Formats",
      "section_title": true,
      "ja": "17.2. MLS ワイヤーフォーマット"
    },
    {
      "indent": 3,
      "text": "The \"MLS Wire Formats\" registry lists identifiers for the types of messages that can be sent in MLS. The wire format field is two bytes wide, so the valid wire format values are in the range 0x0000 to 0xFFFF.",
      "ja": "「MLS Wire Formats」レジストリには、MLSで送信できるメッセージの種類の識別子がリストされています。ワイヤーフォーマットフィールドは2バイト幅であり、有効なワイヤーフォーマットの値は0x0000から0xFFFFの範囲にあります。"
    },
    {
      "indent": 3,
      "text": "Template:",
      "ja": "テンプレート"
    },
    {
      "indent": 6,
      "text": "* Value: The numeric value of the wire format",
      "ja": "* 値：ワイヤーフォーマットの数値値"
    },
    {
      "indent": 6,
      "text": "* Name: The name of the wire format",
      "ja": "* 名前：ワイヤーフォーマットの名前"
    },
    {
      "indent": 6,
      "text": "* Recommended: Same as in Section 17.1",
      "ja": "* 推奨：セクション17.1と同じ"
    },
    {
      "indent": 6,
      "text": "* Reference: The document where this wire format is defined",
      "ja": "* 参照：このワイヤーフォーマットが定義されている文書"
    },
    {
      "indent": 3,
      "text": "Initial contents:",
      "ja": "最初の内容:"
    },
    {
      "indent": 7,
      "text": "+=================+==========================+===+==========+\n| Value           | Name                     | R | Ref      |\n+=================+==========================+===+==========+\n| 0x0000          | RESERVED                 | - | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0x0001          | mls_public_message       | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0x0002          | mls_private_message      | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0x0003          | mls_welcome              | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0x0004          | mls_group_info           | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0x0005          | mls_key_package          | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0xF000 - 0xFFFF | Reserved for Private Use | - | RFC 9420 |\n+-----------------+--------------------------+---+----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Table 8: MLS Wire Formats Registry",
      "ja": "表8：MLSワイヤーフォーマットレジストリ"
    },
    {
      "indent": 0,
      "text": "17.3. MLS Extension Types",
      "section_title": true,
      "ja": "17.3. MLS拡張タイプ"
    },
    {
      "indent": 3,
      "text": "The \"MLS Extension Types\" registry lists identifiers for extensions to the MLS protocol. The extension type field is two bytes wide, so valid extension type values are in the range 0x0000 to 0xFFFF.",
      "ja": "「MLS拡張タイプ」レジストリは、MLSプロトコルの拡張の識別子をリストアップしています。拡張タイプフィールドは2バイト幅であり、有効な拡張タイプの値は0x0000から0xFFFFの範囲内にあります。"
    },
    {
      "indent": 3,
      "text": "Template:",
      "ja": "テンプレート"
    },
    {
      "indent": 6,
      "text": "* Value: The numeric value of the extension type",
      "ja": "* 値：拡張タイプの数値値"
    },
    {
      "indent": 6,
      "text": "* Name: The name of the extension type",
      "ja": "* 名前：拡張子の種類"
    },
    {
      "indent": 6,
      "text": "* Message(s): The messages in which the extension may appear, drawn from the following list:",
      "ja": "* メッセージ：拡張機能が表示される可能性のあるメッセージは、以下のリストから抽出されます。"
    },
    {
      "indent": 12,
      "text": "- KP: KeyPackage objects",
      "ja": "- KP: KeyPackage オブジェクト"
    },
    {
      "indent": 12,
      "text": "- LN: LeafNode objects",
      "ja": "- LN: LeafNode オブジェクト"
    },
    {
      "indent": 12,
      "text": "- GC: GroupContext objects",
      "ja": "- GC：GroupContextオブジェクト"
    },
    {
      "indent": 12,
      "text": "- GI: GroupInfo objects",
      "ja": "- GI: グループ情報オブジェクト"
    },
    {
      "indent": 6,
      "text": "* Recommended: Same as in Section 17.1",
      "ja": "* 推奨：セクション17.1と同じ"
    },
    {
      "indent": 6,
      "text": "* Reference: The document where this extension is defined",
      "ja": "* 参照：この拡張機能が定義されている文書"
    },
    {
      "indent": 3,
      "text": "Initial contents:",
      "ja": "最初の内容:"
    },
    {
      "indent": 5,
      "text": "+==========+=======================+============+===+==========+\n| Value    | Name                  | Message(s) | R | Ref      |\n+==========+=======================+============+===+==========+\n| 0x0000   | RESERVED              | N/A        | - | RFC 9420 |\n+----------+-----------------------+------------+---+----------+\n| 0x0001   | application_id        | LN         | Y | RFC 9420 |\n+----------+-----------------------+------------+---+----------+\n| 0x0002   | ratchet_tree          | GI         | Y | RFC 9420 |\n+----------+-----------------------+------------+---+----------+\n| 0x0003   | required_capabilities | GC         | Y | RFC 9420 |\n+----------+-----------------------+------------+---+----------+\n| 0x0004   | external_pub          | GI         | Y | RFC 9420 |\n+----------+-----------------------+------------+---+----------+\n| 0x0005   | external_senders      | GC         | Y | RFC 9420 |\n+----------+-----------------------+------------+---+----------+\n| 0x0A0A   | GREASE                | KP, GI, LN | Y | RFC 9420 |\n+----------+-----------------------+------------+---+----------+\n| 0x1A1A   | GREASE                | KP, GI, LN | Y | RFC 9420 |\n+----------+-----------------------+------------+---+----------+\n| 0x2A2A   | GREASE                | KP, GI, LN | Y | RFC 9420 |\n+----------+-----------------------+------------+---+----------+\n| 0x3A3A   | GREASE                | KP, GI, LN | Y | RFC 9420 |\n+----------+-----------------------+------------+---+----------+\n| 0x4A4A   | GREASE                | KP, GI, LN | Y | RFC 9420 |\n+----------+-----------------------+------------+---+----------+\n| 0x5A5A   | GREASE                | KP, GI, LN | Y | RFC 9420 |\n+----------+-----------------------+------------+---+----------+\n| 0x6A6A   | GREASE                | KP, GI, LN | Y | RFC 9420 |\n+----------+-----------------------+------------+---+----------+\n| 0x7A7A   | GREASE                | KP, GI, LN | Y | RFC 9420 |\n+----------+-----------------------+------------+---+----------+\n| 0x8A8A   | GREASE                | KP, GI, LN | Y | RFC 9420 |\n+----------+-----------------------+------------+---+----------+\n| 0x9A9A   | GREASE                | KP, GI, LN | Y | RFC 9420 |\n+----------+-----------------------+------------+---+----------+\n| 0xAAAA   | GREASE                | KP, GI, LN | Y | RFC 9420 |\n+----------+-----------------------+------------+---+----------+\n| 0xBABA   | GREASE                | KP, GI, LN | Y | RFC 9420 |\n+----------+-----------------------+------------+---+----------+\n| 0xCACA   | GREASE                | KP, GI, LN | Y | RFC 9420 |\n+----------+-----------------------+------------+---+----------+\n| 0xDADA   | GREASE                | KP, GI, LN | Y | RFC 9420 |\n+----------+-----------------------+------------+---+----------+\n| 0xEAEA   | GREASE                | KP, GI, LN | Y | RFC 9420 |\n+----------+-----------------------+------------+---+----------+\n| 0xF000 - | Reserved for Private  | N/A        | - | RFC 9420 |\n| 0xFFFF   | Use                   |            |   |          |\n+----------+-----------------------+------------+---+----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Table 9: MLS Extension Types Registry",
      "ja": "表9：MLS拡張タイプレジストリ"
    },
    {
      "indent": 0,
      "text": "17.4. MLS Proposal Types",
      "section_title": true,
      "ja": "17.4. MLS提案の種類"
    },
    {
      "indent": 3,
      "text": "The \"MLS Proposal Types\" registry lists identifiers for types of proposals that can be made for changes to an MLS group. The extension type field is two bytes wide, so valid extension type values are in the range 0x0000 to 0xFFFF.",
      "ja": "「MLS提案タイプ」レジストリは、MLSグループへの変更のために行われる提案の種類の識別子をリストアップしています。拡張タイプフィールドは2バイト幅であり、有効な拡張タイプの値は0x0000から0xFFFFの範囲内にあります。"
    },
    {
      "indent": 3,
      "text": "Template:",
      "ja": "テンプレート"
    },
    {
      "indent": 6,
      "text": "* Value: The numeric value of the proposal type",
      "ja": "* 値：提案タイプの数値値"
    },
    {
      "indent": 6,
      "text": "* Name: The name of the proposal type",
      "ja": "* 名前：提案タイプの名前"
    },
    {
      "indent": 6,
      "text": "* Recommended: Same as in Section 17.1",
      "ja": "* 推奨：セクション17.1と同じ"
    },
    {
      "indent": 6,
      "text": "* External: Whether a proposal of this type may be sent by an external sender (see Section 12.1.8)",
      "ja": "* 外部: このタイプの提案が外部の送信者から送信されるかどうか（セクション12.1.8を参照）"
    },
    {
      "indent": 6,
      "text": "* Path Required: Whether a Commit covering a proposal of this type is required to have its path field populated (see Section 12.4)",
      "ja": "* 必要なパス：このタイプの提案をカバーするコミットが、そのパスフィールドが入力されている必要があるかどうか（12.4節を参照）"
    },
    {
      "indent": 6,
      "text": "* Reference: The document where this extension is defined",
      "ja": "* 参照：この拡張機能が定義されている文書"
    },
    {
      "indent": 3,
      "text": "Initial contents:",
      "ja": "最初の内容:"
    },
    {
      "indent": 4,
      "text": "+==========+==========================+===+=====+======+==========+\n| Value    | Name                     | R | Ext | Path | Ref      |\n+==========+==========================+===+=====+======+==========+\n| 0x0000   | RESERVED                 | - | -   | -    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0x0001   | add                      | Y | Y   | N    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0x0002   | update                   | Y | N   | Y    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0x0003   | remove                   | Y | Y   | Y    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0x0004   | psk                      | Y | Y   | N    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0x0005   | reinit                   | Y | Y   | N    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0x0006   | external_init            | Y | N   | Y    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0x0007   | group_context_extensions | Y | Y   | Y    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0x0A0A   | GREASE                   | Y | -   | -    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0x1A1A   | GREASE                   | Y | -   | -    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0x2A2A   | GREASE                   | Y | -   | -    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0x3A3A   | GREASE                   | Y | -   | -    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0x4A4A   | GREASE                   | Y | -   | -    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0x5A5A   | GREASE                   | Y | -   | -    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0x6A6A   | GREASE                   | Y | -   | -    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0x7A7A   | GREASE                   | Y | -   | -    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0x8A8A   | GREASE                   | Y | -   | -    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0x9A9A   | GREASE                   | Y | -   | -    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0xAAAA   | GREASE                   | Y | -   | -    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0xBABA   | GREASE                   | Y | -   | -    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0xCACA   | GREASE                   | Y | -   | -    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0xDADA   | GREASE                   | Y | -   | -    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0xEAEA   | GREASE                   | Y | -   | -    | RFC 9420 |\n+----------+--------------------------+---+-----+------+----------+\n| 0xF000 - | Reserved for Private Use | - | -   | -    | RFC 9420 |\n| 0xFFFF   |                          |   |     |      |          |\n+----------+--------------------------+---+-----+------+----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Table 10: MLS Proposal Types Registry",
      "ja": "表10：MLS提案タイプレジストリ"
    },
    {
      "indent": 0,
      "text": "17.5. MLS Credential Types",
      "section_title": true,
      "ja": "17.5. MLS資格の種類"
    },
    {
      "indent": 3,
      "text": "The \"MLS Credential Types\" registry lists identifiers for types of credentials that can be used for authentication in the MLS protocol. The credential type field is two bytes wide, so valid credential type values are in the range 0x0000 to 0xFFFF.",
      "ja": "「MLS資格種別」レジストリは、MLSプロトコルで認証に使用できる資格種別の識別子をリストアップしています。資格種別フィールドは2バイト幅であり、有効な資格種別の値は0x0000から0xFFFFの範囲内にあります。"
    },
    {
      "indent": 3,
      "text": "Template:",
      "ja": "テンプレート"
    },
    {
      "indent": 6,
      "text": "* Value: The numeric value of the credential type",
      "ja": "* 値：資格タイプの数値値"
    },
    {
      "indent": 6,
      "text": "* Name: The name of the credential type",
      "ja": "* 名前：資格タイプの名前"
    },
    {
      "indent": 6,
      "text": "* Recommended: Same as in Section 17.1",
      "ja": "* 推奨：セクション17.1と同じ"
    },
    {
      "indent": 6,
      "text": "* Reference: The document where this credential is defined",
      "ja": "* 参照：この資格情報が定義されている文書"
    },
    {
      "indent": 3,
      "text": "Initial contents:",
      "ja": "最初の内容:"
    },
    {
      "indent": 7,
      "text": "+=================+==========================+===+==========+\n| Value           | Name                     | R | Ref      |\n+=================+==========================+===+==========+\n| 0x0000          | RESERVED                 | - | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0x0001          | basic                    | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0x0002          | x509                     | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0x0A0A          | GREASE                   | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0x1A1A          | GREASE                   | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0x2A2A          | GREASE                   | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0x3A3A          | GREASE                   | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0x4A4A          | GREASE                   | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0x5A5A          | GREASE                   | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0x6A6A          | GREASE                   | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0x7A7A          | GREASE                   | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0x8A8A          | GREASE                   | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0x9A9A          | GREASE                   | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0xAAAA          | GREASE                   | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0xBABA          | GREASE                   | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0xCACA          | GREASE                   | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0xDADA          | GREASE                   | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0xEAEA          | GREASE                   | Y | RFC 9420 |\n+-----------------+--------------------------+---+----------+\n| 0xF000 - 0xFFFF | Reserved for Private Use | - | RFC 9420 |\n+-----------------+--------------------------+---+----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Table 11: MLS Credential Types Registry",
      "ja": "表11：MLS資格タイプレジストリ"
    },
    {
      "indent": 0,
      "text": "17.6. MLS Signature Labels",
      "section_title": true,
      "ja": "17.6. MLS シグネチャ ラベル"
    },
    {
      "indent": 3,
      "text": "The SignWithLabel function defined in Section 5.1.2 avoids the risk of confusion between signatures in different contexts. Each context is assigned a distinct label that is incorporated into the signature. The \"MLS Signature Labels\" registry records the labels defined in this document and allows additional labels to be registered in case extensions add other types of signatures using the same signature keys used elsewhere in MLS.",
      "ja": "セクション5.1.2で定義されたSignWithLabel関数は、異なるコンテキストでの署名の混同リスクを回避します。各コンテキストには、署名に組み込まれる固有のラベルが割り当てられます。この文書で定義されたラベルは、「MLS Signature Labels」レジストリに記録され、MLSの他の場所で使用される署名キーを使用して他の種類の署名が追加される場合に、追加のラベルを登録することができます。"
    },
    {
      "indent": 3,
      "text": "Template:",
      "ja": "テンプレート"
    },
    {
      "indent": 6,
      "text": "* Label: The string to be used as the Label parameter to SignWithLabel",
      "ja": "* ラベル：SignWithLabelのLabelパラメータとして使用される文字列"
    },
    {
      "indent": 6,
      "text": "* Recommended: Same as in Section 17.1",
      "ja": "* 推奨：17.1節と同様"
    },
    {
      "indent": 6,
      "text": "* Reference: The document where this label is defined",
      "ja": "* 参照：このラベルが定義されている文書"
    },
    {
      "indent": 3,
      "text": "Initial contents:",
      "ja": "最初の内容:"
    },
    {
      "indent": 19,
      "text": "+====================+===+==========+\n| Label              | R | Ref      |\n+====================+===+==========+\n| \"FramedContentTBS\" | Y | RFC 9420 |\n+--------------------+---+----------+\n| \"LeafNodeTBS\"      | Y | RFC 9420 |\n+--------------------+---+----------+\n| \"KeyPackageTBS\"    | Y | RFC 9420 |\n+--------------------+---+----------+\n| \"GroupInfoTBS\"     | Y | RFC 9420 |\n+--------------------+---+----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 12: MLS Signature Labels Registry",
      "ja": "表12：MLS署名ラベルレジストリ"
    },
    {
      "indent": 0,
      "text": "17.7. MLS Public Key Encryption Labels",
      "section_title": true,
      "ja": "17.7. MLS 公開鍵暗号化ラベル"
    },
    {
      "indent": 3,
      "text": "The EncryptWithLabel function defined in Section 5.1.3 avoids the risk of confusion between ciphertexts produced for different purposes in different contexts. Each context is assigned a distinct label that is incorporated into the signature. The \"MLS Public Key Encryption Labels\" registry records the labels defined in this document and allows additional labels to be registered in case extensions add other types of public key encryption using the same HPKE keys used elsewhere in MLS.",
      "ja": "セクション5.1.3で定義されたEncryptWithLabel関数は、異なる文脈で異なる目的のために生成された暗号文の混乱のリスクを回避します。各文脈には、署名に組み込まれる固有のラベルが割り当てられます。この文書で定義されたラベルは、「MLS Public Key Encryption Labels」レジストリに記録され、MLSの他の場所で使用されているHPKEキーを使用した他の種類の公開鍵暗号化が拡張された場合に追加のラベルを登録することができます。"
    },
    {
      "indent": 3,
      "text": "Template:",
      "ja": "テンプレート"
    },
    {
      "indent": 6,
      "text": "* Label: The string to be used as the Label parameter to EncryptWithLabel",
      "ja": "* ラベル：EncryptWithLabelのLabelパラメータとして使用される文字列"
    },
    {
      "indent": 6,
      "text": "* Recommended: Same as in Section 17.1",
      "ja": "* 推奨：セクション17.1と同じ"
    },
    {
      "indent": 6,
      "text": "* Reference: The document where this label is defined",
      "ja": "* 参照先：このラベルが定義されている文書"
    },
    {
      "indent": 3,
      "text": "Initial contents:",
      "ja": "最初の内容:"
    },
    {
      "indent": 20,
      "text": "+==================+===+==========+\n| Label            | R | Ref      |\n+==================+===+==========+\n| \"UpdatePathNode\" | Y | RFC 9420 |\n+------------------+---+----------+\n| \"Welcome\"        | Y | RFC 9420 |\n+------------------+---+----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "Table 13: MLS Public Key Encryption Labels Registry",
      "ja": "表13：MLS公開鍵暗号化ラベルレジストリ"
    },
    {
      "indent": 0,
      "text": "17.8. MLS Exporter Labels",
      "section_title": true,
      "ja": "17.8. MLSエクスポーターラベル"
    },
    {
      "indent": 3,
      "text": "The exporter function defined in Section 8.5 allows applications to derive key material from the MLS key schedule. Like the TLS exporter [RFC8446], the MLS exporter uses a label to distinguish between different applications' use of the exporter. The \"MLS Exporter Labels\" registry allows applications to register their usage to avoid collisions.",
      "ja": "セクション8.5で定義されたエクスポーター機能は、アプリケーションがMLSキースケジュールから鍵素材を導出することを可能にします。TLSエクスポーター[RFC8446]と同様に、MLSエクスポーターはラベルを使用して、異なるアプリケーションのエクスポーターの使用を区別します。\"MLS Exporter Labels\"レジストリを使用することで、アプリケーションは衝突を避けるために自身の使用法を登録できます。"
    },
    {
      "indent": 3,
      "text": "Template:",
      "ja": "テンプレート"
    },
    {
      "indent": 6,
      "text": "* Label: The string to be used as the Label parameter to MLS-Exporter",
      "ja": "* ラベル：MLSエクスポーターのLabelパラメータとして使用される文字列"
    },
    {
      "indent": 6,
      "text": "* Recommended: Same as in Section 17.1",
      "ja": "* 推奨：17.1節と同様"
    },
    {
      "indent": 6,
      "text": "* Reference: The document where this label is defined",
      "ja": "* 参照：このラベルが定義されている文書"
    },
    {
      "indent": 3,
      "text": "The registry has no initial contents, since it is intended to be used by applications, not the core protocol. The table below is intended only to show the column layout of the registry.",
      "ja": "レジストリには最初からコンテンツがありません。なぜなら、それはコアプロトコルではなくアプリケーションによって使用されることを意図しているからです。以下の表は、レジストリの列レイアウトを示すためだけに意図されています。"
    },
    {
      "indent": 20,
      "text": "+=======+=============+===========+\n| Label | Recommended | Reference |\n+=======+=============+===========+\n| (N/A) | (N/A)       | (N/A)     |\n+-------+-------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 14: MLS Exporter Labels Registry",
      "ja": "表14：MLSエクスポーターラベルレジストリ"
    },
    {
      "indent": 0,
      "text": "17.9. MLS Designated Expert Pool",
      "section_title": true,
      "ja": "17.9. MLS指定専門家プール"
    },
    {
      "indent": 3,
      "text": "Specification Required [RFC8126] registry requests are registered after a three-week review period on the MLS Designated Expert (DE) mailing list <mailto:mls-reg-review@ietf.org> on the advice of one or more of the MLS DEs. However, to allow for the allocation of values prior to publication, the MLS DEs may approve registration once they are satisfied that such a specification will be published.",
      "ja": "仕様要件[RFC8126]レジストリのリクエストは、MLS指定専門家（DE）メーリングリスト<mailto:mls-reg-review@ietf.org>での3週間の審査期間後に、MLS DEの1人以上の助言に基づいて登録されます。ただし、公開前に値の割り当てを許可するために、MLS DEは、そのような仕様が公開されることを確信した時点で登録を承認することがあります。"
    },
    {
      "indent": 3,
      "text": "Registration requests sent to the MLS DEs' mailing list for review SHOULD use an appropriate subject (e.g., \"Request to register value in MLS Bar registry\").",
      "ja": "レビューのためにMLS DEsのメーリングリストに送信される登録リクエストは、適切な件名を使用する必要があります（例：\"MLSバー登録に値を登録するリクエスト\"）。"
    },
    {
      "indent": 3,
      "text": "Within the review period, the MLS DEs will either approve or deny the registration request, communicating this decision to the MLS DEs' mailing list and IANA. Denials SHOULD include an explanation and, if applicable, suggestions as to how to make the request successful. Registration requests that are undetermined for a period longer than 21 days can be brought to the IESG's attention for resolution using the <mailto:iesg@ietf.org> mailing list.",
      "ja": "レビュー期間内に、MLS DEsは登録リクエストを承認または拒否し、この決定をMLS DEsのメーリングリストとIANAに通知します。拒否の場合は説明を含めるべきであり、適用される場合はリクエストを成功させるための提案も含めるべきです。21日を超えて未決定の登録リクエストは、<mailto:iesg@ietf.org>メーリングリストを使用してIESGに解決を求めるために持ち込むことができます。"
    },
    {
      "indent": 3,
      "text": "Criteria that SHOULD be applied by the MLS DEs includes determining whether the proposed registration duplicates existing functionality, whether it is likely to be of general applicability or useful only for a single application, and whether the registration description is clear. For example, for cipher suite registrations, the MLS DEs will apply the advisory found in Section 17.1.",
      "ja": "MLS DEs が適用すべき基準には、提案された登録が既存の機能を重複しているかどうかを判断すること、一般的に適用可能か単一のアプリケーションにのみ有用かを判断すること、登録の説明が明確かどうかを含みます。たとえば、暗号スイートの登録に関しては、MLS DEs はセクション17.1 に記載された助言を適用します。"
    },
    {
      "indent": 3,
      "text": "IANA MUST only accept registry updates from the MLS DEs and SHOULD direct all requests for registration to the MLS DEs' mailing list.",
      "ja": "IANAは、MLS DEからの登録更新のみを受け入れる必要があり、登録のリクエストはすべてMLS DEのメーリングリストに送るべきです。"
    },
    {
      "indent": 3,
      "text": "It is suggested that multiple MLS DEs who are able to represent the perspectives of different applications using this specification be appointed, in order to enable a broadly informed review of registration decisions. In cases where a registration decision could be perceived as creating a conflict of interest for a particular MLS DE, that MLS DE SHOULD defer to the judgment of the other MLS DEs.",
      "ja": "この仕様を使用して異なるアプリケーションの視点を代表できる複数のMLS DEが任命されることが提案されており、登録決定の幅広い情報に基づいたレビューを可能にするためです。 特定のMLS DEにとって利益相反を引き起こすと見なされる登録決定の場合、そのMLS DEは他のMLS DEの判断に従うべきです。"
    },
    {
      "indent": 0,
      "text": "17.10. The \"message/mls\" Media Type",
      "section_title": true,
      "ja": "17.10. \"message/mls\" メディアタイプ"
    },
    {
      "indent": 3,
      "text": "This document registers the \"message/mls\" media type in the \"message\" registry in order to allow other protocols (e.g., HTTP [RFC9113]) to convey MLS messages.",
      "ja": "この文書は、「message/mls」メディアタイプを「message」レジストリに登録し、他のプロトコル（例：HTTP [RFC9113]）がMLSメッセージを伝達できるようにするためのものです。"
    },
    {
      "indent": 3,
      "text": "Type name:",
      "ja": "名前を入力してください。"
    },
    {
      "indent": 12,
      "text": "message",
      "ja": "メッセージ"
    },
    {
      "indent": 3,
      "text": "Subtype name:",
      "ja": "サブタイプ名:"
    },
    {
      "indent": 12,
      "text": "mls",
      "ja": "mls"
    },
    {
      "indent": 3,
      "text": "Required parameters:",
      "ja": "必須パラメータ:"
    },
    {
      "indent": 12,
      "text": "none",
      "ja": "何もない"
    },
    {
      "indent": 3,
      "text": "Optional parameters:",
      "ja": "オプションパラメータ："
    },
    {
      "indent": 6,
      "text": "version",
      "ja": "バージョン"
    },
    {
      "indent": 6,
      "text": "version:",
      "ja": "バージョン:"
    },
    {
      "indent": 15,
      "text": "The MLS protocol version expressed as a string <major>.<minor>. If omitted, the version is \"1.0\", which corresponds to MLS ProtocolVersion mls10. If for some reason the version number in the media type parameter differs from the ProtocolVersion embedded in the protocol, the protocol takes precedence.",
      "ja": "MLSプロトコルバージョンは、文字列<major>.<minor>として表されます。省略された場合、バージョンは「1.0」であり、これはMLS ProtocolVersion mls10に対応します。メディアタイプパラメータ内のバージョン番号がプロトコルに埋め込まれたProtocolVersionと異なる場合、プロトコルが優先されます。"
    },
    {
      "indent": 3,
      "text": "Encoding considerations:",
      "ja": "エンコーディングに関する考慮事項:"
    },
    {
      "indent": 12,
      "text": "MLS messages are represented using the TLS presentation language [RFC8446]. Therefore, MLS messages need to be treated as binary data.",
      "ja": "MLSメッセージはTLSプレゼンテーション言語[RFC8446]を使用して表現されます。したがって、MLSメッセージはバイナリデータとして扱う必要があります。"
    },
    {
      "indent": 3,
      "text": "Security considerations:",
      "ja": "セキュリティに関する考慮事項:"
    },
    {
      "indent": 12,
      "text": "MLS is an encrypted messaging layer designed to be transmitted over arbitrary lower-layer protocols. The security considerations in this document (RFC 9420) also apply.",
      "ja": "MLSは、任意の下位層プロトコルを介して送信されるように設計された暗号化されたメッセージングレイヤーです。このドキュメント（RFC 9420）に記載されているセキュリティに関する考慮事項も適用されます。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations:",
      "ja": "相互運用性に関する考慮事項:"
    },
    {
      "indent": 12,
      "text": "N/A",
      "ja": "N/Aは「該当なし」を意味します。"
    },
    {
      "indent": 3,
      "text": "Published specification:",
      "ja": "公開された仕様書:"
    },
    {
      "indent": 12,
      "text": "RFC 9420",
      "ja": "RFC 9420"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type:",
      "ja": "このメディアタイプを使用するアプリケーション:"
    },
    {
      "indent": 12,
      "text": "MLS-based messaging applications",
      "ja": "MLSベースのメッセージングアプリケーション"
    },
    {
      "indent": 3,
      "text": "Fragment identifier considerations:",
      "ja": "フラグメント識別子に関する考慮事項:"
    },
    {
      "indent": 12,
      "text": "N/A",
      "ja": "N/Aは「該当なし」を意味します。"
    },
    {
      "indent": 3,
      "text": "Additional information:",
      "ja": "追加情報:"
    },
    {
      "indent": 6,
      "text": "Deprecated alias names for this type:",
      "ja": "このタイプの非推奨なエイリアス名:"
    },
    {
      "indent": 15,
      "text": "N/A",
      "ja": "N/Aは「該当なし」を意味します。"
    },
    {
      "indent": 6,
      "text": "Magic number(s):",
      "ja": "マジックナンバー(複数形)："
    },
    {
      "indent": 15,
      "text": "N/A",
      "ja": "N/Aは「該当なし」を意味します。"
    },
    {
      "indent": 6,
      "text": "File extension(s):",
      "ja": "ファイルの拡張子（複数形）:"
    },
    {
      "indent": 15,
      "text": "N/A",
      "ja": "N/Aは「該当なし」を意味します。"
    },
    {
      "indent": 6,
      "text": "Macintosh file type code(s):",
      "ja": "マッキントッシュファイルタイプコード："
    },
    {
      "indent": 15,
      "text": "N/A",
      "ja": "N/Aは「該当なし」を意味します。"
    },
    {
      "indent": 3,
      "text": "Person & email address to contact for further information:",
      "ja": "詳細情報を得るための連絡先：個人名およびメールアドレス"
    },
    {
      "indent": 12,
      "text": "IETF MLS Working Group <mailto:mls@ietf.org>",
      "ja": "IETF MLS ワーキンググループ <mailto:mls@ietf.org>"
    },
    {
      "indent": 3,
      "text": "Intended usage:",
      "ja": "使用目的:"
    },
    {
      "indent": 12,
      "text": "COMMON",
      "ja": "共通"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage:",
      "ja": "使用制限:"
    },
    {
      "indent": 12,
      "text": "N/A",
      "ja": "N/Aは「該当なし」を意味します。"
    },
    {
      "indent": 3,
      "text": "Author:",
      "ja": "著者:"
    },
    {
      "indent": 12,
      "text": "IETF MLS Working Group",
      "ja": "IETF MLS ワーキンググループ"
    },
    {
      "indent": 3,
      "text": "Change controller:",
      "ja": "コントローラーを変更します。"
    },
    {
      "indent": 12,
      "text": "IETF",
      "ja": "IETFは、Internet Engineering Task Force（インターネット技術基準化委員会）の略です。"
    },
    {
      "indent": 0,
      "text": "18. References",
      "section_title": true,
      "ja": "18. 参考文献"
    },
    {
      "indent": 0,
      "text": "18.1. Normative References",
      "section_title": true,
      "ja": "18.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-\n           Hashing for Message Authentication\", RFC 2104,\n           DOI 10.17487/RFC2104, February 1997,\n           <https://www.rfc-editor.org/info/rfc2104>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8126]  Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n           Writing an IANA Considerations Section in RFCs\", BCP 26,\n           RFC 8126, DOI 10.17487/RFC8126, June 2017,\n           <https://www.rfc-editor.org/info/rfc8126>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8446]  Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n           Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n           <https://www.rfc-editor.org/info/rfc8446>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9180]  Barnes, R., Bhargavan, K., Lipp, B., and C. Wood, \"Hybrid\n           Public Key Encryption\", RFC 9180, DOI 10.17487/RFC9180,\n           February 2022, <https://www.rfc-editor.org/info/rfc9180>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.2. Informative References",
      "section_title": true,
      "ja": "18.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[ART]      Cohn-Gordon, K., Cremers, C., Garratt, L., Millican, J.,\n           and K. Milner, \"On Ends-to-Ends Encryption: Asynchronous\n           Group Messaging with Strong Security Guarantees\", Version\n           2.3, DOI 10.1145/3243734.3243747, March 2020,\n           <https://eprint.iacr.org/2017/666.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[CFRG-AEAD-LIMITS]\n           Günther, F., Thomson, M., and C. A. Wood, \"Usage Limits on\n           AEAD Algorithms\", Work in Progress, Internet-Draft, draft-\n           irtf-cfrg-aead-limits-07, 31 May 2023,\n           <https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-\n           aead-limits-07>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[CLINIC]   Miller, B., Huang, L., Joseph, A., and J. Tygar, \"I Know\n           Why You Went to the Clinic: Risks and Realization of HTTPS\n           Traffic Analysis\", Privacy Enhancing Technologies, pp.\n           143-163, DOI 10.1007/978-3-319-08506-7_8, 2014,\n           <https://doi.org/10.1007/978-3-319-08506-7_8>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[CONIKS]   Melara, M. S., Blankstein, A., Bonneau, J., Felten, E. W.,\n           and M. J. Freedman, \"CONIKS: Bringing Key Transparency to\n           End Users\", Proceedings of the 24th USENIX Security\n           Symposium, ISBN 978-1-939133-11-3, August 2015,\n           <https://www.usenix.org/system/files/conference/\n           usenixsecurity15/sec15-paper-melara.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[DoubleRatchet]\n           Cohn-Gordon, K., Cremers, C., Dowling, B., Garratt, L.,\n           and D. Stebila, \"A Formal Security Analysis of the Signal\n           Messaging Protocol\", 2017 IEEE European Symposium on\n           Security and Privacy (EuroS&P),\n           DOI 10.1109/eurosp.2017.27, April 2017,\n           <https://doi.org/10.1109/eurosp.2017.27>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HCJ16]    Husák, M., Čermák, M., Jirsík, T., and P. Čeleda, \"HTTPS\n           traffic analysis and client identification using passive\n           SSL/TLS fingerprinting\", EURASIP Journal on Information\n           Security, Vol. 2016, Issue 1,\n           DOI 10.1186/s13635-016-0030-7, February 2016,\n           <https://doi.org/10.1186/s13635-016-0030-7>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[KT]       \"Key Transparency Design Doc\", commit fb0f87f, June 2020,\n           <https://github.com/google/keytransparency/blob/master/\n           docs/design.md>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[MLS-ARCH] Beurdouche, B., Rescorla, E., Omara, E., Inguva, S., and\n           A. Duric, \"The Messaging Layer Security (MLS)\n           Architecture\", Work in Progress, Internet-Draft, draft-\n           ietf-mls-architecture-10, 16 December 2022,\n           <https://datatracker.ietf.org/doc/html/draft-ietf-mls-\n           architecture-10>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[NAN]      Bellare, M., Ng, R., and B. Tackmann, \"Nonces Are Noticed:\n           AEAD Revisited\", Advances in Cryptology - CRYPTO 2019, pp.\n           235-265, DOI 10.1007/978-3-030-26948-7_9, August 2019,\n           <https://doi.org/10.1007/978-3-030-26948-7_9>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5116]  McGrew, D., \"An Interface and Algorithms for Authenticated\n           Encryption\", RFC 5116, DOI 10.17487/RFC5116, January 2008,\n           <https://www.rfc-editor.org/info/rfc5116>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5905]  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,\n           \"Network Time Protocol Version 4: Protocol and Algorithms\n           Specification\", RFC 5905, DOI 10.17487/RFC5905, June 2010,\n           <https://www.rfc-editor.org/info/rfc5905>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6125]  Saint-Andre, P. and J. Hodges, \"Representation and\n           Verification of Domain-Based Application Service Identity\n           within Internet Public Key Infrastructure Using X.509\n           (PKIX) Certificates in the Context of Transport Layer\n           Security (TLS)\", RFC 6125, DOI 10.17487/RFC6125, March\n           2011, <https://www.rfc-editor.org/info/rfc6125>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7696]  Housley, R., \"Guidelines for Cryptographic Algorithm\n           Agility and Selecting Mandatory-to-Implement Algorithms\",\n           BCP 201, RFC 7696, DOI 10.17487/RFC7696, November 2015,\n           <https://www.rfc-editor.org/info/rfc7696>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8032]  Josefsson, S. and I. Liusvaara, \"Edwards-Curve Digital\n           Signature Algorithm (EdDSA)\", RFC 8032,\n           DOI 10.17487/RFC8032, January 2017,\n           <https://www.rfc-editor.org/info/rfc8032>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8701]  Benjamin, D., \"Applying Generate Random Extensions And\n           Sustain Extensibility (GREASE) to TLS Extensibility\",\n           RFC 8701, DOI 10.17487/RFC8701, January 2020,\n           <https://www.rfc-editor.org/info/rfc8701>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9000]  Iyengar, J., Ed. and M. Thomson, Ed., \"QUIC: A UDP-Based\n           Multiplexed and Secure Transport\", RFC 9000,\n           DOI 10.17487/RFC9000, May 2021,\n           <https://www.rfc-editor.org/info/rfc9000>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9001]  Thomson, M., Ed. and S. Turner, Ed., \"Using TLS to Secure\n           QUIC\", RFC 9001, DOI 10.17487/RFC9001, May 2021,\n           <https://www.rfc-editor.org/info/rfc9001>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9113]  Thomson, M., Ed. and C. Benfield, Ed., \"HTTP/2\", RFC 9113,\n           DOI 10.17487/RFC9113, June 2022,\n           <https://www.rfc-editor.org/info/rfc9113>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SHS]      National Institute of Standards and Technology (NIST),\n           \"Secure Hash Standard (SHS)\", FIPS PUB 180-4,\n           DOI 10.6028/NIST.FIPS.180-4, August 2015,\n           <https://doi.org/10.6028/NIST.FIPS.180-4>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Signal]   Perrin(ed), T. and M. Marlinspike, \"The Double Ratchet\n           Algorithm\", Revision 1, November 2016,\n           <https://www.signal.org/docs/specifications/\n           doubleratchet/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix A. Protocol Origins of Example Trees",
      "section_title": true,
      "ja": "付録A. 例の木のプロトコルの起源"
    },
    {
      "indent": 3,
      "text": "Protocol operations in MLS give rise to specific forms of ratchet tree, typically affecting a whole direct path at once. In this section, we describe the protocol operations that could have given rise to the various example trees in this document.",
      "ja": "MLSにおけるプロトコル操作は、通常、一度に全体の直接パスに影響を与える特定の形式のラチェットツリーを生み出します。このセクションでは、この文書のさまざまな例のツリーが生じる可能性のあるプロトコル操作について説明します。"
    },
    {
      "indent": 3,
      "text": "To construct the tree in Figure 11:",
      "ja": "図11に示されている木を構築するには、"
    },
    {
      "indent": 6,
      "text": "* A creates a group with B, ..., G",
      "ja": "* AはB、...、Gとグループを作成します。"
    },
    {
      "indent": 6,
      "text": "* F sends an empty Commit, setting X, Y, and W",
      "ja": "* Fは、X、Y、およびWを設定した空のCommitを送信します。"
    },
    {
      "indent": 6,
      "text": "* G removes C and D, blanking V, U, and setting Y and W",
      "ja": "* GはCとDを取り除き、VとUを消去し、YとWを設定します。"
    },
    {
      "indent": 6,
      "text": "* B sends an empty Commit, setting T and W",
      "ja": "* Bは空のCommitを送信し、TとWを設定します。"
    },
    {
      "indent": 3,
      "text": "To construct the tree in Figure 10:",
      "ja": "図10に示されている木を構築するには、"
    },
    {
      "indent": 6,
      "text": "* A creates a group with B, ..., H, as well as some members outside this subtree",
      "ja": "* Aは、B、...、Hを含むグループを作成し、このサブツリーの外部のいくつかのメンバーも含めます。"
    },
    {
      "indent": 6,
      "text": "* F sends an empty Commit, setting Y and its ancestors",
      "ja": "* Fは空のCommitを送信し、Yとその祖先を設定します。"
    },
    {
      "indent": 6,
      "text": "* D removes B and C, with the following effects:",
      "ja": "* DはBとCを取り除き、以下の効果があります："
    },
    {
      "indent": 12,
      "text": "- Blank the direct paths of B and C",
      "ja": "- BとCの直接の経路をブロックする"
    },
    {
      "indent": 12,
      "text": "- Set X, the top node, and any further nodes in the direct path of D",
      "ja": "- Xをセットし、トップノードと、Dの直接のパスにある追加のノードを含めてください。"
    },
    {
      "indent": 6,
      "text": "* Someone outside this subtree removes G, blanking the direct path of G",
      "ja": "* この部分木の外の誰かがGを取り除き、Gの直接のパスを消去します。"
    },
    {
      "indent": 6,
      "text": "* A adds a new member at B with a partial Commit, adding B as unmerged at X",
      "ja": "* Aは部分的なコミットでBに新しいメンバーを追加し、Xにマージされていない状態でBを追加します。"
    },
    {
      "indent": 3,
      "text": "To construct the tree in Figure 13:",
      "ja": "図13に示されている木を構築するには、"
    },
    {
      "indent": 6,
      "text": "* A creates a group with B, C, and D",
      "ja": "* AはB、C、およびDとグループを作成します。"
    },
    {
      "indent": 6,
      "text": "* B sends a full Commit, setting X and Y",
      "ja": "* BはXとYを設定した完全なコミットを送信します。"
    },
    {
      "indent": 6,
      "text": "* D removes C, setting Z and Y",
      "ja": "* D は C を取り除き、Z と Y を設定します。"
    },
    {
      "indent": 6,
      "text": "* B adds a new member at C with a full Commit",
      "ja": "* Bは、Cに新しいメンバーをフルコミットで追加します。"
    },
    {
      "indent": 12,
      "text": "- The Add proposal adds C as unmerged at Z and Y",
      "ja": "- 提案には、CをZおよびYで未マージとして追加します。"
    },
    {
      "indent": 12,
      "text": "- The path in the Commit resets X and Y, clearing Y's unmerged leaves",
      "ja": "- コミット内のパスは、XとYをリセットし、Yのマージされていない葉をクリアします。"
    },
    {
      "indent": 3,
      "text": "To construct the tree in Figure 21:",
      "ja": "図21の木を構築するには、"
    },
    {
      "indent": 6,
      "text": "* A creates a group with B, ..., G",
      "ja": "* AはB、...、Gとグループを作成します。"
    },
    {
      "indent": 6,
      "text": "* A removes F in a full Commit, setting T, U, and W",
      "ja": "* 完全なコミットでAはFを取り除き、T、U、およびWを設定します。"
    },
    {
      "indent": 6,
      "text": "* E sends an empty Commit, setting Y and W",
      "ja": "* Eは空のCommitを送信し、YとWを設定します。"
    },
    {
      "indent": 6,
      "text": "* A adds a new member at F in a partial Commit, adding F as unmerged at Y and W",
      "ja": "* Aは部分的なコミットでFに新しいメンバーを追加し、YとWでマージされていないFを追加します。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Evolution of Parent Hashes",
      "section_title": true,
      "ja": "付録B. 親ハッシュの進化"
    },
    {
      "indent": 3,
      "text": "To better understand how parent hashes are maintained, let's look in detail at how they evolve in a small group. Consider the following sequence of operations:",
      "ja": "親ハッシュがどのように維持されるかをよりよく理解するために、小さなグループでどのように進化するかを詳しく見てみましょう。次の操作のシーケンスを考えてみてください："
    },
    {
      "indent": 8,
      "text": "1. A initializes a new group",
      "ja": "1. Aは新しいグループを初期化します。"
    },
    {
      "indent": 8,
      "text": "2. A adds B to the group with a full Commit",
      "ja": "2. Aは完全なコミットでBをグループに追加します。"
    },
    {
      "indent": 8,
      "text": "3. B adds C and D to the group with a full Commit",
      "ja": "3. Bは完全なコミットでCとDをグループに追加します。"
    },
    {
      "indent": 8,
      "text": "4. C sends an empty Commit",
      "ja": "4. Cは空のコミットを送信します。"
    },
    {
      "indent": 3,
      "text": "                          Y                   Y'\n                          |                   |\n                        .-+-.               .-+-.\n   ==>         ==>     /     \\     ==>     /     \\\n          X           X'      _=Z         X'      Z'\n         / \\         / \\     / \\         / \\     / \\\nA       A   B       A   B   C   D       A   B   C   D",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 30: Building a Four-Member Tree to Illustrate Parent Hashes",
      "ja": "図30：親ハッシュを示すために4つのメンバーを持つツリーを構築する"
    },
    {
      "indent": 3,
      "text": "Then the parent hashes associated to the nodes will be updated as follows (where we use the shorthand ph for parent hash, th for tree hash, and osth for original sibling tree hash):",
      "ja": "次に、ノードに関連付けられた親ハッシュが以下のように更新されます（ここでは、親ハッシュをph、ツリーハッシュをth、元の兄弟ツリーハッシュをosthの略語を使用します）。"
    },
    {
      "indent": 8,
      "text": "1. A adds B: set X",
      "ja": "1. AがBを追加する：Xを設定"
    },
    {
      "indent": 14,
      "text": "* A.parent_hash = ph(X) = H(X, ph=\"\", osth=th(B))",
      "ja": "* A.parent_hash = ph(X) = H(X, ph=\"\", osth=th(B))"
    },
    {
      "indent": 8,
      "text": "2. B adds C, D: set B', X', and Y",
      "ja": "2. BはCとDを追加します：B'、X'、およびYを設定します。"
    },
    {
      "indent": 14,
      "text": "* X'.parent_hash = ph(Y) = H(Y, ph=\"\", osth=th(Z)), where th(Z) covers (C, _, D)",
      "ja": "* X'.parent_hash = ph(Y) = H(Y, ph=\"\", osth=th(Z))、ここでth(Z)は(C, _, D)をカバーしています。"
    },
    {
      "indent": 14,
      "text": "* B'.parent_hash = ph(X') = H(X', ph=X'.parent_hash, osth=th(A))",
      "ja": "* B'.parent_hash = ph(X') = H(X', ph=X'.parent_hash, osth=th(A))"
    },
    {
      "indent": 8,
      "text": "3. C sends empty Commit: set C', Z', Y'",
      "ja": "3. C は空の Commit を送信します：C'、Z'、Y' を設定します。"
    },
    {
      "indent": 14,
      "text": "* Z'.parent_hash = ph(Y') = H(Y', ph=\"\", osth=th(X')), where th(X') covers (A, X', B')",
      "ja": "* Z'.parent_hash = ph(Y') = H(Y', ph=\"\", osth=th(X'))、ここで、th(X') は (A, X', B') をカバーしています。"
    },
    {
      "indent": 14,
      "text": "* C'.parent_hash = ph(Z') = H(Z', ph=Z'.parent_hash, osth=th(D))",
      "ja": "* C'.parent_hash = ph(Z') = H(Z', ph=Z'.parent_hash, osth=th(D))"
    },
    {
      "indent": 3,
      "text": "When a new member joins, they will receive a tree that has the following parent hash values and compute the indicated parent hash validity relationships:",
      "ja": "新しいメンバーが参加すると、以下の親ハッシュ値を持つツリーが与えられ、指定された親ハッシュの妥当性関係を計算します。"
    },
    {
      "indent": 0,
      "text": "+======+======================================+=====================+\n| Node | Parent Hash Value                    | Valid?              |\n+======+======================================+=====================+\n| A    | H(X, ph=\"\", osth=th(B))              | No, B changed       |\n+------+--------------------------------------+---------------------+\n| B'   | H(X', ph=X'.parent_hash, osth=th(A)) | Yes                 |\n+------+--------------------------------------+---------------------+\n| C'   | H(Z', ph=Z'.parent_hash, osth=th(D)) | Yes                 |\n+------+--------------------------------------+---------------------+\n| D    | (none, never sent an UpdatePath)     | N/A                 |\n+------+--------------------------------------+---------------------+\n| X'   | H(Y, ph=\"\", osth=th(Z))              | No, Y and Z         |\n|      |                                      | changed             |\n+------+--------------------------------------+---------------------+\n| Z'   | H(Y', ph=\"\", osth=th(X'))            | Yes                 |\n+------+--------------------------------------+---------------------+\n\n                               Table 15",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In other words, the joiner will find the following path-hash links in the tree:",
      "ja": "言い換えると、結合者は木構造内で次のパスハッシュリンクを見つけます："
    },
    {
      "indent": 4,
      "text": "      Y'\n      |\n      +-.\n         \\\n  X'      Z'\n   \\     /\nA   B'  C'  D",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Figure 31: Parent-hash links connect all non-empty parent nodes to leaves",
      "ja": "図31：親ハッシュリンクは、すべての空でない親ノードを葉に接続します。"
    },
    {
      "indent": 3,
      "text": "Since these chains collectively cover all non-blank parent nodes in the tree, the tree is parent-hash valid.",
      "ja": "これらのチェーンは、木構造内のすべての空でない親ノードを網羅しているため、この木構造は親ハッシュが有効です。"
    },
    {
      "indent": 3,
      "text": "Note that this tree, though valid, contains invalid parent-hash links. If a client were checking parent hashes top-down from Y', for example, they would find that X' has an invalid parent hash relative to Y', but that Z' has a valid parent hash. Likewise, if the client were checking bottom-up, they would find that the chain from B' ends in an invalid link from X' to Y'. These invalid links are the natural result of multiple clients having committed.",
      "ja": "この木構造は有効ですが、無効な親ハッシュリンクが含まれていることに注意してください。たとえば、クライアントがY'から上方向に親ハッシュを確認している場合、X'がY'に対して無効な親ハッシュを持っていることがわかりますが、Z'は有効な親ハッシュを持っていることがわかります。同様に、クライアントが下方向に確認している場合、B'からのチェーンがX'からY'への無効なリンクで終わっていることがわかります。これらの無効なリンクは、複数のクライアントがコミットした結果です。"
    },
    {
      "indent": 3,
      "text": "Note also the way the tree hash and the parent hash interact. The parent hash of node C' includes the tree hash of node D. The parent hash of node Z' includes the tree hash of X', which covers nodes A and B' (including the parent hash of B'). Although the tree hash and the parent hash depend on each other, the dependency relationships are structured so that there is never a circular dependency.",
      "ja": "木ハッシュと親ハッシュがどのように相互作用するかにも注目してください。ノードC'の親ハッシュにはノードDの木ハッシュが含まれます。ノードZ'の親ハッシュにはX'の木ハッシュが含まれ、これにはノードAとB'（B'の親ハッシュを含む）が含まれます。木ハッシュと親ハッシュは互いに依存していますが、依存関係は循環依存が決して発生しないように構造化されています。"
    },
    {
      "indent": 3,
      "text": "In the particular case where a new member first receives the tree for a group (e.g., in a ratchet tree GroupInfo extension Section 12.4.3.3), the parent hashes will be expressed in the tree representation, but the tree hash need not be. Instead, the new member will recompute the tree hashes for all the nodes in the tree, verifying that this matches the tree hash in the GroupInfo object. If the tree is valid, then the subtree hashes computed in this way will align with the inputs needed for parent hash validation (except where recomputation is needed to account for unmerged leaves).",
      "ja": "特定のケースでは、新しいメンバーがグループのツリーを最初に受け取る場合（たとえば、ラチェットツリーのGroupInfo拡張セクション12.4.3.3で）、親ハッシュはツリー表現で表されますが、ツリーハッシュは必要ありません。代わりに、新しいメンバーはツリー内のすべてのノードのツリーハッシュを再計算し、これがGroupInfoオブジェクト内のツリーハッシュと一致することを検証します。ツリーが有効であれば、この方法で計算されたサブツリーハッシュは、親ハッシュ検証に必要な入力と一致します（未マージの葉を考慮するために再計算が必要な場合を除く）。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Array-Based Trees",
      "section_title": true,
      "ja": "付録C. 配列ベースの木"
    },
    {
      "indent": 3,
      "text": "One benefit of using complete balanced trees is that they admit a simple flat array representation. In this representation, leaf nodes are even-numbered nodes, with the n-th leaf at 2*n. Intermediate nodes are held in odd-numbered nodes. For example, the tree with 8 leaves has the following structure:",
      "ja": "完全バランス木を使用する利点の1つは、単純なフラットな配列表現が可能であることです。この表現では、葉ノードは偶数番目のノードであり、n番目の葉は2*nに配置されます。中間ノードは奇数番目のノードに保持されます。例えば、8つの葉を持つ木の構造は次のようになります："
    },
    {
      "indent": 3,
      "text": "                           X\n                           |\n                 .---------+---------.\n                /                     \\\n               X                       X\n               |                       |\n           .---+---.               .---+---.\n          /         \\             /         \\\n         X           X           X           X\n        / \\         / \\         / \\         / \\\n       /   \\       /   \\       /   \\       /   \\\n      X     X     X     X     X     X     X     X\n\nNode: 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14\n\nLeaf: 0     1     2     3     4     5     6     7",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Figure 32: An Eight-Member Tree Represented as an Array",
      "ja": "図32：配列で表された8人のメンバーの木"
    },
    {
      "indent": 3,
      "text": "This allows us to compute relationships between tree nodes simply by manipulating indices, rather than having to maintain complicated structures in memory. The basic rule is that the high-order bits of parent and child nodes indices have the following relation (where x is an arbitrary bit string):",
      "ja": "これにより、複雑な構造をメモリ内に保持する必要なく、単純にインデックスを操作することで木のノード間の関係を計算できます。基本的なルールは、親ノードと子ノードのインデックスの上位ビットには以下の関係があるということです（ここで x は任意のビット列です）。"
    },
    {
      "indent": 3,
      "text": "parent=01x => left=00x, right=10x",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Since node relationships are implicit, the algorithms for adding and removing nodes at the right edge of the tree are quite simple. If there are N nodes in the array:",
      "ja": "ノードの関係は暗黙的であるため、木の右端にノードを追加および削除するアルゴリズムは非常に単純です。配列にN個のノードがある場合："
    },
    {
      "indent": 6,
      "text": "* Add: Append N + 1 blank values to the end of the array.",
      "ja": "* 追加：配列の末尾にN + 1個の空白値を追加します。"
    },
    {
      "indent": 6,
      "text": "* Remove: Truncate the array to its first (N-1) / 2 entries.",
      "ja": "* 削除：配列を最初の（N-1）/ 2エントリに切り詰めます。"
    },
    {
      "indent": 3,
      "text": "The following python code demonstrates the tree computations necessary to use an array-based tree for MLS.",
      "ja": "次のPythonコードは、MLS用の配列ベースの木を使用するために必要な木の計算を示しています。"
    },
    {
      "indent": 3,
      "text": "# The exponent of the largest power of 2 less than x. Equivalent to:\n#   int(math.floor(math.log(x, 2)))\ndef log2(x):\n    if x == 0:\n        return 0\n\n    k = 0\n    while (x >> k) > 0:\n        k += 1\n    return k-1\n\n# The level of a node in the tree. Leaves are level 0, their parents\n# are level 1, etc. If a node's children are at different levels,\n# then its level is the max level of its children plus one.\ndef level(x):\n    if x & 0x01 == 0:\n        return 0\n\n    k = 0\n    while ((x >> k) & 0x01) == 1:\n        k += 1\n    return k\n\n# The number of nodes needed to represent a tree with n leaves.\ndef node_width(n):\n    if n == 0:\n        return 0\n    else:\n        return 2*(n - 1) + 1\n\n# The index of the root node of a tree with n leaves.\ndef root(n):\n    w = node_width(n)\n    return (1 << log2(w)) - 1\n\n# The left child of an intermediate node.\ndef left(x):\n    k = level(x)\n    if k == 0:\n        raise Exception('leaf node has no children')\n\n    return x ^ (0x01 << (k - 1))\n\n# The right child of an intermediate node.\ndef right(x):\n    k = level(x)\n    if k == 0:\n        raise Exception('leaf node has no children')\n\n    return x ^ (0x03 << (k - 1))\n\n# The parent of a node.\ndef parent(x, n):\n    if x == root(n):\n        raise Exception('root node has no parent')\n\n    k = level(x)\n    b = (x >> (k + 1)) & 0x01\n    return (x | (1 << k)) ^ (b << (k + 1))\n\n# The other child of the node's parent.\ndef sibling(x, n):\n    p = parent(x, n)\n    if x < p:\n        return right(p)\n    else:\n        return left(p)\n\n# The direct path of a node, ordered from leaf to root.\ndef direct_path(x, n):\n    r = root(n)\n    if x == r:\n        return []\n\n    d = []\n    while x != r:\n        x = parent(x, n)\n        d.append(x)\n    return d\n\n# The copath of a node, ordered from leaf to root.\ndef copath(x, n):\n    if x == root(n):\n        return []\n\n    d = direct_path(x, n)\n    d.insert(0, x)\n    d.pop()\n    return [sibling(y, n) for y in d]\n\n# The common ancestor of two nodes is the lowest node that is in the\n# direct paths of both leaves.\ndef common_ancestor_semantic(x, y, n):\n    dx = set([x]) | set(direct_path(x, n))\n    dy = set([y]) | set(direct_path(y, n))\n    dxy = dx & dy\n    if len(dxy) == 0:\n        raise Exception('failed to find common ancestor')\n\n    return min(dxy, key=level)\n\n# The common ancestor of two nodes is the lowest node that is in the\n# direct paths of both leaves.\ndef common_ancestor_direct(x, y, _):\n    # Handle cases where one is an ancestor of the other\n    lx, ly = level(x)+1, level(y)+1\n    if (lx <= ly) and (x>>ly == y>>ly):\n      return y\n    elif (ly <= lx) and (x>>lx == y>>lx):\n      return x\n\n    # Handle other cases\n    xn, yn = x, y\n    k = 0\n    while xn != yn:\n       xn, yn = xn >> 1, yn >> 1\n       k += 1\n    return (xn << k) + (1 << (k-1)) - 1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix D. Link-Based Trees",
      "section_title": true,
      "ja": "付録D. リンクベースの木"
    },
    {
      "indent": 3,
      "text": "An implementation may choose to store ratchet trees in a \"link-based\" representation, where each node stores references to its parents and/ or children (as opposed to the array-based representation suggested above, where these relationships are computed from relationships between nodes' indices in the array). Such an implementation needs to update these links to maintain the balanced structure of the tree as the tree is extended to add new members or truncated when members are removed.",
      "ja": "実装は、各ノードが親や子への参照を格納する「リンクベース」表現でラチェットツリーを保存することを選択することができます（上記で提案された配列ベースの表現とは異なり、ここではこれらの関係が配列内のノードのインデックス間の関係から計算される）。このような実装では、新しいメンバーを追加するためにツリーを拡張する際やメンバーが削除される際にツリーのバランスの取れた構造を維持するためにこれらのリンクを更新する必要があります。"
    },
    {
      "indent": 3,
      "text": "The following code snippet shows how these algorithms could be implemented in Python.",
      "ja": "次のコードスニペットは、これらのアルゴリズムがPythonで実装される方法を示しています。"
    },
    {
      "indent": 3,
      "text": "class Node:\n    def __init__(self, value, left=None, right=None):\n        self.value = value    # Value of the node\n        self.left = left      # Left child node\n        self.right = right    # Right child node\n\n    @staticmethod\n    def blank_subtree(depth):\n        if depth == 1:\n            return Node(None)\n\n        L = Node.blank_subtree(depth-1)\n        R = Node.blank_subtree(depth-1)\n        return Node(None, left=L, right=R)\n\n    def empty(self):\n        L_empty = (self.left == None) or self.left.empty()\n        R_empty = (self.right == None) or self.right.empty()\n        return (self.value == None) and L_empty and R_empty\n\nclass Tree:\n    def __init__(self):\n        self.depth = 0    # Depth of the tree\n        self.root = None  # Root node of the tree, initially empty\n\n    # Add a blank subtree to the right\n    def extend(self):\n        if self.depth == 0:\n            self.depth = 1\n            self.root = Node(None)\n\n        L = self.root\n        R = Node.blank_subtree(self.depth)\n        self.root = Node(None, left=L, right=R)\n        self.depth += 1\n\n    # Truncate the right subtree\n    def truncate(self):\n        if self.root == None:\n            return\n\n        if not self.root.right.empty():\n            raise Exception(\"Cannot truncate non-blank subtree\")\n\n        self.depth -= 1\n        self.root = self.root.left",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Contributors",
      "section_title": true,
      "ja": "貢献者"
    },
    {
      "indent": 3,
      "text": "Joel Alwen\nAmazon\nEmail: alwenjo@amazon.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Karthikeyan Bhargavan\nInria\nEmail: karthikeyan.bhargavan@inria.fr",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Cas Cremers\nCISPA\nEmail: cremers@cispa.de",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Alan Duric\nWire\nEmail: alan@wire.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Britta Hale\nNaval Postgraduate School\nEmail: britta.hale@nps.edu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Srinivas Inguva\nEmail: singuva@yahoo.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Konrad Kohbrok\nPhoenix R&D\nEmail: konrad.kohbrok@datashrine.de",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Albert Kwon\nMIT\nEmail: kwonal@mit.edu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Tom Leavy\nAmazon\nEmail: tomleavy@amazon.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Brendan McMillion\nEmail: brendanmcmillion@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Marta Mularczyk\nAmazon\nEmail: mulmarta@amazon.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Eric Rescorla\nMozilla\nEmail: ekr@rtfm.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Michael Rosenberg\nTrail of Bits\nEmail: michael.rosenberg@trailofbits.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Théophile Wallez\nInria\nEmail: theophile.wallez@inria.fr",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Thyla van der Merwe\nRoyal Holloway, University of London\nEmail: tjvdmerwe@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "Richard Barnes\nCisco\nEmail: rlb@ipv.sx",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Benjamin Beurdouche\nInria & Mozilla\nEmail: ietf@beurdouche.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Raphael Robert\nPhoenix R&D\nEmail: ietf@raphaelrobert.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jon Millican\nMeta Platforms\nEmail: jmillican@meta.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Emad Omara\nEmail: emad.omara@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Katriel Cohn-Gordon\nUniversity of Oxford\nEmail: me@katriel.co.uk",
      "raw": true,
      "ja": ""
    }
  ]
}