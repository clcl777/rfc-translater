{
  "title": {
    "text": "RFC 9528 - Ephemeral Diffie-Hellman Over COSE (EDHOC)",
    "ja": "RFC 9528 - Ephemeral Diffie-Hellman over Cose（Edhoc）"
  },
  "number": 9528,
  "created_at": "2024-03-24 17:00:08.142416+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       G. Selander\nRequest for Comments: 9528                             J. Preuß Mattsson\nCategory: Standards Track                                   F. Palombini\nISSN: 2070-1721                                                 Ericsson\n                                                              March 2024",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Ephemeral Diffie-Hellman Over COSE (EDHOC)",
      "title": true,
      "section_title": true,
      "ja": "Ephemeral Diffie-Hellman over Cose（Edhoc）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document specifies Ephemeral Diffie-Hellman Over COSE (EDHOC), a very compact and lightweight authenticated Diffie-Hellman key exchange with ephemeral keys. EDHOC provides mutual authentication, forward secrecy, and identity protection. EDHOC is intended for usage in constrained scenarios, and a main use case is to establish an Object Security for Constrained RESTful Environments (OSCORE) security context. By reusing CBOR Object Signing and Encryption (COSE) for cryptography, Concise Binary Object Representation (CBOR) for encoding, and Constrained Application Protocol (CoAP) for transport, the additional code size can be kept very low.",
      "ja": "このドキュメントは、非常にコンパクトで軽量の認証されたDiffie-Hellmanキーとはかなかキーとの非常にコンパクトで軽量の認証されたDiffie-Hellmanキー交換であるCose（Edhoc）を超えるEphemeral Diffie-Hellmanを指定しています。EDHOCは、相互認証、前方秘密、およびアイデンティティ保護を提供します。EDHOCは、制約付きシナリオでの使用を目的としており、主なユースケースは、制約されたRESTFUL環境（OSCORE）セキュリティコンテキストのオブジェクトセキュリティを確立することです。暗号化のためのCBORオブジェクトの署名と暗号化（COSE）、エンコード用の簡潔なバイナリオブジェクト表現（CBOR）、および輸送用の制約付きアプリケーションプロトコル（COAP）を再利用することにより、追加のコードサイズを非常に低く保つことができます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準トラックドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 7841のセクション2で入手できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9528.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https://www.rfc-editor.org/info/rfc9528で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2024 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2024 IETF Trustおよび文書著者として特定された人。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、改訂されたBSDライセンスで説明されている保証なしで提供されるように、改訂されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Motivation\n  1.2.  Message Size Examples\n  1.3.  Document Structure\n  1.4.  Terminology and Requirements Language\n2.  EDHOC Outline\n3.  Protocol Elements\n  3.1.  General\n  3.2.  Method\n  3.3.  Connection Identifiers\n  3.4.  Transport\n  3.5.  Authentication Parameters\n  3.6.  Cipher Suites\n  3.7.  Ephemeral Public Keys\n  3.8.  External Authorization Data (EAD)\n  3.9.  Application Profile\n4.  Key Derivation\n  4.1.  Keys for EDHOC Message Processing\n  4.2.  Keys for EDHOC Applications\n5.  Message Formatting and Processing\n  5.1.  EDHOC Message Processing Outline\n  5.2.  EDHOC Message 1\n  5.3.  EDHOC Message 2\n  5.4.  EDHOC Message 3\n  5.5.  EDHOC Message 4\n6.  Error Handling\n  6.1.  Success\n  6.2.  Unspecified Error\n  6.3.  Wrong Selected Cipher Suite\n  6.4.  Unknown Credential Referenced\n7.  EDHOC Message Deduplication\n8.  Compliance Requirements\n9.  Security Considerations\n  9.1.  Security Properties\n  9.2.  Cryptographic Considerations\n  9.3.  Cipher Suites and Cryptographic Algorithms\n  9.4.  Post-Quantum Considerations\n  9.5.  Unprotected Data and Privacy\n  9.6.  Updated Internet Threat Model Considerations\n  9.7.  Denial of Service\n  9.8.  Implementation Considerations\n10. IANA Considerations\n  10.1.  EDHOC Exporter Label Registry\n  10.2.  EDHOC Cipher Suites Registry\n  10.3.  EDHOC Method Type Registry\n  10.4.  EDHOC Error Codes Registry\n  10.5.  EDHOC External Authorization Data Registry\n  10.6.  COSE Header Parameters Registry\n  10.7.  Well-Known URI Registry\n  10.8.  Media Types Registry\n  10.9.  CoAP Content-Formats Registry\n  10.10. Resource Type (rt=) Link Target Attribute Values Registry\n  10.11. Expert Review Instructions\n11. References\n  11.1.  Normative References\n  11.2.  Informative References\nAppendix A.  Use with OSCORE and Transfer over CoAP\n  A.1.  Deriving the OSCORE Security Context\n  A.2.  Transferring EDHOC over CoAP\nAppendix B.  Compact Representation\nAppendix C.  Use of CBOR, CDDL, and COSE in EDHOC\n  C.1.  CBOR and CDDL\n  C.2.  CDDL Definitions\n  C.3.  COSE\nAppendix D.  Authentication-Related Verifications\n  D.1.  Validating the Authentication Credential\n  D.2.  Identities\n  D.3.  Certification Path and Trust Anchors\n  D.4.  Revocation Status\n  D.5.  Unauthenticated Operation\nAppendix E.  Use of External Authorization Data\nAppendix F.  Application Profile Example\nAppendix G.  Long PLAINTEXT_2\nAppendix H.  EDHOC_KeyUpdate\nAppendix I.  Example Protocol State Machine\n  I.1.  Initiator State Machine\n  I.2.  Responder State Machine\nAcknowledgments\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 0,
      "text": "1.1. Motivation",
      "section_title": true,
      "ja": "1.1. モチベーション"
    },
    {
      "indent": 3,
      "text": "Many Internet of Things (IoT) deployments require technologies that are highly performant in constrained environments [RFC7228]. IoT devices may be constrained in various ways, including memory, storage, processing capacity, and power. The connectivity for these settings may also exhibit constraints, such as unreliable and lossy channels, highly restricted bandwidth, and dynamic topology. The IETF has acknowledged this problem by standardizing a range of lightweight protocols and enablers designed for the IoT, including CoAP [RFC7252], CBOR [RFC8949], and Static Context Header Compression (SCHC) [RFC8724].",
      "ja": "多くのモノのインターネット（IoT）の展開には、制約された環境で非常にパフォーマンスのあるテクノロジーが必要です[RFC7228]。IoTデバイスは、メモリ、ストレージ、処理能力、電源など、さまざまな方法で制約される場合があります。これらの設定の接続性は、信頼性が高く損失したチャネル、高度に制限された帯域幅、動的トポロジなどの制約を示す場合があります。IETFは、COAP [RFC7252]、CBOR [RFC8949]、静的コンテキストヘッダー圧縮（SCHC）[RFC8724]を含むIoT向けに設計されたさまざまな軽量プロトコルとイネーブラーを標準化することにより、この問題を認めています。"
    },
    {
      "indent": 3,
      "text": "The need for special protocols targeting constrained IoT deployments extends also to the security domain [LAKE-REQS]. Important characteristics in constrained environments are the number of round trips and protocol message sizes, which (if kept low) can contribute to good performance by enabling transport over a small number of radio frames, reducing latency due to fragmentation, duty cycles, etc. Another important criterion is code size, which may be prohibitively large for certain deployments due to device capabilities or network load during firmware updates. Some IoT deployments also need to support a variety of underlying transport technologies, potentially even with a single connection.",
      "ja": "制約されたIoT展開をターゲットにする特別なプロトコルの必要性は、セキュリティドメイン[Lake-Reqs]にも拡張されます。制約された環境の重要な特性は、往復の数とプロトコルメッセージサイズの数です。これは、少数の無線フレームでの輸送を可能にし、断片化、デューティサイクルなどのために遅延を減らすことにより、良いパフォーマンスに貢献できます。重要な基準はコードサイズであり、これは、ファームウェアの更新中のデバイス機能またはネットワークロードにより、特定の展開に非常に大きい場合があります。一部のIoT展開には、単一の接続がある場合でも、潜在的に潜在的に基礎となる輸送技術をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Some security solutions for such settings exist already. COSE [RFC9052] specifies basic application-layer security services efficiently encoded in CBOR. Another example is OSCORE [RFC8613], which is a lightweight communication security extension to CoAP using CBOR and COSE. In order to establish good quality cryptographic keys for security protocols such as COSE and OSCORE, the two endpoints may run an authenticated Diffie-Hellman key exchange protocol, from which shared secret keying material can be derived. Such a key exchange protocol should also be lightweight to prevent bad performance in case of repeated use, e.g., due to device rebooting or frequent rekeying for security reasons or to avoid latencies in a network formation setting with many devices authenticating at the same time.",
      "ja": "このような設定のいくつかのセキュリティソリューションはすでに存在しています。COSE [RFC9052]は、CBORで効率的にエンコードされた基本的なアプリケーションレイヤーセキュリティサービスを指定します。別の例は、CBORとCOSEを使用してCOAPを使用するための軽量通信セキュリティ拡張であるOSCORE [RFC8613]です。COSEやOSCOREなどのセキュリティプロトコルの良質の暗号化キーを確立するために、2つのエンドポイントは、認証されたDiffie-Hellmanキー交換プロトコルを実行する場合があります。このようなキーエクスチェンジプロトコルは、デバイスの再起動やセキュリティ上の理由のために頻繁に再起動するため、または多くのデバイスが同時に認証されているネットワーク形成設定でのレイテンシーを回避するために、繰り返し使用した場合に悪いパフォーマンスを防ぐための軽量である必要があります。"
    },
    {
      "indent": 3,
      "text": "This document specifies Ephemeral Diffie-Hellman Over COSE (EDHOC), a lightweight authenticated key exchange protocol providing good security properties including forward secrecy, identity protection, and cipher suite negotiation. Authentication can be based on raw public keys (RPKs) or public key certificates and requires the application to provide input on how to verify that endpoints are trusted. This specification supports the referencing of credentials in order to reduce message overhead, but credentials may alternatively be embedded in the messages. EDHOC does not currently support Pre-Shared Key (PSK) authentication as authentication with static Diffie-Hellman (DH) public keys by reference produces equally small message sizes but with much simpler key distribution and identity protection.",
      "ja": "このドキュメントは、前方の秘密、アイデンティティ保護、暗号スイートの交渉などの優れたセキュリティプロパティを提供する軽量認証キーエクスチェンジプロトコルであるCOSE（EDHOC）を超えるEphemeral Diffie-Hellmanを指定しています。認証は、生の公開キー（RPK）または公開キーの証明書に基づいている可能性があり、エンドポイントが信頼されていることを確認する方法に関する入力を提供するためにアプリケーションが必要です。この仕様は、メッセージのオーバーヘッドを減らすための資格情報の参照をサポートしますが、資格情報は代わりにメッセージに組み込まれる場合があります。Edhocは現在、参照による静的Diffie-Hellman（DH）パブリックキーを使用した認証として、事前共有キー（PSK）認証をサポートしていません。"
    },
    {
      "indent": 3,
      "text": "EDHOC makes use of known protocol constructions, such as SIGn-and-MAc [SIGMA], the Noise XX pattern [Noise], and Extract-and-Expand [RFC5869]. EDHOC uses COSE for cryptography and identification of credentials (including COSE_Key, CBOR Web Token (CWT), CWT Claims Set (CCS), X.509, and CBOR-encoded X.509 (C509) certificates; see Section 3.5.2). COSE provides crypto agility and enables the use of future algorithms and credential types targeting IoT.",
      "ja": "Edhocは、記号[Sigma]、ノイズXXパターン[ノイズ]、抽出および拡張[RFC5869]などの既知のプロトコル構造を利用しています。EDHOCは、暗号化および資格情報の識別にCOSEを使用しています（COSE_KEY、CBOR Web Token（CWT）、CWTクレームセット（CCS）、X.509、およびCBORがエンコードしたX.509（C509）証明書を使用します。セクション3.5.2を参照）。COSEは暗号の敏ility性を提供し、IoTをターゲットとする将来のアルゴリズムと資格型タイプの使用を可能にします。"
    },
    {
      "indent": 3,
      "text": "EDHOC is designed for highly constrained settings, making it especially suitable for low-power networks [RFC8376] such as Cellular IoT, IPv6 over the TSCH mode of IEEE 802.15.4e (6TiSCH), and LoRaWAN. A main objective for EDHOC is to be a lightweight authenticated key exchange for OSCORE, i.e., to provide authentication and session key establishment for IoT use cases such as those built on CoAP [RFC7252] involving 'things' with embedded microcontrollers, sensors, and actuators. By reusing the same lightweight primitives as OSCORE (CBOR, COSE, and CoAP), the additional code size can be kept very low. Note that while CBOR and COSE primitives are built into the protocol messages, EDHOC is not bound to a particular transport.",
      "ja": "EDHOCは、高度に制約された設定用に設計されており、IEEE 802.15.4E（6Tisch）のTSCHモードでのセルラーIoT、IPv6などの低電力ネットワーク[RFC8376]、およびLorawanに特に適しています。EDHOCの主な目的は、OSCOREの軽量認証キー交換、つまり、埋め込みマイクロコントローラー、センサー、アクチュエータを含む「物」を含むCOAP [RFC7252]などのIoTユースケースの認証とセッションのキー施設を提供することです。。OSCORE（CBOR、COSE、およびCOAP）と同じ軽量プリミティブを再利用することにより、追加のコードサイズを非常に低く保つことができます。CBORとCOSEプリミティブはプロトコルメッセージに組み込まれていますが、EDHOCは特定の輸送に拘束されていません。"
    },
    {
      "indent": 3,
      "text": "A typical setting is when one of the endpoints is constrained or in a constrained network and the other endpoint is a node on the Internet (such as a mobile phone). Thing-to-thing interactions over constrained networks are also relevant since both endpoints would then benefit from the lightweight properties of the protocol. EDHOC could, e.g., be run when a device connects for the first time or to establish fresh keys that are not revealed by a later compromise of the long-term keys.",
      "ja": "典型的な設定は、エンドポイントの1つが制約されているか、制約されたネットワークで、もう1つのエンドポイントがインターネット上のノード（携帯電話など）である場合です。両方のエンドポイントがプロトコルの軽量特性から利益を得るため、制約されたネットワークを介したものと縮小ネットワークを介したものも関連しています。たとえば、Edhocは、デバイスが初めて接続したときに実行したり、長期キーの妥協によって明らかにされていない新鮮なキーを確立することができます。"
    },
    {
      "indent": 0,
      "text": "1.2. Message Size Examples",
      "section_title": true,
      "ja": "1.2. メッセージサイズの例"
    },
    {
      "indent": 3,
      "text": "Examples of EDHOC message sizes are shown in Table 1, which use different kinds of authentication keys and COSE header parameters for identification, including static Diffie-Hellman keys or signature keys, either in CWT/CCS [RFC8392] identified by a key identifier using 'kid' [RFC9052] or in X.509 certificates identified by a hash value using 'x5t' [RFC9360]. EDHOC always uses ephemeral-ephemeral key exchange. As a comparison, in the case of RPK authentication and when transferred in CoAP, the EDHOC message size can be less than 1/7 of the DTLS 1.3 handshake [RFC9147] with Ephemeral Elliptic Curve Diffie-Hellman (ECDHE) and connection ID; see [CoAP-SEC-PROT].",
      "ja": "EDHOCメッセージサイズの例を表1に示します。表1には、さまざまな種類の認証キーを使用し、CWT/CCS [RFC8392]のいずれかの静的diffie-hellmanキーまたは署名キーを含む識別にCOSEヘッダーパラメーターを使用します。kid '[rfc9052]または「x5t」[rfc9360]を使用してハッシュ値によって識別されるx.509証明書。Edhocは常に短命性のキー交換を使用しています。比較として、RPK認証の場合、COAPで転送された場合、EDHOCメッセージサイズは、DTLS 1.3ハンドシェイク[RFC9147]の1/7未満であり、短命の楕円曲線diffie-hellman（ecdhe）と接続ID;[coap-sec-prot]を参照してください。"
    },
    {
      "indent": 14,
      "text": "+===========+================+================+\n|           | Static DH Keys | Signature Keys |\n+===========+==========+=====+==========+=====+\n|           |      kid | x5t |      kid | x5t |\n+===========+==========+=====+==========+=====+\n| message_1 |       37 |  37 |       37 |  37 |\n+-----------+----------+-----+----------+-----+\n| message_2 |       45 |  58 |      102 | 115 |\n+-----------+----------+-----+----------+-----+\n| message_3 |       19 |  33 |       77 |  90 |\n+-----------+----------+-----+----------+-----+\n| Total     |      101 | 128 |      216 | 242 |\n+-----------+----------+-----+----------+-----+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Table 1: Examples of EDHOC Message Sizes in Bytes",
      "ja": "表1：バイト内のEDHOCメッセージサイズの例"
    },
    {
      "indent": 0,
      "text": "1.3. Document Structure",
      "section_title": true,
      "ja": "1.3. ドキュメント構造"
    },
    {
      "indent": 3,
      "text": "The remainder of the document is organized as follows: Section 2 outlines EDHOC authenticated with signature keys; Section 3 describes the protocol elements of EDHOC, including formatting of the ephemeral public keys; Section 4 specifies the key derivation; Section 5 specifies message processing for EDHOC authenticated with signature keys or static Diffie-Hellman keys; Section 6 describes the error messages; Section 7 describes EDHOC support for transport that does not handle message duplication; and Section 8 lists compliance requirements. Note that normative text is also used in appendices, in particular Appendix A.",
      "ja": "ドキュメントの残りの部分は次のように編成されています。セクション2では、署名キーで認証されたEDHOCの概要を示します。セクション3では、EDHOCのプロトコル要素について説明します。これには、はかないパブリックキーのフォーマットが含まれます。セクション4は、キー派生を指定します。セクション5では、署名キーまたは静的diffie-hellmanキーで認証されたEDHOCのメッセージ処理を指定します。セクション6では、エラーメッセージについて説明します。セクション7では、メッセージの複製を処理しない輸送のEDHOCサポートについて説明します。セクション8には、コンプライアンス要件がリストされています。規範的なテキストは付録、特に付録Aでも使用されていることに注意してください。"
    },
    {
      "indent": 0,
      "text": "1.4. Terminology and Requirements Language",
      "section_title": true,
      "ja": "1.4. 用語と要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "「必須」、「必要」、「必須」、「shall」、「shall」、「suff」、 \"not\"、 \"becommended\"、 \"becommented\"、 \"may\"、 \"optional「このドキュメントでは、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "Readers are expected to be familiar with the terms and concepts described in CBOR [RFC8949], CBOR Sequences [RFC8742], COSE Structures and Processing [RFC9052], COSE Algorithms [RFC9053], CWT and CCS [RFC8392], and the Concise Data Definition Language (CDDL) [RFC8610], which is used to express CBOR data structures. Examples of CBOR and CDDL are provided in Appendix C.1. When referring to CBOR, this specification always refers to Deterministically Encoded CBOR, as specified in Sections 4.2.1 and 4.2.2 of [RFC8949]. The single output from authenticated encryption (including the authentication tag) is called \"ciphertext\", following [RFC5116].",
      "ja": "読者は、CBOR [RFC8949]、CBORシーケンス[RFC8742]、COSE構造と処理[RFC9052]、COSEアルゴリズム[RFC9053]、CWTおよびCCS [RFC8392]、およびCSIS DATA LYSIFINAMENTに記載されている用語と概念に精通していることが期待されています。言語（CDDL）[RFC8610]。これは、CBORデータ構造を表現するために使用されます。CBORとCDDLの例は、付録C.1に記載されています。CBORを参照する場合、この仕様は常に[RFC8949]のセクション4.2.1および4.2.2で指定されているように、決定論的にエンコードされたCBORを指します。認証された暗号化（認証タグを含む）からの単一出力は、[rfc5116]に続いて「ciphertext」と呼ばれます。"
    },
    {
      "indent": 0,
      "text": "2. EDHOC Outline",
      "section_title": true,
      "ja": "2. Edhocアウトライン"
    },
    {
      "indent": 3,
      "text": "EDHOC supports different authentication methods of the ephemeral-ephemeral Diffie-Hellman key exchange. This document specifies authentication methods based on signature keys and static Diffie-Hellman keys. This section outlines the signature-key-based method. Further details of protocol elements and other authentication methods are provided in the remainder of this document.",
      "ja": "EDHOCは、はか一方的なfe diffie-hellmanキーエクスチェンジのさまざまな認証方法をサポートしています。このドキュメントは、署名キーと静的diffie-hellmanキーに基づいた認証方法を指定します。このセクションでは、署名キーベースのメソッドの概要を説明します。このドキュメントの残りの部分では、プロトコル要素とその他の認証方法の詳細が提供されています。"
    },
    {
      "indent": 3,
      "text": "SIGn-and-MAc (SIGMA) is a family of theoretical protocols with a number of variants [SIGMA]. Like in Internet Key Exchange Protocol Version 2 (IKEv2) [RFC7296] and (D)TLS 1.3 [RFC8446] [RFC9147], EDHOC authenticated with signature keys is built on a variant of the SIGMA protocol, SIGMA-I, which provides identity protection against active attacks on the party initiating the protocol. Also like IKEv2, EDHOC implements the MAC-then-Sign variant of the SIGMA-I protocol. The message flow (excluding an optional fourth message) is shown in Figure 1.",
      "ja": "Sign-and-Mac（Sigma）は、多くのバリエーションを持つ理論的プロトコルのファミリーです[Sigma]。インターネットキー交換プロトコルバージョン2（IKEV2）[RFC7296]および（d）TLS 1.3 [RFC8446] [RFC9147]と同様に、署名キーで認証されたEDHOCは、シグマプロトコルのバリアントに基づいて構築されます。プロトコルを開始する当事者への積極的な攻撃に対して。また、IKEV2と同様に、EDHOCはSigma-IプロトコルのMac-Then-Signバリアントを実装します。メッセージフロー（オプションの4番目のメッセージを除く）を図1に示します。"
    },
    {
      "indent": 3,
      "text": "Initiator                                                   Responder\n|                                G_X                                |\n+------------------------------------------------------------------>|\n|                                                                   |\n|      G_Y, Enc( ID_CRED_R, Sig( R; MAC( CRED_R, G_X, G_Y ) ) )     |\n|<------------------------------------------------------------------+\n|                                                                   |\n|        AEAD( ID_CRED_I, Sig( I; MAC( CRED_I, G_Y, G_X ) ) )       |\n+------------------------------------------------------------------>|\n|                                                                   |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Figure 1: MAC-then-Sign Variant of the SIGMA-I Protocol Used by the EDHOC Method 0",
      "ja": "図1：EDHOCメソッド0で使用されるSigma-IプロトコルのMac-Then-Signバリアント0"
    },
    {
      "indent": 3,
      "text": "The parties exchanging messages in an EDHOC session are called the Initiator (I) and the Responder (R), where the Initiator sends message_1 (see Section 3). They exchange ephemeral public keys, compute a shared secret session key PRK_out, and derive symmetric application keys used to protect application data.",
      "ja": "EDHOCセッションでメッセージを交換する当事者は、イニシエーター（i）およびレスポンダー（R）と呼ばれ、イニシエーターはメッセージ_1を送信します（セクション3を参照）。短命のパブリックキーを交換し、共有秘密セッションキーPRK_outを計算し、アプリケーションデータを保護するために使用される対称アプリケーションキーを導き出します。"
    },
    {
      "indent": 6,
      "text": "* G_X and G_Y are the Elliptic Curve Diffie-Hellman (ECDH) ephemeral public keys of I and R, respectively.",
      "ja": "* G_XとG_Yは、それぞれIとRの楕円曲線diffie-hellman（ECDH）は、それぞれiとRのパブリックキーです。"
    },
    {
      "indent": 6,
      "text": "* CRED_I and CRED_R are the authentication credentials containing the public authentication keys of I and R, respectively.",
      "ja": "* CRED_IとCRED_Rは、それぞれIとRのパブリック認証キーを含む認証資格情報です。"
    },
    {
      "indent": 6,
      "text": "* ID_CRED_I and ID_CRED_R are used to identify and optionally transport the credentials of I and R, respectively.",
      "ja": "* ID_CRED_IおよびID_CRED_Rは、それぞれIとRの資格情報を識別し、オプションで輸送するために使用されます。"
    },
    {
      "indent": 6,
      "text": "* Sig(I; . ) and Sig(R; . ) denote signatures made with the private authentication key of I and R, respectively.",
      "ja": "* sig（i;。）およびsig（r;。）は、それぞれiとrのプライベート認証キーで作成された署名を示します。"
    },
    {
      "indent": 6,
      "text": "* Enc(), AEAD(), and MAC() denote encryption, Authenticated Encryption with Associated Data, and Message Authentication Code -- crypto algorithms applied with keys derived from one or more shared secrets calculated during the protocol.",
      "ja": "* enc（）、aead（）、およびmac（）は、暗号化、関連するデータを使用した認証された暗号化、およびメッセージ認証コード - プロトコル中に計算された1つ以上の共有シークレットから派生したキーで適用される暗号アルゴリズムを示します。"
    },
    {
      "indent": 3,
      "text": "In order to create a \"full-fledged\" protocol, some additional protocol elements are needed. This specification adds:",
      "ja": "「本格的な」プロトコルを作成するには、いくつかの追加のプロトコル要素が必要です。この仕様は次のように追加されます"
    },
    {
      "indent": 6,
      "text": "* transcript hashes (hashes of message data), TH_2, TH_3, and TH_4, used for key derivation and as additional authenticated data,",
      "ja": "* トランスクリプトハッシュ（メッセージデータのハッシュ）、TH_2、TH_3、およびTH_4は、キー派生および追加の認証データとして使用されます。"
    },
    {
      "indent": 6,
      "text": "* computationally independent keys derived from the ECDH shared secret and used for authenticated encryption of different messages,",
      "ja": "* ECDH共有秘密から派生した計算的に独立したキーは、異なるメッセージの認証された暗号化に使用されます、"
    },
    {
      "indent": 6,
      "text": "* an optional fourth message giving key confirmation to I in deployments where no protected application data is sent from R to I,",
      "ja": "* 保護されたアプリケーションデータがrからiに送信されない展開でiに重要な確認を与えるオプションの4番目のメッセージ、"
    },
    {
      "indent": 6,
      "text": "* a keying material exporter and a key update function with forward secrecy,",
      "ja": "* キーイングマテリアルエクスポーターと、フォワード秘密を備えたキーアップデート機能、"
    },
    {
      "indent": 6,
      "text": "* secure negotiation of the cipher suite,",
      "ja": "* 暗号スイートの安全な交渉、"
    },
    {
      "indent": 6,
      "text": "* method types, error handling, and padding,",
      "ja": "* メソッドタイプ、エラー処理、およびパディング、"
    },
    {
      "indent": 6,
      "text": "* the selection of connection identifiers, C_I and C_R, which may be used in EDHOC to identify the protocol state, and",
      "ja": "* EDHOCで使用されるためにプロトコル状態を識別するために使用できる接続識別子C_IおよびC_Rの選択、および"
    },
    {
      "indent": 6,
      "text": "* transport of external authorization data.",
      "ja": "* 外部認証データの輸送。"
    },
    {
      "indent": 3,
      "text": "EDHOC is designed to encrypt and integrity protect as much information as possible. Symmetric keys and random material used in EDHOC are derived using EDHOC_KDF with as much previous information as possible; see Figure 6. EDHOC is furthermore designed to be as compact and lightweight as possible, in terms of message sizes, processing, and the ability to reuse already existing CBOR, COSE, and CoAP libraries. Like in (D)TLS, authentication is the responsibility of the application. EDHOC identifies (and optionally transports) authentication credentials and provides proof-of-possession of the private authentication key.",
      "ja": "Edhocは、可能な限り多くの情報を暗号化し、整合性を保護するように設計されています。EDHOCで使用される対称キーとランダム材料は、EDHOC_KDFを使用して導出されます。図6を参照してください。EDHOCは、メッセージサイズ、処理、および既存のCBOR、COSE、およびCOAPライブラリの再利用機能の観点から、可能な限りコンパクトで軽量であるように設計されています。（d）TLSと同様に、認証はアプリケーションの責任です。EDHOCは、認証資格情報を識別（およびオプションで輸送）し、プライベート認証キーの入金の証明を提供します。"
    },
    {
      "indent": 3,
      "text": "To simplify for implementors, the use of CBOR, CDDL, and COSE in EDHOC is summarized in Appendix C. Test vectors, including CBOR diagnostic notation, are provided in [RFC9529].",
      "ja": "実装者を簡素化するために、EDHOCでのCBOR、CDDL、およびCOSEの使用は、付録Cにまとめられています。CBOR診断表記を含むテストベクターは[RFC9529]に記載されています。"
    },
    {
      "indent": 0,
      "text": "3. Protocol Elements",
      "section_title": true,
      "ja": "3. プロトコル要素"
    },
    {
      "indent": 0,
      "text": "3.1. General",
      "section_title": true,
      "ja": "3.1. 一般的な"
    },
    {
      "indent": 3,
      "text": "The EDHOC protocol consists of three mandatory messages (message_1, message_2, and message_3), an optional fourth message (message_4), and an error message, between an Initiator (I) and a Responder (R). The odd messages are sent by I, the even by R. Both I and R can send error messages. The roles have slightly different security properties that should be considered when the roles are assigned; see Section 9.1. All EDHOC messages are CBOR Sequences [RFC8742] and are defined to be deterministically encoded CBOR as specified in Section 4.2.1 of [RFC8949]. Figure 2 illustrates an EDHOC message flow with the optional fourth message as well as the content of each message. The protocol elements in the figure are introduced in Sections 3 and 5. Message formatting and processing are specified in Sections 5 and 6.",
      "ja": "EDHOCプロトコルは、3つの必須メッセージ（message_1、message_2、およびmessage_3）、オプションの4番目のメッセージ（message_4）、およびイニシエーター（i）とレスポンダー（R）の間のエラーメッセージで構成されています。奇妙なメッセージはiによって送信され、さらにはRによっても送信されます。IとRの両方はエラーメッセージを送信できます。役割には、役割が割り当てられたときに考慮すべきセキュリティプロパティがわずかに異なります。セクション9.1を参照してください。すべてのEDHOCメッセージはCBORシーケンス[RFC8742]であり、[RFC8949]のセクション4.2.1で指定されているように、決定論的にエンコードされたCBORであると定義されています。図2は、オプションの4番目のメッセージと各メッセージの内容を備えたEDHOCメッセージフローを示しています。図のプロトコル要素は、セクション3および5で紹介されています。メッセージのフォーマットと処理は、セクション5および6で指定されています。"
    },
    {
      "indent": 3,
      "text": "Application data may be protected using the agreed application algorithms (AEAD, hash) in the selected cipher suite (see Section 3.6), and the application can make use of the established connection identifiers C_I and C_R (see Section 3.3). Media types that may be used for EDHOC are defined in Section 10.8.",
      "ja": "アプリケーションデータは、選択した暗号スイートの合意されたアプリケーションアルゴリズム（AEAD、ハッシュ）を使用して保護できます（セクション3.6を参照）。アプリケーションは、確立された接続識別子C_IおよびC_Rを使用できます（セクション3.3を参照）。EDHOCに使用できるメディアタイプは、セクション10.8で定義されています。"
    },
    {
      "indent": 3,
      "text": "The Initiator can derive symmetric application keys after creating EDHOC message_3; see Section 4.2.1. Protected application data can therefore be sent in parallel or together with EDHOC message_3. EDHOC message_4 is typically not sent.",
      "ja": "イニシエーターは、EDHOC Message_3を作成した後、対称アプリケーションキーを導出できます。セクション4.2.1を参照してください。したがって、保護されたアプリケーションデータは、EDHOC Message_3と並行して、または一緒に送信できます。EDHOC Message_4は通常送信されません。"
    },
    {
      "indent": 3,
      "text": "Initiator                                                   Responder\n|                 METHOD, SUITES_I, G_X, C_I, EAD_1                 |\n+------------------------------------------------------------------>|\n|                             message_1                             |\n|                                                                   |\n|       G_Y, Enc( C_R, ID_CRED_R, Signature_or_MAC_2, EAD_2 )       |\n|<------------------------------------------------------------------+\n|                             message_2                             |\n|                                                                   |\n|            AEAD( ID_CRED_I, Signature_or_MAC_3, EAD_3 )           |\n+------------------------------------------------------------------>|\n|                             message_3                             |\n|                                                                   |\n|                           AEAD( EAD_4 )                           |\n|<- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n|                             message_4                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 2: EDHOC Message Flow Including the Optional Fourth Message",
      "ja": "図2：オプションの4番目のメッセージを含むEDHOCメッセージフロー"
    },
    {
      "indent": 0,
      "text": "3.2. Method",
      "section_title": true,
      "ja": "3.2. 方法"
    },
    {
      "indent": 3,
      "text": "The data item METHOD in message_1 (see Section 5.2.1) is an integer specifying the authentication method. EDHOC currently supports authentication with signature or static Diffie-Hellman keys, as defined in the four authentication methods: 0, 1, 2, and 3; see Table 2. When using a static Diffie-Hellman key, the authentication is provided by a Message Authentication Code (MAC) computed from an ephemeral-static ECDH shared secret that enables significant reductions in message sizes. Note that, also in the static Diffie-Hellman-based authentication methods, there is an ephemeral-ephemeral Diffie-Hellman key exchange.",
      "ja": "Message_1（セクション5.2.1を参照）のデータ項目方法は、認証方法を指定する整数です。EDHOCは現在、4つの認証方法で定義されているように、署名または静的Diffie-Hellmanキーを使用して認証をサポートしています。表2を参照してください。静的diffie-hellmanキーを使用する場合、認証は、メッセージサイズの大幅な削減を可能にするはかない静的ECDH共有秘密から計算されたメッセージ認証コード（MAC）によって提供されます。また、静的diffie-hellmanベースの認証方法にも、はかなephemeral-femeral-femeral diffie-hellmanキー交換があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The Initiator and Responder need to have agreed on a single method to be used for EDHOC; see Section 3.9.",
      "ja": "イニシエーターとレスポンダーは、EDHOCに使用する単一の方法に同意する必要があります。セクション3.9を参照してください。"
    },
    {
      "indent": 6,
      "text": "+===================+====================+====================+\n| Method Type Value | Initiator          | Responder          |\n|                   | Authentication Key | Authentication Key |\n+===================+====================+====================+\n|                 0 | Signature Key      | Signature Key      |\n+-------------------+--------------------+--------------------+\n|                 1 | Signature Key      | Static DH Key      |\n+-------------------+--------------------+--------------------+\n|                 2 | Static DH Key      | Signature Key      |\n+-------------------+--------------------+--------------------+\n|                 3 | Static DH Key      | Static DH Key      |\n+-------------------+--------------------+--------------------+\n|                23 | Reserved           | Reserved           |\n+-------------------+--------------------+--------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Table 2: Authentication Keys for Method Types",
      "ja": "表2：メソッドタイプの認証キー"
    },
    {
      "indent": 3,
      "text": "EDHOC does not have a dedicated message field to indicate the protocol version. Breaking changes to EDHOC can be introduced by specifying and registering new methods.",
      "ja": "Edhocには、プロトコルバージョンを示すための専用のメッセージフィールドがありません。EDHOCの変更を破ることは、新しい方法を指定および登録することで導入できます。"
    },
    {
      "indent": 0,
      "text": "3.3. Connection Identifiers",
      "section_title": true,
      "ja": "3.3. 接続識別子"
    },
    {
      "indent": 3,
      "text": "EDHOC includes the selection of connection identifiers (C_I and C_R) identifying a connection for which keys are agreed.",
      "ja": "EDHOCには、キーが合意されている接続を識別する接続識別子（C_IおよびC_R）の選択が含まれます。"
    },
    {
      "indent": 3,
      "text": "Connection identifiers may be used to correlate EDHOC messages and facilitate the retrieval of protocol state during an EDHOC session (see Section 3.4) or may be used in applications of EDHOC, e.g., in OSCORE (see Section 3.3.3). The connection identifiers do not have any cryptographic purpose in EDHOC and only facilitate the retrieval of security data associated with the protocol state.",
      "ja": "接続識別子を使用して、EDHOCメッセージを相関させ、EDHOCセッション中にプロトコル状態の取得を促進する場合があります（セクション3.4を参照）、またはEDHOC、たとえばOSCORE（セクション3.3.3を参照）のアプリケーションで使用できます。接続識別子は、EDHOCに暗号化目的を持たず、プロトコル状態に関連付けられたセキュリティデータの検索のみを促進します。"
    },
    {
      "indent": 3,
      "text": "Connection identifiers in EDHOC are intrinsically byte strings. Most constrained devices only have a few connections for which short identifiers may be sufficient. In some cases, minimum length identifiers are necessary to comply with overhead requirements. However, CBOR byte strings -- with the exception of the empty byte string h'', which encodes as one byte (0x40) -- are encoded as two or more bytes. To enable one-byte encoding of certain byte strings while maintaining CBOR encoding, EDHOC represents certain identifiers as CBOR integers on the wire; see Section 3.3.2.",
      "ja": "Edhocの接続識別子は、本質的にバイト文字列です。ほとんどの制約されたデバイスには、短い識別子で十分である可能性があるいくつかの接続しかありません。場合によっては、オーバーヘッド要件に準拠するために最小長さの識別子が必要です。ただし、1バイト（0x40）としてエンコードする空のバイト文字列h ''を除くCborバイト文字列は、2つ以上のバイトとしてエンコードされます。CBORエンコードを維持しながら特定のバイト文字列の1バイトのエンコードを有効にするために、EDHOCは特定の識別子をワイヤ上のCBOR整数として表します。セクション3.3.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.3.1. Selection of Connection Identifiers",
      "section_title": true,
      "ja": "3.3.1. 接続識別子の選択"
    },
    {
      "indent": 3,
      "text": "C_I and C_R are chosen by I and R, respectively. The Initiator selects C_I and sends it in message_1 for the Responder to use as a reference to the connection in communications with the Initiator. The Responder selects C_R and sends it in message_2 for the Initiator to use as a reference to the connection in communications with the Responder.",
      "ja": "C_IとC_Rは、それぞれIとRによって選択されます。イニシエーターはC_Iを選択し、Responderがイニシエーターとの通信の接続への参照として使用できるようにメッセージ_1で送信します。ResponderはC_Rを選択し、イニシエーターがResponderとの通信の接続への参照として使用できるようにMessage_2で送信します。"
    },
    {
      "indent": 3,
      "text": "If connection identifiers are used by an application protocol for which EDHOC establishes keys, then the selected connection identifiers SHALL adhere to the requirements for that protocol; see Section 3.3.3 for an example.",
      "ja": "EDHOCがキーを確立するアプリケーションプロトコルによって接続識別子が使用される場合、選択した接続識別子はそのプロトコルの要件を順守するものとします。例については、セクション3.3.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.3.2. Representation of Byte String Identifiers",
      "section_title": true,
      "ja": "3.3.2. バイト文字列識別子の表現"
    },
    {
      "indent": 3,
      "text": "To allow identifiers with minimal overhead on the wire, certain byte strings used in connection identifiers and credential identifiers (see Section 3.5.3) are defined to have integer representations.",
      "ja": "ワイヤー上のオーバーヘッドを最小限に抑える識別子を許可するために、接続された識別子と資格情報識別子（セクション3.5.3を参照）で使用される特定のバイト文字列が整数表現を持つと定義されています。"
    },
    {
      "indent": 3,
      "text": "The integers with one-byte CBOR encoding are -24, ..., 23; see Figure 3.",
      "ja": "1バイトのCBORエンコーディングを持つ整数は-24、...、23です。図3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Integer:  -24  -23  ... -11  ...  -2   -1    0    1  ...  15  ...  23\nEncoding:  37   36  ...  2A  ...  21   20   00   01  ...  0F  ...  17",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Figure 3: One-Byte CBOR-Encoded Integers",
      "ja": "図3：1バイトのCborエンコード整数"
    },
    {
      "indent": 3,
      "text": "The byte strings that coincide with a one-byte CBOR encoding of an integer MUST be represented by the CBOR encoding of that integer. Other byte strings are simply encoded as CBOR byte strings.",
      "ja": "整数の1バイトのCBORエンコードと一致するバイト文字列は、その整数のCBORエンコードによって表現する必要があります。他のバイト文字列は、単にCBORバイト文字列としてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 6,
      "text": "* 0x21 is represented by 0x21 (CBOR encoding of the integer -2), not by 0x4121 (CBOR encoding of the byte string 0x21).",
      "ja": "* 0x21は、0x21（整数-2のCborエンコード）で表され、0x4121（バイト文字列0x21のCborエンコード）で表されます。"
    },
    {
      "indent": 6,
      "text": "* 0x0D is represented by 0x0D (CBOR encoding of the integer 13), not by 0x410D (CBOR encoding of the byte string 0x0D).",
      "ja": "* 0x0Dは、0x410d（cbor encoding of the byte string 0x0d）ではなく、0x0d（整数13のcborエンコード）で表されます。"
    },
    {
      "indent": 6,
      "text": "* 0x18 is represented by 0x4118 (CBOR encoding of the byte string 0x18).",
      "ja": "* 0x18は0x4118（バイト文字列0x18のcborエンコード）で表されます。"
    },
    {
      "indent": 6,
      "text": "* 0x38 is represented by 0x4138 (CBOR encoding of the byte string 0x38).",
      "ja": "* 0x38は0x4138（バイト文字列0x38のCborエンコード）で表されます。"
    },
    {
      "indent": 6,
      "text": "* 0xABCD is represented by 0x42ABCD (CBOR encoding of the byte string 0xABCD).",
      "ja": "* 0XABCDは0x42ABCD（バイト文字列0xABCDのCBORエンコード）で表されます。"
    },
    {
      "indent": 3,
      "text": "One may view this representation of byte strings as a transport encoding, i.e., a byte string that parses as the one-byte CBOR encoding of an integer (i.e., integer in the interval -24, ..., 23) is just copied directly into the message, and a byte string that does not is encoded as a CBOR byte string during transport.",
      "ja": "このバイト文字列の表現は、輸送エンコーディング、つまり、整数の1バイトのCBORエンコードとして解析されるバイト文字列（つまり、間隔-24、...、23）を直接コピーするだけです。メッセージと、輸送中にCBORバイト文字列としてエンコードされていないバイト文字列がエンコードされます。"
    },
    {
      "indent": 12,
      "text": "Implementation Note: When implementing the byte string identifier representation, in some programming languages, it can help to define a new type or other data structure, which (in its user-facing API) behaves like a byte string but when serializing to CBOR produces a CBOR byte string or a CBOR integer depending on its value.",
      "ja": "実装注：バイト文字列識別子表現を実装する場合、一部のプログラミング言語では、（ユーザー向けのAPIで）新しいタイプまたはその他のデータ構造を定義するのに役立ちます。Cborバイト文字列またはその値に応じてCbor整数。"
    },
    {
      "indent": 0,
      "text": "3.3.3. Use of Connection Identifiers with OSCORE",
      "section_title": true,
      "ja": "3.3.3. OSCOREでの接続識別子の使用"
    },
    {
      "indent": 3,
      "text": "For OSCORE, the choice of connection identifier results in the endpoint selecting its Recipient ID (see Section 3.1 of [RFC8613]) for which certain uniqueness requirements apply (see Section 3.3 of [RFC8613]). Therefore, the Initiator and Responder MUST NOT select connection identifiers such that it results in the same OSCORE Recipient ID. Since the connection identifier is a byte string, it is converted to an OSCORE Recipient ID equal to the byte string.",
      "ja": "OSCOREの場合、接続識別子の選択により、特定の一意性要件が適用されるレシピエントID（[RFC8613]のセクション3.1を参照）を選択します（[RFC8613]のセクション3.3を参照）。したがって、イニシエーターとレスポンダーは、同じオスコアレシピエントIDになるように接続識別子を選択してはなりません。接続識別子はバイト文字列であるため、バイト文字列に等しいオスコア受信者IDに変換されます。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "* A connection identifier 0xFF (represented in the EDHOC message as 0x41FF; see Section 3.3.2) is converted to the OSCORE Recipient ID 0xFF.",
      "ja": "* 接続識別子0xff（EDHOCメッセージで0x41ffとして表され、セクション3.3.2を参照）がOSCORE受信者ID 0xffに変換されます。"
    },
    {
      "indent": 6,
      "text": "* A connection identifier 0x21 (represented in the EDHOC message as 0x21; see Section 3.3.2) is converted to the OSCORE Recipient ID 0x21.",
      "ja": "* 接続識別子0x21（EDHOCメッセージで0x21として表され、セクション3.3.2を参照）は、OSCORE受信者ID 0x21に変換されます。"
    },
    {
      "indent": 0,
      "text": "3.4. Transport",
      "section_title": true,
      "ja": "3.4. 輸送"
    },
    {
      "indent": 3,
      "text": "Cryptographically, EDHOC does not put requirements on the underlying layers. Received messages are processed as the expected next message according to the protocol state; see Section 5. If processing fails for any reason, then typically an error message is attempted to be sent and the EDHOC session is aborted.",
      "ja": "暗号化すると、Edhocは基礎となる層に要件を掲載していません。受信したメッセージは、プロトコル状態に従って予想される次のメッセージとして処理されます。セクション5を参照してください。処理が何らかの理由で失敗した場合、通常、エラーメッセージの送信を試み、EDHOCセッションが中止されます。"
    },
    {
      "indent": 3,
      "text": "EDHOC is not bound to a particular transport layer and can even be used in environments without IP. Ultimately, the application is free to choose how to transport EDHOC messages including errors. In order to avoid unnecessary message processing or protocol termination, it is RECOMMENDED to use reliable transport, such as CoAP in reliable mode, which is the default transport; see Appendix A.2. In general, the transport SHOULD handle:",
      "ja": "EDHOCは特定の輸送層にバインドされておらず、IPのない環境でも使用できます。最終的に、アプリケーションはエラーを含むEDHOCメッセージの輸送方法を自由に選択できます。不必要なメッセージ処理またはプロトコル終了を回避するために、デフォルトのトランスポートである信頼できるモードでのCOAPなど、信頼できる輸送を使用することをお勧めします。付録A.2を参照してください。一般的に、輸送は処理する必要があります。"
    },
    {
      "indent": 6,
      "text": "* message loss,",
      "ja": "* メッセージの損失、"
    },
    {
      "indent": 6,
      "text": "* message duplication (see Section 7 for an alternative),",
      "ja": "* メッセージの複製（代替案についてはセクション7を参照）、"
    },
    {
      "indent": 6,
      "text": "* flow control,",
      "ja": "* フロー制御、"
    },
    {
      "indent": 6,
      "text": "* congestion control,",
      "ja": "* 混雑制御、"
    },
    {
      "indent": 6,
      "text": "* fragmentation and reassembly,",
      "ja": "* 断片化と再組み立て、"
    },
    {
      "indent": 6,
      "text": "* demultiplexing EDHOC messages from other types of messages,",
      "ja": "* 他のタイプのメッセージからのedhocメッセージを非難する、"
    },
    {
      "indent": 6,
      "text": "* denial-of-service mitigation, and",
      "ja": "* サービス拒否緩和、および"
    },
    {
      "indent": 6,
      "text": "* message correlation (see Section 3.4.1).",
      "ja": "* メッセージ相関（セクション3.4.1を参照）。"
    },
    {
      "indent": 3,
      "text": "EDHOC does not require error-free transport since a change in message content is detected through the transcript hashes in a subsequent integrity verification; see Section 5. The transport does not require additional means to handle message reordering because of the lockstep processing of EDHOC.",
      "ja": "EDHOCは、メッセージコンテンツの変化がその後の整合性検証で転写産物のハッシュを介して検出されるため、エラーのないトランスポートを必要としません。セクション5を参照してください。トランスポートは、EDHOCのロックステップ処理のためにメッセージの並べ替えを処理するための追加手段を必要としません。"
    },
    {
      "indent": 3,
      "text": "EDHOC is designed to enable an authenticated key exchange with small messages, where the minimum message sizes are of the order illustrated in the first column of Table 1. There is no maximum message size specified by the protocol; for example, this is dependent on the size of the authentication credentials (if they are transported, see Section 3.5). The encryption of very large content in message_2 when using certain hash algorithms is described in Appendix G.",
      "ja": "EDHOCは、小さなメッセージを使用した認証されたキー交換を有効にするように設計されています。ここで、最小メッセージサイズは表1の最初の列に示されています。プロトコルで指定された最大メッセージサイズはありません。たとえば、これは認証資格情報のサイズに依存します（それらが輸送されている場合は、セクション3.5を参照）。特定のハッシュアルゴリズムを使用する場合のMessage_2の非常に大きなコンテンツの暗号化については、付録Gで説明します。"
    },
    {
      "indent": 3,
      "text": "The use of transport is specified in the application profile, which in particular, may specify limitations in message sizes; see Section 3.9.",
      "ja": "輸送の使用はアプリケーションプロファイルで指定されており、特にメッセージサイズの制限を指定する場合があります。セクション3.9を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.4.1. EDHOC Message Correlation",
      "section_title": true,
      "ja": "3.4.1. EDHOCメッセージ相関"
    },
    {
      "indent": 3,
      "text": "Correlation between EDHOC messages is needed to facilitate the retrieval of the protocol state and security context during an EDHOC session. It is also helpful for the Responder to get an indication that a received EDHOC message is the beginning of a new EDHOC session, such that no existing protocol state or security context needs to be retrieved.",
      "ja": "EDHOCメッセージとセキュリティコンテキストの取得を促進するには、EDHOCメッセージ間の相関が必要です。また、レスポンダーが受信したEDHOCメッセージが新しいEDHOCセッションの始まりであることを示していることを把握することも役立ちます。そのため、既存のプロトコル状態またはセキュリティコンテキストを取得する必要はありません。"
    },
    {
      "indent": 3,
      "text": "Correlation may be based on existing mechanisms in the transport protocol; for example, the CoAP Token may be used to correlate EDHOC messages in a CoAP response and in an associated CoAP request. The connection identifiers may also be used to correlate EDHOC messages.",
      "ja": "相関は、輸送プロトコルの既存のメカニズムに基づいている場合があります。たとえば、COAPトークンを使用して、COAP応答および関連するCOAPリクエストでEDHOCメッセージを相関させることができます。接続識別子を使用して、EDHOCメッセージを相関させることもできます。"
    },
    {
      "indent": 3,
      "text": "If correlation between consecutive messages is not provided by other means, then the transport binding SHOULD mandate prepending of an appropriate connection identifier (when available from the EDHOC protocol) to the EDHOC message. If message_1 indication is not provided by other means, then the transport binding SHOULD mandate prepending of message_1 with the CBOR simple value true (0xf5).",
      "ja": "連続したメッセージ間の相関が他の手段によって提供されていない場合、トランスポートバインディングは、適切な接続識別子（EDHOCプロトコルから利用可能な場合）の準備をEDHOCメッセージに義務付ける必要があります。message_1の表示が他の手段によって提供されない場合、トランスポートバインディングは、CBOR Simple Value True（0xf5）でmessage_1を準備することを義務付ける必要があります。"
    },
    {
      "indent": 3,
      "text": "Transport of EDHOC in CoAP payloads is described in Appendix A.2, including how to use connection identifiers and message_1 indication with CoAP. A similar construction is possible for other client-server protocols. Protocols that do not provide any correlation at all can prescribe prepending of the peer's connection identifier to all messages.",
      "ja": "COAPペイロードでのEDHOCの輸送は、付録A.2に記載されています。これには、接続識別子の使用方法とCOAPでのメッセージ_1表示が含まれます。他のクライアントサーバープロトコルでも同様の構造が可能です。相関をまったく提供しないプロトコルは、すべてのメッセージに対するピアの接続識別子の準備を処方できます。"
    },
    {
      "indent": 3,
      "text": "Note that correlation between EDHOC messages may be obtained without transport support or connection identifiers, for example, if the endpoints only accept a single instance of the protocol at a time and execute conditionally on a correct sequence of messages.",
      "ja": "たとえば、エンドポイントが一度にプロトコルの単一のインスタンスのみを受け入れ、正しいメッセージの正しいシーケンスで条件付きで実行する場合、EDHOCメッセージ間の相関は輸送サポートまたは接続識別子なしで取得できることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.5. Authentication Parameters",
      "section_title": true,
      "ja": "3.5. 認証パラメーター"
    },
    {
      "indent": 3,
      "text": "EDHOC supports various settings for how the other endpoint's public key for authentication may be transported, identified, and trusted. We shall use the term \"authentication key\" to mean key used for authentication in general, or specifically, the public key, when there is no risk for confusion.",
      "ja": "EDHOCは、認証のための他のエンドポイントの公開鍵を輸送、識別、信頼できる方法について、さまざまな設定をサポートしています。「認証キー」という用語を使用して、一般的に認証に使用されるキー、具体的には、混乱のリスクがない場合に公開キーを意味します。"
    },
    {
      "indent": 3,
      "text": "EDHOC performs the following authentication-related operations:",
      "ja": "Edhocは、次の認証関連操作を実行します。"
    },
    {
      "indent": 6,
      "text": "* EDHOC transports information about credentials in ID_CRED_I and ID_CRED_R (described in Section 3.5.3). Based on this information, the authentication credentials CRED_I and CRED_R (described in Section 3.5.2) can be obtained. EDHOC may also transport certain authentication-related information as external authorization data (see Section 3.8).",
      "ja": "* EDHOCは、ID_CRED_IおよびID_CRED_Rの資格情報に関する情報を輸送します（セクション3.5.3で説明）。この情報に基づいて、認証資格情報はCRED_IおよびCRED_R（セクション3.5.2で説明）を取得できます。EDHOCは、特定の認証関連情報を外部認証データとして輸送する場合もあります（セクション3.8を参照）。"
    },
    {
      "indent": 6,
      "text": "* EDHOC uses the authentication credentials in two ways (see Sections 5.3.2 and 5.4.2):",
      "ja": "* Edhocは、認証資格情報を2つの方法で使用します（セクション5.3.2および5.4.2を参照）："
    },
    {
      "indent": 12,
      "text": "- The authentication credential is input to the integrity verification using the MAC fields.",
      "ja": "- 認証資格情報は、MACフィールドを使用した整合性検証に入力されます。"
    },
    {
      "indent": 12,
      "text": "- The authentication key of the authentication credential is used with the Signature_or_MAC field to verify proof-of-possession of the private key.",
      "ja": "- 認証資格情報の認証キーは、signature_or_macフィールドとともに使用され、秘密鍵の入力証明を確認します。"
    },
    {
      "indent": 3,
      "text": "Other authentication-related verifications are out of scope for EDHOC and are the responsibility of the application. In particular, the authentication credential needs to be validated in the context of the connection for which EDHOC is used; see Appendix D. EDHOC MUST allow the application to read received information about credentials in ID_CRED_R and ID_CRED_I. EDHOC MUST have access to the authentication key and the authentication credential.",
      "ja": "他の認証関連の検証は、EDHOCの範囲外であり、アプリケーションの責任です。特に、認証資格情報は、EDHOCが使用される接続のコンテキストで検証する必要があります。付録Dを参照してください。EDHOCは、アプリケーションがID_CRED_RおよびID_CRED_Iの資格情報に関する受け取った情報を読み取ることを許可する必要があります。EDHOCは、認証キーと認証資格情報にアクセスする必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that the type of authentication key, the type of authentication credential, and the identification of the credential have a large impact on the message size. For example, the Signature_or_MAC field is much smaller with a static DH key than with a signature key. A CWT Claims Set (CCS) is much smaller than a self-signed certificate / CWT, but if it is possible to reference the credential with a COSE header like 'kid', then that is in turn much smaller than a CCS.",
      "ja": "認証キーのタイプ、認証資格情報のタイプ、および資格情報の識別は、メッセージサイズに大きな影響を与えることに注意してください。たとえば、signature_or_macフィールドは、署名キーよりも静的なDHキーではるかに小さくなります。CWTクレームセット（CCS）は、自己署名証明書 / CWTよりもはるかに小さいですが、「KID」のようなCOSEヘッダーで資格情報を参照できる場合、CCSよりもはるかに小さくなります。"
    },
    {
      "indent": 0,
      "text": "3.5.1. Authentication Keys",
      "section_title": true,
      "ja": "3.5.1. 認証キー"
    },
    {
      "indent": 3,
      "text": "The authentication key MUST be a signature key or a static Diffie-Hellman key. The Initiator and Responder MAY use different types of authentication keys, e.g., one uses a signature key and the other uses a static Diffie-Hellman key.",
      "ja": "認証キーは、署名キーまたは静的diffie-hellmanキーでなければなりません。イニシエーターとレスポンダーは、さまざまなタイプの認証キーを使用する場合があります。たとえば、1つは署名キーを使用し、もう1つは静的diffie-hellmanキーを使用します。"
    },
    {
      "indent": 3,
      "text": "The authentication key algorithm needs to be compatible with the method and the selected cipher suite (see Section 3.6). The authentication key algorithm needs to be compatible with the EDHOC key exchange algorithm when static Diffie-Hellman authentication is used and compatible with the EDHOC signature algorithm when signature authentication is used.",
      "ja": "認証キーアルゴリズムは、メソッドと選択した暗号スイートと互換性がある必要があります（セクション3.6を参照）。認証キーアルゴリズムは、静的diffie-hellman認証が使用され、署名認証が使用されている場合にEDHOC署名アルゴリズムと互換性がある場合、EDHOCキー交換アルゴリズムと互換性がある必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that for most signature algorithms, the signature is determined jointly by the signature algorithm and the authentication key algorithm. When using static Diffie-Hellman keys, the Initiator's and the Responder's private authentication keys are denoted as I and R, respectively, and the public authentication keys are denoted G_I and G_R, respectively.",
      "ja": "ほとんどの署名アルゴリズムの場合、署名は署名アルゴリズムと認証キーアルゴリズムによって共同で決定されることに注意してください。静的diffie-hellmanキーを使用する場合、イニシエーターとレスポンダーのプライベート認証キーはそれぞれIおよびRとして示され、パブリック認証キーはそれぞれG_IとG_Rと表示されます。"
    },
    {
      "indent": 3,
      "text": "For X.509 certificates, the authentication key is represented by a SubjectPublicKeyInfo field, which also contains information about authentication key algorithm. For CWT and CCS (see Section 3.5.2), the authentication key is represented by a 'cnf' claim [RFC8747] containing a COSE_Key [RFC9052], which contains information about authentication key algorithm. In EDHOC, a raw public key (RPK) is an authentication key encoded as a COSE_Key wrapped in a CCS, an example is given in Figure 4.",
      "ja": "X.509証明書の場合、認証キーは、認証キーアルゴリズムに関する情報も含まれているSubjectPublicKeyInfoフィールドで表されます。CWTおよびCCSの場合（セクション3.5.2を参照）、認証キーは、認証キーアルゴリズムに関する情報を含むCOSE_KEY [RFC9052]を含む「CNF」クレーム[RFC8747]で表されます。EDHOCでは、RAW公開鍵（RPK）は、CCSにラップされたCOSE_KEYとしてエンコードされた認証キーであり、図4に例を示します。"
    },
    {
      "indent": 0,
      "text": "3.5.2. Authentication Credentials",
      "section_title": true,
      "ja": "3.5.2. 認証資格情報"
    },
    {
      "indent": 3,
      "text": "The authentication credentials, CRED_I and CRED_R, contain the public authentication key of the Initiator and Responder, respectively. We use the notation CRED_x to refer to CRED_I or CRED_R. Requirements on CRED_x applies both to CRED_I and to CRED_R. The authentication credential typically also contains other parameters that needs to be verified by the application (see Appendix D) and in particular information about the identity (\"subject\") of the endpoint to prevent misbinding attacks (see Appendix D.2).",
      "ja": "認証資格情報であるCRED_IとCRED_Rには、それぞれイニシエーターとレスポンダーのパブリック認証キーが含まれています。NOTATION CRED_Xを使用して、CRED_IまたはCRED_Rを参照しています。CRED_Xの要件は、CRED_IとCRED_Rの両方に適用されます。認証資格情報には、通常、アプリケーション（付録Dを参照）で検証する必要がある他のパラメーターと、誤った攻撃を防ぐためにエンドポイントのID（「主題」）に関する特定の情報（付録D.2を参照）も含まれています。"
    },
    {
      "indent": 3,
      "text": "EDHOC relies on COSE for identification of credentials (see Section 3.5.3), for example, X.509 certificates [RFC9360], C509 certificates [C509-CERTS], CWTs [RFC8392], and CCSs [RFC8392]. When the identified credential is a chain or a bag, the authentication credential CRED_x is just the end entity X.509 or C509 certificate / CWT. In the choice between a chain or a bag, it is RECOMMENDED to use a chain, since the certificates in a bag are unordered and may contain self-signed and extraneous certificates, which can add complexity to the process of extracting the end entity certificate. The Initiator and Responder MAY use different types of authentication credentials, e.g., one uses an RPK and the other uses a public key certificate.",
      "ja": "EDHOCは、資格情報の識別についてCOSEに依存しています（セクション3.5.3を参照）、たとえばX.509証明書[RFC9360]、C509証明書[C509-CERTS]、CWTS [RFC8392]、およびCCSS [RFC8392]。識別された資格情報がチェーンまたはバッグである場合、認証資格情報CRED_Xは、End Entity X.509またはC509証明書 / CWTにすぎません。チェーンまたはバッグのいずれかの選択では、バッグ内の証明書は順序付けられておらず、自己署名の無関係な証明書が含まれているため、チェーンを使用することをお勧めします。イニシエーターとレスポンダーは、さまざまなタイプの認証資格情報を使用する場合があります。たとえば、1つはRPKを使用し、もう1つは公開キー証明書を使用します。"
    },
    {
      "indent": 3,
      "text": "Since CRED_R is used in the integrity verification (see Section 5.3.2), it needs to be specified such that it is identical when used by the Initiator or Responder. Similarly for CRED_I, see Section 5.4.2. The Initiator and Responder are expected to agree on the specific encoding of the authentication credentials; see Section 3.9. It is RECOMMENDED that the COSE 'kid' parameter, when used to identify the authentication credential, refers to such a specific encoding of the authentication credential. The Initiator and Responder SHOULD use an available authentication credential without re-encoding, i.e. an authentication credential transported in EDHOC by value, or otherwise provisioned, SHOULD be used as is. If for some reason re-encoding of an authentication credential passed by reference may occur, then a potential common encoding for CBOR-based credentials is deterministically encoded CBOR, as specified in Sections 4.2.1 and 4.2.2 of [RFC8949].",
      "ja": "CRED_Rは整合性の検証で使用されているため（セクション5.3.2を参照）、イニシエーターまたはレスポンダーが使用する場合に同一になるように指定する必要があります。同様にCRED_Iについては、セクション5.4.2を参照してください。イニシエーターとレスポンダーは、認証資格情報の特定のエンコードに同意することが期待されています。セクション3.9を参照してください。認証資格情報を識別するために使用される場合、COSE「KID」パラメーターは、認証資格情報のこのような特定のエンコードを指すことをお勧めします。イニシエーターとレスポンダーは、再エンコードなしで利用可能な認証資格情報を使用する必要があります。つまり、edhocでvalueによって輸送される認証資格情報、またはその他のプロビジョニングを使用する必要があります。何らかの理由で、参照によって渡された認証資格情報の再エンコードが発生する可能性がある場合、[RFC8949]のセクション4.2.1および4.2.2で指定されているように、CBORベースの資格情報の潜在的な共通エンコードがCBORを決定的にエンコードします。"
    },
    {
      "indent": 6,
      "text": "* When the authentication credential is an X.509 certificate, CRED_x SHALL be the DER-encoded certificate, encoded as a bstr [RFC9360].",
      "ja": "* 認証資格情報がX.509証明書である場合、CRED_XはBSTR [RFC9360]としてエンコードされたDer-Encoded証明書となります。"
    },
    {
      "indent": 6,
      "text": "* When the authentication credential is a C509 certificate, CRED_x SHALL be the C509 certificate [C509-CERTS].",
      "ja": "* 認証資格情報がC509証明書である場合、CRED_XはC509証明書[C509-CERTS]になります。"
    },
    {
      "indent": 6,
      "text": "* When the authentication credential is a CWT including a COSE_Key, CRED_x SHALL be the untagged CWT.",
      "ja": "* 認証資格情報がCOSE_KEYを含むCWTである場合、CRED_Xは未積層のCWTでなければなりません。"
    },
    {
      "indent": 6,
      "text": "* When the authentication credential includes a COSE_Key but is not in a CWT, CRED_x SHALL be an untagged CCS. This is how RPKs are encoded, see Figure 4 for an example.",
      "ja": "* 認証資格にCOSE_KEYが含まれているが、CWTにない場合、CRED_Xは未編成のCCSでなければなりません。これは、RPKのエンコード方法です。例については、図4を参照してください。"
    },
    {
      "indent": 12,
      "text": "- Naked COSE_Keys are thus dressed as CCS when used in EDHOC, in its simplest form by prefixing the COSE_Key with 0xA108A101 (a map with a 'cnf' claim). In that case, the resulting authentication credential contains no other identity than the public key itself; see Appendix D.2.",
      "ja": "- したがって、裸のcose_keysは、edhocで使用される場合、最も単純な形式で、0xa108a101（ 'cnf'クレームを備えたマップ）でcose_keyに接頭することにより、最も単純な形式でCCSにdressしています。その場合、結果の認証資格情報には、公開鍵自体以外のアイデンティティが含まれていません。付録D.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "An example of CRED_x is shown below:",
      "ja": "CRED_Xの例を以下に示します。"
    },
    {
      "indent": 3,
      "text": "{                                              /CCS/\n  2 : \"42-50-31-FF-EF-37-32-39\",               /sub/\n  8 : {                                        /cnf/\n    1 : {                                      /COSE_Key/\n      1 : 1,                                   /kty/\n      2 : h'00',                               /kid/\n     -1 : 4,                                   /crv/\n     -2 : h'b1a3e89460e88d3a8d54211dc95f0b90   /x/\n            3ff205eb71912d6db8f4af980d2db83a'\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Figure 4: CCS Containing an X25519 Static Diffie-Hellman Key and an EUI-64 Identity",
      "ja": "図4：x25519静的diffie-hellmanキーとEUI-64のアイデンティティを含むCCS"
    },
    {
      "indent": 0,
      "text": "3.5.3. Identification of Credentials",
      "section_title": true,
      "ja": "3.5.3. 資格情報の識別"
    },
    {
      "indent": 3,
      "text": "The ID_CRED fields, ID_CRED_R and ID_CRED_I, are transported in message_2 and message_3, respectively; see Sections 5.3.2 and 5.4.2. We use the notation ID_CRED_x to refer to ID_CRED_I or ID_CRED_R. Requirements on ID_CRED_x applies both to ID_CRED_I and to ID_CRED_R. The ID_CRED fields are used to identify and optionally transport credentials:",
      "ja": "ID_CREDフィールド、ID_CRED_RおよびID_CRED_Iは、それぞれMessage_2とMessage_3で輸送されます。セクション5.3.2および5.4.2を参照してください。表記ID_CRED_Xを使用して、ID_CRED_IまたはID_CRED_Rを参照しています。ID_CRED_Xの要件は、ID_CRED_IとID_CRED_Rの両方に適用されます。ID_CREDフィールドは、資格情報を識別し、オプションで輸送するために使用されます。"
    },
    {
      "indent": 6,
      "text": "* ID_CRED_R is intended to facilitate for the Initiator retrieving the authentication credential CRED_R and the authentication key of R.",
      "ja": "* ID_CRED_Rは、認証資格情報CRED_RとRの認証キーを取得するイニシエーターを促進することを目的としています。"
    },
    {
      "indent": 6,
      "text": "* ID_CRED_I is intended to facilitate for the Responder retrieving the authentication credential CRED_I and the authentication key of I.",
      "ja": "* ID_CRED_Iは、認証資格情報CRED_IとIの認証キーを取得するレスポンダーを促進することを目的としています。"
    },
    {
      "indent": 3,
      "text": "ID_CRED_x may contain the authentication credential CRED_x, for x = I or R, but for many settings, it is not necessary to transport the authentication credential within EDHOC. For example, it may be pre-provisioned or acquired out-of-band over less constrained links. ID_CRED_I and ID_CRED_R do not have any cryptographic purpose in EDHOC since the authentication credentials are integrity protected by the Signature_or_MAC field.",
      "ja": "ID_CRED_Xには、X = IまたはRの認証資格情報CRED_Xが含まれる場合がありますが、多くの設定では、EDHOC内で認証資格情報を輸送する必要はありません。たとえば、制約の少ないリンクよりも事前に生成または取得した帯域外で獲得される場合があります。ID_CRED_IおよびID_CRED_R認証資格情報はSignature_or_Macフィールドによって保護されているため、EDHOCに暗号化の目的はありません。"
    },
    {
      "indent": 3,
      "text": "EDHOC relies on COSE for identification of credentials and supports all credential types for which COSE header parameters are defined, including X.509 certificates [RFC9360], C509 certificates [C509-CERTS], CWTs (Section 3.5.3.1) and CCSs (Section 3.5.3.1).",
      "ja": "EDHOC relies on COSE for identification of credentials and supports all credential types for which COSE header parameters are defined, including X.509 certificates [RFC9360], C509 certificates [C509-CERTS], CWTs (Section 3.5.3.1) and CCSs (Section 3.5.3.1）。"
    },
    {
      "indent": 3,
      "text": "ID_CRED_I and ID_CRED_R are of type COSE header_map, as defined in Section 3 of [RFC9052], and contain one or more COSE header parameters. If a map contains several header parameters, the labels do not need to be sorted in bytewise lexicographic order. ID_CRED_I and ID_CRED_R MAY contain different header parameters. The header parameters typically provide some information about the format of the credential.",
      "ja": "ID_CRED_IおよびID_CRED_Rは、[RFC9052]のセクション3で定義されているように、タイプCOSE Header_Mapであり、1つ以上のCOSEヘッダーパラメーターが含まれています。マップにいくつかのヘッダーパラメーターが含まれている場合、ラベルは辞書編集順にバイを並べ替える必要はありません。ID_CRED_IおよびID_CRED_Rには、異なるヘッダーパラメーターが含まれる場合があります。ヘッダーパラメーターは通常、資格情報の形式に関する情報を提供します。"
    },
    {
      "indent": 3,
      "text": "Example: X.509 certificates can be identified by a hash value using the 'x5t' parameter; see Section 2 of [RFC9360]:",
      "ja": "例：X.509証明書は、「X5T」パラメーターを使用してハッシュ値で識別できます。[RFC9360]のセクション2を参照してください。"
    },
    {
      "indent": 6,
      "text": "* ID_CRED_x = { 34 : COSE_CertHash }, for x = I or R",
      "ja": "* id_cred_x = {34：cose_certhash}、x = iまたはr"
    },
    {
      "indent": 3,
      "text": "Example: CWT or CCS can be identified by a key identifier using the 'kid' parameter; see Section 3.1 of [RFC9052]:",
      "ja": "例：CWTまたはCCSは、「KID」パラメーターを使用してキー識別子によって識別できます。[RFC9052]のセクション3.1を参照してください。"
    },
    {
      "indent": 6,
      "text": "* ID_CRED_x = { 4 : kid_x }, where kid_x : kid, for x = I or R",
      "ja": "* id_cred_x = {4：kid_x}、ここでkid_x：kid、for x = iまたはr"
    },
    {
      "indent": 3,
      "text": "Note that COSE header parameters in ID_CRED_x are used to identify the message sender's credential. Therefore, there is no reason to use the \"-sender\" header parameters, such as x5t-sender, defined in Section 3 of [RFC9360]. Instead, the corresponding parameter without \"-sender\", such as x5t, SHOULD be used.",
      "ja": "ID_CRED_XのCOSEヘッダーパラメーターは、メッセージ送信者の資格情報を識別するために使用されることに注意してください。したがって、[RFC9360]のセクション3で定義されているX5Tセンダーなどの「センダー」ヘッダーパラメーターを使用する理由はありません。代わりに、X5Tなどの「-Sender」のない対応するパラメーターを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "As stated in Section 3.1 of [RFC9052], applications MUST NOT assume that 'kid' values are unique and several keys associated with a 'kid' may need to be checked before the correct one is found. Applications might use additional information such as 'kid context' or lower layers to determine which key to try first. Applications should strive to make ID_CRED_x as unique as possible, since the recipient may otherwise have to try several keys.",
      "ja": "[RFC9052]のセクション3.1で述べたように、アプリケーションは「KID」値が一意であり、正しいものが見つかる前に「KID」に関連付けられたいくつかのキーをチェックする必要があると仮定してはなりません。アプリケーションは、「KIDコンテキスト」や下層などの追加情報を使用して、最初に試すキーを決定する場合があります。受信者はいくつかのキーを試す必要がある可能性があるため、アプリケーションはID_CRED_Xを可能な限り一意にするよう努力する必要があります。"
    },
    {
      "indent": 3,
      "text": "See Appendix C.3 for more examples.",
      "ja": "その他の例については、付録C.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.5.3.1. COSE Header Parameters for CWT and CWT Claims Set",
      "section_title": true,
      "ja": "3.5.3.1. CWTおよびCWTクレームセットのCOSEヘッダーパラメーター"
    },
    {
      "indent": 3,
      "text": "This document registers two new COSE header parameters, 'kcwt' and 'kccs', for use with CBOR Web Token (CWT) [RFC8392] and CWT Claims Set (CCS) [RFC8392], respectively. The CWT/CCS MUST contain a COSE_Key in a 'cnf' claim [RFC8747]. There may be any number of additional claims present in the CWT/CCS.",
      "ja": "このドキュメントは、CBOR Webトークン（CWT）[RFC8392]およびCWTクレームセット（CCS）[RFC8392]で使用するために、2つの新しいCOSEヘッダーパラメーター「KCWT」と「KCCS」を登録します。CWT/CCSには、「CNF」クレーム[RFC8747]にCOSE_KEYを含める必要があります。CWT/CCSには、任意の数の追加請求が存在する場合があります。"
    },
    {
      "indent": 3,
      "text": "CWTs sent in 'kcwt' are protected using a MAC or a signature and are similar to a certificate (when used with public key cryptography) or a Kerberos ticket (when used with symmetric key cryptography). CCSs sent in 'kccs' are not protected and are therefore similar to raw public keys or self-signed certificates.",
      "ja": "「KCWT」で送信されたCWTSは、MACまたは署名を使用して保護され、証明書（公開キー暗号化とともに使用する場合）またはKerberosチケット（対称キー暗号化で使用する場合）に似ています。「KCCS」で送信されたCCSSは保護されていないため、生の公開キーまたは自己署名証明書に類似しています。"
    },
    {
      "indent": 3,
      "text": "Security considerations for 'kcwt' and 'kccs' are made in Section 9.8.",
      "ja": "「KCWT」と「KCCS」のセキュリティ上の考慮事項は、セクション9.8で行われます。"
    },
    {
      "indent": 0,
      "text": "3.5.3.2. Compact Encoding of ID_CRED Fields for 'kid'",
      "section_title": true,
      "ja": "3.5.3.2. 「子供」のためのID_CREDフィールドのコンパクトエンコード"
    },
    {
      "indent": 3,
      "text": "To comply with the Lightweight Authenticated Key Exchange (LAKE) message size requirements (see [LAKE-REQS]), two optimizations are made for the case when ID_CRED_x, for x = I or R, contains a single 'kid' parameter.",
      "ja": "軽量認証キーエクスチェンジ（湖）メッセージサイズの要件を遵守するために（[湖reqs]を参照）、x = iまたはrのID_CRED_Xが単一の「KID」パラメーターを含む場合、2つの最適化が行われます。"
    },
    {
      "indent": 8,
      "text": "1. The CBOR map { 4 : kid_x } is replaced by the byte string kid_x.",
      "ja": "1. Cborマップ{4：kid_x}は、バイト文字列kid_xに置き換えられます。"
    },
    {
      "indent": 8,
      "text": "2. The representation of identifiers specified in Section 3.3.2 is applied to kid_x.",
      "ja": "2. セクション3.3.2で指定された識別子の表現は、KID_Xに適用されます。"
    },
    {
      "indent": 3,
      "text": "These optimizations MUST be applied if and only if ID_CRED_x = { 4 : kid_x } and ID_CRED_x in PLAINTEXT_y of message_y, y = 2 or 3; see Sections 5.3.2 and 5.4.2. Note that these optimizations are not applied to instances of ID_CRED_x that have no impact on message size, e.g., context_y, or the COSE protected header. For example:",
      "ja": "これらの最適化は、message_y、y = 2または3のplantext_yのid_cred_x = {4：kid_x}およびid_cred_xの場合にのみ適用する必要があります。セクション5.3.2および5.4.2を参照してください。これらの最適化は、メッセージサイズ、たとえばContext_y、またはCOSE Protectedヘッダーに影響を与えないID_CRED_Xのインスタンスには適用されないことに注意してください。例えば："
    },
    {
      "indent": 6,
      "text": "* For ID_CRED_x = { 4 : h'FF' }, the encoding in PLAINTEXT_y is not the CBOR map 0xA10441FF but the CBOR byte string h'FF', i.e., 0x41FF.",
      "ja": "* id_cred_x = {4：h'ff '}の場合、plantext_yでのエンコードはCborマップ0xa10441ffではなく、cborバイト文字列h'ff'、つまり0x41ffです。"
    },
    {
      "indent": 6,
      "text": "* For ID_CRED_x = { 4 : h'21' }, the encoding in PLAINTEXT_y is neither the CBOR map 0xA1044121 nor the CBOR byte string h'21', i.e., 0x4121, but the CBOR integer 0x21.",
      "ja": "* ID_CRED_X = {4：H'21 '}の場合、Plantext_yでのエンコードは、Cborマップ0xA1044121でもCborバイト文字列H'21'、つまり0x4121ではなく、Cbor整数0x21でもありません。"
    },
    {
      "indent": 0,
      "text": "3.6. Cipher Suites",
      "section_title": true,
      "ja": "3.6. 暗号スイート"
    },
    {
      "indent": 3,
      "text": "An EDHOC cipher suite consists of an ordered set of algorithms from the \"COSE Algorithms\" and \"COSE Elliptic Curves\" registries as well as the EDHOC MAC length. All algorithm names and definitions follow COSE Algorithms [RFC9053]. Note that COSE sometimes uses peculiar names such as ES256 for Elliptic Curve Digital Signature Algorithm (ECDSA) with SHA-256, A128 for AES-128, and Ed25519 for the curve edwards25519. Algorithms need to be specified with enough parameters to make them completely determined. The EDHOC MAC length MUST be at least 8 bytes. Any cryptographic algorithm used in the COSE header parameters in ID_CRED fields is selected independently of the selected cipher suite. EDHOC is currently only specified for use with key exchange algorithms of type ECDH curves, but any Key Encapsulation Mechanism (KEM), including Post-Quantum Cryptography (PQC) KEMs, can be used in method 0; see Section 9.4. Use of other types of key exchange algorithms to replace static DH authentication (methods 1, 2, and 3) would likely require a specification updating EDHOC with new methods.",
      "ja": "EDHOC Cipherスイートは、「COSEアルゴリズム」および「COSE Elliptic Curves」レジストリからの注文されたアルゴリズムのセットと、EDHOC MACの長さで構成されています。すべてのアルゴリズム名と定義は、COSEアルゴリズム[RFC9053]に従います。COSEは、楕円曲線デジタル署名アルゴリズム（ECDSA）にES256などの独特の名前を使用し、SHA-256、AES-128のA128、EDWARDS25519でED25519を使用する場合があることに注意してください。アルゴリズムは、完全に決定するのに十分なパラメーターで指定する必要があります。Edhoc Macの長さは、少なくとも8バイトでなければなりません。ID_CREDフィールドのCOSEヘッダーパラメーターで使用される暗号化アルゴリズムは、選択した暗号スイートとは無関係に選択されます。EDHOCは現在、型ECDH曲線の主要な交換アルゴリズムでのみ使用するために指定されていますが、ポストカントゥム暗号（PQC）KEMを含むすべてのキーカプセル化メカニズム（KEM）は、方法0で使用できます。セクション9.4を参照してください。静的DH認証（方法1、2、および3）を置き換えるために他のタイプのキー交換アルゴリズムを使用するには、新しい方法でEDHOCを更新する仕様が必要になる可能性があります。"
    },
    {
      "indent": 3,
      "text": "EDHOC supports all signature algorithms defined by COSE. Just like in (D)TLS 1.3 [RFC8446] [RFC9147] and IKEv2 [RFC7296], a signature in COSE is determined jointly by the signature algorithm and the authentication key algorithm; see Section 3.5.1. The exact details of the authentication key algorithm depend on the type of authentication credential. COSE supports different formats for storing the public authentication keys including COSE_Key and X.509, which use different names and ways to represent the authentication key and the authentication key algorithm.",
      "ja": "EDHOCは、COSEによって定義されたすべての署名アルゴリズムをサポートしています。（d）TLS 1.3 [RFC8446] [RFC9147]およびIKEV2 [RFC7296]と同様に、COSEの署名は、署名アルゴリズムと認証キーアルゴリズムによって共同で決定されます。セクション3.5.1を参照してください。認証キーアルゴリズムの正確な詳細は、認証資格情報のタイプに依存します。COSEは、COSE_KEYやX.509などのパブリック認証キーを保存するためのさまざまな形式をサポートしています。これは、異なる名前と方法を使用して認証キーと認証キーアルゴリズムを表現しています。"
    },
    {
      "indent": 3,
      "text": "An EDHOC cipher suite consists of the following parameters:",
      "ja": "Edhoc Cipher Suiteは、次のパラメーターで構成されています。"
    },
    {
      "indent": 6,
      "text": "* EDHOC AEAD algorithm,",
      "ja": "* edhoc aeadアルゴリズム、"
    },
    {
      "indent": 6,
      "text": "* EDHOC hash algorithm,",
      "ja": "* Edhoc Hashアルゴリズム、"
    },
    {
      "indent": 6,
      "text": "* EDHOC MAC length in bytes (Static DH),",
      "ja": "* バイト単位のedhoc Macの長さ（静的DH）、"
    },
    {
      "indent": 6,
      "text": "* EDHOC key exchange algorithm (ECDH curve),",
      "ja": "* EDHOCキーエクスチェンジアルゴリズム（ECDH曲線）、"
    },
    {
      "indent": 6,
      "text": "* EDHOC signature algorithm,",
      "ja": "* Edhoc署名アルゴリズム、"
    },
    {
      "indent": 6,
      "text": "* application AEAD algorithm, and",
      "ja": "* アプリケーションAEADアルゴリズム、および"
    },
    {
      "indent": 6,
      "text": "* application hash algorithm.",
      "ja": "* アプリケーションハッシュアルゴリズム。"
    },
    {
      "indent": 3,
      "text": "Each cipher suite is identified with a predefined integer label.",
      "ja": "各暗号スイートは、事前に定義された整数ラベルで識別されます。"
    },
    {
      "indent": 3,
      "text": "EDHOC can be used with all algorithms and curves defined for COSE. Implementations can either use any combination of COSE algorithms and parameters to define their own private cipher suite or use one of the predefined cipher suites. Private cipher suites can be identified with any of the four values: -24, -23, -22, and -21. The predefined cipher suites are listed in the IANA registry (Section 10.2) with the initial content outlined here:",
      "ja": "EDHOCは、COSE用に定義されたすべてのアルゴリズムと曲線で使用できます。実装は、COSEアルゴリズムとパラメーターの任意の組み合わせを使用して、独自のプライベート暗号スイートを定義するか、事前定義された暗号スイートの1つを使用できます。プライベート暗号スイートは、-24、-23、-22、および-21の4つの値のいずれかで識別できます。事前定義された暗号スイートは、IANAレジストリ（セクション10.2）にリストされており、最初のコンテンツはここに概説されています。"
    },
    {
      "indent": 6,
      "text": "* Cipher suites 0-3, based on AES-CCM, are intended for constrained IoT where message overhead is a very important factor. Note that AES-CCM-16-64-128 and AES-CCM-16-128-128 are compatible with the IEEE AES-CCM* mode of operation defined in Annex B of [IEEE.802.15.4-2015].",
      "ja": "* AES-CCMに基づくCipher Suites 0-3は、メッセージのオーバーヘッドが非常に重要な要素である制約付きIoTを目的としています。AES-CCM-16-64-128およびAES-CCM-16-128-128は、[IEEE.802.15.4-2015]の付属書Bで定義されたIEEE AES-CCM*操作モードと互換性があることに注意してください。"
    },
    {
      "indent": 12,
      "text": "- Cipher suites 1 and 3 use a larger tag length (128 bits) in EDHOC than in the application AEAD algorithm (64 bits).",
      "ja": "- 暗号スイート1および3は、アプリケーションAEADアルゴリズム（64ビット）よりも、EDHOCでより大きなタグの長さ（128ビット）を使用します。"
    },
    {
      "indent": 6,
      "text": "* Cipher suites 4 and 5, based on ChaCha20, are intended for less constrained applications and only use 128-bit tag lengths.",
      "ja": "* Chacha20に基づいたCipher Suites 4および5は、制約の少ないアプリケーションを対象としており、128ビットのタグ長のみを使用しています。"
    },
    {
      "indent": 6,
      "text": "* Cipher suite 6, based on AES-GCM, is for general non-constrained applications. It consists of high-performance algorithms that are widely used in non-constrained applications.",
      "ja": "* AES-GCMに基づくCipher Suite 6は、一般的な制約のないアプリケーション用です。制約のないアプリケーションで広く使用されている高性能アルゴリズムで構成されています。"
    },
    {
      "indent": 6,
      "text": "* Cipher suites 24 and 25 are intended for high security applications such as government use and financial applications. These cipher suites do not share any algorithms. Cipher suite 24 consists of algorithms from the Commercial National Security Algorithm (CNSA) 1.0 suite [CNSA].",
      "ja": "* Cipher Suites 24および25は、政府の使用や財務アプリケーションなどの高度なセキュリティアプリケーションを対象としています。これらの暗号スイートはアルゴリズムを共有していません。Cipher Suite 24は、商業国家安全保障アルゴリズム（CNSA）1.0スイート[CNSA]のアルゴリズムで構成されています。"
    },
    {
      "indent": 3,
      "text": "The different methods (Section 3.2) use the same cipher suites, but some algorithms are not used in some methods. The EDHOC signature algorithm is not used in methods without signature authentication.",
      "ja": "異なる方法（セクション3.2）は同じ暗号スイートを使用しますが、一部の方法ではいくつかのアルゴリズムは使用されていません。EDHOC署名アルゴリズムは、署名認証なしではメソッドでは使用されません。"
    },
    {
      "indent": 3,
      "text": "The Initiator needs to have a list of cipher suites it supports in order of preference. The Responder needs to have a list of cipher suites it supports. SUITES_I contains cipher suites supported by the Initiator and formatted and processed as detailed in Section 5.2.1 to secure the cipher suite negotiation. Examples of cipher suite negotiation are given in Section 6.3.2.",
      "ja": "イニシエーターには、好みの順にサポートする暗号スイートのリストが必要です。レスポンダーには、サポートする暗号スイートのリストが必要です。suites_iには、イニシエーターによってサポートされ、セクション5.2.1で詳細にフォーマットおよび処理された暗号スイートが含まれており、暗号スイートのネゴシエーションを保護します。暗号スイートの交渉の例は、セクション6.3.2に記載されています。"
    },
    {
      "indent": 0,
      "text": "3.7. Ephemeral Public Keys",
      "section_title": true,
      "ja": "3.7. 短命の公開鍵"
    },
    {
      "indent": 3,
      "text": "The ephemeral public keys in EDHOC (G_X and G_Y) use compact representation of elliptic curve points; see Appendix B. In COSE, compact representation is achieved by formatting the ECDH ephemeral public keys as COSE_Keys of type EC2 or Octet Key Pair (OKP) according to Sections 7.1 and 7.2 of [RFC9053] but only including the 'x' parameter in G_X and G_Y. For Elliptic Curve Keys of type EC2, compact representation MAY be used also in the COSE_Key. COSE always uses compact output for Elliptic Curve Keys of type EC2. If the COSE implementation requires a 'y' parameter, the value y = false or a calculated y-coordinate can be used; see Appendix B.",
      "ja": "Edhoc（G_XおよびG_Y）のはかない公共鍵は、楕円曲線ポイントのコンパクトな表現を使用しています。付録Bを参照してください。COSEでは、[RFC9053]のセクション7.1および7.2に従って、ECDHはECDH EC2またはOctetキーペア（OKP）のCOSE_KEYSとしてECDH EPEMEMERAL PUBLICEYSをフォーマットすることにより、コンパクトな表現が達成されますが、G_Xの「X」パラメーターのみを含むだけです。およびg_y。型EC2の楕円曲線キーの場合、COSE_KEYではコンパクトな表現も使用できます。COSEは、型EC2の楕円曲線キーに常にコンパクトな出力を使用します。COSE実装に「Y」パラメーターが必要な場合、値y = falseまたは計算されたy座標を使用できます。付録Bを参照してください"
    },
    {
      "indent": 0,
      "text": "3.8. External Authorization Data (EAD)",
      "section_title": true,
      "ja": "3.8. 外部認証データ（EAD）"
    },
    {
      "indent": 3,
      "text": "In order to reduce round trips and the number of messages or to simplify processing, external security applications may be integrated into EDHOC by transporting authorization-related data in the messages.",
      "ja": "丸い旅行とメッセージの数を減らすため、または処理を簡素化するために、メッセージ内の認可関連データを輸送することにより、外部セキュリティアプリケーションをEDHOCに統合することができます。"
    },
    {
      "indent": 3,
      "text": "EDHOC allows processing of external authorization data (EAD) to be defined in a separate specification and sent in dedicated fields of the four EDHOC messages: EAD_1, EAD_2, EAD_3, and EAD_4. EAD is opaque data to EDHOC.",
      "ja": "EDHOCを使用すると、外部認証データ（EAD）の処理を別の仕様で定義し、4つのEDHOCメッセージの専用フィールド（EAD_1、EAD_2、EAD_3、およびEAD_4）で送信できます。EADはEdhocへの不透明なデータです。"
    },
    {
      "indent": 3,
      "text": "Each EAD field, EAD_x, for x = 1, 2, 3, or 4, is a CBOR sequence (see Appendix C.1) consisting of one or more EAD items. EAD item ead is a CBOR sequence of an ead_label and an optional ead_value; see Figure 5 and Appendix C.2 for the CDDL definitions.",
      "ja": "x = 1、2、3、または4の各eadフィールド、ead_xは、1つ以上のeadアイテムで構成されるCBORシーケンス（付録C.1を参照）です。EADアイテムEADは、EAD_LABELのCBORシーケンスとオプションのEAD_VALUEです。CDDL定義については、図5と付録C.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "ead = (\n  ead_label : int,\n  ? ead_value : bstr,\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 29,
      "text": "Figure 5: EAD Item",
      "ja": "図5：EADアイテム"
    },
    {
      "indent": 3,
      "text": "A security application may register one or more EAD labels (see Section 10.5) and specify the associated processing and security considerations. The IANA registry contains the absolute value of the ead_label, |ead_label|; the same ead_value applies independently of the sign of the ead_label.",
      "ja": "セキュリティアプリケーションは、1つ以上のEADラベルを登録し（セクション10.5を参照）、関連する処理とセキュリティの考慮事項を指定できます。IANAレジストリには、ead_labelの絶対値が含まれています| ead_label |;同じead_valueは、ead_labelの兆候とは独立して適用されます。"
    },
    {
      "indent": 3,
      "text": "An EAD item can be either critical or non-critical, determined by the sign of the ead_label in the EAD item transported in the EAD field. A negative value indicates that the EAD item is critical, and a nonnegative value indicates that the EAD item is non-critical.",
      "ja": "EADアイテムは、EADフィールドで輸送されたEADアイテムのEAD_Labelのサインによって決定される重要または非批判的なものです。負の値は、EADアイテムが重要であることを示し、非陰性値は、EADアイテムが非批判的であることを示します。"
    },
    {
      "indent": 3,
      "text": "If an endpoint receives a critical EAD item it does not recognize or a critical EAD item that contains information that it cannot process, then the endpoint MUST send an EDHOC error message back as defined in Section 6, and the EDHOC session MUST be aborted. The EAD item specification defines the error processing. A non-critical EAD item can be ignored.",
      "ja": "エンドポイントが認識できない重要なEADアイテムまたは処理できない情報を含む重要なEADアイテムを受信した場合、エンドポイントはセクション6で定義されているようにEDHOCエラーメッセージを送信する必要があり、EDHOCセッションを中止する必要があります。EADアイテムの仕様は、エラー処理を定義します。非クリティカルなEADアイテムは無視できます。"
    },
    {
      "indent": 3,
      "text": "The security application registering a new EAD item needs to describe under what conditions the EAD item is critical or non-critical, and thus whether the ead_label is used with a negative or positive sign. ead_label = 0 is used for padding; see Section 3.8.1.",
      "ja": "新しいEADアイテムを登録するセキュリティアプリケーションは、EADアイテムがどの条件で重要であるか、非批判的であるか、したがってEAD_Labelがネガティブな兆候で使用されるかどうかを記述する必要があります。ead_label = 0はパディングに使用されます。セクション3.8.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "The security application may define multiple uses of certain EAD items, e.g., the same EAD item may be used in different EDHOC messages. Multiple occurrences of an EAD item in one EAD field may also be specified, but the criticality of the repeated EAD item is expected to be the same.",
      "ja": "セキュリティアプリケーションは、特定のEADアイテムの複数の使用を定義する場合があります。たとえば、同じEADアイテムが異なるEDHOCメッセージで使用される場合があります。1つのEADフィールドでのEADアイテムの複数の発生も指定できますが、繰り返されるEADアイテムの重要性は同じであると予想されます。"
    },
    {
      "indent": 3,
      "text": "The EAD fields of EDHOC MUST only be used with registered EAD items; see Section 10.5. Examples of the use of EAD are provided in Appendix E.",
      "ja": "EDHOCのEADフィールドは、登録されたEADアイテムでのみ使用する必要があります。セクション10.5を参照してください。EADの使用の例は、付録Eに記載されています。"
    },
    {
      "indent": 0,
      "text": "3.8.1. Padding",
      "section_title": true,
      "ja": "3.8.1. パディング"
    },
    {
      "indent": 3,
      "text": "EDHOC message_1 and the plaintext of message_2, message_3, and message_4 can be padded with the use of the corresponding EAD_x field, for x = 1, 2, 3, or 4. Padding in EAD_1 mitigates amplification attacks (see Section 9.7), and padding in EAD_2, EAD_3, and EAD_4 hides the true length of the plaintext (see Section 9.6). Padding MUST be ignored and discarded by the receiving application.",
      "ja": "EDHOC Message_1およびMessage_2、Message_3、およびMessage_4のプレーンテキストは、X = 1、2、3、または4の対応するEAD_Xフィールドの使用でパディングできます。EAD_1のパディングは、増幅攻撃（セクション9.7を参照）、およびパディングを緩和します。EAD_2では、EAD_3、およびEAD_4は、プレーンテキストの真の長さを隠します（セクション9.6を参照）。パディングは、受信アプリケーションによって無視され、破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "Padding is obtained by using an EAD item with ead_label = 0 and a (pseudo)randomly generated byte string of appropriate length as ead_value, noting that the ead_label and the CBOR encoding of ead_value also add bytes. For example:",
      "ja": "パディングは、EAD_LABEL = 0とA（pseudo）の適切な長さのランダムに生成されたバイト文字列を持つEADアイテムをEAD_VALUEとして使用して得られ、EAD_LABELとEAD_VALUEのCBORエンコードもバイトを追加することに注目します。例えば："
    },
    {
      "indent": 6,
      "text": "* One-byte padding (optional ead_value omitted):",
      "ja": "* ワンバイトパディング（オプションのead_value省略）："
    },
    {
      "indent": 10,
      "text": "EAD_x = 0x00",
      "ja": "ead_x = 0x00"
    },
    {
      "indent": 6,
      "text": "* Two-byte padding, using the empty byte string (0x40) as ead_value:",
      "ja": "* ead_valueとして空のバイト文字列（0x40）を使用した2バイトのパディング："
    },
    {
      "indent": 10,
      "text": "EAD_x = 0x0040",
      "ja": "ead_x = 0x0040"
    },
    {
      "indent": 6,
      "text": "* Three-byte padding, constructed from the pseudorandomly generated ead_value 0xe9 encoded as byte string:",
      "ja": "* 擬似ランダムに生成されたead_value 0xe9から構築された3バイトパディング：バイト文字列としてエンコードされた："
    },
    {
      "indent": 10,
      "text": "EAD_x = 0x0041e9",
      "ja": "ead_x = 0x0041e9"
    },
    {
      "indent": 3,
      "text": "Multiple occurrences of EAD items with ead_label = 0 are allowed. Certain padding lengths require the use of at least two such EAD items.",
      "ja": "EAD_Label = 0のEADアイテムの複数の発生が許可されています。特定のパディングの長さには、少なくとも2つのEADアイテムを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that padding is non-critical because the intended behavior when receiving is to ignore it.",
      "ja": "パディングは、受け取るときに意図した動作がそれを無視することであるため、非批判的であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.9. Application Profile",
      "section_title": true,
      "ja": "3.9. アプリケーションプロファイル"
    },
    {
      "indent": 3,
      "text": "EDHOC requires certain parameters to be agreed upon between the Initiator and Responder. Some parameters can be negotiated through the protocol execution (specifically, cipher suite; see Section 3.6), but other parameters are only communicated and may not be negotiated (e.g., which authentication method is used; see Section 3.2). Yet, other parameters need to be known out-of-band to ensure successful completion, e.g., whether message_4 is used or not. The application decides which endpoint is the Initiator and which is the Responder.",
      "ja": "EDHOCは、イニシエーターとレスポンダーの間で特定のパラメーターを合意する必要があります。一部のパラメーターは、プロトコルの実行（具体的には暗号スイート、セクション3.6を参照）を通じて交渉できますが、他のパラメーターは通信され、交渉されない場合があります（たとえば、どの認証方法が使用されますか。セクション3.2を参照）。ただし、Message_4が使用されているかどうかなど、正常に完了することを確実にするために、他のパラメーターを帯域外に把握する必要があります。アプリケーションは、どのエンドポイントがイニシエーターであり、それが応答者であるかを決定します。"
    },
    {
      "indent": 3,
      "text": "The purpose of an application profile is to describe the intended use of EDHOC to allow for the relevant processing and verifications to be made, including things like the following:",
      "ja": "アプリケーションプロファイルの目的は、次のようなものを含め、関連する処理と検証を行うためにEDHOCの使用を目的とすることを説明することです。"
    },
    {
      "indent": 8,
      "text": "1. How the endpoint detects that an EDHOC message is received. This includes how EDHOC messages are transported, for example, in the payload of a CoAP message with a certain Uri-Path or Content-Format; see Appendix A.2.",
      "ja": "1. EDHOCメッセージが受信されることをエンドポイントが検出する方法。これには、たとえば、特定のURI-Pathまたはコンテンツフォーマットを使用したCOAPメッセージのペイロードで、EDHOCメッセージがどのように輸送されるかが含まれます。付録A.2を参照してください。"
    },
    {
      "indent": 12,
      "text": "The method of transporting EDHOC messages may also describe data carried along with the messages that are needed for the transport to satisfy the requirements of Section 3.4, e.g., connection identifiers used with certain messages; see Appendix A.2.",
      "ja": "EDHOCメッセージの輸送方法は、特定のメッセージで使用される接続識別子などのセクション3.4の要件を満たすために、トランスポートに必要なメッセージとともに伝達されたデータを記述する場合があります。付録A.2を参照してください。"
    },
    {
      "indent": 8,
      "text": "2. Authentication method (METHOD; see Section 3.2).",
      "ja": "2. 認証方法（方法;セクション3.2を参照）。"
    },
    {
      "indent": 8,
      "text": "3. Profile for authentication credentials (CRED_I and CRED_R; see Section 3.5.2), e.g., profile for certificate or CCS, including supported authentication key algorithms (subject public key algorithm in X.509 or C509 certificate).",
      "ja": "3. 認証資格情報のプロファイル（CRED_IおよびCRED_R;セクション3.5.2を参照）、例えば、証明書またはCCSのプロファイル、サポートされている認証キーアルゴリズム（X.509またはC509証明書の主題の公開キーアルゴリズム）。"
    },
    {
      "indent": 8,
      "text": "4. Type used to identify credentials (ID_CRED_I and ID_CRED_R; see Section 3.5.3).",
      "ja": "4. 資格情報を識別するために使用されるタイプ（ID_CRED_IおよびID_CRED_R;セクション3.5.3を参照）。"
    },
    {
      "indent": 8,
      "text": "5. Use and type of external authorization data (EAD_1, EAD_2, EAD_3, and EAD_4; see Section 3.8).",
      "ja": "5. 使用およびタイプの外部認証データ（EAD_1、EAD_2、EAD_3、およびEAD_4;セクション3.8を参照）。"
    },
    {
      "indent": 8,
      "text": "6. Identifier used as the identity of the endpoint; see Appendix D.2.",
      "ja": "6. エンドポイントの識別として使用される識別子。付録D.2を参照してください。"
    },
    {
      "indent": 8,
      "text": "7. If message_4 shall be sent/expected, and if not, how to ensure a protected application message is sent from the Responder to the Initiator; see Section 5.5.",
      "ja": "7. Message_4が送信/予想される場合、およびそうでない場合は、保護されたアプリケーションメッセージがResponderからイニシエーターに送信されることを確認する方法。セクション5.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "The application profile may also contain information about supported cipher suites. The procedure for selecting and verifying a cipher suite is still performed as described in Sections 5.2.1 and 6.3, but it may become simplified by this knowledge. EDHOC messages can be processed without the application profile, i.e., the EDHOC messages include information about the type and length of all fields.",
      "ja": "アプリケーションプロファイルには、サポートされている暗号スイートに関する情報も含まれている場合があります。暗号スイートの選択と検証の手順は、セクション5.2.1および6.3で説明されているように実行されますが、この知識によって簡素化される可能性があります。EDHOCメッセージは、アプリケーションプロファイルなしで処理できます。つまり、EDHOCメッセージには、すべてのフィールドのタイプと長さに関する情報が含まれます。"
    },
    {
      "indent": 3,
      "text": "An example of an application profile is shown in Appendix F.",
      "ja": "アプリケーションプロファイルの例を付録Fに示します。"
    },
    {
      "indent": 3,
      "text": "For some parameters, like METHOD, the type of the ID_CRED field, or EAD, the receiver of an EDHOC message is able to verify compliance with the application profile and, if it needs to fail because of the lack of compliance, to infer the reason why the EDHOC session failed.",
      "ja": "メソッド、ID_CREDフィールドのタイプ、またはEADなどの一部のパラメーターの場合、EDHOCメッセージの受信者は、アプリケーションプロファイルのコンプライアンスを確認できます。EDHOCセッションが失敗した理由。"
    },
    {
      "indent": 3,
      "text": "For other encodings, like the profiling of CRED_x in the case that it is not transported, it may not be possible to verify that the lack of compliance with the application profile was the reason for failure. For example, integrity verification in message_2 or message_3 may fail not only because of a wrong credential. For example, in case the Initiator uses a public key certificate by reference (i.e., not transported within the protocol), then both endpoints need to use an identical data structure as CRED_I or else the integrity verification will fail.",
      "ja": "輸送されていない場合のCRED_Xのプロファイリングのように、他のエンコーディングの場合、アプリケーションプロファイルへのコンプライアンスの欠如が障害の理由であることを確認することはできない場合があります。たとえば、Message_2またはMessage_3の整合性検証は、資格が間違っているだけでなく失敗する可能性があります。たとえば、イニシエーターが参照ごとに公開キーの証明書を使用する場合（つまり、プロトコル内で輸送されません）、両方のエンドポイントは同一のデータ構造をCRED_Iと使用する必要があります。そうしないと、整合性の検証が失敗します。"
    },
    {
      "indent": 3,
      "text": "Note that it is not necessary for the endpoints to specify a single transport for the EDHOC messages. For example, a mix of CoAP and HTTP may be used along the path, and this may still allow correlation between messages.",
      "ja": "エンドポイントがEDHOCメッセージの単一のトランスポートを指定する必要はないことに注意してください。たとえば、COAPとHTTPの組み合わせをパスに沿って使用する場合がありますが、これによりメッセージ間の相関が可能になる場合があります。"
    },
    {
      "indent": 3,
      "text": "The application profile may be dependent on the identity of the other endpoint or other information carried in an EDHOC message, but it then applies only to the later phases of the protocol when such information is known. (The Initiator does not know the identity of the Responder before having verified message_2, and the Responder does not know the identity of the Initiator before having verified message_3.)",
      "ja": "アプリケーションプロファイルは、他のエンドポイントまたはEDHOCメッセージに掲載された他の情報のIDに依存する場合がありますが、そのような情報が既知の場合、プロトコルの後期フェーズにのみ適用されます。（イニシエーターは、message_2を検証する前にレスポンダーの身元を知らず、レスポンダーはmessage_3を検証する前にイニシエーターの身元を知りません。）"
    },
    {
      "indent": 3,
      "text": "Other conditions may be part of the application profile, such as what is the target application or use (if there is more than one application/use) to the extent that EDHOC can distinguish between them. In case multiple application profiles are used, the receiver needs to be able to determine which is applicable for a given EDHOC session, for example, based on the URI to which the EDHOC message is sent, or external authorization data type.",
      "ja": "他の条件は、EDHOCがそれらを区別できる範囲で、ターゲットアプリケーションまたは使用（複数のアプリケーション/使用がある場合）など、アプリケーションプロファイルの一部である場合があります。複数のアプリケーションプロファイルが使用される場合、レシーバーは、たとえば、EDHOCメッセージの送信のURIまたは外部認証データ型に基づいて、特定のEDHOCセッションに適用可能なものを決定できる必要があります。"
    },
    {
      "indent": 0,
      "text": "4. Key Derivation",
      "section_title": true,
      "ja": "4. キー派生"
    },
    {
      "indent": 0,
      "text": "4.1. Keys for EDHOC Message Processing",
      "section_title": true,
      "ja": "4.1. EDHOCメッセージ処理のキー"
    },
    {
      "indent": 3,
      "text": "EDHOC uses Extract-and-Expand [RFC5869] with the EDHOC hash algorithm in the selected cipher suite to derive keys used in message processing. This section defines EDHOC_Extract (Section 4.1.1) and EDHOC_Expand (Section 4.1.2) and how to use them to derive PRK_out (Section 4.1.3), which is the shared secret session key resulting from a completed EDHOC session.",
      "ja": "Edhocは、選択した暗号スイートのEdhoc Hashアルゴリズムを使用して、抽出および拡張エンパンド[RFC5869]を使用して、メッセージ処理で使用されるキーを導き出します。このセクションでは、EDHOC_EXTALT（セクション4.1.1）およびEDHOC_EXPAND（セクション4.1.2）と、完成したEDHOCセッションから生じる共有シークレットセッションキーであるPRK_out（セクション4.1.3）を導出するためにそれらを使用する方法を定義します。"
    },
    {
      "indent": 3,
      "text": "EDHOC_Extract is used to derive fixed-length uniformly pseudorandom keys (PRKs) from ECDH shared secrets. EDHOC_Expand is used to define EDHOC_KDF for generating MACs and for deriving output keying material (OKM) from PRKs.",
      "ja": "EDHOC_EXTRACTは、ECDH共有秘密から固定長の均一な擬似ランダムキー（PRK）を導出するために使用されます。EDHOC_EXPANDは、MACを生成するためのEDHOC_KDFを定義し、PRKSから出力キーイング材料（OKM）を導出するために使用されます。"
    },
    {
      "indent": 3,
      "text": "In EDHOC, a specific message is protected with a certain PRK, but how the key is derived depends on the authentication method (Section 3.2), as detailed in Section 5.",
      "ja": "EDHOCでは、特定のメッセージが特定のPRKで保護されていますが、セクション5で詳述されているように、キーの導出方法は認証方法（セクション3.2）に依存します。"
    },
    {
      "indent": 0,
      "text": "4.1.1. EDHOC_Extract",
      "section_title": true,
      "ja": "4.1.1. edhoc_extract"
    },
    {
      "indent": 3,
      "text": "The pseudorandom keys (PRKs) used for EDHOC message processing are derived using EDHOC_Extract:",
      "ja": "EDHOCメッセージ処理に使用される擬似ランダムキー（PRK）は、EDHOC_EXTALTを使用して導出されます。"
    },
    {
      "indent": 6,
      "text": "PRK = EDHOC_Extract( salt, IKM )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where the input keying material (IKM) and salt are defined for each PRK below.",
      "ja": "入力キーイング材料（IKM）と塩が、以下の各PRKについて定義されています。"
    },
    {
      "indent": 3,
      "text": "The definition of EDHOC_Extract depends on the EDHOC hash algorithm of the selected cipher suite:",
      "ja": "Edhoc_extractの定義は、選択した暗号スイートのEDHOCハッシュアルゴリズムに依存します。"
    },
    {
      "indent": 6,
      "text": "* If the EDHOC hash algorithm is SHA-2, then EDHOC_Extract( salt, IKM ) = HKDF-Extract( salt, IKM ) [RFC5869].",
      "ja": "* EDHOCハッシュアルゴリズムがSHA-2の場合、EDHOC_EXTALT（SALT、IKM）= HKDF-EXTRACT（SALT、IKM）[RFC5869]。"
    },
    {
      "indent": 6,
      "text": "* If the EDHOC hash algorithm is SHAKE128, then EDHOC_Extract( salt, IKM ) = KMAC128( salt, IKM, 256, \"\" ).",
      "ja": "* Edhoc HashアルゴリズムがShake128の場合、Edhoc_extract（Salt、IKM）= KMAC128（SALT、IKM、256、 \"\"）。"
    },
    {
      "indent": 6,
      "text": "* If the EDHOC hash algorithm is SHAKE256, then EDHOC_Extract( salt, IKM ) = KMAC256( salt, IKM, 512, \"\" ).",
      "ja": "* EDHOCハッシュアルゴリズムがShake256の場合、Edhoc_extract（Salt、IKM）= KMAC256（SALT、IKM、512、 \"\"）。"
    },
    {
      "indent": 3,
      "text": "where the Keccak Message Authentication Code (KMAC) is specified in [SP800-185].",
      "ja": "Keccakメッセージ認証コード（KMAC）が[SP800-185]で指定されています。"
    },
    {
      "indent": 3,
      "text": "The rest of the section defines the pseudorandom keys PRK_2e, PRK_3e2m, and PRK_4e3m; their use is shown in Figure 6. The index of a PRK indicates its use or in what message protection operation it is involved. For example, PRK_3e2m is involved in the encryption of message 3 and in calculating the MAC of message 2.",
      "ja": "セクションの残りの部分では、Pseudorandom Keys PRK_2E、PRK_3E2M、およびPRK_4E3Mを定義します。それらの使用を図6に示します。PRKのインデックスは、その使用またはそれが関与するメッセージ保護操作におけるものを示しています。たとえば、PRK_3E2Mは、メッセージ3の暗号化とメッセージ2のMACの計算に関与しています。"
    },
    {
      "indent": 0,
      "text": "4.1.1.1. PRK_2e",
      "section_title": true,
      "ja": "4.1.1.1. PRK_2E"
    },
    {
      "indent": 3,
      "text": "The pseudorandom key PRK_2e is derived with the following input:",
      "ja": "擬似ランダムキーPRK_2Eは、次の入力で導出されます。"
    },
    {
      "indent": 6,
      "text": "* The salt SHALL be TH_2.",
      "ja": "* 塩はth_2でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* The IKM SHALL be the ephemeral-ephemeral ECDH shared secret G_XY (calculated from G_X and Y or G_Y and X) as defined in Section 6.3.1 of [RFC9053]. The use of G_XY gives forward secrecy in the sense that compromise of the private authentication keys does not compromise past session keys.",
      "ja": "* IKMは、[RFC9053]のセクション6.3.1で定義されているように、secret g_xy（g_x and yまたはg_yおよびxから計算された）を共有したは、secret ecdhを共有します。G_XYの使用は、プライベート認証キーの妥協が過去のセッションキーを妥協しないという意味で秘密を前進させます。"
    },
    {
      "indent": 3,
      "text": "Example: Assuming the use of curve25519, the ECDH shared secret G_XY is the output of the X25519 function [RFC7748]:",
      "ja": "例：Curve25519の使用を仮定すると、ECDH共有Secret G_XyはX25519関数[RFC7748]の出力です。"
    },
    {
      "indent": 6,
      "text": "G_XY = X25519( Y, G_X ) = X25519( X, G_Y )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Example: Assuming the use of SHA-256, the extract phase of the key derivation function is HKDF-Extract, which produces PRK_2e as follows:",
      "ja": "例：SHA-256の使用を仮定すると、キー導出関数の抽出相はHKDF-Extractであり、次のようにPRK_2Eを生成します。"
    },
    {
      "indent": 6,
      "text": "PRK_2e = HMAC-SHA-256( TH_2, G_XY )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.1.1.2. PRK_3e2m",
      "section_title": true,
      "ja": "4.1.1.2. PRK_3E2M"
    },
    {
      "indent": 3,
      "text": "The pseudorandom key PRK_3e2m is derived as follows:",
      "ja": "擬似ランダムキーPRK_3E2Mは次のように導き出されます。"
    },
    {
      "indent": 3,
      "text": "If the Responder authenticates with a static Diffie-Hellman key, then PRK_3e2m = EDHOC_Extract( SALT_3e2m, G_RX ), where",
      "ja": "レスポンダーが静的diffie-hellmanキーで認証する場合、prk_3e2m = edhoc_extract（salt_3e2m、g_rx）、ここで"
    },
    {
      "indent": 6,
      "text": "* SALT_3e2m is derived from PRK_2e (see Section 4.1.2) and",
      "ja": "* SALT_3E2MはPRK_2E（セクション4.1.2を参照）に由来し、"
    },
    {
      "indent": 6,
      "text": "* G_RX is the ECDH shared secret calculated from G_R and X, or G_X and R (the Responder's private authentication key; see Section 3.5.1),",
      "ja": "* G_RXは、G_RとXから計算されたECDH共有秘密、またはG_XとR（Responderのプライベート認証キー、セクション3.5.1を参照）から計算されています。"
    },
    {
      "indent": 3,
      "text": "else PRK_3e2m = PRK_2e.",
      "ja": "それ以外の場合、prk_3e2m = prk_2e。"
    },
    {
      "indent": 0,
      "text": "4.1.1.3. PRK_4e3m",
      "section_title": true,
      "ja": "4.1.1.3. PRK_4E3M"
    },
    {
      "indent": 3,
      "text": "The pseudorandom key PRK_4e3m is derived as follows:",
      "ja": "擬似ランダムキーPRK_4E3Mは次のように導き出されます。"
    },
    {
      "indent": 3,
      "text": "If the Initiator authenticates with a static Diffie-Hellman key, then PRK_4e3m = EDHOC_Extract( SALT_4e3m, G_IY ), where",
      "ja": "イニシエーターが静的diffie-hellmanキーで認証されている場合、prk_4e3m = edhoc_extract（salt_4e3m、g_iy）、ここで"
    },
    {
      "indent": 6,
      "text": "* SALT_4e3m is derived from PRK_3e2m (see Section 4.1.2) and",
      "ja": "* SALT_4E3MはPRK_3E2M（セクション4.1.2を参照）に由来し、"
    },
    {
      "indent": 6,
      "text": "* G_IY is the ECDH shared secret calculated from G_I and Y, or G_Y and I (the Initiator's private authentication key; see Section 3.5.1),",
      "ja": "* G_IYは、G_IとYから計算されたECDH共有秘密、またはG_YとI（イニシエーターのプライベート認証キー、セクション3.5.1を参照）から計算されています。"
    },
    {
      "indent": 3,
      "text": "else PRK_4e3m = PRK_3e2m.",
      "ja": "それ以外の場合、prk_4e3m = prk_3e2m。"
    },
    {
      "indent": 0,
      "text": "4.1.2. EDHOC_Expand and EDHOC_KDF",
      "section_title": true,
      "ja": "4.1.2. edhoc_expandおよびedhoc_kdf"
    },
    {
      "indent": 3,
      "text": "The output keying material (OKM) -- including keys, initialization vectors (IVs), and salts -- are derived from the PRKs using the EDHOC_KDF, which is defined through EDHOC_Expand:",
      "ja": "キー、初期化ベクトル（IV）、塩を含む出力キーイング材料（OKM）は、EDHOC_EXPANDを介して定義されているEDHOC_KDFを使用してPRKに由来します。"
    },
    {
      "indent": 6,
      "text": "OKM = EDHOC_KDF( PRK, info_label, context, length )\n    = EDHOC_Expand( PRK, info, length )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where info is encoded as the CBOR sequence:",
      "ja": "情報がCBORシーケンスとしてエンコードされている場合："
    },
    {
      "indent": 3,
      "text": "info = (\n  info_label : int,\n  context : bstr,\n  length : uint,\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where:",
      "ja": "ただし："
    },
    {
      "indent": 6,
      "text": "* info_label is an int,",
      "ja": "* info_labelはintです、"
    },
    {
      "indent": 6,
      "text": "* context is a bstr, and",
      "ja": "* コンテキストはBSTRです"
    },
    {
      "indent": 6,
      "text": "* length is the length of OKM in bytes.",
      "ja": "* 長さは、バイト単位のOKMの長さです。"
    },
    {
      "indent": 3,
      "text": "When EDHOC_KDF is used to derive OKM for EDHOC message processing, then the context includes one of the transcript hashes, TH_2, TH_3, or TH_4, defined in Sections 5.3.2 and 5.4.2.",
      "ja": "EDHOC_KDFを使用してEDHOCメッセージ処理のOKMを導出する場合、コンテキストには、セクション5.3.2および5.4.2で定義されているトランスクリプトハッシュの1つ、TH_2、TH_3、またはTH_4が含まれます。"
    },
    {
      "indent": 3,
      "text": "The definition of EDHOC_Expand depends on the EDHOC hash algorithm of the selected cipher suite:",
      "ja": "EDHOC_EXPANDの定義は、選択した暗号スイートのEDHOCハッシュアルゴリズムに依存します。"
    },
    {
      "indent": 6,
      "text": "* If the EDHOC hash algorithm is SHA-2, then EDHOC_Expand( PRK, info, length ) = HKDF-Expand( PRK, info, length ) [RFC5869].",
      "ja": "* EDHOCハッシュアルゴリズムがSHA-2の場合、EDHOC_EXPAND（PRK、INFO、LENGTH）= HKDF-EXPAND（PRK、INFO、LENGTH）[RFC5869]。"
    },
    {
      "indent": 6,
      "text": "* If the EDHOC hash algorithm is SHAKE128, then EDHOC_Expand( PRK, info, length ) = KMAC128( PRK, info, L, \"\" ).",
      "ja": "* EDHOCハッシュアルゴリズムがSHAKE128の場合、EDHOC_EXPAND（PRK、INFO、LENGTH）= KMAC128（PRK、INFO、L、 \"\"）。"
    },
    {
      "indent": 6,
      "text": "* If the EDHOC hash algorithm is SHAKE256, then EDHOC_Expand( PRK, info, length ) = KMAC256( PRK, info, L, \"\" ).",
      "ja": "* EDHOCハッシュアルゴリズムがShake256の場合、Edhoc_expand（prk、info、length）= kmac256（prk、info、l、 \"\"）。"
    },
    {
      "indent": 3,
      "text": "where L = 8 ⋅ length, the output length in bits.",
      "ja": "ここで、L =8⋅の長さ、ビットの出力長。"
    },
    {
      "indent": 3,
      "text": "Figure 6 lists derivations made with EDHOC_KDF, where:",
      "ja": "図6は、EDHOC_KDFで作成された派生派を示します。ここで"
    },
    {
      "indent": 6,
      "text": "* hash_length is the length of output size of the EDHOC hash algorithm of the selected cipher suite,",
      "ja": "* hash_lengthは、選択した暗号スイートのedhocハッシュアルゴリズムの出力サイズの長さです。"
    },
    {
      "indent": 6,
      "text": "* key_length is the length of the encryption key of the EDHOC AEAD algorithm of the selected cipher suite, and",
      "ja": "* key_lengthは、選択した暗号スイートのEdhoc Aeadアルゴリズムの暗号化キーの長さであり、"
    },
    {
      "indent": 6,
      "text": "* iv_length is the length of the initialization vector of the EDHOC AEAD algorithm of the selected cipher suite",
      "ja": "* IV_LENGTHは、選択した暗号スイートのEDHOC AEADアルゴリズムの初期化ベクトルの長さです"
    },
    {
      "indent": 3,
      "text": "Further details of the key derivation and how the output keying material is used are specified in Section 5.",
      "ja": "キー派生の詳細と出力キーイン材料の使用方法は、セクション5で指定されています。"
    },
    {
      "indent": 3,
      "text": "KEYSTREAM_2   = EDHOC_KDF( PRK_2e,   0, TH_2,      plaintext_length )\nSALT_3e2m     = EDHOC_KDF( PRK_2e,   1, TH_2,      hash_length )\nMAC_2         = EDHOC_KDF( PRK_3e2m, 2, context_2, mac_length_2 )\nK_3           = EDHOC_KDF( PRK_3e2m, 3, TH_3,      key_length )\nIV_3          = EDHOC_KDF( PRK_3e2m, 4, TH_3,      iv_length )\nSALT_4e3m     = EDHOC_KDF( PRK_3e2m, 5, TH_3,      hash_length )\nMAC_3         = EDHOC_KDF( PRK_4e3m, 6, context_3, mac_length_3 )\nPRK_out       = EDHOC_KDF( PRK_4e3m, 7, TH_4,      hash_length )\nK_4           = EDHOC_KDF( PRK_4e3m, 8, TH_4,      key_length )\nIV_4          = EDHOC_KDF( PRK_4e3m, 9, TH_4,      iv_length )\nPRK_exporter  = EDHOC_KDF( PRK_out, 10, h'',       hash_length )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 6: Key Derivations Using EDHOC_KDF",
      "ja": "図6：EDHOC_KDFを使用した重要な派生"
    },
    {
      "indent": 3,
      "text": "h'' is CBOR diagnostic notation for the empty byte string, 0x40.",
      "ja": "H ''は、空のバイト文字列0x40のCBOR診断表記です。"
    },
    {
      "indent": 0,
      "text": "4.1.3. PRK_out",
      "section_title": true,
      "ja": "4.1.3. prk_out"
    },
    {
      "indent": 3,
      "text": "The pseudorandom key PRK_out, derived as shown in Figure 6, is the output session key of a completed EDHOC session.",
      "ja": "図6に示すように導出された擬似ランダムキーPRK_outは、完成したEDHOCセッションの出力セッションキーです。"
    },
    {
      "indent": 3,
      "text": "Keys for applications are derived using EDHOC_Exporter (see Section 4.2.1) from PRK_exporter, which in turn is derived from PRK_out as shown in Figure 6. For the purpose of generating application keys, it is sufficient to store PRK_out or PRK_exporter. (Note that the word \"store\" used here does not imply that the application has access to the plaintext PRK_out since that may be reserved for code within a Trusted Execution Environment (TEE); see Section 9.8.)",
      "ja": "アプリケーションのキーは、PRK_EXPORTERのEDHOC_EXPORTER（セクション4.2.1を参照）を使用して導出されます。これは、図6に示すようにPRK_OUTから派生しています。アプリケーションキーを生成するために、PRK_OUTまたはPRK_EXPORTERを保存することが十分です。（ここで使用されている「ストア」という単語は、アプリケーションが信頼できる実行環境（TEE）内のコード用に予約される可能性があるため、アプリケーションがPRK_OUTにアクセスできることを意味しないことに注意してください。セクション9.8を参照してください。）"
    },
    {
      "indent": 0,
      "text": "4.2. Keys for EDHOC Applications",
      "section_title": true,
      "ja": "4.2. EDHOCアプリケーションのキー"
    },
    {
      "indent": 3,
      "text": "This section defines EDHOC_Exporter in terms of EDHOC_KDF and PRK_exporter. A key update function is defined in Appendix H.",
      "ja": "このセクションでは、EDHOC_KDFとPRK_EXPORTERの観点からEDHOC_EXPORTERを定義します。キーアップデート関数は、付録Hで定義されています。"
    },
    {
      "indent": 0,
      "text": "4.2.1. EDHOC_Exporter",
      "section_title": true,
      "ja": "4.2.1. edhoc_exporter"
    },
    {
      "indent": 3,
      "text": "Keying material for the application can be derived using the EDHOC_Exporter interface defined as:",
      "ja": "アプリケーション用のキーキーミーは、次のように定義されたEDHOC_EXPORTERインターフェイスを使用して導出できます。"
    },
    {
      "indent": 6,
      "text": "EDHOC_Exporter(exporter_label, context, length)\n  = EDHOC_KDF(PRK_exporter, exporter_label, context, length)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where:",
      "ja": "ただし："
    },
    {
      "indent": 6,
      "text": "* exporter_label is a registered uint from the \"EDHOC Exporter Labels\" registry (Section 10.1),",
      "ja": "* Exporter_labelは、「Edhoc Exporter Labels」レジストリ（セクション10.1）から登録されたUINTです。"
    },
    {
      "indent": 6,
      "text": "* context is a bstr defined by the application, and",
      "ja": "* コンテキストは、アプリケーションによって定義されるBSTRであり、"
    },
    {
      "indent": 6,
      "text": "* length is a uint defined by the application.",
      "ja": "* 長さは、アプリケーションで定義されたUINTです。"
    },
    {
      "indent": 3,
      "text": "The (exporter_label, context) pair used in EDHOC_Exporter must be unique, i.e., an (exporter_label, context) MUST NOT be used for two different purposes. However, an application can re-derive the same key several times as long as it is done securely. For example, in most encryption algorithms, the same key can be reused with different nonces. The context can, for example, be the empty CBOR byte string.",
      "ja": "EDHOC_EXPORTERで使用される（Exporter_Label、Context）ペアは一意でなければなりません。つまり、（exporter_label、コンテキスト）は、2つの異なる目的に使用してはなりません。ただし、アプリケーションは、安全に行われている限り、同じキーを数回再派生させることができます。たとえば、ほとんどの暗号化アルゴリズムでは、同じキーを異なるNonceで再利用できます。たとえば、コンテキストは空のCborバイト文字列にすることができます。"
    },
    {
      "indent": 3,
      "text": "Examples of use of the EDHOC_Exporter are given in Appendix A.",
      "ja": "EDHOC_EXPORTERの使用の例は、付録Aに記載されています。"
    },
    {
      "indent": 0,
      "text": "5. Message Formatting and Processing",
      "section_title": true,
      "ja": "5. メッセージのフォーマットと処理"
    },
    {
      "indent": 3,
      "text": "This section specifies formatting of the messages and processing steps. Error messages are specified in Section 6. Annotated traces of EDHOC sessions are provided in [RFC9529].",
      "ja": "このセクションでは、メッセージと処理手順のフォーマットを指定します。エラーメッセージはセクション6で指定されています。EDHOCセッションの注釈付きトレースは、[RFC9529]で提供されています。"
    },
    {
      "indent": 3,
      "text": "An EDHOC message is encoded as a sequence of CBOR data items (CBOR Sequence [RFC8742]). Additional optimizations are made to reduce message overhead.",
      "ja": "EDHOCメッセージは、CBORデータ項目のシーケンスとしてエンコードされます（CBORシーケンス[RFC8742]）。メッセージオーバーヘッドを減らすために追加の最適化が行われます。"
    },
    {
      "indent": 3,
      "text": "While EDHOC uses the COSE_Key, COSE_Sign1, and COSE_Encrypt0 structures, only a subset of the parameters is included in the EDHOC messages; see Appendix C.3. In order to recreate the COSE object, the recipient endpoint may need to add parameters to the COSE headers not included in the EDHOC message, for example, the parameter 'alg' to COSE_Sign1 or COSE_Encrypt0.",
      "ja": "EDHOCはCOSE_KEY、COSE_SIGN1、およびCOSE_ENCRYPT0構造を使用していますが、パラメーターのサブセットのみがEDHOCメッセージに含まれています。付録C.3を参照してください。COSEオブジェクトを再作成するために、受信者のエンドポイントは、EDHOCメッセージに含まれていないCOSEヘッダーにパラメーターを追加する必要がある場合があります。たとえば、cose_sign1またはcose_encrypt0のパラメーター「アルグ」です。"
    },
    {
      "indent": 0,
      "text": "5.1. EDHOC Message Processing Outline",
      "section_title": true,
      "ja": "5.1. EDHOCメッセージ処理の概要"
    },
    {
      "indent": 3,
      "text": "For each new/ongoing EDHOC session, the endpoints are assumed to keep an associated protocol state containing identifiers, keying material, etc. used for subsequent processing of protocol-related data. The protocol state is assumed to be associated with an application profile (Section 3.9) that provides the context for how messages are transported, identified, and processed.",
      "ja": "新しい/進行中のEDHOCセッションごとに、エンドポイントは、関連する識別子、キーイングマテリアルなどを含む関連するプロトコル状態を保持すると想定されています。プロトコル関連データのその後の処理に使用されます。プロトコル状態は、メッセージの輸送、識別、および処理方法のコンテキストを提供するアプリケーションプロファイル（セクション3.9）に関連付けられていると想定されています。"
    },
    {
      "indent": 3,
      "text": "EDHOC messages SHALL be processed according to the current protocol state. The following steps are expected to be performed at reception of an EDHOC message:",
      "ja": "EDHOCメッセージは、現在のプロトコル状態に従って処理されます。次の手順は、EDHOCメッセージの受信時に実行される予定です。"
    },
    {
      "indent": 8,
      "text": "1. Detect that an EDHOC message has been received, for example, by means of a port number, URI, or media type (Section 3.9).",
      "ja": "1. たとえば、ポート番号、URI、またはメディアタイプを使用して、EDHOCメッセージが受信されたことを検出します（セクション3.9）。"
    },
    {
      "indent": 8,
      "text": "2. Retrieve the protocol state according to the message correlation; see Section 3.4.1. If there is no protocol state, in the case of message_1, a new protocol state is created. The Responder endpoint needs to make use of available denial-of-service mitigation (Section 9.7).",
      "ja": "2. メッセージの相関に従ってプロトコル状態を取得します。セクション3.4.1を参照してください。プロトコル状態がない場合、message_1の場合、新しいプロトコル状態が作成されます。レスポンダーのエンドポイントは、利用可能なサービス拒否緩和を利用する必要があります（セクション9.7）。"
    },
    {
      "indent": 8,
      "text": "3. If the message received is an error message, then process it according to Section 6, else process it as the expected next message according to the protocol state.",
      "ja": "3. 受信したメッセージがエラーメッセージである場合、セクション6に従って処理します。その場合、プロトコル状態に従って予想される次のメッセージとして処理します。"
    },
    {
      "indent": 3,
      "text": "The message processing steps SHALL be processed in order, unless otherwise stated. If the processing fails for some reason, then typically an error message is sent, the EDHOC session is aborted, and the protocol state is erased. When the composition and sending of one message is completed and before the next message is received, error messages SHALL NOT be sent.",
      "ja": "特に明記しない限り、メッセージ処理手順は順番に処理されます。処理が何らかの理由で失敗した場合、通常、エラーメッセージが送信され、EDHOCセッションが中止され、プロトコル状態が消去されます。1つのメッセージの構成と送信が完了し、次のメッセージが受信される前に、エラーメッセージが送信されません。"
    },
    {
      "indent": 3,
      "text": "After having successfully processed the last message (message_3 or message_4 depending on application profile), the EDHOC session is completed; after which, no error messages are sent and EDHOC session output MAY be maintained even if error messages are received. Further details are provided in the following subsections and in Section 6.",
      "ja": "最後のメッセージ（アプリケーションプロファイルに応じてmessage_3またはmessage_4）を正常に処理した後、EDHOCセッションが完了します。その後、エラーメッセージが送信されず、エラーメッセージが受信された場合でもEDHOCセッションの出力が維持される場合があります。詳細については、以下のサブセクションとセクション6に記載されています。"
    },
    {
      "indent": 3,
      "text": "Different instances of the same message MUST NOT be processed in one EDHOC session. Note that processing will fail if the same message appears a second time for EDHOC processing in the same EDHOC session because the state of the protocol has moved on and now expects something else. Message deduplication MUST be done by the transport protocol (see Section 3.4) or, if not supported by the transport, as described in Section 7.",
      "ja": "同じメッセージの異なるインスタンスを1つのEDHOCセッションで処理してはなりません。プロトコルの状態が移動し、今では他の何かを期待しているため、同じメッセージが同じEDHOCセッションでEDHOC処理に2回目に表示される場合、処理が失敗することに注意してください。メッセージ重複排除は、輸送プロトコル（セクション3.4を参照）で行う必要があります。または、セクション7で説明されているように、輸送でサポートされていない場合は、行う必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2. EDHOC Message 1",
      "section_title": true,
      "ja": "5.2. EDHOCメッセージ1"
    },
    {
      "indent": 0,
      "text": "5.2.1. Formatting of Message 1",
      "section_title": true,
      "ja": "5.2.1. メッセージのフォーマット1"
    },
    {
      "indent": 3,
      "text": "message_1 SHALL be a CBOR Sequence (see Appendix C.1), as defined below.",
      "ja": "Message_1は、以下に定義するように、CBORシーケンス（付録C.1を参照）でなければなりません。"
    },
    {
      "indent": 3,
      "text": "message_1 = (\n  METHOD : int,\n  SUITES_I : suites,\n  G_X : bstr,\n  C_I : bstr / -24..23,\n  ? EAD_1,\n)\n\nsuites = [ 2* int ] / int\nEAD_1 = 1* ead",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where:",
      "ja": "ただし："
    },
    {
      "indent": 6,
      "text": "* METHOD is an authentication method; see Section 3.2,",
      "ja": "* 方法は認証方法です。セクション3.2を参照してください。"
    },
    {
      "indent": 6,
      "text": "* SUITES_I is an array of cipher suites that the Initiator supports constructed as specified in Section 5.2.2,",
      "ja": "* Suites_iは、セクション5.2.2で指定されているように構築されたイニシエーターがサポートする暗号スイートの配列です。"
    },
    {
      "indent": 6,
      "text": "* G_X is the ephemeral public key of the Initiator, and",
      "ja": "* G_Xはイニシエーターのはかない公開鍵であり、"
    },
    {
      "indent": 6,
      "text": "* C_I is a variable-length connection identifier (note that connection identifiers are byte strings but certain values are represented as integers in the message; see Section 3.3.2), and",
      "ja": "* C_Iは可変長の接続識別子です（接続識別子はバイト文字列ですが、特定の値はメッセージの整数として表されます。セクション3.3.2を参照）、および"
    },
    {
      "indent": 6,
      "text": "* EAD_1 is external authorization data; see Section 3.8.",
      "ja": "* EAD_1は外部認証データです。セクション3.8を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Initiator Composition of Message 1",
      "section_title": true,
      "ja": "5.2.2. メッセージ1のイニシエーター構成"
    },
    {
      "indent": 3,
      "text": "The processing steps are detailed below and in Section 6.3.",
      "ja": "処理手順の詳細については、セクション6.3に詳しく説明しています。"
    },
    {
      "indent": 3,
      "text": "The Initiator SHALL compose message_1 as follows:",
      "ja": "イニシエーターは、次のようにmessage_1を作成するものとします。"
    },
    {
      "indent": 6,
      "text": "* Construct SUITES_I as an array of cipher suites supported by I in order of preference by I with the first cipher suite in the array being the most preferred by I and the last being the one selected by I for this EDHOC session. If the cipher suite most preferred by I is selected, then SUITES_I contains only that cipher suite and is encoded as an int. All cipher suites, if any, preferred by I over the selected one MUST be included. (See also Section 6.3.)",
      "ja": "* iがサポートする一連の暗号スイートとして、Iが最も好みの順にサポートする一連の暗号スイートとしてコンストラクトアレイの最初の暗号スイートがIが最も好まれ、最後はこのEDHOCセッションでIが選択したものです。Iが最も優先する暗号スイートが選択されている場合、suites_iにはその暗号スイートのみが含まれ、intとしてエンコードされます。すべての暗号スイート（もしあれば）は、選択したものよりもIよりも優先される必要があります。（セクション6.3も参照してください。）"
    },
    {
      "indent": 12,
      "text": "- The selected suite is based on what the Initiator can assume to be supported by the Responder; if the Initiator previously received from the Responder an error message with error code 2 containing SUITES_R (see Section 6.3) indicating cipher suites supported by the Responder, then the Initiator SHOULD select its most preferred supported cipher suite among those (bearing in mind that error messages may be forged).",
      "ja": "- 選択したスイートは、イニシエーターがレスポンダーによってサポートされると仮定できるものに基づいています。イニシエーターがレスポンダーから以前に受信した場合、Responderがサポートする暗号スイートを示すSuites_rを含むエラーコード2を含むエラーメッセージを使用した場合、イニシエーターはそれらの中で最も優先されるサポートされている暗号スイートを選択する必要があります（エラーメッセージを心に留めてください偽造される可能性があります）。"
    },
    {
      "indent": 12,
      "text": "- The Initiator MUST NOT change its order of preference for cipher suites and MUST NOT omit a cipher suite preferred to the selected one because of previous error messages received from the Responder.",
      "ja": "- イニシエーターは、暗号スイートの優先順位を変更してはなりません。また、応答者から受信した以前のエラーメッセージのために、選択したスイートよりも優先される暗号スイートを省略してはなりません。"
    },
    {
      "indent": 6,
      "text": "* Generate an ephemeral ECDH key pair using the curve in the selected cipher suite and format it as a COSE_Key. Let G_X be the 'x' parameter of the COSE_Key.",
      "ja": "* 選択したCipherスイートの曲線を使用して、短命のECDHキーペアを生成し、COSE_KEYとしてフォーマットします。G_XをCOSE_KEYの「X」パラメーターとします。"
    },
    {
      "indent": 6,
      "text": "* Choose a connection identifier C_I and store it during the EDHOC session.",
      "ja": "* 接続識別子C_Iを選択し、EDHOCセッション中に保存します。"
    },
    {
      "indent": 6,
      "text": "* Encode message_1 as a sequence of CBOR-encoded data items as specified in Section 5.2.1",
      "ja": "* セクション5.2.1で指定されているように、cborエンコードデータ項目のシーケンスとしてmessage_1をエンコード"
    },
    {
      "indent": 0,
      "text": "5.2.3. Responder Processing of Message 1",
      "section_title": true,
      "ja": "5.2.3. メッセージ1のレスポンダー処理"
    },
    {
      "indent": 3,
      "text": "The Responder SHALL process message_1 in the following order:",
      "ja": "レスポンダーは、次の順序でmessage_1を処理するものとします。"
    },
    {
      "indent": 8,
      "text": "1. Decode message_1 (see Appendix C.1).",
      "ja": "1. メッセージ_1をデコードします（付録C.1を参照）。"
    },
    {
      "indent": 8,
      "text": "2. Process message_1. In particular, verify that the selected cipher suite is supported and that no prior cipher suite as ordered in SUITES_I is supported.",
      "ja": "2. message_1を処理します。特に、選択した暗号スイートがサポートされており、suites_iで注文した以前の暗号スイートがサポートされていないことを確認してください。"
    },
    {
      "indent": 8,
      "text": "3. If all processing completed successfully, and if EAD_1 is present, then make it available to the application for EAD processing.",
      "ja": "3. すべての処理が正常に完了し、EAD_1が存在する場合は、EAD処理のためにアプリケーションを利用できるようにします。"
    },
    {
      "indent": 3,
      "text": "If any processing step fails, then the Responder MUST send an EDHOC error message back as defined in Section 6, and the EDHOC session MUST be aborted.",
      "ja": "処理ステップが失敗した場合、レスポンダーはセクション6で定義されているようにEDHOCエラーメッセージを返送する必要があり、EDHOCセッションを中止する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3. EDHOC Message 2",
      "section_title": true,
      "ja": "5.3. EDHOCメッセージ2"
    },
    {
      "indent": 0,
      "text": "5.3.1. Formatting of Message 2",
      "section_title": true,
      "ja": "5.3.1. メッセージ2のフォーマット"
    },
    {
      "indent": 3,
      "text": "message_2 SHALL be a CBOR Sequence (see Appendix C.1), as defined below.",
      "ja": "Message_2は、以下に定義するように、CBORシーケンス（付録C.1を参照）でなければなりません。"
    },
    {
      "indent": 3,
      "text": "message_2 = (\n  G_Y_CIPHERTEXT_2 : bstr,\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where:",
      "ja": "ただし："
    },
    {
      "indent": 6,
      "text": "* G_Y_CIPHERTEXT_2 is the concatenation of G_Y (i.e., the ephemeral public key of the Responder) and CIPHERTEXT_2.",
      "ja": "* g_y_ciphertext_2は、G_y（すなわち、レスポンダーのはかない公共鍵）とciphertext_2の連結です。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Responder Composition of Message 2",
      "section_title": true,
      "ja": "5.3.2. メッセージ2のレスポンダー構成"
    },
    {
      "indent": 3,
      "text": "The Responder SHALL compose message_2 as follows:",
      "ja": "応答者は、次のようにmessage_2を作成するものとします。"
    },
    {
      "indent": 6,
      "text": "* Generate an ephemeral ECDH key pair using the curve in the selected cipher suite and format it as a COSE_Key. Let G_Y be the 'x' parameter of the COSE_Key.",
      "ja": "* 選択したCipherスイートの曲線を使用して、短命のECDHキーペアを生成し、COSE_KEYとしてフォーマットします。g_yをcose_keyの「x」パラメーターとします。"
    },
    {
      "indent": 6,
      "text": "* Choose a connection identifier C_R and store it for the length of the EDHOC session.",
      "ja": "* 接続識別子C_Rを選択し、EDHOCセッションの長さで保存します。"
    },
    {
      "indent": 6,
      "text": "* Compute the transcript hash TH_2 = H( G_Y, H(message_1) ), where H() is the EDHOC hash algorithm of the selected cipher suite. The input to the hash function is a CBOR Sequence. Note that H(message_1) can be computed and cached already in the processing of message_1.",
      "ja": "* 転写産物ハッシュTH_2 = H（G_Y、H（Message_1））を計算します。ここで、H（）は選択した暗号スイートのEDHOCハッシュアルゴリズムです。ハッシュ関数への入力はCBORシーケンスです。h（message_1）は、message_1の処理ですでに計算およびキャッシュできることに注意してください。"
    },
    {
      "indent": 6,
      "text": "* Compute MAC_2 as in Section 4.1.2 with context_2 = << C_R, ID_CRED_R, TH_2, CRED_R, ? EAD_2 >> (see Appendix C.1 for notation).",
      "ja": "* Context_2 = << C_R、ID_CRED_R、TH_2、CRED_R、context_2 = << c_r、with context 4.1.2のようにMAC_2を計算しますか？EAD_2 >>（表記については付録C.1を参照）。"
    },
    {
      "indent": 12,
      "text": "- If the Responder authenticates with a static Diffie-Hellman key (method equals 1 or 3), then mac_length_2 is the EDHOC MAC length of the selected cipher suite. If the Responder authenticates with a signature key (method equals 0 or 2), then mac_length_2 is equal to hash_length.",
      "ja": "- Responderが静的Diffie-Hellmanキー（メソッドは1または3に等しい）で認証される場合、Mac_Length_2は選択した暗号スイートのEDHOC MACの長さです。応答者が署名キー（メソッドは0または2に等しい）で認証される場合、Mac_Length_2はHASH_LENGTHに等しくなります。"
    },
    {
      "indent": 12,
      "text": "- C_R is a variable-length connection identifier. Note that connection identifiers are byte strings but certain values are represented as integers in the message; see Section 3.3.2.",
      "ja": "- C_Rは、可変長接続識別子です。接続識別子はバイト文字列ですが、特定の値はメッセージ内の整数として表されることに注意してください。セクション3.3.2を参照してください。"
    },
    {
      "indent": 12,
      "text": "- ID_CRED_R is an identifier to facilitate the retrieval of CRED_R; see Section 3.5.3.",
      "ja": "- ID_CRED_Rは、CRED_Rの検索を容易にする識別子です。セクション3.5.3を参照してください。"
    },
    {
      "indent": 12,
      "text": "- CRED_R is a CBOR item containing the authentication credential of the Responder; see Section 3.5.2.",
      "ja": "- CRED_Rは、応答者の認証資格情報を含むCBORアイテムです。セクション3.5.2を参照してください。"
    },
    {
      "indent": 12,
      "text": "- EAD_2 is external authorization data; see Section 3.8.",
      "ja": "- EAD_2は外部認証データです。セクション3.8を参照してください。"
    },
    {
      "indent": 6,
      "text": "* If the Responder authenticates with a static Diffie-Hellman key (method equals 1 or 3), then Signature_or_MAC_2 is MAC_2. If the Responder authenticates with a signature key (method equals 0 or 2), then Signature_or_MAC_2 is the 'signature' field of a COSE_Sign1 object, computed as specified in Section 4.4 of [RFC9052] using the signature algorithm of the selected cipher suite, the private authentication key of the Responder, and the following parameters as input (see Appendix C.3 for an overview of COSE and Appendix C.1 for notation):",
      "ja": "* レスポンダーが静的diffie-hellmanキー（メソッドが1または3に等しい）で認証される場合、signature_or_mac_2はmac_2です。レスポンダーが署名キー（メソッドは0または2に等しい）で認証される場合、signature_or_or_mac_2は、[RFC9052]のセクション4.4で指定されているように計算されたCOSE_SIGN1オブジェクトの「署名」フィールドです。Responderのプライベート認証キー、および入力としての次のパラメーター（付録C.3を参照してください。Coseの概要と表記については付録C.1を参照）："
    },
    {
      "indent": 12,
      "text": "- protected = << ID_CRED_R >>",
      "ja": "- 保護= << ID_CRED_R >>"
    },
    {
      "indent": 12,
      "text": "- external_aad = << TH_2, CRED_R, ? EAD_2 >>",
      "ja": "- external_aad = << th_2、cred_r、？EAD_2 >>"
    },
    {
      "indent": 12,
      "text": "- payload = MAC_2",
      "ja": "- ペイロード= mac_2"
    },
    {
      "indent": 6,
      "text": "* CIPHERTEXT_2 is calculated with a binary additive stream cipher, using a keystream generated with EDHOC_Expand and the following plaintext:",
      "ja": "* ciphertext_2は、edhoc_expandと次の平文で生成されたキーストリームを使用して、バイナリ添加剤ストリーム暗号で計算されます。"
    },
    {
      "indent": 12,
      "text": "- PLAINTEXT_2 = ( C_R, ID_CRED_R / bstr / -24..23, Signature_or_MAC_2, ? EAD_2 )",
      "ja": "- plaintext_2 =（c_r、id_cred_r / bstr / -24..23、signature_or_mac_2、？ead_2）"
    },
    {
      "indent": 18,
      "text": "o If ID_CRED_R contains a single 'kid' parameter, i.e., ID_CRED_R = { 4 : kid_R }, then the compact encoding is applied; see Section 3.5.3.2.",
      "ja": "o ID_CRED_Rに単一の「KID」パラメーター、つまりID_CRED_R = {4：KID_R}が含まれている場合、コンパクトエンコードが適用されます。セクション3.5.3.2を参照してください。"
    },
    {
      "indent": 18,
      "text": "o C_R is the variable-length connection identifier. Note that connection identifiers are byte strings, but certain values are represented as integers in the message; see Section 3.3.2.",
      "ja": "o C_Rは可変長接続識別子です。接続識別子はバイト文字列ですが、特定の値はメッセージ内の整数として表されることに注意してください。セクション3.3.2を参照してください。"
    },
    {
      "indent": 12,
      "text": "- Compute KEYSTREAM_2 as in Section 4.1.2, where plaintext_length is the length of PLAINTEXT_2. For the case of plaintext_length exceeding the EDHOC_KDF output size, see Appendix G.",
      "ja": "- keystream_2をセクション4.1.2のように計算します。ここで、plantext_lengthはplantext_2の長さです。EDHOC_KDF出力サイズを超えるPlantext_Lengthの場合については、付録Gを参照してください。"
    },
    {
      "indent": 12,
      "text": "- CIPHERTEXT_2 = PLAINTEXT_2 XOR KEYSTREAM_2",
      "ja": "- ciphertext_2 = plaintext_2 xor keystream_2"
    },
    {
      "indent": 6,
      "text": "* Encode message_2 as a sequence of CBOR-encoded data items as specified in Section 5.3.1.",
      "ja": "* セクション5.3.1で指定されているように、cborエンコードデータ項目のシーケンスとしてmessage_2をエンコードします。"
    },
    {
      "indent": 0,
      "text": "5.3.3. Initiator Processing of Message 2",
      "section_title": true,
      "ja": "5.3.3. メッセージ2のイニシエーター処理"
    },
    {
      "indent": 3,
      "text": "The Initiator SHALL process message_2 in the following order:",
      "ja": "イニシエーターは、次の順序でmessage_2を処理するものとします。"
    },
    {
      "indent": 8,
      "text": "1. Decode message_2 (see Appendix C.1).",
      "ja": "1. メッセージ_2をデコードします（付録C.1を参照）。"
    },
    {
      "indent": 8,
      "text": "2. Retrieve the protocol state using available message correlation (e.g., the CoAP Token, the 5-tuple, or the prepended C_I; see Section 3.4.1).",
      "ja": "2. 利用可能なメッセージ相関を使用してプロトコル状態を取得します（例：COAPトークン、5タプル、または準備されたC_I、セクション3.4.1を参照）。"
    },
    {
      "indent": 8,
      "text": "3. Decrypt CIPHERTEXT_2; see Section 5.3.2.",
      "ja": "3. ciphertext_2を復号化するセクション5.3.2を参照してください。"
    },
    {
      "indent": 8,
      "text": "4. If all processing is completed successfully, then make ID_CRED_R and (if present) EAD_2 available to the application for authentication and EAD processing. When and how to perform authentication is up to the application.",
      "ja": "4. すべての処理が正常に完了した場合、ID_CRED_Rを作成し、（存在する場合）EAD_2を認証とEAD処理のためにアプリケーションで利用できます。認証の実行方法は、アプリケーション次第です。"
    },
    {
      "indent": 8,
      "text": "5. Obtain the authentication credential (CRED_R) and the authentication key of R from the application (or by other means).",
      "ja": "5. Authentication Credential（CRED_R）とアプリケーションからRの認証キーを取得します（または他の手段）。"
    },
    {
      "indent": 8,
      "text": "6. Verify Signature_or_MAC_2 using the algorithm in the selected cipher suite. The verification process depends on the method; see Section 5.3.2. Make the result of the verification available to the application.",
      "ja": "6. 選択した暗号スイートのアルゴリズムを使用して、signature_or_mac_2を確認します。検証プロセスはメソッドに依存します。セクション5.3.2を参照してください。検証の結果をアプリケーションで利用できるようにします。"
    },
    {
      "indent": 3,
      "text": "If any processing step fails, then the Initiator MUST send an EDHOC error message back as defined in Section 6, and the EDHOC session MUST be aborted.",
      "ja": "処理ステップが失敗した場合、イニシエーターはセクション6で定義されているようにEDHOCエラーメッセージを返送する必要があり、EDHOCセッションを中止する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.4. EDHOC Message 3",
      "section_title": true,
      "ja": "5.4. EDHOCメッセージ3"
    },
    {
      "indent": 0,
      "text": "5.4.1. Formatting of Message 3",
      "section_title": true,
      "ja": "5.4.1. メッセージ3のフォーマット"
    },
    {
      "indent": 3,
      "text": "message_3 SHALL be a CBOR Sequence (see Appendix C.1), as defined below.",
      "ja": "Message_3は、以下に定義するように、CBORシーケンス（付録C.1を参照）でなければなりません。"
    },
    {
      "indent": 3,
      "text": "message_3 = (\n  CIPHERTEXT_3 : bstr,\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.4.2. Initiator Composition of Message 3",
      "section_title": true,
      "ja": "5.4.2. メッセージ3のイニシエーター構成"
    },
    {
      "indent": 3,
      "text": "The Initiator SHALL compose message_3 as follows:",
      "ja": "イニシエーターは、次のようにmessage_3を作成するものとします。"
    },
    {
      "indent": 6,
      "text": "* Compute the transcript hash TH_3 = H(TH_2, PLAINTEXT_2, CRED_R), where H() is the EDHOC hash algorithm of the selected cipher suite. The input to the hash function is a CBOR Sequence. Note that TH_3 can be computed and cached already in the processing of message_2.",
      "ja": "* トランスクリプトハッシュTH_3 = H（TH_2、PLANTEXT_2、CRED_R）を計算します。ここで、H（）は選択された暗号スイートのEDHOCハッシュアルゴリズムです。ハッシュ関数への入力はCBORシーケンスです。TH_3は、Message_2の処理にすでに計算およびキャッシュできることに注意してください。"
    },
    {
      "indent": 6,
      "text": "* Compute MAC_3 as in Section 4.1.2, with context_3 = << ID_CRED_I, TH_3, CRED_I, ? EAD_3 >>",
      "ja": "* Context_3 = << id_cred_i、th_3、cred_i、with context_3 = << id_cred_i、？EAD_3 >>"
    },
    {
      "indent": 12,
      "text": "- If the Initiator authenticates with a static Diffie-Hellman key (method equals 2 or 3), then mac_length_3 is the EDHOC MAC length of the selected cipher suite. If the Initiator authenticates with a signature key (method equals 0 or 1), then mac_length_3 is equal to hash_length.",
      "ja": "- イニシエーターが静的diffie-hellmanキー（メソッドが2または3に等しい）で認証される場合、mac_length_3は選択した暗号スイートのedhoc macの長さです。イニシエーターが署名キー（メソッドは0または1に等しい）で認証される場合、Mac_Length_3はhash_lengthに等しくなります。"
    },
    {
      "indent": 12,
      "text": "- ID_CRED_I is an identifier to facilitate the retrieval of CRED_I; see Section 3.5.3.",
      "ja": "- ID_CRED_Iは、CRED_Iの検索を容易にする識別子です。セクション3.5.3を参照してください。"
    },
    {
      "indent": 12,
      "text": "- CRED_I is a CBOR item containing the authentication credential of the Initiator; see Section 3.5.2.",
      "ja": "- CRED_Iは、イニシエーターの認証資格情報を含むCBORアイテムです。セクション3.5.2を参照してください。"
    },
    {
      "indent": 12,
      "text": "- EAD_3 is external authorization data; see Section 3.8.",
      "ja": "- EAD_3は外部認証データです。セクション3.8を参照してください。"
    },
    {
      "indent": 6,
      "text": "* If the Initiator authenticates with a static Diffie-Hellman key (method equals 2 or 3), then Signature_or_MAC_3 is MAC_3. If the Initiator authenticates with a signature key (method equals 0 or 1), then Signature_or_MAC_3 is the 'signature' field of a COSE_Sign1 object, computed as specified in Section 4.4 of [RFC9052] using the signature algorithm of the selected cipher suite, the private authentication key of the Initiator, and the following parameters as input (see Appendix C.3):",
      "ja": "* イニシエーターが静的diffie-hellmanキー（メソッドが2または3に等しい）で認証される場合、signature_or_mac_3はmac_3です。イニシエーターが署名キー（メソッドは0または1に等しい）で認証される場合、signature_or_or_mac_3は、[RFC9052]のセクション4.4で指定されているように計算されたCOSE_SIGN1オブジェクトの「署名」フィールドです。イニシエーターのプライベート認証キー、および入力としての次のパラメーター（付録C.3を参照）："
    },
    {
      "indent": 12,
      "text": "- protected = << ID_CRED_I >>",
      "ja": "- 保護= << id_cred_i >>"
    },
    {
      "indent": 12,
      "text": "- external_aad = << TH_3, CRED_I, ? EAD_3 >>",
      "ja": "- external_aad = << th_3、cred_i、？EAD_3 >>"
    },
    {
      "indent": 12,
      "text": "- payload = MAC_3",
      "ja": "- ペイロード= mac_3"
    },
    {
      "indent": 6,
      "text": "* Compute a COSE_Encrypt0 object as defined in Sections 5.2 and 5.3 of [RFC9052], with the EDHOC AEAD algorithm of the selected cipher suite, using the encryption key K_3, the initialization vector IV_3 (if used by the AEAD algorithm), the plaintext PLAINTEXT_3, and the following parameters as input (see Appendix C.3):",
      "ja": "* [RFC9052]のセクション5.2および5.3で定義されているCOSE_ENCRYPT0オブジェクトを計算し、暗号化キーK_3を使用して、選択された暗号スイートのEDHOC AEADアルゴリズムを使用して、初期化ベクターIV_3（AEADアルゴリズムで使用された場合）、PLAINTEXTEXT PLAINTEXT_3、入力としての次のパラメーター（付録C.3を参照）："
    },
    {
      "indent": 12,
      "text": "- protected = h''",
      "ja": "- 保護= h ''"
    },
    {
      "indent": 12,
      "text": "- external_aad = TH_3",
      "ja": "- external_aad = th_3"
    },
    {
      "indent": 12,
      "text": "- K_3 and IV_3 are defined in Section 4.1.2",
      "ja": "- K_3およびIV_3は、セクション4.1.2で定義されています"
    },
    {
      "indent": 12,
      "text": "- PLAINTEXT_3 = ( ID_CRED_I / bstr / -24..23, Signature_or_MAC_3, ? EAD_3 )",
      "ja": "- plaintext_3 =（id_cred_i / bstr / -24..23、signature_or_mac_3、？ead_3）"
    },
    {
      "indent": 18,
      "text": "o If ID_CRED_I contains a single 'kid' parameter, i.e., ID_CRED_I = { 4 : kid_I }, then the compact encoding is applied; see Section 3.5.3.2.",
      "ja": "o ID_CRED_Iに単一の「KID」パラメーター、つまりID_CRED_I = {4：KID_I}が含まれている場合、コンパクトエンコードが適用されます。セクション3.5.3.2を参照してください。"
    },
    {
      "indent": 10,
      "text": "CIPHERTEXT_3 is the 'ciphertext' of COSE_Encrypt0.",
      "ja": "ciphertext_3は、cose_encrypt0の「ciphertext」です。"
    },
    {
      "indent": 6,
      "text": "* Compute the transcript hash TH_4 = H(TH_3, PLAINTEXT_3, CRED_I), where H() is the EDHOC hash algorithm of the selected cipher suite. The input to the hash function is a CBOR Sequence.",
      "ja": "* トランスクリプトハッシュTH_4 = H（TH_3、PLANTEXT_3、CRED_I）を計算します。ここで、H（）は選択された暗号スイートのEDHOCハッシュアルゴリズムです。ハッシュ関数への入力はCBORシーケンスです。"
    },
    {
      "indent": 6,
      "text": "* Calculate PRK_out as defined in Figure 6. The Initiator can now derive application keys using the EDHOC_Exporter interface; see Section 4.2.1.",
      "ja": "* 図6で定義されているPRK_outを計算します。イニシエーターは、EDHOC_EXPORTERインターフェイスを使用してアプリケーションキーを導出できるようになりました。セクション4.2.1を参照してください。"
    },
    {
      "indent": 6,
      "text": "* Encode message_3 as a CBOR data item as specified in Section 5.4.1.",
      "ja": "* セクション5.4.1で指定されているように、cborデータ項目としてmessage_3をエンコードします。"
    },
    {
      "indent": 6,
      "text": "* Make the connection identifiers (C_I and C_R) and the application algorithms in the selected cipher suite available to the application.",
      "ja": "* 接続識別子（C_IおよびC_R）と、アプリケーションで利用可能な選択した暗号スイートのアプリケーションアルゴリズムを作成します。"
    },
    {
      "indent": 3,
      "text": "After creating message_3, the Initiator can compute PRK_out (see Section 4.1.3) and derive application keys using the EDHOC_Exporter interface (see Section 4.2.1). The Initiator SHOULD NOT persistently store PRK_out or application keys until the Initiator has verified message_4 or a message protected with a derived application key, such as an OSCORE message, from the Responder and the application has authenticated the Responder. This is similar to waiting for an acknowledgment (ACK) in a transport protocol. The Initiator SHOULD NOT send protected application data until the application has authenticated the Responder.",
      "ja": "Message_3を作成した後、イニシエーターはPRK_outを計算し（セクション4.1.3を参照）、EDHOC_EXPORTERインターフェイスを使用してアプリケーションキーを導き出すことができます（セクション4.2.1を参照）。イニシエーターは、PRK_OUTまたはアプリケーションキーを永続的に保存してはなりません。イニシエーターがメッセージ_4または派生したアプリケーションキーで保護されたメッセージを検証して、オスコアメッセージなど、応答者からアプリケーションが応答者を認証しました。これは、輸送プロトコルの謝辞（ACK）を待つことに似ています。イニシエーターは、アプリケーションがレスポンダーを認証するまで、保護されたアプリケーションデータを送信してはなりません。"
    },
    {
      "indent": 0,
      "text": "5.4.3. Responder Processing of Message 3",
      "section_title": true,
      "ja": "5.4.3. メッセージ3のレスポンダー処理"
    },
    {
      "indent": 3,
      "text": "The Responder SHALL process message_3 in the following order:",
      "ja": "レスポンダーは、次の順序でmessage_3を処理するものとします。"
    },
    {
      "indent": 8,
      "text": "1. Decode message_3 (see Appendix C.1).",
      "ja": "1. メッセージ_3をデコードします（付録C.1を参照）。"
    },
    {
      "indent": 8,
      "text": "2. Retrieve the protocol state using available message correlation (e.g., the CoAP Token, the 5-tuple, or the prepended C_R; see Section 3.4.1).",
      "ja": "2. 利用可能なメッセージ相関を使用してプロトコル状態を取得します（例：COAPトークン、5タプル、または準備されたC_R;セクション3.4.1を参照）。"
    },
    {
      "indent": 8,
      "text": "3. Decrypt and verify the COSE_Encrypt0 as defined in Sections 5.2 and 5.3 of [RFC9052], with the EDHOC AEAD algorithm in the selected cipher suite and the parameters defined in Section 5.4.2.",
      "ja": "3. [RFC9052]のセクション5.2および5.3で定義されているCOSE_ENCRYPT0を復号化および検証し、選択した暗号スイートのEDHOC AEADアルゴリズムとセクション5.4.2で定義されているパラメーターを使用します。"
    },
    {
      "indent": 8,
      "text": "4. If all processing completed successfully, then make ID_CRED_I and (if present) EAD_3 available to the application for authentication and EAD processing. When and how to perform authentication is up to the application.",
      "ja": "4. すべての処理が正常に完了した場合、ID_CRED_Iおよび（存在する場合）EAD_3を認証とEAD処理のためにアプリケーションで利用できるようにします。認証の実行方法は、アプリケーション次第です。"
    },
    {
      "indent": 8,
      "text": "5. Obtain the authentication credential (CRED_I) and the authentication key of I from the application (or by other means).",
      "ja": "5. Authentication Credential（cred_i）とアプリケーションからiの認証キーを取得します（または他の手段）。"
    },
    {
      "indent": 8,
      "text": "6. Verify Signature_or_MAC_3 using the algorithm in the selected cipher suite. The verification process depends on the method; see Section 5.4.2. Make the result of the verification available to the application.",
      "ja": "6. 選択した暗号スイートのアルゴリズムを使用して、signature_or_mac_3を確認します。検証プロセスはメソッドに依存します。セクション5.4.2を参照してください。検証の結果をアプリケーションで利用できるようにします。"
    },
    {
      "indent": 8,
      "text": "7. Make the connection identifiers (C_I and C_R) and the application algorithms in the selected cipher suite available to the application.",
      "ja": "7. 接続識別子（C_IおよびC_R）と、アプリケーションで利用可能な選択した暗号スイートのアプリケーションアルゴリズムを作成します。"
    },
    {
      "indent": 3,
      "text": "After processing message_3, the Responder can compute PRK_out (see Section 4.1.3) and derive application keys using the EDHOC_Exporter interface (see Section 4.2.1). The Responder SHOULD NOT persistently store PRK_out or application keys until the application has authenticated the Initiator. The Responder SHOULD NOT send protected application data until the application has authenticated the Initiator.",
      "ja": "message_3を処理した後、レスポンダーはPRK_outを計算し（セクション4.1.3を参照）、EDHOC_EXPORTERインターフェイスを使用してアプリケーションキーを導き出すことができます（セクション4.2.1を参照）。応答者は、アプリケーションがイニシエーターを認証するまで、PRK_OUTまたはアプリケーションキーを永続的に保存しないでください。応答者は、アプリケーションがイニシエーターを認証するまで、保護されたアプリケーションデータを送信してはなりません。"
    },
    {
      "indent": 3,
      "text": "If any processing step fails, then the Responder MUST send an EDHOC error message back as defined in Section 6, and the EDHOC session MUST be aborted.",
      "ja": "処理ステップが失敗した場合、レスポンダーはセクション6で定義されているようにEDHOCエラーメッセージを返送する必要があり、EDHOCセッションを中止する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5. EDHOC Message 4",
      "section_title": true,
      "ja": "5.5. EDHOCメッセージ4"
    },
    {
      "indent": 3,
      "text": "This section specifies message_4, which is OPTIONAL to support. Key confirmation is normally provided by sending an application message from the Responder to the Initiator protected with a key derived with the EDHOC_Exporter, e.g., using OSCORE (see Appendix A). In deployments where no protected application message is sent from the Responder to the Initiator, message_4 MUST be supported and MUST be used. Two examples of such deployments are:",
      "ja": "このセクションでは、サポートがオプションであるMessage_4を指定します。通常、主要な確認は、eDHOC_EXPORTERを使用して派生したキーで保護されたイニシエーターに応答者からアプリケーションメッセージを送信することにより提供されます。たとえば、OSCOREを使用します（付録Aを参照）。ResponderからInitiatorに保護されたアプリケーションメッセージが送信されない展開では、message_4をサポートし、使用する必要があります。このような展開の2つの例は次のとおりです。"
    },
    {
      "indent": 8,
      "text": "1. when EDHOC is only used for authentication and no application data is sent and",
      "ja": "1. Edhocが認証にのみ使用され、アプリケーションデータが送信されない場合、"
    },
    {
      "indent": 8,
      "text": "2. when application data is only sent from the Initiator to the Responder.",
      "ja": "2. アプリケーションデータがイニシエーターからレスポンダーにのみ送信される場合。"
    },
    {
      "indent": 3,
      "text": "Further considerations about when to use message_4 are provided in Sections 3.9 and 9.1.",
      "ja": "Message_4を使用する時期についてのさらなる考慮事項は、セクション3.9および9.1で提供されています。"
    },
    {
      "indent": 0,
      "text": "5.5.1. Formatting of Message 4",
      "section_title": true,
      "ja": "5.5.1. メッセージ4のフォーマット"
    },
    {
      "indent": 3,
      "text": "message_4 SHALL be a CBOR Sequence (see Appendix C.1), as defined below.",
      "ja": "Message_4は、以下に定義するように、CBORシーケンス（付録C.1を参照）でなければなりません。"
    },
    {
      "indent": 3,
      "text": "message_4 = (\n  CIPHERTEXT_4 : bstr,\n\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.5.2. Responder Composition of Message 4",
      "section_title": true,
      "ja": "5.5.2. メッセージ4のレスポンダー構成"
    },
    {
      "indent": 3,
      "text": "The Responder SHALL compose message_4 as follows:",
      "ja": "レスポンダーは、次のようにmessage_4を作成するものとします。"
    },
    {
      "indent": 6,
      "text": "* Compute a COSE_Encrypt0 as defined in Sections 5.2 and 5.3 of [RFC9052], with the EDHOC AEAD algorithm of the selected cipher suite, using the encryption key K_4, the initialization vector IV_4 (if used by the AEAD algorithm), the plaintext PLAINTEXT_4, and the following parameters as input (see Appendix C.3):",
      "ja": "* [RFC9052]のセクション5.2および5.3で定義されているようにCOSE_ENCRYPT0を計算します。暗号化キーK_4を使用して、選択した暗号スイートのEDHOC AEADアルゴリズムを使用して、初期化ベクターIV_4（AEADアルゴリズムで使用されている場合）、PLAINTEXTEXT PLAINTEXT_4、およびPLAINTEXT TEXTEXT_4、および入力としての次のパラメーター（付録C.3を参照）："
    },
    {
      "indent": 12,
      "text": "- protected = h''",
      "ja": "- 保護= h ''"
    },
    {
      "indent": 12,
      "text": "- external_aad = TH_4",
      "ja": "- external_aad = th_4"
    },
    {
      "indent": 12,
      "text": "- K_4 and IV_4 are defined in Section 4.1.2",
      "ja": "- K_4およびIV_4は、セクション4.1.2で定義されています"
    },
    {
      "indent": 12,
      "text": "- PLAINTEXT_4 = ( ? EAD_4 )",
      "ja": "- plaintext_4 =（？ead_4）"
    },
    {
      "indent": 18,
      "text": "o EAD_4 is external authorization data; see Section 3.8.",
      "ja": "o EAD_4は外部認証データです。セクション3.8を参照してください。"
    },
    {
      "indent": 10,
      "text": "CIPHERTEXT_4 is the 'ciphertext' of COSE_Encrypt0.",
      "ja": "ciphertext_4は、cose_encrypt0の「ciphertext」です。"
    },
    {
      "indent": 6,
      "text": "* Encode message_4 as a CBOR data item as specified in Section 5.5.1.",
      "ja": "* セクション5.5.1で指定されているように、cborデータ項目としてmessage_4をエンコードします。"
    },
    {
      "indent": 0,
      "text": "5.5.3. Initiator Processing of Message 4",
      "section_title": true,
      "ja": "5.5.3. メッセージ4のイニシエーター処理"
    },
    {
      "indent": 3,
      "text": "The Initiator SHALL process message_4 as follows:",
      "ja": "イニシエーターは、次のようにmessage_4を処理するものとします。"
    },
    {
      "indent": 6,
      "text": "* Decode message_4 (see Appendix C.1).",
      "ja": "* メッセージ_4をデコードします（付録C.1を参照）。"
    },
    {
      "indent": 6,
      "text": "* Retrieve the protocol state using available message correlation (e.g., the CoAP Token, the 5-tuple, or the prepended C_I; see Section 3.4.1).",
      "ja": "* 利用可能なメッセージ相関を使用してプロトコル状態を取得します（例：COAPトークン、5タプル、または準備されたC_I、セクション3.4.1を参照）。"
    },
    {
      "indent": 6,
      "text": "* Decrypt and verify the COSE_Encrypt0 as defined in Sections 5.2 and 5.3 of [RFC9052], with the EDHOC AEAD algorithm in the selected cipher suite and the parameters defined in Section 5.5.2.",
      "ja": "* [RFC9052]のセクション5.2および5.3で定義されているCOSE_ENCRYPT0を復号化および検証し、選択した暗号スイートのEDHOC AEADアルゴリズムとセクション5.5.2で定義されているパラメーターを使用します。"
    },
    {
      "indent": 6,
      "text": "* Make (if present) EAD_4 available to the application for EAD processing.",
      "ja": "* EAD処理のためにアプリケーションで使用可能な（存在する場合）ead_4を作成します。"
    },
    {
      "indent": 3,
      "text": "If any processing step fails, then the Initiator MUST send an EDHOC error message back as defined in Section 6, and the EDHOC session MUST be aborted.",
      "ja": "処理ステップが失敗した場合、イニシエーターはセクション6で定義されているようにEDHOCエラーメッセージを返送する必要があり、EDHOCセッションを中止する必要があります。"
    },
    {
      "indent": 3,
      "text": "After verifying message_4, the Initiator is assured that the Responder has calculated the key PRK_out (key confirmation) and that no other party can derive the key.",
      "ja": "message_4を確認した後、イニシエーターは、レスポンダーがキーPRK_out（キー確認）を計算し、他の当事者がキーを導き出すことができないことを保証します。"
    },
    {
      "indent": 0,
      "text": "6. Error Handling",
      "section_title": true,
      "ja": "6. エラー処理"
    },
    {
      "indent": 3,
      "text": "This section defines the format for error messages and the processing associated with the currently defined error codes. Additional error codes may be registered; see Section 10.4.",
      "ja": "このセクションでは、エラーメッセージの形式と、現在定義されているエラーコードに関連付けられた処理を定義します。追加のエラーコードが登録される場合があります。セクション10.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "Many kinds of errors can occur during EDHOC processing. As in CoAP, an error can be triggered by errors in the received message or internal errors in the receiving endpoint. Except for processing and formatting errors, it is up to the application when to send an error message. Sending error messages is essential for debugging but MAY be skipped if, for example, an EDHOC session cannot be found or due to denial-of-service reasons; see Section 9.7. Error messages in EDHOC are always fatal. After sending an error message, the sender MUST abort the EDHOC session. The receiver SHOULD treat an error message as an indication that the other party likely has aborted the EDHOC session. But since error messages might be forged, the receiver MAY try to continue the EDHOC session.",
      "ja": "EDHOC処理中に多くの種類のエラーが発生する可能性があります。COAPのように、受信したメッセージのエラーまたは受信エンドポイントの内部エラーによってエラーがトリガーされる可能性があります。エラーの処理とフォーマットを除き、エラーメッセージを送信する時期はアプリケーション次第です。エラーメッセージの送信はデバッグに不可欠ですが、たとえばEDHOCセッションが見つからない場合、またはサービス拒否の理由によりスキップされる場合があります。セクション9.7を参照してください。Edhocのエラーメッセージは常に致命的です。エラーメッセージを送信した後、送信者はEDHOCセッションを中止する必要があります。受信者は、他の当事者がEDHOCセッションを中止した可能性が高いことを示すエラーメッセージを扱う必要があります。ただし、エラーメッセージは偽造される可能性があるため、受信者はEDHOCセッションを続行しようとする場合があります。"
    },
    {
      "indent": 3,
      "text": "An EDHOC error message can be sent by either endpoint as a reply to any non-error EDHOC message. How errors at the EDHOC layer are transported depends on lower layers, which need to enable error messages to be sent and processed as intended.",
      "ja": "EDHOCエラーメッセージは、いずれかのEndPointで、誤差EDHOCメッセージへの返信として送信できます。Edhoc層のエラーが輸送される方法は下層に依存します。これにより、エラーメッセージを送信および処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "error SHALL be a CBOR Sequence (see Appendix C.1), as defined below.",
      "ja": "エラーは、以下に定義されているように、CBORシーケンスでなければなりません（付録C.1を参照）。"
    },
    {
      "indent": 3,
      "text": "error = (\n  ERR_CODE : int,\n  ERR_INFO : any,\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Figure 7: EDHOC Error Message",
      "ja": "図7：EDHOCエラーメッセージ"
    },
    {
      "indent": 3,
      "text": "where:",
      "ja": "ただし："
    },
    {
      "indent": 6,
      "text": "* ERR_CODE is an error code encoded as an integer. The value 0 is reserved for success and can only be used internally; all other values (negative or positive) indicate errors.",
      "ja": "* ERR_CODEは、整数としてエンコードされたエラーコードです。値0は成功のために予約されており、内部でのみ使用できます。他のすべての値（負または正）はエラーを示します。"
    },
    {
      "indent": 6,
      "text": "* ERR_INFO is error information. Content and encoding depend on the error code.",
      "ja": "* ERR_INFOはエラー情報です。コンテンツとエンコーディングはエラーコードによって異なります。"
    },
    {
      "indent": 3,
      "text": "The remainder of this section specifies the currently defined error codes; see Table 3. Additional error codes and corresponding error information may be specified.",
      "ja": "このセクションの残りの部分は、現在定義されているエラーコードを指定します。表3を参照してください。追加のエラーコードと対応するエラー情報が指定される場合があります。"
    },
    {
      "indent": 7,
      "text": "+==========+===============+===============================+\n| ERR_CODE | ERR_INFO Type | Description                   |\n+==========+===============+===============================+\n|        0 |               | Reserved for success          |\n+----------+---------------+-------------------------------+\n|        1 | tstr          | Unspecified error             |\n+----------+---------------+-------------------------------+\n|        2 | suites        | Wrong selected cipher suite   |\n+----------+---------------+-------------------------------+\n|        3 | true          | Unknown credential referenced |\n+----------+---------------+-------------------------------+\n|       23 |               | Reserved                      |\n+----------+---------------+-------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Table 3: EDHOC Error Codes and Error Information",
      "ja": "表3：EDHOCエラーコードとエラー情報"
    },
    {
      "indent": 0,
      "text": "6.1. Success",
      "section_title": true,
      "ja": "6.1. 成功"
    },
    {
      "indent": 3,
      "text": "Error code 0 MAY be used internally in an application to indicate success, i.e., as a standard value in case of no error, e.g., in status reporting or log files. Error code 0 MUST NOT be used as part of the EDHOC message exchange. If an endpoint receives an error message with error code 0, then it MUST abort the EDHOC session and MUST NOT send an error message.",
      "ja": "エラーコード0は、アプリケーションで内部的に使用して、成功を示す、つまり、エラーなし、たとえばステータスレポートまたはログファイルの場合の標準値として使用できます。エラーコード0は、EDHOCメッセージ交換の一部として使用してはなりません。エンドポイントがエラーコード0でエラーメッセージを受信した場合、EDHOCセッションを中止する必要があり、エラーメッセージを送信してはなりません。"
    },
    {
      "indent": 0,
      "text": "6.2. Unspecified Error",
      "section_title": true,
      "ja": "6.2. 不特定のエラー"
    },
    {
      "indent": 3,
      "text": "Error code 1 is used for errors that do not have a specific error code defined. ERR_INFO MUST be a text string containing a human-readable diagnostic message that SHOULD be written in English, for example, \"Method not supported\". The diagnostic text message is mainly intended for software engineers who during debugging need to interpret it in the context of the EDHOC specification. The diagnostic message SHOULD be provided to the calling application where it SHOULD be logged.",
      "ja": "エラーコード1は、特定のエラーコードが定義されていないエラーに使用されます。ERR_INFOは、たとえば「サポートされていない方法」など、英語で書くべき人間の読み取り可能な診断メッセージを含むテキスト文字列でなければなりません。診断テキストメッセージは、主にデバッグ中にEDHOC仕様のコンテキストでそれを解釈する必要があるソフトウェアエンジニアを対象としています。診断メッセージを呼び出しアプリケーションに提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3. Wrong Selected Cipher Suite",
      "section_title": true,
      "ja": "6.3. 間違った選択された暗号スイート"
    },
    {
      "indent": 3,
      "text": "Error code 2 MUST only be used when replying to message_1 in case the cipher suite selected by the Initiator is not supported by the Responder or if the Responder supports a cipher suite more preferred by the Initiator than the selected cipher suite; see Section 5.2.3. In this case, ERR_INFO = SUITES_R and is of type suites; see Section 5.2.1. If the Responder does not support the selected cipher suite, then SUITES_R MUST include one or more supported cipher suites. If the Responder supports a cipher suite in SUITES_I other than the selected cipher suite (independently of if the selected cipher suite is supported or not), then SUITES_R MUST include the supported cipher suite in SUITES_I, which is most preferred by the Initiator. SUITES_R MAY include a single cipher suite; in which case, it is encoded as an int. If the Responder does not support any cipher suite in SUITES_I, then it SHOULD include all its supported cipher suites in SUITES_R.",
      "ja": "エラーコード2は、イニシエーターが選択した暗号スイートがレスポンダーによってサポートされていない場合、またはレスポンダーが選択した暗号スイートよりもイニシエーターが優先する暗号スイートをサポートしている場合にのみ、メッセージ_1に応答する場合にのみ使用する必要があります。セクション5.2.3を参照してください。この場合、err_info = suites_rで、タイプスイートです。セクション5.2.1を参照してください。レスポンダーが選択した暗号スイートをサポートしていない場合、Suites_rは1つ以上のサポートされている暗号スイートを含める必要があります。レスポンダーが、選択した暗号スイート以外のスイートの暗号スイートをサポートしている場合（選択した暗号スイートがサポートされているかどうかとは独立して）、suites_rは、開始者が最も好むsuites_iにサポートされている暗号スイートを含める必要があります。Suites_rには、単一の暗号スイートが含まれる場合があります。その場合、それはintとしてエンコードされます。ResponderがSuites_iの暗号スイートをサポートしていない場合、Suites_rにサポートされているすべての暗号スイートを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "In contrast to SUITES_I, the order of the cipher suites in SUITES_R has no significance.",
      "ja": "suites_iとは対照的に、suites_rの暗号スイートの順序は重要ではありません。"
    },
    {
      "indent": 0,
      "text": "6.3.1. Cipher Suite Negotiation",
      "section_title": true,
      "ja": "6.3.1. 暗号スイート交渉"
    },
    {
      "indent": 3,
      "text": "After receiving SUITES_R, the Initiator can determine which cipher suite to select (if any) for the next EDHOC run with the Responder. The Initiator SHOULD remember which selected cipher suite to use until the next message_1 has been sent; otherwise, the Initiator and Responder will run into an infinite loop where the Initiator selects its most preferred cipher suite and the Responder sends an error with supported cipher suites.",
      "ja": "suites_rを受け取った後、イニシエーターは、レスポンダーを使用して次のedhocランに選択する（存在する場合）選択するスイートを決定できます。イニシエーターは、次のmessage_1が送信されるまで使用する選択したCipherスイートを覚えておく必要があります。それ以外の場合、イニシエーターとレスポンダーは、イニシエーターが最も好ましい暗号スイートを選択し、レスポンダーがサポートされた暗号スイートでエラーを送信する無限ループに遭遇します。"
    },
    {
      "indent": 3,
      "text": "After a completed EDHOC session, the Initiator MAY remember the selected cipher suite to use in future EDHOC sessions with this Responder. Note that if the Initiator or Responder is updated with new cipher suite policies, any cached information may be outdated.",
      "ja": "完了したEDHOCセッションの後、イニシエーターは、このレスポンダーとの将来のEDHOCセッションで使用する選択した暗号スイートを覚えているかもしれません。イニシエーターまたはレスポンダーが新しい暗号スイートポリシーで更新されている場合、キャッシュされた情報は時代遅れになる可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Note that the Initiator's list of supported cipher suites and order of preference is fixed (see Sections 5.2.1 and 5.2.2). Furthermore, the Responder SHALL only accept message_1 if the selected cipher suite is the first cipher suite in SUITES_I that the Responder also supports (see Section 5.2.3). Following this procedure ensures that the selected cipher suite is the most preferred (by the Initiator) cipher suite supported by both parties. For examples, see Section 6.3.2.",
      "ja": "サポートされている暗号スイートと優先順位のイニシエーターのリストが修正されていることに注意してください（セクション5.2.1および5.2.2を参照）。さらに、レスポンダーは、選択した暗号スイートがResponderがサポートするSuites_iの最初の暗号スイートである場合にのみメッセージ_1を受け入れなければなりません（セクション5.2.3を参照）。この手順に従って、選択した暗号スイートが、両当事者によってサポートされている（イニシエーターによって）暗号スイートが最も優先されることを保証します。たとえば、セクション6.3.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "If the selected cipher suite is not the first cipher suite that the Responder supports in SUITES_I received in message_1, then the Responder MUST abort the EDHOC session; see Section 5.2.3. If SUITES_I in message_1 is manipulated, then the integrity verification of message_2 containing the transcript hash TH_2 will fail and the Initiator will abort the EDHOC session.",
      "ja": "選択した暗号スイートが、suiteS_iで応答者がサポートする最初の暗号スイートではない場合、レスポンダーはEDHOCセッションを中止する必要があります。セクション5.2.3を参照してください。Message_1のsuites_iが操作されている場合、転写産物のハッシュTh_2を含むmessage_2の整合性検証が故障し、イニシエーターはEdhocセッションを中止します。"
    },
    {
      "indent": 0,
      "text": "6.3.2. Examples",
      "section_title": true,
      "ja": "6.3.2. 例"
    },
    {
      "indent": 3,
      "text": "Assume that the Initiator supports the five cipher suites, 5, 6, 7, 8, and 9, in decreasing order of preference. Figures 8 and 9 show two examples of how the Initiator can format SUITES_I and how SUITES_R is used by Responders to give the Initiator information about the cipher suites that the Responder supports.",
      "ja": "イニシエーターは、選好の順序を減らすために、5、6、7、8、および9の5つの暗号スイートをサポートしていると仮定します。図8と9は、イニシエーターがどのようにsuites_iをフォーマットできるか、およびレスポンダーが応答者がどのように使用するかについての2つの例を示しています。"
    },
    {
      "indent": 3,
      "text": "In Example 1 (Figure 8), the Responder supports cipher suite 6 but not the initially selected cipher suite 5. The Responder rejects the first message_1 with an error indicating support for suite 6 in SUITES_R. The Initiator also supports suite 6 and therefore selects suite 6 in the second message_1. The Initiator prepends in SUITES_I the selected suite 6 with the more preferred suites, in this case suite 5, to mitigate a potential attack on the cipher suite negotiation.",
      "ja": "例1（図8）では、レスポンダーは暗号スイート6をサポートしますが、最初に選択された暗号スイート5はサポートしていません。イニシエーターもスイート6をサポートするため、2番目のMessage_1でSuite 6を選択します。イニシエーターは、suites_iの選択されたスイート6をより優先スイート（この場合はスイート5で、Cipher Suiteの交渉に対する潜在的な攻撃を緩和します。"
    },
    {
      "indent": 3,
      "text": "Initiator                                                   Responder\n|              METHOD, SUITES_I = 5, G_X, C_I, EAD_1                |\n+------------------------------------------------------------------>|\n|                             message_1                             |\n|                                                                   |\n|                   ERR_CODE = 2, SUITES_R = 6                      |\n|<------------------------------------------------------------------+\n|                               error                               |\n|                                                                   |\n|             METHOD, SUITES_I = [5, 6], G_X, C_I, EAD_1            |\n+------------------------------------------------------------------>|\n|                             message_1                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 8: Cipher Suite Negotiation Example 1",
      "ja": "図8：暗号スイート交渉の例1"
    },
    {
      "indent": 3,
      "text": "In Example 2 (Figure 9), the Responder supports cipher suites 8 and 9 but not the more preferred (by the Initiator) cipher suites 5, 6 or 7. To illustrate the negotiation mechanics, we let the Initiator first make a guess that the Responder supports suite 6 but not suite 5. Since the Responder supports neither 5 nor 6, it rejects the first message_1 with an error indicating support for suites 8 and 9 in SUITES_R (in any order). The Initiator also supports suites 8 and 9, and prefers suite 8, so it selects suite 8 in the second message_1. The Initiator prepends in SUITES_I the selected suite 8 with the more preferred suites in order of preference, in this case, suites 5, 6 and 7, to mitigate a potential attack on the cipher suite negotiation.",
      "ja": "例2（図9）では、レスポンダーは暗号スイート8および9をサポートしていますが、（イニシエーターによる）暗号スイート5、6、または7をサポートしていません。レスポンダーはスイート6をサポートしますが、スイート5はサポートしていません。応答者は5も6もサポートしていないため、スイート8と9のサポートを示すエラーを拒否します。イニシエーターはスイート8と9もサポートし、Suite 8を好むため、2番目のMessage_1でSuite 8を選択します。イニシエーターは、Suites_iの選択されたスイート8を、より優先スイート、この場合は5、6、および7スイートを備えており、暗号スイートの交渉に対する潜在的な攻撃を緩和します。"
    },
    {
      "indent": 18,
      "text": "Note 1. If the Responder had supported suite 5, then the first message_1 would not have been accepted either, since the Responder observes that suite 5 is more preferred by the Initiator than the selected suite 6. In that case, the Responder would have included suite 5 in SUITES_R of the response, and it would then have become the selected and only suite in the second message_1.",
      "ja": "注1.レスポンダーがSuite 5をサポートしていた場合、Responderは選択したスイート6よりもスイート5がイニシエーターよりも優先されることを観察しているため、最初のメッセージ_1も受け入れられませんでした。応答のsuites_rのスイート5、そしてそれは2番目のmessage_1で選択された唯一のスイートになりました。"
    },
    {
      "indent": 18,
      "text": "Note 2. For each message_1, the Initiator MUST generate a new ephemeral ECDH key pair matching the selected cipher suite.",
      "ja": "注2.各message_1について、イニシエーターは、選択した暗号スイートに一致する新しいはかないECDHキーペアを生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "Initiator                                                   Responder\n|            METHOD, SUITES_I = [5, 6], G_X, C_I, EAD_1             |\n+------------------------------------------------------------------>|\n|                             message_1                             |\n|                                                                   |\n|                  ERR_CODE = 2, SUITES_R = [9, 8]                  |\n|<------------------------------------------------------------------+\n|                               error                               |\n|                                                                   |\n|           METHOD, SUITES_I = [5, 6, 7, 8], G_X, C_I, EAD_1        |\n+------------------------------------------------------------------>|\n|                             message_1                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 9: Cipher Suite Negotiation Example 2",
      "ja": "図9：暗号スイート交渉の例2"
    },
    {
      "indent": 0,
      "text": "6.4. Unknown Credential Referenced",
      "section_title": true,
      "ja": "6.4. 不明な資格情報が参照されています"
    },
    {
      "indent": 3,
      "text": "Error code 3 is used for errors due to a received credential identifier (ID_CRED_R in message_2 or ID_CRED_I message_3) containing a reference to a credential that the receiving endpoint does not have access to. The intent with this error code is that the endpoint who sent the credential identifier should, for the next EDHOC session, try another credential identifier supported according to the application profile.",
      "ja": "エラーコード3は、受信エンドポイントがアクセスできないという資格情報への参照を含む、受信された資格情報識別子（メッセージ_2またはID_CRED_Iメッセージ_3のID_CRED_R）に起因するエラーに使用されます。このエラーコードの意図は、クレデンシャル識別子を送信したエンドポイントが、次のEDHOCセッションで、アプリケーションプロファイルに従ってサポートされている別の資格情報識別子を試す必要があることです。"
    },
    {
      "indent": 3,
      "text": "For example, an application profile could list x5t and x5chain as supported credential identifiers and state that x5t should be used if it can be assumed that the X.509 certificate is available at the receiving side. This error code thus enables the certificate chain to be sent only when needed, bearing in mind that error messages are not protected so an adversary can try to cause unnecessary, large credential identifiers.",
      "ja": "たとえば、アプリケーションプロファイルは、サポートされている資格情報識別子としてX5TおよびX5Chainをリストし、X.509証明書が受信側で利用可能であると想定できる場合はX5Tを使用する必要があると述べることができます。したがって、このエラーコードは、証明書チェーンを必要な場合にのみ送信できるようにします。エラーメッセージは保護されていないため、敵が不必要で大きな資格情報識別子を引き起こそうとすることができます。"
    },
    {
      "indent": 3,
      "text": "For the error code 3, the error information SHALL be the CBOR simple value true (0xf5). Error code 3 MUST NOT be used when the received credential identifier type is not supported.",
      "ja": "エラーコード3の場合、エラー情報はCbor Simple値True（0xf5）でなければなりません。受信した資格情報識別子タイプがサポートされていない場合、エラーコード3を使用しないでください。"
    },
    {
      "indent": 0,
      "text": "7. EDHOC Message Deduplication",
      "section_title": true,
      "ja": "7. EDHOCメッセージ重複排除"
    },
    {
      "indent": 3,
      "text": "By default, EDHOC assumes that message duplication is handled by the transport (which is exemplified by CoAP in this section); see Appendix A.2.",
      "ja": "デフォルトでは、Edhocは、メッセージの複製が輸送によって処理されると想定しています（このセクションのCOAPによって例示されています）。付録A.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Deduplication of CoAP messages is described in Section 4.5 of [RFC7252]. This handles the case when the same Confirmable (CON) message is received multiple times due to missing acknowledgment on the CoAP messaging layer. The recommended processing in [RFC7252] is that the duplicate message is acknowledged, but the received message is only processed once by the CoAP stack.",
      "ja": "COAPメッセージの重複排除は、[RFC7252]のセクション4.5で説明されています。これにより、COAPメッセージングレイヤーの確認が欠落しているため、同じ確認可能な（CON）メッセージが複数回受信された場合にケースを処理します。[RFC7252]で推奨される処理は、複製メッセージが確認されていることですが、受信したメッセージはCoAPスタックによって1回のみ処理されます。"
    },
    {
      "indent": 3,
      "text": "Message deduplication is resource demanding and therefore not supported in all CoAP implementations. Since EDHOC is targeting constrained environments, it is desirable that EDHOC can optionally support transport layers that do not handle message duplication. Special care is needed to avoid issues with duplicate messages; see Section 5.1.",
      "ja": "メッセージの重複排除はリソースを要求するため、すべてのCOAP実装でサポートされていません。EDHOCは制約された環境をターゲットにしているため、EDHOCがメッセージの複製を処理しない輸送層をオプションでサポートできることが望ましいです。複製メッセージの問題を回避するには、特別な注意が必要です。セクション5.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "The guiding principle here is similar to the deduplication processing on the CoAP messaging layer, i.e., a received duplicate EDHOC message SHALL NOT result in another instance of the next EDHOC message. The result MAY be that a duplicate next EDHOC message is sent, provided it is still relevant with respect to the current protocol state. In any case, the received message MUST NOT be processed more than once in the same EDHOC session. This is called \"EDHOC message deduplication\".",
      "ja": "ここでの指針は、COAPメッセージングレイヤーの重複排除処理に似ています。つまり、受信した重複したEDHOCメッセージは、次のEDHOCメッセージの別のインスタンスをもたらさないものではありません。その結果、現在のプロトコル状態に関して依然として関連性がある場合、次のEDHOCメッセージが送信される可能性があります。いずれにせよ、受信したメッセージを同じEDHOCセッションで複数回処理してはなりません。これは「Edhoc Message Deduplication」と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "An EDHOC implementation MAY store the previously sent EDHOC message to be able to resend it.",
      "ja": "EDHOCの実装は、以前に送信されたEDHOCメッセージを保存して、再送信できるようにする場合があります。"
    },
    {
      "indent": 3,
      "text": "In principle, if the EDHOC implementation would deterministically regenerate the identical EDHOC message previously sent, it would be possible to instead store the protocol state to be able to recreate and resend the previously sent EDHOC message. However, even if the protocol state is fixed, the message generation may introduce differences that compromise security. For example, in the generation of message_3, if I is performing a (non-deterministic) ECDSA signature (say, method 0 or 1 and cipher suite 2 or 3), then PLAINTEXT_3 is randomized, but K_3 and IV_3 are the same, leading to a key and nonce reuse.",
      "ja": "原則として、EDHOCの実装が以前に送信された同一のEDHOCメッセージを決定的に再生する場合、代わりにプロトコル状態を保存して、以前に送信されたEDHOCメッセージを再作成および再送信できるようにすることができます。ただし、プロトコル状態が修正されたとしても、メッセージ生成はセキュリティを損なう違いを導入する場合があります。たとえば、Message_3の生成では、（非決定的）ECDSA署名（たとえば、方法0または1および暗号スイート2または3）を実行している場合、Plantext_3はランダム化されますが、K_3とIV_3は同じであり、キーとノンセの再利用に。"
    },
    {
      "indent": 3,
      "text": "The EDHOC implementation MUST NOT store the previous protocol state and regenerate an EDHOC message if there is a risk that the same key and IV are used for two (or more) distinct messages.",
      "ja": "EDHOCの実装は、以前のプロトコル状態を保存して、2つ（またはそれ以上）の異なるメッセージに同じキーとIVが使用されるというリスクがある場合、EDHOCメッセージを再生してはなりません。"
    },
    {
      "indent": 3,
      "text": "The previous message or protocol state MUST NOT be kept longer than what is required for retransmission, for example, in the case of CoAP transport, no longer than the EXCHANGE_LIFETIME (see Section 4.8.2 of [RFC7252]).",
      "ja": "以前のメッセージまたはプロトコル状態は、たとえばCoap輸送の場合、Exchange_lifetime以外の場合、再送信に必要なものよりも長く保持する必要があります（[RFC7252]のセクション4.8.2を参照）。"
    },
    {
      "indent": 0,
      "text": "8. Compliance Requirements",
      "section_title": true,
      "ja": "8. コンプライアンス要件"
    },
    {
      "indent": 3,
      "text": "In the absence of an application profile specifying otherwise:",
      "ja": "別の方法で指定するアプリケーションプロファイルがない場合："
    },
    {
      "indent": 6,
      "text": "* An implementation MAY support only an Initiator or only a Responder.",
      "ja": "* 実装は、イニシエーターまたはレスポンダーのみをサポートする場合があります。"
    },
    {
      "indent": 6,
      "text": "* An implementation MAY support only a single method. None of the methods are mandatory to implement.",
      "ja": "* 実装は、単一の方法のみをサポートする場合があります。実装するために必須のメソッドはありません。"
    },
    {
      "indent": 6,
      "text": "* Implementations MUST support 'kid' parameters. None of the other COSE header parameters are mandatory to implement.",
      "ja": "* 実装は「KID」パラメーターをサポートする必要があります。他のCOSEヘッダーパラメーターはどれも実装する必要はありません。"
    },
    {
      "indent": 6,
      "text": "* An implementation MAY support only a single credential type (CCS, CWT, X.509, or C509). None of the credential types are mandatory to implement.",
      "ja": "* 実装は、単一の資格情報のタイプ（CCS、CWT、X.509、またはC509）のみをサポートする場合があります。実装するために必須の資格情報はありません。"
    },
    {
      "indent": 6,
      "text": "* Implementations MUST support the EDHOC_Exporter.",
      "ja": "* 実装はEDHOC_EXPORTERをサポートする必要があります。"
    },
    {
      "indent": 6,
      "text": "* Implementations MAY support message_4. Error codes (ERR_CODE) 1 and 2 MUST be supported.",
      "ja": "* 実装はmessage_4をサポートする場合があります。エラーコード（ERR_CODE）1および2をサポートする必要があります。"
    },
    {
      "indent": 6,
      "text": "* Implementations MUST support EAD.",
      "ja": "* 実装はEADをサポートする必要があります。"
    },
    {
      "indent": 6,
      "text": "* Implementations MUST support cipher suites 2 and 3. Cipher suites 2 (AES-CCM-16-64-128, SHA-256, 8, P-256, ES256, AES-CCM-16-64-128, SHA-256) and 3 (AES-CCM-16-128-128, SHA-256, 16, P-256, ES256, AES-CCM-16-64-128, SHA-256) only differ in the size of the MAC length, so supporting one or both of these is not significantly different. Implementations only need to implement the algorithms needed for their supported methods.",
      "ja": "* 実装は、暗号スイート2および3をサポートする必要があります。暗号スイート2（AES-CCM-16-64-128、SHA-256、8、P-256、ES256、AES-CCM-16-64-128、SHA-256）およびSHA-256）および3（AES-CCM-16-128-128、SHA-256、16、P-256、ES256、AES-CCM-16-64-128、SHA-256）これらの1つまたは両方は、有意な差はありません。実装は、サポートされている方法に必要なアルゴリズムを実装するだけです。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "9.1. Security Properties",
      "section_title": true,
      "ja": "9.1. セキュリティプロパティ"
    },
    {
      "indent": 3,
      "text": "EDHOC has similar security properties as can be expected from the theoretical SIGMA-I protocol [SIGMA] and the Noise XX pattern [Noise], which are similar to methods 0 and 3, respectively. Proven security properties are detailed in the security analysis publications referenced at the end of this section.",
      "ja": "EDHOCには、それぞれ方法0と3に類似した、理論的なSigma-Iプロトコル[Sigma]およびノイズXXパターン[ノイズ]から予想されるように、同様のセキュリティプロパティがあります。実証済みのセキュリティプロパティは、このセクションの最後に参照されているセキュリティ分析出版物で詳しく説明されています。"
    },
    {
      "indent": 3,
      "text": "Using the terminology from [SIGMA], EDHOC provides forward secrecy, mutual authentication with aliveness, consistency, and peer awareness. As described in [SIGMA], message_3 provides peer awareness to the Responder, while message_4 provides peer awareness to the Initiator. By including the authentication credentials in the transcript hash, EDHOC protects against an identity misbinding attack like the Duplicate Signature Key Selection (DSKS) that the MAC-then-Sign variant of SIGMA-I is otherwise vulnerable to.",
      "ja": "[Sigma]の用語を使用して、Edhocは前向きな秘密、相互認証を提供し、Alivension、一貫性、およびピア認識を提供します。[Sigma]で説明されているように、Message_3はResponderにピア認識を提供し、Message_4はイニシエーターにピア認識を提供します。トランスクリプトハッシュに認証資格情報を含めることにより、Edhocは、Sigma-IのMac-Then-Signバリアントが脆弱である重複署名キー選択（DSK）のようなアイデンティティの結合攻撃から保護します。"
    },
    {
      "indent": 3,
      "text": "As described in [SIGMA], different levels of identity protection are provided to the Initiator and Responder. EDHOC provides identity protection of the Initiator against active attacks and identity protection of the Responder against passive attacks. An active attacker can get the credential identifier of the Responder by eavesdropping on the destination address used for transporting message_1 and then sending its own message_1 to the same address. The roles should be assigned to protect the most sensitive identity/ identifier, typically that which is not possible to infer from routing information in the lower layers.",
      "ja": "[sigma]で説明されているように、さまざまなレベルのアイデンティティ保護がイニシエーターとレスポンダーに提供されます。EDHOCは、積極的な攻撃に対するイニシエーターのアイデンティティ保護と、パッシブ攻撃に対する応答者のアイデンティティ保護を提供します。アクティブな攻撃者は、Message_1の輸送に使用される宛先アドレスを盗聴し、同じアドレスに独自のMessage_1を送信するために、宛先アドレスを盗聴することにより、応答者の資格情報識別子を取得できます。役割は、最も機密性の高いアイデンティティ/識別子を保護するために割り当てられる必要があります。通常、下位層のルーティング情報から推測できないものです。"
    },
    {
      "indent": 3,
      "text": "EDHOC messages might change in transit due to a noisy channel or through modification by an attacker. Changes in message_1 and message_2 (except Signature_or_MAC_2 when the signature scheme is not strongly unforgeable) are detected when verifying Signature_or_MAC_2. Changes to not strongly unforgeable Signature_or_MAC_2 and message_3 are detected when verifying CIPHERTEXT_3. Changes to message_4 are detected when verifying CIPHERTEXT_4.",
      "ja": "EDHOCメッセージは、騒々しいチャネルまたは攻撃者による変更により、輸送が変化する可能性があります。signature_or_mac_2を検証するときに、message_1およびmessage_2（signature_or_mac_2を除く）が検出されます。ciphertext_3を検証するときに、強く容認できないsignature_or_mac_2およびmessage_3への変更が検出されます。message_4の変更は、ciphertext_4を確認するときに検出されます。"
    },
    {
      "indent": 3,
      "text": "Compared to [SIGMA], EDHOC adds an explicit method type and expands the message authentication coverage to additional elements such as algorithms, external authorization data, and previous plaintext messages. This protects against an attacker replaying messages or injecting messages from another EDHOC session.",
      "ja": "[Sigma]と比較して、Edhocは明示的なメソッドタイプを追加し、メッセージ認証カバレッジをアルゴリズム、外部認証データ、以前のプレーンテキストメッセージなどの追加要素に拡張します。これにより、攻撃者がメッセージを再生するか、別のEDHOCセッションからメッセージを挿入することから保護します。"
    },
    {
      "indent": 3,
      "text": "EDHOC also adds the selection of connection identifiers and downgrade-protected negotiation of cryptographic parameters, i.e., an attacker cannot affect the negotiated parameters. A single session of EDHOC does not include negotiation of cipher suites, but it enables the Responder to verify that the selected cipher suite is the most preferred cipher suite by the Initiator that is supported by both the Initiator and Responder and to abort the EDHOC session if not.",
      "ja": "Edhocは、接続識別子の選択と暗号化パラメーターのダウングレード保護交渉も追加します。つまり、攻撃者は交渉されたパラメーターに影響を与えることができません。EDHOCの単一セッションには、暗号スイートの交渉は含まれませんが、選択した暗号スイートがイニシエーターとレスポンダーの両方でサポートされているイニシエーターによって最も優先される暗号スイートであることをレスポンダーが確認し、EDHOCセッションを中止することができることを確認できます。ない。"
    },
    {
      "indent": 3,
      "text": "As required by [RFC7258], IETF protocols need to mitigate pervasive monitoring when possible. Therefore, EDHOC only supports methods with ephemeral Diffie-Hellman and provides a key update function (see Appendix H) for lightweight application protocol rekeying. Either of these provides forward secrecy, in the sense that compromise of the private authentication keys does not compromise past session keys (PRK_out) and compromise of a session key does not compromise past session keys. Frequently re-running EDHOC with ephemeral Diffie-Hellman forces attackers to perform dynamic key exfiltration where the attacker must have continuous interactions with the collaborator, which is a significant sustained attack.",
      "ja": "[RFC7258]で要求されているように、IETFプロトコルは、可能であれば広範なモニタリングを緩和する必要があります。したがって、EDHOCは、短命のDiffie-Hellmanを使用した方法のみをサポートし、軽量アプリケーションプロトコルの再キーイングの重要な更新関数（付録Hを参照）を提供します。これらのいずれかは、プライベート認証キーの妥協が過去のセッションキー（PRK_OUT）を侵害しないという意味で、前向きな秘密を提供し、セッションキーの妥協は過去のセッションキーを妥協しません。EDHOCは、EDHOCを短命のDiffie-Hellmanが攻撃者を強制的に再実行し、攻撃者が協力者と継続的な相互作用を持たなければならない動的な重要な抽出を実行します。これは、重要な持続的な攻撃です。"
    },
    {
      "indent": 3,
      "text": "To limit the effect of breaches, it is important to limit the use of symmetric group keys for bootstrapping. Therefore, EDHOC strives to make the additional cost of using raw public keys and self-signed certificates as small as possible. Raw public keys and self-signed certificates are not a replacement for a public key infrastructure but SHOULD be used instead of symmetric group keys for bootstrapping.",
      "ja": "違反の効果を制限するには、ブートストラップに対称的なグループキーの使用を制限することが重要です。したがって、Edhocは、生の公開キーと自己署名証明書を可能な限り小さい追加コストを作成するよう努めています。生のパブリックキーと自己署名証明書は、公開キーインフラストラクチャの代替品ではありませんが、ブートストラップ用の対称グループキーの代わりに使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Compromise of the long-term keys (private signature or static DH keys) does not compromise the security of completed EDHOC sessions. Compromising the private authentication keys of one party lets an active attacker impersonate that compromised party in EDHOC sessions with other parties but does not let the attacker impersonate other parties in EDHOC sessions with the compromised party. Compromise of the long-term keys does not enable a passive attacker to compromise future session keys (PRK_out). Compromise of the HKDF input parameters (ECDH shared secret) leads to compromise of all session keys derived from that compromised shared secret. Compromise of one session key does not compromise other session keys. Compromise of PRK_out leads to compromise of all keying material derived with the EDHOC_Exporter.",
      "ja": "長期キー（プライベート署名または静的DHキー）の妥協は、完了したEDHOCセッションのセキュリティを損なうものではありません。一方の当事者のプライベート認証キーを妥協することで、アクティブな攻撃者は、他の政党とのエドホックセッションで侵害された当事者になりすますが、攻撃者が侵害された当事者とのエドホックセッションで他の政党になりすませないようにすることができます。長期キーの妥協は、パッシブ攻撃者が将来のセッションキー（PRK_OUT）を妥協することを可能にしません。HKDF入力パラメーターの妥協（ECDH共有秘密）は、その妥協した共有秘密から派生したすべてのセッションキーの妥協につながります。1つのセッションキーの妥協は、他のセッションキーを妥協しません。PRK_OUTの妥協は、EDHOC_EXPORTERに由来するすべてのキーイング素材の妥協につながります。"
    },
    {
      "indent": 3,
      "text": "Based on the cryptographic algorithm requirements (Section 9.3), EDHOC provides a minimum of 64-bit security against online brute force attacks and a minimum of 128-bit security against offline brute force attacks. To break 64-bit security against online brute force, an attacker would on average have to send 4.3 billion messages per second for 68 years, which is infeasible in constrained IoT radio technologies. A forgery against a 64-bit MAC in EDHOC breaks the security of all future application data, while a forgery against a 64-bit MAC in the subsequent application protocol (e.g., OSCORE [RFC8613]) typically only breaks the security of the data in the forged packet.",
      "ja": "暗号化アルゴリズムの要件（セクション9.3）に基づいて、EDHOCは、オンラインブルートフォース攻撃に対して最低64ビットのセキュリティと、オフラインブルートフォース攻撃に対する最低128ビットセキュリティを提供します。オンラインブルートフォースに対して64ビットのセキュリティを破るには、攻撃者は平均して68年間あたり43億メッセージを送信する必要があります。これは、制約付きのIoT無線技術では実行不可能です。Edhocの64ビットMACに対する偽造は、すべての将来のアプリケーションデータのセキュリティを破りますが、その後のアプリケーションプロトコルの64ビットMACに対する偽造（例：OSCORE [RFC8613]）は通常、データのセキュリティを破るだけです。鍛造パケット。"
    },
    {
      "indent": 3,
      "text": "As the EDHOC session is aborted when verification fails, the security against online attacks is given by the sum of the strength of the verified signatures and MACs (including MAC in AEAD). As an example, if EDHOC is used with method 3, cipher suite 2, and message_4, the Responder is authenticated with 128-bit security against online attacks (the sum of the 64-bit MACs in message_2 and message_4). The same principle applies for MACs in an application protocol keyed by EDHOC as long as EDHOC is re-run when verification of the first MACs in the application protocol fails. As an example, if EDHOC with method 3 and cipher suite 2 is used as in Figure 2 of [EDHOC-CoAP-OSCORE], 128-bit mutual authentication against online attacks can be achieved after completion of the first OSCORE request and response.",
      "ja": "検証が失敗するとEDHOCセッションが中止されると、オンライン攻撃に対するセキュリティは、検証された署名とMac（AEADのMacを含む）の強度の合計によって与えられます。例として、EDHOCがメソッド3、Cipher Suite 2、およびMessage_4で使用されている場合、レスポンダーはオンライン攻撃に対して128ビットセキュリティで認証されます（Message_2およびMessage_4の64ビットMacの合計）。アプリケーションプロトコルの最初のMacの検証が失敗すると、EDHOCが再実行される限り、EDHOCがキー化したアプリケーションプロトコルのMACに同じ原則が適用されます。例として、[Edhoc-Coap-Oscore]の図2とCipher Suite 2のEDHOCが使用されている場合、オンライン攻撃に対する128ビットの相互認証は、最初のOSCOREリクエストと応答の完了後に達成できます。"
    },
    {
      "indent": 3,
      "text": "After sending message_3, the Initiator is assured that no other party than the Responder can compute the key PRK_out. While the Initiator can securely send protected application data, the Initiator SHOULD NOT persistently store the keying material PRK_out until the Initiator has verified message_4 or a message protected with a derived application key, such as an OSCORE message, from the Responder. After verifying message_3, the Responder is assured that an honest Initiator has computed the key PRK_out. The Responder can securely derive and store the keying material PRK_out and send protected application data.",
      "ja": "Message_3を送信した後、イニシエーターは、レスポンダー以外のパーティがキーPRK_outを計算できないことを保証します。イニシエーターは保護されたアプリケーションデータを安全に送信できますが、イニシエーターは、イニシエーターがメッセージ_4または派生したアプリケーションキー（オスコアメッセージなど）で保護されているメッセージがレスコンダーから保護されているまでキーイングマテリアルPRK_outを永続的に保存する必要はありません。Message_3を確認した後、Responderは、正直なイニシエーターがキーPRK_OUTを計算したことを保証されます。レスポンダーは、キーイング材料PRK_OUTを安全に導き出して保存し、保護されたアプリケーションデータを送信できます。"
    },
    {
      "indent": 3,
      "text": "External authorization data sent in message_1 (EAD_1) or message_2 (EAD_2) should be considered unprotected by EDHOC; see Section 9.5. EAD_2 is encrypted, but the Responder has not yet authenticated the Initiator and the encryption does not provide confidentiality against active attacks.",
      "ja": "Message_1（EAD_1）またはMessage_2（EAD_2）で送信された外部認証データは、EDHOCによって保護されていないと見なされる必要があります。セクション9.5を参照してください。EAD_2は暗号化されていますが、レスポンダーはまだイニシエーターを認証しておらず、暗号化はアクティブな攻撃に対する機密性を提供しません。"
    },
    {
      "indent": 3,
      "text": "External authorization data sent in message_3 (EAD_3) or message_4 (EAD_4) is protected between the Initiator and Responder by the protocol, but note that EAD fields may be used by the application before the message verification is completed; see Section 3.8. Designing a secure mechanism that uses EAD is not necessarily straightforward. This document only provides the EAD transport mechanism, but the problem of agreeing on the surrounding context and the meaning of the information passed to and from the application remains. Any new uses of EAD should be subject to careful review.",
      "ja": "Message_3（EAD_3）またはMessage_4（EAD_4）で送信された外部認証データは、プロトコルによってイニシエーターとレスポンダーの間で保護されていますが、メッセージの確認が完了する前にアプリケーションでEADフィールドを使用できることに注意してください。セクション3.8を参照してください。EADを使用する安全なメカニズムを設計することは、必ずしも簡単ではありません。このドキュメントは、EAD輸送メカニズムのみを提供しますが、周囲のコンテキストとアプリケーションとの間に渡される情報の意味に同意する問題は残ります。EADの新しい使用は、慎重にレビューする必要があります。"
    },
    {
      "indent": 3,
      "text": "Key Compromise Impersonation (KCI):",
      "ja": "重要な妥協のなりすまし（KCI）："
    },
    {
      "indent": 12,
      "text": "In EDHOC authenticated with signature keys, EDHOC provides KCI protection against an attacker having access to the long-term key or the ephemeral secret key. With static Diffie-Hellman key authentication, KCI protection would be provided against an attacker having access to the long-term Diffie-Hellman key but not to an attacker having access to the ephemeral secret key. Note that the term KCI has typically been used for compromise of long-term keys and that an attacker with access to the ephemeral secret key can only attack that specific EDHOC session.",
      "ja": "署名キーで認証されたEDHOCでは、EDHOCは、長期キーまたははかない秘密鍵にアクセスできる攻撃者に対するKCI保護を提供します。静的diffie-hellmanキー認証により、KCI保護は、攻撃者が長期的なDiffie-Hellmanキーにアクセスするが、はかない秘密鍵にアクセスできる攻撃者にはアクセスできない。KCIという用語は通常、長期キーの妥協に使用されており、はかない秘密の鍵にアクセスできる攻撃者は、その特定のEDHOCセッションのみを攻撃できることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Repudiation:",
      "ja": "否認："
    },
    {
      "indent": 12,
      "text": "If an endpoint authenticates with a signature, the other endpoint can prove that the endpoint performed a run of the protocol by presenting the data being signed as well as the signature itself. With static Diffie-Hellman key authentication, the authenticating endpoint can deny having participated in the protocol.",
      "ja": "エンドポイントが署名で認証されている場合、もう一方のエンドポイントは、署名されているデータと署名自体を提示することにより、エンドポイントがプロトコルの実行を実行したことを証明できます。静的diffie-hellmanキー認証により、認証エンドポイントはプロトコルに参加したことを否定できます。"
    },
    {
      "indent": 3,
      "text": "Earlier versions of EDHOC have been formally analyzed [Bruni18] [Norrman20] [CottierPointcheval22] [Jacomme23] [GuentherIlunga22], and the specification has been updated based on the analysis.",
      "ja": "EDHOCの以前のバージョンは、[bruni18] [norrman20] [cottierpointcheval22] [jacomme23] [guentherilunga22] [bruni18] [norrman20] [cottierpointcheval22] [guentherilunga22] [bruni18] [norrman20] [cothierpointcheval22] [guentherilunga22]を分析しています。"
    },
    {
      "indent": 0,
      "text": "9.2. Cryptographic Considerations",
      "section_title": true,
      "ja": "9.2. 暗号化の考慮事項"
    },
    {
      "indent": 3,
      "text": "The SIGMA protocol requires that the encryption of message_3 provides confidentiality against active attackers and EDHOC message_4 relies on the use of authenticated encryption. Hence, the message authenticating functionality of the authenticated encryption in EDHOC is critical, i.e., authenticated encryption MUST NOT be replaced by plain encryption only, even if authentication is provided at another level or through a different mechanism.",
      "ja": "Sigmaプロトコルでは、Message_3の暗号化がアクティブな攻撃者に対して機密性を提供し、EDHOC Message_4が認証された暗号化の使用に依存することが必要です。したがって、EDHOCでの認証された暗号化の認証機能を認証するメッセージは重要です。つまり、認証された暗号化が別のレベルまたは別のメカニズムを介して提供されたとしても、明確な暗号化のみに置き換えてはなりません。"
    },
    {
      "indent": 3,
      "text": "To reduce message overhead, EDHOC does not use explicit nonces and instead relies on the ephemeral public keys to provide randomness to each EDHOC session. A good amount of randomness is important for the key generation to provide liveness and to protect against interleaving attacks. For this reason, the ephemeral keys MUST NOT be used in more than one EDHOC message, and both parties SHALL generate fresh, random ephemeral key pairs. Note that an ephemeral key may be used to calculate several ECDH shared secrets. When static Diffie-Hellman authentication is used, the same ephemeral key is used in both ephemeral-ephemeral and ephemeral-static ECDH.",
      "ja": "メッセージオーバーヘッドを削減するために、Edhocは明示的なノンセスを使用せず、代わりに各EDHOCセッションにランダム性を提供するための短命のパブリックキーに依存しています。重要な生成が活気を提供し、インターリーブ攻撃から保護するためには、かなりの量のランダム性が重要です。このため、一時的なキーを複数のEDHOCメッセージで使用する必要はありません。両当事者は、新鮮でランダムな短命キーペアを生成するものとします。短命キーを使用して、いくつかのECDH共有秘密を計算することができることに注意してください。静的diffie-hellman認証を使用すると、同じはかない父とはかない胸部の両方で同じ一時的なキーが使用されます。"
    },
    {
      "indent": 3,
      "text": "As discussed in [SIGMA], the encryption of message_2 only needs to protect against a passive attacker since active attackers can always get the Responder's identity by sending their own message_1. EDHOC uses the EDHOC_Expand function (typically HKDF-Expand) as a binary additive stream cipher that is proven secure as long as the expand function is a Pseudorandom Function (PRF). HKDF-Expand is not often used as a stream cipher as it is slow on long messages, and most applications require both confidentiality with indistinguishability under adaptive chosen ciphertext attack (IND-CCA2) as well as integrity protection. For the encryption of message_2, any speed difference is negligible, IND-CCA2 does not increase security, and integrity is provided by the inner MAC (and signature depending on method).",
      "ja": "[Sigma]で説明したように、Message_2の暗号化は、アクティブな攻撃者が自分のmessage_1を送信することで常にレスポンダーの身元を取得できるため、パッシブ攻撃者から保護するだけです。EDHOCは、拡張関数が擬似ランダム関数（PRF）である限り安全であることが証明されているバイナリ添加剤ストリーム暗号としてEDHOC_EXPAND関数（通常HKDF-Expand）を使用します。HKDF-Expandは、長いメッセージで遅いため、ストリーム暗号として使用されることはあまりありません。ほとんどのアプリケーションは、適応選択した暗号文攻撃（IND-CCA2）の下で区別されない機密性の両方を必要とし、整合性保護が必要です。Message_2の暗号化の場合、速度の差はごくわずかであり、Ind-CCA2はセキュリティを増加させず、整合性は内部MAC（およびメソッドに応じて署名）によって提供されます。"
    },
    {
      "indent": 3,
      "text": "Requirements for how to securely generate, validate, and process the public keys depend on the elliptic curve. For X25519 and X448, the requirements are defined in [RFC7748]. For X25519 and X448, the check for all-zero output as specified in Section 6 of [RFC7748] MUST be done. For secp256r1, secp384r1, and secp521r1, the requirements are defined in Section 5 of [SP-800-56A]. For secp256r1, secp384r1, and secp521r1, at least partial public key validation MUST be done.",
      "ja": "パブリックキーを安全に生成、検証、および処理する方法の要件は、楕円曲線に依存します。X25519およびX448の場合、要件は[RFC7748]で定義されています。X25519およびX448の場合、[RFC7748]のセクション6で指定されているAll-Zero出力のチェックを実行する必要があります。SECP256R1、SECP384R1、およびSECP521R1の場合、要件は[SP-800-56A]のセクション5で定義されています。SECP256R1、SECP384R1、およびSECP521R1の場合、少なくとも部分的な公開キーの検証を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "The same authentication credential MAY be used for both the Initiator and Responder roles. As noted in Section 12 of [RFC9052], the use of a single key for multiple algorithms is strongly discouraged unless proven secure by a dedicated cryptographic analysis. In particular, this recommendation applies to using the same private key for static Diffie-Hellman authentication and digital signature authentication. A preliminary conjecture is that a minor change to EDHOC may be sufficient to fit the analysis of a secure shared signature and ECDH key usage in [Degabriele11] and [Thormarker21]. Note that Section 5.6.3.2 of [SP-800-56A] allows a key agreement key pair to be used with a signature algorithm in certificate requests.",
      "ja": "イニシエーターとレスポンダーの両方の役割に同じ認証資格情報が使用される場合があります。[RFC9052]のセクション12で述べたように、複数のアルゴリズムに単一のキーを使用することは、専用の暗号化分析によって安全であることが証明されない限り、強く落胆します。特に、この推奨事項は、静的diffie-hellman認証とデジタル署名認証に同じ秘密鍵を使用することに適用されます。予備的な推測では、EDHOCへの小さな変化は、[Degabriele11]および[Thormarker21]の安全な共有署名とECDHの重要な使用法の分析に適合するのに十分である可能性があるということです。[SP-800-56A]のセクション5.6.3.2では、証明書リクエストで署名アルゴリズムでキー契約キーペアを使用できるようにすることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The property that a completed EDHOC session implies that another identity has been active is upheld as long as the Initiator does not have its own identity in the set of Responder identities it is allowed to communicate with. In trust-on-first-use (TOFU) use cases (see Appendix D.5), the Initiator should verify that the Responder's identity is not equal to its own. Any future EDHOC methods using, e.g., PSKs might need to mitigate this in other ways. However, an active attacker can gain information about the set of identities an Initiator is willing to communicate with. If the Initiator is willing to communicate with all identities except its own, an attacker can determine that a guessed Initiator identity is correct. To not leak any long-term identifiers, using a freshly generated authentication key as an identity in each initial TOFU session is RECOMMENDED.",
      "ja": "完成したEDHOCセッションが、イニシエーターが通信できるレスポンダーのアイデンティティのセットに独自のアイデンティティを持っていない限り、別のアイデンティティがアクティブであることを暗示することを意味します。ファーストオンファースト（豆腐）の使用ケース（付録D.5を参照）では、イニシエーターは、レスポンダーの身元がそれ自体と等しくないことを確認する必要があります。PSKを使用した将来のEDHOCメソッドは、他の方法でこれを軽減する必要がある場合があります。ただし、アクティブな攻撃者は、イニシエーターが喜んでコミュニケーションをとるアイデンティティのセットに関する情報を得ることができます。イニシエーターがそれ自体を除くすべてのアイデンティティと通信する意思がある場合、攻撃者は推測されたイニシエーターのアイデンティティが正しいと判断できます。長期識別子を漏らさないようにするには、各初期豆腐セッションのアイデンティティとして新たに生成された認証キーを使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "NIST SP 800-56A [SP-800-56A] forbids deriving secret and non-secret randomness from the same Key Derivation Function (KDF) instance, but this decision has been criticized by Krawczyk in [HKDFpaper] and doing so is common practice. In addition to IVs, other examples are the challenge in Extensible Authentication Protocol Tunneled Transport Layer Security (EAP-TTLS), the RAND in 3GPP Authentication and Key Agreement (AKA), and the Session-Id in EAP-TLS 1.3. Note that part of KEYSTREAM_2 is also non-secret randomness, as it is known or predictable to an attacker. The more recent NIST SP 800-108 [SP-800-108] aligns with [HKDFpaper] and states that, for a secure KDF, the revelation of one portion of the derived keying material must not degrade the security of any other portion of that keying material.",
      "ja": "NIST SP 800-56A [SP-800-56A]は、同じキーデリューション関数（KDF）インスタンスから秘密と非秘密のランダム性を導き出す禁止ですが、この決定は[hkdfpaper]のKrawczykによって批判されており、そうすることは一般的な実践です。IVSに加えて、他の例は、拡張可能な認証プロトコルトンネルトランスポートレイヤーセキュリティ（EAP-TTLS）、3GPP認証および主要な合意（別名）、およびEAP-TLS 1.3のセッションIDの課題です。keystream_2の一部は、攻撃者が既知または予測可能であるため、非秘密のランダム性でもあることに注意してください。最近のNIST SP 800-108 [SP-800-108]は[hkdfpaper]と一致し、安全なKDFの場合、派生したキーイング材料の一部の啓示は、その他の部分のセキュリティを分解してはならないと述べています。キーイング素材。"
    },
    {
      "indent": 0,
      "text": "9.3. Cipher Suites and Cryptographic Algorithms",
      "section_title": true,
      "ja": "9.3. 暗号スイートと暗号化アルゴリズム"
    },
    {
      "indent": 3,
      "text": "When using a private cipher suite or registering new cipher suites, the choice of the key length used in the different algorithms needs to be harmonized so that a sufficient security level is maintained for authentication credentials, the EDHOC session, and the protection of application data. The Initiator and Responder should enforce a minimum security level.",
      "ja": "プライベート暗号スイートを使用したり、新しい暗号スイートを登録したりする場合、異なるアルゴリズムで使用されるキー長の選択を調和させる必要があり、認証資格情報、EDHOCセッション、およびアプリケーションデータの保護に十分なセキュリティレベルを維持する必要があります。イニシエーターとレスポンダーは、最低セキュリティレベルを実施する必要があります。"
    },
    {
      "indent": 3,
      "text": "The output size of the EDHOC hash algorithm MUST be at least 256 bits. In particular, the hash algorithms SHA-1 and SHA-256/64 (SHA-256 truncated to 64 bits) SHALL NOT be supported for use in EDHOC except for certificate identification with x5t and c5t. For security considerations of SHA-1, see [RFC6194]. As EDHOC integrity protects all the authentication credentials, the choice of hash algorithm in x5t and c5t does not affect security and using the same hash algorithm as in the cipher suite, but with as much truncation as possible, is RECOMMENDED. That is, when the EDHOC hash algorithm is SHA-256, using SHA-256/64 in x5t and c5t is RECOMMENDED. The EDHOC MAC length MUST be at least 8 bytes and the tag length of the EDHOC AEAD algorithm MUST be at least 64 bits. Note that secp256k1 is only defined for use with ECDSA and not for ECDH. Note that some COSE algorithms are marked as not recommended in the COSE IANA registry.",
      "ja": "EDHOCハッシュアルゴリズムの出力サイズは、少なくとも256ビットでなければなりません。特に、HashアルゴリズムSHA-1およびSHA-256/64（SHA-256は64ビットに切り捨てられます）は、X5TおよびC5Tでの証明書識別を除き、EDHOCで使用するためにサポートされません。SHA-1のセキュリティ上の考慮事項については、[RFC6194]を参照してください。EDHOCの整合性はすべての認証資格情報を保護するため、X5TおよびC5Tでのハッシュアルゴリズムの選択はセキュリティに影響を与えず、Cipherスイートと同じハッシュアルゴリズムを使用しませんが、可能な限り多くの切り捨てが推奨されます。つまり、EDHOCハッシュアルゴリズムがSHA-256である場合、X5TでSHA-256/64を使用し、C5Tを使用することをお勧めします。Edhoc Macの長さは少なくとも8バイトでなければならず、Edhoc Aeadアルゴリズムのタグ長は少なくとも64ビットでなければなりません。SECP256K1は、ECDHではなくECDSAで使用するためにのみ定義されることに注意してください。一部のCOSEアルゴリズムは、COSE IANAレジストリで推奨されていないとマークされていることに注意してください。"
    },
    {
      "indent": 0,
      "text": "9.4. Post-Quantum Considerations",
      "section_title": true,
      "ja": "9.4. 質量の考慮事項"
    },
    {
      "indent": 3,
      "text": "As of the publication of this specification, it is unclear when or even if a quantum computer of sufficient size and power to exploit public key cryptography will exist. Deployments that need to consider risks decades into the future should transition to Post-Quantum Cryptography (PQC) in the not-too-distant future. Many other systems should take a slower wait-and-see approach where PQC is phased in when the quantum threat is more imminent. Current PQC algorithms have limitations compared to Elliptic Curve Cryptography (ECC), and the data sizes would be problematic in many constrained IoT systems.",
      "ja": "この仕様の公開時点では、公開キーの暗号を悪用するのに十分なサイズとパワーの量子コンピューターがいつ存在するか、または存在する場合でも不明です。何十年もリスクを考慮する必要がある展開は、それほど遠くない将来において、Quantum後の暗号（PQC）に移行する必要があります。他の多くのシステムは、量子の脅威がより差し迫っているときにPQCが段階的に段階的に段階的に段階的に段階的に段階的なアプローチをとる必要があります。現在のPQCアルゴリズムには、楕円曲線暗号化（ECC）と比較して制限があり、多くの制約付きIoTシステムではデータサイズに問題があります。"
    },
    {
      "indent": 3,
      "text": "Symmetric algorithms used in EDHOC, such as SHA-256 and AES-CCM-16-64-128, are practically secure against even large quantum computers. Two of NIST's security levels for quantum-resistant public key cryptography are based on AES-128 and SHA-256. A quantum computer will likely be expensive and slow due to heavy error correction. Grover's algorithm, which is proven to be optimal, cannot effectively be parallelized. It will provide little or no advantage in attacking AES, and AES-128 will remain secure for decades to come [NISTPQC].",
      "ja": "SHA-256やAES-CCM-16-64-128などのEDHOCで使用される対称アルゴリズムは、大規模な量子コンピューターでも実質的に安全です。量子耐性の公開キー暗号に関するNISTのセキュリティレベルの2つは、AES-128とSHA-256に基づいています。量子コンピューターは、重いエラーの補正のために高価で遅くなる可能性があります。最適であることが証明されているGroverのアルゴリズムは、効果的に並列化することはできません。AESの攻撃ではほとんどまたはまったく利点がありません。AES-128は、今後数十年間安全なままであり続けます[nistpqc]。"
    },
    {
      "indent": 3,
      "text": "EDHOC supports all signature algorithms defined by COSE, including PQC signature algorithms such as HSS-LMS. EDHOC is currently only specified for use with key exchange algorithms of type ECDH curves, but any Key Encapsulation Method (KEM), including PQC KEMs, can be used in method 0. While the key exchange in method 0 is specified with the terms of the Diffie-Hellman protocol, the key exchange adheres to a KEM interface: G_X is then the public key of the Initiator, G_Y is the encapsulation, and G_XY is the shared secret. Use of PQC KEMs to replace static DH authentication would likely require a specification updating EDHOC with new methods.",
      "ja": "EDHOCは、HSS-LMSなどのPQC署名アルゴリズムを含む、COSEで定義されたすべての署名アルゴリズムをサポートしています。EDHOCは現在、型ECDH曲線のキー交換アルゴリズムでのみ使用するために指定されていますが、PQC KEMを含むキーカプセル化方法（KEM）は方法0で使用できます。メソッド0のキー交換は、diffie-hellmanプロトコル、キーエクスチェンジはKEMインターフェイスを順守します。G_Xはイニシエーターの公開鍵、G_yはカプセル化、G_xyは共有秘密です。静的DH認証を置き換えるためにPQC KEMを使用するには、新しい方法でEDHOCを更新する仕様が必要になる可能性があります。"
    },
    {
      "indent": 0,
      "text": "9.5. Unprotected Data and Privacy",
      "section_title": true,
      "ja": "9.5. 保護されていないデータとプライバシー"
    },
    {
      "indent": 3,
      "text": "The Initiator and Responder must make sure that unprotected data and metadata do not reveal any sensitive information. This also applies for encrypted data sent to an unauthenticated party. In particular, it applies to EAD_1, ID_CRED_R, EAD_2, and error messages. Using the same EAD_1 in several EDHOC sessions allows passive eavesdroppers to correlate the different sessions. Note that even if ead_value is encrypted outside of EDHOC, the ead_labels in EAD_1 are revealed to passive attackers and the ead_labels in EAD_2 are revealed to active attackers. Another consideration is that the list of supported cipher suites may potentially be used to identify the application. The Initiator and Responder must also make sure that unauthenticated data does not trigger any harmful actions. In particular, this applies to EAD_1 and error messages.",
      "ja": "イニシエーターとレスポンダーは、保護されていないデータとメタデータが機密情報を明らかにしないことを確認する必要があります。これは、認定されていない当事者に送信された暗号化されたデータにも適用されます。特に、EAD_1、ID_CRED_R、EAD_2、およびエラーメッセージに適用されます。いくつかのEDHOCセッションで同じEAD_1を使用すると、受動的な盗聴者が異なるセッションを相関させることができます。EAD_VALUEがEDHOCの外で暗号化されている場合でも、EAD_1のEAD_Labelsは受動的な攻撃者に明らかになり、EAD_2のEAD_Labelsがアクティブな攻撃者に明らかにされていることに注意してください。もう1つの考慮事項は、サポートされている暗号スイートのリストを使用してアプリケーションを特定する可能性があることです。また、イニシエーターとレスポンダーは、認定されていないデータが有害なアクションをトリガーしないことを確認する必要があります。特に、これはEAD_1およびエラーメッセージに適用されます。"
    },
    {
      "indent": 3,
      "text": "An attacker observing network traffic may use connection identifiers sent in clear in EDHOC or the subsequent application protocol to correlate packets sent on different paths or at different times. The attacker may use this information for traffic flow analysis or to track an endpoint. Application protocols using connection identifiers from EDHOC SHOULD provide mechanisms to update the connection identifiers and MAY provide mechanisms to issue several simultaneously active connection identifiers. See [RFC9000] for a non-constrained example of such mechanisms. Connection identifiers can, e.g., be chosen randomly among the set of unused 1-byte connection identifiers. Connection identity privacy mechanisms are only useful when there are not fixed identifiers, such as IP address or MAC address in the lower layers.",
      "ja": "攻撃者がネットワークトラフィックを観察すると、EDHOCまたはその後のアプリケーションプロトコルで送信された接続識別子を使用して、異なるパスまたは異なる時期に送信されたパケットを相関させる場合があります。攻撃者は、この情報をトラフィックフロー分析に使用するか、エンドポイントを追跡するために使用できます。EDHOCの接続識別子を使用したアプリケーションプロトコルは、接続識別子を更新するメカニズムを提供し、いくつかの同時にアクティブな接続識別子を発行するメカニズムを提供する場合があります。このようなメカニズムの制約のない例については、[RFC9000]を参照してください。接続識別子は、例えば、未使用の1バイト接続識別子のセットの中からランダムに選択できます。接続アイデンティティプライバシーメカニズムは、下層のIPアドレスやMACアドレスなどの固定識別子がない場合にのみ役立ちます。"
    },
    {
      "indent": 0,
      "text": "9.6. Updated Internet Threat Model Considerations",
      "section_title": true,
      "ja": "9.6. 更新されたインターネット脅威モデルの考慮事項"
    },
    {
      "indent": 3,
      "text": "Since the publication of [RFC3552], there has been an increased awareness of the need to protect against endpoints that are compromised or malicious or whose interests simply do not align with the interests of users [THREAT-MODEL-GUIDANCE]. [RFC7624] describes an updated threat model for Internet confidentiality; see Section 9.1. [THREAT-MODEL-GUIDANCE] further expands the threat model. Implementations and users should take these threat models into account and consider actions to reduce the risk of tracking by other endpoints. In particular, even data sent protected to the other endpoint, such as ID_CRED fields and EAD fields, can be used for tracking; see Section 2.7 of [THREAT-MODEL-GUIDANCE].",
      "ja": "[RFC3552]の公開以来、妥協したり悪意のあるエンドポイントから保護する必要性についての認識が高まっています。[RFC7624]は、インターネットの機密性に関する最新の脅威モデルを説明しています。セクション9.1を参照してください。[脅威 - モデル調節]脅威モデルをさらに拡大します。実装とユーザーは、これらの脅威モデルを考慮し、他のエンドポイントによる追跡リスクを減らすためのアクションを検討する必要があります。特に、ID_CREDフィールドやEADフィールドなど、他のエンドポイントに保護されたデータでさえ、追跡に使用できます。[脅威 - モデル調節]のセクション2.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "The fields ID_CRED_I, ID_CRED_R, EAD_2, EAD_3, and EAD_4 have variable length, and information regarding the length may leak to an attacker. A passive attacker may, e.g., be able to differentiate endpoints using identifiers of different length. To mitigate this information leakage, an implementation may ensure that the fields have a fixed length or use padding. An implementation may, e.g., only use fixed length identifiers like 'kid' of length 1. Alternatively, padding may be used (see Section 3.8.1) to hide the true length of, e.g., certificates by value in 'x5chain' or 'c5c'.",
      "ja": "Fields ID_CRED_I、ID_CRED_R、EAD_2、EAD_3、およびEAD_4の長さはさまざまであり、長さに関する情報は攻撃者に漏れることがあります。受動的な攻撃者は、例えば、異なる長さの識別子を使用してエンドポイントを区別できる場合があります。この情報漏れを緩和するために、実装により、フィールドが固定された長さまたは使用パディングがあることを確認する場合があります。実装では、たとえば、長さ1の「KID」などの固定長の識別子のみを使用できます。あるいは、パディングを使用して（セクション3.8.1を参照）、「x5chain」または 'の値による証明書、例えば証明書を非表示にすることができます。C5C '。"
    },
    {
      "indent": 0,
      "text": "9.7. Denial of Service",
      "section_title": true,
      "ja": "9.7. サービス拒否"
    },
    {
      "indent": 3,
      "text": "EDHOC itself does not provide countermeasures against denial-of-service attacks. In particular, by sending a number of new or replayed message_1, an attacker may cause the Responder to allocate the state, perform cryptographic operations, and amplify messages. To mitigate such attacks, an implementation SHOULD make use of available lower layer mechanisms. For instance, when EDHOC is transferred as an exchange of CoAP messages, the CoAP server can use the Echo option defined in [RFC9175], which forces the CoAP client to demonstrate reachability at its apparent network address. To avoid an additional round trip, the Initiator can reduce the amplification factor by padding message_1, i.e., using EAD_1; see Section 3.8.1. Note that while the Echo option mitigates some resource exhaustion aspects of spoofing, it does not protect against a distributed denial-of-service attack made by real, potentially compromised, clients. Similarly, limiting amplification only reduces the impact, which still may be significant because of a large number of clients engaged in the attack.",
      "ja": "Edhoc自体は、サービス拒否攻撃に対する対策を提供していません。特に、多数の新規または再生されたmessage_1を送信することにより、攻撃者はレスポンダーに状態を割り当て、暗号操作を実行し、メッセージを増幅することがあります。このような攻撃を緩和するには、実装が利用可能な下層層メカニズムを利用する必要があります。たとえば、EDHOCがCOAPメッセージの交換として転送されると、COAPサーバーは[RFC9175]で定義されたECHOオプションを使用できます。追加の往復を回避するために、イニシエーターはメッセージ_1をパディングすることにより、つまりEAD_1を使用して増幅係数を減らすことができます。セクション3.8.1を参照してください。エコーオプションは、スプーフィングのいくつかのリソースの消耗の側面を軽減しますが、実際の、潜在的に妥協したクライアントによって行われた分散型サービス拒否攻撃から保護しないことに注意してください。同様に、増幅を制限すると、攻撃に従事している多くのクライアントのために、これは依然として重要である可能性があります。"
    },
    {
      "indent": 3,
      "text": "An attacker can also send a faked message_2, message_3, message_4, or error in an attempt to trick the receiving party to send an error message and abort the EDHOC session. EDHOC implementations MAY evaluate if a received message is likely to have been forged by an attacker and ignore it without sending an error message or aborting the EDHOC session.",
      "ja": "攻撃者は、受信者をだましてエラーメッセージを送信してEDHOCセッションを中止するために、偽造message_2、message_3、message_4、またはエラーを送信することもできます。EDHOCの実装は、受信したメッセージが攻撃者によって偽造された可能性があるかどうかを評価し、エラーメッセージを送信したり、EDHOCセッションを中止したりせずにそれを無視する場合があります。"
    },
    {
      "indent": 0,
      "text": "9.8. Implementation Considerations",
      "section_title": true,
      "ja": "9.8. 実装の考慮事項"
    },
    {
      "indent": 3,
      "text": "The availability of a secure random number generator is essential for the security of EDHOC. If no true random number generator is available, a random seed MUST be provided from an external source and used with a cryptographically secure pseudorandom number generator. As each pseudorandom number must only be used once, an implementation needs to get a unique input to the pseudorandom number generator after reboot or continuously store state in nonvolatile memory. Appendix B.1.1 of [RFC8613] describes issues and solution approaches for writing to nonvolatile memory. Intentionally or unintentionally weak or predictable pseudorandom number generators can be abused or exploited for malicious purposes. [RFC8937] describes a way for security protocol implementations to augment their (pseudo)random number generators using a long-term private key and a deterministic signature function. This improves randomness from broken or otherwise subverted random number generators. The same idea can be used with other secrets and functions, such as a Diffie-Hellman function or a symmetric secret, and a PRF like HMAC or KMAC. It is RECOMMENDED to not trust a single source of randomness and to not put unaugmented random numbers on the wire.",
      "ja": "安全な乱数ジェネレーターの可用性は、EDHOCのセキュリティに不可欠です。真の乱数ジェネレーターが利用できない場合、外部ソースからランダムシードを提供し、暗号化された擬似ランダム番号ジェネレーターとともに使用する必要があります。各擬似ランダム数は1回だけ使用する必要があるため、実装は、再起動した後、または不揮発性メモリに状態を継続的に保存した後、擬似ランダム数ジェネレーターに一意の入力を取得する必要があります。[RFC8613]の付録B.1.1は、不揮発性メモリに書き込むための問題とソリューションアプローチについて説明しています。意図的または意図せずに弱いまたは予測可能な擬似ランダム数ジェネレーターは、悪意のある目的のために乱用または悪用される可能性があります。[RFC8937]は、長期的な秘密鍵と決定論的な署名関数を使用して、セキュリティプロトコルの実装が（擬似）乱数ジェネレーターを強化する方法を説明しています。これにより、壊れたまたはその他の包囲された乱数ジェネレーターからのランダム性が向上します。同じアイデアは、diffie-hellman関数や対称的な秘密、およびHMACやKMACのようなPRFなど、他の秘密や関数で使用できます。単一のランダム性のソースを信頼せず、ワイヤーに未締めの乱数を入れないことをお勧めします。"
    },
    {
      "indent": 3,
      "text": "For many constrained IoT devices, it is problematic to support several crypto primitives. Existing devices can be expected to support either ECDSA or Edwards-curve Digital Signature Algorithm (EdDSA). If ECDSA is supported, \"deterministic ECDSA\", as specified in [RFC6979], MAY be used. Pure deterministic elliptic-curve signatures, such as deterministic ECDSA and EdDSA, have gained popularity over randomized ECDSA as their security does not depend on a source of high-quality randomness. Recent research has however found that implementations of these signature algorithms may be vulnerable to certain side-channel and fault injection attacks due to their determinism. For example, see Section 1 of [HEDGED-ECC-SIGS] for a list of attack papers. As suggested in Section 2.1.1 of [RFC9053], this can be addressed by combining randomness and determinism.",
      "ja": "多くの制約されたIoTデバイスにとって、いくつかの暗号プリミティブをサポートすることは問題があります。既存のデバイスは、ECDSAまたはEdwards-Curve Digital Signature Algorithm（EDDSA）のいずれかをサポートすることが期待できます。[RFC6979]で指定されているように、ECDSAがサポートされている場合、「決定論的ECDSA」を使用できます。決定論的ECDSAやEDDSAなどの純粋な決定論的楕円曲線の署名は、セキュリティが高品質のランダム性の原因に依存しないため、無作為化ECDSAよりも人気を博しています。しかし、最近の研究では、これらの署名アルゴリズムの実装は、決定論により特定のサイドチャネルおよび断層注入攻撃に対して脆弱である可能性があることがわかっています。たとえば、攻撃論文のリストについては、[Hedged-ecc-sigs]のセクション1を参照してください。[RFC9053]のセクション2.1.1で示唆されているように、これはランダム性と決定論を組み合わせて対処できます。"
    },
    {
      "indent": 3,
      "text": "Appendix D of [CURVE-REPR] describes how Montgomery curves, such as X25519 and X448, and (twisted) Edwards curves, such as Ed25519 and Ed448, can be mapped to and from short-Weierstrass form for implementations on platforms that accelerate elliptic curve group operations in short-Weierstrass form.",
      "ja": "[Curve-Repr]の付録Dは、X25519やX448などのモンゴメリー曲線、およびED25519やED448などの（ねじれた）エドワーズ曲線を、エリプティックカーブを加速するプラットフォーム上の実装のために、短いウェイアートラスフォームに出入りする方法を説明しています。Short-WeierStrassフォームでのグループ操作。"
    },
    {
      "indent": 3,
      "text": "All private keys, symmetric keys, and IVs MUST be secret. Only the Responder SHALL have access to the Responder's private authentication key, and only the Initiator SHALL have access to the Initiator's private authentication key. Implementations should provide countermeasures to side-channel attacks, such as timing attacks. Intermediate computed values, such as ephemeral ECDH keys and ECDH shared secrets, MUST be deleted after key derivation is completed.",
      "ja": "すべてのプライベートキー、対称キー、およびIVは秘密でなければなりません。レスポンダーのみがレスポンダーのプライベート認証キーにアクセスでき、イニシエーターのみがイニシエーターのプライベート認証キーにアクセスできます。実装は、タイミング攻撃などのサイドチャネル攻撃に対策を提供する必要があります。一時的なECDHキーやECDHの共有秘密などの中間計算値は、キー派生が完了した後に削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "The Initiator and Responder are responsible for verifying the integrity and validity of certificates. Verification of validity may require the use of a Real-Time Clock (RTC). The selection of trusted certification authorities (CAs) should be done very carefully and certificate revocation should be supported. The choice of revocation mechanism is left to the application. For example, in case of X.509 certificates, Certificate Revocation Lists [RFC5280] or the Online Certificate Status Protocol (OCSP) [RFC6960] may be used.",
      "ja": "イニシエーターとレスポンダーは、証明書の整合性と妥当性を確認する責任があります。有効性の検証には、リアルタイムクロック（RTC）の使用が必要になる場合があります。信頼できる認証当局（CAS）の選択は非常に慎重に行われるべきであり、証明書の取り消しをサポートする必要があります。取り消しメカニズムの選択は、アプリケーションに任されています。たとえば、X.509証明書の場合、証明書の取り消しリスト[RFC5280]またはオンライン証明書ステータスプロトコル（OCSP）[RFC6960]が使用される場合があります。"
    },
    {
      "indent": 3,
      "text": "Similar considerations as for certificates are needed for CWT/CCS. The endpoints are responsible for verifying the integrity and validity of CWT/CCS and to handle revocation. The application needs to determine what trust anchors are relevant and have a well-defined trust-establishment process. A self-signed certificate / CWT or CCS appearing in the protocol cannot be a trigger to modify the set of trust anchors. One common way for a new trust anchor to be added to (or removed from) a device is by means firmware upgrade. See [RFC9360] for a longer discussion on trust and validation in constrained devices.",
      "ja": "CWT/CCSには証明書と同様の考慮事項が必要です。エンドポイントは、CWT/CCSの完全性と妥当性を検証し、取り扱いを処理する責任があります。アプリケーションは、どのトラストアンカーが関連するかを決定し、明確に定義された信頼確立プロセスを持っている必要があります。プロトコルに登場する自己署名証明書 / CWTまたはCCSは、信頼アンカーのセットを変更するトリガーになることはできません。デバイスに新しいトラストアンカーを追加（または削除）するための一般的な方法の1つは、ファームウェアのアップグレードです。制約付きデバイスでの信頼と検証に関する長い議論については、[RFC9360]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Just like for certificates, the contents of the COSE header parameters 'kcwt' and 'kccs' defined in Section 10.6 must be processed as untrusted inputs. Endpoints that intend to rely on the assertions made by a CWT/CCS obtained from any of these methods need to validate the contents. For 'kccs', which enables transport of raw public keys, the data structure used does not include any protection or verification data. 'kccs' may be used for unauthenticated operations, e.g., trust on first use, with the limitations and caveats entailed; see Appendix D.5.",
      "ja": "証明書の場合と同様に、セクション10.6で定義されているCOSEヘッダーパラメーター「KCWT」と「KCCS」の内容は、信頼されていない入力として処理する必要があります。これらの方法のいずれかから取得したCWT/CCSによって行われたアサーションに依存することを意図するエンドポイントは、内容を検証する必要があります。生の公開キーの輸送を可能にする「KCCS」の場合、使用されるデータ構造には保護または検証データは含まれません。「KCC」は、制限と警告が伴う、最初の使用に対する信頼を伴う認定されていない操作に使用される場合があります。付録D.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "The Initiator and Responder are allowed to select connection identifiers C_I and C_R, respectively, for the other party to use in the ongoing EDHOC session as well as in a subsequent application protocol (e.g., OSCORE [RFC8613]). The choice of the connection identifier is not security critical in EDHOC but intended to simplify the retrieval of the right security context in combination with using short identifiers. If the wrong connection identifier of the other party is used in a protocol message, it will result in the receiving party not being able to retrieve a security context (which will abort the EDHOC session) or retrieve the wrong security context (which also aborts the EDHOC session as the message cannot be verified).",
      "ja": "イニシエーターとレスポンダーは、進行中のEDHOCセッションおよびその後のアプリケーションプロトコル（例：OSCORE [RFC8613]）で使用する相手がそれぞれC_IおよびC_Rを選択することができます。接続識別子の選択は、EDHOCではセキュリティが重要ではありませんが、短い識別子の使用と組み合わせて適切なセキュリティコンテキストの取得を簡素化することを目的としています。相手の間違った接続識別子がプロトコルメッセージで使用されている場合、受信者はセキュリティコンテキスト（EDHOCセッションを中止する）を取得できないか、間違ったセキュリティコンテキストを取得できません（これはまた、これも中止します。メッセージとしてのEDHOCセッションを検証できません）。"
    },
    {
      "indent": 3,
      "text": "If two nodes unintentionally initiate two simultaneous EDHOC sessions with each other, even if they only want to complete a single EDHOC session, they MAY abort the EDHOC session with the lexicographically smallest G_X. Note that in cases where several EDHOC sessions with different parameter sets (method, COSE headers, etc.) are used, an attacker can affect which parameter set will be used by blocking some of the parameter sets.",
      "ja": "2つのノードが意図せずに2つの同時EDHOCセッションを互いに開始する場合、たとえ1つのEDHOCセッションを完了したい場合でも、辞書編集的に最小のG_XでEDHOCセッションを中止することができます。異なるパラメーターセット（方法、COSEヘッダーなど）を持ついくつかのEDHOCセッションが使用される場合、攻撃者は、パラメーターセットの一部をブロックすることで使用されるパラメーターセットに影響を与える可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "If supported by the device, it is RECOMMENDED that at least the long-term private keys are stored in a Trusted Execution Environment (TEE) (for example, see [RFC9397]) and that sensitive operations using these keys are performed inside the TEE. To achieve even higher security, it is RECOMMENDED that additional operations such as ephemeral key generation, all computations of shared secrets, and storage of the PRK keys can be done inside the TEE. The use of a TEE aims at preventing code within that environment to be tampered with and preventing data used by such code to be read or tampered with by code outside that environment.",
      "ja": "デバイスでサポートされている場合、少なくとも長期的なプライベートキーは信頼できる実行環境（TEE）に保存されることをお勧めします（たとえば、[RFC9397]を参照）。これらのキーを使用した機密操作はTEE内で実行されます。さらに高いセキュリティを実現するには、一時的なキー生成、共有秘密のすべての計算、およびPRKキーのストレージなどの追加操作をTEE内で実行できることをお勧めします。TEEの使用は、その環境内のコードを防止することを目的としています。そのようなコードで使用されるデータがその環境の外側のコードによって読み取られたり改ざんされたりすることを防ぐことを目的としています。"
    },
    {
      "indent": 3,
      "text": "Note that HKDF-Expand has a relatively small maximum output length of 255 ⋅ hash_length, where hash_length is the output size in bytes of the EDHOC hash algorithm of the selected cipher suite. This means that when SHA-256 is used as a hash algorithm, PLAINTEXT_2 cannot be longer than 8160 bytes. This is probably not a limitation for most intended applications, but to be able to support, for example, long certificate chains or large external authorization data, there is a backwards compatible method specified in Appendix G.",
      "ja": "HKDF-Expandの最大出力長は255⋅Hash_Lengthで、Hash_Lengthは選択した暗号スイートのEDHOCハッシュアルゴリズムのバイトの出力サイズです。これは、SHA-256がハッシュアルゴリズムとして使用される場合、Plantext_2は8160バイトを超えることはできないことを意味します。これはおそらく、ほとんどの目的のアプリケーションにとって制限ではありませんが、たとえば長い証明書チェーンや大規模な外部認証データをサポートできるようにするために、付録Gで指定された後方互換の方法があります。"
    },
    {
      "indent": 3,
      "text": "The sequence of transcript hashes in EDHOC (TH_2, TH_3, and TH_4) does not make use of a so-called running hash. This is a design choice, as running hashes are often not supported on constrained platforms.",
      "ja": "Edhoc（Th_2、Th_3、およびTh_4）の転写産物ハッシュのシーケンスは、いわゆる実行ハッシュを使用していません。これは設計の選択です。ランニングハッシュは、制約付きプラットフォームではサポートされていないことが多いためです。"
    },
    {
      "indent": 3,
      "text": "When parsing a received EDHOC message, implementations MUST abort the EDHOC session if the message does not comply with the CDDL for that message. Implementations are not required to support non-deterministic encodings and MAY abort the EDHOC session if the received EDHOC message is not encoded using deterministic CBOR. Implementations MUST abort the EDHOC session if validation of a received public key fails or if any cryptographic field has the wrong length. It is RECOMMENDED to abort the EDHOC session if the received EDHOC message is not encoded using deterministic CBOR.",
      "ja": "受信したEDHOCメッセージを解析する場合、メッセージがそのメッセージのCDDLに準拠していない場合、実装はEDHOCセッションを中止する必要があります。非決定論的エンコーディングをサポートするために実装は必要ありません。また、受信したEDHOCメッセージが決定論的CBORを使用してエンコードされていない場合、EDHOCセッションを中止する場合があります。受信した公開キーの検証が失敗した場合、または暗号化フィールドが間違った長さを持っている場合、実装はEDHOCセッションを中止する必要があります。受信したEDHOCメッセージが決定論的CBORを使用してエンコードされていない場合は、EDHOCセッションを中止することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "10. IANA Considerations",
      "section_title": true,
      "ja": "10. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section gives IANA considerations and, unless otherwise noted, conforms with [RFC8126].",
      "ja": "このセクションでは、IANAの考慮事項を示し、特に明記しない限り、[RFC8126]に準拠しています。"
    },
    {
      "indent": 0,
      "text": "10.1. EDHOC Exporter Label Registry",
      "section_title": true,
      "ja": "10.1. Edhoc Exporter Label Registry"
    },
    {
      "indent": 3,
      "text": "IANA has created a new registry under the new registry group \"Ephemeral Diffie-Hellman Over COSE (EDHOC)\" as follows:",
      "ja": "IANAは、新しいレジストリグループ「Ephemeral Diffie-Hellman over Cose（EDHOC）」の下に新しいレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "Registry Name:",
      "ja": "レジストリ名："
    },
    {
      "indent": 12,
      "text": "EDHOC Exporter Labels",
      "ja": "Edhoc Exporterラベル"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "RFC 9528",
      "ja": "RFC 9528"
    },
    {
      "indent": 8,
      "text": "+=============+==============================+===========+\n| Label       | Description                  | Reference |\n+=============+==============================+===========+\n| 0           | Derived OSCORE Master Secret | RFC 9528  |\n+-------------+------------------------------+-----------+\n| 1           | Derived OSCORE Master Salt   | RFC 9528  |\n+-------------+------------------------------+-----------+\n| 2-22        | Unassigned                   |           |\n+-------------+------------------------------+-----------+\n| 23          | Reserved                     | RFC 9528  |\n+-------------+------------------------------+-----------+\n| 24-32767    | Unassigned                   |           |\n+-------------+------------------------------+-----------+\n| 32768-65535 | Reserved for Private Use     |           |\n+-------------+------------------------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Table 4: EDHOC Exporter Labels",
      "ja": "表4：EDHOC輸出業者ラベル"
    },
    {
      "indent": 3,
      "text": "This registry also has a \"Change Controller\" field. For registrations made by IETF documents, the IETF is listed.",
      "ja": "このレジストリには、「Change Controller」フィールドもあります。IETFドキュメントによって行われた登録の場合、IETFがリストされています。"
    },
    {
      "indent": 17,
      "text": "+=============+=========================+\n| Range       | Registration Procedures |\n+=============+=========================+\n| 0-23        | Standards Action        |\n+-------------+-------------------------+\n| 24-32767    | Expert Review           |\n+-------------+-------------------------+\n| 32768-65535 | Private Use             |\n+-------------+-------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 5: Registration Procedures for EDHOC Exporter Labels",
      "ja": "表5：EDHOC輸出業者ラベルの登録手順"
    },
    {
      "indent": 0,
      "text": "10.2. EDHOC Cipher Suites Registry",
      "section_title": true,
      "ja": "10.2. Edhoc Cipher Suitesレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created a new registry under the new registry group \"Ephemeral Diffie-Hellman Over COSE (EDHOC)\" as follows:",
      "ja": "IANAは、新しいレジストリグループ「Ephemeral Diffie-Hellman over Cose（EDHOC）」の下に新しいレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "Registry Name:",
      "ja": "レジストリ名："
    },
    {
      "indent": 12,
      "text": "EDHOC Cipher Suites",
      "ja": "Edhoc Cipher Suites"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "RFC 9528",
      "ja": "RFC 9528"
    },
    {
      "indent": 3,
      "text": "The columns of the registry are Value, Array, Description, and Reference, where Value is an integer and the other columns are text strings. The initial contents of the registry are:",
      "ja": "レジストリの列は、値、配列、説明、および参照であり、値は整数であり、他の列はテキスト文字列です。レジストリの最初の内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "+=======+================+=============================+===========+\n| Value | Array          | Description                 | Reference |\n+=======+================+=============================+===========+\n| -24   | N/A            | Private Use                 | RFC 9528  |\n+-------+----------------+-----------------------------+-----------+\n| -23   | N/A            | Private Use                 | RFC 9528  |\n+-------+----------------+-----------------------------+-----------+\n| -22   | N/A            | Private Use                 | RFC 9528  |\n+-------+----------------+-----------------------------+-----------+\n| -21   | N/A            | Private Use                 | RFC 9528  |\n+-------+----------------+-----------------------------+-----------+\n| 0     | 10, -16, 8, 4, | AES-CCM-16-64-128, SHA-256, | RFC 9528  |\n|       | -8, 10, -16    | 8, X25519, EdDSA,           |           |\n|       |                | AES-CCM-16-64-128, SHA-256  |           |\n+-------+----------------+-----------------------------+-----------+\n| 1     | 30, -16, 16,   | AES-CCM-16-128-128,         | RFC 9528  |\n|       | 4, -8, 10, -16 | SHA-256, 16, X25519, EdDSA, |           |\n|       |                | AES-CCM-16-64-128, SHA-256  |           |\n+-------+----------------+-----------------------------+-----------+\n| 2     | 10, -16, 8, 1, | AES-CCM-16-64-128, SHA-256, | RFC 9528  |\n|       | -7, 10, -16    | 8, P-256, ES256,            |           |\n|       |                | AES-CCM-16-64-128, SHA-256  |           |\n+-------+----------------+-----------------------------+-----------+\n| 3     | 30, -16, 16,   | AES-CCM-16-128-128,         | RFC 9528  |\n|       | 1, -7, 10, -16 | SHA-256, 16, P-256, ES256,  |           |\n|       |                | AES-CCM-16-64-128, SHA-256  |           |\n+-------+----------------+-----------------------------+-----------+\n| 4     | 24, -16, 16,   | ChaCha20/Poly1305, SHA-256, | RFC 9528  |\n|       | 4, -8, 24, -16 | 16, X25519, EdDSA,          |           |\n|       |                | ChaCha20/Poly1305, SHA-256  |           |\n+-------+----------------+-----------------------------+-----------+\n| 5     | 24, -16, 16,   | ChaCha20/Poly1305, SHA-256, | RFC 9528  |\n|       | 1, -7, 24, -16 | 16, P-256, ES256,           |           |\n|       |                | ChaCha20/Poly1305, SHA-256  |           |\n+-------+----------------+-----------------------------+-----------+\n| 6     | 1, -16, 16, 4, | A128GCM, SHA-256, 16,       | RFC 9528  |\n|       | -7, 1, -16     | X25519, ES256, A128GCM,     |           |\n|       |                | SHA-256                     |           |\n+-------+----------------+-----------------------------+-----------+\n| 23    |                | Reserved                    | RFC 9528  |\n+-------+----------------+-----------------------------+-----------+\n| 24    | 3, -43, 16, 2, | A256GCM, SHA-384, 16,       | RFC 9528  |\n|       | -35, 3, -43    | P-384, ES384, A256GCM,      |           |\n|       |                | SHA-384                     |           |\n+-------+----------------+-----------------------------+-----------+\n| 25    | 24, -45, 16,   | ChaCha20/Poly1305,          | RFC 9528  |\n|       | 5, -8, 24, -45 | SHAKE256, 16, X448, EdDSA,  |           |\n|       |                | ChaCha20/Poly1305, SHAKE256 |           |\n+-------+----------------+-----------------------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 6: EDHOC Cipher Suites",
      "ja": "表6：Edhoc Cipher Suites"
    },
    {
      "indent": 10,
      "text": "+===============+=====================================+\n| Range         | Registration Procedures             |\n+===============+=====================================+\n| -65536 to -25 | Specification Required              |\n+---------------+-------------------------------------+\n| -24 to -21    | Private Use                         |\n+---------------+-------------------------------------+\n| -20 to 23     | Standards Action with Expert Review |\n+---------------+-------------------------------------+\n| 24 to 65535   | Specification Required              |\n+---------------+-------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Table 7: Registration Procedures for EDHOC Cipher Suites",
      "ja": "表7：Edhoc Cipher Suitesの登録手順"
    },
    {
      "indent": 0,
      "text": "10.3. EDHOC Method Type Registry",
      "section_title": true,
      "ja": "10.3. EDHOCメソッドタイプレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created a new registry under the new registry group \"Ephemeral Diffie-Hellman Over COSE (EDHOC)\" as follows:",
      "ja": "IANAは、新しいレジストリグループ「Ephemeral Diffie-Hellman over Cose（EDHOC）」の下に新しいレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "Registry Name:",
      "ja": "レジストリ名："
    },
    {
      "indent": 12,
      "text": "EDHOC Method Types",
      "ja": "EDHOCメソッドタイプ"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "RFC 9528",
      "ja": "RFC 9528"
    },
    {
      "indent": 3,
      "text": "The columns of the registry are Value, Initiator Authentication Key, Responder Authentication Key, and Reference, where Value is an integer and the key columns are text strings describing the authentication keys.",
      "ja": "レジストリの列は、値、イニシエーター認証キー、応答者認証キー、および値が整数であり、キー列は認証キーを説明するテキスト文字列です。"
    },
    {
      "indent": 3,
      "text": "The initial contents of the registry are shown in Table 2. Method 23 is Reserved.",
      "ja": "レジストリの初期内容を表2に示します。方法23は予約されています。"
    },
    {
      "indent": 10,
      "text": "+===============+=====================================+\n| Range         | Registration Procedures             |\n+===============+=====================================+\n| -65536 to -25 | Specification Required              |\n+---------------+-------------------------------------+\n| -24 to 23     | Standards Action with Expert Review |\n+---------------+-------------------------------------+\n| 24 to 65535   | Specification Required              |\n+---------------+-------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Table 8: Registration Procedures for EDHOC Method Types",
      "ja": "表8：EDHOCメソッドタイプの登録手順"
    },
    {
      "indent": 0,
      "text": "10.4. EDHOC Error Codes Registry",
      "section_title": true,
      "ja": "10.4. EDHOCエラーコードレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created a new registry under the new registry group \"Ephemeral Diffie-Hellman Over COSE (EDHOC)\" as follows:",
      "ja": "IANAは、新しいレジストリグループ「Ephemeral Diffie-Hellman over Cose（EDHOC）」の下に新しいレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "Registry Name:",
      "ja": "レジストリ名："
    },
    {
      "indent": 12,
      "text": "EDHOC Error Codes",
      "ja": "EDHOCエラーコード"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "RFC 9528",
      "ja": "RFC 9528"
    },
    {
      "indent": 3,
      "text": "The columns of the registry are ERR_CODE, ERR_INFO Type, Description, Change Controller, and Reference, where ERR_CODE is an integer, ERR_INFO is a CDDL defined type, and Description is a text string. The initial contents of the registry are shown in Table 3. Error code 23 is Reserved. This registry also has a \"Change Controller\" field. For registrations made by IETF documents, the IETF is listed.",
      "ja": "レジストリの列はerr_code、err_infoタイプ、説明、変更コントローラー、および参照であり、err_codeは整数であり、err_infoはcddl定義型であり、説明はテキスト文字列です。レジストリの初期内容を表3に示します。エラーコード23は予約されています。このレジストリには、「Change Controller」フィールドもあります。IETFドキュメントによって行われた登録の場合、IETFがリストされています。"
    },
    {
      "indent": 16,
      "text": "+===============+=========================+\n| Range         | Registration Procedures |\n+===============+=========================+\n| -65536 to -25 | Expert Review           |\n+---------------+-------------------------+\n| -24 to 23     | Standards Action        |\n+---------------+-------------------------+\n| 24 to 65535   | Expert Review           |\n+---------------+-------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 9: Registration Procedures for EDHOC Error Codes",
      "ja": "表9：EDHOCエラーコードの登録手順"
    },
    {
      "indent": 0,
      "text": "10.5. EDHOC External Authorization Data Registry",
      "section_title": true,
      "ja": "10.5. EDHOC外部認証データレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created a new registry under the new registry group \"Ephemeral Diffie-Hellman Over COSE (EDHOC)\" as follows:",
      "ja": "IANAは、新しいレジストリグループ「Ephemeral Diffie-Hellman over Cose（EDHOC）」の下に新しいレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "Registry Name:",
      "ja": "レジストリ名："
    },
    {
      "indent": 12,
      "text": "EDHOC External Authorization Data",
      "ja": "EDHOC外部認証データ"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "RFC 9528",
      "ja": "RFC 9528"
    },
    {
      "indent": 3,
      "text": "The columns of the registry are Name, Label, Description, and Reference, where Label is a nonnegative integer and the other columns are text strings. The initial contents of the registry are shown in Table 10. EAD label 23 is Reserved.",
      "ja": "レジストリの列は名前、ラベル、説明、および参照であり、ラベルは非陰性整数であり、他の列はテキスト文字列です。レジストリの初期内容を表10に示します。EADラベル23は予約されています。"
    },
    {
      "indent": 9,
      "text": "+=========+=======+====================+===============+\n| Name    | Label | Description        | Reference     |\n+=========+=======+====================+===============+\n| Padding | 0     | Randomly generated | RFC 9528,     |\n|         |       | CBOR byte string   | Section 3.8.1 |\n+---------+-------+--------------------+---------------+\n|         | 23    | Reserved           | RFC 9528      |\n+---------+-------+--------------------+---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "Table 10: EDHOC EAD Labels",
      "ja": "表10：EDHOC EADラベル"
    },
    {
      "indent": 11,
      "text": "+=============+=====================================+\n| Range       | Registration Procedures             |\n+=============+=====================================+\n| 0 to 23     | Standards Action with Expert Review |\n+-------------+-------------------------------------+\n| 24 to 65535 | Specification Required              |\n+-------------+-------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "Table 11: Registration Procedures for EDHOC EAD Labels",
      "ja": "表11：EDHOC EADラベルの登録手順"
    },
    {
      "indent": 0,
      "text": "10.6. COSE Header Parameters Registry",
      "section_title": true,
      "ja": "10.6. COSEヘッダーパラメータレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following entries in the \"COSE Header Parameters\" registry under the registry group \"CBOR Object Signing and Encryption (COSE)\" (see Table 12). The value of the 'kcwt' header parameter is a COSE Web Token (CWT) [RFC8392], and the value of the 'kccs' header parameter is a CWT Claims Set (CCS); see Section 1.4. The CWT/CCS must contain a COSE_Key in a 'cnf' claim [RFC8747]. The Value Registry column for this item is empty and omitted from the table below.",
      "ja": "IANAは、レジストリグループ「CBORオブジェクトの署名と暗号化（COSE）」の下にある「COSEヘッダーパラメーター」レジストリに次のエントリを登録しています（表12を参照）。「KCWT」ヘッダーパラメーターの値はCOSE Webトークン（CWT）[RFC8392]であり、「KCCS」ヘッダーパラメーターの値はCWTクレームセット（CCS）です。セクション1.4を参照してください。CWT/CCSには、「CNF」クレーム[RFC8747]にCOSE_KEYを含める必要があります。このアイテムの値レジストリ列は空で、下の表から省略されています。"
    },
    {
      "indent": 5,
      "text": "+======+=======+===============+===============================+\n| Name | Label | Value Type    | Description                   |\n+======+=======+===============+===============================+\n| kcwt | 13    | COSE_Messages | A CBOR Web Token (CWT)        |\n|      |       |               | containing a COSE_Key in a    |\n|      |       |               | 'cnf' claim and possibly      |\n|      |       |               | other claims.  CWT is defined |\n|      |       |               | in RFC 8392.  COSE_Messages   |\n|      |       |               | is defined in RFC 9052.       |\n+------+-------+---------------+-------------------------------+\n| kccs | 14    | map           | A CWT Claims Set (CCS)        |\n|      |       |               | containing a COSE_Key in a    |\n|      |       |               | 'cnf' claim and possibly      |\n|      |       |               | other claims.  CCS is defined |\n|      |       |               | in RFC 8392.                  |\n+------+-------+---------------+-------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Table 12: COSE Header Parameter Labels",
      "ja": "表12：COSEヘッダーパラメーターラベル"
    },
    {
      "indent": 0,
      "text": "10.7. Well-Known URI Registry",
      "section_title": true,
      "ja": "10.7. よく知られているURIレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has added the well-known URI \"edhoc\" to the \"Well-Known URIs\" registry.",
      "ja": "Ianaは、有名なURI「Edhoc」を「有名なURIS」レジストリに追加しました。"
    },
    {
      "indent": 3,
      "text": "URI Suffix:",
      "ja": "URIサフィックス："
    },
    {
      "indent": 12,
      "text": "edhoc",
      "ja": "エドホック"
    },
    {
      "indent": 3,
      "text": "Change Controller:",
      "ja": "Change Controller："
    },
    {
      "indent": 12,
      "text": "IETF",
      "ja": "IETF"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "RFC 9528",
      "ja": "RFC 9528"
    },
    {
      "indent": 3,
      "text": "Related Information:",
      "ja": "関連情報："
    },
    {
      "indent": 12,
      "text": "None",
      "ja": "なし"
    },
    {
      "indent": 0,
      "text": "10.8. Media Types Registry",
      "section_title": true,
      "ja": "10.8. メディアタイプレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has added the media types \"application/edhoc+cbor-seq\" and \"application/cid-edhoc+cbor-seq\" to the \"Media Types\" registry.",
      "ja": "IANAは、「Application/Edhoc+Cbor-Seq」と「Application/CID-Edhoc+Cbor-Seq」を「メディアタイプ」レジストリに追加しました。"
    },
    {
      "indent": 0,
      "text": "10.8.1. application/edhoc+cbor-seq Media Type Registration",
      "section_title": true,
      "ja": "10.8.1. アプリケーション/EDHOC+CBOR-SEQメディアタイプの登録"
    },
    {
      "indent": 3,
      "text": "Type name:",
      "ja": "タイプ名："
    },
    {
      "indent": 12,
      "text": "application",
      "ja": "応用アプリケーション出願塗布申請アプリ使用利用申込申し込み応募運用願い願い出要請控訴勉励丹念請求応用力適用業務"
    },
    {
      "indent": 3,
      "text": "Subtype name:",
      "ja": "サブタイプ名："
    },
    {
      "indent": 12,
      "text": "edhoc+cbor-seq",
      "ja": "edhoc+cbor-seq"
    },
    {
      "indent": 3,
      "text": "Required parameters:",
      "ja": "必要なパラメーター："
    },
    {
      "indent": 12,
      "text": "N/A",
      "ja": "n/a"
    },
    {
      "indent": 3,
      "text": "Optional parameters:",
      "ja": "オプションのパラメーター："
    },
    {
      "indent": 12,
      "text": "N/A",
      "ja": "n/a"
    },
    {
      "indent": 3,
      "text": "Encoding considerations:",
      "ja": "考慮事項のエンコード："
    },
    {
      "indent": 12,
      "text": "binary",
      "ja": "バイナリバイナリー二進"
    },
    {
      "indent": 3,
      "text": "Security considerations:",
      "ja": "セキュリティ上の考慮事項："
    },
    {
      "indent": 12,
      "text": "See Section 7 of RFC 9528.",
      "ja": "RFC 9528のセクション7を参照してください。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations:",
      "ja": "相互運用性の考慮事項："
    },
    {
      "indent": 12,
      "text": "N/A",
      "ja": "n/a"
    },
    {
      "indent": 3,
      "text": "Published specification:",
      "ja": "公開された仕様："
    },
    {
      "indent": 12,
      "text": "RFC 9528",
      "ja": "RFC 9528"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type:",
      "ja": "このメディアタイプを使用するアプリケーション："
    },
    {
      "indent": 12,
      "text": "To be identified",
      "ja": "識別されます"
    },
    {
      "indent": 3,
      "text": "Fragment identifier considerations:",
      "ja": "フラグメント識別子の考慮事項："
    },
    {
      "indent": 12,
      "text": "N/A",
      "ja": "n/a"
    },
    {
      "indent": 3,
      "text": "Additional information:",
      "ja": "追加情報："
    },
    {
      "indent": 6,
      "text": "Magic number(s):",
      "ja": "マジックナンバー："
    },
    {
      "indent": 15,
      "text": "N/A",
      "ja": "n/a"
    },
    {
      "indent": 6,
      "text": "File extension(s):",
      "ja": "ファイル拡張子："
    },
    {
      "indent": 15,
      "text": "N/A",
      "ja": "n/a"
    },
    {
      "indent": 6,
      "text": "Macintosh file type code(s):",
      "ja": "Macintoshファイルタイプコード："
    },
    {
      "indent": 15,
      "text": "N/A",
      "ja": "n/a"
    },
    {
      "indent": 3,
      "text": "Person & email address to contact for further information:",
      "ja": "詳細については、連絡先への個人およびメールアドレス："
    },
    {
      "indent": 12,
      "text": "See \"Authors' Addresses\" section in RFC 9528.",
      "ja": "RFC 9528の「著者のアドレス」セクションを参照してください。"
    },
    {
      "indent": 3,
      "text": "Intended usage:",
      "ja": "意図された使用法："
    },
    {
      "indent": 12,
      "text": "COMMON",
      "ja": "一般"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage:",
      "ja": "使用に関する制限："
    },
    {
      "indent": 12,
      "text": "N/A",
      "ja": "n/a"
    },
    {
      "indent": 3,
      "text": "Author:",
      "ja": "著者："
    },
    {
      "indent": 12,
      "text": "See \"Authors' Addresses\" section.",
      "ja": "「著者のアドレス」セクションを参照してください。"
    },
    {
      "indent": 3,
      "text": "Change Controller:",
      "ja": "Change Controller："
    },
    {
      "indent": 12,
      "text": "IETF",
      "ja": "IETF"
    },
    {
      "indent": 0,
      "text": "10.8.2. application/cid-edhoc+cbor-seq Media Type Registration",
      "section_title": true,
      "ja": "10.8.2. アプリケーション/CID-EDHOC+CBOR-SEQメディアタイプの登録"
    },
    {
      "indent": 3,
      "text": "Type name:",
      "ja": "タイプ名："
    },
    {
      "indent": 12,
      "text": "application",
      "ja": "応用アプリケーション出願塗布申請アプリ使用利用申込申し込み応募運用願い願い出要請控訴勉励丹念請求応用力適用業務"
    },
    {
      "indent": 3,
      "text": "Subtype name:",
      "ja": "サブタイプ名："
    },
    {
      "indent": 12,
      "text": "cid-edhoc+cbor-seq",
      "ja": "cid-edhoc+cbor-seq"
    },
    {
      "indent": 3,
      "text": "Required parameters:",
      "ja": "必要なパラメーター："
    },
    {
      "indent": 12,
      "text": "N/A",
      "ja": "n/a"
    },
    {
      "indent": 3,
      "text": "Optional parameters:",
      "ja": "オプションのパラメーター："
    },
    {
      "indent": 12,
      "text": "N/A",
      "ja": "n/a"
    },
    {
      "indent": 3,
      "text": "Encoding considerations:",
      "ja": "考慮事項のエンコード："
    },
    {
      "indent": 12,
      "text": "binary",
      "ja": "バイナリバイナリー二進"
    },
    {
      "indent": 3,
      "text": "Security considerations:",
      "ja": "セキュリティ上の考慮事項："
    },
    {
      "indent": 12,
      "text": "See Section 7 of RFC 9528.",
      "ja": "RFC 9528のセクション7を参照してください。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations:",
      "ja": "相互運用性の考慮事項："
    },
    {
      "indent": 12,
      "text": "N/A",
      "ja": "n/a"
    },
    {
      "indent": 3,
      "text": "Published specification:",
      "ja": "公開された仕様："
    },
    {
      "indent": 12,
      "text": "RFC 9528",
      "ja": "RFC 9528"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type:",
      "ja": "このメディアタイプを使用するアプリケーション："
    },
    {
      "indent": 12,
      "text": "To be identified",
      "ja": "識別されます"
    },
    {
      "indent": 3,
      "text": "Fragment identifier considerations:",
      "ja": "フラグメント識別子の考慮事項："
    },
    {
      "indent": 12,
      "text": "N/A",
      "ja": "n/a"
    },
    {
      "indent": 3,
      "text": "Additional information:",
      "ja": "追加情報："
    },
    {
      "indent": 6,
      "text": "Magic number(s):",
      "ja": "マジックナンバー："
    },
    {
      "indent": 15,
      "text": "N/A",
      "ja": "n/a"
    },
    {
      "indent": 6,
      "text": "File extension(s):",
      "ja": "ファイル拡張子："
    },
    {
      "indent": 15,
      "text": "N/A",
      "ja": "n/a"
    },
    {
      "indent": 6,
      "text": "Macintosh file type code(s):",
      "ja": "Macintoshファイルタイプコード："
    },
    {
      "indent": 15,
      "text": "N/A",
      "ja": "n/a"
    },
    {
      "indent": 3,
      "text": "Person & email address to contact for further information:",
      "ja": "詳細については、連絡先への個人およびメールアドレス："
    },
    {
      "indent": 12,
      "text": "See \"Authors' Addresses\" section in RFC 9528.",
      "ja": "RFC 9528の「著者のアドレス」セクションを参照してください。"
    },
    {
      "indent": 3,
      "text": "Intended usage:",
      "ja": "意図された使用法："
    },
    {
      "indent": 12,
      "text": "COMMON",
      "ja": "一般"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage:",
      "ja": "使用に関する制限："
    },
    {
      "indent": 12,
      "text": "N/A",
      "ja": "n/a"
    },
    {
      "indent": 3,
      "text": "Author:",
      "ja": "著者："
    },
    {
      "indent": 12,
      "text": "See \"Authors' Addresses\" section.",
      "ja": "「著者のアドレス」セクションを参照してください。"
    },
    {
      "indent": 3,
      "text": "Change Controller:",
      "ja": "Change Controller："
    },
    {
      "indent": 12,
      "text": "IETF",
      "ja": "IETF"
    },
    {
      "indent": 0,
      "text": "10.9. CoAP Content-Formats Registry",
      "section_title": true,
      "ja": "10.9. COAPコンテンツフォーマットレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has added the media types \"application/edhoc+cbor-seq\" and \"application/cid-edhoc+cbor-seq\" to the \"CoAP Content-Formats\" registry under the registry group \"Constrained RESTful Environments (CoRE) Parameters\".",
      "ja": "IANAは、メディアタイプ「アプリケーション/EDHOC+CBOR-SEQ」と「Application/CID-EDHOC+CBOR-SEQ」を、レジストリグループ「RESTFUL環境（CORE）パラメーター」の下で「COAPコンテンツフォーマット」レジストリに追加しました。"
    },
    {
      "indent": 3,
      "text": "+================================+================+====+===========+\n| Content Type                   | Content Coding | ID | Reference |\n+================================+================+====+===========+\n| application/edhoc+cbor-seq     | -              | 64 | RFC 9528  |\n+--------------------------------+----------------+----+-----------+\n| application/cid-edhoc+cbor-seq | -              | 65 | RFC 9528  |\n+--------------------------------+----------------+----+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 13: CoAP Content-Format IDs",
      "ja": "表13：COAPコンテンツフォーマットID"
    },
    {
      "indent": 0,
      "text": "10.10. Resource Type (rt=) Link Target Attribute Values Registry",
      "section_title": true,
      "ja": "10.10. リソースタイプ（rt =）リンクターゲット属性値レジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has added the resource type \"core.edhoc\" to the \"Resource Type (rt=) Link Target Attribute Values\" registry under the registry group \"Constrained RESTful Environments (CoRE) Parameters\".",
      "ja": "IANAは、リソースタイプ「core.edhoc」を「リソースタイプ（rt =）リンクターゲット属性値」に追加しました。レジストリグループ「制約された安らかな環境（core）パラメーター」の下にあります。"
    },
    {
      "indent": 3,
      "text": "Value:",
      "ja": "値："
    },
    {
      "indent": 12,
      "text": "core.edhoc",
      "ja": "core.edhoc"
    },
    {
      "indent": 3,
      "text": "Description:",
      "ja": "説明："
    },
    {
      "indent": 12,
      "text": "EDHOC resource",
      "ja": "EDHOCリソース"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "RFC 9528",
      "ja": "RFC 9528"
    },
    {
      "indent": 0,
      "text": "10.11. Expert Review Instructions",
      "section_title": true,
      "ja": "10.11. 専門家のレビューの指示"
    },
    {
      "indent": 3,
      "text": "The IANA registries established in this document are defined as \"Expert Review\", \"Specification Required\", or \"Standards Action with Expert Review\". This section gives some general guidelines for what the experts should be looking for, but they are being designated as experts for a reason so they should be given substantial latitude.",
      "ja": "このドキュメントで確立されたIANAレジストリは、「専門家のレビュー」、「必要な仕様」、または「専門家のレビューを伴う標準訴訟」として定義されています。このセクションでは、専門家が探しているものについてのいくつかの一般的なガイドラインを示しますが、それらは理由で専門家に指定されているため、実質的な緯度を与えられるべきです。"
    },
    {
      "indent": 3,
      "text": "Expert reviewers should take into consideration the following points:",
      "ja": "専門家のレビュアーは、次のポイントを考慮する必要があります。"
    },
    {
      "indent": 6,
      "text": "* The clarity and correctness of registrations. Experts are expected to check the clarity of purpose and use of the requested entries. Expert needs to make sure the values of algorithms are taken from the right registry when that is required. Experts should consider requesting an opinion on the correctness of registered parameters from relevant IETF working groups. Encodings that do not meet these objectives of clarity and completeness should not be registered.",
      "ja": "* 登録の明確さと正確性。専門家は、要求されたエントリの目的と使用の明確さを確認することが期待されています。専門家は、それが必要なときに正しいレジストリからアルゴリズムの値が取得されることを確認する必要があります。専門家は、関連するIETFワーキンググループから登録パラメーターの正確性に関する意見を要求することを検討する必要があります。これらの明確さと完全性の目的を満たさないエンコーディングは、登録すべきではありません。"
    },
    {
      "indent": 6,
      "text": "* The expected usage of fields when approving code point assignment. The length of the encoded value should be weighed against how many code points of that length are left, the size of device it will be used on, and the number of code points left that encode to that size.",
      "ja": "* コードポイント割り当てを承認する際のフィールドの予想される使用。エンコードされた値の長さは、その長さのコードポイントの数、使用されるデバイスのサイズ、およびそのサイズにエンコードするコードポイントの数と比較して計量する必要があります。"
    },
    {
      "indent": 6,
      "text": "* It is recommended to have a specification even if the registration procedure is \"Expert Review\". When specifications are not provided for a request where Expert Review is the assignment policy, the description provided needs to have sufficient information to verify the code points as above.",
      "ja": "* 登録手続きが「専門家のレビュー」であっても、仕様があることをお勧めします。専門家のレビューが割り当てポリシーであるリクエストの仕様が提供されていない場合、提供された説明には、上記のようにコードポイントを検証するのに十分な情報が必要です。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11. 参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC3279]  Bassham, L., Polk, W., and R. Housley, \"Algorithms and\n           Identifiers for the Internet X.509 Public Key\n           Infrastructure Certificate and Certificate Revocation List\n           (CRL) Profile\", RFC 3279, DOI 10.17487/RFC3279, April\n           2002, <https://www.rfc-editor.org/info/rfc3279>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC3552]  Rescorla, E. and B. Korver, \"Guidelines for Writing RFC\n           Text on Security Considerations\", BCP 72, RFC 3552,\n           DOI 10.17487/RFC3552, July 2003,\n           <https://www.rfc-editor.org/info/rfc3552>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5116]  McGrew, D., \"An Interface and Algorithms for Authenticated\n           Encryption\", RFC 5116, DOI 10.17487/RFC5116, January 2008,\n           <https://www.rfc-editor.org/info/rfc5116>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5869]  Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand\n           Key Derivation Function (HKDF)\", RFC 5869,\n           DOI 10.17487/RFC5869, May 2010,\n           <https://www.rfc-editor.org/info/rfc5869>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6090]  McGrew, D., Igoe, K., and M. Salter, \"Fundamental Elliptic\n           Curve Cryptography Algorithms\", RFC 6090,\n           DOI 10.17487/RFC6090, February 2011,\n           <https://www.rfc-editor.org/info/rfc6090>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6960]  Santesson, S., Myers, M., Ankney, R., Malpani, A.,\n           Galperin, S., and C. Adams, \"X.509 Internet Public Key\n           Infrastructure Online Certificate Status Protocol - OCSP\",\n           RFC 6960, DOI 10.17487/RFC6960, June 2013,\n           <https://www.rfc-editor.org/info/rfc6960>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6979]  Pornin, T., \"Deterministic Usage of the Digital Signature\n           Algorithm (DSA) and Elliptic Curve Digital Signature\n           Algorithm (ECDSA)\", RFC 6979, DOI 10.17487/RFC6979, August\n           2013, <https://www.rfc-editor.org/info/rfc6979>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7252]  Shelby, Z., Hartke, K., and C. Bormann, \"The Constrained\n           Application Protocol (CoAP)\", RFC 7252,\n           DOI 10.17487/RFC7252, June 2014,\n           <https://www.rfc-editor.org/info/rfc7252>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7748]  Langley, A., Hamburg, M., and S. Turner, \"Elliptic Curves\n           for Security\", RFC 7748, DOI 10.17487/RFC7748, January\n           2016, <https://www.rfc-editor.org/info/rfc7748>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7959]  Bormann, C. and Z. Shelby, Ed., \"Block-Wise Transfers in\n           the Constrained Application Protocol (CoAP)\", RFC 7959,\n           DOI 10.17487/RFC7959, August 2016,\n           <https://www.rfc-editor.org/info/rfc7959>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8126]  Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n           Writing an IANA Considerations Section in RFCs\", BCP 26,\n           RFC 8126, DOI 10.17487/RFC8126, June 2017,\n           <https://www.rfc-editor.org/info/rfc8126>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8392]  Jones, M., Wahlstroem, E., Erdtman, S., and H. Tschofenig,\n           \"CBOR Web Token (CWT)\", RFC 8392, DOI 10.17487/RFC8392,\n           May 2018, <https://www.rfc-editor.org/info/rfc8392>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8410]  Josefsson, S. and J. Schaad, \"Algorithm Identifiers for\n           Ed25519, Ed448, X25519, and X448 for Use in the Internet\n           X.509 Public Key Infrastructure\", RFC 8410,\n           DOI 10.17487/RFC8410, August 2018,\n           <https://www.rfc-editor.org/info/rfc8410>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8610]  Birkholz, H., Vigano, C., and C. Bormann, \"Concise Data\n           Definition Language (CDDL): A Notational Convention to\n           Express Concise Binary Object Representation (CBOR) and\n           JSON Data Structures\", RFC 8610, DOI 10.17487/RFC8610,\n           June 2019, <https://www.rfc-editor.org/info/rfc8610>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8613]  Selander, G., Mattsson, J., Palombini, F., and L. Seitz,\n           \"Object Security for Constrained RESTful Environments\n           (OSCORE)\", RFC 8613, DOI 10.17487/RFC8613, July 2019,\n           <https://www.rfc-editor.org/info/rfc8613>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8724]  Minaburo, A., Toutain, L., Gomez, C., Barthel, D., and JC.\n           Zuniga, \"SCHC: Generic Framework for Static Context Header\n           Compression and Fragmentation\", RFC 8724,\n           DOI 10.17487/RFC8724, April 2020,\n           <https://www.rfc-editor.org/info/rfc8724>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8742]  Bormann, C., \"Concise Binary Object Representation (CBOR)\n           Sequences\", RFC 8742, DOI 10.17487/RFC8742, February 2020,\n           <https://www.rfc-editor.org/info/rfc8742>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8747]  Jones, M., Seitz, L., Selander, G., Erdtman, S., and H.\n           Tschofenig, \"Proof-of-Possession Key Semantics for CBOR\n           Web Tokens (CWTs)\", RFC 8747, DOI 10.17487/RFC8747, March\n           2020, <https://www.rfc-editor.org/info/rfc8747>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8949]  Bormann, C. and P. Hoffman, \"Concise Binary Object\n           Representation (CBOR)\", STD 94, RFC 8949,\n           DOI 10.17487/RFC8949, December 2020,\n           <https://www.rfc-editor.org/info/rfc8949>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9052]  Schaad, J., \"CBOR Object Signing and Encryption (COSE):\n           Structures and Process\", STD 96, RFC 9052,\n           DOI 10.17487/RFC9052, August 2022,\n           <https://www.rfc-editor.org/info/rfc9052>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9053]  Schaad, J., \"CBOR Object Signing and Encryption (COSE):\n           Initial Algorithms\", RFC 9053, DOI 10.17487/RFC9053,\n           August 2022, <https://www.rfc-editor.org/info/rfc9053>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9175]  Amsüss, C., Preuß Mattsson, J., and G. Selander,\n           \"Constrained Application Protocol (CoAP): Echo, Request-\n           Tag, and Token Processing\", RFC 9175,\n           DOI 10.17487/RFC9175, February 2022,\n           <https://www.rfc-editor.org/info/rfc9175>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9360]  Schaad, J., \"CBOR Object Signing and Encryption (COSE):\n           Header Parameters for Carrying and Referencing X.509\n           Certificates\", RFC 9360, DOI 10.17487/RFC9360, February\n           2023, <https://www.rfc-editor.org/info/rfc9360>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[Bruni18]  Bruni, A., Sahl Jørgensen, T., Grønbech Petersen, T., and\n           C. Schürmann, \"Formal Verification of Ephemeral Diffie-\n           Hellman Over COSE (EDHOC)\", November 2018,\n           <https://www.springerprofessional.de/en/formal-\n           verification-of-ephemeral-diffie-hellman-over-cose-\n           edhoc/16284348>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[C509-CERTS]\n           Preuß Mattsson, J., Selander, G., Raza, S., Höglund, J.,\n           and M. Furuhed, \"CBOR Encoded X.509 Certificates (C509\n           Certificates)\", Work in Progress, Internet-Draft, draft-\n           ietf-cose-cbor-encoded-cert-09, 4 March 2024,\n           <https://datatracker.ietf.org/doc/html/draft-ietf-cose-\n           cbor-encoded-cert-09>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[CborMe]   Bormann, C., \"CBOR Playground\", <https://cbor.me/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[CNSA]     Wikipedia, \"Commercial National Security Algorithm Suite\",\n           October 2023, <https://en.wikipedia.org/w/index.php?title=\n           Commercial_National_Security_Algorithm_Suite&oldid=1181333\n           611>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[CoAP-SEC-PROT]\n           Mattsson, J. P., Palombini, F., and M. Vučinić,\n           \"Comparison of CoAP Security Protocols\", Work in Progress,\n           Internet-Draft, draft-ietf-iotops-security-protocol-\n           comparison-04, 4 March 2024,\n           <https://datatracker.ietf.org/doc/html/draft-ietf-iotops-\n           security-protocol-comparison-04>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[CottierPointcheval22]\n           Cottier, B. and D. Pointcheval, \"Security Analysis of the\n           EDHOC protocol\", September 2022,\n           <https://arxiv.org/abs/2209.03599>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[CURVE-REPR]\n           Struik, R., \"Alternative Elliptic Curve Representations\",\n           Work in Progress, Internet-Draft, draft-ietf-lwig-curve-\n           representations-23, 21 January 2022,\n           <https://datatracker.ietf.org/doc/html/draft-ietf-lwig-\n           curve-representations-23>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Degabriele11]\n           Degabriele, J., Lehmann, A., Paterson, K., Smart, N., and\n           M. Strefler, \"On the Joint Security of Encryption and\n           Signature in EMV\", December 2011,\n           <https://eprint.iacr.org/2011/615>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[EAT]      Lundblade, L., Mandyam, G., O'Donoghue, J., and C.\n           Wallace, \"The Entity Attestation Token (EAT)\", Work in\n           Progress, Internet-Draft, draft-ietf-rats-eat-25, 15\n           January 2024, <https://datatracker.ietf.org/doc/html/\n           draft-ietf-rats-eat-25>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[EDHOC-CoAP-OSCORE]\n           Palombini, F., Tiloca, M., Höglund, R., Hristozov, S., and\n           G. Selander, \"Using Ephemeral Diffie-Hellman Over COSE\n           (EDHOC) with the Constrained Application Protocol (CoAP)\n           and Object Security for Constrained RESTful Environments\n           (OSCORE)\", Work in Progress, Internet-Draft, draft-ietf-\n           core-oscore-edhoc-10, 29 November 2023,\n           <https://datatracker.ietf.org/doc/html/draft-ietf-core-\n           oscore-edhoc-10>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[GuentherIlunga22]\n           Günther, F. and M. Mukendi, \"Careful with MAc-then-SIGn: A\n           Computational Analysis of the EDHOC Lightweight\n           Authenticated Key Exchange Protocol\", December 2022,\n           <https://eprint.iacr.org/2022/1705>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HEDGED-ECC-SIGS]\n           Preuß Mattsson, J., Thormarker, E., and S. Ruohomaa,\n           \"Hedged ECDSA and EdDSA Signatures\", Work in Progress,\n           Internet-Draft, draft-irtf-cfrg-det-sigs-with-noise-02, 1\n           March 2024, <https://datatracker.ietf.org/doc/html/draft-\n           irtf-cfrg-det-sigs-with-noise-02>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HKDFpaper]\n           Krawczyk, H., \"Cryptographic Extraction and Key\n           Derivation: The HKDF Scheme\", May 2010,\n           <https://eprint.iacr.org/2010/264.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[IEEE.802.15.4-2015]\n           IEEE, \"IEEE Standard for Low-Rate Wireless Networks\",\n           DOI 10.1109/IEEESTD.2016.7460875, April 2016,\n           <https://ieeexplore.ieee.org/document/7460875>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Jacomme23]\n           Jacomme, C., Klein, E., Kremer, S., and M. Racouchot, \"A\n           comprehensive, formal and automated analysis of the EDHOC\n           protocol\", October 2022,\n           <https://hal.inria.fr/hal-03810102/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[KUDOS]    Höglund, R. and M. Tiloca, \"Key Update for OSCORE\n           (KUDOS)\", Work in Progress, Internet-Draft, draft-ietf-\n           core-oscore-key-update-07, 4 March 2024,\n           <https://datatracker.ietf.org/doc/html/draft-ietf-core-\n           oscore-key-update-07>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[LAKE-AUTHZ]\n           Selander, G., Mattsson, J. P., Vučinić, M., Fedrecheski,\n           G., and M. Richardson, \"Lightweight Authorization using\n           Ephemeral Diffie-Hellman Over COSE\", Work in Progress,\n           Internet-Draft, draft-ietf-lake-authz-01, 4 March 2024,\n           <https://datatracker.ietf.org/doc/html/draft-ietf-lake-\n           authz-01>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[LAKE-REQS]\n           Vučinić, M., Selander, G., Preuß Mattsson, J., and D.\n           Garcia-Carillo, \"Requirements for a Lightweight AKE for\n           OSCORE\", Work in Progress, Internet-Draft, draft-ietf-\n           lake-reqs-04, 8 June 2020,\n           <https://datatracker.ietf.org/doc/html/draft-ietf-lake-\n           reqs-04>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[NISTPQC]  National Institute Standards and Technology (NIST), \"Post-\n           Quantum Cryptography FAQs\",\n           <https://csrc.nist.gov/Projects/post-quantum-cryptography/\n           faqs>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Noise]    Perrin, T., \"The Noise Protocol Framework\", Revision 34,\n           July 2018, <https://noiseprotocol.org/noise.html>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Norrman20]\n           Norrman, K., Sundararajan, V., and A. Bruni, \"Formal\n           Analysis of EDHOC Key Establishment for Constrained IoT\n           Devices\", September 2020,\n           <https://arxiv.org/abs/2007.11427>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2986]  Nystrom, M. and B. Kaliski, \"PKCS #10: Certification\n           Request Syntax Specification Version 1.7\", RFC 2986,\n           DOI 10.17487/RFC2986, November 2000,\n           <https://www.rfc-editor.org/info/rfc2986>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n           Housley, R., and W. Polk, \"Internet X.509 Public Key\n           Infrastructure Certificate and Certificate Revocation List\n           (CRL) Profile\", RFC 5280, DOI 10.17487/RFC5280, May 2008,\n           <https://www.rfc-editor.org/info/rfc5280>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6194]  Polk, T., Chen, L., Turner, S., and P. Hoffman, \"Security\n           Considerations for the SHA-0 and SHA-1 Message-Digest\n           Algorithms\", RFC 6194, DOI 10.17487/RFC6194, March 2011,\n           <https://www.rfc-editor.org/info/rfc6194>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7228]  Bormann, C., Ersue, M., and A. Keranen, \"Terminology for\n           Constrained-Node Networks\", RFC 7228,\n           DOI 10.17487/RFC7228, May 2014,\n           <https://www.rfc-editor.org/info/rfc7228>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7258]  Farrell, S. and H. Tschofenig, \"Pervasive Monitoring Is an\n           Attack\", BCP 188, RFC 7258, DOI 10.17487/RFC7258, May\n           2014, <https://www.rfc-editor.org/info/rfc7258>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7296]  Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T.\n           Kivinen, \"Internet Key Exchange Protocol Version 2\n           (IKEv2)\", STD 79, RFC 7296, DOI 10.17487/RFC7296, October\n           2014, <https://www.rfc-editor.org/info/rfc7296>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7624]  Barnes, R., Schneier, B., Jennings, C., Hardie, T.,\n           Trammell, B., Huitema, C., and D. Borkmann,\n           \"Confidentiality in the Face of Pervasive Surveillance: A\n           Threat Model and Problem Statement\", RFC 7624,\n           DOI 10.17487/RFC7624, August 2015,\n           <https://www.rfc-editor.org/info/rfc7624>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8366]  Watsen, K., Richardson, M., Pritikin, M., and T. Eckert,\n           \"A Voucher Artifact for Bootstrapping Protocols\",\n           RFC 8366, DOI 10.17487/RFC8366, May 2018,\n           <https://www.rfc-editor.org/info/rfc8366>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8376]  Farrell, S., Ed., \"Low-Power Wide Area Network (LPWAN)\n           Overview\", RFC 8376, DOI 10.17487/RFC8376, May 2018,\n           <https://www.rfc-editor.org/info/rfc8376>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8446]  Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n           Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n           <https://www.rfc-editor.org/info/rfc8446>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8937]  Cremers, C., Garratt, L., Smyshlyaev, S., Sullivan, N.,\n           and C. Wood, \"Randomness Improvements for Security\n           Protocols\", RFC 8937, DOI 10.17487/RFC8937, October 2020,\n           <https://www.rfc-editor.org/info/rfc8937>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9000]  Iyengar, J., Ed. and M. Thomson, Ed., \"QUIC: A UDP-Based\n           Multiplexed and Secure Transport\", RFC 9000,\n           DOI 10.17487/RFC9000, May 2021,\n           <https://www.rfc-editor.org/info/rfc9000>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9147]  Rescorla, E., Tschofenig, H., and N. Modadugu, \"The\n           Datagram Transport Layer Security (DTLS) Protocol Version\n           1.3\", RFC 9147, DOI 10.17487/RFC9147, April 2022,\n           <https://www.rfc-editor.org/info/rfc9147>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9176]  Amsüss, C., Ed., Shelby, Z., Koster, M., Bormann, C., and\n           P. van der Stok, \"Constrained RESTful Environments (CoRE)\n           Resource Directory\", RFC 9176, DOI 10.17487/RFC9176, April\n           2022, <https://www.rfc-editor.org/info/rfc9176>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9397]  Pei, M., Tschofenig, H., Thaler, D., and D. Wheeler,\n           \"Trusted Execution Environment Provisioning (TEEP)\n           Architecture\", RFC 9397, DOI 10.17487/RFC9397, July 2023,\n           <https://www.rfc-editor.org/info/rfc9397>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9529]  Selander, G., Preuß Mattsson, J., Serafin, M., Tiloca, M.,\n           and M. Vučinić, \"Traces of Ephemeral Diffie-Hellman Over\n           COSE (EDHOC)\", RFC 9529, DOI 10.17487/RFC9529, March 2024,\n           <https://www.rfc-editor.org/info/rfc9529>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SECG]     Certicom Research, \"SEC 1: Elliptic Curve Cryptography\",\n           Standards for Efficient Cryptography, May 2009,\n           <https://www.secg.org/sec1-v2.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SIGMA]    Krawczyk, H., \"SIGMA: the 'SIGn-and-MAc' Approach to\n           Authenticated Diffie-Hellman and Its Use in the IKE-\n           Protocols\", June 2003,\n           <https://www.iacr.org/cryptodb/archive/2003/\n           CRYPTO/1495/1495.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SP-800-108]\n           Chen, L., \"Recommendation for Key Derivation Using\n           Pseudorandom Functions\", NIST Special Publication 800-108\n           Revision 1, DOI 10.6028/NIST.SP.800-108r1-upd1, August\n           2022, <https://doi.org/10.6028/NIST.SP.800-108r1-upd1>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SP-800-56A]\n           Barker, E., Chen, L., Roginsky, A., Vassilev, A., and R.\n           Davis, \"Recommendation for Pair-Wise Key-Establishment\n           Schemes Using Discrete Logarithm Cryptography\",\n           NIST Special Publication 800-56A Revision 3,\n           DOI 10.6028/NIST.SP.800-56Ar3, April 2018,\n           <https://doi.org/10.6028/NIST.SP.800-56Ar3>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SP800-185]\n           Kelsey, J., Chang, S., and R. Perlner, \"SHA-3 Derived\n           Functions cSHAKE, KMAC, TupleHash and ParallelHash\",\n           NIST Special Publication 800-185,\n           DOI 10.6028/NIST.SP.800-185, December 2016,\n           <https://doi.org/10.6028/NIST.SP.800-185>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Thormarker21]\n           Thormarker, E., \"On using the same key pair for Ed25519\n           and an X25519 based KEM\", April 2021,\n           <https://eprint.iacr.org/2021/509.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[THREAT-MODEL-GUIDANCE]\n           Arkko, J. and S. Farrell, \"Internet Threat Model\n           Guidance\", Work in Progress, Internet-Draft, draft-arkko-\n           arch-internet-threat-model-guidance-00, 12 July 2021,\n           <https://datatracker.ietf.org/doc/html/draft-arkko-arch-\n           internet-threat-model-guidance-00>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix A. Use with OSCORE and Transfer over CoAP",
      "section_title": true,
      "ja": "付録A. OSCOREで使用し、COAPで転送します"
    },
    {
      "indent": 3,
      "text": "This appendix describes how to derive an OSCORE security context when EDHOC is used to key OSCORE and how to transfer EDHOC messages over CoAP. The use of CoAP or OSCORE with EDHOC is optional, but if you are using CoAP or OSCORE, then certain normative requirements apply as detailed in the subsections.",
      "ja": "この付録では、EDHOCがキーオスコアに使用されたときにOSCOREセキュリティコンテキストを導き出す方法と、COAPを介してEDHOCメッセージを転送する方法について説明します。EDHOCでのCOAPまたはOSCOREの使用はオプションですが、COAPまたはOSCOREを使用している場合、サブセクションで詳述されているように特定の規範的要件が適用されます。"
    },
    {
      "indent": 0,
      "text": "A.1. Deriving the OSCORE Security Context",
      "section_title": true,
      "ja": "A.1. OSCOREセキュリティコンテキストを導き出す"
    },
    {
      "indent": 3,
      "text": "This section specifies how to use EDHOC output to derive the OSCORE security context.",
      "ja": "このセクションでは、EDHOC出力を使用してOSCOREセキュリティコンテキストを導き出す方法を指定します。"
    },
    {
      "indent": 3,
      "text": "After successful processing of EDHOC message_3, the Client and Server derive Security Context parameters for OSCORE as follows (see Section 3.2 of [RFC8613]):",
      "ja": "EDHOC Message_3の処理が成功した後、クライアントとサーバーは、次のようにOSCOREのセキュリティコンテキストパラメーターを導き出します（[RFC8613]のセクション3.2を参照）："
    },
    {
      "indent": 6,
      "text": "* The Master Secret and Master Salt SHALL be derived by using the EDHOC_Exporter interface (see Section 4.2.1):",
      "ja": "* Master SecretとMaster Saltは、EDHOC_EXPORTERインターフェイスを使用して導出されます（セクション4.2.1を参照）。"
    },
    {
      "indent": 12,
      "text": "- The EDHOC Exporter Labels for deriving the OSCORE Master Secret and OSCORE Master Salt are the uints 0 and 1, respectively.",
      "ja": "- OSCORE Master SecretとOscore Master Saltを導き出すためのEdhoc Exporterラベルは、それぞれUINTS 0と1です。"
    },
    {
      "indent": 12,
      "text": "- The context parameter is h'' (0x40), the empty CBOR byte string.",
      "ja": "- コンテキストパラメーターはH ''（0x40）、空のCborバイト文字列です。"
    },
    {
      "indent": 12,
      "text": "- By default, oscore_key_length is the key length (in bytes) of the application AEAD Algorithm of the selected cipher suite for the EDHOC session. Also by default, oscore_salt_length has value 8. The Initiator and Responder MAY agree out-of-band on a longer oscore_key_length than the default and on shorter or longer than the default oscore_salt_length.",
      "ja": "- デフォルトでは、OSCORE_KEY_LENGTHは、EDHOCセッションの選択した暗号スイートのアプリケーションAEADアルゴリズムのキー長（バイト単位）です。また、デフォルトでは、OSCORE_SALT_LENGTHには値8があります。イニシエーターとレスポンダーは、デフォルトよりも長いOSCORE_KEY_LENGTHで、デフォルトのOSCORE_SALT_LENGTHよりも短または長い帯域で帯域外に同意する場合があります。"
    },
    {
      "indent": 6,
      "text": "Master Secret = EDHOC_Exporter( 0, h'', oscore_key_length )\nMaster Salt   = EDHOC_Exporter( 1, h'', oscore_salt_length )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "* The AEAD Algorithm SHALL be the application AEAD algorithm of the selected cipher suite for the EDHOC session.",
      "ja": "* AEADアルゴリズムは、EDHOCセッション用に選択された暗号スイートのアプリケーションAEADアルゴリズムとするものとします。"
    },
    {
      "indent": 6,
      "text": "* The HKDF Algorithm SHALL be the one based on the application hash algorithm of the selected cipher suite for the EDHOC session. For example, if SHA-256 is the application hash algorithm of the selected cipher suite, HKDF SHA-256 is used as the HKDF Algorithm in the OSCORE Security Context.",
      "ja": "* HKDFアルゴリズムは、EDHOCセッション用に選択した暗号スイートのアプリケーションハッシュアルゴリズムに基づいたものとするものとします。たとえば、SHA-256が選択した暗号スイートのアプリケーションハッシュアルゴリズムである場合、HKDF SHA-256はOSCOREセキュリティコンテキストのHKDFアルゴリズムとして使用されます。"
    },
    {
      "indent": 6,
      "text": "* The relationship between identifiers in OSCORE and EDHOC is specified in Section 3.3.3. The OSCORE Sender ID and Recipient ID SHALL be determined by EDHOC connection identifiers C_R and C_I for the EDHOC session as shown in Table 14.",
      "ja": "* OSCOREとEDHOCの識別子間の関係は、セクション3.3.3で指定されています。OSCORE送信者IDおよび受信者IDは、表14に示すように、EDHOCセッションのEDHOC接続識別子C_RおよびC_Iによって決定されるものとします。"
    },
    {
      "indent": 7,
      "text": "+=================+==================+=====================+\n|                 | OSCORE Sender ID | OSCORE Recipient ID |\n+=================+==================+=====================+\n| EDHOC Initiator |       C_R        |         C_I         |\n+-----------------+------------------+---------------------+\n| EDHOC Responder |       C_I        |         C_R         |\n+-----------------+------------------+---------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Table 14: Usage of Connection Identifiers in OSCORE",
      "ja": "表14：OSCOREの接続識別子の使用"
    },
    {
      "indent": 3,
      "text": "The Client and Server SHALL use the parameters above to establish an OSCORE Security Context, as per Section 3.2.1 of [RFC8613].",
      "ja": "クライアントとサーバーは、上記のパラメーターを使用して、[RFC8613]のセクション3.2.1に従って、OSCOREセキュリティコンテキストを確立するものとします。"
    },
    {
      "indent": 3,
      "text": "From then on, the Client and Server retrieve the OSCORE protocol state using the Recipient ID and optionally other transport information such as the 5-tuple.",
      "ja": "それ以降、クライアントとサーバーは、受信者IDおよびオプションで5タプルなどの他のトランスポート情報を使用してOSCOREプロトコル状態を取得します。"
    },
    {
      "indent": 0,
      "text": "A.2. Transferring EDHOC over CoAP",
      "section_title": true,
      "ja": "A.2. EdhocをCoapに転送します"
    },
    {
      "indent": 3,
      "text": "This section specifies how EDHOC can be transferred as an exchange of CoAP [RFC7252] messages. CoAP provides a reliable transport that can preserve packet ordering, provides flow and congestion control, and handles message duplication. CoAP can also perform fragmentation and mitigate certain denial-of-service attacks. The underlying CoAP transport should be used in reliable mode, in particular, when fragmentation is used, to avoid, e.g., situations with hanging endpoints waiting for each other.",
      "ja": "このセクションでは、EDHOCをCOAP [RFC7252]メッセージの交換として転送する方法を指定します。COAPは、パケットの順序を維持できる信頼できる輸送を提供し、フローと輻輳制御を提供し、メッセージの複製を処理します。COAPは断片化を実行し、特定のサービス拒否攻撃を軽減することもできます。基礎となるCOAP輸送は、特に断片化が使用されるときに信頼できるモードで使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "EDHOC may run with the Initiator either being a CoAP client or CoAP server. We denote the former by the \"forward message flow\" (see Appendix A.2.1) and the latter by the \"reverse message flow\" (see Appendix A.2.2). By default, we assume the forward message flow, but the roles SHOULD be chosen to protect the most sensitive identity; see Section 9.",
      "ja": "EDHOCは、イニシエーターがCOAPクライアントまたはCOAPサーバーであることを実行することができます。「フォワードメッセージフロー」（付録A.2.1を参照）で前者を示し、後者は「リバースメッセージフロー」（付録A.2.2を参照）で示します。デフォルトでは、フォワードメッセージフローを想定していますが、最も敏感なアイデンティティを保護するために役割を選択する必要があります。セクション9を参照してください。"
    },
    {
      "indent": 3,
      "text": "According to this specification, EDHOC is transferred in POST requests to the Uri-Path: \"/.well-known/edhoc\" (see Section 10.7) and 2.04 (Changed) responses. An application may define its own path that can be discovered, e.g., using a resource directory [RFC9176]. Client applications can use the resource type \"core.edhoc\" to discover a server's EDHOC resource, i.e., where to send a request for executing the EDHOC protocol; see Section 10.10. An alternative transfer of the forward message flow is specified in [EDHOC-CoAP-OSCORE].",
      "ja": "この仕様によれば、EdhocはURI-Pathへの郵便リクエストで転送されます： \"/.well-nking/edhoc\"（セクション10.7を参照）および2.04（変更）応答。アプリケーションは、リソースディレクトリ[RFC9176]を使用して、発見できる独自のパスを定義する場合があります。クライアントアプリケーションは、リソースタイプ「core.edhoc」を使用して、サーバーのEDHOCリソース、つまりEDHOCプロトコルの実行のリクエストを送信する場所を発見できます。セクション10.10を参照してください。前方メッセージフローの代替転送は、[Edhoc-Coap-Oscore]で指定されています。"
    },
    {
      "indent": 3,
      "text": "In order for the server to correlate a message received from a client to a message previously sent in the same EDHOC session over CoAP, messages sent by the client SHALL be prepended with the CBOR serialization of the connection identifier that the server has selected; see Section 3.4.1. This applies both to the forward and the reverse message flows. To indicate a new EDHOC session in the forward message flow, message_1 SHALL be prepended with the CBOR simple value true (0xf5). Even if CoAP is carried over a reliable transport protocol, such as TCP, the prepending of identifiers specified here SHALL be practiced to enable interoperability independent of how CoAP is transported.",
      "ja": "サーバーがクライアントから受信したメッセージをCOAPで同じEDHOCセッションで以前に送信したメッセージに相関させるために、クライアントが送信したメッセージは、サーバーが選択した接続識別子のCBORシリアル化で準備されます。セクション3.4.1を参照してください。これは、フォワードと逆メッセージの両方に適用されます。フォワードメッセージフローで新しいEDHOCセッションを示すために、Message_1はCBOR Simple Value True（0xF5）で準備されなければなりません。COAPがTCPなどの信頼できる輸送プロトコルに携帯されている場合でも、COAPの輸送方法とは無関係に相互運用性を可能にするために、ここで指定された識別子の準備が実践されます。"
    },
    {
      "indent": 3,
      "text": "The prepended identifiers are encoded in CBOR and thus self-delimiting. The representation of identifiers described in Section 3.3.2 SHALL be used. They are sent in front of the actual EDHOC message to keep track of messages in an EDHOC session, and only the part of the body following the identifier is used for EDHOC processing. In particular, the connection identifiers within the EDHOC messages are not impacted by the prepended identifiers.",
      "ja": "優先された識別子はCBORでエンコードされているため、自己削除されます。セクション3.3.2で説明した識別子の表現を使用するものとします。それらは、実際のEDHOCメッセージの前で送信され、EDHOCセッションでメッセージを追跡するため、識別子に続く身体の部分のみがEDHOC処理に使用されます。特に、EDHOCメッセージ内の接続識別子は、準備された識別子の影響を受けません。"
    },
    {
      "indent": 3,
      "text": "An EDHOC message has media type \"application/edhoc+cbor-seq\", whereas an EDHOC message prepended by a connection identifier has media type \"application/cid-edhoc+cbor-seq\"; see Section 10.9.",
      "ja": "EDHOCメッセージには、メディアタイプの「アプリケーション/EDHOC+CBOR-SEQ」がありますが、接続識別子によって準備されたEDHOCメッセージにはメディアタイプ「Application/CID-EDHOC+CBOR-SEQ」があります。セクション10.9を参照してください。"
    },
    {
      "indent": 3,
      "text": "To mitigate certain denial-of-service attacks, the CoAP server MAY respond to the first POST request with a 4.01 (Unauthorized) containing an Echo option [RFC9175]. This forces the Initiator to demonstrate reachability at its apparent network address. If message fragmentation is needed, the EDHOC messages may be fragmented using the CoAP Block-Wise Transfer mechanism [RFC7959].",
      "ja": "特定のサービス拒否攻撃を緩和するために、COAPサーバーは、エコーオプション[RFC9175]を含む4.01（不正）で最初のPOSTリクエストに応答する場合があります。これにより、イニシエーターは、見かけのネットワークアドレスで到達可能性を実証するようになります。メッセージの断片化が必要な場合、EDHOCメッセージは、COAPブロックごとの転送メカニズム[RFC7959]を使用して断片化される場合があります。"
    },
    {
      "indent": 3,
      "text": "EDHOC error messages need to be transported in response to a message that failed (see Section 6). EDHOC error messages transported with CoAP are carried in the payload.",
      "ja": "EDHOCエラーメッセージは、失敗したメッセージに応じて輸送する必要があります（セクション6を参照）。COAPで輸送されたEDHOCエラーメッセージは、ペイロード内で運ばれます。"
    },
    {
      "indent": 3,
      "text": "Note that the transport over CoAP can serve as a blueprint for other client-server protocols:",
      "ja": "COAP上のトランスポートは、他のクライアントサーバープロトコルの青写真として機能することに注意してください。"
    },
    {
      "indent": 6,
      "text": "* The client prepends the connection identifier selected by the server (or, for message_1, the CBOR simple value true) to any request message it sends.",
      "ja": "* クライアントは、サーバーによって選択された接続識別子（または、message_1の場合は、CBOR Simple値がTrue）を送信する任意のリクエストメッセージにプリケンドします。"
    },
    {
      "indent": 6,
      "text": "* The server does not send any such indicator, as responses are matched to request by the client-server protocol design.",
      "ja": "* クライアントサーバープロトコル設計によるリクエストに応答が一致するため、サーバーはそのようなインジケーターを送信しません。"
    },
    {
      "indent": 0,
      "text": "A.2.1. The Forward Message Flow",
      "section_title": true,
      "ja": "A.2.1. フォワードメッセージフロー"
    },
    {
      "indent": 3,
      "text": "In the forward message flow, the CoAP client is the Initiator and the CoAP server is the Responder. This flow protects the client identity against active attackers and the server identity against passive attackers.",
      "ja": "フォワードメッセージフローでは、COAPクライアントがイニシエーターであり、COAPサーバーはレスポンダーです。このフローは、アクティブな攻撃者からクライアントのアイデンティティを保護し、パッシブ攻撃者からサーバーのアイデンティティを保護します。"
    },
    {
      "indent": 3,
      "text": "In the forward message flow, the CoAP Token enables correlation on the Initiator (client) side, and the prepended C_R enables correlation on the Responder (server) side.",
      "ja": "フォワードメッセージフローでは、COAPトークンはイニシエーター（クライアント）側での相関を有効にし、再配置されたC_Rはレスポンダー（サーバー）側で相関を有効にします。"
    },
    {
      "indent": 6,
      "text": "* EDHOC message_1 is sent in the payload of a POST request from the client to the server's resource for EDHOC, prepended with the identifier true (0xf5), indicating a new EDHOC session.",
      "ja": "* EDHOC Message_1は、クライアントからEDHOCのサーバーのリソースへのPOSTリクエストのペイロードで送信され、識別子True（0xF5）で準備され、新しいEDHOCセッションを示します。"
    },
    {
      "indent": 6,
      "text": "* EDHOC message_2 or the EDHOC error message is sent from the server to the client in the payload of the response, in the former case with response code 2.04 (Changed) and in the latter with response code as specified in Appendix A.2.3.",
      "ja": "* EDHOC Message_2またはEDHOCエラーメッセージは、応答コード2.04（変更）の前者の場合、応答のペイロード、および付録A.2.3で指定された応答コードを使用して、応答コード（変更）の場合、クライアントにサーバーから送信されます。"
    },
    {
      "indent": 6,
      "text": "* EDHOC message_3 or the EDHOC error message is sent from the client to the server's resource in the payload of a POST request, prepended with connection identifier C_R.",
      "ja": "* EDHOC Message_3またはEDHOCエラーメッセージは、接続識別子C_Rで準備されたPOSTリクエストのペイロードで、クライアントからサーバーのリソースに送信されます。"
    },
    {
      "indent": 6,
      "text": "* If EDHOC message_4 is used, or in case of an error message, it is sent from the server to the client in the payload of the response, with response codes analogously to message_2. In case of an error message sent in response to message_4, it is sent analogously to the error message sent in response to message_2.",
      "ja": "* EDHOC Message_4が使用されている場合、またはエラーメッセージの場合は、応答コードがmessage_2と同様に、応答コードを使用して、応答のペイロードでサーバーからクライアントに送信されます。message_4に応じて送信されたエラーメッセージの場合、message_2に応じて送信されたエラーメッセージに類似して送信されます。"
    },
    {
      "indent": 3,
      "text": "An example of a completed EDHOC session over CoAP in the forward message flow is shown in Figure 10.",
      "ja": "フォワードメッセージフローのCOAPを介したEDHOCセッションが完了した例を図10に示します。"
    },
    {
      "indent": 7,
      "text": "Client    Server\n  |          |\n  +--------->| Header: POST (Code=0.02)\n  |   POST   | Uri-Path: \"/.well-known/edhoc\"\n  |          | Content-Format: application/cid-edhoc+cbor-seq\n  |          | Payload: true, EDHOC message_1\n  |          |\n  |<---------+ Header: 2.04 Changed\n  |   2.04   | Content-Format: application/edhoc+cbor-seq\n  |          | Payload: EDHOC message_2\n  |          |\n  +--------->| Header: POST (Code=0.02)\n  |   POST   | Uri-Path: \"/.well-known/edhoc\"\n  |          | Content-Format: application/cid-edhoc+cbor-seq\n  |          | Payload: C_R, EDHOC message_3\n  |          |\n  |<---------+ Header: 2.04 Changed\n  |   2.04   | Content-Format: application/edhoc+cbor-seq\n  |          | Payload: EDHOC message_4\n  |          |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 10: Example of the Forward Message Flow",
      "ja": "図10：フォワードメッセージフローの例"
    },
    {
      "indent": 3,
      "text": "The forward message flow of EDHOC can be combined with an OSCORE exchange in a total of two round trips; see [EDHOC-CoAP-OSCORE].",
      "ja": "Edhocのフォワードメッセージフローは、合計2回の往復でOSCORE Exchangeと組み合わせることができます。[edhoc-coap-oscore]を参照してください。"
    },
    {
      "indent": 0,
      "text": "A.2.2. The Reverse Message Flow",
      "section_title": true,
      "ja": "A.2.2. 逆メッセージフロー"
    },
    {
      "indent": 3,
      "text": "In the reverse message flow, the CoAP client is the Responder and the CoAP server is the Initiator. This flow protects the server identity against active attackers and the client identity against passive attackers.",
      "ja": "逆のメッセージフローでは、CoAPクライアントがレスポンダーであり、COAPサーバーはイニシエーターです。このフローは、アクティブな攻撃者からサーバーのアイデンティティを保護し、パッシブ攻撃者からクライアントのアイデンティティを保護します。"
    },
    {
      "indent": 3,
      "text": "In the reverse message flow, the CoAP Token enables correlation on the Responder (client) side, and the prepended C_I enables correlation on the Initiator (server) side.",
      "ja": "逆メッセージフローでは、COAPトークンはレスポンダー（クライアント）側の相関を有効にし、Preagended C_Iはイニシエーター（サーバー）側の相関を有効にします。"
    },
    {
      "indent": 6,
      "text": "* To trigger a new EDHOC session, the client makes an empty POST request to the server's resource for EDHOC.",
      "ja": "* 新しいEDHOCセッションをトリガーするために、クライアントはEDHOCのサーバーのリソースに空のPOSTリクエストを行います。"
    },
    {
      "indent": 6,
      "text": "* EDHOC message_1 is sent from the server to the client in the payload of the response with response code 2.04 (Changed).",
      "ja": "* EDHOC Message_1は、応答コード2.04（変更）を使用して、応答のペイロードでサーバーからクライアントに送信されます。"
    },
    {
      "indent": 6,
      "text": "* EDHOC message_2 or the EDHOC error message is sent from the client to the server's resource in the payload of a POST request, prepended with connection identifier C_I.",
      "ja": "* EDHOC Message_2またはEDHOCエラーメッセージは、接続識別子C_Iで準備されたPOSTリクエストのペイロードで、クライアントからサーバーのリソースに送信されます。"
    },
    {
      "indent": 6,
      "text": "* EDHOC message_3 or the EDHOC error message is sent from the server to the client in the payload of the response, in the former case with response code 2.04 (Changed) and in the latter with response code as specified in Appendix A.2.3.",
      "ja": "* EDHOC Message_3またはEDHOCエラーメッセージは、応答コード2.04（変更）の前者の場合、応答のペイロード、および付録A.2.3で指定されている応答コードを使用して、応答のペイロードでクライアントにサーバーから送信されます。"
    },
    {
      "indent": 6,
      "text": "* If EDHOC message_4 is used, or in case of an error message, it is sent from the client to the server's resource in the payload of a POST request, prepended with connection identifier C_I. In case of an error message sent in response to message_4, it is sent analogously to an error message sent in response to message_2.",
      "ja": "* EDHOC Message_4が使用されている場合、またはエラーメッセージの場合は、接続識別子C_Iで準備されたPOSTリクエストのペイロードで、クライアントからサーバーのリソースに送信されます。message_4に応じて送信されたエラーメッセージの場合、message_2に応じて送信されたエラーメッセージに類似して送信されます。"
    },
    {
      "indent": 3,
      "text": "An example of a completed EDHOC session over CoAP in the reverse message flow is shown in Figure 11.",
      "ja": "逆メッセージフローのCOAPを介したEDHOCセッションが完了した例を図11に示します。"
    },
    {
      "indent": 7,
      "text": "Client    Server\n  |          |\n  +--------->| Header: POST (Code=0.02)\n  |   POST   | Uri-Path: \"/.well-known/edhoc\"\n  |          |\n  |<---------+ Header: 2.04 Changed\n  |   2.04   | Content-Format: application/edhoc+cbor-seq\n  |          | Payload: EDHOC message_1\n  |          |\n  +--------->| Header: POST (Code=0.02)\n  |   POST   | Uri-Path: \"/.well-known/edhoc\"\n  |          | Content-Format: application/cid-edhoc+cbor-seq\n  |          | Payload: C_I, EDHOC message_2\n  |          |\n  |<---------+ Header: 2.04 Changed\n  |   2.04   | Content-Format: application/edhoc+cbor-seq\n  |          | Payload: EDHOC message_3\n  |          |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 11: Example of the Reverse Message Flow",
      "ja": "図11：逆メッセージフローの例"
    },
    {
      "indent": 0,
      "text": "A.2.3. Errors in EDHOC over CoAP",
      "section_title": true,
      "ja": "A.2.3. COAP上のEDHOCのエラー"
    },
    {
      "indent": 3,
      "text": "When using EDHOC over CoAP, EDHOC error messages sent as CoAP responses MUST be sent in the payload of error responses, i.e., they MUST specify a CoAP error response code. In particular, it is RECOMMENDED that such error responses have response code either 4.00 (Bad Request) in case of client error (e.g., due to a malformed EDHOC message) or 5.00 (Internal Server Error) in case of server error (e.g., due to failure in deriving EDHOC keying material). The Content-Format of the error response MUST be set to \"application/ edhoc+cbor-seq\"; see Section 10.9.",
      "ja": "EDHOCをCOAPで使用する場合、COAP応答として送信されるEDHOCエラーメッセージは、エラー応答のペイロードで送信する必要があります。つまり、COAPエラー応答コードを指定する必要があります。特に、このようなエラー応答には、クライアントエラーの場合（例えば、EDHOCメッセージの不正されたため）、サーバーエラーの場合（例えば、期限が来る期限がある場合）、クライアントエラーの場合の応答コード（悪い要求）のいずれかを持つことをお勧めします。edhocキーイング材料の導出に失敗します）。エラー応答のコンテンツ形式は、「アプリケーション/ edhoc+cbor-seq」に設定する必要があります。セクション10.9を参照してください。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Compact Representation",
      "section_title": true,
      "ja": "付録B. コンパクトな表現"
    },
    {
      "indent": 3,
      "text": "This section defines a format for compact representation based on the Elliptic-Curve-Point-to-Octet-String Conversion defined in Section 2.3.3 of [SECG].",
      "ja": "このセクションでは、[SECG]のセクション2.3.3で定義されている楕円曲線ポイントからOCTET-STRING変換に基づいたコンパクト表現の形式を定義します。"
    },
    {
      "indent": 3,
      "text": "As described in Section 4.2 of [RFC6090], the x-coordinate of an elliptic curve public key is a suitable representative for the entire point whenever scalar multiplication is used as a one-way function. One example is ECDH with compact output, where only the x-coordinate of the computed value is used as the shared secret.",
      "ja": "[RFC6090]のセクション4.2で説明されているように、楕円曲線の公共鍵のX座標は、スカラー乗算が一方向関数として使用されるたびに、ポイント全体に適した代表者です。1つの例は、コンパクトな出力を持つECDHで、計算値のX座標のみが共有秘密として使用されます。"
    },
    {
      "indent": 3,
      "text": "In EDHOC, compact representation is used for the ephemeral public keys (G_X and G_Y); see Section 3.7. Using the notation from [SECG], the output is an octet string of length ceil( (log2 q) / 8 ), where ceil(x) is the smallest integer not less than x. See [SECG] for a definition of q, M, X, xp, and ~yp. The steps in Section 2.3.3 of [SECG] are replaced with the following steps:",
      "ja": "EDHOCでは、一時的なパブリックキー（G_XおよびG_Y）にコンパクトな表現が使用されます。セクション3.7を参照してください。[secg]の表記法を使用すると、出力は長さのシルのオクテット文字列（（log2 q） / 8）です。ここで、ceil（x）はx以上の最小の整数です。q、m、x、xp、および〜ypの定義については、[secg]を参照してください。[SECG]のセクション2.3.3の手順は、次の手順に置き換えられます。"
    },
    {
      "indent": 8,
      "text": "1. Convert the field element xp to an octet string X of length ceil( (log2 q) / 8 ) octets using the conversion routine specified in Section 2.3.5 of [SECG].",
      "ja": "1. [secg]のセクション2.3.5で指定された変換ルーチンを使用して、フィールド要素xpを長さの天井（（log2 q） / 8）のオクテットのオクテット文字列xに変換します。"
    },
    {
      "indent": 8,
      "text": "2. Output M = X.",
      "ja": "2. 出力m = x。"
    },
    {
      "indent": 3,
      "text": "The encoding of the point at infinity is not supported.",
      "ja": "無限でのポイントのエンコードはサポートされていません。"
    },
    {
      "indent": 3,
      "text": "Compact representation does not change any requirements on validation; see Section 9.2. Using compact representation has some security benefits. An implementation does not need to check that the point is not the point at infinity (the identity element). Similarly, as not even the sign of the y-coordinate is encoded, compact representation trivially avoids so-called \"benign malleability\" attacks where an attacker changes the sign; see [SECG].",
      "ja": "コンパクトな表現は、検証の要件を変更しません。セクション9.2を参照してください。コンパクトな表現を使用するには、セキュリティの利点があります。実装では、ポイントが無限のポイント（ID要素）ではないことを確認する必要はありません。同様に、Y座標の兆候でさえエンコードされていないため、コンパクトな表現は、攻撃者がサインを変更する場合、いわゆる「良性閉鎖」攻撃を些細なことに回避します。[secg]を参照してください。"
    },
    {
      "indent": 3,
      "text": "The following may be needed for validation or compatibility with APIs that do not support compact representation or do not support the full [SECG] format:",
      "ja": "コンパクトな表現をサポートしていない、または完全な[secg]形式をサポートしないAPIとの検証または互換性には、以下が必要になる場合があります。"
    },
    {
      "indent": 6,
      "text": "* If a compressed y-coordinate is required, then the value ~yp set to zero can be used. In such a case, the compact representation described above can be transformed into the Standards for Efficient Cryptography Group (SECG) point-compressed format by prepending it with the single byte 0x02 (i.e., M = 0x02 || X).",
      "ja": "* 圧縮されたY座標が必要な場合、ゼロに設定された値〜ypを使用できます。このような場合、上記のコンパクトな表現は、単一バイト0x02（つまり、m = 0x02 || x）でそれを準備することにより、効率的な暗号化グループ（SECG）ポイント圧縮形式の標準に変換できます。"
    },
    {
      "indent": 6,
      "text": "* If an uncompressed y-coordinate is required, then a y-coordinate has to be calculated following Section 2.3.4 of [SECG] or Appendix C of [RFC6090]. Any of the square roots (see [SECG] or [RFC6090]) can be used. The uncompressed SECG format is M = 0x04 || X || Y.",
      "ja": "* 圧縮されていないY座標が必要な場合は、[secg]のセクション2.3.4または[RFC6090]の付録Cに従ってy座標を計算する必要があります。正方形の根（[secg]または[rfc6090]を参照）を使用できます。非圧縮SECG形式はM = 0x04 ||ですx ||Y."
    },
    {
      "indent": 3,
      "text": "For example: The curve P-256 has the parameters (using the notation in [RFC6090]):",
      "ja": "たとえば、曲線P-256にはパラメーターがあります（[RFC6090]の表記を使用）："
    },
    {
      "indent": 6,
      "text": "* p = 2^256 - 2^224 + 2^192 + 2^96 - 1",
      "ja": "* p = 2^256-2^224 + 2^192 + 2^96-1"
    },
    {
      "indent": 6,
      "text": "* a = -3",
      "ja": "* A = -3"
    },
    {
      "indent": 6,
      "text": "* b = 410583637251521421293261297800472684091144410159937255 54835256314039467401291",
      "ja": "* B = 410583637251521421293261297800472684091144410159937255 54835256314039467401291"
    },
    {
      "indent": 3,
      "text": "Given an example x:",
      "ja": "Xの例を与えられます："
    },
    {
      "indent": 6,
      "text": "* x = 115792089183396302095546807154740558443406795108653336 398970697772788799766525",
      "ja": "* X = 11579208918339630209554680715474055844340679510865336 3989706977727278888888888888888888888825"
    },
    {
      "indent": 3,
      "text": "We can calculate y as the square root w = (x^3 + a ⋅ x + b)^((p + 1)/4) (mod p).",
      "ja": "yを平方根w =（x^3 +a⋅x + b）^（（p + 1）/4）（mod p）として計算できます。"
    },
    {
      "indent": 6,
      "text": "* y = 834387180070192806820075864918626005281451259964015754 16632522940595860276856",
      "ja": "* Y = 83438718007019280682007586491862600528145125996401575416325222940595860276856"
    },
    {
      "indent": 3,
      "text": "Note that this does not guarantee that (x, y) is on the correct elliptic curve. A full validation according to Section 5.6.2.3.3 of [SP-800-56A] is done by also checking that 0 ≤ x < p and that y^2 ≡ x^3 + a ⋅ x + b (mod p).",
      "ja": "これは、（x、y）が正しい楕円曲線上にあることを保証しないことに注意してください。[SP-800-56A]のセクション5.6.2.3.3に従って完全な検証は、0≤x<pとy^2≡x^3 +a⋅x + b（mod p）をチェックすることによって行われます。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Use of CBOR, CDDL, and COSE in EDHOC",
      "section_title": true,
      "ja": "付録C. EdhocでのCBOR、CDDL、およびCOSEの使用"
    },
    {
      "indent": 3,
      "text": "This appendix is intended to help implementors not familiar with CBOR [RFC8949], CDDL [RFC8610], COSE [RFC9052], and HKDF [RFC5869].",
      "ja": "この付録は、CBOR [RFC8949]、CDDL [RFC8610]、COSE [RFC9052]、およびHKDF [RFC5869]に精通していない実装者を支援することを目的としています。"
    },
    {
      "indent": 0,
      "text": "C.1. CBOR and CDDL",
      "section_title": true,
      "ja": "C.1. CBORおよびCDDL"
    },
    {
      "indent": 3,
      "text": "The Concise Binary Object Representation (CBOR) [RFC8949] is a data format designed for small code size and small message size. CBOR builds on the JSON data model but extends it by, e.g., encoding binary data directly without base64 conversion. In addition to the binary CBOR encoding, CBOR also has a diagnostic notation that is readable and editable by humans. The Concise Data Definition Language (CDDL) [RFC8610] provides a way to express structures for protocol messages and APIs that use CBOR. [RFC8610] also extends the diagnostic notation.",
      "ja": "簡潔なバイナリオブジェクト表現（CBOR）[RFC8949]は、小さなコードサイズと小さなメッセージサイズに合わせて設計されたデータ形式です。CBORはJSONデータモデルに基づいて構築されますが、たとえば、Base64変換なしでバイナリデータを直接エンコードすることで拡張します。Binary CBORエンコーディングに加えて、CBORには人間が読みやすく編集可能な診断表記もあります。簡潔なデータ定義言語（CDDL）[RFC8610]は、CBORを使用するプロトコルメッセージとAPIの構造を表現する方法を提供します。[RFC8610]も診断表記を拡張します。"
    },
    {
      "indent": 3,
      "text": "CBOR data items are encoded to or decoded from byte strings using a type-length-value encoding scheme, where the three highest order bits of the initial byte contain information about the major type. CBOR supports several types of data items, integers (int, uint), simple values, byte strings (bstr), and text strings (tstr). CBOR also supports arrays [] of data items, maps {} of pairs of data items, and sequences [RFC8742] of data items. Some examples are given below.",
      "ja": "CBORデータ項目は、タイプ長価値エンコードスキームを使用してバイト文字列にエンコードまたはデコードされます。ここで、初期バイトの3つの最高次数ビットには主要なタイプに関する情報が含まれています。CBORは、いくつかのタイプのデータ項目、Integer（Int、UINT）、単純な値、バイト文字列（BSTR）、およびテキスト文字列（TSTR）をサポートしています。CBORは、データ項目の配列[]、データ項目のペアのマップ{}、およびデータ項目のシーケンス[RFC8742]をサポートしています。いくつかの例を以下に示します。"
    },
    {
      "indent": 3,
      "text": "The EDHOC specification sometimes use CDDL names in CBOR diagnostic notation as in, e.g., << ID_CRED_R, ? EAD_2 >>. This means that EAD_2 is optional and that ID_CRED_R and EAD_2 should be substituted with their values before evaluation. That is, if ID_CRED_R = { 4 : h'' } and EAD_2 is omitted, then << ID_CRED_R, ? EAD_2 >> = << { 4 : h'' } >>, which encodes to 0x43a10440. We also make use of the occurrence symbol \"*\", like in, e.g., 2* int, meaning two or more CBOR integers.",
      "ja": "EDHOCの仕様では、<< ID_CRED_Rなどのように、CBOR診断表記でCDDL名を使用することがあります。EAD_2 >>。これは、EAD_2がオプションであり、ID_CRED_RとEAD_2を評価前に値に置き換える必要があることを意味します。つまり、ID_CRED_R = {4：H ''}とEAD_2が省略されている場合、<< ID_CRED_R、？ead_2 >> = << {4：h ''} >>は、0x43a10440にエンコードします。また、2* intなど、2つ以上のcbor整数のように、発生記号「*」を使用します。"
    },
    {
      "indent": 3,
      "text": "For a complete specification and more examples, see [RFC8949] and [RFC8610]. We recommend implementors get used to CBOR by using the CBOR playground [CborMe].",
      "ja": "完全な仕様とその他の例については、[RFC8949]および[RFC8610]を参照してください。CBOR Playground [Cborme]を使用して、実装者がCBORに慣れることをお勧めします。"
    },
    {
      "indent": 10,
      "text": "+==================+==============+==================+\n| Diagnostic       | Encoded      | Type             |\n+==================+==============+==================+\n| 1                | 0x01         | unsigned integer |\n+------------------+--------------+------------------+\n| 24               | 0x1818       | unsigned integer |\n+------------------+--------------+------------------+\n| -24              | 0x37         | negative integer |\n+------------------+--------------+------------------+\n| -25              | 0x3818       | negative integer |\n+------------------+--------------+------------------+\n| true             | 0xf5         | simple value     |\n+------------------+--------------+------------------+\n| h''              | 0x40         | byte string      |\n+------------------+--------------+------------------+\n| h'12cd'          | 0x4212cd     | byte string      |\n+------------------+--------------+------------------+\n| '12cd'           | 0x4431326364 | byte string      |\n+------------------+--------------+------------------+\n| \"12cd\"           | 0x6431326364 | text string      |\n+------------------+--------------+------------------+\n| { 4 : h'cd' }    | 0xa10441cd   | map              |\n+------------------+--------------+------------------+\n| << 1, 2, true >> | 0x430102f5   | byte string      |\n+------------------+--------------+------------------+\n| [ 1, 2, true ]   | 0x830102f5   | array            |\n+------------------+--------------+------------------+\n| ( 1, 2, true )   | 0x0102f5     | sequence         |\n+------------------+--------------+------------------+\n| 1, 2, true       | 0x0102f5     | sequence         |\n+------------------+--------------+------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Table 15: Examples of Use of CBOR and CDDL",
      "ja": "表15：CBORおよびCDDLの使用例"
    },
    {
      "indent": 0,
      "text": "C.2. CDDL Definitions",
      "section_title": true,
      "ja": "C.2. CDDL定義"
    },
    {
      "indent": 3,
      "text": "This section compiles the CDDL definitions for ease of reference.",
      "ja": "このセクションは、参照を容易にするためにCDDL定義をコンパートします。"
    },
    {
      "indent": 3,
      "text": "suites = [ 2* int ] / int\n\nead = (\n  ead_label : int,\n  ? ead_value : bstr,\n)\n\nEAD_1 = 1* ead\nEAD_2 = 1* ead\nEAD_3 = 1* ead\nEAD_4 = 1* ead\n\nmessage_1 = (\n  METHOD : int,\n  SUITES_I : suites,\n  G_X : bstr,\n  C_I : bstr / -24..23,\n  ? EAD_1,\n)\n\nmessage_2 = (\n  G_Y_CIPHERTEXT_2 : bstr,\n)\n\nPLAINTEXT_2 = (\n  C_R,\n  ID_CRED_R : map / bstr / -24..23,\n  Signature_or_MAC_2 : bstr,\n  ? EAD_2,\n)\n\nmessage_3 = (\n  CIPHERTEXT_3 : bstr,\n)\n\nPLAINTEXT_3 = (\n  ID_CRED_I : map / bstr / -24..23,\n  Signature_or_MAC_3 : bstr,\n  ? EAD_3,\n)\n\nmessage_4 = (\n  CIPHERTEXT_4 : bstr,\n)\n\nPLAINTEXT_4 = (\n  ? EAD_4,\n)\n\nerror = (\n  ERR_CODE : int,\n  ERR_INFO : any,\n)\n\ninfo = (\n  info_label : int,\n  context : bstr,\n  length : uint,\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.3. COSE",
      "section_title": true,
      "ja": "C.3. コセ"
    },
    {
      "indent": 3,
      "text": "CBOR Object Signing and Encryption (COSE) [RFC9052] describes how to create and process signatures, MACs, and encryptions using CBOR. COSE builds on JSON Object Signing and Encryption (JOSE) but is adapted to allow more efficient processing in constrained devices. EDHOC makes use of COSE_Key, COSE_Encrypt0, and COSE_Sign1 objects in the message processing:",
      "ja": "CBORオブジェクトの署名と暗号化（COSE）[RFC9052]は、CBORを使用して署名、Mac、および暗号化を作成および処理する方法について説明します。COSEは、JSONオブジェクトの署名と暗号化（Jose）に基づいて構築されていますが、制約付きデバイスでのより効率的な処理を可能にするように適合しています。Edhocは、メッセージ処理でcose_key、cose_encrypt0、およびcose_sign1オブジェクトを使用しています。"
    },
    {
      "indent": 6,
      "text": "* ECDH ephemeral public keys of type EC2 or OKP in message_1 and message_2 consist of the COSE_Key parameter named 'x'; see Sections 7.1 and 7.2 of [RFC9053].",
      "ja": "* ecdh ecdhは、メッセージ_1およびmessage_2のタイプEC2またはokpのパブリックキーを 'x'という名前のcose_keyパラメーターで構成しています。[RFC9053]のセクション7.1および7.2を参照してください。"
    },
    {
      "indent": 6,
      "text": "* The ciphertexts in message_3 and message_4 consist of a subset of the single recipient encrypted data object COSE_Encrypt0, which is described in Sections 5.2 and 5.3 of [RFC9052]. The ciphertext is computed over the plaintext and associated data, using an encryption key and an initialization vector. The associated data is an Enc_structure consisting of protected headers and externally supplied data (external_aad). COSE constructs the input to the AEAD [RFC5116] for message_i (i = 3 or 4; see Sections 5.4 and 5.5, respectively) as follows:",
      "ja": "* message_3およびmessage_4のciphertextsは、[RFC9052]のセクション5.2および5.3で説明されている単一のレシピエント暗号化されたデータオブジェクトCOSE_ENCRYPT0のサブセットで構成されています。暗号文は、暗号化キーと初期化ベクトルを使用して、プレーンテキストおよび関連データを介して計算されます。関連するデータは、保護されたヘッダーと外部で提供されたデータ（external_aad）で構成されるenc_structureです。COSEは、次のように、message_i（i = 3または4;それぞれセクション5.4および5.5を参照）のAEAD [RFC5116]への入力を構築します。"
    },
    {
      "indent": 12,
      "text": "- Secret key K = K_i",
      "ja": "- シークレットキーk = k_i"
    },
    {
      "indent": 12,
      "text": "- Nonce N = IV_i",
      "ja": "- nonce n = iv_i"
    },
    {
      "indent": 12,
      "text": "- Plaintext P for message_i",
      "ja": "- message_iのPlantext P"
    },
    {
      "indent": 12,
      "text": "- Associated Data A = [ \"Encrypt0\", h'', TH_i ]",
      "ja": "- 関連データa = [\"encrypt0\"、h ''、th_i]"
    },
    {
      "indent": 6,
      "text": "* Signatures in message_2 of method 0 and 2, and in message_3 of method 0 and 1, consist of a subset of the single signer data object COSE_Sign1, which is described in Sections 4.2 and 4.4 of [RFC9052]. The signature is computed over a Sig_structure containing payload, protected headers and externally supplied data (external_aad) using a private signature key, and verified using the corresponding public signature key. For COSE_Sign1, the message to be signed is:",
      "ja": "* 方法0および2のMessage_2、および方法0および1のMessage_3の署名は、[RFC9052]のセクション4.2および4.4で説明されている単一の署名者データオブジェクトCOSE_SIGN1のサブセットで構成されています。署名は、プライベート署名キーを使用して、ペイロード、保護されたヘッダー、および外部から提供されたデータ（外部_AAD）を含むSIG_STRUCTUREを介して計算され、対応するパブリックシグネチャキーを使用して検証されます。cose_sign1の場合、署名されるメッセージは次のとおりです。"
    },
    {
      "indent": 4,
      "text": "[ \"Signature1\", protected, external_aad, payload ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "where protected, external_aad, and payload are specified in Sections 5.3 and 5.4.",
      "ja": "保護されている場合、外部_AAD、およびペイロードは、セクション5.3および5.4で指定されています。"
    },
    {
      "indent": 3,
      "text": "Different header parameters to identify X.509 or C509 certificates by reference are defined in [RFC9360] and [C509-CERTS]:",
      "ja": "参照によりX.509またはC509証明書を識別するさまざまなヘッダーパラメーターは、[RFC9360]および[C509-CERTS]で定義されています。"
    },
    {
      "indent": 6,
      "text": "* by a hash value with the 'x5t' or 'c5t' parameters, respectively:",
      "ja": "* それぞれ「x5t」または「c5t」パラメーターを使用したハッシュ値によって："
    },
    {
      "indent": 12,
      "text": "- ID_CRED_x = { 34 : COSE_CertHash }, for x = I or R and",
      "ja": "- id_cred_x = {34：cose_certhash}、x = iまたはr and and"
    },
    {
      "indent": 12,
      "text": "- ID_CRED_x = { 22 : COSE_CertHash }, for x = I or R,",
      "ja": "- id_cred_x = {22：cose_certhash}、x = iまたはrの場合、"
    },
    {
      "indent": 6,
      "text": "* or by a URI with the 'x5u' or 'c5u' parameters, respectively:",
      "ja": "* または、それぞれ「X5U」または「C5U」パラメーターを備えたURIによる："
    },
    {
      "indent": 12,
      "text": "- ID_CRED_x = { 35 : uri }, for x = I or R, and",
      "ja": "- id_cred_x = {35：uri}、x = i or r、および"
    },
    {
      "indent": 12,
      "text": "- ID_CRED_x = { 23 : uri }, for x = I or R.",
      "ja": "- id_cred_x = {23：uri}、x = iまたはRの場合"
    },
    {
      "indent": 3,
      "text": "When ID_CRED_x does not contain the actual credential, it may be very short, e.g., if the endpoints have agreed to use a key identifier parameter 'kid':",
      "ja": "ID_CRED_Xに実際の資格情報が含まれていない場合、エンドポイントがキー識別子パラメーター「KID」を使用することに同意した場合、非常に短い場合があります。"
    },
    {
      "indent": 6,
      "text": "* ID_CRED_x = { 4 : kid_x }, where kid_x : kid, for x = I or R. For further optimization, see Section 3.5.3.",
      "ja": "* id_cred_x = {4：kid_x}、ここでkid_x：kid、x = iまたはRの場合、さらに最適化するには、セクション3.5.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Note that ID_CRED_x can contain several header parameters, for example, { x5u, x5t } or { kid, kid_context }.",
      "ja": "ID_CRED_Xには、{x5u、x5t}または{kid、kid_context}など、いくつかのヘッダーパラメーターが含まれることに注意してください。"
    },
    {
      "indent": 3,
      "text": "ID_CRED_x MAY also identify the credential by value. For example, a certificate chain can be transported in an ID_CRED field with COSE header parameter c5c or x5chain, as defined in [C509-CERTS] and [RFC9360]. Credentials of type CWT and CCS can be transported with the COSE header parameters registered in Section 10.6.",
      "ja": "ID_CRED_Xは、値によって資格情報を識別することもできます。たとえば、[C509-Certs]および[RFC9360]で定義されているように、COSEヘッダーパラメーターC5CまたはX5Chainを備えたID_CREDフィールドで証明書チェーンを輸送できます。タイプCWTおよびCCSの資格情報は、セクション10.6に登録されているCOSEヘッダーパラメーターで輸送できます。"
    },
    {
      "indent": 0,
      "text": "Appendix D. Authentication-Related Verifications",
      "section_title": true,
      "ja": "付録D. 認証関連の検証"
    },
    {
      "indent": 3,
      "text": "EDHOC performs certain authentication-related operations (see Section 3.5), but in general, it is necessary to make additional verifications beyond EDHOC message processing. Which verifications that are needed depend on the deployment, in particular, the trust model and the security policies, but most commonly, it can be expressed in terms of verifications of credential content.",
      "ja": "EDHOCは特定の認証関連操作を実行します（セクション3.5を参照）が、一般的には、EDHOCメッセージ処理を超えて追加の検証を行う必要があります。必要な検証は、展開、特に信頼モデルとセキュリティポリシーに依存しますが、最も一般的には、資格コンテンツの検証に関して表現できます。"
    },
    {
      "indent": 3,
      "text": "EDHOC assumes the existence of mechanisms (certification authority or other trusted third party, pre-provisioning, etc.) for generating and distributing authentication credentials and other credentials, as well as the existence of trust anchors (CA certificates, trusted public keys, etc.). For example, a public key certificate or CWT may rely on a trusted third party whose public key is pre-provisioned, whereas a CCS or a self-signed certificate / CWT may be used when trust in the public key can be achieved by other means, or in the case of trust on first use, see Appendix D.5.",
      "ja": "Edhocは、認証資格情報やその他の資格情報を生成および配布するためのメカニズム（認定機関またはその他の信頼できる第三者、事前把握など）の存在、および信頼アンカーの存在（CA証明書、信頼できるパブリックキーなどの存在を想定しています。）。たとえば、公開鍵の証明書またはCWTは、公開鍵が事前に生成されている信頼できる第三者に依存する場合がありますが、CCSまたは自己署名証明書 / CWTは、公開鍵の信頼を他の手段で達成できる場合に使用できます。、または最初の使用に関する信頼の場合は、付録D.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "In this section, we provide some examples of such verifications. These verifications are the responsibility of the application but may be implemented as part of an EDHOC library.",
      "ja": "このセクションでは、このような検証の例をいくつか説明します。これらの検証はアプリケーションの責任ですが、EDHOCライブラリの一部として実装される場合があります。"
    },
    {
      "indent": 0,
      "text": "D.1. Validating the Authentication Credential",
      "section_title": true,
      "ja": "D.1. 認証資格情報の検証"
    },
    {
      "indent": 3,
      "text": "In addition to the authentication key, the authentication credential may contain other parameters that need to be verified. For example:",
      "ja": "認証キーに加えて、認証資格情報には、検証する必要がある他のパラメーターが含まれる場合があります。例えば："
    },
    {
      "indent": 6,
      "text": "* In X.509 and C509 certificates, signature keys typically have key usage \"digitalSignature\", and Diffie-Hellman public keys typically have key usage \"keyAgreement\" [RFC3279] [RFC8410].",
      "ja": "* X.509およびC509証明書では、署名キーは通常、「DigitalSignature」という重要な使用法を備えており、Diffie-Hellmanのパブリックキーは通常、キー使用法「キーアグメント」[RFC3279] [RFC8410]です。"
    },
    {
      "indent": 6,
      "text": "* In X.509 and C509 certificates, validity is expressed using Not After and Not Before. In CWT and CCS, the \"exp\" and \"nbf\" claims have similar meanings.",
      "ja": "* X.509およびC509証明書では、妥当性は、後ではないか以前ではないことを使用して表現されます。CWTおよびCCSでは、「EXP」と「NBF」クレームには同様の意味があります。"
    },
    {
      "indent": 0,
      "text": "D.2. Identities",
      "section_title": true,
      "ja": "D.2. アイデンティティ"
    },
    {
      "indent": 3,
      "text": "The application must decide on allowing a connection or not, depending on the intended endpoint, and in particular whether it is a specific identity or in a set of identities. To prevent misbinding attacks, the identity of the endpoint is included in a MAC verified through the protocol. More details and examples are provided in this section.",
      "ja": "アプリケーションは、意図したエンドポイント、特に特定のアイデンティティであるか、一連のアイデンティティであるかに応じて、接続を許可するかどうかを決定する必要があります。誤った攻撃を防ぐために、エンドポイントのアイデンティティは、プロトコルを通じて検証されたMACに含まれています。このセクションでは、詳細と例を示します。"
    },
    {
      "indent": 3,
      "text": "Policies for what connections to allow are typically set based on the identity of the other endpoint, and endpoints typically only allow connections from a specific identity or a small restricted set of identities. For example, in the case of a device connecting to a network, the network may only allow connections from devices that authenticate with certificates having a particular range of serial numbers and signed by a particular CA. Conversely, a device may only be allowed to connect to a network that authenticates with a particular public key.",
      "ja": "通常、他のエンドポイントのアイデンティティに基づいて許可される接続のポリシーは、通常、特定のIDまたは小さな制限付きアイデンティティからの接続のみを許可します。たとえば、ネットワークに接続するデバイスの場合、ネットワークは、特定の範囲のシリアル番号を持つ証明書で認証され、特定のCAによって署名されたデバイスからの接続のみを許可する場合があります。逆に、デバイスは、特定の公開キーで認証するネットワークにのみ接続できる場合があります。"
    },
    {
      "indent": 6,
      "text": "* When a Public Key Infrastructure (PKI) is used with certificates, the identity is the subject whose unique name, e.g., a domain name, a Network Access Identifier (NAI), or an Extended Unique Identifier (EUI), is included in the endpoint's certificate.",
      "ja": "* 公開キーインフラストラクチャ（PKI）が証明書で使用される場合、アイデンティティは、ドメイン名、ネットワークアクセス識別子（NAI）、または拡張ユニークな識別子（EUI）などの一意の名前、例えば、エンドポイントに含まれている主題です。証明書。"
    },
    {
      "indent": 6,
      "text": "* Similarly, when a PKI is used with CWTs, the identity is the subject identified by the relevant claim(s), such as 'sub' (subject).",
      "ja": "* 同様に、PKIがCWTSで使用される場合、アイデンティティは、「sub」（サブジェクト）などの関連する請求によって識別される主題です。"
    },
    {
      "indent": 6,
      "text": "* When PKI is not used (e.g., CCS, self-signed certificate / CWT), the identity is typically directly associated with the authentication key of the other party. For example, if identities can be expressed in the form of unique subject names assigned to public keys, then a binding to identity is achieved by including both the public key and associated subject name in the authentication credential. CRED_I or CRED_R may be a self-signed certificate / CWT or CCS containing the authentication key and the subject name; see Section 3.5.2. Thus, each endpoint needs to know the specific authentication key / unique associated subject name or set of public authentication keys / unique associated subject names, which it is allowed to communicate with.",
      "ja": "* PKIが使用されない場合（CCS、自己署名証明書 / CWTなど）、IDは通常、相手の認証キーに直接関連付けられます。たとえば、IDがパブリックキーに割り当てられた一意の主題名の形で表現できる場合、認証資格に公開キーと関連するサブジェクト名の両方を含めることにより、IDへの拘束力が達成されます。CRED_IまたはCRED_Rは、認証キーと件名を含む自己署名証明書 / CWTまたはCCSです。セクション3.5.2を参照してください。したがって、各エンドポイントは、特定の認証キー /ユニークな関連サブジェクト名またはパブリック認証キー /一意の関連する主題名のセットを知る必要があります。"
    },
    {
      "indent": 3,
      "text": "To prevent misbinding attacks in systems where an attacker can register public keys without proving knowledge of the private key, SIGMA [SIGMA] enforces a MAC to be calculated over the \"identity\". EDHOC follows SIGMA by calculating a MAC over the whole authentication credential, which in case of an X.509 or C509 certificate, includes the \"subject\" and \"subjectAltName\" fields and, in the case of CWT or CCS, includes the \"sub\" claim.",
      "ja": "攻撃者が秘密鍵の知識を証明せずにパブリックキーを登録できるシステムでの誤った攻撃を防ぐために、Sigma [Sigma]は、「ID」で計算されるMacを実施します。Edhocは、X.509またはC509証明書の場合、「サブジェクト」および「件名」フィールドを含む認証資格情報全体でMacを計算することによりSigmaに従います。請求。"
    },
    {
      "indent": 3,
      "text": "(While the SIGMA paper only focuses on the identity, the same principle is true for other information such as policies associated with the public key.)",
      "ja": "（シグマペーパーはアイデンティティにのみ焦点を当てていますが、公開鍵に関連するポリシーなどの他の情報にも同じ原則が当てはまります。）"
    },
    {
      "indent": 0,
      "text": "D.3. Certification Path and Trust Anchors",
      "section_title": true,
      "ja": "D.3. 認定パスと信頼のアンカー"
    },
    {
      "indent": 3,
      "text": "When a Public Key Infrastructure (PKI) is used with certificates, the trust anchor is a certification authority (CA) certificate. Each party needs at least one CA public key certificate or just the CA public key. The certification path contains proof that the subject of the certificate owns the public key in the certificate. Only validated public key certificates are to be accepted.",
      "ja": "公開キーインフラストラクチャ（PKI）が証明書で使用される場合、Trust Anchorは認証機関（CA）証明書です。各当事者には、少なくとも1つのCA公開キー証明書またはCAの公開キーだけが必要です。認定パスには、証明書の主題が証明書に公開キーを所有していることの証拠が含まれています。検証された公開鍵証明書のみが受け入れられます。"
    },
    {
      "indent": 3,
      "text": "Similarly, when a PKI is used with CWTs, each party needs to have at least one trusted third-party public key as a trust anchor to verify the end entity CWTs. The trusted third-party public key can, e.g., be stored in a self-signed CWT or in a CCS.",
      "ja": "同様に、PKIがCWTSで使用される場合、各当事者には、最終エンティティCWTを検証するための信頼アンカーとして、少なくとも1つの信頼できるサードパーティ公開鍵が必要です。たとえば、信頼できるサードパーティの公開鍵は、自己署名CWTまたはCCSに保存することができます。"
    },
    {
      "indent": 3,
      "text": "The signature of the authentication credential needs to be verified with the public key of the issuer. X.509 and C509 certificates includes the \"Issuer\" field. In CWT and CCS, the \"iss\" claim has a similar meaning. The public key is either a trust anchor or the public key in another valid and trusted credential in a certification path from the trust anchor to the authentication credential.",
      "ja": "認証資格情報の署名は、発行者の公開鍵で検証する必要があります。X.509およびC509証明書には、「発行者」フィールドが含まれます。CWTおよびCCSでは、「ISS」クレームにも同様の意味があります。公開鍵は、信頼アンカーから認証資格情報までの認定パスにおける別の有効かつ信頼できる資格情報のトラストアンカーまたは公開鍵のいずれかです。"
    },
    {
      "indent": 3,
      "text": "Similar verifications as made with the authentication credential (see Appendix D.1) are also needed for the other credentials in the certification path.",
      "ja": "認証資格情報（付録D.1を参照）で行われた同様の検証は、認証パスの他の資格情報にも必要です。"
    },
    {
      "indent": 3,
      "text": "When PKI is not used (CCS and self-signed certificate / CWT), the trust anchor is the authentication key of the other party; in which case, there is no certification path.",
      "ja": "PKIが使用されない場合（CCSおよび自己署名証明書 / CWT）、トラストアンカーは相手の認証キーです。その場合、認証パスはありません。"
    },
    {
      "indent": 0,
      "text": "D.4. Revocation Status",
      "section_title": true,
      "ja": "D.4. 取り消しステータス"
    },
    {
      "indent": 3,
      "text": "The application may need to verify that the credentials are not revoked; see Section 9.8. Some use cases may be served by short-lived credentials, for example, where the validity of the credential is on par with the interval between revocation checks. But, in general, credential lifetime and revocation checking are complementary measures to control credential status. Revocation information may be transported as External Authorization Data (EAD); see Appendix E.",
      "ja": "アプリケーションは、資格情報が取り消されていないことを確認する必要がある場合があります。セクション9.8を参照してください。一部のユースケースには、短命の資格情報が提供される場合があります。たとえば、資格の妥当性は取り消しチェック間の間隔と同等です。しかし、一般に、資格の生涯と取り消しチェックは、資格のステータスを制御するための補完的な尺度です。取り消し情報は、外部認証データ（EAD）として輸送される場合があります。付録Eを参照してください。"
    },
    {
      "indent": 0,
      "text": "D.5. Unauthenticated Operation",
      "section_title": true,
      "ja": "D.5. 認証されていない操作"
    },
    {
      "indent": 3,
      "text": "EDHOC might be used without authentication by allowing the Initiator or Responder to communicate with any identity except its own. Note that EDHOC without mutual authentication is vulnerable to active on-path attacks and therefore unsafe for general use. However, it is possible to later establish a trust relationship with an unknown or not-yet-trusted endpoint. Some examples are listed below:",
      "ja": "EDHOCは、イニシエーターまたはレスポンダーが独自のアイデンティティを除くアイデンティティと通信できるようにすることにより、認証なしで使用される場合があります。相互認証のないEDHOCは、積極的なオンパス攻撃に対して脆弱であり、したがって一般的な使用に安全ではないことに注意してください。ただし、後で未知のまたはまだ信頼されていないエンドポイントとの信頼関係を確立することができます。いくつかの例を以下に示します。"
    },
    {
      "indent": 6,
      "text": "* The EDHOC authentication credential can be verified out-of-band at a later stage.",
      "ja": "* EDHOC認証資格情報は、後の段階でバンド外で検証できます。"
    },
    {
      "indent": 6,
      "text": "* The EDHOC session key can be bound to an identity out-of-band at a later stage.",
      "ja": "* EDHOCセッションキーは、後の段階でアイデンティティにバンドにバインドできます。"
    },
    {
      "indent": 6,
      "text": "* Trust on first use (TOFU) can be used to verify that several EDHOC connections are made to the same identity. TOFU combined with proximity is a common IoT deployment model that provides good security if done correctly. Note that secure proximity based on short range wireless technology requires very low signal strength or very low latency.",
      "ja": "* 最初の使用（豆腐）の信頼を使用して、いくつかのEDHOC接続が同じアイデンティティに対して行われていることを確認できます。豆腐と近接性を組み合わせることは、正しく行われれば適切なセキュリティを提供する一般的なIoT展開モデルです。短距離ワイヤレステクノロジーに基づく安全な近接性には、非常に低い信号強度または非常に低いレイテンシが必要であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "Appendix E. Use of External Authorization Data",
      "section_title": true,
      "ja": "付録E. 外部認証データの使用"
    },
    {
      "indent": 3,
      "text": "In order to reduce the number of messages and round trips, or to simplify processing, external security applications may be integrated into EDHOC by transporting related external authorization data (EAD) in the messages.",
      "ja": "メッセージの数とラウンドトリップの数を減らすため、または処理を簡素化するために、メッセージ内の関連する外部認証データ（EAD）を輸送することにより、外部セキュリティアプリケーションをEDHOCに統合できます。"
    },
    {
      "indent": 3,
      "text": "The EAD format is specified in Section 3.8. This section contains examples and further details of how EAD may be used with an appropriate accompanying specification.",
      "ja": "EAD形式は、セクション3.8で指定されています。このセクションには、適切な付随する仕様でEADがどのように使用されるかの例と詳細が含まれています。"
    },
    {
      "indent": 6,
      "text": "* One example is third-party-assisted authorization, requested with EAD_1, and an authorization artifact (\"voucher\", cf. [RFC8366]) returned in EAD_2; see [LAKE-AUTHZ].",
      "ja": "* 1つの例は、ead_1で要求されたサードパーティ支援承認と、ead_2で返された承認アーティファクト（「バウチャー」、[rfc8366]をcf. [rfc8366]）であることです。[Lake-Authz]を参照してください。"
    },
    {
      "indent": 6,
      "text": "* Another example is remote attestation, requested in EAD_2, and an Entity Attestation Token (EAT) [EAT] returned in EAD_3.",
      "ja": "* 別の例は、EAD_2で要求されたリモートの認証と、EAD_3で返されたエンティティの証明トークン（EAT）[EAT]です。"
    },
    {
      "indent": 6,
      "text": "* A third example is certificate enrollment, where a Certificate Signing Request (CSR) [RFC2986] is included in EAD_3, and the issued public key certificate (X.509 [RFC5280] and C509 [C509-CERTS]) or a reference thereof is returned in EAD_4.",
      "ja": "* 3番目の例は証明書の登録です。証明書署名要求（CSR）[RFC2986]がEAD_3に含まれ、発行された公開鍵証明書（X.509 [RFC5280]およびC509 [C509-CERTS]）またはその参照が返されます。EAD_4で。"
    },
    {
      "indent": 3,
      "text": "External authorization data should be considered unprotected by EDHOC, and the protection of EAD is the responsibility of the security application (third-party authorization, remote attestation, certificate enrollment, etc.). The security properties of the EAD fields (after EDHOC processing) are discussed in Section 9.1.",
      "ja": "外部認証データはEDHOCによって保護されていないと見なされる必要があり、EADの保護はセキュリティアプリケーションの責任です（サードパーティの認可、リモート証明、証明書登録など）。EADフィールドのセキュリティプロパティ（EDHOC処理後）については、セクション9.1で説明します。"
    },
    {
      "indent": 3,
      "text": "The content of the EAD field may be used in the EDHOC processing of the message in which they are contained. For example, authentication-related information, like assertions and revocation information, transported in EAD fields may provide input about trust anchors or validity of credentials relevant to the authentication processing. The EAD fields (like ID_CRED fields) are therefore made available to the application before the message is verified; see details of message processing in Section 5. In the first example above, a voucher in EAD_2 made available to the application can enable the Initiator to verify the identity or the public key of the Responder before verifying the signature. An application allowing EAD fields containing authentication information thus may need to handle authentication-related verifications associated with EAD processing.",
      "ja": "EADフィールドの内容は、それらが含まれているメッセージのEDHOC処理で使用できます。たとえば、認証関連情報（アサーションや取り消し情報など）は、EADフィールドで輸送される可能性があり、認証処理に関連する資格情報の信頼アンカーまたは妥当性に関する入力を提供する場合があります。したがって、EADフィールド（ID_CREDフィールドなど）は、メッセージが検証される前にアプリケーションで利用可能になります。セクション5のメッセージ処理の詳細を参照してください。上記の最初の例では、アプリケーションで利用可能になったEAD_2のバウチャーを使用すると、署名を確認する前にイニシエーターがResponderのIDまたは公開キーを確認できます。したがって、認証情報を含むEADフィールドを許可するアプリケーションは、EAD処理に関連する認証関連の検証を処理する必要がある場合があります。"
    },
    {
      "indent": 3,
      "text": "Conversely, the security application may need to wait for EDHOC message verification to complete. In the third example above, the validation of a CSR carried in EAD_3 is not started by the Responder before EDHOC has successfully verified message_3 and proven the possession of the private key of the Initiator.",
      "ja": "逆に、セキュリティアプリケーションは、EDHOCメッセージの確認が完了するまで待つ必要がある場合があります。上記の3番目の例では、EDHOCがMessage_3を正常に検証し、イニシエーターの秘密鍵の所有を証明する前に、EAD_3で運ばれるCSRの検証はレスポンダーによって開始されません。"
    },
    {
      "indent": 3,
      "text": "The security application may reuse EDHOC protocol fields that therefore need to be available to the application. For example, the security application may use the same crypto algorithms as in the EDHOC session and therefore needs access to the selected cipher suite (or the whole SUITES_I). The application may use the ephemeral public keys G_X and G_Y as ephemeral keys or as nonces; see [LAKE-AUTHZ].",
      "ja": "したがって、セキュリティアプリケーションはEDHOCプロトコルフィールドを再利用する場合があります。したがって、アプリケーションで利用できる必要があります。たとえば、セキュリティアプリケーションは、EDHOCセッションと同じ暗号アルゴリズムを使用する場合があるため、選択した暗号スイート（またはsuites_i全体）にアクセスする必要があります。アプリケーションは、はかない公共キーG_XおよびG_Yを短命キーとして、またはNoncesとして使用する場合があります。[Lake-Authz]を参照してください。"
    },
    {
      "indent": 3,
      "text": "The processing of the EAD item (ead_label, ? ead_value) by the security application needs to be described in the specification where the ead_label is registered (see Section 10.5), including the optional ead_value for each message and actions in case of errors. An application may support multiple security applications that make use of EAD, which may result in multiple EAD items in one EAD field; see Section 3.8. Any dependencies on security applications with previously registered EAD items need to be documented, and the processing needs to consider their simultaneous use.",
      "ja": "セキュリティアプリケーションによるEADアイテム（ead_label、？ead_value）の処理は、ead_labelが登録されている仕様（セクション10.5を参照）で説明する必要があります。アプリケーションは、EADを使用する複数のセキュリティアプリケーションをサポートする場合があり、1つのEADフィールドに複数のEADアイテムが表示される場合があります。セクション3.8を参照してください。以前に登録されたEADアイテムを備えたセキュリティアプリケーションへの依存関係を文書化する必要があり、処理は同時使用を考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "Since data carried in EAD may not be protected, or processed by the application before the EDHOC message is verified, special considerations need to be made such that it does not violate security and privacy requirements of the service that uses this data; see Section 9.5. The content in an EAD item may impact the security properties provided by EDHOC. Security applications making use of the EAD items must perform the necessary security analysis.",
      "ja": "EADで運ばれたデータは、EDHOCメッセージが検証される前にアプリケーションによって保護されていないか、アプリケーションによって処理される可能性があるため、このデータを使用するサービスのセキュリティとプライバシー要件に違反しないように特別な考慮事項を作成する必要があります。セクション9.5を参照してください。EADアイテムのコンテンツは、EDHOCが提供するセキュリティプロパティに影響を与える可能性があります。EADアイテムを使用するセキュリティアプリケーションは、必要なセキュリティ分析を実行する必要があります。"
    },
    {
      "indent": 0,
      "text": "Appendix F. Application Profile Example",
      "section_title": true,
      "ja": "付録F. アプリケーションプロファイルの例"
    },
    {
      "indent": 3,
      "text": "This appendix contains a rudimentary example of an application profile; see Section 3.9.",
      "ja": "この付録には、アプリケーションプロファイルの初歩的な例が含まれています。セクション3.9を参照してください。"
    },
    {
      "indent": 3,
      "text": "For use of EDHOC with application X, the following assumptions are made:",
      "ja": "アプリケーションXでEDHOCを使用するために、次の仮定が行われます。"
    },
    {
      "indent": 8,
      "text": "1. Transfer in CoAP as specified in Appendix A.2 with requests expected by the CoAP server (= Responder) at /app1-edh, no Content-Format needed.",
      "ja": "1. 付録A.2で指定されたCoAPで転送します。CoAPサーバー（= Responder）AT /APP1-EDHが予想している場合、コンテンツフォーマットは必要ありません。"
    },
    {
      "indent": 8,
      "text": "2. METHOD = 1 (I uses signature key; R uses static DH key.)",
      "ja": "2. 方法= 1（署名キーを使用します。Rは静的DHキーを使用します。）"
    },
    {
      "indent": 8,
      "text": "3. CRED_I is an IEEE 802.1AR Initial Device Identifier (IDevID) encoded as a C509 certificate of type 0 [C509-CERTS].",
      "ja": "3. CRED_Iは、IEEE 802.1AR初期デバイス識別子（IDEVID）であり、タイプ0のC509証明書[C509-CERTS]としてエンコードされています。"
    },
    {
      "indent": 14,
      "text": "* R acquires CRED_I out-of-band, indicated in EAD_1.",
      "ja": "* rは、ead_1に示されているcred_iを取得します。"
    },
    {
      "indent": 14,
      "text": "* ID_CRED_I = {4: h''} is a 'kid' with the value of the empty CBOR byte string.",
      "ja": "* id_cred_i = {4：h ''}は、空のcborバイト文字列の値を持つ「子供」です。"
    },
    {
      "indent": 8,
      "text": "4. CRED_R is a CCS of type OKP as specified in Section 3.5.2.",
      "ja": "4. CRED_Rは、セクション3.5.2で指定されているタイプOKPのCCSです。"
    },
    {
      "indent": 14,
      "text": "* The CBOR map has parameters 1 (kty), -1 (crv), and -2 (x-coordinate).",
      "ja": "* CBORマップには、パラメーター1（KTY）、-1（CRV）、および-2（X座標）があります。"
    },
    {
      "indent": 14,
      "text": "* ID_CRED_R is {14 : CCS}.",
      "ja": "* ID_CRED_Rは{14：CCS}です。"
    },
    {
      "indent": 8,
      "text": "5. External authorization data is defined and processed as specified in [LAKE-AUTHZ].",
      "ja": "5. 外部認証データは、[lake-authz]で指定されているように定義および処理されます。"
    },
    {
      "indent": 8,
      "text": "6. EUI-64 is used as the identity of the endpoint (see an example in Section 3.5.2).",
      "ja": "6. EUI-64は、エンドポイントのアイデンティティとして使用されます（セクション3.5.2の例を参照）。"
    },
    {
      "indent": 8,
      "text": "7. No use of message_4. The application sends protected messages from R to I.",
      "ja": "7. message_4の使用はありません。アプリケーションは、保護されたメッセージをRからIに送信します。"
    },
    {
      "indent": 0,
      "text": "Appendix G. Long PLAINTEXT_2",
      "section_title": true,
      "ja": "付録G. Long Plantext_2"
    },
    {
      "indent": 3,
      "text": "By the definition of encryption of PLAINTEXT_2 with KEYSTREAM_2, it is limited to lengths of PLAINTEXT_2 not exceeding the output of EDHOC_KDF; see Section 4.1.2. If the EDHOC hash algorithm is SHA-2, then HKDF-Expand is used, which limits the length of the EDHOC_KDF output to 255 ⋅ hash_length, where hash_length is the length of the output of the EDHOC hash algorithm given by the cipher suite. For example, with SHA-256 as the EDHOC hash algorithm, the length of the hash output is 32 bytes and the maximum length of PLAINTEXT_2 is 255 ⋅ 32 = 8160 bytes.",
      "ja": "KeyStream_2を使用したPlantext_2の暗号化の定義により、EDHOC_KDFの出力を超えないPlantext_2の長さに制限されています。セクション4.1.2を参照してください。EDHOCハッシュアルゴリズムがSHA-2である場合、HKDF-Expandが使用されます。これにより、EDHOC_KDF出力の長さが255⋅Hash_Lengthに制限されます。ここで、Hash_LengthはCipher Suiteによって与えられたEDHOCハッシュアルゴリズムの出力の長さです。たとえば、SHA-256はEDHOCハッシュアルゴリズムとして、ハッシュ出力の長さは32バイトで、Plaintext_2の最大長は255⋅32= 8160バイトです。"
    },
    {
      "indent": 3,
      "text": "While PLAINTEXT_2 is expected to be much shorter than 8 kB for the intended use cases, it seems nevertheless prudent to specify a solution for the event that this should turn out to be a limitation.",
      "ja": "Plaintext_2は、意図したユースケースでは8 kbよりもはるかに短くなると予想されますが、それでもこれが制限であることが判明するイベントのソリューションを指定することは賢明のようです。"
    },
    {
      "indent": 3,
      "text": "A potential work-around is to use a cipher suite with a different hash function. In particular, the use of KMAC removes all practical limitations in this respect.",
      "ja": "潜在的なワークアラウンドは、異なるハッシュ機能を備えた暗号スイートを使用することです。特に、KMACの使用は、この点ですべての実際的な制限を削除します。"
    },
    {
      "indent": 3,
      "text": "This section specifies a solution that works with any hash function by making use of multiple invocations of HKDF-Expand and negative values of info_label.",
      "ja": "このセクションでは、hkdf-expandの複数の呼び出しとinfo_labelの負の値を使用することにより、任意のハッシュ関数で動作するソリューションを指定します。"
    },
    {
      "indent": 3,
      "text": "Consider the PLAINTEXT_2 partitioned in parts P(i) of length equal to M = 255 ⋅ hash_length, except possibly the last part P(last), which has 0 < length ≤ M.",
      "ja": "M =255⋅Hash_Lengthに等しい長さの部分P（i）に分割されたPlaintext_2を考えてみましょう。"
    },
    {
      "indent": 3,
      "text": "PLAINTEXT_2 = P(0) | P(1) | ... | P(last)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where \"|\" indicates concatenation.",
      "ja": "ここで「|」連結を示します。"
    },
    {
      "indent": 3,
      "text": "The object is to define a matching KEYSTREAM_2 of the same length and perform the encryption in the same way as defined in Section 5.3.2:",
      "ja": "オブジェクトは、同じ長さの一致するキーストリーム_2を定義し、セクション5.3.2で定義されているのと同じ方法で暗号化を実行することです。"
    },
    {
      "indent": 3,
      "text": "CIPHERTEXT_2 = PLAINTEXT_2 XOR KEYSTREAM_2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Define the keystream as:",
      "ja": "キーストリームを次のように定義します。"
    },
    {
      "indent": 3,
      "text": "KEYSTREAM_2 = OKM(0) | OKM(1)  | ... | OKM(last)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where:",
      "ja": "ただし："
    },
    {
      "indent": 3,
      "text": "OKM(i) = EDHOC_KDF( PRK_2e, -i, TH_2, length(P(i)) )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that if length(PLAINTEXT_2) ≤ M, then P(0) = PLAINTEXT_2 and the definition of KEYSTREAM_2 = OKM(0) coincides with Figure 6.",
      "ja": "長さ（plaintext_2）≤mの場合、p（0）= plantext_2およびkeystream_2 = okm（0）の定義は図6と一致することに注意してください。"
    },
    {
      "indent": 3,
      "text": "This describes the processing of the Responder when sending message_2. The Initiator makes the same calculations when receiving message_2 but interchanging PLAINTEXT_2 and CIPHERTEXT_2.",
      "ja": "これは、message_2を送信するときのレスポンダーの処理について説明します。イニシエーターは、message_2を受信するときに同じ計算を行いますが、plaintext_2とciphertext_2を交換します。"
    },
    {
      "indent": 3,
      "text": "An application profile may specify if it supports or does not support the method described in this appendix.",
      "ja": "アプリケーションプロファイルは、この付録で説明されている方法をサポートするか、サポートしていないかどうかを指定できます。"
    },
    {
      "indent": 0,
      "text": "Appendix H. EDHOC_KeyUpdate",
      "section_title": true,
      "ja": "付録H. edhoc_keyupdate"
    },
    {
      "indent": 3,
      "text": "To provide forward secrecy in an even more efficient way than re-running EDHOC, this section specifies the optional function EDHOC_KeyUpdate in terms of EDHOC_KDF and PRK_out.",
      "ja": "EDHOCを再ランニングするよりもさらに効率的な方法で秘密を提供するために、このセクションでは、EDHOC_KDFとPRK_OUTの観点からオプションの機能EDHOC_KEYUPDATEを指定します。"
    },
    {
      "indent": 3,
      "text": "When EDHOC_KeyUpdate is called, a new PRK_out is calculated as the output of the EDHOC_Expand function with the old PRK_out as input. The change of PRK_out causes a change to PRK_exporter, which enables the derivation of new application keys superseding the old ones, using EDHOC_Exporter; see Section 4.2.1. The process is illustrated by the following pseudocode.",
      "ja": "EDHOC_KEYUPDATEと呼ばれると、新しいPRK_OUTがEDHOC_EXPAND関数の出力として計算され、古いPRK_OUTが入力として計算されます。PRK_OUTの変更により、PRK_EXPORTERが変更され、EDHOC_EXPORTERを使用して古いアプリケーションに取って代わる新しいアプリケーションキーの導出が可能になります。セクション4.2.1を参照してください。このプロセスは、次の擬似コードによって示されています。"
    },
    {
      "indent": 3,
      "text": "EDHOC_KeyUpdate( context ):\n   new PRK_out = EDHOC_KDF( old PRK_out, 11, context, hash_length )\n   new PRK_exporter = EDHOC_KDF( new PRK_out, 10, h'', hash_length )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where hash_length denotes the output size in bytes of the EDHOC hash algorithm of the selected cipher suite.",
      "ja": "ここで、Hash_Lengthは、選択した暗号スイートのEDHOCハッシュアルゴリズムのバイトの出力サイズを示します。"
    },
    {
      "indent": 3,
      "text": "The EDHOC_KeyUpdate takes a context as input to enable binding of the updated PRK_out to some event that triggered the key update. The Initiator and Responder need to agree on the context, which can, e.g., be a counter, a pseudorandom number, or a hash. To provide forward secrecy, the old PRK_out and keys derived from it (old PRK_exporter and old application keys) must be deleted as soon as they are not needed. When to delete the old keys and how to verify that they are not needed is up to the application. Note that the security properties depend on the type of context and the number of KeyUpdate iterations.",
      "ja": "Edhoc_keyupdateは、キーアップデートをトリガーしたいくつかのイベントへの更新されたprk_outのバインディングを有効にするための入力としてコンテキストを取ります。イニシエーターとレスポンダーは、コンテキストに同意する必要があります。コンテキストは、例えば、カウンター、擬似ランダム番号、またはハッシュである可能性があります。フォワードの秘密を提供するには、それから派生した古いprk_outとキー（古いprk_exporterおよび古いアプリケーションキー）を必要としなくなったらすぐに削除する必要があります。古いキーをいつ削除し、それらが必要でないことを確認する方法は、アプリケーション次第です。セキュリティプロパティは、コンテキストのタイプとキーアップデートの反復の数に依存することに注意してください。"
    },
    {
      "indent": 3,
      "text": "An application using EDHOC_KeyUpdate needs to store PRK_out. Compromise of PRK_out leads to compromise of all keying material derived with the EDHOC_Exporter since the last invocation of the EDHOC_KeyUpdate function.",
      "ja": "edhoc_keyupdateを使用したアプリケーションは、prk_outを保存する必要があります。PRK_OUTの妥協は、EDHOC_KEYUPDATE関数の最後の呼び出し以来、EDHOC_EXPORTERで導出されたすべてのキーイング素材の妥協につながります。"
    },
    {
      "indent": 3,
      "text": "While this key update method provides forward secrecy, it does not give as strong security properties as re-running EDHOC. EDHOC_KeyUpdate can be used to meet cryptographic limits and provide partial protection against key leakage, but it provides significantly weaker security properties than re-running EDHOC with ephemeral Diffie-Hellman. Even with frequent use of EDHOC_KeyUpdate, compromise of one session key compromises all future session keys, and an attacker therefore only needs to perform static key exfiltration [RFC7624], which is less complicated and has a lower risk profile than the dynamic case; see Section 9.1.",
      "ja": "このキーアップデート方法は、フォワードの秘密を提供しますが、EDHOCの再実行ほど強力なセキュリティプロパティを提供しません。EDHOC_KEYUPDATEを使用して暗号化の制限を満たし、主要な漏れに対する部分的な保護を提供しますが、EDHOCをEDHOCとEphemeral Diffie-Hellmanで再ランニングするよりも、セキュリティプロパティが大幅に弱くなります。edhoc_keyupdateを頻繁に使用しても、1つのセッションキーの妥協はすべての将来のセッションキーを妥協するため、攻撃者は静的なキー除去[RFC7624]を実行する必要があります。セクション9.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "A similar method to do a key update for OSCORE is KUDOS; see [KUDOS].",
      "ja": "OSCOREのキーアップデートを実行する同様の方法は称賛です。[kudos]を参照してください。"
    },
    {
      "indent": 0,
      "text": "Appendix I. Example Protocol State Machine",
      "section_title": true,
      "ja": "付録I. 例プロトコル状態マシン"
    },
    {
      "indent": 3,
      "text": "This appendix describes an example protocol state machine for the Initiator and Responder. States are denoted in all capitals, and parentheses denote actions taken only in some circumstances.",
      "ja": "この付録では、イニシエーターとレスポンダーのためのプロトコル状態マシンの例について説明します。状態はすべての首都で示されており、括弧は状況によってのみ行われたアクションを示します。"
    },
    {
      "indent": 3,
      "text": "Note that this state machine is just an example, and that details of processing are omitted. For example:",
      "ja": "この状態マシンは単なる例であり、処理の詳細は省略されていることに注意してください。例えば："
    },
    {
      "indent": 6,
      "text": "* when error messages are being sent (with one exception);",
      "ja": "* エラーメッセージが送信されている場合（1つの例外を除く）。"
    },
    {
      "indent": 6,
      "text": "* how credentials and EAD are processed by EDHOC and the application in the RCVD state; and",
      "ja": "* EDHOCとRCVD状態のアプリケーションによって資格とEADがどのように処理されるか。そして"
    },
    {
      "indent": 6,
      "text": "* what verifications are made, which includes not only MACs and signatures.",
      "ja": "* マックや署名だけでなく、どのような検証が作成されますか。"
    },
    {
      "indent": 0,
      "text": "I.1. Initiator State Machine",
      "section_title": true,
      "ja": "I.1. イニシエーター状態マシン"
    },
    {
      "indent": 3,
      "text": "The Initiator sends message_1, triggering the state machine to transition from START to WAIT_M2, and waits for message_2.",
      "ja": "イニシエーターはmessage_1を送信し、ステートマシンをトリガーして開始からwait_m2に移行し、message_2を待ちます。"
    },
    {
      "indent": 3,
      "text": "If the incoming message is an error message, then the Initiator transitions from WAIT_M2 to ABORTED. In case of error code 2 (Wrong Selected Cipher Suite), the Initiator remembers the supported cipher suites for this particular Responder and transitions from ABORTED to START. The message_1 that the Initiator subsequently sends takes into account the cipher suites supported by the Responder.",
      "ja": "着信メッセージがエラーメッセージである場合、イニシエーターはwait_m2から中止されました。エラーコード2（選択された暗号スイートが誤っている場合）の場合、イニシエーターは、この特定のレスポンダーでサポートされている暗号スイートと、中止されたものから開始までの遷移を覚えています。その後、イニシエーターが送信するメッセージ_1は、レスポンダーによってサポートされている暗号スイートを考慮に入れます。"
    },
    {
      "indent": 3,
      "text": "Upon receiving a non-error message, the Initiator transitions from WAIT_M2 to RCVD_M2 and processes the message. If a processing error occurs on message_2, then the Initiator transitions from RCVD_M2 to ABORTED. In case of successful processing of message_2, the Initiator transitions from RCVD_M2 to VRFD_M2.",
      "ja": "非エラーメッセージを受信すると、イニシエーターはWAIT_M2からRCVD_M2に遷移し、メッセージを処理します。Message_2で処理エラーが発生した場合、イニシエーターはRCVD_M2から中止されます。Message_2の処理が成功した場合、イニシエーターはRCVD_M2からVRFD_M2に遷移します。"
    },
    {
      "indent": 3,
      "text": "The Initiator prepares and processes message_3 for sending. If any processing error is encountered, the Initiator transitions from VRFD_M2 to ABORTED. If message_3 is successfully sent, the Initiator transitions from VRFD_M2 to COMPLETED.",
      "ja": "イニシエーターは、送信用にmessage_3を準備および処理します。処理エラーが発生した場合、イニシエーターはVRFD_M2から中止に移行します。Message_3が正常に送信された場合、イニシエーターはVRFD_M2から完了します。"
    },
    {
      "indent": 3,
      "text": "If the application profile includes message_4, then the Initiator waits for message_4. If the incoming message is an error message, then the Initiator transitions from COMPLETED to ABORTED. Upon receiving a non-error message, the Initiator transitions from COMPLETED (=\"WAIT_M4\") to RCVD_M4 and processes the message. If a processing error occurs on message_4, then the Initiator transitions from RCVD_M4 to ABORTED. In case of successful processing of message_4, the Initiator transitions from RCVD_M4 to PERSISTED (=\"VRFD_M4\").",
      "ja": "アプリケーションプロファイルにmessage_4が含まれている場合、イニシエーターはmessage_4を待ちます。着信メッセージがエラーメッセージである場合、イニシエーターは完了から中止されたものに移行します。非誤差メッセージを受信すると、イニシエーターは完了（= \"wait_m4\"）からrcvd_m4に移行し、メッセージを処理します。Message_4で処理エラーが発生した場合、イニシエーターはRCVD_M4から中止されます。Message_4の処理が成功した場合、イニシエーターはRCVD_M4から永続化（= \"VRFD_M4\"）に移行します。"
    },
    {
      "indent": 3,
      "text": "If the application profile does not include message_4, then the Initiator waits for an incoming application message. If the decryption and verification of the application message is successful, then the Initiator transitions from COMPLETED to PERSISTED.",
      "ja": "アプリケーションプロファイルにmessage_4が含まれていない場合、イニシエーターは着信アプリケーションメッセージを待ちます。アプリケーションメッセージの復号化と検証が成功した場合、イニシエーターは完了から永続化まで移行します。"
    },
    {
      "indent": 4,
      "text": "    +- - - - - - - - - -> START\n    |                       |\n                            | Send message_1\n    |                       |\n          Receive error     v\nABORTED <---------------- WAIT_M2\n    ^                       |\n    |                       | Receive message_2\n    |                       |\n    |    Processing error   v\n    +-------------------- RCVD_M2\n    ^                       |\n    |                       | Verify message_2\n    |                       |\n    |    Processing error   v\n    +-------------------- VRFD_M2\n    ^                       |\n    |                       | Send message_3\n    |                       |\n    |    (Receive error)    v\n    +-------------------- COMPLETED ----------------+\n    ^                       |                       |\n    |                       | (Receive message_4)   |\n    |                       |                       |\n    |   (Processing error)  v                       | (Verify\n    +------------------- (RCVD_M4)                  |  application\n                            |                       |  message)\n                            | (Verify message_4)    |\n                            |                       |\n                            v                       |\n                          PERSISTED <---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 12: Initiator State Machine",
      "ja": "図12：イニシエーター状態マシン"
    },
    {
      "indent": 0,
      "text": "I.2. Responder State Machine",
      "section_title": true,
      "ja": "I.2. レスポンダー状態マシン"
    },
    {
      "indent": 3,
      "text": "Upon receiving message_1, the Responder transitions from START to RCVD_M1.",
      "ja": "Message_1を受信すると、Responderは開始からRCVD_M1に移行します。"
    },
    {
      "indent": 3,
      "text": "If a processing error occurs on message_1, the Responder transitions from RCVD_M1 to ABORTED. This includes sending an error message with error code 2 (Wrong Selected Cipher Suite) if the selected cipher suite in message_1 is not supported. In case of successful processing of message_1, the Responder transitions from RCVD_M1 to VRFD_M1.",
      "ja": "Message_1で処理エラーが発生すると、RCVD_M1から中止されたレスポンダーが遷移します。これには、Message_1の選択したCipherスイートがサポートされていない場合、エラーコード2（誤って選択した暗号スイート）を使用してエラーメッセージの送信が含まれます。Message_1の処理が成功した場合、RCVD_M1からVRFD_M1へのレスポンダー遷移。"
    },
    {
      "indent": 3,
      "text": "The Responder prepares and processes message_2 for sending. If any processing error is encountered, the Responder transitions from VRFD_M1 to ABORTED. If message_2 is successfully sent, the Initiator transitions from VRFD_M2 to WAIT_M3 and waits for message_3.",
      "ja": "Responderは、送信用にmessage_2を準備および処理します。処理エラーが発生した場合、ResponderはVRFD_M1から中止に移行します。Message_2が正常に送信された場合、イニシエーターはVRFD_M2からWAIT_M3に遷移し、Message_3を待ちます。"
    },
    {
      "indent": 3,
      "text": "If the incoming message is an error message, then the Responder transitions from WAIT_M3 to ABORTED.",
      "ja": "着信メッセージがエラーメッセージである場合、レスポンダーはwait_m3から中止されます。"
    },
    {
      "indent": 3,
      "text": "Upon receiving message_3, the Responder transitions from WAIT_M3 to RCVD_M3. If a processing error occurs on message_3, the Responder transitions from RCVD_M3 to ABORTED. In case of successful processing of message_3, the Responder transitions from RCVD_M3 to COMPLETED (=\"VRFD_M3\").",
      "ja": "message_3を受信すると、レスポンダーはwait_m3からrcvd_m3に移行します。Message_3で処理エラーが発生した場合、RCVD_M3から中止されたRESPONDERの移行。Message_3の処理が成功した場合、RCVD_M3から完了（= \"VRFD_M3\"）にレスポンダーが移行します。"
    },
    {
      "indent": 3,
      "text": "If the application profile includes message_4, the Responder prepares and processes message_4 for sending. If any processing error is encountered, the Responder transitions from COMPLETED to ABORTED.",
      "ja": "アプリケーションプロファイルにmessage_4が含まれている場合、Responderは送信用にmessage_4を準備して処理します。処理エラーが発生した場合、レスポンダーの移行は完了から中止されます。"
    },
    {
      "indent": 3,
      "text": "If message_4 is successfully sent, or if the application profile does not include message_4, the Responder transitions from COMPLETED to PERSISTED.",
      "ja": "Message_4が正常に送信された場合、またはアプリケーションプロファイルにmessage_4が含まれていない場合、Responder Transitionが完了から永続化されました。"
    },
    {
      "indent": 14,
      "text": "                          START\n                            |\n                            | Receive message_1\n                            |\n         Processing error   v\nABORTED <---------------- RCVD_M1\n    ^                       |\n    |                       | Verify message_1\n    |                       |\n    |    Processing error   v\n    +-------------------- VRFD_M1\n    ^                       |\n    |                       | Send message_2\n    |                       |\n    |     Receive error     v\n    +-------------------- WAIT_M3\n    ^                       |\n    |                       | Receive message_3\n    |                       |\n    |    Processing error   v\n    +-------------------- RCVD_M3\n    ^                       |\n    |                       | Verify message_3\n    |                       |\n    |   (Processing error)  v\n    +------------------- COMPLETED\n                            |\n                            | (Send message_4)\n                            |\n                            v\n                         PERSISTED",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 13: Responder State Machine",
      "ja": "図13：レスポンダー状態マシン"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "section_title": true,
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors want to thank Christian Amsüss, Karthikeyan Bhargavan, Carsten Bormann, Alessandro Bruni, Timothy Claeys, Baptiste Cottier, Roman Danyliw, Martin Disch, Martin Duke, Donald Eastlake 3rd, Lars Eggert, Stephen Farrell, Loïc Ferreira, Theis Grønbech Petersen, Felix Günther, Dan Harkins, Klaus Hartke, Russ Housley, Stefan Hristozov, Marc Ilunga, Charlie Jacomme, Elise Klein, Erik Kline, Steve Kremer, Alexandros Krontiris, Ilari Liusvaara, Rafa Marín-López, Kathleen Moriarty, David Navarro, Karl Norrman, Salvador Pérez, Radia Perlman, David Pointcheval, Maïwenn Racouchot, Eric Rescorla, Michael Richardson, Thorvald Sahl Jørgensen, Zaheduzzaman Sarker, Jim Schaad, Michael Scharf, Carsten Schürmann, John Scudder, Ludwig Seitz, Brian Sipos, Stanislav Smyshlyaev, Valery Smyslov, Peter van der Stok, Rene Struik, Vaishnavi Sundararajan, Erik Thormarker, Marco Tiloca, Sean Turner, Michel Veillette, Mališa Vučinić, Paul Wouters, and Lei Yan for reviewing and commenting on intermediate draft versions of this document.",
      "ja": "著者は、クリスチャン・アムス、カーシケヤン・バルガヴァン、カルステン・ボルマン、アレッサンドロ・ブルーニ、ティモシー・クレイズ、バプティスト・コティエ、ローマン・ダニリウ、マーティン・ディスチ、マーティン・デューク、ドナルド・イーストレイク3rd、ラース・エッサート、ステフェン・ファーレル、ロイック・フェレイラ、Günther、Dan Harkins、Klaus Hartke、Russ Housley、Stefan Hristozov、Marc Ilunga、Charlie Jacomme、Elise Klein、Erik Kline、Steve Kremer、Alexandros Krontiris、Ilari Liusvaara、RafaMarínópez、Karrameren varraren davarra daverra narmaner navarratペレス、ラディア・ペルマン、デビッド・ポイントチェヴァル、マイウェン・ラシュチョット、エリック・レスコルラ、マイケル・リチャードソン、トールヴァルド・サール・ヨルゲンセン、ザヘドゥザマン・サルカー、ジム・シャード、マイケル・シャーフ、カルステン・シュルマン、ジョン・スカッド、ルドウィグ・セイツ、ブリアン・シポス・スミスラヴァーヴァーヴァーヴァー・スミスヴァン・スミスヴァン・スミス・スミス・スミス・スミスDer Stok、Rene Struik、Vaishnavi Sundararajan、Erik Thormarker、Marco Tiloca、Sean Turner、Michel Veillette、MališaVučinić、Paul Wouters、およびLei Yanは、この文書の中間ドラフトバージョンについてレビューし、コメントしています。"
    },
    {
      "indent": 3,
      "text": "We are especially indebted to the late Jim Schaad for his continuous review and implementation of draft versions of this document, as well as his work on other technologies such as COSE and OSCORE without which EDHOC would not have been.",
      "ja": "このドキュメントのドラフトバージョンの継続的なレビューと実装と、EdhocがいなかったCoseやOscoreなどの他のテクノロジーに関する彼の作業について、故Jim Schaadに特に感謝しています。"
    },
    {
      "indent": 3,
      "text": "Work on this document has in part been supported by the H2020 project SIFIS-Home (grant agreement 952652).",
      "ja": "このドキュメントの作業は、H2020 Project Sifis-Home（Grant Agreement 952652）によって部分的にサポートされています。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Göran Selander\nEricsson AB\nSE-164 80 Stockholm\nSweden\nEmail: goran.selander@ericsson.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "John Preuß Mattsson\nEricsson AB\nSE-164 80 Stockholm\nSweden\nEmail: john.mattsson@ericsson.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Francesca Palombini\nEricsson AB\nSE-164 80 Stockholm\nSweden\nEmail: francesca.palombini@ericsson.com",
      "raw": true,
      "ja": ""
    }
  ]
}