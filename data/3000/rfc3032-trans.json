{
  "title": {
    "text": "RFC 3032 - MPLS Label Stack Encoding",
    "ja": "RFC 3032 - MPLSラベルスタックエンコーディング"
  },
  "number": 3032,
  "created_at": "2023-12-29 05:17:52.998902+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                           E. Rosen\nRequest for Comments: 3032                                     D. Tappan\nCategory: Standards Track                                    G. Fedorkow\n                                                     Cisco Systems, Inc.\n                                                              Y. Rekhter\n                                                        Juniper Networks\n                                                            D. Farinacci\n                                                                   T. Li\n                                                  Procket Networks, Inc.\n                                                                A. Conta\n                                                  TranSwitch Corporation\n                                                            January 2001",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "MPLS Label Stack Encoding",
      "ja": "MPLSラベルスタックエンコーディング"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2001）。無断転載を禁じます。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "\"Multi-Protocol Label Switching (MPLS)\" [1] requires a set of procedures for augmenting network layer packets with \"label stacks\", thereby turning them into \"labeled packets\". Routers which support MPLS are known as \"Label Switching Routers\", or \"LSRs\". In order to transmit a labeled packet on a particular data link, an LSR must support an encoding technique which, given a label stack and a network layer packet, produces a labeled packet. This document specifies the encoding to be used by an LSR in order to transmit labeled packets on Point-to-Point Protocol (PPP) data links, on LAN data links, and possibly on other data links as well. On some data links, the label at the top of the stack may be encoded in a different manner, but the techniques described here MUST be used to encode the remainder of the label stack. This document also specifies rules and procedures for processing the various fields of the label stack encoding.",
      "ja": "「マルチプロトコルラベルスイッチング（MPLS）」[1]には、「ラベルスタック」でネットワークレイヤーパケットを拡張するための一連の手順が必要であり、それにより「ラベル付きパケット」に変換します。MPLSをサポートするルーターは、「ラベルスイッチングルーター」または「LSRS」として知られています。特定のデータリンクにラベル付きパケットを送信するには、LSRがラベルスタックとネットワークレイヤーパケットを与えられたエンコード手法をサポートする必要があります。このドキュメントは、ポイントツーポイントプロトコル（PPP）データリンク、LANデータリンク、および場合によっては他のデータリンクでもラベル付けされたパケットを送信するために、LSRが使用するエンコードを指定します。一部のデータリンクでは、スタックの上部にあるラベルは別の方法でエンコードされる場合がありますが、ここで説明する手法は、ラベルスタックの残りの部分をエンコードするために使用する必要があります。このドキュメントは、ラベルスタックエンコーディングのさまざまなフィールドを処理するためのルールと手順も指定しています。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": " 1      Introduction  ...........................................  2\n 1.1    Specification of Requirements  ..........................  3\n 2      The Label Stack  ........................................  3\n 2.1    Encoding the Label Stack  ...............................  3\n 2.2    Determining the Network Layer Protocol  .................  5\n 2.3    Generating ICMP Messages for Labeled IP Packets  ........  6\n 2.3.1  Tunneling through a Transit Routing Domain  .............  7\n 2.3.2  Tunneling Private Addresses through a Public Backbone  ..  7\n 2.4    Processing the Time to Live Field  ......................  8\n 2.4.1  Definitions  ............................................  8\n 2.4.2  Protocol-independent rules  .............................  8\n 2.4.3  IP-dependent rules  .....................................  9\n 2.4.4  Translating Between Different Encapsulations  ...........  9\n 3      Fragmentation and Path MTU Discovery  ................... 10\n 3.1    Terminology  ............................................ 11\n 3.2    Maximum Initially Labeled IP Datagram Size  ............. 12\n 3.3    When are Labeled IP Datagrams Too Big?  ................. 13\n 3.4    Processing Labeled IPv4 Datagrams which are Too Big  .... 13\n 3.5    Processing Labeled IPv6 Datagrams which are Too Big  .... 14\n 3.6    Implications with respect to Path MTU Discovery  ........ 15\n 4      Transporting Labeled Packets over PPP  .................. 16\n 4.1    Introduction  ........................................... 16\n 4.2    A PPP Network Control Protocol for MPLS  ................ 17\n 4.3    Sending Labeled Packets  ................................ 18\n 4.4    Label Switching Control Protocol Configuration Options  . 18\n 5      Transporting Labeled Packets over LAN Media  ............ 18\n 6      IANA Considerations  .................................... 19\n 7      Security Considerations  ................................ 19\n 8      Intellectual Property  .................................. 19\n 9      Authors' Addresses  ..................................... 20\n10      References  ............................................. 22\n11      Full Copyright Statement  ............................... 23",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "\"Multi-Protocol Label Switching (MPLS)\" [1] requires a set of procedures for augmenting network layer packets with \"label stacks\", thereby turning them into \"labeled packets\". Routers which support MPLS are known as \"Label Switching Routers\", or \"LSRs\". In order to transmit a labeled packet on a particular data link, an LSR must support an encoding technique which, given a label stack and a network layer packet, produces a labeled packet.",
      "ja": "「マルチプロトコルラベルスイッチング（MPLS）」[1]には、「ラベルスタック」でネットワークレイヤーパケットを拡張するための一連の手順が必要であり、それにより「ラベル付きパケット」に変換します。MPLSをサポートするルーターは、「ラベルスイッチングルーター」または「LSRS」として知られています。特定のデータリンクにラベル付きパケットを送信するには、LSRがラベルスタックとネットワークレイヤーパケットを与えられたエンコード手法をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "This document specifies the encoding to be used by an LSR in order to transmit labeled packets on PPP data links and on LAN data links. The specified encoding may also be useful for other data links as well.",
      "ja": "このドキュメントは、PPPデータリンクおよびLANデータリンクでラベル付きパケットを送信するために、LSRが使用するエンコードを指定します。指定されたエンコードは、他のデータリンクにも役立つ場合があります。"
    },
    {
      "indent": 3,
      "text": "This document also specifies rules and procedures for processing the various fields of the label stack encoding. Since MPLS is independent of any particular network layer protocol, the majority of such procedures are also protocol-independent. A few, however, do differ for different protocols. In this document, we specify the protocol-independent procedures, and we specify the protocol-dependent procedures for IPv4 and IPv6.",
      "ja": "このドキュメントは、ラベルスタックエンコーディングのさまざまなフィールドを処理するためのルールと手順も指定しています。MPLSは特定のネットワークレイヤープロトコルに依存しないため、そのような手順の大部分はプロトコルに依存しません。ただし、一部は異なるプロトコルで異なります。このドキュメントでは、プロトコルに依存しない手順を指定し、IPv4およびIPv6のプロトコル依存性手順を指定します。"
    },
    {
      "indent": 3,
      "text": "LSRs that are implemented on certain switching devices (such as ATM switches) may use different encoding techniques for encoding the top one or two entries of the label stack. When the label stack has additional entries, however, the encoding technique described in this document MUST be used for the additional label stack entries.",
      "ja": "特定のスイッチングデバイス（ATMスイッチなど）に実装されているLSRは、ラベルスタックの上部1つまたは2つのエントリをエンコードするために異なるエンコーディング手法を使用する場合があります。ただし、ラベルスタックに追加のエントリがある場合、このドキュメントで説明されているエンコード手法を追加のラベルスタックエントリに使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "1.1. Specification of Requirements",
      "section_title": true,
      "ja": "1.1. 要件の仕様"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [2].",
      "ja": "「必須」、「そうしない」、「必須」、「必要」、「「しない」、「そうでない」、「そうではない」、「そうでない」、「推奨」、「5月」、および「オプション」は、RFC 2119 [2]に記載されているように解釈される。"
    },
    {
      "indent": 0,
      "text": "2. The Label Stack",
      "section_title": true,
      "ja": "2. ラベルスタック"
    },
    {
      "indent": 0,
      "text": "2.1. Encoding the Label Stack",
      "section_title": true,
      "ja": "2.1. ラベルスタックのエンコード"
    },
    {
      "indent": 3,
      "text": "The label stack is represented as a sequence of \"label stack entries\". Each label stack entry is represented by 4 octets. This is shown in Figure 1.",
      "ja": "ラベルスタックは、「ラベルスタックエントリ」のシーケンスとして表されます。各ラベルスタックエントリは、4オクテットで表されます。これを図1に示します。"
    },
    {
      "indent": 0,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Label\n|                Label                  | Exp |S|       TTL     | Stack\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Entry",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Label: Label Value, 20 bits Exp: Experimental Use, 3 bits S: Bottom of Stack, 1 bit TTL: Time to Live, 8 bits",
      "ja": "ラベル値：ラベル値、20ビットExp：実験用使用、3ビットS：スタックの下部、1ビットTTL：ライブの時間、8ビット"
    },
    {
      "indent": 30,
      "text": "Figure 1",
      "ja": "図1"
    },
    {
      "indent": 3,
      "text": "The label stack entries appear AFTER the data link layer headers, but BEFORE any network layer headers. The top of the label stack appears earliest in the packet, and the bottom appears latest. The network layer packet immediately follows the label stack entry which has the S bit set.",
      "ja": "ラベルスタックエントリは、データリンクレイヤーヘッダーの後に表示されますが、ネットワークレイヤーヘッダーの前に表示されます。ラベルスタックの上部はパケットで最も早く表示され、下部が最新のものに見えます。ネットワークレイヤーパケットは、Sビットが設定されたラベルスタックエントリのすぐ後に続きます。"
    },
    {
      "indent": 3,
      "text": "Each label stack entry is broken down into the following fields:",
      "ja": "各ラベルスタックエントリは、次のフィールドに分類されます。"
    },
    {
      "indent": 6,
      "text": "1. Bottom of Stack (S)",
      "ja": "1. スタックの底"
    },
    {
      "indent": 9,
      "text": "This bit is set to one for the last entry in the label stack (i.e., for the bottom of the stack), and zero for all other label stack entries.",
      "ja": "このビットは、ラベルスタックの最後のエントリ（つまり、スタックの下部用）に1つ、他のすべてのラベルスタックエントリでゼロに設定されています。"
    },
    {
      "indent": 6,
      "text": "2. Time to Live (TTL)",
      "ja": "2. ライブの時間（TTL）"
    },
    {
      "indent": 9,
      "text": "This eight-bit field is used to encode a time-to-live value. The processing of this field is described in section 2.4.",
      "ja": "この8ビットフィールドは、時間までの値をエンコードするために使用されます。このフィールドの処理については、セクション2.4で説明します。"
    },
    {
      "indent": 6,
      "text": "3. Experimental Use",
      "ja": "3. 実験的使用"
    },
    {
      "indent": 9,
      "text": "This three-bit field is reserved for experimental use.",
      "ja": "この3ビットフィールドは、実験用に予約されています。"
    },
    {
      "indent": 6,
      "text": "4. Label Value",
      "ja": "4. ラベル値"
    },
    {
      "indent": 9,
      "text": "This 20-bit field carries the actual value of the Label.",
      "ja": "この20ビットフィールドには、ラベルの実際の値があります。"
    },
    {
      "indent": 9,
      "text": "When a labeled packet is received, the label value at the top of the stack is looked up. As a result of a successful lookup one learns:",
      "ja": "ラベル付きパケットが受信されると、スタックの上部にあるラベル値が検索されます。ルックアップが成功した結果、学習しました："
    },
    {
      "indent": 9,
      "text": "a) the next hop to which the packet is to be forwarded;",
      "ja": "a) パケットを転送する次のホップ。"
    },
    {
      "indent": 9,
      "text": "b) the operation to be performed on the label stack before forwarding; this operation may be to replace the top label stack entry with another, or to pop an entry off the label stack, or to replace the top label stack entry and then to push one or more additional entries on the label stack.",
      "ja": "b) 転送前にラベルスタックで実行される操作。この操作は、トップレーベルスタックエントリを別のものに置き換えるか、ラベルスタックからエントリをポップするか、トップレーベルスタックエントリを交換してから、ラベルスタックに1つ以上の追加エントリを押します。"
    },
    {
      "indent": 9,
      "text": "In addition to learning the next hop and the label stack operation, one may also learn the outgoing data link encapsulation, and possibly other information which is needed in order to properly forward the packet.",
      "ja": "次のホップとラベルスタック操作の学習に加えて、パケットを適切に転送するために必要な発信データリンクのカプセル化、および場合によっては必要な他の情報を学習することもできます。"
    },
    {
      "indent": 9,
      "text": "There are several reserved label values:",
      "ja": "いくつかの予約されたラベル値があります："
    },
    {
      "indent": 11,
      "text": "i. A value of 0 represents the \"IPv4 Explicit NULL Label\". This label value is only legal at the bottom of the label stack. It indicates that the label stack must be popped, and the forwarding of the packet must then be based on the IPv4 header.",
      "ja": "i. 0の値は、「IPv4明示的なヌルラベル」を表します。このラベル値は、ラベルスタックの下部でのみ合法です。これは、ラベルスタックをポップする必要があり、パケットの転送がIPv4ヘッダーに基づいている必要があることを示しています。"
    },
    {
      "indent": 10,
      "text": "ii. A value of 1 represents the \"Router Alert Label\". This label value is legal anywhere in the label stack except at the bottom. When a received packet contains this label value at the top of the label stack, it is delivered to a local software module for processing. The actual forwarding of the packet is determined by the label beneath it in the stack. However, if the packet is forwarded further, the Router Alert Label should be pushed back onto the label stack before forwarding. The use of this label is analogous to the use of the \"Router Alert Option\" in IP packets [5]. Since this label cannot occur at the bottom of the stack, it is not associated with a particular network layer protocol.",
      "ja": "ii。1の値は、「ルーターアラートラベル」を表します。このラベル値は、下部を除き、ラベルスタックのどこでも合法です。受信したパケットに、ラベルスタックの上部にこのラベル値が含まれている場合、処理のためにローカルソフトウェアモジュールに配信されます。パケットの実際の転送は、スタック内のその下のラベルによって決定されます。ただし、パケットがさらに転送される場合は、転送前にルーターアラートラベルをラベルスタックに押し戻す必要があります。このラベルの使用は、IPパケットで「ルーターアラートオプション」の使用に類似しています[5]。このラベルはスタックの下部で発生することはできないため、特定のネットワークレイヤープロトコルに関連付けられていません。"
    },
    {
      "indent": 9,
      "text": "iii. A value of 2 represents the \"IPv6 Explicit NULL Label\". This label value is only legal at the bottom of the label stack. It indicates that the label stack must be popped, and the forwarding of the packet must then be based on the IPv6 header.",
      "ja": "iii。2の値は、「IPv6明示的なヌルラベル」を表します。このラベル値は、ラベルスタックの下部でのみ合法です。これは、ラベルスタックをポップする必要があり、パケットの転送がIPv6ヘッダーに基づいている必要があることを示しています。"
    },
    {
      "indent": 10,
      "text": "iv. A value of 3 represents the \"Implicit NULL Label\". This is a label that an LSR may assign and distribute, but which never actually appears in the encapsulation. When an LSR would otherwise replace the label at the top of the stack with a new label, but the new label is \"Implicit NULL\", the LSR will pop the stack instead of doing the replacement. Although this value may never appear in the encapsulation, it needs to be specified in the Label Distribution Protocol, so a value is reserved.",
      "ja": "IV。3の値は、「暗黙のヌルラベル」を表します。これは、LSRが割り当てて配布することができるラベルですが、実際にはカプセル化には表示されません。それ以外の場合、LSRがスタックの上部にあるラベルを新しいラベルに置き換えますが、新しいラベルは「暗黙のヌル」である場合、LSRは交換を行う代わりにスタックをポップします。この値はカプセル化には決して表示されない場合がありますが、ラベル分布プロトコルで指定する必要があるため、値は予約されています。"
    },
    {
      "indent": 11,
      "text": "v. Values 4-15 are reserved.",
      "ja": "v. 値4-15は予約されています。"
    },
    {
      "indent": 0,
      "text": "2.2. Determining the Network Layer Protocol",
      "section_title": true,
      "ja": "2.2. ネットワークレイヤープロトコルの決定"
    },
    {
      "indent": 3,
      "text": "When the last label is popped from a packet's label stack (resulting in the stack being emptied), further processing of the packet is based on the packet's network layer header. The LSR which pops the last label off the stack must therefore be able to identify the packet's network layer protocol. However, the label stack does not contain any field which explicitly identifies the network layer protocol. This means that the identity of the network layer protocol must be inferable from the value of the label which is popped from the bottom of the stack, possibly along with the contents of the network layer header itself.",
      "ja": "最後のラベルがパケットのラベルスタックからポップされると（スタックが空になります）、パケットのさらなる処理はパケットのネットワークレイヤーヘッダーに基づいています。したがって、スタックから最後のラベルをポップするLSRは、パケットのネットワークレイヤープロトコルを識別できる必要があります。ただし、ラベルスタックには、ネットワークレイヤープロトコルを明示的に識別するフィールドは含まれていません。これは、ネットワークレイヤープロトコルのIDは、おそらくネットワークレイヤーヘッダー自体の内容とともに、スタックの下部からポップされたラベルの値から推測する必要があることを意味します。"
    },
    {
      "indent": 3,
      "text": "Therefore, when the first label is pushed onto a network layer packet, either the label must be one which is used ONLY for packets of a particular network layer, or the label must be one which is used ONLY for a specified set of network layer protocols, where packets of the specified network layers can be distinguished by inspection of the network layer header. Furthermore, whenever that label is replaced by another label value during a packet's transit, the new value must also be one which meets the same criteria. If these conditions are not met, the LSR which pops the last label off a packet will not be able to identify the packet's network layer protocol.",
      "ja": "したがって、最初のラベルがネットワークレイヤーパケットにプッシュされる場合、ラベルは特定のネットワークレイヤーのパケットにのみ使用されるものであるか、ラベルが指定されたネットワークレイヤープロトコルのセットにのみ使用されるものでなければなりません。、指定されたネットワークレイヤーのパケットは、ネットワークレイヤーヘッダーの検査により区別できます。さらに、パケットのトランジット中にそのラベルが別のラベル値に置き換えられるたびに、新しい値も同じ基準を満たすものでなければなりません。これらの条件が満たされていない場合、パケットから最後のラベルをポップするLSRは、パケットのネットワークレイヤープロトコルを識別できません。"
    },
    {
      "indent": 3,
      "text": "Adherence to these conditions does not necessarily enable intermediate nodes to identify a packet's network layer protocol. Under ordinary conditions, this is not necessary, but there are error conditions under which it is desirable. For instance, if an intermediate LSR determines that a labeled packet is undeliverable, it may be desirable for that LSR to generate error messages which are specific to the packet's network layer. The only means the intermediate LSR has for identifying the network layer is inspection of the top label and the network layer header. So if intermediate nodes are to be able to generate protocol-specific error messages for labeled packets, all labels in the stack must meet the criteria specified above for labels which appear at the bottom of the stack.",
      "ja": "これらの条件を順守しても、必ずしも中間ノードがパケットのネットワークレイヤープロトコルを識別できるとは限りません。通常の条件下では、これは必要ありませんが、望ましいエラー条件があります。たとえば、中間LSRがラベル付きパケットが配信不可能であると判断した場合、そのLSRがパケットのネットワークレイヤーに固有のエラーメッセージを生成することが望ましい場合があります。ネットワークレイヤーを識別するための中間LSRの唯一の意味は、トップレーベルとネットワークレイヤーヘッダーの検査です。したがって、中間ノードがラベル付きパケットのプロトコル固有のエラーメッセージを生成できる場合、スタック内のすべてのラベルは、スタックの下部に表示されるラベルについて上記の基準を満たす必要があります。"
    },
    {
      "indent": 3,
      "text": "If a packet cannot be forwarded for some reason (e.g., it exceeds the data link MTU), and either its network layer protocol cannot be identified, or there are no specified protocol-dependent rules for handling the error condition, then the packet MUST be silently discarded.",
      "ja": "何らかの理由でパケットを転送できない（例：データリンクMTUを超える）、およびそのネットワークレイヤープロトコルを識別できない場合、またはエラー条件を処理するための指定されたプロトコル依存ルールがない場合、パケットは静かに捨てられました。"
    },
    {
      "indent": 0,
      "text": "2.3. Generating ICMP Messages for Labeled IP Packets",
      "section_title": true,
      "ja": "2.3. ラベル付きIPパケットのICMPメッセージを生成します"
    },
    {
      "indent": 3,
      "text": "Section 2.4 and section 3 discuss situations in which it is desirable to generate ICMP messages for labeled IP packets. In order for a particular LSR to be able to generate an ICMP packet and have that packet sent to the source of the IP packet, two conditions must hold:",
      "ja": "セクション2.4およびセクション3では、ラベル付きIPパケットのICMPメッセージを生成することが望ましい状況について説明します。特定のLSRがICMPパケットを生成し、そのパケットをIPパケットのソースに送信できるようにするためには、2つの条件を保持する必要があります。"
    },
    {
      "indent": 6,
      "text": "1. it must be possible for that LSR to determine that a particular labeled packet is an IP packet;",
      "ja": "1. そのLSRが特定のラベルのあるパケットがIPパケットであると判断することは可能である必要があります。"
    },
    {
      "indent": 6,
      "text": "2. it must be possible for that LSR to route to the packet's IP source address.",
      "ja": "2. そのLSRがパケットのIPソースアドレスにルーティングできるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "Condition 1 is discussed in section 2.2. The following two subsections discuss condition 2. However, there will be some cases in which condition 2 does not hold at all, and in these cases it will not be possible to generate the ICMP message.",
      "ja": "条件1については、セクション2.2で説明します。次の2つのサブセクションでは、条件2について説明します。ただし、条件2がまったく保持されない場合があり、これらの場合、ICMPメッセージを生成することはできません。"
    },
    {
      "indent": 0,
      "text": "2.3.1. Tunneling through a Transit Routing Domain",
      "section_title": true,
      "ja": "2.3.1. トランジットルーティングドメインを通過します"
    },
    {
      "indent": 3,
      "text": "Suppose one is using MPLS to \"tunnel\" through a transit routing domain, where the external routes are not leaked into the domain's interior routers. For example, the interior routers may be running OSPF, and may only know how to reach destinations within that OSPF domain. The domain might contain several Autonomous System Border Routers (ASBRs), which talk BGP to each other. However, in this example the routes from BGP are not distributed into OSPF, and the LSRs which are not ASBRs do not run BGP.",
      "ja": "MPLSを使用して、外部ルートがドメインの内部ルーターに漏れていないトランジットルーティングドメインを介して「トンネル」を使用しているとします。たとえば、インテリアルーターはOSPFを実行している可能性があり、そのOSPFドメイン内の目的地に到達する方法のみを知っている場合があります。ドメインには、いくつかの自律システムの境界ルーター（ASBR）が含まれている場合があり、BGPを相互に話します。ただし、この例では、BGPからのルートはOSPFに分布しておらず、ASBRではないLSRはBGPを実行しません。"
    },
    {
      "indent": 3,
      "text": "In this example, only an ASBR will know how to route to the source of some arbitrary packet. If an interior router needs to send an ICMP message to the source of an IP packet, it will not know how to route the ICMP message.",
      "ja": "この例では、ASBRのみが、任意のパケットのソースにルーティングする方法を知っています。インテリアルーターがIPパケットのソースにICMPメッセージを送信する必要がある場合、ICMPメッセージのルーティング方法がわかりません。"
    },
    {
      "indent": 3,
      "text": "One solution is to have one or more of the ASBRs inject \"default\" into the IGP. (N.B.: this does NOT require that there be a \"default\" carried by BGP.) This would then ensure that any unlabeled packet which must leave the domain (such as an ICMP packet) gets sent to a router which has full routing information. The routers with full routing information will label the packets before sending them back through the transit domain, so the use of default routing within the transit domain does not cause any loops.",
      "ja": "1つの解決策は、1つ以上のASBRに「デフォルト」をIGPに注入することです。（N.B。：これは、BGPによって「デフォルト」が搭載されていることを要求するものではありません。）これにより、ドメイン（ICMPパケットなど）を離れる必要がある非標識パケットが完全なルーティング情報を持つルーターに送信されます。完全なルーティング情報を備えたルーターは、パケットをトランジットドメインに送り返す前にパケットにラベルを付けます。そのため、トランジットドメイン内でデフォルトルーティングを使用しても、ループは発生しません。"
    },
    {
      "indent": 3,
      "text": "This solution only works for packets which have globally unique addresses, and for networks in which all the ASBRs have complete routing information. The next subsection describes a solution which works when these conditions do not hold.",
      "ja": "このソリューションは、グローバルに一意のアドレスを持つパケットと、すべてのASBRが完全なルーティング情報を持っているネットワークでのみ機能します。次のサブセクションでは、これらの条件が保持されないときに機能するソリューションについて説明します。"
    },
    {
      "indent": 0,
      "text": "2.3.2. Tunneling Private Addresses through a Public Backbone",
      "section_title": true,
      "ja": "2.3.2. パブリックバックボーンを介したプライベートアドレスのトンネル"
    },
    {
      "indent": 3,
      "text": "In some cases where MPLS is used to tunnel through a routing domain, it may not be possible to route to the source address of a fragmented packet at all. This would be the case, for example, if the IP addresses carried in the packet were private (i.e., not globally unique) addresses, and MPLS were being used to tunnel those packets through a public backbone. Default routing to an ASBR will not work in this environment.",
      "ja": "MPLSがルーティングドメインを通過するために使用される場合には、断片化されたパケットのソースアドレスにまったくルーティングできない場合があります。これは、たとえば、パケットに携帯されているIPアドレスがプライベートである場合（つまり、グローバルに一意ではない）アドレスであり、MPLSが公共のバックボーンを介してそれらのパケットをトンネルするために使用されていました。ASBRへのデフォルトルーティングは、この環境では機能しません。"
    },
    {
      "indent": 3,
      "text": "In this environment, in order to send an ICMP message to the source of a packet, one can copy the label stack from the original packet to the ICMP message, and then label switch the ICMP message. This will cause the message to proceed in the direction of the original packet's destination, rather than its source. Unless the message is label switched all the way to the destination host, it will end up, unlabeled, in a router which does know how to route to the source of original packet, at which point the message will be sent in the proper direction.",
      "ja": "この環境では、ICMPメッセージをパケットのソースに送信するために、元のパケットからラベルスタックをICMPメッセージにコピーしてから、ICMPメッセージをラベルスイッチにコピーできます。これにより、メッセージはソースではなく、元のパケットの宛先の方向に進みます。メッセージが宛先ホストに完全に切り替えられていない限り、元のパケットのソースにルーティングする方法を知っているルーターで、それが最終的にラベル付けされ、その時点でメッセージが適切な方向に送信されます。"
    },
    {
      "indent": 3,
      "text": "This technique can be very useful if the ICMP message is a \"Time Exceeded\" message or a \"Destination Unreachable because fragmentation needed and DF set\" message.",
      "ja": "この手法は、ICMPメッセージが「時間を超えた」メッセージであるか、「断片化が必要であり、DFセット」メッセージが必要なため、「到達不可能な宛先」というメッセージである場合に非常に便利です。"
    },
    {
      "indent": 3,
      "text": "When copying the label stack from the original packet to the ICMP message, the label values must be copied exactly, but the TTL values in the label stack should be set to the TTL value that is placed in the IP header of the ICMP message. This TTL value should be long enough to allow the circuitous route that the ICMP message will need to follow.",
      "ja": "ラベルスタックを元のパケットからICMPメッセージにコピーする場合、ラベル値を正確にコピーする必要がありますが、ラベルスタックのTTL値は、ICMPメッセージのIPヘッダーに配置されたTTL値に設定する必要があります。このTTL値は、ICMPメッセージが従う必要がある回路のルートを許可するのに十分な長さでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that if a packet's TTL expiration is due to the presence of a routing loop, then if this technique is used, the ICMP message may loop as well. Since an ICMP message is never sent as a result of receiving an ICMP message, and since many implementations throttle the rate at which ICMP messages can be generated, this is not expected to pose a problem.",
      "ja": "パケットのTTLの有効期限がルーティングループの存在によるものである場合、この手法が使用される場合、ICMPメッセージもループする可能性があることに注意してください。ICMPメッセージがICMPメッセージを受信した結果、ICMPメッセージが送信されることはなく、多くの実装がICMPメッセージを生成できる速度を調整するため、これは問題を引き起こすとは予想されません。"
    },
    {
      "indent": 0,
      "text": "2.4. Processing the Time to Live Field",
      "section_title": true,
      "ja": "2.4. ライブフィールドに時間を処理します"
    },
    {
      "indent": 0,
      "text": "2.4.1. Definitions",
      "section_title": true,
      "ja": "2.4.1. 定義"
    },
    {
      "indent": 3,
      "text": "The \"incoming TTL\" of a labeled packet is defined to be the value of the TTL field of the top label stack entry when the packet is received.",
      "ja": "ラベル付きパケットの「着信TTL」は、パケットを受信したときにトップラベルスタックエントリのTTLフィールドの値と定義されます。"
    },
    {
      "indent": 3,
      "text": "The \"outgoing TTL\" of a labeled packet is defined to be the larger of:",
      "ja": "ラベル付きパケットの「発信TTL」は、次の大きさと定義されています。"
    },
    {
      "indent": 6,
      "text": "a) one less than the incoming TTL, b) zero.",
      "ja": "a) 着信TTLよりも1つ、b）ゼロ。"
    },
    {
      "indent": 0,
      "text": "2.4.2. Protocol-independent rules",
      "section_title": true,
      "ja": "2.4.2. プロトコルに依存しないルール"
    },
    {
      "indent": 3,
      "text": "If the outgoing TTL of a labeled packet is 0, then the labeled packet MUST NOT be further forwarded; nor may the label stack be stripped off and the packet forwarded as an unlabeled packet. The packet's lifetime in the network is considered to have expired.",
      "ja": "ラベル付きパケットの発信TTLが0の場合、ラベル付きパケットをさらに転送する必要はありません。また、ラベルスタックを剥がし、パケットを非標識パケットとして転送することもできません。ネットワーク内のパケットの寿命は期限切れと見なされます。"
    },
    {
      "indent": 3,
      "text": "Depending on the label value in the label stack entry, the packet MAY be simply discarded, or it may be passed to the appropriate \"ordinary\" network layer for error processing (e.g., for the generation of an ICMP error message, see section 2.3).",
      "ja": "ラベルスタックエントリのラベル値に応じて、パケットは単純に破棄されるか、エラー処理のために適切な「通常の」ネットワークレイヤーに渡される場合があります（たとえば、ICMPエラーメッセージの生成については、セクション2.3を参照）。"
    },
    {
      "indent": 3,
      "text": "When a labeled packet is forwarded, the TTL field of the label stack entry at the top of the label stack MUST be set to the outgoing TTL value.",
      "ja": "ラベル付きパケットが転送される場合、ラベルスタックの上部にあるラベルスタックエントリのTTLフィールドを発信TTL値に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that the outgoing TTL value is a function solely of the incoming TTL value, and is independent of whether any labels are pushed or popped before forwarding. There is no significance to the value of the TTL field in any label stack entry which is not at the top of the stack.",
      "ja": "発信TTL値は、着信TTL値のみの関数であり、転送前にラベルがプッシュされるかポップされるかに依存しないことに注意してください。スタックの上部にないラベルスタックエントリには、TTLフィールドの値に意味がありません。"
    },
    {
      "indent": 0,
      "text": "2.4.3. IP-dependent rules",
      "section_title": true,
      "ja": "2.4.3. IP依存規則"
    },
    {
      "indent": 3,
      "text": "We define the \"IP TTL\" field to be the value of the IPv4 TTL field, or the value of the IPv6 Hop Limit field, whichever is applicable.",
      "ja": "「IP TTL」フィールドを、IPv4 TTLフィールドの値、またはIPv6ホップ制限フィールドの値のいずれか該当する値であると定義します。"
    },
    {
      "indent": 3,
      "text": "When an IP packet is first labeled, the TTL field of the label stack entry MUST BE set to the value of the IP TTL field. (If the IP TTL field needs to be decremented, as part of the IP processing, it is assumed that this has already been done.)",
      "ja": "IPパケットが最初にラベルが付けられた場合、ラベルスタックエントリのTTLフィールドをIP TTLフィールドの値に設定する必要があります。（IP処理の一部として、IP TTLフィールドを減少させる必要がある場合、これはすでに行われていると想定されています。）"
    },
    {
      "indent": 3,
      "text": "When a label is popped, and the resulting label stack is empty, then the value of the IP TTL field SHOULD BE replaced with the outgoing TTL value, as defined above. In IPv4 this also requires modification of the IP header checksum.",
      "ja": "ラベルがポップされ、結果のラベルスタックが空になると、IP TTLフィールドの値は、上記のように発信TTL値に置き換える必要があります。IPv4では、これにはIPヘッダーチェックサムの変更も必要です。"
    },
    {
      "indent": 3,
      "text": "It is recognized that there may be situations where a network administration prefers to decrement the IPv4 TTL by one as it traverses an MPLS domain, instead of decrementing the IPv4 TTL by the number of LSP hops within the domain.",
      "ja": "ドメイン内のLSPホップの数によってIPv4 TTLを減少させるのではなく、ネットワーク管理がMPLSドメインを横断する際に、ネットワーク管理がIPv4 TTLを1つずつ減少させることを好む状況がある可能性があることが認識されています。"
    },
    {
      "indent": 0,
      "text": "2.4.4. Translating Between Different Encapsulations",
      "section_title": true,
      "ja": "2.4.4. 異なるカプセル間の翻訳"
    },
    {
      "indent": 3,
      "text": "Sometimes an LSR may receive a labeled packet over, e.g., a label switching controlled ATM (LC-ATM) interface [9], and may need to send it out over a PPP or LAN link. Then the incoming packet will not be received using the encapsulation specified in this document, but the outgoing packet will be sent using the encapsulation specified in this document.",
      "ja": "LSRは、ラベルスイッチング制御ATM（LC-ATM）インターフェイス[9]などのラベル付きパケットを受け取る場合があり、PPPまたはLANリンクを介して送信する必要がある場合があります。次に、このドキュメントで指定されたカプセル化を使用して、着信パケットは受信されませんが、このドキュメントで指定されたカプセル化を使用して送信パケットは送信されます。"
    },
    {
      "indent": 3,
      "text": "In this case, the value of the \"incoming TTL\" is determined by the procedures used for carrying labeled packets on, e.g., LC-ATM interfaces. TTL processing then proceeds as described above.",
      "ja": "この場合、「着信TTL」の値は、LC-ATMインターフェイスなど、ラベル付きパケットを運ぶために使用される手順によって決定されます。TTL処理は、上記のように進行します。"
    },
    {
      "indent": 3,
      "text": "Sometimes an LSR may receive a labeled packet over a PPP or a LAN link, and may need to send it out, say, an LC-ATM interface. Then the incoming packet will be received using the encapsulation specified in this document, but the outgoing packet will not be sent using the encapsulation specified in this document. In this case, the procedure for carrying the value of the \"outgoing TTL\" is determined by the procedures used for carrying labeled packets on, e.g., LC-ATM interfaces.",
      "ja": "LSRがPPPまたはLANリンク上にラベル付きパケットを受け取る場合があり、LC-ATMインターフェイスなどを送信する必要がある場合があります。次に、このドキュメントで指定されたカプセル化を使用して着信パケットを受信しますが、このドキュメントで指定されたカプセル化を使用して送信パケットは送信されません。この場合、「発信TTL」の値を携帯する手順は、ラベル付きパケット、たとえばLC-ATMインターフェイスに使用される手順によって決定されます。"
    },
    {
      "indent": 0,
      "text": "3. Fragmentation and Path MTU Discovery",
      "section_title": true,
      "ja": "3. 断片化とパスMTU発見"
    },
    {
      "indent": 3,
      "text": "Just as it is possible to receive an unlabeled IP datagram which is too large to be transmitted on its output link, it is possible to receive a labeled packet which is too large to be transmitted on its output link.",
      "ja": "出力リンクに送信するには大きすぎる無効なIPデータグラムを受信できるように、出力リンクに送信するには大きすぎるラベル付きパケットを受信することができます。"
    },
    {
      "indent": 3,
      "text": "It is also possible that a received packet (labeled or unlabeled) which was originally small enough to be transmitted on that link becomes too large by virtue of having one or more additional labels pushed onto its label stack. In label switching, a packet may grow in size if additional labels get pushed on. Thus if one receives a labeled packet with a 1500-byte frame payload, and pushes on an additional label, one needs to forward it as frame with a 1504-byte payload.",
      "ja": "また、1つ以上の追加ラベルがラベルスタックに押し込まれているため、元々そのリンクに送信するのに十分なほど小さかった受信したパケット（ラベル付きまたはラベル付けされていない）が可能です。ラベルスイッチングでは、追加のラベルがプッシュされると、パケットがサイズが大きくなる場合があります。したがって、1500バイトのフレームペイロードを備えたラベル付きパケットを受け取り、追加のラベルをプッシュする場合、1504バイトのペイロードでフレームとして転送する必要があります。"
    },
    {
      "indent": 3,
      "text": "This section specifies the rules for processing labeled packets which are \"too large\". In particular, it provides rules which ensure that hosts implementing Path MTU Discovery [4], and hosts using IPv6 [7,8], will be able to generate IP datagrams that do not need fragmentation, even if those datagrams get labeled as they traverse the network.",
      "ja": "このセクションでは、「大きすぎる」というラベル付きパケットを処理するルールを指定します。特に、ホストの実装PATH MTU発見[4]を実装するルールを提供し、IPv6 [7,8]を使用してホストが断片化を必要としないIPデータグラムを生成できるようにすることができます。ネットワーク。"
    },
    {
      "indent": 3,
      "text": "In general, IPv4 hosts which do not implement Path MTU Discovery [4] send IP datagrams which contain no more than 576 bytes. Since the MTUs in use on most data links today are 1500 bytes or more, the probability that such datagrams will need to get fragmented, even if they get labeled, is very small.",
      "ja": "一般に、PATH MTU Discovery [4]を実装しないIPv4ホストは、576バイト以下を含むIPデータグラムを送信します。今日のほとんどのデータリンクで使用されているMTUは1500バイト以上であるため、そのようなデータグラムがラベル付けされたとしても、そのようなデータグラムが断片化する必要がある可能性は非常に小さいです。"
    },
    {
      "indent": 3,
      "text": "Some hosts that do not implement Path MTU Discovery [4] will generate IP datagrams containing 1500 bytes, as long as the IP Source and Destination addresses are on the same subnet. These datagrams will not pass through routers, and hence will not get fragmented.",
      "ja": "PATH MTU Discovery [4]を実装しないホストの中には、IPソースと宛先アドレスが同じサブネット上にある限り、1500バイトを含むIPデータグラムを生成します。これらのデータグラムはルーターを通過せず、したがって断片化されません。"
    },
    {
      "indent": 3,
      "text": "Unfortunately, some hosts will generate IP datagrams containing 1500 bytes, as long the IP Source and Destination addresses have the same classful network number. This is the one case in which there is any risk of fragmentation when such datagrams get labeled. (Even so, fragmentation is not likely unless the packet must traverse an ethernet of some sort between the time it first gets labeled and the time it gets unlabeled.)",
      "ja": "残念ながら、一部のホストは、IPソースと宛先アドレスが同じクラスフルネットワーク番号を持つ長い間、1500バイトを含むIPデータグラムを生成します。これは、そのようなデータグラムがラベル付けされたときに断片化のリスクがある1つのケースです。（それでも、パケットが最初にラベルにされるまでの間から何らかのイーサネットを通過しなければならない場合を除き、断片化は可能性がありません。）"
    },
    {
      "indent": 3,
      "text": "This document specifies procedures which allow one to configure the network so that large datagrams from hosts which do not implement Path MTU Discovery get fragmented just once, when they are first labeled. These procedures make it possible (assuming suitable configuration) to avoid any need to fragment packets which have already been labeled.",
      "ja": "このドキュメントは、パスMTUディスカバリーを実装しないホストからの大きなデータグラムが最初にラベル付けされたときに一度断片化されるように、ネットワークを構成できるようにする手順を指定します。これらの手順により、すでにラベルが付けられているパケットをフラグメントする必要性を回避するために（適切な構成を仮定して）可能になります。"
    },
    {
      "indent": 0,
      "text": "3.1. Terminology",
      "section_title": true,
      "ja": "3.1. 用語"
    },
    {
      "indent": 3,
      "text": "With respect to a particular data link, we can use the following terms:",
      "ja": "特定のデータリンクに関しては、次の用語を使用できます。"
    },
    {
      "indent": 6,
      "text": "- Frame Payload:",
      "ja": "- フレームペイロード："
    },
    {
      "indent": 9,
      "text": "The contents of a data link frame, excluding any data link layer headers or trailers (e.g., MAC headers, LLC headers, 802.1Q headers, PPP header, frame check sequences, etc.).",
      "ja": "データリンクフレームの内容は、データリンクレイヤーヘッダーまたはトレーラー（Mac Headers、LLCヘッダー、802.1Qヘッダー、PPPヘッダー、フレームチェックシーケンスなど）を除く。"
    },
    {
      "indent": 9,
      "text": "When a frame is carrying an unlabeled IP datagram, the Frame Payload is just the IP datagram itself. When a frame is carrying a labeled IP datagram, the Frame Payload consists of the label stack entries and the IP datagram.",
      "ja": "フレームが無効なIPデータグラムを運ぶ場合、フレームペイロードはIPデータグラム自体だけです。フレームがラベル付きIPデータグラムを運ぶとき、フレームペイロードはラベルスタックエントリとIPデータグラムで構成されます。"
    },
    {
      "indent": 6,
      "text": "- Conventional Maximum Frame Payload Size:",
      "ja": "- 従来の最大フレームペイロードサイズ："
    },
    {
      "indent": 9,
      "text": "The maximum Frame Payload size allowed by data link standards. For example, the Conventional Maximum Frame Payload Size for ethernet is 1500 bytes.",
      "ja": "データリンク標準で許可される最大フレームペイロードサイズ。たとえば、イーサネットの従来の最大フレームペイロードサイズは1500バイトです。"
    },
    {
      "indent": 6,
      "text": "- True Maximum Frame Payload Size:",
      "ja": "- 真の最大フレームペイロードサイズ："
    },
    {
      "indent": 9,
      "text": "The maximum size frame payload which can be sent and received properly by the interface hardware attached to the data link.",
      "ja": "データリンクに接続されたインターフェイスハードウェアによって適切に送信および受信できる最大サイズのフレームペイロード。"
    },
    {
      "indent": 9,
      "text": "On ethernet and 802.3 networks, it is believed that the True Maximum Frame Payload Size is 4-8 bytes larger than the Conventional Maximum Frame Payload Size (as long as neither an 802.1Q header nor an 802.1p header is present, and as long as neither can be added by a switch or bridge while a packet is in transit to its next hop). For example, it is believed that most ethernet equipment could correctly send and receive packets carrying a payload of 1504 or perhaps even 1508 bytes, at least, as long as the ethernet header does not have an 802.1Q or 802.1p field.",
      "ja": "イーサネットと802.3ネットワークでは、真の最大フレームペイロードサイズは、従来の最大フレームペイロードサイズよりも4〜8バイト大きいと考えられています（802.1Qヘッダーも802.1Pヘッダーも存在しない限り、そしてパケットが次のホップに輸送されている間、どちらもスイッチやブリッジによって追加することはできません）。たとえば、イーサネットヘッダーに802.1Qまたは802.1pフィールドがない限り、ほとんどのイーサネット機器は、少なくとも1504またはおそらく1508バイトのペイロードを含むパケットを正しく送信および受信できると考えられています。"
    },
    {
      "indent": 9,
      "text": "On PPP links, the True Maximum Frame Payload Size may be virtually unbounded.",
      "ja": "PPPリンクでは、真の最大フレームペイロードサイズが実質的に無制限になる場合があります。"
    },
    {
      "indent": 6,
      "text": "- Effective Maximum Frame Payload Size for Labeled Packets:",
      "ja": "- ラベル付きパケットの効果的な最大フレームペイロードサイズ："
    },
    {
      "indent": 9,
      "text": "This is either the Conventional Maximum Frame Payload Size or the True Maximum Frame Payload Size, depending on the capabilities of the equipment on the data link and the size of the data link header being used.",
      "ja": "これは、データリンク上の機器の機能と使用されているデータリンクヘッダーのサイズに応じて、従来の最大フレームペイロードサイズまたは真の最大フレームペイロードサイズのいずれかです。"
    },
    {
      "indent": 6,
      "text": "- Initially Labeled IP Datagram:",
      "ja": "- 最初にラベル付きIPデータグラム："
    },
    {
      "indent": 9,
      "text": "Suppose that an unlabeled IP datagram is received at a particular LSR, and that the the LSR pushes on a label before forwarding the datagram. Such a datagram will be called an Initially Labeled IP Datagram at that LSR.",
      "ja": "無効なIPデータグラムが特定のLSRで受信され、LSRがデータグラムを転送する前にラベルをプッシュすると仮定します。このようなデータグラムは、そのLSRで最初にラベル付けされたIPデータグラムと呼ばれます。"
    },
    {
      "indent": 6,
      "text": "- Previously Labeled IP Datagram:",
      "ja": "- 以前にラベル付けされたIPデータグラム："
    },
    {
      "indent": 9,
      "text": "An IP datagram which had already been labeled before it was received by a particular LSR.",
      "ja": "特定のLSRによって受信される前にすでにラベル付けされていたIPデータグラム。"
    },
    {
      "indent": 0,
      "text": "3.2. Maximum Initially Labeled IP Datagram Size",
      "section_title": true,
      "ja": "3.2. 最大最初にラベル付きIPデータグラムサイズ"
    },
    {
      "indent": 3,
      "text": "Every LSR which is capable of",
      "ja": "可能なすべてのLSR"
    },
    {
      "indent": 6,
      "text": "a) receiving an unlabeled IP datagram, b) adding a label stack to the datagram, and c) forwarding the resulting labeled packet,",
      "ja": "a) ラベルのないIPデータグラムを受信し、b）データグラムにラベルスタックを追加し、c）結果のラベル付きパケットを転送する、"
    },
    {
      "indent": 3,
      "text": "SHOULD support a configuration parameter known as the \"Maximum Initially Labeled IP Datagram Size\", which can be set to a non-negative value.",
      "ja": "「最初にラベルが付いた最大IPデータグラムサイズ」と呼ばれる構成パラメーターをサポートする必要があります。これは、非陰性値に設定できます。"
    },
    {
      "indent": 3,
      "text": "If this configuration parameter is set to zero, it has no effect.",
      "ja": "この構成パラメーターがゼロに設定されている場合、効果はありません。"
    },
    {
      "indent": 3,
      "text": "If it is set to a positive value, it is used in the following way. If:",
      "ja": "正の値に設定されている場合、次の方法で使用されます。もし："
    },
    {
      "indent": 3,
      "text": " a) an unlabeled IP datagram is received, and b) that datagram does not have the DF bit set in its IP header, and c) that datagram needs to be labeled before being forwarded, and d) the size of the datagram (before labeling) exceeds the value of the parameter, then a) the datagram must be broken into fragments, each of whose size is no greater than the value of the parameter, and",
      "ja": "a）無効なIPデータグラムが受信され、b）データグラムにはIPヘッダーにDFビットが設定されていないこと、およびc）データグラムに転送する前にラベルを付ける必要があり、d）データグラムのサイズ（ラベル付けの前）パラメーターの値を超えて、a）データグラムをフラグメントに分割する必要があります。各サイズはパラメーターの値よりも大きくありません。"
    },
    {
      "indent": 6,
      "text": "b) each fragment must be labeled and then forwarded.",
      "ja": "b) 各フラグメントにラベルを付けてから転送する必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, if this configuration parameter is set to a value of 1488, then any unlabeled IP datagram containing more than 1488 bytes will be fragmented before being labeled. Each fragment will be capable of being carried on a 1500-byte data link, without further fragmentation, even if as many as three labels are pushed onto its label stack.",
      "ja": "たとえば、この構成パラメーターが1488の値に設定されている場合、1488を超えるバイトを含む非標識IPデータグラムは、ラベル付けされる前に断片化されます。 各フラグメントは、3つのラベルがラベルスタックに押し込まれていても、さらに断片化することなく、1500バイトのデータリンクで運ぶことができます。"
    },
    {
      "indent": 3,
      "text": "In other words, setting this parameter to a non-zero value allows one to eliminate all fragmentation of Previously Labeled IP Datagrams, but it may cause some unnecessary fragmentation of Initially Labeled IP Datagrams.",
      "ja": "言い換えれば、このパラメーターを非ゼロ値に設定すると、以前にラベル付けされたIPデータグラムのすべての断片化を排除できますが、最初にラベルの付いたIPデータグラムの不必要な断片化を引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "Note that the setting of this parameter does not affect the processing of IP datagrams that have the DF bit set; hence the result of Path MTU discovery is unaffected by the setting of this parameter.",
      "ja": "このパラメーターの設定は、DFビットが設定されているIPデータグラムの処理に影響しないことに注意してください。したがって、PATH MTU発見の結果は、このパラメーターの設定によって影響を受けません。"
    },
    {
      "indent": 0,
      "text": "3.3. When are Labeled IP Datagrams Too Big?",
      "section_title": true,
      "ja": "3.3. IPデータグラムが大きすぎるのはいつですか？"
    },
    {
      "indent": 3,
      "text": "A labeled IP datagram whose size exceeds the Conventional Maximum Frame Payload Size of the data link over which it is to be forwarded MAY be considered to be \"too big\".",
      "ja": "サイズが転送されるデータリンクの従来の最大フレームペイロードサイズを超えるラベル付きIPデータグラムは、「大きすぎる」と見なされる場合があります。"
    },
    {
      "indent": 3,
      "text": "A labeled IP datagram whose size exceeds the True Maximum Frame Payload Size of the data link over which it is to be forwarded MUST be considered to be \"too big\".",
      "ja": "サイズが転送されるデータリンクの真の最大フレームペイロードサイズを超えるラベル付きIPデータグラムは、「大きすぎる」と見なされる必要があります。"
    },
    {
      "indent": 3,
      "text": "A labeled IP datagram which is not \"too big\" MUST be transmitted without fragmentation.",
      "ja": "「大きすぎる」ではないラベル付きIPデータグラムは、断片化せずに送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.4. Processing Labeled IPv4 Datagrams which are Too Big",
      "section_title": true,
      "ja": "3.4. 大きすぎるIPv4データグラムというラベルの処理"
    },
    {
      "indent": 3,
      "text": "If a labeled IPv4 datagram is \"too big\", and the DF bit is not set in its IP header, then the LSR MAY silently discard the datagram.",
      "ja": "ラベル付きのIPv4データグラムが「大きすぎる」であり、DFビットがIPヘッダーに設定されていない場合、LSRはデータグラムを静かに破棄する場合があります。"
    },
    {
      "indent": 3,
      "text": "Note that discarding such datagrams is a sensible procedure only if the \"Maximum Initially Labeled IP Datagram Size\" is set to a non-zero value in every LSR in the network which is capable of adding a label stack to an unlabeled IP datagram.",
      "ja": "このようなデータグラムを破棄することは、「最初にラベル付けされたIPデータグラムサイズの最大値」がネットワーク内のすべてのLSRで非ゼロ値に設定されている場合にのみ、賢明な手順であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "If the LSR chooses not to discard a labeled IPv4 datagram which is too big, or if the DF bit is set in that datagram, then it MUST execute the following algorithm:",
      "ja": "LSRが、大きすぎるラベル付きIPv4データグラムを破棄しないことを選択した場合、またはそのデータグラムでDFビットが設定されている場合、次のアルゴリズムを実行する必要があります。"
    },
    {
      "indent": 6,
      "text": "1. Strip off the label stack entries to obtain the IP datagram.",
      "ja": "1. ラベルスタックエントリを取り除いて、IPデータグラムを取得します。"
    },
    {
      "indent": 6,
      "text": "2. Let N be the number of bytes in the label stack (i.e, 4 times the number of label stack entries).",
      "ja": "2. nをラベルスタック内のバイト数（つまり、ラベルスタックエントリの4倍）とします。"
    },
    {
      "indent": 6,
      "text": "3. If the IP datagram does NOT have the \"Don't Fragment\" bit set in its IP header:",
      "ja": "3. IPデータグラムにIPヘッダーに「断片化しない」ビットが設定されていない場合："
    },
    {
      "indent": 9,
      "text": "a. convert it into fragments, each of which MUST be at least N bytes less than the Effective Maximum Frame Payload Size.",
      "ja": "a. それをフラグメントに変換します。それぞれは、有効な最大フレームペイロードサイズよりも少なくともnバイトが少ない必要があります。"
    },
    {
      "indent": 9,
      "text": "b. Prepend each fragment with the same label header that would have been on the original datagram had fragmentation not been necessary.",
      "ja": "b. 元のデータグラムにあったであろう同じラベルヘッダーで各フラグメントをプレーニングして、フラグメンテーションが不要でした。"
    },
    {
      "indent": 9,
      "text": "c. Forward the fragments",
      "ja": "c. フラグメントを転送します"
    },
    {
      "indent": 6,
      "text": "4. If the IP datagram has the \"Don't Fragment\" bit set in its IP header:",
      "ja": "4. IPデータグラムにIPヘッダーに「断片化しない」ビットが設定されている場合："
    },
    {
      "indent": 9,
      "text": "a. the datagram MUST NOT be forwarded",
      "ja": "a. データグラムを転送してはなりません"
    },
    {
      "indent": 9,
      "text": "b. Create an ICMP Destination Unreachable Message:",
      "ja": "b. ICMP宛先の到達不可能なメッセージを作成します："
    },
    {
      "indent": 13,
      "text": "i. set its Code field [3] to \"Fragmentation Required and DF Set\",",
      "ja": "i. コードフィールド[3]を「断片化が必要とDFセット」に設定し、"
    },
    {
      "indent": 12,
      "text": "ii. set its Next-Hop MTU field [4] to the difference between the Effective Maximum Frame Payload Size and the value of N",
      "ja": "ii。次のホップMTUフィールド[4]を、有効な最大フレームペイロードサイズとnの値の差に設定します"
    },
    {
      "indent": 9,
      "text": "c. If possible, transmit the ICMP Destination Unreachable Message to the source of the of the discarded datagram.",
      "ja": "c. 可能であれば、ICMP宛先の到達不可能なメッセージを、破棄されたデータグラムのソースに送信します。"
    },
    {
      "indent": 0,
      "text": "3.5. Processing Labeled IPv6 Datagrams which are Too Big",
      "section_title": true,
      "ja": "3.5. 大きすぎるIPv6データグラムというラベルの処理"
    },
    {
      "indent": 3,
      "text": "To process a labeled IPv6 datagram which is too big, an LSR MUST execute the following algorithm:",
      "ja": "大きすぎるラベル付きのIPv6データグラムを処理するには、LSRが次のアルゴリズムを実行する必要があります。"
    },
    {
      "indent": 6,
      "text": "1. Strip off the label stack entries to obtain the IP datagram.",
      "ja": "1. ラベルスタックエントリを取り除いて、IPデータグラムを取得します。"
    },
    {
      "indent": 6,
      "text": "2. Let N be the number of bytes in the label stack (i.e., 4 times the number of label stack entries).",
      "ja": "2. nをラベルスタックのバイト数（つまり、ラベルスタックエントリの4倍）とします。"
    },
    {
      "indent": 6,
      "text": "3. If the IP datagram contains more than 1280 bytes (not counting the label stack entries), or if it does not contain a fragment header, then: a. Create an ICMP Packet Too Big Message, and set its Next-Hop MTU field to the difference between the Effective Maximum Frame Payload Size and the value of N",
      "ja": "3. IPデータグラムに1280バイト以上が含まれている場合（ラベルスタックエントリをカウントしない）、またはフラグメントヘッダーが含まれていない場合、a。ICMPパケットが大きすぎるメッセージを作成し、次のホップMTUフィールドを有効な最大フレームペイロードサイズとnの値の違いに設定します"
    },
    {
      "indent": 9,
      "text": "b. If possible, transmit the ICMP Packet Too Big Message to the source of the datagram.",
      "ja": "b. 可能であれば、ICMPパケットをデータグラムのソースにあまりにも大きなメッセージを送信します。"
    },
    {
      "indent": 9,
      "text": "c. discard the labeled IPv6 datagram.",
      "ja": "c. ラベル付けされたIPv6データグラムを破棄します。"
    },
    {
      "indent": 6,
      "text": "4. If the IP datagram is not larger than 1280 octets, and it contains a fragment header, then",
      "ja": "4. IPデータグラムが1280オクテットより大きくなく、フラグメントヘッダーが含まれている場合、"
    },
    {
      "indent": 9,
      "text": "a. Convert it into fragments, each of which MUST be at least N bytes less than the Effective Maximum Frame Payload Size.",
      "ja": "a. それをフラグメントに変換します。それぞれは、有効な最大フレームペイロードサイズよりも少なくともnバイトが少ない必要があります。"
    },
    {
      "indent": 9,
      "text": "b. Prepend each fragment with the same label header that would have been on the original datagram had fragmentation not been necessary.",
      "ja": "b. 元のデータグラムにあったであろう同じラベルヘッダーで各フラグメントをプレーニングして、フラグメンテーションが不要でした。"
    },
    {
      "indent": 9,
      "text": "c. Forward the fragments.",
      "ja": "c. フラグメントを転送します。"
    },
    {
      "indent": 9,
      "text": "Reassembly of the fragments will be done at the destination host.",
      "ja": "フラグメントの再組み立ては、宛先ホストで行われます。"
    },
    {
      "indent": 0,
      "text": "3.6. Implications with respect to Path MTU Discovery",
      "section_title": true,
      "ja": "3.6. Path MTU発見に関する意味"
    },
    {
      "indent": 3,
      "text": "The procedures described above for handling datagrams which have the DF bit set, but which are \"too large\", have an impact on the Path MTU Discovery procedures of RFC 1191 [4]. Hosts which implement these procedures will discover an MTU which is small enough to allow n labels to be pushed on the datagrams, without need for fragmentation, where n is the number of labels that actually get pushed on along the path currently in use.",
      "ja": "DFビットが設定されているが「大きすぎる」データグラムを処理するための上記の手順は、RFC 1191のパスMTU発見手順に影響を与えます[4]。これらの手順を実装するホストは、断片化を必要とせずに、nラベルをデータグラムにプッシュできるほど小さいMTUを発見します。ここで、nは現在使用中のパスに沿って実際にプッシュされるラベルの数です。"
    },
    {
      "indent": 3,
      "text": "In other words, datagrams from hosts that use Path MTU Discovery will never need to be fragmented due to the need to put on a label header, or to add new labels to an existing label header. (Also, datagrams from hosts that use Path MTU Discovery generally have the DF bit set, and so will never get fragmented anyway.)",
      "ja": "言い換えれば、Path MTU Discoveryを使用するホストからのデータグラムは、ラベルヘッダーを置く必要があるか、既存のラベルヘッダーに新しいラベルを追加する必要があるため、断片化する必要はありません。 （また、Path MTU Discoveryを使用するホストからのデータグラムには、一般にDFビットが設定されているため、とにかく断片化されることはありません。）"
    },
    {
      "indent": 3,
      "text": "Note that Path MTU Discovery will only work properly if, at the point where a labeled IP Datagram's fragmentation needs to occur, it is possible to cause an ICMP Destination Unreachable message to be routed to the packet's source address. See section 2.3.",
      "ja": "PATH MTUの発見は、ラベル付きIPデータグラムのフラグメンテーションが発生する必要がある時点で、ICMP宛先の到達不可能なメッセージをパケットのソースアドレスにルーティングすることができる場合にのみ適切に機能することに注意してください。セクション2.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "If it is not possible to forward an ICMP message from within an MPLS \"tunnel\" to a packet's source address, but the network configuration makes it possible for the LSR at the transmitting end of the tunnel to receive packets that must go through the tunnel, but are too large to pass through the tunnel unfragmented, then:",
      "ja": "MPLS「トンネル」内からICMPメッセージをパケットのソースアドレスに転送することができない場合は、ネットワーク構成により、トンネルの送信端でLSRがトンネルを通過する必要があるパケットを受信することが可能になります。しかし、トンネルを通過するには大きすぎてフレーミングされていません。"
    },
    {
      "indent": 6,
      "text": "- The LSR at the transmitting end of the tunnel MUST be able to determine the MTU of the tunnel as a whole. It MAY do this by sending packets through the tunnel to the tunnel's receiving endpoint, and performing Path MTU Discovery with those packets.",
      "ja": "- トンネルの送信端にあるLSRは、トンネル全体のMTUを決定できる必要があります。これは、トンネルを介してトンネルの受信エンドポイントにパケットを送信し、それらのパケットでPATH MTU発見を実行することでこれを行う場合があります。"
    },
    {
      "indent": 6,
      "text": "- Any time the transmitting endpoint of the tunnel needs to send a packet into the tunnel, and that packet has the DF bit set, and it exceeds the tunnel MTU, the transmitting endpoint of the tunnel MUST send the ICMP Destination Unreachable message to the source, with code \"Fragmentation Required and DF Set\", and the Next-Hop MTU Field set as described above.",
      "ja": "- トンネルの送信エンドポイントがトンネルにパケットを送信する必要があり、そのパケットにはDFビットが設定され、トンネルMTUを超える場合、トンネルの送信エンドポイントはICMP宛先の到達不可能なメッセージをソースに送信する必要があります。コード「フラグメンテーションが必要とDFセット」、および上記のように次のホップMTUフィールドセットを使用して。"
    },
    {
      "indent": 0,
      "text": "4. Transporting Labeled Packets over PPP",
      "section_title": true,
      "ja": "4. ラベル付きパケットをPPPに輸送します"
    },
    {
      "indent": 3,
      "text": "The Point-to-Point Protocol (PPP) [6] provides a standard method for transporting multi-protocol datagrams over point-to-point links. PPP defines an extensible Link Control Protocol, and proposes a family of Network Control Protocols for establishing and configuring different network-layer protocols.",
      "ja": "ポイントツーポイントプロトコル（PPP）[6]は、ポイントツーポイントリンクを介してマルチプロトコルデータグラムを輸送するための標準的な方法を提供します。PPPは、拡張可能なリンク制御プロトコルを定義し、さまざまなネットワーク層プロトコルを確立および構成するためのネットワーク制御プロトコルのファミリーを提案します。"
    },
    {
      "indent": 3,
      "text": "This section defines the Network Control Protocol for establishing and configuring label Switching over PPP.",
      "ja": "このセクションでは、PPPでラベルスイッチングを確立および構成するためのネットワーク制御プロトコルを定義します。"
    },
    {
      "indent": 0,
      "text": "4.1. Introduction",
      "section_title": true,
      "ja": "4.1. はじめに"
    },
    {
      "indent": 3,
      "text": "PPP has three main components:",
      "ja": "PPPには3つの主要なコンポーネントがあります。"
    },
    {
      "indent": 6,
      "text": "1. A method for encapsulating multi-protocol datagrams.",
      "ja": "1. マルチプロトコルデータグラムをカプセル化する方法。"
    },
    {
      "indent": 6,
      "text": "2. A Link Control Protocol (LCP) for establishing, configuring, and testing the data-link connection.",
      "ja": "2. データリンク接続を確立、構成、テストするためのリンク制御プロトコル（LCP）。"
    },
    {
      "indent": 6,
      "text": "3. A family of Network Control Protocols for establishing and configuring different network-layer protocols.",
      "ja": "3. さまざまなネットワーク層プロトコルを確立および構成するためのネットワーク制御プロトコルのファミリー。"
    },
    {
      "indent": 3,
      "text": "In order to establish communications over a point-to-point link, each end of the PPP link must first send LCP packets to configure and test the data link. After the link has been established and optional facilities have been negotiated as needed by the LCP, PPP must send \"MPLS Control Protocol\" packets to enable the transmission of labeled packets. Once the \"MPLS Control Protocol\" has reached the Opened state, labeled packets can be sent over the link.",
      "ja": "ポイントツーポイントリンクで通信を確立するには、PPPリンクの各端が最初にLCPパケットを送信して、データリンクを構成およびテストする必要があります。リンクが確立され、LCPが必要に応じてオプションの施設が交渉された後、PPPはラベル付きパケットの送信を有効にするために「MPLS制御プロトコル」パケットを送信する必要があります。「MPLS制御プロトコル」が開いた状態に到達すると、ラベル付きパケットをリンク上に送信できます。"
    },
    {
      "indent": 3,
      "text": "The link will remain configured for communications until explicit LCP or MPLS Control Protocol packets close the link down, or until some external event occurs (an inactivity timer expires or network administrator intervention).",
      "ja": "リンクは、明示的なLCPまたはMPLS制御プロトコルパケットがリンクを閉じるか、外部イベントが発生するまで通信用に構成されたままになります（非アクティブタイマーが期限切れまたはネットワーク管理者の介入）。"
    },
    {
      "indent": 0,
      "text": "4.2. A PPP Network Control Protocol for MPLS",
      "section_title": true,
      "ja": "4.2. MPLSのPPPネットワーク制御プロトコル"
    },
    {
      "indent": 3,
      "text": "The MPLS Control Protocol (MPLSCP) is responsible for enabling and disabling the use of label switching on a PPP link. It uses the same packet exchange mechanism as the Link Control Protocol (LCP). MPLSCP packets may not be exchanged until PPP has reached the Network-Layer Protocol phase. MPLSCP packets received before this phase is reached should be silently discarded.",
      "ja": "MPLSコントロールプロトコル（MPLSCP）は、PPPリンクでのラベルスイッチングの使用を可能にし、無効にする責任があります。リンク制御プロトコル（LCP）と同じパケット交換メカニズムを使用します。MPLSCPパケットは、PPPがネットワーク層プロトコルフェーズに達するまで交換されない場合があります。このフェーズに到達する前に受信したMPLSCPパケットは、静かに廃棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "The MPLS Control Protocol is exactly the same as the Link Control Protocol [6] with the following exceptions:",
      "ja": "MPLS制御プロトコルは、次の例外を除いて、リンク制御プロトコル[6]とまったく同じです。"
    },
    {
      "indent": 6,
      "text": "1. Frame Modifications",
      "ja": "1. フレームの変更"
    },
    {
      "indent": 9,
      "text": "The packet may utilize any modifications to the basic frame format which have been negotiated during the Link Establishment phase.",
      "ja": "パケットは、リンク確立段階でネゴシエートされた基本フレーム形式の変更を使用する場合があります。"
    },
    {
      "indent": 6,
      "text": "2. Data Link Layer Protocol Field",
      "ja": "2. データリンクレイヤープロトコルフィールド"
    },
    {
      "indent": 9,
      "text": "Exactly one MPLSCP packet is encapsulated in the PPP Information field, where the PPP Protocol field indicates type hex 8281 (MPLS).",
      "ja": "正確に1つのMPLSCPパケットがPPP情報フィールドにカプセル化されており、PPPプロトコルフィールドはタイプHEX 8281（MPLS）を示します。"
    },
    {
      "indent": 6,
      "text": "3. Code field",
      "ja": "3. コードフィールド"
    },
    {
      "indent": 9,
      "text": "Only Codes 1 through 7 (Configure-Request, Configure-Ack, Configure-Nak, Configure-Reject, Terminate-Request, Terminate-Ack and Code-Reject) are used. Other Codes should be treated as unrecognized and should result in Code-Rejects.",
      "ja": "コード1〜7（configure-request、configure-ack、configure-nak、configure-reject、terminate-request、continate-cack、code-reject）のみが使用されます。他のコードは認識されていないものとして扱われるべきであり、コード抵抗をもたらす必要があります。"
    },
    {
      "indent": 6,
      "text": "4. Timeouts",
      "ja": "4. タイムアウト"
    },
    {
      "indent": 9,
      "text": "MPLSCP packets may not be exchanged until PPP has reached the Network-Layer Protocol phase. An implementation should be prepared to wait for Authentication and Link Quality Determination to finish before timing out waiting for a Configure-Ack or other response. It is suggested that an implementation give up only after user intervention or a configurable amount of time.",
      "ja": "MPLSCPパケットは、PPPがネットワーク層プロトコルフェーズに達するまで交換されない場合があります。認証を待つように実装を準備し、Configure-ackまたはその他の応答を待つタイミングを出す前に、品質決定をリンクする必要があります。実装は、ユーザーの介入または構成可能な時間の後にのみあきらめることが示唆されています。"
    },
    {
      "indent": 6,
      "text": "5. Configuration Option Types",
      "ja": "5. 構成オプションタイプ"
    },
    {
      "indent": 9,
      "text": "None.",
      "ja": "なし。"
    },
    {
      "indent": 0,
      "text": "4.3. Sending Labeled Packets",
      "section_title": true,
      "ja": "4.3. ラベル付きパケットを送信します"
    },
    {
      "indent": 3,
      "text": "Before any labeled packets may be communicated, PPP must reach the Network-Layer Protocol phase, and the MPLS Control Protocol must reach the Opened state.",
      "ja": "ラベル付きパケットが通信される前に、PPPはネットワーク層プロトコルフェーズに到達する必要があり、MPLS制御プロトコルは開かれた状態に到達する必要があります。"
    },
    {
      "indent": 3,
      "text": "Exactly one labeled packet is encapsulated in the PPP Information field, where the PPP Protocol field indicates either type hex 0281 (MPLS Unicast) or type hex 0283 (MPLS Multicast). The maximum length of a labeled packet transmitted over a PPP link is the same as the maximum length of the Information field of a PPP encapsulated packet.",
      "ja": "PPPプロトコルフィールドは、PPPプロトコルフィールドがタイプHEX 0281（MPLSユニキャスト）またはタイプHEX 0283（MPLSマルチキャスト）のいずれかを示すPPP情報フィールドに正確に1つのラベルパケットがカプセル化されています。PPPリンク上に送信されたラベル付きパケットの最大長は、PPPカプセル化されたパケットの情報フィールドの最大長と同じです。"
    },
    {
      "indent": 3,
      "text": "The format of the Information field itself is as defined in section 2.",
      "ja": "情報フィールド自体の形式は、セクション2で定義されています。"
    },
    {
      "indent": 3,
      "text": "Note that two codepoints are defined for labeled packets; one for multicast and one for unicast. Once the MPLSCP has reached the Opened state, both label switched multicasts and label switched unicasts can be sent over the PPP link.",
      "ja": "ラベル付きパケット用に2つのコードポイントが定義されていることに注意してください。マルチキャスト用、1つはユニキャスト用です。MPLSCPが開いた状態に到達すると、ラベルスイッチされたマルチキャストとラベルスイッチされたユニキャストの両方をPPPリンク上に送信できます。"
    },
    {
      "indent": 0,
      "text": "4.4. Label Switching Control Protocol Configuration Options",
      "section_title": true,
      "ja": "4.4. ラベルスイッチング制御プロトコル構成オプション"
    },
    {
      "indent": 3,
      "text": "There are no configuration options.",
      "ja": "構成オプションはありません。"
    },
    {
      "indent": 0,
      "text": "5. Transporting Labeled Packets over LAN Media",
      "section_title": true,
      "ja": "5. LANメディア上のラベル付きパケットを輸送します"
    },
    {
      "indent": 3,
      "text": "Exactly one labeled packet is carried in each frame.",
      "ja": "各フレームに1つのラベル付きパケットが運ばれます。"
    },
    {
      "indent": 3,
      "text": "The label stack entries immediately precede the network layer header, and follow any data link layer headers, including, e.g., any 802.1Q headers that may exist.",
      "ja": "ラベルスタックエントリはネットワークレイヤーヘッダーの直前に、存在する可能性のある802.1Qヘッダーなど、データリンクレイヤーヘッダーに従います。"
    },
    {
      "indent": 3,
      "text": "The ethertype value 8847 hex is used to indicate that a frame is carrying an MPLS unicast packet.",
      "ja": "EtherType値8847 HEXは、フレームがMPLSユニキャストパケットを運んでいることを示すために使用されます。"
    },
    {
      "indent": 3,
      "text": "The ethertype value 8848 hex is used to indicate that a frame is carrying an MPLS multicast packet.",
      "ja": "EtherType値8848 HEXは、フレームがMPLSマルチキャストパケットを運んでいることを示すために使用されます。"
    },
    {
      "indent": 3,
      "text": "These ethertype values can be used with either the ethernet encapsulation or the 802.3 LLC/SNAP encapsulation to carry labeled packets. The procedure for choosing which of these two encapsulations to use is beyond the scope of this document.",
      "ja": "これらのEtherType値は、イーサネットカプセル化または802.3 LLC/SNAPカプセル化のいずれかで使用して、ラベル付きパケットを運ぶことができます。使用するこれら2つのカプセルのどれを選択する手順は、このドキュメントの範囲を超えています。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "Label values 0-15 inclusive have special meaning, as specified in this document, or as further assigned by IANA.",
      "ja": "ラベル値0-15インクルーシブには、このドキュメントで指定されているように、またはIANAによってさらに割り当てられた特別な意味があります。"
    },
    {
      "indent": 3,
      "text": "In this document, label values 0-3 are specified in section 2.1.",
      "ja": "このドキュメントでは、ラベル値0-3がセクション2.1で指定されています。"
    },
    {
      "indent": 3,
      "text": "Label values 4-15 may be assigned by IANA, based on IETF Consensus.",
      "ja": "ラベル値4-15は、IETFコンセンサスに基づいてIANAによって割り当てられる場合があります。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The MPLS encapsulation that is specified herein does not raise any security issues that are not already present in either the MPLS architecture [1] or in the architecture of the network layer protocol contained within the encapsulation.",
      "ja": "本明細書で指定されているMPLSカプセル化は、MPLSアーキテクチャ[1]のいずれにも存在していないセキュリティの問題を提起しません。"
    },
    {
      "indent": 3,
      "text": "There are two security considerations inherited from the MPLS architecture which may be pointed out here:",
      "ja": "MPLSアーキテクチャから継承された2つのセキュリティ上の考慮事項があります。"
    },
    {
      "indent": 6,
      "text": "- Some routers may implement security procedures which depend on the network layer header being in a fixed place relative to the data link layer header. These procedures will not work when the MPLS encapsulation is used, because that encapsulation is of a variable size.",
      "ja": "- 一部のルーターは、データリンクレイヤーヘッダーに比べて固定場所にあるネットワークレイヤーヘッダーに依存するセキュリティ手順を実装する場合があります。これらの手順は、MPLSカプセル化が使用されている場合には機能しません。そのカプセル化はさまざまなサイズであるためです。"
    },
    {
      "indent": 6,
      "text": "- An MPLS label has its meaning by virtue of an agreement between the LSR that puts the label in the label stack (the \"label writer\"), and the LSR that interprets that label (the \"label reader\"). However, the label stack does not provide any means of determining who the label writer was for any particular label. If labeled packets are accepted from untrusted sources, the result may be that packets are routed in an illegitimate manner.",
      "ja": "- MPLSラベルは、ラベルをラベルスタック（「ラベルライター」）に配置するLSRと、そのラベルを解釈するLSR（「ラベルリーダー」）との間の合意により、その意味を持っています。ただし、ラベルスタックは、ラベルライターが特定のラベルに対して誰であるかを決定する手段を提供しません。ラベル付きパケットが信頼できないソースから受け入れられている場合、その結果、パケットは非合法的な方法でルーティングされます。"
    },
    {
      "indent": 0,
      "text": "8. Intellectual Property",
      "section_title": true,
      "ja": "8. 知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF has been notified of intellectual property rights claimed in regard to some or all of the specification contained in this document. For more information consult the online list of claimed rights.",
      "ja": "IETFは、このドキュメントに含まれる仕様の一部またはすべてに関して請求された知的財産権について通知されています。詳細については、請求権のオンラインリストを参照してください。"
    },
    {
      "indent": 0,
      "text": "9. Authors' Addresses",
      "section_title": true,
      "ja": "9. 著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Eric C. Rosen Cisco Systems, Inc. 250 Apollo Drive Chelmsford, MA, 01824",
      "ja": "Eric C. Rosen Cisco Systems、Inc。250 Apollo Drive Chelmsford、MA、01824"
    },
    {
      "indent": 3,
      "text": "EMail: erosen@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dan Tappan Cisco Systems, Inc. 250 Apollo Drive Chelmsford, MA, 01824",
      "ja": "Dan Tappan Cisco Systems、Inc。250 Apollo Drive Chelmsford、MA、01824"
    },
    {
      "indent": 3,
      "text": "EMail: tappan@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Yakov Rekhter Juniper Networks 1194 N. Mathilda Avenue Sunnyvale, CA 94089",
      "ja": "Yakov Rekhter Juniper Networks 1194 N. Mathilda Avenue Sunnyvale、CA 94089"
    },
    {
      "indent": 3,
      "text": "EMail: yakov@juniper.net",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Guy Fedorkow Cisco Systems, Inc. 250 Apollo Drive Chelmsford, MA, 01824",
      "ja": "Guy Fedorkow Cisco Systems、Inc。250 Apollo Drive Chelmsford、MA、01824"
    },
    {
      "indent": 3,
      "text": "EMail: fedorkow@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dino Farinacci Procket Networks, Inc. 3910 Freedom Circle, Ste. 102A Santa Clara, CA 95054",
      "ja": "Dino Farinacci Procket Networks、Inc。3910 Freedom Circle、Ste。102a Santa Clara、CA 95054"
    },
    {
      "indent": 3,
      "text": "EMail: dino@procket.com\n   Tony Li\nProcket Networks, Inc.\n3910 Freedom Circle, Ste. 102A\nSanta Clara, CA 95054",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "EMail: tli@procket.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Alex Conta TranSwitch Corporation 3 Enterprise Drive Shelton, CT, 06484",
      "ja": "Alex Conta Transwitch Corporation 3エンタープライズドライブシェルトン、コネチカット州、06484"
    },
    {
      "indent": 3,
      "text": "EMail: aconta@txc.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 3,
      "text": "[1] Rosen, E., Viswanathan, A., and R. Callon, \"Multiprotocol Label Switching Architecture\", RFC 3031, January 2001.",
      "ja": "[1] Rosen、E.、Viswanathan、A。、およびR. Callon、「Multiprotocolラベルスイッチングアーキテクチャ」、RFC 3031、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[2] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[2] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[3] Postel, J., \"Internet Control Message Protocol\", STD 5, RFC 792, September 1981.",
      "ja": "[3] Postel、J。、「インターネットコントロールメッセージプロトコル」、STD 5、RFC 792、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[4] Mogul, J. and S. Deering, \"Path MTU Discovery\", RFC 1191, November 1990.",
      "ja": "[4] Mogul、J。およびS. Deering、「Path MTU Discovery」、RFC 1191、1990年11月。"
    },
    {
      "indent": 3,
      "text": "[5] Katz, D., \"IP Router Alert Option\", RFC 2113, February 1997.",
      "ja": "[5] Katz、D。、「IPルーターアラートオプション」、RFC 2113、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[6] Simpson, W., Editor, \"The Point-to-Point Protocol (PPP)\", STD 51, RFC 1661, July 1994.",
      "ja": "[6] シンプソン、W。、編集者、「ポイントツーポイントプロトコル（PPP）」、STD 51、RFC 1661、1994年7月。"
    },
    {
      "indent": 3,
      "text": "[7] Conta, A. and S. Deering, \"Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification\", RFC 1885, December 1995.",
      "ja": "[7] Conta、A。およびS. Deering、「インターネットプロトコルバージョン6（IPv6）仕様のインターネット制御メッセージプロトコル（ICMPV6）」、RFC 1885、1995年12月。"
    },
    {
      "indent": 3,
      "text": "[8] McCann, J., Deering, S. and J. Mogul, \"Path MTU Discovery for IP version 6\", RFC 1981, August 1996.",
      "ja": "[8] McCann、J.、Deering、S。、およびJ. Mogul、「IPバージョン6のPath MTU Discovery」、RFC 1981、1996年8月。"
    },
    {
      "indent": 3,
      "text": "[9] Davie, B., Lawrence, J., McCloghrie, K., Rekhter, Y., Rosen, E. and G. Swallow, \"MPLS Using LDP and ATM VC Switching\", RFC 3035, January 2001.",
      "ja": "[9] Davie、B.、Lawrence、J.、McCloghrie、K.、Rekhter、Y.、Rosen、E。and G. Swallow、「LDPおよびATM VCスイッチングを使用したMPLS」、RFC 3035、2001年1月。"
    },
    {
      "indent": 0,
      "text": "11. Full Copyright Statement",
      "section_title": true,
      "ja": "11. 完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2001）。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書と本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}