{
  "title": {
    "text": "RFC 3072 - Structured Data Exchange Format (SDXF)",
    "ja": "RFC 3072 - 構造化されたデータ交換形式（SDXF）"
  },
  "number": 3072,
  "created_at": "2023-12-23 11:17:49.441070+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                       M. Wildgrube\nRequest for Comments: 3072                                    March 2001\nCategory: Informational",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Structured Data Exchange Format (SDXF)",
      "ja": "構造化されたデータ交換形式（SDXF）"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモは、インターネットコミュニティに情報を提供します。いかなる種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2001）。無断転載を禁じます。"
    },
    {
      "indent": 0,
      "text": "IESG Note",
      "ja": "IESGノート"
    },
    {
      "indent": 3,
      "text": "This document specifies a data exchange format and, partially, an API that can be used for creating and parsing such a format. The IESG notes that the same problem space can be addressed using formats that the IETF normally uses including ASN.1 and XML. The document reader is strongly encouraged to carefully read section 13 before choosing SDXF over ASN.1 or XML. Further, when storing text in SDXF, the user is encourage to use the datatype for UTF-8, specified in section 2.5.",
      "ja": "このドキュメントは、データ交換形式と、そのような形式の作成と解析に使用できるAPIを部分的に指定します。IESGは、IETFがASN.1やXMLを含む通常使用する形式を使用して、同じ問題空間に対処できることを指摘しています。ドキュメントリーダーは、ASN.1またはXMLよりもSDXFを選択する前に、セクション13を注意深く読むことを強くお勧めします。さらに、テキストをSDXFに保存する場合、ユーザーはセクション2.5で指定されたUTF-8にデータ型を使用することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This specification describes an all-purpose interchange format for use as a file format or for net-working. Data is organized in chunks which can be ordered in hierarchical structures. This format is self-describing and CPU-independent.",
      "ja": "この仕様では、ファイル形式またはネットワーキングに使用するための汎用インターチェンジ形式について説明します。データは、階層構造で注文できるチャンクで編成されています。この形式は、自己記述的であり、CPUに依存しません。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction ................................................. 2\n2.  Description of the SDXF data format .......................... 3\n3.  Introduction to the SDXF functions ........................... 5\n3.1 General remarks .............................................. 5\n3.2 Writing a SDXF buffer ........................................ 5\n3.3 Reading a SDXF buffer ........................................ 6\n3.4 Example ...................................................... 6\n4.  Platform independence ........................................ 8\n5.  Compression .................................................. 9\n6.  Encryption ...................................................11\n7.  Arrays........................................................11\n8.  Description of the SDXF functions ............................12\n   8.1 Introduction .................................................12\n8.2 Basic definitions ............................................13\n8.3 Definitions for C++ ..........................................15\n8.4 Common Definitions ...........................................16\n8.5 Special functions ............................................17\n9.  'Support' of UTF-8 ...........................................19\n10.  Security Considerations .....................................19\n11.  Some general hints ..........................................20\n12.  IANA Considerations .........................................20\n13.  Discussion ..................................................21\n13.1 SDXF vs. ASN.1 ..............................................21\n13.2 SDXF vs. XML ................................................22\n14.  Author's Address ............................................24\n15.  Acknowledgements ............................................24\n16.  References ..................................................24\n17.  Full Copyright Statement ....................................26",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The purpose of the Structured Data eXchange Format (SDXF) is to permit the interchange of an arbitrary structured data block with different kinds of data (numerical, text, bitstrings). Because data is normalized to an abstract computer architecture independent \"network format\", SDXF is usable as a network interchange data format.",
      "ja": "構造化されたデータ交換形式（SDXF）の目的は、異なる種類のデータ（数値、テキスト、ビットストリング）を持つ任意の構造化データブロックの交換を許可することです。データは抽象的なコンピューターアーキテクチャに依存しない「ネットワーク形式」に正規化されるため、SDXFはネットワークインターチェンジデータ形式として使用可能です。"
    },
    {
      "indent": 3,
      "text": "This data format is not limited to any application, the demand for this format is that it is usable as a text format for word-processing, as a picture format, a sound format, for remote procedure calls with complex parameters, suitable for document formats, for interchanging business data, etc.",
      "ja": "このデータ形式はアプリケーションに限定されません。この形式の需要は、文書形式に適した複雑なパラメーターを使用したリモート手順呼び出しの画像形式、サウンド形式として、ワードプロセスのテキスト形式として使用可能であることです。、交換するビジネスデータなど。"
    },
    {
      "indent": 3,
      "text": "SDXF is self-describing, every program can unpack every SDXF-data without knowing the meaning of the individual data elements.",
      "ja": "SDXFは自己記述的であり、すべてのプログラムは、個々のデータ要素の意味を知らずにすべてのSDXF-DATAを開梱できます。"
    },
    {
      "indent": 3,
      "text": "Together with the description of the data format a set of functions will be introduced. With the help of these functions one can create and access the data elements of SDXF. The idea is that a programmer should only use these functions instead of maintaining the structure by himself on the level of bits and bytes. (In the speech of object-oriented programming these functions are methods of an object which works as a handle for a given SDXF data block.)",
      "ja": "データ形式の説明とともに、一連の関数が導入されます。これらの機能の助けを借りて、SDXFのデータ要素を作成およびアクセスできます。アイデアは、プログラマーは、ビットとバイトのレベルで自分で構造を維持するのではなく、これらの関数のみを使用する必要があるということです。（オブジェクト指向プログラミングのスピーチでは、これらの関数は、特定のSDXFデータブロックのハンドルとして機能するオブジェクトの方法です。）"
    },
    {
      "indent": 3,
      "text": "SDXF is not limited to a specific platform, along with a correct preparation of the SDXF functions the SDXF data can be interchanged (via network or data carrier) across the boundaries of different architectures (specified by the character code like ASCII, ANSI or EBCDIC and the byte order for binary data).",
      "ja": "SDXFは特定のプラットフォームに限定されません。SDXF関数の正しい準備とともに、SDXFデータは（ネットワークまたはデータキャリアを介して）異なるアーキテクチャの境界を越えて交換できます（ASCII、ANSI、EBCDICなどの文字コードで指定されています。バイナリデータのバイト順序）。"
    },
    {
      "indent": 3,
      "text": "SDXF is also prepared to compress and encrypt parts or the whole block of SDXF data.",
      "ja": "SDXFは、部品またはSDXFデータのブロック全体を圧縮および暗号化する準備もできています。"
    },
    {
      "indent": 0,
      "text": "2. Description of SDXF data format.",
      "ja": "2. SDXFデータ形式の説明。"
    },
    {
      "indent": 0,
      "text": "2.1 First we introduce the term \"chunk\". A chunk is a data structure with a fixed set of components. A chunk may be \"elementary\" or \"structured\". The latter one contains itself one or more other chunks.",
      "ja": "2.1 最初に「チャンク」という用語を紹介します。チャンクは、コンポーネントの固定セットを備えたデータ構造です。チャンクは、「小学校」または「構造化」される場合があります。後者には、1つ以上の他のチャンクが含まれています。"
    },
    {
      "indent": 3,
      "text": "A chunk consists of a header and the data body (content):",
      "ja": "チャンクは、ヘッダーとデータ本体（コンテンツ）で構成されています。"
    },
    {
      "indent": 3,
      "text": "+----------+-----+-------+-----------------------------------+\n| Name     | Pos.| Length| Description                       |\n+----------+-----+-------+-----------------------------------+\n| chunk-ID |  1  |   2   | ID of the chunk (unsigned short)  |\n| flags    |  3  |   1   | type and properties of this chunk |\n| length   |  4  |   3   | length  of the following data     |\n| content  |  7  |   *)  | net data or a list of of chunks   |\n+----------+-----+-------+-----------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(* as stated in \"length\". total length of chunk is length+6. The chunk ID is a non-zero positive number.",
      "ja": "（*「長さ」で述べられているように。チャンクの全長は長さ6です。チャンクIDはゼロ以外の正の数です。"
    },
    {
      "indent": 3,
      "text": "or more visually:",
      "ja": "またはより視覚的に："
    },
    {
      "indent": 3,
      "text": "+----+----+----+----+----+----+----+----+----+-...\n| chunkID | fl | length       |  content\n+----+----+----+----+----+----+----+----+----+-...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "or in ASN.1 syntax:",
      "ja": "またはasn.1構文："
    },
    {
      "indent": 3,
      "text": "chunk  ::=  SEQUENCE\n{\n  chunkID INTEGER (1..65535),\n  flags   BIT STRING,\n  length  OCTET STRING SIZE 3, -- or: INTEGER (0..16777215)\n  content OCTET STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.2 Structured chunk.",
      "ja": "2.2 構造化されたチャンク。"
    },
    {
      "indent": 3,
      "text": "A structured chunk is marked as such by the flag byte (see 2.5). Opposed to an elementary chunk its content consists of a list of chunks (elementary or structured):",
      "ja": "構造化されたチャンクは、フラグバイトによってそのようにマークされます（2.5を参照）。小学校とは対照的に、そのコンテンツはチャンクのリスト（小学校または構造化）で構成されています。"
    },
    {
      "indent": 3,
      "text": "+----+-+---+-------+-------+-------+-----+-------+\n| id |f|len| chunk | chunk | chunk | ... | chunk |\n+----+-+---+-------+-------+-------+-----+-------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "With the help of this concept you can reproduce every hierarchically structured data into a SDXF chunk.",
      "ja": "この概念の助けを借りて、すべての階層的に構造化されたデータをSDXFチャンクに再現できます。"
    },
    {
      "indent": 0,
      "text": "2.3 Some Remarks about the internal representation of the chunk's elements:",
      "ja": "2.3 チャンクの要素の内部表現に関するいくつかの発言："
    },
    {
      "indent": 3,
      "text": "Binary values are always in high-order-first (big endian) format, like the binary values in the IP header (network format). A length of 300 (=256 + 32 + 12) is stored as",
      "ja": "バイナリ値は、IPヘッダー（ネットワーク形式）のバイナリ値と同様に、常に高次（ビッグエンディアン）形式です。300の長さ（= 256 32 12）が保存されます"
    },
    {
      "indent": 3,
      "text": "+----+----+----+----+----+----+----+----+----+--\n|         |    | 00   01   2C |  content\n+----+----+----+----+----+----+----+----+----+--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "in hexadecimal notation.",
      "ja": "16進表で。"
    },
    {
      "indent": 3,
      "text": "This is also valid for the chunk-ID.",
      "ja": "これは、Chunk-IDにも有効です。"
    },
    {
      "indent": 0,
      "text": "2.4 Character values in the content portion are also an object of adaptation: see chapter 4.",
      "ja": "2.4 コンテンツ部分の文字値は、適応のオブジェクトでもあります。第4章を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.5 Meaning of the flag-bits: Let us represent the flag byte in this manner:",
      "ja": "2.5 フラッグビットの意味：この方法でフラグバイトを表してみましょう。"
    },
    {
      "indent": 5,
      "text": "+-+-+-+-+-+-+-+-+\n|0|1|2|3|4|5|6|7|\n+-+-+-+-+-+-+-+-+\n | | | | | | | |\n | | | | | | | +-- reserved\n | | | | | | +---- array\n | | | | | +------ short chunk\n | | | | +-------- encrypted chunk\n | | | +---------- compressed chunk\n | | |\n +-+-+------------ data type (0..7)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "data types are:",
      "ja": "データ型は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "0 -- pending structure (chunk is inconsistent, see also 11.1) 1 -- structure 2 -- bit string 3 -- numeric 4 -- character 5 -- float (ANSI/IEEE 754-1985) 6 -- UTF-8 7 -- reserved",
      "ja": "0-保留構造（チャンクは一貫性がない、11.1も参照）1-構造2-ビット文字列3-数値4-文字5-フロート（ANSI/IEEE 754-1985）6-UTF-8 7 -  予約済み"
    },
    {
      "indent": 0,
      "text": "2.6 A short chunk has no data body. The 3 byte Length field is used as data bytes instead. This is used in order to save space when there are many small chunks.",
      "ja": "2.6 短いチャンクにはデータ本文がありません。3バイトの長さフィールドは、代わりにデータバイトとして使用されます。これは、多くの小さなチャンクがあるときにスペースを節約するために使用されます。"
    },
    {
      "indent": 0,
      "text": "2.7 Compressed and encrypted chunks are explained in chapter 5 and 6.",
      "ja": "2.7 圧縮および暗号化されたチャンクについては、第5章と6章で説明しています。"
    },
    {
      "indent": 0,
      "text": "2.8 Arrays are explained in chapter 7.",
      "ja": "2.8 アレイについては、第7章で説明しています。"
    },
    {
      "indent": 0,
      "text": "2.9 Handling of UTF-8 is explained in chapter 9.",
      "ja": "2.9 UTF-8の処理については、第9章で説明しています。"
    },
    {
      "indent": 0,
      "text": "2.10 Not all combinations of bits are allowed or reasonable:",
      "ja": "2.10 すべてのビットの組み合わせが許可されていないわけでも、合理的ではありません。"
    },
    {
      "indent": 3,
      "text": "- the flags 'array' and 'short' are mutually exclusive. - 'short' is not applicable for data type 'structure' and 'float'. - 'array' is not applicable for data type 'structure'.",
      "ja": "- フラグの「配列」と「短い」は相互に排他的です。 - 「ショート」は、データ型「構造」と「フロート」には適用されません。 - 「配列」は、データ型「構造」には適用されません。"
    },
    {
      "indent": 0,
      "text": "3. Introduction to the SDXF functions",
      "section_title": true,
      "ja": "3. SDXF関数の紹介"
    },
    {
      "indent": 0,
      "text": "3.1 General remarks",
      "section_title": true,
      "ja": "3.1 一般的な発言"
    },
    {
      "indent": 3,
      "text": "The functionality of the SDXF concept is not bounded to any programming language, but of course the functions themselves must be coded in a particular language. I discuss these functions in C and C++, because in the meanwhile these languages are available on almost all platforms.",
      "ja": "SDXFコンセプトの機能はプログラミング言語に限定されていませんが、もちろん機能自体は特定の言語でコード化する必要があります。一方、これらの言語はほぼすべてのプラットフォームで利用できるため、これらの機能についてはCとCで説明します。"
    },
    {
      "indent": 3,
      "text": "All these functions for reading and writing SDXF chunks uses only one parameter, a parameter structure. In C++ this parameter structure is part of the \"SDXF class\" and the SDXF functions are methods of this class.",
      "ja": "SDXFチャンクを読み書きするためのこれらの機能はすべて、パラメーター構造であるパラメーター1つのパラメーターのみを使用します。Cでは、このパラメーター構造は「SDXFクラス」の一部であり、SDXF関数はこのクラスの方法です。"
    },
    {
      "indent": 3,
      "text": "An exact description of the interface is given in chapter 8.",
      "ja": "インターフェイスの正確な説明は、第8章に記載されています。"
    },
    {
      "indent": 0,
      "text": "3.2 Writing a SDXF buffer",
      "section_title": true,
      "ja": "3.2 SDXFバッファーの書き込み"
    },
    {
      "indent": 3,
      "text": "For to write SDXF chunks, there are following functions:",
      "ja": "SDXFチャンクを書くために、次の機能があります。"
    },
    {
      "indent": 3,
      "text": "init -- initialize the parameter structure create -- create a new chunk leave -- \"close\" a structured chunk",
      "ja": "init-パラメーター構造の初期化作成 - 新しいチャンク休暇を作成 - 構造化されたチャンクを「閉じる」"
    },
    {
      "indent": 0,
      "text": "3.3 Reading a SDXF buffer",
      "section_title": true,
      "ja": "3.3 SDXFバッファーの読み取り"
    },
    {
      "indent": 3,
      "text": "For to read SDXF chunks, there are following functions:",
      "ja": "SDXFチャンクを読むために、次の機能があります。"
    },
    {
      "indent": 3,
      "text": "init -- initialize the parameter structure enter -- \"go into\" a structured chunk next -- \"go to\" the next chunk inside a structured chunk extract -- extract the content of an elementary chunk into user's data area leave -- \"go out\" off a structured chunk",
      "ja": "init-パラメーター構造の初期化ENTERの入力 - 「進む」構造化されたチャンクNext-」に移動します。構造化されたチャンクから出て"
    },
    {
      "indent": 0,
      "text": "3.4 Example:",
      "ja": "3.4 例："
    },
    {
      "indent": 0,
      "text": "3.4.1 Writing:",
      "ja": "3.4.1 書き込み："
    },
    {
      "indent": 3,
      "text": "For demonstration we use a reduced (outlined) C++ Form of these functions with polymorph definitions:",
      "ja": "デモンストレーションには、これらの関数の縮小（概要）c形式をポリモーフ定義を使用します。"
    },
    {
      "indent": 3,
      "text": "void create (short chunkID); // opens a new structure, void create (short chunkID, char *string); // creates a new chunk with dataType character, etc.)",
      "ja": "void create（short chunkid）;//新しい構造を開き、void create（short chunkid、char *string）;// datatype文字などで新しいチャンクを作成します）"
    },
    {
      "indent": 3,
      "text": "The sequence:",
      "ja": "シーケンス："
    },
    {
      "indent": 3,
      "text": "SDXF x(new); // create the SDXF object \"x\" for a new chunk\n             // includes the \"init\"\nx.create (3301);   // opens a new structure\nx.create (3302, \"first chunk\");\nx.create (3303, \"second chunk\");\nx.create (3304);   // opens a new structure\nx.create (3305, \"chunk in a structure\");\nx.create (3306, \"next chunk in a structure\");\nx.leave ();        // closes the inner structure\nx.create (3307, \"third chunk\");\nx.leave ();        // closes the outer structure\n   creates a chunk which we can show graphically like:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "3301\n |\n +--- 3302 = \"first chunk\"\n |\n +--- 3303 = \"second chunk\"\n |\n +--- 3304\n |      |\n |      +--- 3305 = \"chunk in a structure\"\n |      |\n |      +--- 3306 = \"next chunk in a structure\"\n |\n +--- 3307 = \"last chunk\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.4.2 Reading",
      "section_title": true,
      "ja": "3.4.2 読む"
    },
    {
      "indent": 3,
      "text": "A typically access to a structured SDXF chunk is a selection inside a loop:",
      "ja": "通常、構造化されたSDXFチャンクへのアクセスは、ループ内の選択です。"
    },
    {
      "indent": 3,
      "text": "SDXF x(old); // defines a SDXF object \"x\" for an old chunk\nx.enter ();  // enters the structure",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "while (x.rc == 0) // 0 == ok, rc will set by the SDXF functions\n{\n  switch (x.chunkID)\n  {\n    case 3302:\n      x.extract (data1, maxLength1);\n                // extr. 1st chunk into data1\n      break;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "case 3303: x.extract (data2, maxLength2); // extr. 2nd chunk into data2 break;",
      "ja": "ケース3303：x.Extrage（data2、maxlength2）;// ingr。Data2ブレイクに2番目のチャンク。"
    },
    {
      "indent": 7,
      "text": "case 3304:  // we know this is a structure\n  x.enter (); // enters the inner structure",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "while (x.rc == 0) // inner loop\n{\n  switch (x.chunkID)\n  {\n    case 3305:\n      x.extract (data3, maxLength3);\n                // extr. the chunk inside struct.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "      break;\n    case 3306:\n      x.extract (data4, maxLength4);\n                // extr. 2nd chunk inside struct.\n      break;\n  }\n  x.next (); // returns x.rc == 1 at end of structure\n} // end-while\nbreak;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "case 3307:\n  x.extract (data5, maxLength5);\n            // extract last chunk into data\n  break;\n// default: none - ignore unknown chunks !!!",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  } // end-switch\n  x.next (); // returns x.rc = 1 at end of structure\n} // end-while",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4. Platform independence",
      "section_title": true,
      "ja": "4. プラットフォームの独立性"
    },
    {
      "indent": 3,
      "text": "The very most of the computer platforms today have a 8-Bits-in-a-Byte architecture, which enables data exchange between these platforms. But there are two significant points in which platforms may be different:",
      "ja": "今日のコンピュータープラットフォームのほとんどには、8ビットのバイトアーキテクチャがあり、これらのプラットフォーム間のデータ交換が可能です。しかし、プラットフォームが異なる場合がある2つの重要なポイントがあります。"
    },
    {
      "indent": 3,
      "text": "a) The representation of binary numerical (the short and long int and floats).",
      "ja": "a) バイナリ数値の表現（短いINTおよびLONG INTおよびFLOAT）。"
    },
    {
      "indent": 3,
      "text": "b) The representation of characters (ASCII/ANSI vs. EBCDIC)",
      "ja": "b) 文字の表現（ASCII/ANSI対EBCDIC）"
    },
    {
      "indent": 3,
      "text": "Point (a) is the phenomenon of \"byte swapping\": How is a short int value 259 = 0x0103 = X'0103' be stored at address 4402?",
      "ja": "ポイント（a）は「バイトスワッピング」の現象です。短いINT値259 = 0x0103 = X'0103 'はどのようにアドレス4402に保存されていますか？"
    },
    {
      "indent": 3,
      "text": "The two flavours are:",
      "ja": "2つのフレーバーは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "4402 4403 01 03 the big-endian, and 03 01 the little-endian.",
      "ja": "4402 4403 01 03ビッグエンディアン、および03 01リトルエンディアン。"
    },
    {
      "indent": 3,
      "text": "Point (b) is represented by a table of the assignment of the 256 possible values of a Byte to printable or control characters. (In ASCII the letter \"A\" is assigned to value (or position) 0x41 = 65, in EBCDIC it is 0xC1 = 193.) The solution of these problems is to normalize the data:",
      "ja": "ポイント（b）は、印刷可能な文字または制御文字へのバイトの256の可能な値の割り当ての表で表されます。（ASCIIでは、文字「A」は値（または位置）0x41 = 65に割り当てられます。"
    },
    {
      "indent": 3,
      "text": "We fix:",
      "ja": "修正："
    },
    {
      "indent": 3,
      "text": "(a) The internal representation of binary numerals are 2-complements in big-endian order.",
      "ja": "(a) バイナリ数字の内部表現は、大幅な順序で2つの複製です。"
    },
    {
      "indent": 3,
      "text": "(b) The internal representation of characters is ISO 8859-1 (also known as Latin 1).",
      "ja": "(b) 文字の内部表現はISO 8859-1（ラテン1とも呼ばれます）です。"
    },
    {
      "indent": 3,
      "text": "The fixing of point (b) should be regarded as a first strike. In some environment 8859-1 seems not to be the best choice, in a greek or russian environment 8859-5 or 8859-7 are appropriate.",
      "ja": "ポイント（b）の修正は、最初のストライキと見なされるべきです。一部の環境では、8859-1は最良の選択ではないようです。ギリシャまたはロシアの環境では、8859-5または8859-7が適切です。"
    },
    {
      "indent": 3,
      "text": "Nevertheless, in a specific group (or world) of applications, that is to say all the applications which wants to interchange data with a defined protocol (via networking or diskette or something else), this internal character table must be unique.",
      "ja": "それにもかかわらず、特定のグループ（または世界）のアプリケーション、つまり、定義されたプロトコル（ネットワークやディスケットなど）とデータを交換したいすべてのアプリケーションが、この内部文字テーブルは一意でなければなりません。"
    },
    {
      "indent": 3,
      "text": "So a possibility to define a translation table (and his inversion) should be given.",
      "ja": "したがって、翻訳テーブル（および彼の反転）を定義する可能性を与える必要があります。"
    },
    {
      "indent": 3,
      "text": "Important: You construct a SDXF chunk not for a specific addressee, but you adapt your data into a normalized format (or network format).",
      "ja": "重要：特定の宛先ではなくSDXFチャンクを構築しますが、データを正規化された形式（またはネットワーク形式）に適応させます。"
    },
    {
      "indent": 3,
      "text": "This adaption is not done by the programmer, it will be done by the create and extract function. An administrator has take care of defining the correct translation tables.",
      "ja": "この適応はプログラマーによって行われるのではなく、作成および抽出機能によって行われます。管理者は、正しい翻訳テーブルの定義に注意しています。"
    },
    {
      "indent": 0,
      "text": "5. Compression",
      "section_title": true,
      "ja": "5. 圧縮"
    },
    {
      "indent": 3,
      "text": "As stated in 2.5 there is a flag bit which declares that the following data (elementary or structured) are compressed. This data is not further interpretable until it is decompressed. Compression is transparently done by the SDXF functions: \"create\" does the compression for elementary chunks, \"leave\" for structured chunks, \"extract\" does the decompression for elementary chunks, \"enter\" for structured chunks.",
      "ja": "2.5に記載されているように、次のデータ（初等または構造化）が圧縮されていることを宣言するフラグビットがあります。このデータは、減圧されるまでさらに解釈できません。圧縮はSDXF関数によって透過的に行われます。「create」は、基本チャンクの圧縮を行い、構造化されたチャンクの「残し」、「抽出」は、「基本チャンクの減圧」を行い、構造化されたチャンクに「入力します。"
    },
    {
      "indent": 3,
      "text": "Transparently means that the programmer has only to tell the SDXF functions that he want compress the following chunk(s).",
      "ja": "透過的には、プログラマーがSDXF関数に次のチャンクを圧縮したいことを伝えるだけであることを意味します。"
    },
    {
      "indent": 3,
      "text": "For choosing between different compression methods and for controlling the decompressed (original) length, there is an additional definition: After the chunk header for a compressed chunk, a compression header is following:",
      "ja": "異なる圧縮方法を選択し、減圧（元の）長さを制御するために、追加の定義があります。圧縮チャンクのチャンクヘッダーの後、圧縮ヘッダーが次のとおりです。"
    },
    {
      "indent": 3,
      "text": "+-----------------------+---------------+---------------->\n|      chunk header     | compr. header | compressed data\n+---+---+---+---+---+---+---+---+---+---+---------------->\n|chunkID|flg|   length  |md | orglength |\n+---+---+---+---+---+---+---+---+---+---+---------------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "- 'orglength' is the original (decompressed) length of the data.",
      "ja": "- 「Orglength」は、データの元の（減圧された）長さです。"
    },
    {
      "indent": 3,
      "text": "- 'md' is the \"compression method\": Two methods are described here:",
      "ja": "- 「MD」は「圧縮方法」です。ここでは、2つの方法が説明されています。"
    },
    {
      "indent": 6,
      "text": "# method 01 for a simple (fast but not very effective) \"Run Length 1\" or \"Byte Run 1\" algorithm. (More then two consecutive identical characters are replaced by the number of these characters and the character itself.)",
      "ja": "＃メソッド01単純な（高速ではないがあまり効果的ではない）「実行長1」または「バイト実行1」アルゴリズムの場合。（2つの連続した同一の文字が、これらの文字の数と文字自体に置き換えられます。）"
    },
    {
      "indent": 9,
      "text": "more precisely:",
      "ja": "より正確に："
    },
    {
      "indent": 9,
      "text": "The compressed data consists of several sections of various length. Every section starts with a \"counter\" byte, a signed \"tiny\" (8 bit) integer, which contains a length information.",
      "ja": "圧縮データは、さまざまな長さのいくつかのセクションで構成されています。すべてのセクションは、「カウンター」バイト、署名された「小さな」（8ビット）整数で始まり、長さの情報が含まれています。"
    },
    {
      "indent": 9,
      "text": "If this byte contains the value \"n\", with n >= 0 (and n <128), the next n+1 bytes will be taken unchanged; with n < 0 (and n > -128), the next byte will be replicated -n+1 times; n = -128 will be ignored.",
      "ja": "このバイトにn> = 0（およびn <128）の値「n」が含まれている場合、次のn 1バイトは変更されません。n <0（およびn> -128）では、次のバイトが1回複製されます。n = -128は無視されます。"
    },
    {
      "indent": 9,
      "text": "Appending blanks will be cutted in general. If these are necessary, they can be reconstructed while \"extract\"ing with the parameter field \"filler\" (see 8.2.1) set to space character.",
      "ja": "アプリデンディングブランクは一般にカットされます。これらが必要な場合は、パラメーターフィールド「フィラー」（8.2.1を参照）を使用して「抽出」しているときに再構築できます。"
    },
    {
      "indent": 6,
      "text": "# method 02 for the wonderful \"deflate\" algorithm which comes from the \"zip\"-people. The authors are: Jean-loup Gailly (deflate routine), Mark Adler (inflate routine), and others.",
      "ja": "＃メソッド02「zip」ペオプルに由来する素晴らしい「デフレート」アルゴリズム。著者は、Jean-Loup Gailly（DEFLATEルーチン）、Mark Adler（膨張ルーチン）などです。"
    },
    {
      "indent": 9,
      "text": "The deflate format is described in [DEFLATE].",
      "ja": "DEFLATE形式は[DEFLATE]で説明されています。"
    },
    {
      "indent": 6,
      "text": "The values for the compression method number are maintained by IANA, see chap. 12.1.",
      "ja": "圧縮法番号の値はIANAによって維持されます。Chapを参照してください。12.1。"
    },
    {
      "indent": 0,
      "text": "6. Encryption",
      "section_title": true,
      "ja": "6. 暗号化"
    },
    {
      "indent": 3,
      "text": "As stated in 2.5 there is a flag bit which declares that the following data (elementary or structured) is encrypted. This data is not interpretable until it is decrypted. En/Decryption is transparently done by the SDXF functions, \"create\" does the encryption for elementary chunks, \"leave\" for structured chunks, \"extract\" does the decryption for elementary chunks, \"enter\" for structured chunks. (Yes it sounds very similar to chapter 5.) More then one encryption method for a given range of applications is not very reasonable. Some encryption algorithms work with block ciphering algorithms. That means that the length of the data to encrypt must be rounded up to the next multiple of this block length. This blocksize (zero means non-blocking) is reported by the encryption interface routine (addressed by the option field *encryptProc, see chapter 8.5) with mode=3. If blocking is used, at least one byte is added, the last byte of the lengthening data contains the number of added bytes minus one. With this the decryption interface routine can calculate the real data length.",
      "ja": "2.5に記載されているように、次のデータ（初等または構造化）が暗号化されていることを宣言するフラグビットがあります。このデータは、復号化されるまで解釈できません。EN/復号化はSDXF関数によって透過的に行われ、「Create」は基本チャンクの暗号化を行い、構造化されたチャンクの「残し」、「抽出」は「基本チャンクの復号化」を行い、「構造的なチャンクに「入力」します。（はい、それは第5章に非常に似ているように聞こえます）。一部の暗号化アルゴリズムは、ブロック微分アルゴリズムで動作します。つまり、暗号化するデータの長さは、このブロックの長さの次の倍数に切り上げなければなりません。このブロックサイズ（ゼロは非ブロックを意味します）は、モード= 3で暗号化インターフェイスルーチン（オプションフィールド *encryptProc、第8.5章を参照）によって報告されます。ブロッキングを使用すると、少なくとも1つのバイトが追加されます。延長データの最後のバイトには、追加されたバイトの数を引いた数が含まれています。これにより、復号化インターフェイスルーチンは実際のデータ長を計算できます。"
    },
    {
      "indent": 3,
      "text": "If an application (or network connect handshaking protocol) needs to negotiate an encryption method it should be used a method number maintained by IANA, see chap. 12.2.",
      "ja": "アプリケーション（またはネットワーク接続ハンドシェーキングプロトコル）が暗号化方法をネゴシエートする必要がある場合は、IANAによって維持されるメソッド番号を使用する必要があります。Chapを参照してください。12.2。"
    },
    {
      "indent": 3,
      "text": "Even the en/decryption is done transparently, an encryption key (password) must be given to the SDXF functions. Encryption is done after translating character data into, decryption is done before translation from the internal (\"network-\") format.",
      "ja": "EN/復号化が透過的に行われていても、暗号化キー（パスワード）をSDXF関数に指定する必要があります。暗号化は、文字データを翻訳した後に行われ、復号化は内部（「ネットワーク」）形式から変換される前に行われます。"
    },
    {
      "indent": 3,
      "text": "If both, encryption and compression are applied on the same chunk, compression is done first - compression on good encrypted data (same strings appears as different after encryption) tends to zero compression rates.",
      "ja": "暗号化と圧縮の両方が同じチャンクに適用される場合、最初に圧縮が行われます - 良好な暗号化されたデータでの圧縮（暗号化後に同じ文字列が異なると表示されます）は圧縮速度がゼロになる傾向があります。"
    },
    {
      "indent": 0,
      "text": "7. Arrays",
      "section_title": true,
      "ja": "7. 配列"
    },
    {
      "indent": 3,
      "text": "An array is a sequence of chunks with identical chunk-ID, length and data type.",
      "ja": "配列は、同じチャンクID、長さ、データ型を備えた一連のチャンクです。"
    },
    {
      "indent": 3,
      "text": "At first a hint: in principle a special definition in SDXF for such an array is not really necessary:",
      "ja": "最初はヒント：原則として、このような配列のSDXFの特別な定義は実際には必要ありません。"
    },
    {
      "indent": 3,
      "text": "It is not forbidden that there are more than one chunk with equal chunk-ID within the same structured chunk.",
      "ja": "同じ構造化されたチャンク内に等しいチャンクIDを持つ複数のチャンクがあることは禁止されていません。"
    },
    {
      "indent": 3,
      "text": "Therefore with a sequence of SDX_next / SDX_extract calls one can fill the destination array step by step.",
      "ja": "したがって、一連のSDX_NEXT / SDX_EXTRACTコールを使用すると、宛先配列を段階的に入力できます。"
    },
    {
      "indent": 3,
      "text": "If there are many occurrences of chunks with the same chunk-ID (and a comparative small length), the overhead of the chunk-packages may be significant.",
      "ja": "同じチャンクID（および比較小さな長さ）でチャンクの多くの発生がある場合、チャンクパッケージのオーバーヘッドは重要な場合があります。"
    },
    {
      "indent": 3,
      "text": "Therefore the array flag is introduced. An array chunk has only one chunk header for the complete sequence of elementary chunks. After the chunk header for an array chunk, an array header is following:",
      "ja": "したがって、配列フラグが導入されます。Array Chunkには、一連の基本チャンクの完全なシーケンス用のチャンクヘッダーが1つしかありません。アレイチャンクのチャンクヘッダーの後、アレイヘッダーが次のとおりです。"
    },
    {
      "indent": 3,
      "text": "This is a short integer (big endian!) which contains the number of the array elements (CT). Every element has a fixed length (EL), so the chunklength (CL) is CL = EL * CT + 2.",
      "ja": "これは、アレイ要素の数（CT）を含む短い整数（Big Endian！）です。すべての要素の固定長（EL）があるため、ChunkLength（CL）はCl = EL * CT 2です。"
    },
    {
      "indent": 3,
      "text": "The data elements follows immediately after the array header.",
      "ja": "データ要素は、配列ヘッダーの直後に続きます。"
    },
    {
      "indent": 3,
      "text": "The complete array will be constructed by SDX_create, the complete array will be read by SDX_extract.",
      "ja": "完全な配列はSDX_Createによって構築され、完全な配列はSDX_EXTRACTによって読み取られます。"
    },
    {
      "indent": 3,
      "text": "The parameter fields (see 8.2.1) 'dataLength' and 'count' are used for the SDXF functions 'extract' and 'create':",
      "ja": "パラメーターフィールド（8.2.1を参照）「Datalength」と「Count」は、SDXF関数「抽出」および「作成」に使用されます。"
    },
    {
      "indent": 3,
      "text": "Field 'dataLength' is the common length of the array elements, 'count' is the actual dimension of the array for 'create' (input).",
      "ja": "フィールド「Datalength」は配列要素の一般的な長さであり、「カウント」は「create」（入力）の配列の実際の次元です。"
    },
    {
      "indent": 3,
      "text": "For the 'extract' function 'count' acts both as an input and output parameter:",
      "ja": "「抽出」関数の場合、「カウント」は、入力パラメーターと出力パラメーターの両方として機能します。"
    },
    {
      "indent": 3,
      "text": "Input : the maximum dimension output: the actual array dimension.",
      "ja": "入力：最大寸法出力：実際の配列寸法。"
    },
    {
      "indent": 3,
      "text": "(If output count is greater than input count, the 'data cutted' warning will be responded and the destination array is filled up to the maximum dimension.)",
      "ja": "（出力カウントが入力カウントよりも大きい場合、「データ削減」警告が応答され、宛先配列が最大寸法に満たされます。）"
    },
    {
      "indent": 0,
      "text": "8. Description of the SDXF functions",
      "section_title": true,
      "ja": "8. SDXF関数の説明"
    },
    {
      "indent": 0,
      "text": "8.1 Introduction",
      "section_title": true,
      "ja": "8.1 はじめに"
    },
    {
      "indent": 3,
      "text": "Following the principles of Object Oriented Programming, not only the description of the data is necessary, but also the functions which manipulate data - the \"methods\".",
      "ja": "オブジェクト指向プログラミングの原則に従って、データの説明だけでなく、データを操作する機能（「メソッド」も操作する」。"
    },
    {
      "indent": 3,
      "text": "For the programmer knowing the methods is more important than knowing the data structure, the methods has to know the exact specifications of the data and guarantees the consistence of the data while creating them.",
      "ja": "メソッドを知るプログラマがデータ構造を知るよりも重要であるため、メソッドはデータの正確な仕様を知り、データを作成しながらデータの一貫性を保証する必要があります。"
    },
    {
      "indent": 3,
      "text": "A SDXF object is an instance of a parameter structure which acts as a programming interface. Especially it points to an actual SDXF data chunk, and, while processing on this data, there is a pointer to the actual inner chunk which will be the focus for the next operation.",
      "ja": "SDXFオブジェクトは、プログラミングインターフェイスとして機能するパラメーター構造のインスタンスです。特に、実際のSDXFデータチャンクを指しており、このデータで処理する際に、実際の内側チャンクへのポインターがあり、次の操作の焦点となります。"
    },
    {
      "indent": 3,
      "text": "The benefit of an exact interface description is the same as using for example the standard C library functions: By using standard interfaces your code remains platform independent.",
      "ja": "正確なインターフェイスの説明の利点は、たとえば標準のCライブラリ関数を使用することと同じです。標準インターフェイスを使用することにより、コードはプラットフォームに依存しません。"
    },
    {
      "indent": 0,
      "text": "8.2 Basic definitions",
      "section_title": true,
      "ja": "8.2 基本的な定義"
    },
    {
      "indent": 0,
      "text": "8.2.1 The SDXF Parameter structure",
      "section_title": true,
      "ja": "8.2.1 SDXFパラメーター構造"
    },
    {
      "indent": 3,
      "text": "All SDXF access functions need only one parameter, a pointer to the SDXF parameter structure:",
      "ja": "すべてのSDXFアクセス関数には、SDXFパラメーター構造へのポインター、1つのパラメーターのみが必要です。"
    },
    {
      "indent": 3,
      "text": "First 3 prerequisite definitions:",
      "ja": "最初の3つの前提条件定義："
    },
    {
      "indent": 3,
      "text": "typedef short int ChunkID; typedef unsigned char Byte;",
      "ja": "typedef short int chunkid;typedef unsigned charバイト。"
    },
    {
      "indent": 3,
      "text": "typedef struct Chunk\n{\n  ChunkID    chunkID;\n  Byte       flags;\n  char       length [3];\n  Byte       data;\n} Chunk;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "And now the parameter structure:",
      "ja": "そして今、パラメーター構造："
    },
    {
      "indent": 3,
      "text": "typedef struct\n{\n  ChunkID  chunkID;       // name (ID) of Chunk\n  Byte    *container;     // pointer to the whole Chunk\n  long     bufferSize;    // size of container\n  Chunk   *currChunk;     // pointer to actual Chunk\n  long     dataLength;    // length of data in Chunk\n  long     maxLength;     // max. length of Chunk for SDX_extract\n  long     remainingSize; // rem. size in cont. after SDX_create\n  long     value;         // for data type numeric\n  double   fvalue;        // for data type float\n  char    *function;      // name of the executed SDXF function\n  Byte    *data;          // pointer to Data\n  Byte    *cryptkey;      // pointer to Crypt Key\n  short    count;         // (max.) number of elements in an array\n  short    dataType;      // Chunk data type / init open type\n  short    ec;            // extended return-code\n     short    rc;            // return-code\n  short    level;         // level of hierarchy\n  char     filler;        // filler char for SDX_extract\n  Byte     encrypt;       // Indication if data to encrypt (0 / 1)\n  Byte     compression;   // compression method\n                          //   (00=none, 01=RL1, 02=zip/deflate)\n} SDX_obj, *SDX_handle;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Only the \"public\" fields of the parameter structure which acts as input and output for the SDXF functions is described here. A given implementation may add some \"private\" fields to this structure.",
      "ja": "SDXF関数の入力と出力として機能するパラメーター構造の「パブリック」フィールドのみがここで説明されています。特定の実装により、この構造に「プライベート」フィールドが追加される場合があります。"
    },
    {
      "indent": 0,
      "text": "8.2.2 Basic Functions",
      "section_title": true,
      "ja": "8.2.2 基本機能"
    },
    {
      "indent": 3,
      "text": "All these functions works with a SDX_handle as the only formal parameter. Every function returns as output ec and rc as a report of success. For the values for ec, rc and dataType see chap. 8.4.",
      "ja": "これらのすべての関数は、SDX_Handleを唯一の正式なパラメーターとして使用します。すべての関数は、成功のレポートとして出力ECおよびRCとして戻ります。EC、RC、およびデータ型の値については、Chapを参照してください。8.4。"
    },
    {
      "indent": 4,
      "text": "1. SDX_init : Initialize the parameter structure.",
      "ja": "1. SDX_INIT：パラメーター構造を初期化します。"
    },
    {
      "indent": 9,
      "text": "input : container, dataType, bufferSize (for dataType = SDX_NEW only) output: currChunk, dataLength (for dataType = SDX_OLD only), ec, rc, the other fields of the parameter structure will be initialized.",
      "ja": "入力：コンテナ、データタイプ、緩衝（データタイプ= SDX_NEWのみ）出力：Currchunk、DatAlength（Datatype = SDX_OLDのみ）、EC、RC、パラメーター構造の他のフィールドが初期化されます。"
    },
    {
      "indent": 4,
      "text": "2. SDX_enter : Enter a structured chunk. You can access the first chunk inside this structured chunk. input : none output: currChunk, chunkID, dataLength, level, dataType, ec, rc",
      "ja": "2. SDX_ENTER：構造化されたチャンクを入力します。この構造化されたチャンク内の最初のチャンクにアクセスできます。入力：なし出力：Currchunk、Chunkid、Datalength、Level、Datatype、EC、RC"
    },
    {
      "indent": 4,
      "text": "3. SDX_leave : Leave the actual entered structured chunk. input : none output: currChunk, chunkID, dataLength, level, dataType, ec, rc",
      "ja": "3. SDX_LEAVE：実際に入力された構造化されたチャンクを残します。入力：なし出力：Currchunk、Chunkid、Datalength、Level、Datatype、EC、RC"
    },
    {
      "indent": 4,
      "text": "4. SDX_next : Go to the next chunk inside a structured chunk. input : none output: currChunk, chunkID, dataLength, dataType, count, ec, rc",
      "ja": "4. SDX_NEXT：構造化されたチャンク内の次のチャンクに移動します。入力：なし出力：Currchunk、Chunkid、Datalength、DataType、Count、EC、RC"
    },
    {
      "indent": 8,
      "text": "At the end of a structured chunk SDX_next returns rc = SDX_RC_failed and ec = SDX_EC_eoc (end of chunk) The actual structured chunk is SDX_leave'd automatically.",
      "ja": "構造化されたチャンクの最後に、rc = sdx_rc_failedおよびec = sdx_ec_eoc（chunkの終わり）を返します。実際の構造化されたチャンクはsdx_leave'dです。"
    },
    {
      "indent": 4,
      "text": "5. SDX_extract : Extract data of the actual chunk. (If actual chunk is structured, only a copy is done, elsewhere the data is converted to host format.) input / output depends on the dataType:",
      "ja": "5. SDX_Extra：実際のチャンクのデータを抽出します。（実際のチャンクが構造化されている場合、コピーのみが行われます。他の場所では、データはホスト形式に変換されます。）入力 /出力はデータ型に依存します。"
    },
    {
      "indent": 7,
      "text": "if dataType is structured, binary or char: input : data, maxLength, count, filler output: dataLength, count, ec, rc",
      "ja": "DataTypeが構造化されている場合、バイナリまたはchar：入力：データ、MaxLength、Count、Filler Output：Datalength、Count、EC、RC"
    },
    {
      "indent": 7,
      "text": "if dataType is numeric (float resp.): input : none output: value (fvalue resp.), ec, rc",
      "ja": "データタイプが数値（float rep。）：input：none output：value（fvalue resp。）、ec、rc"
    },
    {
      "indent": 4,
      "text": "6. SDX_select : Go to the (next) chunk with a given chunkID. input : chunkID output: currChunk, dataLength, dataType, ec, rc",
      "ja": "6. SDX_SELECT：特定のチャンクで（次の）チャンクに移動します。入力：Chunkid Output：Currchunk、Datalength、DataType、EC、RC"
    },
    {
      "indent": 4,
      "text": "7. SDX_create : Creating a new chunk (at the end of the actual structured chunk). input : chunkID, dataLength, data, (f)value, dataType, compression, encrypt, count update: remainingSize, level output: currChunk, dataLength, ec, rc",
      "ja": "7. SDX_CREATE：新しいチャンクを作成します（実際の構造化されたチャンクの最後に）。入力：Chunkid、DataLength、Data、（f）値、データ型、圧縮、暗号化、カウントアップデート：残り、レベル出力：Currchunk、Datalength、EC、RC"
    },
    {
      "indent": 4,
      "text": "8. SDX_append : Append a complete chunk at the end of the actual structured chunk). input : data, maxLength, currChunk update: remainingSize, level output: chunkID, chunkLength, maxLength, dataType, ec, rc",
      "ja": "8. SDX_APPEND：実際の構造化されたチャンクの最後に完全なチャンクを追加します）。入力：データ、MaxLength、Currchunk Update：残り、レベル出力：Chunkid、ChunkLength、MaxLength、Datatype、EC、RC"
    },
    {
      "indent": 0,
      "text": "8.3 Definitions for C++",
      "section_title": true,
      "ja": "8.3 cの定義"
    },
    {
      "indent": 3,
      "text": "This is the specification of the SDXF class in C++: (The type 'Byte' is defined as \"unsigned char\" for bitstrings, opposed to \"signed char\" for character strings)",
      "ja": "これは、cのSDXFクラスの仕様です（型 'byte'は、ビットストリングの「符号なしのchar」として定義され、キャラクター文字列の「署名されたchar」とは反対です）"
    },
    {
      "indent": 3,
      "text": "class C_SDXF { public:",
      "ja": "クラスC_SDXF {public："
    },
    {
      "indent": 5,
      "text": "// constructors and destructor:\nC_SDXF  ();                          // dummy\nC_SDXF  (Byte *cont);                // old container\nC_SDXF  (Byte *cont, long size);     // new container\nC_SDXF  (long size);                 // new container\n~C_SDXF ();\n// methods:\n     void init  (void);                   // old container\nvoid init  (Byte *cont);             // old container\nvoid init  (Byte *cont, long size);  // new container\nvoid init  (long size);              // new container",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "void enter   (void);\nvoid leave   (void);\nvoid next    (void);\nlong extract (Byte *data, long length);    // chars, bits\nlong extract (void);                       // numeric data\nvoid create  (ChunkID);                    // structured\nvoid create  (ChunkID, long value);        // numeric\nvoid create  (ChunkID, double fvalue);     // float\nvoid create  (ChunkID, Byte *data, long length);// binary\nvoid create  (ChunkID, char *data);             // chars\nvoid set_compression (Byte compression_method);\nvoid set_encryption  (Byte *encryption_key);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "// interface:",
      "ja": "// インターフェース："
    },
    {
      "indent": 5,
      "text": "ChunkID  id;        // see 8.4.1\nshort    dataType;  // see 8.4.2\nlong     length;    // length of data or chunk",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "long     value;\ndouble   fvalue;\nshort    rc;  // the raw return code       see 8.4.3\nshort    ec;  // the extended return code  see 8.4.4",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "protected: // implementation dependent ...",
      "ja": "保護：//実装依存..."
    },
    {
      "indent": 3,
      "text": "};",
      "ja": "};"
    },
    {
      "indent": 0,
      "text": "8.4 Common Definitions:",
      "ja": "8.4 一般的な定義："
    },
    {
      "indent": 0,
      "text": "8.4.1 Definition of ChunkID:",
      "ja": "8.4.1 Chunkidの定義："
    },
    {
      "indent": 3,
      "text": "typedef short ChunkID;",
      "ja": "typedefショートチャンク。"
    },
    {
      "indent": 0,
      "text": "8.4.2 Values for dataType:",
      "ja": "8.4.2 データ型の値："
    },
    {
      "indent": 3,
      "text": "SDX_DT_inconsistent = 0 SDX_DT_structured = 1 SDX_DT_binary = 2 SDX_DT_numeric = 3 SDX_DT_char = 4 SDX_DT_float = 5 SDX_DT_UTF8 = 6",
      "ja": "sdx_dt_inconsistent = 0 sdx_dt_structured = 1 sdx_dt_binary = 2 sdx_dt_numeric = 3 sdx_dt_char = 4 sdx_dt_float = 5 sdx_dt_utf8 = 6 6"
    },
    {
      "indent": 3,
      "text": " data types for SDX_init: SDX_OLD = 1 SDX_NEW = 2",
      "ja": "sdx_initのデータ型：sdx_old = 1 sdx_new = 2"
    },
    {
      "indent": 0,
      "text": "8.4.3 Values for rc:",
      "ja": "8.4.3 RCの値："
    },
    {
      "indent": 3,
      "text": "SDX_RC_ok = 0 SDX_RC_failed = 1 SDX_RC_warning = 1 SDX_RC_illegalOperation = 2 SDX_RC_dataError = 3 SDX_RC_parameterError = 4 SDX_RC_programError = 5 SDX_RC_noMemory = 6",
      "ja": "SDX_RC_OK = 0 SDX_RC_FAILED = 1 SDX_RC_WARNING = 1 SDX_RC_ILLEGALOPERATION = 2 SDX_RC_DATAERROR = 3 SDX_RC_PARAMETERERROR = 4 SDX_RC_RC_PORMORMERROR = 5 SDX_RC_NOMEMORY = 6"
    },
    {
      "indent": 0,
      "text": "8.4.4 Values for ec:",
      "ja": "8.4.4 ECの値："
    },
    {
      "indent": 3,
      "text": "SDX_EC_ok              =  0\nSDX_EC_eoc             =  1 // end of chunk\nSDX_EC_notFound        =  2\nSDX_EC_dataCutted      =  3\nSDX_EC_overflow        =  4\nSDX_EC_wrongInitType   =  5\nSDX_EC_comprerr        =  6 // compression error\nSDX_EC_forbidden       =  7\nSDX_EC_unknown         =  8\nSDX_EC_levelOvflw      =  9\nSDX_EC_paramMissing    = 10\nSDX_EC_magicError      = 11\nSDX_EC_not_consistent  = 12\nSDX_EC_wrongDataType   = 13\nSDX_EC_noMemory        = 14\nSDX_EC_error           = 99 // rc is sufficiently",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.5 Special functions",
      "section_title": true,
      "ja": "8.5 特別な機能"
    },
    {
      "indent": 3,
      "text": "Besides the basic definitions there is a global function (SDX_getOptions) which returns a pointer to a global table of options.",
      "ja": "基本的な定義に加えて、グローバルな機能（SDX_GETOPTIONS）があり、グローバルオプションの表にポインターを返します。"
    },
    {
      "indent": 3,
      "text": "With the help of these options you can adapt the behaviour of SDXF. Especially you can define an alternative pair of translation tables or an alternative function which reads these tables from an external resource (p.e. from disk).",
      "ja": "これらのオプションの助けを借りて、SDXFの動作を適応させることができます。特に、翻訳テーブルの代替ペアまたは外部リソース（ディスクからのP.E.）からこれらのテーブルを読み取る代替機能を定義できます。"
    },
    {
      "indent": 3,
      "text": "Within this table of options there is also a pointer to the function which is used for encryption / decryption: You can install your own encryption algorithm by setting this pointer.",
      "ja": "このオプションの表には、暗号化 /復号化に使用される関数へのポインターもあります。このポインターを設定して、独自の暗号化アルゴリズムをインストールできます。"
    },
    {
      "indent": 3,
      "text": "The options pointer is received by:",
      "ja": "オプションポインターは次のように受信されます。"
    },
    {
      "indent": 3,
      "text": "SDX_TOptions *opt = SDX_getOptions ();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "With:",
      "ja": "と："
    },
    {
      "indent": 3,
      "text": "typedef struct\n{\n Byte            *toHost;        // Trans tab net -> host\n Byte            *toNet;         // Trans tab host -> net\n int              maxlevel;      // highest possible level\n int              translation;   // translation net <-> host\n                                 // is in effect=1 or not=0\n TEncryptProc    *encryptProc;   // alternate encryption routine\n TGetTablesProc  *getTablesProc; // alternate routine defining\n                                 // translation Tables\n TcvtUTF8Proc    *convertUTF8;   // routine to convert to/from UTF-8\n}  SDX_TOptions;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef long TencryptProc (\n  int   mode,   // 1= to encrypt, 2= to decrypt, 3= encrypted length\n  Byte *buffer, // data to en/decrypt\n  long  len,    // len: length of buffer\n  char *passw); // Password",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "// returns length of en/de-crypted data\n// (parameter buffer and passw are ignored for mode=3)\n// returns blocksize for mode=3 and len=0.\n// blocksize is zero for non-blocking algorithms",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef int TGetTablesProc (Byte **toNet, Byte **toHost);\n // toNet, toHost: pointer to output params.  Both params\n // points to translation tables of 256 Bytes.\n // returns success: 1 = ok, 0 = error.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef int TcvtUTF8Proc\n( int   mode,     // 1 = to UTF-8, 2 = from UTF-8\n  Byte *target, int *targetlength,  // output\n  Byte *source, int sourcelength);  // input\n// targetlength contains maximal size as input param.\n// returns success: 1 = ok, 0 = no conversion",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9. 'Support' of UTF-8.",
      "ja": "9. UTF-8の「サポート」。"
    },
    {
      "indent": 3,
      "text": "Many systems supports [UTF-8] as a character format for transferred data. The benefit is that no fixing of a specific character set for an application is needed because the set of 'all' characters is used, represented by the 'Universal Character Set' UCS-2 [UCS], a double byte coding for characters.",
      "ja": "多くのシステムは、転送されたデータの文字形式として[UTF-8]をサポートしています。利点は、「All」文字のセットが「Universal Characterセット」UCS-2 [UCS]で表されるため、アプリケーション用の特定の文字セットの修正が必要であることです。"
    },
    {
      "indent": 3,
      "text": "SDXF does not really deal with UTF-8 by itself, there are many possibilities to interprete an UTF-8 sequence: The application may:",
      "ja": "SDXFは、それ自体でUTF-8を実際に扱っていません。UTF-8シーケンスを解釈する可能性は多くあります。アプリケーションは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "- reconstruct the UCS-2 sequence, - accepts only the pure ASCII character and maps non-ASCII to a special 'non-printable' character. - target is pure ASCII, non-ASCII is replaced in a senseful manner (French accented vowels replaced by vowels without accents, etc.). - target is a specific ANSI character set, the non-ASCII chars are mapped as possible, other replaced to a 'non-printable'. - etc.",
      "ja": "- UCS-2シーケンスを再構築する - 純粋なASCII文字のみを受け入れ、非ASCIIを特別な「印刷できない」文字にマップします。 - ターゲットは純粋なASCIIであり、非ASCIIは意味のある方法で置き換えられます（アクセントなどのない母音に置き換えられたフランスのアクセントの母音など）。 - ターゲットは特定のANSI文字セットであり、非ASCIIチャーは可能な限りマッピングされ、その他は「印刷できない」に置き換えられます。 - など。"
    },
    {
      "indent": 3,
      "text": "But SDXF offers an interface for the 'extract' and 'create' functions:",
      "ja": "ただし、SDXFは「抽出」および「作成」関数のインターフェイスを提供します。"
    },
    {
      "indent": 3,
      "text": "A function pointer may be specified in the options table to maintain this possibility (see 8.5). Default for this pointer is NULL: No further conversions are done by SDXF, the data are copied 'as is', it is treated as a bit string as for data type 'binary'.",
      "ja": "この可能性を維持するために、オプションテーブルに関数ポインターを指定できます（8.5を参照）。このポインターのデフォルトはnullです。これ以上の変換はSDXFによって行われません。データは「現状のまま」でコピーされ、データ型「バイナリ」のように少し文字列として扱われます。"
    },
    {
      "indent": 3,
      "text": "If this function is specified, it is used by the 'create' function with the 'toUTF8' mode, and by the 'extract' function with the ' fromUTF8' mode. The invoking of these functions is done by SDXF transparently.",
      "ja": "この関数が指定されている場合、「toutf8」モードを使用した「作成」関数と、「fromutf8」モードで「抽出」関数によって使用されます。これらの機能の呼び出しは、SDXFによって透過的に行われます。"
    },
    {
      "indent": 3,
      "text": "If the function returns zero (no conversion) SDXF copies the data without conversion.",
      "ja": "関数がゼロ（変換なし）を返す場合、SDXFは変換せずにデータをコピーします。"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Any corruption of data in the chunk headers denounce the complete SDXF structure.",
      "ja": "チャンクヘッダーのデータの破損は、完全なSDXF構造を非難します。"
    },
    {
      "indent": 3,
      "text": "Any corruption of data in a encrypted or compressed SDXF structure makes this chunk unusable. An integrity check after decryption or decompression should be done by the \"enter\" function.",
      "ja": "暗号化または圧縮されたSDXF構造内のデータの破損により、このチャンクは使用できなくなります。復号化または減圧後の整合性チェックは、「Enter」関数によって行う必要があります。"
    },
    {
      "indent": 3,
      "text": "While using TCP/IP (more precisely: IP) as a transmission medium we can trust on his CRC check on the transport layer.",
      "ja": "TCP/IP（より正確に：IP）を送信媒体として使用している間、輸送層でのCRCチェックで信頼できることがあります。"
    },
    {
      "indent": 0,
      "text": "11. Some general hints",
      "section_title": true,
      "ja": "11. いくつかの一般的なヒント"
    },
    {
      "indent": 3,
      "text": "1. A consistent construction of a SDXF structure is done if every \"create\" to a structured chunk is closed by a paired \"leave\". While a structured chunk is under construction, his data type is set to zero - that means: this chunk is inconsistent. The SDX_leave function sets the datatype to \"structured\".",
      "ja": "1. SDXF構造の一貫した構造は、構造化されたチャンクのすべての「作成」がペアの「休暇」によって閉じられている場合に行われます。構造化されたチャンクは建設中ですが、彼のデータ型はゼロに設定されています。つまり、このチャンクは矛盾しています。SDX_Leave関数は、データ型を「構造化」に設定します。"
    },
    {
      "indent": 3,
      "text": "2. While creating an elementary chunk a platform dependent transformation to a platform independent format of the data is performed - at the end of construction the content of the buffer is ready to transport to another site, without any further translation.",
      "ja": "2. 基本チャンクの作成中、プラットフォームに依存するデータのデータの独立した形式への依存変換が実行されます。建設の最後に、バッファのコンテンツは、さらなる翻訳なしで別のサイトに輸送する準備ができています。"
    },
    {
      "indent": 3,
      "text": "3. As you see no data definition in your programming language is needed for to construct a specific SDXF structure. The data is created dynamically by function calls.",
      "ja": "3. 特定のSDXF構造を構築するためには、プログラミング言語にデータ定義が必要ありません。データは、関数呼び出しによって動的に作成されます。"
    },
    {
      "indent": 3,
      "text": "4. With SDXF as a base you can define protocols for client / server applications. These protocols may be extended in downward compatibility manner by following two rules:",
      "ja": "4. SDXFをベースとして使用すると、クライアント /サーバーアプリケーションのプロトコルを定義できます。これらのプロトコルは、2つのルールに従うことにより、下向きの互換性で拡張できます。"
    },
    {
      "indent": 6,
      "text": "Rule 1: Ignore unknown chunkIDs.",
      "ja": "ルール1：不明な帯域を無視します。"
    },
    {
      "indent": 6,
      "text": "Rule 2: The sequence of chunks should not be significant.",
      "ja": "ルール2：チャンクのシーケンスは重要ではありません。"
    },
    {
      "indent": 0,
      "text": "12. IANA Considerations",
      "section_title": true,
      "ja": "12. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The compression and encryption algorithms for SDXF is not fixed, SDXF is open for various algorithms. Therefore an agreement is necessary to interprete the compression and encryption algorithm method numbers. (Encryption methods are not a semantic part of SDXF, but may be used for a connection protocol to negotiate the encryption method to use.)",
      "ja": "SDXFの圧縮および暗号化アルゴリズムは固定されていません。SDXFはさまざまなアルゴリズムに対して開かれています。したがって、圧縮および暗号化アルゴリズムのメソッド番号を解釈するには、合意が必要です。（暗号化方法はSDXFのセマンティック部分ではありませんが、使用する暗号化方法をネゴシエートするために接続プロトコルに使用できます。）"
    },
    {
      "indent": 3,
      "text": "Following two items are registered by IANA:",
      "ja": "次の2つの項目がIANAによって登録されています。"
    },
    {
      "indent": 0,
      "text": "12.1 COMPRESSION METHODS FOR SDXF",
      "section_title": true,
      "ja": "12.1 SDXFの圧縮方法"
    },
    {
      "indent": 3,
      "text": "The compressed SDXF chunk starts with a \"compression header\".  This\nheader contains the compression method as an unsigned 1-Byte integer\n(1-255).  These numbers are assigned by IANA and listed here:\n   compression\n method     Description                     Hints\n---------   ------------------------------- -------------\n      01    RUN-LENGTH algorithm            see chap. 5\n      02    DEFLATE (ZIP)                   see [DEFLATE]\n  03-239    IANA to assign\n 240-255    private or application specific",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "12.2 ENCRYPTION METHODS FOR SDXF",
      "section_title": true,
      "ja": "12.2 SDXFの暗号化方法"
    },
    {
      "indent": 3,
      "text": "An unique encryption method is fixed or negotiated by handshaking. For the latter one a number for each encryption method is necessary. These numbers are unsigned 1-Byte integers (1-255). These numbers are assigned by IANA and listed here:",
      "ja": "一意の暗号化方法は、手作業で固定または交渉されます。後者の場合、各暗号化方法の数値が必要です。これらの数値は、署名されていない1バイト整数（1-255）です。これらの番号はIANAによって割り当てられ、ここにリストされています。"
    },
    {
      "indent": 3,
      "text": "encryption\n  method    Description\n ---------  ------------------------------\n  01-239    IANA to assign\n 240-255    private or application specific",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "12.3 Hints for assigning a number:",
      "ja": "12.3 番号を割り当てるためのヒント："
    },
    {
      "indent": 3,
      "text": "Developers which want to register a compression or encrypt method for SDXF should contact IANA for a method number. The ASSIGNED NUMBERS document should be referred to for a current list of METHOD numbers and their corresponding protocols, see [IANA]. The new method SHOULD be a standard published as a RFC or by a established standardization organization (as OSI).",
      "ja": "SDXFの圧縮または暗号化方法を登録する開発者は、メソッド番号についてIANAに連絡する必要があります。割り当てられた番号ドキュメントは、メソッド番号とそれらに対応するプロトコルの現在のリストについて参照する必要があります。[IANA]を参照してください。新しい方法は、RFCとして、または確立された標準化組織（OSIとして）によって公開される標準である必要があります。"
    },
    {
      "indent": 0,
      "text": "13. Discussion",
      "section_title": true,
      "ja": "13. 考察"
    },
    {
      "indent": 3,
      "text": "There are already some standards for Internet data exchanging, IETF prefers ASN.1 and XML therefore. So the reasons for establish a new data format should be discussed.",
      "ja": "IETFは、インターネットデータの交換にはすでにいくつかの基準があります。したがって、IETFはXMLを好みます。したがって、新しいデータ形式を確立する理由について説明する必要があります。"
    },
    {
      "indent": 0,
      "text": "13.1 SDXF vs. ASN.1",
      "section_title": true,
      "ja": "13.1 SDXF対ASN.1"
    },
    {
      "indent": 3,
      "text": "The demand of ASN.1 (see [ASN.1]) is to serve program language independent means to define data structures. The real data format which is used to send the data is not defined by ASN.1 but usually BER or PER (or some derivates of them like CER and DER) are used in this context, see [BER] and [PER].",
      "ja": "asn.1（[asn.1]を参照）の需要は、データ構造を定義するためのプログラム言語に依存しない手段を提供することです。データの送信に使用される実際のデータ形式は、asn.1によって定義されませんが、通常はBERまたはPER（またはCERやDERのような派生物）がこのコンテキストで使用されます。[BER]および[PER]を参照してください。"
    },
    {
      "indent": 3,
      "text": "The idea behind ASN.1 is: On every platform on which a given application is to develop descriptions of the used data structures are available in ASN.1 notation. Out off these notations the real language dependent definitions are generated with the help of an ASN.1-compiler.",
      "ja": "ASN.1の背後にあるアイデアは、特定のアプリケーションが使用されているデータ構造の説明を開発することであるすべてのプラットフォームで、ASN.1表記で利用可能です。これらの表記の外で、ASN.1コンパイラの助けを借りて、実際の言語依存定義が生成されます。"
    },
    {
      "indent": 3,
      "text": "This compiler generates also transform functions for these data structures for to pack and unpack to and from the BER (or other) format.",
      "ja": "このコンパイラは、これらのデータ構造の関数を生成し、BER（または他の）形式をパックして開梱するために変換されます。"
    },
    {
      "indent": 3,
      "text": "A direct comparison between ASN.1 and SDXF is somehow inappropriate: The data format of SDXF is related rather to BER (and relatives). The use of ASN.1 to define data structures is no contradiction to SDXF, but: SDXF does not require a complete data structure to build the message to send, nor a complete data structure will be generated out off the received message.",
      "ja": "ASN.1とSDXFの直接的な比較は何らかの形で不適切です。SDXFのデータ形式は、BER（および親relative）に関連しています。データ構造を定義するためにASN.1を使用することはSDXFと矛盾するものではありませんが、SDXFは送信するメッセージを作成するために完全なデータ構造を必要としません。また、受信したメッセージから完全なデータ構造も生成されます。"
    },
    {
      "indent": 3,
      "text": "The main difference lies in the concept of building and interpretation of the message, I want to name it the \"static\" and \"dynamic\" concept:",
      "ja": "主な違いは、メッセージの構築と解釈の概念にあります。「静的」と「動的な」概念と名付けたいと思います。"
    },
    {
      "indent": 3,
      "text": "o ASN.1 uses a \"static\" approach: The whole data structure must exists before the message can be created.",
      "ja": "o ASN.1は「静的」アプローチを使用します。メッセージを作成する前に、データ構造全体が存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "o SDXF constructs and interpretes the message in a \"dynamic\" way, the message will be packed and unpacked step by step by SDXF functions.",
      "ja": "o SDXFはメッセージを「ダイナミックな」方法で構築および解釈するため、メッセージは梱包され、SDXF関数ごとに段階的に開梱されます。"
    },
    {
      "indent": 3,
      "text": "The use of static structures may be appropriate for a series of applications, but for complex tasks it is often impossible to define the message as a whole. As an example try to define an ASN.1 description for a complex structured text document which is presented in XML: There are sections and paragraphs and text elements which may recursively consist of sections with specific text attributes.",
      "ja": "静的構造の使用は、一連のアプリケーションに適している場合がありますが、複雑なタスクでは、メッセージ全体を定義することは不可能です。例として、XMLで提示されている複雑な構造化されたテキストドキュメントのasn.1説明を定義してみてください。特定のテキスト属性を持つセクションで再帰的に構成される可能性のあるセクションとパラグラフとテキスト要素があります。"
    },
    {
      "indent": 0,
      "text": "13.2 SDXF vs. XML",
      "section_title": true,
      "ja": "13.2 SDXF対XML"
    },
    {
      "indent": 3,
      "text": "On the one hand SDXF and XML are similar as they can handle any recursive complex data stream. The main difference is the kind of data which are to be maintained:",
      "ja": "一方では、SDXFとXMLは、再帰的な複雑なデータストリームを処理できるため、似ています。主な違いは、維持されるデータの種類です。"
    },
    {
      "indent": 3,
      "text": "o XML works with pure text data (though it should be noted that the character representation is not standardized by XML). And: a XML document with all his tags is readable by human. Binary data as graphic is not included directly but may be referenced by an external link as in HTML.",
      "ja": "o XMLは純粋なテキストデータで動作します（ただし、文字表現はXMLによって標準化されていないことに注意する必要があります）。および：すべてのタグを備えたXMLドキュメントは、人間が読むことができます。グラフィックとしてのバイナリデータは直接含まれていませんが、HTMLのように外部リンクによって参照される場合があります。"
    },
    {
      "indent": 6,
      "text": "In XML there is no strong separation between informational and control data, escape characters (like \"<\" and \"&\") and the <![CDATA[...]]> construction are used to distinguish between these two types of data.",
      "ja": "XMLでは、情報データと制御データの間に強い分離はありません。エスケープ文字（「<」や「＆」など）、<！[cdata [...]]>構造は、これら2つのタイプのデータを区別するために使用されます。"
    },
    {
      "indent": 3,
      "text": "o SDXF maintains machine-readable data, it is not designed to be readable by human nor to edit SDXF data with a text editor (even more if compression and encryption is used). With the help of the SDXF functions you have a quick and easy access to every data element. The standard parser for a SDXF data structure follows always a simple template, the \"while - switch -case ID - enter/extract\" pattern as outlined in chap. 3.4.2.",
      "ja": "o SDXFは機械可読データを維持します。これは、人間が読みやすくすることも、テキストエディターでSDXFデータを編集するようにも設計されていません（圧縮と暗号化が使用される場合はさらに多く）。 SDXF関数の助けを借りて、すべてのデータ要素にすばやく簡単にアクセスできます。 SDXFデータ構造の標準パーサーは、常に単純なテンプレート、「while -switch -case id -Enter/抽出」パターンに続きます。 3.4.2。"
    },
    {
      "indent": 3,
      "text": "Because of the complete different philosophy behind XML and SDXF (and even ASN.1) a direct comparison may not be very senseful, as XML has its own right to exist next to ASN.1 (and even SDXF).",
      "ja": "XMLとSDXFの背後にある完全な異なる哲学のために、XMLにはASN.1（およびSDXF）の隣に存在する独自の権利があるため、直接的な比較はそれほど意味がないかもしれません。"
    },
    {
      "indent": 3,
      "text": "Nevertheless there is a chance to convert a XML data stream into a SDXF structure: As a first strike, every XML tag becomes a SDXF chunk ID. An elementary sequence <tag>pure text</tag> can be transformed into an elementary (non-structured) chunk with data type \"character\". Tags with attributes and sequences with nested tags are transformed into structured chunks. Because XML allows a tag sequence everywhere in a text stream, an artificially \"elementary text\" tag must be introduced: If <t> is the tag for text elements, the sequence:",
      "ja": "それにもかかわらず、XMLデータストリームをSDXF構造に変換する機会があります。最初のストライクとして、すべてのXMLタグはSDXFチャンクIDになります。初等シーケンス<タグ>純粋なテキスト</tag>は、データ型「文字」を使用して小学校（非構造化）チャンクに変換できます。ネストされたタグを使用した属性とシーケンスを持つタグは、構造化されたチャンクに変換されます。XMLはテキストストリーム内のどこでもタグシーケンスを許可するため、人為的に「基本テキスト」タグを導入する必要があります。<t>がテキスト要素のタグである場合、シーケンス："
    },
    {
      "indent": 3,
      "text": "<t>this is a text <attr value='bold'>with</attr> attributes</t>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "is to be \"in thought\" replaced by:",
      "ja": "次のことに置き換えられることです。"
    },
    {
      "indent": 3,
      "text": "<t><et>this is a text </et><attr value='bold'><et>with</et></attr>\n<et> attributes</et></t>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(With \"et\" as the \"elementary text\" tag) This results in following SDXF structure:",
      "ja": "（「ET」を「初等のテキスト」タグとして）これにより、SDXF構造に続きます。"
    },
    {
      "indent": 3,
      "text": "ID_t\n|\n+-- ID_et = \" this is a text \"\n|\n+-- ID_attr\n|   |\n|   +-- ID_value = \"bold\"\n|   |\n|   +-- ID_et = \"with\"\n|\n+-- ID_et = \" attributes\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ID_t and ID_et may be represented by the same chunk ID, only distinguished by the data type (\"structured\" for <t> and \"character\" for <et>)",
      "ja": "ID_TおよびID_ETは、同じチャンクIDで表される場合があり、データ型（<t>の「構造」と<et>の「文字」）によってのみ区別される場合があります。"
    },
    {
      "indent": 3,
      "text": "Binary data as pictures can be directly imbedded into a SDXF structure instead referencing them as an external link like in HTML.",
      "ja": "写真としてのバイナリデータは、HTMLのような外部リンクとしてそれらを参照する代わりに、SDXF構造に直接埋め込むことができます。"
    },
    {
      "indent": 0,
      "text": "14. Author's Address",
      "section_title": true,
      "ja": "14. 著者の連絡先"
    },
    {
      "indent": 3,
      "text": "Max Wildgrube Schlossstrasse 120 60486 Frankfurt Germany",
      "ja": "Max WildGrube SchlossStrasse 120 60486フランクフルトドイツ"
    },
    {
      "indent": 3,
      "text": "EMail: max@wildgrube.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "15. Acknowledgements",
      "section_title": true,
      "ja": "15. 謝辞"
    },
    {
      "indent": 3,
      "text": "I would like to thank Michael J. Slifcak (mslifcak@iss.net) for the supporting discussions.",
      "ja": "サポートの議論について、Michael J. Slifcak（mslifcak@iss.net）に感謝します。"
    },
    {
      "indent": 0,
      "text": "16. References",
      "section_title": true,
      "ja": "16. 参考文献"
    },
    {
      "indent": 3,
      "text": "[ASN.1] Information processing systems - Open Systems Interconnection, \"Specification of Abstract Syntax Notation One (ASN.1)\", International Organization for Standardization, International Standard 8824, December 1987.",
      "ja": "[ASN.1]情報処理システム - オープンシステムの相互接続、「抽象的構文表記1（ASN.1）の仕様」、国際標準化機関、国際標準8824、1987年12月。"
    },
    {
      "indent": 3,
      "text": "[BER] Information Processing Systems - Open Systems Interconnection - \"Specification of Basic Encoding Rules for Abstract Notation One (ASN.1)\", International Organization for Standardization, International Standard 8825-1, December 1987.",
      "ja": "[BER]情報処理システム - オープンシステムの相互接続 - 「抽象表記1（ASN.1）の基本エンコードルールの仕様」、国際標準化機関、国際標準8825-1、1987年12月。"
    },
    {
      "indent": 3,
      "text": "[DEFLATE] Deutsch, P., \"DEFLATE Compressed Data Format Specification version 1.3\", RFC 1951, May 1996.",
      "ja": "[DEFLATE] Deutsch、P。、「Deflate圧縮データ形式仕様バージョン1.3」、RFC 1951、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[IANA] Internet Assigned Numbers Authority, http://www.iana.org/numbers.htm",
      "ja": "[IANA]インターネットが割り当てられた数字の権限、http://www.iana.org/numbers.htm"
    },
    {
      "indent": 3,
      "text": "[PER] Information Processing Systems - Open Systems Interconnection -\"Specification of Packed Encoding Rules for Abstract Syntax Notation One (ASN.1)\", International Organization for Standardization, International Standard 8825-2.",
      "ja": "[PER]情報処理システム - オープンシステムの相互接続 - 「抽象的構文表記1（ASN.1）のための詰め込まれたエンコードルールの仕様」、国際標準化機関、国際標準8825-2。"
    },
    {
      "indent": 3,
      "text": "[UCS] ISO/IEC 10646-1:1993. International Standard -- Information technology -- Universal Multiple-Octet Coded Character Set (UCS)",
      "ja": "[UCS] ISO/IEC 10646-1：1993。国際標準 - 情報技術 - ユニバーサルマルチオクテットコード化された文字セット（UCS）"
    },
    {
      "indent": 3,
      "text": "[UTF8] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", RFC 2279, January 1998.",
      "ja": "[UTF8] Yergeau、F。、「UTF-8、ISO 10646の変換形式」、RFC 2279、1998年1月。"
    },
    {
      "indent": 0,
      "text": "17. Full Copyright Statement",
      "section_title": true,
      "ja": "17. 完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2001）。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書と本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}