{
  "title": {
    "text": "RFC 3493 - Basic Socket Interface Extensions for IPv6",
    "ja": "RFC 3493 - IPv6の基本的なソケットインターフェイス拡張機能"
  },
  "number": 3493,
  "created_at": "2023-10-31 15:17:55.693037+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                        R. Gilligan\nRequest for Comments: 3493                                Intransa, Inc.\nObsoletes: 2553                                               S. Thomson\nCategory: Informational                                            Cisco\n                                                                J. Bound\n                                                               J. McCann\n                                                         Hewlett-Packard\n                                                              W. Stevens\n                                                           February 2003",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Basic Socket Interface Extensions for IPv6",
      "ja": "IPv6の基本的なソケットインターフェイス拡張機能"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモは、インターネットコミュニティに情報を提供します。いかなる種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2003）。無断転載を禁じます。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "The de facto standard Application Program Interface (API) for TCP/IP applications is the \"sockets\" interface. Although this API was developed for Unix in the early 1980s it has also been implemented on a wide variety of non-Unix systems. TCP/IP applications written using the sockets API have in the past enjoyed a high degree of portability and we would like the same portability with IPv6 applications. But changes are required to the sockets API to support IPv6 and this memo describes these changes. These include a new socket address structure to carry IPv6 addresses, new address conversion functions, and some new socket options. These extensions are designed to provide access to the basic IPv6 features required by TCP and UDP applications, including multicasting, while introducing a minimum of change into the system and providing complete compatibility for existing IPv4 applications. Additional extensions for advanced IPv6 features (raw sockets and access to the IPv6 extension headers) are defined in another document.",
      "ja": "TCP/IPアプリケーションの事実上の標準アプリケーションプログラムインターフェイス（API）は、「ソケット」インターフェイスです。このAPIは1980年代初頭にUNIX向けに開発されましたが、さまざまな非UNIXシステムにも実装されています。Sockets APIを使用して記述されたTCP/IPアプリケーションは、過去に高度な携帯性を享受しており、IPv6アプリケーションでも同じ移植性を希望しています。ただし、IPv6をサポートするにはSockets APIに変更が必要であり、このメモはこれらの変更について説明しています。これらには、IPv6アドレスを運ぶための新しいソケットアドレス構造、新しいアドレス変換関数、およびいくつかの新しいソケットオプションが含まれます。これらの拡張機能は、マルチキャストを含むTCPおよびUDPアプリケーションで必要な基本的なIPv6機能へのアクセスを提供するように設計されており、システムに最小限の変更を導入し、既存のIPv4アプリケーションに完全な互換性を提供します。高度なIPv6機能（生のソケットとIPv6拡張ヘッダーへのアクセス）の追加の拡張機能は、別のドキュメントで定義されています。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction................................................3\n2.  Design Considerations.......................................4\n    2.1  What Needs to be Changed...............................4\n    2.2  Data Types.............................................6\n    2.3  Headers................................................6\n    2.4  Structures.............................................6\n3.  Socket Interface............................................6\n    3.1  IPv6 Address Family and Protocol Family................6\n    3.2  IPv6 Address Structure.................................7\n    3.3  Socket Address Structure for 4.3BSD-Based Systems......7\n    3.4  Socket Address Structure for 4.4BSD-Based Systems......9\n    3.5  The Socket Functions...................................9\n    3.6  Compatibility with IPv4 Applications..................10\n    3.7  Compatibility with IPv4 Nodes.........................11\n    3.8  IPv6 Wildcard Address.................................11\n    3.9  IPv6 Loopback Address.................................13\n    3.10 Portability Additions.................................14\n4.  Interface Identification...................................16\n    4.1  Name-to-Index.........................................17\n    4.2  Index-to-Name.........................................17\n    4.3  Return All Interface Names and Indexes................18\n    4.4  Free Memory...........................................18\n5.  Socket Options.............................................18\n    5.1  Unicast Hop Limit.....................................19\n    5.2  Sending and Receiving Multicast Packets...............19\n    5.3  IPV6_V6ONLY option for AF_INET6 Sockets...............22\n6.  Library Functions..........................................22\n    6.1  Protocol-Independent Nodename and\n         Service Name Translation..............................23\n    6.2  Socket Address Structure to Node Name\n         and Service Name......................................28\n    6.3  Address Conversion Functions..........................31\n    6.4  Address Testing Macros................................33\n7.  Summary of New Definitions.................................33\n8.  Security Considerations....................................35\n9.  Changes from RFC 2553......................................35\n10. Acknowledgments............................................36\n11. References.................................................37\n12. Authors' Addresses.........................................38\n13. Full Copyright Statement...................................39",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "While IPv4 addresses are 32 bits long, IPv6 addresses are 128 bits long. The socket interface makes the size of an IP address quite visible to an application; virtually all TCP/IP applications for BSD-based systems have knowledge of the size of an IP address. Those parts of the API that expose the addresses must be changed to accommodate the larger IPv6 address size. IPv6 also introduces new features, some of which must be made visible to applications via the API. This memo defines a set of extensions to the socket interface to support the larger address size and new features of IPv6. It defines \"basic\" extensions that are of use to a broad range of applications. A companion document, the \"advanced\" API [4], covers extensions that are of use to more specialized applications, examples of which include routing daemons, and the \"ping\" and \"traceroute\" utilities.",
      "ja": "IPv4アドレスの長さは32ビットですが、IPv6アドレスの長さは128ビットです。ソケットインターフェイスにより、IPアドレスのサイズがアプリケーションに非常に表示されます。BSDベースのシステムの実質的にすべてのTCP/IPアプリケーションには、IPアドレスのサイズの知識があります。アドレスを公開するAPIのこれらの部分は、より大きなIPv6アドレスサイズに対応するために変更する必要があります。IPv6には新機能も導入されており、その一部はAPIを介してアプリケーションに表示できるようにする必要があります。このメモは、IPv6のより大きなアドレスサイズと新機能をサポートするために、ソケットインターフェイスへの一連の拡張機能を定義します。幅広いアプリケーションに使用される「基本的な」拡張機能を定義します。コンパニオンドキュメントである「Advanced」API [4]は、より専門化されたアプリケーションに使用される拡張機能をカバーしています。その例では、Daemonsと「Ping」および「Traceroute」ユーティリティが含まれます。"
    },
    {
      "indent": 3,
      "text": "The development of this API was started in 1994 in the IETF IPng working group. The API has evolved over the years, published first in RFC 2133, then again in RFC 2553, and reaching its final form in this document.",
      "ja": "このAPIの開発は、1994年にIETF IPNGワーキンググループで開始されました。APIは長年にわたって進化し、RFC 2133で最初に公開され、次にRFC 2553で再び公開され、このドキュメントで最終フォームに達しました。"
    },
    {
      "indent": 3,
      "text": "As the API matured and stabilized, it was incorporated into the Open Group's Networking Services (XNS) specification, issue 5.2, which was subsequently incorporated into a joint Open Group/IEEE/ISO standard [3].",
      "ja": "APIが成熟して安定化すると、オープングループのネットワークサービス（XNS）仕様である問題5.2に組み込まれました。これは、その後、オープングループ/IEEE/ISO標準に組み込まれました[3]。"
    },
    {
      "indent": 3,
      "text": "Effort has been made to ensure that this document and [3] contain the same information with regard to the API definitions. However, the reader should note that this document is for informational purposes only, and that the official standard specification of the sockets API is [3].",
      "ja": "このドキュメントと[3]がAPI定義に関して同じ情報が含まれていることを確認するための努力がなされてきました。ただし、読者は、このドキュメントは情報提供のみを目的としており、ソケットAPIの公式標準仕様は[3]であることに注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "It is expected that any future standardization work on this API would be done by the Open Group Base Working Group [6].",
      "ja": "このAPIでの将来の標準化作業は、オープングループベースワーキンググループ[6]によって行われることが期待されています。"
    },
    {
      "indent": 3,
      "text": "It should also be noted that this document describes only those portions of the API needed for IPv4 and IPv6 communications. Other potential uses of the API, for example the use of getaddrinfo() and getnameinfo() with the AF_UNIX address family, are beyond the scope of this document.",
      "ja": "また、このドキュメントでは、IPv4およびIPv6通信に必要なAPIの部分のみが記述されていることにも注意してください。APIのその他の潜在的な使用、たとえばAF_UNIXアドレスファミリでgetAddrinfo（）およびgetNameInfo（）の使用は、このドキュメントの範囲を超えています。"
    },
    {
      "indent": 0,
      "text": "2. Design Considerations",
      "section_title": true,
      "ja": "2. 設計上の考慮事項"
    },
    {
      "indent": 3,
      "text": "There are a number of important considerations in designing changes to this well-worn API:",
      "ja": "この使い古されたAPIの変更を設計する際には、多くの重要な考慮事項があります。"
    },
    {
      "indent": 3,
      "text": "- The API changes should provide both source and binary compatibility for programs written to the original API. That is, existing program binaries should continue to operate when run on a system supporting the new API. In addition, existing applications that are re-compiled and run on a system supporting the new API should continue to operate. Simply put, the API changes for IPv6 should not break existing programs. An additional mechanism for implementations to verify this is to verify the new symbols are protected by Feature Test Macros as described in [3]. (Such Feature Test Macros are not defined by this RFC.)",
      "ja": "- APIの変更は、元のAPIに書かれたプログラムのソースとバイナリの互換性の両方を提供する必要があります。つまり、既存のプログラムバイナリは、新しいAPIをサポートするシステムで実行すると、引き続き動作します。さらに、新しいAPIをサポートするシステムで再コンパイルされて実行される既存のアプリケーションは、引き続き動作し続ける必要があります。簡単に言えば、IPv6のAPI変更は既存のプログラムを壊すべきではありません。これを検証するための実装の追加メカニズムは、[3]で説明されているように、特徴テストマクロによって新しいシンボルが保護されていることを確認することです。（このような機能テストマクロは、このRFCによって定義されていません。）"
    },
    {
      "indent": 3,
      "text": "- The changes to the API should be as small as possible in order to simplify the task of converting existing IPv4 applications to IPv6.",
      "ja": "- APIの変更は、既存のIPv4アプリケーションをIPv6に変換するタスクを簡素化するために、できるだけ小さくする必要があります。"
    },
    {
      "indent": 3,
      "text": "- Where possible, applications should be able to use this API to interoperate with both IPv6 and IPv4 hosts. Applications should not need to know which type of host they are communicating with.",
      "ja": "- 可能であれば、アプリケーションはこのAPIを使用して、IPv6ホストとIPv4ホストの両方と相互運用できる必要があります。アプリケーションは、どのタイプのホストと通信しているかを知る必要はありません。"
    },
    {
      "indent": 3,
      "text": "- IPv6 addresses carried in data structures should be 64-bit aligned. This is necessary in order to obtain optimum performance on 64-bit machine architectures.",
      "ja": "- データ構造に搭載されているIPv6アドレスは、64ビットアライメントする必要があります。これは、64ビットマシンアーキテクチャで最適なパフォーマンスを取得するために必要です。"
    },
    {
      "indent": 3,
      "text": "Because of the importance of providing IPv4 compatibility in the API, these extensions are explicitly designed to operate on machines that provide complete support for both IPv4 and IPv6. A subset of this API could probably be designed for operation on systems that support only IPv6. However, this is not addressed in this memo.",
      "ja": "APIでIPv4の互換性を提供することの重要性があるため、これらの拡張機能は、IPv4とIPv6の両方に完全なサポートを提供するマシンで動作するように明示的に設計されています。このAPIのサブセットは、おそらくIPv6のみをサポートするシステム上の動作用に設計できます。ただし、これはこのメモでは対処されていません。"
    },
    {
      "indent": 0,
      "text": "2.1 What Needs to be Changed",
      "section_title": true,
      "ja": "2.1 何を変更する必要がありますか"
    },
    {
      "indent": 3,
      "text": "The socket interface API consists of a few distinct components:",
      "ja": "Socket Interface APIは、いくつかの異なるコンポーネントで構成されています。"
    },
    {
      "indent": 3,
      "text": "- Core socket functions.",
      "ja": "- コアソケット機能。"
    },
    {
      "indent": 3,
      "text": "- Address data structures.",
      "ja": "- アドレスデータ構造。"
    },
    {
      "indent": 3,
      "text": "- Name-to-address translation functions.",
      "ja": "- 名前からアドレスへの翻訳関数。"
    },
    {
      "indent": 3,
      "text": "- Address conversion functions.",
      "ja": "- アドレス変換関数。"
    },
    {
      "indent": 3,
      "text": "The core socket functions -- those functions that deal with such things as setting up and tearing down TCP connections, and sending and receiving UDP packets -- were designed to be transport independent. Where protocol addresses are passed as function arguments, they are carried via opaque pointers. A protocol-specific address data structure is defined for each protocol that the socket functions support. Applications must cast pointers to these protocol-specific address structures into pointers to the generic \"sockaddr\" address structure when using the socket functions. These functions need not change for IPv6, but a new IPv6-specific address data structure is needed.",
      "ja": "コアソケット機能 -  TCP接続のセットアップと引き裂き、UDPパケットの送信と受信などの機能を扱う機能は、独立しているように設計されています。プロトコルアドレスが関数引数として渡される場合、それらは不透明なポインターを介して運ばれます。ソケット機能がサポートするプロトコルごとに、プロトコル固有のアドレスデータ構造が定義されます。アプリケーションは、ソケット機能を使用する場合、これらのプロトコル固有のアドレス構造にポインターをキャストする必要があります。これらの関数はIPv6の変更を変更する必要はありませんが、新しいIPv6固有のアドレスデータ構造が必要です。"
    },
    {
      "indent": 3,
      "text": "The \"sockaddr_in\" structure is the protocol-specific data structure for IPv4. This data structure actually includes 8-octets of unused space, and it is tempting to try to use this space to adapt the sockaddr_in structure to IPv6. Unfortunately, the sockaddr_in structure is not large enough to hold the 16-octet IPv6 address as well as the other information (address family and port number) that is needed. So a new address data structure must be defined for IPv6.",
      "ja": "「Sockaddr_in」構造は、IPv4のプロトコル固有のデータ構造です。このデータ構造には、実際には未使用スペースの8オクテットが含まれており、このスペースを使用してSockaddr_in構造をIPv6に適応させようとするのは魅力的です。残念ながら、Sockaddr_in構造は、16オクテットのIPv6アドレスと、必要な他の情報（アドレスファミリ番号）を保持するのに十分な大きさではありません。したがって、IPv6に対して新しいアドレスデータ構造を定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "IPv6 addresses are scoped [2] so they could be link-local, site, organization, global, or other scopes at this time undefined. To support applications that want to be able to identify a set of interfaces for a specific scope, the IPv6 sockaddr_in structure must support a field that can be used by an implementation to identify a set of interfaces identifying the scope for an IPv6 address.",
      "ja": "IPv6アドレスはスコープ[2]であるため、現時点ではリンクローカル、サイト、組織、グローバル、またはその他のスコープにすることができます。特定の範囲のインターフェイスのセットを識別できるようにするアプリケーションをサポートするには、IPv6 Sockaddr_in構造は、IPv6アドレスの範囲を識別する一連のインターフェイスを識別するために実装によって使用できるフィールドをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "The IPv4 name-to-address translation functions in the socket interface are gethostbyname() and gethostbyaddr(). These are left as is, and new functions are defined which support both IPv4 and IPv6.",
      "ja": "ソケットインターフェイスのIPv4名からアドレスへの翻訳関数は、gethostbyname（）およびgethostbyaddr（）です。これらはそのまま残っており、IPv4とIPv6の両方をサポートする新しい機能が定義されています。"
    },
    {
      "indent": 3,
      "text": "The IPv4 address conversion functions -- inet_ntoa() and inet_addr() -- convert IPv4 addresses between binary and printable form. These functions are quite specific to 32-bit IPv4 addresses. We have designed two analogous functions that convert both IPv4 and IPv6 addresses, and carry an address type parameter so that they can be extended to other protocol families as well.",
      "ja": "IPv4アドレス変換関数-INET_NTOA（）およびINET_ADDR（）-IPv4アドレスをバイナリと印刷可能なフォーム間で変換します。これらの機能は、32ビットIPv4アドレスに非常に固有です。IPv4アドレスとIPv6アドレスの両方を変換する2つの類似の関数を設計し、アドレスタイプパラメーターを他のプロトコルファミリーに拡張できるようにしています。"
    },
    {
      "indent": 3,
      "text": "Finally, a few miscellaneous features are needed to support IPv6. A new interface is needed to support the IPv6 hop limit header field. New socket options are needed to control the sending and receiving of IPv6 multicast packets.",
      "ja": "最後に、IPv6をサポートするには、いくつかのその他の機能が必要です。IPv6ホップリミットヘッダーフィールドをサポートするには、新しいインターフェイスが必要です。IPv6マルチキャストパケットの送信と受信を制御するには、新しいソケットオプションが必要です。"
    },
    {
      "indent": 3,
      "text": "The socket interface will be enhanced in the future to provide access to other IPv6 features. Some of these extensions are described in [4].",
      "ja": "ソケットインターフェイスは、他のIPv6機能へのアクセスを提供するために将来強化されます。これらの拡張機能の一部は[4]で説明されています。"
    },
    {
      "indent": 0,
      "text": "2.2 Data Types",
      "section_title": true,
      "ja": "2.2 データ型"
    },
    {
      "indent": 3,
      "text": "The data types of the structure elements given in this memo are intended to track the relevant standards. uintN_t means an unsigned integer of exactly N bits (e.g., uint16_t). The sa_family_t and in_port_t types are defined in [3].",
      "ja": "このメモに記載されている構造要素のデータ型は、関連する標準を追跡することを目的としています。uintn_tとは、正確なnビット（uint16_tなど）の符号なし整数を意味します。SA_FAMILY_TおよびIN_PORT_Tタイプは[3]で定義されています。"
    },
    {
      "indent": 0,
      "text": "2.3 Headers",
      "section_title": true,
      "ja": "2.3 ヘッダー"
    },
    {
      "indent": 3,
      "text": "When function prototypes and structures are shown we show the headers that must be #included to cause that item to be defined.",
      "ja": "関数のプロトタイプと構造が示されている場合、そのアイテムを定義するために#includedでなければならないヘッダーを表示します。"
    },
    {
      "indent": 0,
      "text": "2.4 Structures",
      "section_title": true,
      "ja": "2.4 構造"
    },
    {
      "indent": 3,
      "text": "When structures are described the members shown are the ones that must appear in an implementation. Additional, nonstandard members may also be defined by an implementation. As an additional precaution nonstandard members could be verified by Feature Test Macros as described in [3]. (Such Feature Test Macros are not defined by this RFC.)",
      "ja": "構造を説明する場合、表示されているメンバーは、実装に表示されなければならないメンバーです。追加の非標準メンバーは、実装によって定義される場合もあります。追加の予防策として、[3]で説明されているように、特徴テストマクロによって非標準メンバーを検証することができます。（このような機能テストマクロは、このRFCによって定義されていません。）"
    },
    {
      "indent": 3,
      "text": "The ordering shown for the members of a structure is the recommended ordering, given alignment considerations of multibyte members, but an implementation may order the members differently.",
      "ja": "構造のメンバーに示されている順序は、マルチバイトメンバーのアラインメントに関する考慮事項を考慮して、推奨される注文ですが、実装によりメンバーが異なる方法で注文する場合があります。"
    },
    {
      "indent": 0,
      "text": "3. Socket Interface",
      "section_title": true,
      "ja": "3. ソケットインターフェイス"
    },
    {
      "indent": 3,
      "text": "This section specifies the socket interface changes for IPv6.",
      "ja": "このセクションでは、IPv6のソケットインターフェイスの変更を指定します。"
    },
    {
      "indent": 0,
      "text": "3.1 IPv6 Address Family and Protocol Family",
      "section_title": true,
      "ja": "3.1 IPv6はファミリおよびプロトコルファミリーを扱います"
    },
    {
      "indent": 3,
      "text": "A new address family name, AF_INET6, is defined in <sys/socket.h>. The AF_INET6 definition distinguishes between the original sockaddr_in address data structure, and the new sockaddr_in6 data structure.",
      "ja": "新しいアドレス姓AF_INET6は、<sys/socket.h>で定義されています。AF_INET6の定義は、元のSockaddr_inアドレスデータ構造と新しいSockaddr_in6データ構造を区別します。"
    },
    {
      "indent": 3,
      "text": "A new protocol family name, PF_INET6, is defined in <sys/socket.h>. Like most of the other protocol family names, this will usually be defined to have the same value as the corresponding address family name:",
      "ja": "新しいプロトコル姓PF_INET6は、<sys/socket.h>で定義されています。他のプロトコル名のほとんどと同様に、これは通常、対応するアドレス姓と同じ値を持つように定義されます。"
    },
    {
      "indent": 6,
      "text": "#define PF_INET6 AF_INET6",
      "ja": "#define pf_inet6 af_inet6"
    },
    {
      "indent": 3,
      "text": "The AF_INET6 is used in the first argument to the socket() function to indicate that an IPv6 socket is being created.",
      "ja": "AF_INET6は、Socket（）関数の最初の引数で使用され、IPv6ソケットが作成されていることを示します。"
    },
    {
      "indent": 0,
      "text": "3.2 IPv6 Address Structure",
      "section_title": true,
      "ja": "3.2 IPv6アドレス構造"
    },
    {
      "indent": 3,
      "text": "A new in6_addr structure holds a single IPv6 address and is defined as a result of including <netinet/in.h>:",
      "ja": "新しいIN6_ADDR構造は単一のIPv6アドレスを保持し、<netinet/in.h>を含める結果として定義されます。"
    },
    {
      "indent": 6,
      "text": "struct in6_addr {\n    uint8_t  s6_addr[16];      /* IPv6 address */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This data structure contains an array of sixteen 8-bit elements, which make up one 128-bit IPv6 address. The IPv6 address is stored in network byte order.",
      "ja": "このデータ構造には、1つの128ビットIPv6アドレスを構成する16の8ビット要素の配列が含まれています。IPv6アドレスは、ネットワークバイトの順序で保存されます。"
    },
    {
      "indent": 3,
      "text": "The structure in6_addr above is usually implemented with an embedded union with extra fields that force the desired alignment level in a manner similar to BSD implementations of \"struct in_addr\". Those additional implementation details are omitted here for simplicity.",
      "ja": "上記の構造IN6_ADDRは通常、「struct in_addr」のBSD実装と同様の方法で、目的のアライメントレベルを強制する追加フィールドを備えた組み込みの結合で実装されます。これらの追加の実装の詳細は、簡単にするために省略されています。"
    },
    {
      "indent": 3,
      "text": "An example is as follows:",
      "ja": "例は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "struct in6_addr {\n     union {\n         uint8_t  _S6_u8[16];\n         uint32_t _S6_u32[4];\n         uint64_t _S6_u64[2];\n     } _S6_un;\n};\n#define s6_addr _S6_un._S6_u8",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3 Socket Address Structure for 4.3BSD-Based Systems",
      "section_title": true,
      "ja": "3.3 4.3bsdベースのシステムのソケットアドレス構造"
    },
    {
      "indent": 3,
      "text": "In the socket interface, a different protocol-specific data structure is defined to carry the addresses for each protocol suite. Each protocol-specific data structure is designed so it can be cast into a protocol-independent data structure -- the \"sockaddr\" structure. Each has a \"family\" field that overlays the \"sa_family\" of the sockaddr data structure. This field identifies the type of the data structure.",
      "ja": "ソケットインターフェイスでは、各プロトコルスイートのアドレスを携帯するために、異なるプロトコル固有のデータ構造が定義されています。各プロトコル固有のデータ構造は、プロトコルに依存しないデータ構造（「Sockaddr」構造）にキャストできるように設計されています。それぞれには、Sockaddrデータ構造の「Sa_family」に重なる「ファミリー」分野があります。このフィールドは、データ構造のタイプを識別します。"
    },
    {
      "indent": 3,
      "text": "The sockaddr_in structure is the protocol-specific address data structure for IPv4. It is used to pass addresses between applications and the system in the socket functions. The following sockaddr_in6 structure holds IPv6 addresses and is defined as a result of including the <netinet/in.h> header:",
      "ja": "Sockaddr_in構造は、IPv4のプロトコル固有のアドレスデータ構造です。ソケット機能内のアプリケーションとシステム間のアドレスを渡すために使用されます。次のsockaddr_in6構造にはIPv6アドレスが保持され、<netinet/in.h>ヘッダーを含めた結果として定義されます。"
    },
    {
      "indent": 0,
      "text": "struct sockaddr_in6 {\n    sa_family_t     sin6_family;    /* AF_INET6 */\n    in_port_t       sin6_port;      /* transport layer port # */\n    uint32_t        sin6_flowinfo;  /* IPv6 flow information */\n    struct in6_addr sin6_addr;      /* IPv6 address */\n    uint32_t        sin6_scope_id;  /* set of interfaces for a scope */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This structure is designed to be compatible with the sockaddr data structure used in the 4.3BSD release.",
      "ja": "この構造は、4.3bsdリリースで使用されるSockaddrデータ構造と互換性があるように設計されています。"
    },
    {
      "indent": 3,
      "text": "The sin6_family field identifies this as a sockaddr_in6 structure. This field overlays the sa_family field when the buffer is cast to a sockaddr data structure. The value of this field must be AF_INET6.",
      "ja": "sin6_familyフィールドは、これをsockaddr_in6構造として識別します。このフィールドは、バッファがSockadDRデータ構造にキャストされると、SA_Familyフィールドに重なります。このフィールドの値はAF_INET6でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The sin6_port field contains the 16-bit UDP or TCP port number. This field is used in the same way as the sin_port field of the sockaddr_in structure. The port number is stored in network byte order.",
      "ja": "SIN6_PORTフィールドには、16ビットUDPまたはTCPポート番号が含まれています。このフィールドは、sockaddr_in構造のsin_portフィールドと同じ方法で使用されます。ポート番号は、ネットワークバイトの順序で保存されます。"
    },
    {
      "indent": 3,
      "text": "The sin6_flowinfo field is a 32-bit field intended to contain flow-related information. The exact way this field is mapped to or from a packet is not currently specified. Until such time as its use is specified, applications should set this field to zero when constructing a sockaddr_in6, and ignore this field in a sockaddr_in6 structure constructed by the system.",
      "ja": "SIN6_FLOWINFOフィールドは、フロー関連の情報を含めることを目的とした32ビットフィールドです。このフィールドがパケットとの間でマッピングされる正確な方法は現在指定されていません。使用が指定されるまで、Sockaddr_in6を構築するときにアプリケーションがこのフィールドをゼロに設定し、システムによって構築されたSockaddr_in6構造でこのフィールドを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "The sin6_addr field is a single in6_addr structure (defined in the previous section). This field holds one 128-bit IPv6 address. The address is stored in network byte order.",
      "ja": "SIN6_ADDRフィールドは、単一のIN6_ADDR構造です（前のセクションで定義されています）。このフィールドには、128ビットIPv6アドレスが1つあります。アドレスはネットワークバイトの順序で保存されます。"
    },
    {
      "indent": 3,
      "text": "The ordering of elements in this structure is specifically designed so that when sin6_addr field is aligned on a 64-bit boundary, the start of the structure will also be aligned on a 64-bit boundary. This is done for optimum performance on 64-bit architectures.",
      "ja": "この構造内の要素の順序付けは、SIN6_ADDRフィールドが64ビット境界に整列されると、構造の開始が64ビット境界に並べられるように特異的に設計されています。これは、64ビットアーキテクチャで最適なパフォーマンスのために行われます。"
    },
    {
      "indent": 3,
      "text": "The sin6_scope_id field is a 32-bit integer that identifies a set of interfaces as appropriate for the scope [2] of the address carried in the sin6_addr field. The mapping of sin6_scope_id to an interface or set of interfaces is left to implementation and future specifications on the subject of scoped addresses.",
      "ja": "SIN6_SCOPE_IDフィールドは、SIN6_ADDRフィールドに掲載されたアドレスのスコープ[2]に適しているように、インターフェイスのセットを識別する32ビット整数です。インターフェイスまたはインターフェイスのセットへのSIN6_SCOPE_IDのマッピングは、スコープアドレスの主題に関する実装および将来の仕様に任されています。"
    },
    {
      "indent": 3,
      "text": "Notice that the sockaddr_in6 structure will normally be larger than the generic sockaddr structure. On many existing implementations the sizeof(struct sockaddr_in) equals sizeof(struct sockaddr), with both being 16 bytes. Any existing code that makes this assumption needs to be examined carefully when converting to IPv6.",
      "ja": "Sockaddr_in6構造は通常、一般的なSockaddr構造よりも大きくなることに注意してください。多くの既存の実装では、sizeof（struct sockaddr_in）はsizeof（struct sockaddr）に等しく、どちらも16バイトです。この仮定を作成する既存のコードは、IPv6に変換する際に慎重に調べる必要があります。"
    },
    {
      "indent": 0,
      "text": "3.4 Socket Address Structure for 4.4BSD-Based Systems",
      "section_title": true,
      "ja": "3.4 4.4BSDベースのシステムのソケットアドレス構造"
    },
    {
      "indent": 3,
      "text": "The 4.4BSD release includes a small, but incompatible change to the socket interface. The \"sa_family\" field of the sockaddr data structure was changed from a 16-bit value to an 8-bit value, and the space saved used to hold a length field, named \"sa_len\". The sockaddr_in6 data structure given in the previous section cannot be correctly cast into the newer sockaddr data structure. For this reason, the following alternative IPv6 address data structure is provided to be used on systems based on 4.4BSD. It is defined as a result of including the <netinet/in.h> header.",
      "ja": "4.4BSDリリースには、ソケットインターフェイスへの小さなが互換性のない変更が含まれています。Sockaddrデータ構造の「SA_Family」フィールドは、16ビット値から8ビット値に変更され、「SA_LEN」という名前の長さフィールドを保持するために使用されるスペースが節約されました。前のセクションに記載されているSockaddr_in6データ構造は、新しいSockaddrデータ構造に正しくキャストすることはできません。このため、4.4BSDに基づいてシステムで使用するために、次の代替IPv6アドレスデータ構造が提供されます。<netinet/in.h>ヘッダーを含めた結果として定義されます。"
    },
    {
      "indent": 0,
      "text": "struct sockaddr_in6 {\n    uint8_t         sin6_len;       /* length of this struct */\n    sa_family_t     sin6_family;    /* AF_INET6 */\n    in_port_t       sin6_port;      /* transport layer port # */\n    uint32_t        sin6_flowinfo;  /* IPv6 flow information */\n    struct in6_addr sin6_addr;      /* IPv6 address */\n    uint32_t        sin6_scope_id;  /* set of interfaces for a scope */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The only differences between this data structure and the 4.3BSD variant are the inclusion of the length field, and the change of the family field to a 8-bit data type. The definitions of all the other fields are identical to the structure defined in the previous section.",
      "ja": "このデータ構造と4.3BSDバリアントの唯一の違いは、長さフィールドを含めること、およびファミリーフィールドの8ビットデータ型への変更です。他のすべてのフィールドの定義は、前のセクションで定義された構造と同一です。"
    },
    {
      "indent": 3,
      "text": "Systems that provide this version of the sockaddr_in6 data structure must also declare SIN6_LEN as a result of including the <netinet/in.h> header. This macro allows applications to determine whether they are being built on a system that supports the 4.3BSD or 4.4BSD variants of the data structure.",
      "ja": "sockaddr_in6データ構造のこのバージョンを提供するシステムは、<netinet/in.h>ヘッダーを含めた結果としてsin6_lenを宣言する必要があります。このマクロにより、アプリケーションは、データ構造の4.3bsdまたは4.4bsdのバリアントをサポートするシステム上に構築されているかどうかを判断できます。"
    },
    {
      "indent": 0,
      "text": "3.5 The Socket Functions",
      "section_title": true,
      "ja": "3.5 ソケット機能"
    },
    {
      "indent": 3,
      "text": "Applications call the socket() function to create a socket descriptor that represents a communication endpoint. The arguments to the socket() function tell the system which protocol to use, and what format address structure will be used in subsequent functions. For example, to create an IPv4/TCP socket, applications make the call:",
      "ja": "アプリケーションはSocket（）関数を呼び出して、通信エンドポイントを表すソケット記述子を作成します。Socket（）関数の引数は、使用するプロトコルと、後続の関数で使用されるどの形式アドレス構造をシステムに伝えます。たとえば、IPv4/TCPソケットを作成するには、アプリケーションが呼び出します。"
    },
    {
      "indent": 6,
      "text": "s = socket(AF_INET, SOCK_STREAM, 0);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "To create an IPv4/UDP socket, applications make the call:",
      "ja": "IPv4/UDPソケットを作成するには、アプリケーションが呼び出します。"
    },
    {
      "indent": 6,
      "text": "s = socket(AF_INET, SOCK_DGRAM, 0);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Applications may create IPv6/TCP and IPv6/UDP sockets (which may also handle IPv4 communication as described in section 3.7) by simply using the constant AF_INET6 instead of AF_INET in the first argument. For example, to create an IPv6/TCP socket, applications make the call:",
      "ja": "アプリケーションは、最初の引数でAF_INETの代わりに定数AF_INET6を使用するだけで、IPv6/TCPおよびIPv6/UDPソケット（セクション3.7で説明されているようにIPv4通信も処理する場合があります）を作成する場合があります。たとえば、IPv6/TCPソケットを作成するには、アプリケーションが呼び出します。"
    },
    {
      "indent": 6,
      "text": "s = socket(AF_INET6, SOCK_STREAM, 0);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "To create an IPv6/UDP socket, applications make the call:",
      "ja": "IPv6/UDPソケットを作成するには、アプリケーションが呼び出します。"
    },
    {
      "indent": 6,
      "text": "s = socket(AF_INET6, SOCK_DGRAM, 0);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Once the application has created a AF_INET6 socket, it must use the sockaddr_in6 address structure when passing addresses in to the system. The functions that the application uses to pass addresses into the system are:",
      "ja": "アプリケーションがAF_INET6ソケットを作成したら、アドレスをシステムに渡すときにSockaddr_in6アドレス構造を使用する必要があります。アプリケーションがアドレスをシステムに渡すために使用する機能は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "bind() connect() sendmsg() sendto()",
      "ja": "bind（）connect（）sendmsg（）sendto（）"
    },
    {
      "indent": 3,
      "text": "The system will use the sockaddr_in6 address structure to return addresses to applications that are using AF_INET6 sockets. The functions that return an address from the system to an application are:",
      "ja": "システムは、sockaddr_in6アドレス構造を使用して、AF_INET6ソケットを使用しているアプリケーションにアドレスを返します。システムからアプリケーションにアドレスを返す機能は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "accept() recvfrom() recvmsg() getpeername() getsockname()",
      "ja": "Accept（）recvfrom（）recvmsg（）getPeername（）getSockName（）"
    },
    {
      "indent": 3,
      "text": "No changes to the syntax of the socket functions are needed to support IPv6, since all of the \"address carrying\" functions use an opaque address pointer, and carry an address length as a function argument.",
      "ja": "すべての「アドレスを伝える」関数のすべてが不透明なアドレスポインターを使用し、関数引数としてアドレス長を運ぶため、IPv6をサポートするためにソケット関数の構文に変更は必要ありません。"
    },
    {
      "indent": 0,
      "text": "3.6 Compatibility with IPv4 Applications",
      "section_title": true,
      "ja": "3.6 IPv4アプリケーションとの互換性"
    },
    {
      "indent": 3,
      "text": "In order to support the large base of applications using the original API, system implementations must provide complete source and binary compatibility with the original API. This means that systems must continue to support AF_INET sockets and the sockaddr_in address structure. Applications must be able to create IPv4/TCP and IPv4/UDP sockets using the AF_INET constant in the socket() function, as described in the previous section. Applications should be able to hold a combination of IPv4/TCP, IPv4/UDP, IPv6/TCP and IPv6/UDP sockets simultaneously within the same process.",
      "ja": "元のAPIを使用してアプリケーションの大規模なベースをサポートするために、システムの実装は、元のAPIとの完全なソースとバイナリの互換性を提供する必要があります。これは、システムがaf_inetソケットとsockaddr_inアドレス構造を引き続きサポートする必要があることを意味します。前のセクションで説明したように、アプリケーションはSocket（）関数のAF_INET定数を使用してIPv4/TCPおよびIPv4/UDPソケットを作成できる必要があります。アプリケーションは、同じプロセス内でIPv4/TCP、IPv4/UDP、IPv6/TCP、IPv6/UDPソケットの組み合わせを同時に保持できる必要があります。"
    },
    {
      "indent": 3,
      "text": "Applications using the original API should continue to operate as they did on systems supporting only IPv4. That is, they should continue to interoperate with IPv4 nodes.",
      "ja": "元のAPIを使用したアプリケーションは、IPv4のみをサポートするシステムで行ったように、引き続き動作します。つまり、IPv4ノードと相互運用し続ける必要があります。"
    },
    {
      "indent": 0,
      "text": "3.7 Compatibility with IPv4 Nodes",
      "section_title": true,
      "ja": "3.7 IPv4ノードとの互換性"
    },
    {
      "indent": 3,
      "text": "The API also provides a different type of compatibility: the ability for IPv6 applications to interoperate with IPv4 applications. This feature uses the IPv4-mapped IPv6 address format defined in the IPv6 addressing architecture specification [2]. This address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address. The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF. IPv4-mapped addresses are written as follows:",
      "ja": "APIは、異なるタイプの互換性も提供します。IPv6アプリケーションがIPv4アプリケーションと相互操作する機能です。この機能では、IPv6アドレス指定のアーキテクチャ仕様[2]で定義されているIPv4-Mapped IPv6アドレス形式を使用します。このアドレス形式により、IPv4ノードのIPv4アドレスをIPv6アドレスとして表現できます。IPv4アドレスは、IPv6アドレスの低次の32ビットにエンコードされ、高次の96ビットは固定プレフィックス0：0：0：0：0：FFFFを保持します。IPv4マップアドレスは次のように記述されます。"
    },
    {
      "indent": 6,
      "text": "::FFFF:<IPv4-address>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "These addresses can be generated automatically by the getaddrinfo() function, as described in Section 6.1.",
      "ja": "これらのアドレスは、セクション6.1で説明されているように、getaddrinfo（）関数によって自動的に生成できます。"
    },
    {
      "indent": 3,
      "text": "Applications may use AF_INET6 sockets to open TCP connections to IPv4 nodes, or send UDP packets to IPv4 nodes, by simply encoding the destination's IPv4 address as an IPv4-mapped IPv6 address, and passing that address, within a sockaddr_in6 structure, in the connect() or sendto() call. When applications use AF_INET6 sockets to accept TCP connections from IPv4 nodes, or receive UDP packets from IPv4 nodes, the system returns the peer's address to the application in the accept(), recvfrom(), or getpeername() call using a sockaddr_in6 structure encoded this way.",
      "ja": "アプリケーションは、AF_INET6ソケットを使用して、IPv4ノードへのTCP接続を開き、IPv4ノードにUDPパケットを送信します。これは、宛先のIPv4アドレスをIPv4-Mapped IPv6アドレスとしてエンコードし、接続内のSockaddr_in6構造内でそのアドレスを渡すだけで、そのアドレスを渡すことができます（）またはsendto（）call。アプリケーションがAF_INET6ソケットを使用してIPv4ノードからTCP接続を受け入れるか、IPv4ノードからUDPパケットを受信した場合、システムは、sockaddr_in6構造を使用してcompead（）、recvfrom（）、またはgetPeername（）コールでピアのアドレスをアプリケーションに返します。こちらです。"
    },
    {
      "indent": 3,
      "text": "Few applications will likely need to know which type of node they are interoperating with. However, for those applications that do need to know, the IN6_IS_ADDR_V4MAPPED() macro, defined in Section 6.4, is provided.",
      "ja": "どのタイプのノードが相互運用しているかを知る必要があるアプリケーションはほとんどありません。ただし、知る必要があるアプリケーションについては、セクション6.4で定義されているIN6_IS_ADDR_V4MAPPENT（）マクロが提供されます。"
    },
    {
      "indent": 0,
      "text": "3.8 IPv6 Wildcard Address",
      "section_title": true,
      "ja": "3.8 IPv6ワイルドカードアドレス"
    },
    {
      "indent": 3,
      "text": "While the bind() function allows applications to select the source IP address of UDP packets and TCP connections, applications often want the system to select the source address for them. With IPv4, one specifies the address as the symbolic constant INADDR_ANY (called the \"wildcard\" address) in the bind() call, or simply omits the bind() entirely.",
      "ja": "BIND（）関数により、アプリケーションはUDPパケットとTCP接続のソースIPアドレスを選択できますが、アプリケーションはシステムのソースアドレスを選択することを望んでいます。IPv4を使用すると、bind（）呼び出しのシンボリック定数inaddr_any（「wildcard」アドレスと呼ばれる）としてアドレスを指定するか、単にbind（）を完全に省略します。"
    },
    {
      "indent": 3,
      "text": "Since the IPv6 address type is a structure (struct in6_addr), a symbolic constant can be used to initialize an IPv6 address variable, but cannot be used in an assignment. Therefore systems provide the IPv6 wildcard address in two forms.",
      "ja": "IPv6アドレスタイプは構造（struct in6_addr）であるため、シンボリック定数を使用してIPv6アドレス変数を初期化できますが、割り当てでは使用できません。したがって、システムは2つの形式でIPv6ワイルドカードアドレスを提供します。"
    },
    {
      "indent": 3,
      "text": "The first version is a global variable named \"in6addr_any\" that is an in6_addr structure. The extern declaration for this variable is defined in <netinet/in.h>:",
      "ja": "最初のバージョンは、in6_addr構造である「in6addr_any」という名前のグローバル変数です。この変数のextern宣言は、<netinet/in.h>で定義されています。"
    },
    {
      "indent": 6,
      "text": "extern const struct in6_addr in6addr_any;",
      "ja": "extern const struct in6_addr in6addr_any;"
    },
    {
      "indent": 3,
      "text": "Applications use in6addr_any similarly to the way they use INADDR_ANY in IPv4. For example, to bind a socket to port number 23, but let the system select the source address, an application could use the following code:",
      "ja": "アプリケーションは、IPv4でINADDR_ANYを使用する方法と同様に、IN6ADDR_ANYを使用します。たとえば、ソケットをポート番号23にバインドするには、システムにソースアドレスを選択できるようにするため、アプリケーションは次のコードを使用できます。"
    },
    {
      "indent": 6,
      "text": "struct sockaddr_in6 sin6;\n . . .\nsin6.sin6_family = AF_INET6;\nsin6.sin6_flowinfo = 0;\nsin6.sin6_port = htons(23);\nsin6.sin6_addr = in6addr_any;  /* structure assignment */\n . . .\nif (bind(s, (struct sockaddr *) &sin6, sizeof(sin6)) == -1)\n        . . .",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The other version is a symbolic constant named IN6ADDR_ANY_INIT and is defined in <netinet/in.h>. This constant can be used to initialize an in6_addr structure:",
      "ja": "他のバージョンは、in6addr_any_initという名前の象徴的な定数であり、<netinet/in.h>で定義されています。この定数は、IN6_ADDR構造を初期化するために使用できます。"
    },
    {
      "indent": 6,
      "text": "struct in6_addr anyaddr = IN6ADDR_ANY_INIT;",
      "ja": "struct in6_addr anyaddr = in6addr_any_init;"
    },
    {
      "indent": 3,
      "text": "Note that this constant can be used ONLY at declaration time. It can not be used to assign a previously declared in6_addr structure. For example, the following code will not work:",
      "ja": "この定数は、宣言時にのみ使用できることに注意してください。以前に宣言されたIN6_ADDR構造を割り当てるために使用できません。たとえば、次のコードは機能しません。"
    },
    {
      "indent": 6,
      "text": "/* This is the WRONG way to assign an unspecified address */\nstruct sockaddr_in6 sin6;\n . . .\nsin6.sin6_addr = IN6ADDR_ANY_INIT; /* will NOT compile */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Be aware that the IPv4 INADDR_xxx constants are all defined in host byte order but the IPv6 IN6ADDR_xxx constants and the IPv6 in6addr_xxx externals are defined in network byte order.",
      "ja": "IPv4 INADDR_XXX定数はすべてホストバイトの順序で定義されているが、IPv6 IN6ADDR_XXX定数とIPv6 IN6ADDR_XXX外部はネットワークバイトの順序で定義されていることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.9 IPv6 Loopback Address",
      "section_title": true,
      "ja": "3.9 IPv6ループバックアドレス"
    },
    {
      "indent": 3,
      "text": "Applications may need to send UDP packets to, or originate TCP connections to, services residing on the local node. In IPv4, they can do this by using the constant IPv4 address INADDR_LOOPBACK in their connect(), sendto(), or sendmsg() call.",
      "ja": "アプリケーションは、ローカルノードに存在するサービスにUDPパケットを送信、またはTCP接続を送信する必要がある場合があります。IPv4では、connect（）、sendto（）、またはsendmsg（）callで定数IPv4アドレスinaddr_loopbackを使用してこれを行うことができます。"
    },
    {
      "indent": 3,
      "text": "IPv6 also provides a loopback address to contact local TCP and UDP services. Like the unspecified address, the IPv6 loopback address is provided in two forms -- a global variable and a symbolic constant.",
      "ja": "IPv6は、ローカルTCPおよびUDPサービスに連絡するためのループバックアドレスも提供します。不特定のアドレスと同様に、IPv6ループバックアドレスは、グローバル変数とシンボリック定数の2つの形式で提供されます。"
    },
    {
      "indent": 3,
      "text": "The global variable is an in6_addr structure named \"in6addr_loopback.\" The extern declaration for this variable is defined in <netinet/in.h>:",
      "ja": "グローバル変数は、「in6addr_loopback」という名前のIN6_ADDR構造です。この変数のextern宣言は、<netinet/in.h>で定義されています。"
    },
    {
      "indent": 6,
      "text": "extern const struct in6_addr in6addr_loopback;",
      "ja": "extern const struct in6_addr in6addr_loopback;"
    },
    {
      "indent": 3,
      "text": "Applications use in6addr_loopback as they would use INADDR_LOOPBACK in IPv4 applications (but beware of the byte ordering difference mentioned at the end of the previous section). For example, to open a TCP connection to the local telnet server, an application could use the following code:",
      "ja": "アプリケーションは、IN6ADDR_LOOPBACKを使用して、IPv4アプリケーションでINADDR_Loopbackを使用します（ただし、前のセクションの最後に記載されているバイトの順序差に注意してください）。たとえば、ローカルTelnetサーバーへのTCP接続を開くには、アプリケーションが次のコードを使用できます。"
    },
    {
      "indent": 3,
      "text": "struct sockaddr_in6 sin6;\n . . .\nsin6.sin6_family = AF_INET6;\nsin6.sin6_flowinfo = 0;\nsin6.sin6_port = htons(23);\nsin6.sin6_addr = in6addr_loopback;  /* structure assignment */\n . . .\nif (connect(s, (struct sockaddr *) &sin6, sizeof(sin6)) == -1)\n        . . .",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The symbolic constant is named IN6ADDR_LOOPBACK_INIT and is defined in <netinet/in.h>. It can be used at declaration time ONLY; for example:",
      "ja": "シンボリック定数はin6addr_loopback_initという名前で、<netinet/in.h>で定義されています。宣言時間のみで使用できます。例えば："
    },
    {
      "indent": 6,
      "text": "struct in6_addr loopbackaddr = IN6ADDR_LOOPBACK_INIT;",
      "ja": "struct in6_addr loopbackaddr = in6addr_loopback_init;"
    },
    {
      "indent": 3,
      "text": "Like IN6ADDR_ANY_INIT, this constant cannot be used in an assignment to a previously declared IPv6 address variable.",
      "ja": "IN6ADDR_ANY_INITと同様に、この定数は、以前に宣言されたIPv6アドレス変数への割り当てで使用することはできません。"
    },
    {
      "indent": 0,
      "text": "3.10 Portability Additions",
      "section_title": true,
      "ja": "3.10 移植性の追加"
    },
    {
      "indent": 3,
      "text": "One simple addition to the sockets API that can help application writers is the \"struct sockaddr_storage\". This data structure can simplify writing code that is portable across multiple address families and platforms. This data structure is designed with the following goals.",
      "ja": "アプリケーションライターに役立つソケットAPIに追加された1つの単純な追加は、「struct sockaddr_storage」です。このデータ構造は、複数のアドレスファミリやプラットフォームにわたって移植可能な書き込みコードを簡素化できます。このデータ構造は、次の目標で設計されています。"
    },
    {
      "indent": 3,
      "text": "- Large enough to accommodate all supported protocol-specific address structures.",
      "ja": "- サポートされているすべてのプロトコル固有のアドレス構造に対応するのに十分な大きさ。"
    },
    {
      "indent": 3,
      "text": "- Aligned at an appropriate boundary so that pointers to it can be cast as pointers to protocol specific address structures and used to access the fields of those structures without alignment problems.",
      "ja": "- 適切な境界に合わせて、それへのポインターをプロトコル固有のアドレス構造のポインターとしてキャストし、アライメントの問題なしにそれらの構造のフィールドにアクセスするために使用できます。"
    },
    {
      "indent": 3,
      "text": "The sockaddr_storage structure contains field ss_family which is of type sa_family_t. When a sockaddr_storage structure is cast to a sockaddr structure, the ss_family field of the sockaddr_storage structure maps onto the sa_family field of the sockaddr structure. When a sockaddr_storage structure is cast as a protocol specific address structure, the ss_family field maps onto a field of that structure that is of type sa_family_t and that identifies the protocol's address family.",
      "ja": "sockaddr_storage構造には、sa_family_tのタイプのフィールドSS_familyが含まれています。Sockaddr_storage構造がSockaddr構造にキャストされると、Sockaddr_storage構造のSS_Familyフィールドは、SOCKADDR構造のSA_Familyフィールドにマップします。Sockaddr_storage構造がプロトコル固有のアドレス構造としてキャストされると、SS_Familyフィールドは、SA_FAMILY_Tのタイプであり、プロトコルのアドレスファミリを識別するその構造のフィールドにマップします。"
    },
    {
      "indent": 3,
      "text": "An example implementation design of such a data structure would be as follows.",
      "ja": "このようなデータ構造の実装設計の例は次のとおりです。"
    },
    {
      "indent": 0,
      "text": "/*\n * Desired design of maximum size and alignment\n */\n#define _SS_MAXSIZE    128  /* Implementation specific max size */\n#define _SS_ALIGNSIZE  (sizeof (int64_t))\n                         /* Implementation specific desired alignment */\n/*\n * Definitions used for sockaddr_storage structure paddings design.\n */\n#define _SS_PAD1SIZE   (_SS_ALIGNSIZE - sizeof (sa_family_t))\n#define _SS_PAD2SIZE   (_SS_MAXSIZE - (sizeof (sa_family_t) +\n                              _SS_PAD1SIZE + _SS_ALIGNSIZE))\nstruct sockaddr_storage {\n    sa_family_t  ss_family;     /* address family */\n    /* Following fields are implementation specific */\n    char      __ss_pad1[_SS_PAD1SIZE];\n              /* 6 byte pad, this is to make implementation\n              /* specific pad up to alignment field that */\n              /* follows explicit in the data structure */\n    int64_t   __ss_align;     /* field to force desired structure */\n               /* storage alignment */\n    char      __ss_pad2[_SS_PAD2SIZE];\n              /* 112 byte pad to achieve desired size, */\n              /* _SS_MAXSIZE value minus size of ss_family */\n              /* __ss_pad1, __ss_align fields is 112 */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The above example implementation illustrates a data structure which will align on a 64-bit boundary. An implementation-specific field \"__ss_align\" along with \"__ss_pad1\" is used to force a 64-bit alignment which covers proper alignment good enough for the needs of sockaddr_in6 (IPv6), sockaddr_in (IPv4) address data structures. The size of padding field __ss_pad1 depends on the chosen alignment boundary. The size of padding field __ss_pad2 depends on the value of overall size chosen for the total size of the structure. This size and alignment are represented in the above example by implementation specific (not required) constants _SS_MAXSIZE (chosen value 128) and _SS_ALIGNSIZE (with chosen value 8). Constants _SS_PAD1SIZE (derived value 6) and _SS_PAD2SIZE (derived value 112) are also for illustration and not required. The derived values assume sa_family_t is 2 bytes. The implementation specific definitions and structure field names above start with an underscore to denote implementation private namespace. Portable code is not expected to access or reference those fields or constants.",
      "ja": "上記の例の実装は、64ビットの境界に並ぶデータ構造を示しています。「__SS_PAD1」とともに実装固有のフィールド「__SS_ALIGN」を使用して、SOCKADDR_IN6（IPv6）、Sockaddr_in（IPV4）の対処データ構造のニーズに合わせて適切なアライメントをカバーする64ビットアライメントを強制します。パディングフィールドのサイズ__SS_PAD1は、選択したアライメント境界に依存します。パディングフィールドのサイズ__SS_PAD2は、構造の総サイズに対して選択された全体のサイズの値に依存します。このサイズとアラインメントは、上記の例で、実装固有の（不要）定数_SS_MAXSIZE（選択された値128）および_SS_AlignSize（選択された値8を含む）で表されます。定数_SS_PAD1SIZE（派生値6）および_SS_PAD2SIZE（派生値112）もイラスト用であり、不要です。導出された値は、SA_FAMILY_Tが2バイトであると仮定します。上記の実装固有の定義と構造フィールド名は、実装のプライベートネームスペースを示すアンダースコアから始まります。ポータブルコードは、これらのフィールドまたは定数にアクセスまたは参照することは期待されていません。"
    },
    {
      "indent": 3,
      "text": "On implementations where the sockaddr data structure includes a \"sa_len\" field this data structure would look like this:",
      "ja": "Sockaddrデータ構造に「SA_LEN」フィールドが含まれる実装では、このデータ構造は次のようになります。"
    },
    {
      "indent": 0,
      "text": "/*\n * Definitions used for sockaddr_storage structure paddings design.\n */\n#define _SS_PAD1SIZE (_SS_ALIGNSIZE -\n                            (sizeof (uint8_t) + sizeof (sa_family_t))\n#define _SS_PAD2SIZE (_SS_MAXSIZE -\n                            (sizeof (uint8_t) + sizeof (sa_family_t) +\n                             _SS_PAD1SIZE + _SS_ALIGNSIZE))\nstruct sockaddr_storage {\n    uint8_t      ss_len;        /* address length */\n    sa_family_t  ss_family;     /* address family */\n    /* Following fields are implementation specific */\n    char         __ss_pad1[_SS_PAD1SIZE];\n                  /* 6 byte pad, this is to make implementation\n                  /* specific pad up to alignment field that */\n                  /* follows explicit in the data structure */\n    int64_t      __ss_align;  /* field to force desired structure */\n                  /* storage alignment */\n    char         __ss_pad2[_SS_PAD2SIZE];\n                  /* 112 byte pad to achieve desired size, */\n                  /* _SS_MAXSIZE value minus size of ss_len, */\n                  /* __ss_family, __ss_pad1, __ss_align fields is 112 */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4. Interface Identification",
      "section_title": true,
      "ja": "4. インターフェイス識別"
    },
    {
      "indent": 3,
      "text": "This API uses an interface index (a small positive integer) to identify the local interface on which a multicast group is joined (Section 5.2). Additionally, the advanced API [4] uses these same interface indexes to identify the interface on which a datagram is received, or to specify the interface on which a datagram is to be sent.",
      "ja": "このAPIは、インターフェイスインデックス（小さな正の整数）を使用して、マルチキャストグループが結合されているローカルインターフェイスを識別します（セクション5.2）。さらに、Advanced API [4]は、これらの同じインターフェイスインデックスを使用して、データグラムが受信されるインターフェイスを識別するか、データグラムを送信するインターフェイスを指定します。"
    },
    {
      "indent": 3,
      "text": "Interfaces are normally known by names such as \"le0\", \"sl1\", \"ppp2\", and the like. On Berkeley-derived implementations, when an interface is made known to the system, the kernel assigns a unique positive integer value (called the interface index) to that interface. These are small positive integers that start at 1. (Note that 0 is never used for an interface index.) There may be gaps so that there is no current interface for a particular positive interface index.",
      "ja": "インターフェイスは通常、「LE0」、「SL1」、「PPP2」などの名前で知られています。バークレー由来の実装では、インターフェイスがシステムに知られている場合、カーネルはそのインターフェイスに一意の正の整数値（インターフェイスインデックスと呼ばれる）を割り当てます。これらは、1から始まる小さな正の整数です（0はインターフェイスインデックスに使用されないことに注意してください。）特定のポジティブインターフェイスインデックスの現在のインターフェイスがないようにギャップがある可能性があります。"
    },
    {
      "indent": 3,
      "text": "This API defines two functions that map between an interface name and index, a third function that returns all the interface names and indexes, and a fourth function to return the dynamic memory allocated by the previous function. How these functions are implemented is left up to the implementation. 4.4BSD implementations can implement these functions using the existing sysctl() function with the NET_RT_IFLIST command. Other implementations may wish to use ioctl() for this purpose.",
      "ja": "このAPIは、インターフェイス名とインデックスの間にマッピングされる2つの関数、すべてのインターフェイス名とインデックスを返す3番目の関数、および前の関数によって割り当てられた動的メモリを返す4番目の関数を定義します。これらの機能がどのように実装されるかは、実装に任されています。4.4BSD実装は、net_rt_iflistコマンドを使用して既存のsysctl（）関数を使用してこれらの関数を実装できます。他の実装では、この目的のためにIOCTL（）を使用する場合があります。"
    },
    {
      "indent": 0,
      "text": "4.1 Name-to-Index",
      "section_title": true,
      "ja": "4.1 名前からインデックス"
    },
    {
      "indent": 3,
      "text": "The first function maps an interface name into its corresponding index.",
      "ja": "最初の関数は、インターフェイス名を対応するインデックスにマップします。"
    },
    {
      "indent": 6,
      "text": "#include <net/if.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "unsigned int  if_nametoindex(const char *ifname);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If ifname is the name of an interface, the if_nametoindex() function shall return the interface index corresponding to name ifname; otherwise, it shall return zero. No errors are defined.",
      "ja": "IFNameがインターフェイスの名前である場合、IF_NAMETOINDEX（）関数は、名前IFNameに対応するインターフェイスインデックスを返すものとします。それ以外の場合は、ゼロを返します。エラーは定義されていません。"
    },
    {
      "indent": 0,
      "text": "4.2 Index-to-Name",
      "section_title": true,
      "ja": "4.2 インデックスから名前"
    },
    {
      "indent": 3,
      "text": "The second function maps an interface index into its corresponding name.",
      "ja": "2番目の関数は、インターフェイスインデックスを対応する名前にマッピングします。"
    },
    {
      "indent": 6,
      "text": "#include <net/if.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "char  *if_indextoname(unsigned int ifindex, char *ifname);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When this function is called, the ifname argument shall point to a buffer of at least IF_NAMESIZE bytes. The function shall place in this buffer the name of the interface with index ifindex. (IF_NAMESIZE is also defined in <net/if.h> and its value includes a terminating null byte at the end of the interface name.) If ifindex is an interface index, then the function shall return the value supplied in ifname, which points to a buffer now containing the interface name. Otherwise, the function shall return a NULL pointer and set errno to indicate the error. If there is no interface corresponding to the specified index, errno is set to ENXIO. If there was a system error (such as running out of memory), errno would be set to the proper value (e.g., ENOMEM).",
      "ja": "この関数が呼び出される場合、IFName引数は、少なくともif_namesizeバイトのバッファーを指します。この関数は、このバッファ内にインターフェイスの名前をインデックスifindexに配置するものとします。（if_namesizeは<net/if.h>でも定義され、その値にはインターフェイス名の最後に終端nullバイトが含まれます。）ifindexがインターフェイスインデックスである場合、関数はifnameで提供される値を返します。インターフェイス名を含むバッファーに。それ以外の場合、関数はnullポインターを返し、errnoを設定してエラーを示します。指定されたインデックスに対応するインターフェイスがない場合、errnoはenxioに設定されます。システムエラーが発生した場合（メモリの不足など）、Errnoは適切な値（Enomemなど）に設定されます。"
    },
    {
      "indent": 0,
      "text": "4.3 Return All Interface Names and Indexes",
      "section_title": true,
      "ja": "4.3 すべてのインターフェイス名とインデックスを返します"
    },
    {
      "indent": 3,
      "text": "The if_nameindex structure holds the information about a single interface and is defined as a result of including the <net/if.h> header.",
      "ja": "if_nameindex構造は、単一のインターフェイスに関する情報を保持し、<net/if.h>ヘッダーを含めた結果として定義されます。"
    },
    {
      "indent": 3,
      "text": "struct if_nameindex {\n  unsigned int   if_index;  /* 1, 2, ... */\n  char          *if_name;   /* null terminated name: \"le0\", ... */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The final function returns an array of if_nameindex structures, one structure per interface.",
      "ja": "最終関数は、IF_NameIndex構造の配列を返します。これは、インターフェイスごとに1つの構造です。"
    },
    {
      "indent": 6,
      "text": "#include <net/if.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct if_nameindex  *if_nameindex(void);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The end of the array of structures is indicated by a structure with an if_index of 0 and an if_name of NULL. The function returns a NULL pointer upon an error, and would set errno to the appropriate value.",
      "ja": "構造の配列の終了は、0のif_indexとnullのif_nameを持つ構造によって示されます。この関数は、エラー時にnullポインターを返し、errnoを適切な値に設定します。"
    },
    {
      "indent": 3,
      "text": "The memory used for this array of structures along with the interface names pointed to by the if_name members is obtained dynamically. This memory is freed by the next function.",
      "ja": "この一連の構造に使用されるメモリと、IF_NAMEメンバーが指すインターフェイス名は動的に取得されます。このメモリは、次の関数によって解放されます。"
    },
    {
      "indent": 0,
      "text": "4.4 Free Memory",
      "section_title": true,
      "ja": "4.4 無料のメモリ"
    },
    {
      "indent": 3,
      "text": "The following function frees the dynamic memory that was allocated by if_nameindex().",
      "ja": "次の関数は、if_nameindex（）によって割り当てられた動的メモリを解放します。"
    },
    {
      "indent": 6,
      "text": "#include <net/if.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "void  if_freenameindex(struct if_nameindex *ptr);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The ptr argument shall be a pointer that was returned by if_nameindex(). After if_freenameindex() has been called, the application shall not use the array of which ptr is the address.",
      "ja": "PTR引数は、if_nameindex（）によって返されたポインターでなければなりません。IF_FREENAMEINDEX（）が呼び出された後、アプリケーションはPTRがアドレスである配列を使用してはなりません。"
    },
    {
      "indent": 0,
      "text": "5. Socket Options",
      "section_title": true,
      "ja": "5. ソケットオプション"
    },
    {
      "indent": 3,
      "text": "A number of new socket options are defined for IPv6. All of these new options are at the IPPROTO_IPV6 level. That is, the \"level\" parameter in the getsockopt() and setsockopt() calls is IPPROTO_IPV6 when using these options. The constant name prefix IPV6_ is used in all of the new socket options. This serves to clearly identify these options as applying to IPv6.",
      "ja": "IPv6に対しては、多くの新しいソケットオプションが定義されています。これらの新しいオプションはすべて、IPPROTO_IPV6レベルにあります。つまり、これらのオプションを使用する場合、getSockopt（）およびsetSockopt（）呼び出しの「レベル」パラメーターはIPPROTO_IPV6です。定数のプレフィックスIPv6_は、すべての新しいソケットオプションで使用されます。これは、これらのオプションをIPv6に適用することとして明確に識別するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "The declaration for IPPROTO_IPV6, the new IPv6 socket options, and related constants defined in this section are obtained by including the header <netinet/in.h>.",
      "ja": "IPPROTO_IPV6の宣言、新しいIPv6ソケットオプション、およびこのセクションで定義された関連定数は、Header <NetInet/in.h>を含めることで取得されます。"
    },
    {
      "indent": 0,
      "text": "5.1 Unicast Hop Limit",
      "section_title": true,
      "ja": "5.1 ユニキャストホップ制限"
    },
    {
      "indent": 3,
      "text": "A new setsockopt() option controls the hop limit used in outgoing unicast IPv6 packets. The name of this option is IPV6_UNICAST_HOPS, and it is used at the IPPROTO_IPV6 layer. The following example illustrates how it is used:",
      "ja": "新しいsetSockopt（）オプションは、発信ユニキャストIPv6パケットで使用されるホップ制限を制御します。このオプションの名前はIPv6_unicast_hopsで、IPProto_ipv6レイヤーで使用されます。次の例は、それがどのように使用されるかを示しています。"
    },
    {
      "indent": 3,
      "text": "int hoplimit = 10;",
      "ja": "int hoplimit = 10;"
    },
    {
      "indent": 3,
      "text": "if (setsockopt(s, IPPROTO_IPV6, IPV6_UNICAST_HOPS,\n               (char *) &hoplimit, sizeof(hoplimit)) == -1)\n    perror(\"setsockopt IPV6_UNICAST_HOPS\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When the IPV6_UNICAST_HOPS option is set with setsockopt(), the option value given is used as the hop limit for all subsequent unicast packets sent via that socket. If the option is not set, the system selects a default value. The integer hop limit value (called x) is interpreted as follows:",
      "ja": "IPv6_unicast_hopsオプションがsetSockopt（）で設定されている場合、与えられたオプション値は、そのソケットを介して送信されるすべての後続のユニキャストパケットのホップ制限として使用されます。オプションが設定されていない場合、システムはデフォルト値を選択します。整数ホップ制限値（xと呼ばれる）は、次のように解釈されます。"
    },
    {
      "indent": 6,
      "text": "x < -1:        return an error of EINVAL\nx == -1:       use kernel default\n0 <= x <= 255: use x\nx >= 256:      return an error of EINVAL",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The IPV6_UNICAST_HOPS option may be used with getsockopt() to determine the hop limit value that the system will use for subsequent unicast packets sent via that socket. For example:",
      "ja": "IPv6_unicast_hopsオプションは、getSockopt（）で使用して、システムがそのソケットを介して送信される後続のユニキャストパケットに使用するホップ制限値を決定できます。例えば："
    },
    {
      "indent": 6,
      "text": "int  hoplimit;\nsocklen_t  len = sizeof(hoplimit);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "if (getsockopt(s, IPPROTO_IPV6, IPV6_UNICAST_HOPS,\n               (char *) &hoplimit, &len) == -1)\n    perror(\"getsockopt IPV6_UNICAST_HOPS\");\nelse\n    printf(\"Using %d for hop limit.\\n\", hoplimit);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.2 Sending and Receiving Multicast Packets",
      "section_title": true,
      "ja": "5.2 マルチキャストパケットの送信と受信"
    },
    {
      "indent": 3,
      "text": "IPv6 applications may send multicast packets by simply specifying an IPv6 multicast address as the destination address, for example in the destination address argument of the sendto() function.",
      "ja": "IPv6アプリケーションは、IPv6マルチキャストアドレスを宛先アドレスとして指定するだけでマルチキャストパケットを送信する場合があります。たとえば、sendto（）関数の宛先アドレスの引数です。"
    },
    {
      "indent": 3,
      "text": "Three socket options at the IPPROTO_IPV6 layer control some of the parameters for sending multicast packets. Setting these options is not required: applications may send multicast packets without using these options. The setsockopt() options for controlling the sending of multicast packets are summarized below. These three options can also be used with getsockopt().",
      "ja": "IPPROTO_IPV6レイヤーの3つのソケットオプションは、マルチキャストパケットを送信するためのパラメーターの一部を制御します。これらのオプションの設定は必要ありません。アプリケーションは、これらのオプションを使用せずにマルチキャストパケットを送信する場合があります。マルチキャストパケットの送信を制御するためのSetSockopt（）オプションを以下にまとめます。これらの3つのオプションは、getSockopt（）で使用することもできます。"
    },
    {
      "indent": 6,
      "text": "IPV6_MULTICAST_IF",
      "ja": "ipv6_multicast_if"
    },
    {
      "indent": 9,
      "text": "Set the interface to use for outgoing multicast packets. The argument is the index of the interface to use. If the interface index is specified as zero, the system selects the interface (for example, by looking up the address in a routing table and using the resulting interface).",
      "ja": "発信マルチキャストパケットに使用するインターフェイスを設定します。引数は、使用するインターフェイスのインデックスです。インターフェイスインデックスがゼロとして指定されている場合、システムはインターフェイスを選択します（たとえば、ルーティングテーブルのアドレスを調べて、結果のインターフェイスを使用して）。"
    },
    {
      "indent": 9,
      "text": "Argument type: unsigned int",
      "ja": "引数タイプ：署名されていないint"
    },
    {
      "indent": 6,
      "text": "IPV6_MULTICAST_HOPS",
      "ja": "ipv6_multicast_hops"
    },
    {
      "indent": 9,
      "text": "Set the hop limit to use for outgoing multicast packets. (Note a separate option - IPV6_UNICAST_HOPS - is provided to set the hop limit to use for outgoing unicast packets.)",
      "ja": "発信マルチキャストパケットに使用するホップ制限を設定します。（別のオプションに注意してください-IPv6_unicast_hops-は、発信ユニキャストパケットに使用するホップ制限を設定するために提供されます。）"
    },
    {
      "indent": 9,
      "text": "The interpretation of the argument is the same as for the IPV6_UNICAST_HOPS option:",
      "ja": "引数の解釈は、IPv6_unicast_hopsオプションの場合と同じです。"
    },
    {
      "indent": 12,
      "text": "x < -1:        return an error of EINVAL\nx == -1:       use kernel default\n0 <= x <= 255: use x\nx >= 256:      return an error of EINVAL",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "If IPV6_MULTICAST_HOPS is not set, the default is 1 (same as IPv4 today)",
      "ja": "IPv6_multicast_hopsが設定されていない場合、デフォルトは1です（今日のIPv4と同じ）"
    },
    {
      "indent": 9,
      "text": "Argument type: int",
      "ja": "引数タイプ：int"
    },
    {
      "indent": 6,
      "text": "IPV6_MULTICAST_LOOP",
      "ja": "ipv6_multicast_loop"
    },
    {
      "indent": 9,
      "text": "If a multicast datagram is sent to a group to which the sending host itself belongs (on the outgoing interface), a copy of the datagram is looped back by the IP layer for local delivery if this option is set to 1. If this option is set to 0 a copy is not looped back. Other option values return an error of EINVAL.",
      "ja": "マルチキャストデータグラムが送信ホスト自体が属するグループに送信された場合（発信インターフェイス上）、データグラムのコピーは、このオプションが1に設定されている場合、ローカル配信のためにIPレイヤーによってループされます。0に設定されているコピーがループバックされていません。その他のオプション値は、Einvalのエラーを返します。"
    },
    {
      "indent": 9,
      "text": "If IPV6_MULTICAST_LOOP is not set, the default is 1 (loopback; same as IPv4 today).",
      "ja": "IPv6_multicast_loopが設定されていない場合、デフォルトは1（ループバック、今日のIPv4と同じ）です。"
    },
    {
      "indent": 9,
      "text": "Argument type: unsigned int",
      "ja": "引数タイプ：署名されていないint"
    },
    {
      "indent": 3,
      "text": "The reception of multicast packets is controlled by the two setsockopt() options summarized below. An error of EOPNOTSUPP is returned if these two options are used with getsockopt().",
      "ja": "マルチキャストパケットの受信は、以下にまとめた2つのSetSockopt（）オプションによって制御されます。これらの2つのオプションがgetSockopt（）で使用される場合、eopnotsuppのエラーが返されます。"
    },
    {
      "indent": 6,
      "text": "IPV6_JOIN_GROUP",
      "ja": "ipv6_join_group"
    },
    {
      "indent": 9,
      "text": "Join a multicast group on a specified local interface. If the interface index is specified as 0, the kernel chooses the local interface. For example, some kernels look up the multicast group in the normal IPv6 routing table and use the resulting interface.",
      "ja": "指定されたローカルインターフェイスでマルチキャストグループに参加します。インターフェイスインデックスが0として指定されている場合、カーネルはローカルインターフェイスを選択します。たとえば、一部のカーネルは、通常のIPv6ルーティングテーブルでマルチキャストグループを検索し、結果のインターフェイスを使用します。"
    },
    {
      "indent": 9,
      "text": "Argument type: struct ipv6_mreq",
      "ja": "引数タイプ：struct ipv6_mreq"
    },
    {
      "indent": 6,
      "text": "IPV6_LEAVE_GROUP",
      "ja": "ipv6_leave_group"
    },
    {
      "indent": 9,
      "text": "Leave a multicast group on a specified interface. If the interface index is specified as 0, the system may choose a multicast group membership to drop by matching the multicast address only.",
      "ja": "指定されたインターフェイスにマルチキャストグループを残します。インターフェイスインデックスが0として指定されている場合、システムはマルチキャストアドレスのみを一致させることでドロップするマルチキャストグループメンバーシップを選択できます。"
    },
    {
      "indent": 9,
      "text": "Argument type: struct ipv6_mreq",
      "ja": "引数タイプ：struct ipv6_mreq"
    },
    {
      "indent": 3,
      "text": "The argument type of both of these options is the ipv6_mreq structure, defined as a result of including the <netinet/in.h> header;",
      "ja": "これらの両方のオプションの両方の引数タイプは、<netinet/in.h>ヘッダーを含めた結果として定義されるIPv6_mreq構造です。"
    },
    {
      "indent": 3,
      "text": "struct ipv6_mreq {\n    struct in6_addr ipv6mr_multiaddr; /* IPv6 multicast addr */\n    unsigned int    ipv6mr_interface; /* interface index */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that to receive multicast datagrams a process must join the multicast group to which datagrams will be sent. UDP applications must also bind the UDP port to which datagrams will be sent. Some processes also bind the multicast group address to the socket, in addition to the port, to prevent other datagrams destined to that same port from being delivered to the socket.",
      "ja": "マルチキャストデータグラムを受信するには、プロセスがデータグラムが送信されるマルチキャストグループに参加する必要があることに注意してください。UDPアプリケーションは、データグラムが送信されるUDPポートにもバインドする必要があります。また、一部のプロセスは、ポートに加えて、マルチキャストグループアドレスをポートに加えてソケットに結合し、同じポートに導かれた他のデータグラムがソケットに配信されないようにします。"
    },
    {
      "indent": 0,
      "text": "5.3 IPV6_V6ONLY option for AF_INET6 Sockets",
      "section_title": true,
      "ja": "5.3 AF_INET6ソケットのIPv6_v6onlyオプション"
    },
    {
      "indent": 3,
      "text": "This socket option restricts AF_INET6 sockets to IPv6 communications only. As stated in section <3.7 Compatibility with IPv4 Nodes>, AF_INET6 sockets may be used for both IPv4 and IPv6 communications. Some applications may want to restrict their use of an AF_INET6 socket to IPv6 communications only. For these applications the IPV6_V6ONLY socket option is defined. When this option is turned on, the socket can be used to send and receive IPv6 packets only. This is an IPPROTO_IPV6 level option. This option takes an int value. This is a boolean option. By default this option is turned off.",
      "ja": "このソケットオプションは、AF_INET6ソケットをIPv6通信のみに制限します。IPv4ノード>とのセクション<3.7の互換性>に記載されているように、AF_INET6ソケットは、IPv4通信とIPv6通信の両方に使用できます。一部のアプリケーションでは、AF_INET6ソケットの使用をIPv6通信のみに制限したい場合があります。これらのアプリケーションの場合、IPv6_v6onlyソケットオプションが定義されています。このオプションがオンになっている場合、ソケットを使用してIPv6パケットのみを送信および受信できます。これはIPPROTO_IPV6レベルのオプションです。このオプションにはint値が必要です。これはブールオプションです。デフォルトでは、このオプションはオフになります。"
    },
    {
      "indent": 3,
      "text": "Here is an example of setting this option:",
      "ja": "このオプションを設定する例は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "int on = 1;",
      "ja": "int on = 1;"
    },
    {
      "indent": 6,
      "text": "if (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY,\n               (char *)&on, sizeof(on)) == -1)\n    perror(\"setsockopt IPV6_V6ONLY\");\nelse\n    printf(\"IPV6_V6ONLY set\\n\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note - This option has no effect on the use of IPv4 Mapped addresses which enter a node as a valid IPv6 addresses for IPv6 communications as defined by Stateless IP/ICMP Translation Algorithm (SIIT) [5].",
      "ja": "注 - このオプションは、Stateless IP/ICMP翻訳アルゴリズム（SIIT）[5]で定義されているIPv6通信の有効なIPv6アドレスとしてノードを入力するIPv4マッピングアドレスの使用に影響を与えません。"
    },
    {
      "indent": 3,
      "text": "An example use of this option is to allow two versions of the same server process to run on the same port, one providing service over IPv6, the other providing the same service over IPv4.",
      "ja": "このオプションの使用例は、同じサーバープロセスの2つのバージョンが同じポートで実行できるようにすることです。1つはIPv6を介してサービスを提供し、もう1つはIPv4を介して同じサービスを提供します。"
    },
    {
      "indent": 0,
      "text": "6. Library Functions",
      "section_title": true,
      "ja": "6. ライブラリ関数"
    },
    {
      "indent": 3,
      "text": "New library functions are needed to perform a variety of operations with IPv6 addresses. Functions are needed to lookup IPv6 addresses in the Domain Name System (DNS). Both forward lookup (nodename-to-address translation) and reverse lookup (address-to-nodename translation) need to be supported. Functions are also needed to convert IPv6 addresses between their binary and textual form.",
      "ja": "IPv6アドレスを使用してさまざまな操作を実行するには、新しいライブラリ機能が必要です。ドメイン名システム（DNS）でIPv6アドレスを検索するには、関数が必要です。フォワードルックアップ（Nodename-to-Addressからの翻訳）とリバースルックアップ（アドレス間翻訳）の両方をサポートする必要があります。IPv6アドレスをバイナリ形式とテキスト形式の間で変換するには、関数も必要です。"
    },
    {
      "indent": 3,
      "text": "We note that the two existing functions, gethostbyname() and gethostbyaddr(), are left as-is. New functions are defined to handle both IPv4 and IPv6 addresses.",
      "ja": "既存の2つの関数、gethostbyname（）とgethostbyaddr（）は、そのまま残されていることに注意してください。新しい関数は、IPv4アドレスとIPv6アドレスの両方を処理するために定義されています。"
    },
    {
      "indent": 3,
      "text": "The commonly used function gethostbyname() is inadequate for many applications, first because it provides no way for the caller to specify anything about the types of addresses desired (IPv4 only, IPv6 only, IPv4-mapped IPv6 are OK, etc.), and second because many implementations of this function are not thread safe. RFC 2133 defined a function named gethostbyname2() but this function was also inadequate, first because its use required setting a global option (RES_USE_INET6) when IPv6 addresses were required, and second because a flag argument is needed to provide the caller with additional control over the types of addresses required. The gethostbyname2() function was deprecated in RFC 2553 and is no longer part of the basic API.",
      "ja": "一般的に使用される関数gethostbyname（）は、多くのアプリケーションでは不十分です。まず、発信者が望ましいアドレスの種類について何も指定する方法を提供しないためです（IPv4のみ、IPv6のみ、IPv4-Mapped IPv6は大丈夫です）、および第二に、この関数の多くの実装はスレッド安全ではないためです。RFC 2133はgethostbyname2（）という名前の関数を定義しましたが、この関数も不十分でした。1つ目は、IPv6アドレスが必要なときにグローバルオプション（RES_USE_INET6）を設定する必要があるため、2つ目は、発信者に追加の制御を提供するためにFLAG引数が必要なためです。必要なアドレスの種類。gethostbyname2（）関数はRFC 2553で非推奨され、基本的なAPIの一部ではなくなりました。"
    },
    {
      "indent": 0,
      "text": "6.1 Protocol-Independent Nodename and Service Name Translation",
      "section_title": true,
      "ja": "6.1 プロトコルに依存しないノデナムとサービス名の翻訳"
    },
    {
      "indent": 3,
      "text": "Nodename-to-address translation is done in a protocol-independent fashion using the getaddrinfo() function.",
      "ja": "Nodename-to-Addressからの翻訳は、getaddrinfo（）関数を使用してプロトコルに依存しない方法で行われます。"
    },
    {
      "indent": 0,
      "text": "#include <sys/socket.h>\n#include <netdb.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "int getaddrinfo(const char *nodename, const char *servname,\n                const struct addrinfo *hints, struct addrinfo **res);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "void freeaddrinfo(struct addrinfo *ai);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "struct addrinfo {\n  int     ai_flags;     /* AI_PASSIVE, AI_CANONNAME,\n                           AI_NUMERICHOST, .. */\n  int     ai_family;    /* AF_xxx */\n  int     ai_socktype;  /* SOCK_xxx */\n  int     ai_protocol;  /* 0 or IPPROTO_xxx for IPv4 and IPv6 */\n  socklen_t  ai_addrlen;   /* length of ai_addr */\n  char   *ai_canonname; /* canonical name for nodename */\n  struct sockaddr  *ai_addr; /* binary address */\n  struct addrinfo  *ai_next; /* next structure in linked list */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The getaddrinfo() function translates the name of a service location (for example, a host name) and/or a service name and returns a set of socket addresses and associated information to be used in creating a socket with which to address the specified service.",
      "ja": "getaddrinfo（）関数は、サービスの場所（ホスト名など）および/またはサービス名の名前を翻訳し、指定されたサービスをアドレス指定するソケットの作成に使用するソケットアドレスのセットと関連する情報を返します。"
    },
    {
      "indent": 3,
      "text": "The nodename and servname arguments are either null pointers or pointers to null-terminated strings. One or both of these two arguments must be a non-null pointer.",
      "ja": "nodenameおよびservnameの引数は、nullポインターまたはヌル終端文字列へのポインターのいずれかです。これら2つの引数の1つまたは両方は、非ヌルポインターでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The format of a valid name depends on the address family or families. If a specific family is not given and the name could be interpreted as valid within multiple supported families, the implementation will attempt to resolve the name in all supported families and, in absence of errors, one or more results shall be returned.",
      "ja": "有効な名前の形式は、住所ファミリまたは家族に依存します。特定のファミリが与えられず、名前が複数のサポートされている家族内で有効と解釈される場合、実装はすべてのサポートされている家族の名前を解決しようとし、エラーがない場合、1つ以上の結果が返されるものとします。"
    },
    {
      "indent": 3,
      "text": "If the nodename argument is not null, it can be a descriptive name or can be an address string. If the specified address family is AF_INET, AF_INET6, or AF_UNSPEC, valid descriptive names include host names. If the specified address family is AF_INET or AF_UNSPEC, address strings using Internet standard dot notation as specified in inet_addr() are valid. If the specified address family is AF_INET6 or AF_UNSPEC, standard IPv6 text forms described in inet_pton() are valid.",
      "ja": "nodename引数がnullでない場合、それは説明的な名前であるか、アドレス文字列にすることができます。指定されたアドレスファミリがAF_INET、AF_INET6、またはAF_UNSPECの場合、有効な記述名にはホスト名が含まれます。指定されたアドレスファミリがAF_INETまたはAF_UNSPECの場合、INET_ADDR（）で指定されているようにインターネット標準のDOT表記を使用したアドレス文字列が有効です。指定されたアドレスファミリがAF_INET6またはAF_UNSPECの場合、inet_pton（）で説明されている標準のIPv6テキストフォームが有効です。"
    },
    {
      "indent": 3,
      "text": "If nodename is not null, the requested service location is named by nodename; otherwise, the requested service location is local to the caller.",
      "ja": "nodenameがnullでない場合、要求されたサービスの場所はnodenameによって名前が付けられています。それ以外の場合、要求されたサービスの場所は発信者にローカルです。"
    },
    {
      "indent": 3,
      "text": "If servname is null, the call shall return network-level addresses for the specified nodename. If servname is not null, it is a null-terminated character string identifying the requested service. This can be either a descriptive name or a numeric representation suitable for use with the address family or families. If the specified address family is AF_INET, AF_INET6 or AF_UNSPEC, the service can be specified as a string specifying a decimal port number.",
      "ja": "servnameがnullの場合、呼び出しは指定されたnodenameのネットワークレベルのアドレスを返します。servnameがnullでない場合、それは要求されたサービスを識別するヌル終端文字列です。これは、説明的な名前または住所ファミリまたは家族での使用に適した数値表現のいずれかです。指定されたアドレスファミリがAF_INET、AF_INET6、またはAF_UNSPECである場合、サービスは小数ポート番号を指定する文字列として指定できます。"
    },
    {
      "indent": 3,
      "text": "If the argument hints is not null, it refers to a structure containing input values that may direct the operation by providing options and by limiting the returned information to a specific socket type, address family and/or protocol. In this hints structure every member other than ai_flags, ai_family, ai_socktype and ai_protocol shall be set to zero or a null pointer. A value of AF_UNSPEC for ai_family means that the caller shall accept any address family. A value of zero for ai_socktype means that the caller shall accept any socket type. A value of zero for ai_protocol means that the caller shall accept any protocol. If hints is a null pointer, the behavior shall be as if it referred to a structure containing the value zero for the ai_flags, ai_socktype and ai_protocol fields, and AF_UNSPEC for the ai_family field.",
      "ja": "引数のヒントがnullでない場合、オプションを提供し、返された情報を特定のソケットタイプ、アドレスファミリおよび/またはプロトコルに制限することにより、操作を指示する入力値を含む構造を指します。このヒント構造では、AI_FLAGS以外のすべてのメンバー、AI_FAMILY、AI_SOCKTYPE、およびAI_Protocolはゼロまたはヌルポインターに設定されます。AI_FamilyのAF_UNSPECの値は、発信者が住所ファミリを受け入れることを意味します。AI_SockTypeのゼロ値は、発信者がソケットタイプを受け入れることを意味します。AI_Protocolのゼロの値は、発信者がプロトコルを受け入れることを意味します。ヒントがヌルポインターである場合、動作は、AI_FLAGS、AI_SOCKTYPE、AI_ProtoColフィールド、およびAI_FamilyフィールドのAF_UNSPECの値ゼロを含む構造を参照するかのようになります。"
    },
    {
      "indent": 3,
      "text": "Note:",
      "ja": "注記："
    },
    {
      "indent": 3,
      "text": "1. If the caller handles only TCP and not UDP, for example, then the ai_protocol member of the hints structure should be set to IPPROTO_TCP when getaddrinfo() is called.",
      "ja": "1. たとえば、発信者がUDPではなくTCPのみを処理する場合、getaddrinfo（）が呼び出された場合、ヒント構造のAI_ProtoColメンバーはIPPROTO_TCPに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "2. If the caller handles only IPv4 and not IPv6, then the ai_family member of the hints structure should be set to AF_INET when getaddrinfo() is called.",
      "ja": "2. 発信者がIPv4ではなくIPv4のみを処理する場合、getaddrinfo（）が呼び出された場合、ヒント構造のAI_FamilyメンバーをAF_INETに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The ai_flags field to which hints parameter points shall be set to zero or be the bitwise-inclusive OR of one or more of the values AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST, AI_NUMERICSERV, AI_V4MAPPED, AI_ALL, and AI_ADDRCONFIG.",
      "ja": "パラメーターポイントをヒントするAI_FLAGSフィールドは、ゼロに設定されるか、ビットワイズインクルーシブに設定されるか、1つ以上の値AI_PASSIVE、AI_CANONNAME、AI_NUMERICHOST、AI_NUMERICSERV、AI_V4MAPPED、AI_ALL、AI_ADDRCONFIG。"
    },
    {
      "indent": 3,
      "text": "If the AI_PASSIVE flag is specified, the returned address information shall be suitable for use in binding a socket for accepting incoming connections for the specified service (i.e., a call to bind()). In this case, if the nodename argument is null, then the IP address portion of the socket address structure shall be set to INADDR_ANY for an IPv4 address or IN6ADDR_ANY_INIT for an IPv6 address. If the AI_PASSIVE flag is not specified, the returned address information shall be suitable for a call to connect() (for a connection-mode protocol) or for a call to connect(), sendto() or sendmsg() (for a connectionless protocol). In this case, if the nodename argument is null, then the IP address portion of the socket address structure shall be set to the loopback address. This flag is ignored if the nodename argument is not null.",
      "ja": "AI_PASSIVEフラグが指定されている場合、返されたアドレス情報は、指定されたサービスの着信接続を受け入れるためのソケットをバインドするのに適しています（つまり、BIND（）への呼び出し）。この場合、nodename引数がnullの場合、ソケットアドレス構造のIPアドレス部分は、IPv4アドレスの場合はINADDR_ANYまたはIPv6アドレスの場合はIN6ADDR_ANY_INITに設定されます。ai_passiveフラグが指定されていない場合、返されたアドレス情報は、connect（）（接続モードプロトコルの場合）への呼び出しまたはconnect（）、send（）またはsendmsg（）（Connectionlessの呼び出しに適しているものとします。プロトコル）。この場合、nodename引数がnullの場合、ソケットアドレス構造のIPアドレス部分をループバックアドレスに設定する必要があります。Nodename引数がnullでない場合、このフラグは無視されます。"
    },
    {
      "indent": 3,
      "text": "If the AI_CANONNAME flag is specified and the nodename argument is not null, the function shall attempt to determine the canonical name corresponding to nodename (for example, if nodename is an alias or shorthand notation for a complete name).",
      "ja": "AI_CANONNAMEフラグが指定されており、nodename引数がnullでない場合、関数はnodenameに対応する標準名を決定しようとします（たとえば、Nodenameが完全な名前のエイリアスまたは速記の表記です）。"
    },
    {
      "indent": 3,
      "text": "If the AI_NUMERICHOST flag is specified, then a non-null nodename string supplied shall be a numeric host address string. Otherwise, an [EAI_NONAME] error is returned. This flag shall prevent any type of name resolution service (for example, the DNS) from being invoked.",
      "ja": "ai_numerichostフラグが指定されている場合、提供される非ヌルノデナム文字列は、数値ホストアドレス文字列でなければなりません。それ以外の場合、[eai_noname]エラーが返されます。このフラグは、あらゆるタイプの名前解像度サービス（たとえば、DNS）が呼び出されるのを防ぎます。"
    },
    {
      "indent": 3,
      "text": "If the AI_NUMERICSERV flag is specified, then a non-null servname string supplied shall be a numeric port string. Otherwise, an [EAI_NONAME] error shall be returned. This flag shall prevent any type of name resolution service (for example, NIS+) from being invoked.",
      "ja": "ai_numericservフラグが指定されている場合、供給される非ヌルサーブネーム文字列は数値ポート文字列でなければなりません。それ以外の場合、[eai_noname]エラーが返されます。このフラグは、あらゆるタイプの名前解像度サービス（たとえば、NIS）が呼び出されるのを防ぎます。"
    },
    {
      "indent": 3,
      "text": "If the AI_V4MAPPED flag is specified along with an ai_family of AF_INET6, then getaddrinfo() shall return IPv4-mapped IPv6 addresses on finding no matching IPv6 addresses (ai_addrlen shall be 16).",
      "ja": "AI_V4MappedフラグがAF_INET6のAI_Familyとともに指定されている場合、getAddrinfo（）は、一致しないIPv6アドレスを見つけた場合にIPv4-Mapped IPv6アドレスを返します（AI_ADDRLENは16でなければなりません）。"
    },
    {
      "indent": 6,
      "text": "For example, when using the DNS, if no AAAA records are found then a query is made for A records and any found are returned as IPv4- mapped IPv6 addresses.",
      "ja": "たとえば、DNSを使用する場合、AAAAレコードが見つからない場合、レコードに対してクエリが作成され、見つかったものはIPv4マッピングされたIPv6アドレスとして返されます。"
    },
    {
      "indent": 3,
      "text": "The AI_V4MAPPED flag shall be ignored unless ai_family equals AF_INET6.",
      "ja": "AI_FamilyがAF_INET6に等しい場合を除き、AI_V4MAPPEDフラグは無視されます。"
    },
    {
      "indent": 3,
      "text": "If the AI_ALL flag is used with the AI_V4MAPPED flag, then getaddrinfo() shall return all matching IPv6 and IPv4 addresses.",
      "ja": "AI_ALLフラグがAI_V4MAPPEDフラグで使用されている場合、getAdDrinfo（）はすべての一致するIPv6およびIPv4アドレスを返します。"
    },
    {
      "indent": 6,
      "text": "For example, when using the DNS, queries are made for both AAAA records and A records, and getaddrinfo() returns the combined results of both queries. Any IPv4 addresses found are returned as IPv4-mapped IPv6 addresses.",
      "ja": "たとえば、DNSを使用する場合、AAAAレコードとレコードの両方に対してクエリが作成され、getAddrinfo（）は両方のクエリの合計結果を返します。見つかったIPv4アドレスはすべて、IPv4マップIPv6アドレスとして返されます。"
    },
    {
      "indent": 3,
      "text": "The AI_ALL flag without the AI_V4MAPPED flag is ignored.",
      "ja": "AI_V4MAPPEDフラグのないAI_ALLフラグは無視されます。"
    },
    {
      "indent": 6,
      "text": "Note:",
      "ja": "注記："
    },
    {
      "indent": 6,
      "text": "When ai_family is not specified (AF_UNSPEC), AI_V4MAPPED and AI_ALL flags will only be used if AF_INET6 is supported.",
      "ja": "AI_Familyが指定されていない場合（AF_UNSPEC）、AI_V4MappedおよびAI_ALLフラグは、AF_INET6がサポートされている場合にのみ使用されます。"
    },
    {
      "indent": 3,
      "text": "If the AI_ADDRCONFIG flag is specified, IPv4 addresses shall be returned only if an IPv4 address is configured on the local system, and IPv6 addresses shall be returned only if an IPv6 address is configured on the local system. The loopback address is not considered for this case as valid as a configured address.",
      "ja": "AI_ADDRCONFIGフラグが指定されている場合、IPv4アドレスはローカルシステムでIPv4アドレスが構成されている場合にのみ返され、IPv6アドレスはローカルシステムでIPv6アドレスが構成されている場合にのみ返されます。このケースのループバックアドレスは、構成されたアドレスと同じくらい有効であると見なされません。"
    },
    {
      "indent": 6,
      "text": "For example, when using the DNS, a query for AAAA records should occur only if the node has at least one IPv6 address configured (other than IPv6 loopback) and a query for A records should occur only if the node has at least one IPv4 address configured (other than the IPv4 loopback).",
      "ja": "たとえば、DNSを使用する場合、AAAAレコードのクエリは、ノードに少なくとも1つのIPv6アドレスが構成されている場合にのみ発生する必要があります（IPv6ループバック以外）、レコードのクエリはノードに少なくとも1つのIPv4アドレスがある場合にのみ発生するはずです構成（IPv4ループバック以外）。"
    },
    {
      "indent": 3,
      "text": "The ai_socktype field to which argument hints points specifies the socket type for the service, as defined for socket(). If a specific socket type is not given (for example, a value of zero) and the service name could be interpreted as valid with multiple supported socket types, the implementation shall attempt to resolve the service name for all supported socket types and, in the absence of errors, all possible results shall be returned. A non-zero socket type value shall limit the returned information to values with the specified socket type.",
      "ja": "Socket（）で定義されているように、引数ポイントがヒントポイントをヒントするAI_SockTypeフィールドは、サービスのソケットタイプを指定します。特定のソケットタイプが与えられていない場合（たとえば、ゼロの値）、サービス名が複数のサポートされているソケットタイプで有効と解釈できる場合、実装はサポートされているすべてのソケットタイプのサービス名を解決しようとするものとします。エラーがないため、すべての可能な結果が返されます。ゼロ以外のソケットタイプの値は、指定されたソケットタイプで返された情報を値に制限するものとします。"
    },
    {
      "indent": 3,
      "text": "If the ai_family field to which hints points has the value AF_UNSPEC, addresses shall be returned for use with any address family that can be used with the specified nodename and/or servname. Otherwise, addresses shall be returned for use only with the specified address family. If ai_family is not AF_UNSPEC and ai_protocol is not zero, then addresses are returned for use only with the specified address family and protocol; the value of ai_protocol shall be interpreted as in a call to the socket() function with the corresponding values of ai_family and ai_protocol.",
      "ja": "ヒントポイントが値AF_UNSPECを持っているAI_Familyフィールドに、指定されたNodenameおよび/またはServnameで使用できるアドレスファミリでアドレスを返すためにアドレスを返すものとします。それ以外の場合、指定されたアドレスファミリでのみ使用するために住所を返すものとします。ai_familyがaf_unspecではなく、ai_protocolがゼロではない場合、指定されたアドレスファミリとプロトコルでのみ使用するためにアドレスが返されます。AI_Protocolの値は、AI_FamilyとAI_Protocolの対応する値を持つSocket（）関数への呼び出しで解釈されるものとします。"
    },
    {
      "indent": 3,
      "text": "The freeaddrinfo() function frees one or more addrinfo structures returned by getaddrinfo(), along with any additional storage associated with those structures (for example, storage pointed to by the ai_canonname and ai_addr fields; an application must not reference this storage after the associated addrinfo structure has been freed). If the ai_next field of the structure is not null, the entire list of structures is freed. The freeaddrinfo() function must support the freeing of arbitrary sublists of an addrinfo list originally returned by getaddrinfo().",
      "ja": "Freeaddrinfo（）関数は、getaddrinfo（）によって返された1つまたは複数のaddrinfo構造を解放し、それらの構造に関連する追加のストレージ（たとえば、AI_CANONNAMEおよびAI_ADDRフィールドが指すストレージ。AddRinfo構造は解放されました）。構造のai_nextフィールドがnullでない場合、構造のリスト全体が解放されます。Freeaddrinfo（）関数は、もともとgetaddrinfo（）によって返されたaddrinfoリストの任意のサブリストの解放をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Functions getaddrinfo() and freeaddrinfo() must be thread-safe.",
      "ja": "関数getaddrinfo（）およびfreeaddrinfo（）はスレッドセーフでなければなりません。"
    },
    {
      "indent": 3,
      "text": "A zero return value for getaddrinfo() indicates successful completion; a non-zero return value indicates failure. The possible values for the failures are listed below under Error Return Values.",
      "ja": "getaddrinfo（）のゼロ戻り値は、正常に完了します。ゼロ以外の返品値は、障害を示します。障害の可能性のある値は、エラーリターン値の下に以下にリストされています。"
    },
    {
      "indent": 3,
      "text": "Upon successful return of getaddrinfo(), the location to which res points shall refer to a linked list of addrinfo structures, each of which shall specify a socket address and information for use in creating a socket with which to use that socket address. The list shall include at least one addrinfo structure. The ai_next field of each structure contains a pointer to the next structure on the list, or a null pointer if it is the last structure on the list. Each structure on the list shall include values for use with a call to the socket() function, and a socket address for use with the connect() function or, if the AI_PASSIVE flag was specified, for use with the bind() function. The fields ai_family, ai_socktype, and ai_protocol shall be usable as the arguments to the socket() function to create a socket suitable for use with the returned address. The fields ai_addr and ai_addrlen are usable as the arguments to the connect() or bind() functions with such a socket, according to the AI_PASSIVE flag.",
      "ja": "getaddrinfo（）が成功した場合、RESポイントがaddRinfo構造のリンクリストを指す場所は、それぞれがそのソケットアドレスを使用するソケットを作成する際に使用するソケットアドレスと情報を指定するものとします。リストには、少なくとも1つのAddRINFO構造が含まれます。各構造のAI_NEXTフィールドには、リストの次の構造へのポインター、またはリストの最後の構造である場合はnullポインターが含まれています。リストの各構造には、Socket（）関数への呼び出しで使用する値と、connect（）関数で使用するソケットアドレス、またはbind（）関数で使用するためのAI_passiveフラグが指定された場合は含まれます。Fields AI_Family、AI_SockType、およびAI_Protocolは、Socket（）関数の引数として使用できるようにして、返されたアドレスで使用するのに適したソケットを作成します。AI_Passiveフラグによると、Fields AI_ADDRとAI_ADDRLENは、Connect（）またはBind（）関数をそのようなソケットで機能させるものとして使用できます。"
    },
    {
      "indent": 3,
      "text": "If nodename is not null, and if requested by the AI_CANONNAME flag, the ai_canonname field of the first returned addrinfo structure shall point to a null-terminated string containing the canonical name corresponding to the input nodename; if the canonical name is not available, then ai_canonname shall refer to the nodename argument or a string with the same contents. The contents of the ai_flags field of the returned structures are undefined.",
      "ja": "nodenameがnullではない場合、AI_Canonnameフラグから要求された場合、最初に返されたAddRINFO構造のAI_CANONNAMEフィールドは、入力nodenameに対応する標準名を含むヌル終端文字列を指します。標準名が利用できない場合、AI_CANONNAMEは、同じコンテンツを持つnodename引数または文字列を参照するものとします。返された構造のAI_FLAGSフィールドの内容は未定義です。"
    },
    {
      "indent": 3,
      "text": "All fields in socket address structures returned by getaddrinfo() that are not filled in through an explicit argument (for example, sin6_flowinfo) shall be set to zero.",
      "ja": "getaddrinfo（）によって返されるソケットアドレス構造のすべてのフィールドは、明示的な引数（sin6_flowinfoなど）を通じて埋められないものをゼロに設定するものとします。"
    },
    {
      "indent": 3,
      "text": "Note: This makes it easier to compare socket address structures.",
      "ja": "注：これにより、ソケットアドレス構造を簡単に比較できます。"
    },
    {
      "indent": 3,
      "text": "Error Return Values:",
      "ja": "エラー戻り値："
    },
    {
      "indent": 3,
      "text": "The getaddrinfo() function shall fail and return the corresponding value if:",
      "ja": "getaddrinfo（）関数は故障し、対応する値を返します。"
    },
    {
      "indent": 3,
      "text": "[EAI_AGAIN] The name could not be resolved at this time. Future attempts may succeed.",
      "ja": "[eai_again]この時点では名前を解決できませんでした。将来の試みは成功するかもしれません。"
    },
    {
      "indent": 3,
      "text": "[EAI_BADFLAGS] The flags parameter had an invalid value.",
      "ja": "[EAI_BADFLAGS] Flagsパラメーターには無効な値がありました。"
    },
    {
      "indent": 3,
      "text": "[EAI_FAIL] A non-recoverable error occurred when attempting to resolve the name.",
      "ja": "[EAI_FAIL]名前を解決しようとしたときに、回復不可能なエラーが発生しました。"
    },
    {
      "indent": 3,
      "text": "[EAI_FAMILY] The address family was not recognized.",
      "ja": "[eai_family]住所ファミリは認識されていませんでした。"
    },
    {
      "indent": 3,
      "text": "[EAI_MEMORY] There was a memory allocation failure when trying to allocate storage for the return value.",
      "ja": "[EAI_Memory]返品値にストレージを割り当てようとすると、メモリ割り当て障害がありました。"
    },
    {
      "indent": 3,
      "text": "[EAI_NONAME] The name does not resolve for the supplied parameters. Neither nodename nor servname were supplied. At least one of these must be supplied.",
      "ja": "[EAI_NONAME]名前は、付属のパラメーターに対して解決しません。NodenameもServnameも提供されませんでした。これらの少なくとも1つを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "[EAI_SERVICE] The service passed was not recognized for the specified socket type.",
      "ja": "[EAI_Service]合格したサービスは、指定されたソケットタイプについては認識されませんでした。"
    },
    {
      "indent": 3,
      "text": "[EAI_SOCKTYPE] The intended socket type was not recognized.",
      "ja": "[EAI_SOCKTYPE]意図したソケットタイプは認識されませんでした。"
    },
    {
      "indent": 3,
      "text": "[EAI_SYSTEM] A system error occurred; the error code can be found in errno.",
      "ja": "[EAI_System]システムエラーが発生しました。エラーコードはerrnoにあります。"
    },
    {
      "indent": 3,
      "text": "The gai_strerror() function provides a descriptive text string corresponding to an EAI_xxx error value.",
      "ja": "GAI_STRERROR（）関数は、EAI_XXXエラー値に対応する説明的なテキスト文字列を提供します。"
    },
    {
      "indent": 6,
      "text": "#include <netdb.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "const char *gai_strerror(int ecode);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The argument is one of the EAI_xxx values defined for the getaddrinfo() and getnameinfo() functions. The return value points to a string describing the error. If the argument is not one of the EAI_xxx values, the function still returns a pointer to a string whose contents indicate an unknown error.",
      "ja": "この引数は、getaddrinfo（）およびgetNameInfo（）関数に対して定義されたEAI_XXX値の1つです。リターン値は、エラーを説明する文字列を指します。引数がEAI_XXX値の1つではない場合、関数は、内容が不明な誤差を示す文字列へのポインターを返します。"
    },
    {
      "indent": 0,
      "text": "6.2 Socket Address Structure to Node Name and Service Name",
      "section_title": true,
      "ja": "6.2 ノード名とサービス名へのソケットアドレス構造"
    },
    {
      "indent": 3,
      "text": "The getnameinfo() function is used to translate the contents of a socket address structure to a node name and/or service name.",
      "ja": "getNameInfo（）関数は、ソケットアドレス構造の内容をノード名および/またはサービス名に変換するために使用されます。"
    },
    {
      "indent": 3,
      "text": "#include <sys/socket.h>\n#include <netdb.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *node, socklen_t nodelen, char *service, socklen_t servicelen, int flags);",
      "ja": "int getnameInfo（const struct sockaddr *sa、socklen_t salen、char *node、socklen_t nodelen、char *service、socklen_t servicelen、int flags）;"
    },
    {
      "indent": 3,
      "text": "The getnameinfo() function shall translate a socket address to a node name and service location, all of which are defined as in getaddrinfo().",
      "ja": "getNameInfo（）関数は、ソケットアドレスをノード名とサービスの場所に変換するものとします。これらはすべてgetaddrinfo（）のように定義されます。"
    },
    {
      "indent": 3,
      "text": "The sa argument points to a socket address structure to be translated.",
      "ja": "SA引数は、翻訳されるソケットアドレス構造を指します。"
    },
    {
      "indent": 3,
      "text": "The salen argument holds the size of the socket address structure pointed to by sa.",
      "ja": "Salen引数は、SAが指すソケットアドレス構造のサイズを保持します。"
    },
    {
      "indent": 3,
      "text": "If the socket address structure contains an IPv4-mapped IPv6 address or an IPv4-compatible IPv6 address, the implementation shall extract the embedded IPv4 address and lookup the node name for that IPv4 address.",
      "ja": "ソケットアドレス構造にIPv4-Mapped IPv6アドレスまたはIPv4互換のIPv6アドレスが含まれている場合、実装は埋め込まれたIPv4アドレスを抽出し、そのIPv4アドレスのノード名を検索するものとします。"
    },
    {
      "indent": 6,
      "text": "Note: The IPv6 unspecified address (\"::\") and the IPv6 loopback address (\"::1\") are not IPv4-compatible addresses. If the address is the IPv6 unspecified address (\"::\"), a lookup is not performed, and the [EAI_NONAME] error is returned.",
      "ja": "注：IPv6未特定のアドレス（ \"::\"）およびIPv6ループバックアドレス（ \":: 1\"）は、IPv4互換アドレスではありません。アドレスがIPv6の不特定アドレス（ \"::\"）である場合、ルックアップは実行されず、[eai_noname]エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "If the node argument is non-NULL and the nodelen argument is nonzero, then the node argument points to a buffer able to contain up to nodelen characters that receives the node name as a null-terminated string. If the node argument is NULL or the nodelen argument is zero, the node name shall not be returned. If the node's name cannot be located, the numeric form of the node's address is returned instead of its name.",
      "ja": "ノード引数が非ヌルであり、ノデレン引数がゼロである場合、ノード引数は、null末端の文字列としてノード名を受信するNodelen文字を封じ込めることができるバッファーを指します。ノード引数がnullの場合、またはノデレン引数がゼロの場合、ノード名は返されません。ノードの名前を見つけることができない場合、ノードのアドレスの数値形式が名前の代わりに返されます。"
    },
    {
      "indent": 3,
      "text": "If the service argument is non-NULL and the servicelen argument is non-zero, then the service argument points to a buffer able to contain up to servicelen bytes that receives the service name as a null-terminated string. If the service argument is NULL or the servicelen argument is zero, the service name shall not be returned. If the service's name cannot be located, the numeric form of the service address (for example, its port number) shall be returned instead of its name.",
      "ja": "サービス引数が非ヌルであり、Servicelen引数がゼロではない場合、サービス引数は、ヌル終端文字列としてサービス名を受信するServicelenバイトを封じ込めることができるバッファーを指します。サービス引数がnullであるか、Servicelen引数がゼロの場合、サービス名は返されません。サービスの名前を見つけることができない場合、サービスアドレスの数値形式（たとえば、そのポート番号）は、その名前の代わりに返されます。"
    },
    {
      "indent": 3,
      "text": "The arguments node and service cannot both be NULL.",
      "ja": "引数ノードとサービスは両方ともヌルではありません。"
    },
    {
      "indent": 3,
      "text": "The flags argument is a flag that changes the default actions of the function. By default the fully-qualified domain name (FQDN) for the host shall be returned, but:",
      "ja": "Flags引数は、関数のデフォルトアクションを変更するフラグです。デフォルトでは、ホストの完全に資格のあるドメイン名（FQDN）が返されますが、"
    },
    {
      "indent": 3,
      "text": "- If the flag bit NI_NOFQDN is set, only the node name portion of the FQDN shall be returned for local hosts.",
      "ja": "- フラグビットni_nofqdnが設定されている場合、fqdnのノード名部分のみがローカルホストに対して返されます。"
    },
    {
      "indent": 3,
      "text": "- If the flag bit NI_NUMERICHOST is set, the numeric form of the host's address shall be returned instead of its name, under all circumstances.",
      "ja": "- フラグビットni_numerichostが設定されている場合、あらゆる状況に基づいて、ホストのアドレスの数値は、その名前の代わりに返されます。"
    },
    {
      "indent": 3,
      "text": "- If the flag bit NI_NAMEREQD is set, an error shall be returned if the host's name cannot be located.",
      "ja": "- フラグビットNI_NAMEREQDが設定されている場合、ホストの名前を見つけることができない場合、エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "- If the flag bit NI_NUMERICSERV is set, the numeric form of the service address shall be returned (for example, its port number) instead of its name, under all circumstances.",
      "ja": "- フラグビットni_numericservが設定されている場合、あらゆる状況で、その名前の代わりにサービスアドレスの数値形式（たとえば、そのポート番号）が返されます。"
    },
    {
      "indent": 3,
      "text": "- If the flag bit NI_DGRAM is set, this indicates that the service is a datagram service (SOCK_DGRAM). The default behavior shall assume that the service is a stream service (SOCK_STREAM).",
      "ja": "- フラグビットni_dgramが設定されている場合、これはサービスがデータグラムサービス（sock_dgram）であることを示します。デフォルトの動作は、サービスがストリームサービス（sock_stream）であると想定するものとします。"
    },
    {
      "indent": 3,
      "text": "Note:",
      "ja": "注記："
    },
    {
      "indent": 3,
      "text": "1. The NI_NUMERICxxx flags are required to support the \"-n\" flags that many commands provide.",
      "ja": "1. NI_NUMERICXXXフラグは、多くのコマンドが提供する「-N」フラグをサポートするために必要です。"
    },
    {
      "indent": 3,
      "text": "2. The NI_DGRAM flag is required for the few AF_INET and AF_INET6 port numbers (for example, [512,514]) that represent different services for UDP and TCP.",
      "ja": "2. NI_DGRAMフラグは、UDPとTCPのさまざまなサービスを表すいくつかのAF_INETおよびAF_INET6ポート番号（[512,514]など）に必要です。"
    },
    {
      "indent": 3,
      "text": "The getnameinfo() function shall be thread safe.",
      "ja": "getNameInfo（）関数は、スレッドセーフでなければなりません。"
    },
    {
      "indent": 3,
      "text": "A zero return value for getnameinfo() indicates successful completion; a non-zero return value indicates failure.",
      "ja": "getNameInfo（）のゼロ戻り値は、正常に完了します。ゼロ以外の返品値は、障害を示します。"
    },
    {
      "indent": 3,
      "text": "Upon successful completion, getnameinfo() shall return the node and service names, if requested, in the buffers provided. The returned names are always null-terminated strings.",
      "ja": "正常に完了すると、getNameInfo（）は、要求された場合、提供されたバッファーでノードとサービス名を返します。返された名前は常にヌル終端文字列です。"
    },
    {
      "indent": 3,
      "text": "Error Return Values:",
      "ja": "エラー戻り値："
    },
    {
      "indent": 3,
      "text": "The getnameinfo() function shall fail and return the corresponding value if:",
      "ja": "getnameInfo（）関数は、次の場合に故障し、対応する値を返します。"
    },
    {
      "indent": 3,
      "text": "[EAI_AGAIN] The name could not be resolved at this time. Future attempts may succeed.",
      "ja": "[eai_again]この時点では名前を解決できませんでした。将来の試みは成功するかもしれません。"
    },
    {
      "indent": 3,
      "text": "[EAI_BADFLAGS] The flags had an invalid value.",
      "ja": "[EAI_BADFLAGS]フラグには無効な値がありました。"
    },
    {
      "indent": 3,
      "text": "[EAI_FAIL] A non-recoverable error occurred.",
      "ja": "[EAI_FAIL]再獲得不可能なエラーが発生しました。"
    },
    {
      "indent": 3,
      "text": "[EAI_FAMILY] The address family was not recognized or the address length was invalid for the specified family.",
      "ja": "[EAI_FAMILY]住所ファミリは認識されていないか、指定されたファミリに対して住所の長さが無効でした。"
    },
    {
      "indent": 3,
      "text": "[EAI_MEMORY] There was a memory allocation failure.",
      "ja": "[EAI_Memory]メモリの割り当て障害がありました。"
    },
    {
      "indent": 3,
      "text": "[EAI_NONAME] The name does not resolve for the supplied parameters. NI_NAMEREQD is set and the host's name cannot be located, or both nodename and servname were null.",
      "ja": "[EAI_NONAME]名前は、付属のパラメーターに対して解決しません。NI_NAMEREQDが設定されており、ホストの名前を見つけることができないか、NodenameとServnameの両方がnullでした。"
    },
    {
      "indent": 3,
      "text": "[EAI_OVERFLOW] An argument buffer overflowed.",
      "ja": "[eai_overflow]オーバーフローされた引数バッファー。"
    },
    {
      "indent": 3,
      "text": "[EAI_SYSTEM] A system error occurred. The error code can be found in errno.",
      "ja": "[EAI_System]システムエラーが発生しました。エラーコードはerrnoにあります。"
    },
    {
      "indent": 0,
      "text": "6.3 Address Conversion Functions",
      "section_title": true,
      "ja": "6.3 アドレス変換関数"
    },
    {
      "indent": 3,
      "text": "The two IPv4 functions inet_addr() and inet_ntoa() convert an IPv4 address between binary and text form. IPv6 applications need similar functions. The following two functions convert both IPv6 and IPv4 addresses:",
      "ja": "2つのIPv4機能は、INET_ADDR（）とINET_NTOA（）をバイナリフォームとテキストフォーム間でIPv4アドレスを変換します。IPv6アプリケーションにも同様の機能が必要です。次の2つの関数は、IPv6とIPv4アドレスの両方を変換します。"
    },
    {
      "indent": 3,
      "text": "#include <arpa/inet.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int inet_pton(int af, const char *src, void *dst);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const char *inet_ntop(int af, const void *src,\n                         char *dst, socklen_t size);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The inet_pton() function shall convert an address in its standard text presentation form into its numeric binary form. The af argument shall specify the family of the address. The AF_INET and AF_INET6 address families shall be supported. The src argument points to the string being passed in. The dst argument points to a buffer into which the function stores the numeric address; this shall be large enough to hold the numeric address (32 bits for AF_INET, 128 bits for AF_INET6). The inet_pton() function shall return 1 if the conversion succeeds, with the address pointed to by dst in network byte order. It shall return 0 if the input is not a valid IPv4 dotted-decimal string or a valid IPv6 address string, or -1 with errno set to EAFNOSUPPORT if the af argument is unknown.",
      "ja": "INET_PTON（）関数は、標準のテキストプレゼンテーションフォームのアドレスを数値バイナリ形式に変換するものとします。AF引数は、住所のファミリーを指定するものとします。AF_INETおよびAF_INET6アドレスファミリをサポートするものとします。SRC引数は、渡される文字列を指します。DST引数は、関数が数値アドレスを格納するバッファーを指します。これは、数値アドレスを保持するのに十分な大きさでなければなりません（AF_INETの場合は32ビット、AF_INET6で128ビット）。INET_PTON（）関数は、コンバージョンが成功した場合に1を返し、アドレスはDSTでネットワークバイトの順序で指摘されます。入力が有効なIPv4ドットドシマル文字列または有効なIPv6アドレス文字列である場合は0を返します。"
    },
    {
      "indent": 3,
      "text": "If the af argument of inet_pton() is AF_INET, the src string shall be in the standard IPv4 dotted-decimal form:",
      "ja": "INET_PTON（）のAF引数がAF_INETである場合、SRC文字列は標準のIPv4点線形式になります。"
    },
    {
      "indent": 6,
      "text": "ddd.ddd.ddd.ddd",
      "ja": "ddd.ddd.ddd.ddd"
    },
    {
      "indent": 3,
      "text": "where \"ddd\" is a one to three digit decimal number between 0 and 255. The inet_pton() function does not accept other formats (such as the octal numbers, hexadecimal numbers, and fewer than four numbers that inet_addr() accepts).",
      "ja": "ここで、「DDD」は0から255の間の1〜3桁の小数点以下です。INET_PTON（）関数は、他の形式（Octal数、16進数など、INET_ADDR（）が受け入れる4つの数値）を受け入れません。"
    },
    {
      "indent": 3,
      "text": "If the af argument of inet_pton() is AF_INET6, the src string shall be in one of the standard IPv6 text forms defined in Section 2.2 of the addressing architecture specification [2].",
      "ja": "INET_PTON（）のAF引数がAF_INET6の場合、SRC文字列は、アドレス指定アーキテクチャ仕様のセクション2.2で定義されている標準IPv6テキストフォームの1つになります[2]。"
    },
    {
      "indent": 3,
      "text": "The inet_ntop() function shall convert a numeric address into a text string suitable for presentation. The af argument shall specify the family of the address. This can be AF_INET or AF_INET6. The src argument points to a buffer holding an IPv4 address if the af argument is AF_INET, or an IPv6 address if the af argument is AF_INET6; the address must be in network byte order. The dst argument points to a buffer where the function stores the resulting text string; it shall not be NULL. The size argument specifies the size of this buffer, which shall be large enough to hold the text string (INET_ADDRSTRLEN characters for IPv4, INET6_ADDRSTRLEN characters for IPv6).",
      "ja": "INET_NTOP（）関数は、数値アドレスをプレゼンテーションに適したテキスト文字列に変換するものとします。AF引数は、住所のファミリーを指定するものとします。これは、af_inetまたはaf_inet6です。SRC引数は、AF引数がAF_INETの場合はIPv4アドレスを保持するバッファーを指します。AF引数がAF_INET6の場合はIPv6アドレスです。アドレスはネットワークバイトの順序でなければなりません。DST引数は、関数が結果のテキスト文字列を保存するバッファーを指します。それはヌルではありません。サイズ引数は、このバッファのサイズを指定します。これは、テキスト文字列（IPv4のINET_ADDRSTRLEN文字、IPv6のINET6_ADDRSTRLEN文字）を保持するのに十分な大きさでなければなりません。"
    },
    {
      "indent": 3,
      "text": "In order to allow applications to easily declare buffers of the proper size to store IPv4 and IPv6 addresses in string form, the following two constants are defined in <netinet/in.h>:",
      "ja": "アプリケーションが適切なサイズのバッファーを簡単に宣言できるようにするために、IPv4およびIPv6アドレスを文字列形式で保存するには、次の2つの定数が<netinet/in.h>で定義されています。"
    },
    {
      "indent": 6,
      "text": "#define INET_ADDRSTRLEN 16 #define INET6_ADDRSTRLEN 46",
      "ja": "#Define INET_ADDRSTRLEN 16 #DEFINE INET6_ADDRSTRLEN 46"
    },
    {
      "indent": 3,
      "text": "The inet_ntop() function shall return a pointer to the buffer containing the text string if the conversion succeeds, and NULL otherwise. Upon failure, errno is set to EAFNOSUPPORT if the af argument is invalid or ENOSPC if the size of the result buffer is inadequate.",
      "ja": "INET_NTOP（）関数は、変換が成功した場合はテキスト文字列を含むバッファーへのポインターを返し、それ以外の場合はnullを返します。障害時に、AF引数が無効である場合、ERRNOは、結果バッファーのサイズが不十分な場合はENOSPCの場合、EafnoSupportに設定されます。"
    },
    {
      "indent": 0,
      "text": "6.4 Address Testing Macros",
      "section_title": true,
      "ja": "6.4 マクロのアドレステスト"
    },
    {
      "indent": 3,
      "text": "The following macros can be used to test for special IPv6 addresses.",
      "ja": "次のマクロを使用して、特別なIPv6アドレスをテストできます。"
    },
    {
      "indent": 3,
      "text": "#include <netinet/in.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int  IN6_IS_ADDR_UNSPECIFIED (const struct in6_addr *);\nint  IN6_IS_ADDR_LOOPBACK    (const struct in6_addr *);\nint  IN6_IS_ADDR_MULTICAST   (const struct in6_addr *);\nint  IN6_IS_ADDR_LINKLOCAL   (const struct in6_addr *);\nint  IN6_IS_ADDR_SITELOCAL   (const struct in6_addr *);\nint  IN6_IS_ADDR_V4MAPPED    (const struct in6_addr *);\nint  IN6_IS_ADDR_V4COMPAT    (const struct in6_addr *);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int  IN6_IS_ADDR_MC_NODELOCAL(const struct in6_addr *);\nint  IN6_IS_ADDR_MC_LINKLOCAL(const struct in6_addr *);\nint  IN6_IS_ADDR_MC_SITELOCAL(const struct in6_addr *);\nint  IN6_IS_ADDR_MC_ORGLOCAL (const struct in6_addr *);\nint  IN6_IS_ADDR_MC_GLOBAL   (const struct in6_addr *);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The first seven macros return true if the address is of the specified type, or false otherwise. The last five test the scope of a multicast address and return true if the address is a multicast address of the specified scope or false if the address is either not a multicast address or not of the specified scope.",
      "ja": "最初の7つのマクロは、アドレスが指定されたタイプの場合、またはそれ以外の場合はfalseの場合にtrueを返します。最後の5つのテストマルチキャストアドレスの範囲をテストし、アドレスが指定されたスコープのマルチキャストアドレスである場合、またはアドレスが指定されたスコープのマルチキャストアドレスではない場合はfalseの場合はtrueを返します。"
    },
    {
      "indent": 3,
      "text": "Note that IN6_IS_ADDR_LINKLOCAL and IN6_IS_ADDR_SITELOCAL return true only for the two types of local-use IPv6 unicast addresses (Link-Local and Site-Local) defined in [2], and that by this definition, the IN6_IS_ADDR_LINKLOCAL macro returns false for the IPv6 loopback address (::1). These two macros do not return true for IPv6 multicast addresses of either link-local scope or site-local scope.",
      "ja": "IN6_IS_ADDR_LINKLOCALおよびIN6_IS_ADDR_SITELOCALは、[2]で定義されている2種類のローカル使用IPv6ユニキャストアドレス（リンク - ローカルおよびサイトローカル）に対してのみTRUEを返すことに注意してください。（:: 1）。これらの2つのマクロは、Link-Local ScopeまたはSite-Local ScopeのいずれかのIPv6マルチキャストアドレスに対して真実ではありません。"
    },
    {
      "indent": 0,
      "text": "7. Summary of New Definitions",
      "section_title": true,
      "ja": "7. 新しい定義の概要"
    },
    {
      "indent": 3,
      "text": "The following list summarizes the constants, structure, and extern definitions discussed in this memo, sorted by header.",
      "ja": "次のリストは、このメモで説明されている定数、構造、および外部定義を、ヘッダーでソートしたものをまとめたものです。"
    },
    {
      "indent": 0,
      "text": "<net/if.h>      IF_NAMESIZE\n<net/if.h>      struct if_nameindex{};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "<netdb.h>       AI_ADDRCONFIG\n<netdb.h>       AI_ALL\n<netdb.h>       AI_CANONNAME\n<netdb.h>       AI_NUMERICHOST\n<netdb.h>       AI_NUMERICSERV\n<netdb.h>       AI_PASSIVE\n<netdb.h>       AI_V4MAPPED",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "<netdb.h>       EAI_AGAIN\n<netdb.h>       EAI_BADFLAGS\n<netdb.h>       EAI_FAIL\n<netdb.h>       EAI_FAMILY\n<netdb.h>       EAI_MEMORY\n<netdb.h>       EAI_NONAME\n<netdb.h>       EAI_OVERFLOW\n<netdb.h>       EAI_SERVICE\n<netdb.h>       EAI_SOCKTYPE\n<netdb.h>       EAI_SYSTEM\n<netdb.h>       NI_DGRAM\n<netdb.h>       NI_NAMEREQD\n<netdb.h>       NI_NOFQDN\n<netdb.h>       NI_NUMERICHOST\n<netdb.h>       NI_NUMERICSERV\n<netdb.h>       struct addrinfo{};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "<netinet/in.h>  IN6ADDR_ANY_INIT\n<netinet/in.h>  IN6ADDR_LOOPBACK_INIT\n<netinet/in.h>  INET6_ADDRSTRLEN\n<netinet/in.h>  INET_ADDRSTRLEN\n<netinet/in.h>  IPPROTO_IPV6\n<netinet/in.h>  IPV6_JOIN_GROUP\n<netinet/in.h>  IPV6_LEAVE_GROUP\n<netinet/in.h>  IPV6_MULTICAST_HOPS\n<netinet/in.h>  IPV6_MULTICAST_IF\n<netinet/in.h>  IPV6_MULTICAST_LOOP\n<netinet/in.h>  IPV6_UNICAST_HOPS\n<netinet/in.h>  IPV6_V6ONLY\n<netinet/in.h>  SIN6_LEN\n<netinet/in.h>  extern const struct in6_addr in6addr_any;\n<netinet/in.h>  extern const struct in6_addr in6addr_loopback;\n<netinet/in.h>  struct in6_addr{};\n<netinet/in.h>  struct ipv6_mreq{};\n<netinet/in.h>  struct sockaddr_in6{};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "<sys/socket.h>  AF_INET6\n<sys/socket.h>  PF_INET6\n<sys/socket.h>  struct sockaddr_storage;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following list summarizes the function and macro prototypes discussed in this memo, sorted by header.",
      "ja": "次のリストは、このメモで説明されている関数とマクロプロトタイプを要約して、ヘッダーでソートします。"
    },
    {
      "indent": 0,
      "text": "<arpa/inet.h>   int inet_pton(int, const char *, void *);\n<arpa/inet.h>   const char *inet_ntop(int, const void *,\n                               char *, socklen_t);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "<net/if.h>      char *if_indextoname(unsigned int, char *);\n<net/if.h>      unsigned int if_nametoindex(const char *);\n<net/if.h>      void if_freenameindex(struct if_nameindex *);\n<net/if.h>      struct if_nameindex *if_nameindex(void);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "<netdb.h>       int getaddrinfo(const char *, const char *,\n                                const struct addrinfo *,\n                                struct addrinfo **);\n<netdb.h>       int getnameinfo(const struct sockaddr *, socklen_t,\n                  char *, socklen_t, char *, socklen_t, int);\n<netdb.h>       void freeaddrinfo(struct addrinfo *);\n<netdb.h>       const char *gai_strerror(int);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "<netinet/in.h>  int IN6_IS_ADDR_LINKLOCAL(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_LOOPBACK(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_MC_GLOBAL(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_MC_LINKLOCAL(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_MC_NODELOCAL(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_MC_ORGLOCAL(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_MC_SITELOCAL(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_MULTICAST(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_SITELOCAL(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_UNSPECIFIED(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_V4COMPAT(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_V4MAPPED(const struct in6_addr *);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "IPv6 provides a number of new security mechanisms, many of which need to be accessible to applications. Companion memos detailing the extensions to the socket interfaces to support IPv6 security are being written.",
      "ja": "IPv6は多くの新しいセキュリティメカニズムを提供しますが、その多くはアプリケーションにアクセスできる必要があります。IPv6セキュリティをサポートするためにソケットインターフェイスの拡張機能を詳述するコンパニオンメモが記述されています。"
    },
    {
      "indent": 0,
      "text": "9. Changes from RFC 2553",
      "section_title": true,
      "ja": "9. RFC 2553からの変更"
    },
    {
      "indent": 3,
      "text": "1. Add brief description of the history of this API and its relation to the Open Group/IEEE/ISO standards.",
      "ja": "1. このAPIの履歴と、オープングループ/IEEE/ISO標準との関係について簡単に説明します。"
    },
    {
      "indent": 3,
      "text": "2. Alignments with [3].",
      "ja": "2. [3]とのアラインメント。"
    },
    {
      "indent": 3,
      "text": "3. Removed all references to getipnodebyname() and getipnodebyaddr(), which are deprecated in favor of getaddrinfo() and getnameinfo().",
      "ja": "3. getIpNodeByName（）およびgetIpNodeByaddr（）へのすべての参照を削除しました。"
    },
    {
      "indent": 3,
      "text": "4. Added IPV6_V6ONLY IP level socket option to permit nodes to not process IPv4 packets as IPv4 Mapped addresses in implementations.",
      "ja": "4. IPv6_V6only IPレベルソケットオプションを追加して、実装でIPv4マッピングアドレスとしてIPv4パケットを処理しないことをノードに許可します。"
    },
    {
      "indent": 3,
      "text": "5. Added SIIT to references and added new contributors.",
      "ja": "5. 参照にSIITを追加し、新しい貢献者を追加しました。"
    },
    {
      "indent": 3,
      "text": "6. In previous versions of this specification, the sin6_flowinfo field was associated with the IPv6 traffic class and flow label, but its usage was not completely specified. The complete definition of the sin6_flowinfo field, including its association with the traffic class or flow label, is now deferred to a future specification.",
      "ja": "6. この仕様の以前のバージョンでは、SIN6_FLOWINFOフィールドはIPv6トラフィッククラスとフローラベルに関連付けられていましたが、その使用は完全に指定されていませんでした。トラフィッククラスまたはフローラベルとの関連を含むSIN6_FLOWINFOフィールドの完全な定義は、将来の仕様に延期されています。"
    },
    {
      "indent": 0,
      "text": "10. Acknowledgments",
      "section_title": true,
      "ja": "10. 謝辞"
    },
    {
      "indent": 3,
      "text": "This specification's evolution and completeness were significantly influenced by the efforts of Richard Stevens, who has passed on. Richard's wisdom and talent made the specification what it is today. The co-authors will long think of Richard with great respect.",
      "ja": "この仕様の進化と完全性は、亡くなったリチャードスティーブンスの努力に大きく影響されました。リチャードの知恵と才能は、今日の仕様を作りました。共著者は、リチャードを大いに尊敬して長い間考えています。"
    },
    {
      "indent": 3,
      "text": "Thanks to the many people who made suggestions and provided feedback to this document, including:",
      "ja": "提案をし、このドキュメントにフィードバックを提供してくれた多くの人々に感謝します。"
    },
    {
      "indent": 3,
      "text": "Werner Almesberger, Ran Atkinson, Fred Baker, Dave Borman, Andrew Cherenson, Alex Conta, Alan Cox, Steve Deering, Richard Draves, Francis Dupont, Robert Elz, Brian Haberman, Jun-ichiro itojun Hagino, Marc Hasson, Tom Herbert, Bob Hinden, Wan-Yen Hsu, Christian Huitema, Koji Imada, Markus Jork, Ron Lee, Alan Lloyd, Charles Lynn, Dan McDonald, Dave Mitton, Finnbarr Murphy, Thomas Narten, Josh Osborne, Craig Partridge, Jean-Luc Richier, Bill Sommerfield, Erik Scoredos, Keith Sklower, JINMEI Tatuya, Dave Thaler, Matt Thomas, Harvey Thompson, Dean D. Throop, Karen Tracey, Glenn Trewitt, Paul Vixie, David Waitzman, Carl Williams, Kazu Yamamoto, Vlad Yasevich, Stig Venaas, and Brian Zill.",
      "ja": "Werner Almesberger、Atkinson、Fred Baker、Dave Borman、Andrew Cherenson、Alex Conta、Alan Cox、Steve Deering、Richard Draves、Francis Dupont、Robert Elz、Brian Haberman、Jun-ichiro Itojun Hagino、Marc Hasson、Tom Herbert、Tom Herber、Wan-yen Hsu、Christian Huitema、Koji Imada、Markus Jork、Ron Lee、Alan Lloyd、Charles Lynn、Dan McDonald、Dave Mitton、Finnbarr Murphy、Thomas Narten、Josh Osborne、Craig Partridge、Jean-Luc Richier、ビルマンエリックはスコアーズ、キース・スクラワー、ジンメイ・タトゥヤ、デイブ・ターラー、マット・トーマス、ハーベイ・トンプソン、ディーン・D・スループ、カレン・トレーシー、グレン・トレウィット、ポール・ビクシー、デビッド・ウェイツマン、カール・ウィリアムズ、ヤマモト、ヤマモト、ヴラッド・ヤセブイチ、スティギグナス、ブリアン・ジル、。"
    },
    {
      "indent": 3,
      "text": "The getaddrinfo() and getnameinfo() functions are taken from an earlier document by Keith Sklower. As noted in that document, William Durst, Steven Wise, Michael Karels, and Eric Allman provided many useful discussions on the subject of protocol-independent name-to-address translation, and reviewed early versions of Keith Sklower's original proposal. Eric Allman implemented the first prototype of getaddrinfo(). The observation that specifying the pair of name and service would suffice for connecting to a service independent of protocol details was made by Marshall Rose in a proposal to X/Open for a \"Uniform Network Interface\".",
      "ja": "getaddrinfo（）およびgetNameInfo（）関数は、Keith Sklowerによる以前のドキュメントから取得されます。その文書で述べたように、ウィリアム・ダースト、スティーブン・ワイズ、マイケル・カレル、およびエリック・オールマンは、プロトコルに依存しない名前からアドレスへの翻訳の主題について多くの有用な議論を提供し、キース・スクラワーの元の提案の初期バージョンをレビューしました。Eric Allmanは、getaddrinfo（）の最初のプロトタイプを実装しました。名前とサービスのペアを指定するだけで十分であるという観察は、プロトコルの詳細とは独立したサービスに接続するのに十分であるという観察は、「均一なネットワークインターフェイス」のX/Openの提案でMarshall Roseによって行われました。"
    },
    {
      "indent": 3,
      "text": "Craig Metz, Jack McCann, Erik Nordmark, Tim Hartrick, and Mukesh Kacker made many contributions to this document. Ramesh Govindan made a number of contributions and co-authored an earlier version of this memo.",
      "ja": "クレイグ・メッツ、ジャック・マッキャン、エリック・ノードマーク、ティム・ハートリック、ムケシュ・カッカーは、この文書に多くの貢献をしました。Ramesh Govindanは多くの貢献をし、このメモの以前のバージョンを共著しました。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11. 参考文献"
    },
    {
      "indent": 3,
      "text": "[1] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[1] Deering、S。and R. Hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[2] Hinden, R. and S. Deering, \"IP Version 6 Addressing Architecture\", RFC 2373, July 1998.",
      "ja": "[2] Hinden、R。and S. Deering、「IPバージョン6アドレス指定アーキテクチャ」、RFC 2373、1998年7月。"
    },
    {
      "indent": 3,
      "text": "[3] IEEE Std. 1003.1-2001 Standard for Information Technology -- Portable Operating System Interface (POSIX). Open Group Technical Standard: Base Specifications, Issue 6, December 2001. ISO/IEC 9945:2002. http://www.opengroup.org/austin",
      "ja": "[3] IEEE STD。1003.1-2001情報技術の標準 - ポータブルオペレーティングシステムインターフェイス（POSIX）。オープングループの技術標準：基本仕様、2001年12月、第6号。ISO/IEC 9945：2002。http://www.opengroup.org/austin"
    },
    {
      "indent": 3,
      "text": "[4] Stevens, W. and M. Thomas, \"Advanced Sockets API for IPv6\", RFC 2292, February 1998.",
      "ja": "[4] Stevens、W。およびM. Thomas、「IPv6のAdvanced Sockets API」、RFC 2292、1998年2月。"
    },
    {
      "indent": 3,
      "text": "[5] Nordmark, E., \"Stateless IP/ICMP Translation Algorithm (SIIT)\", RFC 2765, February 2000.",
      "ja": "[5] Nordmark、E。、「Stateless IP/ICMP翻訳アルゴリズム（SIIT）」、RFC 2765、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[6] The Open Group Base Working Group http://www.opengroup.org/platform/base.html",
      "ja": "[6] オープングループベースワーキンググループhttp://www.opengroup.org/platform/base.html"
    },
    {
      "indent": 0,
      "text": "12. Authors' Addresses",
      "section_title": true,
      "ja": "12. 著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Bob Gilligan Intransa, Inc. 2870 Zanker Rd. San Jose, CA 95134",
      "ja": "Bob Gilligan Intransa、Inc。2870 Zanker Rd。サンノゼ、CA 95134"
    },
    {
      "indent": 3,
      "text": "Phone: 408-678-8647 EMail: gilligan@intransa.com",
      "ja": "電話：408-678-8647メール：gilligan@intransa.com"
    },
    {
      "indent": 3,
      "text": "Susan Thomson Cisco Systems 499 Thornall Street, 8th floor Edison, NJ 08837",
      "ja": "スーザン・トムソン・シスコ・システム499 Thornall Street、8階・エジソン、ニュージャージー08837"
    },
    {
      "indent": 3,
      "text": "Phone: 732-635-3086 EMail: sethomso@cisco.com",
      "ja": "電話：732-635-3086メール：sethomso@cisco.com"
    },
    {
      "indent": 3,
      "text": "Jim Bound Hewlett-Packard Company 110 Spitbrook Road ZKO3-3/W20 Nashua, NH 03062",
      "ja": "Jim Bound Hewlett-Packard Company 110 Spitbrook Road ZKO3-3/W20 NASHUA、NH 03062"
    },
    {
      "indent": 3,
      "text": "Phone: 603-884-0062 EMail: Jim.Bound@hp.com",
      "ja": "電話：603-884-0062メール：jim.bound@hp.com"
    },
    {
      "indent": 3,
      "text": "Jack McCann Hewlett-Packard Company 110 Spitbrook Road ZKO3-3/W20 Nashua, NH 03062",
      "ja": "Jack McCann Hewlett-Packard Company 110 Spitbrook Road ZKO3-3/W20 NASHUA、NH 03062"
    },
    {
      "indent": 3,
      "text": "Phone: 603-884-2608 EMail: Jack.McCann@hp.com",
      "ja": "電話：603-884-2608メール：jack.mccann@hp.com"
    },
    {
      "indent": 0,
      "text": "13. Full Copyright Statement",
      "section_title": true,
      "ja": "13. 完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2003）。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書と本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}