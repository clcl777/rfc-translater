{
  "title": {
    "text": "RFC 3542 - Advanced Sockets Application Program Interface (API) for IPv6",
    "ja": "RFC 3542 - IPv6の高度なソケットアプリケーションプログラムインターフェイス（API）"
  },
  "number": 3542,
  "created_at": "2023-10-24 17:18:08.887821+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                         W. Stevens\nRequest for Comments: 3542                                     M. Thomas\nObsoletes: 2292                                               Consultant\nCategory: Informational                                      E. Nordmark\n                                                                     Sun\n                                                               T. Jinmei\n                                                                 Toshiba\n                                                                May 2003",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Advanced Sockets Application Program Interface (API) for IPv6",
      "ja": "IPv6の高度なソケットアプリケーションプログラムインターフェイス（API）"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモは、インターネットコミュニティに情報を提供します。いかなる種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2003）。無断転載を禁じます。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document provides sockets Application Program Interface (API) to support \"advanced\" IPv6 applications, as a supplement to a separate specification, RFC 3493. The expected applications include Ping, Traceroute, routing daemons and the like, which typically use raw sockets to access IPv6 or ICMPv6 header fields. This document proposes some portable interfaces for applications that use raw sockets under IPv6. There are other features of IPv6 that some applications will need to access: interface identification (specifying the outgoing interface and determining the incoming interface), IPv6 extension headers, and path Maximum Transmission Unit (MTU) information. This document provides API access to these features too. Additionally, some extended interfaces to libraries for the \"r\" commands are defined. The extension will provide better backward compatibility to existing implementations that are not IPv6-capable.",
      "ja": "このドキュメントは、Socketsアプリケーションプログラムインターフェイス（API）を提供して、「高度な」IPv6アプリケーションを別の仕様の補足としてサポートしています。RFC3493。IPv6またはICMPV6ヘッダーフィールド。このドキュメントでは、IPv6の下で生のソケットを使用するアプリケーション用のいくつかのポータブルインターフェイスを提案しています。IPv6には、一部のアプリケーションにアクセスする必要がある他の機能があります。インターフェイス識別（発信インターフェイスの指定と着信インターフェイスの決定）、IPv6拡張ヘッダー、およびパス最大伝送ユニット（MTU）情報。このドキュメントは、これらの機能へのAPIアクセスも提供します。さらに、「r」コマンドのライブラリへのいくつかの拡張インターフェイスが定義されています。この拡張機能は、IPv6対応ではない既存の実装により、より良い後方互換性を提供します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.   Introduction ..............................................  3\n2.   Common Structures and Definitions .........................  5\n     2.1  The ip6_hdr Structure ................................  6\n          2.1.1  IPv6 Next Header Values .......................  6\n          2.1.2  IPv6 Extension Headers ........................  7\n          2.1.3  IPv6 Options ..................................  8\n     2.2  The icmp6_hdr Structure .............................. 10\n          2.2.1  ICMPv6 Type and Code Values ................... 10\n          2.2.2  ICMPv6 Neighbor Discovery Definitions ......... 11\n          2.2.3  Multicast Listener Discovery Definitions ...... 14\n          2.2.4  ICMPv6 Router Renumbering Definitions ......... 14\n     2.3  Address Testing Macros ............................... 16\n     2.4  Protocols File ....................................... 16\n3.   IPv6 Raw Sockets .......................................... 17\n     3.1  Checksums ............................................ 18\n     3.2  ICMPv6 Type Filtering ................................ 19\n     3.3  ICMPv6 Verification of Received Packets .............. 22\n4.   Access to IPv6 and Extension Headers ...................... 22\n     4.1  TCP Implications ..................................... 24\n     4.2  UDP and Raw Socket Implications ...................... 25\n5.   Extensions to Socket Ancillary Data ....................... 26\n     5.1  CMSG_NXTHDR .......................................... 26\n     5.2  CMSG_SPACE ........................................... 26\n     5.3  CMSG_LEN ............................................. 27\n6.   Packet Information ........................................ 27\n     6.1  Specifying/Receiving the Interface ................... 28\n     6.2  Specifying/Receiving Source/Destination Address ...... 29\n     6.3  Specifying/Receiving the Hop Limit ................... 29\n     6.4  Specifying the Next Hop Address ...................... 30\n     6.5  Specifying/Receiving the Traffic Class value ......... 31\n     6.6  Additional Errors with sendmsg() and setsockopt() .... 32\n     6.7  Summary of Outgoing Interface Selection .............. 32\n7.   Routing Header Option ..................................... 33\n     7.1  inet6_rth_space ...................................... 35\n     7.2  inet6_rth_init ....................................... 35\n     7.3  inet6_rth_add ........................................ 36\n     7.4  inet6_rth_reverse .................................... 36\n     7.5  inet6_rth_segments ................................... 36\n     7.6  inet6_rth_getaddr .................................... 36\n8.   Hop-By-Hop Options ........................................ 37\n     8.1  Receiving Hop-by-Hop Options ......................... 38\n     8.2  Sending Hop-by-Hop Options ........................... 38\n9.   Destination Options ....................................... 39\n     9.1  Receiving Destination Options ........................ 39\n     9.2  Sending Destination Options .......................... 39\n10.  Hop-by-Hop and Destination Options Processing ............. 40",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "     10.1  inet6_opt_init ...................................... 41\n     10.2  inet6_opt_append .................................... 41\n     10.3  inet6_opt_finish .................................... 42\n     10.4  inet6_opt_set_val ................................... 42\n     10.5  inet6_opt_next ...................................... 42\n     10.6  inet6_opt_find ...................................... 43\n     10.7  inet6_opt_get_val ................................... 43\n11.  Additional Advanced API Functions ......................... 44\n     11.1  Sending with the Minimum MTU ........................ 44\n     11.2  Sending without Fragmentation ....................... 45\n     11.3  Path MTU Discovery and UDP .......................... 46\n     11.4  Determining the Current Path MTU .................... 47\n12.  Ordering of Ancillary Data and IPv6 Extension Headers ..... 48\n13.  IPv6-Specific Options with IPv4-Mapped IPv6 Addresses ..... 50\n14.  Extended interfaces for rresvport, rcmd and rexec ......... 51\n     14.1  rresvport_af ........................................ 51\n     14.2  rcmd_af ............................................. 51\n     14.3  rexec_af ............................................ 52\n15.  Summary of New Definitions ................................ 52\n16.  Security Considerations ................................... 56\n17.  Changes from RFC 2292 ..................................... 57\n18.  References ................................................ 59\n19.  Acknowledgments ........................................... 59\n20.  Appendix A: Ancillary Data Overview ....................... 60\n     20.1  The msghdr Structure ................................ 60\n     20.2  The cmsghdr Structure ............................... 61\n     20.3  Ancillary Data Object Macros ........................ 62\n           20.3.1  CMSG_FIRSTHDR ............................... 63\n           20.3.2  CMSG_NXTHDR ................................. 64\n           20.3.3  CMSG_DATA ................................... 65\n           20.3.4  CMSG_SPACE .................................. 65\n           20.3.5  CMSG_LEN .................................... 65\n21.  Appendix B: Examples Using the inet6_rth_XXX() Functions .. 65\n     21.1  Sending a Routing Header ............................ 65\n     21.2  Receiving Routing Headers ........................... 70\n22.  Appendix C: Examples Using the inet6_opt_XXX() Functions .. 72\n     22.1  Building Options .................................... 72\n     22.2  Parsing Received Options ............................ 74\n23.  Authors' Addresses ........................................ 76\n24.  Full Copyright Statement .................................. 77",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "A separate specification [RFC-3493] contains changes to the sockets API to support IP version 6. Those changes are for TCP and UDP-based applications. This document defines some of the \"advanced\" features of the sockets API that are required for applications to take advantage of additional features of IPv6.",
      "ja": "個別の仕様[RFC-3493]には、IPバージョン6をサポートするSockets APIの変更が含まれています。これらの変更は、TCPおよびUDPベースのアプリケーション用です。このドキュメントでは、IPv6の追加機能を活用するためにアプリケーションに必要なソケットAPIの「高度な」機能の一部を定義しています。"
    },
    {
      "indent": 3,
      "text": "Today, the portability of applications using IPv4 raw sockets is quite high, but this is mainly because most IPv4 implementations started from a common base (the Berkeley source code) or at least started with the Berkeley header files. This allows programs such as Ping and Traceroute, for example, to compile with minimal effort on many hosts that support the sockets API. With IPv6, however, there is no common source code base that implementors are starting from, and the possibility for divergence at this level between different implementations is high. To avoid a complete lack of portability amongst applications that use raw IPv6 sockets, some standardization is necessary.",
      "ja": "今日、IPv4 Raw Socketsを使用したアプリケーションの移植性は非常に高いですが、これは主に、ほとんどのIPv4実装が共通ベース（Berkeleyソースコード）から始まったか、少なくともBerkeley Headerファイルから始まったためです。これにより、たとえばPingやTracerouteなどのプログラムが、Sockets APIをサポートする多くのホストで最小限の労力でコンパイルできます。ただし、IPv6では、実装者が開始している一般的なソースコードベースはなく、異なる実装間のこのレベルでの発散の可能性が高いです。RAW IPv6ソケットを使用するアプリケーション間の携帯性の完全な不足を回避するには、いくつかの標準化が必要です。"
    },
    {
      "indent": 3,
      "text": "There are also features from the basic IPv6 specification that are not addressed in [RFC-3493]: sending and receiving Routing headers, Hop-by-Hop options, and Destination options, specifying the outgoing interface, being told of the receiving interface, and control of path MTU information.",
      "ja": "[RFC-3493]で対処されていない基本IPv6仕様の機能もあります。ルーティングヘッダーの送信と受信、ホップバイホップオプション、および目的地のオプション、発信インターフェイスの指定、受信インターフェイス、および受信インターフェイスの指定、およびパスMTU情報の制御。"
    },
    {
      "indent": 3,
      "text": "This document updates and replaces RFC 2292. This revision is based on implementation experience of RFC 2292, as well as some additional extensions that have been found to be useful through the IPv6 deployment. Note, however, that further work on this document may still be needed. Once the API specification becomes mature and is deployed among implementations, it may be formally standardized by a more appropriate body, such as has been done with the Basic API [RFC-3493].",
      "ja": "このドキュメントは、RFC 2292を更新および置き換えます。この改訂は、RFC 2292の実装エクスペリエンスと、IPv6展開を通じて有用であることがわかった追加の拡張機能に基づいています。ただし、このドキュメントでのさらなる作業がまだ必要になる場合があることに注意してください。API仕様が成熟し、実装の間に展開されると、基本的なAPI [RFC-3493]で行われたように、より適切な本体によって正式に標準化される可能性があります。"
    },
    {
      "indent": 3,
      "text": "This document can be divided into the following main sections.",
      "ja": "このドキュメントは、次のメインセクションに分けることができます。"
    },
    {
      "indent": 3,
      "text": "1. Definitions of the basic constants and structures required for applications to use raw IPv6 sockets. This includes structure definitions for the IPv6 and ICMPv6 headers and all associated constants (e.g., values for the Next Header field).",
      "ja": "1. RAW IPv6ソケットを使用するためにアプリケーションに必要な基本的な定数と構造の定義。これには、IPv6およびICMPV6ヘッダーの構造定義、および関連するすべての定数（次のヘッダーフィールドの値など）が含まれます。"
    },
    {
      "indent": 3,
      "text": "2. Some basic semantic definitions for IPv6 raw sockets. For example, a raw ICMPv4 socket requires the application to calculate and store the ICMPv4 header checksum. But with IPv6 this would require the application to choose the source IPv6 address because the source address is part of the pseudo header that ICMPv6 now uses for its checksum computation. It should be defined that with a raw ICMPv6 socket the kernel always calculates and stores the ICMPv6 header checksum.",
      "ja": "2. IPv6 RAWソケットの基本的なセマンティック定義。たとえば、RAW ICMPV4ソケットでは、ICMPV4ヘッダーチェックサムを計算および保存するためのアプリケーションが必要です。ただし、IPv6では、ソースアドレスがICMPv6が現在チェックサム計算に使用している擬似ヘッダーの一部であるため、ソースIPv6アドレスを選択するためにアプリケーションが必要になります。生のICMPv6ソケットでは、カーネルは常にICMPV6ヘッダーチェックサムを計算して保存することを定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "3. Packet information: how applications can obtain the received interface, destination address, and received hop limit, along with specifying these values on a per-packet basis. There are a class of applications that need this capability and the technique should be portable.",
      "ja": "3. パケット情報：アプリケーションが受信されたインターフェイス、宛先アドレス、および受信ホップ制限を取得する方法と、パケットごとにこれらの値を指定します。この機能を必要とするアプリケーションのクラスがあり、テクニックはポータブルでなければなりません。"
    },
    {
      "indent": 3,
      "text": "4. Access to the optional Routing header, Hop-by-Hop options, and Destination options extension headers.",
      "ja": "4. オプションのルーティングヘッダー、ホップバイホップオプション、および宛先オプション拡張ヘッダーへのアクセス。"
    },
    {
      "indent": 3,
      "text": "5. Additional features required for improved IPv6 application portability.",
      "ja": "5. IPv6アプリケーションのポータビリティを改善するために必要な追加機能。"
    },
    {
      "indent": 3,
      "text": "The packet information along with access to the extension headers (Routing header, Hop-by-Hop options, and Destination options) are specified using the \"ancillary data\" fields that were added to the 4.3BSD Reno sockets API in 1990. The reason is that these ancillary data fields are part of the Posix standard [POSIX] and should therefore be adopted by most vendors.",
      "ja": "拡張ヘッダーへのアクセス（ルーティングヘッダー、ホップバイホップオプション、および宛先オプション）へのパケット情報は、1990年に4.3bsd Reno Sockets APIに追加された「補助データ」フィールドを使用して指定されています。これらの補助データフィールドはPOSIX標準[POSIX]の一部であるため、ほとんどのベンダーが採用する必要があります。"
    },
    {
      "indent": 3,
      "text": "This document does not address application access to either the authentication header or the encapsulating security payload header.",
      "ja": "このドキュメントでは、認証ヘッダーまたはカプセル化セキュリティペイロードヘッダーへのアプリケーションアクセスには対応していません。"
    },
    {
      "indent": 3,
      "text": "Many examples in this document omit error checking in favor of brevity and clarity.",
      "ja": "このドキュメントの多くの例は、簡潔さと明確さを支持してエラーチェックを省略します。"
    },
    {
      "indent": 3,
      "text": "We note that some of the functions and socket options defined in this document may have error returns that are not defined in this document. Some of these possible error returns will be recognized only as implementations proceed.",
      "ja": "このドキュメントで定義されている機能とソケットオプションの一部には、このドキュメントで定義されていないエラーリターンがある場合があることに注意してください。これらの可能なエラーリターンの一部は、実装が進むにつれてのみ認識されます。"
    },
    {
      "indent": 3,
      "text": "Datatypes in this document follow the Posix format: intN_t means a signed integer of exactly N bits (e.g., int16_t) and uintN_t means an unsigned integer of exactly N bits (e.g., uint32_t).",
      "ja": "このドキュメントのデータタイプは、POSIX形式に従います。INTN_Tとは、正確なnビット（int16_tなど）の署名された整数を意味し、uintn_tは正確なnビット（uint32_tなど）の符号なし整数を意味します。"
    },
    {
      "indent": 3,
      "text": "Note that we use the (unofficial) terminology ICMPv4, IGMPv4, and ARPv4 to avoid any confusion with the newer ICMPv6 protocol.",
      "ja": "新しいICMPV6プロトコルとの混乱を避けるために、（非公式の）用語ICMPV4、IGMPV4、およびARPV4を使用していることに注意してください。"
    },
    {
      "indent": 0,
      "text": "2. Common Structures and Definitions",
      "section_title": true,
      "ja": "2. 一般的な構造と定義"
    },
    {
      "indent": 3,
      "text": "Many advanced applications examine fields in the IPv6 header and set and examine fields in the various ICMPv6 headers. Common structure definitions for these protocol headers are required, along with common constant definitions for the structure members.",
      "ja": "多くの高度なアプリケーションがIPv6ヘッダーのフィールドを調べ、さまざまなICMPv6ヘッダーのフィールドを設定および調べます。これらのプロトコルヘッダーの共通構造定義と、構造メンバーの共通定義定義が必要です。"
    },
    {
      "indent": 3,
      "text": "This API assumes that the fields in the protocol headers are left in the network byte order, which is big-endian for the Internet protocols. If not, then either these constants or the fields being tested must be converted at run-time, using something like htons() or htonl().",
      "ja": "このAPIは、プロトコルヘッダーのフィールドがネットワークバイト順序で残されていると想定しています。そうでない場合は、これらの定数またはテスト対象のフィールドのいずれかを、htons（）やhtonl（）のようなものを使用して、実行時に変換する必要があります。"
    },
    {
      "indent": 3,
      "text": "Two new header files are defined: <netinet/ip6.h> and <netinet/icmp6.h>.",
      "ja": "2つの新しいヘッダーファイルが定義されています：<netinet/ip6.h>と<netinet/icmp6.h>。"
    },
    {
      "indent": 3,
      "text": "When an include file is specified, that include file is allowed to include other files that do the actual declaration or definition.",
      "ja": "含まれるファイルが指定されている場合、ファイルには実際の宣言または定義を実行する他のファイルを含めることができます。"
    },
    {
      "indent": 0,
      "text": "2.1. The ip6_hdr Structure",
      "section_title": true,
      "ja": "2.1. IP6_HDR構造"
    },
    {
      "indent": 3,
      "text": "The following structure is defined as a result of including <netinet/ip6.h>. Note that this is a new header.",
      "ja": "次の構造は、<netinet/ip6.h>を含めた結果として定義されます。これは新しいヘッダーであることに注意してください。"
    },
    {
      "indent": 6,
      "text": "struct ip6_hdr {\n  union {\n    struct ip6_hdrctl {\n      uint32_t ip6_un1_flow; /* 4 bits version, 8 bits TC, 20 bits\n                                flow-ID */\n      uint16_t ip6_un1_plen; /* payload length */\n      uint8_t  ip6_un1_nxt;  /* next header */\n      uint8_t  ip6_un1_hlim; /* hop limit */\n    } ip6_un1;\n    uint8_t ip6_un2_vfc;     /* 4 bits version, top 4 bits\n                                tclass */\n  } ip6_ctlun;\n  struct in6_addr ip6_src;   /* source address */\n  struct in6_addr ip6_dst;   /* destination address */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define ip6_vfc ip6_ctlun.ip6_un2_vfc #define ip6_flow ip6_ctlun.ip6_un1.ip6_un1_flow #define ip6_plen ip6_ctlun.ip6_un1.ip6_un1_plen #define ip6_nxt ip6_ctlun.ip6_un1.ip6_un1_nxt #define ip6_hlim ip6_ctlun.ip6_un1.ip6_un1_hlim #define ip6_hops ip6_ctlun.ip6_un1.ip6_un1_hlim",
      "ja": "＃DEFINE IP6_VFC IP6_CTLUN.IP6_UN2_VFC #DEFINE IP6_FLOW IP6_CTLUN.IP6_UN1.IP6_UN1_FLOW #DEFINE IP6_PLEN IP6_CTLUN.IP6_UN1.IP6_UN1_PLEN hlim ip6_ctlun.ip6_un1.ip6_un1_hlim #define ip6_hops ip6_ctlun.ip6_un1.ip6_un1_hlim"
    },
    {
      "indent": 0,
      "text": "2.1.1. IPv6 Next Header Values",
      "section_title": true,
      "ja": "2.1.1. IPv6次のヘッダー値"
    },
    {
      "indent": 3,
      "text": "IPv6 defines many new values for the Next Header field. The following constants are defined as a result of including <netinet/in.h>.",
      "ja": "IPv6は、次のヘッダーフィールドの多くの新しい値を定義します。次の定数は、<netinet/in.h>を含める結果として定義されます。"
    },
    {
      "indent": 6,
      "text": "#define IPPROTO_HOPOPTS   0   /* IPv6 Hop-by-Hop options */\n#define IPPROTO_IPV6     41   /* IPv6 header */\n#define IPPROTO_ROUTING  43   /* IPv6 Routing header */\n#define IPPROTO_FRAGMENT 44   /* IPv6 fragment header */\n#define IPPROTO_ESP      50   /* encapsulating security payload */\n#define IPPROTO_AH       51   /* authentication header */\n#define IPPROTO_ICMPV6   58   /* ICMPv6 */\n#define IPPROTO_NONE     59   /* IPv6 no next header */\n#define IPPROTO_DSTOPTS  60   /* IPv6 Destination options */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Berkeley-derived IPv4 implementations also define IPPROTO_IP to be 0. This should not be a problem since IPPROTO_IP is used only with IPv4 sockets and IPPROTO_HOPOPTS only with IPv6 sockets.",
      "ja": "Berkeley由来のIPv4実装は、IPPROTO_IPが0であると定義しています。IPPROTO_IPはIPv4ソケットでのみ使用されるため、IPv6ソケットでのみIpproto_hopoptsでのみ使用されるため、これは問題ではありません。"
    },
    {
      "indent": 0,
      "text": "2.1.2. IPv6 Extension Headers",
      "section_title": true,
      "ja": "2.1.2. IPv6拡張ヘッダー"
    },
    {
      "indent": 3,
      "text": "Six extension headers are defined for IPv6. We define structures for all except the Authentication header and Encapsulating Security Payload header, both of which are beyond the scope of this document. The following structures are defined as a result of including <netinet/ip6.h>.",
      "ja": "IPv6用に6つの拡張ヘッダーが定義されています。認証ヘッダーを除くすべての構造を定義し、セキュリティペイロードヘッダーをカプセル化します。どちらもこのドキュメントの範囲を超えています。次の構造は、<netinet/ip6.h>を含めた結果として定義されます。"
    },
    {
      "indent": 6,
      "text": "/* Hop-by-Hop options header */\nstruct ip6_hbh {\n  uint8_t  ip6h_nxt;        /* next header */\n  uint8_t  ip6h_len;        /* length in units of 8 octets */\n    /* followed by options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Destination options header */\nstruct ip6_dest {\n  uint8_t  ip6d_nxt;        /* next header */\n  uint8_t  ip6d_len;        /* length in units of 8 octets */\n    /* followed by options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Routing header */\nstruct ip6_rthdr {\n  uint8_t  ip6r_nxt;        /* next header */\n  uint8_t  ip6r_len;        /* length in units of 8 octets */\n  uint8_t  ip6r_type;       /* routing type */\n  uint8_t  ip6r_segleft;    /* segments left */\n    /* followed by routing type specific data */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Type 0 Routing header */\nstruct ip6_rthdr0 {\n  uint8_t  ip6r0_nxt;       /* next header */\n  uint8_t  ip6r0_len;       /* length in units of 8 octets */\n  uint8_t  ip6r0_type;      /* always zero */\n  uint8_t  ip6r0_segleft;   /* segments left */\n  uint32_t ip6r0_reserved;  /* reserved field */\n    /* followed by up to 127 struct in6_addr */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Fragment header */\nstruct ip6_frag {\n  uint8_t   ip6f_nxt;       /* next header */\n  uint8_t   ip6f_reserved;  /* reserved field */\n  uint16_t  ip6f_offlg;     /* offset, reserved, and flag */\n  uint32_t  ip6f_ident;     /* identification */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#if     BYTE_ORDER == BIG_ENDIAN\n#define IP6F_OFF_MASK       0xfff8  /* mask out offset from\n                                       ip6f_offlg */\n#define IP6F_RESERVED_MASK  0x0006  /* reserved bits in\n                                       ip6f_offlg */\n#define IP6F_MORE_FRAG      0x0001  /* more-fragments flag */\n#else   /* BYTE_ORDER == LITTLE_ENDIAN */\n#define IP6F_OFF_MASK       0xf8ff  /* mask out offset from\n                                       ip6f_offlg */\n#define IP6F_RESERVED_MASK  0x0600  /* reserved bits in\n                                       ip6f_offlg */\n#define IP6F_MORE_FRAG      0x0100  /* more-fragments flag */\n#endif",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.1.3. IPv6 Options",
      "section_title": true,
      "ja": "2.1.3. IPv6オプション"
    },
    {
      "indent": 3,
      "text": "Several options are defined for IPv6, and we define structures and macro definitions for some of them below. The following structures are defined as a result of including <netinet/ip6.h>.",
      "ja": "IPv6に対していくつかのオプションが定義されており、以下の一部の構造とマクロ定義を定義します。次の構造は、<netinet/ip6.h>を含めた結果として定義されます。"
    },
    {
      "indent": 6,
      "text": "/* IPv6 options */\nstruct ip6_opt {\n  uint8_t  ip6o_type;\n  uint8_t  ip6o_len;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/*\n * The high-order 3 bits of the option type define the behavior\n * when processing an unknown option and whether or not the option\n * content changes in flight.\n */\n#define IP6OPT_TYPE(o)        ((o) & 0xc0)\n#define IP6OPT_TYPE_SKIP      0x00\n#define IP6OPT_TYPE_DISCARD   0x40\n#define IP6OPT_TYPE_FORCEICMP 0x80\n#define IP6OPT_TYPE_ICMP      0xc0\n#define IP6OPT_MUTABLE        0x20",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define IP6OPT_PAD1           0x00  /* 00 0 00000 */\n#define IP6OPT_PADN           0x01  /* 00 0 00001 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define IP6OPT_JUMBO          0xc2  /* 11 0 00010 */\n#define IP6OPT_NSAP_ADDR      0xc3  /* 11 0 00011 */\n#define IP6OPT_TUNNEL_LIMIT   0x04  /* 00 0 00100 */\n#define IP6OPT_ROUTER_ALERT   0x05  /* 00 0 00101 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Jumbo Payload Option */\nstruct ip6_opt_jumbo {\n  uint8_t  ip6oj_type;\n  uint8_t  ip6oj_len;\n  uint8_t  ip6oj_jumbo_len[4];\n};\n#define IP6OPT_JUMBO_LEN   6",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* NSAP Address Option */\nstruct ip6_opt_nsap {\n  uint8_t  ip6on_type;\n  uint8_t  ip6on_len;\n  uint8_t  ip6on_src_nsap_len;\n  uint8_t  ip6on_dst_nsap_len;\n    /* followed by source NSAP */\n    /* followed by destination NSAP */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Tunnel Limit Option */\nstruct ip6_opt_tunnel {\n  uint8_t  ip6ot_type;\n  uint8_t  ip6ot_len;\n  uint8_t  ip6ot_encap_limit;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Router Alert Option */\nstruct ip6_opt_router {\n  uint8_t  ip6or_type;\n  uint8_t  ip6or_len;\n  uint8_t  ip6or_value[2];\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Router alert values (in network byte order) */\n#ifdef _BIG_ENDIAN\n#define IP6_ALERT_MLD      0x0000\n#define IP6_ALERT_RSVP     0x0001\n#define  IP6_ALERT_AN      0x0002\n#else\n#define IP6_ALERT_MLD      0x0000\n#define IP6_ALERT_RSVP     0x0100\n#define IP6_ALERT_AN       0x0200\n#endif",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.2. The icmp6_hdr Structure",
      "section_title": true,
      "ja": "2.2. ICMP6_HDR構造"
    },
    {
      "indent": 3,
      "text": "The ICMPv6 header is needed by numerous IPv6 applications including Ping, Traceroute, router discovery daemons, and neighbor discovery daemons. The following structure is defined as a result of including <netinet/icmp6.h>. Note that this is a new header.",
      "ja": "ICMPV6ヘッダーは、Ping、Traceroute、Router Discovery Daemons、Neighbor Discovery Daemonsなど、多数のIPv6アプリケーションに必要です。次の構造は、<netinet/icmp6.h>を含めた結果として定義されます。これは新しいヘッダーであることに注意してください。"
    },
    {
      "indent": 6,
      "text": "struct icmp6_hdr {\n  uint8_t     icmp6_type;   /* type field */\n  uint8_t     icmp6_code;   /* code field */\n  uint16_t    icmp6_cksum;  /* checksum field */\n  union {\n    uint32_t  icmp6_un_data32[1]; /* type-specific field */\n    uint16_t  icmp6_un_data16[2]; /* type-specific field */\n    uint8_t   icmp6_un_data8[4];  /* type-specific field */\n  } icmp6_dataun;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define icmp6_data32    icmp6_dataun.icmp6_un_data32\n#define icmp6_data16    icmp6_dataun.icmp6_un_data16\n#define icmp6_data8     icmp6_dataun.icmp6_un_data8\n#define icmp6_pptr      icmp6_data32[0]  /* parameter prob */\n#define icmp6_mtu       icmp6_data32[0]  /* packet too big */\n#define icmp6_id        icmp6_data16[0]  /* echo request/reply */\n#define icmp6_seq       icmp6_data16[1]  /* echo request/reply */\n#define icmp6_maxdelay  icmp6_data16[0]  /* mcast group\n                                            membership */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.2.1. ICMPv6 Type and Code Values",
      "section_title": true,
      "ja": "2.2.1. ICMPV6タイプとコード値"
    },
    {
      "indent": 3,
      "text": "In addition to a common structure for the ICMPv6 header, common definitions are required for the ICMPv6 type and code fields. The following constants are also defined as a result of including <netinet/icmp6.h>.",
      "ja": "ICMPV6ヘッダーの共通構造に加えて、ICMPV6タイプとコードフィールドに共通の定義が必要です。次の定数は、<netinet/icmp6.h>を含めた結果として定義されます。"
    },
    {
      "indent": 6,
      "text": "#define ICMP6_DST_UNREACH             1\n#define ICMP6_PACKET_TOO_BIG          2\n#define ICMP6_TIME_EXCEEDED           3\n#define ICMP6_PARAM_PROB              4",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define ICMP6_INFOMSG_MASK  0x80    /* all informational\n                                       messages */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define ICMP6_ECHO_REQUEST          128\n#define ICMP6_ECHO_REPLY            129",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define ICMP6_DST_UNREACH_NOROUTE     0 /* no route to\n                                           destination */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define ICMP6_DST_UNREACH_ADMIN       1 /* communication with\n                                           destination */\n                                        /* admin. prohibited */\n#define ICMP6_DST_UNREACH_BEYONDSCOPE 2 /* beyond scope of source\n                                           address */\n#define ICMP6_DST_UNREACH_ADDR        3 /* address unreachable */\n#define ICMP6_DST_UNREACH_NOPORT      4 /* bad port */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define ICMP6_TIME_EXCEED_TRANSIT     0 /* Hop Limit == 0 in\n                                           transit */\n#define ICMP6_TIME_EXCEED_REASSEMBLY  1 /* Reassembly time out */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define ICMP6_PARAMPROB_HEADER        0 /* erroneous header\n                                           field */\n#define ICMP6_PARAMPROB_NEXTHEADER    1 /* unrecognized\n                                           Next Header */\n#define ICMP6_PARAMPROB_OPTION        2 /* unrecognized\n                                           IPv6 option */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The five ICMP message types defined by IPv6 neighbor discovery (133- 137) are defined in the next section.",
      "ja": "IPv6 Neighbor Discovery（133-137）によって定義された5つのICMPメッセージタイプは、次のセクションで定義されています。"
    },
    {
      "indent": 0,
      "text": "2.2.2. ICMPv6 Neighbor Discovery Definitions",
      "section_title": true,
      "ja": "2.2.2. ICMPV6ネイバーディスカバリー定義"
    },
    {
      "indent": 3,
      "text": "The following structures and definitions are defined as a result of including <netinet/icmp6.h>.",
      "ja": "以下の構造と定義は、<netinet/icmp6.h>を含めた結果として定義されます。"
    },
    {
      "indent": 6,
      "text": "#define ND_ROUTER_SOLICIT           133\n#define ND_ROUTER_ADVERT            134\n#define ND_NEIGHBOR_SOLICIT         135\n#define ND_NEIGHBOR_ADVERT          136\n#define ND_REDIRECT                 137",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct nd_router_solicit {     /* router solicitation */\n  struct icmp6_hdr  nd_rs_hdr;\n    /* could be followed by options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define nd_rs_type               nd_rs_hdr.icmp6_type\n#define nd_rs_code               nd_rs_hdr.icmp6_code\n#define nd_rs_cksum              nd_rs_hdr.icmp6_cksum\n#define nd_rs_reserved           nd_rs_hdr.icmp6_data32[0]\n      struct nd_router_advert {      /* router advertisement */\n  struct icmp6_hdr  nd_ra_hdr;\n  uint32_t   nd_ra_reachable;   /* reachable time */\n  uint32_t   nd_ra_retransmit;  /* retransmit timer */\n    /* could be followed by options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define nd_ra_type               nd_ra_hdr.icmp6_type\n#define nd_ra_code               nd_ra_hdr.icmp6_code\n#define nd_ra_cksum              nd_ra_hdr.icmp6_cksum\n#define nd_ra_curhoplimit        nd_ra_hdr.icmp6_data8[0]\n#define nd_ra_flags_reserved     nd_ra_hdr.icmp6_data8[1]\n#define ND_RA_FLAG_MANAGED       0x80\n#define ND_RA_FLAG_OTHER         0x40\n#define nd_ra_router_lifetime    nd_ra_hdr.icmp6_data16[1]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct nd_neighbor_solicit {   /* neighbor solicitation */\n  struct icmp6_hdr  nd_ns_hdr;\n  struct in6_addr   nd_ns_target; /* target address */\n    /* could be followed by options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define nd_ns_type               nd_ns_hdr.icmp6_type\n#define nd_ns_code               nd_ns_hdr.icmp6_code\n#define nd_ns_cksum              nd_ns_hdr.icmp6_cksum\n#define nd_ns_reserved           nd_ns_hdr.icmp6_data32[0]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct nd_neighbor_advert {    /* neighbor advertisement */\n  struct icmp6_hdr  nd_na_hdr;\n  struct in6_addr   nd_na_target; /* target address */\n    /* could be followed by options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define nd_na_type               nd_na_hdr.icmp6_type\n#define nd_na_code               nd_na_hdr.icmp6_code\n#define nd_na_cksum              nd_na_hdr.icmp6_cksum\n#define nd_na_flags_reserved     nd_na_hdr.icmp6_data32[0]\n#if     BYTE_ORDER == BIG_ENDIAN\n#define ND_NA_FLAG_ROUTER        0x80000000\n#define ND_NA_FLAG_SOLICITED     0x40000000\n#define ND_NA_FLAG_OVERRIDE      0x20000000\n#else   /* BYTE_ORDER == LITTLE_ENDIAN */\n#define ND_NA_FLAG_ROUTER        0x00000080\n#define ND_NA_FLAG_SOLICITED     0x00000040\n#define ND_NA_FLAG_OVERRIDE      0x00000020\n#endif\n      struct nd_redirect {           /* redirect */\n  struct icmp6_hdr  nd_rd_hdr;\n  struct in6_addr   nd_rd_target; /* target address */\n  struct in6_addr   nd_rd_dst;    /* destination address */\n    /* could be followed by options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define nd_rd_type               nd_rd_hdr.icmp6_type\n#define nd_rd_code               nd_rd_hdr.icmp6_code\n#define nd_rd_cksum              nd_rd_hdr.icmp6_cksum\n#define nd_rd_reserved           nd_rd_hdr.icmp6_data32[0]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct nd_opt_hdr {         /* Neighbor discovery option header */\n  uint8_t  nd_opt_type;\n  uint8_t  nd_opt_len;      /* in units of 8 octets */\n    /* followed by option specific data */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define ND_OPT_SOURCE_LINKADDR 1 #define ND_OPT_TARGET_LINKADDR 2 #define ND_OPT_PREFIX_INFORMATION 3 #define ND_OPT_REDIRECTED_HEADER 4 #define ND_OPT_MTU 5",
      "ja": "#define nd_opt_source_linkaddr 1 #define nd_opt_target_linkaddr 2 #define nd_opt_prefix_information 3 #define nd_opt_redirection_header 4 #define nd_opt_mtu 5 5"
    },
    {
      "indent": 6,
      "text": "struct nd_opt_prefix_info {    /* prefix information */\n  uint8_t   nd_opt_pi_type;\n  uint8_t   nd_opt_pi_len;\n  uint8_t   nd_opt_pi_prefix_len;\n  uint8_t   nd_opt_pi_flags_reserved;\n  uint32_t  nd_opt_pi_valid_time;\n  uint32_t  nd_opt_pi_preferred_time;\n  uint32_t  nd_opt_pi_reserved2;\n  struct in6_addr  nd_opt_pi_prefix;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define ND_OPT_PI_FLAG_ONLINK 0x80 #define ND_OPT_PI_FLAG_AUTO 0x40",
      "ja": "#define nd_opt_pi_flag_onlink 0x80 #define nd_opt_pi_flag_auto 0x40"
    },
    {
      "indent": 6,
      "text": "struct nd_opt_rd_hdr {         /* redirected header */\n  uint8_t   nd_opt_rh_type;\n  uint8_t   nd_opt_rh_len;\n  uint16_t  nd_opt_rh_reserved1;\n  uint32_t  nd_opt_rh_reserved2;\n    /* followed by IP header and data */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct nd_opt_mtu {            /* MTU option */\n  uint8_t   nd_opt_mtu_type;\n  uint8_t   nd_opt_mtu_len;\n  uint16_t  nd_opt_mtu_reserved;\n  uint32_t  nd_opt_mtu_mtu;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "We note that the nd_na_flags_reserved flags have the same byte ordering problems as we showed with ip6f_offlg.",
      "ja": "ND_NA_FLAGS_Reservedフラグには、IP6F_OFFLGで示したのと同じバイト順序付けの問題があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "2.2.3. Multicast Listener Discovery Definitions",
      "section_title": true,
      "ja": "2.2.3. マルチキャストリスナーの発見定義"
    },
    {
      "indent": 3,
      "text": "The following structures and definitions are defined as a result of including <netinet/icmp6.h>.",
      "ja": "以下の構造と定義は、<netinet/icmp6.h>を含めた結果として定義されます。"
    },
    {
      "indent": 6,
      "text": "#define MLD_LISTENER_QUERY 130 #define MLD_LISTENER_REPORT 131 #define MLD_LISTENER_REDUCTION 132",
      "ja": "#define mld_listener_query 130 #define mld_listener_report 131 #define mld_listener_reduction 132"
    },
    {
      "indent": 6,
      "text": "struct mld_hdr {\n  struct icmp6_hdr  mld_icmp6_hdr;\n  struct in6_addr   mld_addr; /* multicast address */\n};\n#define mld_type                 mld_icmp6_hdr.icmp6_type\n#define mld_code                 mld_icmp6_hdr.icmp6_code\n#define mld_cksum                mld_icmp6_hdr.icmp6_cksum\n#define mld_maxdelay             mld_icmp6_hdr.icmp6_data16[0]\n#define mld_reserved             mld_icmp6_hdr.icmp6_data16[1]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.2.4. ICMPv6 Router Renumbering Definitions",
      "section_title": true,
      "ja": "2.2.4. ICMPV6ルーターの変更定義"
    },
    {
      "indent": 3,
      "text": "The following structures and definitions are defined as a result of including <netinet/icmp6.h>.",
      "ja": "以下の構造と定義は、<netinet/icmp6.h>を含めた結果として定義されます。"
    },
    {
      "indent": 6,
      "text": "#define ICMP6_ROUTER_RENUMBERING    138   /* router renumbering */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct icmp6_router_renum {  /* router renumbering header */\n  struct icmp6_hdr  rr_hdr;\n  uint8_t           rr_segnum;\n  uint8_t           rr_flags;\n  uint16_t          rr_maxdelay;\n  uint32_t          rr_reserved;\n};\n#define rr_type                  rr_hdr.icmp6_type\n#define rr_code                  rr_hdr.icmp6_code\n#define rr_cksum                 rr_hdr.icmp6_cksum\n#define rr_seqnum                rr_hdr.icmp6_data32[0]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Router renumbering flags */\n#define ICMP6_RR_FLAGS_TEST        0x80\n#define ICMP6_RR_FLAGS_REQRESULT   0x40\n#define ICMP6_RR_FLAGS_FORCEAPPLY  0x20\n#define ICMP6_RR_FLAGS_SPECSITE    0x10\n#define ICMP6_RR_FLAGS_PREVDONE    0x08",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct rr_pco_match {    /* match prefix part */\n  uint8_t          rpm_code;\n  uint8_t          rpm_len;\n  uint8_t          rpm_ordinal;\n  uint8_t          rpm_matchlen;\n  uint8_t          rpm_minlen;\n  uint8_t          rpm_maxlen;\n  uint16_t         rpm_reserved;\n  struct in6_addr  rpm_prefix;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* PCO code values */\n#define RPM_PCO_ADD              1\n#define RPM_PCO_CHANGE           2\n#define RPM_PCO_SETGLOBAL        3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct rr_pco_use {    /* use prefix part */\n  uint8_t          rpu_uselen;\n  uint8_t          rpu_keeplen;\n  uint8_t          rpu_ramask;\n  uint8_t          rpu_raflags;\n  uint32_t         rpu_vltime;\n  uint32_t         rpu_pltime;\n  uint32_t         rpu_flags;\n  struct in6_addr  rpu_prefix;\n};\n#define ICMP6_RR_PCOUSE_RAFLAGS_ONLINK   0x20\n#define ICMP6_RR_PCOUSE_RAFLAGS_AUTO     0x10",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#if BYTE_ORDER == BIG_ENDIAN\n#define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME 0x80000000\n#define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME 0x40000000\n#elif BYTE_ORDER == LITTLE_ENDIAN\n#define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME 0x80\n#define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME 0x40\n#endif\n      struct rr_result {    /* router renumbering result message */\n  uint16_t         rrr_flags;\n  uint8_t          rrr_ordinal;\n  uint8_t          rrr_matchedlen;\n  uint32_t         rrr_ifid;\n  struct in6_addr  rrr_prefix;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#if BYTE_ORDER == BIG_ENDIAN\n#define ICMP6_RR_RESULT_FLAGS_OOB        0x0002\n#define ICMP6_RR_RESULT_FLAGS_FORBIDDEN  0x0001\n#elif BYTE_ORDER == LITTLE_ENDIAN\n#define ICMP6_RR_RESULT_FLAGS_OOB        0x0200\n#define ICMP6_RR_RESULT_FLAGS_FORBIDDEN  0x0100\n#endif",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.3. Address Testing Macros",
      "section_title": true,
      "ja": "2.3. マクロのアドレステスト"
    },
    {
      "indent": 3,
      "text": "The basic API ([RFC-3493]) defines some macros for testing an IPv6 address for certain properties. This API extends those definitions with additional address testing macros, defined as a result of including <netinet/in.h>.",
      "ja": "基本的なAPI（[RFC-3493]）は、特定のプロパティのIPv6アドレスをテストするためのマクロを定義します。このAPIは、これらの定義を追加のアドレステストマクロで拡張します。これは、<netinet/in.h>を含めた結果として定義されます。"
    },
    {
      "indent": 6,
      "text": "int  IN6_ARE_ADDR_EQUAL(const struct in6_addr *,\n                        const struct in6_addr *);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This macro returns non-zero if the addresses are equal; otherwise it returns zero.",
      "ja": "アドレスが等しい場合、このマクロはゼロ以外を返します。それ以外の場合は、ゼロを返します。"
    },
    {
      "indent": 0,
      "text": "2.4. Protocols File",
      "section_title": true,
      "ja": "2.4. プロトコルファイル"
    },
    {
      "indent": 3,
      "text": "Many hosts provide the file /etc/protocols that contains the names of the various IP protocols and their protocol number (e.g., the value of the protocol field in the IPv4 header for that protocol, such as 1 for ICMP). Some programs then call the function getprotobyname() to obtain the protocol value that is then specified as the third argument to the socket() function. For example, the Ping program contains code of the form",
      "ja": "多くのホストは、さまざまなIPプロトコルの名前とそのプロトコル番号を含むファイル /etc /プロトコルを提供します（たとえば、ICMPの1など、そのプロトコルのIPv4ヘッダーのプロトコルフィールドの値）。一部のプログラムは、関数getProtobyname（）を呼び出して、ソケット（）関数の3番目の引数として指定されるプロトコル値を取得します。たとえば、Pingプログラムにはフォームのコードが含まれています"
    },
    {
      "indent": 6,
      "text": "struct protoent *proto;",
      "ja": "struct protoent *proto;"
    },
    {
      "indent": 6,
      "text": "proto = getprotobyname(\"icmp\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "s = socket(AF_INET, SOCK_RAW, proto->p_proto);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Common names are required for the new IPv6 protocols in this file, to provide portability of applications that call the getprotoXXX() functions.",
      "ja": "このファイルの新しいIPv6プロトコルには、getProtoxxx（）関数を呼び出すアプリケーションの移植性を提供するために、共通名が必要です。"
    },
    {
      "indent": 3,
      "text": "We define the following protocol names with the values shown. These are taken under http://www.iana.org/numbers.html.",
      "ja": "表示されている値で次のプロトコル名を定義します。これらはhttp://www.iana.org/numbers.htmlで撮影されています。"
    },
    {
      "indent": 6,
      "text": "hopopt           0    # hop-by-hop options for ipv6\nipv6            41    # ipv6\nipv6-route      43    # routing header for ipv6\nipv6-frag       44    # fragment header for ipv6\nesp             50    # encapsulating security payload for ipv6\nah              51    # authentication header for ipv6\nipv6-icmp       58    # icmp for ipv6\nipv6-nonxt      59    # no next header for ipv6\nipv6-opts       60    # destination options for ipv6",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3. IPv6 Raw Sockets",
      "section_title": true,
      "ja": "3. IPv6 RAWソケット"
    },
    {
      "indent": 3,
      "text": "Raw sockets bypass the transport layer (TCP or UDP). With IPv4, raw sockets are used to access ICMPv4, IGMPv4, and to read and write IPv4 datagrams containing a protocol field that the kernel does not process. An example of the latter is a routing daemon for OSPF, since it uses IPv4 protocol field 89. With IPv6 raw sockets will be used for ICMPv6 and to read and write IPv6 datagrams containing a Next Header field that the kernel does not process. Examples of the latter are a routing daemon for OSPF for IPv6 and RSVP (protocol field 46).",
      "ja": "生のソケットは、輸送層（TCPまたはUDP）をバイパスします。IPv4を使用すると、RAWソケットを使用してICMPV4、IGMPV4にアクセスし、カーネルが処理しないプロトコルフィールドを含むIPv4データグラムの読み取りと書き込みです。後者の例は、IPv4プロトコルフィールド89を使用しているため、OSPFのルーティングデーモンです。IPv6のソケットを使用してICMPv6に使用され、カーネルが処理しない次のヘッダーフィールドを含むIPv6データグラムの読み取りと書き込みです。後者の例は、IPv6およびRSVPのOSPFのルーティングデーモンです（プロトコルフィールド46）。"
    },
    {
      "indent": 3,
      "text": "All data sent via raw sockets must be in network byte order and all data received via raw sockets will be in network byte order. This differs from the IPv4 raw sockets, which did not specify a byte ordering and used the host's byte order for certain IP header fields.",
      "ja": "生のソケットを介して送信されるすべてのデータはネットワークバイトの順序でなければならず、生のソケットを介して受信したすべてのデータはネットワークバイトの順序で行われます。これは、バイトの順序を指定せず、特定のIPヘッダーフィールドにホストのバイトオーダーを使用したIPv4 Raw Socketsとは異なります。"
    },
    {
      "indent": 3,
      "text": "Another difference from IPv4 raw sockets is that complete packets (that is, IPv6 packets with extension headers) cannot be sent or received using the IPv6 raw sockets API. Instead, ancillary data objects are used to transfer the extension headers and hoplimit information, as described in Section 6. Should an application need access to the complete IPv6 packet, some other technique, such as the datalink interfaces BPF or DLPI, must be used.",
      "ja": "IPv4 Raw Socketsとのもう1つの違いは、完全なパケット（つまり、拡張ヘッダー付きIPv6パケット）をIPv6 Raw Sockets APIを使用して送信または受信できないことです。代わりに、セクション6で説明されているように、補助的なデータオブジェクトは、拡張ヘッダーとHopLimit情報の転送に使用されます。アプリケーションでは、DatalinkインターフェイスBPFやDLPIなどのその他の手法をアプリケーションにアクセスする必要があります。"
    },
    {
      "indent": 3,
      "text": "All fields except the flow label in the IPv6 header that an application might want to change (i.e., everything other than the version number) can be modified using ancillary data and/or socket options by the application for output. All fields except the flow label in a received IPv6 header (other than the version number and Next Header fields) and all extension headers that an application might want to know are also made available to the application as ancillary data on input. Hence there is no need for a socket option similar to the IPv4 IP_HDRINCL socket option and on receipt the application will only receive the payload i.e., the data after the IPv6 header and all the extension headers.",
      "ja": "アプリケーションが変更したい可能性のあるIPv6ヘッダーのフローラベルを除くすべてのフィールド（つまり、バージョン番号以外のすべて）は、出力用のアプリケーションによって補助データおよび/またはソケットオプションを使用して変更できます。受信したIPv6ヘッダー（バージョン番号および次のヘッダーフィールド以外）のフローラベルを除くすべてのフィールドと、アプリケーションが知りたいと思う可能性のあるすべての拡張ヘッダーも、入力に関する補助データとしてアプリケーションに利用可能になります。したがって、IPv4 IP_HDRINCLソケットオプションと同様のソケットオプションは必要ありません。受領時には、アプリケーションはペイロード、つまりIPv6ヘッダーとすべての拡張ヘッダーの後のデータのみを受け取ります。"
    },
    {
      "indent": 3,
      "text": "This API does not define access to the flow label field, because today there is no standard usage of the field.",
      "ja": "このAPIは、フィールドの標準的な使用法がないため、フローラベルフィールドへのアクセスを定義するものではありません。"
    },
    {
      "indent": 3,
      "text": "When writing to a raw socket the kernel will automatically fragment the packet if its size exceeds the path MTU, inserting the required fragment headers. On input the kernel reassembles received fragments, so the reader of a raw socket never sees any fragment headers.",
      "ja": "生のソケットに書き込むとき、カーネルは、そのサイズがパスMTUを超えた場合、パケットを自動的にフラグメントし、必要なフラグメントヘッダーを挿入します。入力時には、カーネルの再組み立てが受信されたフラグメントであるため、生のソケットの読者はフラグメントヘッダーを見ることはありません。"
    },
    {
      "indent": 3,
      "text": "When we say \"an ICMPv6 raw socket\" we mean a socket created by calling the socket function with the three arguments AF_INET6, SOCK_RAW, and IPPROTO_ICMPV6.",
      "ja": "「ICMPV6 RAW SOCKET」と言うと、3つの引数AF_INET6、SOCK_RAW、およびIPPROTO_ICMPV6を使用してソケット関数を呼び出すことで作成されたソケットを意味します。"
    },
    {
      "indent": 3,
      "text": "Most IPv4 implementations give special treatment to a raw socket created with a third argument to socket() of IPPROTO_RAW, whose value is normally 255, to have it mean that the application will send down complete packets including the IPv4 header. (Note: This feature was added to IPv4 in 1988 by Van Jacobson to support traceroute, allowing a complete IP header to be passed by the application, before the IP_HDRINCL socket option was added.) We note that IPPROTO_RAW has no special meaning to an IPv6 raw socket (and the IANA currently reserves the value of 255 when used as a next-header field).",
      "ja": "ほとんどのIPv4実装は、IPPROTO_RAWのSocket（）の3番目の引数で作成された生のソケットに対して特別な処理を提供します。これは通常255であるため、アプリケーションがIPv4ヘッダーを含む完全なパケットを送信することを意味します。（注：この機能は、1988年にVan JacobsonによってIPv4に追加され、Tracerouteをサポートし、IP_Hdrinclソケットオプションが追加される前に、アプリケーションで完全なIPヘッダーを渡すことができます。RAWソケット（およびIANAは現在、次のヘッダーフィールドとして使用すると255の値を予約しています）。"
    },
    {
      "indent": 0,
      "text": "3.1. Checksums",
      "section_title": true,
      "ja": "3.1. チェックサム"
    },
    {
      "indent": 3,
      "text": "The kernel will calculate and insert the ICMPv6 checksum for ICMPv6 raw sockets, since this checksum is mandatory.",
      "ja": "カーネルは、このチェックサムが必須であるため、ICMPV6生のソケットのICMPV6チェックサムを計算して挿入します。"
    },
    {
      "indent": 3,
      "text": "For other raw IPv6 sockets (that is, for raw IPv6 sockets created with a third argument other than IPPROTO_ICMPV6), the application must set the new IPV6_CHECKSUM socket option to have the kernel (1) compute and store a checksum for output, and (2) verify the received checksum on input, discarding the packet if the checksum is in error. This option prevents applications from having to perform source address selection on the packets they send. The checksum will incorporate the IPv6 pseudo-header, defined in Section 8.1 of [RFC-2460]. This new socket option also specifies an integer offset into the user data of where the checksum is located.",
      "ja": "他の生のIPv6ソケット（つまり、ipproto_icmpv6以外の3番目の引数で作成された生のIPv6ソケットの場合）の場合、アプリケーションは、新しいIPv6_Checksumソケットオプションを設定して、カーネル（1）を計算し、出力のチェックサムを保存する必要があります。）入力に関する受信したチェックサムを確認し、チェックサムが誤っている場合はパケットを破棄します。このオプションは、アプリケーションが送信するパケットでソースアドレス選択を実行する必要がないことを防ぎます。チェックサムには、[RFC-2460]のセクション8.1で定義されているIPv6擬似ヘッダーが組み込まれます。この新しいソケットオプションは、チェックサムの配置場所のユーザーデータへの整数オフセットも指定します。"
    },
    {
      "indent": 6,
      "text": "int  offset = 2;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_CHECKSUM, &offset,\n           sizeof(offset));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "By default, this socket option is disabled. Setting the offset to -1 also disables the option. By disabled we mean (1) the kernel will not calculate and store a checksum for outgoing packets, and (2) the kernel will not verify a checksum for received packets.",
      "ja": "デフォルトでは、このソケットオプションは無効になっています。オフセットを-1に設定することもオプションを無効にします。（1）カーネルは発信パケットのチェックサムを計算して保存せず、（2）カーネルは受信パケットのチェックサムを確認しません。"
    },
    {
      "indent": 3,
      "text": "This option assumes the use of the 16-bit one's complement of the one's complement sum as the checksum algorithm and that the checksum field is aligned on a 16-bit boundary. Thus, specifying a positive odd value as offset is invalid, and setsockopt() will fail for such offset values.",
      "ja": "このオプションは、チェックサムアルゴリズムとしての16ビットの補体合計の補体の使用と、チェックサムフィールドが16ビットの境界に並べられていることを想定しています。したがって、正の奇数値をオフセットとして指定することは無効であり、SetSockopt（）はそのようなオフセット値で失敗します。"
    },
    {
      "indent": 3,
      "text": "An attempt to set IPV6_CHECKSUM for an ICMPv6 socket will fail. Also, an attempt to set or get IPV6_CHECKSUM for a non-raw IPv6 socket will fail.",
      "ja": "ICMPv6ソケットのIPv6_Checksumを設定する試みは失敗します。また、非RAW IPv6ソケットのIPv6_Checksumを設定または取得する試みは失敗します。"
    },
    {
      "indent": 3,
      "text": "(Note: Since the checksum is always calculated by the kernel for an ICMPv6 socket, applications are not able to generate ICMPv6 packets with incorrect checksums (presumably for testing purposes) using this API.)",
      "ja": "（注：チェックサムは常にICMPV6ソケットのカーネルによって計算されるため、アプリケーションはこのAPIを使用して誤ったチェックサム（おそらくテスト目的で）でICMPv6パケットを生成できません。）"
    },
    {
      "indent": 0,
      "text": "3.2. ICMPv6 Type Filtering",
      "section_title": true,
      "ja": "3.2. ICMPV6タイプフィルタリング"
    },
    {
      "indent": 3,
      "text": "ICMPv4 raw sockets receive most ICMPv4 messages received by the kernel. (We say \"most\" and not \"all\" because Berkeley-derived kernels never pass echo requests, timestamp requests, or address mask requests to a raw socket. Instead these three messages are processed entirely by the kernel.) But ICMPv6 is a superset of ICMPv4, also including the functionality of IGMPv4 and ARPv4. This means that an ICMPv6 raw socket can potentially receive many more messages than would be received with an ICMPv4 raw socket: ICMP messages similar to ICMPv4, along with neighbor solicitations, neighbor advertisements, and the three multicast listener discovery messages.",
      "ja": "ICMPV4 RAWソケットは、カーネルで受信されたほとんどのICMPV4メッセージを受信します。（バークレー由来のカーネルがエコーリクエスト、タイムスタンプリクエスト、またはマスクリクエストを生のソケットに渡すことはないため、「ほとんど」と「すべて」とは「すべて」と言います。代わりに、これらの3つのメッセージは完全にケネルによって処理されます。）IGMPv4とArpv4の機能も含まれます。これは、ICMPV6 RAWソケットが、ICMPV4 RAWソケットで受信されるよりも多くのメッセージを受信する可能性があることを意味します。ICMPv4に似たICMPメッセージ、および近隣の勧誘、近隣広告、および3つのマルチキャストリスナーディスカバリーメッセージとともに。"
    },
    {
      "indent": 3,
      "text": "Most applications using an ICMPv6 raw socket care about only a small subset of the ICMPv6 message types. To transfer extraneous ICMPv6 messages from the kernel to user can incur a significant overhead. Therefore this API includes a method of filtering ICMPv6 messages by the ICMPv6 type field.",
      "ja": "ICMPV6 RAWソケットを使用するほとんどのアプリケーションは、ICMPV6メッセージタイプの小さなサブセットのみを注意してください。カーネルからユーザーに無関係なICMPV6メッセージを転送するには、重大なオーバーヘッドが発生する可能性があります。したがって、このAPIには、ICMPV6型フィールドによるICMPV6メッセージをフィルタリングする方法が含まれています。"
    },
    {
      "indent": 3,
      "text": "Each ICMPv6 raw socket has an associated filter whose datatype is defined as",
      "ja": "各icmpv6生ソケットには、データ型が次のように定義されている関連フィルターがあります"
    },
    {
      "indent": 6,
      "text": "struct icmp6_filter;",
      "ja": "struct icmp6_filter;"
    },
    {
      "indent": 3,
      "text": "This structure, along with the macros and constants defined later in this section, are defined as a result of including the <netinet/icmp6.h>.",
      "ja": "この構造は、このセクションの後半で定義されたマクロと定数とともに、<netinet/icmp6.h>を含めた結果として定義されます。"
    },
    {
      "indent": 3,
      "text": "The current filter is fetched and stored using getsockopt() and setsockopt() with a level of IPPROTO_ICMPV6 and an option name of ICMP6_FILTER.",
      "ja": "現在のフィルターは、getsockopt（）およびsetSockopt（）を使用してICMP6_Filterのオプション名を使用してfetted ockopt（）およびsetSockopt（）を使用して保存されます。"
    },
    {
      "indent": 3,
      "text": "Six macros operate on an icmp6_filter structure:",
      "ja": "6つのマクロがICMP6_Filter構造で動作します。"
    },
    {
      "indent": 6,
      "text": "void ICMP6_FILTER_SETPASSALL (struct icmp6_filter *);\nvoid ICMP6_FILTER_SETBLOCKALL(struct icmp6_filter *);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "void ICMP6_FILTER_SETPASS ( int, struct icmp6_filter *);\nvoid ICMP6_FILTER_SETBLOCK( int, struct icmp6_filter *);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "int ICMP6_FILTER_WILLPASS (int, const struct icmp6_filter *); int ICMP6_FILTER_WILLBLOCK(int, const struct icmp6_filter *);",
      "ja": "int icmp6_filter_willpass（int、const struct icmp6_filter *）;int icmp6_filter_willblock（int、const struct icmp6_filter *）;"
    },
    {
      "indent": 3,
      "text": "The first argument to the last four macros (an integer) is an ICMPv6 message type, between 0 and 255. The pointer argument to all six macros is a pointer to a filter that is modified by the first four macros and is examined by the last two macros.",
      "ja": "最後の4つのマクロ（整数）の最初の引数は、0〜255のICMPV6メッセージタイプです。6つのマクロすべてへのポインター引数は、最初の4つのマクロによって変更され、最後の4つのマクロによって修正されたフィルターへのポインターです。2つのマクロ。"
    },
    {
      "indent": 3,
      "text": "The first two macros, SETPASSALL and SETBLOCKALL, let us specify that all ICMPv6 messages are passed to the application or that all ICMPv6 messages are blocked from being passed to the application.",
      "ja": "最初の2つのマクロ、SetPassallとSetBlockallは、すべてのICMPV6メッセージがアプリケーションに渡されるか、すべてのICMPV6メッセージがアプリケーションに渡されるのをブロックされることを指定します。"
    },
    {
      "indent": 3,
      "text": "The next two macros, SETPASS and SETBLOCK, let us specify that messages of a given ICMPv6 type should be passed to the application or not passed to the application (blocked).",
      "ja": "次の2つのマクロ、SetPassとSetBlockは、特定のICMPV6タイプのメッセージをアプリケーションに渡すか、アプリケーションに渡されないか（ブロックされていない）ことを指定しましょう。"
    },
    {
      "indent": 3,
      "text": "The final two macros, WILLPASS and WILLBLOCK, return true or false depending whether the specified message type is passed to the application or blocked from being passed to the application by the filter pointed to by the second argument.",
      "ja": "最後の2つのマクロ、ウィルパスとウィルブロックは、指定されたメッセージタイプがアプリケーションに渡されるか、2番目の引数によって指されたフィルターによってアプリケーションに渡されるのをブロックするかどうかに応じてtrueまたはfalseを返します。"
    },
    {
      "indent": 3,
      "text": "When an ICMPv6 raw socket is created, it will by default pass all ICMPv6 message types to the application.",
      "ja": "ICMPV6 RAWソケットが作成されると、デフォルトではすべてのICMPV6メッセージタイプをアプリケーションに渡します。"
    },
    {
      "indent": 3,
      "text": "As an example, a program that wants to receive only router advertisements could execute the following:",
      "ja": "例として、ルーター広告のみを受け取りたいプログラムは、次のことを実行できます。"
    },
    {
      "indent": 6,
      "text": "struct icmp6_filter myfilt;",
      "ja": "struct icmp6_filter myfilt;"
    },
    {
      "indent": 6,
      "text": "fd = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ICMP6_FILTER_SETBLOCKALL(&myfilt); ICMP6_FILTER_SETPASS(ND_ROUTER_ADVERT, &myfilt); setsockopt(fd, IPPROTO_ICMPV6, ICMP6_FILTER, &myfilt,",
      "ja": "icmp6_filter_setblockall（＆myfilt）;icmp6_filter_setpass（nd_router_advert、＆myfilt）;SetSockopt（FD、IPPROTO_ICMPV6、ICMP6_FILTER、＆MYFILT、"
    },
    {
      "indent": 17,
      "text": "sizeof(myfilt));",
      "ja": "sizeof（myfilt））;"
    },
    {
      "indent": 3,
      "text": "The filter structure is declared and then initialized to block all messages types. The filter structure is then changed to allow router advertisement messages to be passed to the application and the filter is installed using setsockopt().",
      "ja": "フィルター構造が宣言され、すべてのメッセージタイプをブロックするように初期化されます。次に、フィルター構造を変更して、ルーター広告メッセージをアプリケーションに渡すことができ、フィルターはsetSockopt（）を使用してインストールされます。"
    },
    {
      "indent": 3,
      "text": "In order to clear an installed filter the application can issue a setsockopt for ICMP6_FILTER with a zero length. When no such filter has been installed, getsockopt() will return the kernel default filter.",
      "ja": "インストールされたフィルターをクリアするために、アプリケーションは長さがゼロのICMP6_FilterのSetSockoptを発行できます。そのようなフィルターがインストールされていない場合、GetSockopt（）はカーネルデフォルトフィルターを返します。"
    },
    {
      "indent": 3,
      "text": "The icmp6_filter structure is similar to the fd_set datatype used with the select() function in the sockets API. The icmp6_filter structure is an opaque datatype and the application should not care how it is implemented. All the application does with this datatype is allocate a variable of this type, pass a pointer to a variable of this type to getsockopt() and setsockopt(), and operate on a variable of this type using the six macros that we just defined.",
      "ja": "ICMP6_Filter構造は、Sockets APIのSelect（）関数で使用されるFD_SETデータタイプに似ています。ICMP6_Filter構造は不透明なデータ型であり、アプリケーションがどのように実装されているかを気にしてはなりません。このデータタイプで行うすべてのアプリケーションは、このタイプの変数を割り当て、このタイプの変数へのポインターをgetSockopt（）とsetSockopt（）に渡し、定義した6つのマクロを使用してこのタイプの変数を操作します。"
    },
    {
      "indent": 3,
      "text": "Nevertheless, it is worth showing a simple implementation of this datatype and the six macros.",
      "ja": "それにもかかわらず、このデータ型と6つのマクロの簡単な実装を示す価値があります。"
    },
    {
      "indent": 6,
      "text": "struct icmp6_filter {\n  uint32_t  icmp6_filt[8];  /* 8*32 = 256 bits */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define ICMP6_FILTER_WILLPASS(type, filterp) \\\n  ((((filterp)->icmp6_filt[(type) >> 5]) & \\\n    (1 << ((type) & 31))) != 0)\n#define ICMP6_FILTER_WILLBLOCK(type, filterp) \\\n  ((((filterp)->icmp6_filt[(type) >> 5]) & \\\n    (1 << ((type) & 31))) == 0)\n#define ICMP6_FILTER_SETPASS(type, filterp) \\\n  ((((filterp)->icmp6_filt[(type) >> 5]) |= \\\n    (1 << ((type) & 31))))\n#define ICMP6_FILTER_SETBLOCK(type, filterp) \\\n  ((((filterp)->icmp6_filt[(type) >> 5]) &= \\\n    ~(1 << ((type) & 31))))\n#define ICMP6_FILTER_SETPASSALL(filterp) \\\n  memset((filterp), 0xFF, sizeof(struct icmp6_filter))\n#define ICMP6_FILTER_SETBLOCKALL(filterp) \\\n  memset((filterp), 0, sizeof(struct icmp6_filter))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(Note: These sample definitions have two limitations that an implementation may want to change. The first four macros evaluate their first argument two times. The second two macros require the inclusion of the <string.h> header for the memset() function.)",
      "ja": "（注：これらのサンプル定義には、実装が変更したい2つの制限があります。最初の4つのマクロは最初の引数を2回評価します。2番目の2つのマクロには、Memset（）関数に<String.H>ヘッダーを含める必要があります。））"
    },
    {
      "indent": 0,
      "text": "3.3. ICMPv6 Verification of Received Packets",
      "section_title": true,
      "ja": "3.3. ICMPV6受信パケットの検証"
    },
    {
      "indent": 3,
      "text": "The protocol stack will verify the ICMPv6 checksum and discard any packets with invalid checksums.",
      "ja": "プロトコルスタックは、ICMPV6チェックサムを検証し、無効なチェックサムでパケットを破棄します。"
    },
    {
      "indent": 3,
      "text": "An implementation might perform additional validity checks on the ICMPv6 message content and discard malformed packets. However, a portable application must not assume that such validity checks have been performed.",
      "ja": "実装は、ICMPV6メッセージコンテンツの追加の妥当性チェックを実行し、不正なパケットを破棄する場合があります。ただし、ポータブルアプリケーションは、そのような妥当性チェックが実行されたと仮定してはなりません。"
    },
    {
      "indent": 3,
      "text": "The protocol stack should not automatically discard packets if the ICMP type is unknown to the stack. For extensibility reasons received ICMP packets with any type (informational or error) must be passed to the applications (subject to ICMP6_FILTER filtering on the type value and the checksum verification).",
      "ja": "ICMPタイプがスタックに不明な場合、プロトコルスタックはパケットを自動的に破棄してはなりません。拡張上の理由で、任意のタイプのICMPパケット（情報またはエラー）をアプリケーションに渡す必要があります（型値とチェックサムの検証に関するICMP6_FILTERフィルタリングの対象となります）。"
    },
    {
      "indent": 0,
      "text": "4. Access to IPv6 and Extension Headers",
      "section_title": true,
      "ja": "4. IPv6および拡張ヘッダーへのアクセス"
    },
    {
      "indent": 3,
      "text": "Applications need to be able to control IPv6 header and extension header content when sending as well as being able to receive the content of these headers. This is done by defining socket option types which can be used both with setsockopt and with ancillary data. Ancillary data is discussed in Appendix A. The following optional information can be exchanged between the application and the kernel:",
      "ja": "アプリケーションは、これらのヘッダーのコンテンツを送信するだけでなく、送信時にIPv6ヘッダーと拡張ヘッダーのコンテンツを制御できる必要があります。これは、SetSockoptと補助データの両方で使用できるソケットオプションタイプを定義することによって行われます。補助データについては、付録Aで説明します。次のオプション情報は、アプリケーションとカーネルの間で交換できます。"
    },
    {
      "indent": 3,
      "text": "1. The send/receive interface and source/destination address, 2. The hop limit, 3. Next hop address, 4. The traffic class, 5. Routing header, 6. Hop-by-Hop options header, and 7. Destination options header.",
      "ja": "1. インターフェイスとソース/宛先アドレスを送信/受信、2。ホップ制限3.次のホップアドレス、4。トラフィッククラス、5。ルーティングヘッダー、6。ホップバイホップオプションヘッダー、および7.宛先オプションヘッダー。"
    },
    {
      "indent": 3,
      "text": "First, to receive any of this optional information (other than the next hop address, which can only be set) on a UDP or raw socket, the application must call setsockopt() to turn on the corresponding flag:",
      "ja": "まず、UDPまたはRAWソケットでこのオプションの情報（設定できる次のホップアドレス以外）を受信するには、アプリケーションがSetSockopt（）を呼び出して対応するフラグをオンにする必要があります。"
    },
    {
      "indent": 6,
      "text": "int on = 1;",
      "ja": "int on = 1;"
    },
    {
      "indent": 6,
      "text": "setsockopt(fd, IPPROTO_IPV6, IPV6_RECVPKTINFO,  &on, sizeof(on));\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVHOPLIMIT, &on, sizeof(on));\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVRTHDR,    &on, sizeof(on));\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVHOPOPTS,  &on, sizeof(on));\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVDSTOPTS,  &on, sizeof(on));\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVTCLASS,   &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When any of these options are enabled, the corresponding data is returned as control information by recvmsg(), as one or more ancillary data objects.",
      "ja": "これらのオプションのいずれかが有効になっている場合、対応するデータは、1つ以上の補助データオブジェクトとして、Recvmsg（）による制御情報として返されます。"
    },
    {
      "indent": 3,
      "text": "This document does not define how to receive the optional information on a TCP socket. See Section 4.1 for more details.",
      "ja": "このドキュメントでは、TCPソケットでオプションの情報を受信する方法を定義するものではありません。詳細については、セクション4.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Two different mechanisms exist for sending this optional information:",
      "ja": "このオプションの情報を送信するための2つの異なるメカニズムが存在します。"
    },
    {
      "indent": 3,
      "text": "1. Using setsockopt to specify the option content for a socket. These are known \"sticky\" options since they affect all transmitted packets on the socket until either a new setsockopt is done or the options are overridden using ancillary data.",
      "ja": "1. SetSockoptを使用して、ソケットのオプションコンテンツを指定します。これらは、新しいSetSockoptが完了するか、補助データを使用してオプションがオーバーライドされるまで、ソケット上のすべての送信パケットに影響を与えるため、「粘着性」オプションです。"
    },
    {
      "indent": 3,
      "text": "2. Using ancillary data to specify the option content for a single datagram. This only applies to datagram and raw sockets; not to TCP sockets.",
      "ja": "2. 補助データを使用して、単一のデータグラムのオプションコンテンツを指定します。これは、データグラムと生のソケットにのみ適用されます。TCPソケットではありません。"
    },
    {
      "indent": 3,
      "text": "The three socket option parameters and the three cmsghdr fields that describe the options/ancillary data objects are summarized as:",
      "ja": "オプション/補助データオブジェクトを説明する3つのソケットオプションパラメーターと3つのCMSGHDRフィールドは、次のように要約されています。"
    },
    {
      "indent": 6,
      "text": "opt level/    optname/          optval/\ncmsg_level    cmsg_type         cmsg_data[]\n------------  ------------      ------------------------\nIPPROTO_IPV6  IPV6_PKTINFO      in6_pktinfo structure\nIPPROTO_IPV6  IPV6_HOPLIMIT     int\nIPPROTO_IPV6  IPV6_NEXTHOP      socket address structure\nIPPROTO_IPV6  IPV6_RTHDR        ip6_rthdr structure\nIPPROTO_IPV6  IPV6_HOPOPTS      ip6_hbh structure\nIPPROTO_IPV6  IPV6_DSTOPTS      ip6_dest structure\nIPPROTO_IPV6  IPV6_RTHDRDSTOPTS ip6_dest structure\nIPPROTO_IPV6  IPV6_TCLASS       int",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "(Note: IPV6_HOPLIMIT can be used as ancillary data items only)",
      "ja": "（注：IPv6_hoplimitは、補助データ項目としてのみ使用できます）"
    },
    {
      "indent": 3,
      "text": "All these options are described in detail in Section 6, 7, 8 and 9. All the constants beginning with IPV6_ are defined as a result of including <netinet/in.h>.",
      "ja": "これらのすべてのオプションについては、セクション6、7、8、および9で詳しく説明します。IPv6_で始まるすべての定数は、<netinet/in.h>を含む結果として定義されます。"
    },
    {
      "indent": 3,
      "text": "Note: We intentionally use the same constant for the cmsg_level member as is used as the second argument to getsockopt() and setsockopt() (what is called the \"level\"), and the same constant for the cmsg_type member as is used as the third argument to getsockopt() and setsockopt() (what is called the \"option name\").",
      "ja": "注：getsockopt（）およびsetsockopt（）（「レベル」と呼ばれるもの）の2番目の引数として使用されるCMSG_LEVELメンバーに対して同じ定数を意図的に使用し、CMSG_TYPEメンバーと同じ定数を使用して使用します。getsockopt（）およびsetsockopt（）（「オプション名」と呼ばれるもの）に対する3番目の議論。"
    },
    {
      "indent": 3,
      "text": "Issuing getsockopt() for the above options will return the sticky option value i.e., the value set with setsockopt(). If no sticky option value has been set getsockopt() will return the following values:",
      "ja": "上記のオプションに対してgetSockopt（）を発行すると、粘着性のオプション値、つまりsetsockopt（）で設定された値が返されます。粘着性のオプション値が設定されていない場合、GetSockopt（）は次の値を返します。"
    },
    {
      "indent": 3,
      "text": "- For the IPV6_PKTINFO option, it will return an in6_pktinfo structure with ipi6_addr being in6addr_any and ipi6_ifindex being zero.",
      "ja": "- IPv6_pktinfoオプションの場合、IPI6_ADDRがIN6ADDR_ANY、IPI6_ifindexがゼロであるIN6_PKTINFO構造を返します。"
    },
    {
      "indent": 3,
      "text": "- For the IPV6_TCLASS option, it will return the kernel default value.",
      "ja": "- IPv6_TClassオプションの場合、カーネルのデフォルト値を返します。"
    },
    {
      "indent": 3,
      "text": "- For other options, it will indicate the lack of the option value with optlen being zero.",
      "ja": "- 他のオプションでは、Optlenがゼロであるオプション値がないことを示します。"
    },
    {
      "indent": 3,
      "text": "The application does not explicitly need to access the data structures for the Routing header, Hop-by-Hop options header, and Destination options header, since the API to these features is through a set of inet6_rth_XXX() and inet6_opt_XXX() functions that we define in Section 7 and Section 10. Those functions simplify the interface to these features instead of requiring the application to know the intimate details of the extension header formats.",
      "ja": "これらの機能のAPIは、INET6_RTH_XXX（）およびINET6_OPT_XXX（）機能のセットを使用するため、アプリケーションはルーティングヘッダー、ホップバイホップオプションヘッダー、および宛先オプションヘッダーのデータ構造にアクセスする必要はありません。セクション7およびセクション10で定義します。これらの関数は、アプリケーションに拡張ヘッダー形式の親密な詳細を知ることを要求する代わりに、これらの機能へのインターフェイスを簡素化します。"
    },
    {
      "indent": 3,
      "text": "When specifying extension headers, this API assumes the header ordering and the number of occurrences of each header as described in [RFC-2460]. More details about the ordering issue will be discussed in Section 12.",
      "ja": "拡張ヘッダーを指定するとき、このAPIは、[RFC-2460]で説明されているように、各ヘッダーのヘッダー順序と発生数を想定します。注文問題の詳細については、セクション12で説明します。"
    },
    {
      "indent": 0,
      "text": "4.1. TCP Implications",
      "section_title": true,
      "ja": "4.1. TCPの意味"
    },
    {
      "indent": 3,
      "text": "It is not possible to use ancillary data to transmit the above options for TCP since there is not a one-to-one mapping between send operations and the TCP segments being transmitted. Instead an application can use setsockopt to specify them as sticky options. When the application uses setsockopt to specify the above options it is expected that TCP will start using the new information when sending segments. However, TCP may or may not use the new information when retransmitting segments that were originally sent when the old sticky options were in effect.",
      "ja": "送信操作と送信されるTCPセグメントの間に1対1のマッピングがないため、TCPの上記のオプションを送信するために補助データを使用することはできません。代わりに、アプリケーションはSetSockoptを使用して、それらを粘着性のオプションとして指定できます。アプリケーションがSetSockoptを使用して上記のオプションを指定する場合、TCPはセグメントを送信するときに新しい情報の使用を開始することが予想されます。ただし、TCPは、古い粘着性のオプションが有効になっているときに元々送信されたセグメントを再送信するときに、新しい情報を使用する場合と使用できない場合があります。"
    },
    {
      "indent": 3,
      "text": "It is unclear how a TCP application can use received information (such as extension headers) due to the lack of mapping between received TCP segments and receive operations. In particular, the received information could not be used for access control purposes like on UDP and raw sockets.",
      "ja": "受信したTCPセグメント間のマッピングがないため、TCPアプリケーションが受信情報（拡張ヘッダーなど）をどのように使用できるかは不明です。特に、受信した情報は、UDPや生のソケットなどのアクセス制御目的で使用できませんでした。"
    },
    {
      "indent": 3,
      "text": "This specification therefore does not define how to get the received information on TCP sockets. The result of the IPV6_RECVxxx options on a TCP socket is undefined as well.",
      "ja": "したがって、この仕様では、TCPソケットで受信した情報を取得する方法を定義するものではありません。TCPソケットのIPv6_Recvxxxオプションの結果も定義されていません。"
    },
    {
      "indent": 0,
      "text": "4.2. UDP and Raw Socket Implications",
      "section_title": true,
      "ja": "4.2. UDPおよび生のソケットへの影響"
    },
    {
      "indent": 3,
      "text": "The receive behavior for UDP and raw sockets is quite straightforward. After the application has enabled an IPV6_RECVxxx socket option it will receive ancillary data items for every recvmsg() call containing the requested information. However, if the information is not present in the packet the ancillary data item will not be included. For example, if the application enables IPV6_RECVRTHDR and a received datagram does not contain a Routing header there will not be an IPV6_RTHDR ancillary data item. Note that due to buffering in the socket implementation there might be some packets queued when an IPV6_RECVxxx option is enabled and they might not have the ancillary data information.",
      "ja": "UDPと生のソケットの受信動作は非常に簡単です。アプリケーションがIPv6_Recvxxxソケットオプションを有効にした後、要求された情報を含むすべてのRecvmsg（）コールの補助データ項目を受け取ります。ただし、情報がパケットに存在しない場合、補助データ項目は含まれません。たとえば、アプリケーションがIPv6_recvrthdrを有効にし、受信したデータグラムにはルーティングヘッダーが含まれていない場合、IPv6_rthdrの補助データ項目はありません。ソケットの実装でのバッファリングにより、IPv6_Recvxxxオプションが有効になっている場合、補助的なデータ情報がない場合に、いくつかのパケットがキューになっている可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "For sending the application has the choice between using sticky options and ancillary data. The application can also use both having the sticky options specify the \"default\" and using ancillary data to override the default options.",
      "ja": "アプリケーションを送信するには、粘着性のオプションを使用するか、補助データを使用するかを選択できます。また、アプリケーションでは、粘着性のオプションが「デフォルト」を指定することと、補助データを使用してデフォルトオプションをオーバーライドすることの両方を使用することもできます。"
    },
    {
      "indent": 3,
      "text": "When an ancillary data item is specified in a call to sendmsg(), the item will override an existing sticky option of the same name (if previously specified). For example, if the application has set IPV6_RTHDR using a sticky option and later passes IPV6_RTHDR as ancillary data this will override the IPV6_RTHDR sticky option and the routing header of the outgoing packet will be from the ancillary data item, not from the sticky option. Note, however, that other sticky options than IPV6_RTHDR will not be affected by the IPV6_RTHDR ancillary data item; the overriding mechanism only works for the same type of sticky options and ancillary data items.",
      "ja": "sendmsg（）への呼び出しで補助的なデータ項目が指定されている場合、アイテムは同じ名前の既存の粘着性オプションをオーバーライドします（以前に指定された場合）。たとえば、アプリケーションがStickyオプションを使用してIPv6_RTHDRを設定し、後にIPv6_RTHDRを補助データとして渡す場合、これによりIPv6_RTHDRスティッキーオプションがオーバーライドされ、発信パケットのルーティングヘッダーは、Stickyオプションからではなく、補助データ項目からです。ただし、IPv6_rthdr以外の粘着性のオプションは、IPv6_rthdrの補助データ項目の影響を受けないことに注意してください。オーバーライドメカニズムは、同じタイプの粘着性のオプションと補助データ項目に対してのみ機能します。"
    },
    {
      "indent": 3,
      "text": "(Note: the overriding rule is different from the one in RFC 2292. In RFC 2292, an ancillary data item overrode all sticky options previously defined. This was reasonable, because sticky options could only be specified as a set by a single socket option. However, in this API, each option is separated so that it can be specified as a single sticky option. Additionally, there are much more ancillary data items and sticky options than in RFC 2292, including ancillary-only one. Thus, it should be natural for application programmers to separate the overriding rule as well.)",
      "ja": "（注：オーバーライドルールは、RFC 2292のルールとは異なります。RFC2292では、補助的なデータ項目が以前に定義されたすべての粘着性オプションを覆しました。これは合理的でした。これは、粘着オプションが単一のソケットオプションで設定されたものとしてのみ指定できるためです。ただし、このAPIでは、各オプションが単一の粘着性オプションとして指定できるように分離されています。さらに、補助のみを含むRFC 2292よりもはるかに多くの補助的なデータ項目と粘着オプションがあります。したがって、それはそうでなければなりません。アプリケーションプログラマーがオーバーライドルールを分離することも自然です。）"
    },
    {
      "indent": 3,
      "text": "An application can also temporarily disable a particular sticky option by specifying a corresponding ancillary data item that could disable the sticky option when being used as an argument for a socket option. For example, if the application has set IPV6_HOPOPTS as a sticky option and later passes IPV6_HOPOPTS with a zero length as an ancillary data item, the packet will not have a Hop-by-Hop options header.",
      "ja": "アプリケーションは、ソケットオプションの引数として使用されるときに粘着性オプションを無効にできる対応する補助データ項目を指定することにより、特定の粘着性オプションを一時的に無効にすることもできます。たとえば、アプリケーションがIPv6_hopoptsを粘着性オプションとして設定し、後に補助データ項目としてゼロ長でIPv6_hopoptsを渡す場合、パケットにはホップバイホップオプションヘッダーがありません。"
    },
    {
      "indent": 0,
      "text": "5. Extensions to Socket Ancillary Data",
      "section_title": true,
      "ja": "5. ソケットの補助データへの拡張"
    },
    {
      "indent": 3,
      "text": "This specification uses ancillary data as defined in Posix with some compatible extensions, which are described in the following subsections. Section 20 will provide a detailed overview of ancillary data and related structures and macros, including the extensions.",
      "ja": "この仕様では、以下のサブセクションで説明されているいくつかの互換性のある拡張機能を備えたPOSIXで定義されている補助データを使用します。セクション20では、補助データと関連する構造とマクロの詳細な概要を説明します。"
    },
    {
      "indent": 0,
      "text": "5.1. CMSG_NXTHDR",
      "section_title": true,
      "ja": "5.1. CMSG_NXTHDR"
    },
    {
      "indent": 6,
      "text": "struct cmsghdr *CMSG_NXTHDR(const struct msghdr *mhdr,\n                            const struct cmsghdr *cmsg);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CMSG_NXTHDR() returns a pointer to the cmsghdr structure describing the next ancillary data object. Mhdr is a pointer to a msghdr structure and cmsg is a pointer to a cmsghdr structure. If there is not another ancillary data object, the return value is NULL.",
      "ja": "CMSG_NXTHDR（）次の補助データオブジェクトを記述するCMSGHDR構造へのポインターを返します。MHDRはMSGHDR構造へのポインターであり、CMSGはCMSGHDR構造へのポインターです。別の補助データオブジェクトがない場合、返品値はnullです。"
    },
    {
      "indent": 3,
      "text": "The following behavior of this macro is new to this API: if the value of the cmsg pointer is NULL, a pointer to the cmsghdr structure describing the first ancillary data object is returned. That is, CMSG_NXTHDR(mhdr, NULL) is equivalent to CMSG_FIRSTHDR(mhdr). If there are no ancillary data objects, the return value is NULL.",
      "ja": "このマクロの次の動作は、このAPIの新しいものです。CMSGポインターの値がnullの場合、最初の補助データオブジェクトを記述するCMSGHDR構造へのポインターが返されます。つまり、CMSG_NXTHDR（MHDR、NULL）はCMSG_FIRSTHDR（MHDR）と同等です。補助的なデータオブジェクトがない場合、返品値はnullです。"
    },
    {
      "indent": 0,
      "text": "5.2. CMSG_SPACE",
      "section_title": true,
      "ja": "5.2. CMSG_SPACE"
    },
    {
      "indent": 3,
      "text": "socklen_t CMSG_SPACE(socklen_t length);",
      "ja": "socklen_t cmsg_space（socklen_t length）;"
    },
    {
      "indent": 3,
      "text": "This macro is new with this API. Given the length of an ancillary data object, CMSG_SPACE() returns an upper bound on the space required by the object and its cmsghdr structure, including any padding needed to satisfy alignment requirements. This macro can be used, for example, when allocating space dynamically for the ancillary data. This macro should not be used to initialize the cmsg_len member of a cmsghdr structure; instead use the CMSG_LEN() macro.",
      "ja": "このマクロはこのAPIで新しくなっています。補助データオブジェクトの長さを考えると、CMSG_SPACE（）は、アライメント要件を満たすために必要なパディングを含む、オブジェクトとそのCMSGHDR構造に必要なスペースの上限を返します。このマクロは、たとえば、補助データに空間を動的に割り当てるときに使用できます。このマクロは、CMSGHDR構造のCMSG_LENメンバーを初期化するために使用しないでください。代わりに、cmsg_len（）マクロを使用します。"
    },
    {
      "indent": 0,
      "text": "5.3. CMSG_LEN",
      "section_title": true,
      "ja": "5.3. cmsg_len"
    },
    {
      "indent": 3,
      "text": "socklen_t CMSG_LEN(socklen_t length);",
      "ja": "socklen_t cmsg_len（socklen_t length）;"
    },
    {
      "indent": 3,
      "text": "This macro is new with this API. Given the length of an ancillary data object, CMSG_LEN() returns the value to store in the cmsg_len member of the cmsghdr structure, taking into account any padding needed to satisfy alignment requirements.",
      "ja": "このマクロはこのAPIで新しくなっています。補助データオブジェクトの長さを考えると、CMSG_LEN（）は、アライメント要件を満たすために必要なパディングを考慮して、CMSGHDR構造のCMSG_LENメンバーに保存する値を返します。"
    },
    {
      "indent": 3,
      "text": "Note the difference between CMSG_SPACE() and CMSG_LEN(), shown also in the figure in Section 20.2: the former accounts for any required padding at the end of the ancillary data object and the latter is the actual length to store in the cmsg_len member of the ancillary data object.",
      "ja": "セクション20.2の図にも示されているcmsg_space（）とcmsg_len（）の違いに注意してください。補助データオブジェクトの端にある必要なパディングの前の説明と後者は、CMSG_LENメンバーの実際の長さであることです。補助データオブジェクト。"
    },
    {
      "indent": 0,
      "text": "6. Packet Information",
      "section_title": true,
      "ja": "6. パケット情報"
    },
    {
      "indent": 3,
      "text": "There are five pieces of information that an application can specify for an outgoing packet using ancillary data:",
      "ja": "補助データを使用して、出て行くパケットにアプリケーションが指定できる5つの情報があります。"
    },
    {
      "indent": 6,
      "text": "1. the source IPv6 address, 2. the outgoing interface index, 3. the outgoing hop limit, 4. the next hop address, and 5. the outgoing traffic class value.",
      "ja": "1. ソースIPv6アドレス、2。発信インターフェイスインデックス、3。発信ホップ制限、4。次のホップアドレス、5。発信トラフィッククラス値。"
    },
    {
      "indent": 3,
      "text": "Four similar pieces of information can be returned for a received packet as ancillary data:",
      "ja": "受信したパケットの場合、4つの同様の情報を補助データとして返すことができます。"
    },
    {
      "indent": 6,
      "text": "1. the destination IPv6 address, 2. the arriving interface index, 3. the arriving hop limit, and 4. the arriving traffic class value.",
      "ja": "1. 宛先IPv6アドレス、2。到着インターフェイスインデックス、3。到着ホップ制限、および4.到着するトラフィッククラス値。"
    },
    {
      "indent": 3,
      "text": "The first two pieces of information are contained in an in6_pktinfo structure that is set with setsockopt() or sent as ancillary data with sendmsg() and received as ancillary data with recvmsg(). This structure is defined as a result of including <netinet/in.h>.",
      "ja": "最初の2つの情報は、setsockopt（）で設定されたIN6_PKTINFO構造に含まれているか、sendmsg（）で補助データとして送信され、recvmsg（）で補助データとして受信されます。この構造は、<netinet/in.h>を含めた結果として定義されます。"
    },
    {
      "indent": 6,
      "text": "struct in6_pktinfo {\n  struct in6_addr ipi6_addr;    /* src/dst IPv6 address */\n  unsigned int    ipi6_ifindex; /* send/recv interface index */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the socket option and cmsghdr level will be IPPROTO_IPV6, the type will be IPV6_PKTINFO, and the first byte of the option value and cmsg_data[] will be the first byte of the in6_pktinfo structure. An application can clear any sticky IPV6_PKTINFO option by doing a",
      "ja": "ソケットオプションとCMSGHDRレベルはIPPROTO_IPV6であり、タイプはIPv6_pktinfoであり、オプション値の最初のバイトとCMSG_DATA []はIN6_PKTINFO構造の最初のバイトになります。アプリケーションは、粘着性のあるipv6_pktinfoオプションを実行することでクリアできます"
    },
    {
      "indent": 3,
      "text": "\"regular\" setsockopt with ipi6_addr being in6addr_any and ipi6_ifindex being zero.",
      "ja": "IPI6_ADDRがIN6ADDR_ANYであり、IPI6_IFINDEXがゼロである「通常の」SetSockopt。"
    },
    {
      "indent": 3,
      "text": "This information is returned as ancillary data by recvmsg() only if the application has enabled the IPV6_RECVPKTINFO socket option:",
      "ja": "この情報は、アプリケーションがIPv6_Recvpktinfoソケットオプションを有効にした場合にのみ、recvmsg（）によって補助データとして返されます。"
    },
    {
      "indent": 6,
      "text": "int  on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVPKTINFO, &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(Note: The hop limit is not contained in the in6_pktinfo structure for the following reason. Some UDP servers want to respond to client requests by sending their reply out the same interface on which the request was received and with the source IPv6 address of the reply equal to the destination IPv6 address of the request. To do this the application can enable just the IPV6_RECVPKTINFO socket option and then use the received control information from recvmsg() as the outgoing control information for sendmsg(). The application need not examine or modify the in6_pktinfo structure at all. But if the hop limit were contained in this structure, the application would have to parse the received control information and change the hop limit member, since the received hop limit is not the desired value for an outgoing packet.)",
      "ja": "（注：ホップ制限は、次の理由でIN6_PKTINFO構造に含まれていません。一部のUDPサーバーは、リクエストが受信されたのと同じインターフェイスを送信して、返信のソースIPv6アドレスを使用して、返信を送信してクライアント要求に応答したいと考えています。リクエストの宛先IPv6アドレスに等しい。これを行うには、アプリケーションがIPv6_recvpktinfoソケットオプションのみを有効にすることができ、recvmsg（）の受信制御情報をsendmsg（）の発信制御情報として使用できます。IN6_PKTINFO構造。しかし、この構造にホップ制限が含まれている場合、受信したホップ制限は発信パケットの望ましい値ではないため、受信した制御情報を解析してホップ制限メンバーを変更する必要があります。）"
    },
    {
      "indent": 0,
      "text": "6.1. Specifying/Receiving the Interface",
      "section_title": true,
      "ja": "6.1. インターフェイスの指定/受信"
    },
    {
      "indent": 3,
      "text": "Interfaces on an IPv6 node are identified by a small positive integer, as described in Section 4 of [RFC-3493]. That document also describes a function to map an interface name to its interface index, a function to map an interface index to its interface name, and a function to return all the interface names and indexes. Notice from this document that no interface is ever assigned an index of 0.",
      "ja": "IPv6ノード上のインターフェイスは、[RFC-3493]のセクション4で説明されているように、小さな正の整数によって識別されます。このドキュメントでは、インターフェイス名をインターフェイスインデックスにマッピングする関数、インターフェイスインデックスをインターフェイス名にマッピングする関数、およびすべてのインターフェイス名とインデックスを返す関数についても説明します。このドキュメントから、インターフェイスが0のインデックスが割り当てられていないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "When specifying the outgoing interface, if the ipi6_ifindex value is 0, the kernel will choose the outgoing interface.",
      "ja": "発信インターフェイスを指定する場合、IPI6_ifindex値が0の場合、カーネルは発信インターフェイスを選択します。"
    },
    {
      "indent": 3,
      "text": "The ordering among various options that can specify the outgoing interface, including IPV6_PKTINFO, is defined in Section 6.7.",
      "ja": "IPv6_pktinfoを含む発信インターフェイスを指定できるさまざまなオプションの順序付けは、セクション6.7で定義されています。"
    },
    {
      "indent": 3,
      "text": "When the IPV6_RECVPKTINFO socket option is enabled, the received interface index is always returned as the ipi6_ifindex member of the in6_pktinfo structure.",
      "ja": "IPv6_Recvpktinfoソケットオプションが有効になっている場合、受信されたインターフェイスインデックスは、IN6_PKTINFO構造のIPI6_IFINDEXメンバーとして常に返されます。"
    },
    {
      "indent": 0,
      "text": "6.2. Specifying/Receiving Source/Destination Address",
      "section_title": true,
      "ja": "6.2. ソース/宛先アドレスの指定/受信"
    },
    {
      "indent": 3,
      "text": "The source IPv6 address can be specified by calling bind() before each output operation, but supplying the source address together with the data requires less overhead (i.e., fewer system calls) and requires less state to be stored and protected in a multithreaded application.",
      "ja": "ソースIPv6アドレスは、各出力操作の前にbind（）を呼び出すことで指定できますが、ソースアドレスをデータと一緒に供給するには、より少ないオーバーヘッド（つまり、システム呼び出しが少なくなります）が必要であり、マルチスレッドアプリケーションで保存および保護される必要が少なくなります。"
    },
    {
      "indent": 3,
      "text": "When specifying the source IPv6 address as ancillary data, if the ipi6_addr member of the in6_pktinfo structure is the unspecified address (IN6ADDR_ANY_INIT or in6addr_any), then (a) if an address is currently bound to the socket, it is used as the source address, or (b) if no address is currently bound to the socket, the kernel will choose the source address. If the ipi6_addr member is not the unspecified address, but the socket has already bound a source address, then the ipi6_addr value overrides the already-bound source address for this output operation only.",
      "ja": "ソースIPv6アドレスを補助データとして指定する場合、IN6_PKTINFO構造のIPI6_ADDRメンバーが不特定のアドレス（IN6ADDR_ANY_INITまたはIN6ADDR_ANY）である場合、（a）アドレスが現在ソケットにバインドされている場合、ソースアドレスとして使用されます。または（b）現在ソケットにアドレスがバインドされていない場合、カーネルはソースアドレスを選択します。IPI6_ADDRメンバーが不特定のアドレスではないが、ソケットがすでにソースアドレスをバインドしている場合、IPI6_ADDR値は、この出力操作のみの既にバインドされたソースアドレスをオーバーライドします。"
    },
    {
      "indent": 3,
      "text": "The kernel must verify that the requested source address is indeed a unicast address assigned to the node. When the address is a scoped one, there may be ambiguity about its scope zone. This is particularly the case for link-local addresses. In such a case, the kernel must first determine the appropriate scope zone based on the zone of the destination address or the outgoing interface (if known), then qualify the address. This also means that it is not feasible to specify the source address for a non-binding socket by the IPV6_PKTINFO sticky option, unless the outgoing interface is also specified. The application should simply use bind() for such purposes.",
      "ja": "カーネルは、要求されたソースアドレスが実際にノードに割り当てられたユニキャストアドレスであることを確認する必要があります。アドレスがスコープされたものである場合、そのスコープゾーンには曖昧さがあるかもしれません。これは、特にLink-Localアドレスの場合です。そのような場合、カーネルは、最初に宛先アドレスのゾーンまたは発信インターフェイス（既知の場合）に基づいて適切なスコープゾーンを決定する必要があります。これはまた、発信インターフェイスも指定されていない限り、IPv6_pktinfoスティッキーオプションによって、非バインディングソケットのソースアドレスを指定することが不可能であることを意味します。アプリケーションは、そのような目的でBind（）を単に使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "IPV6_PKTINFO can also be used as a sticky option for specifying the socket's default source address. However, the ipi6_addr member must be the unspecified address for TCP sockets, because it is not possible to dynamically change the source address of a TCP connection. When the IPV6_PKTINFO option is specified for a TCP socket with a non-unspecified address, the call will fail. This restriction should be applied even before the socket binds a specific address.",
      "ja": "IPv6_pktinfoは、ソケットのデフォルトのソースアドレスを指定するための粘着性オプションとしても使用できます。ただし、TCP接続のソースアドレスを動的に変更することはできないため、IPI6_ADDRメンバーはTCPソケットの不特定のアドレスである必要があります。IPv6_pktinfoオプションが、非指定されていないアドレスを備えたTCPソケットに指定されている場合、通話は失敗します。この制限は、ソケットが特定のアドレスにバインドする前であっても適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "When the in6_pktinfo structure is returned as ancillary data by recvmsg(), the ipi6_addr member contains the destination IPv6 address from the received packet.",
      "ja": "in6_pktinfo構造がrecvmsg（）によって補助データとして返される場合、IPI6_ADDRメンバーには受信パケットの宛先IPv6アドレスが含まれます。"
    },
    {
      "indent": 0,
      "text": "6.3. Specifying/Receiving the Hop Limit",
      "section_title": true,
      "ja": "6.3. ホップ制限の指定/受信"
    },
    {
      "indent": 3,
      "text": "The outgoing hop limit is normally specified with either the IPV6_UNICAST_HOPS socket option or the IPV6_MULTICAST_HOPS socket option, both of which are described in [RFC-3493]. Specifying the hop limit as ancillary data lets the application override either the kernel's default or a previously specified value, for either a unicast destination or a multicast destination, for a single output operation. Returning the received hop limit is useful for IPv6 applications that need to verify that the received hop limit is 255 (e.g., that the packet has not been forwarded).",
      "ja": "発信ホップ制限は、通常、IPv6_unicast_hopsソケットオプションまたはIPv6_multicast_hopsソケットオプションのいずれかで指定されます。どちらも[RFC-3493]で説明されています。ホップ制限を補助データとして指定すると、アプリケーションは、ユニキャスト宛先またはマルチキャスト宛先のいずれかのカーネルのデフォルトまたは以前に指定された値のいずれかを、単一の出力操作にオーバーライドできます。受信したホップ制限を返すことは、受信したホップ制限が255であることを確認する必要があるIPv6アプリケーションに役立ちます（たとえば、パケットが転送されていないこと）。"
    },
    {
      "indent": 3,
      "text": "The received hop limit is returned as ancillary data by recvmsg() only if the application has enabled the IPV6_RECVHOPLIMIT socket option:",
      "ja": "受信したホップ制限は、アプリケーションがIPv6_Recvhoplimitソケットオプションを有効にした場合にのみ、recvmsg（）によって補助データとして返されます。"
    },
    {
      "indent": 6,
      "text": "int  on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVHOPLIMIT, &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the cmsghdr structure containing this ancillary data, the cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be IPV6_HOPLIMIT, and the first byte of cmsg_data[] will be the first byte of the integer hop limit.",
      "ja": "この補助データを含むCMSGHDR構造では、CMSG_LEVELメンバーはIPPROTO_IPV6であり、CMSG_TYPEメンバーはIPv6_hoplimitであり、CMSG_DATA []の最初のバイトは整数ホップ制限の最初のバイトになります。"
    },
    {
      "indent": 3,
      "text": "Nothing special need be done to specify the outgoing hop limit: just specify the control information as ancillary data for sendmsg(). As specified in [RFC-3493], the interpretation of the integer hop limit value is",
      "ja": "発信ホップ制限を指定するために特別なことは何もありません。SendMSG（）の補助データとして制御情報を指定するだけです。[RFC-3493]で指定されているように、整数ホップ制限値の解釈は"
    },
    {
      "indent": 6,
      "text": "x < -1:        return an error of EINVAL\nx == -1:       use kernel default\n0 <= x <= 255: use x\nx >= 256:      return an error of EINVAL",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This API defines IPV6_HOPLIMIT as an ancillary-only option, that is, the option name cannot be used as a socket option. This is because [RFC-3493] has more fine-grained socket options; IPV6_UNICAST_HOPS and IPV6_MULTICAST_HOPS.",
      "ja": "このAPIは、IPv6_hoplimitを補助のみのオプションとして定義します。つまり、オプション名はソケットオプションとして使用できません。これは、[RFC-3493]にはより細かいソケットオプションがあるためです。ipv6_unicast_hopsおよびipv6_multicast_hops。"
    },
    {
      "indent": 0,
      "text": "6.4. Specifying the Next Hop Address",
      "section_title": true,
      "ja": "6.4. 次のホップアドレスを指定します"
    },
    {
      "indent": 3,
      "text": "The IPV6_NEXTHOP ancillary data object specifies the next hop for the datagram as a socket address structure. In the cmsghdr structure containing this ancillary data, the cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be IPV6_NEXTHOP, and the first byte of cmsg_data[] will be the first byte of the socket address structure.",
      "ja": "IPv6_Nexthop Ancillary Dataオブジェクトは、ソケットアドレス構造としてデータグラムの次のホップを指定します。この補助データを含むCMSGHDR構造では、CMSG_LEVELメンバーはIPPROTO_IPV6であり、CMSG_TYPEメンバーはIPv6_Nexthopであり、CMSG_DATA []の最初のバイトはソケットアドレス構造の最初のバイトになります。"
    },
    {
      "indent": 3,
      "text": "This is a privileged option. (Note: It is implementation defined and beyond the scope of this document to define what \"privileged\" means. Unix systems use this term to mean the process must have an effective user ID of 0.) This API only defines the case where the socket address contains an IPv6 address (i.e., the sa_family member is AF_INET6). And, in this case, the node identified by that address must be a neighbor of the sending host. If that address equals the destination IPv6 address of the datagram, then this is equivalent to the existing SO_DONTROUTE socket option.",
      "ja": "これは特権的なオプションです。（注：「特権」の意味を定義するために、このドキュメントの範囲を超えて定義されている実装です。UNIXシステムは、この用語を使用して、効果的なユーザーIDを持つ必要があることを意味しますアドレスにはIPv6アドレスが含まれています（つまり、SA_FamilyメンバーはAF_INET6です）。そして、この場合、そのアドレスによって識別されたノードは、送信ホストの隣人でなければなりません。そのアドレスがデータグラムの宛先IPv6アドレスに等しい場合、これは既存のSO_DONTROUTEソケットオプションに相当します。"
    },
    {
      "indent": 3,
      "text": "This option does not have any meaning for multicast destinations. In such a case, the specified next hop will be ignored.",
      "ja": "このオプションには、マルチキャストの目的地には意味がありません。そのような場合、指定された次のホップは無視されます。"
    },
    {
      "indent": 3,
      "text": "When the outgoing interface is specified by IPV6_PKTINFO as well, the next hop specified by this option must be reachable via the specified interface.",
      "ja": "発信インターフェイスがIPv6_pktinfoによっても指定されている場合、このオプションで指定された次のホップは、指定されたインターフェイスを介して到達可能でなければなりません。"
    },
    {
      "indent": 3,
      "text": "In order to clear a sticky IPV6_NEXTHOP option the application must issue a setsockopt for IPV6_NEXTHOP with a zero length.",
      "ja": "Sticky IPv6_Nexthopオプションをクリアするには、アプリケーションはゼロの長さのIPv6_NexthopのSetSockoptを発行する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.5. Specifying/Receiving the Traffic Class value",
      "section_title": true,
      "ja": "6.5. トラフィッククラスの値の指定/受信"
    },
    {
      "indent": 3,
      "text": "The outgoing traffic class is normally set to 0. Specifying the traffic class as ancillary data lets the application override either the kernel's default or a previously specified value, for either a unicast destination or a multicast destination, for a single output operation. Returning the received traffic class is useful for programs such as a diffserv debugging tool and for user level ECN (explicit congestion notification) implementation.",
      "ja": "発信トラフィッククラスは通常0に設定されています。トラフィッククラスを補助データとして指定すると、アプリケーションは、ユニキャスト宛先またはマルチキャストの宛先のいずれかについて、カーネルのデフォルトまたは以前に指定された値のいずれかを単一の出力操作にオーバーライドできます。受信したトラフィッククラスを返すことは、DiffServデバッグツールなどのプログラムや、ユーザーレベルのECN（明示的な混雑通知）の実装に役立ちます。"
    },
    {
      "indent": 3,
      "text": "The received traffic class is returned as ancillary data by recvmsg() only if the application has enabled the IPV6_RECVTCLASS socket option:",
      "ja": "受信したトラフィッククラスは、アプリケーションがIPv6_RecvtClassソケットオプションを有効にした場合にのみ、recvmsg（）によって補助データとして返されます。"
    },
    {
      "indent": 6,
      "text": "int  on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVTCLASS, &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the cmsghdr structure containing this ancillary data, the cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be IPV6_TCLASS, and the first byte of cmsg_data[] will be the first byte of the integer traffic class.",
      "ja": "この補助データを含むCMSGHDR構造では、CMSG_LEVELメンバーはIPPROTO_IPV6であり、CMSG_TYPEメンバーはIPv6_TCLASSであり、CMSG_DATA []の最初のバイトは整数トラフィッククラスの最初のバイトになります。"
    },
    {
      "indent": 3,
      "text": "To specify the outgoing traffic class value, just specify the control information as ancillary data for sendmsg() or using setsockopt(). Just like the hop limit value, the interpretation of the integer traffic class value is",
      "ja": "発信トラフィッククラスの値を指定するには、制御情報をsendmsg（）の補助データとして指定するか、setsockopt（）を使用してください。ホップ制限値と同じように、整数トラフィッククラス値の解釈は"
    },
    {
      "indent": 6,
      "text": "x < -1:        return an error of EINVAL\nx == -1:       use kernel default\n0 <= x <= 255: use x\nx >= 256:      return an error of EINVAL",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In order to clear a sticky IPV6_TCLASS option the application can specify -1 as the value.",
      "ja": "粘着性のあるIPv6_TCLASSオプションをクリアするために、アプリケーションは-1を値として指定できます。"
    },
    {
      "indent": 3,
      "text": "There are cases where the kernel needs to control the traffic class value and conflicts with the user-specified value on the outgoing traffic. An example is an implementation of ECN in the kernel, setting 2 bits of the traffic class value. In such cases, the kernel should override the user-specified value. On the incoming traffic, the kernel may mask some of the bits in the traffic class field.",
      "ja": "カーネルがトラフィッククラスの値を制御し、発信トラフィックのユーザー指定値と競合する必要がある場合があります。例は、カーネルでのECNの実装であり、トラフィッククラス値の2ビットを設定します。そのような場合、カーネルはユーザー指定値をオーバーライドする必要があります。着信トラフィックでは、カーネルはトラフィッククラスフィールドの一部のビットをマスクする場合があります。"
    },
    {
      "indent": 0,
      "text": "6.6. Additional Errors with sendmsg() and setsockopt()",
      "section_title": true,
      "ja": "6.6. sendmsg（）およびsetSockopt（）を使用した追加のエラー"
    },
    {
      "indent": 3,
      "text": "With the IPV6_PKTINFO socket option there are no additional errors possible with the call to recvmsg(). But when specifying the outgoing interface or the source address, additional errors are possible from sendmsg() or setsockopt(). Note that some implementations might only be able to return this type of errors for setsockopt(). The following are examples, but some of these may not be provided by some implementations, and some implementations may define additional errors:",
      "ja": "IPv6_pktinfoソケットオプションを使用すると、Recvmsg（）への呼び出しで追加のエラーはありません。ただし、発信インターフェイスまたはソースアドレスを指定する場合、sendmsg（）またはsetsockopt（）から追加のエラーが可能です。いくつかの実装は、setSockopt（）のこのタイプのエラーのみを返すことができる場合があることに注意してください。以下は例ですが、これらのいくつかはいくつかの実装によって提供されない場合があり、いくつかの実装では追加のエラーを定義する場合があります。"
    },
    {
      "indent": 3,
      "text": "ENXIO The interface specified by ipi6_ifindex does not exist.",
      "ja": "enxio ipi6_ifindexによって指定されたインターフェイスは存在しません。"
    },
    {
      "indent": 3,
      "text": "ENETDOWN The interface specified by ipi6_ifindex is not enabled for IPv6 use.",
      "ja": "ENETDOWN IPI6_IFINDEXで指定されたインターフェイスは、IPv6の使用には有効になっていません。"
    },
    {
      "indent": 3,
      "text": "EADDRNOTAVAIL ipi6_ifindex specifies an interface but the address ipi6_addr is not available for use on that interface.",
      "ja": "eaddrnotavail ipi6_ifindexインターフェイスを指定しますが、アドレスIPI6_addrはそのインターフェイスで使用できません。"
    },
    {
      "indent": 3,
      "text": "EHOSTUNREACH No route to the destination exists over the interface specified by ipi6_ifindex.",
      "ja": "ehostunReach IPI6_IFINDEXで指定されたインターフェイス上に宛先へのルートはありません。"
    },
    {
      "indent": 0,
      "text": "6.7. Summary of Outgoing Interface Selection",
      "section_title": true,
      "ja": "6.7. 発信インターフェイス選択の概要"
    },
    {
      "indent": 3,
      "text": "This document and [RFC-3493] specify various methods that affect the selection of the packet's outgoing interface. This subsection summarizes the ordering among those in order to ensure deterministic behavior.",
      "ja": "このドキュメントと[RFC-3493]は、パケットの発信インターフェイスの選択に影響するさまざまな方法を指定します。このサブセクションは、決定論的な行動を確保するために、それらの間の順序を要約しています。"
    },
    {
      "indent": 3,
      "text": "For a given outgoing packet on a given socket, the outgoing interface is determined in the following order:",
      "ja": "特定のソケットの特定の発信パケットの場合、発信インターフェイスは次の順序で決定されます。"
    },
    {
      "indent": 3,
      "text": "1. if an interface is specified in an IPV6_PKTINFO ancillary data item, the interface is used.",
      "ja": "1. IPv6_pktinfo補助データ項目でインターフェイスが指定されている場合、インターフェイスが使用されます。"
    },
    {
      "indent": 3,
      "text": "2. otherwise, if an interface is specified in an IPV6_PKTINFO sticky option, the interface is used.",
      "ja": "2. それ以外の場合、IPv6_pktinfo Stickyオプションでインターフェイスが指定されている場合、インターフェイスが使用されます。"
    },
    {
      "indent": 3,
      "text": "3. otherwise, if the destination address is a multicast address and the IPV6_MULTICAST_IF socket option is specified for the socket, the interface is used.",
      "ja": "3. それ以外の場合、宛先アドレスがマルチキャストアドレスであり、IPv6_multicast_ifソケットオプションがソケットに指定されている場合、インターフェイスが使用されます。"
    },
    {
      "indent": 3,
      "text": "4. otherwise, if an IPV6_NEXTHOP ancillary data item is specified, the interface to the next hop is used.",
      "ja": "4. それ以外の場合、IPv6_nexthopの補助データ項目が指定されている場合、次のホップへのインターフェイスが使用されます。"
    },
    {
      "indent": 3,
      "text": "5. otherwise, if an IPV6_NEXTHOP sticky option is specified, the interface to the next hop is used.",
      "ja": "5. それ以外の場合、IPv6_Nexthop Stickyオプションが指定されている場合、次のホップへのインターフェイスが使用されます。"
    },
    {
      "indent": 3,
      "text": "6. otherwise, the outgoing interface should be determined in an implementation dependent manner.",
      "ja": "6. それ以外の場合、発信インターフェイスは、実装依存の方法で決定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The ordering above particularly means if the application specifies an interface by the IPV6_MULTICAST_IF socket option (described in [RFC-3493]) as well as specifying a different interface by the IPV6_PKTINFO sticky option, the latter will override the former for every multicast packet on the corresponding socket. The reason for the ordering comes from expectation that the source address is specified as well and that the pair of the address and the outgoing interface should be preferred.",
      "ja": "上記の順序は、特にアプリケーションがIPv6_multicast_ifソケットオプション（[RFC-3493]で説明）によってインターフェイスを指定し、IPv6_pktinfoのスティッキーオプションによって異なるインターフェイスを指定する場合、後者は前者をオーバーライドします。対応するソケット。注文の理由は、ソースアドレスも指定されており、アドレスのペアと発信インターフェイスを優先することを期待することに起因しています。"
    },
    {
      "indent": 3,
      "text": "In any case, the kernel must also verify that the source and destination addresses do not break their scope zones with regard to the outgoing interface.",
      "ja": "いずれにせよ、カーネルは、ソースと宛先アドレスが発信インターフェイスに関してスコープゾーンを破らないことを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "7. Routing Header Option",
      "section_title": true,
      "ja": "7. ルーティングヘッダーオプション"
    },
    {
      "indent": 3,
      "text": "Source routing in IPv6 is accomplished by specifying a Routing header as an extension header. There can be different types of Routing headers, but IPv6 currently defines only the Type 0 Routing header [RFC-2460]. This type supports up to 127 intermediate nodes (limited by the length field in the extension header). With this maximum number of intermediate nodes, a source, and a destination, there are 128 hops.",
      "ja": "IPv6のソースルーティングは、ルーティングヘッダーを拡張ヘッダーとして指定することにより達成されます。ルーティングヘッダーにはさまざまな種類がありますが、IPv6は現在、タイプ0ルーティングヘッダー[RFC-2460]のみを定義しています。このタイプは、最大127個の中間ノードをサポートします（拡張ヘッダーの長さフィールドによって制限されます）。この最大数の中間ノード、ソース、および宛先には、128ホップがあります。"
    },
    {
      "indent": 3,
      "text": "Source routing with the IPv4 sockets API (the IP_OPTIONS socket option) requires the application to build the source route in the format that appears as the IPv4 header option, requiring intimate knowledge of the IPv4 options format. This IPv6 API, however, defines six functions that the application calls to build and examine a Routing header, and the ability to use sticky options or ancillary data to communicate this information between the application and the kernel using the IPV6_RTHDR option.",
      "ja": "IPv4ソケットAPI（IP_OPTIONSソケットオプション）を使用したソースルーティングでは、IPv4ヘッダーオプションとして表示される形式でソースルートを構築するためにアプリケーションが必要であるため、IPv4オプション形式の詳細な知識が必要です。ただし、このIPv6 APIは、アプリケーションがルーティングヘッダーを構築および調査するために呼び出す6つの機能と、IPv6_RTHDRオプションを使用してアプリケーションとカーネル間でこの情報を通信するために粘着性オプションまたは補助データを使用する機能を定義します。"
    },
    {
      "indent": 3,
      "text": "Three functions build a Routing header:",
      "ja": "3つの関数はルーティングヘッダーを構築します。"
    },
    {
      "indent": 6,
      "text": "inet6_rth_space()    - return #bytes required for Routing header\ninet6_rth_init()     - initialize buffer data for Routing header\ninet6_rth_add()      - add one IPv6 address to the Routing header",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Three functions deal with a returned Routing header:",
      "ja": "3つの関数は、返されたルーティングヘッダーを扱います。"
    },
    {
      "indent": 6,
      "text": "inet6_rth_reverse()  - reverse a Routing header\ninet6_rth_segments() - return #segments in a Routing header\ninet6_rth_getaddr()  - fetch one address from a Routing header",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The function prototypes for these functions are defined as a result of including <netinet/in.h>.",
      "ja": "これらの関数の関数プロトタイプは、<netinet/in.h>を含める結果として定義されます。"
    },
    {
      "indent": 3,
      "text": "To receive a Routing header the application must enable the IPV6_RECVRTHDR socket option:",
      "ja": "ルーティングヘッダーを受信するには、アプリケーションがIPv6_RecvrthDRソケットオプションを有効にする必要があります。"
    },
    {
      "indent": 6,
      "text": "int  on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVRTHDR, &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each received Routing header is returned as one ancillary data object described by a cmsghdr structure with cmsg_type set to IPV6_RTHDR. When multiple Routing headers are received, multiple ancillary data objects (with cmsg_type set to IPV6_RTHDR) will be returned to the application.",
      "ja": "受信したルーティングヘッダーは、CMSG_TypeがIPv6_RTHDRに設定されたCMSGHDR構造によって記述された1つの補助データオブジェクトとして返されます。複数のルーティングヘッダーを受信すると、複数の補助データオブジェクト（CMSG_TypeがIPv6_RTHDRに設定されています）がアプリケーションに返されます。"
    },
    {
      "indent": 3,
      "text": "To send a Routing header the application specifies it either as ancillary data in a call to sendmsg() or using setsockopt(). For the sending side, this API assumes the number of occurrences of the Routing header as described in [RFC-2460]. That is, applications can only specify at most one outgoing Routing header.",
      "ja": "ルーティングヘッダーを送信するには、アプリケーションはそれをsendmsg（）への呼び出しで補助データとして指定するか、setsockopt（）を使用します。送信側の場合、このAPIは[RFC-2460]で説明されているように、ルーティングヘッダーの発生数を想定しています。つまり、アプリケーションは最大で1つの発信ルーティングヘッダーのみを指定できます。"
    },
    {
      "indent": 3,
      "text": "The application can remove any sticky Routing header by calling setsockopt() for IPV6_RTHDR with a zero option length.",
      "ja": "アプリケーションは、ゼロオプションの長さでIPv6_rthdrのSetSockopt（）を呼び出すことにより、粘着性のルーティングヘッダーを削除できます。"
    },
    {
      "indent": 3,
      "text": "When using ancillary data a Routing header is passed between the application and the kernel as follows: The cmsg_level member has a value of IPPROTO_IPV6 and the cmsg_type member has a value of IPV6_RTHDR. The contents of the cmsg_data[] member is implementation dependent and should not be accessed directly by the application, but should be accessed using the six functions that we are about to describe.",
      "ja": "補助データを使用する場合、アプリケーションとカーネルの間に次のようにルーティングヘッダーが渡されます。CMSG_LEVELメンバーはIPPROTO_IPV6の値を持ち、CMSG_TYPEメンバーはIPv6_RTHDRの値を持っています。CMSG_DATA []メンバーの内容は実装依存であり、アプリケーションで直接アクセスする必要はありませんが、説明しようとしている6つの関数を使用してアクセスする必要があります。"
    },
    {
      "indent": 3,
      "text": "The following constant is defined as a result of including the <netinet/in.h>:",
      "ja": "次の定数は、<netinet/in.h>を含める結果として定義されます。"
    },
    {
      "indent": 6,
      "text": "#define IPV6_RTHDR_TYPE_0    0 /* IPv6 Routing header type 0 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When a Routing header is specified, the destination address specified for connect(), sendto(), or sendmsg() is the final destination address of the datagram. The Routing header then contains the addresses of all the intermediate nodes.",
      "ja": "ルーティングヘッダーが指定されている場合、connect（）、sendto（）、またはsendmsg（）に指定された宛先アドレスがデータグラムの最終宛先アドレスです。ルーティングヘッダーには、すべての中間ノードのアドレスが含まれます。"
    },
    {
      "indent": 0,
      "text": "7.1. inet6_rth_space",
      "section_title": true,
      "ja": "7.1. inet6_rth_space"
    },
    {
      "indent": 6,
      "text": "socklen_t inet6_rth_space(int type, int segments);",
      "ja": "socklen_t inet6_rth_space（int type、int segments）;"
    },
    {
      "indent": 3,
      "text": "This function returns the number of bytes required to hold a Routing header of the specified type containing the specified number of segments (addresses). For an IPv6 Type 0 Routing header, the number of segments must be between 0 and 127, inclusive. The return value is just the space for the Routing header. When the application uses ancillary data it must pass the returned length to CMSG_SPACE() to determine how much memory is needed for the ancillary data object (including the cmsghdr structure).",
      "ja": "この関数は、指定されたセグメント数（アドレス）を含む指定されたタイプのルーティングヘッダーを保持するために必要なバイト数を返します。IPv6タイプ0ルーティングヘッダーの場合、セグメントの数は0〜127でなければなりません。返品値は、ルーティングヘッダーのスペースにすぎません。アプリケーションが補助データを使用する場合、返された長さをCMSG_SPACE（）に渡す必要があります。"
    },
    {
      "indent": 3,
      "text": "If the return value is 0, then either the type of the Routing header is not supported by this implementation or the number of segments is invalid for this type of Routing header.",
      "ja": "戻り値が0の場合、この実装によってルーティングヘッダーのタイプがサポートされていないか、このタイプのルーティングヘッダーに対してセグメントの数が無効です。"
    },
    {
      "indent": 3,
      "text": "(Note: This function returns the size but does not allocate the space required for the ancillary data. This allows an application to allocate a larger buffer, if other ancillary data objects are desired, since all the ancillary data objects must be specified to sendmsg() as a single msg_control buffer.)",
      "ja": "（注：この関数はサイズを返しますが、補助データに必要なスペースを割り当てません。これにより、他の補助データオブジェクトが必要な場合、すべての補助データオブジェクトをSENDMSGに指定する必要があるため、より大きなバッファーを割り当てることができます。）単一のMSG_CONTROLバッファとして。）"
    },
    {
      "indent": 0,
      "text": "7.2. inet6_rth_init",
      "section_title": true,
      "ja": "7.2. inet6_rth_init"
    },
    {
      "indent": 6,
      "text": "void *inet6_rth_init(void *bp, socklen_t bp_len, int type,\n                     int segments);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This function initializes the buffer pointed to by bp to contain a Routing header of the specified type and sets ip6r_len based on the segments parameter. bp_len is only used to verify that the buffer is large enough. The ip6r_segleft field is set to zero; inet6_rth_add() will increment it.",
      "ja": "この関数は、指定されたバッファーを初期化して、指定されたタイプのルーティングヘッダーを含み、セグメントパラメーターに基づいてIP6R_LENを設定します。BP_LENは、バッファが十分に大きいことを確認するためにのみ使用されます。IP6R_SEGLEFTフィールドはゼロに設定されています。inet6_rth_add（）はそれを増やします。"
    },
    {
      "indent": 3,
      "text": "When the application uses ancillary data the application must initialize any cmsghdr fields.",
      "ja": "アプリケーションが補助データを使用する場合、アプリケーションはCMSGHDRフィールドを初期化する必要があります。"
    },
    {
      "indent": 3,
      "text": "The caller must allocate the buffer and its size can be determined by calling inet6_rth_space().",
      "ja": "発信者はバッファーを割り当てる必要があり、そのサイズはINET6_RTH_SPACE（）を呼び出すことで決定できます。"
    },
    {
      "indent": 3,
      "text": "Upon success the return value is the pointer to the buffer (bp), and this is then used as the first argument to the inet6_rth_add() function. Upon an error the return value is NULL.",
      "ja": "成功すると、戻り値はバッファー（BP）へのポインターであり、これはINET6_RTH_ADD（）関数の最初の引数として使用されます。エラーが発生すると、返品値はnullです。"
    },
    {
      "indent": 0,
      "text": "7.3. inet6_rth_add",
      "section_title": true,
      "ja": "7.3. inet6_rth_add"
    },
    {
      "indent": 6,
      "text": "int inet6_rth_add(void *bp, const struct in6_addr *addr);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This function adds the IPv6 address pointed to by addr to the end of the Routing header being constructed.",
      "ja": "この関数は、構築されているルーティングヘッダーの最後にADDRによって指されたIPv6アドレスを追加します。"
    },
    {
      "indent": 3,
      "text": "If successful, the segleft member of the Routing Header is updated to account for the new address in the Routing header and the return value of the function is 0. Upon an error the return value of the function is -1.",
      "ja": "成功した場合、ルーティングヘッダーのsegleftメンバーが更新され、ルーティングヘッダーの新しいアドレスが考慮され、関数の戻り値は0です。エラー上、関数の返品値は-1です。"
    },
    {
      "indent": 0,
      "text": "7.4. inet6_rth_reverse",
      "section_title": true,
      "ja": "7.4. inet6_rth_reverse"
    },
    {
      "indent": 6,
      "text": "int inet6_rth_reverse(const void *in, void *out);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This function takes a Routing header extension header (pointed to by the first argument) and writes a new Routing header that sends datagrams along the reverse of that route. The function reverses the order of the addresses and sets the segleft member in the new Routing header to the number of segments. Both arguments are allowed to point to the same buffer (that is, the reversal can occur in place).",
      "ja": "この関数は、ルーティングヘッダーエクステンションヘッダー（最初の引数で指された）を取り、そのルートの裏側に沿ってデータグラムを送信する新しいルーティングヘッダーを書き込みます。この関数は、アドレスの順序を逆転させ、新しいルーティングヘッダーにSegleftメンバーをセグメントの数に設定します。どちらの引数も同じバッファーを指すことが許可されています（つまり、逆転が所定の位置に発生する可能性があります）。"
    },
    {
      "indent": 3,
      "text": "The return value of the function is 0 on success, or -1 upon an error.",
      "ja": "関数の返品値は成功した場合は0、エラー時に-1です。"
    },
    {
      "indent": 0,
      "text": "7.5. inet6_rth_segments",
      "section_title": true,
      "ja": "7.5. inet6_rth_segments"
    },
    {
      "indent": 6,
      "text": "int inet6_rth_segments(const void *bp);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This function returns the number of segments (addresses) contained in the Routing header described by bp. On success the return value is zero or greater. The return value of the function is -1 upon an error.",
      "ja": "この関数は、BPで記述されたルーティングヘッダーに含まれるセグメントの数（アドレス）の数を返します。成功すると、返品値はゼロ以上です。関数の返品値は、エラー時に-1です。"
    },
    {
      "indent": 0,
      "text": "7.6. inet6_rth_getaddr",
      "section_title": true,
      "ja": "7.6. inet6_rth_getaddr"
    },
    {
      "indent": 6,
      "text": "struct in6_addr *inet6_rth_getaddr(const void *bp, int index);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This function returns a pointer to the IPv6 address specified by index (which must have a value between 0 and one less than the value returned by inet6_rth_segments()) in the Routing header described by bp. An application should first call inet6_rth_segments() to obtain the number of segments in the Routing header.",
      "ja": "この関数は、インデックスで指定されたIPv6アドレスへのポインターを返します（BPが記述されたルーティングヘッダーで、INET6_RTH_SEGMENTS（）によって返される値より0〜1個の値が必要です）。アプリケーションは、最初にinet6_rth_segments（）を呼び出して、ルーティングヘッダーのセグメントの数を取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "Upon an error the return value of the function is NULL.",
      "ja": "エラー時に、関数の返品値はnullです。"
    },
    {
      "indent": 0,
      "text": "8. Hop-By-Hop Options",
      "section_title": true,
      "ja": "8. ホップバイホップオプション"
    },
    {
      "indent": 3,
      "text": "A variable number of Hop-by-Hop options can appear in a single Hop-by-Hop options header. Each option in the header is TLV-encoded with a type, length, and value. This IPv6 API defines seven functions that the application calls to build and examine a Hop-by_Hop options header, and the ability to use sticky options or ancillary data to communicate this information between the application and the kernel. This uses the IPV6_HOPOPTS for a Hop-by-Hop options header.",
      "ja": "さまざまな数のホップバイホップオプションが、単一のホップバイホップオプションヘッダーに表示されます。ヘッダー内の各オプションは、タイプ、長さ、および値でTLVエンコードされています。このIPv6 APIは、アプリケーションがホップ-by_hopオプションヘッダーを構築および調査するために呼び出す7つの関数と、粘着性オプションまたは補助データを使用してアプリケーションとカーネルの間でこの情報を通知する機能を定義します。これは、ホップバイホップオプションヘッダーにIPv6_hopoptsを使用します。"
    },
    {
      "indent": 3,
      "text": "Today several Hop-by-Hop options are defined for IPv6. Two pad options, Pad1 and PadN, are for alignment purposes and are automatically inserted by the inet6_opt_XXX() routines and ignored by the inet6_opt_XXX() routines on the receive side. This section of the API is therefore defined for other (and future) Hop-by-Hop options that an application may need to specify and receive.",
      "ja": "今日、IPv6に対していくつかのホップバイホップオプションが定義されています。2つのパッドオプション、PAD1とPADNはアライメント目的であり、INET6_OPT_XXX（）ルーチンによって自動的に挿入され、受信側のINET6_OPT_XXX（）ルーチンによって無視されます。したがって、APIのこのセクションは、アプリケーションが指定および受信する必要がある他の（および将来の）ホップバイホップオプションに対して定義されています。"
    },
    {
      "indent": 3,
      "text": "Four functions build an options header:",
      "ja": "4つの関数はオプションヘッダーを作成します。"
    },
    {
      "indent": 6,
      "text": "inet6_opt_init()     - initialize buffer data for options header\ninet6_opt_append()   - add one TLV option to the options header\ninet6_opt_finish()   - finish adding TLV options to the options\n                       header\ninet6_opt_set_val()  - add one component of the option content to\n                       the option",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Three functions deal with a returned options header:",
      "ja": "3つの関数は、返されたオプションヘッダーを扱います。"
    },
    {
      "indent": 6,
      "text": "inet6_opt_next() - extract the next option from the options header inet6_opt_find() - extract an option of a specified type from the header inet6_opt_get_val() - retrieve one component of the option content",
      "ja": "inet6_opt_next（） - オプションヘッダーinet6_opt_find（）から次のオプションを抽出 - ヘッダーinet6_opt_get_val（）から指定されたタイプのオプションを抽出 - オプションコンテンツの1つのコンポーネントを取得します"
    },
    {
      "indent": 3,
      "text": "Individual Hop-by-Hop options (and Destination options, which are described in Section 9 and are very similar to the Hop-by-Hop options) may have specific alignment requirements. For example, the 4-byte Jumbo Payload length should appear on a 4-byte boundary, and IPv6 addresses are normally aligned on an 8-byte boundary. These requirements and the terminology used with these options are discussed in Section 4.2 and Appendix B of [RFC-2460]. The alignment of first byte of each option is specified by two values, called x and y, written as \"xn + y\". This states that the option must appear at an integer multiple of x bytes from the beginning of the options header (x can have the values 1, 2, 4, or 8), plus y bytes (y can have a value between 0 and 7, inclusive). The Pad1 and PadN options are inserted as needed to maintain the required alignment. The functions below need to know the alignment of the end of the option (which is always in the form \"xn,\" where x can have the values 1, 2, 4, or 8) and the total size of the data portion of the option. These are passed as the \"align\" and \"len\" arguments to inet6_opt_append().",
      "ja": "個々のホップバイホップオプション（およびセクション9で説明されており、ホップバイホップオプションに非常に似ている目的地オプション）には、特定のアライメント要件がある場合があります。たとえば、4バイトのジャンボペイロード長は4バイトの境界に表示され、IPv6アドレスは通常、8バイトの境界に揃っています。これらの要件とこれらのオプションで使用される用語については、[RFC-2460]のセクション4.2および付録Bで説明します。各オプションの最初のバイトのアライメントは、「xn y」と書かれたxとyと呼ばれる2つの値で指定されます。これは、オプションヘッダーの先頭からXバイトの整数倍に表示されなければならないことを示しています（xは値1、2、4、または8を持つことができます）とyバイト（yは0〜7の間の値を持つことができます、包括的）。必要に応じて、PAD1およびPADNオプションが挿入され、必要に応じて必要に応じて挿入されます。以下の関数は、オプションの終了のアラインメント（常に「xn」、xが値1、2、4、または8を持つことができる形式の形式である）と、データ部分のデータ部分の合計サイズを知る必要があります。オプション。これらは、inet6_opt_append（）の「align」および「len」引数として渡されます。"
    },
    {
      "indent": 3,
      "text": "Multiple Hop-by-Hop options must be specified by the application by placing them in a single extension header.",
      "ja": "複数のホップバイホップオプションを、単一の拡張ヘッダーに配置することにより、アプリケーションで指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Finally, we note that use of some Hop-by-Hop options or some Destination options, might require special privilege. That is, normal applications (without special privilege) might be forbidden from setting certain options in outgoing packets, and might never see certain options in received packets.",
      "ja": "最後に、いくつかのホップバイホップオプションまたはいくつかの目的地オプションを使用するには、特別な特権が必要になる場合があることに注意してください。つまり、通常のアプリケーション（特別な特権なし）は、発信パケットに特定のオプションを設定することを禁じられている可能性があり、受信パケットに特定のオプションが表示されない場合があります。"
    },
    {
      "indent": 0,
      "text": "8.1. Receiving Hop-by-Hop Options",
      "section_title": true,
      "ja": "8.1. ホップバイホップオプションを受信します"
    },
    {
      "indent": 3,
      "text": "To receive a Hop-by-Hop options header the application must enable the IPV6_RECVHOPOPTS socket option:",
      "ja": "ホップバイホップオプションヘッダーを受信するには、アプリケーションがIPv6_recvhopoptsソケットオプションを有効にする必要があります。"
    },
    {
      "indent": 6,
      "text": "int  on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVHOPOPTS, &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When using ancillary data a Hop-by-hop options header is passed between the application and the kernel as follows: The cmsg_level member will be IPPROTO_IPV6 and the cmsg_type member will be IPV6_HOPOPTS. These options are then processed by calling the inet6_opt_next(), inet6_opt_find(), and inet6_opt_get_val() functions, described in Section 10.",
      "ja": "補助データを使用する場合、次のように、アプリケーションとカーネルの間にホップバイホップオプションヘッダーが渡されます。CMSG_LEVELメンバーはIPPROTO_IPV6であり、CMSG_TYPEメンバーはIPv6_hopoptsです。これらのオプションは、セクション10で説明されているINET6_OPT_NEXT（）、INET6_OPT_FIND（）、およびINET6_OPT_GET_VAL（）関数を呼び出すことにより処理されます。"
    },
    {
      "indent": 0,
      "text": "8.2. Sending Hop-by-Hop Options",
      "section_title": true,
      "ja": "8.2. ホップバイホップオプションを送信します"
    },
    {
      "indent": 3,
      "text": "To send a Hop-by-Hop options header, the application specifies the header either as ancillary data in a call to sendmsg() or using setsockopt().",
      "ja": "ホップバイホップオプションヘッダーを送信するには、アプリケーションは、sendmsg（）への呼び出しの補助データとしてヘッダーを指定するか、setsockopt（）を使用します。"
    },
    {
      "indent": 3,
      "text": "The application can remove any sticky Hop-by-Hop options header by calling setsockopt() for IPV6_HOPOPTS with a zero option length.",
      "ja": "アプリケーションは、オプションの長さがゼロのIPv6_hopoptsのSetSockopt（）を呼び出すことにより、スティッキーホップバイホップオプションヘッダーを削除できます。"
    },
    {
      "indent": 3,
      "text": "All the Hop-by-Hop options must be specified by a single ancillary data object. The cmsg_level member is set to IPPROTO_IPV6 and the cmsg_type member is set to IPV6_HOPOPTS. The option is normally constructed using the inet6_opt_init(), inet6_opt_append(), inet6_opt_finish(), and inet6_opt_set_val() functions, described in Section 10.",
      "ja": "すべてのホップバイホップオプションは、単一の補助データオブジェクトで指定する必要があります。CMSG_LEVELメンバーはIPPROTO_IPV6に設定され、CMSG_TYPEメンバーはIPv6_hopoptsに設定されます。オプションは通常、inet6_opt_init（）、inet6_opt_append（）、inet6_opt_finish（）、およびinet6_opt_set_val（）関数を使用して構築されます。"
    },
    {
      "indent": 3,
      "text": "Additional errors may be possible from sendmsg() and setsockopt() if the specified option is in error.",
      "ja": "指定されたオプションが誤っている場合、sendmsg（）およびsetSockopt（）から追加のエラーが可能になる場合があります。"
    },
    {
      "indent": 0,
      "text": "9. Destination Options",
      "section_title": true,
      "ja": "9. 目的地オプション"
    },
    {
      "indent": 3,
      "text": "A variable number of Destination options can appear in one or more Destination options headers. As defined in [RFC-2460], a Destination options header appearing before a Routing header is processed by the first destination plus any subsequent destinations specified in the Routing header, while a Destination options header that is not followed by a Routing header is processed only by the final destination. As with the Hop-by-Hop options, each option in a Destination options header is TLV-encoded with a type, length, and value.",
      "ja": "さまざまな数の宛先オプションが、1つ以上の宛先オプションヘッダーに表示されます。[RFC-2460]で定義されているように、ルーティングヘッダーが最初の宛先によって処理される前に表示される宛先オプションヘッダーと、ルーティングヘッダーで指定された後続の宛先が、ルーティングヘッダーが続いていない宛先オプションヘッダーは処理のみで処理されます。最終目的地で。ホップバイホップオプションと同様に、宛先オプションヘッダーの各オプションは、タイプ、長さ、および値でTLVエンコードされています。"
    },
    {
      "indent": 0,
      "text": "9.1. Receiving Destination Options",
      "section_title": true,
      "ja": "9.1. 目的地オプションを受信します"
    },
    {
      "indent": 3,
      "text": "To receive Destination options header the application must enable the IPV6_RECVDSTOPTS socket option:",
      "ja": "宛先オプションを受信するには、アプリケーションを有効にする必要がありますIPv6_Recvdstoptsソケットオプション："
    },
    {
      "indent": 6,
      "text": "int  on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVDSTOPTS, &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each Destination options header is returned as one ancillary data object described by a cmsghdr structure with cmsg_level set to IPPROTO_IPV6 and cmsg_type set to IPV6_DSTOPTS.",
      "ja": "各宛先オプションヘッダーは、CMSG_LEVELがIPPROTO_IPV6に設定されたCMSGHDR構造とIPv6_DSTOPTSに設定されたCMSG_TYPEを使用して、CMSGHDR構造によって記述された1つの補助データオブジェクトとして返されます。"
    },
    {
      "indent": 3,
      "text": "These options are then processed by calling the inet6_opt_next(), inet6_opt_find(), and inet6_opt_get_value() functions.",
      "ja": "これらのオプションは、INET6_OPT_NEXT（）、INET6_OPT_FIND（）、およびINET6_OPT_GET_VALUE（）関数を呼び出して処理されます。"
    },
    {
      "indent": 0,
      "text": "9.2. Sending Destination Options",
      "section_title": true,
      "ja": "9.2. 目的地オプションの送信"
    },
    {
      "indent": 3,
      "text": "To send a Destination options header, the application specifies it either as ancillary data in a call to sendmsg() or using setsockopt().",
      "ja": "宛先オプションヘッダーを送信するには、アプリケーションは、sendmsg（）への呼び出しの補助データとしてそれを指定するか、setsockopt（）を使用します。"
    },
    {
      "indent": 3,
      "text": "The application can remove any sticky Destination options header by calling setsockopt() for IPV6_RTHDRDSTOPTS/IPV6_DSTOPTS with a zero option length.",
      "ja": "アプリケーションは、オプションの長さがゼロのIPv6_RTHDRDSTOPTS/IPv6_DSTOPTSのSetSockopt（）を呼び出すことにより、スティッキーデスティネーションオプションヘッダーを削除できます。"
    },
    {
      "indent": 3,
      "text": "This API assumes the ordering about extension headers as described in [RFC-2460]. Thus, one set of Destination options can only appear before a Routing header, and one set can only appear after a Routing header (or in a packet with no Routing header). Each set can consist of one or more options but each set is a single extension header.",
      "ja": "このAPIは、[RFC-2460]で説明されているように、拡張ヘッダーに関する順序を想定しています。したがって、1つの宛先オプションのセットは、ルーティングヘッダーの前にのみ表示され、1つのセットはルーティングヘッダー（またはルーティングヘッダーのないパケット）の後にのみ表示できます。各セットは1つ以上のオプションで構成できますが、各セットは単一の拡張ヘッダーです。"
    },
    {
      "indent": 3,
      "text": "Today all destination options that an application may want to specify can be put after (or without) a Routing header. Thus, applications should usually need IPV6_DSTOPTS only and should avoid using IPV6_RTHDRDSTOPTS whenever possible.",
      "ja": "今日、アプリケーションが指定したいすべての目的地オプションは、ルーティングヘッダーの後（またはなし）に配置できます。したがって、アプリケーションは通常、IPv6_dstoptsのみを必要とする必要があり、可能な限りIPv6_rthdrdstoptsの使用を避ける必要があります。"
    },
    {
      "indent": 3,
      "text": "When using ancillary data a Destination options header is passed between the application and the kernel as follows: The set preceding a Routing header are specified with the cmsg_level member set to IPPROTO_IPV6 and the cmsg_type member set to IPV6_RTHDRDSTOPTS. Any setsockopt or ancillary data for IPV6_RTHDRDSTOPTS is silently ignored when sending packets unless a Routing header is also specified. Note that the \"Routing header\" here means the one specified by this API. Even when the kernel inserts a routing header in its internal routine (e.g., in a mobile IPv6 stack), the Destination options header specified by IPV6_RTHDRDSTOPTS will still be ignored unless the application explicitly specifies its own Routing header.",
      "ja": "補助データを使用する場合、アプリケーションとカーネルの間に次のように宛先オプションヘッダーが渡されます。ルーティングヘッダーの前のセットは、CMSG_LEVELメンバーがIPPROTO_IPV6に設定され、CMSG_TYPEメンバーがIPv6_RTHDRDSTOPTSに設定されていることを指定します。ルーティングヘッダーも指定されていない限り、パケットを送信する場合、IPv6_RTHDRDSTOPTSのSetSockoptまたは補助データは静かに無視されます。ここでの「ルーティングヘッダー」は、このAPIで指定されたものを意味することに注意してください。カーネルがルーティングヘッダーを内部ルーチン（モバイルIPv6スタックなど）に挿入した場合でも、IPv6_rthdrdstoptsで指定された宛先オプションヘッダーは、アプリケーションが独自のルーティングヘッダーを明示的に指定しない限り無視されます。"
    },
    {
      "indent": 3,
      "text": "The set of Destination options after a Routing header, which are also used when no Routing header is present, are specified with the cmsg_level member is set to IPPROTO_IPV6 and the cmsg_type member is set to IPV6_DSTOPTS.",
      "ja": "ルーティングヘッダーが存在しないときにも使用されるルーティングヘッダーの後の宛先オプションのセットは、CMSG_LEVELメンバーがIPPROTO_IPV6に設定され、CMSG_TYPEメンバーはIPv6_DSTOPTSに設定されます。"
    },
    {
      "indent": 3,
      "text": "The Destination options are normally constructed using the inet6_opt_init(), inet6_opt_append(), inet6_opt_finish(), and inet6_opt_set_val() functions, described in Section 10.",
      "ja": "宛先オプションは、通常、INET6_OPT_INIT（）、INET6_OPT_APPEND（）、INET6_OPT_FINISH（）、およびINET6_OPT_SET_VAL（）関数を使用して構築されます。"
    },
    {
      "indent": 3,
      "text": "Additional errors may be possible from sendmsg() and setsockopt() if the specified option is in error.",
      "ja": "指定されたオプションが誤っている場合、sendmsg（）およびsetSockopt（）から追加のエラーが可能になる場合があります。"
    },
    {
      "indent": 0,
      "text": "10. Hop-by-Hop and Destination Options Processing",
      "section_title": true,
      "ja": "10. ホップバイホップと宛先オプションの処理"
    },
    {
      "indent": 3,
      "text": "Building and parsing the Hop-by-Hop and Destination options is complicated for the reasons given earlier. We therefore define a set of functions to help the application. These functions assume the formatting rules specified in Appendix B in [RFC-2460] i.e., that the largest field is placed last in the option.",
      "ja": "ホップバイホップと目的地のオプションを構築して解析することは、以前に与えられた理由で複雑です。したがって、アプリケーションを支援するために一連の関数を定義します。これらの関数は、[RFC-2460]の付録Bで指定されているフォーマットルールを想定しています。つまり、最大のフィールドがオプションで最後に配置されていることを想定しています。"
    },
    {
      "indent": 3,
      "text": "The function prototypes for these functions are defined as a result of including <netinet/in.h>.",
      "ja": "これらの関数の関数プロトタイプは、<netinet/in.h>を含める結果として定義されます。"
    },
    {
      "indent": 3,
      "text": "The first 3 functions (init, append, and finish) are used both to calculate the needed buffer size for the options, and to actually encode the options once the application has allocated a buffer for the header. In order to only calculate the size the application must pass a NULL extbuf and a zero extlen to those functions.",
      "ja": "最初の3つの機能（init、append、およびfinish）は、オプションに必要なバッファサイズを計算するために、またアプリケーションがヘッダーのバッファーを割り当てた後にオプションを実際にエンコードするために使用されます。サイズのみを計算するためには、アプリケーションはそれらの関数にnull extbufとゼロのextlenを渡す必要があります。"
    },
    {
      "indent": 0,
      "text": "10.1. inet6_opt_init",
      "section_title": true,
      "ja": "10.1. inet6_opt_init"
    },
    {
      "indent": 6,
      "text": "int inet6_opt_init(void *extbuf, socklen_t extlen);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This function returns the number of bytes needed for the empty extension header i.e., without any options. If extbuf is not NULL it also initializes the extension header to have the correct length field. In that case if the extlen value is not a positive (i.e., non-zero) multiple of 8 the function fails and returns -1.",
      "ja": "この関数は、空の拡張ヘッダーに必要なバイト数、つまりオプションがないことを返します。extbufがnullでない場合、拡張ヘッダーを初期化して正しい長さフィールドを持つようにします。その場合、extlen値が8の正の（つまり、非ゼロ）倍数でない場合、関数は失敗し、-1を返します。"
    },
    {
      "indent": 3,
      "text": "(Note: since the return value on success is based on a \"constant\" parameter, i.e., the empty extension header, an implementation may return a constant value. However, this specification does not require the value be constant, and leaves it as implementation dependent. The application should not assume a particular constant value as a successful return value of this function.)",
      "ja": "（注：成功の返品値は「定数」パラメーター、つまり空の拡張ヘッダーに基づいているため、実装は一定の値を返す場合があります。ただし、この仕様は値を一定ではなく、実装として残します依存。アプリケーションは、この関数の成功した返品値として特定の一定の値を想定すべきではありません。）"
    },
    {
      "indent": 0,
      "text": "10.2. inet6_opt_append",
      "section_title": true,
      "ja": "10.2. inet6_opt_append"
    },
    {
      "indent": 6,
      "text": "int inet6_opt_append(void *extbuf, socklen_t extlen, int offset,\n                     uint8_t type, socklen_t len, uint_t align,\n                     void **databufp);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Offset should be the length returned by inet6_opt_init() or a previous inet6_opt_append(). This function returns the updated total length taking into account adding an option with length 'len' and alignment 'align'. If extbuf is not NULL then, in addition to returning the length, the function inserts any needed pad option, initializes the option (setting the type and length fields) and returns a pointer to the location for the option content in databufp. If the option does not fit in the extension header buffer the function returns -1.",
      "ja": "オフセットは、inet6_opt_init（）または以前のinet6_opt_append（）によって返される長さである必要があります。この関数は、長さの「LEN」とアライメント「ALIGN」を備えたオプションを追加することを考慮して、更新された総長さを返します。extbufがnullでない場合、長さを返すことに加えて、関数は必要なパッドオプションを挿入し、オプションを初期化（タイプと長さフィールドの設定）し、データビューFPのオプションコンテンツの位置へのポインターを返します。オプションが拡張ヘッダーバッファに適合しない場合、関数は-1を返します。"
    },
    {
      "indent": 3,
      "text": "Type is the 8-bit option type. Len is the length of the option data (i.e., excluding the option type and option length fields).",
      "ja": "タイプは8ビットオプションタイプです。LENは、オプションデータの長さです（つまり、オプションタイプとオプションの長さフィールドを除く）。"
    },
    {
      "indent": 3,
      "text": "Once inet6_opt_append() has been called the application can use the databuf directly, or use inet6_opt_set_val() to specify the content of the option.",
      "ja": "INET6_OPT_APPEND（）が呼び出されると、アプリケーションはDataBufを直接使用するか、INET6_OPT_SET_VAL（）を使用してオプションのコンテンツを指定できます。"
    },
    {
      "indent": 3,
      "text": "The option type must have a value from 2 to 255, inclusive. (0 and 1 are reserved for the Pad1 and PadN options, respectively.)",
      "ja": "オプションタイプには、2〜255の値が含まれている必要があります。（0と1は、それぞれPAD1およびPADNオプション用に予約されています。）"
    },
    {
      "indent": 3,
      "text": "The option data length must have a value between 0 and 255, inclusive, and is the length of the option data that follows.",
      "ja": "オプションデータの長さは、包括的0〜255の値を持つ必要があり、次のオプションデータの長さです。"
    },
    {
      "indent": 3,
      "text": "The align parameter must have a value of 1, 2, 4, or 8. The align value can not exceed the value of len.",
      "ja": "Alignパラメーターの値は1、2、4、または8の値を持っている必要があります。LENの値はLENの値を超えません。"
    },
    {
      "indent": 0,
      "text": "10.3. inet6_opt_finish",
      "section_title": true,
      "ja": "10.3. inet6_opt_finish"
    },
    {
      "indent": 6,
      "text": "int inet6_opt_finish(void *extbuf, socklen_t extlen, int offset);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Offset should be the length returned by inet6_opt_init() or inet6_opt_append(). This function returns the updated total length taking into account the final padding of the extension header to make it a multiple of 8 bytes. If extbuf is not NULL the function also initializes the option by inserting a Pad1 or PadN option of the proper length.",
      "ja": "オフセットは、inet6_opt_init（）またはinet6_opt_append（）によって返される長さである必要があります。この関数は、拡張ヘッダーの最終的なパディングを考慮して、8バイトの倍数にするために、更新された総長さを返します。extbufがnullでない場合、関数は、適切な長さのPAD1またはPADNオプションを挿入することにより、オプションを初期化します。"
    },
    {
      "indent": 3,
      "text": "If the necessary pad does not fit in the extension header buffer the function returns -1.",
      "ja": "必要なパッドが拡張ヘッダーバッファに収まらない場合、関数は-1を返します。"
    },
    {
      "indent": 0,
      "text": "10.4. inet6_opt_set_val",
      "section_title": true,
      "ja": "10.4. inet6_opt_set_val"
    },
    {
      "indent": 6,
      "text": "int inet6_opt_set_val(void *databuf, int offset, void *val,\n                      socklen_t vallen);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Databuf should be a pointer returned by inet6_opt_append(). This function inserts data items of various sizes in the data portion of the option. Val should point to the data to be inserted. Offset specifies where in the data portion of the option the value should be inserted; the first byte after the option type and length is accessed by specifying an offset of zero.",
      "ja": "DataBufは、inet6_opt_append（）によって返されるポインターである必要があります。この関数は、オプションのデータ部分にさまざまなサイズのデータ項目を挿入します。VALは、挿入するデータを指す必要があります。オフセットは、オプションのデータ部分で値を挿入する場所を指定します。オプションタイプと長さの後の最初のバイトには、ゼロのオフセットを指定することによりアクセスします。"
    },
    {
      "indent": 3,
      "text": "The caller should ensure that each field is aligned on its natural boundaries as described in Appendix B of [RFC-2460], but the function must not rely on the caller's behavior. Even when the alignment requirement is not satisfied, inet6_opt_set_val should just copy the data as required.",
      "ja": "発信者は、[RFC-2460]の付録Bに記載されているように、各フィールドが自然境界に整合するようにする必要がありますが、機能は発信者の動作に依存してはなりません。アライメント要件が満たされていない場合でも、INET6_OPT_SET_VALは、必要に応じてデータをコピーするだけです。"
    },
    {
      "indent": 3,
      "text": "The function returns the offset for the next field (i.e., offset + vallen) which can be used when composing option content with multiple fields.",
      "ja": "この関数は、複数のフィールドでオプションコンテンツを構成するときに使用できる次のフィールド（つまり、オフセットVallen）のオフセットを返します。"
    },
    {
      "indent": 0,
      "text": "10.5. inet6_opt_next",
      "section_title": true,
      "ja": "10.5. inet6_opt_next"
    },
    {
      "indent": 6,
      "text": "int inet6_opt_next(void *extbuf, socklen_t extlen, int offset,\n                   uint8_t *typep, socklen_t *lenp,\n                   void **databufp);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This function parses received option extension headers returning the next option. Extbuf and extlen specifies the extension header. Offset should either be zero (for the first option) or the length returned by a previous call to inet6_opt_next() or inet6_opt_find(). It specifies the position where to continue scanning the extension buffer. The next option is returned by updating typep, lenp, and databufp. Typep stores the option type, lenp stores the length of the option data (i.e., excluding the option type and option length fields), and databufp points the data field of the option. This function returns the updated \"previous\" length computed by advancing past the option that was returned. This returned \"previous\" length can then be passed to subsequent calls to inet6_opt_next(). This function does not return any PAD1 or PADN options. When there are no more options or if the option extension header is malformed the return value is -1.",
      "ja": "この関数は、次のオプションを返すオプション拡張ヘッダーを解析します。ExtbufとExtlenは、拡張ヘッダーを指定します。オフセットは、ゼロ（最初のオプションの場合）またはinet6_opt_next（）またはinet6_opt_find（）への前の呼び出しによって返された長さのいずれかである必要があります。拡張バッファーのスキャンを続ける位置を指定します。次のオプションは、typep、lenp、およびdataBufpを更新することにより返されます。Typepはオプションタイプを保存し、LENPはオプションデータの長さ（つまり、オプションタイプとオプションの長さフィールドを除く）を保存し、DataBUFPはオプションのデータフィールドをポイントします。この関数は、返されたオプションを通過することによって計算された更新された「以前の」長さを返します。これにより、「前の」長さが返され、その後のINET6_OPT_NEXT（）への後続の呼び出しに渡すことができます。この関数は、PAD1またはPADNオプションを返しません。これ以上のオプションがない場合、またはオプション拡張ヘッダーが奇形である場合、戻り値は-1です。"
    },
    {
      "indent": 0,
      "text": "10.6. inet6_opt_find",
      "section_title": true,
      "ja": "10.6. inet6_opt_find"
    },
    {
      "indent": 6,
      "text": "int inet6_opt_find(void *extbuf, socklen_t extlen, int offset,\n                   uint8_t type, socklen_t *lenp,\n                   void **databufp);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This function is similar to the previously described inet6_opt_next() function, except this function lets the caller specify the option type to be searched for, instead of always returning the next option in the extension header.",
      "ja": "この関数は、前述のINET6_OPT_NEXT（）関数と類似しています。ただし、この関数により、拡張ヘッダーの次のオプションを常に返すのではなく、この関数が検索するオプションタイプを指定できます。"
    },
    {
      "indent": 3,
      "text": "If an option of the specified type is located, the function returns the updated \"previous\" total length computed by advancing past the option that was returned and past any options that didn't match the type. This returned \"previous\" length can then be passed to subsequent calls to inet6_opt_find() for finding the next occurrence of the same option type.",
      "ja": "指定されたタイプのオプションが配置されている場合、関数は、返されたオプションを超えて進出し、タイプと一致しないオプションを通過することによって計算された更新された「以前の」合計長さを返します。これにより、「以前の」長さが返され、同じオプションタイプの次の発生を見つけるために、INET6_OPT_FIND（）への後続の呼び出しに渡すことができます。"
    },
    {
      "indent": 3,
      "text": "If an option of the specified type is not located, the return value is -1. If the option extension header is malformed, the return value is -1.",
      "ja": "指定されたタイプのオプションが配置されていない場合、戻り値は-1です。オプション拡張ヘッダーが奇形である場合、戻り値は-1です。"
    },
    {
      "indent": 0,
      "text": "10.7. inet6_opt_get_val",
      "section_title": true,
      "ja": "10.7. inet6_opt_get_val"
    },
    {
      "indent": 6,
      "text": "int inet6_opt_get_val(void *databuf, int offset, void *val,\n                      socklen_t vallen);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Databuf should be a pointer returned by inet6_opt_next() or inet6_opt_find(). This function extracts data items of various sizes in the data portion of the option. Val should point to the destination for the extracted data. Offset specifies from where in the data portion of the option the value should be extracted; the first byte after the option type and length is accessed by specifying an offset of zero.",
      "ja": "DataBufは、inet6_opt_next（）またはinet6_opt_find（）によって返されるポインターである必要があります。この関数は、オプションのデータ部分にさまざまなサイズのデータ項目を抽出します。VALは、抽出されたデータの宛先を指す必要があります。オフセットは、オプションのデータ部分で値を抽出する必要がある場所から指定します。オプションタイプと長さの後の最初のバイトには、ゼロのオフセットを指定することによりアクセスします。"
    },
    {
      "indent": 3,
      "text": "It is expected that each field is aligned on its natural boundaries as described in Appendix B of [RFC-2460], but the function must not rely on the alignment.",
      "ja": "[RFC-2460]の付録Bに記載されているように、各フィールドはその自然境界に整合されると予想されますが、関数はアライメントに依存してはなりません。"
    },
    {
      "indent": 3,
      "text": "The function returns the offset for the next field (i.e., offset + vallen) which can be used when extracting option content with multiple fields.",
      "ja": "この関数は、複数のフィールドでオプションコンテンツを抽出するときに使用できる次のフィールド（つまり、オフセットVallen）のオフセットを返します。"
    },
    {
      "indent": 0,
      "text": "11. Additional Advanced API Functions",
      "section_title": true,
      "ja": "11. 追加の高度なAPI関数"
    },
    {
      "indent": 0,
      "text": "11.1. Sending with the Minimum MTU",
      "section_title": true,
      "ja": "11.1. 最小MTUで送信します"
    },
    {
      "indent": 3,
      "text": "Unicast applications should usually let the kernel perform path MTU discovery [RFC-1981], as long as the kernel supports it, and should not care about the path MTU. Some applications, however, might not want to incur the overhead of path MTU discovery, especially if the applications only send a single datagram to a destination. A potential example is a DNS server.",
      "ja": "ユニキャストアプリケーションは、通常、カーネルがそれをサポートしている限り、パスMTU発見[RFC-1981]を実行できるようにする必要があり、パスMTUを気にしないでください。ただし、一部のアプリケーションは、特にアプリケーションが単一のデータグラムのみを宛先に送信する場合、PATH MTU発見のオーバーヘッドを発生させたくない場合があります。潜在的な例は、DNSサーバーです。"
    },
    {
      "indent": 3,
      "text": "[RFC-1981] describes how path MTU discovery works for multicast destinations. From practice in using IPv4 multicast, however, many careless applications that send large multicast packets on the wire have caused implosion of ICMPv4 error messages. The situation can be worse when there is a filtering node that blocks the ICMPv4 messages. Though the filtering issue applies to unicast as well, the impact is much larger in the multicast cases.",
      "ja": "[RFC-1981]は、マルチキャストの目的地でMTU発見がどのように機能するかを説明しています。ただし、IPv4マルチキャストの使用の練習から、ワイヤー上に大きなマルチキャストパケットを送信する多くの不注意なアプリケーションは、ICMPV4エラーメッセージの破壊を引き起こしました。ICMPV4メッセージをブロックするフィルタリングノードがある場合、状況は悪化する可能性があります。フィルタリングの問題はユニキャストにも適用されますが、マルチキャストの場合には影響がはるかに大きくなります。"
    },
    {
      "indent": 3,
      "text": "Thus, applications sending multicast traffic should explicitly enable path MTU discovery only when they understand that the benefit of possibly larger MTU usage outweighs the possible impact of MTU discovery for active sources across the delivery tree(s). This default behavior is based on the today's practice with IPv4 multicast and path MTU discovery. The behavior may change in the future once it is found that path MTU discovery effectively works with actual multicast applications and network configurations.",
      "ja": "したがって、マルチキャストトラフィックを送信するアプリケーションは、おそらくより大きなMTU使用の利点が、配信ツリー全体のアクティブソースのMTU発見の可能性のある影響を上回ることを理解している場合にのみ、Path MTU発見を明示的に有効にする必要があります。このデフォルトの動作は、IPv4マルチキャストおよびPATH MTU発見による今日の実践に基づいています。Path MTU Discoveryが実際のマルチキャストアプリケーションとネットワーク構成で効果的に機能することがわかった場合、動作は将来変化する可能性があります。"
    },
    {
      "indent": 3,
      "text": "This specification defines a mechanism to avoid path MTU discovery by sending at the minimum IPv6 MTU [RFC-2460]. If the packet is larger than the minimum MTU and this feature has been enabled the IP layer will fragment to the minimum MTU. To control the policy about path MTU discovery, applications can use the IPV6_USE_MIN_MTU socket option.",
      "ja": "この仕様は、最小IPv6 MTU [RFC-2460]で送信することにより、PATH MTUの発見を回避するメカニズムを定義します。パケットが最小MTUよりも大きく、この機能が有効になっている場合、IPレイヤーは最小MTUに分割されます。PATH MTU発見に関するポリシーを制御するために、アプリケーションはIPv6_use_min_mtuソケットオプションを使用できます。"
    },
    {
      "indent": 3,
      "text": "As described above, the default policy should depend on whether the destination is unicast or multicast. For unicast destinations path MTU discovery should be performed by default. For multicast destinations path MTU discovery should be disabled by default. This option thus takes the following three types of integer arguments:",
      "ja": "上記のように、デフォルトのポリシーは、宛先がユニキャストであるかマルチキャストかによって異なります。ユニキャスト宛先の場合、パスMTU発見はデフォルトで実行する必要があります。マルチキャストの宛先の場合、パスMTU発見はデフォルトで無効にする必要があります。したがって、このオプションは、次の3種類の整数引数を取ります。"
    },
    {
      "indent": 3,
      "text": "-1: perform path MTU discovery for unicast destinations but do not perform it for multicast destinations. Packets to multicast destinations are therefore sent with the minimum MTU.",
      "ja": "-1：ユニキャストの目的地のPATH MTUディスカバリーを実行しますが、マルチキャストの目的地では実行しません。したがって、マルチキャストの宛先へのパケットは、最小MTUで送信されます。"
    },
    {
      "indent": 3,
      "text": "0: always perform path MTU discovery.",
      "ja": "0：常にPATH MTUディスカバリーを実行します。"
    },
    {
      "indent": 3,
      "text": "1: always disable path MTU discovery and send packets at the minimum MTU.",
      "ja": "1：PATH MTUディスカバリーを常に無効にし、最小MTUでパケットを送信します。"
    },
    {
      "indent": 3,
      "text": "The default value of this option is -1. Values other than -1, 0, and 1 are invalid, and an error EINVAL will be returned for those values.",
      "ja": "このオプションのデフォルト値は-1です。-1、0、および1以外の値は無効であり、これらの値に対してeinvalのエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "As an example, if a unicast application intentionally wants to disable path MTU discovery, it will add the following lines:",
      "ja": "例として、ユニキャストアプリケーションが意図的にPATH MTU発見を無効にしたい場合、次の行が追加されます。"
    },
    {
      "indent": 6,
      "text": "int  on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that this API intentionally excludes the case where the application wants to perform path MTU discovery for multicast but to disable it for unicast. This is because such usage is not feasible considering a scale of performance issues around whether to do path MTU discovery or not. When path MTU discovery makes sense to a destination but not to a different destination, regardless of whether the destination is unicast or multicast, applications either need to toggle the option between sending such packets on the same socket, or use different sockets for the two classes of destinations.",
      "ja": "このAPIは、アプリケーションがマルチキャストのPATH MTUディスカバリーを実行するが、ユニキャスト用に無効にする場合を意図的に除外していることに注意してください。これは、Path MTUの発見を行うかどうかについてのパフォーマンスの問題の規模を考慮して、そのような使用が実行不可能であるためです。PATH MTUディスカバリーが目的地に理にかなっているが、目的地がユニキャストであるかマルチキャストであるかに関係なく、別の宛先には意味がない場合、アプリケーションは同じソケットでそのようなパケットを送信する間のオプションを切り替えるか、2つのクラスに異なるソケットを使用する必要があります目的地の。"
    },
    {
      "indent": 3,
      "text": "This option can also be sent as ancillary data. In the cmsghdr structure containing this ancillary data, the cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be IPV6_USE_MIN_MTU, and the first byte of cmsg_data[] will be the first byte of the integer.",
      "ja": "このオプションは、補助データとして送信することもできます。この補助データを含むCMSGHDR構造では、CMSG_LEVELメンバーはIPPROTO_IPV6であり、CMSG_TYPEメンバーはIPv6_USE_MIN_MTUであり、CMSG_DATA []の最初のバイトは整数の最初のバイトになります。"
    },
    {
      "indent": 0,
      "text": "11.2. Sending without Fragmentation",
      "section_title": true,
      "ja": "11.2. 断片化なしで送信します"
    },
    {
      "indent": 3,
      "text": "In order to provide for easy porting of existing UDP and raw socket applications IPv6 implementations will, when originating packets, automatically insert a fragment header in the packet if the packet is too big for the path MTU.",
      "ja": "既存のUDPおよびRAWソケットアプリケーションの簡単な移植を提供するために、IPv6実装は、パケットがPATH MTUに大きすぎる場合、パケットがパケットにフラグメントヘッダーを自動的に挿入します。"
    },
    {
      "indent": 3,
      "text": "Some applications might not want this behavior. An example is traceroute which might want to discover the actual path MTU.",
      "ja": "一部のアプリケーションは、この動作を望んでいない場合があります。例は、実際のパスMTUを発見したいと思うかもしれないTracerouteです。"
    },
    {
      "indent": 3,
      "text": "This specification defines a mechanism to turn off the automatic inserting of a fragment header for UDP and raw sockets. This can be enabled using the IPV6_DONTFRAG socket option.",
      "ja": "この仕様は、UDPおよび生のソケットのフラグメントヘッダーの自動挿入をオフにするメカニズムを定義します。これは、IPv6_DontFrag Socketオプションを使用して有効にできます。"
    },
    {
      "indent": 6,
      "text": "int on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_DONTFRAG, &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "By default, this socket option is disabled. Setting the value to 0 also disables the option i.e., reverts to the default behavior of automatic inserting. This option can also be sent as ancillary data. In the cmsghdr structure containing this ancillary data, the cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be IPV6_DONTFRAG, and the first byte of cmsg_data[] will be the first byte of the integer. This API only specifies the use of this option for UDP and raw sockets, and does not define the usage for TCP sockets.",
      "ja": "デフォルトでは、このソケットオプションは無効になっています。値を0に設定すると、オプションも無効になります。つまり、自動挿入のデフォルト動作に戻ります。このオプションは、補助データとして送信することもできます。この補助データを含むCMSGHDR構造では、CMSG_LEVELメンバーはIPPROTO_IPV6であり、CMSG_TYPEメンバーはIPv6_DontFragであり、CMSG_DATA []の最初のバイトは整数の最初のバイトになります。このAPIは、UDPおよび生のソケットにこのオプションの使用のみを指定し、TCPソケットの使用を定義しません。"
    },
    {
      "indent": 3,
      "text": "When the data size is larger than the MTU of the outgoing interface, the packet will be discarded. Applications can know the result by enabling the IPV6_RECVPATHMTU option described below and receiving the corresponding ancillary data items. An additional error EMSGSIZE may also be returned in some implementations. Note, however, that some other implementations might not be able to return this additional error when sending a message.",
      "ja": "データサイズが発信インターフェイスのMTUよりも大きい場合、パケットは破棄されます。アプリケーションは、以下に説明するIPv6_RecvPathMTUオプションを有効にし、対応する補助データ項目を受信することにより、結果を知ることができます。いくつかの実装では、追加のエラーEMSGSIZEも返される場合があります。ただし、他のいくつかの実装は、メッセージを送信するときにこの追加のエラーを返すことができない場合があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "11.3. Path MTU Discovery and UDP",
      "section_title": true,
      "ja": "11.3. Path MTU DiscoveryとUDP"
    },
    {
      "indent": 3,
      "text": "UDP and raw socket applications need to be able to determine the \"maximum send transport-message size\" (Section 5.1 of [RFC-1981]) to a given destination so that those applications can participate in path MTU discovery. This lets those applications send smaller datagrams to the destination, avoiding fragmentation.",
      "ja": "UDPおよびRAWソケットアプリケーションは、「最大送信輸送メサージサイズ」（[RFC-1981]のセクション5.1）を特定の宛先に決定できるようにする必要があり、それらのアプリケーションがPath MTU発見に参加できるようにします。これにより、これらのアプリケーションは、断片化を回避して、より小さなデータグラムを宛先に送信できます。"
    },
    {
      "indent": 3,
      "text": "This is accomplished using a new ancillary data item (IPV6_PATHMTU) which is delivered to recvmsg() without any actual data. The application can enable the receipt of IPV6_PATHMTU ancillary data items by setting the IPV6_RECVPATHMTU socket option.",
      "ja": "これは、実際のデータなしでrecvmsg（）に配信される新しい補助データ項目（IPv6_pathmtu）を使用して達成されます。このアプリケーションは、IPv6_RecvPathMTUソケットオプションを設定することにより、IPv6_PathMTUの補助データ項目を受信できます。"
    },
    {
      "indent": 6,
      "text": "int  on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVPATHMTU, &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "By default, this socket option is disabled. Setting the value to 0 also disables the option. This API only specifies the use of this option for UDP and raw sockets, and does not define the usage for TCP sockets.",
      "ja": "デフォルトでは、このソケットオプションは無効になっています。値を0に設定することもオプションを無効にします。このAPIは、UDPおよび生のソケットにこのオプションの使用のみを指定し、TCPソケットの使用を定義しません。"
    },
    {
      "indent": 3,
      "text": "When the application is sending packets too big for the path MTU recvmsg() will return zero (indicating no data) but there will be a cmsghdr with cmsg_type set to IPV6_PATHMTU, and cmsg_len will indicate that cmsg_data is sizeof(struct ip6_mtuinfo) bytes long. This can happen when the sending node receives a corresponding ICMPv6 packet too big error, or when the packet is sent from a socket with the IPV6_DONTFRAG option being on and the packet size is larger than the MTU of the outgoing interface. This indication is considered as an ancillary data item for a separate (empty) message. Thus, when there are buffered messages (i.e., messages that the application has not received yet) on the socket the application will first receive the buffered messages and then receive the indication.",
      "ja": "アプリケーションがパスの大きすぎるパケットを送信すると、MTU recvmsg（）はゼロを返します（データがないことを示します）が、CMSG_TYPEを備えたCMSGHDRがIPv6_PathmTUに設定され、CMSG_LENはCMSG_DATAがsizeof（struct ip6_mtuinfo）bytes longであることを示します。これは、送信ノードが対応するICMPv6パケットを受信している場合、またはパケットがソケットから送信され、IPv6_DontFragオプションがオンになり、パケットサイズが発信インターフェイスのMTUよりも大きい場合に発生する可能性があります。この表示は、別の（空の）メッセージの補助データ項目と見なされます。したがって、ソケットにバッファリングされたメッセージ（つまり、アプリケーションがまだ受信していないメッセージ）がある場合、アプリケーションは最初にバッファーメッセージを受信してから表示を受信します。"
    },
    {
      "indent": 3,
      "text": "The first byte of cmsg_data[] will point to a struct ip6_mtuinfo carrying the path MTU to use together with the IPv6 destination address.",
      "ja": "CMSG_DATA []の最初のバイトは、IPv6宛先アドレスと一緒に使用するパスMTUを運ぶstruct IP6_MTUINFOを指します。"
    },
    {
      "indent": 6,
      "text": "struct ip6_mtuinfo {\n  struct sockaddr_in6 ip6m_addr; /* dst address including\n                                    zone ID */\n  uint32_t            ip6m_mtu;  /* path MTU in host byte order */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This cmsghdr will be passed to every socket that sets the IPV6_RECVPATHMTU socket option, even if the socket is non-connected. Note that this also means an application that sets the option may receive an IPV6_MTU ancillary data item for each ICMP too big error the node receives, including such ICMP errors caused by other applications on the node. Thus, an application that wants to perform the path MTU discovery by itself needs to keep history of destinations that it has actually sent to and to compare the address returned in the ip6_mtuinfo structure to the history. An implementation may choose not to delivery data to a connected socket that has a foreign address that is different than the address specified in the ip6m_addr structure.",
      "ja": "このCMSGHDRは、ソケットが接続されていない場合でも、IPv6_RecVPathMTUソケットオプションを設定するすべてのソケットに渡されます。これは、オプションを設定するアプリケーションが、ノード上の他のアプリケーションによって引き起こされるICMPエラーを含む、ノードが受信する各ICMPのIPv6_MTU補助データ項目を受信できることを意味することに注意してください。したがって、MTU発見をパス自体に実行したいアプリケーションは、実際に送信された目的地の歴史を維持し、IP6_MTUINFO構造で返されたアドレスを歴史に比較する必要があります。実装は、IP6M_ADDR構造で指定されたアドレスとは異なる外部アドレスを持つ接続されたソケットにデータを配信しないことを選択できます。"
    },
    {
      "indent": 3,
      "text": "When an application sends a packet with a routing header, the final destination stored in the ip6m_addr member does not necessarily contain complete information of the entire path.",
      "ja": "アプリケーションがルーティングヘッダーを使用してパケットを送信する場合、IP6M_ADDRメンバーに保存されている最終宛先には、必ずしもパス全体の完全な情報が含まれているわけではありません。"
    },
    {
      "indent": 0,
      "text": "11.4. Determining the Current Path MTU",
      "section_title": true,
      "ja": "11.4. 現在のパスMTUの決定"
    },
    {
      "indent": 3,
      "text": "Some applications might need to determine the current path MTU e.g., applications using IPV6_RECVPATHMTU might want to pick a good starting value.",
      "ja": "一部のアプリケーションは、現在のパスMTUを決定する必要がある場合があります。たとえば、IPv6_RecVPathMTUを使用したアプリケーションは、優れた開始値を選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "This specification defines a get-only socket option to retrieve the current path MTU value for the destination of a given connected socket. If the IP layer does not have a cached path MTU value it will return the interface MTU for the interface that will be used when sending to the destination address.",
      "ja": "この仕様では、特定の接続されたソケットの宛先の現在のパスMTU値を取得するためのGET専用ソケットオプションを定義します。IPレイヤーにキャッシュされたパスMTU値がない場合、宛先アドレスに送信するときに使用されるインターフェイスのインターフェイスMTUを返します。"
    },
    {
      "indent": 3,
      "text": "This information is retrieved using the IPV6_PATHMTU socket option. This option takes a pointer to the ip6_mtuinfo structure as the fourth argument, and the size of the structure should be passed as a value-result parameter in the fifth argument.",
      "ja": "この情報は、IPv6_pathmtuソケットオプションを使用して取得されます。このオプションは、4番目の引数としてIP6_MTUINFO構造へのポインターを取り、構造のサイズを5番目の引数の値応答パラメーターとして渡す必要があります。"
    },
    {
      "indent": 6,
      "text": "struct ip6_mtuinfo mtuinfo;\nsocklen_t infolen = sizeof(mtuinfo);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "getsockopt(fd, IPPROTO_IPV6, IPV6_PATHMTU, &mtuinfo, &infolen);",
      "ja": "GetSockopt（FD、IPPROTO_IPV6、IPv6_Pathmtu、＆Mtuinfo、＆Infolen）;"
    },
    {
      "indent": 3,
      "text": "When the call succeeds, the path MTU value is stored in the ip6m_mtu member of the ip6_mtuinfo structure. Since the socket is connected, the ip6m_addr member is meaningless and should not be referred to by the application.",
      "ja": "コールが成功すると、PATH MTU値はIP6_MTUINFO構造のIP6M_MTUメンバーに保存されます。ソケットが接続されているため、IP6M_ADDRメンバーは無意味であり、アプリケーションで参照されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "This option can only be used for a connected socket, because a non-connected socket does not have the information of the destination and there is no way to pass the destination via getsockopt(). When getsockopt() for this option is issued on a non-connected socket, the call will fail. Despite this limitation, this option is still useful from a practical point of view, because applications that care about the path MTU tend to send a lot of packets to a single destination and to connect the socket to the destination for performance reasons. If the application needs to get the MTU value in a more generic way, it should use a more generic interface, such as routing sockets [TCPIPILLUST].",
      "ja": "接続されていないソケットには目的地の情報がなく、GetSockopt（）を介して目的地を通過する方法がないため、このオプションは接続ソケットにのみ使用できます。このオプションのgetSockopt（）が接続されていないソケットで発行されると、通話は失敗します。この制限にもかかわらず、このオプションは、MTUのパスに関心があるアプリケーションが多くのパケットを単一の宛先に送信し、パフォーマンス上の理由でソケットを宛先に接続する傾向があるため、実際の観点から依然として役立ちます。アプリケーションがより一般的な方法でMTU値を取得する必要がある場合、ルーティングソケット[Tcpipillust]などのより一般的なインターフェイスを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "12. Ordering of Ancillary Data and IPv6 Extension Headers",
      "section_title": true,
      "ja": "12. 補助データとIPv6拡張ヘッダーの順序付け"
    },
    {
      "indent": 3,
      "text": "Three IPv6 extension headers can be specified by the application and returned to the application using ancillary data with sendmsg() and recvmsg(): the Routing header, Hop-by-Hop options header, and Destination options header. When multiple ancillary data objects are transferred via recvmsg() and these objects represent any of these three extension headers, their placement in the control buffer is directly tied to their location in the corresponding IPv6 datagram. For example, when the application has enabled the IPV6_RECVRTHDR and IPV6_RECVDSTOPTS options and later receives an IPv6 packet with extension headers in the following order:",
      "ja": "3つのIPv6拡張ヘッダーをアプリケーションで指定し、sendmsg（）およびrecvmsg（）を使用して補助データを使用してアプリケーションに返します。ルーティングヘッダー、ホップバイホップオプションヘッダー、および宛先オプションヘッダー。複数の補助的なデータオブジェクトがrecvmsg（）を介して転送され、これらのオブジェクトがこれらの3つの拡張ヘッダーのいずれかを表している場合、コントロールバッファーへの配置は、対応するIPv6データグラムの位置に直接結び付けられます。たとえば、アプリケーションがIPv6_RecvrthDRおよびIPv6_RecvdStoptsオプションを有効にし、後に次の順序で拡張ヘッダーを備えたIPv6パケットを受信した場合："
    },
    {
      "indent": 6,
      "text": "The IPv6 header A Hop-by-Hop options header A Destination options header (1) A Routing header An Authentication header A Destination options header (2) A UDP header and UDP data",
      "ja": "IPv6ヘッダーホップバイホップオプションヘッダー宛先オプションヘッダー（1）ルーティングヘッダー認証ヘッダー宛先オプションヘッダー（2）UDPヘッダーとUDPデータ"
    },
    {
      "indent": 3,
      "text": "then the application will receive three ancillary data objects in the following order:",
      "ja": "次に、アプリケーションは次の順序で3つの補助データオブジェクトを受け取ります。"
    },
    {
      "indent": 6,
      "text": "an object with cmsg_type set to IPV6_DSTOPTS, which represents the destination options header (1) an object with cmsg_type set to IPV6_RTHDR, which represents the Routing header an object with cmsg_type set to IPV6_DSTOPTS, which represents the destination options header (2)",
      "ja": "cmsg_typeを持つオブジェクトは、IPv6_dstoptsに設定されています。これは、宛先オプションヘッダー（1）CMSG_Typeを持つオブジェクトをipv6_rthdrに設定します。これは、cmsg_toptsに設定されたオブジェクトをルーティングヘッダーに表すオブジェクトを表します。"
    },
    {
      "indent": 3,
      "text": "This example follows the header ordering described in [RFC-2460], but the receiving side of this specification does not assume the ordering. Applications may receive any numbers of objects in any order according to the ordering of the received IPv6 datagram.",
      "ja": "この例は、[RFC-2460]で説明されているヘッダー順序に続きますが、この仕様の受信側は順序付けを想定していません。アプリケーションは、受信したIPv6データグラムの順序に応じて、任意の数のオブジェクトを任意の数のオブジェクトを受信する場合があります。"
    },
    {
      "indent": 3,
      "text": "For the sending side, however, this API imposes some ordering constraints according to [RFC-2460]. Applications using this API cannot make a packet with extension headers that do not follow the ordering. Note, however, that this does not mean applications must always follow the restriction. This is just a limitation in this API in order to give application programmers a guideline to construct headers in a practical manner. Should an application need to make an outgoing packet in an arbitrary order about the extension headers, some other technique, such as the datalink interfaces BPF or DLPI, must be used.",
      "ja": "ただし、送信側の場合、このAPIは[RFC-2460]に従っていくつかの順序制約を課します。このAPIを使用するアプリケーションは、注文に従わない拡張ヘッダーを備えたパケットを作成することはできません。ただし、これはアプリケーションが常に制限に従わなければならないという意味ではないことに注意してください。これは、アプリケーションプログラマーに実用的な方法でヘッダーを構築するためのガイドラインを提供するためのこのAPIの単なる制限です。アプリケーションが拡張ヘッダーについて任意の順序で送信パケットを作成する必要がある場合、DatalinkインターフェイスBPFやDLPIなどの他の手法を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The followings are more details about the constraints:",
      "ja": "以下は、制約の詳細です。"
    },
    {
      "indent": 3,
      "text": "- Each IPV6_xxx ancillary data object for a particular type of extension header can be specified at most once in a single control buffer.",
      "ja": "- 特定のタイプの拡張ヘッダーの各IPv6_xxx補助データオブジェクトは、1つのコントロールバッファーで最大で1回指定できます。"
    },
    {
      "indent": 3,
      "text": "- IPV6_xxx ancillary data objects can appear in any order in a control buffer, because there is no ambiguity of the ordering.",
      "ja": "- IPv6_xxx順序付けのあいまいさがないため、IPv6_xxxの補助データオブジェクトは、コントロールバッファーで任意の順序で表示できます。"
    },
    {
      "indent": 3,
      "text": "- Each set of IPV6_xxx ancillary data objects and sticky options will be put in the outgoing packet along with the header ordering described in [RFC-2460].",
      "ja": "- [RFC-2460]で説明されているヘッダー順序とともに、IPv6_xxxの補助データオブジェクトとスティッキーオプションの各セットが発信パケットに配置されます。"
    },
    {
      "indent": 3,
      "text": "- An ancillary data object or a sticky option of IPV6_RTHDRDSTOPTS will affect the outgoing packet only when a Routing header is specified as an ancillary data object or a sticky option. Otherwise, the specified value for IPV6_RTHDRDSTOPTS will be ignored.",
      "ja": "- 補助データオブジェクトまたはIPv6_rthdrdstoptsの粘着性オプションは、ルーティングヘッダーが補助データオブジェクトまたは粘着性オプションとして指定されている場合にのみ、発信パケットに影響します。それ以外の場合、IPv6_RTHDRDSTOPTSの指定された値は無視されます。"
    },
    {
      "indent": 3,
      "text": "For example, when an application sends a UDP datagram with a control data buffer containing ancillary data objects in the following order:",
      "ja": "たとえば、アプリケーションが次の順序で補助データオブジェクトを含むコントロールデータバッファーを備えたUDPデータグラムを送信する場合："
    },
    {
      "indent": 6,
      "text": "an object with cmsg_type set to IPV6_DSTOPTS an object with cmsg_type set to IPV6_RTHDRDSTOPTS an object with cmsg_type set to IPV6_HOPOPTS",
      "ja": "cmsg_toptsに設定されたcmsg_topts cmsg_toptsに設定されたオブジェクトcmsg_typeを備えたオブジェクトはipv6_rthdrdstopts cmsg_toptsに設定されているオブジェクト"
    },
    {
      "indent": 3,
      "text": "and the sending socket does not have any sticky options, then the outgoing packet would be constructed as follows:",
      "ja": "また、送信ソケットには粘着性のオプションがありません。その後、発信パケットは次のように構築されます。"
    },
    {
      "indent": 6,
      "text": "The IPv6 header A Hop-by-Hop options header A Destination options header A UDP header and UDP data",
      "ja": "IPv6ヘッダーホップバイホップオプションヘッダー宛先オプションヘッダーUDPヘッダーとUDPデータ"
    },
    {
      "indent": 3,
      "text": "where the destination options header corresponds to the ancillary data object with the type IPV6_DSTOPTS.",
      "ja": "宛先オプションヘッダーは、タイプIPv6_dstoptsを使用して補助データオブジェクトに対応します。"
    },
    {
      "indent": 3,
      "text": "Note that the constraints above do not necessarily mean that the outgoing packet sent on the wire always follows the header ordering specified in this API document. The kernel may insert additional headers that break the ordering as a result. For example, if the kernel supports Mobile IPv6, an additional destination options header may be inserted before an authentication header, even without a routing header.",
      "ja": "上記の制約は、ワイヤー上に送信された送信パケットが常にこのAPIドキュメントで指定されたヘッダー順序に従うことを意味するわけではないことに注意してください。カーネルは、結果として順序を破る追加のヘッダーを挿入する場合があります。たとえば、カーネルがモバイルIPv6をサポートする場合、ルーティングヘッダーがなくても、認証ヘッダーの前に追加の宛先オプションヘッダーが挿入される場合があります。"
    },
    {
      "indent": 3,
      "text": "This API does not provide access to any other extension headers than the supported three types of headers. In particular, no information is provided about the IP security headers on an incoming packet, nor can be specified for an outgoing packet. This API is for applications that do not care about the existence of IP security headers.",
      "ja": "このAPIは、サポートされている3種類のヘッダーよりも、他の拡張ヘッダーへのアクセスを提供しません。特に、着信パケットのIPセキュリティヘッダーに関する情報は提供されておらず、発信パケット用に指定することもできません。このAPIは、IPセキュリティヘッダーの存在を気にしないアプリケーション向けです。"
    },
    {
      "indent": 0,
      "text": "13. IPv6-Specific Options with IPv4-Mapped IPv6 Addresses",
      "section_title": true,
      "ja": "13. IPv4マップIPv6アドレスを使用したIPv6固有のオプション"
    },
    {
      "indent": 3,
      "text": "The various socket options and ancillary data specifications defined in this document apply only to true IPv6 sockets. It is possible to create an IPv6 socket that actually sends and receives IPv4 packets, using IPv4-mapped IPv6 addresses, but the mapping of the options defined in this document to an IPv4 datagram is beyond the scope of this document.",
      "ja": "このドキュメントで定義されているさまざまなソケットオプションと補助データ仕様は、真のIPv6ソケットにのみ適用されます。IPv4-Mapped IPv6アドレスを使用して、IPv4パケットを実際に送信および受信するIPv6ソケットを作成することができますが、このドキュメントで定義されているオプションのマッピングは、IPv4データグラムにこのドキュメントの範囲を超えています。"
    },
    {
      "indent": 3,
      "text": "In general, attempting to specify an IPv6-only option, such as the Hop-by-Hop options, Destination options, or Routing header on an IPv6 socket that is using IPv4-mapped IPv6 addresses, will probably result in an error. Some implementations, however, may provide access to the packet information (source/destination address, send/receive interface, and hop limit) on an IPv6 socket that is using IPv4-mapped IPv6 addresses.",
      "ja": "一般に、IPv4-Mapped IPv6アドレスを使用しているIPv6ソケットのホップバイホップオプション、宛先オプション、またはルーティングヘッダーなど、IPv6のみのオプションを指定しようとすると、おそらくエラーが発生します。ただし、一部の実装では、IPv4マップのIPv6アドレスを使用しているIPv6ソケットのパケット情報（ソース/宛先アドレス、送信/受信インターフェイス、およびホップ制限）へのアクセスを提供する場合があります。"
    },
    {
      "indent": 0,
      "text": "14. Extended interfaces for rresvport, rcmd and rexec",
      "section_title": true,
      "ja": "14. RRESVPORT、RCMD、REXECの拡張インターフェイス"
    },
    {
      "indent": 3,
      "text": "Library functions that support the \"r\" commands hide the creation of a socket and the name resolution procedure from an application. When the libraries return an AF_INET6 socket to an application that do not support the address family, the application may encounter an unexpected result when, e.g., calling getpeername() for the socket. In order to support AF_INET6 sockets for the \"r\" commands while keeping backward compatibility, this section defines some extensions to the libraries.",
      "ja": "「R」コマンドをサポートするライブラリ関数は、ソケットの作成と、アプリケーションからの名前解決手順を非表示にします。ライブラリがAF_INET6ソケットをアドレスファミリをサポートしないアプリケーションに返すと、たとえばソケットのgetPeername（）を呼び出すと、アプリケーションが予期しない結果に遭遇する可能性があります。後方互換性を維持しながら「R」コマンドのAF_INET6ソケットをサポートするために、このセクションでは、ライブラリへのいくつかの拡張機能を定義します。"
    },
    {
      "indent": 0,
      "text": "14.1. rresvport_af",
      "section_title": true,
      "ja": "14.1. rresvport_af"
    },
    {
      "indent": 3,
      "text": "The rresvport() function is used by the rcmd() function, and this function is in turn called by many of the \"r\" commands such as rlogin. While new applications are not being written to use the rcmd() function, legacy applications such as rlogin will continue to use it and these will be ported to IPv6.",
      "ja": "rresvport（）関数はrcmd（）関数によって使用され、この関数はrloginなどの「r」コマンドの多くで順番に呼び出されます。RCMD（）関数を使用するための新しいアプリケーションは書かれていませんが、Rloginなどのレガシーアプリケーションは引き続き使用され、これらはIPv6に移植されます。"
    },
    {
      "indent": 3,
      "text": "rresvport() creates an IPv4/TCP socket and binds a \"reserved port\" to the socket. Instead of defining an IPv6 version of this function we define a new function that takes an address family as its argument.",
      "ja": "rresvport（）は、IPv4/TCPソケットを作成し、「予約ポート」をソケットにバインドします。この関数のIPv6バージョンを定義する代わりに、アドレスファミリをその引数として取る新しい関数を定義します。"
    },
    {
      "indent": 6,
      "text": "#include <unistd.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "int  rresvport_af(int *port, int family);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This function behaves the same as the existing rresvport() function, but instead of creating an AF_INET TCP socket, it can also create an AF_INET6 TCP socket. The family argument is either AF_INET or AF_INET6, and a new error return is EAFNOSUPPORT if the address family is not supported.",
      "ja": "この関数は既存のrresvport（）関数と同じ動作をしますが、AF_INET TCPソケットを作成する代わりに、AF_INET6 TCPソケットを作成することもできます。家族の議論はaf_inetまたはaf_inet6のいずれかであり、アドレスファミリがサポートされていない場合、新しいエラーリターンはeafnosupportです。"
    },
    {
      "indent": 3,
      "text": "(Note: There is little consensus on which header defines the rresvport() and rcmd() function prototypes. 4.4BSD defines it in <unistd.h>, others in <netdb.h>, and others don't define the function prototypes at all.)",
      "ja": "（注：ヘッダーがrresvport（）およびrcmd（）関数プロトタイプを定義するコンセンサスはほとんどありません。まったく。）"
    },
    {
      "indent": 0,
      "text": "14.2. rcmd_af",
      "section_title": true,
      "ja": "14.2. RCMD_AF"
    },
    {
      "indent": 3,
      "text": "The existing rcmd() function can not transparently use AF_INET6 sockets since an application would not be prepared to handle AF_INET6 addresses returned by e.g., getpeername() on the file descriptor created by rcmd(). Thus a new function is needed.",
      "ja": "既存のrcmd（）関数は、rcmd（）によって作成されたファイル記述子のgetPeername（）で返されるAF_INET6アドレスを処理するためのアプリケーションが準備されていないため、AF_INET6ソケットを透過的に使用することはできません。したがって、新しい機能が必要です。"
    },
    {
      "indent": 6,
      "text": "int rcmd_af(char **ahost, unsigned short rport,\n            const char *locuser, const char *remuser,\n            const char *cmd, int *fd2p, int af)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This function behaves the same as the existing rcmd() function, but instead of creating an AF_INET TCP socket, it can also create an AF_INET6 TCP socket. The family argument is AF_INET, AF_INET6, or AF_UNSPEC. When either AF_INET or AF_INET6 is specified, this function will create a socket of the specified address family. When AF_UNSPEC is specified, it will try all possible address families until a connection can be established, and will return the associated socket of the connection. A new error EAFNOSUPPORT will be returned if the address family is not supported.",
      "ja": "この関数は既存のrcmd（）関数と同じように動作しますが、AF_INET TCPソケットを作成する代わりに、AF_INET6 TCPソケットを作成することもできます。家族の議論は、af_inet、af_inet6、またはaf_unspecです。AF_INETまたはAF_INET6のいずれかが指定されている場合、この関数は指定されたアドレスファミリのソケットを作成します。AF_UNSPECが指定されると、接続が確立できるまですべての可能なアドレスファミリを試み、接続の関連ソケットを返します。アドレスファミリがサポートされていない場合、新しいエラーeafnosupportが返されます。"
    },
    {
      "indent": 0,
      "text": "14.3. rexec_af",
      "section_title": true,
      "ja": "14.3. rexec_af"
    },
    {
      "indent": 3,
      "text": "The existing rexec() function can not transparently use AF_INET6 sockets since an application would not be prepared to handle AF_INET6 addresses returned by e.g., getpeername() on the file descriptor created by rexec(). Thus a new function is needed.",
      "ja": "既存のrexec（）関数は、rexec（）によって作成されたファイル記述子のgetPeername（）で返されるAF_INET6アドレスを処理するためのアプリケーションが準備されていないため、AF_INET6ソケットを透過的に使用することはできません。したがって、新しい機能が必要です。"
    },
    {
      "indent": 6,
      "text": "int rexec_af(char **ahost, unsigned short rport, const char *name,\n             const char *pass, const char *cmd, int *fd2p, int af)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This function behaves the same as the existing rexec() function, but instead of creating an AF_INET TCP socket, it can also create an AF_INET6 TCP socket. The family argument is AF_INET, AF_INET6, or AF_UNSPEC. When either AF_INET or AF_INET6 is specified, this function will create a socket of the specified address family. When AF_UNSPEC is specified, it will try all possible address families until a connection can be established, and will return the associated socket of the connection. A new error EAFNOSUPPORT will be returned if the address family is not supported.",
      "ja": "この関数は既存のrexec（）関数と同じ動作をしますが、AF_INET TCPソケットを作成する代わりに、AF_INET6 TCPソケットを作成することもできます。家族の議論は、af_inet、af_inet6、またはaf_unspecです。AF_INETまたはAF_INET6のいずれかが指定されている場合、この関数は指定されたアドレスファミリのソケットを作成します。AF_UNSPECが指定されると、接続が確立できるまですべての可能なアドレスファミリを試み、接続の関連ソケットを返します。アドレスファミリがサポートされていない場合、新しいエラーeafnosupportが返されます。"
    },
    {
      "indent": 0,
      "text": "15. Summary of New Definitions",
      "section_title": true,
      "ja": "15. 新しい定義の概要"
    },
    {
      "indent": 3,
      "text": "The following list summarizes the constants and structure, definitions discussed in this memo, sorted by header.",
      "ja": "次のリストは、Headerでソートされたこのメモで説明されている定義、定義を要約しています。"
    },
    {
      "indent": 6,
      "text": "<netinet/icmp6.h> ICMP6_DST_UNREACH\n<netinet/icmp6.h> ICMP6_DST_UNREACH_ADDR\n<netinet/icmp6.h> ICMP6_DST_UNREACH_ADMIN\n<netinet/icmp6.h> ICMP6_DST_UNREACH_BEYONDSCOPE\n<netinet/icmp6.h> ICMP6_DST_UNREACH_NOPORT\n<netinet/icmp6.h> ICMP6_DST_UNREACH_NOROUTE\n<netinet/icmp6.h> ICMP6_ECHO_REPLY\n<netinet/icmp6.h> ICMP6_ECHO_REQUEST\n<netinet/icmp6.h> ICMP6_INFOMSG_MASK",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<netinet/icmp6.h> ICMP6_PACKET_TOO_BIG\n<netinet/icmp6.h> ICMP6_PARAMPROB_HEADER\n<netinet/icmp6.h> ICMP6_PARAMPROB_NEXTHEADER\n<netinet/icmp6.h> ICMP6_PARAMPROB_OPTION\n<netinet/icmp6.h> ICMP6_PARAM_PROB\n<netinet/icmp6.h> ICMP6_ROUTER_RENUMBERING\n<netinet/icmp6.h> ICMP6_RR_FLAGS_FORCEAPPLY\n<netinet/icmp6.h> ICMP6_RR_FLAGS_PREVDONE\n<netinet/icmp6.h> ICMP6_RR_FLAGS_REQRESULT\n<netinet/icmp6.h> ICMP6_RR_FLAGS_SPECSITE\n<netinet/icmp6.h> ICMP6_RR_FLAGS_TEST\n<netinet/icmp6.h> ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME\n<netinet/icmp6.h> ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME\n<netinet/icmp6.h> ICMP6_RR_PCOUSE_RAFLAGS_AUTO\n<netinet/icmp6.h> ICMP6_RR_PCOUSE_RAFLAGS_ONLINK\n<netinet/icmp6.h> ICMP6_RR_RESULT_FLAGS_FORBIDDEN\n<netinet/icmp6.h> ICMP6_RR_RESULT_FLAGS_OOB\n<netinet/icmp6.h> ICMP6_TIME_EXCEEDED\n<netinet/icmp6.h> ICMP6_TIME_EXCEED_REASSEMBLY\n<netinet/icmp6.h> ICMP6_TIME_EXCEED_TRANSIT\n<netinet/icmp6.h> MLD_LISTENER_QUERY\n<netinet/icmp6.h> MLD_LISTENER_REDUCTION\n<netinet/icmp6.h> MLD_LISTENER_REPORT\n<netinet/icmp6.h> ND_NA_FLAG_OVERRIDE\n<netinet/icmp6.h> ND_NA_FLAG_ROUTER\n<netinet/icmp6.h> ND_NA_FLAG_SOLICITED\n<netinet/icmp6.h> ND_NEIGHBOR_ADVERT\n<netinet/icmp6.h> ND_NEIGHBOR_SOLICIT\n<netinet/icmp6.h> ND_OPT_MTU\n<netinet/icmp6.h> ND_OPT_PI_FLAG_AUTO\n<netinet/icmp6.h> ND_OPT_PI_FLAG_ONLINK\n<netinet/icmp6.h> ND_OPT_PREFIX_INFORMATION\n<netinet/icmp6.h> ND_OPT_REDIRECTED_HEADER\n<netinet/icmp6.h> ND_OPT_SOURCE_LINKADDR\n<netinet/icmp6.h> ND_OPT_TARGET_LINKADDR\n<netinet/icmp6.h> ND_RA_FLAG_MANAGED\n<netinet/icmp6.h> ND_RA_FLAG_OTHER\n<netinet/icmp6.h> ND_REDIRECT\n<netinet/icmp6.h> ND_ROUTER_ADVERT\n<netinet/icmp6.h> ND_ROUTER_SOLICIT",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<netinet/icmp6.h> struct icmp6_filter{};\n<netinet/icmp6.h> struct icmp6_hdr{};\n<netinet/icmp6.h> struct icmp6_router_renum{};\n<netinet/icmp6.h> struct mld_hdr{};\n<netinet/icmp6.h> struct nd_neighbor_advert{};\n<netinet/icmp6.h> struct nd_neighbor_solicit{};\n<netinet/icmp6.h> struct nd_opt_hdr{};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<netinet/icmp6.h> struct nd_opt_mtu{};\n<netinet/icmp6.h> struct nd_opt_prefix_info{};\n<netinet/icmp6.h> struct nd_opt_rd_hdr{};\n<netinet/icmp6.h> struct nd_redirect{};\n<netinet/icmp6.h> struct nd_router_advert{};\n<netinet/icmp6.h> struct nd_router_solicit{};\n<netinet/icmp6.h> struct rr_pco_match{};\n<netinet/icmp6.h> struct rr_pco_use{};\n<netinet/icmp6.h> struct rr_result{};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<netinet/in.h>    IPPROTO_AH\n<netinet/in.h>    IPPROTO_DSTOPTS\n<netinet/in.h>    IPPROTO_ESP\n<netinet/in.h>    IPPROTO_FRAGMENT\n<netinet/in.h>    IPPROTO_HOPOPTS\n<netinet/in.h>    IPPROTO_ICMPV6\n<netinet/in.h>    IPPROTO_IPV6\n<netinet/in.h>    IPPROTO_NONE\n<netinet/in.h>    IPPROTO_ROUTING\n<netinet/in.h>    IPV6_CHECKSUM\n<netinet/in.h>    IPV6_DONTFRAG\n<netinet/in.h>    IPV6_DSTOPTS\n<netinet/in.h>    IPV6_HOPLIMIT\n<netinet/in.h>    IPV6_HOPOPTS",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<netinet/in.h>    IPV6_NEXTHOP\n<netinet/in.h>    IPV6_PATHMTU\n<netinet/in.h>    IPV6_PKTINFO\n<netinet/in.h>    IPV6_RECVDSTOPTS\n<netinet/in.h>    IPV6_RECVHOPLIMIT\n<netinet/in.h>    IPV6_RECVHOPOPTS\n<netinet/in.h>    IPV6_RECVPKTINFO\n<netinet/in.h>    IPV6_RECVRTHDR\n<netinet/in.h>    IPV6_RECVTCLASS\n<netinet/in.h>    IPV6_RTHDR\n<netinet/in.h>    IPV6_RTHDRDSTOPTS\n<netinet/in.h>    IPV6_RTHDR_TYPE_0\n<netinet/in.h>    IPV6_RECVPATHMTU\n<netinet/in.h>    IPV6_TCLASS\n<netinet/in.h>    IPV6_USE_MIN_MTU\n<netinet/in.h>    struct in6_pktinfo{};\n<netinet/in.h>    struct ip6_mtuinfo{};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<netinet/ip6.h>   IP6F_MORE_FRAG\n<netinet/ip6.h>   IP6F_OFF_MASK\n<netinet/ip6.h>   IP6F_RESERVED_MASK\n<netinet/ip6.h>   IP6OPT_JUMBO\n<netinet/ip6.h>   IP6OPT_JUMBO_LEN",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<netinet/ip6.h>   IP6OPT_MUTABLE\n<netinet/ip6.h>   IP6OPT_NSAP_ADDR\n<netinet/ip6.h>   IP6OPT_PAD1\n<netinet/ip6.h>   IP6OPT_PADN\n<netinet/ip6.h>   IP6OPT_ROUTER_ALERT\n<netinet/ip6.h>   IP6OPT_TUNNEL_LIMIT\n<netinet/ip6.h>   IP6OPT_TYPE_DISCARD\n<netinet/ip6.h>   IP6OPT_TYPE_FORCEICMP\n<netinet/ip6.h>   IP6OPT_TYPE_ICMP\n<netinet/ip6.h>   IP6OPT_TYPE_SKIP\n<netinet/ip6.h>   IP6_ALERT_AN\n<netinet/ip6.h>   IP6_ALERT_MLD\n<netinet/ip6.h>   IP6_ALERT_RSVP\n<netinet/ip6.h>   struct ip6_dest{};\n<netinet/ip6.h>   struct ip6_frag{};\n<netinet/ip6.h>   struct ip6_hbh{};\n<netinet/ip6.h>   struct ip6_hdr{};\n<netinet/ip6.h>   struct ip6_opt{};\n<netinet/ip6.h>   struct ip6_opt_jumbo{};\n<netinet/ip6.h>   struct ip6_opt_nsap{};\n<netinet/ip6.h>   struct ip6_opt_router{};\n<netinet/ip6.h>   struct ip6_opt_tunnel{};\n<netinet/ip6.h>   struct ip6_rthdr{};\n<netinet/ip6.h>   struct ip6_rthdr0{};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following list summarizes the function and macro prototypes discussed in this memo, sorted by header.",
      "ja": "次のリストは、このメモで説明されている関数とマクロプロトタイプを要約して、ヘッダーでソートします。"
    },
    {
      "indent": 6,
      "text": "<netinet/icmp6.h> void ICMP6_FILTER_SETBLOCK(int, struct\n                                         icmp6_filter *);\n<netinet/icmp6.h> void\n                  ICMP6_FILTER_SETBLOCKALL(struct icmp6_filter *);\n<netinet/icmp6.h> void\n                  ICMP6_FILTER_SETPASS(int,\n                                       struct icmp6_filter *);\n<netinet/icmp6.h> void\n                  ICMP6_FILTER_SETPASSALL(struct icmp6_filter *);\n<netinet/icmp6.h> int  ICMP6_FILTER_WILLBLOCK(int,\n                                     const struct icmp6_filter *);\n<netinet/icmp6.h> int  ICMP6_FILTER_WILLPASS(int,\n                                     const struct icmp6_filter *);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<netinet/in.h>    int IN6_ARE_ADDR_EQUAL(const struct in6_addr *,\n                                     const struct in6_addr *);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<netinet/in.h>    int inet6_opt_append(void *, socklen_t, int,\n                                       uint8_t, socklen_t, uint_t,\n                                       void **);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<netinet/in.h>    int inet6_opt_get_val(void *, int, void *,\n                                        socklen_t);\n<netinet/in.h>    int inet6_opt_find(void *, socklen_t,\n                                     int, uint8_t ,\n                                     socklen_t *, void **);\n<netinet/in.h>    int inet6_opt_finish(void *, socklen_t, int);\n<netinet/in.h>    int inet6_opt_init(void *, socklen_t);\n<netinet/in.h>    int inet6_opt_next(void *, socklen_t,\n                                     int, uint8_t *,\n                                     socklen_t *, void **);\n<netinet/in.h>    int inet6_opt_set_val(void *, int,\n                                        void *, socklen_t);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<netinet/in.h>    int inet6_rth_add(void *,\n                                    const struct in6_addr *);\n<netinet/in.h>    struct in6_addr inet6_rth_getaddr(const void *,\n                                                    int);\n<netinet/in.h>    void *inet6_rth_init(void *, socklen_t,\n                                       int, int);\n<netinet/in.h>    int inet6_rth_reverse(const void *, void *);\n<netinet/in.h>    int inet6_rth_segments(const void *);\n<netinet/in.h>    soccklen_t inet6_rth_space(int, int);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<netinet/ip6.h>   int  IP6OPT_TYPE(uint8_t);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<sys/socket.h>    socklen_t CMSG_LEN(socklen_t);\n<sys/socket.h>    socklen_t CMSG_SPACE(socklen_t);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<unistd.h>        int rresvport_af(int *, int);\n<unistd.h>        int rcmd_af(char **, unsigned short,\n                              const char *, const char *,\n                              const char *, int *, int);\n<unistd.h>        int rexec_af(char **, unsigned short,\n                               const char *, const char *,\n                               const char *, int *, int);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "16. Security Considerations",
      "section_title": true,
      "ja": "16. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The setting of certain Hop-by-Hop options and Destination options may be restricted to privileged processes. Similarly some Hop-by-Hop options and Destination options may not be returned to non-privileged applications.",
      "ja": "特定のホップバイホップオプションと宛先オプションの設定は、特権プロセスに制限される場合があります。同様に、一部のホップバイホップオプションと宛先オプションは、非具体的なアプリケーションに返されない場合があります。"
    },
    {
      "indent": 3,
      "text": "The ability to specify an arbitrary source address using IPV6_PKTINFO must be prevented; at least for non-privileged processes.",
      "ja": "IPv6_pktinfoを使用して任意のソースアドレスを指定する機能を防ぐ必要があります。少なくとも非主要なプロセスの場合。"
    },
    {
      "indent": 0,
      "text": "17. Changes from RFC 2292",
      "section_title": true,
      "ja": "17. RFC 2292からの変更"
    },
    {
      "indent": 3,
      "text": "Significant changes that affect the compatibility to RFC 2292:",
      "ja": "RFC 2292との互換性に影響する重要な変更："
    },
    {
      "indent": 3,
      "text": "- Removed the IPV6_PKTOPTIONS socket option by allowing sticky options to be set with individual setsockopt() calls.",
      "ja": "- 個々のSetSockopt（）呼び出しで粘着性オプションを設定できるようにすることにより、IPv6_pktoptionsソケットオプションを削除しました。"
    },
    {
      "indent": 3,
      "text": "- Removed the ability to be able to specify Hop-by-Hop and Destination options using multiple ancillary data items. The application, using the inet6_opt_xxx() routines (see below), is responsible for formatting the whole extension header.",
      "ja": "- 複数の補助データ項目を使用して、ホップバイホップおよび宛先オプションを指定できる機能を削除しました。INET6_OPT_XXX（）ルーチン（以下を参照）を使用するアプリケーションは、拡張ヘッダー全体のフォーマットを担当します。"
    },
    {
      "indent": 3,
      "text": "- Removed the support for the loose/strict Routing header since that has been removed from the IPv6 specification.",
      "ja": "- IPv6仕様から削除されたため、ルーズ/厳格なルーティングヘッダーのサポートを削除しました。"
    },
    {
      "indent": 3,
      "text": "- Loosened the constraints for jumbo payload option that this option was always hidden from applications.",
      "ja": "- このオプションは常にアプリケーションから隠されていたというジャンボペイロードオプションの制約を緩めました。"
    },
    {
      "indent": 3,
      "text": "- Disabled the use of the IPV6_HOPLIMIT sticky option.",
      "ja": "- IPv6_hoplimitスティッキーオプションの使用を無効にしました。"
    },
    {
      "indent": 3,
      "text": "- Removed ip6r0_addr field from the ip6_rthdr structure.",
      "ja": "- IP6_RTHDR構造からIP6R0_ADDRフィールドを削除しました。"
    },
    {
      "indent": 3,
      "text": "- Intentionally unspecified how to get received packet's information on TCP sockets.",
      "ja": "- TCPソケットに関する受信パケットの情報を取得する方法を意図的に特定していません。"
    },
    {
      "indent": 3,
      "text": "New features:",
      "ja": "新機能："
    },
    {
      "indent": 3,
      "text": "- Added IPV6_RTHDRDSTOPTS to specify a Destination Options header before the Routing header.",
      "ja": "- IPv6_rthdrdstoptsを追加して、ルーティングヘッダーの前に宛先オプションヘッダーを指定しました。"
    },
    {
      "indent": 3,
      "text": "- Added separate IPV6_RECVxxx options to enable the receipt of the corresponding ancillary data items.",
      "ja": "- 対応する補助データ項目の受領を有効にするために、個別のIPv6_Recvxxxオプションを追加しました。"
    },
    {
      "indent": 3,
      "text": "- Added inet6_rth_xxx() and inet6_opt_xxx() functions to deal with routing or IPv6 options headers.",
      "ja": "- INET6_RTH_XXX（）およびINET6_OPT_XXX（）を追加して、ルーティングまたはIPv6オプションヘッダーを扱うように機能します。"
    },
    {
      "indent": 3,
      "text": "- Added extensions of libraries for the \"r\" commands.",
      "ja": "- 「R」コマンドのライブラリの拡張機能を追加しました。"
    },
    {
      "indent": 3,
      "text": "- Introduced additional IPv6 option definitions such as IP6OPT_PAD1.",
      "ja": "- IP6OPT_PAD1などの追加のIPv6オプション定義を導入しました。"
    },
    {
      "indent": 3,
      "text": "- Added MLD and router renumbering definitions.",
      "ja": "- MLDおよびルーターの変更定義を追加しました。"
    },
    {
      "indent": 3,
      "text": "- Added MTU-related socket options and ancillary data items.",
      "ja": "- MTU関連のソケットオプションと補助データ項目を追加しました。"
    },
    {
      "indent": 3,
      "text": "- Added options and ancillary data items to manipulate the traffic class field.",
      "ja": "- トラフィッククラスフィールドを操作するためのオプションと補助データ項目が追加されました。"
    },
    {
      "indent": 3,
      "text": "- Changed the name of ICMPv6 unreachable code 2 to be \"beyond scope of source address.\" ICMP6_DST_UNREACH_NOTNEIGHBOR was removed with this change.",
      "ja": "- ICMPV6の到達不可能なコード2の名前を「ソースアドレスの範囲を超えて」に変更しました。ICMP6_DST_UNREACH_NOTNEIGHBORは、この変更により削除されました。"
    },
    {
      "indent": 3,
      "text": "Clarifications:",
      "ja": "説明："
    },
    {
      "indent": 3,
      "text": "- Added clarifications on extension headers ordering; for the sending side, assume the recommended ordering described in RFC 2460. For the receiving side, do not assume any ordering and pass all headers to the application in the received order.",
      "ja": "- 拡張ヘッダー注文に明確化を追加しました。送信側の場合、RFC 2460に記載されている推奨注文を想定してください。受信側については、注文を想定せず、受信順序ですべてのヘッダーをアプリケーションに渡さないでください。"
    },
    {
      "indent": 3,
      "text": "- Added a summary about the interface selection rule.",
      "ja": "- インターフェイス選択ルールに関する要約を追加しました。"
    },
    {
      "indent": 3,
      "text": "- Clarified the ordering between IPV6_MULTICAST_IF and the IPV6_PKTINFO sticky option for multicast packets.",
      "ja": "- IPv6_multicast_ifとマルチキャストパケットのIPv6_pktinfoスティッキーオプションの間の順序を明確にしました。"
    },
    {
      "indent": 3,
      "text": "- Clarified how sticky options and the ICMPv6 filter are turned off and that getsockopt() of a sticky option returns what was set with setsockopt().",
      "ja": "- 粘着性のオプションとICMPV6フィルターがオフになっている方法を明確にし、StickyオプションのGetSockopt（）がSetSockopt（）で設定されたものを返します。"
    },
    {
      "indent": 3,
      "text": "- Clarified that IPV6_NEXTHOP should be ignored for a multicast destination, that it should not contradict with the specified outgoing interface, and that the next hop should be a sockaddr_in6 structure.",
      "ja": "- IPv6_Nexthopは、マルチキャストの目的地では無視されるべきであり、指定された発信インターフェイスと矛盾するべきではないこと、次のホップはSockaddr_in6構造であることを明らかにしました。"
    },
    {
      "indent": 3,
      "text": "- Clarified corner cases of IPV6_CHECKSUM.",
      "ja": "- IPv6_Checksumの明確なコーナーケース。"
    },
    {
      "indent": 3,
      "text": "- Aligned with the POSIX standard.",
      "ja": "- POSIX標準と整合しています。"
    },
    {
      "indent": 3,
      "text": "Editorial changes:",
      "ja": "編集の変更："
    },
    {
      "indent": 3,
      "text": "- Replaced MUST with must (since this is an informational document).",
      "ja": "- Mustに置き換えられた必要があります（これは情報ドキュメントであるため）。"
    },
    {
      "indent": 3,
      "text": "- Revised abstract to be more clear and concise, particularly concentrating on differences from RFC 2292.",
      "ja": "- 改訂された要約は、特にRFC 2292との違いに集中して、より明確かつ簡潔にします。"
    },
    {
      "indent": 3,
      "text": "- Made the URL of assigned numbers less specific so that it would be more robust for future changes.",
      "ja": "- 割り当てられた数値のURLを具体的にしなくなり、将来の変更により堅牢になりました。"
    },
    {
      "indent": 3,
      "text": "- Updated the reference to the basic API.",
      "ja": "- 基本的なAPIへの参照を更新しました。"
    },
    {
      "indent": 3,
      "text": "- Added a reference to the latest POSIX standard.",
      "ja": "- 最新のPOSIX標準への参照を追加しました。"
    },
    {
      "indent": 3,
      "text": "- Moved general specifications of ancillary data and CMSG macros to the appendix.",
      "ja": "- 補助データとCMSGマクロの一般仕様を付録に移動しました。"
    },
    {
      "indent": 0,
      "text": "18. References",
      "section_title": true,
      "ja": "18. 参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC-1981] McCann, J., Deering, S. and J. Mogul, \"Path MTU Discovery for IP version 6\", RFC 1981, August 1996.",
      "ja": "[RFC-1981] McCann、J.、Deering、S。、およびJ. Mogul、「IPバージョン6のPath MTU Discovery」、RFC 1981、1996年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC-2460] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[RFC-2460] Deering、S。and R. Hinden、「Internet Protocol、バージョン6（IPv6）仕様」、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC-3493] Gilligan, R., Thomson, S., Bound, J., McCann, J. and W. Stevens, \"Basic Socket Interface Extensions for IPv6\", RFC 3493, March 2003.",
      "ja": "[RFC-3493] Gilligan、R.、Thomson、S.、Bound、J.、McCann、J。、およびW. Stevens、「IPv6の基本ソケットインターフェイス拡張」、RFC 3493、2003年3月。"
    },
    {
      "indent": 3,
      "text": "[POSIX] IEEE Std. 1003.1-2001 Standard for Information Technology -- Portable Operating System Interface (POSIX). Open group Technical Standard: Base Specifications, Issue 6, December 2001. ISO/IEC 9945:2002. http://www.opengroup.org/austin",
      "ja": "[posix] IEEE std。1003.1-2001情報技術の標準 - ポータブルオペレーティングシステムインターフェイス（POSIX）。オープングループの技術標準：基本仕様、2001年12月、第6号。ISO/IEC 9945：2002。http://www.opengroup.org/austin"
    },
    {
      "indent": 3,
      "text": "[TCPIPILLUST] Wright, G., Stevens, W., \"TCP/IP Illustrated, Volume 2: The Implementation\", Addison Wesley, 1994.",
      "ja": "[Tcpipillust] Wright、G.、Stevens、W。、「TCP/IP Illustrated、Volume 2：The Information」、Addison Wesley、1994。"
    },
    {
      "indent": 0,
      "text": "19. Acknowledgments",
      "section_title": true,
      "ja": "19. 謝辞"
    },
    {
      "indent": 3,
      "text": "Matt Thomas and Jim Bound have been working on the technical details in this document for over a year. Keith Sklower is the original implementor of ancillary data in the BSD networking code. Craig Metz provided lots of feedback, suggestions, and comments based on his implementing many of these features as the document was being written. Mark Andrews first proposed the idea of the IPV6_USE_MIN_MTU option. Jun-ichiro Hagino contributed text for the traffic class API from a document of his own.",
      "ja": "マット・トーマスとジム・バウンドは、この文書の技術的な詳細に1年以上取り組んできました。Keith Sklowerは、BSDネットワークコードの補助データの元の実装者です。Craig Metzは、ドキュメントが書かれているときにこれらの機能の多くを実装することに基づいて、多くのフィードバック、提案、およびコメントを提供しました。マークアンドリュースは、最初にIPv6_use_min_mtuオプションのアイデアを提案しました。Jun-Ithiro Haginoは、彼自身のドキュメントからトラフィッククラスAPIのテキストを提供しました。"
    },
    {
      "indent": 3,
      "text": "The following provided comments on earlier drafts: Pascal Anelli, Hamid Asayesh, Ran Atkinson, Karl Auerbach, Hamid Asayesh, Don Coolidge, Matt Crawford, Sam T. Denton, Richard Draves, Francis Dupont, Toerless Eckert, Lilian Fernandes, Bob Gilligan, Gerri Harter, Tim Hartrick, Bob Halley, Masaki Hirabaru, Michael Hunter, Yoshinobu Inoue, Mukesh Kacker, A. N. Kuznetsov, Sam Manthorpe, Pedro Marques, Jack McCann, der Mouse, John Moy, Lori Napoli, Thomas Narten, Atsushi Onoe, Steve Parker, Charles Perkins, Ken Powell, Tom Pusateri, Pedro Roque, Sameer Shah, Peter Sjodin, Stephen P. Spackman, Jinmei Tatuya, Karen Tracey, Sowmini Varadhan, Quaizar Vohra, Carl Williams, Steve Wise, Eric Wong, Farrell Woods, Kazu Yamamoto, Vladislav Yasevich, and Yoshifuji Hideaki.",
      "ja": "以下は、以前のドラフトに関するコメントを提供しました：パスカルアネッリ、ハミドアセイシュ、ランアトキンソン、カールアウアーバッハ、ハミドアセイシュ、ドンクーリッジ、マットクロフォード、サムT.デントン、リチャードドレーブス、フランシスデュポン、トアレスエッカート、リリアンフェルナンデス、ボブギリガン、ゲリリガンハーター、ティム・ハートリック、ボブ・ハレー、マサキ・ヒラバル、マイケル・ハンター、ヨシノブ・イノウエ、ムケシュ・カッカー、A。N。クズネツォフ、サム・マンソープ、ペドロ・マルケス、ジャック・マッキャン、デル・マウス、ジョン・モイ、ロリ・ナポリ、トーマス・ナルテンチャールズ・パーキンス、ケン・パウエル、トム・プサテリ、ペドロ・ロケ、サミャー・シャー、ピーター・ショディン、スティーブン・P・スパックマン、ジンメイ・タトゥヤ、カレン・トレーシー、ソウミニ・バラダン、Quaizar Vohra、Carl Williams、Steve Wise、Eric WongVladislav Yasevich、およびYoshifuji Hideaki。"
    },
    {
      "indent": 0,
      "text": "20. Appendix A: Ancillary Data Overview",
      "section_title": true,
      "ja": "20. 付録A：補助データの概要"
    },
    {
      "indent": 3,
      "text": "4.2BSD allowed file descriptors to be transferred between separate processes across a UNIX domain socket using the sendmsg() and recvmsg() functions. Two members of the msghdr structure, msg_accrights and msg_accrightslen, were used to send and receive the descriptors. When the OSI protocols were added to 4.3BSD Reno in 1990 the names of these two fields in the msghdr structure were changed to msg_control and msg_controllen, because they were used by the OSI protocols for \"control information\", although the comments in the source code call this \"ancillary data\".",
      "ja": "4.2BSDでは、sendmsg（）およびrecvmsg（）関数を使用して、UNIXドメインソケットを横切る個別のプロセス間でファイル記述子を転送することができました。MSGHDR構造の2人のメンバーであるMSG_ACCRIGHTSとMSG_ACCRIGHTSLENが、記述子の送信と受信に使用されました。1990年にOSIプロトコルが4.3BSD RENOに追加されたとき、MSGHDR構造のこれら2つのフィールドの名前はMSG_CONTROLとMSG_CONTROLLENに変更されました。これを「補助データ」と呼びます。"
    },
    {
      "indent": 3,
      "text": "Other than the OSI protocols, the use of ancillary data has been rare. In 4.4BSD, for example, the only use of ancillary data with IPv4 is to return the destination address of a received UDP datagram if the IP_RECVDSTADDR socket option is set. With Unix domain sockets ancillary data is still used to send and receive descriptors.",
      "ja": "OSIプロトコル以外に、補助データの使用はまれです。たとえば、4.4BSDでは、IPv4を使用した補助データの唯一の使用は、IP_RECVDSTADDRソケットオプションが設定されている場合、受信したUDPデータグラムの宛先アドレスを返すことです。UNIXドメインソケットでは、補助データを使用して記述子を送信および受信します。"
    },
    {
      "indent": 3,
      "text": "Nevertheless the ancillary data fields of the msghdr structure provide a clean way to pass information in addition to the data that is being read or written. The inclusion of the msg_control and msg_controllen members of the msghdr structure along with the cmsghdr structure that is pointed to by the msg_control member is required by the Posix sockets API standard.",
      "ja": "それにもかかわらず、MSGHDR構造の補助データフィールドは、読み取られているデータに加えて情報を渡すクリーンな方法を提供します。MSGHDR構造のMSG_CONTROLおよびMSG_CONTROLLENメンバーを、MSG_CONTROLメンバーが指すCMSGHDR構造とともに、POSIX Sockets API標準で要求されます。"
    },
    {
      "indent": 0,
      "text": "20.1. The msghdr Structure",
      "section_title": true,
      "ja": "20.1. MSGHDR構造"
    },
    {
      "indent": 3,
      "text": "The msghdr structure is used by the recvmsg() and sendmsg() functions. Its Posix definition is:",
      "ja": "MSGHDR構造は、recvmsg（）およびsendmsg（）関数によって使用されます。そのposix定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "struct msghdr {\n  void      *msg_name;        /* ptr to socket address\n                                 structure */\n  socklen_t  msg_namelen;     /* size of socket address\n                                 structure */\n  struct iovec  *msg_iov;     /* scatter/gather array */\n  int        msg_iovlen;      /* # elements in msg_iov */\n  void      *msg_control;     /* ancillary data */\n  socklen_t  msg_controllen;  /* ancillary data buffer length */\n  int        msg_flags;       /* flags on received message */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The structure is declared as a result of including <sys/socket.h>.",
      "ja": "構造は、<sys/socket.h>を含めた結果として宣言されます。"
    },
    {
      "indent": 3,
      "text": "(Note: Before Posix the two \"void *\" pointers were typically \"char *\", and the two socklen_t members were typically integers. Earlier drafts of Posix had the two socklen_t members as size_t, but it then changed these to socklen_t to simplify binary portability for 64-bit implementations and to align Posix with X/Open's Networking Services, Issue 5. The change in msg_control to a \"void *\" pointer affects any code that increments this pointer.)",
      "ja": "（注：POSIXの前に、2つの「void *」ポインターは通常「char *」であり、2つのsocklen_tメンバーは通常整数でした。Posixの以前のドラフトには2つのsocklen_tメンバーがsize_tとしてありましたが、バイナリを簡素化するためにこれらをsocklen_tに変更しました。64ビットの実装のポータビリティおよびX/OpenのネットワークサービスにPOSIXを整列させるために、問題。MSG_CONTROLの「void *」ポインターへの変更は、このポインターを増やすコードに影響します。）"
    },
    {
      "indent": 3,
      "text": "Most Berkeley-derived implementations limit the amount of ancillary data in a call to sendmsg() to no more than 108 bytes (an mbuf). This API requires a minimum of 10240 bytes of ancillary data, but it is recommended that the amount be limited only by the buffer space reserved by the socket (which can be modified by the SO_SNDBUF socket option). (Note: This magic number 10240 was picked as a value that should always be large enough. 108 bytes is clearly too small as the maximum size of a Routing header is 2048 bytes.)",
      "ja": "ほとんどのバークレー由来の実装は、sendmsg（）への呼び出し中の補助データの量を108バイト（MBUF）以下に制限しています。このAPIには、最低10240バイトの補助データが必要ですが、ソケット（SO_SNDBUFソケットオプションで変更できます）で予約されたバッファースペースによってのみ量を制限することをお勧めします。（注：このマジック番号10240は、常に十分に大きくする値として選択されました。108バイトは、ルーティングヘッダーの最大サイズが2048バイトであるため、明らかに小さすぎます。）"
    },
    {
      "indent": 0,
      "text": "20.2. The cmsghdr Structure",
      "section_title": true,
      "ja": "20.2. CMSGHDR構造"
    },
    {
      "indent": 3,
      "text": "The cmsghdr structure describes ancillary data objects transferred by recvmsg() and sendmsg(). Its Posix definition is:",
      "ja": "CMSGHDR構造は、recvmsg（）およびsendmsg（）によって転送される補助データオブジェクトを記述します。そのposix定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "struct cmsghdr {\n  socklen_t  cmsg_len;   /* #bytes, including this header */\n  int        cmsg_level; /* originating protocol */\n  int        cmsg_type;  /* protocol-specific type */\n             /* followed by unsigned char cmsg_data[]; */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This structure is declared as a result of including <sys/socket.h>.",
      "ja": "この構造は、<sys/socket.h>を含めた結果として宣言されます。"
    },
    {
      "indent": 3,
      "text": "(Note: Before Posix the cmsg_len member was an integer, and not a socklen_t. See the Note in the previous section for why socklen_t is used here.)",
      "ja": "（注：POSIXの前に、CMSG_LENメンバーは整数であり、Socklen_Tではありませんでした。Socklen_Tがここで使用される理由については、前のセクションのメモを参照してください。）"
    },
    {
      "indent": 3,
      "text": "As shown in this definition, normally there is no member with the name cmsg_data[]. Instead, the data portion is accessed using the CMSG_xxx() macros, as described in Section 20.3. Nevertheless, it is common to refer to the cmsg_data[] member.",
      "ja": "この定義に示されているように、通常、CMSG_DATAという名前のメンバーはいません。代わりに、セクション20.3で説明されているように、データ部分にCMSG_XXX（）マクロを使用してアクセスされます。それにもかかわらず、CMSG_DATA []メンバーを参照することが一般的です。"
    },
    {
      "indent": 3,
      "text": "When ancillary data is sent or received, any number of ancillary data objects can be specified by the msg_control and msg_controllen members of the msghdr structure, because each object is preceded by a cmsghdr structure defining the object's length (the cmsg_len member). Historically Berkeley-derived implementations have passed only one object at a time, but this API allows multiple objects to be passed in a single call to sendmsg() or recvmsg(). The following example shows two ancillary data objects in a control buffer.",
      "ja": "補助的なデータが送信または受信されると、各オブジェクトの前にオブジェクトの長さ（CMSG_LENメンバー）を定義するCMSGHDR構造が先行するため、MSGHDR構造のMSG_CONTROLおよびMSG_CONTROLLENメンバーによって任意の数の補助データオブジェクトを指定できます。歴史的に、バークレー由来の実装では、一度に1つのオブジェクトのみに合格していますが、このAPIにより、複数のオブジェクトをsendmsg（）またはrecvmsg（）への1回の呼び出しで渡すことができます。次の例は、コントロールバッファー内の2つの補助データオブジェクトを示しています。"
    },
    {
      "indent": 0,
      "text": "|<--------------------------- msg_controllen ------------------------->|\n|                                 OR                                   |\n|<--------------------------- msg_controllen ---------------------->|\n|                                                                      |\n|<----- ancillary data object ----->|<---- ancillary data object ----->|\n|<------ min CMSG_SPACE() --------->|<----- min CMSG_SPACE() --------->|\n|                                   |                                  |\n|<---------- cmsg_len ---------->|  |<-------- cmsg_len ----------->|  |\n|<--------- CMSG_LEN() --------->|  |<------- CMSG_LEN() ---------->|  |\n|                                |  |                               |  |\n+-----+-----+-----+--+-----------+--+-----+-----+-----+--+----------+--+\n|cmsg_|cmsg_|cmsg_|XX|   cmsg_   |XX|cmsg_|cmsg_|cmsg_|XX|  cmsg_   |XX|\n|len  |level|type |XX|   data[]  |XX|len  |level|type |XX|  data[]  |XX|\n+-----+-----+-----+--+-----------+--+-----+-----+-----+--+----------+--+\n^\n|\nmsg_control\npoints here",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The fields shown as \"XX\" are possible padding, between the cmsghdr structure and the data, and between the data and the next cmsghdr structure, if required by the implementation. While sending an application may or may not include padding at the end of last ancillary data in msg_controllen and implementations must accept both as valid. On receiving a portable application must provide space for padding at the end of the last ancillary data as implementations may copy out the padding at the end of the control message buffer and include it in the received msg_controllen. When recvmsg() is called if msg_controllen is too small for all the ancillary data items including any trailing padding after the last item an implementation may set MSG_CTRUNC.",
      "ja": "「xx」として示されているフィールドは、実装で必要な場合は、「xx」と表示されているフィールドは、cmsghdr構造とデータの間、およびデータと次のcmsghdr構造の間で可能なパディングです。アプリケーションの送信中は、MSG_CONTROLLENの最後の補助データの最後にパディングを含める場合と含まない場合があり、実装は両方を有効であると受け入れる必要があります。受信時、ポータブルアプリケーションは、最後の補助データの最後にパディング用のスペースを提供する必要があります。実装により、コントロールメッセージバッファーの最後にパディングをコピーし、受信したMSG_CONTROLLENに含めることができます。MSG_CONTROLLENが、最後の項目の後の後続のパディングを含むすべての補助データ項目に対してMSG_CONTROLLENが小さすぎる場合、recvmsg（）が呼び出される場合、実装はmsg_ctruncを設定する場合があります。"
    },
    {
      "indent": 0,
      "text": "20.3. Ancillary Data Object Macros",
      "section_title": true,
      "ja": "20.3. 補助データオブジェクトマクロ"
    },
    {
      "indent": 3,
      "text": "To aid in the manipulation of ancillary data objects, three macros from 4.4BSD are defined by Posix: CMSG_DATA(), CMSG_NXTHDR(), and CMSG_FIRSTHDR(). Before describing these macros, we show the following example of how they might be used with a call to recvmsg().",
      "ja": "補助データオブジェクトの操作を支援するために、4.4BSDの3つのマクロがPOSIXで定義されています：CMSG_DATA（）、CMSG_NXTHDR（）、およびCMSG_FIRSTHDR（）。これらのマクロを説明する前に、recvmsg（）への呼び出しでそれらをどのように使用するかについての次の例を示します。"
    },
    {
      "indent": 6,
      "text": "struct msghdr msg; struct cmsghdr *cmsgptr;",
      "ja": "struct msghdr msg;struct cmsghdr *cmsgptr;"
    },
    {
      "indent": 6,
      "text": "/* fill in msg */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* call recvmsg() */\n      for (cmsgptr = CMSG_FIRSTHDR(&msg); cmsgptr != NULL;\n     cmsgptr = CMSG_NXTHDR(&msg, cmsgptr)) {\n    if (cmsgptr->cmsg_len == 0) {\n        /* Error handling */\n     break;\n    }\n    if (cmsgptr->cmsg_level == ... &&\n        cmsgptr->cmsg_type == ... ) {\n        u_char  *ptr;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "        ptr = CMSG_DATA(cmsgptr);\n        /* process data pointed to by ptr */\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "We now describe the three Posix macros, followed by two more that are new with this API: CMSG_SPACE() and CMSG_LEN(). All these macros are defined as a result of including <sys/socket.h>.",
      "ja": "次に、3つのPOSIXマクロについて説明し、その後にこのAPIで新しい2つのcmsg_space（）とcmsg_len（）を説明します。これらのすべてのマクロは、<sys/socket.h>を含める結果として定義されます。"
    },
    {
      "indent": 0,
      "text": "20.3.1. CMSG_FIRSTHDR",
      "section_title": true,
      "ja": "20.3.1. CMSG_FIRSTHDR"
    },
    {
      "indent": 6,
      "text": "struct cmsghdr *CMSG_FIRSTHDR(const struct msghdr *mhdr);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CMSG_FIRSTHDR() returns a pointer to the first cmsghdr structure in the msghdr structure pointed to by mhdr. The macro returns NULL if there is no ancillary data pointed to by the msghdr structure (that is, if either msg_control is NULL or if msg_controllen is less than the size of a cmsghdr structure).",
      "ja": "CMSG_FIRSTHDR（）は、MHDRが指すMSGHDR構造の最初のCMSGHDR構造へのポインターを返します。MSGHDR構造によって指摘された補助データがない場合、マクロはnullを返します（つまり、MSG_CONTROLがnullの場合、またはMSG_CONTROLLENがCMSGHDR構造のサイズよりも小さい場合）。"
    },
    {
      "indent": 3,
      "text": "One possible implementation could be",
      "ja": "可能な実装が1つある場合があります"
    },
    {
      "indent": 6,
      "text": "#define CMSG_FIRSTHDR(mhdr) \\\n    ( (mhdr)->msg_controllen >= sizeof(struct cmsghdr) ? \\\n      (struct cmsghdr *)(mhdr)->msg_control : \\\n      (struct cmsghdr *)NULL )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(Note: Most existing implementations do not test the value of msg_controllen, and just return the value of msg_control. The value of msg_controllen must be tested, because if the application asks recvmsg() to return ancillary data, by setting msg_control to point to the application's buffer and setting msg_controllen to the length of this buffer, the kernel indicates that no ancillary data is available by setting msg_controllen to 0 on return. It is also easier to put this test into this macro, than making the application perform the test.)",
      "ja": "（注：ほとんどの既存の実装はMSG_CONTROLLENの値をテストせず、MSG_CONTROLの値を返すだけです。MSG_CONTROLLENの値をテストする必要があります。なぜなら、アプリケーションがMSG_CONTROLを設定することにより、補助データを返すようにアプリケーションがRECVMSG（）を要求する場合、アプリケーションのバッファーとMSG_CONTROLLENをこのバッファーの長さに設定すると、カーネルは、返信時にMSG_CONTROLLENを0に設定することで補助データが利用できないことを示しています。また、このテストをこのマクロに入力する方が、アプリケーションにテストを実行するよりも簡単です。"
    },
    {
      "indent": 0,
      "text": "20.3.2. CMSG_NXTHDR",
      "section_title": true,
      "ja": "20.3.2. CMSG_NXTHDR"
    },
    {
      "indent": 3,
      "text": "As described in Section 5.1, CMSG_NXTHDR has been extended to handle a NULL 2nd argument to mean \"get the first header\". This provides an alternative way of coding the processing loop shown earlier:",
      "ja": "セクション5.1で説明されているように、CMSG_NXTHDRは、「最初のヘッダーを取得」を意味するヌル2番目の引数を処理するために拡張されています。これにより、前述の処理ループをコーディングする別の方法が提供されます。"
    },
    {
      "indent": 6,
      "text": "struct msghdr  msg;\nstruct cmsghdr  *cmsgptr = NULL;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* fill in msg */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* call recvmsg() */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "while ((cmsgptr = CMSG_NXTHDR(&msg, cmsgptr)) != NULL) {\n    if (cmsgptr->cmsg_len == 0) {\n        /* Error handling */\n     break;\n    }\n    if (cmsgptr->cmsg_level == ... &&\n        cmsgptr->cmsg_type == ... ) {\n        u_char  *ptr;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "        ptr = CMSG_DATA(cmsgptr);\n        /* process data pointed to by ptr */\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "One possible implementation could be:",
      "ja": "可能な実装の1つは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "#define CMSG_NXTHDR(mhdr, cmsg) \\\n  (((cmsg) == NULL) ? CMSG_FIRSTHDR(mhdr) : \\\n   (((u_char *)(cmsg) + ALIGN_H((cmsg)->cmsg_len) \\\n                      + ALIGN_D(sizeof(struct cmsghdr)) > \\\n     (u_char *)((mhdr)->msg_control) + (mhdr)->msg_controllen) ? \\\n    (struct cmsghdr *)NULL : \\\n    (struct cmsghdr *)((u_char *)(cmsg) + \\\n                                  ALIGN_H((cmsg)->cmsg_len))))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The macros ALIGN_H() and ALIGN_D(), which are implementation dependent, round their arguments up to the next even multiple of whatever alignment is required for the start of the cmsghdr structure and the data, respectively. (This is probably a multiple of 4 or 8 bytes.) They are often the same macro in implementations platforms where alignment requirement for header and data is chosen to be identical.",
      "ja": "実装依存であるMacroS Align_h（）およびAlign_d（）は、それぞれCMSGHDR構造とデータの開始に必要なアライメントの次の倍数まで、それぞれの倍数に至ります。（これはおそらく4バイトまたは8バイトの倍数です。）これらは、ヘッダーのアラインメント要件とデータが同一に選択される実装プラットフォームで同じマクロであることがよくあります。"
    },
    {
      "indent": 0,
      "text": "20.3.3. CMSG_DATA",
      "section_title": true,
      "ja": "20.3.3. CMSG_DATA"
    },
    {
      "indent": 6,
      "text": "unsigned char *CMSG_DATA(const struct cmsghdr *cmsg);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CMSG_DATA() returns a pointer to the data (what is called the cmsg_data[] member, even though such a member is not defined in the structure) following a cmsghdr structure.",
      "ja": "CMSGHDR構造に従って、CMSG_DATA（）はデータへのポインタを返します（そのようなメンバーは構造で定義されていない場合でも、CMSG_DATA []メンバーと呼ばれるもの）。"
    },
    {
      "indent": 3,
      "text": "One possible implementation could be:",
      "ja": "可能な実装の1つは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "#define CMSG_DATA(cmsg) ( (u_char *)(cmsg) + \\\n                          ALIGN_D(sizeof(struct cmsghdr)) )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.3.4. CMSG_SPACE",
      "section_title": true,
      "ja": "20.3.4. CMSG_SPACE"
    },
    {
      "indent": 3,
      "text": "CMSG_SPACE is new with this API (see Section 5.2). It is used to determine how much space needs to be allocated for an ancillary data item.",
      "ja": "CMSG_SPACEはこのAPIで新しくなっています（セクション5.2を参照）。補助データ項目に割り当てられる必要があるスペースの量を判断するために使用されます。"
    },
    {
      "indent": 3,
      "text": "One possible implementation could be:",
      "ja": "可能な実装の1つは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "#define CMSG_SPACE(length) ( ALIGN_D(sizeof(struct cmsghdr)) + \\\n                             ALIGN_H(length) )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.3.5. CMSG_LEN",
      "section_title": true,
      "ja": "20.3.5. cmsg_len"
    },
    {
      "indent": 3,
      "text": "CMSG_LEN is new with this API (see Section 5.3). It returns the value to store in the cmsg_len member of the cmsghdr structure, taking into account any padding needed to satisfy alignment requirements.",
      "ja": "CMSG_LENはこのAPIで新しくなっています（セクション5.3を参照）。アライメント要件を満たすために必要なパディングを考慮して、CMSGHDR構造のCMSG_LENメンバーに保存する値を返します。"
    },
    {
      "indent": 3,
      "text": "One possible implementation could be:",
      "ja": "可能な実装の1つは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "#define CMSG_LEN(length) ( ALIGN_D(sizeof(struct cmsghdr)) + \\\n                           length )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "21. Appendix B: Examples Using the inet6_rth_XXX() Functions",
      "section_title": true,
      "ja": "21. 付録B：INET6_RTH_XXX（）関数を使用した例"
    },
    {
      "indent": 3,
      "text": "Here we show an example for both sending Routing headers and processing and reversing a received Routing header.",
      "ja": "ここでは、ルーティングヘッダーの送信と受信したルーティングヘッダーの逆転の両方の例を示します。"
    },
    {
      "indent": 0,
      "text": "21.1. Sending a Routing Header",
      "section_title": true,
      "ja": "21.1. ルーティングヘッダーの送信"
    },
    {
      "indent": 3,
      "text": "As an example of these Routing header functions defined in this document, we go through the function calls for the example on p. 17 of [RFC-2460]. The source is S, the destination is D, and the three intermediate nodes are I1, I2, and I3.",
      "ja": "このドキュメントで定義されているこれらのルーティングヘッダー関数の例として、pの例の関数呼び出しを説明します。[RFC-2460]の17。ソースはs、宛先はd、3つの中間ノードはi1、i2、およびi3です。"
    },
    {
      "indent": 14,
      "text": "S -----> I1 -----> I2 -----> I3 -----> D",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "src:    *    S         S         S         S   S\ndst:    D   I1        I2        I3         D   D\nA[1]:  I1   I2        I1        I1        I1  I1\nA[2]:  I2   I3        I3        I2        I2  I2\nA[3]:  I3    D         D         D        I3  I3\n#seg:   3    3         2         1         0   3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "src and dst are the source and destination IPv6 addresses in the IPv6 header. A[1], A[2], and A[3] are the three addresses in the Routing header. #seg is the Segments Left field in the Routing header.",
      "ja": "SRCとDSTは、IPv6ヘッダーのソースおよび宛先IPv6アドレスです。a [1]、a [2]、およびa [3]は、ルーティングヘッダーの3つのアドレスです。#Segは、ルーティングヘッダーのセグメント左フィールドです。"
    },
    {
      "indent": 3,
      "text": "The six values in the column beneath node S are the values in the Routing header specified by the sending application using sendmsg() of setsockopt(). The function calls by the sender would look like:",
      "ja": "Node Sの下の列の6つの値は、SetSockopt（）のsendmsg（）を使用して送信アプリケーションによって指定されたルーティングヘッダーの値です。送信者による関数呼び出しは次のようになります。"
    },
    {
      "indent": 6,
      "text": "void  *extptr;\nsocklen_t   extlen;\nstruct msghdr  msg;\nstruct cmsghdr  *cmsgptr;\nint   cmsglen;\nstruct sockaddr_in6  I1, I2, I3, D;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "extlen = inet6_rth_space(IPV6_RTHDR_TYPE_0, 3);\ncmsglen = CMSG_SPACE(extlen);\ncmsgptr = malloc(cmsglen);\ncmsgptr->cmsg_len = CMSG_LEN(extlen);\ncmsgptr->cmsg_level = IPPROTO_IPV6;\ncmsgptr->cmsg_type = IPV6_RTHDR;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "extptr = CMSG_DATA(cmsgptr);\nextptr = inet6_rth_init(extptr, extlen, IPV6_RTHDR_TYPE_0, 3);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "inet6_rth_add(extptr, &I1.sin6_addr);\ninet6_rth_add(extptr, &I2.sin6_addr);\ninet6_rth_add(extptr, &I3.sin6_addr);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "msg.msg_control = cmsgptr;\nmsg.msg_controllen = cmsglen;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* finish filling in msg{}, msg_name = D */\n/* call sendmsg() */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "We also assume that the source address for the socket is not specified (i.e., the asterisk in the figure).",
      "ja": "また、ソケットのソースアドレスが指定されていないと仮定します（つまり、図のアスタリスク）。"
    },
    {
      "indent": 3,
      "text": "The four columns of six values that are then shown between the five nodes are the values of the fields in the packet while the packet is in transit between the two nodes. Notice that before the packet is sent by the source node S, the source address is chosen (replacing the asterisk), I1 becomes the destination address of the datagram, the two addresses A[2] and A[3] are \"shifted up\", and D is moved to A[3].",
      "ja": "5つのノードの間に表示される6つの値の4つの列は、パケットが2つのノード間で輸送されている間に、パケット内のフィールドの値です。パケットがソースノードSによって送信される前に、ソースアドレスが選択され（アスタリスクの置換）、i1がデータグラムの宛先アドレスになり、2つのアドレスA [2]と[3]が「シフトアップ」されることに注意してください。、DはA [3]に移動します。"
    },
    {
      "indent": 3,
      "text": "The columns of values that are shown beneath the destination node are the values returned by recvmsg(), assuming the application has enabled both the IPV6_RECVPKTINFO and IPV6_RECVRTHDR socket options. The source address is S (contained in the sockaddr_in6 structure pointed to by the msg_name member), the destination address is D (returned as an ancillary data object in an in6_pktinfo structure), and the ancillary data object specifying the Routing header will contain three addresses (I1, I2, and I3). The number of segments in the Routing header is known from the Hdr Ext Len field in the Routing header (a value of 6, indicating 3 addresses).",
      "ja": "宛先ノードの下に表示される値の列は、アプリケーションがIPv6_RecvpktinfoとIPv6_Recvrthdrソケットオプションの両方が有効になっていると仮定して、Recvmsg（）によって返される値です。ソースアドレスはs（MSG_NAMEメンバーが指すsockaddr_in6構造に含まれています）、宛先アドレスはd（in6_pktinfo構造の補助データオブジェクトとして返されます）、ルーティングヘッダーを指定する補助データオブジェクトには3つのアドレスが含まれます。（I1、I2、およびI3）。ルーティングヘッダーのセグメントの数は、ルーティングヘッダーのHDR ext Lenフィールドからわかっています（6の値、3つのアドレスを示しています）。"
    },
    {
      "indent": 3,
      "text": "The return value from inet6_rth_segments() will be 3 and inet6_rth_getaddr(0) will return I1, inet6_rth_getaddr(1) will return I2, and inet6_rth_getaddr(2) will return I3,",
      "ja": "INET6_RTH_SEGMENTS（）からの返品値は3で、INET6_RTH_GETADDR（0）はi1、INET6_RTH_GETADDR（1）はI2を返し、INET6_RTH_GETADDR（2）はi3を返します。"
    },
    {
      "indent": 3,
      "text": "If the receiving application then calls inet6_rth_reverse(), the order of the three addresses will become I3, I2, and I1.",
      "ja": "受信アプリケーションがinet6_rth_reverse（）を呼び出す場合、3つのアドレスの順序はi3、i2、およびi1になります。"
    },
    {
      "indent": 3,
      "text": "We can also show what an implementation might store in the ancillary data object as the Routing header is being built by the sending process. If we assume a 32-bit architecture where sizeof(struct cmsghdr) equals 12, with a desired alignment of 4-byte boundaries, then the call to inet6_rth_space(3) returns 68: 12 bytes for the cmsghdr structure and 56 bytes for the Routing header (8 + 3*16).",
      "ja": "また、送信プロセスによってルーティングヘッダーが構築されているため、補助データオブジェクトに実装が保存されるものを表示することもできます。sizeof（struct cmsghdr）が12に等しい32ビットアーキテクチャが4バイト境界の目的のアライメントであると仮定した場合、inet6_rth_space（3）への呼び出しは、CMSGHDR構造のために68：12バイト、ルーティングの場合は56バイトを返します。ヘッダー（8 3*16）。"
    },
    {
      "indent": 3,
      "text": "The call to inet6_rth_init() initializes the ancillary data object to contain a Type 0 Routing header:",
      "ja": "inet6_rth_init（）への呼び出しは、補助データオブジェクトを初期化して、タイプ0ルーティングヘッダーを含むようにします。"
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_len = 20                                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_level = IPPROTO_IPV6                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_type = IPV6_RTHDR                                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Next Header  | Hdr Ext Len=6 | Routing Type=0|  Seg Left=0   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           Reserved                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The first call to inet6_rth_add() adds I1 to the list.",
      "ja": "inet6_rth_add（）への最初の呼び出しは、i1をリストに追加します。"
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_len = 36                                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_level = IPPROTO_IPV6                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_type = IPV6_RTHDR                                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Next Header  | Hdr Ext Len=6 | Routing Type=0|  Seg Left=1   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           Reserved                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                                                               +\n|                                                               |\n+                           Address[1] = I1                     +\n|                                                               |\n+                                                               +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "cmsg_len is incremented by 16, and the Segments Left field is incremented by 1.",
      "ja": "CMSG_LENは16で増分され、左フィールドのセグメントは1で増加します。"
    },
    {
      "indent": 3,
      "text": "The next call to inet6_rth_add() adds I2 to the list.",
      "ja": "inet6_rth_add（）の次の呼び出しは、i2をリストに追加します。"
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_len = 52                                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_level = IPPROTO_IPV6                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_type = IPV6_RTHDR                                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Next Header  | Hdr Ext Len=6 | Routing Type=0|  Seg Left=2   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           Reserved                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                                                               +\n|                                                               |\n+                           Address[1] = I1                     +\n|                                                               |\n+                                                               +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                                                               +\n|                                                               |\n+                           Address[2] = I2                     +\n|                                                               |\n+                                                               +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "cmsg_len is incremented by 16, and the Segments Left field is incremented by 1.",
      "ja": "CMSG_LENは16で増分され、左フィールドのセグメントは1で増加します。"
    },
    {
      "indent": 3,
      "text": "The last call to inet6_rth_add() adds I3 to the list.",
      "ja": "inet6_rth_add（）への最後の呼び出しは、i3をリストに追加します。"
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_len = 68                                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_level = IPPROTO_IPV6                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_type = IPV6_RTHDR                                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Next Header  | Hdr Ext Len=6 | Routing Type=0|  Seg Left=3   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           Reserved                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                                                               +\n|                                                               |\n+                           Address[1] = I1                     +\n|                                                               |\n+                                                               +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                                                               +\n|                                                               |\n+                           Address[2] = I2                     +\n|                                                               |\n+                                                               +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                                                               +\n|                                                               |\n+                           Address[3] = I3                     +\n|                                                               |\n+                                                               +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "cmsg_len is incremented by 16, and the Segments Left field is incremented by 1.",
      "ja": "CMSG_LENは16で増分され、左フィールドのセグメントは1で増加します。"
    },
    {
      "indent": 0,
      "text": "21.2. Receiving Routing Headers",
      "section_title": true,
      "ja": "21.2. ルーティングヘッダーを受信します"
    },
    {
      "indent": 3,
      "text": "This example assumes that the application has enabled IPV6_RECVRTHDR socket option. The application prints and reverses a source route and uses that to echo the received data.",
      "ja": "この例では、アプリケーションがIPv6_Recvrthdrソケットオプションを有効にしていることを前提としています。アプリケーションはソースルートを印刷および逆にし、それを使用して受信したデータをエコーします。"
    },
    {
      "indent": 6,
      "text": "struct sockaddr_in6     addr;\nstruct msghdr           msg;\nstruct iovec            iov;\nstruct cmsghdr          *cmsgptr;\nsocklen_t               cmsgspace;\nvoid                    *extptr;\nint                     extlen;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "int                     segments;\nint                     i;\nchar                    databuf[8192];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "segments = 100;        /* Enough */\nextlen = inet6_rth_space(IPV6_RTHDR_TYPE_0, segments);\ncmsgspace = CMSG_SPACE(extlen);\ncmsgptr = malloc(cmsgspace);\nif (cmsgptr == NULL) {\n        perror(\"malloc\");\n        exit(1);\n}\nextptr = CMSG_DATA(cmsgptr);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "msg.msg_control = cmsgptr;\nmsg.msg_controllen = cmsgspace;\nmsg.msg_name = (struct sockaddr *)&addr;\nmsg.msg_namelen = sizeof (addr);\nmsg.msg_iov = &iov;\nmsg.msg_iovlen = 1;\niov.iov_base = databuf;\niov.iov_len = sizeof (databuf);\nmsg.msg_flags = 0;\nif (recvmsg(s, &msg, 0) == -1) {\n        perror(\"recvmsg\");\n        return;\n}\nif (msg.msg_controllen != 0 &&\n    cmsgptr->cmsg_level == IPPROTO_IPV6 &&\n    cmsgptr->cmsg_type == IPV6_RTHDR) {\n        struct in6_addr *in6;\n        char asciiname[INET6_ADDRSTRLEN];\n        struct ip6_rthdr *rthdr;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "rthdr = (struct ip6_rthdr *)extptr;\nsegments = inet6_rth_segments(extptr);\nprintf(\"route (%d segments, %d left): \",\n    segments, rthdr->ip6r_segleft);\nfor (i = 0; i < segments; i++) {\n        in6 = inet6_rth_getaddr(extptr, i);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "                if (in6 == NULL)\n                        printf(\"<NULL> \");\n                else\n                        printf(\"%s \", inet_ntop(AF_INET6,\n                            (void *)in6->s6_addr,\n                            asciiname, INET6_ADDRSTRLEN));\n        }\n        if (inet6_rth_reverse(extptr, extptr) == -1) {\n                printf(\"reverse failed\");\n                return;\n        }\n}\niov.iov_base = databuf;\niov.iov_len = strlen(databuf);\nif (sendmsg(s, &msg, 0) == -1)\n        perror(\"sendmsg\");\nif (cmsgptr != NULL)\n        free(cmsgptr);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note: The above example is a simple illustration. It skips some error checks, including those involving the MSG_TRUNC and MSG_CTRUNC flags. It also leaves some type mismatches in favor of brevity.",
      "ja": "注：上記の例は簡単なイラストです。MSG_TRUNCおよびMSG_CTRUNCフラグを含むエラーチェックをスキップします。また、いくつかのタイプの不一致を簡潔にしています。"
    },
    {
      "indent": 0,
      "text": "22. Appendix C: Examples Using the inet6_opt_XXX() Functions",
      "section_title": true,
      "ja": "22. 付録C：INET6_OPT_XXX（）関数を使用した例"
    },
    {
      "indent": 3,
      "text": "This shows how Hop-by-Hop and Destination options can be both built as well as parsed using the inet6_opt_XXX() functions. These examples assume that there are defined values for OPT_X and OPT_Y.",
      "ja": "これは、INET6_OPT_XXX（）関数を使用して、ホップバイホップと目的地のオプションをどのように構築し、解析できるかを示しています。これらの例は、opt_xとopt_yに定義された値があることを前提としています。"
    },
    {
      "indent": 3,
      "text": "Note: The example is a simple illustration. It skips some error checks and leaves some type mismatches in favor of brevity.",
      "ja": "注：例は簡単なイラストです。いくつかのエラーチェックをスキップし、いくつかのタイプの不一致を簡潔にします。"
    },
    {
      "indent": 0,
      "text": "22.1. Building Options",
      "section_title": true,
      "ja": "22.1. 構築オプション"
    },
    {
      "indent": 3,
      "text": "We now provide an example that builds two Hop-by-Hop options using the example in Appendix B of [RFC-2460].",
      "ja": "[RFC-2460]の付録Bの例を使用して、2つのホップバイホップオプションを構築する例を提供します。"
    },
    {
      "indent": 6,
      "text": "void *extbuf;\nsocklen_t extlen;\nint currentlen;\nvoid *databuf;\nint offset;\nuint8_t value1;\nuint16_t value2;\nuint32_t value4;\nuint64_t value8;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Estimate the length */\n      currentlen = inet6_opt_init(NULL, 0);\nif (currentlen == -1)\n        return (-1);\ncurrentlen = inet6_opt_append(NULL, 0, currentlen, OPT_X,\n                              12, 8, NULL);\nif (currentlen == -1)\n        return (-1);\ncurrentlen = inet6_opt_append(NULL, 0, currentlen, OPT_Y,\n                              7, 4, NULL);\nif (currentlen == -1)\n        return (-1);\ncurrentlen = inet6_opt_finish(NULL, 0, currentlen);\nif (currentlen == -1)\n        return (-1);\nextlen = currentlen;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "extbuf = malloc(extlen);\nif (extbuf == NULL) {\n        perror(\"malloc\");\n        return (-1);\n}\ncurrentlen = inet6_opt_init(extbuf, extlen);\nif (currentlen == -1)\n        return (-1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "currentlen = inet6_opt_append(extbuf, extlen, currentlen,\n    OPT_X, 12, 8, &databuf);\nif (currentlen == -1)\n        return (-1);\n/* Insert value 0x12345678 for 4-octet field */\noffset = 0;\nvalue4 = 0x12345678;\noffset = inet6_opt_set_val(databuf, offset,\n                           &value4, sizeof (value4));\n/* Insert value 0x0102030405060708 for 8-octet field */\nvalue8 = 0x0102030405060708;\noffset = inet6_opt_set_val(databuf, offset,\n                           &value8, sizeof (value8));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "currentlen = inet6_opt_append(extbuf, extlen, currentlen,\n    OPT_Y, 7, 4, &databuf);\nif (currentlen == -1)\n        return (-1);\n/* Insert value 0x01 for 1-octet field */\noffset = 0;\nvalue1 = 0x01;\noffset = inet6_opt_set_val(databuf, offset,\n                           &value1, sizeof (value1));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Insert value 0x1331 for 2-octet field */\nvalue2 = 0x1331;\noffset = inet6_opt_set_val(databuf, offset,\n                           &value2, sizeof (value2));\n/* Insert value 0x01020304 for 4-octet field */\nvalue4 = 0x01020304;\noffset = inet6_opt_set_val(databuf, offset,\n                           &value4, sizeof (value4));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "currentlen = inet6_opt_finish(extbuf, extlen, currentlen);\nif (currentlen == -1)\n        return (-1);\n/* extbuf and extlen are now completely formatted */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "22.2. Parsing Received Options",
      "section_title": true,
      "ja": "22.2. 受信したオプションを解析します"
    },
    {
      "indent": 3,
      "text": "This example parses and prints the content of the two options in the previous example.",
      "ja": "この例は、前の例で2つのオプションのコンテンツを解析および印刷します。"
    },
    {
      "indent": 6,
      "text": "int\nprint_opt(void *extbuf, socklen_t extlen)\n{\n        struct ip6_dest *ext;\n        int currentlen;\n        uint8_t type;\n        socklen_t len;\n        void *databuf;\n        int offset;\n        uint8_t value1;\n        uint16_t value2;\n        uint32_t value4;\n        uint64_t value8;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "ext = (struct ip6_dest *)extbuf;\nprintf(\"nxt %u, len %u (bytes %d)\\n\", ext->ip6d_nxt,\n    ext->ip6d_len, (ext->ip6d_len + 1) * 8);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "currentlen = 0;\nwhile (1) {\n        currentlen = inet6_opt_next(extbuf, extlen,\n                                    currentlen, &type,\n                                    &len, &databuf);\n        if (currentlen == -1)\n                break;\n        printf(\"Received opt %u len %u\\n\",\n            type, len);\n        switch (type) {\n        case OPT_X:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "                        offset = 0;\n                        offset =\n                            inet6_opt_get_val(databuf, offset,\n                                              &value4,\n                                              sizeof (value4));\n                        printf(\"X 4-byte field %x\\n\", value4);\n                        offset =\n                            inet6_opt_get_val(databuf, offset,\n                                              &value8,\n                                              sizeof (value8));\n                        printf(\"X 8-byte field %llx\\n\", value8);\n                        break;\n                case OPT_Y:\n                        offset = 0;\n                        offset =\n                            inet6_opt_get_val(databuf, offset,\n                                              &value1,\n                                              sizeof (value1));\n                        printf(\"Y 1-byte field %x\\n\", value1);\n                        offset =\n                            inet6_opt_get_val(databuf, offset,\n                                              &value2,\n                                              sizeof (value2));\n                        printf(\"Y 2-byte field %x\\n\", value2);\n                        offset =\n                            inet6_opt_get_val(databuf, offset,\n                                              &value4,\n                                              sizeof (value4));\n                        printf(\"Y 4-byte field %x\\n\", value4);\n                        break;\n                default:\n                        printf(\"Unknown option %u\\n\", type);\n                        break;\n                }\n        }\n        return (0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "23. Authors' Addresses",
      "section_title": true,
      "ja": "23. 著者のアドレス"
    },
    {
      "indent": 3,
      "text": "W. Richard Stevens (deceased)",
      "ja": "W.リチャードスティーブンス（故人）"
    },
    {
      "indent": 3,
      "text": "Matt Thomas 3am Software Foundry 8053 Park Villa Circle Cupertino, CA 95014",
      "ja": "Matt Thomas 3am Software Foundry 8053 Park Villa Circle Cupertino、CA 95014"
    },
    {
      "indent": 3,
      "text": "EMail: matt@3am-software.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Erik Nordmark Sun Microsystems Laboratories, Europe 180, avenue de l'Europe 38334 SAINT ISMIER Cedex, France",
      "ja": "Erik Nordmark Sun Microsystems Laboratories、Europe 180、Avenue de L'Europe 38334 Saint Ismier Cedex、フランス"
    },
    {
      "indent": 3,
      "text": "Phone: +33 (0)4 74 18 88 03\nFax:   +33 (0)4 76 18 88 88\nEMail: Erik.Nordmark@sun.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Tatuya JINMEI Corporate Research & Development Center, Toshiba Corporation 1 Komukai Toshiba-cho, Kawasaki-shi Kanagawa 212-8582, Japan",
      "ja": "Tatuya Jinmei Corporate Research＆Development Center、Toshiba Corporation 1 Komukai Toshiba-Cho、川崎-Shi Kanagawa 212-8582、日本"
    },
    {
      "indent": 3,
      "text": "EMail: jinmei@isl.rdc.toshiba.co.jp",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "24. Full Copyright Statement",
      "section_title": true,
      "ja": "24. 完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2003）。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書と本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}