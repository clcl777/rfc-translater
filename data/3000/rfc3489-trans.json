{
  "title": {
    "text": "RFC 3489 - STUN - Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs)",
    "ja": "RFC 3489 - スタン - ネットワークアドレス翻訳者（NAT）を介したユーザーデータグラムプロトコル（UDP）の単純なトラバーサル"
  },
  "number": 3489,
  "created_at": "2023-11-01 05:17:59.153855+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                       J. Rosenberg\nRequest for Comments: 3489                                 J. Weinberger\nCategory: Standards Track                                    dynamicsoft\n                                                              C. Huitema\n                                                               Microsoft\n                                                                 R. Mahy\n                                                                   Cisco\n                                                              March 2003",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "STUN - Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs)",
      "ja": "スタン - ネットワークアドレス翻訳者（NAT）を介したユーザーデータグラムプロトコル（UDP）の単純なトラバーサル"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2003）。無断転載を禁じます。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs) (STUN) is a lightweight protocol that allows applications to discover the presence and types of NATs and firewalls between them and the public Internet. It also provides the ability for applications to determine the public Internet Protocol (IP) addresses allocated to them by the NAT. STUN works with many existing NATs, and does not require any special behavior from them. As a result, it allows a wide variety of applications to work through existing NAT infrastructure.",
      "ja": "ネットワークアドレス翻訳者（NAT）（STUN）を介したユーザーデータグラムプロトコル（UDP）の単純なトラバーサルは、アプリケーションがそれらとパブリックインターネット間の存在とタイプのNATとファイアウォールを発見できる軽量プロトコルです。また、アプリケーションがNATによって割り当てられたパブリックインターネットプロトコル（IP）アドレスを決定する機能を提供します。Stunは多くの既存のNATと連携しており、それらからの特別な行動は必要ありません。その結果、さまざまなアプリケーションが既存のNATインフラストラクチャを介して動作することができます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.   Applicability Statement ...................................    3\n2.   Introduction ..............................................    3\n3.   Terminology ...............................................    4\n4.   Definitions ...............................................    5\n5.   NAT Variations ............................................    5\n6.   Overview of Operation .....................................    6\n7.   Message Overview ..........................................    8\n8.   Server Behavior ...........................................   10\n     8.1   Binding Requests ....................................   10\n        8.2   Shared Secret Requests ..............................   13\n9.   Client Behavior ...........................................   14\n     9.1   Discovery ...........................................   15\n     9.2   Obtaining a Shared Secret ...........................   15\n     9.3   Formulating the Binding Request .....................   17\n     9.4   Processing Binding Responses ........................   17\n10.  Use Cases .................................................   19\n     10.1  Discovery Process ...................................   19\n     10.2  Binding Lifetime Discovery ..........................   21\n     10.3  Binding Acquisition .................................   23\n11.  Protocol Details ..........................................   24\n     11.1  Message Header ......................................   25\n     11.2  Message Attributes ..................................   26\n           11.2.1  MAPPED-ADDRESS ..............................   27\n           11.2.2  RESPONSE-ADDRESS ............................   27\n           11.2.3  CHANGED-ADDRESS .............................   28\n           11.2.4  CHANGE-REQUEST ..............................   28\n           11.2.5  SOURCE-ADDRESS ..............................   28\n           11.2.6  USERNAME ....................................   28\n           11.2.7  PASSWORD ....................................   29\n           11.2.8  MESSAGE-INTEGRITY ...........................   29\n           11.2.9  ERROR-CODE ..................................   29\n           11.2.10 UNKNOWN-ATTRIBUTES ..........................   31\n           11.2.11 REFLECTED-FROM ..............................   31\n12.  Security Considerations ...................................   31\n     12.1  Attacks on STUN .....................................   31\n           12.1.1  Attack I: DDOS Against a Target .............   32\n           12.1.2  Attack II: Silencing a Client ...............   32\n           12.1.3  Attack III: Assuming the Identity of a Client   32\n           12.1.4  Attack IV: Eavesdropping ....................   33\n     12.2  Launching the Attacks ...............................   33\n           12.2.1  Approach I: Compromise a Legitimate\n                   STUN Server .................................   33\n           12.2.2  Approach II: DNS Attacks ....................   34\n           12.2.3  Approach III: Rogue Router or NAT ...........   34\n           12.2.4  Approach IV: MITM ...........................   35\n           12.2.5  Approach V: Response Injection Plus DoS .....   35\n           12.2.6  Approach VI: Duplication ....................   35\n     12.3  Countermeasures .....................................   36\n     12.4  Residual Threats ....................................   37\n13.  IANA Considerations .......................................   38\n14.  IAB Considerations ........................................   38\n     14.1  Problem Definition ..................................   38\n     14.2  Exit Strategy .......................................   39\n     14.3  Brittleness Introduced by STUN ......................   40\n     14.4  Requirements for a Long Term Solution ...............   42\n     14.5  Issues with Existing NAPT Boxes .....................   43\n     14.6  In Closing ..........................................   43",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "15.  Acknowledgments ...........................................   44\n16.  Normative References ......................................   44\n17.  Informative References ....................................   44\n18.  Authors' Addresses ........................................   46\n19.  Full Copyright Statement...................................   47",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Applicability Statement",
      "section_title": true,
      "ja": "1. アプリケーションステートメント"
    },
    {
      "indent": 3,
      "text": "This protocol is not a cure-all for the problems associated with NAT. It does not enable incoming TCP connections through NAT. It allows incoming UDP packets through NAT, but only through a subset of existing NAT types. In particular, STUN does not enable incoming UDP packets through symmetric NATs (defined below), which are common in large enterprises. STUN's discovery procedures are based on assumptions on NAT treatment of UDP; such assumptions may prove invalid down the road as new NAT devices are deployed. STUN does not work when it is used to obtain an address to communicate with a peer which happens to be behind the same NAT. STUN does not work when the STUN server is not in a common shared address realm. For a more complete discussion of the limitations of STUN, see Section 14.",
      "ja": "このプロトコルは、NATに関連する問題の治療法ではありません。NATを介したTCP接続を受信することはできません。NATを介してUDPパケットを着信することができますが、既存のNATタイプのサブセットを介してのみ使用できます。特に、STUNは、大企業で一般的な対称NAT（以下に定義）を介して、受信UDPパケットを有効にしません。Stunの発見手順は、UDPのNAT処理に関する仮定に基づいています。このような仮定は、新しいNATデバイスが展開されるため、将来的に無効であることが証明される場合があります。Stunは、たまたま同じNATの後ろにあるピアと通信するためのアドレスを取得するために使用される場合は機能しません。Stunサーバーが一般的な共有アドレスの領域にない場合、Stunは機能しません。スタンの制限についてのより完全な議論については、セクション14を参照してください。"
    },
    {
      "indent": 0,
      "text": "2. Introduction",
      "section_title": true,
      "ja": "2. はじめに"
    },
    {
      "indent": 3,
      "text": "Network Address Translators (NATs), while providing many benefits, also come with many drawbacks. The most troublesome of those drawbacks is the fact that they break many existing IP applications, and make it difficult to deploy new ones. Guidelines have been developed [8] that describe how to build \"NAT friendly\" protocols, but many protocols simply cannot be constructed according to those guidelines. Examples of such protocols include almost all peer-to-peer protocols, such as multimedia communications, file sharing and games.",
      "ja": "ネットワークアドレス翻訳者（NAT）は、多くの利点を提供しますが、多くの欠点もあります。これらの欠点の中で最も厄介なのは、既存の多くのIPアプリケーションを破壊し、新しいアプリケーションを展開することを困難にするという事実です。「NATフレンドリー」プロトコルを構築する方法を説明するガイドラインが開発されました[8]が、多くのプロトコルは、これらのガイドラインに従って単に構築することはできません。このようなプロトコルの例には、マルチメディア通信、ファイル共有、ゲームなど、ほぼすべてのピアツーピアプロトコルが含まれます。"
    },
    {
      "indent": 3,
      "text": "To combat this problem, Application Layer Gateways (ALGs) have been embedded in NATs. ALGs perform the application layer functions required for a particular protocol to traverse a NAT. Typically, this involves rewriting application layer messages to contain translated addresses, rather than the ones inserted by the sender of the message. ALGs have serious limitations, including scalability, reliability, and speed of deploying new applications. To resolve these problems, the Middlebox Communications (MIDCOM) protocol is being developed [9]. MIDCOM allows an application entity, such as an end client or network server of some sort (like a Session Initiation Protocol (SIP) proxy [10]) to control a NAT (or firewall), in order to obtain NAT bindings and open or close pinholes. In this way, NATs and applications can be separated once more, eliminating the need for embedding ALGs in NATs, and resolving the limitations imposed by current architectures.",
      "ja": "この問題に対処するために、アプリケーションレイヤーゲートウェイ（ALG）がNATに埋め込まれています。ALGは、特定のプロトコルがNATをトラバースするために必要なアプリケーション層関数を実行します。通常、これには、メッセージの送信者によって挿入されたアドレスではなく、翻訳されたアドレスを含むアプリケーションレイヤーメッセージを書き換えることが含まれます。ALGには、新しいアプリケーションの展開のスケーラビリティ、信頼性、速度など、深刻な制限があります。これらの問題を解決するために、Middlebox Communications（MIDCOM）プロトコルが開発されています[9]。MIDCOMでは、何らかの種類のエンドクライアントやネットワークサーバー（セッション開始プロトコル（SIP）プロキシ[10]など）などのアプリケーションエンティティがNAT（またはファイアウォール）を制御し、NATバインディングを取得して開閉または閉じることができます。ピンホール。このようにして、NATとアプリケーションをもう一度分離し、NATにALGを埋め込む必要性を排除し、現在のアーキテクチャによって課される制限を解決できます。"
    },
    {
      "indent": 3,
      "text": "Unfortunately, MIDCOM requires upgrades to existing NAT and firewalls, in addition to application components. Complete upgrades of these NAT and firewall products will take a long time, potentially years. This is due, in part, to the fact that the deployers of NAT and firewalls are not the same people who are deploying and using applications. As a result, the incentive to upgrade these devices will be low in many cases. Consider, for example, an airport Internet lounge that provides access with a NAT. A user connecting to the NATed network may wish to use a peer-to-peer service, but cannot, because the NAT doesn't support it. Since the administrators of the lounge are not the ones providing the service, they are not motivated to upgrade their NAT equipment to support it, using either an ALG, or MIDCOM.",
      "ja": "残念ながら、MIDCOMでは、アプリケーションコンポーネントに加えて、既存のNATおよびファイアウォールのアップグレードが必要です。これらのNATおよびファイアウォール製品の完全なアップグレードには、長い時間がかかります。これは、NATとファイアウォールの展開者がアプリケーションを展開して使用している人と同じではないという事実に一部起因しています。その結果、これらのデバイスをアップグレードするインセンティブは多くの場合、低くなります。たとえば、NATにアクセスを提供する空港インターネットラウンジを検討してください。Natedネットワークに接続するユーザーは、ピアツーピアサービスを使用したい場合がありますが、NATがサポートしていないため、できません。ラウンジの管理者はサービスを提供しているものではないため、ALGまたはMIDCOMのいずれかを使用して、NAT機器をサポートするためにアップグレードする動機はありません。"
    },
    {
      "indent": 3,
      "text": "Another problem is that the MIDCOM protocol requires that the agent controlling the middleboxes know the identity of those middleboxes, and have a relationship with them which permits control. In many configurations, this will not be possible. For example, many cable access providers use NAT in front of their entire access network. This NAT could be in addition to a residential NAT purchased and operated by the end user. The end user will probably not have a control relationship with the NAT in the cable access network, and may not even know of its existence.",
      "ja": "別の問題は、MIDCOMプロトコルでは、ミドルボックスを制御するエージェントがそれらのミドルボックスのアイデンティティを知っており、制御を許可するそれらとの関係を持つことを要求することです。多くの構成では、これは不可能です。たとえば、多くのケーブルアクセスプロバイダーは、アクセスネットワーク全体の前でNATを使用しています。このNATは、エンドユーザーが購入および運用した住宅NATに追加できます。エンドユーザーは、おそらくケーブルアクセスネットワーク内のNATとの制御関係を持たず、その存在さえ知らないかもしれません。"
    },
    {
      "indent": 3,
      "text": "Many existing proprietary protocols, such as those for online games (such as the games described in RFC 3027 [11]) and Voice over IP, have developed tricks that allow them to operate through NATs without changing those NATs. This document is an attempt to take some of those ideas, and codify them into an interoperable protocol that can meet the needs of many applications.",
      "ja": "オンラインゲーム（RFC 3027 [11]で説明されているゲームなど）やIPオーバーボイスなどの多くの既存の独自のプロトコルは、それらのNATを変更せずにNATを介して動作できるトリックを開発しました。このドキュメントは、これらのアイデアのいくつかを採用し、それらを多くのアプリケーションのニーズを満たすことができる相互運用可能なプロトコルに体系化する試みです。"
    },
    {
      "indent": 3,
      "text": "The protocol described here, Simple Traversal of UDP Through NAT (STUN), allows entities behind a NAT to first discover the presence of a NAT and the type of NAT, and then to learn the addresses bindings allocated by the NAT. STUN requires no changes to NATs, and works with an arbitrary number of NATs in tandem between the application entity and the public Internet.",
      "ja": "ここで説明するプロトコル、NAT（STUN）を介したUDPの単純なトラバーサルにより、NATの背後にあるエンティティが最初にNATの存在とNATの種類を発見し、次にNATによって割り当てられたアドレスバインディングを学習できます。StunはNATに変更を必要とせず、アプリケーションエンティティとパブリックインターネットの間で任意の数のNATと連携して動作します。"
    },
    {
      "indent": 0,
      "text": "3. Terminology",
      "section_title": true,
      "ja": "3. 用語"
    },
    {
      "indent": 3,
      "text": "In this document, the key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" are to be interpreted as described in BCP 14, RFC 2119 [1] and indicate requirement levels for compliant STUN implementations.",
      "ja": "このドキュメントでは、キーワードが「必須」、「必須」、「必須」、「shall」、「shall \"、\" low \"of\" bould \"、\" becommented \"、\"、 \"、\"、 \"optional\"BCP 14、RFC 2119 [1]で説明されているように解釈され、準拠したSTUN実装の要件レベルを示します。"
    },
    {
      "indent": 0,
      "text": "4. Definitions",
      "section_title": true,
      "ja": "4. 定義"
    },
    {
      "indent": 3,
      "text": "STUN Client: A STUN client (also just referred to as a client) is an entity that generates STUN requests. A STUN client can execute on an end system, such as a user's PC, or can run in a network element, such as a conferencing server.",
      "ja": "スタンクライアント：スタンクライアント（クライアントとも呼ばれます）は、スタンリクエストを生成するエンティティです。スタンクライアントは、ユーザーのPCなどのエンドシステムで実行することも、会議サーバーなどのネットワーク要素で実行できます。"
    },
    {
      "indent": 3,
      "text": "STUN Server: A STUN Server (also just referred to as a server) is an entity that receives STUN requests, and sends STUN responses. STUN servers are generally attached to the public Internet.",
      "ja": "Stun Server：Stunサーバー（サーバーとも呼ばれます）は、Stunリクエストを受信し、スタン応答を送信するエンティティです。スタンサーバーは通常、パブリックインターネットに接続されています。"
    },
    {
      "indent": 0,
      "text": "5. NAT Variations",
      "section_title": true,
      "ja": "5. NATバリエーション"
    },
    {
      "indent": 3,
      "text": "It is assumed that the reader is familiar with NATs. It has been observed that NAT treatment of UDP varies among implementations. The four treatments observed in implementations are:",
      "ja": "読者はNATに精通していると想定されています。UDPのNAT処理は実装によって異なることが観察されています。実装で観察される4つの治療法は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Full Cone: A full cone NAT is one where all requests from the same internal IP address and port are mapped to the same external IP address and port. Furthermore, any external host can send a packet to the internal host, by sending a packet to the mapped external address.",
      "ja": "フルコーン：フルコーンNATは、同じ内部IPアドレスとポートからのすべてのリクエストが同じ外部IPアドレスとポートにマッピングされるものです。さらに、外部ホストは、マッピングされた外部アドレスにパケットを送信することにより、内部ホストにパケットを送信できます。"
    },
    {
      "indent": 3,
      "text": "Restricted Cone: A restricted cone NAT is one where all requests from the same internal IP address and port are mapped to the same external IP address and port. Unlike a full cone NAT, an external host (with IP address X) can send a packet to the internal host only if the internal host had previously sent a packet to IP address X.",
      "ja": "制限付きコーン：制限付きコーンNATは、同じ内部IPアドレスとポートからのすべての要求が同じ外部IPアドレスとポートにマッピングされるものです。完全なコーンNATとは異なり、外部ホスト（IPアドレスxを備えた）は、内部ホストが以前にIPアドレスXにパケットを送信した場合にのみ、内部ホストにパケットを送信できます。"
    },
    {
      "indent": 3,
      "text": "Port Restricted Cone: A port restricted cone NAT is like a restricted cone NAT, but the restriction includes port numbers. Specifically, an external host can send a packet, with source IP address X and source port P, to the internal host only if the internal host had previously sent a packet to IP address X and port P.",
      "ja": "ポート制限コーン：ポート制限付きコーンナットは制限付きコーンナットのようなものですが、制限にはポート番号が含まれます。具体的には、外部ホストは、内部ホストが以前にパケットをIPアドレスXおよびポートPに送信した場合にのみ、ソースIPアドレスXとソースポートPを備えたパケットを内部ホストに送信できます。"
    },
    {
      "indent": 3,
      "text": "Symmetric: A symmetric NAT is one where all requests from the same internal IP address and port, to a specific destination IP address and port, are mapped to the same external IP address and port. If the same host sends a packet with the same source address and port, but to a different destination, a different mapping is used. Furthermore, only the external host that receives a packet can send a UDP packet back to the internal host.",
      "ja": "対称：対称NATは、同じ内部IPアドレスとポート（特定の宛先IPアドレスとポートへのすべての要求が同じ外部IPアドレスとポートにマッピングされる）です。同じホストが同じソースアドレスとポートを持つパケットを送信するが、別の宛先に送信された場合、別のマッピングが使用されます。さらに、パケットを受け取った外部ホストのみが、UDPパケットを内部ホストに送り返すことができます。"
    },
    {
      "indent": 3,
      "text": "Determining the type of NAT is important in many cases. Depending on what the application wants to do, it may need to take the particular behavior into account.",
      "ja": "NATのタイプを決定することは、多くの場合重要です。アプリケーションが何をしたいかに応じて、特定の動作を考慮する必要がある場合があります。"
    },
    {
      "indent": 0,
      "text": "6. Overview of Operation",
      "section_title": true,
      "ja": "6. 操作の概要"
    },
    {
      "indent": 3,
      "text": "This section is descriptive only. Normative behavior is described in Sections 8 and 9.",
      "ja": "このセクションは説明のみです。規範的な動作は、セクション8および9で説明されています。"
    },
    {
      "indent": 25,
      "text": "   /-----\\\n // STUN  \\\\\n|   Server  |\n \\\\       //\n   \\-----/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "                +--------------+             Public Internet\n................|     NAT 2    |.......................\n                +--------------+",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "                +--------------+             Private NET 2\n................|     NAT 1    |.......................\n                +--------------+",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "   /-----\\\n // STUN  \\\\\n|   Client  |\n \\\\       //               Private NET 1\n   \\-----/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 1: STUN Configuration",
      "ja": "図1：スタン構成"
    },
    {
      "indent": 3,
      "text": "The typical STUN configuration is shown in Figure 1. A STUN client is connected to private network 1. This network connects to private network 2 through NAT 1. Private network 2 connects to the public Internet through NAT 2. The STUN server resides on the public Internet.",
      "ja": "典型的なスタン構成を図1に示します。スタンクライアントはプライベートネットワーク1に接続されています。このネットワークは、プライベートネットワーク2に接続します。インターネット。"
    },
    {
      "indent": 3,
      "text": "STUN is a simple client-server protocol. A client sends a request to a server, and the server returns a response. There are two types of requests - Binding Requests, sent over UDP, and Shared Secret Requests, sent over TLS [2] over TCP. Shared Secret Requests ask the server to return a temporary username and password. This username and password are used in a subsequent Binding Request and Binding Response, for the purposes of authentication and message integrity.",
      "ja": "Stunはシンプルなクライアントサーバープロトコルです。クライアントはサーバーにリクエストを送信し、サーバーは応答を返します。リクエストには、UDPを介して送信された拘束力のあるリクエストと共有秘密のリクエストの2つのタイプがあります。TCPを介してTLS [2]を介して送信されます。共有秘密のリクエストは、サーバーに一時的なユーザー名とパスワードを返すように依頼します。このユーザー名とパスワードは、認証とメッセージの整合性を目的として、後続の拘束力のある要求と拘束力のある応答で使用されます。"
    },
    {
      "indent": 3,
      "text": "Binding requests are used to determine the bindings allocated by NATs. The client sends a Binding Request to the server, over UDP. The server examines the source IP address and port of the request, and copies them into a response that is sent back to the client. There are some parameters in the request that allow the client to ask that the response be sent elsewhere, or that the server send the response from a different address and port. There are attributes for providing message integrity and authentication.",
      "ja": "バインディングリクエストは、NATによって割り当てられたバインディングを決定するために使用されます。クライアントは、UDPを介して、サーバーにバインディングリクエストを送信します。サーバーは、リクエストのソースIPアドレスとポートを調べ、クライアントに送信される応答にコピーします。リクエストには、クライアントが応答を他の場所に送信するように要求できるようにするパラメーターがいくつかあります。メッセージの整合性と認証を提供するための属性があります。"
    },
    {
      "indent": 3,
      "text": "The trick is using STUN to discover the presence of NAT, and to learn and use the bindings they allocate.",
      "ja": "トリックは、Stunを使用してNATの存在を発見し、彼らが割り当てるバインディングを学び、使用することです。"
    },
    {
      "indent": 3,
      "text": "The STUN client is typically embedded in an application which needs to obtain a public IP address and port that can be used to receive data. For example, it might need to obtain an IP address and port to receive Real Time Transport Protocol (RTP) [12] traffic. When the application starts, the STUN client within the application sends a STUN Shared Secret Request to its server, obtains a username and password, and then sends it a Binding Request. STUN servers can be discovered through DNS SRV records [3], and it is generally assumed that the client is configured with the domain to use to find the STUN server. Generally, this will be the domain of the provider of the service the application is using (such a provider is incented to deploy STUN servers in order to allow its customers to use its application through NAT). Of course, a client can determine the address or domain name of a STUN server through other means. A STUN server can even be embedded within an end system.",
      "ja": "STUNクライアントは通常、データの受信に使用できるパブリックIPアドレスとポートを取得する必要があるアプリケーションに組み込まれています。たとえば、リアルタイム輸送プロトコル（RTP）[12]トラフィックを受信するには、IPアドレスとポートを取得する必要がある場合があります。アプリケーションが開始されると、アプリケーション内のスタンクライアントは、STUN共有のシークレットリクエストをサーバーに送信し、ユーザー名とパスワードを取得し、拘束力のあるリクエストを送信します。STUNサーバーはDNS SRVレコード[3]を介して発見することができ、一般に、クライアントがドメインで構成されていると想定されています。一般に、これはアプリケーションが使用しているサービスのプロバイダーのドメインになります（このようなプロバイダーは、顧客がNATを介してアプリケーションを使用できるようにするためにSTUNサーバーを展開するインセンティブです）。もちろん、クライアントは他の手段を介してスタンサーバーのアドレスまたはドメイン名を決定できます。スタンサーバーは、エンドシステム内に埋め込むこともできます。"
    },
    {
      "indent": 3,
      "text": "The STUN Binding Request is used to discover the presence of a NAT, and to discover the public IP address and port mappings generated by the NAT. Binding Requests are sent to the STUN server using UDP. When a Binding Request arrives at the STUN server, it may have passed through one or more NATs between the STUN client and the STUN server. As a result, the source address of the request received by the server will be the mapped address created by the NAT closest to the server. The STUN server copies that source IP address and port into a STUN Binding Response, and sends it back to the source IP address and port of the STUN request. For all of the NAT types above, this response will arrive at the STUN client.",
      "ja": "スタンバインディングリクエストは、NATの存在を発見し、NATによって生成されたパブリックIPアドレスとポートマッピングを発見するために使用されます。バインディングリクエストは、UDPを使用してStunサーバーに送信されます。バインディングリクエストがStunサーバーに到着すると、StunクライアントとStunサーバーの間の1つ以上のNATを通過した可能性があります。その結果、サーバーが受信した要求のソースアドレスは、サーバーに最も近いNATによって作成されたマッピングアドレスになります。Stunサーバーは、そのソースIPアドレスとポートをスタンバインディング応答にコピーし、STUNリクエストのソースIPアドレスとポートに送り返します。上記のすべてのNATタイプについて、この応答はスタンクライアントに到達します。"
    },
    {
      "indent": 3,
      "text": "When the STUN client receives the STUN Binding Response, it compares the IP address and port in the packet with the local IP address and port it bound to when the request was sent. If these do not match, the STUN client is behind one or more NATs. In the case of a full-cone NAT, the IP address and port in the body of the STUN response are public, and can be used by any host on the public Internet to send packets to the application that sent the STUN request. An application need only listen on the IP address and port from which the STUN request was sent. Any packets sent by a host on the public Internet to the public address and port learned by STUN will be received by the application.",
      "ja": "スタンクライアントがスタンバインディング応答を受信すると、パケット内のIPアドレスとポートをローカルIPアドレスと比較し、リクエストが送信されたときにバインドされたポートを比較します。これらが一致しない場合、スタンクライアントは1つ以上のNATの背後にいます。フルコーンNATの場合、スタン応答の本文のIPアドレスとポートは公開されており、パブリックインターネット上のどのホストでも、スタンリクエストを送信したアプリケーションにパケットを送信することができます。アプリケーションは、スタンリクエストが送信されたIPアドレスとポートでのみ聞く必要があります。パブリックインターネット上のホストがパブリックアドレスに送信したパケットと、STUNが学んだポートは、アプリケーションによって受信されます。"
    },
    {
      "indent": 3,
      "text": "Of course, the host may not be behind a full-cone NAT. Indeed, it doesn't yet know what type of NAT it is behind. To determine that, the client uses additional STUN Binding Requests. The exact procedure is flexible, but would generally work as follows. The client would send a second STUN Binding Request, this time to a different IP address, but from the same source IP address and port. If the IP address and port in the response are different from those in the first response, the client knows it is behind a symmetric NAT. To determine if it's behind a full-cone NAT, the client can send a STUN Binding Request with flags that tell the STUN server to send a response from a different IP address and port than the request was received on. In other words, if the client sent a Binding Request to IP address/port A/B using a source IP address/port of X/Y, the STUN server would send the Binding Response to X/Y using source IP address/port C/D. If the client receives this response, it knows it is behind a full cone NAT.",
      "ja": "もちろん、ホストはフルコーンNATの後ろにいない場合があります。確かに、それがどのようなタイプのNATが背後にあるかはまだわかりません。それを決定するために、クライアントは追加のスタンバインディングリクエストを使用します。正確な手順は柔軟ですが、一般に次のように機能します。クライアントは、今回は別のIPアドレスに2番目のスタンバインディングリクエストを送信しますが、同じソースIPアドレスとポートから。応答のIPアドレスとポートが最初の応答のアドレスと異なる場合、クライアントはそれが対称NATの背後にあることを知っています。フルコーンNATの背後にあるかどうかを判断するために、クライアントは、リクエストが受信されたものとは異なるIPアドレスとポートから応答を送信するようにStunサーバーに伝えるフラグでスタンバインディングリクエストを送信できます。言い換えれば、クライアントがX/YのソースIPアドレス/ポートを使用してIPアドレス/ポートA/Bにバインディングリクエストを送信した場合、STUNサーバーはソースIPアドレス/ポートCを使用してX/Yにバインディング応答を送信します/d。クライアントがこの応答を受け取った場合、それは完全なコーンナットの背後にあることを知っています。"
    },
    {
      "indent": 3,
      "text": "STUN also allows the client to ask the server to send the Binding Response from the same IP address the request was received on, but with a different port. This can be used to detect whether the client is behind a port restricted cone NAT or just a restricted cone NAT.",
      "ja": "また、Stunを使用すると、クライアントは、リクエストが受信された同じIPアドレスからバインディング応答を送信するようにサーバーに要求することもできますが、別のポートを使用します。これを使用して、クライアントがポート制限付きコーンナットの背後にあるのか、それとも単なる制限付きコーンNATの後ろにいるのかを検出できます。"
    },
    {
      "indent": 3,
      "text": "It should be noted that the configuration in Figure 1 is not the only permissible configuration. The STUN server can be located anywhere, including within another client. The only requirement is that the STUN server is reachable by the client, and if the client is trying to obtain a publicly routable address, that the server reside on the public Internet.",
      "ja": "図1の構成だけが許容構成だけではないことに注意する必要があります。スタンサーバーは、別のクライアント内を含むどこにでも配置できます。唯一の要件は、クライアントがスタンサーバーに到達できること、およびクライアントが公開されているアドレスを取得しようとしている場合、サーバーがパブリックインターネットに存在することです。"
    },
    {
      "indent": 0,
      "text": "7. Message Overview",
      "section_title": true,
      "ja": "7. メッセージの概要"
    },
    {
      "indent": 3,
      "text": "STUN messages are TLV (type-length-value) encoded using big endian (network ordered) binary. All STUN messages start with a STUN header, followed by a STUN payload. The payload is a series of STUN attributes, the set of which depends on the message type. The STUN header contains a STUN message type, transaction ID, and length. The message type can be Binding Request, Binding Response, Binding Error Response, Shared Secret Request, Shared Secret Response, or Shared Secret Error Response. The transaction ID is used to correlate requests and responses. The length indicates the total length of the STUN payload, not including the header. This allows STUN to run over TCP. Shared Secret Requests are always sent over TCP (indeed, using TLS over TCP).",
      "ja": "スタンメッセージは、Big Endian（ネットワーク順序）バイナリを使用してエンコードされたTLV（タイプ長値）です。すべてのスタンメッセージは、スタンヘッダーから始まり、続いてスタンペイロードが続きます。ペイロードは一連のスタン属性であり、そのセットはメッセージタイプに依存します。スタンヘッダーには、スタンメッセージタイプ、トランザクションID、および長さが含まれています。メッセージタイプは、バインディングリクエスト、バインディング応答、バインディングエラー応答、共有秘密要求、共有された秘密応答、または共有秘密エラー応答です。トランザクションIDは、リクエストと応答を相関させるために使用されます。長さは、ヘッダーを含まないスタンペイロードの全長を示します。これにより、スタンはTCPを介して実行できます。共有秘密のリクエストは常にTCPを介して送信されます（実際、TCPを介してTLSを使用しています）。"
    },
    {
      "indent": 3,
      "text": "Several STUN attributes are defined. The first is a MAPPED-ADDRESS attribute, which is an IP address and port. It is always placed in the Binding Response, and it indicates the source IP address and port the server saw in the Binding Request. There is also a RESPONSE-ADDRESS attribute, which contains an IP address and port. The RESPONSE-ADDRESS attribute can be present in the Binding Request, and indicates where the Binding Response is to be sent. It's optional, and when not present, the Binding Response is sent to the source IP address and port of the Binding Request.",
      "ja": "いくつかのスタン属性が定義されています。1つ目は、IPアドレスとポートであるマッピングされたアドレス属性です。これは常にバインディング応答に配置され、ソースIPアドレスと、ビンディングリクエストでサーバーが表示されるポートを示します。IPアドレスとポートを含む応答アドレス属性もあります。応答 - アドレス属性は、バインディングリクエストに存在することができ、バインディング応答がどこに送信されるかを示します。オプションであり、存在しない場合、バインディング応答はソースIPアドレスとバインディングリクエストのポートに送信されます。"
    },
    {
      "indent": 3,
      "text": "The third attribute is the CHANGE-REQUEST attribute, and it contains two flags to control the IP address and port used to send the response. These flags are called \"change IP\" and \"change port\" flags. The CHANGE-REQUEST attribute is allowed only in the Binding Request. The \"change IP\" and \"change port\" flags are useful for determining whether the client is behind a restricted cone NAT or restricted port cone NAT. They instruct the server to send the Binding Responses from a different source IP address and port. The CHANGE-REQUEST attribute is optional in the Binding Request.",
      "ja": "3番目の属性は、変更リケスト属性であり、応答の送信に使用されるIPアドレスとポートを制御するための2つのフラグが含まれています。これらのフラグは、「Change IP」と「Change Port」フラグと呼ばれます。Change-Request属性は、バインディングリクエストでのみ許可されます。「Change IP」および「Change Port」フラグは、クライアントが制限付きコーンNATまたは制限付きポートコーンNATの背後にいるかどうかを判断するのに役立ちます。彼らは、異なるソースIPアドレスとポートからバインディング応答を送信するようサーバーに指示します。Change-Request属性は、バインディングリクエストでオプションです。"
    },
    {
      "indent": 3,
      "text": "The fourth attribute is the CHANGED-ADDRESS attribute. It is present in Binding Responses. It informs the client of the source IP address and port that would be used if the client requested the \"change IP\" and \"change port\" behavior.",
      "ja": "4番目の属性は、変更されたアドレス属性です。結合応答に存在します。クライアントが「IPの変更」および「ポートの変更」動作を要求した場合に使用されるソースIPアドレスとポートをクライアントに通知します。"
    },
    {
      "indent": 3,
      "text": "The fifth attribute is the SOURCE-ADDRESS attribute. It is only present in Binding Responses. It indicates the source IP address and port where the response was sent from. It is useful for detecting twice NAT configurations.",
      "ja": "5番目の属性は、ソースアドレス属性です。結合応答にのみ存在します。応答が送信されたソースIPアドレスとポートを示します。2回のNAT構成を検出するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "The sixth attribute is the USERNAME attribute. It is present in a Shared Secret Response, which provides the client with a temporary username and password (encoded in the PASSWORD attribute). The USERNAME is also present in Binding Requests, serving as an index to the shared secret used for the integrity protection of the Binding Request. The seventh attribute, PASSWORD, is only found in Shared Secret Response messages. The eight attribute is the MESSAGE-INTEGRITY attribute, which contains a message integrity check over the Binding Request or Binding Response.",
      "ja": "6番目の属性は、ユーザー名属性です。共有された秘密の応答に存在し、クライアントに一時的なユーザー名とパスワードを提供します（パスワード属性にエンコードされています）。ユーザー名は拘束力のある要求にも存在し、バインディングリクエストの整合性保護に使用される共有秘密のインデックスとして機能します。7番目の属性であるパスワードは、共有秘密の応答メッセージにのみ見つかります。8つの属性はメッセージ統合属性であり、これには、バインディングリクエストまたはバインディング応答に対するメッセージの整合性チェックが含まれています。"
    },
    {
      "indent": 3,
      "text": "The ninth attribute is the ERROR-CODE attribute. This is present in the Binding Error Response and Shared Secret Error Response. It indicates the error that has occurred. The tenth attribute is the UNKNOWN-ATTRIBUTES attribute, which is present in either the Binding Error Response or Shared Secret Error Response. It indicates the mandatory attributes from the request which were unknown. The eleventh attribute is the REFLECTED-FROM attribute, which is present in Binding Responses. It indicates the IP address and port of the sender of a Binding Request, used for traceability purposes to prevent certain denial-of-service attacks.",
      "ja": "9番目の属性は、エラーコード属性です。これは、バインディングエラー応答と共有秘密エラー応答に存在します。発生したエラーを示します。10番目の属性は、バインディングエラー応答または共有秘密エラー応答のいずれかに存在する未知のアトリビュート属性です。不明な要求からの必須の属性を示します。11番目の属性は、結合応答に存在する反射属性です。これは、特定のサービス拒否攻撃を防ぐためにトレーサビリティ目的で使用される拘束力のある要求の送信者のIPアドレスとポートを示します。"
    },
    {
      "indent": 0,
      "text": "8. Server Behavior",
      "section_title": true,
      "ja": "8. サーバーの動作"
    },
    {
      "indent": 3,
      "text": "The server behavior depends on whether the request is a Binding Request or a Shared Secret Request.",
      "ja": "サーバーの動作は、リクエストが拘束力のある要求か共有秘密のリクエストであるかに依存します。"
    },
    {
      "indent": 0,
      "text": "8.1 Binding Requests",
      "section_title": true,
      "ja": "8.1 バインディングリクエスト"
    },
    {
      "indent": 3,
      "text": "A STUN server MUST be prepared to receive Binding Requests on four address/port combinations - (A1, P1), (A2, P1), (A1, P2), and (A2, P2). (A1, P1) represent the primary address and port, and these are the ones obtained through the client discovery procedures below. Typically, P1 will be port 3478, the default STUN port. A2 and P2 are arbitrary. A2 and P2 are advertised by the server through the CHANGED-ADDRESS attribute, as described below.",
      "ja": "STUNサーバーは、4つのアドレス/ポートの組み合わせ（A1、P1）、（A2、P1）、（A1、P2）、および（A2、P2）でバインディングリクエストを受信するために準備する必要があります。（A1、P1）は主要なアドレスとポートを表し、これらは以下のクライアント発見手順を通じて得られたものです。通常、P1はデフォルトのスタンポートであるポート3478になります。A2とP2は任意です。A2とP2は、以下に説明するように、変更されたアドレス属性を介してサーバーによって宣伝されています。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that the server check the Binding Request for a MESSAGE-INTEGRITY attribute. If not present, and the server requires integrity checks on the request, it generates a Binding Error Response with an ERROR-CODE attribute with response code 401. If the MESSAGE-INTEGRITY attribute was present, the server computes the HMAC over the request as described in Section 11.2.8. The key to use depends on the shared secret mechanism. If the STUN Shared Secret Request was used, the key MUST be the one associated with the USERNAME attribute present in the request. If the USERNAME attribute was not present, the server MUST generate a Binding Error Response. The Binding Error Response MUST include an ERROR-CODE attribute with response code 432. If the USERNAME is present, but the server doesn't remember the shared secret for that USERNAME (because it timed out, for example), the server MUST generate a Binding Error Response. The Binding Error Response MUST include an ERROR-CODE attribute with response code 430. If the server does know the shared secret, but the computed HMAC differs from the one in the request, the server MUST generate a Binding Error Response with an ERROR-CODE attribute with response code 431. The Binding Error Response is sent to the IP address and port the Binding Request came from, and sent from the IP address and port the Binding Request was sent to.",
      "ja": "サーバーは、メッセージインテグリティ属性のバインディングリクエストを確認することをお勧めします。存在しない場合、およびサーバーがリクエストで整合性チェックを必要とする場合、応答コード401を使用してエラーコード属性を使用してバインディングエラー応答を生成します。セクション11.2.8で。使用する鍵は、共有された秘密のメカニズムに依存します。Stun Shared Secretリクエストが使用された場合、キーはリクエストに存在するユーザー名属性に関連付けられているものでなければなりません。ユーザー名属性が存在しない場合、サーバーはバインディングエラー応答を生成する必要があります。バインディングエラー応答には、応答コード432のエラーコード属性を含める必要があります。ユーザー名が存在しますが、サーバーがそのユーザー名の共有秘密を覚えていない場合（たとえば、タイミングで締められているため）、サーバーはAを生成する必要があります。結合エラー応答。バインディングエラー応答には、応答コード430を持つエラーコード属性を含める必要があります。サーバーが共有シークレットを知っているが、計算されたHMACがリクエスト内のものと異なる場合、サーバーはエラーコードでバインディングエラー応答を生成する必要があります応答コード431を使用した属性。バインディングエラー応答はIPアドレスに送信され、バインディングリクエストはIPアドレスから送信され、IPアドレスから送信され、バインディングリクエストが送信されました。"
    },
    {
      "indent": 3,
      "text": "Assuming the message integrity check passed, processing continues. The server MUST check for any attributes in the request with values less than or equal to 0x7fff which it does not understand. If it encounters any, the server MUST generate a Binding Error Response, and it MUST include an ERROR-CODE attribute with a 420 response code.",
      "ja": "メッセージの整合性チェックが合格したと仮定すると、処理が続きます。サーバーは、リクエスト内の属性を、わからない0x7FFF以下の属性を確認する必要があります。侵入した場合、サーバーはバインディングエラー応答を生成する必要があり、420応答コードを持つエラーコード属性を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "That response MUST contain an UNKNOWN-ATTRIBUTES attribute listing the attributes with values less than or equal to 0x7fff which were not understood. The Binding Error Response is sent to the IP address and port the Binding Request came from, and sent from the IP address and port the Binding Request was sent to.",
      "ja": "その応答には、理解されていない値が0x7fff以下の値を持つ属性をリストする未知のアトリビュート属性を含める必要があります。バインディングエラー応答はIPアドレスに送信され、拘束力のあるリクエストが由来し、IPアドレスから送信され、バインディングリクエストが送信されました。"
    },
    {
      "indent": 3,
      "text": "Assuming the request was correctly formed, the server MUST generate a single Binding Response. The Binding Response MUST contain the same transaction ID contained in the Binding Request. The length in the message header MUST contain the total length of the message in bytes, excluding the header. The Binding Response MUST have a message type of \"Binding Response\".",
      "ja": "リクエストが正しく形成されたと仮定すると、サーバーは単一のバインディング応答を生成する必要があります。バインディング応答には、バインディングリクエストに含まれる同じトランザクションIDが含まれている必要があります。メッセージヘッダーの長さには、ヘッダーを除いて、メッセージの合計メッセージの長さをバイト単位で含める必要があります。結合応答には、メッセージタイプの「バインディング応答」が必要です。"
    },
    {
      "indent": 3,
      "text": "The server MUST add a MAPPED-ADDRESS attribute to the Binding Response. The IP address component of this attribute MUST be set to the source IP address observed in the Binding Request. The port component of this attribute MUST be set to the source port observed in the Binding Request.",
      "ja": "サーバーは、マッピングされたアドレス属性をバインディング応答に追加する必要があります。この属性のIPアドレスコンポーネントは、バインディングリクエストで観察されたソースIPアドレスに設定する必要があります。この属性のポートコンポーネントは、バインディングリクエストで観測されたソースポートに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the RESPONSE-ADDRESS attribute was absent from the Binding Request, the destination address and port of the Binding Response MUST be the same as the source address and port of the Binding Request. Otherwise, the destination address and port of the Binding Response MUST be the value of the IP address and port in the RESPONSE-ADDRESS attribute.",
      "ja": "応答とアドレス属性がバインディングリクエストに存在しない場合、バインディング応答の宛先アドレスとポートは、バインディングリクエストのソースアドレスとポートと同じでなければなりません。それ以外の場合、バインディング応答の宛先アドレスとポートは、応答アドレス属性のIPアドレスとポートの値でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The source address and port of the Binding Response depend on the value of the CHANGE-REQUEST attribute and on the address and port the Binding Request was received on, and are summarized in Table 1.",
      "ja": "バインディング応答のソースアドレスとポートは、Change-Request属性の値に依存し、アドレスとポートにバインディングリクエストが受信され、表1に要約されています。"
    },
    {
      "indent": 3,
      "text": "Let Da represent the destination IP address of the Binding Request (which will be either A1 or A2), and Dp represent the destination port of the Binding Request (which will be either P1 or P2). Let Ca represent the other address, so that if Da is A1, Ca is A2. If Da is A2, Ca is A1. Similarly, let Cp represent the other port, so that if Dp is P1, Cp is P2. If Dp is P2, Cp is P1. If the \"change port\" flag was set in CHANGE-REQUEST attribute of the Binding Request, and the \"change IP\" flag was not set, the source IP address of the Binding Response MUST be Da and the source port of the Binding Response MUST be Cp. If the \"change IP\" flag was set in the Binding Request, and the \"change port\" flag was not set, the source IP address of the Binding Response MUST be Ca and the source port of the Binding Response MUST be Dp. When both flags are set, the source IP address of the Binding Response MUST be Ca and the source port of the Binding Response MUST be Cp. If neither flag is set, or if the CHANGE-REQUEST attribute is absent entirely, the source IP address of the Binding Response MUST be Da and the source port of the Binding Response MUST be Dp.",
      "ja": "DAがバインディング要求の宛先IPアドレス（A1またはA2のいずれか）を表し、DPはバインディング要求の宛先ポート（P1またはP2のいずれか）を表します。DAがA1の場合、CAがA2になるように、CAを他のアドレスを表してください。DAがA2の場合、CAはA1です。同様に、CPを他のポートを表すため、DPがP1の場合、CPがP2になるようにします。DPがP2の場合、CPはP1です。「変更ポート」フラグがバインディングリクエストの変更要求属性に設定され、「変更IP」フラグが設定されていない場合、バインディング応答のソースIPアドレスはDAでなければならず、バインディング応答のソースポートは必要です。CPになります。「IPの変更」フラグがバインディングリクエストに設定され、「変更ポート」フラグが設定されていない場合、バインディング応答のソースIPアドレスはCAでなければならず、バインディング応答のソースポートはDPでなければなりません。両方のフラグが設定されている場合、バインディング応答のソースIPアドレスはCAでなければならず、バインディング応答のソースポートはCPでなければなりません。どちらのフラグも設定されていない場合、または変更リクエスト属性が完全に存在しない場合、バインディング応答のソースIPアドレスはDAでなければならず、バインディング応答のソースポートはDPでなければなりません。"
    },
    {
      "indent": 6,
      "text": "Flags          Source Address  Source Port   CHANGED-ADDRESS\nnone           Da              Dp            Ca:Cp\nChange IP      Ca              Dp            Ca:Cp\nChange port    Da              Cp            Ca:Cp\nChange IP and\n  Change port  Ca              Cp            Ca:Cp",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Table 1: Impact of Flags on Packet Source and CHANGED-ADDRESS",
      "ja": "表1：パケットソースと変化したアドレスに対するフラグの影響"
    },
    {
      "indent": 3,
      "text": "The server MUST add a SOURCE-ADDRESS attribute to the Binding Response, containing the source address and port used to send the Binding Response.",
      "ja": "サーバーは、バインディング応答を送信するために使用されるソースアドレスとポートを含むバインディング応答にソースアドレス属性を追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "The server MUST add a CHANGED-ADDRESS attribute to the Binding Response. This contains the source IP address and port that would be used if the client had set the \"change IP\" and \"change port\" flags in the Binding Request. As summarized in Table 1, these are Ca and Cp, respectively, regardless of the value of the CHANGE-REQUEST flags.",
      "ja": "サーバーは、バインディング応答に変更されたアドレス属性を追加する必要があります。これには、クライアントがバインディングリクエストで「Change IP」と「Change Port」フラグを設定した場合に使用されるソースIPアドレスとポートが含まれます。表1に要約されているように、これらは、変更要求フラグの値に関係なく、それぞれCAとCPです。"
    },
    {
      "indent": 3,
      "text": "If the Binding Request contained both the USERNAME and MESSAGE-INTEGRITY attributes, the server MUST add a MESSAGE-INTEGRITY attribute to the Binding Response. The attribute contains an HMAC [13] over the response, as described in Section 11.2.8. The key to use depends on the shared secret mechanism. If the STUN Shared Secret Request was used, the key MUST be the one associated with the USERNAME attribute present in the Binding Request.",
      "ja": "バインディングリクエストにユーザー名とメッセージインテグリティの両方の属性が含まれている場合、サーバーはバインディング応答にメッセージインテグリティ属性を追加する必要があります。属性には、セクション11.2.8で説明されているように、応答に対するHMAC [13]が含まれています。使用する鍵は、共有された秘密のメカニズムに依存します。Stun Shared Secret Requestが使用された場合、キーは、バインディングリクエストに存在するユーザー名属性に関連付けられているものでなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the Binding Request contained a RESPONSE-ADDRESS attribute, the server MUST add a REFLECTED-FROM attribute to the response. If the Binding Request was authenticated using a username obtained from a Shared Secret Request, the REFLECTED-FROM attribute MUST contain the source IP address and port where that Shared Secret Request came from. If the username present in the request was not allocated using a Shared Secret Request, the REFLECTED-FROM attribute MUST contain the source address and port of the entity which obtained the username, as best can be verified with the mechanism used to allocate the username. If the username was not present in the request, and the server was willing to process the request, the REFLECTED-FROM attribute SHOULD contain the source IP address and port where the request came from.",
      "ja": "バインディング要求に応答アドレス属性が含まれている場合、サーバーは応答に反射属性を追加する必要があります。共有されたシークレットリクエストから取得したユーザー名を使用してバインディングリクエストが認証された場合、反射属性には、共有された秘密要求が生じたソースIPアドレスとポートを含める必要があります。リクエストに存在するユーザー名が共有シークレットリクエストを使用して割り当てられなかった場合、反射属性は、ユーザー名の割り当てに使用されるメカニズムで最適に検証できるため、ユーザー名を取得したエンティティのソースアドレスとポートを含める必要があります。リクエストにユーザー名が存在せず、サーバーがリクエストを処理する意思がある場合、反射属性にリクエストが発生したソースIPアドレスとポートを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "The server SHOULD NOT retransmit the response. Reliability is achieved by having the client periodically resend the request, each of which triggers a response from the server.",
      "ja": "サーバーは応答を再送信しないでください。信頼性は、クライアントに定期的にリクエストを再送信させることで達成され、それぞれがサーバーからの応答をトリガーします。"
    },
    {
      "indent": 0,
      "text": "8.2 Shared Secret Requests",
      "section_title": true,
      "ja": "8.2 共有秘密のリクエスト"
    },
    {
      "indent": 3,
      "text": "Shared Secret Requests are always received on TLS connections. When the server receives a request from the client to establish a TLS connection, it MUST proceed with TLS, and SHOULD present a site certificate. The TLS ciphersuite TLS_RSA_WITH_AES_128_CBC_SHA [4] SHOULD be used. Client TLS authentication MUST NOT be done, since the server is not allocating any resources to clients, and the computational burden can be a source of attacks.",
      "ja": "共有秘密のリクエストは、常にTLS接続で受信されます。サーバーがTLS接続を確立するためにクライアントからリクエストを受信した場合、TLSを続行する必要があり、サイト証明書を提示する必要があります。TLS Ciphersuite TLS_RSA_WITH_AES_128_CBC_SHA [4]を使用する必要があります。サーバーはクライアントにリソースを割り当てていないため、クライアントTLS認証を実行する必要はありません。"
    },
    {
      "indent": 3,
      "text": "If the server receives a Shared Secret Request, it MUST verify that the request arrived on a TLS connection. If it did not receive the request over TLS, it MUST generate a Shared Secret Error Response, and it MUST include an ERROR-CODE attribute with a 433 response code. The destination for the error response depends on the transport on which the request was received. If the Shared Secret Request was received over TCP, the Shared Secret Error Response is sent over the same connection the request was received on. If the Shared Secret Request was receive over UDP, the Shared Secret Error Response is sent to the source IP address and port that the request came from.",
      "ja": "サーバーが共有の秘密要求を受信した場合、リクエストがTLS接続に届いたことを確認する必要があります。TLSを介してリクエストを受信しなかった場合、共有シークレットエラー応答を生成する必要があり、433応答コードを持つエラーコード属性を含める必要があります。エラー応答の宛先は、リクエストが受信されたトランスポートに依存します。共有秘密の要求がTCPを介して受信された場合、リクエストが受信されたのと同じ接続で共有された秘密エラー応答が送信されます。共有秘密の要求がUDPを介して受信された場合、共有された秘密エラー応答は、リクエストが生じたソースIPアドレスとポートに送信されます。"
    },
    {
      "indent": 3,
      "text": "The server MUST check for any attributes in the request with values less than or equal to 0x7fff which it does not understand. If it encounters any, the server MUST generate a Shared Secret Error Response, and it MUST include an ERROR-CODE attribute with a 420 response code. That response MUST contain an UNKNOWN-ATTRIBUTES attribute listing the attributes with values less than or equal to 0x7fff which were not understood. The Shared Secret Error Response is sent over the TLS connection.",
      "ja": "サーバーは、リクエスト内の属性を、わからない0x7FFF以下の属性を確認する必要があります。侵入した場合、サーバーは共有秘密エラー応答を生成する必要があり、420応答コードを持つエラーコード属性を含める必要があります。その応答には、理解されていない値が0x7fff以下の値を持つ属性をリストする未知のアトリビュート属性を含める必要があります。共有秘密エラー応答は、TLS接続を介して送信されます。"
    },
    {
      "indent": 3,
      "text": "All Shared Secret Error Responses MUST contain the same transaction ID contained in the Shared Secret Request. The length in the message header MUST contain the total length of the message in bytes, excluding the header. The Shared Secret Error Response MUST have a message type of \"Shared Secret Error Response\" (0x0112).",
      "ja": "共有されたすべての秘密エラー応答には、共有されたシークレットリクエストに含まれる同じトランザクションIDが含まれている必要があります。メッセージヘッダーの長さには、ヘッダーを除いて、メッセージの合計メッセージの長さをバイト単位で含める必要があります。共有された秘密エラー応答には、「共有秘密エラー応答」（0x0112）のメッセージタイプが必要です。"
    },
    {
      "indent": 3,
      "text": "Assuming the request was properly constructed, the server creates a Shared Secret Response. The Shared Secret Response MUST contain the same transaction ID contained in the Shared Secret Request. The length in the message header MUST contain the total length of the message in bytes, excluding the header. The Shared Secret Response MUST have a message type of \"Shared Secret Response\". The Shared Secret Response MUST contain a USERNAME attribute and a PASSWORD attribute. The USERNAME attribute serves as an index to the password, which is contained in the PASSWORD attribute. The server can use any mechanism it chooses to generate the username. However, the username MUST be valid for a period of at least 10 minutes. Validity means that the server can compute the password for that username. There MUST be a single password for each username. In other words, the server cannot, 10 minutes later, assign a different password to the same username. The server MUST hand out a different username for each distinct Shared Secret Request. Distinct, in this case, implies a different transaction ID. It is RECOMMENDED that the server explicitly invalidate the username after ten minutes. It MUST invalidate the username after 30 minutes. The PASSWORD contains the password bound to that username. The password MUST have at least 128 bits. The likelihood that the server assigns the same password for two different usernames MUST be vanishingly small, and the passwords MUST be unguessable. In other words, they MUST be a cryptographically random function of the username.",
      "ja": "リクエストが適切に構築されていると仮定すると、サーバーは共有された秘密の応答を作成します。共有された秘密応答には、共有秘密要求に含まれる同じトランザクションIDが含まれている必要があります。メッセージヘッダーの長さには、ヘッダーを除いて、メッセージの合計メッセージの長さをバイト単位で含める必要があります。共有された秘密の応答には、メッセージタイプの「共有秘密応答」が必要です。共有秘密応答には、ユーザー名属性とパスワード属性を含める必要があります。ユーザー名属性は、パスワード属性に含まれるパスワードのインデックスとして機能します。サーバーは、ユーザー名を生成するために選択したメカニズムを使用できます。ただし、ユーザー名は少なくとも10分間有効でなければなりません。有効性とは、サーバーがそのユーザー名のパスワードを計算できることを意味します。各ユーザー名に単一のパスワードが必要です。言い換えれば、サーバーは10分後に同じユーザー名に別のパスワードを割り当てることはできません。サーバーは、異なる共有シークレットリクエストごとに異なるユーザー名を配布する必要があります。この場合は、異なるトランザクションIDを意味します。10分後にサーバーがユーザー名を明示的に無効にすることをお勧めします。30分後にユーザー名を無効にする必要があります。パスワードには、そのユーザー名にバインドされたパスワードが含まれています。パスワードには少なくとも128ビットが必要です。サーバーが2つの異なるユーザー名に対して同じパスワードを割り当てる可能性は、消滅するほど小さくなければならず、パスワードは不可能でなければなりません。言い換えれば、それらはユーザー名の暗号的にランダムな関数でなければなりません。"
    },
    {
      "indent": 3,
      "text": "These requirements can still be met using a stateless server, by intelligently computing the USERNAME and PASSWORD. One approach is to construct the USERNAME as:",
      "ja": "これらの要件は、ユーザー名とパスワードをインテリジェントに計算することにより、ステートレスサーバーを使用してまだ満たすことができます。1つのアプローチは、ユーザー名を次のように構築することです。"
    },
    {
      "indent": 6,
      "text": "USERNAME = <prefix,rounded-time,clientIP,hmac>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where prefix is some random text string (different for each shared secret request), rounded-time is the current time modulo 20 minutes, clientIP is the source IP address where the Shared Secret Request came from, and hmac is an HMAC [13] over the prefix, rounded-time, and client IP, using a server private key.",
      "ja": "プレフィックスはいくつかのランダムなテキスト文字列（共有シークレットリクエストごとに異なる）、丸みを帯びた時間は現在の時刻20分であり、ClientIPは共有秘密要求が発生したソースIPアドレスであり、HMACはHMAC [13]を超えるソースIPアドレスです。サーバーの秘密鍵を使用して、プレフィックス、丸みを帯びた時間、クライアントIP。"
    },
    {
      "indent": 3,
      "text": "The password is then computed as:",
      "ja": "パスワードは次のように計算されます。"
    },
    {
      "indent": 6,
      "text": "password = <hmac(USERNAME,anotherprivatekey)>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "With this structure, the username itself, which will be present in the Binding Request, contains the source IP address where the Shared Secret Request came from. That allows the server to meet the requirements specified in Section 8.1 for constructing the REFLECTED-FROM attribute. The server can verify that the username was not tampered with, using the hmac present in the username.",
      "ja": "この構造を使用すると、バインディングリクエストに存在するユーザー名自体には、共有された秘密要求が生じたソースIPアドレスが含まれています。これにより、サーバーは、反射属性を構築するためにセクション8.1で指定された要件を満たすことができます。サーバーは、ユーザー名に存在するHMACを使用して、ユーザー名が改ざんされていないことを確認できます。"
    },
    {
      "indent": 3,
      "text": "The Shared Secret Response is sent over the same TLS connection the request was received on. The server SHOULD keep the connection open, and let the client close it.",
      "ja": "共有秘密の応答は、リクエストが受信されたのと同じTLS接続の上に送信されます。サーバーは接続を開いたままにし、クライアントを閉じさせます。"
    },
    {
      "indent": 0,
      "text": "9. Client Behavior",
      "section_title": true,
      "ja": "9. クライアントの動作"
    },
    {
      "indent": 3,
      "text": "The behavior of the client is very straightforward. Its task is to discover the STUN server, obtain a shared secret, formulate the Binding Request, handle request reliability, and process the Binding Responses.",
      "ja": "クライアントの動作は非常に簡単です。そのタスクは、スタンサーバーを発見し、共有された秘密を取得し、バインディングリクエストを策定し、リクエストの信頼性を処理し、バインディング応答を処理することです。"
    },
    {
      "indent": 0,
      "text": "9.1 Discovery",
      "section_title": true,
      "ja": "9.1 発見"
    },
    {
      "indent": 3,
      "text": "Generally, the client will be configured with a domain name of the provider of the STUN servers. This domain name is resolved to an IP address and port using the SRV procedures specified in RFC 2782 [3].",
      "ja": "通常、クライアントは、STUNサーバーのプロバイダーのドメイン名で構成されます。このドメイン名は、RFC 2782 [3]で指定されたSRV手順を使用して、IPアドレスとポートに解決されます。"
    },
    {
      "indent": 3,
      "text": "Specifically, the service name is \"stun\". The protocol is \"udp\" for sending Binding Requests, or \"tcp\" for sending Shared Secret Requests. The procedures of RFC 2782 are followed to determine the server to contact. RFC 2782 spells out the details of how a set of SRV records are sorted and then tried. However, it only states that the client should \"try to connect to the (protocol, address, service)\" without giving any details on what happens in the event of failure. Those details are described here for STUN.",
      "ja": "具体的には、サービス名は「スタン」です。プロトコルは、バインディングリクエストを送信するための「UDP」、または共有秘密のリクエストを送信するための「TCP」です。RFC 2782の手順に従って、接触するサーバーを決定します。RFC 2782は、SRVレコードのセットがどのように並べ替えられ、その後試行されるかの詳細を説明しています。ただし、クライアントは、失敗の場合に何が起こるかについて詳細を与えることなく、クライアントが「（プロトコル、アドレス、サービス）に接続しようとする」だけであると述べています。これらの詳細については、ここではスタンについて説明します。"
    },
    {
      "indent": 3,
      "text": "For STUN requests, failure occurs if there is a transport failure of some sort (generally, due to fatal ICMP errors in UDP or connection failures in TCP). Failure also occurs if the transaction fails due to timeout. This occurs 9.5 seconds after the first request is sent, for both Shared Secret Requests and Binding Requests. See Section 9.3 for details on transaction timeouts for Binding Requests. If a failure occurs, the client SHOULD create a new request, which is identical to the previous, but has a different transaction ID and MESSAGE INTEGRITY attribute (the HMAC will change because the transaction ID has changed). That request is sent to the next element in the list as specified by RFC 2782.",
      "ja": "スタンリクエストの場合、何らかの輸送障害がある場合に障害が発生します（一般に、UDPでの致命的なICMPエラーまたはTCPでの接続障害により）。タイムアウトのためにトランザクションが失敗した場合にも障害が発生します。これは、共有された秘密のリクエストと拘束力のあるリクエストの両方に対して、最初のリクエストが送信されてから9.5秒で発生します。バインディングリクエストについては、トランザクションタイムアウトの詳細については、セクション9.3を参照してください。失敗が発生した場合、クライアントは以前と同一の新しいリクエストを作成する必要がありますが、異なるトランザクションIDとメッセージの整合性属性があります（トランザクションIDが変更されたため、HMACは変更されます）。その要求は、RFC 2782で指定されているように、リストの次の要素に送信されます。"
    },
    {
      "indent": 3,
      "text": "The default port for STUN requests is 3478, for both TCP and UDP. Administrators SHOULD use this port in their SRV records, but MAY use others.",
      "ja": "スタン要求のデフォルトポートは、TCPとUDPの両方の3478です。管理者はこのポートをSRVレコードで使用する必要がありますが、他のポートを使用する場合があります。"
    },
    {
      "indent": 3,
      "text": "If no SRV records were found, the client performs an A record lookup of the domain name. The result will be a list of IP addresses, each of which can be contacted at the default port.",
      "ja": "SRVレコードが見つからなかった場合、クライアントはドメイン名のAレコード検索を実行します。結果は、IPアドレスのリストになり、それぞれがデフォルトのポートで連絡できます。"
    },
    {
      "indent": 3,
      "text": "This would allow a firewall admin to open the STUN port, so hosts within the enterprise could access new applications. Whether they will or won't do this is a good question.",
      "ja": "これにより、ファイアウォール管理者がスタンポートを開くことができるため、エンタープライズ内のホストは新しいアプリケーションにアクセスできます。彼らがこれをするかしないかは良い質問です。"
    },
    {
      "indent": 0,
      "text": "9.2 Obtaining a Shared Secret",
      "section_title": true,
      "ja": "9.2 共有秘密を取得します"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 12, there are several attacks possible on STUN systems. Many of these are prevented through integrity of requests and responses. To provide that integrity, STUN makes use of a shared secret between client and server, used as the keying material for an HMAC used in both the Binding Request and Binding Response. STUN allows for the shared secret to be obtained in any way (for example, Kerberos [14]). However, it MUST have at least 128 bits of randomness. In order to ensure interoperability, this specification describes a TLS-based mechanism. This mechanism, described in this section, MUST be implemented by clients and servers.",
      "ja": "セクション12で説明したように、スタンシステムでいくつかの攻撃が可能です。これらの多くは、要求と応答の完全性によって防止されます。その整合性を提供するために、Stunは、バインディング要求と拘束力のある応答の両方で使用されるHMACのキーイング素材として使用されるクライアントとサーバーの間の共有秘密を利用します。Stunは、共有された秘密を何らかの形で得ることができます（たとえば、Kerberos [14]）。ただし、少なくとも128ビットのランダム性が必要です。相互運用性を確保するために、この仕様はTLSベースのメカニズムについて説明します。このセクションで説明するこのメカニズムは、クライアントとサーバーによって実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "First, the client determines the IP address and port that it will open a TCP connection to. This is done using the discovery procedures in Section 9.1. The client opens up the connection to that address and port, and immediately begins TLS negotiation [2]. The client MUST verify the identity of the server. To do that, it follows the identification procedures defined in Section 3.1 of RFC 2818 [5]. Those procedures assume the client is dereferencing a URI. For purposes of usage with this specification, the client treats the domain name or IP address used in Section 9.1 as the host portion of the URI that has been dereferenced.",
      "ja": "まず、クライアントは、TCP接続を開くIPアドレスとポートを決定します。これは、セクション9.1の発見手順を使用して行われます。クライアントは、そのアドレスとポートへの接続を開き、すぐにTLS交渉を開始します[2]。クライアントは、サーバーのIDを確認する必要があります。そのために、RFC 2818のセクション3.1で定義されている識別手順に従います[5]。これらの手順は、クライアントがURIを繰り返していると仮定しています。この仕様で使用する目的のために、クライアントは、セクション9.1で使用されているドメイン名またはIPアドレスを、参照されたURIのホスト部分として扱います。"
    },
    {
      "indent": 3,
      "text": "Once the connection is opened, the client sends a Shared Secret request. This request has no attributes, just the header. The transaction ID in the header MUST meet the requirements outlined for the transaction ID in a binding request, described in Section 9.3 below. The server generates a response, which can either be a Shared Secret Response or a Shared Secret Error Response.",
      "ja": "接続が開かれると、クライアントは共有秘密のリクエストを送信します。このリクエストには属性がなく、ヘッダーだけです。ヘッダー内のトランザクションIDは、以下のセクション9.3で説明する拘束力のある要求で、トランザクションIDの概説された要件を満たす必要があります。サーバーは応答を生成します。これは、共有された秘密応答または共有秘密エラー応答のいずれかです。"
    },
    {
      "indent": 3,
      "text": "If the response was a Shared Secret Error Response, the client checks the response code in the ERROR-CODE attribute. Interpretation of those response codes is identical to the processing of Section 9.4 for the Binding Error Response.",
      "ja": "応答が共有された秘密エラー応答である場合、クライアントはエラーコード属性の応答コードをチェックします。これらの応答コードの解釈は、結合エラー応答のセクション9.4の処理と同一です。"
    },
    {
      "indent": 3,
      "text": "If a client receives a Shared Secret Response with an attribute whose type is greater than 0x7fff, the attribute MUST be ignored. If the client receives a Shared Secret Response with an attribute whose type is less than or equal to 0x7fff, the response is ignored.",
      "ja": "クライアントが、タイプが0x7FFFを超える属性を使用して共有秘密応答を受け取る場合、属性は無視する必要があります。クライアントが、タイプが0x7FFF以下の属性を使用して共有の秘密応答を受け取った場合、応答は無視されます。"
    },
    {
      "indent": 3,
      "text": "If the response was a Shared Secret Response, it will contain a short lived username and password, encoded in the USERNAME and PASSWORD attributes, respectively.",
      "ja": "応答が共有された秘密の応答である場合、それぞれユーザー名とパスワードの属性にエンコードされた短命のユーザー名とパスワードが含まれます。"
    },
    {
      "indent": 3,
      "text": "The client MAY generate multiple Shared Secret Requests on the connection, and it MAY do so before receiving Shared Secret Responses to previous Shared Secret Requests. The client SHOULD close the connection as soon as it has finished obtaining usernames and passwords.",
      "ja": "クライアントは、接続に複数の共有秘密要求を生成する場合があり、以前の共有秘密リクエストに対する共有秘密の応答を受信する前にそうすることができます。クライアントは、ユーザー名とパスワードの取得が完了したらすぐに接続を閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "Section 9.3 describes how these passwords are used to provide integrity protection over Binding Requests, and Section 8.1 describes how it is used in Binding Responses.",
      "ja": "セクション9.3では、これらのパスワードが拘束力のある要求よりも整合性保護を提供するためにどのように使用されるかについて説明し、セクション8.1では、バインディング応答で使用する方法について説明します。"
    },
    {
      "indent": 0,
      "text": "9.3 Formulating the Binding Request",
      "section_title": true,
      "ja": "9.3 バインディングリクエストの策定"
    },
    {
      "indent": 3,
      "text": "A Binding Request formulated by the client follows the syntax rules defined in Section 11. Any two requests that are not bit-wise identical, and not sent to the same server from the same IP address and port, MUST carry different transaction IDs. The transaction ID MUST be uniformly and randomly distributed between 0 and 2**128 - 1. The large range is needed because the transaction ID serves as a form of randomization, helping to prevent replays of previously signed responses from the server. The message type of the request MUST be \"Binding Request\".",
      "ja": "クライアントによって策定されたバインディングリクエストは、セクション11で定義された構文ルールに従います。ビットごとの同一ではなく、同じIPアドレスとポートから同じサーバーに送信されない2つのリクエストは、異なるトランザクションIDを運ぶ必要があります。トランザクションIDは、0〜2 ** 128-1の間に均一かつランダムに分散する必要があります。トランザクションIDはランダム化の形式として機能し、サーバーからの以前に署名された応答のリプレイを防ぐのに役立ちます。リクエストのメッセージタイプは「バインディングリクエスト」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The RESPONSE-ADDRESS attribute is optional in the Binding Request. It is used if the client wishes the response to be sent to a different IP address and port than the one the request was sent from. This is useful for determining whether the client is behind a firewall, and for applications that have separated control and data components. See Section 10.3 for more details. The CHANGE-REQUEST attribute is also optional. Whether it is present depends on what the application is trying to accomplish. See Section 10 for some example uses.",
      "ja": "Response-Address属性は、バインディングリクエストでオプションです。クライアントが、リクエストが送信されたものとは別のIPアドレスとポートに応答を送信することを希望する場合に使用されます。これは、クライアントがファイアウォールの背後にあるかどうか、および制御コンポーネントとデータコンポーネントを分離したアプリケーションに役立ちます。詳細については、セクション10.3を参照してください。Change-Request属性もオプションです。存在するかどうかは、アプリケーションが何を達成しようとしているかによって異なります。いくつかの例の使用については、セクション10を参照してください。"
    },
    {
      "indent": 3,
      "text": "The client SHOULD add a MESSAGE-INTEGRITY and USERNAME attribute to the Binding Request. This MESSAGE-INTEGRITY attribute contains an HMAC [13]. The value of the username, and the key to use in the MESSAGE-INTEGRITY attribute depend on the shared secret mechanism. If the STUN Shared Secret Request was used, the USERNAME must be a valid username obtained from a Shared Secret Response within the last nine minutes. The shared secret for the HMAC is the value of the PASSWORD attribute obtained from the same Shared Secret Response.",
      "ja": "クライアントは、バインディングリクエストにメッセージインテグリティとユーザー名属性を追加する必要があります。このメッセージインテグティ属性には、HMACが含まれています[13]。ユーザー名の値、およびメッセージインテグリティ属性で使用するキーは、共有された秘密メカニズムに依存します。Stun Shared Secret Requestが使用された場合、ユーザー名は、過去9分以内に共有された秘密応答から取得した有効なユーザー名でなければなりません。HMACの共有秘密は、同じ共有秘密応答から取得されたパスワード属性の値です。"
    },
    {
      "indent": 3,
      "text": "Once formulated, the client sends the Binding Request. Reliability is accomplished through client retransmissions. Clients SHOULD retransmit the request starting with an interval of 100ms, doubling every retransmit until the interval reaches 1.6s. Retransmissions continue with intervals of 1.6s until a response is received, or a total of 9 requests have been sent. If no response is received by 1.6 seconds after the last request has been sent, the client SHOULD consider the transaction to have failed. In other words, requests would be sent at times 0ms, 100ms, 300ms, 700ms, 1500ms, 3100ms, 4700ms, 6300ms, and 7900ms. At 9500ms, the client considers the transaction to have failed if no response has been received.",
      "ja": "定式化すると、クライアントはバインディングリクエストを送信します。信頼性は、クライアントの再送信を通じて達成されます。クライアントは、100msの間隔から始まるリクエストを再送信する必要があり、間隔が1.6秒に達するまですべての再送信を2倍にします。再送信は、応答が受信されるまで、または合計9つのリクエストが送信されるまで1.6の間隔で続きます。最後のリクエストが送信されてから1.6秒後に応答がない場合、クライアントはトランザクションが失敗したと考える必要があります。つまり、リクエストは、0ms、100ms、300ms、700ms、1500ms、3100ms、4700ms、6300ms、および7900msで送信されます。9500msで、クライアントは、回答が受信されていない場合、トランザクションが失敗したと考えています。"
    },
    {
      "indent": 0,
      "text": "9.4 Processing Binding Responses",
      "section_title": true,
      "ja": "9.4 バインディング応答の処理"
    },
    {
      "indent": 3,
      "text": "The response can either be a Binding Response or Binding Error Response. Binding Error Responses are always received on the source address and port the request was sent from. A Binding Response will be received on the address and port placed in the RESPONSE-ADDRESS attribute of the request. If none was present, the Binding Responses will be received on the source address and port the request was sent from.",
      "ja": "応答は、結合応答または結合エラー応答のいずれかです。バインディングエラー応答は常にソースアドレスで受信され、リクエストは送信されました。拘束力のある応答は、リクエストの応答アドレス属性に配置されたアドレスとポートで受信されます。存在しない場合、拘束力のある応答はソースアドレスで受信され、リクエストが送信されました。"
    },
    {
      "indent": 3,
      "text": "If the response is a Binding Error Response, the client checks the response code from the ERROR-CODE attribute of the response. For a 400 response code, the client SHOULD display the reason phrase to the user. For a 420 response code, the client SHOULD retry the request, this time omitting any attributes listed in the UNKNOWN-ATTRIBUTES attribute of the response. For a 430 response code, the client SHOULD obtain a new shared secret, and retry the Binding Request with a new transaction. For 401 and 432 response codes, if the client had omitted the USERNAME or MESSAGE-INTEGRITY attribute as indicated by the error, it SHOULD try again with those attributes. For a 431 response code, the client SHOULD alert the user, and MAY try the request again after obtaining a new username and password. For a 500 response code, the client MAY wait several seconds and then retry the request. For a 600 response code, the client MUST NOT retry the request, and SHOULD display the reason phrase to the user. Unknown attributes between 400 and 499 are treated like a 400, unknown attributes between 500 and 599 are treated like a 500, and unknown attributes between 600 and 699 are treated like a 600. Any response between 100 and 399 MUST result in the cessation of request retransmissions, but otherwise is discarded.",
      "ja": "応答がバインディングエラー応答である場合、クライアントは応答のエラーコード属性から応答コードをチェックします。400回の応答コードの場合、クライアントは理由フレーズをユーザーに表示する必要があります。420の応答コードの場合、クライアントはリクエストを再試行する必要があります。今回は、応答の不明なアトリビュート属性にリストされている属性を省略します。430応答コードの場合、クライアントは新しい共有秘密を取得し、新しいトランザクションでバインディングリクエストを再試行する必要があります。401および432の応答コードの場合、クライアントがエラーで示されているようにユーザー名またはメッセージインテグリティ属性を省略した場合、それらの属性で再試行する必要があります。431の応答コードの場合、クライアントはユーザーに警告し、新しいユーザー名とパスワードを取得した後に再度リクエストを試すことができます。500回の応答コードの場合、クライアントは数秒待ってからリクエストを再試行する場合があります。600の応答コードの場合、クライアントはリクエストを再試行してはならず、理由フレーズをユーザーに表示する必要があります。400〜499の間の未知の属性は400のように扱われ、500〜599の間の未知の属性は500のように扱われ、600〜699の未知の属性は600のように扱われます。再送信ですが、それ以外の場合は破棄されます。"
    },
    {
      "indent": 3,
      "text": "If a client receives a response with an attribute whose type is greater than 0x7fff, the attribute MUST be ignored. If the client receives a response with an attribute whose type is less than or equal to 0x7fff, request retransmissions MUST cease, but the entire response is otherwise ignored.",
      "ja": "クライアントがタイプが0x7FFFを超える属性を使用して応答を受信する場合、属性は無視する必要があります。クライアントがタイプが0x7FFF以下の属性を使用して応答を受信した場合、リクエストの再送信は停止する必要がありますが、それ以外の場合は応答全体が無視されます。"
    },
    {
      "indent": 3,
      "text": "If the response is a Binding Response, the client SHOULD check the response for a MESSAGE-INTEGRITY attribute. If not present, and the client placed a MESSAGE-INTEGRITY attribute into the request, it MUST discard the response. If present, the client computes the HMAC over the response as described in Section 11.2.8. The key to use depends on the shared secret mechanism. If the STUN Shared Secret Request was used, the key MUST be same as used to compute the MESSAGE-INTEGRITY attribute in the request. If the computed HMAC differs from the one in the response, the client MUST discard the response, and SHOULD alert the user about a possible attack. If the computed HMAC matches the one from the response, processing continues.",
      "ja": "応答が拘束力のある応答である場合、クライアントはメッセージインテグリティ属性の応答を確認する必要があります。存在しない場合、クライアントがメッセージインテグリティ属性をリクエストに配置した場合、応答を破棄する必要があります。存在する場合、クライアントは、セクション11.2.8で説明されているように、応答に対してHMACを計算します。使用する鍵は、共有された秘密のメカニズムに依存します。Stun Shared Secret Requestが使用された場合、キーは、リクエストのメッセージインテグリティ属性を計算するために使用されている必要があります。計算されたHMACが応答のものと異なる場合、クライアントは応答を破棄する必要があり、可能な攻撃についてユーザーに警告する必要があります。計算されたHMACが応答からのものと一致する場合、処理は継続されます。"
    },
    {
      "indent": 3,
      "text": "Reception of a response (either Binding Error Response or Binding Response) to a Binding Request will terminate retransmissions of that request. However, clients MUST continue to listen for responses to a Binding Request for 10 seconds after the first response. If it receives any responses in this interval with different message types (Binding Responses and Binding Error Responses, for example) or different MAPPED-ADDRESSes, it is an indication of a possible attack. The client MUST NOT use the MAPPED-ADDRESS from any of the responses it received (either the first or the additional ones), and SHOULD alert the user.",
      "ja": "拘束力のある要求に対する応答（バインディングエラー応答または結合応答のいずれか）の受信は、その要求の再送信を終了します。ただし、クライアントは、最初の応答の後に10秒間拘束力のあるリクエストに対する応答を聞き続ける必要があります。この間隔で、異なるメッセージタイプ（バインディング応答や結合エラー応答など）または異なるマッピングされたアドレスを使用して応答を受信した場合、それは攻撃の可能性を示しています。クライアントは、受け取った応答（最初のものまたは追加の応答）のいずれかからマッピングされたアドレスを使用してはならず、ユーザーに警告する必要があります。"
    },
    {
      "indent": 3,
      "text": "Furthermore, if a client receives more than twice as many Binding Responses as the number of Binding Requests it sent, it MUST NOT use the MAPPED-ADDRESS from any of those responses, and SHOULD alert the user about a potential attack.",
      "ja": "さらに、クライアントが送信したバインディングリクエストの数の2倍以上のバインディング応答を受信した場合、それらの応答のいずれかからマッピングされたアドレスを使用してはならず、潜在的な攻撃についてユーザーに警告する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the Binding Response is authenticated, and the MAPPED-ADDRESS was not discarded because of a potential attack, the CLIENT MAY use the MAPPED-ADDRESS and SOURCE-ADDRESS attributes.",
      "ja": "バインディング応答が認証されており、マッピングされたアドレスが潜在的な攻撃のために破棄されなかった場合、クライアントはマッピングされたアドレスおよびソースアドレス属性を使用する場合があります。"
    },
    {
      "indent": 0,
      "text": "10. Use Cases",
      "section_title": true,
      "ja": "10. ユースケース"
    },
    {
      "indent": 3,
      "text": "The rules of Sections 8 and 9 describe exactly how a client and server interact to send requests and get responses. However, they do not dictate how the STUN protocol is used to accomplish useful tasks. That is at the discretion of the client. Here, we provide some useful scenarios for applying STUN.",
      "ja": "セクション8および9のルールでは、クライアントとサーバーがどのように対話してリクエストを送信して応答を取得するかを正確に説明しています。ただし、STUNプロトコルがどのように使用されて有用なタスクを達成するかを決定しません。それはクライアントの裁量にあります。ここでは、Stunを適用するためのいくつかの便利なシナリオを提供します。"
    },
    {
      "indent": 0,
      "text": "10.1 Discovery Process",
      "section_title": true,
      "ja": "10.1 発見プロセス"
    },
    {
      "indent": 3,
      "text": "In this scenario, a user is running a multimedia application which needs to determine which of the following scenarios applies to it:",
      "ja": "このシナリオでは、ユーザーがマルチメディアアプリケーションを実行しているため、次のシナリオのどれが適用されるかを判断する必要があります。"
    },
    {
      "indent": 3,
      "text": "o On the open Internet",
      "ja": "o オープンインターネットで"
    },
    {
      "indent": 3,
      "text": "o Firewall that blocks UDP",
      "ja": "o UDPをブロックするファイアウォール"
    },
    {
      "indent": 3,
      "text": "o Firewall that allows UDP out, and responses have to come back to the source of the request (like a symmetric NAT, but no translation. We call this a symmetric UDP Firewall)",
      "ja": "o UDPを可能にするファイアウォールと応答は、リクエストのソースに戻る必要があります（対称NATのように、翻訳はありません。これを対称UDPファイアウォールと呼びます）"
    },
    {
      "indent": 3,
      "text": "o Full-cone NAT",
      "ja": "o フルコーンナット"
    },
    {
      "indent": 3,
      "text": "o Symmetric NAT",
      "ja": "o 対称NAT"
    },
    {
      "indent": 3,
      "text": "o Restricted cone or restricted port cone NAT",
      "ja": "o 制限付きコーンまたは制限付きポートコーンNAT"
    },
    {
      "indent": 3,
      "text": "Which of the six scenarios applies can be determined through the flow chart described in Figure 2. The chart refers only to the sequence of Binding Requests; Shared Secret Requests will, of course, be needed to authenticate each Binding Request used in the sequence.",
      "ja": "6つのシナリオのうち、図2で説明するフローチャートを介して適用されるのはどれですか。チャートは、バインディングリクエストのシーケンスのみを指します。もちろん、共有された秘密のリクエストは、シーケンスで使用される各バインディングリクエストを認証するために必要です。"
    },
    {
      "indent": 3,
      "text": "The flow makes use of three tests. In test I, the client sends a STUN Binding Request to a server, without any flags set in the CHANGE-REQUEST attribute, and without the RESPONSE-ADDRESS attribute. This causes the server to send the response back to the address and port that the request came from. In test II, the client sends a Binding Request with both the \"change IP\" and \"change port\" flags from the CHANGE-REQUEST attribute set. In test III, the client sends a Binding Request with only the \"change port\" flag set.",
      "ja": "フローは3つのテストを使用します。テストIでは、クライアントは、変更リクエスト属性にフラグが設定されておらず、応答とアドレス属性なしで、スタンバインディングリクエストをサーバーに送信します。これにより、サーバーはリクエストが由来するアドレスとポートに応答を送り返します。テストIIでは、クライアントは、「Change-IP」と「Change Port」フラグの両方をChange-Request属性セットから送信します。テストIIIでは、クライアントは「変更ポート」フラグのみを使用して拘束力のあるリクエストを送信します。"
    },
    {
      "indent": 3,
      "text": "The client begins by initiating test I. If this test yields no response, the client knows right away that it is not capable of UDP connectivity. If the test produces a response, the client examines the MAPPED-ADDRESS attribute. If this address and port are the same as the local IP address and port of the socket used to send the request, the client knows that it is not natted. It executes test II.",
      "ja": "クライアントはテストIを開始することから始めます。このテストで応答がない場合、クライアントはUDP接続ができないことをすぐに知っています。テストが応答を生成する場合、クライアントはマッピングされたアドレス属性を調べます。このアドレスとポートが、リクエストの送信に使用されるローカルIPアドレスとソケットのポートと同じである場合、クライアントはそれがナットではないことを知っています。テストIIを実行します。"
    },
    {
      "indent": 3,
      "text": "If a response is received, the client knows that it has open access to the Internet (or, at least, its behind a firewall that behaves like a full-cone NAT, but without the translation). If no response is received, the client knows its behind a symmetric UDP firewall.",
      "ja": "応答が受信された場合、クライアントはインターネットへのオープンアクセスがあることを知っています（または、少なくとも、フルコーンNATのように振る舞うが、翻訳なしで動作するファイアウォールの後ろに）。応答がない場合、クライアントは対称UDPファイアウォールの背後にあることを知っています。"
    },
    {
      "indent": 3,
      "text": "In the event that the IP address and port of the socket did not match the MAPPED-ADDRESS attribute in the response to test I, the client knows that it is behind a NAT. It performs test II. If a response is received, the client knows that it is behind a full-cone NAT. If no response is received, it performs test I again, but this time, does so to the address and port from the CHANGED-ADDRESS attribute from the response to test I. If the IP address and port returned in the MAPPED-ADDRESS attribute are not the same as the ones from the first test I, the client knows its behind a symmetric NAT. If the address and port are the same, the client is either behind a restricted or port restricted NAT. To make a determination about which one it is behind, the client initiates test III. If a response is received, its behind a restricted NAT, and if no response is received, its behind a port restricted NAT.",
      "ja": "ソケットのIPアドレスとポートが、テストIへの応答でマッピングされたアドレス属性と一致しなかった場合、クライアントはそれがNATの背後にあることを知っています。テストIIを実行します。応答が受信された場合、クライアントはそれがフルコーンNATの背後にあることを知っています。応答がない場合、それは再びテストを実行しますが、今回は、変更されたアドレスドレス属性からのアドレスとポートに、回答からテストIへのポートにそれを行います。最初のテストIのものと同じではありません。クライアントは、対称NATの背後にあることを知っています。アドレスとポートが同じ場合、クライアントは制限付きまたはポート制限NATの背後にいます。どちらの背後にあるかを決定するために、クライアントはテストIIIを開始します。応答が受信された場合、制限付きNATの後ろに、および応答がない場合、ポート制限NATの後ろに。"
    },
    {
      "indent": 3,
      "text": "This procedure yields substantial information about the operating condition of the client application. In the event of multiple NATs between the client and the Internet, the type that is discovered will be the type of the most restrictive NAT between the client and the Internet. The types of NAT, in order of restrictiveness, from most to least, are symmetric, port restricted cone, restricted cone, and full cone.",
      "ja": "この手順により、クライアントアプリケーションの動作条件に関するかなりの情報が得られます。クライアントとインターネットの間に複数のNATが発生した場合、発見されるタイプは、クライアントとインターネットの間の最も制限的なNATのタイプになります。制限の順に、最小限から最小限のNATのタイプは、対称、ポート制限コーン、制限された円錐形、および完全な円錐です。"
    },
    {
      "indent": 3,
      "text": "Typically, a client will re-do this discovery process periodically to detect changes, or look for inconsistent results. It is important to note that when the discovery process is redone, it should not generally be done from the same local address and port used in the previous discovery process. If the same local address and port are reused, bindings from the previous test may still be in existence, and these will invalidate the results of the test. Using a different local address and port for subsequent tests resolves this problem. An alternative is to wait sufficiently long to be confident that the old bindings have expired (half an hour should more than suffice).",
      "ja": "通常、クライアントは、この発見プロセスを定期的に改装して変更を検出するか、一貫性のない結果を探します。発見プロセスがやり直されている場合、通常、以前の発見プロセスで使用されていた同じローカルアドレスとポートから行うべきではないことに注意することが重要です。同じローカルアドレスとポートが再利用されている場合、前のテストからのバインディングがまだ存在している可能性があり、これらはテストの結果を無効にします。以降のテストに別のローカルアドレスとポートを使用すると、この問題が解決します。別の方法は、古いバインディングが期限切れになっていると確信するために十分に長い間待つことです（十分な場合は30分以上）。"
    },
    {
      "indent": 0,
      "text": "10.2 Binding Lifetime Discovery",
      "section_title": true,
      "ja": "10.2 結合寿命の発見"
    },
    {
      "indent": 3,
      "text": "STUN can also be used to discover the lifetimes of the bindings created by the NAT. In many cases, the client will need to refresh the binding, either through a new STUN request, or an application packet, in order for the application to continue to use the binding. By discovering the binding lifetime, the client can determine how frequently it needs to refresh.",
      "ja": "Stunは、NATによって作成されたバインディングの寿命を発見するためにも使用できます。多くの場合、クライアントは、アプリケーションがバインディングを引き続き使用し続けるために、新しいスタン要求またはアプリケーションパケットのいずれかを介してバインディングを更新する必要があります。バインディングライフタイムを発見することにより、クライアントは更新する頻度を判断できます。"
    },
    {
      "indent": 3,
      "text": "                     +--------+\n                     |  Test  |\n                     |   I    |\n                     +--------+\n                          |\n                          |\n                          V\n                         /\\              /\\\n                      N /  \\ Y          /  \\ Y             +--------+\n       UDP     <-------/Resp\\--------->/ IP \\------------->|  Test  |\n       Blocked         \\ ?  /          \\Same/              |   II   |\n                        \\  /            \\? /               +--------+\n                         \\/              \\/                    |\n                                          | N                  |\n                                          |                    V\n                                          V                    /\\\n                                      +--------+  Sym.      N /  \\\n                                      |  Test  |  UDP    <---/Resp\\\n                                      |   II   |  Firewall   \\ ?  /\n                                      +--------+              \\  /\n                                          |                    \\/\n                                          V                     |Y\n               /\\                         /\\                    |\nSymmetric  N  /  \\       +--------+   N  /  \\                   V\n   NAT  <--- / IP \\<-----|  Test  |<--- /Resp\\               Open\n             \\Same/      |   I    |     \\ ?  /               Internet\n              \\? /       +--------+      \\  /\n               \\/                         \\/\n               |                           |Y\n               |                           |\n               |                           V\n               |                           Full\n               |                           Cone\n               V              /\\\n           +--------+        /  \\ Y\n           |  Test  |------>/Resp\\---->Restricted\n           |   III  |       \\ ?  /\n           +--------+        \\  /\n                              \\/\n                               |N\n                               |       Port\n                               +------>Restricted",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 2: Flow for type discovery process",
      "ja": "図2：タイプ発見プロセスのフロー"
    },
    {
      "indent": 3,
      "text": "To determine the binding lifetime, the client first sends a Binding Request to the server from a particular socket, X. This creates a binding in the NAT. The response from the server contains a MAPPED-ADDRESS attribute, providing the public address and port on the NAT. Call this Pa and Pp, respectively. The client then starts a timer with a value of T seconds. When this timer fires, the client sends another Binding Request to the server, using the same destination address and port, but from a different socket, Y. This request contains a RESPONSE-ADDRESS address attribute, set to (Pa,Pp). This will create a new binding on the NAT, and cause the STUN server to send a Binding Response that would match the old binding, if it still exists. If the client receives the Binding Response on socket X, it knows that the binding has not expired. If the client receives the Binding Response on socket Y (which is possible if the old binding expired, and the NAT allocated the same public address and port to the new binding), or receives no response at all, it knows that the binding has expired.",
      "ja": "バインディングライフタイムを決定するために、クライアントは最初に特定のソケットXからサーバーにバインディングリクエストを送信します。これにより、NATにバインディングが作成されます。サーバーからの応答には、マッピングされたアドレス属性が含まれており、NATにパブリックアドレスとポートを提供します。それぞれこのPAとPPを呼び出します。次に、クライアントはT秒の値でタイマーを開始します。このタイマーが発射すると、クライアントは同じ宛先アドレスとポートを使用して別のバインディングリクエストをサーバーに送信しますが、異なるソケットからYを使用します。この要求には、（PA、PP）に設定された応答アドレスアドレス属性が含まれます。これにより、NATの新しいバインディングが作成され、Stunサーバーがまだ存在する場合、古いバインディングに一致するバインディング応答を送信します。クライアントがソケットXでバインディング応答を受信した場合、バインディングが期限切れになっていないことがわかっています。クライアントがソケットYのバインディング応答を受信し（古いバインディングが失効し、NATが同じパブリックアドレスと新しいバインディングにポートを割り当てた場合に可能です）、またはまったく応答を受け取らない場合、バインディングが期限切れになったことを知っています。"
    },
    {
      "indent": 3,
      "text": "The client can find the value of the binding lifetime by doing a binary search through T, arriving eventually at the value where the response is not received for any timer greater than T, but is received for any timer less than T.",
      "ja": "クライアントは、Tを介してバイナリ検索を行うことで結合寿命の値を見つけることができ、最終的にはTよりも大きなタイマーに対して応答が受信されない値に到達しますが、Tよりも少ないタイマーに対して受信されます。"
    },
    {
      "indent": 3,
      "text": "This discovery process takes quite a bit of time, and is something that will typically be run in the background on a device once it boots.",
      "ja": "この発見プロセスにはかなりの時間がかかり、通常、デバイスが起動するとバックグラウンドで実行されるものです。"
    },
    {
      "indent": 3,
      "text": "It is possible that the client can get inconsistent results each time this process is run. For example, if the NAT should reboot, or be reset for some reason, the process may discover a lifetime than is shorter than the actual one. For this reason, implementations are encouraged to run the test numerous times, and be prepared to get inconsistent results.",
      "ja": "このプロセスが実行されるたびに、クライアントが一貫性のない結果を得ることができる可能性があります。たとえば、NATが再起動するか、何らかの理由でリセットする場合、プロセスは実際のものよりも短いよりも寿命を発見する場合があります。このため、実装はテストを何度も実行し、一貫性のない結果を得るために準備することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "10.3 Binding Acquisition",
      "section_title": true,
      "ja": "10.3 拘束力のある獲得"
    },
    {
      "indent": 3,
      "text": "Consider once more the case of a VoIP phone. It used the discovery process above when it started up, to discover its environment. Now, it wants to make a call. As part of the discovery process, it determined that it was behind a full-cone NAT.",
      "ja": "もう一度VoIP電話の場合を検討してください。環境を発見するために、上記の上記の発見プロセスを使用しました。今、それは電話をかけたいです。発見プロセスの一環として、それはフルコーンNATの背後にあると判断しました。"
    },
    {
      "indent": 3,
      "text": "Consider further that this phone consists of two logically separated components - a control component that handles signaling, and a media component that handles the audio, video, and RTP [12]. Both are behind the same NAT. Because of this separation of control and media, we wish to minimize the communication required between them. In fact, they may not even run on the same host.",
      "ja": "さらに、この携帯電話は、2つの論理的に分離されたコンポーネントで構成されていることを考えてください。シグナリングを処理する制御コンポーネントと、オーディオ、ビデオ、およびRTPを処理するメディアコンポーネント[12]で構成されていることを考えてください。どちらも同じNATの後ろにあります。このコントロールとメディアの分離により、それらの間で必要なコミュニケーションを最小限に抑えたいと考えています。実際、彼らは同じホストでも走らないかもしれません。"
    },
    {
      "indent": 3,
      "text": "In order to make a voice call, the phone needs to obtain an IP address and port that it can place in the call setup message as the destination for receiving audio.",
      "ja": "音声通話を行うために、電話は音声を受信する宛先としてコールセットアップメッセージに配置できるIPアドレスとポートを取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "To obtain an address, the control component sends a Shared Secret Request to the server, obtains a shared secret, and then sends a Binding Request to the server. No CHANGE-REQUEST attribute is present in the Binding Request, and neither is the RESPONSE-ADDRESS attribute. The Binding Response contains a mapped address. The control component then formulates a second Binding Request. This request contains a RESPONSE-ADDRESS, which is set to the mapped address learned from the previous Binding Response. This Binding Request is passed to the media component, along with the IP address and port of the STUN server. The media component sends the Binding Request. The request goes to the STUN server, which sends the Binding Response back to the control component. The control component receives this, and now has learned an IP address and port that will be routed back to the media component that sent the request.",
      "ja": "アドレスを取得するには、コントロールコンポーネントがサーバーに共有秘密のリクエストを送信し、共有シークレットを取得し、サーバーにバインディングリクエストを送信します。バインディングリクエストには、変更リクエスト属性は存在しません。また、応答アドレス属性も存在しません。バインディング応答には、マッピングされたアドレスが含まれています。次に、制御コンポーネントは2番目のバインディングリクエストを定式化します。このリクエストには、以前のバインディング応答から学習されたマップされたアドレスに設定された応答アドレスが含まれています。このバインディング要求は、STUNサーバーのIPアドレスとポートとともに、メディアコンポーネントに渡されます。メディアコンポーネントは拘束力のあるリクエストを送信します。リクエストは、バインディング応答を制御コンポーネントに送り返すStunサーバーに送られます。制御コンポーネントはこれを受信し、リクエストを送信したメディアコンポーネントにルーティングされるIPアドレスとポートを学習しました。"
    },
    {
      "indent": 3,
      "text": "The client will be able to receive media from anywhere on this mapped address.",
      "ja": "クライアントは、このマッピングされたアドレスのどこからでもメディアを受信できます。"
    },
    {
      "indent": 3,
      "text": "In the case of silence suppression, there may be periods where the client receives no media. In this case, the UDP bindings could timeout (UDP bindings in NATs are typically short; 30 seconds is common). To deal with this, the application can periodically retransmit the query in order to keep the binding fresh.",
      "ja": "沈黙の抑制の場合、クライアントがメディアを受け取らない期間があるかもしれません。この場合、UDPバインディングはタイムアウトできます（NATのUDPバインディングは通常短いですが、30秒は一般的です）。これに対処するために、アプリケーションはバインディングを新鮮に保つために定期的にクエリを再送信できます。"
    },
    {
      "indent": 3,
      "text": "It is possible that both participants in the multimedia session are behind the same NAT. In that case, both will repeat this procedure above, and both will obtain public address bindings. When one sends media to the other, the media is routed to the NAT, and then turns right back around to come back into the enterprise, where it is translated to the private address of the recipient. This is not particularly efficient, and unfortunately, does not work in many commercial NATs. In such cases, the clients may need to retry using private addresses.",
      "ja": "マルチメディアセッションの両方の参加者が同じNATの背後にいる可能性があります。その場合、どちらも上記のこの手順を繰り返し、両方ともパブリックアドレスバインディングを取得します。一方がメディアを他方に送ると、メディアはNATにルーティングされ、すぐに戻って企業に戻り、受信者のプライベートアドレスに翻訳されます。これは特に効率的ではありませんが、残念ながら、多くの商業NATでは機能しません。そのような場合、クライアントはプライベートアドレスを使用して再試行する必要がある場合があります。"
    },
    {
      "indent": 0,
      "text": "11. Protocol Details",
      "section_title": true,
      "ja": "11. プロトコルの詳細"
    },
    {
      "indent": 3,
      "text": "This section presents the detailed encoding of a STUN message.",
      "ja": "このセクションでは、スタンメッセージの詳細なエンコードを示します。"
    },
    {
      "indent": 3,
      "text": "STUN is a request-response protocol. Clients send a request, and the server sends a response. There are two requests, Binding Request, and Shared Secret Request. The response to a Binding Request can either be the Binding Response or Binding Error Response. The response to a Shared Secret Request can either be a Shared Secret Response or a Shared Secret Error Response.",
      "ja": "Stunはリクエスト応答プロトコルです。クライアントはリクエストを送信し、サーバーは応答を送信します。2つのリクエスト、拘束力のあるリクエスト、共有秘密のリクエストがあります。結合要求に対する応答は、バインディング応答または結合エラー応答のいずれかです。共有された秘密要求に対する応答は、共有された秘密の応答または共有秘密のエラー応答のいずれかです。"
    },
    {
      "indent": 3,
      "text": "STUN messages are encoded using binary fields. All integer fields are carried in network byte order, that is, most significant byte (octet) first. This byte order is commonly known as big-endian. The transmission order is described in detail in Appendix B of RFC 791 [6]. Unless otherwise noted, numeric constants are in decimal (base 10).",
      "ja": "スタンメッセージは、バイナリフィールドを使用してエンコードされます。すべての整数フィールドは、ネットワークバイトの順序で運ばれます。つまり、最初に最も重要なバイト（Octet）です。このバイト順序は、一般にビッグエンディアンとして知られています。伝送順序については、RFC 791 [6]の付録Bで詳しく説明しています。特に明記しない限り、数値定数は10進数です（ベース10）。"
    },
    {
      "indent": 0,
      "text": "11.1 Message Header",
      "section_title": true,
      "ja": "11.1 メッセージヘッダー"
    },
    {
      "indent": 3,
      "text": "All STUN messages consist of a 20 byte header:",
      "ja": "すべてのスタンメッセージは、20バイトのヘッダーで構成されています。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      STUN Message Type        |         Message Length        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                         Transaction ID\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                                                                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Message Types can take on the following values:",
      "ja": "メッセージタイプは、次の値を取ることができます。"
    },
    {
      "indent": 6,
      "text": "0x0001 : Binding Request 0x0101 : Binding Response 0x0111 : Binding Error Response 0x0002 : Shared Secret Request 0x0102 : Shared Secret Response 0x0112 : Shared Secret Error Response",
      "ja": "0x0001：バインディングリクエスト0x0101：バインディング応答0x0111：バインディングエラー応答0x0002：共有シークレットリクエスト0x0102：共有シークレット応答0x0112：共有シークレットエラー応答"
    },
    {
      "indent": 3,
      "text": "The message length is the count, in bytes, of the size of the message, not including the 20 byte header.",
      "ja": "メッセージの長さは、20バイトヘッダーを含まないメッセージのサイズのカウントです。"
    },
    {
      "indent": 3,
      "text": "The transaction ID is a 128 bit identifier. It also serves as salt to randomize the request and the response. All responses carry the same identifier as the request they correspond to.",
      "ja": "トランザクションIDは128ビット識別子です。また、リクエストと応答をランダム化するための塩としても機能します。すべての応答には、対応する要求と同じ識別子が含まれます。"
    },
    {
      "indent": 0,
      "text": "11.2 Message Attributes",
      "section_title": true,
      "ja": "11.2 メッセージ属性"
    },
    {
      "indent": 3,
      "text": "After the header are 0 or more attributes. Each attribute is TLV encoded, with a 16 bit type, 16 bit length, and variable value:",
      "ja": "ヘッダーが0以上の属性の後。各属性はTLVエンコードされており、16ビットタイプ、16ビットの長さ、可変値："
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Type                  |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             Value                             ....\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following types are defined:",
      "ja": "次のタイプが定義されています。"
    },
    {
      "indent": 3,
      "text": "0x0001: MAPPED-ADDRESS 0x0002: RESPONSE-ADDRESS 0x0003: CHANGE-REQUEST 0x0004: SOURCE-ADDRESS 0x0005: CHANGED-ADDRESS 0x0006: USERNAME 0x0007: PASSWORD 0x0008: MESSAGE-INTEGRITY 0x0009: ERROR-CODE 0x000a: UNKNOWN-ATTRIBUTES 0x000b: REFLECTED-FROM",
      "ja": "0x0001：マッピングされたアドレス0x0002：Response-Address 0x0003：Change-Request 0x0004：Source-Address 0x0005：変更-Address 0x0006：Username 0x0007：パスワード0x0008：Message-Integrity 0x0009：エラーコード0x000aから"
    },
    {
      "indent": 3,
      "text": "To allow future revisions of this specification to add new attributes if needed, the attribute space is divided into optional and mandatory ones. Attributes with values greater than 0x7fff are optional, which means that the message can be processed by the client or server even though the attribute is not understood. Attributes with values less than or equal to 0x7fff are mandatory to understand, which means that the client or server cannot process the message unless it understands the attribute.",
      "ja": "この仕様の将来の改訂を可能にして、必要に応じて新しい属性を追加するために、属性スペースはオプションの属性と必須の属性に分割されます。0x7FFFを超える値を持つ属性はオプションです。つまり、属性が理解されていない場合でも、メッセージはクライアントまたはサーバーによって処理できます。0x7FFF以下の値を持つ属性は理解することが必須です。つまり、属性を理解しない限り、クライアントまたはサーバーはメッセージを処理できません。"
    },
    {
      "indent": 3,
      "text": "The MESSAGE-INTEGRITY attribute MUST be the last attribute within a message. Any attributes that are known, but are not supposed to be present in a message (MAPPED-ADDRESS in a request, for example) MUST be ignored.",
      "ja": "メッセージインテグリティ属性は、メッセージ内の最後の属性でなければなりません。既知の属性ですが、メッセージに存在することは想定されていません（たとえば、リクエストのマッピングされたアドレスなど）は無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Table 2 indicates which attributes are present in which messages. An M indicates that inclusion of the attribute in the message is mandatory, O means its optional, C means it's conditional based on some other aspect of the message, and N/A means that the attribute is not applicable to that message type.",
      "ja": "表2は、メッセージがどの属性が存在するかを示しています。mは、メッセージに属性を含めることが必須であることを示し、oはそのオプションを意味し、cはメッセージの他の側面に基づいて条件付きであり、n/aは属性がそのメッセージタイプに適用されないことを意味します。"
    },
    {
      "indent": 3,
      "text": "                                      Binding  Shared  Shared  Shared\n                    Binding  Binding  Error    Secret  Secret  Secret\nAtt.                Req.     Resp.    Resp.    Req.    Resp.   Error\n                                                               Resp.\n_____________________________________________________________________\nMAPPED-ADDRESS      N/A      M        N/A      N/A     N/A     N/A\nRESPONSE-ADDRESS    O        N/A      N/A      N/A     N/A     N/A\nCHANGE-REQUEST      O        N/A      N/A      N/A     N/A     N/A\nSOURCE-ADDRESS      N/A      M        N/A      N/A     N/A     N/A\nCHANGED-ADDRESS     N/A      M        N/A      N/A     N/A     N/A\nUSERNAME            O        N/A      N/A      N/A     M       N/A\nPASSWORD            N/A      N/A      N/A      N/A     M       N/A\nMESSAGE-INTEGRITY   O        O        N/A      N/A     N/A     N/A\nERROR-CODE          N/A      N/A      M        N/A     N/A     M\nUNKNOWN-ATTRIBUTES  N/A      N/A      C        N/A     N/A     C\nREFLECTED-FROM      N/A      C        N/A      N/A     N/A     N/A",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Table 2: Summary of Attributes",
      "ja": "表2：属性の概要"
    },
    {
      "indent": 3,
      "text": "The length refers to the length of the value element, expressed as an unsigned integral number of bytes.",
      "ja": "長さは、バイトの積分数として表される値要素の長さを指します。"
    },
    {
      "indent": 0,
      "text": "11.2.1 MAPPED-ADDRESS",
      "section_title": true,
      "ja": "11.2.1 マッピングされたアドレス"
    },
    {
      "indent": 3,
      "text": "The MAPPED-ADDRESS attribute indicates the mapped IP address and port. It consists of an eight bit address family, and a sixteen bit port, followed by a fixed length value representing the IP address.",
      "ja": "マッピングされたアドレス属性は、マッピングされたIPアドレスとポートを示します。8ビットアドレスファミリと16ビットポートで構成され、その後、IPアドレスを表す固定長い値が続きます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|x x x x x x x x|    Family     |           Port                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             Address                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The port is a network byte ordered representation of the mapped port. The address family is always 0x01, corresponding to IPv4. The first 8 bits of the MAPPED-ADDRESS are ignored, for the purposes of aligning parameters on natural boundaries. The IPv4 address is 32 bits.",
      "ja": "ポートは、マッピングされたポートのネットワークバイト順序付けられた表現です。アドレスファミリは常に0x01で、IPv4に対応しています。自然境界にパラメーターを調整する目的で、マッピングされたアドレスの最初の8ビットは無視されます。IPv4アドレスは32ビットです。"
    },
    {
      "indent": 0,
      "text": "11.2.2 RESPONSE-ADDRESS",
      "section_title": true,
      "ja": "11.2.2 応答 - アドレス"
    },
    {
      "indent": 3,
      "text": "The RESPONSE-ADDRESS attribute indicates where the response to a Binding Request should be sent. Its syntax is identical to MAPPED-ADDRESS.",
      "ja": "Response-Address属性は、拘束力のあるリクエストへの応答を送信する場所を示します。その構文は、マッピングされたアドレスと同じです。"
    },
    {
      "indent": 0,
      "text": "11.2.3 CHANGED-ADDRESS",
      "section_title": true,
      "ja": "11.2.3 変更 - アドレス"
    },
    {
      "indent": 3,
      "text": "The CHANGED-ADDRESS attribute indicates the IP address and port where responses would have been sent from if the \"change IP\" and \"change port\" flags had been set in the CHANGE-REQUEST attribute of the Binding Request. The attribute is always present in a Binding Response, independent of the value of the flags. Its syntax is identical to MAPPED-ADDRESS.",
      "ja": "変更されたアドレス属性は、「IPの変更」と「変更」フラグがバインディングリクエストの変更要求属性に設定されていた場合、応答が送信されるIPアドレスとポートを示します。属性は、フラグの値とは無関係に、常に拘束力のある応答に存在します。その構文は、マッピングされたアドレスと同じです。"
    },
    {
      "indent": 0,
      "text": "11.2.4 CHANGE-REQUEST",
      "section_title": true,
      "ja": "11.2.4 変更要求"
    },
    {
      "indent": 3,
      "text": "The CHANGE-REQUEST attribute is used by the client to request that the server use a different address and/or port when sending the response. The attribute is 32 bits long, although only two bits (A and B) are used:",
      "ja": "Change-Request属性は、応答を送信するときにサーバーが異なるアドレスおよび/またはポートを使用するようにクライアントが要求するために使用されます。属性の長さは32ビットですが、2ビット（AとB）のみが使用されます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 A B 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The meaning of the flags is:",
      "ja": "フラグの意味は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "A: This is the \"change IP\" flag. If true, it requests the server to send the Binding Response with a different IP address than the one the Binding Request was received on.",
      "ja": "A：これは「IPの変更」フラグです。Trueの場合、拘束力のあるリクエストが受信されたものとは異なるIPアドレスでバインディング応答を送信するようサーバーに要求します。"
    },
    {
      "indent": 3,
      "text": "B: This is the \"change port\" flag. If true, it requests the server to send the Binding Response with a different port than the one the Binding Request was received on.",
      "ja": "B：これは「ポートの変更」フラグです。Trueの場合、拘束力のある要求が受信されたポートとは異なるポートでバインディング応答を送信するようサーバーに要求します。"
    },
    {
      "indent": 0,
      "text": "11.2.5 SOURCE-ADDRESS",
      "section_title": true,
      "ja": "11.2.5 ソースアドレス"
    },
    {
      "indent": 3,
      "text": "The SOURCE-ADDRESS attribute is present in Binding Responses. It indicates the source IP address and port that the server is sending the response from. Its syntax is identical to that of MAPPED-ADDRESS.",
      "ja": "ソースアドレス属性は、結合応答に存在します。サーバーが応答を送信しているソースIPアドレスとポートを示します。その構文は、マッピングされたアドレスの構文と同じです。"
    },
    {
      "indent": 0,
      "text": "11.2.6 USERNAME",
      "section_title": true,
      "ja": "11.2.6 ユーザー名"
    },
    {
      "indent": 3,
      "text": "The USERNAME attribute is used for message integrity. It serves as a means to identify the shared secret used in the message integrity check. The USERNAME is always present in a Shared Secret Response, along with the PASSWORD. It is optionally present in a Binding Request when message integrity is used.",
      "ja": "ユーザー名属性は、メッセージの整合性に使用されます。メッセージの整合性チェックで使用される共有秘密を特定する手段として機能します。ユーザー名は、パスワードとともに、共有された秘密の応答で常に存在します。メッセージの整合性を使用すると、オプションで拘束力のある要求に存在します。"
    },
    {
      "indent": 3,
      "text": "The value of USERNAME is a variable length opaque value. Its length MUST be a multiple of 4 (measured in bytes) in order to guarantee alignment of attributes on word boundaries.",
      "ja": "ユーザー名の値は、可変長さの不透明値です。その長さは、単語の境界上の属性のアラインメントを保証するために、4の倍数（バイトで測定）でなければなりません。"
    },
    {
      "indent": 0,
      "text": "11.2.7 PASSWORD",
      "section_title": true,
      "ja": "11.2.7 パスワード"
    },
    {
      "indent": 3,
      "text": "The PASSWORD attribute is used in Shared Secret Responses. It is always present in a Shared Secret Response, along with the USERNAME.",
      "ja": "パスワード属性は、共有された秘密応答で使用されます。ユーザー名とともに、共有された秘密の応答に常に存在します。"
    },
    {
      "indent": 3,
      "text": "The value of PASSWORD is a variable length value that is to be used as a shared secret. Its length MUST be a multiple of 4 (measured in bytes) in order to guarantee alignment of attributes on word boundaries.",
      "ja": "パスワードの値は、共有秘密として使用される変動長値です。その長さは、単語の境界上の属性のアラインメントを保証するために、4の倍数（バイトで測定）でなければなりません。"
    },
    {
      "indent": 0,
      "text": "11.2.8 MESSAGE-INTEGRITY",
      "section_title": true,
      "ja": "11.2.8 メッセージインテグリティ"
    },
    {
      "indent": 3,
      "text": "The MESSAGE-INTEGRITY attribute contains an HMAC-SHA1 [13] of the STUN message. It can be present in Binding Requests or Binding Responses. Since it uses the SHA1 hash, the HMAC will be 20 bytes. The text used as input to HMAC is the STUN message, including the header, up to and including the attribute preceding the MESSAGE-INTEGRITY attribute. That text is then padded with zeroes so as to be a multiple of 64 bytes. As a result, the MESSAGE-INTEGRITY attribute MUST be the last attribute in any STUN message. The key used as input to HMAC depends on the context.",
      "ja": "メッセージインテグリティ属性には、スタンメッセージのHMAC-SHA1 [13]が含まれています。拘束力のある要求または拘束力のある応答に存在する可能性があります。SHA1ハッシュを使用するため、HMACは20バイトになります。HMACへの入力として使用されるテキストは、ヘッダーを含むスタンメッセージです。これは、メッセージIntegrity属性の前の属性までの属性を含むものです。そのテキストには、64バイトの倍数になるように、ゼロが詰め込まれています。その結果、メッセージインテグリティ属性は、スタンメッセージの最後の属性でなければなりません。HMACへの入力として使用されるキーは、コンテキストによって異なります。"
    },
    {
      "indent": 0,
      "text": "11.2.9 ERROR-CODE",
      "section_title": true,
      "ja": "11.2.9 エラーコード"
    },
    {
      "indent": 3,
      "text": "The ERROR-CODE attribute is present in the Binding Error Response and Shared Secret Error Response. It is a numeric value in the range of 100 to 699 plus a textual reason phrase encoded in UTF-8, and is consistent in its code assignments and semantics with SIP [10] and HTTP [15]. The reason phrase is meant for user consumption, and can be anything appropriate for the response code. The lengths of the reason phrases MUST be a multiple of 4 (measured in bytes). This can be accomplished by added spaces to the end of the text, if necessary. Recommended reason phrases for the defined response codes are presented below.",
      "ja": "エラーコード属性は、バインディングエラー応答と共有秘密エラー応答に存在します。これは、100〜699の範囲の数値であり、UTF-8でエンコードされたテキストの理由フレーズであり、SIP [10]およびHTTP [15]とのコード割り当てとセマンティクスで一貫しています。理由フレーズはユーザーの消費を対象としており、応答コードに適したものになる可能性があります。理由フレーズの長さは、4の倍数（バイトで測定）でなければなりません。これは、必要に応じて、テキストの最後に追加されたスペースによって実現できます。定義された応答コードの推奨理由フレーズを以下に示します。"
    },
    {
      "indent": 3,
      "text": "To facilitate processing, the class of the error code (the hundreds digit) is encoded separately from the rest of the code.",
      "ja": "処理を容易にするために、エラーコードのクラス（数百桁）は、コードの残りの部分とは別にエンコードされます。"
    },
    {
      "indent": 4,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   0                     |Class|     Number    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Reason Phrase (variable)                                ..\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The class represents the hundreds digit of the response code. The value MUST be between 1 and 6. The number represents the response code modulo 100, and its value MUST be between 0 and 99.",
      "ja": "クラスは、応答コードの数百桁を表します。値は1〜6でなければなりません。数値は応答コードModulo 100を表し、その値は0〜99でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following response codes, along with their recommended reason phrases (in brackets) are defined at this time:",
      "ja": "次の応答コードと、推奨される理由（括弧内）とともに、この時点で定義されています。"
    },
    {
      "indent": 3,
      "text": "400 (Bad Request): The request was malformed. The client should not retry the request without modification from the previous attempt.",
      "ja": "400（悪いリクエスト）：リクエストは奇形でした。クライアントは、以前の試みからの変更なしにリクエストを再試行しないでください。"
    },
    {
      "indent": 3,
      "text": "401 (Unauthorized): The Binding Request did not contain a MESSAGE-INTEGRITY attribute.",
      "ja": "401（不正）：バインディングリクエストには、メッセージインテグリティ属性が含まれていませんでした。"
    },
    {
      "indent": 3,
      "text": "420 (Unknown Attribute): The server did not understand a mandatory attribute in the request.",
      "ja": "420（不明な属性）：サーバーは、リクエストの必須属性を理解していませんでした。"
    },
    {
      "indent": 3,
      "text": "430 (Stale Credentials): The Binding Request did contain a MESSAGE-INTEGRITY attribute, but it used a shared secret that has expired. The client should obtain a new shared secret and try again.",
      "ja": "430（古い資格情報）：バインディングリクエストにはメッセージインテグリティ属性が含まれていましたが、有効期限が切れた共有秘密を使用しました。クライアントは、新しい共有の秘密を取得し、再試行する必要があります。"
    },
    {
      "indent": 3,
      "text": "431 (Integrity Check Failure): The Binding Request contained a MESSAGE-INTEGRITY attribute, but the HMAC failed verification. This could be a sign of a potential attack, or client implementation error.",
      "ja": "431（整合性チェックの障害）：バインディング要求にはメッセージインテグリティ属性が含まれていましたが、HMACは検証に失敗しました。これは、潜在的な攻撃、またはクライアントの実装エラーの兆候である可能性があります。"
    },
    {
      "indent": 3,
      "text": "432 (Missing Username): The Binding Request contained a MESSAGE-INTEGRITY attribute, but not a USERNAME attribute. Both must be present for integrity checks.",
      "ja": "432（Ussiond username）：バインディングリクエストには、メッセージIntegrity属性が含まれていましたが、ユーザー名属性は含まれていませんでした。両方とも整合性チェックのために存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "433 (Use TLS): The Shared Secret request has to be sent over TLS, but was not received over TLS.",
      "ja": "433（TLSを使用）：共有秘密の要求はTLSを介して送信する必要がありますが、TLSを介して受信されませんでした。"
    },
    {
      "indent": 3,
      "text": "500 (Server Error): The server has suffered a temporary error. The client should try again.",
      "ja": "500（サーバーエラー）：サーバーは一時的なエラーを受けました。クライアントは再試行する必要があります。"
    },
    {
      "indent": 3,
      "text": "600 (Global Failure:) The server is refusing to fulfill the request. The client should not retry.",
      "ja": "600（グローバル失敗:)サーバーはリクエストを満たすことを拒否しています。クライアントは再試行しないでください。"
    },
    {
      "indent": 0,
      "text": "11.2.10 UNKNOWN-ATTRIBUTES",
      "section_title": true,
      "ja": "11.2.10 未知のアトリビュート"
    },
    {
      "indent": 3,
      "text": "The UNKNOWN-ATTRIBUTES attribute is present only in a Binding Error Response or Shared Secret Error Response when the response code in the ERROR-CODE attribute is 420.",
      "ja": "未知のアトリビュート属性は、エラーコード属性の応答コードが420の場合、結合エラー応答または共有秘密エラー応答にのみ存在します。"
    },
    {
      "indent": 3,
      "text": "The attribute contains a list of 16 bit values, each of which represents an attribute type that was not understood by the server. If the number of unknown attributes is an odd number, one of the attributes MUST be repeated in the list, so that the total length of the list is a multiple of 4 bytes.",
      "ja": "属性には16ビット値のリストが含まれており、それぞれがサーバーによって理解されていない属性タイプを表します。不明な属性の数が奇数の場合、リストの総長さが4バイトの倍数になるように、属性の1つをリスト内で繰り返す必要があります。"
    },
    {
      "indent": 3,
      "text": "0                   1                   2                   3\n  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |      Attribute 1 Type           |     Attribute 2 Type        |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |      Attribute 3 Type           |     Attribute 4 Type    ...\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "11.2.11 REFLECTED-FROM",
      "section_title": true,
      "ja": "11.2.11 反射から"
    },
    {
      "indent": 3,
      "text": "The REFLECTED-FROM attribute is present only in Binding Responses, when the Binding Request contained a RESPONSE-ADDRESS attribute. The attribute contains the identity (in terms of IP address) of the source where the request came from. Its purpose is to provide traceability, so that a STUN server cannot be used as a reflector for denial-of-service attacks.",
      "ja": "反射属性は、バインディングリクエストに応答とアドレス属性が含まれていた場合にのみ、バインディング応答に存在します。属性には、要求が生じたソースのID（IPアドレスの観点から）が含まれます。その目的は、トゥンサーバーをサービス拒否攻撃のリフレクターとして使用できないように、トレーサビリティを提供することです。"
    },
    {
      "indent": 3,
      "text": "Its syntax is identical to the MAPPED-ADDRESS attribute.",
      "ja": "その構文は、マッピングされたアドレス属性と同じです。"
    },
    {
      "indent": 0,
      "text": "12. Security Considerations",
      "section_title": true,
      "ja": "12. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "12.1 Attacks on STUN",
      "section_title": true,
      "ja": "12.1 スタンへの攻撃"
    },
    {
      "indent": 3,
      "text": "Generally speaking, attacks on STUN can be classified into denial of service attacks and eavesdropping attacks. Denial of service attacks can be launched against a STUN server itself, or against other elements using the STUN protocol.",
      "ja": "一般的に言えば、スタンへの攻撃は、サービス攻撃の拒否と盗聴攻撃に分類できます。サービス拒否攻撃は、スタンサーバー自体、またはSTUNプロトコルを使用した他の要素に対して起動できます。"
    },
    {
      "indent": 3,
      "text": "STUN servers create state through the Shared Secret Request mechanism. To prevent being swamped with traffic, a STUN server SHOULD limit the number of simultaneous TLS connections it will hold open by dropping an existing connection when a new connection request arrives (based on an Least Recently Used (LRU) policy, for example). Similarly, it SHOULD limit the number of shared secrets it will store, in the event that the server is storing the shared secrets.",
      "ja": "STUNサーバーは、共有された秘密要求メカニズムを介して状態を作成します。トラフィックで圧倒されるのを防ぐために、スタンサーバーは、新しい接続要求が到着したときに既存の接続を削除することにより、同時にTLS接続の数を制限する必要があります（たとえば、最近使用されている（LRU）ポリシーに基づいて）。同様に、サーバーが共有秘密を保存している場合に、保存する共有秘密の数を制限する必要があります。"
    },
    {
      "indent": 3,
      "text": "The attacks of greater interest are those in which the STUN server and client are used to launch DOS attacks against other entities, including the client itself.",
      "ja": "より大きな関心のある攻撃は、STUNサーバーとクライアントがクライアント自体を含む他のエンティティに対するDOS攻撃を開始するために使用される攻撃です。"
    },
    {
      "indent": 3,
      "text": "Many of the attacks require the attacker to generate a response to a legitimate STUN request, in order to provide the client with a faked MAPPED-ADDRESS. The attacks that can be launched using such a technique include:",
      "ja": "攻撃の多くは、クライアントに偽造されたマッピングされたアドレスを提供するために、攻撃者が正当なスタン要求に対する応答を生成することを要求しています。このような手法を使用して起動できる攻撃には、次のものがあります。"
    },
    {
      "indent": 0,
      "text": "12.1.1 Attack I: DDOS Against a Target",
      "section_title": true,
      "ja": "12.1.1 攻撃I：ターゲットに対するDDO"
    },
    {
      "indent": 3,
      "text": "In this case, the attacker provides a large number of clients with the same faked MAPPED-ADDRESS that points to the intended target. This will trick all the STUN clients into thinking that their addresses are equal to that of the target. The clients then hand out that address in order to receive traffic on it (for example, in SIP or H.323 messages). However, all of that traffic becomes focused at the intended target. The attack can provide substantial amplification, especially when used with clients that are using STUN to enable multimedia applications.",
      "ja": "この場合、攻撃者は、意図したターゲットを指す同じ偽造マッピングされたアドレスを多数のクライアントに提供します。これにより、すべてのスタンクライアントがアドレスがターゲットのアドレスと等しいと考えるようになります。その後、クライアントはその住所を配布してトラフィックを受け取ります（たとえば、SIPまたはH.323メッセージ）。ただし、そのトラフィックはすべて、意図したターゲットに焦点を合わせます。この攻撃は、特にマルチメディアアプリケーションを有効にするためにスタンを使用しているクライアントで使用する場合、かなりの増幅を提供できます。"
    },
    {
      "indent": 0,
      "text": "12.1.2 Attack II: Silencing a Client",
      "section_title": true,
      "ja": "12.1.2 攻撃II：クライアントのサイレンシング"
    },
    {
      "indent": 3,
      "text": "In this attack, the attacker seeks to deny a client access to services enabled by STUN (for example, a client using STUN to enable SIP-based multimedia traffic). To do that, the attacker provides that client with a faked MAPPED-ADDRESS. The MAPPED-ADDRESS it provides is an IP address that routes to nowhere. As a result, the client won't receive any of the packets it expects to receive when it hands out the MAPPED-ADDRESS.",
      "ja": "この攻撃では、攻撃者はStunによって有効なサービスへのクライアントのアクセスを拒否しようとします（たとえば、STUNを使用してSIPベースのマルチメディアトラフィックを可能にするクライアント）。そのために、攻撃者はそのクライアントに偽造されたマッピングされたアドレスを提供します。それが提供するマッピングされたアドレスは、どこにもルーティングするIPアドレスです。その結果、クライアントは、マッピングされたアドレスを配布するときに受け取ると予想されるパケットを受け取ることはありません。"
    },
    {
      "indent": 3,
      "text": "This exploitation is not very interesting for the attacker. It impacts a single client, which is frequently not the desired target. Moreover, any attacker that can mount the attack could also deny service to the client by other means, such as preventing the client from receiving any response from the STUN server, or even a DHCP server.",
      "ja": "この搾取は、攻撃者にとってそれほど興味深いものではありません。それは単一のクライアントに影響を与えますが、これはしばしば目的のターゲットではありません。さらに、攻撃を攻撃することができる攻撃者は、クライアントがスタンサーバーやDHCPサーバーから応答を受信しないようにするなど、他の手段によってクライアントへのサービスを拒否する可能性もあります。"
    },
    {
      "indent": 0,
      "text": "12.1.3 Attack III: Assuming the Identity of a Client",
      "section_title": true,
      "ja": "12.1.3 攻撃III：クライアントの身元を仮定します"
    },
    {
      "indent": 3,
      "text": "This attack is similar to attack II. However, the faked MAPPED-ADDRESS points to the attacker themself. This allows the attacker to receive traffic which was destined for the client.",
      "ja": "この攻撃は攻撃IIに似ています。しかし、偽造されたマッピングされたアドレスは、攻撃者自身を指します。これにより、攻撃者はクライアント向けのトラフィックを受け取ることができます。"
    },
    {
      "indent": 0,
      "text": "12.1.4 Attack IV: Eavesdropping",
      "section_title": true,
      "ja": "12.1.4 攻撃IV：盗聴"
    },
    {
      "indent": 3,
      "text": "In this attack, the attacker forces the client to use a MAPPED-ADDRESS that routes to itself. It then forwards any packets it receives to the client. This attack would allow the attacker to observe all packets sent to the client. However, in order to launch the attack, the attacker must have already been able to observe packets from the client to the STUN server. In most cases (such as when the attack is launched from an access network), this means that the attacker could already observe packets sent to the client. This attack is, as a result, only useful for observing traffic by attackers on the path from the client to the STUN server, but not generally on the path of packets being routed towards the client.",
      "ja": "この攻撃では、攻撃者はクライアントにそれ自体にルーティングするマッピングされたアドレスを使用するように強制します。その後、受信するパケットをクライアントに転送します。この攻撃により、攻撃者はクライアントに送信されるすべてのパケットを観察することができます。ただし、攻撃を開始するために、攻撃者はすでにクライアントからStunサーバーへのパケットを観察できる必要があります。ほとんどの場合（アクセスネットワークから攻撃が起動されたときなど）、これは攻撃者がクライアントに送信されたパケットを既に観察できることを意味します。その結果、この攻撃は、クライアントからスタンサーバーへのパスへの攻撃者によるトラフィックを観察するのにのみ役立ちますが、一般的にクライアントにルーティングされているパケットのパスではありません。"
    },
    {
      "indent": 0,
      "text": "12.2 Launching the Attacks",
      "section_title": true,
      "ja": "12.2 攻撃を開始します"
    },
    {
      "indent": 3,
      "text": "It is important to note that attacks of this nature (injecting responses with fake MAPPED-ADDRESSes) require that the attacker be capable of eavesdropping requests sent from the client to the server (or to act as a MITM for such attacks). This is because STUN requests contain a transaction identifier, selected by the client, which is random with 128 bits of entropy. The server echoes this value in the response, and the client ignores any responses that don't have a matching transaction ID. Therefore, in order for an attacker to provide a faked response that is accepted by the client, the attacker needs to know what the transaction ID in the request was. The large amount of randomness, combined with the need to know when the client sends a request, precludes attacks that involve guessing the transaction ID.",
      "ja": "この性質の攻撃（偽のマッピングされたアドレスで応答を注入する）は、攻撃者がクライアントからサーバーに送信されるリクエストを盗聴することができる（またはそのような攻撃のMITMとして機能することが必要であることに注意することが重要です。これは、STUN要求にクライアントが選択したトランザクション識別子が含まれているためです。これは、128ビットのエントロピーでランダムです。サーバーは応答でこの値をエコーし、クライアントは一致するトランザクションIDを持たない応答を無視します。したがって、攻撃者がクライアントに受け入れられる偽の応答を提供するためには、攻撃者はリクエストのトランザクションIDが何であるかを知る必要があります。クライアントがリクエストを送信する時期を知る必要性と相まって、大量のランダム性は、トランザクションIDの推測を伴う攻撃を排除します。"
    },
    {
      "indent": 3,
      "text": "Since all of the above attacks rely on this one primitive - injecting a response with a faked MAPPED-ADDRESS - preventing the attacks is accomplished by preventing this one operation. To prevent it, we need to consider the various ways in which it can be accomplished. There are several:",
      "ja": "上記の攻撃はすべて、この1つのプリミティブに依存しているため、偽造されたマッピングされたアドレスで応答を注入することに依存しているため、この1つの操作を防ぐことで攻撃を防ぐことができます。それを防ぐには、それを達成できるさまざまな方法を考慮する必要があります。いくつかあります："
    },
    {
      "indent": 0,
      "text": "12.2.1 Approach I: Compromise a Legitimate STUN Server",
      "section_title": true,
      "ja": "12.2.1 アプローチI：正当なスタンサーバーを妥協します"
    },
    {
      "indent": 3,
      "text": "In this attack, the attacker compromises a legitimate STUN server through a virus or Trojan horse. Presumably, this would allow the attacker to take over the STUN server, and control the types of responses it generates.",
      "ja": "この攻撃では、攻撃者はウイルスまたはトロイの木馬を介して正当なスタンサーバーを妥協します。おそらく、これにより、攻撃者はスタンサーバーを引き継ぎ、生成する応答の種類を制御することができます。"
    },
    {
      "indent": 3,
      "text": "Compromise of a STUN server can also lead to discovery of open ports. Knowledge of an open port creates an opportunity for DoS attacks on those ports (or DDoS attacks if the traversed NAT is a full cone NAT). Discovering open ports is already fairly trivial using port probing, so this does not represent a major threat.",
      "ja": "スタンサーバーの妥協は、オープンポートの発見にもつながる可能性があります。オープンポートの知識は、これらのポートに対するDOS攻撃の機会を作成します（または、移動したNATが完全なコーンNATである場合、DDOS攻撃）。オープンポートの発見は、ポートプロービングを使用してすでにかなり些細なことであるため、これは大きな脅威ではありません。"
    },
    {
      "indent": 0,
      "text": "12.2.2 Approach II: DNS Attacks",
      "section_title": true,
      "ja": "12.2.2 アプローチII：DNS攻撃"
    },
    {
      "indent": 3,
      "text": "STUN servers are discovered using DNS SRV records. If an attacker can compromise the DNS, it can inject fake records which map a domain name to the IP address of a STUN server run by the attacker. This will allow it to inject fake responses to launch any of the attacks above.",
      "ja": "STUNサーバーは、DNS SRVレコードを使用して発見されます。攻撃者がDNSを侵害できる場合、ドメイン名を攻撃者が実行するスタンサーバーのIPアドレスにマッピングする偽のレコードを挿入できます。これにより、上記の攻撃のいずれかを起動するために偽の応答を注入できます。"
    },
    {
      "indent": 0,
      "text": "12.2.3 Approach III: Rogue Router or NAT",
      "section_title": true,
      "ja": "12.2.3 アプローチIII：ローグルーターまたはナット"
    },
    {
      "indent": 3,
      "text": "Rather than compromise the STUN server, an attacker can cause a STUN server to generate responses with the wrong MAPPED-ADDRESS by compromising a router or NAT on the path from the client to the STUN server. When the STUN request passes through the rogue router or NAT, it rewrites the source address of the packet to be that of the desired MAPPED-ADDRESS. This address cannot be arbitrary. If the attacker is on the public Internet (that is, there are no NATs between it and the STUN server), and the attacker doesn't modify the STUN request, the address has to have the property that packets sent from the STUN server to that address would route through the compromised router. This is because the STUN server will send the responses back to the source address of the request. With a modified source address, the only way they can reach the client is if the compromised router directs them there. If the attacker is on the public Internet, but they can modify the STUN request, they can insert a RESPONSE-ADDRESS attribute into the request, containing the actual source address of the STUN request. This will cause the server to send the response to the client, independent of the source address the STUN server sees. This gives the attacker the ability to forge an arbitrary source address when it forwards the STUN request.",
      "ja": "スタンサーバーを妥協するのではなく、攻撃者は、クライアントからスタンサーバーへのパス上のルーターまたはNATを損なうことにより、STUNサーバーが間違ったマッピングアドレスを使用して応答を生成する可能性があります。スタンリクエストがRogueルーターまたはNATを通過すると、パケットのソースアドレスを、目的のマッピングアドレスのソースアドレスに書き換えます。このアドレスはarbitrary意的ではありません。攻撃者がパブリックインターネット上にいる場合（つまり、それとスタンサーバーの間にNATがありません）、攻撃者がスタンリクエストを変更しない場合、アドレスはパケットがStunサーバーから送信されるプロパティを持たなければなりません。そのアドレスは、侵害されたルーターを通過します。これは、STUNサーバーがリクエストのソースアドレスに回答を送り返すためです。修正されたソースアドレスを使用すると、クライアントに到達できる唯一の方法は、侵害されたルーターがそれらをそこに向ける場合です。攻撃者がパブリックインターネット上にいるが、スタンリクエストを変更できる場合、スタンリクエストの実際のソースアドレスを含む応答アドレス属性をリクエストに挿入できます。これにより、Stunサーバーが見ているソースアドレスとは無関係に、サーバーがクライアントに応答を送信します。これにより、攻撃者は、スタンリクエストを転送するときに任意のソースアドレスを偽造することができます。"
    },
    {
      "indent": 3,
      "text": "If the attacker is on a private network (that is, there are NATs between it and the STUN server), the attacker will not be able to force the server to generate arbitrary MAPPED-ADRESSes in responses. They will only be able force the STUN server to generate MAPPED-ADDRESSes which route to the private network. This is because the NAT between the attacker and the STUN server will rewrite the source address of the STUN request, mapping it to a public address that routes to the private network. Because of this, the attacker can only force the server to generate faked mapped addresses that route to the private network. Unfortunately, it is possible that a low quality NAT would be willing to map an allocated public address to another public address (as opposed to an internal private address), in which case the attacker could forge the source address in a STUN request to be an arbitrary public address. This kind of behavior from NATs does appear to be rare.",
      "ja": "攻撃者がプライベートネットワークにいる場合（つまり、それとStunサーバーの間にNATがあります）、攻撃者は、サーバーに応答に任意のマッピングされたアドレスを生成するように強制することができません。彼らは、スタンサーバーがプライベートネットワークにどのようなルーティングをするかマッピングされたアドレスを生成するように強制することしかできません。これは、攻撃者とStunサーバーの間のNATがStun要求のソースアドレスを書き換え、プライベートネットワークにルーティングするパブリックアドレスにマッピングするためです。このため、攻撃者は、プライベートネットワークにルーティングする偽造マッピングアドレスを生成するようサーバーにのみ強制できます。残念ながら、低品質のNATが割り当てられたパブリックアドレスを別のパブリックアドレスに（内部のプライベートアドレスとは対照的にマッピングすることをいとわない可能性があります。任意のパブリックアドレス。NATSからのこの種の動作はまれであるように見えます。"
    },
    {
      "indent": 0,
      "text": "12.2.4 Approach IV: MITM",
      "section_title": true,
      "ja": "12.2.4 アプローチIV：MITM"
    },
    {
      "indent": 3,
      "text": "As an alternative to approach III, if the attacker can place an element on the path from the client to the server, the element can act as a man-in-the-middle. In that case, it can intercept a STUN request, and generate a STUN response directly with any desired value of the MAPPED-ADDRESS field. Alternatively, it can forward the STUN request to the server (after potential modification), receive the response, and forward it to the client. When forwarding the request and response, this attack is subject to the same limitations on the MAPPED-ADDRESS described in Section 12.2.3.",
      "ja": "IIIにアプローチする代わりに、攻撃者がクライアントからサーバーへのパスに要素を配置できる場合、要素は中間の男として機能します。その場合、スタン要求を傍受し、マッピングされたアドレスフィールドの任意の任意の値でスタン応答を直接生成できます。または、スタン要求をサーバーに転送し（潜在的な変更後）、応答を受け取り、クライアントに転送することができます。リクエストと応答を転送するとき、この攻撃は、セクション12.2.3で説明されているマッピングされたアドレスの同じ制限の対象となります。"
    },
    {
      "indent": 0,
      "text": "12.2.5 Approach V: Response Injection Plus DoS",
      "section_title": true,
      "ja": "12.2.5 アプローチV：応答インジェクションとDOS"
    },
    {
      "indent": 3,
      "text": "In this approach, the attacker does not need to be a MITM (as in approaches III and IV). Rather, it only needs to be able to eavesdrop onto a network segment that carries STUN requests. This is easily done in multiple access networks such as ethernet or unprotected 802.11. To inject the fake response, the attacker listens on the network for a STUN request. When it sees one, it simultaneously launches a DoS attack on the STUN server, and generates its own STUN response with the desired MAPPED-ADDRESS value. The STUN response generated by the attacker will reach the client, and the DoS attack against the server is aimed at preventing the legitimate response from the server from reaching the client. Arguably, the attacker can do without the DoS attack on the server, so long as the faked response beats the real response back to the client, and the client uses the first response, and ignores the second (even though it's different).",
      "ja": "このアプローチでは、攻撃者はMITMである必要はありません（アプローチIIIおよびIVのように）。むしろ、スタンリクエストを運ぶネットワークセグメントに盗聴できる必要があるだけです。これは、イーサネットや保護されていない802.11などの複数のアクセスネットワークで簡単に実行できます。偽の応答を注入するために、攻撃者はスタンリクエストのためにネットワークに耳を傾けます。1つを表示すると、Stunサーバーに対するDOS攻撃を同時に起動し、目的のマッピングアドレス値で独自のスタン応答を生成します。攻撃者によって生成されたスタン応答がクライアントに到達し、サーバーに対するDOS攻撃は、サーバーからの正当な応答がクライアントに届かないようにすることを目的としています。間違いなく、攻撃者はサーバーへのDOS攻撃なしで行うことができます。偽造応答がクライアントへの実際の応答を打ち負かし、クライアントが最初の応答を使用し、2番目の応答を無視します（違いますが）。"
    },
    {
      "indent": 0,
      "text": "12.2.6 Approach VI: Duplication",
      "section_title": true,
      "ja": "12.2.6 アプローチVI：複製"
    },
    {
      "indent": 3,
      "text": "This approach is similar to approach V. The attacker listens on the network for a STUN request. When it sees it, it generates its own STUN request towards the server. This STUN request is identical to the one it saw, but with a spoofed source IP address. The spoofed address is equal to the one that the attacker desires to have placed in the MAPPED-ADDRESS of the STUN response. In fact, the attacker generates a flood of such packets. The STUN server will receive the one original request, plus a flood of duplicate fake ones. It generates responses to all of them. If the flood is sufficiently large for the responses to congest routers or some other equipment, there is a reasonable probability that the one real response is lost (along with many of the faked ones), but the net result is that only the faked responses are received by the STUN client. These responses are all identical and all contain the MAPPED-ADDRESS that the attacker wanted the client to use.",
      "ja": "このアプローチは、アプローチVに似ています。攻撃者は、スタン要求のためにネットワーク上で耳を傾けます。それがそれを見るとき、それはサーバーに対する独自のスタン要求を生成します。このスタン要求は、見たものと同じですが、ソースIPアドレスがスプーフィングしています。スプーフィングされたアドレスは、攻撃者がスタン応答のマッピングされたアドレスに配置したいと望んでいるアドレスと等しくなります。実際、攻撃者はそのようなパケットの洪水を生成します。Stunサーバーは、1つの元のリクエストに加えて、重複した偽物の洪水を受け取ります。それらすべてに対する応答を生成します。洪水が混雑ルーターまたは他のいくつかの機器に対する応答のために十分に大きい場合、1つの実際の応答が（多くの偽造されたものとともに）失われるという合理的な確率がありますが、純結果は偽造された応答のみがスタンクライアントが受け取った。これらの応答はすべて同一であり、すべてが攻撃者がクライアントに使用することを望んでいたマッピングされたアドレスを含んでいます。"
    },
    {
      "indent": 3,
      "text": "The flood of duplicate packets is not needed (that is, only one faked request is sent), so long as the faked response beats the real response back to the client, and the client uses the first response, and ignores the second (even though it's different).",
      "ja": "重複したパケットの洪水は必要ありません（つまり、偽造リクエストが1つだけ送信されます）。違います）。"
    },
    {
      "indent": 3,
      "text": "Note that, in this approach, launching a DoS attack against the STUN server or the IP network, to prevent the valid response from being sent or received, is problematic. The attacker needs the STUN server to be available to handle its own request. Due to the periodic retransmissions of the request from the client, this leaves a very tiny window of opportunity. The attacker must start the DoS attack immediately after the actual request from the client, causing the correct response to be discarded, and then cease the DoS attack in order to send its own request, all before the next retransmission from the client. Due to the close spacing of the retransmits (100ms to a few seconds), this is very difficult to do.",
      "ja": "このアプローチでは、有効な応答が送信または受信されないように、StunサーバーまたはIPネットワークに対するDOS攻撃を開始することに問題があることに注意してください。攻撃者は、独自の要求を処理するためにSTUNサーバーを利用できるようにする必要があります。クライアントからのリクエストの定期的な再送信により、これは非常に小さな機会の窓を残します。攻撃者は、クライアントからの実際の要求の直後にDOS攻撃を開始し、正しい応答を破棄し、次のクライアントからの再送信の前に独自の要求を送信するためにDOS攻撃を停止する必要があります。再送信の間隔（100msから数秒）の間隔のため、これを行うのは非常に困難です。"
    },
    {
      "indent": 3,
      "text": "Besides DoS attacks, there may be other ways to prevent the actual request from the client from reaching the server. Layer 2 manipulations, for example, might be able to accomplish it.",
      "ja": "DOS攻撃に加えて、クライアントから実際の要求がサーバーに届かないようにする他の方法がある場合があります。たとえば、レイヤー2の操作が達成できる場合があります。"
    },
    {
      "indent": 3,
      "text": "Fortunately, Approach IV is subject to the same limitations documented in Section 12.2.3, which limit the range of MAPPED-ADDRESSes the attacker can cause the STUN server to generate.",
      "ja": "幸いなことに、アプローチIVは、セクション12.2.3に文書化された同じ制限の対象となります。これにより、攻撃者がSTUNサーバーを生成する可能性のあるマッピングされたアドレスの範囲が制限されます。"
    },
    {
      "indent": 0,
      "text": "12.3 Countermeasures",
      "section_title": true,
      "ja": "12.3 対策"
    },
    {
      "indent": 3,
      "text": "STUN provides mechanisms to counter the approaches described above, and additional, non-STUN techniques can be used as well.",
      "ja": "Stunは、上記のアプローチに対抗するメカニズムを提供し、追加の非スタン技術も同様に使用できます。"
    },
    {
      "indent": 3,
      "text": "First off, it is RECOMMENDED that networks with STUN clients implement ingress source filtering (RFC 2827 [7]). This is particularly important for the NATs themselves. As Section 12.2.3 explains, NATs which do not perform this check can be used as \"reflectors\" in DDoS attacks. Most NATs do perform this check as a default mode of operation. We strongly advise people that purchase NATs to ensure that this capability is present and enabled.",
      "ja": "まず、Stunクライアントを持つネットワークがイングレスソースフィルタリングを実装することをお勧めします（RFC 2827 [7]）。これは、NAT自体にとって特に重要です。セクション12.2.3が説明しているように、このチェックを実行しないNATは、DDOS攻撃の「リフレクター」として使用できます。ほとんどのNATは、このチェックをデフォルトの操作モードとして実行します。この機能が存在し、有効になっていることを確認するために、NATを購入する人々に強くお勧めします。"
    },
    {
      "indent": 3,
      "text": "Secondly, it is RECOMMENDED that STUN servers be run on hosts dedicated to STUN, with all UDP and TCP ports disabled except for the STUN ports. This is to prevent viruses and Trojan horses from infecting STUN servers, in order to prevent their compromise. This helps mitigate Approach I (Section 12.2.1).",
      "ja": "第二に、スタンポートを除き、すべてのUDPポートとTCPポートを無効にして、スタン専用のホストでSTUNサーバーを実行することをお勧めします。これは、妥協を防ぐために、ウイルスやトロイの木馬がスタンサーバーに感染するのを防ぐためです。これにより、アプローチI（セクション12.2.1）を軽減するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "Thirdly, to prevent the DNS attack of Section 12.2.2, Section 9.2 recommends that the client verify the credentials provided by the server with the name used in the DNS lookup.",
      "ja": "第三に、セクション12.2.2のDNS攻撃を防ぐために、セクション9.2は、クライアントがDNSルックアップで使用されている名前をサーバーが提供する資格情報を確認することを推奨します。"
    },
    {
      "indent": 3,
      "text": "Finally, all of the attacks above rely on the client taking the mapped address it learned from STUN, and using it in application layer protocols. If encryption and message integrity are provided within those protocols, the eavesdropping and identity assumption attacks can be prevented. As such, applications that make use of STUN addresses in application protocols SHOULD use integrity and encryption, even if a SHOULD level strength is not specified for that protocol. For example, multimedia applications using STUN addresses to receive RTP traffic would use secure RTP [16].",
      "ja": "最後に、上記のすべての攻撃は、Stunから学んだマッピングされたアドレスを取得し、アプリケーションレイヤープロトコルで使用しているクライアントに依存しています。これらのプロトコル内で暗号化とメッセージの整合性が提供される場合、盗聴とアイデンティティの仮定攻撃を防ぐことができます。そのため、アプリケーションプロトコルでSTUNアドレスを使用するアプリケーションは、そのプロトコルにレベルの強度が指定されていない場合でも、整合性と暗号化を使用する必要があります。たとえば、STUNアドレスを使用してRTPトラフィックを受信するマルチメディアアプリケーションは、安全なRTPを使用します[16]。"
    },
    {
      "indent": 3,
      "text": "The above three techniques are non-STUN mechanisms. STUN itself provides several countermeasures.",
      "ja": "上記の3つの手法は、非スタンメカニズムです。Stun自体はいくつかの対策を提供します。"
    },
    {
      "indent": 3,
      "text": "Approaches IV (Section 12.2.4), when generating the response locally, and V (Section 12.2.5) require an attacker to generate a faked response. This attack is prevented using the message integrity mechanism provided in STUN, described in Section 8.1.",
      "ja": "IV（セクション12.2.4）にアプローチし、局所的に応答を生成する場合、V（セクション12.2.5）が攻撃者に偽造された応答を生成する必要があります。この攻撃は、セクション8.1で説明されているSTUNで提供されるメッセージの整合性メカニズムを使用して防止されます。"
    },
    {
      "indent": 3,
      "text": "Approaches III (Section 12.2.3) IV (Section 12.2.4), when using the relaying technique, and VI (12.2.6), however, are not preventable through server signatures. Both approaches are most potent when the attacker can modify the request, inserting a RESPONSE-ADDRESS that routes to the client. Fortunately, such modifications are preventable using the message integrity techniques described in Section 9.3. However, these three approaches are still functional when the attacker modifies nothing but the source address of the STUN request. Sadly, this is the one thing that cannot be protected through cryptographic means, as this is the change that STUN itself is seeking to detect and report. It is therefore an inherent weakness in NAT, and not fixable in STUN. To help mitigate these attacks, Section 9.4 provides several heuristics for the client to follow. The client looks for inconsistent or extra responses, both of which are signs of the attacks described above. However, these heuristics are just that - heuristics, and cannot be guaranteed to prevent attacks. The heuristics appear to prevent the attacks as we know how to launch them today. Implementors should stay posted for information on new heuristics that might be required in the future. Such information will be distributed on the IETF MIDCOM mailing list, midcom@ietf.org.",
      "ja": "アプローチIII（セクション12.2.3）IV（セクション12.2.4）は、リレーテクニックを使用している場合、VI（12.2.6）を使用している場合は、サーバーの署名を通じて予防できません。両方のアプローチは、攻撃者がリクエストを変更できる場合、最も強力です。クライアントにルーティングする応答アドレスを挿入します。幸いなことに、このような変更は、セクション9.3で説明されているメッセージ整合性手法を使用して予防可能です。ただし、攻撃者がスタンリクエストのソースアドレス以外何も変更しない場合、これらの3つのアプローチは依然として機能します。悲しいことに、これは暗号化手段を通じて保護できないことの1つです。これは、スタン自体が検出と報告を求めている変化です。したがって、それはNATの固有の弱点であり、スタンでは修正できません。これらの攻撃を緩和するために、セクション9.4は、クライアントが従うためのいくつかのヒューリスティックを提供します。クライアントは、一貫性のない応答または追加の応答を探します。どちらも上記の攻撃の兆候です。ただし、これらのヒューリスティックはまさにそれであり、攻撃を防ぐことを保証することはできません。ヒューリスティックは、今日それらを起動する方法を知っているので、攻撃を防ぐように見えます。実装者は、将来的に必要とされる可能性のある新しいヒューリスティックに関する情報のために投稿されたままにする必要があります。このような情報は、IETF Midcomメーリングリスト、midcom@itf.orgに配布されます。"
    },
    {
      "indent": 0,
      "text": "12.4 Residual Threats",
      "section_title": true,
      "ja": "12.4 残留脅威"
    },
    {
      "indent": 3,
      "text": "None of the countermeasures listed above can prevent the attacks described in Section 12.2.3 if the attacker is in the appropriate network paths. Specifically, consider the case in which the attacker wishes to convince client C that it has address V. The attacker needs to have a network element on the path between A and the server (in order to modify the request) and on the path between the server and V so that it can forward the response to C. Furthermore, if there is a NAT between the attacker and the server, V must also be behind the same NAT. In such a situation, the attacker can either gain access to all the application-layer traffic or mount the DDOS attack described in Section 12.1.1. Note that any host which exists in the correct topological relationship can be DDOSed. It need not be using STUN.",
      "ja": "上記の対策はいずれも、攻撃者が適切なネットワークパスにある場合、セクション12.2.3で説明されている攻撃を防ぐことはできません。具体的には、攻撃者がクライアントCにVにアドレスを持っていることを納得させたい場合を検討してください。攻撃者は、（リクエストを変更するために）Aとサーバーの間のパスにネットワーク要素を持つ必要があります。サーバーとVで、Cへの応答を転送できるように、さらに、攻撃者とサーバーの間にNATがある場合、Vも同じNATの背後にある必要があります。このような状況では、攻撃者はすべてのアプリケーション層トラフィックにアクセスするか、セクション12.1.1で説明されているDDOS攻撃をマウントできます。正しいトポロジー関係に存在するホストは、ddosedすることができることに注意してください。スタンを使用する必要はありません。"
    },
    {
      "indent": 0,
      "text": "13. IANA Considerations",
      "section_title": true,
      "ja": "13. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "STUN cannot be extended. Changes to the protocol are made through a standards track revision of this specification. As a result, no IANA registries are needed. Any future extensions will establish any needed registries.",
      "ja": "スタンを拡張することはできません。プロトコルの変更は、この仕様の標準トラック改訂を通じて行われます。その結果、IANAレジストリは必要ありません。将来の拡張機能は、必要なレジストリを確立します。"
    },
    {
      "indent": 0,
      "text": "14. IAB Considerations",
      "section_title": true,
      "ja": "14. IABの考慮事項"
    },
    {
      "indent": 3,
      "text": "The IAB has studied the problem of \"Unilateral Self Address Fixing\", which is the general process by which a client attempts to determine its address in another realm on the other side of a NAT through a collaborative protocol reflection mechanism (RFC 3424 [17]). STUN is an example of a protocol that performs this type of function. The IAB has mandated that any protocols developed for this purpose document a specific set of considerations. This section meets those requirements.",
      "ja": "IABは、「一方的なセルフアドレス修正」の問題を研究しました。これは、クライアントが共同プロトコル反射メカニズムを通じてNATの反対側の別の領域でそのアドレスを決定しようとする一般的なプロセスです（RFC 3424 [17]）。Stunは、このタイプの機能を実行するプロトコルの例です。IABは、この目的のために開発されたプロトコルが特定の考慮事項を文書化することを義務付けています。このセクションでは、これらの要件を満たしています。"
    },
    {
      "indent": 0,
      "text": "14.1 Problem Definition",
      "section_title": true,
      "ja": "14.1 問題の定義"
    },
    {
      "indent": 3,
      "text": "From RFC 3424 [17], any UNSAF proposal must provide:",
      "ja": "RFC 3424 [17]から、UNSAF提案は次のことを提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "Precise definition of a specific, limited-scope problem that is to be solved with the UNSAF proposal. A short term fix should not be generalized to solve other problems; this is why \"short term fixes usually aren't\".",
      "ja": "UNSAF提案で解決される特定の限られたスコープ問題の正確な定義。他の問題を解決するために、短期的な修正を一般化しないでください。これが、「短期的な修正は通常そうではない」理由です。"
    },
    {
      "indent": 3,
      "text": "The specific problems being solved by STUN are:",
      "ja": "スタンによって解決される特定の問題は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Provide a means for a client to detect the presence of one or more NATs between it and a server run by a service provider on the public Internet. The purpose of such detection is to determine additional steps that might be necessary in order to receive service from that particular provider.",
      "ja": "o クライアントが、パブリックインターネット上でサービスプロバイダーが実行するサーバーの間に1つ以上のNATの存在を検出する手段を提供します。このような検出の目的は、その特定のプロバイダーからサービスを受けるために必要な追加の手順を決定することです。"
    },
    {
      "indent": 3,
      "text": "o Provide a means for a client to detect the presence of one or more NATs between it and another client, where the second client is reachable from the first, but it is not known whether the second client resides on the public Internet.",
      "ja": "o クライアントが1つ以上のクライアントと別のクライアントの間に1つ以上のNATの存在を検出する手段を提供します。ここでは、2番目のクライアントが最初のクライアントに到達できますが、2番目のクライアントがパブリックインターネットに存在するかどうかは不明です。"
    },
    {
      "indent": 3,
      "text": "o Provide a means for a client to obtain an address on the public Internet from a non-symmetric NAT, for the express purpose of receiving incoming UDP traffic from another host, targeted to that address.",
      "ja": "o そのアドレスをターゲットにした別のホストから受信UDPトラフィックを受信するという明確な目的のために、クライアントが非対称NATからパブリックインターネット上のアドレスを取得する手段を提供します。"
    },
    {
      "indent": 3,
      "text": "STUN does not address TCP, either incoming or outgoing, and does not address outgoing UDP communications.",
      "ja": "Stunは、受信または発信のいずれかのTCPに対処せず、発信UDP通信には対処しません。"
    },
    {
      "indent": 0,
      "text": "14.2 Exit Strategy",
      "section_title": true,
      "ja": "14.2 終了戦略"
    },
    {
      "indent": 3,
      "text": "From [17], any UNSAF proposal must provide:",
      "ja": "[17]から、UNSAFの提案は次のことを提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "Description of an exit strategy/transition plan. The better short term fixes are the ones that will naturally see less and less use as the appropriate technology is deployed.",
      "ja": "出口戦略/移行計画の説明。より良い短期的な修正は、適切なテクノロジーが展開されるにつれて、自然に使用が少なく使用されるものです。"
    },
    {
      "indent": 3,
      "text": "STUN comes with its own built in exit strategy. This strategy is the detection operation that is performed as a precursor to the actual UNSAF address-fixing operation. This discovery operation, documented in Section 10.1, attempts to discover the existence of, and type of, any NATS between the client and the service provider network. Whilst the detection of the specific type of NAT may be brittle, the discovery of the existence of NAT is itself quite robust. As NATs are phased out through the deployment of IPv6, the discovery operation will return immediately with the result that there is no NAT, and no further operations are required. Indeed, the discovery operation itself can be used to help motivate deployment of IPv6; if a user detects a NAT between themselves and the public Internet, they can call up their access provider and complain about it.",
      "ja": "Stunには、独自のExit戦略が組み込まれています。この戦略は、実際のUNSAFアドレス固定操作の前駆体として実行される検出操作です。セクション10.1で文書化されたこの発見操作は、クライアントとサービスプロバイダーネットワークの間のNATの存在とタイプを発見しようとします。特定のタイプのNATの検出は脆いかもしれませんが、NATの存在の発見自体は非常に堅牢です。NATはIPv6の展開を通じて段階的に廃止されるため、発見操作はNATがなく、それ以上の操作が必要であるという結果、すぐに戻ります。実際、発見操作自体を使用して、IPv6の展開の動機付けに役立ちます。ユーザーが自分自身とパブリックインターネットの間でNATを検出した場合、アクセスプロバイダーを呼び出して不平を言うことができます。"
    },
    {
      "indent": 3,
      "text": "STUN can also help facilitate the introduction of midcom. As midcom-capable NATs are deployed, applications will, instead of using STUN (which also resides at the application layer), first allocate an address binding using midcom. However, it is a well-known limitation of midcom that it only works when the agent knows the middleboxes through which its traffic will flow. Once bindings have been allocated from those middleboxes, a STUN detection procedure can validate that there are no additional middleboxes on the path from the public Internet to the client. If this is the case, the application can continue operation using the address bindings allocated from midcom. If it is not the case, STUN provides a mechanism for self-address fixing through the remaining midcom-unaware middleboxes. Thus, STUN provides a way to help transition to full midcom-aware networks.",
      "ja": "Stunは、Midcomの導入を促進するのにも役立ちます。Midcom対応NATが展開されるため、アプリケーションは、Stun（アプリケーション層にも存在する）を使用する代わりに、Midcomを使用してアドレスバインディングを割り当てます。ただし、Midcomのよく知られている制限であり、エージェントがトラフィックが流れるミドルボックスを知っている場合にのみ機能します。これらのミドルボックスからバインディングが割り当てられたら、スタン検出手順では、パブリックインターネットからクライアントへのパスに追加のミドルボックスがないことを検証できます。この場合、Midcomから割り当てられたアドレスバインディングを使用して、アプリケーションは操作を続けることができます。そうでない場合、Stunは、残りのMidcom-Unawareミドルボックスを介して自己アドレス修正のメカニズムを提供します。したがって、Stunは、完全なMidcom認識ネットワークへの移行を支援する方法を提供します。"
    },
    {
      "indent": 0,
      "text": "14.3 Brittleness Introduced by STUN",
      "section_title": true,
      "ja": "14.3 Stunによって導入されたBrittleness"
    },
    {
      "indent": 3,
      "text": "From [17], any UNSAF proposal must provide:",
      "ja": "[17]から、UNSAFの提案は次のことを提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "Discussion of specific issues that may render systems more \"brittle\". For example, approaches that involve using data at multiple network layers create more dependencies, increase debugging challenges, and make it harder to transition.",
      "ja": "システムをより「脆く」する可能性のある特定の問題の議論。たとえば、複数のネットワークレイヤーでデータを使用することを含むアプローチは、より多くの依存関係を作成し、デバッグの課題を増やし、移行を難しくします。"
    },
    {
      "indent": 3,
      "text": "STUN introduces brittleness into the system in several ways:",
      "ja": "Stunはいくつかの方法でシステムにBrittlenessを紹介します。"
    },
    {
      "indent": 3,
      "text": "o The discovery process assumes a certain classification of devices based on their treatment of UDP. There could be other types of NATs that are deployed that would not fit into one of these molds. Therefore, future NATs may not be properly detected by STUN. STUN clients (but not servers) would need to change to accommodate that.",
      "ja": "o 発見プロセスでは、UDPの処理に基づいてデバイスの特定の分類を想定しています。これらの金型のいずれかに適合しない他のタイプのNATが展開される可能性があります。したがって、将来のNATはスタンによって適切に検出されない可能性があります。スタンクライアント（サーバーではなく）は、それに対応するために変更する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The binding acquisition usage of STUN does not work for all NAT types. It will work for any application for full cone NATs only. For restricted cone and port restricted cone NAT, it will work for some applications depending on the application. Application specific processing will generally be needed. For symmetric NATs, the binding acquisition will not yield a usable address. The tight dependency on the specific type of NAT makes the protocol brittle.",
      "ja": "o STUNの拘束力のある獲得の使用は、すべてのNATタイプでは機能しません。完全なコーンナットのみのアプリケーションでのみ機能します。制限付きコーンおよびポート制限付きコーンNATの場合、アプリケーションに応じて一部のアプリケーションで機能します。通常、アプリケーション固有の処理が必要になります。対称NATの場合、拘束力のある獲得は使用可能なアドレスを生成しません。特定のタイプのNATへの厳しい依存性により、プロトコルが脆くなります。"
    },
    {
      "indent": 3,
      "text": "o STUN assumes that the server exists on the public Internet. If the server is located in another private address realm, the user may or may not be able to use its discovered address to communicate with other users. There is no way to detect such a condition.",
      "ja": "o Stunは、サーバーがパブリックインターネットに存在すると想定しています。サーバーが別のプライベートアドレスの領域にある場合、ユーザーは発見されたアドレスを使用して他のユーザーと通信できる場合とできない場合があります。そのような状態を検出する方法はありません。"
    },
    {
      "indent": 3,
      "text": "o The bindings allocated from the NAT need to be continuously refreshed. Since the timeouts for these bindings is very implementation specific, the refresh interval cannot easily be determined. When the binding is not being actively used to receive traffic, but to wait for an incoming message, the binding refresh will needlessly consume network bandwidth.",
      "ja": "o NATから割り当てられたバインディングは、継続的にリフレッシュする必要があります。これらのバインディングのタイムアウトは非常に実装特異的であるため、更新間隔を簡単に決定することはできません。バインディングがトラフィックを受信するために積極的に使用されていないが、着信メッセージを待つために使用されている場合、バインディングリフレッシュはネットワーク帯域幅を不必要に消費します。"
    },
    {
      "indent": 3,
      "text": "o The use of the STUN server as an additional network element introduces another point of potential security attack. These attacks are largely prevented by the security measures provided by STUN, but not entirely.",
      "ja": "o 追加のネットワーク要素としてSTUNサーバーを使用すると、セキュリティ攻撃の潜在的なポイントが導入されます。これらの攻撃は、スタンによって提供されたセキュリティ対策によって大部分が防止されていますが、完全ではありません。"
    },
    {
      "indent": 3,
      "text": "o The use of the STUN server as an additional network element introduces another point of failure. If the client cannot locate a STUN server, or if the server should be unavailable due to failure, the application cannot function.",
      "ja": "o 追加のネットワーク要素としてStunサーバーを使用すると、障害の別のポイントが導入されます。クライアントがスタンサーバーを見つけることができない場合、または障害のためにサーバーを利用できない場合、アプリケーションは機能できません。"
    },
    {
      "indent": 3,
      "text": "o The use of STUN to discover address bindings will result in an increase in latency for applications. For example, a Voice over IP application will see an increase of call setup delays equal to at least one RTT to the STUN server.",
      "ja": "o アドレスバインディングを発見するためにスタンを使用すると、アプリケーションの遅延が増加します。たとえば、Voice over IPアプリケーションでは、Stunサーバーへの少なくとも1つのRTTに等しいコールセットアップの遅延が増加します。"
    },
    {
      "indent": 3,
      "text": "o The discovery of binding lifetimes is prone to error. It assumes that the same lifetime will exist for all bindings. This may not be true if the NAT uses dynamic binding lifetimes to handle overload, or if the NAT itself reboots during the discovery process.",
      "ja": "o 結合寿命の発見はエラーになりやすいです。それは、すべてのバインディングに同じ寿命が存在すると仮定します。これは、NATが動的結合寿命を使用して過負荷を処理する場合、または発見プロセス中にNAT自体が再起動する場合に当てはまらない場合があります。"
    },
    {
      "indent": 3,
      "text": "o STUN imposes some restrictions on the network topologies for proper operation. If client A obtains an address from STUN server X, and sends it to client B, B may not be able to send to A using that IP address. The address will not work if any of the following is true:",
      "ja": "o Stunは、適切な動作のためにネットワークトポロジにいくつかの制限を課します。クライアントAがStun Server Xからアドレスを取得し、クライアントBに送信すると、BがそのIPアドレスを使用してAに送信できない場合があります。次のいずれかが真実であれば、アドレスは機能しません。"
    },
    {
      "indent": 6,
      "text": "- The STUN server is not in an address realm that is a common ancestor (topologically) of both clients A and B. For example, consider client A and B, both of which have residential NAT devices. Both devices connect them to their cable operators, but both clients have different providers. Each provider has a NAT in front of their entire network, connecting it to the public Internet. If the STUN server used by A is in A's cable operator's network, an address obtained by it will not be usable by B. The STUN server must be in the network which is a common ancestor to both - in this case, the public Internet.",
      "ja": "- スタンサーバーは、クライアントAとBの両方の共通の祖先であるアドレス領域にはありません。たとえば、クライアントAとBを考慮してください。どちらも住宅のNATデバイスを持っています。どちらのデバイスもケーブルオペレーターに接続しますが、両方のクライアントは異なるプロバイダーを持っています。各プロバイダーには、ネットワーク全体の前にNATがあり、パブリックインターネットに接続しています。Aで使用されるスタンサーバーがAのケーブルオペレーターのネットワークにある場合、Bが取得したアドレスはBによって使用できません。スタンサーバーは、両方の共通の祖先であるネットワークにある必要があります。この場合、パブリックインターネット。"
    },
    {
      "indent": 6,
      "text": "- The STUN server is in an address realm that is a common ancestor to both clients, but both clients are behind the same NAT connecting to that address realm. For example, if the two clients in the previous example had the same cable operator, that cable operator had a single NAT connecting their network to the public Internet, and the STUN server was on the public Internet, the address obtained by A would not be usable by B. That is because some NATs will not accept an internal packet sent to a public IP address which is mapped back to an internal address. To deal with this, additional protocol mechanisms or configuration parameters need to be introduced which detect this case.",
      "ja": "- スタンサーバーは、両方のクライアントの共通の祖先であるアドレス領域にありますが、両方のクライアントはそのアドレス領域に接続する同じNATの背後にいます。たとえば、前の例の2つのクライアントが同じケーブルオペレーターを持っていた場合、そのケーブルオペレーターはネットワークをパブリックインターネットに接続する単一のNATを持っていて、スタンサーバーはパブリックインターネット上にありました。Bが使用できるのは、一部のNATが、内部アドレスにマッピングされたパブリックIPアドレスに送信された内部パケットを受け入れないためです。これに対処するには、このケースを検出する追加のプロトコルメカニズムまたは構成パラメーターを導入する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Most significantly, STUN introduces potential security threats which cannot be eliminated. This specification describes heuristics that can be used to mitigate the problem, but it is provably unsolvable given what STUN is trying to accomplish. These security problems are described fully in Section 12.",
      "ja": "o 最も重要なことは、Stunが排除できない潜在的なセキュリティの脅威を導入することです。この仕様では、問題を軽減するために使用できるヒューリスティックについて説明しますが、Stunが達成しようとしていることを考えると、それは確かに解決できません。これらのセキュリティの問題は、セクション12で完全に説明されています。"
    },
    {
      "indent": 0,
      "text": "14.4 Requirements for a Long Term Solution",
      "section_title": true,
      "ja": "14.4 長期的なソリューションの要件"
    },
    {
      "indent": 3,
      "text": "From [17], any UNSAF proposal must provide:",
      "ja": "[17]から、UNSAFの提案は次のことを提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "Identify requirements for longer term, sound technical solutions -- contribute to the process of finding the right longer term solution.",
      "ja": "長期的な健全な技術的ソリューションの要件を特定します - 適切な長期ソリューションを見つけるプロセスに貢献します。"
    },
    {
      "indent": 3,
      "text": "Our experience with STUN has led to the following requirements for a long term solution to the NAT problem:",
      "ja": "Stunの経験は、NATの問題に対する長期的な解決策のための次の要件につながりました。"
    },
    {
      "indent": 3,
      "text": "Requests for bindings and control of other resources in a NAT need to be explicit. Much of the brittleness in STUN derives from its guessing at the parameters of the NAT, rather than telling the NAT what parameters to use.",
      "ja": "NATでの他のリソースのバインディングと制御の要求は明示的である必要があります。Stunの脆性の多くは、NATにどのパラメーターを使用するかを伝えるのではなく、NATのパラメーターを推測することに由来しています。"
    },
    {
      "indent": 3,
      "text": "Control needs to be \"in-band\". There are far too many scenarios in which the client will not know about the location of middleboxes ahead of time. Instead, control of such boxes needs to occur in-band, traveling along the same path as the data will itself travel. This guarantees that the right set of middleboxes are controlled. This is only true for first-party controls; third-party controls are best handled using the midcom framework.",
      "ja": "制御は「インバンド」である必要があります。クライアントが事前にミドルボックスの位置について知らないというシナリオが多すぎます。代わりに、そのようなボックスの制御は帯域内で発生する必要があり、データ自体が移動するのと同じパスに沿って移動する必要があります。これにより、正しいミドルボックスが制御されることが保証されます。これは、ファーストパーティコントロールにのみ当てはまります。サードパーティのコントロールは、Midcomフレームワークを使用して最適に処理されます。"
    },
    {
      "indent": 3,
      "text": "Control needs to be limited. Users will need to communicate through NATs which are outside of their administrative control. In order for providers to be willing to deploy NATs which can be controlled by users in different domains, the scope of such controls needs to be extremely limited - typically, allocating a binding to reach the address where the control packets are coming from.",
      "ja": "制御を制限する必要があります。ユーザーは、管理管理の外側にあるNATを介して通信する必要があります。プロバイダーが異なるドメインのユーザーが制御できるNATを展開することをいとわないため、そのようなコントロールの範囲は非常に制限する必要があります - 通常、制御パケットが来る場所に到達するためにバインディングを割り当てます。"
    },
    {
      "indent": 3,
      "text": "Simplicity is Paramount. The control protocol will need to be implement in very simple clients. The servers will need to support extremely high loads. The protocol will need to be extremely robust, being the precursor to a host of application protocols. As such, simplicity is key.",
      "ja": "シンプルさが最重要です。制御プロトコルは、非常にシンプルなクライアントに実装する必要があります。サーバーは非常に高い負荷をサポートする必要があります。プロトコルは非常に堅牢であり、多くのアプリケーションプロトコルの前兆である必要があります。そのため、シンプルさが重要です。"
    },
    {
      "indent": 0,
      "text": "14.5 Issues with Existing NAPT Boxes",
      "section_title": true,
      "ja": "14.5 既存のNAPTボックスの問題"
    },
    {
      "indent": 3,
      "text": "From [17], any UNSAF proposal must provide:",
      "ja": "[17]から、UNSAFの提案は次のことを提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "Discussion of the impact of the noted practical issues with existing, deployed NA[P]Ts and experience reports.",
      "ja": "既存の展開されたNA [P] TSおよびExperience Reportsに関する有名な実用的な問題の影響についての議論。"
    },
    {
      "indent": 3,
      "text": "Several of the practical issues with STUN involve future proofing - breaking the protocol when new NAT types get deployed. Fortunately, this is not an issue at the current time, since most of the deployed NATs are of the types assumed by STUN. The primary usage STUN has found is in the area of VoIP, to facilitate allocation of addresses for receiving RTP [12] traffic. In that application, the periodic keepalives are provided by the RTP traffic itself. However, several practical problems arise for RTP. First, RTP assumes that RTCP traffic is on a port one higher than the RTP traffic. This pairing property cannot be guaranteed through NATs that are not directly controllable. As a result, RTCP traffic may not be properly received. Protocol extensions to SDP have been proposed which mitigate this by allowing the client to signal a different port for RTCP [18]. However, there will be interoperability problems for some time.",
      "ja": "Stunに関する実際の問題のいくつかには、将来の校正が含まれます - 新しいNATタイプが展開されたときにプロトコルを破ります。幸いなことに、展開されたNATのほとんどはStunによって想定されるタイプのものであるため、これは現時点では問題ではありません。Stunが発見した主な使用法は、RTP [12]トラフィックを受信するためのアドレスの割り当てを容易にするためにVoIPの領域にあります。そのアプリケーションでは、RTPトラフィック自体によって周期的なキープライブが提供されます。ただし、RTPにはいくつかの実際的な問題が発生します。まず、RTPは、RTCPトラフィックがRTPトラフィックよりも高いポート上にあると想定しています。このペアリングプロパティは、直接制御できないNATを介して保証することはできません。その結果、RTCPトラフィックが適切に受信されない場合があります。SDPへのプロトコル拡張は、クライアントがRTCPの別のポートを信号することを可能にすることにより、これを軽減することを提案しています[18]。ただし、しばらくの間、相互運用性の問題があります。"
    },
    {
      "indent": 3,
      "text": "For VoIP, silence suppression can cause a gap in the transmission of RTP packets. This could result in the loss of a binding in the middle of a call, if that silence period exceeds the binding timeout. This can be mitigated by sending occasional silence packets to keep the binding alive. However, the result is additional brittleness; proper operation depends on the silence suppression algorithm in use, the usage of a comfort noise codec, the duration of the silence period, and the binding lifetime in the NAT.",
      "ja": "VoIPの場合、沈黙抑制はRTPパケットの伝送にギャップを引き起こす可能性があります。これにより、その沈黙期間がバインディングタイムアウトを超える場合、コールの途中でバインディングが失われる可能性があります。これは、バインディングを生かし続けるために時折沈黙のパケットを送信することで軽減できます。ただし、結果は追加のbrittlenessです。適切な操作は、使用中の沈黙抑制アルゴリズム、コンフォートノイズコーデックの使用、沈黙期間の持続時間、およびNATの結合寿命に依存します。"
    },
    {
      "indent": 0,
      "text": "14.6 In Closing",
      "section_title": true,
      "ja": "14.6 最後に"
    },
    {
      "indent": 3,
      "text": "The problems with STUN are not design flaws in STUN. The problems in STUN have to do with the lack of standardized behaviors and controls in NATs. The result of this lack of standardization has been a proliferation of devices whose behavior is highly unpredictable, extremely variable, and uncontrollable. STUN does the best it can in such a hostile environment. Ultimately, the solution is to make the environment less hostile, and to introduce controls and standardized behaviors into NAT. However, until such time as that happens, STUN provides a good short term solution given the terrible conditions under which it is forced to operate.",
      "ja": "スタンの問題は、スタンの設計上の欠陥ではありません。スタンの問題は、NATの標準化された動作とコントロールの欠如に関係しています。この標準化の欠如の結果、動作が非常に予測不可能で、非常に変動し、制御不能なデバイスの急増でした。Stunは、このような敵対的な環境でできる限り最善を尽くします。最終的に、解決策は、環境を敵対的にし、コントロールと標準化された動作をNATに導入することです。ただし、そのような時期になるまで、Stunは、運用を余儀なくされる恐ろしい条件を考えると、良い短期的な解決策を提供します。"
    },
    {
      "indent": 0,
      "text": "15. Acknowledgments",
      "section_title": true,
      "ja": "15. 謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Cedric Aoun, Pete Cordell, Cullen Jennings, Bob Penfield and Chris Sullivan for their comments, and Baruch Sterman and Alan Hawrylyshen for initial implementations. Thanks for Leslie Daigle, Allison Mankin, Eric Rescorla, and Henning Schulzrinne for IESG and IAB input on this work.",
      "ja": "著者は、セドリック・アウン、ピート・コーデル、カレン・ジェニングス、ボブ・ペンフィールド、クリス・サリバンのコメント、およびバルーシュ・スターマンとアラン・ホーリリーが最初の実装について感謝したいと思います。Leslie Daigle、Allison Mankin、Eric Rescorla、Henning Schulzrinneに、この作業に関するIESGとIABの入力をありがとう。"
    },
    {
      "indent": 0,
      "text": "16. Normative References",
      "section_title": true,
      "ja": "16. 引用文献"
    },
    {
      "indent": 3,
      "text": "[1] Bradner, S., \"Key words for use in RFCs to indicate requirement levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[1] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[2] Dierks, T. and C. Allen, \"The TLS protocol Version 1.0\", RFC 2246, January 1999.",
      "ja": "[2] Dierks、T。およびC. Allen、「TLSプロトコルバージョン1.0」、RFC 2246、1999年1月。"
    },
    {
      "indent": 3,
      "text": "[3] Gulbrandsen, A., Vixie, P. and L. Esibov, \"A DNS RR for specifying the location of services (DNS SRV)\", RFC 2782, February 2000.",
      "ja": "[3] Gulbrandsen、A.、Vixie、P。and L. Esibov、「サービスの場所（DNS SRV）を指定するためのDNS RR」、RFC 2782、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[4] Chown, P., \"Advanced Encryption Standard (AES) Ciphersuites for Transport Layer Security (TLS)\", RFC 3268, June 2002.",
      "ja": "[4] Chown、P。、「輸送層のセキュリティ（TLS）のための高度な暗号化標準（AES）ciphersuites」、RFC 3268、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[5] Rescorla, E., \"HTTP over TLS\", RFC 2818, May 2000.",
      "ja": "[5] Rescorla、E。、「TLS上のHTTP」、RFC 2818、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[6] Postel, J., \"Internet Protocol\", STD 5, RFC 791, September 1981.",
      "ja": "[6] Postel、J。、「インターネットプロトコル」、STD 5、RFC 791、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[7] Ferguson, P. and D. Senie, \"Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing\", BCP 38, RFC 2827, May 2000.",
      "ja": "[7] Ferguson、P。およびD. Senie、「ネットワークイングレスフィルタリング：IPソースアドレススプーフィングを採用するサービス拒否攻撃の敗北」、BCP 38、RFC 2827、2000年5月。"
    },
    {
      "indent": 0,
      "text": "17. Informative References",
      "section_title": true,
      "ja": "17. 参考引用"
    },
    {
      "indent": 3,
      "text": "[8] Senie, D., \"Network Address Translator (NAT)-Friendly Application Design Guidelines\", RFC 3235, January 2002.",
      "ja": "[8] Senie、D。、「ネットワークアドレス翻訳者（NAT）フレンドリーアプリケーション設計ガイドライン」、RFC 3235、2002年1月。"
    },
    {
      "indent": 3,
      "text": "[9] Srisuresh, P., Kuthan, J., Rosenberg, J., Molitor, A. and A. Rayhan, \"Middlebox Communication Architecture and Framework\", RFC 3303, August 2002.",
      "ja": "[9] Srisuresh、P.、Kuthan、J.、Rosenberg、J.、Molitor、A。、およびA. Rayhan、「Middlebox Communication Architecture and Framework」、RFC 3303、2002年8月。"
    },
    {
      "indent": 3,
      "text": "[10] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M. and E. Schooler, \"SIP: Session Initiation Protocol\", RFC 3261, June 2002.",
      "ja": "[10] Rosenberg、J.、Schulzrinne、H.、Camarillo、G.、Johnston、A.、Peterson、J.、Sparks、R.、Handley、M.、E。Schooler、 \"SIP：SESSION INIATIATION Protocol\"、RFC 3261、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[11] Holdrege, M. and P. Srisuresh, \"Protocol Complications with the IP Network Address Translator\", RFC 3027, January 2001.",
      "ja": "[11] Holdrege、M。およびP. Srisuresh、「IPネットワークアドレス翻訳者とのプロトコルの合併症」、RFC 3027、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[12] Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobson, \"RTP: A Transport Protocol for Real-Time Applications\", RFC 1889, January 1996.",
      "ja": "[12] Schulzrinne、H.、Casner、S.、Frederick、R。and V. Jacobson、「RTP：リアルタイムアプリケーション用の輸送プロトコル」、RFC 1889、1996年1月。"
    },
    {
      "indent": 3,
      "text": "[13] Krawczyk, H., Bellare, M. and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[13] Krawczyk、H.、Bellare、M。、およびR. Canetti、「HMAC：メッセージ認証のためのキードハッシング」、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[14] Kohl, J. and C. Neuman, \"The kerberos Network Authentication Service (V5)\", RFC 1510, September 1993.",
      "ja": "[14] Kohl、J。およびC. Neuman、「The Kerberos Network Authentication Service（V5）」、RFC 1510、1993年9月。"
    },
    {
      "indent": 3,
      "text": "[15] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.",
      "ja": "[15] Fielding、R.、Gettys、J.、Mogul、J.、Frystyk、H.、Masinter、L.、Leach、P。and T. Berners-Lee、「HyperText Transfer Protocol-HTTP/1.1」、RFC 2616、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[16] Baugher M., et al., \"The secure real-time transport protocol\", Work in Progress.",
      "ja": "[16] Baugher M.、et al。、「安全なリアルタイム輸送プロトコル」、進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[17] Daigle, L., Editor, \"IAB Considerations for UNilateral Self-Address Fixing (UNSAF) Across Network Address Translation\", RFC 3424, November 2002.",
      "ja": "[17] Daigle、L.、編集者、「ネットワークアドレス翻訳全体の一方的な自己アドレス固定（UNSAF）のIABの考慮事項」、RFC 3424、2002年11月。"
    },
    {
      "indent": 3,
      "text": "[18] Huitema, C., \"RTCP attribute in SDP\", Work in Progress.",
      "ja": "[18] Huitema、C。、「SDPのRTCP属性」、進行中の作業。"
    },
    {
      "indent": 0,
      "text": "18. Authors' Addresses",
      "section_title": true,
      "ja": "18. 著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Jonathan Rosenberg dynamicsoft 72 Eagle Rock Avenue First Floor East Hanover, NJ 07936",
      "ja": "ジョナサンローゼンバーグダイナミクスソフト72イーグルロックアベニュー1階イーストハノーバー、ニュージャージー07936"
    },
    {
      "indent": 3,
      "text": "EMail: jdrosen@dynamicsoft.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Joel Weinberger dynamicsoft 72 Eagle Rock Avenue First Floor East Hanover, NJ 07936",
      "ja": "Joel Weinberger Dynamicsoft 72 Eagle Rock Avenue 1階イーストハノーバー、ニュージャージー07936"
    },
    {
      "indent": 3,
      "text": "EMail: jweinberger@dynamicsoft.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Christian Huitema Microsoft Corporation One Microsoft Way Redmond, WA 98052-6399",
      "ja": "Christian Huitema Microsoft Corporation One Microsoft Way Redmond、WA 98052-6399"
    },
    {
      "indent": 3,
      "text": "EMail: huitema@microsoft.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Rohan Mahy Cisco Systems 101 Cooper St Santa Cruz, CA 95060",
      "ja": "Rohan Mahy Cisco Systems 101 Cooper St Santa Cruz、CA 95060"
    },
    {
      "indent": 3,
      "text": "EMail: rohan@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "19. Full Copyright Statement",
      "section_title": true,
      "ja": "19. 完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2003）。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントと本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}