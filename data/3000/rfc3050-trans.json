{
  "title": {
    "text": "RFC 3050 - Common Gateway Interface for SIP",
    "ja": "RFC 3050 - SIP用の共通ゲートウェイインターフェイス"
  },
  "number": 3050,
  "created_at": "2023-12-26 11:17:20.299953+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          J. Lennox\nRequest for Comments: 3050                                H. Schulzrinne\nCategory: Informational                                      Columbia U.\n                                                            J. Rosenberg\n                                                             dynamicsoft\n                                                            January 2001",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Common Gateway Interface for SIP",
      "ja": "SIP用の共通ゲートウェイインターフェイス"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモは、インターネットコミュニティに情報を提供します。いかなる種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2001）。無断転載を禁じます。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "In Internet telephony, there must be a means by which new services are created and deployed rapidly. In the World Wide Web, the Common Gateway Interface (CGI) has served as popular means towards programming web services. Due to the similarities between the Session Initiation Protocol (SIP) and the Hyper Text Transfer Protocol (HTTP), CGI is a good candidate for service creation in a SIP environment. This document defines a SIP CGI interface for providing SIP services on a SIP server.",
      "ja": "インターネットテレフォニーには、新しいサービスが迅速に作成および展開される手段が必要です。World Wide Webでは、Common Gateway Interface（CGI）は、Webサービスのプログラミングに向けて一般的な手段として機能しています。セッション開始プロトコル（SIP）とハイパーテキスト転送プロトコル（HTTP）の類似性により、CGIはSIP環境でのサービス作成の優れた候補です。このドキュメントでは、SIPサーバーでSIPサービスを提供するためのSIP CGIインターフェイスを定義しています。"
    },
    {
      "indent": 0,
      "text": "IESG Note",
      "ja": "IESGノート"
    },
    {
      "indent": 3,
      "text": "The IESG notes that the mechanism specified here depends on the Common Gateway Interface. Should this interface change or be enhanced changes in this specification may also be necessary or appropriate. According to the W3C, the CGI is presently maintained by the NCSA Software Development Group. See",
      "ja": "IESGは、ここで指定されているメカニズムは共通のゲートウェイインターフェイスに依存していることを指摘しています。このインターフェイスが変更されたり、この仕様の変更が強化されたりした場合も、必要または適切である可能性があります。W3Cによると、CGIは現在NCSAソフトウェア開発グループによって維持されています。見る"
    },
    {
      "indent": 6,
      "text": "http://www.w3c.org/cgi",
      "ja": "http://www.w3c.org/cgi"
    },
    {
      "indent": 3,
      "text": "for additional information on the current state of the CGI interface.",
      "ja": "CGIインターフェイスの現在の状態に関する追加情報。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1          Introduction .......................................   3\n2          Motivations ........................................   4\n3          Differences from HTTP CGI ..........................   5\n3.1        Basic Model ........................................   6\n3.2        Persistence Model ..................................   8\n3.3        SIP CGI Triggers ...................................   9\n3.4        Naming .............................................   9\n3.5        Environment Variables ..............................   9\n3.6        Timers .............................................  10\n4          Overview of SIP CGI ................................  10\n5          SIP CGI Specification ..............................  12\n5.1        Introduction .......................................  12\n5.1.1      Relationship with HTTP CGI .........................  12\n5.1.2      Conventions of This Document .......................  12\n5.1.3      Specifications .....................................  12\n5.1.4      Terminology ........................................  13\n5.2        Notational Conventions and Generic Grammar .........  13\n5.3        Invoking the Script ................................  14\n5.4        The SIP CGI Script Command Line ....................  14\n5.5        Data Input to the SIP CGI Script ...................  14\n5.5.1      Message Metadata (Metavariables) ...................  14\n5.5.1.1    AUTH_TYPE ..........................................  16\n5.5.1.2    CONTENT_LENGTH .....................................  16\n5.5.1.3    CONTENT_TYPE .......................................  17\n5.5.1.4    GATEWAY_INTERFACE ..................................  17\n5.5.1.5    Protocol-Specific Metavariables ....................  18\n5.5.1.6    REGISTRATIONS ......................................  18\n5.5.1.7    REMOTE_ADDR ........................................  19\n5.5.1.8    REMOTE_HOST ........................................  19\n5.5.1.9    REMOTE_IDENT .......................................  19\n5.5.1.10   REMOTE_USER ........................................  20\n5.5.1.11   REQUEST_METHOD .....................................  20\n5.5.1.12   REQUEST_TOKEN ......................................  21\n5.5.1.13   REQUEST_URI ........................................  21\n5.5.1.14   RESPONSE_STATUS ....................................  21\n5.5.1.15   RESPONSE_REASON ....................................  21\n5.5.1.16   RESPONSE_TOKEN .....................................  21\n5.5.1.17   SCRIPT_COOKIE ......................................  22\n5.5.1.18   SERVER_NAME ........................................  22\n5.5.1.19   SERVER_PORT ........................................  22\n5.5.1.20   SERVER_PROTOCOL ....................................  22\n5.5.1.21   SERVER_SOFTWARE ....................................  23\n5.5.2      Message Bodies .....................................  23\n5.6        Data Output from the SIP CGI Script ................  23\n5.6.1      CGI Action Lines ...................................  25\n5.6.1.1    Status .............................................  25\n   5.6.1.2    Proxy Request ......................................  25\n5.6.1.3    Forward Response ...................................  26\n5.6.1.4    Script Cookie ......................................  26\n5.6.1.5    CGI Again ..........................................  27\n5.6.1.6    Default Action .....................................  27\n5.6.2      CGI Header Fields ..................................  28\n5.6.2.1    Request-Token ......................................  28\n5.6.2.2    Remove .............................................  28\n5.7        Local Expiration Handling ..........................  28\n5.8        Locally-Generated Responses ........................  29\n5.9        SIP CGI and REGISTER ...............................  29\n5.10       SIP CGI and CANCEL .................................  29\n5.11       SIP CGI and ACK ....................................  30\n5.11.1     Receiving ACK's ....................................  30\n5.11.2     Sending ACK's ......................................  30\n6          System Specifications ..............................  30\n6.1        Unix ...............................................  30\n6.2        Microsoft Windows ..................................  31\n7          Security Considerations ............................  31\n7.1        Request Initiation .................................  31\n7.2        Authenticated and Encrypted Messages ...............  31\n7.3        SIP Header Fields Containing Sensitive Information..  32\n7.4        Script Interference with the Server ................  32\n7.5        Data Length and Buffering Considerations ...........  32\n8          Acknowledgements ...................................  33\n9          Authors' Addresses .................................  33\n10         Bibliography .......................................  34\n11         Full Copyright Statement ...........................  35",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1 Introduction",
      "ja": "1はじめに"
    },
    {
      "indent": 3,
      "text": "In Internet telephony, there must be a means by which new services are created and deployed rapidly. In traditional telephony networks, this was accomplished through IN service creation environments, which provided an interface for creating new services, often using GUI-based tools.",
      "ja": "インターネットテレフォニーには、新しいサービスが迅速に作成および展開される手段が必要です。従来のテレフォニーネットワークでは、これはサービス作成環境で実現され、GUIベースのツールを使用することが多い新しいサービスを作成するためのインターフェイスを提供しました。"
    },
    {
      "indent": 3,
      "text": "The WWW has evolved with its own set of tools for service creation. Originally, web servers simply translated URLs into filenames stored on a local system, and returned the file content. Over time, servers evolved to provide dynamic content, and forms provided a means for soliciting user input. In essence, what evolved was a means for service creation in a web environment. There are now many means for creation of dynamic web content, including server side JavaScript, servlets, and the common gateway interface (CGI) [1].",
      "ja": "WWWは、サービスを作成するための独自のツールセットで進化しました。もともと、Webサーバーは、URLをローカルシステムに保存されたファイル名に単純に翻訳し、ファイルコンテンツを返しました。時間が経つにつれて、サーバーは動的なコンテンツを提供するように進化し、フォームはユーザー入力を勧誘する手段を提供しました。本質的に、進化したのは、ウェブ環境でのサービス作成の手段でした。現在、サーバー側のJavaScript、サーブレット、Common Gatewayインターフェイス（CGI）[1]など、動的Webコンテンツの作成には多くの手段があります。"
    },
    {
      "indent": 3,
      "text": "Multimedia communications, including Internet telephony, will also require a mechanism for creating services. This mechanism is strongly tied to the features provided by the signaling protocols. The Session Initiation Protocol (SIP) [2] has been developed for initiation and termination of multimedia sessions. SIP borrows heavily from HTTP, inheriting its client-server interaction and much of its syntax and semantics. For this reason, the web service creation environments, and CGI in particular, seem attractive as starting points for developing SIP based service creation environments.",
      "ja": "インターネットテレフォニーを含むマルチメディア通信には、サービスを作成するためのメカニズムも必要です。このメカニズムは、シグナリングプロトコルによって提供される機能に強く結び付けられています。セッション開始プロトコル（SIP）[2]は、マルチメディアセッションの開始と終了のために開発されました。SIPはHTTPから大きく借用し、クライアントサーバーの相互作用とその構文とセマンティクスの多くを継承します。このため、Webサービスの作成環境、特にCGIは、SIPベースのサービス作成環境を開発するための出発点として魅力的に思えます。"
    },
    {
      "indent": 0,
      "text": "2 Motivations",
      "ja": "2つの動機"
    },
    {
      "indent": 3,
      "text": "CGI has a number of strengths which make it attractive as an environment for creating SIP services:",
      "ja": "CGIには、SIPサービスを作成するための環境として魅力的なものになる多くの強みがあります。"
    },
    {
      "indent": 8,
      "text": "Language independence: CGI works with perl, C, VisualBasic, tcl, and many other languages, as long as they support access to environment variables.",
      "ja": "言語の独立性：CGIは、環境変数へのアクセスをサポートする限り、Perl、C、VisualBasic、TCL、および他の多くの言語で動作します。"
    },
    {
      "indent": 8,
      "text": "Exposes all headers: CGI exposes the content of all the headers in an HTTP request to the CGI application. An application can make use of these as it sees fit, and ignore those it doesn't care about. This allows all aspects of an HTTP request to be considered for creation of content. In a SIP environment, headers have greater importance than in HTTP. They carry critical information about the transaction, including caller and callee, subject, contact addresses, organizations, extension names, registration parameters and expirations, call status, and call routes, to name a few. It is therefore critical for SIP services to have as much access to these headers as possible. For this reason, CGI is very attractive.",
      "ja": "すべてのヘッダーを公開します。CGIは、すべてのヘッダーのコンテンツをHTTPリクエストでCGIアプリケーションに公開します。アプリケーションは、適切と思われるようにこれらを利用し、気にしないものを無視できます。これにより、HTTPリクエストのすべての側面をコンテンツの作成に考慮することができます。SIP環境では、ヘッダーはHTTPよりも重要です。発信者とCallee、件名、連絡先住所、組織、拡張名、登録パラメーター、有効期限、コールステータス、コールルートなど、トランザクションに関する重要な情報があります。したがって、SIPサービスがこれらのヘッダーにできるだけ多くのアクセスを持つことが重要です。このため、CGIは非常に魅力的です。"
    },
    {
      "indent": 8,
      "text": "Creation of responses: CGI is advantageous in that it can create all parts of a response, including headers, status codes and reason phrases, in addition to message bodies. This is not the case for other mechanisms, such as Java servlets, which are focused primarily on the body. In a SIP environment, it is critical to be able to generate all aspects of a response (and, all aspects of new or proxied requests), since the body is usually not of central importance in SIP service creation.",
      "ja": "応答の作成：CGIは、メッセージ本文に加えて、ヘッダー、ステータスコード、理由フレーズを含む応答のすべての部分を作成できるという点で有利です。これは、主に身体に焦点を当てているJavaサーブレットなど、他のメカニズムには当てはまりません。SIP環境では、通常、体はSIPサービスの作成において中心的に重要ではないため、応答のすべての側面（および新規またはプロキシのリクエストのすべての側面）を生成できることが重要です。"
    },
    {
      "indent": 8,
      "text": "Component reuse: Many of the CGI utilities allow for easy reading of environment variables, parsing of form data, and often parsing and generation of header fields. Since SIP reuses the basic RFC822 [3] syntax of HTTP, many of these tools are applicable to SIP CGI.",
      "ja": "コンポーネントの再利用：CGIユーティリティの多くは、環境変数を簡単に読みやすく、フォームデータの解析、しばしばヘッダーフィールドの解析と生成を可能にします。SIPはHTTPの基本的なRFC822 [3]の構文を再利用するため、これらのツールの多くはSIP CGIに適用できます。"
    },
    {
      "indent": 8,
      "text": "Familiar environment: Many web programmers are familiar with CGI.",
      "ja": "おなじみの環境：多くのWebプログラマーはCGIに精通しています。"
    },
    {
      "indent": 8,
      "text": "Ease of extensibility: Since CGI is an interface and not a language, it becomes easy to extend and reapply to other protocols, such as SIP.",
      "ja": "拡張性の容易さ：CGIは言語ではなくインターフェイスであるため、SIPなどの他のプロトコルに簡単に拡張して再適用できます。"
    },
    {
      "indent": 3,
      "text": "The generality, extensibility, and detailed control and access to information provided by CGI, coupled with the range of tools that exist for it, which can be immediately applied to SIP, make it a good mechanism for SIP service creation.",
      "ja": "CGIが提供する情報への一般性、拡張性、詳細な制御とアクセスは、そのために存在するツールの範囲と組み合わせて、すぐにSIPに適用できるため、SIPサービス作成の優れたメカニズムになります。"
    },
    {
      "indent": 0,
      "text": "3 Differences from HTTP CGI",
      "ja": "HTTP CGIとの3つの違い"
    },
    {
      "indent": 3,
      "text": "While SIP and HTTP share a basic syntax and a request-response model, there are important differences. Proxies play a critical role in services for SIP, while they are less important for HTTP. SIP servers can fork requests (proxying multiple requests when a single request is received), an important capability absent from HTTP. SIP supports additional features, such as registrations, which are absent from HTTP. These differences are reflected in the differences between SIP CGI and HTTP CGI. SIP CGI runs primarily on proxy, redirect, and registrar servers, rather than user agent servers (which are the equivalent of origin servers in HTTP). SIP CGI allows the script to perform specific messaging functions not supported in HTTP CGI (such as proxying requests), and SIP CGI introduces a persistence model that allow a script to maintain control through multiple message exchanges. HTTP CGI has no persistence for scripts.",
      "ja": "SIPとHTTPは基本的な構文とリクエスト応答モデルを共有していますが、重要な違いがあります。プロキシはSIPのサービスで重要な役割を果たしますが、HTTPにとってはそれほど重要ではありません。SIPサーバーは、httpに存在しない重要な機能である（単一のリクエストが受信されたときに複数のリクエストをプロキシングする）要求をフォークできます。SIPは、HTTPに存在しない登録などの追加機能をサポートしています。これらの違いは、SIP CGIとHTTP CGIの違いに反映されています。SIP CGIは、ユーザーエージェントサーバー（HTTPのオリジンサーバーに相当）ではなく、主にプロキシ、リダイレクト、およびレジストラサーバーで実行されます。SIP CGIを使用すると、スクリプトはHTTP CGI（プロキシリクエストなど）でサポートされていない特定のメッセージング関数を実行でき、SIP CGIは、スクリプトが複数のメッセージ交換を通じて制御を維持できる永続性モデルを導入します。HTTP CGIには、スクリプトの持続性がありません。"
    },
    {
      "indent": 0,
      "text": "3.1 Basic Model",
      "section_title": true,
      "ja": "3.1 基本モデル"
    },
    {
      "indent": 3,
      "text": "The basic model for HTTP CGI is depicted in figure 1.",
      "ja": "HTTP CGIの基本モデルを図1に示します。"
    },
    {
      "indent": 4,
      "text": "            -----    ------------\n ~~~~~~~~  |req  |  |  --------  |\n|        |----------| |  http  | |\n| client | |resp |  | | server | |\n|        |----------| |        | |w\n ~~~~~~~~  |     |  |  --------  |e\n            -----   |  s|  /\\s   |b\n           net      |  t|   |t   |\n                    |e d| C |d   |s\n                    |n i| G |o   |e\n                    |v n| I |u   |r\n                    |   |   |t   |v\n                    |  \\/   |    |e\n                    |  -------   |r\n                    | |       |  |\n                    | |  CGI  |  |\n                    | | prog. |  |\n                    | |       |  |\n                    |  -------   |\n                     ------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 1: HTTP CGI Model",
      "ja": "図1：HTTP CGIモデル"
    },
    {
      "indent": 3,
      "text": "A client issues an HTTP request, which is passed either directly to the origin server (as shown), or is forwarded through a proxy server. The origin server executes a CGI script, and the CGI script returns a response, which is passed back to the client. The main job of the script is to generate the body for the response. Only origin servers execute CGI scripts, not proxy servers.",
      "ja": "クライアントは、HTTP要求を発行します。これは、Origin Serverに直接渡され（図のように）、またはプロキシサーバーを介して転送されます。Origin ServerはCGIスクリプトを実行し、CGIスクリプトは応答を返し、クライアントに渡されます。スクリプトの主な仕事は、応答のために本体を生成することです。Origin ServerのみがCGIスクリプトを実行し、プロキシサーバーではありません。"
    },
    {
      "indent": 3,
      "text": "In a SIP server, the model is different, and is depicted in Figure 2.",
      "ja": "SIPサーバーでは、モデルは異なり、図2に示されています。"
    },
    {
      "indent": 4,
      "text": " ~~~~~~~~   req  -------   req   -------     req   ~~~~~~~~\n|        |------|       |-------|       |---------|        |\n| client | resp | server| resp  | server| resp    | client |\n|        |------|       |-------|       |---------|        |\n ~~~~~~~~        -------         -------           --------\n                  |   | CGI\n                  |   |\n                 -------\n                |       |\n                |  CGI  |\n                | prog. |\n                |       |\n                 -------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 2: SIP CGI Model",
      "ja": "図2：SIP CGIモデル"
    },
    {
      "indent": 3,
      "text": "The client generates a request, which is forwarded to a server. The server may generate a response (such as an error or redirect response). Or, if the server is a proxy server, the request is proxied to another server, and eventually to a user agent, and the response is passed back upstream, through the server, and back towards the client. A SIP proxy server may additionally fork requests, generating multiple requests in response to a received request. Generally, a proxy server will not generate the content in responses. These contain session descriptions created by user agents. Services, such as call forward and mobility services, are based on the decisions the server makes about (1) when, to where, and how many requests to proxy downstream, and (2) when to send a response back upstream. Creation of services such as ad-hoc bridging (where the server acts as a media mixer in a multiparty call, without being asked to do so by the end users) will require the server to generate new requests of its own, and for it to modify and generate the body in responses.",
      "ja": "クライアントは、サーバーに転送されるリクエストを生成します。サーバーは、応答を生成する場合があります（エラーやリダイレクト応答など）。または、サーバーがプロキシサーバーである場合、リクエストは別のサーバーに、最終的にはユーザーエージェントにプロキシ化され、応答はサーバーを介して上流に戻り、クライアントに向かって戻ります。SIPプロキシサーバーはさらに、要求をフォークし、受信した要求に応じて複数のリクエストを生成する場合があります。通常、プロキシサーバーは応答のコンテンツを生成しません。これらには、ユーザーエージェントによって作成されたセッションの説明が含まれています。コールフォワードサービスやモビリティサービスなどのサービスは、サーバーが（1）下流のプロキシへのリクエスト数、および（2）上流に返信を送信する時期についての決定を下す決定に基づいています。アドホックブリッジングなどのサービスの作成（エンドユーザーからそうするように求められることなく、マルチパーティコールでサーバーがメディアミキサーとして機能する場合）は、サーバーが独自の新しいリクエストを生成する必要があります。応答で体を変更して生成します。"
    },
    {
      "indent": 3,
      "text": "An HTTP server is mainly concerned about generation of responses. A SIP server is generally concerned about performing four basic operations:",
      "ja": "HTTPサーバーは、主に応答の生成に関係しています。通常、SIPサーバーは4つの基本操作を実行することを懸念しています。"
    },
    {
      "indent": 8,
      "text": "Proxying of Requests: Receiving a request, adding or modifying any of the headers, deciding on a set of servers to forward the request to, and forwarding it to them.",
      "ja": "リクエストのプロキシ：リクエストの受信、ヘッダーの追加または変更、リクエストを転送するためにサーバーのセットを決定し、それらに転送します。"
    },
    {
      "indent": 8,
      "text": "Returning Responses: Receiving a response, adding or modifying any of the headers, and passing the response towards the client.",
      "ja": "回答の返信：応答を受信し、ヘッダーを追加または変更し、クライアントに応答を渡します。"
    },
    {
      "indent": 8,
      "text": "Generating Requests: Creating a new request, originating at the server, placing headers and a body into the message, and sending it to a server.",
      "ja": "リクエストの生成：サーバーで発信する新しいリクエストの作成、ヘッダーと本文をメッセージに配置し、サーバーに送信します。"
    },
    {
      "indent": 8,
      "text": "Generation of Responses: Receiving a request, generating a response to it, and sending it back to the client.",
      "ja": "応答の生成：リクエストを受信し、それに対する応答を生成し、クライアントに送り返します。"
    },
    {
      "indent": 3,
      "text": "When a request is received, one or more of the above operations may occur at once. For example, a SIP server may generate a provisional response, generate a new request, and proxy the original request to two servers. This implies that SIP CGI must encompass a greater set of functions than HTTP CGI. These functions are a super-set of the simple end-server request/response model.",
      "ja": "リクエストが受信されると、上記の操作の1つ以上が一度に発生する場合があります。たとえば、SIPサーバーは暫定的な応答を生成し、新しいリクエストを生成し、2つのサーバーに元のリクエストをプロキシできます。これは、SIP CGIがHTTP CGIよりも大きな関数セットを網羅する必要があることを意味します。これらの関数は、単純なエンドサーバーリクエスト/応答モデルのスーパーセットです。"
    },
    {
      "indent": 0,
      "text": "3.2 Persistence Model",
      "section_title": true,
      "ja": "3.2 持続モデル"
    },
    {
      "indent": 3,
      "text": "In HTTP CGI, a script is executed once for each request. It generates the response, and then terminates. There is no state maintained across requests from the same user, as a general rule (although this can be done -- and is -- for more complex services such as database accesses, which essentially encapsulate state in client-side cookies or dynamically-generated URLs). A transaction is just a single request, and a response.",
      "ja": "HTTP CGIでは、各リクエストに対してスクリプトが1回実行されます。応答を生成し、終了します。一般的なルールと同じユーザーからの要求を介して維持されている状態はありません（これは、これを行うことができますが、データベースアクセスなどのより複雑なサービスの場合、クライアント側のCookieの状態を本質的にカプセル化したり、動的に生成したりします。URL）。トランザクションは単一のリクエストと応答です。"
    },
    {
      "indent": 3,
      "text": "In SIP CGI, since a request can generate many new and proxied requests, these themselves will generate responses. A service will often require these responses to be processed, and additional requests or responses to be generated. As a result, whereas an HTTP CGI script executes once per transaction, a SIP CGI script must maintain control somehow over numerous events.",
      "ja": "SIP CGIでは、リクエストが多くの新しいリクエストを生成できるため、これら自体が応答を生成します。多くの場合、サービスではこれらの応答を処理する必要があり、追加のリクエストまたは応答を生成する必要があります。その結果、HTTP CGIスクリプトはトランザクションごとに1回実行されますが、SIP CGIスクリプトは、多数のイベントで何らかの形でコントロールを維持する必要があります。"
    },
    {
      "indent": 3,
      "text": "In order to enable this, and to stay with the original CGI model, we mandate that a SIP CGI script executes when a message arrives, and after generating output (in the form of additional messages), terminate. State is maintained by allowing the CGI to return an opaque token to the server. When the CGI script is called again for the same transaction, this token is passed back to the CGI script. When called for a new transaction, no token is passed.",
      "ja": "これを有効にし、元のCGIモデルにとどまるために、メッセージが届いたときにSIP CGIスクリプトが実行され、出力（追加のメッセージの形で）を生成した後、終了することを義務付けます。状態は、CGIがサーバーに不透明なトークンを返すことを許可することにより維持されます。同じトランザクションに対してCGIスクリプトが再び呼び出されると、このトークンはCGIスクリプトに渡されます。新しいトランザクションを求めると、トークンは渡されません。"
    },
    {
      "indent": 3,
      "text": "For example, consider a request which arrives at a SIP server. The server calls a CGI script, which generates a provisional response and a proxied request. It also returns a token to the server, and then terminates. The response is returned upstream towards the client, and the request is proxied. When the response to the proxied request arrives, the script is executed again. The environment variables are set based on the content of the new response. The script is also passed back the token. Using the token as its state, the script decides to proxy the request to a different location. It therefore returns a proxied request, and another token. The server forwards this new request, and when the response comes, calls the CGI script once more, and passes back the token. This time, the script generates a final response, and passes this back to the server. The server sends the response to the client, destroys the token, and the transaction is complete.",
      "ja": "たとえば、SIPサーバーに到着するリクエストを検討してください。サーバーは、暫定的な応答とプロキシリクエストを生成するCGIスクリプトを呼び出します。また、トークンをサーバーに返し、終了します。応答はクライアントに向かって上流に戻され、リクエストがプロキシになります。プロキシリクエストへの応答が届くと、スクリプトは再び実行されます。環境変数は、新しい応答の内容に基づいて設定されます。スクリプトはトークンも渡されます。トークンをその状態として使用して、スクリプトはリクエストを別の場所にプロキシすることを決定します。したがって、プロキシリクエストと別のトークンを返します。サーバーはこの新しい要求を転送し、応答が来たら、CGIスクリプトをもう一度呼び出し、トークンを渡します。今回は、スクリプトが最終的な応答を生成し、これをサーバーに戻します。サーバーはクライアントに応答を送信し、トークンを破壊し、トランザクションが完了します。"
    },
    {
      "indent": 0,
      "text": "3.3 SIP CGI Triggers",
      "section_title": true,
      "ja": "3.3 SIP CGIトリガー"
    },
    {
      "indent": 3,
      "text": "In many cases, calling the CGI script on the reception of every message is inefficient. CGI scripts come at the cost of significant overhead since they generally require creation of a new process. Therefore, it is important in SIP CGI for a script to indicate, after it is called the first time, under what conditions it will be called for the remainder of the transaction. If the script is not called, the server will take the \"default\" action, as specified in this document. This allows an application designer to trade off flexibility for computational resources. Making an analogy to the Intelligent Network (IN) - a script is able to define the triggers for its future execution.",
      "ja": "多くの場合、すべてのメッセージの受信時にCGIスクリプトを呼び出すことは非効率的です。CGIスクリプトは、一般に新しいプロセスの作成が必要なため、大幅なオーバーヘッドを犠牲にします。したがって、SIP CGIでは、スクリプトが最初に呼ばれた後、トランザクションの残りのためにどの条件で呼び出されるかを示すことが重要です。スクリプトが呼び出されない場合、サーバーはこのドキュメントで指定されているように「デフォルト」アクションを実行します。これにより、アプリケーション設計者は計算リソースの柔軟性をトレードオフできます。インテリジェントネットワーク（in）に類似している - スクリプトは、将来の実行のためにトリガーを定義することができます。"
    },
    {
      "indent": 3,
      "text": "So, in summary, whereas an HTTP CGI script executes once during a transaction, a single SIP CGI script may execute many times during a transaction, and may specify at which points it would like to have control for the remainder of the transaction.",
      "ja": "したがって、要約すると、HTTP CGIスクリプトはトランザクション中に1回実行されますが、単一のSIP CGIスクリプトはトランザクション中に何度も実行され、トランザクションの残りのコントロールを希望するポイントを指定する場合があります。"
    },
    {
      "indent": 0,
      "text": "3.4 Naming",
      "section_title": true,
      "ja": "3.4 ネーミング"
    },
    {
      "indent": 3,
      "text": "In HTTP CGI, the CGI script itself is generally the resource named in the request URI of the HTTP request. This is not so in SIP. In general, the request URI names a user to be called. The mapping to a script to be executed may depend on other SIP headers, including To and From fields, the SIP method, status codes, and reason phrases. As such, the mapping of a message to a CGI script is purely a matter of local policy administration at a server. A server may have a single script which always executes, or it may have multiple scripts, and the target is selected by some parts of the header.",
      "ja": "HTTP CGIでは、CGIスクリプト自体は、一般に、HTTPリクエストのリクエストURIに名前が付けられたリソースです。これはSIPではそうではありません。一般に、リクエストはユーザーに呼ばれるユーザーに名前を付けます。実行されるスクリプトへのマッピングは、フィールド、SIPメソッド、ステータスコード、および理由フレーズを含む他のSIPヘッダーに依存する場合があります。そのため、CGIスクリプトへのメッセージのマッピングは、純粋にサーバーでのローカルポリシー管理の問題です。サーバーには常に実行される単一のスクリプトがある場合があります。または、複数のスクリプトがある場合があり、ターゲットはヘッダーの一部によって選択されます。"
    },
    {
      "indent": 0,
      "text": "3.5 Environment Variables",
      "section_title": true,
      "ja": "3.5 環境変数"
    },
    {
      "indent": 3,
      "text": "In HTTP CGI, environment variables are set with the values of the paths and other aspects of the request. As there is no notion of a path in SIP, some of these environment variables do not make sense.",
      "ja": "HTTP CGIでは、環境変数がパスの値とリクエストの他の側面で設定されています。SIPにパスの概念がないため、これらの環境変数の一部は意味がありません。"
    },
    {
      "indent": 0,
      "text": "3.6 Timers",
      "section_title": true,
      "ja": "3.6 タイマー"
    },
    {
      "indent": 3,
      "text": "In SIP, certain services require that the script gets called not only when a message arrives, but when some timer expires. The classic example of this is \"call forward no answer.\" To be implemented with SIP CGI, the first time the script is executed, it must generate a proxied request, and also indicate a time at which to be called again if no response comes. This kind of feature is not present in HTTP CGI, and some rudimentary support for it is needed in SIP CGI.",
      "ja": "SIPでは、特定のサービスでは、メッセージが届くだけでなく、いくつかのタイマーが期限切れになったときにスクリプトが呼び出される必要があります。この古典的な例は、「フォワードノー答えを呼び出す」です。SIP CGIを使用して実装するには、スクリプトが最初に実行されたときに、プロキシリクエストを生成する必要があり、応答がない場合に再び呼び出される時間を示す必要があります。この種の機能はHTTP CGIには存在しません。SIPCGIでは、ITに対する基本的なサポートが必要です。"
    },
    {
      "indent": 0,
      "text": "4 Overview of SIP CGI",
      "ja": "4 SIP CGIの概要"
    },
    {
      "indent": 3,
      "text": "When a request arrives at a SIP server, initiating a new transaction, the server will set a number of environment variables, and call a CGI script. The script is passed the body of the request through stdin.",
      "ja": "リクエストがSIPサーバーに到着し、新しいトランザクションを開始すると、サーバーは多くの環境変数を設定し、CGIスクリプトを呼び出します。スクリプトは、stdinを介して要求の本文に渡されます。"
    },
    {
      "indent": 3,
      "text": "The script returns, on stdout, a set of SIP action lines, each of which may be modified by CGI and/or SIP headers. This set is delimited through the use of two carriage returns. The action lines allow the script to specify any of the four operations defined above, in addition to the default operation. Generating a response is done by copying the the status line of the response into an action line of the CGI output. For example, the following will create a 200 OK to the original request:",
      "ja": "スクリプトは、STDOUTで、一連のSIPアクションラインを返します。それぞれがCGIおよび/またはSIPヘッダーによって変更される場合があります。このセットは、2つのキャリッジリターンを使用して区切られています。アクションラインを使用すると、スクリプトは、デフォルト操作に加えて、上記の4つの操作のいずれかを指定できます。応答の生成は、応答のステータス行をCGI出力のアクションラインにコピーすることにより行われます。たとえば、以下は元のリクエストに200 OKを作成します。"
    },
    {
      "indent": 3,
      "text": "SIP/2.0 200 OK",
      "ja": "SIP/2.0 200 OK"
    },
    {
      "indent": 3,
      "text": "The operation of proxying a request is supported by the CGI-PROXY-REQUEST CGI action, which takes the URL to proxy to as an argument. For example, to proxy a request to dante@inferno.com:",
      "ja": "リクエストのプロキシの操作は、CGI-Proxy-Request CGIアクションによってサポートされています。これにより、URLは引数としてプロキシになります。たとえば、dante@inferno.comへのリクエストを紹介するには："
    },
    {
      "indent": 3,
      "text": "CGI-PROXY-REQUEST sip:dante@inferno.com SIP/2.0\nContact: sip:server1@company.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In this example, the server will take the original request, and modify any header fields normally changed during the proxy operation (such as decrementing Max-Forwards, and adding a Via field). This message is then \"merged\" with the output of the CGI script - SIP headers specified below the action line in the CGI output will be added to the outbound request. In the above example, the Contact header will be added. Note that the action line looks like the request line of a SIP request message. This is done in order to simplify parsing.",
      "ja": "この例では、サーバーは元のリクエストを実行し、プロキシ操作中に通常変更されたヘッダーフィールドを変更します（最大化フォワードの減少やVIAフィールドの追加など）。このメッセージは、CGIスクリプトの出力と「マージ」されます。CGI出力のアクションラインの下に指定されたSIPヘッダーがアウトバウンドリクエストに追加されます。上記の例では、コンタクトヘッダーが追加されます。アクションラインは、SIPリクエストメッセージの要求行のように見えることに注意してください。これは、解析を簡素化するために行われます。"
    },
    {
      "indent": 3,
      "text": "To delete headers from the outgoing request, the merge process also supports the CGI header CGI-Remove. Like SIP headers, CGI headers are written underneath the action line. They are extracted by the SIP server, and used to provide the server with additional guidance.",
      "ja": "発信要求からヘッダーを削除するために、マージプロセスはCGIヘッダーCGIリモーブもサポートします。SIPヘッダーと同様に、CGIヘッダーはアクションラインの下に書かれています。それらはSIPサーバーによって抽出され、サーバーに追加のガイダンスを提供するために使用されます。"
    },
    {
      "indent": 3,
      "text": "CGI headers always begin with CGI to differentiate them from SIP headers. In this case, the supported values for the CGI-Remove header are the names of headers in the original message.",
      "ja": "CGIヘッダーは常にCGIから始まり、SIPヘッダーと区別します。この場合、CGIリモーブヘッダーのサポート値は、元のメッセージのヘッダーの名前です。"
    },
    {
      "indent": 3,
      "text": "Returning of responses is more complex. A server may receive multiple responses as the result of forking a request. The script should be able to ask the server to return any of the responses it had received previously. To support this, the server will pass an opaque token to the script through environment variables, unique for each response received. To return a response, a CGI script needs to indicate which response is to be returned. For example, to return a response named with the token abcdefghij, the following output is generated:",
      "ja": "応答の返却はより複雑です。サーバーは、リクエストのフォーキングの結果として、複数の応答を受信する場合があります。スクリプトは、以前に受け取った応答のいずれかを返すようにサーバーに依頼できるはずです。これをサポートするために、サーバーは、受信した応答ごとに一意の環境変数を介して、不透明なトークンを環境変数を介してスクリプトに渡します。応答を返すために、CGIスクリプトは、どの応答を返すかを示す必要があります。たとえば、Token Abcdefghijで名前が付けられた応答を返すために、次の出力が生成されます。"
    },
    {
      "indent": 3,
      "text": "CGI-FORWARD-RESPONSE abcdefghij SIP/2.0",
      "ja": "CGI-Forward-response abcdefghij sip/2.0"
    },
    {
      "indent": 3,
      "text": "Finally, if the script does not output any of the above actions, the server does what it would normally do upon receiving the message that triggered the script.",
      "ja": "最後に、スクリプトが上記のアクションのいずれかを出力しない場合、サーバーはスクリプトをトリガーしたメッセージを受信すると通常行うことを行います。"
    },
    {
      "indent": 3,
      "text": "A SIP CGI script is normally only executed when the original request arrives. If the script also wants to be called for subsequent messages in a transaction -- due to responses to proxied requests, or (in certain circumstances) ACK and CANCEL requests, it can perform the CGI-AGAIN action:",
      "ja": "SIP CGIスクリプトは、通常、元のリクエストが到着したときにのみ実行されます。スクリプトがトランザクションで後続のメッセージを呼び出すことを望んでいる場合 - プロキシリクエストへの応答、または（特定の状況で）ACKおよびキャンセル要求のために、CGI-Againアクションを実行できます。"
    },
    {
      "indent": 3,
      "text": "CGI-AGAIN yes SIP/2.0",
      "ja": "cgi-again yes sip/2.0"
    },
    {
      "indent": 3,
      "text": "This action applies only to the next invocation of the script; it means to invoke the script one more time. Outputting \"no\" is identical to outputting \"yes\" on this invocation of the script and outputting nothing the next time the script is called.",
      "ja": "このアクションは、スクリプトの次の呼び出しにのみ適用されます。スクリプトをもう一度呼び出すことを意味します。「いいえ」を出力することは、スクリプトのこの呼び出しで「はい」を出力し、次にスクリプトが呼び出されたときに何も出力しません。"
    },
    {
      "indent": 3,
      "text": "When the script is re-executed, it may need access to some state in order to continue processing. A script can generate one piece of state, called a cookie, for any new request or proxied request. It is passed to the server through the CGI-SET-COOKIE action. The action contains a token, which is the cookie itself. The server does not examine or parse the cookie. It is simply stored. When the script is re-executed, the cookie is passed back to the script through an environment variable.",
      "ja": "スクリプトが再実行されると、処理を継続するために何らかの状態にアクセスする必要がある場合があります。スクリプトは、新しいリクエストまたはプロキシリクエストのために、Cookieと呼ばれる1つの状態を生成できます。CGI-Set-Cookieアクションを介してサーバーに渡されます。アクションには、クッキー自体であるトークンが含まれています。サーバーは、Cookieを調べたり解析したりしません。それは単に保管されます。スクリプトが再実行されると、Cookieは環境変数を介してスクリプトに渡されます。"
    },
    {
      "indent": 3,
      "text": "CGI-SET-COOKIE khsihppii8asdl SIP/2.0",
      "ja": "cgi-set-cookie khsihppii8asdl sip/2.0"
    },
    {
      "indent": 3,
      "text": "Finally, when the script causes the server to proxy a request, responses to these requests will arrive. To ease matching of responses to requests, the script can place a request token in the CGI CGI-Request-Token header. This header is removed by the server when the request is proxied. Any responses received to this request will have the token passed in an environment variable.",
      "ja": "最後に、スクリプトがサーバーにリクエストをプロキシにすると、これらのリクエストへの応答が到着します。リクエストへの応答の一致を容易にするために、スクリプトはCGI CGI-Request-Tokenヘッダーにリクエストトークンを配置できます。このヘッダーは、リクエストがプロキシになったときにサーバーによって削除されます。このリクエストに受け取った回答は、トークンを環境変数で渡すことになります。"
    },
    {
      "indent": 0,
      "text": "5 SIP CGI Specification",
      "ja": "5 SIP CGI仕様"
    },
    {
      "indent": 0,
      "text": "5.1 Introduction",
      "section_title": true,
      "ja": "5.1 はじめに"
    },
    {
      "indent": 0,
      "text": "5.1.1 Relationship with HTTP CGI",
      "section_title": true,
      "ja": "5.1.1 HTTP CGIとの関係"
    },
    {
      "indent": 3,
      "text": "This SIP CGI specification is based on work-in-progress revision 1.1 of the HTTP CGI specification [1]. That document is a product of the CGI-WG mailing list, which is not an official IETF working group. CGI-WG's homepage is located at the URL http://Web.Golux.Com/coar/cgi/, and the most recent versions of the CGI specification are available there. This specification incorporates a great deal of text from the work-in-progress version of that document as of February 23, 2000. A future version of this specification may be changed to cite parts of that document by reference instead.",
      "ja": "このSIP CGI仕様は、HTTP CGI仕様[1]の進行中の改訂1.1に基づいています。そのドキュメントは、CGI-WGメーリングリストの製品であり、公式のIETFワーキンググループではありません。CGI-WGのホームページは、URL http://web.golux.com/coar/cgi/にあり、CGI仕様の最新のバージョンが利用可能です。この仕様には、2000年2月23日現在、そのドキュメントの進行中のバージョンからの多くのテキストが組み込まれています。この仕様の将来のバージョンは、代わりにそのドキュメントの一部を引用するために変更される場合があります。"
    },
    {
      "indent": 0,
      "text": "5.1.2 Conventions of This Document",
      "section_title": true,
      "ja": "5.1.2 この文書の慣習"
    },
    {
      "indent": 3,
      "text": "In this document, the key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" are to be interpreted as described in RFC 2119 [4] and indicate requirement levels for compliant SIP CGI implementations.",
      "ja": "このドキュメントでは、キーワードは「必要はない」、「必須」、「必要」、「shall」、「suff」、 \"nove\"、 \"bulsed\"、 \"becommended\"、 \"、\"、 \"、\" optional \"RFC 2119 [4]で説明されているように解釈され、準拠したSIP CGI実装の要件レベルを示します。"
    },
    {
      "indent": 8,
      "text": "Some paragraphs are indented, like this; they give motivations of design choices, or questions for future discussion in the development of SIP CGI. They are not normative to the specification of the protocol.",
      "ja": "このように、いくつかの段落がインデントされています。彼らは、SIP CGIの開発における将来の議論のための設計の選択の動機、または質問を与えます。これらは、プロトコルの仕様には規範的ではありません。"
    },
    {
      "indent": 0,
      "text": "5.1.3 Specifications",
      "section_title": true,
      "ja": "5.1.3 仕様"
    },
    {
      "indent": 3,
      "text": "Not all of the functions and features of SIP CGI are defined in the main part of this specification. The following phrases are used to describe the features which are not specified:",
      "ja": "SIP CGIの機能と機能のすべてが、この仕様の主要部分で定義されているわけではありません。次のフレーズは、指定されていない機能を説明するために使用されます。"
    },
    {
      "indent": 9,
      "text": "System-defined: The feature may differ between systems, but must be the same for different implementations using the same system. A system will usually identify a class of operating systems. Some systems are defined in section 6 of this document. New systems may be defined by new specifications without revision of this document.",
      "ja": "システム定義：この機能はシステム間で異なる場合がありますが、同じシステムを使用して異なる実装で同じでなければなりません。システムは通常、オペレーティングシステムのクラスを識別します。一部のシステムは、このドキュメントのセクション6で定義されています。新しいシステムは、このドキュメントの改訂なしに新しい仕様によって定義される場合があります。"
    },
    {
      "indent": 9,
      "text": "Implementation-defined: The behavior of the feature may vary from implementation to implementation, but a particular implementation should be consistent in its behavior.",
      "ja": "実装定義：機能の動作は実装ごとに異なる場合がありますが、特定の実装はその動作に一貫している必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1.4 Terminology",
      "section_title": true,
      "ja": "5.1.4 用語"
    },
    {
      "indent": 3,
      "text": "This specification uses many terms defined in the SIP/2.0 specification [2]; however, the following terms are used here in a sense which may not accord with their definitions in that document, or with their common meaning.",
      "ja": "この仕様では、SIP/2.0仕様[2]で定義されている多くの用語を使用しています。ただし、次の用語は、その文書の定義、または共通の意味と一致しない可能性のある意味でここで使用されます。"
    },
    {
      "indent": 9,
      "text": "metavariable: A named parameter that carries information from the server to the script. It is not necessarily a variable in the operating system's environment, although that is the most common implementation.",
      "ja": "MetAvariable：サーバーからスクリプトに情報を伝達する名前付きパラメーター。それは必ずしもオペレーティングシステムの環境で変数ではありませんが、それは最も一般的な実装です。"
    },
    {
      "indent": 9,
      "text": "script: The software which is invoked by the server via this interface. It need not be a standalone program, but could be a dynamically-loaded or shared library, or even a subroutine in the server. It may be a set of statements interpreted at run-time, as the term `script' is frequently understood, but that is not a requirement and within the context of this specification the term has the broader definition stated.",
      "ja": "スクリプト：このインターフェイスを介してサーバーによって呼び出されるソフトウェア。スタンドアロンプログラムである必要はありませんが、動的にロードされたライブラリまたは共有ライブラリ、またはサーバー内のサブルーチンでさえある場合があります。「スクリプト」という用語が頻繁に理解されるため、実行時に解釈される一連のステートメントかもしれませんが、それは要件ではなく、この仕様のコンテキスト内では、この用語にはより広範な定義が記載されています。"
    },
    {
      "indent": 9,
      "text": "server: The application program which invokes the script in order to service messages.",
      "ja": "サーバー：メッセージをサービスするためにスクリプトを呼び出すアプリケーションプログラム。"
    },
    {
      "indent": 9,
      "text": "message: A SIP request or response, typically either the one that triggered the invocation of the CGI script, or one that the CGI script caused to be sent.",
      "ja": "メッセージ：SIPリクエストまたは応答。通常、CGIスクリプトの呼び出しをトリガーしたもの、またはCGIスクリプトが送信されたもののいずれかです。"
    },
    {
      "indent": 0,
      "text": "5.2 Notational Conventions and Generic Grammar",
      "section_title": true,
      "ja": "5.2 表記規則と一般的な文法"
    },
    {
      "indent": 3,
      "text": "In this specification we use the Augmented Backus-Naur Form notation as described in appendix C of the SIP/2.0 specification, RFC 2543 [2].",
      "ja": "この仕様では、SIP/2.0仕様RFC 2543 [2]の付録Cに記載されているように、拡張されたバックスノーフォーム表記を使用します。"
    },
    {
      "indent": 3,
      "text": "The following grammatical constructs are taken from other documents; this table lists the appropriate sources.",
      "ja": "次の文法構造は、他の文書から取られています。このテーブルには、適切なソースがリストされています。"
    },
    {
      "indent": 8,
      "text": "OCTET          SIP/2.0 [2] Appendix C.1\nCHAR           SIP/2.0 [2] Appendix C.1\ndigit          SIP/2.0 [2] Appendix C.1\nalphanum       SIP/2.0 [2] Appendix C.1\ntoken          SIP/2.0 [2] Appendix C.1\nhostname       SIP/2.0 [2] Section 2\nSIP-URL        SIP/2.0 [2] Section 2\nSIP-Version    SIP/2.0 [2] Section 4.3.1\nStatus-Code    SIP/2.0 [2] Section 5.1.1\nReason-Phrase  SIP/2.0 [2] Section 5.1.1\nmedia-type     HTTP/1.1 [5] Section 3.7",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": " (via SIP/2.0 [2] Section 6.16) field-name SIP/2.0 [2] Section 6.6",
      "ja": "（SIP/2.0 [2]セクション6.16を介して）フィールド名SIP/2.0 [2]セクション6.6"
    },
    {
      "indent": 3,
      "text": "Other grammatical constructs taken from outside sources are noted in the text.",
      "ja": "外部のソースから取得した他の文法的構成要素は、テキストに記載されています。"
    },
    {
      "indent": 0,
      "text": "5.3 Invoking the Script",
      "section_title": true,
      "ja": "5.3 スクリプトを呼び出す"
    },
    {
      "indent": 3,
      "text": "The script is invoked in a system-defined manner. Unless specified otherwise, the file containing the script will be invoked as an executable program.",
      "ja": "スクリプトは、システム定義の方法で呼び出されます。特に指定されていない限り、スクリプトを含むファイルは実行可能プログラムとして呼び出されます。"
    },
    {
      "indent": 3,
      "text": "Only one CGI script at a time may be outstanding for a SIP transaction. If subsequently arriving responses would cause a CGI script to be invoked, handling of them is deferred, except for ACK, until CGI scripts for previous messages in the transaction terminate. Messages are processed in the order they are received.",
      "ja": "SIPトランザクションでは、一度に1つのCGIスクリプトのみが顕著です。その後、応答が届くとCGIスクリプトが呼び出されると、トランザクションの以前のメッセージのCGIスクリプトが終了するまで、ACKを除き、それらの処理が延期されます。メッセージは、受信される順序で処理されます。"
    },
    {
      "indent": 0,
      "text": "5.4 The SIP CGI Script Command Line",
      "section_title": true,
      "ja": "5.4 SIP CGIスクリプトコマンドライン"
    },
    {
      "indent": 3,
      "text": "The server SHOULD NOT provide any command line arguments to the script.",
      "ja": "サーバーは、スクリプトにコマンドライン引数を提供しないでください。"
    },
    {
      "indent": 8,
      "text": "Command line arguments are used for indexed queries in HTTP CGI; HTTP indexed queries do not have an equivalent in SIP.",
      "ja": "コマンドライン引数は、HTTP CGIのインデックス付きクエリに使用されます。HTTPインデックス付きクエリには、SIPに同等のものがありません。"
    },
    {
      "indent": 0,
      "text": "5.5 Data Input to the SIP CGI Script",
      "section_title": true,
      "ja": "5.5 SIP CGIスクリプトへのデータ入力"
    },
    {
      "indent": 3,
      "text": "Information about a message comes from two different sources: the message header, and any associated content-body. Servers MUST make portions of this information available to scripts.",
      "ja": "メッセージに関する情報は、メッセージヘッダーと関連するコンテンツボディの2つの異なるソースからのものです。サーバーは、この情報の一部をスクリプトで利用できるようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5.1 Message Metadata (Metavariables)",
      "section_title": true,
      "ja": "5.5.1 メッセージメタデータ（Metavariables）"
    },
    {
      "indent": 3,
      "text": "Each SIP CGI server implementation MUST define a mechanism to pass data about the message from the server to the script. The metavariables containing these data are accessed by the script in a system-defined manner. The representation of the characters in the metavariables is system-defined.",
      "ja": "各SIP CGIサーバーの実装は、サーバーからスクリプトへのメッセージに関するデータを渡すメカニズムを定義する必要があります。これらのデータを含むmetavariablesは、システム定義の方法でスクリプトによってアクセスされます。Metavariablesの文字の表現はシステム定義です。"
    },
    {
      "indent": 3,
      "text": "The representation of metavariables MUST distinguish between undefined values (which are not present) and null values (which are present, but have zero length). Null values are only allowed for those metavariables whose grammar permits this.",
      "ja": "Metavariablesの表現は、未定義の値（存在しない）とヌル値（存在しますが、長さはゼロ）を区別する必要があります。ヌル値は、文法がこれを許可する人のみにのみ許可されます。"
    },
    {
      "indent": 8,
      "text": "For historical reasons, HTTP CGI does not distinguish between null values and undefined values. This specification eliminates this misfeature; null values and undefined values are semantically different.",
      "ja": "歴史的な理由から、HTTP CGIはヌル値と未定義の値を区別しません。この仕様により、このマスフィーチャーが排除されます。null値と未定義の値は意味的に異なります。"
    },
    {
      "indent": 3,
      "text": "Case is not significant in the metavariable names, in that there cannot be two different variables whose names differ in case only. Here they are shown using a canonical representation of capitals plus underscore (\"_\"). The actual representation of the names is system defined; for a particular system the representation MAY be defined differently than this.",
      "ja": "MetAvariableの名前では、ケースは重要ではありません。という点では、2つの異なる変数が存在することはできません。ここでは、キャピタルとアンダースコア（ \"_\"）の標準表現を使用して表示されます。名前の実際の表現は、システムが定義されています。特定のシステムの場合、表現はこれとは異なる方法で定義される場合があります。"
    },
    {
      "indent": 3,
      "text": "Metavariable values MUST be considered case-sensitive except as noted otherwise.",
      "ja": "特に指摘されている場合を除き、メタヴァリ可能な値は症例に敏感であると見なす必要があります。"
    },
    {
      "indent": 3,
      "text": "The canonical metavariables defined by this specification are:",
      "ja": "この仕様で定義されている標準的なメトバリスブルは次のとおりです。"
    },
    {
      "indent": 7,
      "text": "AUTH_TYPE CONTENT_LENGTH CONTENT_TYPE GATEWAY_INTERFACE REMOTE_ADDR REMOTE_HOST REMOTE_IDENT REMOTE_USER REGISTRATIONS REQUEST_METHOD REQUEST_TOKEN REQUEST_URI RESPONSE_STATUS RESPONSE_REASON RESPONSE_TOKEN SCRIPT_COOKIE SERVER_NAME SERVER_PORT SERVER_PROTOCOL SERVER_SOFTWARE",
      "ja": "auth_type content_length content_type gateway_interface remote_addr remote_host remote_ident remote_user登録request_method request_token request_uri response_status response_reason response_token script_name server_port server_portocol server_software_name"
    },
    {
      "indent": 3,
      "text": "Metavariables with names beginning with the protocol name (e.g., \"SIP_ACCEPT\") are also canonical in their description of message header fields. The number and meaning of these fields may change independently of this specification. (See also section 5.5.1.5.)",
      "ja": "プロトコル名（たとえば、「SIP_ACCEPT」）から始まる名前のメトバリスブルも、メッセージヘッダーフィールドの説明において標準的です。これらのフィールドの数と意味は、この仕様とは無関係に変更される場合があります。（セクション5.5.1.5も参照してください。）"
    },
    {
      "indent": 3,
      "text": "A server MAY also specify additional non-canonical metavariables.",
      "ja": "サーバーは、追加の非標準的なメタバブルを指定することもできます。"
    },
    {
      "indent": 0,
      "text": "5.5.1.1 AUTH_TYPE",
      "section_title": true,
      "ja": "5.5.1.1 auth_type"
    },
    {
      "indent": 3,
      "text": "If the target of the message required access authentication for external access, then the server MUST set the value of this variable from the auth-scheme token in the message's Authorization header field. Otherwise it is not defined.",
      "ja": "メッセージのターゲットが外部アクセスにアクセス認証を必要とする場合、サーバーは、メッセージの承認ヘッダーフィールドのAuth-Schemeトークンからこの変数の値を設定する必要があります。それ以外の場合は、定義されていません。"
    },
    {
      "indent": 8,
      "text": "AUTH_TYPE    =  \"\" | auth-scheme\nauth-scheme  =  \"Basic\" | \"Digest\" | \"PGP\" | token",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "SIP access authentication schemes are described in sections 14 and 15 of the SIP/2.0 specification [2]. The auth-scheme is not case-sensitive.",
      "ja": "SIPアクセス認証スキームは、SIP/2.0仕様のセクション14および15で説明されています[2]。Auth-Schemeは症例に敏感ではありません。"
    },
    {
      "indent": 3,
      "text": "Servers MUST provide this metavariable to scripts if the message header included an Authorization field that was authenticated.",
      "ja": "メッセージヘッダーに認証された承認フィールドが含まれている場合、サーバーはスクリプトにこのmetavariableを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "For the complex authentication schemes, the server SHOULD perform the authentication checking itself. If the authentication failed, this metavariable SHOULD NOT be set.",
      "ja": "複雑な認証スキームの場合、サーバーはそれ自体を確認する認証を実行する必要があります。認証が失敗した場合、このMetAvariableを設定しないでください。"
    },
    {
      "indent": 3,
      "text": "If several authentication credentials, with multiple schemes, are present in the message, this variable SHOULD be set to correspond to the authenticated credentials with the strongest scheme the server supports. If credentials are present for several domains, the server SHOULD NOT perform any action on credentials from domains external to it.",
      "ja": "複数のスキームを持ついくつかの認証資格情報がメッセージに存在する場合、この変数は、サーバーがサポートする最も強力なスキームを持つ認証された資格情報に対応するように設定する必要があります。いくつかのドメインに資格情報が存在する場合、サーバーは、外部のドメインからの資格情報に対してアクションを実行してはなりません。"
    },
    {
      "indent": 3,
      "text": "If both Authorization and Proxy-Authorization headers are present, the server SHOULD perform the authorizations based on the appropriate header for the context in which it is running. For example, a server which is a proxy server and a registrar would use Authorization headers for REGISTER messages aimed at its local domains, and Proxy-Authorization headers for all other messages.",
      "ja": "承認とプロキシと認証ヘッダーの両方が存在する場合、サーバーは、実行中のコンテキストの適切なヘッダーに基づいて承認を実行する必要があります。たとえば、プロキシサーバーであり、レジストラであるサーバーは、ローカルドメインを対象としたレジスタメッセージに認証ヘッダーを使用し、他のすべてのメッセージのプロキシ承認ヘッダーを使用します。"
    },
    {
      "indent": 0,
      "text": "5.5.1.2 CONTENT_LENGTH",
      "section_title": true,
      "ja": "5.5.1.2 content_length"
    },
    {
      "indent": 3,
      "text": "This metavariable is set to the size of the message-body entity attached to the message, if any, in decimal number of octets. If no data are attached, then this metavariable is not defined. The syntax is the same as for the SIP Content-Length header field (section 6.15, SIP/2.0 specification [2]).",
      "ja": "このMetAvariableは、10進数のオクテットでメッセージに添付されているメッセージボディエンティティのサイズに設定されます。データが添付されていない場合、このMetAvariableは定義されていません。構文は、SIPコンテンツ長ヘッダーフィールドと同じです（セクション6.15、SIP/2.0仕様[2]）。"
    },
    {
      "indent": 8,
      "text": "CONTENT_LENGTH = \"\" | 1*digit",
      "ja": "content_length = \"\" |1*桁"
    },
    {
      "indent": 3,
      "text": "Servers MUST provide this metavariable to scripts if the message was a accompanied by a content-body entity, even if the message did not include a Content-Length header field.",
      "ja": "メッセージにコンテンツレングスヘッダーフィールドが含まれていなくても、メッセージにコンテンツボディエンティティが添付されていた場合、サーバーはスクリプトにこのmetavariableを提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5.1.3 CONTENT_TYPE",
      "section_title": true,
      "ja": "5.5.1.3 content_type"
    },
    {
      "indent": 3,
      "text": "If the message includes a message-body, CONTENT_TYPE is set to the Internet Media Type [6] of the attached entity if the type was provided via a Content-type field in the message header, or if the server can determine it in the absence of a supplied Content-type field. The syntax is the same as for the SIP Content-Type header field.",
      "ja": "メッセージにメッセージボディが含まれている場合、content_typeは、メッセージヘッダー内のコンテンツタイプのフィールドを介してタイプが提供された場合、またはサーバーが非存在下でそれを決定できる場合、添付エンティティのインターネットメディアタイプ[6]に設定されます。提供されたコンテンツタイプのフィールドの。構文は、SIPコンテンツタイプのヘッダーフィールドと同じです。"
    },
    {
      "indent": 8,
      "text": "CONTENT_TYPE = \"\" | media-type",
      "ja": "content_type = \"\" |メディアタイプ"
    },
    {
      "indent": 3,
      "text": "The type, subtype, and parameter attribute names are not case-sensitive. Parameter values MAY be case sensitive. Media types and their use in SIP are described in section 6.16 of the SIP/2.0 specification [2], and by reference in section 3.7 of the HTTP/1.1 specification [5].",
      "ja": "タイプ、サブタイプ、およびパラメーター属性名は、ケースに敏感ではありません。パラメーター値はケースに敏感になる場合があります。SIPでのメディアタイプとその使用は、SIP/2.0仕様[2]のセクション6.16で説明されており、HTTP/1.1仕様[5]のセクション3.7に参照されています。"
    },
    {
      "indent": 3,
      "text": "Since in SIP the Content-Type header MUST be specified if a body is present, servers MUST provide this metavariable to scripts if a body was present in the original message, unless the \"body\" is actually an encrypted payload.",
      "ja": "SIPでは、ボディが存在する場合はコンテンツタイプのヘッダーを指定する必要があるため、「ボディ」が実際に暗号化されたペイロードでない限り、本文が元のメッセージに存在する場合、サーバーはスクリプトにこのメトバリブルを提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5.1.4 GATEWAY_INTERFACE",
      "section_title": true,
      "ja": "5.5.1.4 gateway_interface"
    },
    {
      "indent": 3,
      "text": "This metavariable is set to the dialect of SIP CGI being used by the server to communicate with the script. Syntax:",
      "ja": "このMetAvariableは、サーバーがスクリプトと通信するために使用されるSIP CGIの方言に設定されています。構文："
    },
    {
      "indent": 8,
      "text": "GATEWAY_INTERFACE  =  \"SIP-CGI\" \"/\" major \".\" minor\nmajor              =  1*digit\nminor              =  1*digit",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that the major and minor numbers are treated as separate integers and hence each may be more than a single digit. Thus SIP-CGI/2.4 is a lower version than SIP-CGI/2.13 which in turn is lower than SIP-CGI/12.3. Leading zeros in either the major or the minor number MUST be ignored by scripts and SHOULD NOT be generated by servers.",
      "ja": "主要な数字とマイナー数は別々の整数として扱われているため、それぞれが1桁以上である可能性があることに注意してください。したがって、SIP-CGI/2.4はSIP-CGI/2.13よりも低いバージョンで、SIP-CGI/12.3よりも低くなります。主要なゼロは、メジャー数またはマイナー数のいずれかのいずれかで、スクリプトで無視する必要があり、サーバーによって生成されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "This document defines the 1.1 version of the SIP CGI interface (\"SIP-CGI/1.1\").",
      "ja": "このドキュメントでは、SIP CGIインターフェイスの1.1バージョン（ \"SIP-CGI/1.1\"）を定義します。"
    },
    {
      "indent": 3,
      "text": "Servers MUST provide this metavariable to scripts.",
      "ja": "サーバーは、スクリプトにこのMetAvariableを提供する必要があります。"
    },
    {
      "indent": 8,
      "text": "For maximal compatibility with existing HTTP CGI libraries, we want to keep this as similar as possible to the syntax of CGI 1.1. However, we do want it to be clear that this is indeed SIP CGI. Making HTTP CGI's version identifier a substring of the SIP CGI identifier seemed like a reasonable compromise. (The existing CGI libraries we checked do not seem to check the version.)",
      "ja": "既存のHTTP CGIライブラリとの最大の互換性については、CGI 1.1の構文と可能な限り同様に保つ必要があります。ただし、これが実際にCGIであることを明確にしていることを望んでいます。HTTP CGIのバージョン識別子をSIP CGI識別子のサブストリングにすることは、合理的な妥協のように思えました。（確認した既存のCGIライブラリは、バージョンを確認していないようです。）"
    },
    {
      "indent": 0,
      "text": "5.5.1.5 Protocol-Specific Metavariables",
      "section_title": true,
      "ja": "5.5.1.5 プロトコル固有のメトバリスブル"
    },
    {
      "indent": 3,
      "text": "These metavariables are specific to the protocol via which the method is sent. Interpretation of these variables depends on the value of the SERVER_PROTOCOL metavariable (see section 5.5.1.20).",
      "ja": "これらのメトバリスは、メソッドが送信されるプロトコルに固有です。これらの変数の解釈は、server_protocol metavariableの値に依存します（セクション5.5.1.20を参照）。"
    },
    {
      "indent": 3,
      "text": "Metavariables with names beginning with \"SIP_\" contain values from the message header, if the protocol used was SIP. Each SIP header field name is converted to upper case, has all occurrences of \"-\" replaced with \"_\", and has \"SIP_\" prepended to form the metavariable name. Similar transformations are applied for other protocols. The header data MAY be presented as sent by the client, or MAY be rewritten in ways which do not change its semantics. If multiple header fields with the same field-name are received then the server MUST rewrite them as though they had been received as a single header field having the same semantics before being represented in a metavariable. Similarly, a header field that is received on more than one line MUST be merged into a single line. The server MUST, if necessary, change the representation of the data (for example, the character set) to be appropriate for a CGI metavariable.",
      "ja": "「SIP_」から始まる名前のMetavariablesは、使用されているプロトコルがSIPである場合、メッセージヘッダーからの値を含んでいます。各SIPヘッダーのフィールド名は大文字に変換され、「 - 」のすべての発生が「_」に置き換えられ、「SIP_」がメタヴァリアブル名を形成するために準備されています。他のプロトコルにも同様の変換が適用されます。ヘッダーデータは、クライアントによって送信されたものとして提示されるか、そのセマンティクスを変更しない方法で書き直される場合があります。同じフィールド名を持つ複数のヘッダーフィールドを受信した場合、サーバーは、メタバリアブルで表現される前に、同じセマンティクスを持つ単一のヘッダーフィールドとして受信されたかのようにそれらを書き直す必要があります。同様に、複数の行で受信されるヘッダーフィールドを単一の行に統合する必要があります。サーバーは、必要に応じて、データの表現（キャラクターセットなど）をCGI MetAvariableに適切に変更する必要があります。"
    },
    {
      "indent": 8,
      "text": "Note: these metavariables' names were changed from HTTP_* to SIP_* since the first draft of this specification. The intention had been to make it easier to use existing CGI libraries unmodified, but this convenience was felt to be outweighed by the confusion this introduced.",
      "ja": "注：これらのMetavariablesの名前は、この仕様の最初のドラフト以降、http_*からSIP_*に変更されました。意図は、既存のCGIライブラリを変更していないことを容易にすることでしたが、この利便性は、これが導入した混乱によって上回ると感じられました。"
    },
    {
      "indent": 3,
      "text": "Servers are not required to create metavariables for all the message header fields they receive. However, because of the relatively high importance of headers in SIP for messages' semantic content, the server SHOULD provide all headers which do not contain potentially sensitive authorization information, such as Authorization. Servers SHOULD provide protocol-specific metavariables even for information which is available through other SIP CGI metavariables, such as CONTENT_LENGTH and CONTENT_TYPE.",
      "ja": "サーバーは、受信したすべてのメッセージヘッダーフィールドに対してMetAvariablesを作成する必要はありません。ただし、メッセージのセマンティックコンテンツのSIPにおけるヘッダーの比較的高い重要性があるため、サーバーは、承認などの潜在的に機密性の高い認証情報を含まないすべてのヘッダーを提供する必要があります。サーバーは、content_lengthやcontent_typeなどの他のSIP CGIメタバリブルを介して利用できる情報に対しても、プロトコル固有のメタバリスブルを提供する必要があります。"
    },
    {
      "indent": 8,
      "text": "This allows a SIP CGI script to determine, if necessary, whether the information in the other metavariables was in the original message, or was synthesized by the server.",
      "ja": "これにより、SIP CGIスクリプトは、必要に応じて、他のMetavariablesの情報が元のメッセージに含まれているか、サーバーによって合成されたかどうかを判断できます。"
    },
    {
      "indent": 0,
      "text": "5.5.1.6 REGISTRATIONS",
      "section_title": true,
      "ja": "5.5.1.6 登録"
    },
    {
      "indent": 3,
      "text": "This metavariable contains a list the current locations the server has registered for the user in the Request-URI of the initial request of a transaction. It is syntactically identical to the protocol metavariable SIP_CONTACT, and thus is defined by section 5.5.1.5 of this document and by section 6.13 of the SIP/2.0 specification [2]. It contains all the uris, uri parameters, display names, and contact parameters for the addresses registered with the server.",
      "ja": "このMetAvariableには、トランザクションの最初の要求のリクエスト-URIでサーバーがユーザーに登録している現在の場所にリストが含まれています。これは、プロトコルMetAvariable SIP_CONTACTと構文的に同一であるため、このドキュメントのセクション5.5.1.5およびSIP/2.0仕様[2]のセクション6.13で定義されます。サーバーに登録されているアドレスのすべてのURI、URIパラメーター、表示名、および連絡先パラメーターが含まれています。"
    },
    {
      "indent": 8,
      "text": "The syntax of REGISTRATIONS is identical to how SIP_CONTACT would appear in a 302 response from a redirection server. This allows parsing code to be re-used.",
      "ja": "登録の構文は、リダイレクトサーバーからの302応答でSIP_CONTACTがどのように表示されるかと同じです。これにより、解析コードを再利用できます。"
    },
    {
      "indent": 3,
      "text": "If a user's registrations change in the course of a transaction, the server SHOULD update this metavariable accordingly for subsequent script invocations for the transaction.",
      "ja": "ユーザーの登録がトランザクションの過程で変更された場合、サーバーは、トランザクションの後続のスクリプトの呼び出しのためにこのメタバリアブルを更新する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5.1.7 REMOTE_ADDR",
      "section_title": true,
      "ja": "5.5.1.7 remote_addr"
    },
    {
      "indent": 3,
      "text": "The IP address of the client that sent the message to the server. This is not necessarily that of the originating user agent client or server.",
      "ja": "メッセージをサーバーに送信したクライアントのIPアドレス。これは、必ずしも元のユーザーエージェントクライアントまたはサーバーのものではありません。"
    },
    {
      "indent": 8,
      "text": "REMOTE_ADDR = hostnumber hostnumber = IPv4address | IPv6address",
      "ja": "remote_addr = hostnumber hostnumber = ipv4address |IPv6Address"
    },
    {
      "indent": 3,
      "text": "The definitions of IPv4address and Ipv6address are provided in Appendix B of RFC 2373 [7].",
      "ja": "IPv4AddressとIPv6Addressの定義は、RFC 2373の付録Bに記載されています[7]。"
    },
    {
      "indent": 3,
      "text": "For locally-generated responses (see section 5.8), this SHOULD be the loopback address (i.e., 127.0.0.1 for IPv4 or ::1 for IPv6).",
      "ja": "局所的に生成された応答の場合（セクション5.8を参照）、これはループバックアドレス（つまり、IPv4の場合は127.0.0.1またはIPv6の場合は:: 1）である必要があります。"
    },
    {
      "indent": 3,
      "text": "Servers MUST supply this value to scripts.",
      "ja": "サーバーはこの値をスクリプトに提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5.1.8 REMOTE_HOST",
      "section_title": true,
      "ja": "5.5.1.8 リモートホスト"
    },
    {
      "indent": 3,
      "text": "This is the fully qualified domain name of the host sending the message to this server, if available, otherwise not defined. (See section 5.5.1.7). Domain names are not case sensitive.",
      "ja": "これは、利用可能な場合はこのサーバーにメッセージを送信するホストの完全に適格なドメイン名であり、それ以外の場合は定義されていません。（セクション5.5.1.7を参照）。ドメイン名はケースに敏感ではありません。"
    },
    {
      "indent": 8,
      "text": "REMOTE_HOST  =  hostname",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Servers SHOULD provide this information to scripts.",
      "ja": "サーバーはこの情報をスクリプトに提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5.1.9 REMOTE_IDENT",
      "section_title": true,
      "ja": "5.5.1.9 remote_ident"
    },
    {
      "indent": 3,
      "text": "The identity information supported about the connection by a RFC 1413 [8] request, if available.",
      "ja": "RFC 1413 [8]リクエストによって接続についてサポートされているID情報。"
    },
    {
      "indent": 8,
      "text": "REMOTE_IDENT  =  *CHAR",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The server MAY choose not to support this feature, and it is anticipated that not many implementations will, as the information is not particularly useful in the presence of complex proxy paths.",
      "ja": "サーバーは、この機能をサポートしないことを選択する場合があります。また、複雑なプロキシパスの存在下で情報が特に役立たないため、多くの実装はそうではないことが予想されます。"
    },
    {
      "indent": 0,
      "text": "5.5.1.10 REMOTE_USER",
      "section_title": true,
      "ja": "5.5.1.10 remote_user"
    },
    {
      "indent": 3,
      "text": "If the message requested authentication (i.e., the AUTH_TYPE metavariable is set), then the value of the REMOTE_USER metavariable is set to the user-ID supplied for the authentication. For Basic authentication this is the content of the (decoded) \"userid\" grammar element; for Digest it is content of \"username-value.\" For PGP authentication, it is the URI specified in the \"signed-by\" parameter of the Authorization header, if present, otherwise the URI part of the From header.",
      "ja": "メッセージが認証を要求した場合（つまり、auth_type metavariableが設定されている場合）、remote_user metavariableの値は、認証用に提供されるユーザーIDに設定されます。基本認証の場合、これは（デコードされた）「userid」文法要素のコンテンツです。ダイジェストの場合、それは「ユーザー名値」の内容です。PGP認証の場合、存在する場合は、承認ヘッダーの「署名」パラメーターで指定されているURIです。"
    },
    {
      "indent": 3,
      "text": "If some other authentication scheme was requested, this metavariable SHOULD be set to an appropriate component of the authorization information identifying the user or entity associated with the credentials. If authentication was not requested, this metavariable is not defined.",
      "ja": "他の認証スキームが要求された場合、このMetAvariableは、資格情報に関連付けられたユーザーまたはエンティティを識別する承認情報の適切なコンポーネントに設定する必要があります。認証が要求されなかった場合、このメタバリアブルは定義されていません。"
    },
    {
      "indent": 8,
      "text": "REMOTE_USER  =  *OCTET",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Servers SHOULD provide this metavariable to scripts.",
      "ja": "サーバーは、スクリプトにこのMetAvariableを提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5.1.11 REQUEST_METHOD",
      "section_title": true,
      "ja": "5.5.1.11 request_method"
    },
    {
      "indent": 3,
      "text": "If the message triggering the script was a request, the REQUEST_METHOD metavariable is set to the method with which the request was made, as described in section 4.2 of the SIP/2.0 specification [2]; otherwise not defined.",
      "ja": "スクリプトをトリガーするメッセージがリクエストである場合、sip/2.0仕様[2]のセクション4.2で説明されているように、リクエスト_method metavariableはリクエストが作成された方法に設定されます。それ以外の場合は定義されていません。"
    },
    {
      "indent": 8,
      "text": "REQUEST_METHOD    =  sip-method\nsip-method        =  \"INVITE\" | \"BYE\" | \"OPTIONS\" | \"CANCEL\"\n                     | \"REGISTER\" | \"ACK\"\n                     | extension-method\nextension-method  =  token",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that ACK is usually not appropriate for the SIP CGI 1.1 environment; however, see section 5.11. The implications of REGISTER in the CGI context are discussed in section 5.9, and CANCEL is discussed in section 5.10. A SIP CGI 1.1 server MAY choose to process some methods directly rather than passing them to scripts.",
      "ja": "ACKは通常、SIP CGI 1.1環境には適していないことに注意してください。ただし、セクション5.11を参照してください。CGIコンテキストでのレジスタの意味については、セクション5.9で説明し、キャンセルについてはセクション5.10で説明します。SIP CGI 1.1サーバーは、スクリプトに渡すのではなく、いくつかのメソッドを直接処理することを選択できます。"
    },
    {
      "indent": 3,
      "text": "Servers MUST provide this metavariable to scripts if the triggering message was a request.",
      "ja": "トリガーメッセージがリクエストである場合、サーバーはスクリプトにこのメトバリアブルを提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5.1.12 REQUEST_TOKEN",
      "section_title": true,
      "ja": "5.5.1.12 request_token"
    },
    {
      "indent": 8,
      "text": "REQUEST_TOKEN  =  token",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the script specified a request token in a proxied request, this token is returned to the server in responses to that request. Note that this token is chosen by the script, not by the server. Each response to a proxied request contains the same value for this token.",
      "ja": "スクリプトがプロキシリクエストでリクエストトークンを指定した場合、このトークンはそのリクエストへの応答でサーバーに返されます。このトークンは、サーバーではなくスクリプトによって選択されることに注意してください。プロキシリクエストに対する各応答には、このトークンの同じ値が含まれています。"
    },
    {
      "indent": 0,
      "text": "5.5.1.13 REQUEST_URI",
      "section_title": true,
      "ja": "5.5.1.13 request_uri"
    },
    {
      "indent": 3,
      "text": "This metavariable is specific to requests made with SIP.",
      "ja": "このMetAvariableは、SIPで作成されたリクエストに固有です。"
    },
    {
      "indent": 8,
      "text": "REQUEST_URI = absoluteURI ; defined in RFC 2396 [9]",
      "ja": "request_uri = absoluteuri;RFC 2396で定義[9]"
    },
    {
      "indent": 3,
      "text": "If the message triggering the script was a request, this variable indicates the URI specified with the request method. This metavariable is only defined if REQUEST_METHOD is defined; in that case, servers MUST provide it to scripts.",
      "ja": "スクリプトをトリガーするメッセージがリクエストである場合、この変数はリクエストメソッドで指定されたURIを示します。このMetAvariableは、request_methodが定義されている場合にのみ定義されます。その場合、サーバーはスクリプトに提供する必要があります。"
    },
    {
      "indent": 8,
      "text": "This metavariable fills the roles of HTTP CGI's SCRIPT_NAME, PATH_INFO, and QUERY_STRING.",
      "ja": "これにより、HTTP CGIのscript_name、path_info、およびquery_stringの役割が記入されます。"
    },
    {
      "indent": 0,
      "text": "5.5.1.14 RESPONSE_STATUS",
      "section_title": true,
      "ja": "5.5.1.14 Response_status"
    },
    {
      "indent": 8,
      "text": "RESPONSE_STATUS  =  Status-Code",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the message triggering the script was a response, this variable indicates the numeric code specified in the response; otherwise it is not defined. In the former case, servers MUST provide this metavariable to scripts.",
      "ja": "スクリプトをトリガーするメッセージが応答である場合、この変数は応答で指定された数値コードを示します。それ以外の場合は、定義されていません。前者の場合、サーバーはスクリプトにこのメタバリアブルを提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5.1.15 RESPONSE_REASON",
      "section_title": true,
      "ja": "5.5.1.15 Response_Reason"
    },
    {
      "indent": 8,
      "text": "RESPONSE_REASON  =  Reason-Phrase",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the message triggering the script was a response, this variable indicates the textual string specified in the response.",
      "ja": "スクリプトをトリガーするメッセージが応答である場合、この変数は応答で指定されたテキスト文字列を示します。"
    },
    {
      "indent": 0,
      "text": "5.5.1.16 RESPONSE_TOKEN",
      "section_title": true,
      "ja": "5.5.1.16 Response_Token"
    },
    {
      "indent": 8,
      "text": "RESPONSE_TOKEN  =  token",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the message triggering the script was a response, the server MUST specify a token which subsequent invocations of the CGI script can use to identify this response. This string is chosen by the server and is opaque to the CGI script. See the discussion of CGI-FORWARD-RESPONSE in section 5.6.1 below.",
      "ja": "スクリプトをトリガーするメッセージが応答である場合、サーバーは、CGIスクリプトの後続の呼び出しがこの応答を識別するために使用できるトークンを指定する必要があります。この文字列はサーバーによって選択され、CGIスクリプトに不透明です。以下のセクション5.6.1のCGI-forward-responseの説明を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.5.1.17 SCRIPT_COOKIE",
      "section_title": true,
      "ja": "5.5.1.17 script_cookie"
    },
    {
      "indent": 8,
      "text": "SCRIPT_COOKIE  =  token",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This is the value an earlier invocation of this script for this transaction passed to the server in CGI action line CGI-SET-COOKIE. See the description of that action in section 5.6.1.4 below.",
      "ja": "これは、CGIアクションラインCGI-Set-Cookieでサーバーに渡されたこのトランザクションのこのスクリプトの以前の呼び出しの値です。以下のセクション5.6.1.4のそのアクションの説明を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.5.1.18 SERVER_NAME",
      "section_title": true,
      "ja": "5.5.1.18 サーバーの名前"
    },
    {
      "indent": 3,
      "text": "The SERVER_NAME metavariable is set to the name of the server.",
      "ja": "server_name metavariableは、サーバーの名前に設定されています。"
    },
    {
      "indent": 8,
      "text": "SERVER_NAME = hostname | hostnumber",
      "ja": "server_name = hostname |hostnumber"
    },
    {
      "indent": 3,
      "text": "Servers MUST provide this metavariable to scripts.",
      "ja": "サーバーは、スクリプトにこのMetAvariableを提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5.1.19 SERVER_PORT",
      "section_title": true,
      "ja": "5.5.1.19 サーバポート"
    },
    {
      "indent": 3,
      "text": "The SERVER_PORT metavariable is set to the port on which the message was received.",
      "ja": "server_port metavariableは、メッセージが受信されたポートに設定されます。"
    },
    {
      "indent": 8,
      "text": "SERVER_PORT  =  1*digit",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Servers MUST provide this metavariable to scripts.",
      "ja": "サーバーは、スクリプトにこのMetAvariableを提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5.1.20 SERVER_PROTOCOL",
      "section_title": true,
      "ja": "5.5.1.20 server_protocol"
    },
    {
      "indent": 3,
      "text": "The SERVER_PROTOCOL metavariable is set to the name and revision of the protocol with which the message arrived. This will usually be \"SIP/2.0\". This is not necessarily the same as the protocol version used by the server in its response to the client.",
      "ja": "server_protocol metavariableは、メッセージが届いたプロトコルの名前と改訂に設定されています。これは通常、「SIP/2.0」になります。これは、クライアントへの応答でサーバーが使用するプロトコルバージョンと必ずしも同じではありません。"
    },
    {
      "indent": 8,
      "text": "SERVER_PROTOCOL    =  SIP-Version | extension-version\n                      | extension-token\nextension-version  =  protocol \"/\" 1*digit \".\" 1*digit\nprotocol           =  1*( alphanum | \"+\" | \"-\" | \".\" )\nextension-token    =  token",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Servers MUST provide this metavariable to scripts.",
      "ja": "サーバーは、スクリプトにこのMetAvariableを提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5.1.21 SERVER_SOFTWARE",
      "section_title": true,
      "ja": "5.5.1.21 server_software"
    },
    {
      "indent": 3,
      "text": "The SERVER_SOFTWARE metavariable is set to the name and version of the information server software handling the message (and running the gateway).",
      "ja": "Server_Software MetAvariableは、メッセージを処理する（およびゲートウェイを実行する）情報サーバーソフトウェアの名前とバージョンに設定されています。"
    },
    {
      "indent": 8,
      "text": "SERVER_SOFTWARE  =  1*product\nproduct          =  token [ \"/\" product-version ]\nproduct-version  =  token",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Servers MUST provide this metavariable to scripts.",
      "ja": "サーバーは、スクリプトにこのMetAvariableを提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5.2 Message Bodies",
      "section_title": true,
      "ja": "5.5.2 メッセージ本文"
    },
    {
      "indent": 3,
      "text": "As there may be a data entity attached to the message, there MUST be a system-defined method for the script to read these data. Unless defined otherwise, this will be via the `standard input' file descriptor.",
      "ja": "メッセージに添付されているデータエンティティがある可能性があるため、スクリプトがこれらのデータを読み取るためのシステム定義のメソッドが必要です。特に定義されていない限り、これは「標準入力」ファイル記述子を介して行われます。"
    },
    {
      "indent": 3,
      "text": "If the metavariable CONTENT_LENGTH (see section 5.5.1.2) is defined, the server MUST supply at least that many bytes to scripts on the standard input stream. Scripts are not obliged to read the data. Servers MAY signal an EOF condition after CONTENT_LENGTH bytes have been read, but are not obligated to do so. Therefore, scripts MUST NOT attempt to read more than CONTENT_LENGTH bytes, even if more data are available.",
      "ja": "metAvariable content_length（セクション5.5.1.2を参照）が定義されている場合、サーバーは少なくとも標準の入力ストリーム上のスクリプトに多くのバイトを提供する必要があります。スクリプトはデータを読み取る義務はありません。サーバーは、content_lengthバイトが読み取られた後、EOF条件を信号する場合がありますが、そうする義務はありません。したがって、スクリプトは、より多くのデータが利用可能であっても、Content_Lengthバイト以上の読み取りを試みてはなりません。"
    },
    {
      "indent": 0,
      "text": "5.6 Data Output from the SIP CGI Script",
      "section_title": true,
      "ja": "5.6 SIP CGIスクリプトからのデータ出力"
    },
    {
      "indent": 3,
      "text": "There MUST be a system-defined method for the script to send data back to the server or client. Unless defined otherwise, this will be via the `standard output' file descriptor.",
      "ja": "スクリプトがサーバーまたはクライアントにデータを送信するためのシステム定義の方法が必要です。特に定義されていない限り、これは「標準出力」ファイル記述子を介して行われます。"
    },
    {
      "indent": 3,
      "text": "Servers MAY implement a timeout period within which data must be received from scripts, a maximum number of requests or responses that a particular CGI script can initiate, a maximum total number of requests or responses that can be sent by scripts over the lifetime of a transaction, or any other resource limitations it desires. If a script exceeds one of these limitations, the server MAY terminate the script process and SHOULD abort the transaction with either a `504 Gateway Timed Out' or a `500 Internal Server Error' response.",
      "ja": "サーバーは、スクリプトからデータを受信する必要があるタイムアウト期間、特定のCGIスクリプトが開始できるリクエストまたは応答の最大数、トランザクションの生涯にわたってスクリプトによって送信できるリクエストまたは応答の最大総数を実装する場合があります。、またはそれが望むその他のリソースの制限。スクリプトがこれらの制限のいずれかを超える場合、サーバーはスクリプトプロセスを終了し、「504ゲートウェイタイムアウト」または「500内部サーバーエラー」応答のいずれかでトランザクションを中止する必要があります。"
    },
    {
      "indent": 3,
      "text": "A SIP CGI script's output consists of any number of messages, each corresponding to actions which the script is requesting that the server perform. Messages consist of an action line, whose syntax is specific to the type of action, followed by CGI header fields and SIP header fields. Action lines determine the nature of the action performed, and are described in section 5.6.1. CGI header fields pass additional instructions or information to the server, and are described in section 5.6.2.",
      "ja": "SIP CGIスクリプトの出力は、それぞれがサーバーが実行することを要求しているアクションに対応する任意の数のメッセージで構成されています。メッセージはアクションラインで構成されており、その構文はアクションの種類に固有であり、CGIヘッダーフィールドとSIPヘッダーフィールドがそれに続きます。アクションラインは、実行されたアクションの性質を決定し、セクション5.6.1で説明します。CGIヘッダーフィールドは、追加の手順または情報をサーバーに渡し、セクション5.6.2で説明します。"
    },
    {
      "indent": 3,
      "text": "A message MUST contain exactly one action line, MAY also contain any number of CGI header fields and SIP header fields, and MAY contain a SIP body.",
      "ja": "メッセージには正確に1つのアクションラインが含まれている必要があります。また、任意の数のCGIヘッダーフィールドとSIPヘッダーフィールドを含めることも、SIPボディを含む場合があります。"
    },
    {
      "indent": 3,
      "text": "All header fields (both SIP and CGI) occurring in an output message MUST be specified one per line; SIP CGI 1.1 makes no provision for continuation lines.",
      "ja": "出力メッセージで発生するすべてのヘッダーフィールド（SIPとCGIの両方）は、1行ごとに1つを指定する必要があります。SIP CGI 1.1は、継続ラインを規定していません。"
    },
    {
      "indent": 3,
      "text": "The generic syntax of CGI header fields is specified in section 5.6.2.",
      "ja": "CGIヘッダーフィールドの一般的な構文は、セクション5.6.2で指定されています。"
    },
    {
      "indent": 3,
      "text": "A server MAY choose to honor only some of the requests or responses; in particular, it SHOULD NOT accept any responses following a Status message which sends a definitive non-success response.",
      "ja": "サーバーは、リクエストまたは応答の一部のみを尊重することを選択できます。特に、決定的な非サクセス応答を送信するステータスメッセージに従って応答を受け入れるべきではありません。"
    },
    {
      "indent": 3,
      "text": "The messages sent by a script are delimited as follows:",
      "ja": "スクリプトによって送信されたメッセージは、次のように区切られています。"
    },
    {
      "indent": 8,
      "text": "1. A message begins with an action line.",
      "ja": "1. メッセージはアクションラインから始まります。"
    },
    {
      "indent": 8,
      "text": "2. If the message does not contain a Content-Type header field, or if it contains the header field \"Content-Length: 0\", then it is terminated by a blank line.",
      "ja": "2. メッセージにコンテンツタイプのヘッダーフィールドが含まれていない場合、またはヘッダーフィールド「コンテンツレングス：0」が含まれている場合、空白行で終了します。"
    },
    {
      "indent": 8,
      "text": "3. If the message contains both Content-Type and Content-Length header fields, the message has a body consisting of the Content-Length octets following the blank line below the set. The next message begins after the body (and optionally some number of blank lines). If the script closes its output prematurely, the server SHOULD report a 500-class server error.",
      "ja": "3. メッセージにコンテンツタイプとコンテンツレングスの両方のヘッダーフィールドが含まれている場合、メッセージには、セットの下の空白行に続くコンテンツの長さのオクテットで構成される本文があります。次のメッセージは、体の後に始まります（そして、オプションではいくつかの空白線）。スクリプトが出力を早期に閉じる場合、サーバーは500クラスのサーバーエラーを報告する必要があります。"
    },
    {
      "indent": 8,
      "text": "4. If the message contains Content-Type but not Content-Length, the message's body similarly begins with the blank line following the set; this body extends until the script closes its output. In this case, this is necessarily the last message the script can send. The server SHOULD insert a Content-Length header containing the amount of data read before the script closed its output.",
      "ja": "4. メッセージにコンテンツタイプが含まれているがコンテンツレングスではない場合、メッセージの本文は同様に、セットに続く空白行から始まります。この本体は、スクリプトが出力を閉じるまで拡張されます。この場合、これは必然的にスクリプトが送信できる最後のメッセージです。サーバーは、スクリプトが出力を閉じる前に読み取られるデータの量を含むコンテンツレングスヘッダーを挿入する必要があります。"
    },
    {
      "indent": 8,
      "text": "5. If a message contains a non-zero Content-Length but does not contain a Content-Type, it is an error. The server SHOULD report a 500-class server error.",
      "ja": "5. メッセージにゼロ以外のコンテンツレングスが含まれているが、コンテンツタイプが含まれていない場合、エラーです。サーバーは、500クラスのサーバーエラーを報告する必要があります。"
    },
    {
      "indent": 8,
      "text": "The output of a SIP CGI script is intended to be syntactically identical to that of a UDP packet in which multiple requests or responses are sent, so that the same message parser may be used.",
      "ja": "SIP CGIスクリプトの出力は、複数のリクエストまたは応答が送信されるUDPパケットの出力と同じメッセージパーサーを使用できるようにすることを目的としています。"
    },
    {
      "indent": 0,
      "text": "5.6.1 CGI Action Lines",
      "section_title": true,
      "ja": "5.6.1 CGIアクションライン"
    },
    {
      "indent": 0,
      "text": "5.6.1.1 Status",
      "section_title": true,
      "ja": "5.6.1.1 状態"
    },
    {
      "indent": 8,
      "text": "Status = SIP-Version 3*digit SP reason-phrase NL",
      "ja": "ステータス= sip-version 3*digit sp reasue-phrase nl"
    },
    {
      "indent": 3,
      "text": "This action line causes the server to generate a SIP response and relay it upstream towards the client. The server MUST copy the To, From, Call-ID, and CSeq headers from the original request into the response if these headers are not specified in the script output. The server SHOULD copy any other headers from the request which would normally be copied in the response if these are not specified in the script output.",
      "ja": "このアクションラインにより、サーバーはSIP応答を生成し、クライアントに向かって上流にリレーします。サーバーは、これらのヘッダーがスクリプトの出力で指定されていない場合、To、from、call-id、およびcseqヘッダーを元のリクエストから応答にコピーする必要があります。サーバーは、これらがスクリプト出力で指定されていない場合、通常応答でコピーされるリクエストから他のヘッダーをコピーする必要があります。"
    },
    {
      "indent": 3,
      "text": "For compatibility with HTTP CGI, a server MAY interpret a message containing a Content-Type header field and no action line as though it contained \"SIP/2.0 200 OK\". This usage is deprecated.",
      "ja": "HTTP CGIとの互換性のために、サーバーは、コンテンツタイプのヘッダーフィールドを含むメッセージを解釈する場合があり、「SIP/2.0 200 OK」が含まれているかのようにアクションラインがありません。この使用法は非推奨です。"
    },
    {
      "indent": 0,
      "text": "5.6.1.2 Proxy Request",
      "section_title": true,
      "ja": "5.6.1.2 プロキシリクエスト"
    },
    {
      "indent": 8,
      "text": "Proxy-Request = \"CGI-PROXY-REQUEST\" SIP-URL SIP-Version",
      "ja": "proxy-request = \"cgi-proxy-request\" sip-url sip-version"
    },
    {
      "indent": 3,
      "text": "This action line causes the server to forward a request to the specified SIP URI. It may be sent either by a script triggered by a request, in which case the triggering request is forwarded; or by a script triggered by a response on a server which is running statefully, in which case the initial request of the transaction is sent.",
      "ja": "このアクションラインにより、サーバーは指定されたSIP URIにリクエストを転送します。リクエストによってトリガーされたスクリプトによって送信される場合があります。その場合、トリガーリクエストは転送されます。または、状態で実行されているサーバー上の応答によってトリガーされたスクリプトによって、その場合、トランザクションの最初の要求が送信されます。"
    },
    {
      "indent": 3,
      "text": "Any SIP header field MAY be specified below the action line. Specified SIP headers replace all those in the original message in their entirety; if a script wants to preserve header elements from the original message as well as adding new ones, it can concatenate them by the usual rules of header concatenation, and place the result in the script output. New header fields are added to the message after any Via headers but before any other headers.",
      "ja": "SIPヘッダーフィールドは、アクションラインの下に指定できます。指定されたSIPヘッダーは、元のメッセージ全体のすべてのものを置き換えます。スクリプトが元のメッセージからヘッダー要素を保持し、新しいメッセージを追加したい場合、通常のヘッダー連結ルールによってそれらを連結し、結果をスクリプト出力に配置できます。新しいヘッダーフィールドは、Viaヘッダーの後には他のヘッダーの前にメッセージに追加されます。"
    },
    {
      "indent": 3,
      "text": "Any headers from the original request which are not generated by the CGI script are copied into the proxied request, after modifications normally performed by a proxy server. In particular, the server MUST append a Via field and decrement Max-Forwards. A server MAY perform additional modifications as it sees fit, such as adding a Record-Route header. A server SHOULD NOT append these headers if they are specified in the script output.",
      "ja": "CGIスクリプトによって生成されない元のリクエストのヘッダーは、通常プロキシサーバーによって実行される変更の後、プロキシリクエストにコピーされます。特に、サーバーはフィールドを介してAを追加し、最大値を減少させる必要があります。サーバーは、レコードルートヘッダーの追加など、適切であると思われる追加の変更を実行する場合があります。サーバーがスクリプト出力で指定されている場合、サーバーはこれらのヘッダーを追加してはなりません。"
    },
    {
      "indent": 3,
      "text": "A script MAY specify that a SIP header is to be deleted from the message by using the CGI-Remove CGI header; see section 5.6.2.",
      "ja": "スクリプトは、CGIリモーブCGIヘッダーを使用して、SIPヘッダーがメッセージから削除されることを指定する場合があります。セクション5.6.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "If the message does not specify a body, the body from the initial request is used. A message with \"Content-Length: 0\" is specifying an empty body; this causes the body to be deleted from the message.",
      "ja": "メッセージが本体を指定していない場合、最初のリクエストのボディが使用されます。「Content-Length：0」を含むメッセージは、空のボディを指定することです。これにより、ボディがメッセージから削除されます。"
    },
    {
      "indent": 3,
      "text": "If the original request was authenticated by any means other than `basic,' the script SHOULD NOT add, change, or remove any end-to-end headers, as this would break the authentication.",
      "ja": "元のリクエストが「基本」以外の手段によって認証された場合、スクリプトは、エンドツーエンドのヘッダーを追加、変更、または削除してはなりません。これにより、認証が破壊されるためです。"
    },
    {
      "indent": 0,
      "text": "5.6.1.3 Forward Response",
      "section_title": true,
      "ja": "5.6.1.3 フォワード応答"
    },
    {
      "indent": 8,
      "text": "Forward-Response = \"CGI-FORWARD-RESPONSE\" Response-Name SIP-Version Response-Name = response-token | \"this\"",
      "ja": "forward-response = \"cgi-forward-response\" response-name sip-version response-name = response-token |\"これ\""
    },
    {
      "indent": 3,
      "text": "This action line causes the server to forward a response on to its appropriate final destination. The same rules apply for accompanying SIP headers and message bodies as for CGI-PROXY-REQUEST.",
      "ja": "このアクションラインにより、サーバーは適切な最終宛先に応答を転送します。同じルールは、CGI-Proxy-Requestと同じように付随するSIPヘッダーとメッセージ本文に適用されます。"
    },
    {
      "indent": 3,
      "text": "The specified response name may either be a response token the server previously submitted in a RESPONSE_TOKEN metavariable, or the string \"this.\" The string \"this\" may only be sent if the message which triggered this CGI script was a response; it indicates that this triggering response should be forwarded.",
      "ja": "指定された応答名は、以前にResponse_Token MetAvariableで送信されたサーバーをトークンする応答であるか、文字列「This」のいずれかです。文字列「this」は、このCGIスクリプトをトリガーしたメッセージが応答である場合にのみ送信できます。これは、このトリガー応答を転送する必要があることを示しています。"
    },
    {
      "indent": 0,
      "text": "5.6.1.4 Script Cookie",
      "section_title": true,
      "ja": "5.6.1.4 スクリプトクッキー"
    },
    {
      "indent": 8,
      "text": "Script-Cookie = \"CGI-SET-COOKIE\" token SIP-Version",
      "ja": "script-cookie = \"cgi-set-cookie\"トークンSip-version"
    },
    {
      "indent": 3,
      "text": "This action line causes the server to store a script cookie, passed as a token in the action line. Subsequent script invocations for messages within the same transaction carry the token in a meta-header. The script can alter the value of the cookie by subsequent script cookie actions. This alteration will take affect for all subsequent script invocations.",
      "ja": "このアクションラインにより、サーバーはスクリプトクッキーを保存し、アクションラインのトークンとして渡されます。同じトランザクション内のメッセージの後続のスクリプトの呼び出しは、メタヘッダーでトークンを運びます。スクリプトは、後続のスクリプトCookieアクションにより、Cookieの値を変更できます。この変更は、その後のすべてのスクリプトの呼び出しに影響を与えます。"
    },
    {
      "indent": 0,
      "text": "5.6.1.5 CGI Again",
      "section_title": true,
      "ja": "5.6.1.5 再びCGI"
    },
    {
      "indent": 8,
      "text": "CGI-Again  =  \"CGI-AGAIN\" (\"yes\" | \"no\") SIP-Version",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This action line determines whether the script will be invoked for subsequent requests and responses for this transaction. If the parameter \"yes\" is given to this action, the script will be executed again when the next message arrives. If the parameter is \"no,\" or this action is not specified, the script will not be executed again, and the server will perform its default action for all subsequent messages.",
      "ja": "このアクションラインは、このトランザクションの後続の要求と回答のためにスクリプトが呼び出されるかどうかを決定します。このアクションにパラメーター「はい」が与えられた場合、次のメッセージが届くとスクリプトが再度実行されます。パラメーターが「いいえ」またはこのアクションが指定されていない場合、スクリプトは再度実行されず、サーバーは後続のすべてのメッセージに対してデフォルトアクションを実行します。"
    },
    {
      "indent": 0,
      "text": "5.6.1.6 Default Action",
      "section_title": true,
      "ja": "5.6.1.6 デフォルトのアクション"
    },
    {
      "indent": 3,
      "text": "If none of the actions CGI-PROXY-REQUEST, CGI-FORWARD-RESPONSE, or a new response are performed -- that is to say, the script outputs only CGI-AGAIN, CGI-SET-COOKIE, or nothing -- the script performs its default action. The default action to take depends on the event which triggered the script:",
      "ja": "cgi-proxy-request、cgi-forward-response、または新しい応答が実行されない場合、つまり、スクリプトはcgi-again、cgi-set-cookie、またはnothingのみを出力しない場合 - スクリプトデフォルトのアクションを実行します。取得するデフォルトのアクションは、スクリプトをトリガーしたイベントによって異なります。"
    },
    {
      "indent": 9,
      "text": "Request received: When the request is first received, the default action of the server is to check whether the domain of the server matches the domain of the Request-URI. If it does not, the request is proxied to the request in the Request-URI. Otherwise, the server checks its registration database against the request, and either proxies or redirects the request based on the action specified by the user agent in the registration.",
      "ja": "リクエストの受信：リクエストが最初に受信された場合、サーバーのデフォルトアクションは、サーバーのドメインがリクエスト-URIのドメインと一致するかどうかを確認することです。そうでない場合、リクエストはリクエスト-URIのリクエストに賛成されます。それ以外の場合、サーバーはリクエストに対して登録データベースをチェックし、登録中にユーザーエージェントが指定したアクションに基づいてリクエストをプロキシまたはリダイレクトします。"
    },
    {
      "indent": 9,
      "text": "Proxied response received: If a response is received to a proxied request, the server forwards the response towards the caller if the response was a 200 or 600 class response, and sends a CANCEL on all pending branches. If the response was 100 class, the state machinery for that branch is updated, and the response is proxied upstream towards the caller unless the it was a 100 response, not some other 1xx. For 300, 400, and 500 class responses, an ACK is sent, and the response is forwarded upstream towards the caller if all other branches have terminated, and the response is the best received so far. If not all branches have terminated, the server does nothing. If all branches have terminated, but this response is not the best, the best is forwarded upstream. This is the basic algorithm outlined in the SIP specification.",
      "ja": "受信したプロキシの応答：応答がプロキシリクエストに受信された場合、サーバーは、応答が200または600のクラス応答である場合、応答を発信者に転送し、すべての保留中のブランチでキャンセルを送信します。応答が100クラスの場合、そのブランチの状態機械が更新され、応答は100の応答であり、他の1xxではなく、100の応答でない限り、発信者に向かって上流にプロにされます。300、400、および500のクラス応答の場合、ACKが送信され、他のすべてのブランチが終了した場合、応答は発信者に向かって上流に転送され、応答はこれまでに最もよく受け取っています。すべてのブランチが終了していない場合、サーバーは何もしません。すべてのブランチが終了したが、この応答が最良ではない場合、最高は上流に転送されます。これは、SIP仕様で概説されている基本的なアルゴリズムです。"
    },
    {
      "indent": 0,
      "text": "5.6.2 CGI Header Fields",
      "section_title": true,
      "ja": "5.6.2 CGIヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "CGI header fields syntactically resemble SIP header fields, but their names all begin with the string \"CGI-\". The SIP server MUST strip all CGI header fields from any message before sending it, including those it does not recognize.",
      "ja": "CGIヘッダーフィールドは、SIPヘッダーフィールドに構文的に似ていますが、それらの名前はすべて文字列「cgi-」で始まります。SIPサーバーは、送信する前にすべてのCGIヘッダーフィールドを任意のメッセージから削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "CGI header fields have the generic syntax specified in section 6.6 of the SIP/2.0 specification [2]. The field-name is not case sensitive; the field value MUST conform to the grammar of that specific field in the specification where it is defined.",
      "ja": "CGIヘッダーフィールドには、SIP/2.0仕様[2]のセクション6.6で指定された一般的な構文があります。フィールド名はケースに敏感ではありません。フィールド値は、定義されている仕様のその特定のフィールドの文法に準拠する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.6.2.1 Request-Token",
      "section_title": true,
      "ja": "5.6.2.1 リクエストトークン"
    },
    {
      "indent": 8,
      "text": "Request-Token  =  \"CGI-Request-Token\" \":\" token",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "To assist in matching responses to proxied requests, the script can place a CGI-Request-Token CGI header in a CGI-PROXY-REQUEST or new request. This header contains a token, opaque to the server. When a response to this request arrives, the token is passed back to the script as a meta-header.",
      "ja": "プロキシリクエストに対する応答の一致を支援するために、スクリプトはCGI-Proxy-Requestまたは新しいリクエストにCGI-Request-Token CGIヘッダーを配置できます。このヘッダーには、サーバーへの不透明なトークンが含まれています。このリクエストへの応答が届くと、トークンはメタヘッダーとしてスクリプトに渡されます。"
    },
    {
      "indent": 8,
      "text": "This allows scripts to \"fork\" a proxy request, and correlate which response corresponds to which branch of the request.",
      "ja": "これにより、スクリプトはプロキシリクエストを「フォーク」し、どの応答がリクエストのどのブランチに対応するかを相関させることができます。"
    },
    {
      "indent": 0,
      "text": "5.6.2.2 Remove",
      "section_title": true,
      "ja": "5.6.2.2 取り除く"
    },
    {
      "indent": 8,
      "text": "Remove  =  \"CGI-Remove\" \":\" 1#field-name",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The CGI-Remove header allows the script to remove SIP headers from the outgoing request or response. The value of this header is a comma-separated list of SIP headers which should be removed before sending out the message.",
      "ja": "CGIリモーブヘッダーを使用すると、スクリプトが発信リクエストまたは応答からSIPヘッダーを削除できます。このヘッダーの値は、メッセージを送信する前に削除する必要があるSIPヘッダーのコンマ分離されたリストです。"
    },
    {
      "indent": 3,
      "text": "A script MAY specify headers which are not in the request; the server SHOULD silently ignore these. A script SHOULD NOT both specify a SIP header in its output and also list that header in a CGI-Remove header; the result of doing this is undefined.",
      "ja": "スクリプトは、リクエストに含まれていないヘッダーを指定する場合があります。サーバーは静かにこれらを無視する必要があります。スクリプトは、出力にSIPヘッダーを指定し、CGIリモーブヘッダーのヘッダーをリストするものではありません。これを行う結果は未定義です。"
    },
    {
      "indent": 0,
      "text": "5.7 Local Expiration Handling",
      "section_title": true,
      "ja": "5.7 ローカル有効期限の処理"
    },
    {
      "indent": 3,
      "text": "If a CGI script specifies an Expires header field along with CGI-PROXY-REQUEST, the SIP server SHOULD track the expiration timeout locally as well as sending the message to the remote server. When the timeout expires, the server SHOULD generate a \"408 Request Timeout\" response. The timeout response SHOULD be handled as specified in section 5.8. At the time the request is timed out, the server SHOULD also transmit CANCEL messages for the request.",
      "ja": "CGIスクリプトがCGI-Proxy-Requestとともにヘッダーフィールドの有効期限を指定する場合、SIPサーバーは有効期限のタイムアウトをローカルで追跡し、メッセージをリモートサーバーに送信する必要があります。タイムアウトの有効期限が切れると、サーバーは「408リクエストタイムアウト」応答を生成する必要があります。タイムアウト応答は、セクション5.8で指定されているように処理する必要があります。リクエストがタイムアウトされている時点で、サーバーはリクエストのキャンセルメッセージも送信する必要があります。"
    },
    {
      "indent": 8,
      "text": "This allows a SIP CGI script in a proxy server to implement services like \"Call Forward No Answer\" to trigger after a user-determined time, even if the remote user-agent server is not responding or does not properly handle the Expires header field.",
      "ja": "これにより、プロキシサーバー内のSIP CGIスクリプトが、リモートユーザーエージェントサーバーが応答していないか、ヘッダーフィールドを適切に処理していない場合でも、ユーザーが決定した時間の後にトリガーするために「フォワードフォワードノーアンサー」などのサービスを実装できます。"
    },
    {
      "indent": 0,
      "text": "5.8 Locally-Generated Responses",
      "section_title": true,
      "ja": "5.8 局所的に生成された応答"
    },
    {
      "indent": 3,
      "text": "In a proxy environment, locally-generated responses such as \"408 Request Timeout\" SHOULD be sent to the CGI script in the same manner as received messages are. However, messages which merely report a problem with a message, such as \"400 Bad Request\", SHOULD NOT be.",
      "ja": "プロキシ環境では、「408リクエストタイムアウト」などの局所的に生成された応答を、受信したメッセージと同じ方法でCGIスクリプトに送信する必要があります。ただし、「400の悪いリクエスト」などのメッセージの問題を単に報告するメッセージは、そうすべきではありません。"
    },
    {
      "indent": 8,
      "text": "This is the other half of the requirements for the implementation of the \"Call Forward No Answer\" service, along with the local handling of the Expires header.",
      "ja": "これは、「Call Forward No Answer」サービスを実装するための要件の残りの半分と、Expiresヘッダーのローカルハンドリングとともに。"
    },
    {
      "indent": 0,
      "text": "5.9 SIP CGI and REGISTER",
      "section_title": true,
      "ja": "5.9 CGIと登録をSIPします"
    },
    {
      "indent": 3,
      "text": "The specific semantics of a SIP CGI script which is triggered by a REGISTER request are somewhat different than that of those triggered by call-related requests; however, allowing user control of registration may in some cases be useful. The two specific actions for REGISTER that need to be discussed are the response \"200\" and the default action. In the former case, the server SHOULD assume that the CGI script is handling the registration internally, and SHOULD NOT add the registration to its internal registration database; in the latter case, the server SHOULD add the registration to its own database. The server also SHOULD NOT add the registration if a 3xx, 4xx, 5xx, or 6xx status was returned, or if the registration request was proxied to another location.",
      "ja": "レジスタリクエストによってトリガーされるSIP CGIスクリプトの特定のセマンティクスは、コール関連のリクエストによってトリガーされたものとは多少異なります。ただし、登録のユーザー制御を許可する場合がある場合もあります。議論する必要があるレジスタの2つの特定のアクションは、応答「200」とデフォルトのアクションです。前者の場合、サーバーは、CGIスクリプトが内部的に登録を処理していると想定し、内部登録データベースに登録を追加しないでください。後者の場合、サーバーは独自のデータベースに登録を追加する必要があります。また、サーバーは、3xx、4xx、5xx、または6xxステータスが返された場合、または登録リクエストが別の場所にプロキシ化された場合、登録を追加しないでください。"
    },
    {
      "indent": 0,
      "text": "5.10 SIP CGI and CANCEL",
      "section_title": true,
      "ja": "5.10 CGIをSIPしてキャンセルします"
    },
    {
      "indent": 3,
      "text": "SIP CGI servers SHOULD execute scripts when a CANCEL message is received. The script SHOULD clean up any state it has for the transaction as quickly as possible.",
      "ja": "SIP CGIサーバーは、キャンセルメッセージが受信されたときにスクリプトを実行する必要があります。スクリプトは、できるだけ早くトランザクションのために持っている状態をクリーンアップする必要があります。"
    },
    {
      "indent": 3,
      "text": "When a CANCEL is received at a server for an existing transaction, the server SHOULD send a 200 OK response to the cancel and cancel all currently outstanding branches. The transmission of the script on a CANCEL message is purely advisory, and the script SHOULD NOT perform any actions in response to it.",
      "ja": "既存のトランザクションのためにサーバーでキャンセルが受信されると、サーバーはキャンセルに200 OK応答を送信し、現在発行されたすべてのブランチをキャンセルする必要があります。キャンセルメッセージにスクリプトを送信することは純粋にアドバイザリーであり、スクリプトはそれに応じてアクションを実行してはなりません。"
    },
    {
      "indent": 0,
      "text": "5.11 SIP CGI and ACK",
      "section_title": true,
      "ja": "5.11 SIP CGIとACK"
    },
    {
      "indent": 0,
      "text": "5.11.1 Receiving ACK's",
      "section_title": true,
      "ja": "5.11.1 ACKを受信します"
    },
    {
      "indent": 3,
      "text": "Under normal circumstances, if the server receives an ACK, the script is not re-executed. If the ACK is destined for the proxy (acknowledging a 300, 400, 500, or 600 response), the ACK causes response retransmissions to cease. If the ACK is for a 200 response forwarded from a downstream server, the ACK is proxied downstream.",
      "ja": "通常の状況では、サーバーがACKを受信した場合、スクリプトは再実行されません。ACKがプロキシに運命づけられている場合（300、400、500、または600の応答を認める）、ACKは応答の再送信を停止します。ACKがダウンストリームサーバーから転送された200の応答の場合、ACKは下流にプロキシ化されます。"
    },
    {
      "indent": 3,
      "text": "However, if the script generated its own 200 response to an INVITE request, the script SHOULD be re-executed with the ACK message. This is necessary in cases where the script is causing the proxy to act as a UAS. ACK messages can contain bodies, and would therefore be useful to the script.",
      "ja": "ただし、スクリプトが招待リクエストに対する独自の200の応答を生成した場合、スクリプトはACKメッセージで再実行される必要があります。これは、スクリプトがプロキシをUASとして機能させている場合に必要です。ACKメッセージにはボディを含めることができるため、スクリプトに役立ちます。"
    },
    {
      "indent": 0,
      "text": "5.11.2 Sending ACK's",
      "section_title": true,
      "ja": "5.11.2 ACKを送信します"
    },
    {
      "indent": 3,
      "text": "When the server receives a non-200 final response to an INVITE request, it SHOULD generate an ACK on its own, and not depend on the script to do so. There is no way in SIP CGI 1.1 to override this behavior. However, since the server will not generate an ACK for 200 responses to INVITE, a script causing the server to act as a UAC MUST generate ACK's for them.",
      "ja": "サーバーが招待リクエストに対する200の非最終応答を受信した場合、それ自体でACKを生成する必要があり、そうするためのスクリプトに依存しません。SIP CGI 1.1には、この動作をオーバーライドする方法はありません。ただし、サーバーは招待のための200の応答のACKを生成しないため、サーバーがUACとして機能する原因となるスクリプトは、それらのACKを生成する必要があります。"
    },
    {
      "indent": 0,
      "text": "6 System Specifications",
      "ja": "6システム仕様"
    },
    {
      "indent": 0,
      "text": "6.1 Unix",
      "section_title": true,
      "ja": "6.1 Unix"
    },
    {
      "indent": 3,
      "text": "The implementation of SIP CGI on a Unix operating system platform SHOULD use environment variables as the mechanism of providing request metadata to CGI scripts.",
      "ja": "UNIXオペレーティングシステムプラットフォームでのSIP CGIの実装は、CGIスクリプトにリクエストメタデータを提供するメカニズムとして環境変数を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "For Unix compatible operating systems, the following are defined:",
      "ja": "UNIX互換性のあるオペレーティングシステムの場合、以下が定義されています。"
    },
    {
      "indent": 8,
      "text": "Environment variables: These are accessed by the C library routine getenv.",
      "ja": "環境変数：これらは、CライブラリルーチンGetENVによってアクセスされます。"
    },
    {
      "indent": 8,
      "text": "The current working directory: The current working directory for the script SHOULD be set to the directory containing the script.",
      "ja": "現在の作業ディレクトリ：スクリプトの現在の作業ディレクトリは、スクリプトを含むディレクトリに設定する必要があります。"
    },
    {
      "indent": 8,
      "text": "Character set: The US-ASCII character set is used for the definition of environment variable names and header field names; the newline (NL) sequence is LF; servers SHOULD also accept CR LF as a newline.",
      "ja": "文字セット：US-ASCII文字セットは、環境変数名とヘッダーフィールド名の定義に使用されます。NewLine（NL）シーケンスはLFです。サーバーはまた、CR LFを新しいラインとして受け入れる必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2 Microsoft Windows",
      "section_title": true,
      "ja": "6.2 マイクロソフトウィンドウズ"
    },
    {
      "indent": 3,
      "text": "The implementation of SIP CGI on 32-bit Microsoft Windows system platforms (Windows 95, 98, NT, and 2000) SHOULD use environment variables as the mechanism of providing request metadata to CGI scripts.",
      "ja": "32ビットMicrosoft Windowsシステムプラットフォーム（Windows 95、98、NT、および2000）でのSIP CGIの実装は、環境変数をCGIスクリプトにリクエストメタデータを提供するメカニズムとして使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "For Microsoft Windows, the following are defined:",
      "ja": "Microsoft Windowsの場合、以下が定義されています。"
    },
    {
      "indent": 8,
      "text": "Environment variables: These are accessed by the C library routine getenv.",
      "ja": "環境変数：これらは、CライブラリルーチンGetENVによってアクセスされます。"
    },
    {
      "indent": 8,
      "text": "The current working directory: The current working directory for the script SHOULD be set to the directory containing the script.",
      "ja": "現在の作業ディレクトリ：スクリプトの現在の作業ディレクトリは、スクリプトを含むディレクトリに設定する必要があります。"
    },
    {
      "indent": 8,
      "text": "Character set: The US-ASCII character set is used for the definition of environment variable names and header field names; the newline (NL) sequence is CR LF; servers SHOULD also accept LF as a newline.",
      "ja": "文字セット：US-ASCII文字セットは、環境変数名とヘッダーフィールド名の定義に使用されます。NewLine（NL）シーケンスはCr LFです。サーバーもLFを新しいラインとして受け入れる必要があります。"
    },
    {
      "indent": 0,
      "text": "7 Security Considerations",
      "ja": "7つのセキュリティ上の考慮事項"
    },
    {
      "indent": 0,
      "text": "7.1 Request Initiation",
      "section_title": true,
      "ja": "7.1 リクエスト開始"
    },
    {
      "indent": 3,
      "text": "CGI scripts are able to initiate arbitrary SIP transactions, or to produce spoofed responses of any sort. This protocol does not attempt to restrict the actions CGI scripts can take. Server administrators MUST consider CGI scripts to be as security-sensitive as their SIP server itself, and perform equivalent levels of security review before installing them.",
      "ja": "CGIスクリプトは、任意のSIPトランザクションを開始するか、あらゆる種類のスプーフィングされた応答を作成することができます。このプロトコルは、CGIスクリプトが実行できるアクションを制限しようとはしません。サーバー管理者は、CGIスクリプトをSIPサーバー自体と同じくらいセキュリティに敏感であると考える必要があり、インストールする前に同等のレベルのセキュリティレビューを実行する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.2 Authenticated and Encrypted Messages",
      "section_title": true,
      "ja": "7.2 認証された暗号化されたメッセージ"
    },
    {
      "indent": 3,
      "text": "CGI scripts must be careful not to interfere with authentication. In particular, adding or removing header fields that are below the Authorization header will cause the message to fail authentication at the user agent.",
      "ja": "CGIスクリプトは、認証に干渉しないように注意する必要があります。特に、承認ヘッダーの下にあるヘッダーフィールドを追加または削除すると、メッセージはユーザーエージェントで認証に失敗します。"
    },
    {
      "indent": 3,
      "text": "When a SIP request is encrypted, the headers which are in the clear are passed to the server according to this specification. The encrypted portion of the request is passed to the script as a body. Any SIP headers output by the script will be added to the message. However, scripts should be aware that these may be discarded if they also exist within the encrypted portion.",
      "ja": "SIPリクエストが暗号化されると、クリアにあるヘッダーは、この仕様に従ってサーバーに渡されます。リクエストの暗号化された部分は、ボディとしてスクリプトに渡されます。スクリプトによるSIPヘッダー出力は、メッセージに追加されます。ただし、スクリプトは、暗号化された部分内に存在する場合、これらが破棄される可能性があることに注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.3 SIP Header Fields Containing Sensitive Information",
      "section_title": true,
      "ja": "7.3 機密情報を含むSIPヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "Some SIP header fields may carry sensitive information which the server SHOULD NOT pass on to the script unless explicitly configured to do so. For example, if the server protects the script using the Basic authentication scheme, then the client will send an Authorization header field containing a username and password. If the server, rather than the script, validates this information then the password SHOULD NOT be passed on to the script via the HTTP_AUTHORIZATION metavariable.",
      "ja": "一部のSIPヘッダーフィールドには、明示的に設定されていない限り、サーバーがスクリプトに渡すべきではない機密情報が搭載される場合があります。たとえば、基本認証スキームを使用してサーバーがスクリプトを保護する場合、クライアントはユーザー名とパスワードを含む承認ヘッダーフィールドを送信します。スクリプトではなくサーバーがこの情報を検証する場合、http_authorization metavariableを介してパスワードをスクリプトに渡すことはできません。"
    },
    {
      "indent": 0,
      "text": "7.4 Script Interference with the Server",
      "section_title": true,
      "ja": "7.4 サーバーへのスクリプト干渉"
    },
    {
      "indent": 3,
      "text": "The most common implementation of CGI invokes the script as a child process using the same user and group as the server process. It SHOULD therefore be ensured that the script cannot interfere with the server process, its configuration, or documents.",
      "ja": "CGIの最も一般的な実装は、サーバープロセスと同じユーザーとグループを使用して、子プロセスとしてスクリプトを呼び出します。したがって、スクリプトがサーバープロセス、その構成、またはドキュメントに干渉できないことを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the script is executed by calling a function linked in to the server software (either at compile-time or run-time) then precautions SHOULD be taken to protect the core memory of the server, or to ensure that untrusted code cannot be executed.",
      "ja": "スクリプトがサーバーソフトウェアにリンクされた関数（コンパイル時間または実行時）を呼び出して実行される場合、サーバーのコアメモリを保護するため、または信頼されていないコードを実行できないことを確認するために注意を払う必要があります。"
    },
    {
      "indent": 0,
      "text": "7.5 Data Length and Buffering Considerations",
      "section_title": true,
      "ja": "7.5 データの長さとバッファリングの考慮事項"
    },
    {
      "indent": 3,
      "text": "This specification places no limits on the length of entity bodies presented to the script. Scripts SHOULD NOT assume that statically allocated buffers of any size are sufficient to contain the entire submission at one time. Use of a fixed length buffer without careful overflow checking may result in an attacker exploiting `stack-smashing' or `stack-overflow' vulnerabilities of the operating system. Scripts may spool large submissions to disk or other buffering media, but a rapid succession of large submissions may result in denial of service conditions. If the CONTENT_LENGTH of an entity-body is larger than resource considerations allow, scripts SHOULD respond with `413 Request Entity Too Large.'",
      "ja": "この仕様は、スクリプトに提示されたエンティティボディの長さに制限を設けません。スクリプトは、任意のサイズの静的に割り当てられたバッファが、一度に提出全体を封じ込めるのに十分であると想定してはなりません。慎重なオーバーフローチェックなしの固定長バッファーを使用すると、攻撃者がオペレーティングシステムの「スタックスマッシュ」または「スタックオーバーフロー」の脆弱性を悪用する可能性があります。スクリプトは、ディスクまたはその他のバッファリングメディアへの大規模な提出物をスプールする可能性がありますが、大規模な提出物の急速な連続により、サービス条件が拒否される可能性があります。エンティティボディのcontent_lengthがリソースの考慮事項よりも大きい場合、スクリプトは「413リクエストエンティティが大きすぎる」で応答する必要があります。"
    },
    {
      "indent": 0,
      "text": "8 Acknowledgements",
      "ja": "8謝辞"
    },
    {
      "indent": 3,
      "text": "This work draws extremely heavily upon the HTTP CGI specification [1]; approximately half the text of the specification section is taken from that document.",
      "ja": "この作業は、HTTP CGI仕様[1]に非常に重くなります。仕様セクションのテキストの約半分は、そのドキュメントから取得されます。"
    },
    {
      "indent": 0,
      "text": "9 Authors' Addresses",
      "ja": "9著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Jonathan Lennox Dept. of Computer Science Columbia University 1214 Amsterdam Avenue, MC 0401 New York, NY 10027 USA",
      "ja": "コンピュータサイエンスコロンビア大学のジョナサンレノックス部1214アムステルダムアベニュー、MC 0401ニューヨーク、ニューヨーク10027 USA"
    },
    {
      "indent": 3,
      "text": "EMail: lennox@cs.columbia.edu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jonathan Rosenberg dynamicsoft 72 Eagle Rock Ave. First Floor East Hanover, NJ 07936",
      "ja": "ジョナサンローゼンバーグダイナミクスソフト72イーグルロックアベニュー1階イーストハノーバー、ニュージャージー07936"
    },
    {
      "indent": 3,
      "text": "EMail: jdrosen@dynamicsoft.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Henning Schulzrinne Dept. of Computer Science Columbia University 1214 Amsterdam Avenue, MC 0401 New York, NY 10027 USA",
      "ja": "コンピューターサイエンスコロンビア大学のヘニングシュルツリン部1214アムステルダムアベニュー、MC 0401ニューヨーク、ニューヨーク10027 USA"
    },
    {
      "indent": 3,
      "text": "EMail: schulzrinne@cs.columbia.edu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "10 Bibliography",
      "ja": "10書誌"
    },
    {
      "indent": 3,
      "text": "[1] http://hoohoo.ncsa.uiuc.edu/cgi/interface.html",
      "ja": "[1] http://hoohoo.ncsa.uiuc.edu/cgi/interface.html"
    },
    {
      "indent": 3,
      "text": "[2] Handley, M, Schulzrinne, H., Schooler, E. and J. Rosenberg, \"SIP: Session Initiation Protocol\", RFC 2543, March 1999.",
      "ja": "[2] Handley、M、Schulzrinne、H.、Schooler、E。and J. Rosenberg、「SIP：SESSION INTIATION Protocol」、RFC 2543、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[3] Crocker, D., \"Standard for the Format of ARPA Internet Text Messages\", STD 10, RFC 822, August 1982.",
      "ja": "[3] Crocker、D。、「ARPAインターネットテキストメッセージの形式の標準」、STD 10、RFC 822、1982年8月。"
    },
    {
      "indent": 3,
      "text": "[4] Bradner, S., \"Key words for use in RFCs to indicate requirement levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[4] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[5] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.",
      "ja": "[5] Fielding、R.、Gettys、J.、Mogul、J.、Frystyk、H.、Masinter、L.、Leach、P。and T. Berners-Lee、「HyperText Transfer Protocol-HTTP/1.1」、RFC 2616、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[6] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types\", RFC 2046, November 1996.",
      "ja": "[6] Freed、N。およびN. Borenstein、「多目的インターネットメール拡張機能（MIME）パート2：メディアタイプ」、RFC 2046、1996年11月。"
    },
    {
      "indent": 3,
      "text": "[7] Hinden, R. and S. Deering, \"IP Version 6 Addressing Architecture\", RFC 2373, July 1998.",
      "ja": "[7] Hinden、R。and S. Deering、「IPバージョン6アドレス指定アーキテクチャ」、RFC 2373、1998年7月。"
    },
    {
      "indent": 3,
      "text": "[8] St. Johns, M., \"Identification Protocol\", RFC 1413, January 1993.",
      "ja": "[8] セントジョンズ、M。、「識別プロトコル」、RFC 1413、1993年1月。"
    },
    {
      "indent": 3,
      "text": "[9] Berners-Lee, T., Fielding, R. and L. Masinter, \"Uniform Resource Identifiers (URI): Generic Syntax\", RFC 2396, August 1998.",
      "ja": "[9] Berners-Lee、T.、Fielding、R。and L. Masinter、「ユニフォームリソース識別子（URI）：Generic Syntax」、RFC 2396、1998年8月。"
    },
    {
      "indent": 0,
      "text": "11 Full Copyright Statement",
      "ja": "11完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2001）。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書と本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}