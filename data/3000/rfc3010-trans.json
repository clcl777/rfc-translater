{
  "title": {
    "text": "RFC 3010 - NFS version 4 Protocol",
    "ja": "RFC 3010 - NFSバージョン4プロトコル"
  },
  "number": 3010,
  "created_at": "2023-12-31 15:17:18.197711+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                         S. Shepler\nRequest for Comments: 3010                                  B. Callaghan\nObsoletes: 1813, 1094                                        D. Robinson\nCategory: Standards Track                                     R. Thurlow\n                                                   Sun Microsystems Inc.\n                                                                C. Beame\n                                                        Hummingbird Ltd.\n                                                               M. Eisler\n                                                           Zambeel, Inc.\n                                                               D. Noveck\n                                                 Network Appliance, Inc.\n                                                           December 2000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "NFS version 4 Protocol",
      "ja": "NFSバージョン4プロトコル"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2000). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2000）。無断転載を禁じます。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "NFS (Network File System) version 4 is a distributed file system protocol which owes heritage to NFS protocol versions 2 [RFC1094] and 3 [RFC1813]. Unlike earlier versions, the NFS version 4 protocol supports traditional file access while integrating support for file locking and the mount protocol. In addition, support for strong security (and its negotiation), compound operations, client caching, and internationalization have been added. Of course, attention has been applied to making NFS version 4 operate well in an Internet environment.",
      "ja": "NFS（ネットワークファイルシステム）バージョン4は、NFSプロトコルバージョン2 [RFC1094]および3 [RFC1813]に遺産を負う分散ファイルシステムプロトコルです。以前のバージョンとは異なり、NFSバージョン4プロトコルは、ファイルロックとマウントプロトコルのサポートを統合しながら、従来のファイルアクセスをサポートしています。さらに、強力なセキュリティ（およびその交渉）、複合操作、クライアントキャッシュ、および国際化へのサポートが追加されました。もちろん、NFSバージョン4をインターネット環境でうまく動作させることに注意が払われています。"
    },
    {
      "indent": 0,
      "text": "Key Words",
      "ja": "キーワード"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.",
      "ja": "「必須」、「そうしない」、「必須」、「必要」、「「しない」、「そうでない」、「そうではない」、「そうでない」、「推奨」、「5月」、および「オプション」は、RFC 2119に記載されているとおりに解釈されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . .   5\n1.1.  Overview of NFS Version 4 Features . . . . . . . . . . . .   6\n1.1.1.  RPC and Security . . . . . . . . . . . . . . . . . . . .   6\n1.1.2.  Procedure and Operation Structure  . . . . . . . . . . .   7\n1.1.3.  File System Model  . . . . . . . . . . . . . . . . . . .   8\n1.1.3.1.  Filehandle Types . . . . . . . . . . . . . . . . . . .   8\n1.1.3.2.  Attribute Types  . . . . . . . . . . . . . . . . . . .   8\n1.1.3.3.  File System Replication and Migration  . . . . . . . .   9\n1.1.4.  OPEN and CLOSE . . . . . . . . . . . . . . . . . . . . .   9\n1.1.5.  File locking . . . . . . . . . . . . . . . . . . . . . .   9\n1.1.6.  Client Caching and Delegation  . . . . . . . . . . . . .  10\n1.2.  General Definitions  . . . . . . . . . . . . . . . . . . .  11\n2.  Protocol Data Types  . . . . . . . . . . . . . . . . . . . .  12\n2.1.  Basic Data Types . . . . . . . . . . . . . . . . . . . . .  12\n2.2.  Structured Data Types  . . . . . . . . . . . . . . . . . .  14\n3.  RPC and Security Flavor  . . . . . . . . . . . . . . . . . .  18\n3.1.  Ports and Transports . . . . . . . . . . . . . . . . . . .  18\n3.2.  Security Flavors . . . . . . . . . . . . . . . . . . . . .  18\n3.2.1.  Security mechanisms for NFS version 4  . . . . . . . . .  19\n3.2.1.1.  Kerberos V5 as security triple . . . . . . . . . . . .  19\n3.2.1.2.  LIPKEY as a security triple  . . . . . . . . . . . . .  19\n3.2.1.3.  SPKM-3 as a security triple  . . . . . . . . . . . . .  20\n3.3.  Security Negotiation . . . . . . . . . . . . . . . . . . .  21\n3.3.1.  Security Error . . . . . . . . . . . . . . . . . . . . .  21\n3.3.2.  SECINFO  . . . . . . . . . . . . . . . . . . . . . . . .  21\n3.4.  Callback RPC Authentication  . . . . . . . . . . . . . . .  22\n4.  Filehandles  . . . . . . . . . . . . . . . . . . . . . . . .  23\n4.1.  Obtaining the First Filehandle . . . . . . . . . . . . . .  24\n4.1.1.  Root Filehandle  . . . . . . . . . . . . . . . . . . . .  24\n4.1.2.  Public Filehandle  . . . . . . . . . . . . . . . . . . .  24\n4.2.  Filehandle Types . . . . . . . . . . . . . . . . . . . . .  25\n4.2.1.  General Properties of a Filehandle . . . . . . . . . . .  25\n4.2.2.  Persistent Filehandle  . . . . . . . . . . . . . . . . .  26\n4.2.3.  Volatile Filehandle  . . . . . . . . . . . . . . . . . .  26\n4.2.4.  One Method of Constructing a Volatile Filehandle . . . .  28\n4.3.  Client Recovery from Filehandle Expiration . . . . . . . .  28\n5.  File Attributes  . . . . . . . . . . . . . . . . . . . . . .  29\n5.1.  Mandatory Attributes . . . . . . . . . . . . . . . . . . .  30\n5.2.  Recommended Attributes . . . . . . . . . . . . . . . . . .  30\n5.3.  Named Attributes . . . . . . . . . . . . . . . . . . . . .  31\n5.4.  Mandatory Attributes - Definitions . . . . . . . . . . . .  31\n5.5.  Recommended Attributes - Definitions . . . . . . . . . . .  33\n5.6.  Interpreting owner and owner_group . . . . . . . . . . . .  38\n5.7.  Character Case Attributes  . . . . . . . . . . . . . . . .  39\n5.8.  Quota Attributes . . . . . . . . . . . . . . . . . . . . .  39\n5.9.  Access Control Lists . . . . . . . . . . . . . . . . . . .  40\n   5.9.1.  ACE type . . . . . . . . . . . . . . . . . . . . . . . .  41\n5.9.2.  ACE flag . . . . . . . . . . . . . . . . . . . . . . . .  41\n5.9.3.  ACE Access Mask  . . . . . . . . . . . . . . . . . . . .  43\n5.9.4.  ACE who  . . . . . . . . . . . . . . . . . . . . . . . .  44\n6.  File System Migration and Replication  . . . . . . . . . . .  44\n6.1.  Replication  . . . . . . . . . . . . . . . . . . . . . . .  45\n6.2.  Migration  . . . . . . . . . . . . . . . . . . . . . . . .  45\n6.3.  Interpretation of the fs_locations Attribute . . . . . . .  46\n6.4.  Filehandle Recovery for Migration or Replication . . . . .  47\n7.  NFS Server Name Space  . . . . . . . . . . . . . . . . . . .  47\n7.1.  Server Exports . . . . . . . . . . . . . . . . . . . . . .  47\n7.2.  Browsing Exports . . . . . . . . . . . . . . . . . . . . .  48\n7.3.  Server Pseudo File System  . . . . . . . . . . . . . . . .  48\n7.4.  Multiple Roots . . . . . . . . . . . . . . . . . . . . . .  49\n7.5.  Filehandle Volatility  . . . . . . . . . . . . . . . . . .  49\n7.6.  Exported Root  . . . . . . . . . . . . . . . . . . . . . .  49\n7.7.  Mount Point Crossing . . . . . . . . . . . . . . . . . . .  49\n7.8.  Security Policy and Name Space Presentation  . . . . . . .  50\n8.  File Locking and Share Reservations  . . . . . . . . . . . .  50\n8.1.  Locking  . . . . . . . . . . . . . . . . . . . . . . . . .  51\n8.1.1.  Client ID  . . . . . . . . . . . . . . . . . . . . . . .  51\n8.1.2.  Server Release of Clientid . . . . . . . . . . . . . . .  53\n8.1.3.  nfs_lockowner and stateid Definition . . . . . . . . . .  54\n8.1.4.  Use of the stateid . . . . . . . . . . . . . . . . . . .  55\n8.1.5.  Sequencing of Lock Requests  . . . . . . . . . . . . . .  56\n8.1.6.  Recovery from Replayed Requests  . . . . . . . . . . . .  56\n8.1.7.  Releasing nfs_lockowner State  . . . . . . . . . . . . .  57\n8.2.  Lock Ranges  . . . . . . . . . . . . . . . . . . . . . . .  57\n8.3.  Blocking Locks . . . . . . . . . . . . . . . . . . . . . .  58\n8.4.  Lease Renewal  . . . . . . . . . . . . . . . . . . . . . .  58\n8.5.  Crash Recovery . . . . . . . . . . . . . . . . . . . . . .  59\n8.5.1.  Client Failure and Recovery  . . . . . . . . . . . . . .  59\n8.5.2.  Server Failure and Recovery  . . . . . . . . . . . . . .  60\n8.5.3.  Network Partitions and Recovery  . . . . . . . . . . . .  62\n8.6.  Recovery from a Lock Request Timeout or Abort  . . . . . .  63\n8.7.  Server Revocation of Locks . . . . . . . . . . . . . . . .  63\n8.8.  Share Reservations . . . . . . . . . . . . . . . . . . . .  65\n8.9.  OPEN/CLOSE Operations  . . . . . . . . . . . . . . . . . .  65\n8.10.  Open Upgrade and Downgrade  . . . . . . . . . . . . . . .  66\n8.11.  Short and Long Leases . . . . . . . . . . . . . . . . . .  66\n8.12.  Clocks and Calculating Lease Expiration . . . . . . . . .  67\n8.13.  Migration, Replication and State  . . . . . . . . . . . .  67\n8.13.1.  Migration and State . . . . . . . . . . . . . . . . . .  67\n8.13.2.  Replication and State . . . . . . . . . . . . . . . . .  68\n8.13.3.  Notification of Migrated Lease  . . . . . . . . . . . .  69\n9.  Client-Side Caching  . . . . . . . . . . . . . . . . . . . .  69\n9.1.  Performance Challenges for Client-Side Caching . . . . . .  70\n9.2.  Delegation and Callbacks . . . . . . . . . . . . . . . . .  71\n   9.2.1.  Delegation Recovery  . . . . . . . . . . . . . . . . . .  72\n9.3.  Data Caching . . . . . . . . . . . . . . . . . . . . . . .  74\n9.3.1.  Data Caching and OPENs . . . . . . . . . . . . . . . . .  74\n9.3.2.  Data Caching and File Locking  . . . . . . . . . . . . .  75\n9.3.3.  Data Caching and Mandatory File Locking  . . . . . . . .  77\n9.3.4.  Data Caching and File Identity . . . . . . . . . . . . .  77\n9.4.  Open Delegation  . . . . . . . . . . . . . . . . . . . . .  78\n9.4.1.  Open Delegation and Data Caching . . . . . . . . . . . .  80\n9.4.2.  Open Delegation and File Locks . . . . . . . . . . . . .  82\n9.4.3.  Recall of Open Delegation  . . . . . . . . . . . . . . .  82\n9.4.4.  Delegation Revocation  . . . . . . . . . . . . . . . . .  84\n9.5.  Data Caching and Revocation  . . . . . . . . . . . . . . .  84\n9.5.1.  Revocation Recovery for Write Open Delegation  . . . . .  85\n9.6.  Attribute Caching  . . . . . . . . . . . . . . . . . . . .  85\n9.7.  Name Caching . . . . . . . . . . . . . . . . . . . . . . .  86\n9.8.  Directory Caching  . . . . . . . . . . . . . . . . . . . .  87\n10.  Minor Versioning  . . . . . . . . . . . . . . . . . . . . .  88\n11.  Internationalization  . . . . . . . . . . . . . . . . . . .  91\n11.1.  Universal Versus Local Character Sets . . . . . . . . . .  91\n11.2.  Overview of Universal Character Set Standards . . . . . .  92\n11.3.  Difficulties with UCS-4, UCS-2, Unicode . . . . . . . . .  93\n11.4.  UTF-8 and its solutions . . . . . . . . . . . . . . . . .  94\n11.5.  Normalization . . . . . . . . . . . . . . . . . . . . . .  94\n12.  Error Definitions . . . . . . . . . . . . . . . . . . . . .  95\n13.  NFS Version 4 Requests  . . . . . . . . . . . . . . . . . .  99\n13.1.  Compound Procedure  . . . . . . . . . . . . . . . . . . . 100\n13.2.  Evaluation of a Compound Request  . . . . . . . . . . . . 100\n13.3.  Synchronous Modifying Operations  . . . . . . . . . . . . 101\n13.4.  Operation Values  . . . . . . . . . . . . . . . . . . . . 102\n14.  NFS Version 4 Procedures  . . . . . . . . . . . . . . . . . 102\n14.1.  Procedure 0: NULL - No Operation  . . . . . . . . . . . . 102\n14.2.  Procedure 1: COMPOUND - Compound Operations . . . . . . . 102\n14.2.1.  Operation 3: ACCESS - Check Access Rights . . . . . . . 105\n14.2.2.  Operation 4: CLOSE - Close File . . . . . . . . . . . . 108\n14.2.3.  Operation 5: COMMIT - Commit Cached Data  . . . . . . . 109\n14.2.4.  Operation 6: CREATE - Create a Non-Regular File Object. 112\n14.2.5.  Operation 7: DELEGPURGE - Purge Delegations Awaiting\n         Recovery  . . . . . . . . . . . . . . . . . . . . . . . 114\n14.2.6.  Operation 8: DELEGRETURN - Return Delegation  . . . . . 115\n14.2.7.  Operation 9: GETATTR - Get Attributes . . . . . . . . . 115\n14.2.8.  Operation 10: GETFH - Get Current Filehandle  . . . . . 117\n14.2.9.  Operation 11: LINK - Create Link to a File  . . . . . . 118\n14.2.10.  Operation 12: LOCK - Create Lock . . . . . . . . . . . 119\n14.2.11.  Operation 13: LOCKT - Test For Lock  . . . . . . . . . 121\n14.2.12.  Operation 14: LOCKU - Unlock File  . . . . . . . . . . 122\n14.2.13.  Operation 15: LOOKUP - Lookup Filename . . . . . . . . 123\n14.2.14.  Operation 16: LOOKUPP - Lookup Parent Directory  . . . 126\n   14.2.15.  Operation 17: NVERIFY - Verify Difference in\n          Attributes . . . . . . . . . . . . . . . . . . . . . . 127\n14.2.16.  Operation 18: OPEN - Open a Regular File . . . . . . . 128\n14.2.17.  Operation 19: OPENATTR - Open Named Attribute\n          Directory  . . . . . . . . . . . . . . . . . . . . . . 137\n14.2.18.  Operation 20: OPEN_CONFIRM - Confirm Open  . . . . . . 138\n14.2.19.  Operation 21: OPEN_DOWNGRADE - Reduce Open File Access 140\n14.2.20.  Operation 22: PUTFH - Set Current Filehandle . . . . . 141\n14.2.21.  Operation 23: PUTPUBFH - Set Public Filehandle . . . . 142\n14.2.22.  Operation 24: PUTROOTFH - Set Root Filehandle  . . . . 143\n14.2.23.  Operation 25: READ - Read from File  . . . . . . . . . 144\n14.2.24.  Operation 26: READDIR - Read Directory . . . . . . . . 146\n14.2.25.  Operation 27: READLINK - Read Symbolic Link  . . . . . 150\n14.2.26.  Operation 28: REMOVE - Remove Filesystem Object  . . . 151\n14.2.27.  Operation 29: RENAME - Rename Directory Entry  . . . . 153\n14.2.28.  Operation 30: RENEW - Renew a Lease  . . . . . . . . . 155\n14.2.29.  Operation 31: RESTOREFH - Restore Saved Filehandle . . 156\n14.2.30.  Operation 32: SAVEFH - Save Current Filehandle . . . . 157\n14.2.31.  Operation 33: SECINFO - Obtain Available Security  . . 158\n14.2.32.  Operation 34: SETATTR - Set Attributes . . . . . . . . 160\n14.2.33.  Operation 35: SETCLIENTID - Negotiate Clientid . . . . 162\n14.2.34.  Operation 36: SETCLIENTID_CONFIRM - Confirm Clientid . 163\n14.2.35.  Operation 37: VERIFY - Verify Same Attributes  . . . . 164\n14.2.36.  Operation 38: WRITE - Write to File  . . . . . . . . . 166\n15.  NFS Version 4 Callback Procedures . . . . . . . . . . . . . 170\n15.1.  Procedure 0: CB_NULL - No Operation . . . . . . . . . . . 170\n15.2.  Procedure 1: CB_COMPOUND - Compound Operations  . . . . . 171\n15.2.1.  Operation 3: CB_GETATTR - Get Attributes  . . . . . . . 172\n15.2.2.  Operation 4: CB_RECALL - Recall an Open Delegation  . . 173\n16.  Security Considerations . . . . . . . . . . . . . . . . . . 174\n17.  IANA Considerations . . . . . . . . . . . . . . . . . . . . 174\n17.1.  Named Attribute Definition  . . . . . . . . . . . . . . . 174\n18.  RPC definition file . . . . . . . . . . . . . . . . . . . . 175\n19.  Bibliography  . . . . . . . . . . . . . . . . . . . . . . . 206\n20.  Authors . . . . . . . . . . . . . . . . . . . . . . . . . . 210\n20.1.  Editor's Address  . . . . . . . . . . . . . . . . . . . . 210\n20.2.  Authors' Addresses  . . . . . . . . . . . . . . . . . . . 210\n20.3.  Acknowledgements  . . . . . . . . . . . . . . . . . . . . 211\n21.  Full Copyright Statement  . . . . . . . . . . . . . . . . . 212",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The NFS version 4 protocol is a further revision of the NFS protocol defined already by versions 2 [RFC1094] and 3 [RFC1813]. It retains the essential characteristics of previous versions: design for easy recovery, independent of transport protocols, operating systems and filesystems, simplicity, and good performance. The NFS version 4 revision has the following goals: o Improved access and good performance on the Internet.",
      "ja": "NFSバージョン4プロトコルは、バージョン2 [RFC1094]および3 [RFC1813]ですでに定義されているNFSプロトコルのさらなる改訂です。これは、以前のバージョンの本質的な特性を保持しています。輸送プロトコル、オペレーティングシステム、ファイルシステムとは無関係に、簡単に回復するための設計、シンプルさ、優れたパフォーマンスです。NFSバージョン4のリビジョンには、次の目標があります。oインターネット上のアクセスの改善と優れたパフォーマンス。"
    },
    {
      "indent": 6,
      "text": "The protocol is designed to transit firewalls easily, perform well where latency is high and bandwidth is low, and scale to very large numbers of clients per server.",
      "ja": "このプロトコルは、ファイアウォールを簡単にトランジットし、レイテンシが高く帯域幅が低い場合にうまく機能し、サーバーごとに非常に多数のクライアントにスケーリングするように設計されています。"
    },
    {
      "indent": 3,
      "text": "o Strong security with negotiation built into the protocol.",
      "ja": "o プロトコルに組み込まれた交渉を伴う強力なセキュリティ。"
    },
    {
      "indent": 6,
      "text": "The protocol builds on the work of the ONCRPC working group in supporting the RPCSEC_GSS protocol. Additionally, the NFS version 4 protocol provides a mechanism to allow clients and servers the ability to negotiate security and require clients and servers to support a minimal set of security schemes.",
      "ja": "このプロトコルは、RPCSEC_GSSプロトコルをサポートする際に、ONCRPCワーキンググループの作業に基づいています。さらに、NFSバージョン4プロトコルは、クライアントとサーバーがセキュリティを交渉し、クライアントとサーバーに最小限のセキュリティスキームをサポートすることを可能にするメカニズムを提供します。"
    },
    {
      "indent": 3,
      "text": "o Good cross-platform interoperability.",
      "ja": "o 優れたクロスプラットフォームの相互運用性。"
    },
    {
      "indent": 6,
      "text": "The protocol features a file system model that provides a useful, common set of features that does not unduly favor one file system or operating system over another.",
      "ja": "このプロトコルには、あるファイルシステムまたはオペレーティングシステムを別のファイルシステムまたはオペレーティングシステムに不当に支持しない機能セットを提供するファイルシステムモデルを備えています。"
    },
    {
      "indent": 3,
      "text": "o Designed for protocol extensions.",
      "ja": "o プロトコル拡張用に設計されています。"
    },
    {
      "indent": 6,
      "text": "The protocol is designed to accept standard extensions that do not compromise backward compatibility.",
      "ja": "このプロトコルは、後方互換性を損なわない標準拡張機能を受け入れるように設計されています。"
    },
    {
      "indent": 0,
      "text": "1.1. Overview of NFS Version 4 Features",
      "section_title": true,
      "ja": "1.1. NFSバージョン4の機能の概要"
    },
    {
      "indent": 3,
      "text": "To provide a reasonable context for the reader, the major features of NFS version 4 protocol will be reviewed in brief. This will be done to provide an appropriate context for both the reader who is familiar with the previous versions of the NFS protocol and the reader that is new to the NFS protocols. For the reader new to the NFS protocols, there is still a fundamental knowledge that is expected. The reader should be familiar with the XDR and RPC protocols as described in [RFC1831] and [RFC1832]. A basic knowledge of file systems and distributed file systems is expected as well.",
      "ja": "読者に合理的なコンテキストを提供するために、NFSバージョン4プロトコルの主要な機能を簡単に確認します。これは、NFSプロトコルの以前のバージョンに精通している読者と、NFSプロトコルの新しいリーダーの両方に適切なコンテキストを提供するために行われます。NFSプロトコルを初めて使用するリーダーには、予想される基本的な知識がまだあります。[RFC1831]および[RFC1832]で説明されているように、読者はXDRおよびRPCプロトコルに精通している必要があります。ファイルシステムと分散ファイルシステムの基本的な知識も期待されています。"
    },
    {
      "indent": 0,
      "text": "1.1.1. RPC and Security",
      "section_title": true,
      "ja": "1.1.1. RPCとセキュリティ"
    },
    {
      "indent": 3,
      "text": "As with previous versions of NFS, the External Data Representation (XDR) and Remote Procedure Call (RPC) mechanisms used for the NFS version 4 protocol are those defined in [RFC1831] and [RFC1832]. To meet end to end security requirements, the RPCSEC_GSS framework [RFC2203] will be used to extend the basic RPC security. With the use of RPCSEC_GSS, various mechanisms can be provided to offer authentication, integrity, and privacy to the NFS version 4 protocol. Kerberos V5 will be used as described in [RFC1964] to provide one security framework. The LIPKEY GSS-API mechanism described in",
      "ja": "NFSの以前のバージョンと同様に、NFSバージョン4プロトコルに使用される外部データ表現（XDR）およびリモートプロシージャコール（RPC）メカニズムは、[RFC1831]および[RFC1832]で定義されているメカニズムです。エンドツーエンドセキュリティ要件を満たすために、RPCSEC_GSSフレームワーク[RFC2203]を使用して、基本的なRPCセキュリティを拡張します。RPCSEC_GSSを使用すると、NFSバージョン4プロトコルの認証、整合性、プライバシーを提供するために、さまざまなメカニズムを提供できます。Kerberos V5は、[RFC1964]に記載されているように使用され、1つのセキュリティフレームワークを提供します。で説明されているリプキーGSS-APIメカニズム"
    },
    {
      "indent": 3,
      "text": "[RFC2847] will be used to provide for the use of user password and server public key by the NFS version 4 protocol. With the use of RPCSEC_GSS, other mechanisms may also be specified and used for NFS version 4 security.",
      "ja": "[RFC2847]は、NFSバージョン4プロトコルによるユーザーパスワードとサーバーの公開キーの使用を提供するために使用されます。RPCSEC_GSSを使用すると、NFSバージョン4セキュリティに他のメカニズムも指定および使用できます。"
    },
    {
      "indent": 3,
      "text": "To enable in-band security negotiation, the NFS version 4 protocol has added a new operation which provides the client a method of querying the server about its policies regarding which security mechanisms must be used for access to the server's file system resources. With this, the client can securely match the security mechanism that meets the policies specified at both the client and server.",
      "ja": "帯域内のセキュリティ交渉を有効にするために、NFSバージョン4プロトコルは、サーバーのファイルシステムリソースにアクセスするためにセキュリティメカニズムを使用する必要があるセキュリティメカニズムを使用する必要があるというポリシーについてクライアントにクライアントにクエリする方法を提供する新しい操作を追加しました。これにより、クライアントは、クライアントとサーバーの両方で指定されたポリシーを満たすセキュリティメカニズムを安全に一致させることができます。"
    },
    {
      "indent": 0,
      "text": "1.1.2. Procedure and Operation Structure",
      "section_title": true,
      "ja": "1.1.2. 手順と操作構造"
    },
    {
      "indent": 3,
      "text": "A significant departure from the previous versions of the NFS protocol is the introduction of the COMPOUND procedure. For the NFS version 4 protocol, there are two RPC procedures, NULL and COMPOUND. The COMPOUND procedure is defined in terms of operations and these operations correspond more closely to the traditional NFS procedures. With the use of the COMPOUND procedure, the client is able to build simple or complex requests. These COMPOUND requests allow for a reduction in the number of RPCs needed for logical file system operations. For example, without previous contact with a server a client will be able to read data from a file in one request by combining LOOKUP, OPEN, and READ operations in a single COMPOUND RPC. With previous versions of the NFS protocol, this type of single request was not possible.",
      "ja": "NFSプロトコルの以前のバージョンからの大幅な逸脱は、複合手順の導入です。NFSバージョン4プロトコルには、NULLと化合物の2つのRPC手順があります。複合手順は操作の観点から定義されており、これらの操作は従来のNFS手順により密接に対応しています。複合手順を使用すると、クライアントは単純または複雑な要求を作成できます。これらの複合リクエストにより、論理ファイルシステム操作に必要なRPCの数を減らすことができます。たとえば、サーバーとの以前の連絡がなければ、クライアントは、単一の化合物RPCでルックアップ、オープン、および読み取り操作を組み合わせて、1つのリクエストでファイルからデータを読み取ることができます。NFSプロトコルの以前のバージョンでは、このタイプの単一リクエストは不可能でした。"
    },
    {
      "indent": 3,
      "text": "The model used for COMPOUND is very simple. There is no logical OR or ANDing of operations. The operations combined within a COMPOUND request are evaluated in order by the server. Once an operation returns a failing result, the evaluation ends and the results of all evaluated operations are returned to the client.",
      "ja": "化合物に使用されるモデルは非常に簡単です。操作の論理的またはまたはandingはありません。複合リクエスト内に組み合わされた操作は、サーバーによって順番に評価されます。操作が失敗した結果を返すと、評価が終了し、すべての評価された操作の結果がクライアントに返されます。"
    },
    {
      "indent": 3,
      "text": "The NFS version 4 protocol continues to have the client refer to a file or directory at the server by a \"filehandle\". The COMPOUND procedure has a method of passing a filehandle from one operation to another within the sequence of operations. There is a concept of a \"current filehandle\" and \"saved filehandle\". Most operations use the \"current filehandle\" as the file system object to operate upon. The \"saved filehandle\" is used as temporary filehandle storage within a COMPOUND procedure as well as an additional operand for certain operations.",
      "ja": "NFSバージョン4プロトコルは、「FileHandle」によってサーバーのファイルまたはディレクトリをクライアントに参照させ続けています。複合手順には、一連の操作内でファイルハンドルをある操作から別の操作に渡す方法があります。「現在のファイルハンドル」と「保存されたファイルハンドル」の概念があります。ほとんどの操作は、ファイルシステムオブジェクトとして「現在のファイルハンドル」を使用して動作させます。「保存されたファイルハンドル」は、複合手順内の一時的なファイルハンドルストレージとして、および特定の操作のための追加のオペランドとして使用されます。"
    },
    {
      "indent": 0,
      "text": "1.1.3. File System Model",
      "section_title": true,
      "ja": "1.1.3. ファイルシステムモデル"
    },
    {
      "indent": 3,
      "text": "The general file system model used for the NFS version 4 protocol is the same as previous versions. The server file system is hierarchical with the regular files contained within being treated as opaque byte streams. In a slight departure, file and directory names are encoded with UTF-8 to deal with the basics of internationalization.",
      "ja": "NFSバージョン4プロトコルに使用される一般的なファイルシステムモデルは、以前のバージョンと同じです。サーバーファイルシステムは、不透明なバイトストリームとして扱われることに含まれる通常のファイルとともに階層的です。わずかな出発では、ファイルとディレクトリ名がUTF-8でエンコードされ、国際化の基本に対処します。"
    },
    {
      "indent": 3,
      "text": "The NFS version 4 protocol does not require a separate protocol to provide for the initial mapping between path name and filehandle. Instead of using the older MOUNT protocol for this mapping, the server provides a ROOT filehandle that represents the logical root or top of the file system tree provided by the server. The server provides multiple file systems by gluing them together with pseudo file systems. These pseudo file systems provide for potential gaps in the path names between real file systems.",
      "ja": "NFSバージョン4プロトコルでは、パス名とファイルハンドル間の初期マッピングを提供するために、個別のプロトコルを必要としません。このマッピングに古いマウントプロトコルを使用する代わりに、サーバーは、サーバーが提供するファイルシステムツリーの論理ルートまたは上部を表すルートファイルハンドルを提供します。サーバーは、擬似ファイルシステムと一緒に接着することにより、複数のファイルシステムを提供します。これらの擬似ファイルシステムは、実際のファイルシステム間のパス名の潜在的なギャップを提供します。"
    },
    {
      "indent": 0,
      "text": "1.1.3.1. Filehandle Types",
      "section_title": true,
      "ja": "1.1.3.1. ファイルハンドルタイプ"
    },
    {
      "indent": 3,
      "text": "In previous versions of the NFS protocol, the filehandle provided by the server was guaranteed to be valid or persistent for the lifetime of the file system object to which it referred. For some server implementations, this persistence requirement has been difficult to meet. For the NFS version 4 protocol, this requirement has been relaxed by introducing another type of filehandle, volatile. With persistent and volatile filehandle types, the server implementation can match the abilities of the file system at the server along with the operating environment. The client will have knowledge of the type of filehandle being provided by the server and can be prepared to deal with the semantics of each.",
      "ja": "NFSプロトコルの以前のバージョンでは、サーバーが提供するファイルハンドルが、参照されたファイルシステムオブジェクトの寿命に対して有効または永続的であることが保証されていました。一部のサーバーの実装では、この永続性要件を満たすのは困難です。NFSバージョン4プロトコルの場合、この要件は、別のタイプのファイルハンドル、揮発性を導入することで緩和されています。永続的で揮発性のファイルハンドルタイプを使用すると、サーバーの実装は、動作環境とともにサーバーのファイルシステムの能力と一致させることができます。クライアントは、サーバーによって提供されるファイルハンドルのタイプに関する知識を持ち、それぞれのセマンティクスに対処する準備ができます。"
    },
    {
      "indent": 0,
      "text": "1.1.3.2. Attribute Types",
      "section_title": true,
      "ja": "1.1.3.2. 属性タイプ"
    },
    {
      "indent": 3,
      "text": "The NFS version 4 protocol introduces three classes of file system or file attributes. Like the additional filehandle type, the classification of file attributes has been done to ease server implementations along with extending the overall functionality of the NFS protocol. This attribute model is structured to be extensible such that new attributes can be introduced in minor revisions of the protocol without requiring significant rework.",
      "ja": "NFSバージョン4プロトコルは、3つのクラスのファイルシステムまたはファイル属性を導入します。追加のファイルハンドルタイプと同様に、NFSプロトコルの全体的な機能を拡張するとともに、サーバーの実装を容易にするためにファイル属性の分類が行われました。この属性モデルは、重要な再作業を必要とせずに、新しい属性をプロトコルの軽微な改訂で導入できるように拡張可能に構成されています。"
    },
    {
      "indent": 3,
      "text": "The three classifications are: mandatory, recommended and named attributes. This is a significant departure from the previous attribute model used in the NFS protocol. Previously, the attributes for the file system and file objects were a fixed set of mainly Unix attributes. If the server or client did not support a particular attribute, it would have to simulate the attribute the best it could.",
      "ja": "3つの分類は、必須、推奨、名前付き属性です。これは、NFSプロトコルで使用されていた以前の属性モデルからの大幅な逸脱です。以前は、ファイルシステムとファイルオブジェクトの属性は、主にUNIX属性の固定セットでした。サーバーまたはクライアントが特定の属性をサポートしていない場合、可能な限り属性をシミュレートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes are the minimal set of file or file system attributes that must be provided by the server and must be properly represented by the server. Recommended attributes represent different file system types and operating environments. The recommended attributes will allow for better interoperability and the inclusion of more operating environments. The mandatory and recommended attribute sets are traditional file or file system attributes. The third type of attribute is the named attribute. A named attribute is an opaque byte stream that is associated with a directory or file and referred to by a string name. Named attributes are meant to be used by client applications as a method to associate application specific data with a regular file or directory.",
      "ja": "必須属性は、サーバーによって提供され、サーバーによって適切に表現する必要があるファイルまたはファイルシステムの属性の最小セットです。推奨属性は、異なるファイルシステムタイプと動作環境を表します。推奨される属性により、相互運用性の向上と、より多くの動作環境が含まれる可能性があります。必須および推奨属性セットは、従来のファイルまたはファイルシステム属性です。3番目のタイプの属性は、指名された属性です。名前付き属性は、ディレクトリまたはファイルに関連付けられ、文字列名で呼ばれる不透明なバイトストリームです。名前付き属性は、クライアントアプリケーションで使用され、アプリケーション固有のデータを通常のファイルまたはディレクトリに関連付ける方法として使用することを目的としています。"
    },
    {
      "indent": 3,
      "text": "One significant addition to the recommended set of file attributes is the Access Control List (ACL) attribute. This attribute provides for directory and file access control beyond the model used in previous versions of the NFS protocol. The ACL definition allows for specification of user and group level access control.",
      "ja": "推奨されるファイル属性のセットへの重要な追加の1つは、アクセス制御リスト（ACL）属性です。この属性は、NFSプロトコルの以前のバージョンで使用されたモデルを超えて、ディレクトリとファイルアクセス制御を提供します。ACL定義により、ユーザーとグループレベルのアクセス制御の指定が可能です。"
    },
    {
      "indent": 0,
      "text": "1.1.3.3. File System Replication and Migration",
      "section_title": true,
      "ja": "1.1.3.3. ファイルシステムの複製と移行"
    },
    {
      "indent": 3,
      "text": "With the use of a special file attribute, the ability to migrate or replicate server file systems is enabled within the protocol. The file system locations attribute provides a method for the client to probe the server about the location of a file system. In the event of a migration of a file system, the client will receive an error when operating on the file system and it can then query as to the new file system location. Similar steps are used for replication, the client is able to query the server for the multiple available locations of a particular file system. From this information, the client can use its own policies to access the appropriate file system location.",
      "ja": "特別なファイル属性を使用すると、プロトコル内でサーバーファイルシステムを移行または複製する機能が有効になります。ファイルシステムの場所属性は、クライアントがファイルシステムの場所についてサーバーにプローブする方法を提供します。ファイルシステムが移行した場合、クライアントはファイルシステムで動作するときにエラーを受け取り、新しいファイルシステムの場所をクエリすることができます。同様の手順が複製に使用されます。クライアントは、特定のファイルシステムの複数の使用可能な場所をサーバーにクエリすることができます。この情報から、クライアントは独自のポリシーを使用して、適切なファイルシステムの場所にアクセスできます。"
    },
    {
      "indent": 0,
      "text": "1.1.4. OPEN and CLOSE",
      "section_title": true,
      "ja": "1.1.4. 開いて閉じます"
    },
    {
      "indent": 3,
      "text": "The NFS version 4 protocol introduces OPEN and CLOSE operations. The OPEN operation provides a single point where file lookup, creation, and share semantics can be combined. The CLOSE operation also provides for the release of state accumulated by OPEN.",
      "ja": "NFSバージョン4プロトコルでは、オープンおよびクローズ操作が導入されています。オープン操作は、ファイルのルックアップ、作成、共有セマンティクスを組み合わせることができる単一のポイントを提供します。緊密な操作は、オープンによって蓄積された状態のリリースも提供します。"
    },
    {
      "indent": 0,
      "text": "1.1.5. File locking",
      "section_title": true,
      "ja": "1.1.5. ファイルロック"
    },
    {
      "indent": 3,
      "text": "With the NFS version 4 protocol, the support for byte range file locking is part of the NFS protocol. The file locking support is structured so that an RPC callback mechanism is not required. This is a departure from the previous versions of the NFS file locking protocol, Network Lock Manager (NLM). The state associated with file locks is maintained at the server under a lease-based model. The server defines a single lease period for all state held by a NFS client. If the client does not renew its lease within the defined period, all state associated with the client's lease may be released by the server. The client may renew its lease with use of the RENEW operation or implicitly by use of other operations (primarily READ).",
      "ja": "NFSバージョン4プロトコルでは、BYTE範囲ファイルロックのサポートはNFSプロトコルの一部です。ファイルロックサポートは構造化されているため、RPCコールバックメカニズムが不要になります。これは、NFSファイルロックプロトコルのネットワークロックマネージャー（NLM）の以前のバージョンからの逸脱です。ファイルロックに関連付けられた状態は、リースベースのモデルの下でサーバーで維持されます。サーバーは、NFSクライアントが保有するすべての州の単一のリース期間を定義します。クライアントが定義された期間内にリースを更新しない場合、クライアントのリースに関連するすべての状態がサーバーによってリリースされる場合があります。クライアントは、他の操作を使用して、更新操作を使用してリースを更新することができます（主に読み取り）。"
    },
    {
      "indent": 0,
      "text": "1.1.6. Client Caching and Delegation",
      "section_title": true,
      "ja": "1.1.6. クライアントのキャッシュと代表団"
    },
    {
      "indent": 3,
      "text": "The file, attribute, and directory caching for the NFS version 4 protocol is similar to previous versions. Attributes and directory information are cached for a duration determined by the client. At the end of a predefined timeout, the client will query the server to see if the related file system object has been updated.",
      "ja": "NFSバージョン4プロトコルのファイル、属性、およびディレクトリキャッシングは、以前のバージョンに似ています。属性とディレクトリ情報は、クライアントが決定する期間、キャッシュされます。事前定義されたタイムアウトの最後に、クライアントはサーバーを照会して、関連するファイルシステムオブジェクトが更新されているかどうかを確認します。"
    },
    {
      "indent": 3,
      "text": "For file data, the client checks its cache validity when the file is opened. A query is sent to the server to determine if the file has been changed. Based on this information, the client determines if the data cache for the file should kept or released. Also, when the file is closed, any modified data is written to the server.",
      "ja": "ファイルデータの場合、クライアントはファイルが開いたときにキャッシュの有効性をチェックします。クエリがサーバーに送信され、ファイルが変更されたかどうかを判断します。この情報に基づいて、クライアントは、ファイルのデータキャッシュが保持またはリリースされるかどうかを判断します。また、ファイルが閉じている場合、変更されたデータはサーバーに書き込まれます。"
    },
    {
      "indent": 3,
      "text": "If an application wants to serialize access to file data, file locking of the file data ranges in question should be used.",
      "ja": "アプリケーションがファイルデータへのアクセスをシリアル化する場合、問題のファイルデータ範囲のファイルロックを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The major addition to NFS version 4 in the area of caching is the ability of the server to delegate certain responsibilities to the client. When the server grants a delegation for a file to a client, the client is guaranteed certain semantics with respect to the sharing of that file with other clients. At OPEN, the server may provide the client either a read or write delegation for the file. If the client is granted a read delegation, it is assured that no other client has the ability to write to the file for the duration of the delegation. If the client is granted a write delegation, the client is assured that no other client has read or write access to the file.",
      "ja": "キャッシュの分野におけるNFSバージョン4への主要な追加は、サーバーが特定の責任をクライアントに委任する能力です。サーバーがファイルの代表団をクライアントに付与する場合、クライアントは、他のクライアントとそのファイルの共有に関して特定のセマンティクスが保証されます。開いているとき、サーバーはクライアントにファイルの読み取りまたは書き込み委任を提供する場合があります。クライアントに読み取り代表団が許可されている場合、代表団の期間中、他のクライアントがファイルに書き込むことができないことが保証されています。クライアントに書き込み代表団が許可されている場合、クライアントは他のクライアントがファイルへの読み取りまたは書き込みアクセスを持っていないことを保証します。"
    },
    {
      "indent": 3,
      "text": "Delegations can be recalled by the server. If another client requests access to the file in such a way that the access conflicts with the granted delegation, the server is able to notify the initial client and recall the delegation. This requires that a callback path exist between the server and client. If this callback path does not exist, then delegations can not be granted. The essence of a delegation is that it allows the client to locally service operations such as OPEN, CLOSE, LOCK, LOCKU, READ, WRITE without immediate interaction with the server.",
      "ja": "代表団はサーバーによってリコールできます。別のクライアントが、アクセスが付与された委任と競合するようにファイルへのアクセスを要求した場合、サーバーは最初のクライアントに通知して代表団をリコールすることができます。これには、サーバーとクライアントの間にコールバックパスが存在する必要があります。このコールバックパスが存在しない場合、代表団に付与できません。代表団の本質は、クライアントがサーバーとの即時のやり取りなしに、オープン、クローズ、ロック、ロック、読み取りなどのオープン、クローズ、ロック、読み取りなどの操作をローカルにサービスできることです。"
    },
    {
      "indent": 0,
      "text": "1.2. General Definitions",
      "section_title": true,
      "ja": "1.2. 一般的な定義"
    },
    {
      "indent": 3,
      "text": "The following definitions are provided for the purpose of providing an appropriate context for the reader.",
      "ja": "読者に適切なコンテキストを提供する目的で、以下の定義が提供されています。"
    },
    {
      "indent": 3,
      "text": "Client The \"client\" is the entity that accesses the NFS server's resources. The client may be an application which contains the logic to access the NFS server directly. The client may also be the traditional operating system client remote file system services for a set of applications.",
      "ja": "クライアント「クライアント」は、NFSサーバーのリソースにアクセスするエンティティです。クライアントは、NFSサーバーに直接アクセスするロジックを含むアプリケーションである場合があります。クライアントは、一連のアプリケーションの従来のオペレーティングシステムクライアントリモートファイルシステムサービスでもあります。"
    },
    {
      "indent": 13,
      "text": "In the case of file locking the client is the entity that maintains a set of locks on behalf of one or more applications. This client is responsible for crash or failure recovery for those locks it manages.",
      "ja": "ファイルロックの場合、クライアントは、1つ以上のアプリケーションに代わってロックのセットを維持するエンティティです。このクライアントは、管理するロックのクラッシュまたは故障回復を担当します。"
    },
    {
      "indent": 13,
      "text": "Note that multiple clients may share the same transport and multiple clients may exist on the same network node.",
      "ja": "複数のクライアントが同じトランスポートを共有し、同じネットワークノードに複数のクライアントが存在する場合があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Clientid A 64-bit quantity used as a unique, short-hand reference to a client supplied Verifier and ID. The server is responsible for supplying the Clientid.",
      "ja": "ClientIDは、クライアントが提供された検証剤とIDを提供するユニークで短い手の参照として使用される64ビットの数量です。サーバーは、clientidを提供する責任があります。"
    },
    {
      "indent": 3,
      "text": "Lease An interval of time defined by the server for which the client is irrevocably granted a lock. At the end of a lease period the lock may be revoked if the lease has not been extended. The lock must be revoked if a conflicting lock has been granted after the lease interval.",
      "ja": "クライアントがロックを取り消せないほど許可されているサーバーによって定義された時間間隔をリースします。リース期間の終わりに、リースが延長されていない場合、ロックが取り消される可能性があります。リース間隔後に競合するロックが許可されている場合、ロックを取り消す必要があります。"
    },
    {
      "indent": 13,
      "text": "All leases granted by a server have the same fixed interval. Note that the fixed interval was chosen to alleviate the expense a server would have in maintaining state about variable length leases across server failures.",
      "ja": "サーバーによって付与されるすべてのリースには、同じ固定間隔があります。固定間隔は、サーバーの障害全体でさまざまな長さリースに関する状態を維持する際にサーバーが持つ費用を緩和するために選択されたことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Lock The term \"lock\" is used to refer to both record (byte-range) locks as well as file (share) locks unless specifically stated otherwise.",
      "ja": "ロック「ロック」という用語は、特に明記されていない限り、レコード（バイトレンジ）ロックとファイル（共有）ロックの両方を参照するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Server The \"Server\" is the entity responsible for coordinating client access to a set of file systems.",
      "ja": "サーバー「サーバー」とは、ファイルシステムのセットへのクライアントアクセスを調整するエンティティです。"
    },
    {
      "indent": 3,
      "text": "Stable Storage NFS version 4 servers must be able to recover without data loss from multiple power failures (including cascading power failures, that is, several power failures in quick succession), operating system failures, and hardware failure of components other than the storage medium itself (for example, disk, nonvolatile RAM).",
      "ja": "安定したストレージNFSバージョン4サーバーは、複数の電源障害（カスケード電源障害、つまり迅速な連続したいくつかの電力障害を含む）、オペレーティングシステムの障害、およびストレージ媒体以外のコンポーネントのハードウェア障害を含むデータ損失なしに回復できる必要があります（たとえば、ディスク、不揮発性RAM）。"
    },
    {
      "indent": 13,
      "text": "Some examples of stable storage that are allowable for an NFS server include:",
      "ja": "NFSサーバーに許容される安定したストレージの例は次のとおりです。"
    },
    {
      "indent": 13,
      "text": "1. Media commit of data, that is, the modified data has been successfully written to the disk media, for example, the disk platter.",
      "ja": "1. データのメディアコミット、つまり、修正されたデータは、たとえばディスクプラッターなど、ディスクメディアに正常に書き込まれています。"
    },
    {
      "indent": 13,
      "text": "2. An immediate reply disk drive with battery-backed on-drive intermediate storage or uninterruptible power system (UPS).",
      "ja": "2. バッテリーバッキングオンドライブ中間ストレージまたは無停電電源システム（UPS）を備えた即時の返信ディスクドライブ。"
    },
    {
      "indent": 13,
      "text": "3. Server commit of data with battery-backed intermediate storage and recovery software.",
      "ja": "3. バッテリーが支援する中間ストレージおよびリカバリソフトウェアを使用したデータのサーバーコミット。"
    },
    {
      "indent": 13,
      "text": "4. Cache commit with uninterruptible power system (UPS) and recovery software.",
      "ja": "4. 中断性のない電力システム（UPS）およびリカバリソフトウェアを使用してキャッシュコミット。"
    },
    {
      "indent": 3,
      "text": "Stateid A 64-bit quantity returned by a server that uniquely defines the locking state granted by the server for a specific lock owner for a specific file.",
      "ja": "StateIDは、特定のファイルに対して特定のロック所有者に対してサーバーが付与されたロック状態を一意に定義するサーバーによって返される64ビット数量。"
    },
    {
      "indent": 13,
      "text": "Stateids composed of all bits 0 or all bits 1 have special meaning and are reserved values.",
      "ja": "すべてのビット0またはすべてのビット1で構成されるStateids 1には特別な意味があり、予約された値です。"
    },
    {
      "indent": 3,
      "text": "Verifier A 64-bit quantity generated by the client that the server can use to determine if the client has restarted and lost all previous lock state.",
      "ja": "Verifierは、サーバーが以前のすべてのロック状態を再起動して失ったかどうかを判断するためにサーバーが使用できるクライアントによって生成された64ビット数量。"
    },
    {
      "indent": 0,
      "text": "2. Protocol Data Types",
      "section_title": true,
      "ja": "2. プロトコルデータ型"
    },
    {
      "indent": 3,
      "text": "The syntax and semantics to describe the data types of the NFS version 4 protocol are defined in the XDR [RFC1832] and RPC [RFC1831] documents. The next sections build upon the XDR data types to define types and structures specific to this protocol.",
      "ja": "NFSバージョン4プロトコルのデータ型を記述する構文とセマンティクスは、XDR [RFC1832]およびRPC [RFC1831]ドキュメントで定義されています。次のセクションでは、XDRデータ型に基づいて、このプロトコルに固有のタイプと構造を定義します。"
    },
    {
      "indent": 0,
      "text": "2.1. Basic Data Types",
      "section_title": true,
      "ja": "2.1. 基本的なデータ型"
    },
    {
      "indent": 3,
      "text": "Data Type     Definition\n_____________________________________________________________________\nint32_t       typedef int             int32_t;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "uint32_t typedef unsigned int uint32_t;",
      "ja": "uint32_t typedef unsigned int uint32_t;"
    },
    {
      "indent": 3,
      "text": "int64_t typedef hyper int64_t;",
      "ja": "int64_t typedef hyper int64_t;"
    },
    {
      "indent": 3,
      "text": "uint64_t typedef unsigned hyper uint64_t;",
      "ja": "uint64_t typedef unsigned hyper uint64_t;"
    },
    {
      "indent": 3,
      "text": "attrlist4 typedef opaque attrlist4<>; Used for file/directory attributes",
      "ja": "attrlist4 typedef opaque attrlist4 <>;ファイル/ディレクトリ属性に使用されます"
    },
    {
      "indent": 3,
      "text": "bitmap4 typedef uint32_t bitmap4<>; Used in attribute array encoding.",
      "ja": "bitmap4 typedef uint32_t bitmap4 <>;属性配列エンコードで使用されます。"
    },
    {
      "indent": 3,
      "text": "changeid4 typedef uint64_t changeid4; Used in definition of change_info",
      "ja": "ChangeId4 Typedef Uint64_T ChangeId4;Change_infoの定義で使用されます"
    },
    {
      "indent": 3,
      "text": "clientid4 typedef uint64_t clientid4; Shorthand reference to client identification",
      "ja": "clientId4 typedef uint64_t clientid4;クライアント識別への速記の参照"
    },
    {
      "indent": 3,
      "text": "component4 typedef utf8string component4; Represents path name components",
      "ja": "component4 typedef utf8string component4;パス名コンポーネントを表します"
    },
    {
      "indent": 3,
      "text": "count4 typedef uint32_t count4; Various count parameters (READ, WRITE, COMMIT)",
      "ja": "count4 typedef uint32_t count4;さまざまなカウントパラメーター（読み取り、書き込み、コミット）"
    },
    {
      "indent": 3,
      "text": "length4 typedef uint64_t length4; Describes LOCK lengths",
      "ja": "length4 typedef uint64_t length4;ロックの長さについて説明します"
    },
    {
      "indent": 3,
      "text": "linktext4 typedef utf8string linktext4; Symbolic link contents",
      "ja": "linktext4 typedef utf8string linktext4;シンボリックリンクの内容"
    },
    {
      "indent": 3,
      "text": "mode4 typedef uint32_t mode4; Mode attribute data type",
      "ja": "mode4 typedef uint32_t mode4;モード属性データ型"
    },
    {
      "indent": 3,
      "text": "nfs_cookie4 typedef uint64_t nfs_cookie4; Opaque cookie value for READDIR",
      "ja": "nfs_cookie4 typedef uint64_t nfs_cookie4;Readdirの不透明なクッキー値"
    },
    {
      "indent": 3,
      "text": "nfs_fh4       typedef opaque          nfs_fh4<NFS4_FHSIZE>;\n              Filehandle definition; NFS4_FHSIZE is defined as 128",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "nfs_ftype4 enum nfs_ftype4; Various defined file types",
      "ja": "nfs_ftype4 enum nfs_ftype4;さまざまな定義されたファイルタイプ"
    },
    {
      "indent": 3,
      "text": "nfsstat4 enum nfsstat4; Return value for operations",
      "ja": "nfsstat4 enum nfsstat4;操作の返品値"
    },
    {
      "indent": 3,
      "text": "offset4 typedef uint64_t offset4; Various offset designations (READ, WRITE, LOCK, COMMIT)",
      "ja": "Offset4 Typedef UINT64_T Offset4;さまざまなオフセット指定（読み取り、書き込み、ロック、コミット）"
    },
    {
      "indent": 3,
      "text": "pathname4 typedef component4 pathname4<>; Represents path name for LOOKUP, OPEN and others",
      "ja": "pathname4 typedef component4 pathname4 <>;ルックアップ、オープンなどのパス名を表します"
    },
    {
      "indent": 3,
      "text": "qop4 typedef uint32_t qop4; Quality of protection designation in SECINFO",
      "ja": "QOP4 Typedef UINT32_T QOP4;Secinfoにおける保護指定の質"
    },
    {
      "indent": 3,
      "text": "sec_oid4 typedef opaque sec_oid4<>; Security Object Identifier The sec_oid4 data type is not really opaque. Instead contains an ASN.1 OBJECT IDENTIFIER as used by GSS-API in the mech_type argument to GSS_Init_sec_context. See [RFC2078] for details.",
      "ja": "sec_oid4 typedef opaque sec_oid4 <>;セキュリティオブジェクト識別子sec_oid4データ型は実際には不透明ではありません。代わりに、GSS_INIT_SEC_CONTEXTのMECH_TYPE引数でGSS-APIで使用されるASN.1オブジェクト識別子を含みます。詳細については、[RFC2078]を参照してください。"
    },
    {
      "indent": 3,
      "text": "seqid4 typedef uint32_t seqid4; Sequence identifier used for file locking",
      "ja": "seqid4 typedef uint32_t seqid4;ファイルロックに使用されるシーケンス識別子"
    },
    {
      "indent": 3,
      "text": "stateid4 typedef uint64_t stateid4; State identifier used for file locking and delegation",
      "ja": "StateID4 Typedef UINT64_T STATEID4;ファイルロックおよび委任に使用される状態識別子"
    },
    {
      "indent": 3,
      "text": "utf8string typedef opaque utf8string<>; UTF-8 encoding for strings",
      "ja": "utf8string typedef opaque utf8string <>;文字列のUTF-8エンコード"
    },
    {
      "indent": 3,
      "text": "verifier4 typedef opaque verifier4[NFS4_VERIFIER_SIZE]; Verifier used for various operations (COMMIT, CREATE, OPEN, READDIR, SETCLIENTID, WRITE) NFS4_VERIFIER_SIZE is defined as 8",
      "ja": "verifier4 typedef Opaque verifier4 [nfs4_verifier_size];さまざまな操作に使用される検証剤（コミット、作成、オープン、readdir、setclientId、write）nfs4_verifier_sizeは8として定義されています"
    },
    {
      "indent": 0,
      "text": "2.2. Structured Data Types",
      "section_title": true,
      "ja": "2.2. 構造化されたデータ型"
    },
    {
      "indent": 3,
      "text": "nfstime4\n               struct nfstime4 {\n                       int64_t seconds;\n                       uint32_t nseconds;\n               }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "The nfstime4 structure gives the number of seconds and nanoseconds since midnight or 0 hour January 1, 1970 Coordinated Universal Time (UTC). Values greater than zero for the seconds field denote dates after the 0 hour January 1, 1970. Values less than zero for the seconds field denote dates before the 0 hour January 1, 1970. In both cases, the nseconds field is to be added to the seconds field for the final time representation. For example, if the time to be represented is one-half second before 0 hour January 1, 1970, the seconds field would have a value of negative one (-1) and the nseconds fields would have a value of one-half second (500000000). Values greater than 999,999,999 for nseconds are considered invalid.",
      "ja": "NFSTIME4の構造は、1970年1月1日の真夜中または0時間から秒数と0時間の調整されたユニバーサル時間（UTC）から秒数とナノ秒を与えます。秒フィールドのゼロを超える値は、1970年1月1日0時間以降の日付を示します。秒フィールドの値は、1970年1月1日の0時間前の日付を示します。どちらの場合も、NSECONDSフィールドはに追加されます最終時間表現の秒フィールド。たとえば、1970年1月1日0時間前に表される時間が半分前にある場合、秒フィールドは負の値（-1）の値を持ち、nsecondsフィールドは値の半秒（500000000）。nセカンドの999,99,999を超える値は無効と見なされます。"
    },
    {
      "indent": 6,
      "text": "This data type is used to pass time and date information. A server converts to and from its local representation of time when processing time values, preserving as much accuracy as possible. If the precision of timestamps stored for a file system object is less than defined, loss of precision can occur. An adjunct time maintenance protocol is recommended to reduce client and server time skew.",
      "ja": "このデータ型は、日付情報を渡すために使用されます。サーバーは、時間を処理するときの時間のローカル表現と可能な限り多くの精度を保持するときのローカル表現との間で変換します。ファイルシステムオブジェクトのために保存されているタイムスタンプの精度が定義よりも少ない場合、精度の損失が発生する可能性があります。クライアントとサーバーの時間を減らすために、補助時間メンテナンスプロトコルが推奨されます。"
    },
    {
      "indent": 3,
      "text": "time_how4",
      "ja": "time_how4"
    },
    {
      "indent": 18,
      "text": "enum time_how4 { SET_TO_SERVER_TIME4 = 0, SET_TO_CLIENT_TIME4 = 1 };",
      "ja": "enum time_how4 {set_to_server_time4 = 0、set_to_client_time4 = 1};"
    },
    {
      "indent": 3,
      "text": "settime4",
      "ja": "Settime4"
    },
    {
      "indent": 18,
      "text": "union settime4 switch (time_how4 set_it) {\n case SET_TO_CLIENT_TIME4:\n         nfstime4       time;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "The above definitions are used as the attribute definitions to set time values. If set_it is SET_TO_SERVER_TIME4, then the server uses its local representation of time for the time value.",
      "ja": "上記の定義は、時間値を設定するための属性定義として使用されます。set_itがset_to_server_time4である場合、サーバーは時間値に対して時間のローカル表現を使用します。"
    },
    {
      "indent": 3,
      "text": "specdata4",
      "ja": "SpecData4"
    },
    {
      "indent": 18,
      "text": "struct specdata4 {\n        uint32_t specdata1;\n        uint32_t specdata2;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "This data type represents additional information for the device file types NF4CHR and NF4BLK.",
      "ja": "このデータ型は、デバイスファイルタイプNF4CHRおよびNF4BLKの追加情報を表します。"
    },
    {
      "indent": 3,
      "text": "fsid4",
      "ja": "FSID4"
    },
    {
      "indent": 18,
      "text": "struct fsid4 {\n  uint64_t        major;\n  uint64_t        minor;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "This type is the file system identifier that is used as a mandatory attribute.",
      "ja": "このタイプは、必須属性として使用されるファイルシステム識別子です。"
    },
    {
      "indent": 3,
      "text": "fs_location4",
      "ja": "fs_location4"
    },
    {
      "indent": 18,
      "text": "struct fs_location4 {\n        utf8string    server<>;\n        pathname4     rootpath;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "fs_locations4",
      "ja": "fs_locations4"
    },
    {
      "indent": 18,
      "text": "struct fs_locations4 {\n        pathname4     fs_root;\n        fs_location4  locations<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "The fs_location4 and fs_locations4 data types are used for the fs_locations recommended attribute which is used for migration and replication support.",
      "ja": "FS_LOCATION4およびFS_LOCATION4データ型は、移行および複製サポートに使用されるFS_Locations推奨属性に使用されます。"
    },
    {
      "indent": 3,
      "text": "fattr4",
      "ja": "FATTR4"
    },
    {
      "indent": 18,
      "text": "struct fattr4 {\n        bitmap4       attrmask;\n        attrlist4     attr_vals;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "The fattr4 structure is used to represent file and directory attributes.",
      "ja": "FATTR4構造は、ファイルおよびディレクトリの属性を表すために使用されます。"
    },
    {
      "indent": 8,
      "text": "The bitmap is a counted array of 32 bit integers used to contain bit values. The position of the integer in the array that contains bit n can be computed from the expression (n / 32) and its bit within that integer is (n mod 32).",
      "ja": "ビットマップは、ビット値を含むために使用される32ビット整数のカウントされた配列です。ビットnを含む配列内の整数の位置は、式（n / 32）から計算でき、その整数内のビットは（n mod 32）です。"
    },
    {
      "indent": 20,
      "text": "                  0            1\n+-----------+-----------+-----------+--\n|  count    | 31  ..  0 | 63  .. 32 |\n+-----------+-----------+-----------+--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "change_info4",
      "ja": "change_info4"
    },
    {
      "indent": 18,
      "text": "struct change_info4 {\n        bool          atomic;\n        changeid4     before;\n        changeid4     after;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "This structure is used with the CREATE, LINK, REMOVE, RENAME operations to let the client the know value of the change attribute for the directory in which the target file system object resides.",
      "ja": "この構造は、作成、リンク、削除、操作の変更、操作の名前を変更して、ターゲットファイルシステムオブジェクトが存在するディレクトリの変更属性の値をクライアントに知らせることができます。"
    },
    {
      "indent": 3,
      "text": "clientaddr4",
      "ja": "ClientAddr4"
    },
    {
      "indent": 18,
      "text": "struct clientaddr4 {\n        /* see struct rpcb in RFC 1833 */\n        string r_netid<>;    /* network id */\n        string r_addr<>;     /* universal address */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "The clientaddr4 structure is used as part of the SETCLIENT operation to either specify the address of the client that is using a clientid or as part of the call back registration.",
      "ja": "clientAddr4構造は、SetClient操作の一部として使用され、ClientIDを使用しているクライアントのアドレスを指定するか、コールバック登録の一部として指定します。"
    },
    {
      "indent": 3,
      "text": "cb_client4",
      "ja": "CB_CLIENT4"
    },
    {
      "indent": 18,
      "text": "struct cb_client4 {\n        unsigned int  cb_program;\n        clientaddr4   cb_location;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "This structure is used by the client to inform the server of its call back address; includes the program number and client address.",
      "ja": "この構造は、クライアントがサーバーにコールバックアドレスを通知するために使用されます。プログラム番号とクライアントアドレスが含まれています。"
    },
    {
      "indent": 3,
      "text": "nfs_client_id4",
      "ja": "NFS_CLIENT_ID4"
    },
    {
      "indent": 18,
      "text": "struct nfs_client_id4 {\n        verifier4     verifier;\n        opaque        id<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "This structure is part of the arguments to the SETCLIENTID operation.",
      "ja": "この構造は、SetClientID操作の引数の一部です。"
    },
    {
      "indent": 3,
      "text": "nfs_lockowner4",
      "ja": "nfs_lockowner4"
    },
    {
      "indent": 18,
      "text": "struct nfs_lockowner4 {\n        clientid4     clientid;\n        opaque        owner<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "This structure is used to identify the owner of a OPEN share or file lock.",
      "ja": "この構造は、オープンシェアまたはファイルロックの所有者を識別するために使用されます。"
    },
    {
      "indent": 0,
      "text": "3. RPC and Security Flavor",
      "section_title": true,
      "ja": "3. RPCとセキュリティフレーバー"
    },
    {
      "indent": 3,
      "text": "The NFS version 4 protocol is a Remote Procedure Call (RPC) application that uses RPC version 2 and the corresponding eXternal Data Representation (XDR) as defined in [RFC1831] and [RFC1832]. The RPCSEC_GSS security flavor as defined in [RFC2203] MUST be used as the mechanism to deliver stronger security for the NFS version 4 protocol.",
      "ja": "NFSバージョン4プロトコルは、RPCバージョン2と[RFC1831]および[RFC1832]で定義されている対応する外部データ表現（XDR）を使用するリモートプロシージャコール（RPC）アプリケーションです。[RFC2203]で定義されているRPCSEC_GSSセキュリティフレーバーは、NFSバージョン4プロトコルのより強力なセキュリティを提供するメカニズムとして使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.1. Ports and Transports",
      "section_title": true,
      "ja": "3.1. ポートとトランスポート"
    },
    {
      "indent": 3,
      "text": "Historically, NFS version 2 and version 3 servers have resided on port 2049. The registered port 2049 [RFC1700] for the NFS protocol should be the default configuration. Using the registered port for NFS services means the NFS client will not need to use the RPC binding protocols as described in [RFC1833]; this will allow NFS to transit firewalls.",
      "ja": "歴史的に、NFSバージョン2およびバージョン3サーバーはポート2049に存在しています。NFSプロトコルの登録ポート2049 [RFC1700]はデフォルトの構成でなければなりません。NFSサービスに登録されたポートを使用すると、[RFC1833]で説明されているように、NFSクライアントはRPCバインディングプロトコルを使用する必要はありません。これにより、NFSはファイアウォールをトランジットできます。"
    },
    {
      "indent": 3,
      "text": "The transport used by the RPC service for the NFS version 4 protocol MUST provide congestion control comparable to that defined for TCP in [RFC2581]. If the operating environment implements TCP, the NFS version 4 protocol SHOULD be supported over TCP. The NFS client and server may use other transports if they support congestion control as defined above and in those cases a mechanism may be provided to override TCP usage in favor of another transport.",
      "ja": "NFSバージョン4プロトコルにRPCサービスが使用するトランスポートは、[RFC2581]でTCPで定義されたものに匹敵する渋滞制御を提供する必要があります。オペレーティング環境がTCPを実装する場合、NFSバージョン4プロトコルをTCPでサポートする必要があります。NFSクライアントとサーバーは、上記の渋滞制御をサポートする場合、他のトランスポートを使用する場合があり、そのような場合、別のトランスポートを支持してTCP使用をオーバーライドするメカニズムが提供される場合があります。"
    },
    {
      "indent": 3,
      "text": "If TCP is used as the transport, the client and server SHOULD use persistent connections. This will prevent the weakening of TCP's congestion control via short lived connections and will improve performance for the WAN environment by eliminating the need for SYN handshakes.",
      "ja": "TCPがトランスポートとして使用される場合、クライアントとサーバーは永続的な接続を使用する必要があります。これにより、短命の接続を介したTCPの輻輳制御の弱体化が妨げられ、Synハンドシェイクの必要性を排除することにより、WAN環境のパフォーマンスが向上します。"
    },
    {
      "indent": 3,
      "text": "Note that for various timers, the client and server should avoid inadvertent synchronization of those timers. For further discussion of the general issue refer to [Floyd].",
      "ja": "さまざまなタイマーの場合、クライアントとサーバーはそれらのタイマーの不注意な同期を回避する必要があることに注意してください。一般的な問題の詳細については、[フロイド]を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.2. Security Flavors",
      "section_title": true,
      "ja": "3.2. セキュリティフレーバー"
    },
    {
      "indent": 3,
      "text": "Traditional RPC implementations have included AUTH_NONE, AUTH_SYS, AUTH_DH, and AUTH_KRB4 as security flavors. With [RFC2203] an additional security flavor of RPCSEC_GSS has been introduced which uses the functionality of GSS-API [RFC2078]. This allows for the use of varying security mechanisms by the RPC layer without the additional implementation overhead of adding RPC security flavors. For NFS version 4, the RPCSEC_GSS security flavor MUST be used to enable the mandatory security mechanism. Other flavors, such as, AUTH_NONE, AUTH_SYS, and AUTH_DH MAY be implemented as well.",
      "ja": "従来のRPC実装には、Auth_none、auth_sys、auth_dh、およびauth_krb4がセキュリティフレーバーとして含まれています。[RFC2203]では、GSS-API [RFC2078]の機能を使用するRPCSEC_GSSの追加のセキュリティフレーバーが導入されました。これにより、RPCセキュリティフレーバーを追加する追加の実装オーバーヘッドなしで、RPCレイヤーによるさまざまなセキュリティメカニズムを使用できます。NFSバージョン4の場合、RPCSEC_GSSセキュリティフレーバーを使用して、必須のセキュリティメカニズムを有効にする必要があります。auth_none、auth_sys、auth_dhなどの他のフレーバーも実装される場合があります。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Security mechanisms for NFS version 4",
      "section_title": true,
      "ja": "3.2.1. NFSバージョン4のセキュリティメカニズム"
    },
    {
      "indent": 3,
      "text": "The use of RPCSEC_GSS requires selection of: mechanism, quality of protection, and service (authentication, integrity, privacy). The remainder of this document will refer to these three parameters of the RPCSEC_GSS security as the security triple.",
      "ja": "RPCSEC_GSSの使用には、メカニズム、保護の質、およびサービス（認証、整合性、プライバシー）の選択が必要です。このドキュメントの残りの部分では、RPCSEC_GSSセキュリティのこれら3つのパラメーターをセキュリティトリプルとして参照します。"
    },
    {
      "indent": 0,
      "text": "3.2.1.1. Kerberos V5 as security triple",
      "section_title": true,
      "ja": "3.2.1.1. セキュリティトリプルとしてのKerberos V5"
    },
    {
      "indent": 3,
      "text": "The Kerberos V5 GSS-API mechanism as described in [RFC1964] MUST be implemented and provide the following security triples.",
      "ja": "[RFC1964]に記載されているKerberos V5 GSS-APIメカニズムを実装し、以下のセキュリティトリプルを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "column descriptions:",
      "ja": "列の説明："
    },
    {
      "indent": 3,
      "text": "1 == number of pseudo flavor\n2 == name of pseudo flavor\n3 == mechanism's OID\n4 == mechanism's algorithm(s)\n5 == RPCSEC_GSS service",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1      2     3                    4              5\n-----------------------------------------------------------------------\n390003 krb5  1.2.840.113554.1.2.2 DES MAC MD5    rpc_gss_svc_none\n390004 krb5i 1.2.840.113554.1.2.2 DES MAC MD5    rpc_gss_svc_integrity\n390005 krb5p 1.2.840.113554.1.2.2 DES MAC MD5    rpc_gss_svc_privacy\n                                  for integrity,\n                                  and 56 bit DES\n                                  for privacy.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that the pseudo flavor is presented here as a mapping aid to the implementor. Because this NFS protocol includes a method to negotiate security and it understands the GSS-API mechanism, the pseudo flavor is not needed. The pseudo flavor is needed for NFS version 3 since the security negotiation is done via the MOUNT protocol.",
      "ja": "ここでは、擬似風味が実装者へのマッピング援助として提示されていることに注意してください。このNFSプロトコルにはセキュリティを交渉する方法が含まれており、GSS-APIメカニズムを理解しているため、擬似フレーバーは必要ありません。セキュリティ交渉はマウントプロトコルを介して行われるため、NFSバージョン3には擬似フレーバーが必要です。"
    },
    {
      "indent": 3,
      "text": "For a discussion of NFS' use of RPCSEC_GSS and Kerberos V5, please see [RFC2623].",
      "ja": "NFSのRPCSEC_GSSおよびKerberos V5の使用についての議論については、[RFC2623]を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.2.1.2. LIPKEY as a security triple",
      "section_title": true,
      "ja": "3.2.1.2. セキュリティトリプルとしてのリップキー"
    },
    {
      "indent": 3,
      "text": "The LIPKEY GSS-API mechanism as described in [RFC2847] MUST be implemented and provide the following security triples. The definition of the columns matches the previous subsection \"Kerberos V5 as security triple\"",
      "ja": "[RFC2847]に記載されているLipkey GSS-APIメカニズムを実装し、以下のセキュリティトリプルを提供する必要があります。列の定義は、以前のサブセクション「Kerberos V5としてのセキュリティトリプル」と一致しています"
    },
    {
      "indent": 0,
      "text": "1      2        3                    4              5\n-----------------------------------------------------------------------\n390006 lipkey   1.3.6.1.5.5.9        negotiated  rpc_gss_svc_none\n390007 lipkey-i 1.3.6.1.5.5.9        negotiated  rpc_gss_svc_integrity\n390008 lipkey-p 1.3.6.1.5.5.9        negotiated  rpc_gss_svc_privacy",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The mechanism algorithm is listed as \"negotiated\". This is because LIPKEY is layered on SPKM-3 and in SPKM-3 [RFC2847] the confidentiality and integrity algorithms are negotiated. Since SPKM-3 specifies HMAC-MD5 for integrity as MANDATORY, 128 bit cast5CBC for confidentiality for privacy as MANDATORY, and further specifies that HMAC-MD5 and cast5CBC MUST be listed first before weaker algorithms, specifying \"negotiated\" in column 4 does not impair interoperability. In the event an SPKM-3 peer does not support the mandatory algorithms, the other peer is free to accept or reject the GSS-API context creation.",
      "ja": "メカニズムアルゴリズムは「ネゴシエート」としてリストされています。これは、LipkeyがSPKM-3およびSPKM-3 [RFC2847]に階層化されているためです。SPKM-3はHMAC-MD5を整合性として必須として指定しているため、128ビットCAST5CBCはプライバシーのための機密性を義務付けられており、さらにHMAC-MD5とCAST5CBCをより弱いアルゴリズムの前に最初にリストし、列4で「ネゴシオン」を指定する必要があることを指定します。相互運用性。SPKM-3ピアが必須アルゴリズムをサポートしていない場合、他のピアはGSS-APIコンテキストの作成を自由に受け入れるか拒否できます。"
    },
    {
      "indent": 3,
      "text": "Because SPKM-3 negotiates the algorithms, subsequent calls to LIPKEY's GSS_Wrap() and GSS_GetMIC() by RPCSEC_GSS will use a quality of protection value of 0 (zero). See section 5.2 of [RFC2025] for an explanation.",
      "ja": "SPKM-3はアルゴリズムを交渉しているため、RPCSEC_GSSによるLipkeyのGSS_WRAP（）およびGSS_GETMIC（）へのその後の呼び出しは、0（ゼロ）の保護値の品質を使用します。説明については、[RFC2025]のセクション5.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "LIPKEY uses SPKM-3 to create a secure channel in which to pass a user name and password from the client to the user. Once the user name and password have been accepted by the server, calls to the LIPKEY context are redirected to the SPKM-3 context. See [RFC2847] for more details.",
      "ja": "Lipkeyは、SPKM-3を使用して、ユーザー名とパスワードをクライアントからユーザーに渡す安全なチャネルを作成します。ユーザー名とパスワードがサーバーによって受け入れられると、Lipkeyコンテキストへの呼び出しがSPKM-3コンテキストにリダイレクトされます。詳細については、[RFC2847]を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.2.1.3. SPKM-3 as a security triple",
      "section_title": true,
      "ja": "3.2.1.3. セキュリティトリプルとしてのSPKM-3"
    },
    {
      "indent": 3,
      "text": "The SPKM-3 GSS-API mechanism as described in [RFC2847] MUST be implemented and provide the following security triples. The definition of the columns matches the previous subsection \"Kerberos V5 as security triple\".",
      "ja": "[RFC2847]に記載されているSPKM-3 GSS-APIメカニズムを実装し、以下のセキュリティトリプルを提供する必要があります。列の定義は、以前のサブセクション「Kerberos V5としてセキュリティトリプルとして」と一致しています。"
    },
    {
      "indent": 0,
      "text": "1      2        3                    4              5\n-----------------------------------------------------------------------\n390009 spkm3    1.3.6.1.5.5.1.3      negotiated  rpc_gss_svc_none\n390010 spkm3i   1.3.6.1.5.5.1.3      negotiated  rpc_gss_svc_integrity\n390011 spkm3p   1.3.6.1.5.5.1.3      negotiated  rpc_gss_svc_privacy",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For a discussion as to why the mechanism algorithm is listed as \"negotiated\", see the previous section \"LIPKEY as a security triple.\"",
      "ja": "メカニズムアルゴリズムが「ネゴシエート」としてリストされている理由についての議論については、以前のセクション「Lipkeyはセキュリティトリプルとして」を参照してください。"
    },
    {
      "indent": 3,
      "text": "Because SPKM-3 negotiates the algorithms, subsequent calls to SPKM-3's GSS_Wrap() and GSS_GetMIC() by RPCSEC_GSS will use a quality of protection value of 0 (zero). See section 5.2 of [RFC2025] for an explanation.",
      "ja": "SPKM-3はアルゴリズムを交渉しているため、RPCSEC_GSSによるSPKM-3のGSS_WRAP（）およびGSS_GETMIC（）へのその後の呼び出しは、0（ゼロ）の品質を使用します。説明については、[RFC2025]のセクション5.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Even though LIPKEY is layered over SPKM-3, SPKM-3 is specified as a mandatory set of triples to handle the situations where the initiator (the client) is anonymous or where the initiator has its own certificate. If the initiator is anonymous, there will not be a user name and password to send to the target (the server). If the initiator has its own certificate, then using passwords is superfluous.",
      "ja": "LipkeyはSPKM-3上に階層化されていますが、SPKM-3は、イニシエーター（クライアント）が匿名またはイニシエーターが独自の証明書を持っている状況を処理するための必須のトリプルセットとして指定されています。イニシエーターが匿名の場合、ターゲット（サーバー）に送信するユーザー名とパスワードはありません。イニシエーターに独自の証明書がある場合、パスワードを使用することは余分です。"
    },
    {
      "indent": 0,
      "text": "3.3. Security Negotiation",
      "section_title": true,
      "ja": "3.3. セキュリティ交渉"
    },
    {
      "indent": 3,
      "text": "With the NFS version 4 server potentially offering multiple security mechanisms, the client needs a method to determine or negotiate which mechanism is to be used for its communication with the server. The NFS server may have multiple points within its file system name space that are available for use by NFS clients. In turn the NFS server may be configured such that each of these entry points may have different or multiple security mechanisms in use.",
      "ja": "NFSバージョン4サーバーが複数のセキュリティメカニズムを提供する可能性があるため、クライアントは、サーバーとの通信に使用するメカニズムを決定または交渉する方法を必要とします。NFSサーバーには、NFSクライアントが使用できるファイルシステム名スペース内に複数のポイントがある場合があります。次に、これらのエントリポイントのそれぞれが使用されているセキュリティメカニズムが異なるか、複数のセキュリティメカニズムを持つように、NFSサーバーを構成することができます。"
    },
    {
      "indent": 3,
      "text": "The security negotiation between client and server must be done with a secure channel to eliminate the possibility of a third party intercepting the negotiation sequence and forcing the client and server to choose a lower level of security than required or desired.",
      "ja": "クライアントとサーバー間のセキュリティ交渉は、サードパーティが交渉シーケンスを傍受し、クライアントとサーバーが必要または望ましいよりも低いレベルのセキュリティを選択する可能性を排除するために、安全なチャネルで行う必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3.1. Security Error",
      "section_title": true,
      "ja": "3.3.1. セキュリティエラー"
    },
    {
      "indent": 3,
      "text": "Based on the assumption that each NFS version 4 client and server must support a minimum set of security (i.e. LIPKEY, SPKM-3, and Kerberos-V5 all under RPCSEC_GSS), the NFS client will start its communication with the server with one of the minimal security triples. During communication with the server, the client may receive an NFS error of NFS4ERR_WRONGSEC. This error allows the server to notify the client that the security triple currently being used is not appropriate for access to the server's file system resources. The client is then responsible for determining what security triples are available at the server and choose one which is appropriate for the client.",
      "ja": "各NFSバージョン4クライアントとサーバーが最小限のセキュリティ（つまり、Lipkey、SPKM-3、およびKerberos-V5がすべてRPCSEC_GSSの下で）をサポートする必要があるという仮定に基づいて、NFSクライアントはサーバーとの通信を開始します。最小限のセキュリティトリプル。サーバーとの通信中、クライアントはNFS4err_WrongSecのNFSエラーを受信する場合があります。このエラーにより、サーバーは、現在使用されているセキュリティトリプルがサーバーのファイルシステムリソースへのアクセスに適していないことをクライアントに通知できます。その後、クライアントは、サーバーで利用可能なセキュリティトリプルを決定する責任があり、クライアントに適したものを選択します。"
    },
    {
      "indent": 0,
      "text": "3.3.2. SECINFO",
      "section_title": true,
      "ja": "3.3.2. Secinfo"
    },
    {
      "indent": 3,
      "text": "The new SECINFO operation will allow the client to determine, on a per filehandle basis, what security triple is to be used for server access. In general, the client will not have to use the SECINFO procedure except during initial communication with the server or when the client crosses policy boundaries at the server. It is possible that the server's policies change during the client's interaction therefore forcing the client to negotiate a new security triple.",
      "ja": "新しいSECINFO操作により、クライアントは、ファイルハンドルごとに、サーバーアクセスに使用するセキュリティトリプルを決定できます。一般に、クライアントは、サーバーとの最初の通信中またはクライアントがサーバーでポリシーの境界を越えたときを除き、SECINFO手順を使用する必要はありません。クライアントの相互作用中にサーバーのポリシーが変更される可能性があります。そのため、クライアントは新しいセキュリティトリプルを交渉することを余儀なくされます。"
    },
    {
      "indent": 0,
      "text": "3.4. Callback RPC Authentication",
      "section_title": true,
      "ja": "3.4. コールバックRPC認証"
    },
    {
      "indent": 3,
      "text": "The callback RPC (described later) must mutually authenticate the NFS server to the principal that acquired the clientid (also described later), using the same security flavor the original SETCLIENTID operation used. Because LIPKEY is layered over SPKM-3, it is permissible for the server to use SPKM-3 and not LIPKEY for the callback even if the client used LIPKEY for SETCLIENTID.",
      "ja": "コールバックRPC（後述）は、元のSetClientID操作を使用した同じセキュリティフレーバーを使用して、ClientIDを取得したプリンシパル（後述）にNFSサーバーを相互に認証する必要があります。LipkeyはSPKM-3上に階層化されているため、サーバーがSTKM-3を使用することは許可されており、クライアントがSetClientIDにLipkeyを使用した場合でも、コールバックにはリップキーではありません。"
    },
    {
      "indent": 3,
      "text": "For AUTH_NONE, there are no principals, so this is a non-issue.",
      "ja": "auth_noneの場合、プリンシパルはありませんので、これは問題ではありません。"
    },
    {
      "indent": 3,
      "text": "For AUTH_SYS, the server simply uses the AUTH_SYS credential that the user used when it set up the delegation.",
      "ja": "AUTH_SYSの場合、サーバーは、ユーザーが委任を設定したときに使用したAUTH_SYS資格情報を単純に使用します。"
    },
    {
      "indent": 3,
      "text": "For AUTH_DH, one commonly used convention is that the server uses the credential corresponding to this AUTH_DH principal:",
      "ja": "AUTH_DHの場合、一般的に使用される条約の1つは、サーバーがこのauth_dhプリンシパルに対応する資格情報を使用することです。"
    },
    {
      "indent": 9,
      "text": "unix.host@domain",
      "ja": "unix.host@domain"
    },
    {
      "indent": 3,
      "text": "where host and domain are variables corresponding to the name of server host and directory services domain in which it lives such as a Network Information System domain or a DNS domain.",
      "ja": "ここで、ホストとドメインは、ネットワーク情報システムドメインやDNSドメインなど、サーバーホストサービスドメインとディレクトリサービスドメインの名前に対応する変数です。"
    },
    {
      "indent": 3,
      "text": "Regardless of what security mechanism under RPCSEC_GSS is being used, the NFS server, MUST identify itself in GSS-API via a GSS_C_NT_HOSTBASED_SERVICE name type. GSS_C_NT_HOSTBASED_SERVICE names are of the form:",
      "ja": "RPCSEC_GSSの下でのセキュリティメカニズムが使用されているにもかかわらず、NFSサーバーは、GSS_C_NT_HOST_HOSTBASET_SERVICE名タイプを介してGSS-APIで自分自身を識別する必要があります。gss_c_nt_hostbased_service名は形式です。"
    },
    {
      "indent": 9,
      "text": "service@hostname",
      "ja": "service@hostname"
    },
    {
      "indent": 3,
      "text": "For NFS, the \"service\" element is",
      "ja": "NFSの場合、「サービス」要素はです"
    },
    {
      "indent": 9,
      "text": "nfs",
      "ja": "NFS"
    },
    {
      "indent": 3,
      "text": "Implementations of security mechanisms will convert nfs@hostname to various different forms. For Kerberos V5 and LIPKEY, the following form is RECOMMENDED:",
      "ja": "セキュリティメカニズムの実装により、NFS@hostNameをさまざまな形式に変換します。Kerberos V5とLipkeyの場合、次のフォームをお勧めします。"
    },
    {
      "indent": 9,
      "text": "nfs/hostname",
      "ja": "NFS/ホスト名"
    },
    {
      "indent": 3,
      "text": "For Kerberos V5, nfs/hostname would be a server principal in the Kerberos Key Distribution Center database. For LIPKEY, this would be the username passed to the target (the NFS version 4 client that receives the callback).",
      "ja": "Kerberos V5の場合、NFS/ホスト名はKerberos Key Distribution Centerデータベースのサーバープリンシパルになります。Lipkeyの場合、これはターゲットに渡されたユーザー名（コールバックを受信するNFSバージョン4クライアント）になります。"
    },
    {
      "indent": 3,
      "text": "It should be noted that LIPKEY may not work for callbacks, since the LIPKEY client uses a user id/password. If the NFS client receiving the callback can authenticate the NFS server's user name/password pair, and if the user that the NFS server is authenticating to has a public key certificate, then it works.",
      "ja": "LipkeyクライアントはユーザーID/パスワードを使用するため、Lipkeyはコールバックでは機能しない可能性があることに注意してください。コールバックを受信するNFSクライアントがNFSサーバーのユーザー名/パスワードペアを認証できる場合、およびNFSサーバーが認証されているユーザーが公開キー証明書を持っている場合、それは機能します。"
    },
    {
      "indent": 3,
      "text": "In situations where NFS client uses LIPKEY and uses a per-host principal for the SETCLIENTID operation, instead of using LIPKEY for SETCLIENTID, it is RECOMMENDED that SPKM-3 with mutual authentication be used. This effectively means that the client will use a certificate to authenticate and identify the initiator to the target on the NFS server. Using SPKM-3 and not LIPKEY has the following advantages:",
      "ja": "NFSクライアントがLipkeyを使用し、SetClientID操作にホストあたりのプリンシパルを使用する状況では、LipkeyをSetClientIDに使用する代わりに、相互認証を使用してSPKM-3を使用することをお勧めします。これは、事実上、クライアントが証明書を使用して、NFSサーバーのターゲットにイニシエーターを認証および識別することを意味します。LipkeyではなくSPKM-3を使用するには、次の利点があります。"
    },
    {
      "indent": 3,
      "text": "o When the server does a callback, it must authenticate to the principal used in the SETCLIENTID. Even if LIPKEY is used, because LIPKEY is layered over SPKM-3, the NFS client will need to have a certificate that corresponds to the principal used in the SETCLIENTID operation. From an administrative perspective, having a user name, password, and certificate for both the client and server is redundant.",
      "ja": "o サーバーがコールバックを実行する場合、SetClientIDで使用されるプリンシパルに認証する必要があります。LipkeyがSPKM-3上に階層化されているため、Lipkeyが使用されていても、NFSクライアントはSetClientID操作で使用されているプリンシパルに対応する証明書を持っている必要があります。管理上の観点から、クライアントとサーバーの両方のユーザー名、パスワード、および証明書を持つことは冗長です。"
    },
    {
      "indent": 3,
      "text": "o LIPKEY was intended to minimize additional infrastructure requirements beyond a certificate for the target, and the expectation is that existing password infrastructure can be leveraged for the initiator. In some environments, a per-host password does not exist yet. If certificates are used for any per-host principals, then additional password infrastructure is not needed.",
      "ja": "o Lipkeyは、ターゲットの証明書を超えた追加のインフラストラクチャ要件を最小限に抑えることを目的としており、既存のパスワードインフラストラクチャをイニシエーターに活用できることが期待されています。一部の環境では、ホストごとのパスワードはまだ存在しません。ホストごとのプリンシパルに証明書が使用されている場合、追加のパスワードインフラストラクチャは必要ありません。"
    },
    {
      "indent": 3,
      "text": "o In cases when a host is both an NFS client and server, it can share the same per-host certificate.",
      "ja": "o ホストがNFSクライアントとサーバーの両方である場合、同じホストあたりの証明書を共有できます。"
    },
    {
      "indent": 0,
      "text": "4. Filehandles",
      "section_title": true,
      "ja": "4. ファイルハンドル"
    },
    {
      "indent": 3,
      "text": "The filehandle in the NFS protocol is a per server unique identifier for a file system object. The contents of the filehandle are opaque to the client. Therefore, the server is responsible for translating the filehandle to an internal representation of the file system object. Since the filehandle is the client's reference to an object and the client may cache this reference, the server SHOULD not reuse a filehandle for another file system object. If the server needs to reuse a filehandle value, the time elapsed before reuse SHOULD be large enough such that it is unlikely the client has a cached copy of the reused filehandle value. Note that a client may cache a filehandle for a very long time. For example, a client may cache NFS data to local storage as a method to expand its effective cache size and as a means to survive client restarts. Therefore, the lifetime of a cached filehandle may be extended.",
      "ja": "NFSプロトコルのファイルハンドルは、ファイルシステムオブジェクトのサーバーごとの一意の識別子です。ファイルハンドルの内容は、クライアントに不透明です。したがって、サーバーは、ファイルハンドルをファイルシステムオブジェクトの内部表現に変換する責任があります。ファイルハンドルはオブジェクトへのクライアントの参照であり、クライアントはこの参照をキャッシュすることができるため、サーバーは別のファイルシステムオブジェクトのファイルハンドルを再利用しないでください。サーバーがファイルハンドル値を再利用する必要がある場合、クライアントが再利用されたファイルハンドル値のキャッシュされたコピーを持っている可能性が低いため、再利用前の時間が十分に大きくなるはずです。クライアントは非常に長い間ファイルハンドルをキャッシュすることができることに注意してください。たとえば、クライアントは、効果的なキャッシュサイズを拡張する方法として、またクライアントの再起動を生き残るための手段として、NFSデータをローカルストレージにキャッシュすることができます。したがって、キャッシュされたファイルハンドルの寿命を延長することができます。"
    },
    {
      "indent": 0,
      "text": "4.1. Obtaining the First Filehandle",
      "section_title": true,
      "ja": "4.1. 最初のファイルハンドルを取得します"
    },
    {
      "indent": 3,
      "text": "The operations of the NFS protocol are defined in terms of one or more filehandles. Therefore, the client needs a filehandle to initiate communication with the server. With the NFS version 2 protocol [RFC1094] and the NFS version 3 protocol [RFC1813], there exists an ancillary protocol to obtain this first filehandle. The MOUNT protocol, RPC program number 100005, provides the mechanism of translating a string based file system path name to a filehandle which can then be used by the NFS protocols.",
      "ja": "NFSプロトコルの操作は、1つ以上のファイルハンドルの観点から定義されます。したがって、クライアントはサーバーとの通信を開始するためにファイルハンドルを必要とします。NFSバージョン2プロトコル[RFC1094]およびNFSバージョン3プロトコル[RFC1813]を使用すると、この最初のファイルハンドルを取得するための補助プロトコルが存在します。マウントプロトコルであるRPCプログラム番号100005は、文字列ベースのファイルシステムパス名をファイルハンドルに変換するメカニズムを提供し、NFSプロトコルで使用できます。"
    },
    {
      "indent": 3,
      "text": "The MOUNT protocol has deficiencies in the area of security and use via firewalls. This is one reason that the use of the public filehandle was introduced in [RFC2054] and [RFC2055]. With the use of the public filehandle in combination with the LOOKUP procedure in the NFS version 2 and 3 protocols, it has been demonstrated that the MOUNT protocol is unnecessary for viable interaction between NFS client and server.",
      "ja": "マウントプロトコルには、ファイアウォールを介してセキュリティと使用の分野に欠陥があります。これが、[RFC2054]および[RFC2055]でパブリックファイルハンドルの使用が導入された理由の1つです。NFSバージョン2および3プロトコルのルックアップ手順と組み合わせてパブリックファイルハンドルを使用すると、NFSクライアントとサーバー間の実行可能な相互作用にマウントプロトコルが不要であることが実証されています。"
    },
    {
      "indent": 3,
      "text": "Therefore, the NFS version 4 protocol will not use an ancillary protocol for translation from string based path names to a filehandle. Two special filehandles will be used as starting points for the NFS client.",
      "ja": "したがって、NFSバージョン4プロトコルは、文字列ベースのパス名からファイルハンドルへの変換に補助プロトコルを使用しません。NFSクライアントの出発点として2つの特別なファイルハンドルが使用されます。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Root Filehandle",
      "section_title": true,
      "ja": "4.1.1. ルートファイルハンドル"
    },
    {
      "indent": 3,
      "text": "The first of the special filehandles is the ROOT filehandle. The ROOT filehandle is the \"conceptual\" root of the file system name space at the NFS server. The client uses or starts with the ROOT filehandle by employing the PUTROOTFH operation. The PUTROOTFH operation instructs the server to set the \"current\" filehandle to the ROOT of the server's file tree. Once this PUTROOTFH operation is used, the client can then traverse the entirety of the server's file tree with the LOOKUP procedure. A complete discussion of the server name space is in the section \"NFS Server Name Space\".",
      "ja": "特別なファイルハンドルの最初はルートファイルハンドルです。ルートファイルハンドルは、NFSサーバーのファイルシステム名スペースの「概念的」ルートです。クライアントは、putrootfh操作を使用して、ルートファイルハンドルを使用または開始します。Putrootfh操作は、サーバーに「現在」のファイルハンドルをサーバーのファイルツリーのルートに設定するように指示します。このputrootfh操作が使用されると、クライアントはルックアップ手順でサーバーのファイルツリー全体を通過できます。サーバー名スペースの完全な説明は、セクション「NFSサーバー名スペース」にあります。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Public Filehandle",
      "section_title": true,
      "ja": "4.1.2. パブリックファイルハンドル"
    },
    {
      "indent": 3,
      "text": "The second special filehandle is the PUBLIC filehandle. Unlike the ROOT filehandle, the PUBLIC filehandle may be bound or represent an arbitrary file system object at the server. The server is responsible for this binding. It may be that the PUBLIC filehandle and the ROOT filehandle refer to the same file system object. However, it is up to the administrative software at the server and the policies of the server administrator to define the binding of the PUBLIC filehandle and server file system object. The client may not make any assumptions about this binding.",
      "ja": "2番目の特別なファイルハンドルは、パブリックファイルハンドルです。ルートファイルハンドルとは異なり、パブリックファイルハンドルは、サーバーの任意のファイルシステムオブジェクトをバインドまたは表すことができます。サーバーはこのバインディングの責任を負います。パブリックファイルハンドルとルートファイルハンドルが同じファイルシステムオブジェクトを参照する可能性があります。ただし、パブリックファイルハンドルとサーバーファイルシステムオブジェクトのバインディングを定義するのは、サーバーの管理ソフトウェアとサーバー管理者のポリシー次第です。クライアントは、このバインディングについて仮定することはできません。"
    },
    {
      "indent": 0,
      "text": "4.2. Filehandle Types",
      "section_title": true,
      "ja": "4.2. ファイルハンドルタイプ"
    },
    {
      "indent": 3,
      "text": "In the NFS version 2 and 3 protocols, there was one type of filehandle with a single set of semantics. The NFS version 4 protocol introduces a new type of filehandle in an attempt to accommodate certain server environments. The first type of filehandle is 'persistent'. The semantics of a persistent filehandle are the same as the filehandles of the NFS version 2 and 3 protocols. The second or new type of filehandle is the \"volatile\" filehandle.",
      "ja": "NFSバージョン2および3プロトコルでは、1つのタイプのファイルハンドルがあり、セマンティクスのセットが1つありました。NFSバージョン4プロトコルは、特定のサーバー環境に対応するために、新しいタイプのファイルハンドルを導入します。ファイルハンドルの最初のタイプは「永続的」です。永続的なファイルハンドルのセマンティクスは、NFSバージョン2および3プロトコルのファイルハンドルと同じです。2番目または新しいタイプのファイルハンドルは、「揮発性」ファイルハンドルです。"
    },
    {
      "indent": 3,
      "text": "The volatile filehandle type is being introduced to address server functionality or implementation issues which make correct implementation of a persistent filehandle infeasible. Some server environments do not provide a file system level invariant that can be used to construct a persistent filehandle. The underlying server file system may not provide the invariant or the server's file system programming interfaces may not provide access to the needed invariant. Volatile filehandles may ease the implementation of server functionality such as hierarchical storage management or file system reorganization or migration. However, the volatile filehandle increases the implementation burden for the client. However this increased burden is deemed acceptable based on the overall gains achieved by the protocol.",
      "ja": "揮発性のファイルハンドルタイプが導入されており、サーバー機能または実装の問題に対処し、永続的なファイルハンドルの正しい実装を実行できます。一部のサーバー環境では、永続的なファイルハンドルの構築に使用できるファイルシステムレベルの不変を提供しません。基礎となるサーバーファイルシステムは、Invariantまたはサーバーのファイルシステムプログラミングインターフェイスを提供しない場合があります。揮発性ファイルハンドルは、階層ストレージ管理やファイルシステムの再編成や移行などのサーバー機能の実装を容易にする場合があります。ただし、不安定なファイルハンドルは、クライアントの実装負担を増加させます。しかし、この増加した負担は、プロトコルによって達成された全体的な利益に基づいて許容されると見なされます。"
    },
    {
      "indent": 3,
      "text": "Since the client will need to handle persistent and volatile filehandle differently, a file attribute is defined which may be used by the client to determine the filehandle types being returned by the server.",
      "ja": "クライアントは、永続的で揮発性のファイルハンドルを異なる方法で処理する必要があるため、ファイル属性が定義されています。これは、サーバーが返しているファイルハンドルタイプを決定するためにクライアントが使用できます。"
    },
    {
      "indent": 0,
      "text": "4.2.1. General Properties of a Filehandle",
      "section_title": true,
      "ja": "4.2.1. ファイルハンドルの一般的なプロパティ"
    },
    {
      "indent": 3,
      "text": "The filehandle contains all the information the server needs to distinguish an individual file. To the client, the filehandle is opaque. The client stores filehandles for use in a later request and can compare two filehandles from the same server for equality by doing a byte-by-byte comparison. However, the client MUST NOT otherwise interpret the contents of filehandles. If two filehandles from the same server are equal, they MUST refer to the same file. If they are not equal, the client may use information provided by the server, in the form of file attributes, to determine whether they denote the same files or different files. The client would do this as necessary for client side caching. Servers SHOULD try to maintain a one-to-one correspondence between filehandles and files but this is not required. Clients MUST use filehandle comparisons only to improve performance, not for correct behavior. All clients need to be prepared for situations in which it cannot be determined whether two filehandles denote the same object and in such cases, avoid making invalid assumptions which might cause incorrect behavior.",
      "ja": "ファイルハンドルには、サーバーが個々のファイルを区別するために必要なすべての情報が含まれています。クライアントにとって、ファイルハンドルは不透明です。クライアントは、後のリクエストで使用するためにファイルハンドルを保存し、バイトごとの比較を行うことにより、同じサーバーの2つのファイルハンドルを平等のために比較できます。ただし、それ以外の場合は、クライアントがファイルハンドルの内容を解釈してはなりません。同じサーバーの2つのファイルハンドルが等しい場合、同じファイルを参照する必要があります。それらが等しくない場合、クライアントは、ファイル属性の形式でサーバーから提供される情報を使用して、同じファイルまたは異なるファイルを示すかどうかを判断することができます。クライアントは、クライアント側のキャッシュに必要に応じてこれを行います。サーバーは、ファイルハンドルとファイルの間に1対1の対応を維持しようとする必要がありますが、これは必須ではありません。クライアントは、正しい動作のためではなく、パフォーマンスを改善するためにのみファイルハンドル比較を使用する必要があります。すべてのクライアントは、2つのファイルハンドルが同じオブジェクトを示しているかどうかを判断できない状況に備えて準備する必要があります。"
    },
    {
      "indent": 3,
      "text": "Further discussion of filehandle and attribute comparison in the context of data caching is presented in the section \"Data Caching and File Identity\".",
      "ja": "データキャッシュのコンテキストでのファイルハンドルと属性の比較のさらなる議論は、セクション「データキャッシュとファイルID」セクションに示されています。"
    },
    {
      "indent": 3,
      "text": "As an example, in the case that two different path names when traversed at the server terminate at the same file system object, the server SHOULD return the same filehandle for each path. This can occur if a hard link is used to create two file names which refer to the same underlying file object and associated data. For example, if paths /a/b/c and /a/d/c refer to the same file, the server SHOULD return the same filehandle for both path names traversals.",
      "ja": "例として、サーバーでトラバースしたときに2つの異なるパス名が同じファイルシステムオブジェクトで終了する場合、サーバーは各パスに対して同じファイルハンドルを返す必要があります。これは、ハードリンクを使用して、同じ基礎となるファイルオブジェクトと関連するデータを参照する2つのファイル名を作成する場合に発生する可能性があります。たとえば、Paths/a/b/cおよび/a/d/cの場合、同じファイルを参照する場合、サーバーは両方のPATH名のトラバーサルに対して同じファイルハンドルを返す必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Persistent Filehandle",
      "section_title": true,
      "ja": "4.2.2. 永続的なファイルハンドル"
    },
    {
      "indent": 3,
      "text": "A persistent filehandle is defined as having a fixed value for the lifetime of the file system object to which it refers. Once the server creates the filehandle for a file system object, the server MUST accept the same filehandle for the object for the lifetime of the object. If the server restarts or reboots the NFS server must honor the same filehandle value as it did in the server's previous instantiation. Similarly, if the file system is migrated, the new NFS server must honor the same file handle as the old NFS server.",
      "ja": "永続的なファイルハンドルは、それが参照するファイルシステムオブジェクトの寿命に固定値を持つと定義されます。サーバーがファイルシステムオブジェクトのファイルハンドルを作成すると、サーバーはオブジェクトの寿命のためにオブジェクトに対して同じファイルハンドルを受け入れる必要があります。サーバーが再起動または再起動する場合、NFSサーバーは、サーバーの以前のインスタンス化と同じファイルハンドル値を尊重する必要があります。同様に、ファイルシステムが移行された場合、新しいNFSサーバーは古いNFSサーバーと同じファイルハンドルを尊重する必要があります。"
    },
    {
      "indent": 3,
      "text": "The persistent filehandle will be become stale or invalid when the file system object is removed. When the server is presented with a persistent filehandle that refers to a deleted object, it MUST return an error of NFS4ERR_STALE. A filehandle may become stale when the file system containing the object is no longer available. The file system may become unavailable if it exists on removable media and the media is no longer available at the server or the file system in whole has been destroyed or the file system has simply been removed from the server's name space (i.e. unmounted in a Unix environment).",
      "ja": "ファイルシステムオブジェクトが削除されると、永続的なファイルハンドルが古くなったり無効になります。サーバーが削除されたオブジェクトを参照する永続的なファイルハンドルで表示される場合、nfs4err_staleのエラーを返す必要があります。オブジェクトを含むファイルシステムが使用できなくなると、ファイルハンドルが古くなる場合があります。ファイルシステムが取り外し可能なメディアに存在し、メディアがサーバーで使用できなくなった場合、またはファイルシステム全体が破壊されている場合や、ファイルシステムがサーバーの名前スペースから削除された場合（つまり、UNIXでマウントされていません。環境）。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Volatile Filehandle",
      "section_title": true,
      "ja": "4.2.3. 揮発性ファイルハンドル"
    },
    {
      "indent": 3,
      "text": "A volatile filehandle does not share the same longevity characteristics of a persistent filehandle. The server may determine that a volatile filehandle is no longer valid at many different points in time. If the server can definitively determine that a volatile filehandle refers to an object that has been removed, the server should return NFS4ERR_STALE to the client (as is the case for persistent filehandles). In all other cases where the server determines that a volatile filehandle can no longer be used, it should return an error of NFS4ERR_FHEXPIRED.",
      "ja": "揮発性ファイルハンドルは、永続的なファイルハンドルの同じ長寿特性を共有しません。サーバーは、揮発性のファイルハンドルが多くの異なる時点でもはや有効ではないことを判断する場合があります。サーバーが揮発性ファイルハンドルが削除されたオブジェクトを参照することを明確に判断できる場合、サーバーはnfs4err_staleをクライアントに返す必要があります（永続的なファイルハンドルの場合と同様）。サーバーが揮発性ファイルハンドルを使用できなくなったと判断した他のすべての場合、nfs4err_fhexpiredのエラーを返すはずです。"
    },
    {
      "indent": 3,
      "text": "The mandatory attribute \"fh_expire_type\" is used by the client to determine what type of filehandle the server is providing for a particular file system. This attribute is a bitmask with the following values:",
      "ja": "必須属性「FH_EXPIRE_TYPE」は、クライアントが特定のファイルシステムにサーバーが提供しているファイルハンドルのタイプを決定するために使用されます。この属性は、次の値でビットマスクです。"
    },
    {
      "indent": 3,
      "text": "FH4_PERSISTENT The value of FH4_PERSISTENT is used to indicate a persistent filehandle, which is valid until the object is removed from the file system. The server will not return NFS4ERR_FHEXPIRED for this filehandle. FH4_PERSISTENT is defined as a value in which none of the bits specified below are set.",
      "ja": "FH4_PERSISTENT FH4_PERSISTENTの値は、オブジェクトがファイルシステムから削除されるまで有効な永続的なファイルハンドルを示すために使用されます。サーバーは、このファイルハンドルのためにnfs4err_fhexpiredを返しません。FH4_PERSISTENTは、以下に指定されたビットが設定されていない値として定義されます。"
    },
    {
      "indent": 3,
      "text": "FH4_NOEXPIRE_WITH_OPEN The filehandle will not expire while client has the file open. If this bit is set, then the values FH4_VOLATILE_ANY or FH4_VOL_RENAME do not impact expiration while the file is open. Once the file is closed or if the FH4_NOEXPIRE_WITH_OPEN bit is false, the rest of the volatile related bits apply.",
      "ja": "fh4_noexpire_with_open filehandleは、クライアントにファイルが開いている間は期限切れになりません。このビットが設定されている場合、値FH4_VOLATILE_ANYまたはFH4_VOL_RENAMEは、ファイルが開いている間に有効期限に影響を与えません。ファイルが閉じられた場合、またはFH4_NOEXPIRE_WITH_OPENビットがfalseの場合、揮発性関連ビットの残りの部分が適用されます。"
    },
    {
      "indent": 3,
      "text": "FH4_VOLATILE_ANY The filehandle may expire at any time and will expire during system migration and rename.",
      "ja": "FH4_VOLATILE_ANY FILEHANDLEはいつでも期限切れになる場合があり、システムの移行と名前変更中に期限切れになります。"
    },
    {
      "indent": 3,
      "text": "FH4_VOL_MIGRATION The filehandle will expire during file system migration. May only be set if FH4_VOLATILE_ANY is not set.",
      "ja": "fh4_vol_migrationファイルハンドルは、ファイルシステムの移行中に期限切れになります。FH4_VOLATILE_ANYが設定されていない場合にのみ設定できます。"
    },
    {
      "indent": 3,
      "text": "FH4_VOL_RENAME The filehandle may expire due to a rename. This includes a rename by the requesting client or a rename by another client. May only be set if FH4_VOLATILE_ANY is not set.",
      "ja": "fh4_vol_rename filehandleは、名前が変更されているために期限切れになる場合があります。これには、リクエストクライアントによる名前の変更または別のクライアントによる名前の変更が含まれます。FH4_VOLATILE_ANYが設定されていない場合にのみ設定できます。"
    },
    {
      "indent": 3,
      "text": "Servers which provide volatile filehandles should deny a RENAME or REMOVE that would affect an OPEN file or any of the components leading to the OPEN file. In addition, the server should deny all RENAME or REMOVE requests during the grace or lease period upon server restart.",
      "ja": "揮発性ファイルハンドルを提供するサーバーは、オープンファイルまたは開いたファイルにつながるコンポーネントに影響する名前の変更または削除を拒否する必要があります。さらに、サーバーは、サーバーの再起動時に、GRACEまたはリース期間中にすべての変更を拒否または削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "The reader may be wondering why there are three FH4_VOL* bits and why FH4_VOLATILE_ANY is exclusive of FH4_VOL_MIGRATION and FH4_VOL_RENAME. If the a filehandle is normally persistent but cannot persist across a file set migration, then the presence of the FH4_VOL_MIGRATION or FH4_VOL_RENAME tells the client that it can treat the file handle as persistent for purposes of maintaining a file name to file handle cache, except for the specific event described by the bit. However, FH4_VOLATILE_ANY tells the client that it should not maintain such a cache for unopened files. A server MUST not present FH4_VOLATILE_ANY with FH4_VOL_MIGRATION or FH4_VOL_RENAME as this will lead to confusion. FH4_VOLATILE_ANY implies that the file handle will expire upon migration or rename, in addition to other events.",
      "ja": "読者は、なぜ3つのFH4_VOL*ビットがあるのか、なぜFH4_VOLATILE_ANYがFH4_VOL_MIGRATIONとFH4_VOL_RENAMEを除外しているのか疑問に思っているかもしれません。ファイルハンドルが通常永続的であるが、ファイルセットの移行全体で持続できない場合、FH4_VOL_MIGRATIONまたはFH4_VOL_RENAMEの存在は、ファイル名を維持するためにファイル名を維持する目的でファイルハンドルを保持することができることをクライアントに指示します。ビットで説明されている特定のイベント。ただし、FH4_VOLATILE_ANYは、オープンしていないファイルに対してこのようなキャッシュを維持してはならないことをクライアントに伝えます。サーバーは、FH4_VOL_MIGRATIONまたはFH4_VOL_RENAMEを使用してFH4_Volatile_Anyを提示してはなりません。これは混乱につながるためです。FH4_VOLATILE_ANYは、他のイベントに加えて、ファイルハンドルが移行または変更時に期限切れになることを意味します。"
    },
    {
      "indent": 0,
      "text": "4.2.4. One Method of Constructing a Volatile Filehandle",
      "section_title": true,
      "ja": "4.2.4. 揮発性ファイルハンドルを構築する1つの方法"
    },
    {
      "indent": 3,
      "text": "As mentioned, in some instances a filehandle is stale (no longer valid; perhaps because the file was removed from the server) or it is expired (the underlying file is valid but since the filehandle is volatile, it may have expired). Thus the server needs to be able to return NFS4ERR_STALE in the former case and NFS4ERR_FHEXPIRED in the latter case. This can be done by careful construction of the volatile filehandle. One possible implementation follows.",
      "ja": "前述のように、場合によっては、ファイルハンドルが古くなっています（もはや有効ではありません。おそらくファイルがサーバーから削除されたためです）、または有効期限が切れます（基礎となるファイルは有効ですが、ファイルハンドルは揮発性であるため、有効期限が切れている可能性があります）。したがって、サーバーは、前者の場合にnfs4err_staleを返すことができ、後者の場合はnfs4err_fhexppiredが必要です。これは、揮発性ファイルハンドルを慎重に構築することで実行できます。1つの可能な実装が続きます。"
    },
    {
      "indent": 3,
      "text": "A volatile filehandle, while opaque to the client could contain:",
      "ja": "揮発性のファイルハンドル、クライアントに不透明なことを含めることができます。"
    },
    {
      "indent": 3,
      "text": "[volatile bit = 1 | server boot time | slot | generation number]",
      "ja": "[揮発性ビット= 1 |サーバーブート時間|スロット|生成番号]"
    },
    {
      "indent": 3,
      "text": "o slot is an index in the server volatile filehandle table",
      "ja": "o スロットはサーバーの揮発性ファイルハンドルテーブルのインデックスです"
    },
    {
      "indent": 3,
      "text": "o generation number is the generation number for the table entry/slot",
      "ja": "o 生成番号は、テーブルエントリ/スロットの生成番号です"
    },
    {
      "indent": 3,
      "text": "If the server boot time is less than the current server boot time, return NFS4ERR_FHEXPIRED. If slot is out of range, return NFS4ERR_BADHANDLE. If the generation number does not match, return NFS4ERR_FHEXPIRED.",
      "ja": "サーバーの起動時間が現在のサーバーの起動時間よりも短い場合は、nfs4err_fhexppiredを返します。スロットが範囲外の場合は、nfs4err_badhandleを返します。生成番号が一致しない場合は、nfs4err_fhexppiredを返します。"
    },
    {
      "indent": 3,
      "text": "When the server reboots, the table is gone (it is volatile).",
      "ja": "サーバーが再起動すると、テーブルがなくなっています（揮発性）。"
    },
    {
      "indent": 3,
      "text": "If volatile bit is 0, then it is a persistent filehandle with a different structure following it.",
      "ja": "揮発性ビットが0の場合、それはそれに続く異なる構造を持つ永続的なファイルハンドルです。"
    },
    {
      "indent": 0,
      "text": "4.3. Client Recovery from Filehandle Expiration",
      "section_title": true,
      "ja": "4.3. FileHandleの有効期限からのクライアントの回復"
    },
    {
      "indent": 3,
      "text": "If possible, the client SHOULD recover from the receipt of an NFS4ERR_FHEXPIRED error. The client must take on additional responsibility so that it may prepare itself to recover from the expiration of a volatile filehandle. If the server returns persistent filehandles, the client does not need these additional steps.",
      "ja": "可能であれば、クライアントはnfs4err_fhexpiredエラーの受領から回復する必要があります。クライアントは、揮発性のファイルハンドルの有効期限から回復する準備をするために、追加の責任を負う必要があります。サーバーが永続的なファイルハンドルを返している場合、クライアントはこれらの追加の手順を必要としません。"
    },
    {
      "indent": 3,
      "text": "For volatile filehandles, most commonly the client will need to store the component names leading up to and including the file system object in question. With these names, the client should be able to recover by finding a filehandle in the name space that is still available or by starting at the root of the server's file system name space.",
      "ja": "揮発性のファイルハンドルの場合、最も一般的には、クライアントは、問題のファイルシステムオブジェクトに至るまでのコンポーネント名を保存する必要があります。これらの名前を使用すると、クライアントは、まだ利用可能な名前空間でファイルハンドルを見つけるか、サーバーのファイルシステム名スペースのルートから開始することにより、回復できる必要があります。"
    },
    {
      "indent": 3,
      "text": "If the expired filehandle refers to an object that has been removed from the file system, obviously the client will not be able to recover from the expired filehandle.",
      "ja": "期限切れのファイルハンドルがファイルシステムから削除されたオブジェクトを指す場合、明らかにクライアントは期限切れのファイルハンドルから回復できません。"
    },
    {
      "indent": 3,
      "text": "It is also possible that the expired filehandle refers to a file that has been renamed. If the file was renamed by another client, again it is possible that the original client will not be able to recover. However, in the case that the client itself is renaming the file and the file is open, it is possible that the client may be able to recover. The client can determine the new path name based on the processing of the rename request. The client can then regenerate the new filehandle based on the new path name. The client could also use the compound operation mechanism to construct a set of operations like:",
      "ja": "有効期限切れのファイルハンドルが名前が変更されたファイルを指す可能性もあります。ファイルが別のクライアントによって名前が変更された場合、元のクライアントが回復できない可能性があります。ただし、クライアント自体がファイルの名前を変更し、ファイルが開いている場合、クライアントが回復できる可能性があります。クライアントは、名前のリクエストの処理に基づいて新しいパス名を決定できます。クライアントは、新しいパス名に基づいて新しいファイルハンドルを再生できます。クライアントは、複合操作メカニズムを使用して、次のような一連の操作を構築することもできます。"
    },
    {
      "indent": 12,
      "text": "RENAME A B LOOKUP B GETFH",
      "ja": "B lookup b getfhの名前を変更します"
    },
    {
      "indent": 0,
      "text": "5. File Attributes",
      "section_title": true,
      "ja": "5. ファイル属性"
    },
    {
      "indent": 3,
      "text": "To meet the requirements of extensibility and increased interoperability with non-Unix platforms, attributes must be handled in a flexible manner. The NFS Version 3 fattr3 structure contains a fixed list of attributes that not all clients and servers are able to support or care about. The fattr3 structure can not be extended as new needs arise and it provides no way to indicate non-support. With the NFS Version 4 protocol, the client will be able to ask what attributes the server supports and will be able to request only those attributes in which it is interested.",
      "ja": "非UNIXプラットフォームとの拡張性と相互運用性の向上の要件を満たすには、属性を柔軟な方法で処理する必要があります。NFSバージョン3 FATTR3構造には、すべてのクライアントとサーバーがサポートまたはケアできるとは限らない属性の固定リストが含まれています。FATTR3構造は、新しいニーズが生じるため、拡張できません。非サポートを示す方法は提供されません。NFSバージョン4プロトコルを使用すると、クライアントはサーバーがサポートする属性を尋ねることができ、関心のある属性のみを要求できます。"
    },
    {
      "indent": 3,
      "text": "To this end, attributes will be divided into three groups: mandatory, recommended, and named. Both mandatory and recommended attributes are supported in the NFS version 4 protocol by a specific and well-defined encoding and are identified by number. They are requested by setting a bit in the bit vector sent in the GETATTR request; the server response includes a bit vector to list what attributes were returned in the response. New mandatory or recommended attributes may be added to the NFS protocol between major revisions by publishing a standards-track RFC which allocates a new attribute number value and defines the encoding for the attribute. See the section \"Minor Versioning\" for further discussion.",
      "ja": "この目的のために、属性は、必須、推奨、名前の3つのグループに分けられます。必須属性と推奨属性の両方が、特定の明確に定義されたエンコードによってNFSバージョン4プロトコルでサポートされ、数で識別されます。それらは、getattrリクエストで送信されたビットベクトルに少し設定することで要求されます。サーバーの応答には、応答で返された属性をリストするためのビットベクトルが含まれています。新しい属性番号値を割り当て、属性のエンコーディングを定義する標準トラックRFCを公開することにより、新しい必須または推奨属性をNFSプロトコル間に追加することができます。詳細については、セクション「マイナーバージョン」を参照してください。"
    },
    {
      "indent": 3,
      "text": "Named attributes are accessed by the new OPENATTR operation, which accesses a hidden directory of attributes associated with a file system object. OPENATTR takes a filehandle for the object and returns the filehandle for the attribute hierarchy. The filehandle for the named attributes is a directory object accessible by LOOKUP or READDIR and contains files whose names represent the named attributes and whose data bytes are the value of the attribute. For example:",
      "ja": "名前の属性は、ファイルシステムオブジェクトに関連付けられた属性の非表示ディレクトリにアクセスする新しいOpenATTR操作によってアクセスされます。OpenATTRは、オブジェクトのファイルハンドルを取得し、属性階層のファイルハンドルを返します。名前付き属性のファイルハンドルは、ルックアップまたはReadDirでアクセスできるディレクトリオブジェクトであり、名前が指定された属性を表し、データバイトが属性の値であるファイルが含まれています。例えば："
    },
    {
      "indent": 9,
      "text": "LOOKUP \"foo\" ; look up file GETATTR attrbits OPENATTR ; access foo's named attributes LOOKUP \"x11icon\" ; look up specific attribute READ 0,4096 ; read stream of bytes",
      "ja": "ルックアップ \"foo\";ファイルgetattr aTtrbits openAttrを検索します。fooの名前付き属性をlookup \"x11icon\"にアクセスします。特定の属性を調べてください0,4096を読み取ります。バイトのストリームを読み取ります"
    },
    {
      "indent": 3,
      "text": "Named attributes are intended for data needed by applications rather than by an NFS client implementation. NFS implementors are strongly encouraged to define their new attributes as recommended attributes by bringing them to the IETF standards-track process.",
      "ja": "名前付き属性は、NFSクライアントの実装ではなく、アプリケーションで必要なデータを目的としています。NFS実装者は、IETF標準トラックプロセスにそれらを持ち込むことにより、推奨属性として新しい属性を定義することを強くお勧めします。"
    },
    {
      "indent": 3,
      "text": "The set of attributes which are classified as mandatory is deliberately small since servers must do whatever it takes to support them. The recommended attributes may be unsupported; though a server should support as many as it can. Attributes are deemed mandatory if the data is both needed by a large number of clients and is not otherwise reasonably computable by the client when support is not provided on the server.",
      "ja": "サーバーがそれらをサポートするために必要なことは何でもしなければならないため、必須として分類される一連の属性は意図的に小さいです。推奨される属性はサポートされていない場合があります。サーバーはできるだけ多くサポートする必要があります。属性は、データが両方とも多数のクライアントに必要であり、サーバーでサポートが提供されていない場合にクライアントが合理的に計算できない場合、必須とみなされます。"
    },
    {
      "indent": 0,
      "text": "5.1. Mandatory Attributes",
      "section_title": true,
      "ja": "5.1. 必須属性"
    },
    {
      "indent": 3,
      "text": "These MUST be supported by every NFS Version 4 client and server in order to ensure a minimum level of interoperability. The server must store and return these attributes and the client must be able to function with an attribute set limited to these attributes. With just the mandatory attributes some client functionality may be impaired or limited in some ways. A client may ask for any of these attributes to be returned by setting a bit in the GETATTR request and the server must return their value.",
      "ja": "これらは、最小レベルの相互運用性を確保するために、すべてのNFSバージョン4クライアントとサーバーによってサポートする必要があります。サーバーはこれらの属性を保存して返す必要があり、クライアントはこれらの属性に限定された属性セットで機能できる必要があります。必須の属性だけで、一部のクライアント機能はいくつかの点で損なわれたり制限されたりする可能性があります。クライアントは、GetATTRリクエストに少し設定することにより、これらの属性のいずれかを返すように要求する場合があり、サーバーはその値を返す必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2. Recommended Attributes",
      "section_title": true,
      "ja": "5.2. 推奨属性"
    },
    {
      "indent": 3,
      "text": "These attributes are understood well enough to warrant support in the NFS Version 4 protocol. However, they may not be supported on all clients and servers. A client may ask for any of these attributes to be returned by setting a bit in the GETATTR request but must handle the case where the server does not return them. A client may ask for the set of attributes the server supports and should not request attributes the server does not support. A server should be tolerant of requests for unsupported attributes and simply not return them rather than considering the request an error. It is expected that servers will support all attributes they comfortably can and only fail to support attributes which are difficult to support in their operating environments. A server should provide attributes whenever they don't have to \"tell lies\" to the client. For example, a file modification time should be either an accurate time or should not be supported by the server. This will not always be comfortable to clients but it seems that the client has a better ability to fabricate or construct an attribute or do without the attribute.",
      "ja": "これらの属性は、NFSバージョン4プロトコルでのサポートを保証するのに十分なほど理解されています。ただし、すべてのクライアントとサーバーでサポートされていない場合があります。クライアントは、GetATTRリクエストに少し設定することにより、これらの属性のいずれかを返すように要求する場合がありますが、サーバーがそれらを返さない場合を処理する必要があります。クライアントは、サーバーがサポートする属性のセットを要求する場合があり、サーバーがサポートしていない属性を要求してはなりません。サーバーは、サポートされていない属性の要求に耐性があり、リクエストをエラーと見なすのではなく、単に返品しないでください。サーバーは、快適にできるすべての属性をサポートし、動作環境でサポートするのが難しい属性のみをサポートできないことが期待されています。サーバーは、クライアントに「嘘をつく」必要がないときはいつでも属性を提供する必要があります。たとえば、ファイルの変更時間は正確な時間であるか、サーバーによってサポートされてはなりません。これは常にクライアントにとって快適であるとは限りませんが、クライアントは属性を製造または構築したり、属性なしで行う能力を持っているようです。"
    },
    {
      "indent": 0,
      "text": "5.3. Named Attributes",
      "section_title": true,
      "ja": "5.3. 名前付き属性"
    },
    {
      "indent": 3,
      "text": "These attributes are not supported by direct encoding in the NFS Version 4 protocol but are accessed by string names rather than numbers and correspond to an uninterpreted stream of bytes which are stored with the file system object. The name space for these attributes may be accessed by using the OPENATTR operation. The OPENATTR operation returns a filehandle for a virtual \"attribute directory\" and further perusal of the name space may be done using READDIR and LOOKUP operations on this filehandle. Named attributes may then be examined or changed by normal READ and WRITE and CREATE operations on the filehandles returned from READDIR and LOOKUP. Named attributes may have attributes.",
      "ja": "これらの属性は、NFSバージョン4プロトコルでの直接エンコードではサポートされていませんが、数字ではなく文字列名でアクセスされ、ファイルシステムオブジェクトに保存されている解釈されていないバイトのストリームに対応します。これらの属性の名前スペースには、OpenATTR操作を使用してアクセスできます。OpenATTR操作は、仮想「属性ディレクトリ」のファイルハンドルを返し、このファイルハンドルのReadDirおよびLookup操作を使用して名前スペースのさらなる閲覧を行うことができます。その後、名前付き属性は、通常の読み取りと書き込みによって検査または変更され、ReadDirおよびLookupから返されたファイルハンドルの操作を作成できます。名前の属性には属性がある場合があります。"
    },
    {
      "indent": 3,
      "text": "It is recommended that servers support arbitrary named attributes. A client should not depend on the ability to store any named attributes in the server's file system. If a server does support named attributes, a client which is also able to handle them should be able to copy a file's data and meta-data with complete transparency from one location to another; this would imply that names allowed for regular directory entries are valid for named attribute names as well.",
      "ja": "サーバーは、任意の名前の属性をサポートすることをお勧めします。クライアントは、サーバーのファイルシステムに名前付き属性を保存する機能に依存してはなりません。サーバーが名前の属性をサポートしている場合、それらを処理できるクライアントは、ある場所から別の場所への完全な透明性でファイルのデータとメタデータをコピーできる必要があります。これは、通常のディレクトリエントリに許可されている名前が属性名も有効であることを意味します。"
    },
    {
      "indent": 3,
      "text": "Names of attributes will not be controlled by this document or other IETF standards track documents. See the section \"IANA Considerations\" for further discussion.",
      "ja": "属性の名前は、このドキュメントまたはその他のIETF標準がドキュメントを追跡することによって制御されません。詳細については、セクション「IANAの考慮事項」を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.4. Mandatory Attributes - Definitions",
      "section_title": true,
      "ja": "5.4. 必須属性 - 定義"
    },
    {
      "indent": 3,
      "text": "Name              #    DataType     Access   Description\n___________________________________________________________________\nsupp_attr         0    bitmap       READ     The bit vector which\n                                             would retrieve all\n                                             mandatory and\n                                             recommended attributes\n                                             that are supported for\n                                             this object.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "type 1 nfs4_ftype READ The type of the object (file, directory, symlink)",
      "ja": "タイプ1 nfs4_ftypeオブジェクトのタイプを読み取ります（ファイル、ディレクトリ、symlink）"
    },
    {
      "indent": 3,
      "text": "fh_expire_type 2 uint32 READ Server uses this to specify filehandle expiration behavior to the client. See the section \"Filehandles\" for additional description.",
      "ja": "FH_EXPIRE_TYPE 2 UINT32読み取りサーバーはこれを使用して、クライアントにファイルハンドルの有効期限動作を指定します。 追加の説明については、セクション「FileHandles」を参照してください。"
    },
    {
      "indent": 3,
      "text": "change 3 uint64 READ A value created by the server that the client can use to determine if file data, directory contents or attributes of the object have been modified. The server may return the object's time_modify attribute for this attribute's value but only if the file system object can not be updated more frequently than the resolution of time_modify.",
      "ja": "変更3 UINT64は、クライアントがファイルデータ、ディレクトリコンテンツ、またはオブジェクトの属性が変更されているかどうかを判断するために使用できるサーバーによって作成された値を読み取ります。サーバーは、この属性の値に対してオブジェクトのtime_modify属性を返す場合がありますが、ファイルシステムオブジェクトをtime_modifyの解像度よりも頻繁に更新できない場合のみです。"
    },
    {
      "indent": 3,
      "text": "size 4 uint64 R/W The size of the object in bytes.",
      "ja": "サイズ4 UINT64 R/Wバイト単位のオブジェクトのサイズ。"
    },
    {
      "indent": 3,
      "text": "link_support 5 boolean READ Does the object's file system supports hard links?",
      "ja": "link_support 5 boolean readオブジェクトのファイルシステムはハードリンクをサポートしていますか？"
    },
    {
      "indent": 3,
      "text": "symlink_support 6 boolean READ Does the object's file system supports symbolic links?",
      "ja": "symlink_support 6 boolean readオブジェクトのファイルシステムはシンボリックリンクをサポートしていますか？"
    },
    {
      "indent": 3,
      "text": "named_attr 7 boolean READ Does this object have named attributes?",
      "ja": "named_attr 7 boolean readこのオブジェクトには名前の属性がありますか？"
    },
    {
      "indent": 3,
      "text": "fsid 8 fsid4 READ Unique file system identifier for the file system holding this object. fsid contains major and minor components each of which are uint64.",
      "ja": "FSID 8 FSID4このオブジェクトを保持しているファイルシステムの一意のファイルシステム識別子を読み取ります。FSIDには、それぞれがUINT64である主要コンポーネントとマイナーコンポーネントが含まれています。"
    },
    {
      "indent": 3,
      "text": "unique_handles 9 boolean READ Are two distinct filehandles guaranteed to refer to two different file system objects?",
      "ja": "inquire_handles 9 boolean read 2つの異なるファイルシステムオブジェクトを参照することが保証されている2つの異なるファイルハンドルはありますか？"
    },
    {
      "indent": 3,
      "text": "lease_time 10 nfs_lease4 READ Duration of leases at server in seconds.",
      "ja": "lease_time 10 nfs_lease4数秒でサーバーでリースの期間を読み取ります。"
    },
    {
      "indent": 3,
      "text": "rdattr_error 11 enum READ Error returned from getattr during readdir.",
      "ja": "RDATTR_ERROR 11 ENUM READDIR中にGetATTRから返されたエラーの読み取りエラー。"
    },
    {
      "indent": 0,
      "text": "5.5. Recommended Attributes - Definitions",
      "section_title": true,
      "ja": "5.5. 推奨属性 - 定義"
    },
    {
      "indent": 3,
      "text": "Name               #    Data Type      Access   Description\n_____________________________________________________________________\nACL                12   nfsace4<>      R/W      The access control\n                                                list for the object.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "aclsupport 13 uint32 READ Indicates what types of ACLs are supported on the current file system.",
      "ja": "ACLSUPPORT 13 UINT32読み取り現在のファイルシステムでどのタイプのACLがサポートされているかを示します。"
    },
    {
      "indent": 3,
      "text": "archive 14 boolean R/W Whether or not this file has been archived since the time of last modification (deprecated in favor of time_backup).",
      "ja": "アーカイブ14ブールr/wこのファイルが最後の変更の時代からアーカイブされているかどうか（time_backupを支持して非推奨）。"
    },
    {
      "indent": 3,
      "text": "cansettime 15 boolean READ Is the server able to change the times for a file system object as specified in a SETATTR operation?",
      "ja": "cansettime 15 boolean readサーバーは、setattr操作で指定されているファイルシステムオブジェクトの時間を変更できますか？"
    },
    {
      "indent": 3,
      "text": "case_insensitive 16 boolean READ Are filename comparisons on this file system case insensitive?",
      "ja": "case_insensive 16ブール読み取りは、このファイルシステムケースの鈍感なファイル名の比較ですか？"
    },
    {
      "indent": 3,
      "text": "case_preserving 17 boolean READ Is filename case on this file system preserved?",
      "ja": "case_preserving 17 boolean readは、このファイルシステムのファイル名ケースを保存していますか？"
    },
    {
      "indent": 3,
      "text": "chown_restricted 18 boolean READ If TRUE, the server will reject any request to change either the owner or the group associated with a file if the caller is not a privileged user (for example, \"root\" in Unix operating environments or in NT the \"Take Ownership\" privilege)",
      "ja": "chown_restricted 18 boolean read trueの場合、サーバーは、発信者が特権ユーザーではない場合、ファイルに関連付けられたグループのいずれかを変更するリクエストを拒否します（たとえば、unix操作環境の「ルート」またはntの「テイク」所有権 \"特権）"
    },
    {
      "indent": 3,
      "text": "filehandle 19 nfs4_fh READ The filehandle of this object (primarily for readdir requests).",
      "ja": "FileHandle 19 NFS4_FHこのオブジェクトのファイルハンドルを読み取ります（主にReadDirリクエスト用）。"
    },
    {
      "indent": 3,
      "text": "fileid 20 uint64 READ A number uniquely identifying the file within the file system.",
      "ja": "FileID 20 UINT64ファイルシステム内のファイルを一意に識別する番号を読み取ります。"
    },
    {
      "indent": 3,
      "text": "files_avail 21 uint64 READ File slots available to this user on the file system containing this object - this should be the smallest relevant limit.",
      "ja": "files_avail 21 UINT64このオブジェクトを含むファイルシステム上でこのユーザーが利用できるファイルスロットを読み取ります - これは最小の関連制限です。"
    },
    {
      "indent": 3,
      "text": "files_free 22 uint64 READ Free file slots on the file system containing this object - this should be the smallest relevant limit.",
      "ja": "files_free 22 uint64このオブジェクトを含むファイルシステム上の無料ファイルスロットを読み取ります - これは最小の関連制限です。"
    },
    {
      "indent": 3,
      "text": "files_total 23 uint64 READ Total file slots on the file system containing this object.",
      "ja": "files_total 23 uint64このオブジェクトを含むファイルシステム上の合計ファイルスロットを読み取ります。"
    },
    {
      "indent": 3,
      "text": "fs_locations 24 fs_locations READ Locations where this file system may be found. If the server returns NFS4ERR_MOVED as an error, this attribute must be supported.",
      "ja": "fs_locations 24 fs_locationsこのファイルシステムが見つかる可能性のある場所を読み取ります。サーバーがエラーとしてnfs4err_movedを返す場合、この属性をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "hidden 25 boolean R/W Is file considered hidden with respect to the WIN32 API?",
      "ja": "Hidden 25 Boolean R/Wは、Win32 APIに対して非表示と見なされますか？"
    },
    {
      "indent": 3,
      "text": "homogeneous 26 boolean READ Whether or not this object's file system is homogeneous, i.e. are per file system attributes the same for all file system's objects.",
      "ja": "均一な26ブール値このオブジェクトのファイルシステムが均一であるかどうか、つまり、すべてのファイルシステムのオブジェクトで同じファイルシステム属性が同じであるかどうかを読み取ります。"
    },
    {
      "indent": 3,
      "text": "maxfilesize 27 uint64 READ Maximum supported file size for the file system of this object.",
      "ja": "maxFilesize 27 UINT64このオブジェクトのファイルシステムの最大サポートファイルサイズを読み取ります。"
    },
    {
      "indent": 3,
      "text": "maxlink 28 uint32 READ Maximum number of links for this object.",
      "ja": "maxlink 28 uint32このオブジェクトのリンクの最大数を読み取ります。"
    },
    {
      "indent": 3,
      "text": "maxname 29 uint32 READ Maximum filename size supported for this object.",
      "ja": "MaxName 29 UINT32このオブジェクトでサポートされている最大ファイル名サイズを読み取ります。"
    },
    {
      "indent": 3,
      "text": "maxread 30 uint64 READ Maximum read size supported for this object.",
      "ja": "maxread 30 UINT64読み取りこのオブジェクトでサポートされている最大読み取りサイズ。"
    },
    {
      "indent": 3,
      "text": "maxwrite 31 uint64 READ Maximum write size supported for this object. This attribute SHOULD be supported if the file is writable. Lack of this attribute can lead to the client either wasting bandwidth or not receiving the best performance.",
      "ja": "MaxWrite 31 UINT64このオブジェクトでサポートされている最大書き込みサイズを読み取ります。ファイルが書き込み可能な場合は、この属性をサポートする必要があります。この属性の欠如は、クライアントが帯域幅を無駄にするか、最高のパフォーマンスを受け取らないことにつながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "mimetype 32 utf8<> R/W MIME body type/subtype of this object.",
      "ja": "MIMETYPE 32 UTF8 <> R/W MIMEボディタイプ/このオブジェクトのサブタイプ。"
    },
    {
      "indent": 3,
      "text": "mode               33   mode4          R/W      Unix-style permission\n                                                bits for this object\n                                                (deprecated in favor\n                                                of ACLs)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "no_trunc 34 boolean READ If a name longer than name_max is used, will an error be returned or will the name be truncated?",
      "ja": "no_trunc 34 boolean read name_maxより長い名前が使用されている場合、エラーが返されますか、それとも名前が切り捨てられますか？"
    },
    {
      "indent": 3,
      "text": "numlinks 35 uint32 READ Number of hard links to this object.",
      "ja": "NumLinks 35 UINT32このオブジェクトへのハードリンクの数を読み取ります。"
    },
    {
      "indent": 3,
      "text": "owner 36 utf8<> R/W The string name of the owner of this object.",
      "ja": "所有者36 UTF8 <> r/wこのオブジェクトの所有者の文字列名。"
    },
    {
      "indent": 3,
      "text": "owner_group 37 utf8<> R/W The string name of the group ownership of this object.",
      "ja": "owner_group 37 UTF8 <> r/wこのオブジェクトのグループ所有権の文字列名。"
    },
    {
      "indent": 3,
      "text": "quota_avail_hard 38 uint64 READ For definition see \"Quota Attributes\" section below.",
      "ja": "quota_avail_hard 38 uint64定義について読む「クォータ属性」セクションを参照してください。"
    },
    {
      "indent": 3,
      "text": "quota_avail_soft 39 uint64 READ For definition see \"Quota Attributes\" section below.",
      "ja": "quota_avail_soft 39 uint64定義について読む「クォータ属性」セクションを参照してください。"
    },
    {
      "indent": 3,
      "text": "quota_used 40 uint64 READ For definition see \"Quota Attributes\" section below.",
      "ja": "quota_used 40 uint64定義について読み取り、以下の「クォータ属性」セクションを参照してください。"
    },
    {
      "indent": 3,
      "text": "rawdev 41 specdata4 READ Raw device identifier. Unix device major/minor node information.",
      "ja": "Rawdev 41 SpecData4 RAWデバイス識別子を読み取ります。UNIXデバイスメジャー/マイナーノード情報。"
    },
    {
      "indent": 3,
      "text": "space_avail 42 uint64 READ Disk space in bytes available to this user on the file system containing this object - this should be the smallest relevant limit.",
      "ja": "SPACE_AVAIL 42 UINT64このオブジェクトを含むファイルシステムでこのユーザーが利用できるバイトでディスクスペースを読み取ります - これは最小の関連制限です。"
    },
    {
      "indent": 3,
      "text": "space_free 43 uint64 READ Free disk space in bytes on the file system containing this object - this should be the smallest relevant limit.",
      "ja": "Space_Free 43 UINT64このオブジェクトを含むファイルシステムのバイトで無料ディスクスペースを読み取ります - これは最小の関連制限です。"
    },
    {
      "indent": 3,
      "text": "space_total 44 uint64 READ Total disk space in bytes on the file system containing this object.",
      "ja": "space_total 44 uint64このオブジェクトを含むファイルシステムのバイトで、ディスクスペースの合計スペースを読み取ります。"
    },
    {
      "indent": 3,
      "text": "space_used 45 uint64 READ Number of file system bytes allocated to this object.",
      "ja": "Space_used 45 UINT64このオブジェクトに割り当てられたファイルシステムバイトの数を読み取ります。"
    },
    {
      "indent": 3,
      "text": "system 46 boolean R/W Is this file a system file with respect to the WIN32 API?",
      "ja": "システム46ブールr/wこのファイルは、win32 APIに関するシステムファイルですか？"
    },
    {
      "indent": 3,
      "text": "time_access 47 nfstime4 READ The time of last access to the object.",
      "ja": "time_access 47 nfstime4オブジェクトへの最後のアクセスの時間を読み取ります。"
    },
    {
      "indent": 3,
      "text": "time_access_set 48 settime4 WRITE Set the time of last access to the object. SETATTR use only.",
      "ja": "time_access_set 48 settime4書き込みオブジェクトへの最後のアクセスの時間を設定します。Setattrの使用のみ。"
    },
    {
      "indent": 3,
      "text": "time_backup 49 nfstime4 R/W The time of last backup of the object.",
      "ja": "time_backup 49 nfstime4 r/wオブジェクトの最後のバックアップの時間。"
    },
    {
      "indent": 3,
      "text": "time_create 50 nfstime4 R/W The time of creation of the object. This attribute does not have any relation to the traditional Unix file attribute \"ctime\" or \"change time\".",
      "ja": "time_create 50 nfstime4 r/wオブジェクトの作成時間。この属性には、従来のUNIXファイル属性「CTIME」または「変更時間」とは関係ありません。"
    },
    {
      "indent": 3,
      "text": "time_delta 51 nfstime4 READ Smallest useful server time granularity.",
      "ja": "time_delta 51 nfstime4は、最小の有用なサーバー時間の粒度を読み取ります。"
    },
    {
      "indent": 3,
      "text": "time_metadata 52 nfstime4 R/W The time of last meta-data modification of the object.",
      "ja": "time_metadata 52 nfstime4 r/wオブジェクトの最後のメタデータ変更の時間。"
    },
    {
      "indent": 3,
      "text": "time_modify 53 nfstime4 READ The time of last modification to the object.",
      "ja": "time_modify 53 nfstime4オブジェクトの最後の変更の時間を読み取ります。"
    },
    {
      "indent": 3,
      "text": "time_modify_set 54 settime4 WRITE Set the time of last modification to the object. SETATTR use only.",
      "ja": "time_modify_set 54 settime4書き込み最後の変更の時間をオブジェクトに設定します。Setattrの使用のみ。"
    },
    {
      "indent": 0,
      "text": "5.6. Interpreting owner and owner_group",
      "section_title": true,
      "ja": "5.6. 解釈所有者とowner_group"
    },
    {
      "indent": 3,
      "text": "The recommended attributes \"owner\" and \"owner_group\" are represented in terms of a UTF-8 string. To avoid a representation that is tied to a particular underlying implementation at the client or server, the use of the UTF-8 string has been chosen. Note that section 6.1 of [RFC2624] provides additional rationale. It is expected that the client and server will have their own local representation of owner and owner_group that is used for local storage or presentation to the end user. Therefore, it is expected that when these attributes are transferred between the client and server that the local representation is translated to a syntax of the form \"user@dns_domain\". This will allow for a client and server that do not use the same local representation the ability to translate to a common syntax that can be interpreted by both.",
      "ja": "推奨される属性「所有者」と「owner_group」は、UTF-8文字列の観点から表されます。クライアントまたはサーバーで特定の基礎となる実装に関連する表現を回避するために、UTF-8文字列の使用が選択されています。[RFC2624]のセクション6.1は、追加の根拠を提供していることに注意してください。クライアントとサーバーには、エンドユーザーへのローカルストレージまたはプレゼンテーションに使用される所有者と所有者_groupの独自のローカル表現があることが期待されています。したがって、これらの属性がクライアントとサーバーの間に転送されると、ローカル表現が「user@dns_domain」という形式の構文に変換されることが予想されます。これにより、同じローカル表現を使用しないクライアントとサーバーが、両方で解釈できる共通の構文に変換する機能を可能にします。"
    },
    {
      "indent": 3,
      "text": "The translation is not specified as part of the protocol. This allows various solutions to be employed. For example, a local translation table may be consulted that maps between a numeric id to the user@dns_domain syntax. A name service may also be used to accomplish the translation. The \"dns_domain\" portion of the owner string is meant to be a DNS domain name. For example, user@ietf.org.",
      "ja": "翻訳はプロトコルの一部として指定されていません。これにより、さまざまなソリューションを使用できます。たとえば、ユーザー@dns_domain構文への数値ID間のマップを確認するローカル翻訳テーブルに相談することができます。翻訳を達成するために、名前サービスを使用することもできます。所有者文字列の「DNS_DOMAIN」部分は、DNSドメイン名であることを意図しています。たとえば、user@ietf.org。"
    },
    {
      "indent": 3,
      "text": "In the case where there is no translation available to the client or server, the attribute value must be constructed without the \"@\". Therefore, the absence of the @ from the owner or owner_group attribute signifies that no translation was available and the receiver of the attribute should not place any special meaning with the attribute value. Even though the attribute value can not be translated, it may still be useful. In the case of a client, the attribute string may be used for local display of ownership.",
      "ja": "クライアントまたはサーバーが利用できる翻訳がない場合、属性値は「@」なしで構築する必要があります。したがって、所有者またはowner_group属性からの @がないことは、翻訳が利用できず、属性の受信者が属性値に特別な意味を置くべきではないことを意味します。属性値を翻訳することはできませんが、それでも有用かもしれません。クライアントの場合、属性文字列は、所有権のローカル表示に使用できます。"
    },
    {
      "indent": 0,
      "text": "5.7. Character Case Attributes",
      "section_title": true,
      "ja": "5.7. キャラクターケースの属性"
    },
    {
      "indent": 3,
      "text": "With respect to the case_insensitive and case_preserving attributes, each UCS-4 character (which UTF-8 encodes) has a \"long descriptive name\" [RFC1345] which may or may not included the word \"CAPITAL\" or \"SMALL\". The presence of SMALL or CAPITAL allows an NFS server to implement unambiguous and efficient table driven mappings for case insensitive comparisons, and non-case-preserving storage. For general character handling and internationalization issues, see the section \"Internationalization\".",
      "ja": "case_insensitiveおよびcase_preserving属性に関して、各UCS-4文字（UTF-8エンコード）には、「キャピタル」または「小」という単語が含まれる場合と含まれない場合がある「長い説明」[RFC1345]があります。小規模または資本の存在により、NFSサーバーは、ケースの鈍感な比較、および非ケース普及ストレージのために、明確で効率的なテーブル駆動型マッピングを実装できます。一般的なキャラクターの取り扱いと国際化の問題については、セクション「国際化」を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.8. Quota Attributes",
      "section_title": true,
      "ja": "5.8. クォータ属性"
    },
    {
      "indent": 3,
      "text": "For the attributes related to file system quotas, the following definitions apply:",
      "ja": "ファイルシステムの割り当てに関連する属性の場合、次の定義が適用されます。"
    },
    {
      "indent": 3,
      "text": "quota_avail_soft The value in bytes which represents the amount of additional disk space that can be allocated to this file or directory before the user may reasonably be warned. It is understood that this space may be consumed by allocations to other files or directories though there is a rule as to which other files or directories.",
      "ja": "quota_avail_softユーザーが合理的に警告する前に、このファイルまたはディレクトリに割り当てることができる追加のディスクスペースの量を表すバイトの値。このスペースは、他のファイルまたはディレクトリのルールがありますが、他のファイルやディレクトリへの割り当てによって消費される可能性があると理解されています。"
    },
    {
      "indent": 3,
      "text": "quota_avail_hard The value in bytes which represent the amount of additional disk space beyond the current allocation that can be allocated to this file or directory before further allocations will be refused. It is understood that this space may be consumed by allocations to other files or directories.",
      "ja": "quota_avail_hardさらなる割り当てが拒否される前に、このファイルまたはディレクトリに割り当てることができる現在の割り当てを超える追加のディスク容量の量を表すバイトの値。このスペースは、他のファイルやディレクトリへの割り当てによって消費される可能性があることが理解されています。"
    },
    {
      "indent": 3,
      "text": "quota_used The value in bytes which represent the amount of disc space used by this file or directory and possibly a number of other similar files or directories, where the set of \"similar\" meets at least the criterion that allocating space to any file or directory in the set will reduce the \"quota_avail_hard\" of every other file or directory in the set.",
      "ja": "quota_suseこのファイルまたはディレクトリで使用されるディスクスペースの量、および「同様」のセットが少なくともファイルまたはディレクトリにスペースを割り当てる基準を満たしている他の多くの類似ファイルまたはディレクトリを表すバイトの値を使用しました。このセットは、セット内の他のすべてのファイルまたはディレクトリの「quota_avail_hard」を削減します。"
    },
    {
      "indent": 9,
      "text": "Note that there may be a number of distinct but overlapping sets of files or directories for which a quota_used value is maintained. E.g. \"all files with a given owner\", \"all files with a given group owner\". etc.",
      "ja": "quota_used値が維持されるファイルまたはディレクトリの重複セットが多数ある場合があることに注意してください。例えば。「特定の所有者とのすべてのファイル」、「特定のグループ所有者を持つすべてのファイル」。等"
    },
    {
      "indent": 9,
      "text": "The server is at liberty to choose any of those sets but should do so in a repeatable way. The rule may be configured per-filesystem or may be \"choose the set with the smallest quota\".",
      "ja": "サーバーは、これらのセットのいずれかを選択するためにLibertyにありますが、繰り返し可能な方法でそれを行う必要があります。ルールは、ファイルシステムごとに構成されている場合があります。または、「最小の割り当てでセットを選択」する場合があります。"
    },
    {
      "indent": 0,
      "text": "5.9. Access Control Lists",
      "section_title": true,
      "ja": "5.9. アクセス制御リスト"
    },
    {
      "indent": 3,
      "text": "The NFS ACL attribute is an array of access control entries (ACE). There are various access control entry types. The server is able to communicate which ACE types are supported by returning the appropriate value within the aclsupport attribute. The types of ACEs are defined as follows:",
      "ja": "NFS ACL属性は、アクセス制御エントリの配列（ACE）です。さまざまなアクセス制御入力タイプがあります。サーバーは、ACLSupport属性内の適切な値を返すことにより、どのACEタイプがサポートされるかを通信できます。ACEのタイプは次のように定義されます。"
    },
    {
      "indent": 3,
      "text": "Type         Description\n_____________________________________________________\nALLOW        Explicitly grants the access defined in\n             acemask4 to the file or directory.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DENY Explicitly denies the access defined in acemask4 to the file or directory.",
      "ja": "denyは、acemask4でファイルまたはディレクトリに定義されているアクセスを明示的に拒否します。"
    },
    {
      "indent": 3,
      "text": "AUDIT LOG (system dependent) any access attempt to a file or directory which uses any of the access methods specified in acemask4.",
      "ja": "監査ログ（システム依存）ACEMASK4で指定されたアクセスメソッドのいずれかを使用するファイルまたはディレクトリへのアクセスの試行。"
    },
    {
      "indent": 3,
      "text": "ALARM Generate a system ALARM (system dependent) when any access attempt is made to a file or directory for the access methods specified in acemask4.",
      "ja": "アラームACEMASK4で指定されたアクセスメソッドのファイルまたはディレクトリに対してアクセスの試行が行われたときに、システムアラーム（システム依存）を生成します。"
    },
    {
      "indent": 3,
      "text": "The NFS ACE attribute is defined as follows:",
      "ja": "NFS ACE属性は次のように定義されます。"
    },
    {
      "indent": 3,
      "text": "typedef uint32_t        acetype4;\ntypedef uint32_t        aceflag4;\ntypedef uint32_t        acemask4;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct nfsace4 {\n        acetype4        type;\n        aceflag4        flag;\n        acemask4        access_mask;\n        utf8string      who;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "To determine if an ACCESS or OPEN request succeeds each nfsace4 entry is processed in order by the server. Only ACEs which have a \"who\" that matches the requester are considered. Each ACE is processed until all of the bits of the requester's access have been ALLOWED. Once a bit (see below) has been ALLOWED by an ACCESS_ALLOWED_ACE, it is no longer considered in the processing of later ACEs. If an ACCESS_DENIED_ACE is encountered where the requester's mode still has unALLOWED bits in common with the \"access_mask\" of the ACE, the request is denied.",
      "ja": "アクセスまたはオープンリクエストが成功するかどうかを判断するために、各NFSACE4エントリがサーバーによって順番に処理されます。要求者に一致する「who」を持つエースのみが考慮されます。各ACEは、要求者のアクセスのすべてのビットが許可されるまで処理されます。Access_Allowed_aceによって少し（以下を参照）が許可されると、後のACEの処理では考慮されなくなります。Access_denied_aceが、リクエスターのモードがまだACEの「Access_mask」と共通していない場合に遭遇した場合、リクエストは拒否されます。"
    },
    {
      "indent": 3,
      "text": "The bitmask constants used to represent the above definitions within the aclsupport attribute are as follows:",
      "ja": "aclsupport属性内の上記の定義を表すために使用されるビットマスク定数は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "const ACL4_SUPPORT_ALLOW_ACL    = 0x00000001;\nconst ACL4_SUPPORT_DENY_ACL     = 0x00000002;\nconst ACL4_SUPPORT_AUDIT_ACL    = 0x00000004;\nconst ACL4_SUPPORT_ALARM_ACL    = 0x00000008;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.9.1. ACE type",
      "section_title": true,
      "ja": "5.9.1. エースタイプ"
    },
    {
      "indent": 3,
      "text": "The semantics of the \"type\" field follow the descriptions provided above.",
      "ja": "「タイプ」フィールドのセマンティクスは、上記の説明に従います。"
    },
    {
      "indent": 3,
      "text": "The bitmask constants used for the type field are as follows:",
      "ja": "タイプフィールドに使用されるビットマスク定数は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "const ACE4_ACCESS_ALLOWED_ACE_TYPE      = 0x00000000;\nconst ACE4_ACCESS_DENIED_ACE_TYPE       = 0x00000001;\nconst ACE4_SYSTEM_AUDIT_ACE_TYPE        = 0x00000002;\nconst ACE4_SYSTEM_ALARM_ACE_TYPE        = 0x00000003;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.9.2. ACE flag",
      "section_title": true,
      "ja": "5.9.2. エースフラグ"
    },
    {
      "indent": 3,
      "text": "The \"flag\" field contains values based on the following descriptions.",
      "ja": "「フラグ」フィールドには、次の説明に基づいて値が含まれています。"
    },
    {
      "indent": 3,
      "text": "ACE4_FILE_INHERIT_ACE",
      "ja": "ACE4_FILE_INHERIT_ACE"
    },
    {
      "indent": 3,
      "text": "Can be placed on a directory and indicates that this ACE should be added to each new non-directory file created.",
      "ja": "ディレクトリに配置することができ、このエースを作成した新しい非ディレクトリファイルに追加する必要があることを示します。"
    },
    {
      "indent": 3,
      "text": "ACE4_DIRECTORY_INHERIT_ACE",
      "ja": "ACE4_DIRECTORY_INHERIT_ACE"
    },
    {
      "indent": 3,
      "text": "Can be placed on a directory and indicates that this ACE should be added to each new directory created.",
      "ja": "ディレクトリに配置することができ、作成された新しいディレクトリにこのエースを追加する必要があることを示します。"
    },
    {
      "indent": 3,
      "text": "ACE4_INHERIT_ONLY_ACE",
      "ja": "ACE4_INHERIT_ONLY_ACE"
    },
    {
      "indent": 3,
      "text": "Can be placed on a directory but does not apply to the directory, only to newly created files/directories as specified by the above two flags.",
      "ja": "ディレクトリに配置できますが、上記の2つのフラグで指定されているように、新しく作成されたファイル/ディレクトリにのみディレクトリに適用されません。"
    },
    {
      "indent": 3,
      "text": "ACE4_NO_PROPAGATE_INHERIT_ACE Can be placed on a directory. Normally when a new directory is created and an ACE exists on the parent directory which is marked ACL4_DIRECTORY_INHERIT_ACE, two ACEs are placed on the new directory. One for the directory itself and one which is an inheritable ACE for newly created directories. This flag tells the server to not place an ACE on the newly created directory which is inheritable by subdirectories of the created directory.",
      "ja": "ACE4_NO_PROPAGATE_INHERIT_ACEはディレクトリに配置できます。通常、新しいディレクトリが作成され、ACL4_DIRECTORY_INHERIT_ACEとマークされた親ディレクトリにACEが存在すると、2つのエースが新しいディレクトリに配置されます。1つはディレクトリ自体と、新しく作成されたディレクトリの継承可能なエースです。このフラグは、作成されたディレクトリのサブディレクトリによって継承可能な新しく作成されたディレクトリにACEを配置しないようにサーバーに指示します。"
    },
    {
      "indent": 3,
      "text": "ACE4_SUCCESSFUL_ACCESS_ACE_FLAG",
      "ja": "ace4_successful_access_ace_flag"
    },
    {
      "indent": 3,
      "text": "ACL4_FAILED_ACCESS_ACE_FLAG",
      "ja": "acl4_failed_access_ace_flag"
    },
    {
      "indent": 3,
      "text": "Both indicate for AUDIT and ALARM which state to log the event. On every ACCESS or OPEN call which occurs on a file or directory which has an ACL that is of type ACE4_SYSTEM_AUDIT_ACE_TYPE or ACE4_SYSTEM_ALARM_ACE_TYPE, the attempted access is compared to the ace4mask of these ACLs. If the access is a subset of ace4mask and the identifier match, an AUDIT trail or an ALARM is generated. By default this happens regardless of the success or failure of the ACCESS or OPEN call.",
      "ja": "どちらも、イベントを記録する状態で監査とアラームを示しています。タイプACE4_System_Audit_ace_TypeまたはACE4_SYSTEM_ALARM_ALARM_TYPEのACLを備えたファイルまたはディレクトリで発生するすべてのアクセスまたはオープンコールで、これらのACLのACE4マスクと比較されます。アクセスがACE4マスクのサブセットと識別子一致である場合、監査証跡またはアラームが生成されます。デフォルトでは、アクセスまたはオープンコールの成功や失敗に関係なく、これは発生します。"
    },
    {
      "indent": 3,
      "text": "The flag ACE4_SUCCESSFUL_ACCESS_ACE_FLAG only produces the AUDIT or ALARM if the ACCESS or OPEN call is successful. The ACE4_FAILED_ACCESS_ACE_FLAG causes the ALARM or AUDIT if the ACCESS or OPEN call fails.",
      "ja": "FLAG ACE4_SUCCESSFUL_ACESS_ACE_FLAGは、アクセスまたはオープンコールが成功した場合にのみ監査またはアラームを生成します。ACE4_FAILED_ACCESS_ACE_FLAGは、アクセスまたはオープンコールが失敗した場合、アラームまたは監査を引き起こします。"
    },
    {
      "indent": 3,
      "text": "ACE4_IDENTIFIER_GROUP",
      "ja": "ace4_identifier_group"
    },
    {
      "indent": 3,
      "text": "Indicates that the \"who\" refers to a GROUP as defined under Unix.",
      "ja": "「who」は、unixの下で定義されているグループを指すことを示します。"
    },
    {
      "indent": 3,
      "text": "The bitmask constants used for the flag field are as follows:",
      "ja": "フラグフィールドに使用されるビットマスク定数は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "const ACE4_FILE_INHERIT_ACE             = 0x00000001;\nconst ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;\nconst ACE4_NO_PROPAGATE_INHERIT_ACE     = 0x00000004;\nconst ACE4_INHERIT_ONLY_ACE             = 0x00000008;\nconst ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;\nconst ACE4_FAILED_ACCESS_ACE_FLAG       = 0x00000020;\nconst ACE4_IDENTIFIER_GROUP             = 0x00000040;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.9.3. ACE Access Mask",
      "section_title": true,
      "ja": "5.9.3. エースアクセスマスク"
    },
    {
      "indent": 3,
      "text": "The access_mask field contains values based on the following:",
      "ja": "Access_Maskフィールドには、以下に基づいて値が含まれています。"
    },
    {
      "indent": 3,
      "text": "Access                 Description\n_______________________________________________________________\nREAD_DATA              Permission to read the data of the file\nLIST_DIRECTORY         Permission to list the contents of a\n                       directory\nWRITE_DATA             Permission to modify the file's data\nADD_FILE               Permission to add a new file to a\n                       directory\nAPPEND_DATA            Permission to append data to a file\nADD_SUBDIRECTORY       Permission to create a subdirectory to a\n                       directory\nREAD_NAMED_ATTRS       Permission to read the named attributes\n                       of a file\nWRITE_NAMED_ATTRS      Permission to write the named attributes\n                       of a file\nEXECUTE                Permission to execute a file\nDELETE_CHILD           Permission to delete a file or directory\n                       within a directory\nREAD_ATTRIBUTES        The ability to read basic attributes\n                       (non-acls) of a file\nWRITE_ATTRIBUTES       Permission to change basic attributes\n                       (non-acls) of a file",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DELETE                 Permission to Delete the file\nREAD_ACL               Permission to Read the ACL\nWRITE_ACL              Permission to Write the ACL\nWRITE_OWNER            Permission to change the owner\nSYNCHRONIZE            Permission to access file locally at the\n                       server with synchronous reads and writes",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The bitmask constants used for the access mask field are as follows:",
      "ja": "アクセスマスクフィールドに使用されるビットマスク定数は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "const ACE4_READ_DATA            = 0x00000001;\nconst ACE4_LIST_DIRECTORY       = 0x00000001;\nconst ACE4_WRITE_DATA           = 0x00000002;\nconst ACE4_ADD_FILE             = 0x00000002;\nconst ACE4_APPEND_DATA          = 0x00000004;\nconst ACE4_ADD_SUBDIRECTORY     = 0x00000004;\nconst ACE4_READ_NAMED_ATTRS     = 0x00000008;\nconst ACE4_WRITE_NAMED_ATTRS    = 0x00000010;\nconst ACE4_EXECUTE              = 0x00000020;\nconst ACE4_DELETE_CHILD         = 0x00000040;\nconst ACE4_READ_ATTRIBUTES      = 0x00000080;\nconst ACE4_WRITE_ATTRIBUTES     = 0x00000100;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const ACE4_DELETE               = 0x00010000;\nconst ACE4_READ_ACL             = 0x00020000;\nconst ACE4_WRITE_ACL            = 0x00040000;\nconst ACE4_WRITE_OWNER          = 0x00080000;\nconst ACE4_SYNCHRONIZE          = 0x00100000;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.9.4. ACE who",
      "section_title": true,
      "ja": "5.9.4. エースだ"
    },
    {
      "indent": 3,
      "text": "There are several special identifiers (\"who\") which need to be understood universally. Some of these identifiers cannot be understood when an NFS client accesses the server, but have meaning when a local process accesses the file. The ability to display and modify these permissions is permitted over NFS.",
      "ja": "普遍的に理解する必要があるいくつかの特別な識別子（「WHO」）があります。これらの識別子の一部は、NFSクライアントがサーバーにアクセスするときに理解することはできませんが、ローカルプロセスがファイルにアクセスするときに意味があります。これらのアクセス許可を表示および変更する機能は、NFSで許可されています。"
    },
    {
      "indent": 3,
      "text": "Who                    Description\n_______________________________________________________________\n\"OWNER\"                The owner of the file.\n\"GROUP\"                The group associated with the file.\n\"EVERYONE\"             The world.\n\"INTERACTIVE\"          Accessed from an interactive terminal.\n\"NETWORK\"              Accessed via the network.\n\"DIALUP\"               Accessed as a dialup user to the server.\n\"BATCH\"                Accessed from a batch job.\n\"ANONYMOUS\"            Accessed without any authentication.\n\"AUTHENTICATED\"        Any authenticated user (opposite of\n                       ANONYMOUS)\n\"SERVICE\"              Access from a system service.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "To avoid conflict, these special identifiers are distinguish by an appended \"@\" and should appear in the form \"xxxx@\" (note: no domain name after the \"@\"). For example: ANONYMOUS@.",
      "ja": "競合を回避するために、これらの特別な識別子は追加された「@」で区別され、「xxxx@」という形式に表示されるはずです（注：「@」の後にドメイン名なし）。例：anonymous@。"
    },
    {
      "indent": 0,
      "text": "6. File System Migration and Replication",
      "section_title": true,
      "ja": "6. ファイルシステムの移行と複製"
    },
    {
      "indent": 3,
      "text": "With the use of the recommended attribute \"fs_locations\", the NFS version 4 server has a method of providing file system migration or replication services. For the purposes of migration and replication, a file system will be defined as all files that share a given fsid (both major and minor values are the same).",
      "ja": "推奨属性「FS_Locations」を使用すると、NFSバージョン4サーバーには、ファイルシステムの移行または複製サービスを提供する方法があります。移行と複製の目的のために、ファイルシステムは、特定のFSIDを共有するすべてのファイルとして定義されます（主要な値とマイナー値の両方が同じです）。"
    },
    {
      "indent": 3,
      "text": "The fs_locations attribute provides a list of file system locations. These locations are specified by providing the server name (either DNS domain or IP address) and the path name representing the root of the file system. Depending on the type of service being provided, the list will provide a new location or a set of alternate locations for the file system. The client will use this information to redirect its requests to the new server.",
      "ja": "FS_Locations属性は、ファイルシステムの場所のリストを提供します。これらの場所は、サーバー名（DNSドメインまたはIPアドレス）とファイルシステムのルートを表すパス名を提供することによって指定されます。提供されるサービスの種類に応じて、リストはファイルシステムの新しい場所または代替場所のセットを提供します。クライアントはこの情報を使用して、リクエストを新しいサーバーにリダイレクトします。"
    },
    {
      "indent": 0,
      "text": "6.1. Replication",
      "section_title": true,
      "ja": "6.1. 複製"
    },
    {
      "indent": 3,
      "text": "It is expected that file system replication will be used in the case of read-only data. Typically, the file system will be replicated on two or more servers. The fs_locations attribute will provide the list of these locations to the client. On first access of the file system, the client should obtain the value of the fs_locations attribute. If, in the future, the client finds the server unresponsive, the client may attempt to use another server specified by fs_locations.",
      "ja": "読み取り専用データの場合、ファイルシステムの複製が使用されることが期待されています。通常、ファイルシステムは2つ以上のサーバーに複製されます。FS_Locations属性は、これらの場所のリストをクライアントに提供します。ファイルシステムに最初にアクセスすると、クライアントはFS_Locations属性の値を取得する必要があります。将来、クライアントがサーバーが反応しないと判断した場合、クライアントはFS_Locationsで指定された別のサーバーを使用しようとする場合があります。"
    },
    {
      "indent": 3,
      "text": "If applicable, the client must take the appropriate steps to recover valid filehandles from the new server. This is described in more detail in the following sections.",
      "ja": "該当する場合、クライアントは新しいサーバーから有効なファイルハンドルを回復するために適切な手順を実行する必要があります。これについては、次のセクションで詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "6.2. Migration",
      "section_title": true,
      "ja": "6.2. 移行"
    },
    {
      "indent": 3,
      "text": "File system migration is used to move a file system from one server to another. Migration is typically used for a file system that is writable and has a single copy. The expected use of migration is for load balancing or general resource reallocation. The protocol does not specify how the file system will be moved between servers. This server-to-server transfer mechanism is left to the server implementor. However, the method used to communicate the migration event between client and server is specified here.",
      "ja": "ファイルシステムの移行は、ファイルシステムをあるサーバーから別のサーバーに移動するために使用されます。移行は通常、書き込み可能で単一のコピーがあるファイルシステムに使用されます。移行の予想される使用は、ロードバランスまたは一般的なリソースの再割り当てです。プロトコルは、ファイルシステムがサーバー間で移動する方法を指定しません。このサーバーからサーバーへの転送メカニズムは、サーバー実装者に任されています。ただし、クライアントとサーバー間の移行イベントの通信に使用される方法は、ここで指定されています。"
    },
    {
      "indent": 3,
      "text": "Once the servers participating in the migration have completed the move of the file system, the error NFS4ERR_MOVED will be returned for subsequent requests received by the original server. The NFS4ERR_MOVED error is returned for all operations except GETATTR. Upon receiving the NFS4ERR_MOVED error, the client will obtain the value of the fs_locations attribute. The client will then use the contents of the attribute to redirect its requests to the specified server. To facilitate the use of GETATTR, operations such as PUTFH must also be accepted by the server for the migrated file system's filehandles. Note that if the server returns NFS4ERR_MOVED, the server MUST support the fs_locations attribute.",
      "ja": "移行に参加するサーバーがファイルシステムの移動を完了すると、元のサーバーが受け取った後続のリクエストに対してエラーNFS4err_movedが返されます。NFS4err_movedエラーは、getattrを除くすべての操作に対して返されます。nfs4err_movedエラーを受信すると、クライアントはfs_locations属性の値を取得します。クライアントは、属性のコンテンツを使用して、指定されたサーバーにリクエストをリダイレクトします。getattrの使用を容易にするには、PUTFHなどの操作も、移行されたファイルシステムのファイルハンドルのサーバーが受け入れる必要があります。サーバーがnfs4err_movedを返す場合、サーバーはfs_locations属性をサポートする必要があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "If the client requests more attributes than just fs_locations, the server may return fs_locations only. This is to be expected since the server has migrated the file system and may not have a method of obtaining additional attribute data.",
      "ja": "クライアントがFS_Locationsよりも多くの属性を要求する場合、サーバーはFS_Locationsのみを返すことができます。これは、サーバーがファイルシステムを移行し、追加の属性データを取得する方法がない場合があるため、予想されることです。"
    },
    {
      "indent": 3,
      "text": "The server implementor needs to be careful in developing a migration solution. The server must consider all of the state information clients may have outstanding at the server. This includes but is not limited to locking/share state, delegation state, and asynchronous file writes which are represented by WRITE and COMMIT verifiers. The server should strive to minimize the impact on its clients during and after the migration process.",
      "ja": "サーバーの実装者は、移行ソリューションの開発に注意する必要があります。サーバーは、すべての州の情報クライアントがサーバーで未解決の可能性があると考える必要があります。これには、状態のロック/共有状態、委任状態、および非同期ファイルの書き込みが含まれますが、書き込みおよびコミットされた検証者によって表されます。サーバーは、移行プロセス中および移行プロセス後のクライアントへの影響を最小限に抑えるよう努力する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3. Interpretation of the fs_locations Attribute",
      "section_title": true,
      "ja": "6.3. FS_Locations属性の解釈"
    },
    {
      "indent": 3,
      "text": "The fs_location attribute is structured in the following way:",
      "ja": "FS_Location属性は、次のように構成されています。"
    },
    {
      "indent": 3,
      "text": "struct fs_location {\n        utf8string      server<>;\n        pathname4       rootpath;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct fs_locations {\n        pathname4       fs_root;\n        fs_location     locations<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The fs_location struct is used to represent the location of a file system by providing a server name and the path to the root of the file system. For a multi-homed server or a set of servers that use the same rootpath, an array of server names may be provided. An entry in the server array is an UTF8 string and represents one of a traditional DNS host name, IPv4 address, or IPv6 address. It is not a requirement that all servers that share the same rootpath be listed in one fs_location struct. The array of server names is provided for convenience. Servers that share the same rootpath may also be listed in separate fs_location entries in the fs_locations attribute.",
      "ja": "FS_Location構造体は、サーバー名とファイルシステムのルートへのパスを提供することにより、ファイルシステムの位置を表すために使用されます。同じルートパスを使用するマルチホームサーバーまたは一連のサーバーの場合、サーバー名の配列が提供される場合があります。サーバーアレイのエントリはUTF8文字列であり、従来のDNSホスト名、IPv4アドレス、またはIPv6アドレスの1つを表します。同じルートパスを共有するすべてのサーバーが1つのFS_Location構造体にリストされることは要件ではありません。サーバー名の配列は便利なために提供されます。同じルートパスを共有するサーバーは、FS_Locations属性の個別のFS_Locationエントリにもリストされる場合があります。"
    },
    {
      "indent": 3,
      "text": "The fs_locations struct and attribute then contains an array of locations. Since the name space of each server may be constructed differently, the \"fs_root\" field is provided. The path represented by fs_root represents the location of the file system in the server's name space. Therefore, the fs_root path is only associated with the server from which the fs_locations attribute was obtained. The fs_root path is meant to aid the client in locating the file system at the various servers listed.",
      "ja": "FS_Locations structと属性には、一連の場所が含まれています。各サーバーの名前スペースは異なる方法で構築される可能性があるため、「FS_ROOT」フィールドが提供されます。FS_ROOTで表されるパスは、サーバーの名前空間内のファイルシステムの位置を表します。したがって、FS_ROOTパスは、FS_Locations属性が取得されたサーバーにのみ関連付けられます。FS_ROOTパスは、リストされているさまざまなサーバーにファイルシステムを見つけるのを支援するためのものです。"
    },
    {
      "indent": 3,
      "text": "As an example, there is a replicated file system located at two servers (servA and servB). At servA the file system is located at path \"/a/b/c\". At servB the file system is located at path \"/x/y/z\". In this example the client accesses the file system first at servA with a multi-component lookup path of \"/a/b/c/d\". Since the client used a multi-component lookup to obtain the filehandle at \"/a/b/c/d\", it is unaware that the file system's root is located in servA's name space at \"/a/b/c\". When the client switches to servB, it will need to determine that the directory it first referenced at servA is now represented by the path \"/x/y/z/d\" on servB. To facilitate this, the fs_locations attribute provided by servA would have a fs_root value of \"/a/b/c\" and two entries in fs_location. One entry in fs_location will be for itself (servA) and the other will be for servB with a path of \"/x/y/z\". With this information, the client is able to substitute \"/x/y/z\" for the \"/a/b/c\" at the beginning of its access path and construct \"/x/y/z/d\" to use for the new server.",
      "ja": "例として、2つのサーバー（ServaとServb）にある複製ファイルシステムがあります。Servaでは、ファイルシステムはパス「/a/b/c」にあります。Servbでは、ファイルシステムはパス \"/x/y/z\"にあります。この例では、クライアントは、「/a/b/c/d」のマルチコンポーネントルックアップパスで最初にservaでファイルシステムにアクセスします。クライアントはマルチコンポーネントルックアップを使用して「/a/b/c/d」でファイルハンドルを取得するため、ファイルシステムのルートが「/a/b/c」のservaの名前スペースにあることを知りません。クライアントがSERVBに切り替えると、SERVAで最初に参照されたディレクトリがSERVBのパス「/x/y/z/d」で表されることを判断する必要があります。これを容易にするために、servaによって提供されるFS_locations属性は、fs_root値の「/a/b/c」とFS_Locationの2つのエントリを持ちます。FS_Locationの1つのエントリはそれ自体（Serva）であり、もう1つは「/x/y/z」のパスを持つSERVBです。この情報を使用すると、クライアントは、アクセスパスの先頭に「/x/y/z」を「/a/b/c」に置き換えることができます。新しいサーバー。"
    },
    {
      "indent": 0,
      "text": "6.4. Filehandle Recovery for Migration or Replication",
      "section_title": true,
      "ja": "6.4. 移行または複製のためのファイルハンドルリカバリ"
    },
    {
      "indent": 3,
      "text": "Filehandles for file systems that are replicated or migrated generally have the same semantics as for file systems that are not replicated or migrated. For example, if a file system has persistent filehandles and it is migrated to another server, the filehandle values for the file system will be valid at the new server.",
      "ja": "複製または移行されたファイルシステムのファイルハンドルは、一般的に複製または移行されていないファイルシステムと同じセマンティクスを持っています。たとえば、ファイルシステムにファイルハンドルが永続的になり、別のサーバーに移行された場合、ファイルシステムのファイルハンドル値が新しいサーバーで有効になります。"
    },
    {
      "indent": 3,
      "text": "For volatile filehandles, the servers involved likely do not have a mechanism to transfer filehandle format and content between themselves. Therefore, a server may have difficulty in determining if a volatile filehandle from an old server should return an error of NFS4ERR_FHEXPIRED. Therefore, the client is informed, with the use of the fh_expire_type attribute, whether volatile filehandles will expire at the migration or replication event. If the bit FH4_VOL_MIGRATION is set in the fh_expire_type attribute, the client must treat the volatile filehandle as if the server had returned the NFS4ERR_FHEXPIRED error. At the migration or replication event in the presence of the FH4_VOL_MIGRATION bit, the client will not present the original or old volatile file handle to the new server. The client will start its communication with the new server by recovering its filehandles using the saved file names.",
      "ja": "揮発性ファイルハンドルの場合、関係するサーバーには、ファイルハンドル形式とコンテンツを自分の間に転送するメカニズムがない可能性があります。したがって、サーバーは、古いサーバーからの揮発性ファイルハンドルがnfs4err_fhexpiredのエラーを返す必要があるかどうかを判断するのが困難な場合があります。したがって、fh_expire_type属性を使用して、揮発性のファイルハンドルが移行または複製イベントで期限切れになるかどうかを使用して、クライアントに通知されます。ビットfh4_vol_migrationがfh_expire_type属性に設定されている場合、クライアントはサーバーがnfs4err_fhexpiredエラーを返したかのように揮発性ファイルハンドルを扱う必要があります。FH4_Vol_Migrationビットの存在下での移行または複製イベントでは、クライアントは元の揮発性ファイルハンドルを新しいサーバーに表示しません。クライアントは、保存されたファイル名を使用してファイルハンドルを回復することにより、新しいサーバーとの通信を開始します。"
    },
    {
      "indent": 0,
      "text": "7. NFS Server Name Space",
      "section_title": true,
      "ja": "7. NFSサーバー名スペース"
    },
    {
      "indent": 0,
      "text": "7.1. Server Exports",
      "section_title": true,
      "ja": "7.1. サーバーエクスポート"
    },
    {
      "indent": 3,
      "text": "On a UNIX server the name space describes all the files reachable by pathnames under the root directory or \"/\". On a Windows NT server the name space constitutes all the files on disks named by mapped disk letters. NFS server administrators rarely make the entire server's file system name space available to NFS clients. More often portions of the name space are made available via an \"export\" feature. In previous versions of the NFS protocol, the root filehandle for each export is obtained through the MOUNT protocol; the client sends a string that identifies the export of name space and the server returns the root filehandle for it. The MOUNT protocol supports an EXPORTS procedure that will enumerate the server's exports.",
      "ja": "UNIXサーバーでは、名前空間は、ルートディレクトリまたは「/」の下のPathNamesによって到達可能なすべてのファイルを記述します。Windows NTサーバーでは、名前スペースは、マッピングされたディスク文字によって名前が付けられたディスク上のすべてのファイルを構成します。NFSサーバーの管理者は、サーバーのファイルシステム名をNFSクライアントが利用できるようにすることはめったにありません。多くの場合、「エクスポート」機能を介して名前スペースの一部が利用可能になります。NFSプロトコルの以前のバージョンでは、各エクスポートのルートファイルハンドルがマウントプロトコルを介して取得されます。クライアントは、名前空間のエクスポートを識別する文字列を送信し、サーバーはルートファイルハンドルを返します。マウントプロトコルは、サーバーのエクスポートを列挙するエクスポート手順をサポートしています。"
    },
    {
      "indent": 0,
      "text": "7.2. Browsing Exports",
      "section_title": true,
      "ja": "7.2. ブラウジングエクスポート"
    },
    {
      "indent": 3,
      "text": "The NFS version 4 protocol provides a root filehandle that clients can use to obtain filehandles for these exports via a multi-component LOOKUP. A common user experience is to use a graphical user interface (perhaps a file \"Open\" dialog window) to find a file via progressive browsing through a directory tree. The client must be able to move from one export to another export via single-component, progressive LOOKUP operations.",
      "ja": "NFSバージョン4プロトコルは、マルチコンポーネントルックアップを介してこれらのエクスポートのファイルハンドルを取得するためにクライアントが使用できるルートファイルハンドルを提供します。一般的なユーザーエクスペリエンスは、グラフィカルユーザーインターフェイス（おそらく「開く」ダイアログウィンドウ）を使用して、ディレクトリツリーを介したプログレッシブブラウジングを介してファイルを見つけることです。クライアントは、あるコンポーネントのプログレッシブルックアップ操作を介して、あるエクスポートから別のエクスポートに移動できる必要があります。"
    },
    {
      "indent": 3,
      "text": "This style of browsing is not well supported by the NFS version 2 and 3 protocols. The client expects all LOOKUP operations to remain within a single server file system. For example, the device attribute will not change. This prevents a client from taking name space paths that span exports.",
      "ja": "このスタイルのブラウジングは、NFSバージョン2および3プロトコルでは十分にサポートされていません。クライアントは、すべてのルックアップ操作が単一のサーバーファイルシステム内にとどまることを期待しています。たとえば、デバイス属性は変更されません。これにより、クライアントがエクスポートにまたがる名前のスペースパスを取得することができなくなります。"
    },
    {
      "indent": 3,
      "text": "An automounter on the client can obtain a snapshot of the server's name space using the EXPORTS procedure of the MOUNT protocol. If it understands the server's pathname syntax, it can create an image of the server's name space on the client. The parts of the name space that are not exported by the server are filled in with a \"pseudo file system\" that allows the user to browse from one mounted file system to another. There is a drawback to this representation of the server's name space on the client: it is static. If the server administrator adds a new export the client will be unaware of it.",
      "ja": "クライアントの自動車は、マウントプロトコルのエクスポート手順を使用して、サーバーの名前空間のスナップショットを取得できます。サーバーのPathname構文を理解している場合、クライアントにサーバーの名前スペースの画像を作成できます。サーバーによってエクスポートされていない名前スペースの部分には、ユーザーがマウントされたファイルシステムから別のファイルシステムに閲覧できる「擬似ファイルシステム」が入力されます。クライアント上のサーバーの名前空間を表現するには欠点があります。それは静的です。サーバー管理者が新しいエクスポートを追加した場合、クライアントはそれを認識しません。"
    },
    {
      "indent": 0,
      "text": "7.3. Server Pseudo File System",
      "section_title": true,
      "ja": "7.3. サーバー擬似ファイルシステム"
    },
    {
      "indent": 3,
      "text": "NFS version 4 servers avoid this name space inconsistency by presenting all the exports within the framework of a single server name space. An NFS version 4 client uses LOOKUP and READDIR operations to browse seamlessly from one export to another. Portions of the server name space that are not exported are bridged via a \"pseudo file system\" that provides a view of exported directories only. A pseudo file system has a unique fsid and behaves like a normal, read only file system.",
      "ja": "NFSバージョン4サーバーは、単一のサーバー名スペースのフレームワーク内ですべてのエクスポートを提示することにより、この名前のスペースの矛盾を回避します。NFSバージョン4クライアントは、ルックアップおよびReadDir操作を使用して、あるエクスポートから別のエクスポートにシームレスに閲覧します。エクスポートされていないサーバー名スペースの一部は、エクスポートされたディレクトリのみのビューを提供する「擬似ファイルシステム」を介して橋渡しされます。擬似ファイルシステムには一意のFSIDがあり、通常の読み取り専用ファイルシステムのように動作します。"
    },
    {
      "indent": 3,
      "text": "Based on the construction of the server's name space, it is possible that multiple pseudo file systems may exist. For example,",
      "ja": "サーバーの名前スペースの構築に基づいて、複数の擬似ファイルシステムが存在する可能性があります。例えば、"
    },
    {
      "indent": 3,
      "text": "/a         pseudo file system\n/a/b       real file system\n/a/b/c     pseudo file system\n/a/b/c/d   real file system",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each of the pseudo file systems are consider separate entities and therefore will have a unique fsid.",
      "ja": "各擬似ファイルシステムは別々のエンティティを考慮しているため、一意のFSIDがあります。"
    },
    {
      "indent": 0,
      "text": "7.4. Multiple Roots",
      "section_title": true,
      "ja": "7.4. 複数の根"
    },
    {
      "indent": 3,
      "text": "The DOS and Windows operating environments are sometimes described as having \"multiple roots\". File systems are commonly represented as disk letters. MacOS represents file systems as top level names. NFS version 4 servers for these platforms can construct a pseudo file system above these root names so that disk letters or volume names are simply directory names in the pseudo root.",
      "ja": "DOSおよびWindowsの動作環境は、「複数の根」を持つと説明されることがあります。ファイルシステムは一般にディスク文字として表されます。MacOSは、ファイルシステムをトップレベルの名前として表します。これらのプラットフォーム用のNFSバージョン4サーバーは、これらのルート名の上に擬似ファイルシステムを構築できるため、ディスク文字またはボリューム名は擬似ルートの単純なディレクトリ名になります。"
    },
    {
      "indent": 0,
      "text": "7.5. Filehandle Volatility",
      "section_title": true,
      "ja": "7.5. ファイルハンドルのボラティリティ"
    },
    {
      "indent": 3,
      "text": "The nature of the server's pseudo file system is that it is a logical representation of file system(s) available from the server. Therefore, the pseudo file system is most likely constructed dynamically when the server is first instantiated. It is expected that the pseudo file system may not have an on disk counterpart from which persistent filehandles could be constructed. Even though it is preferable that the server provide persistent filehandles for the pseudo file system, the NFS client should expect that pseudo file system filehandles are volatile. This can be confirmed by checking the associated \"fh_expire_type\" attribute for those filehandles in question. If the filehandles are volatile, the NFS client must be prepared to recover a filehandle value (e.g. with a multi-component LOOKUP) when receiving an error of NFS4ERR_FHEXPIRED.",
      "ja": "サーバーの擬似ファイルシステムの性質は、サーバーから利用可能なファイルシステムの論理的な表現であることです。したがって、擬似ファイルシステムは、サーバーが最初にインスタンス化されたときに動的に構築される可能性が最も高くなります。Pseudoファイルシステムには、永続的なファイルハンドルを構築できるディスクの対応物がない場合があります。サーバーが擬似ファイルシステムに永続的なファイルハンドルを提供することが望ましい場合でも、NFSクライアントは擬似ファイルシステムファイルハンドルが不安定であることを期待する必要があります。これは、問題のファイルハンドルの関連する「FH_EXPIRE_TYPE」属性をチェックすることで確認できます。ファイルハンドルが揮発性の場合、NFS4err_fhexpiredのエラーを受信するときに、NFSクライアントはファイルハンドル値（たとえば、マルチコンポーネントの検索を使用して）を回復するために準備する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.6. Exported Root",
      "section_title": true,
      "ja": "7.6. エクスポートされたルート"
    },
    {
      "indent": 3,
      "text": "If the server's root file system is exported, one might conclude that a pseudo-file system is not needed. This would be wrong. Assume the following file systems on a server:",
      "ja": "サーバーのルートファイルシステムがエクスポートされている場合、擬似ファイルシステムは必要ないと結論付けるかもしれません。これは間違っているでしょう。サーバー上の次のファイルシステムを想定しています。"
    },
    {
      "indent": 12,
      "text": "/       disk1  (exported)\n/a      disk2  (not exported)\n/a/b    disk3  (exported)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Because disk2 is not exported, disk3 cannot be reached with simple LOOKUPs. The server must bridge the gap with a pseudo-file system.",
      "ja": "Disk2はエクスポートされていないため、Disk3に簡単な検索で到達できません。サーバーは、擬似ファイルシステムでギャップを橋渡しする必要があります。"
    },
    {
      "indent": 0,
      "text": "7.7. Mount Point Crossing",
      "section_title": true,
      "ja": "7.7. マウントポイント交差"
    },
    {
      "indent": 3,
      "text": "The server file system environment may be constructed in such a way that one file system contains a directory which is 'covered' or mounted upon by a second file system. For example:",
      "ja": "サーバーファイルシステム環境は、1つのファイルシステムに「カバー」または2番目のファイルシステムによって取り付けられたディレクトリが含まれるように構築される場合があります。例えば："
    },
    {
      "indent": 12,
      "text": "/a/b (file system 1) /a/b/c/d (file system 2)",
      "ja": "/a/b（ファイルシステム1）/a/b/c/d（ファイルシステム2）"
    },
    {
      "indent": 3,
      "text": "The pseudo file system for this server may be constructed to look like:",
      "ja": "このサーバーの擬似ファイルシステムは、次のように見えるように構築される場合があります。"
    },
    {
      "indent": 12,
      "text": "/               (place holder/not exported)\n/a/b            (file system 1)\n/a/b/c/d        (file system 2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "It is the server's responsibility to present the pseudo file system that is complete to the client. If the client sends a lookup request for the path \"/a/b/c/d\", the server's response is the filehandle of the file system \"/a/b/c/d\". In previous versions of the NFS protocol, the server would respond with the directory \"/a/b/c/d\" within the file system \"/a/b\".",
      "ja": "クライアントに完全な擬似ファイルシステムを提示することは、サーバーの責任です。クライアントがパス「/a/b/c/d」のルックアップ要求を送信する場合、サーバーの応答はファイルシステム「/a/b/c/d」のファイルハンドルです。NFSプロトコルの以前のバージョンでは、サーバーはディレクトリ「/a/b/c/d」でファイルシステム「/a/b」内で応答します。"
    },
    {
      "indent": 3,
      "text": "The NFS client will be able to determine if it crosses a server mount point by a change in the value of the \"fsid\" attribute.",
      "ja": "NFSクライアントは、「FSID」属性の値の変更によってサーバーマウントポイントを横断するかどうかを判断できます。"
    },
    {
      "indent": 0,
      "text": "7.8. Security Policy and Name Space Presentation",
      "section_title": true,
      "ja": "7.8. セキュリティポリシーと名前スペースのプレゼンテーション"
    },
    {
      "indent": 3,
      "text": "The application of the server's security policy needs to be carefully considered by the implementor. One may choose to limit the viewability of portions of the pseudo file system based on the server's perception of the client's ability to authenticate itself properly. However, with the support of multiple security mechanisms and the ability to negotiate the appropriate use of these mechanisms, the server is unable to properly determine if a client will be able to authenticate itself. If, based on its policies, the server chooses to limit the contents of the pseudo file system, the server may effectively hide file systems from a client that may otherwise have legitimate access.",
      "ja": "サーバーのセキュリティポリシーの適用は、実装者が慎重に検討する必要があります。クライアントが適切に認証する能力に対するサーバーの認識に基づいて、擬似ファイルシステムの一部の視界を制限することを選択できます。ただし、複数のセキュリティメカニズムのサポートとこれらのメカニズムの適切な使用をネゴシエートする能力により、サーバーはクライアントが自分自身を認証できるかどうかを適切に判断できません。ポリシーに基づいて、サーバーが擬似ファイルシステムの内容を制限することを選択した場合、サーバーは、そうでなければ正当なアクセスを持つ可能性のあるクライアントからファイルシステムを効果的に非表示にすることができます。"
    },
    {
      "indent": 0,
      "text": "8. File Locking and Share Reservations",
      "section_title": true,
      "ja": "8. ファイルロックと予約を共有します"
    },
    {
      "indent": 3,
      "text": "Integrating locking into the NFS protocol necessarily causes it to be state-full. With the inclusion of \"share\" file locks the protocol becomes substantially more dependent on state than the traditional combination of NFS and NLM [XNFS]. There are three components to making this state manageable:",
      "ja": "NFSプロトコルにロックすることを統合すると、必然的にそれが完全に完全になります。「共有」ファイルロックを含めると、プロトコルは、NFSとNLM [XNFS]の従来の組み合わせよりも、状態に大きく依存するようになります。この状態を管理可能にするための3つのコンポーネントがあります。"
    },
    {
      "indent": 3,
      "text": "o Clear division between client and server",
      "ja": "o クライアントとサーバーの間の明確な分割"
    },
    {
      "indent": 3,
      "text": "o Ability to reliably detect inconsistency in state between client and server",
      "ja": "o クライアントとサーバーの間の状態の矛盾を確実に検出する能力"
    },
    {
      "indent": 3,
      "text": "o Simple and robust recovery mechanisms In this model, the server owns the state information. The client communicates its view of this state to the server as needed. The client is also able to detect inconsistent state before modifying a file.",
      "ja": "o シンプルで堅牢な回復メカニズムこのモデルでは、サーバーは状態情報を所有しています。クライアントは、必要に応じてこの状態のビューをサーバーに伝えます。クライアントは、ファイルを変更する前に一貫性のない状態を検出することもできます。"
    },
    {
      "indent": 3,
      "text": "To support Win32 \"share\" locks it is necessary to atomically OPEN or CREATE files. Having a separate share/unshare operation would not allow correct implementation of the Win32 OpenFile API. In order to correctly implement share semantics, the previous NFS protocol mechanisms used when a file is opened or created (LOOKUP, CREATE, ACCESS) need to be replaced. The NFS version 4 protocol has an OPEN operation that subsumes the functionality of LOOKUP, CREATE, and ACCESS. However, because many operations require a filehandle, the traditional LOOKUP is preserved to map a file name to filehandle without establishing state on the server. The policy of granting access or modifying files is managed by the server based on the client's state. These mechanisms can implement policy ranging from advisory only locking to full mandatory locking.",
      "ja": "Win32 \"Share\"ロックをサポートするには、原子的にファイルを開いたり作成したりする必要があります。個別の共有/非シェア操作を持つことで、Win32 OpenFile APIの正しい実装は許可されません。共有セマンティクスを正しく実装するには、ファイルが開かれたり作成されたときに使用された以前のNFSプロトコルメカニズム（ルックアップ、作成、アクセス）を交換する必要があります。NFSバージョン4プロトコルには、ルックアップ、作成、アクセスの機能を包含するオープン操作があります。ただし、多くの操作にはファイルハンドルが必要なため、従来のルックアップが保存され、ファイル名をサーバー上に状態を確立せずにファイルハンドルにマッピングします。アクセスを許可またはファイルを変更するというポリシーは、クライアントの状態に基づいてサーバーによって管理されます。これらのメカニズムは、アドバイザリーロックのみから完全な強制ロックまでの範囲のポリシーを実装できます。"
    },
    {
      "indent": 0,
      "text": "8.1. Locking",
      "section_title": true,
      "ja": "8.1. ロック"
    },
    {
      "indent": 3,
      "text": "It is assumed that manipulating a lock is rare when compared to READ and WRITE operations. It is also assumed that crashes and network partitions are relatively rare. Therefore it is important that the READ and WRITE operations have a lightweight mechanism to indicate if they possess a held lock. A lock request contains the heavyweight information required to establish a lock and uniquely define the lock owner.",
      "ja": "読み取りおよび書き込み操作と比較すると、ロックを操作することはまれであると想定されています。また、クラッシュとネットワークパーティションは比較的まれであると想定されています。したがって、読み取りおよび書き込み操作には、保持されたロックを持っているかどうかを示すための軽量メカニズムがあることが重要です。ロックリクエストには、ロックを確立し、ロック所有者を一意に定義するために必要なヘビー級情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "The following sections describe the transition from the heavy weight information to the eventual stateid used for most client and server locking and lease interactions.",
      "ja": "次のセクションでは、重量情報からほとんどのクライアントおよびサーバーのロックおよびリースインタラクションに使用される最終的なStateIDへの移行について説明します。"
    },
    {
      "indent": 0,
      "text": "8.1.1. Client ID",
      "section_title": true,
      "ja": "8.1.1. クライアントID"
    },
    {
      "indent": 3,
      "text": "For each LOCK request, the client must identify itself to the server.",
      "ja": "各ロックリクエストについて、クライアントはサーバーに自分自身を識別する必要があります。"
    },
    {
      "indent": 3,
      "text": "This is done in such a way as to allow for correct lock identification and crash recovery. Client identification is accomplished with two values.",
      "ja": "これは、正しいロックの識別とクラッシュの回復を可能にするような方法で行われます。クライアントの識別は、2つの値で達成されます。"
    },
    {
      "indent": 3,
      "text": "o A verifier that is used to detect client reboots.",
      "ja": "o クライアントの再起動を検出するために使用される検証剤。"
    },
    {
      "indent": 3,
      "text": "o A variable length opaque array to uniquely define a client.",
      "ja": "o クライアントを一意に定義するための可変長さの不透明な配列。"
    },
    {
      "indent": 9,
      "text": "For an operating system this may be a fully qualified host name or IP address. For a user level NFS client it may additionally contain a process id or other unique sequence.",
      "ja": "オペレーティングシステムの場合、これは完全に資格のあるホスト名またはIPアドレスかもしれません。ユーザーレベルのNFSクライアントの場合、プロセスIDまたはその他の一意のシーケンスがさらに含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "The data structure for the Client ID would then appear as:",
      "ja": "クライアントIDのデータ構造は次のように表示されます。"
    },
    {
      "indent": 12,
      "text": "struct nfs_client_id {\n        opaque verifier[4];\n        opaque id<>;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "It is possible through the mis-configuration of a client or the existence of a rogue client that two clients end up using the same nfs_client_id. This situation is avoided by \"negotiating\" the nfs_client_id between client and server with the use of the SETCLIENTID and SETCLIENTID_CONFIRM operations. The following describes the two scenarios of negotiation.",
      "ja": "クライアントの間違った構成または不正なクライアントの存在により、2人のクライアントが同じNFS_CLIENT_IDを使用することが可能です。この状況は、SetClientIDおよびSetClientID_CONFIRMオペレーションを使用して、クライアントとサーバーの間のNFS_CLIENT_IDを「ネゴシエート」することで回避されます。以下は、交渉の2つのシナリオを説明しています。"
    },
    {
      "indent": 3,
      "text": "1 Client has never connected to the server",
      "ja": "1クライアントがサーバーに接続したことはありません"
    },
    {
      "indent": 6,
      "text": "In this case the client generates an nfs_client_id and unless another client has the same nfs_client_id.id field, the server accepts the request. The server also records the principal (or principal to uid mapping) from the credential in the RPC request that contains the nfs_client_id negotiation request (SETCLIENTID operation).",
      "ja": "この場合、クライアントはNFS_CLIENT_IDを生成し、別のクライアントが同じNFS_CLIENT_ID.IDフィールドを持っている場合を除き、サーバーはリクエストを受け入れます。また、サーバーは、NFS_CLIENT_IDネゴシエーションリクエスト（SETCLIENTID操作）を含むRPCリクエストの資格情報からプリンシパル（またはUIDマッピングのプリンシパルマッピング）を記録します。"
    },
    {
      "indent": 6,
      "text": "Two clients might still use the same nfs_client_id.id due to perhaps configuration error. For example, a High Availability configuration where the nfs_client_id.id is derived from the ethernet controller address and both systems have the same address. In this case, the result is a switched union that returns, in addition to NFS4ERR_CLID_INUSE, the network address (the rpcbind netid and universal address) of the client that is using the id.",
      "ja": "おそらく構成エラーのため、2つのクライアントが同じNFS_CLIENT_ID.IDを使用する場合があります。たとえば、NFS_CLIENT_ID.IDがイーサネットコントローラーアドレスから派生し、両方のシステムが同じアドレスを持っている高可用性構成です。この場合、結果は、IDを使用しているクライアントのネットワークアドレス（RPCBind NetIDおよびUniversalアドレス）に加えて、NFS4ERR_CLID_INUSEに加えて、戻ってくる切り替えの組合です。"
    },
    {
      "indent": 3,
      "text": "2 Client is re-connecting to the server after a client reboot",
      "ja": "2クライアントがクライアントの再起動後にサーバーに再接続しています"
    },
    {
      "indent": 6,
      "text": "In this case, the client still generates an nfs_client_id but the nfs_client_id.id field will be the same as the nfs_client_id.id generated prior to reboot. If the server finds that the principal/uid is equal to the previously \"registered\" nfs_client_id.id, then locks associated with the old nfs_client_id are immediately released. If the principal/uid is not equal, then this is a rogue client and the request is returned in error. For more discussion of crash recovery semantics, see the section on \"Crash Recovery\".",
      "ja": "この場合、クライアントは依然としてNFS_CLIENT_IDを生成しますが、NFS_CLIENT_ID.IDフィールドは、再起動前に生成されたNFS_CLIENT_ID.IDと同じです。サーバーがプリンシパル/UIDが以前に「登録された」NFS_CLIENT_ID.IDに等しいことを発見した場合、古いNFS_CLIENT_IDに関連付けられたロックがすぐにリリースされます。プリンシパル/UIDが等しくない場合、これは不正なクライアントであり、リクエストが誤って返されます。クラッシュ回復セマンティクスの詳細については、「クラッシュリカバリー」のセクションを参照してください。"
    },
    {
      "indent": 6,
      "text": "It is possible for a retransmission of request to be received by the server after the server has acted upon and responded to the original client request. Therefore to mitigate effects of the retransmission of the SETCLIENTID operation, the client and server use a confirmation step. The server returns a confirmation verifier that the client then sends to the server in the SETCLIENTID_CONFIRM operation. Once the server receives the confirmation from the client, the locking state for the client is released.",
      "ja": "サーバーが行動し、元のクライアントリクエストに応答した後、サーバーがリクエストの再送信をサーバーが受信することが可能です。したがって、SetClientID操作の再送信の効果を軽減するために、クライアントとサーバーは確認ステップを使用します。サーバーは、クライアントがSetClientID_CONFIRM操作でサーバーに送信する確認検証剤を返します。サーバーがクライアントから確認を受信すると、クライアントのロック状態がリリースされます。"
    },
    {
      "indent": 3,
      "text": "In both cases, upon success, NFS4_OK is returned. To help reduce the amount of data transferred on OPEN and LOCK, the server will also return a unique 64-bit clientid value that is a shorthand reference to the nfs_client_id values presented by the client. From this point forward, the client will use the clientid to refer to itself.",
      "ja": "どちらの場合も、成功すると、NFS4_OKが返されます。Open and Lockで転送されるデータの量を減らすために、サーバーは、クライアントが提示するNFS_CLIENT_ID値への速記である一意の64ビットClientID値を返します。この時点から、クライアントはClientIDを使用して自分自身を参照します。"
    },
    {
      "indent": 3,
      "text": "The clientid assigned by the server should be chosen so that it will not conflict with a clientid previously assigned by the server. This applies across server restarts or reboots. When a clientid is presented to a server and that clientid is not recognized, as would happen after a server reboot, the server will reject the request with the error NFS4ERR_STALE_CLIENTID. When this happens, the client must obtain a new clientid by use of the SETCLIENTID operation and then proceed to any other necessary recovery for the server reboot case (See the section \"Server Failure and Recovery\").",
      "ja": "サーバーによって割り当てられたclientIDは、以前にサーバーによって割り当てられたClientIDと競合しないように選択する必要があります。これは、サーバーの再起動または再起動に適用されます。サーバーの再起動後に発生するように、clientIDがサーバーに提示され、そのclientIDが認識されない場合、サーバーはエラーnfs4err_stale_clientidでリクエストを拒否します。これが発生した場合、クライアントはSetClientID操作を使用して新しいClientIDを取得し、サーバーの再起動ケースに他の必要な回復に進む必要があります（セクション「サーバーの障害と回復」を参照）。"
    },
    {
      "indent": 3,
      "text": "The client must also employ the SETCLIENTID operation when it receives a NFS4ERR_STALE_STATEID error using a stateid derived from its current clientid, since this also indicates a server reboot which has invalidated the existing clientid (see the next section \"nfs_lockowner and stateid Definition\" for details).",
      "ja": "クライアントは、現在のClientIDから派生したStateIDを使用してNFS4err_Stale_StateIDエラーを受信したときにSetClientID操作を使用する必要があります。。"
    },
    {
      "indent": 0,
      "text": "8.1.2. Server Release of Clientid",
      "section_title": true,
      "ja": "8.1.2. clientIDのサーバーリリース"
    },
    {
      "indent": 3,
      "text": "If the server determines that the client holds no associated state for its clientid, the server may choose to release the clientid. The server may make this choice for an inactive client so that resources are not consumed by those intermittently active clients. If the client contacts the server after this release, the server must ensure the client receives the appropriate error so that it will use the SETCLIENTID/SETCLIENTID_CONFIRM sequence to establish a new identity. It should be clear that the server must be very hesitant to release a clientid since the resulting work on the client to recover from such an event will be the same burden as if the server had failed and restarted. Typically a server would not release a clientid unless there had been no activity from that client for many minutes.",
      "ja": "クライアントがClientIDの関連状態を保持していないことをサーバーが判断した場合、サーバーはClientIDをリリースすることを選択できます。サーバーは、断続的にアクティブなクライアントによってリソースが消費されないように、非アクティブなクライアントにこの選択をする場合があります。クライアントがこのリリース後にサーバーに連絡した場合、サーバーはクライアントが適切なエラーを受信して、SetClientID/setClientID_CONFIRMシーケンスを使用して新しいIDを確立する必要があります。そのようなイベントから回復するためにクライアントの結果として得られた作業は、サーバーが故障して再起動した場合と同じ負担になるため、サーバーがクライアントIDをリリースすることを非常にためらわなければならないことは明らかです。通常、サーバーは、そのクライアントから何分間もアクティビティがなかった限り、ClientIDをリリースしません。"
    },
    {
      "indent": 0,
      "text": "8.1.3. nfs_lockowner and stateid Definition",
      "section_title": true,
      "ja": "8.1.3. NFS_LOCKOWNERおよびSTATEID定義"
    },
    {
      "indent": 3,
      "text": "When requesting a lock, the client must present to the server the clientid and an identifier for the owner of the requested lock. These two fields are referred to as the nfs_lockowner and the definition of those fields are:",
      "ja": "ロックを要求するとき、クライアントは、要求されたロックの所有者のclientidと識別子をサーバーに提示する必要があります。これらの2つのフィールドはNFS_Lockownerと呼ばれ、それらのフィールドの定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o A clientid returned by the server as part of the client's use of the SETCLIENTID operation.",
      "ja": "o クライアントがSetClientID操作をクライアントの使用の一部としてサーバーによって返したClientID。"
    },
    {
      "indent": 3,
      "text": "o A variable length opaque array used to uniquely define the owner of a lock managed by the client.",
      "ja": "o クライアントが管理するロックの所有者を一意に定義するために使用される可変長さの不透明なアレイ。"
    },
    {
      "indent": 9,
      "text": "This may be a thread id, process id, or other unique value.",
      "ja": "これは、スレッドID、プロセスID、またはその他の一意の値です。"
    },
    {
      "indent": 3,
      "text": "When the server grants the lock, it responds with a unique 64-bit stateid. The stateid is used as a shorthand reference to the nfs_lockowner, since the server will be maintaining the correspondence between them.",
      "ja": "サーバーがロックを付与すると、ユニークな64ビットSTATEIDで応答します。StateIDは、サーバーがそれらの間の対応を維持するため、NFS_Lockownerへの速記として使用されます。"
    },
    {
      "indent": 3,
      "text": "The server is free to form the stateid in any manner that it chooses as long as it is able to recognize invalid and out-of-date stateids. This requirement includes those stateids generated by earlier instances of the server. From this, the client can be properly notified of a server restart. This notification will occur when the client presents a stateid to the server from a previous instantiation.",
      "ja": "サーバーは、無効で時代遅れのStateIDSを認識できる限り、選択するいかなる方法でもStateIDを自由に形成できます。この要件には、サーバーの以前のインスタンスによって生成されたSTATEIDが含まれます。これから、クライアントにサーバーの再起動を適切に通知できます。この通知は、クライアントが以前のインスタンスからStateIDをサーバーに提示するときに発生します。"
    },
    {
      "indent": 3,
      "text": "The server must be able to distinguish the following situations and return the error as specified:",
      "ja": "サーバーは、次の状況を区別し、指定されたエラーを返すことができる必要があります。"
    },
    {
      "indent": 3,
      "text": "o The stateid was generated by an earlier server instance (i.e. before a server reboot). The error NFS4ERR_STALE_STATEID should be returned.",
      "ja": "o StateIDは、以前のサーバーインスタンスによって（つまり、サーバーの再起動の前）に生成されました。エラーnfs4err_stale_stateidを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "o The stateid was generated by the current server instance but the stateid no longer designates the current locking state for the lockowner-file pair in question (i.e. one or more locking operations has occurred). The error NFS4ERR_OLD_STATEID should be returned.",
      "ja": "o StateIDは現在のサーバーインスタンスによって生成されましたが、StateIDは、問題のLockowner-Fileペアの現在のロック状態を指定しなくなりました（つまり、1つ以上のロック操作が発生しました）。エラーnfs4err_old_stateidを返す必要があります。"
    },
    {
      "indent": 6,
      "text": "This error condition will only occur when the client issues a locking request which changes a stateid while an I/O request that uses that stateid is outstanding.",
      "ja": "このエラー条件は、クライアントがSTATEIDを変更するロック要求を発行し、そのStateIDが未解決のI/O要求である場合にのみ発生します。"
    },
    {
      "indent": 3,
      "text": "o The stateid was generated by the current server instance but the stateid does not designate a locking state for any active lockowner-file pair. The error NFS4ERR_BAD_STATEID should be returned.",
      "ja": "o StateIDは現在のサーバーインスタンスによって生成されましたが、StateIDはアクティブロックオーナーファイルペアのロック状態を指定していません。エラーnfs4err_bad_stateidを返す必要があります。"
    },
    {
      "indent": 6,
      "text": "This error condition will occur when there has been a logic error on the part of the client or server. This should not happen.",
      "ja": "このエラー状態は、クライアントまたはサーバーの側面にロジックエラーがあった場合に発生します。これは起こらないはずです。"
    },
    {
      "indent": 3,
      "text": "One mechanism that may be used to satisfy these requirements is for the server to divide stateids into three fields:",
      "ja": "これらの要件を満たすために使用される可能性のあるメカニズムの1つは、サーバーがStateIDを3つのフィールドに分割することです。"
    },
    {
      "indent": 3,
      "text": "o A server verifier which uniquely designates a particular server instantiation.",
      "ja": "o 特定のサーバーのインスタンス化を一意に指定するサーバー検証器。"
    },
    {
      "indent": 3,
      "text": "o An index into a table of locking-state structures.",
      "ja": "o ロック状態構造のテーブルへのインデックス。"
    },
    {
      "indent": 3,
      "text": "o A sequence value which is incremented for each stateid that is associated with the same index into the locking-state table.",
      "ja": "o 同じインデックスに関連付けられている各StateIDに対して、ロック状態テーブルに関連付けられているシーケンス値。"
    },
    {
      "indent": 3,
      "text": "By matching the incoming stateid and its field values with the state held at the server, the server is able to easily determine if a stateid is valid for its current instantiation and state. If the stateid is not valid, the appropriate error can be supplied to the client.",
      "ja": "着信StateIDとそのフィールド値をサーバーに保持している状態と一致させることにより、サーバーは、StateIDが現在のインスタンス化と状態に対して有効であるかどうかを簡単に判断できます。StateIDが有効でない場合、適切なエラーをクライアントに提供できます。"
    },
    {
      "indent": 0,
      "text": "8.1.4. Use of the stateid",
      "section_title": true,
      "ja": "8.1.4. STATEIDの使用"
    },
    {
      "indent": 3,
      "text": "All READ and WRITE operations contain a stateid. If the nfs_lockowner performs a READ or WRITE on a range of bytes within a locked range, the stateid (previously returned by the server) must be used to indicate that the appropriate lock (record or share) is held. If no state is established by the client, either record lock or share lock, a stateid of all bits 0 is used. If no conflicting locks are held on the file, the server may service the READ or WRITE operation. If a conflict with an explicit lock occurs, an error is returned for the operation (NFS4ERR_LOCKED). This allows \"mandatory locking\" to be implemented.",
      "ja": "すべての読み取りおよび書き込み操作にはStateIDが含まれています。NFS_Lockownerがロックされた範囲内のさまざまなバイトで読み取りまたは書き込みを実行する場合、STATEID（以前はサーバーによって返された）を使用して、適切なロック（レコードまたは共有）が保持されていることを示す必要があります。クライアント、レコードロックまたは共有ロックのいずれかの状態が確立されていない場合、すべてのビット0のStateIDが使用されます。ファイルに競合するロックが保持されていない場合、サーバーは読み取りまたは書き込み操作にサービスを提供する場合があります。明示的なロックとの競合が発生した場合、操作のエラーが返されます（nfs4err_locked）。これにより、「必須ロック」を実装できます。"
    },
    {
      "indent": 3,
      "text": "A stateid of all bits 1 (one) allows READ operations to bypass record locking checks at the server. However, WRITE operations with stateid with bits all 1 (one) do not bypass record locking checks. File locking checks are handled by the OPEN operation (see the section \"OPEN/CLOSE Operations\").",
      "ja": "すべてのビット1（1）のStateIDを使用すると、操作を読み取り、サーバーでのレコードロックチェックをバイパスすることができます。ただし、1（1）すべてのビットでStateIDを使用して操作を書き込み、レコードロックチェックをバイパスしません。ファイルロックチェックは、オープン操作によって処理されます（セクション「オープン/クローズ操作」を参照）。"
    },
    {
      "indent": 3,
      "text": "An explicit lock may not be granted while a READ or WRITE operation with conflicting implicit locking is being performed.",
      "ja": "矛盾する暗黙のロックを伴う読み取りまたは書き込み操作が実行されている間、明示的なロックは許可されない場合があります。"
    },
    {
      "indent": 0,
      "text": "8.1.5. Sequencing of Lock Requests",
      "section_title": true,
      "ja": "8.1.5. ロック要求のシーケンス"
    },
    {
      "indent": 3,
      "text": "Locking is different than most NFS operations as it requires \"at-most-one\" semantics that are not provided by ONCRPC. ONCRPC over a reliable transport is not sufficient because a sequence of locking requests may span multiple TCP connections. In the face of retransmission or reordering, lock or unlock requests must have a well defined and consistent behavior. To accomplish this, each lock request contains a sequence number that is a consecutively increasing integer. Different nfs_lockowners have different sequences. The server maintains the last sequence number (L) received and the response that was returned.",
      "ja": "ロックは、ONCRPCによって提供されていない「最大1つの」セマンティクスを必要とするため、ほとんどのNFS操作とは異なります。ロック要求のシーケンスが複数のTCP接続に及ぶ可能性があるため、信頼できる輸送を介したONCRPCでは十分ではありません。再送信または並べ替えに直面して、リクエストには、明確に定義された一貫した動作が必要です。これを達成するために、各ロック要求には、連続して整数が増加するシーケンス番号が含まれています。異なるNFS_Lockownersには、シーケンスが異なります。サーバーは、受信した最後のシーケンス番号（L）と返された応答を維持します。"
    },
    {
      "indent": 3,
      "text": "Note that for requests that contain a sequence number, for each nfs_lockowner, there should be no more than one outstanding request.",
      "ja": "NFS_Lockownerごとに、シーケンス番号を含むリクエストには、1つの未解決のリクエストが必要であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "If a request with a previous sequence number (r < L) is received, it is rejected with the return of error NFS4ERR_BAD_SEQID. Given a properly-functioning client, the response to (r) must have been received before the last request (L) was sent. If a duplicate of last request (r == L) is received, the stored response is returned. If a request beyond the next sequence (r == L + 2) is received, it is rejected with the return of error NFS4ERR_BAD_SEQID. Sequence history is reinitialized whenever the client verifier changes.",
      "ja": "以前のシーケンス番号（r <l）のリクエストが受信された場合、エラーnfs4err_bad_seqidの戻りで拒否されます。適切に機能しているクライアントが与えられた場合、（r）への応答は、最後のリクエスト（l）が送信される前に受信されている必要があります。最後の要求（r == L）の複製が受信されると、保存された応答が返されます。次のシーケンスを超えた要求（r == l 2）を受信した場合、エラーnfs4err_bad_seqidの返されて拒否されます。シーケンス履歴は、クライアント検証器が変更されるたびに再活性化されます。"
    },
    {
      "indent": 3,
      "text": "Since the sequence number is represented with an unsigned 32-bit integer, the arithmetic involved with the sequence number is mod 2^32.",
      "ja": "シーケンス番号は署名されていない32ビット整数で表されるため、シーケンス番号に関与する算術はmod 2^32です。"
    },
    {
      "indent": 3,
      "text": "It is critical the server maintain the last response sent to the client to provide a more reliable cache of duplicate non-idempotent requests than that of the traditional cache described in [Juszczak]. The traditional duplicate request cache uses a least recently used algorithm for removing unneeded requests. However, the last lock request and response on a given nfs_lockowner must be cached as long as the lock state exists on the server.",
      "ja": "サーバーがクライアントに送信された最後の応答を維持し、[Juszczak]に記載されている従来のキャッシュのそれよりも、重複していない非主体要求のより信頼性の高いキャッシュを提供することが重要です。従来の重複リクエストキャッシュは、最近使用されていないアルゴリズムを使用して、不要な要求を削除します。ただし、特定のNFS_Lockownerの最後のロック要求と応答は、サーバーにロック状態が存在する限り、キャッシュする必要があります。"
    },
    {
      "indent": 0,
      "text": "8.1.6. Recovery from Replayed Requests",
      "section_title": true,
      "ja": "8.1.6. 再生されたリクエストからの回復"
    },
    {
      "indent": 3,
      "text": "As described above, the sequence number is per nfs_lockowner. As long as the server maintains the last sequence number received and follows the methods described above, there are no risks of a Byzantine router re-sending old requests. The server need only maintain the nfs_lockowner, sequence number state as long as there are open files or closed files with locks outstanding.",
      "ja": "上記のように、シーケンス番号はNFS_Lockownerごとにあります。サーバーが受信した最後のシーケンス番号を維持し、上記の方法に従う限り、ビザンチンのルーターが古いリクエストを再配置するリスクはありません。サーバーは、開いているファイルまたはロックが顕著な閉じたファイルがある限り、NFS_Lockowner、Secence番号状態のみを維持する必要があります。"
    },
    {
      "indent": 3,
      "text": "LOCK, LOCKU, OPEN, OPEN_DOWNGRADE, and CLOSE each contain a sequence number and therefore the risk of the replay of these operations resulting in undesired effects is non-existent while the server maintains the nfs_lockowner state.",
      "ja": "Lock、Locku、Open、Open_DownGrade、およびCloseはそれぞれシーケンス番号を含むため、これらの操作のリプレイのリスクは、サーバーがNFS_Lockowner状態を維持している間、望ましくない効果をもたらすリスクが存在しません。"
    },
    {
      "indent": 0,
      "text": "8.1.7. Releasing nfs_lockowner State",
      "section_title": true,
      "ja": "8.1.7. NFS_Lockowner状態のリリース"
    },
    {
      "indent": 3,
      "text": "When a particular nfs_lockowner no longer holds open or file locking state at the server, the server may choose to release the sequence number state associated with the nfs_lockowner. The server may make this choice based on lease expiration, for the reclamation of server memory, or other implementation specific details. In any event, the server is able to do this safely only when the nfs_lockowner no longer is being utilized by the client. The server may choose to hold the nfs_lockowner state in the event that retransmitted requests are received. However, the period to hold this state is implementation specific.",
      "ja": "特定のnfs_lockownerがサーバーにオープンまたはファイルロック状態を保持しなくなった場合、サーバーはnfs_lockownerに関連付けられたシーケンス番号状態をリリースすることを選択できます。サーバーは、サーバーメモリの再生、またはその他の実装固有の詳細のために、リースの有効期限に基づいてこの選択を行う場合があります。いずれにせよ、サーバーは、NFS_Lockownerがクライアントによって利用されなくなった場合にのみ、これを安全に行うことができます。サーバーは、再送信されたリクエストが受信された場合にNFS_Lockowner状態を保持することを選択できます。ただし、この状態を保持する期間は実装固有です。"
    },
    {
      "indent": 3,
      "text": "In the case that a LOCK, LOCKU, OPEN_DOWNGRADE, or CLOSE is retransmitted after the server has previously released the nfs_lockowner state, the server will find that the nfs_lockowner has no files open and an error will be returned to the client. If the nfs_lockowner does have a file open, the stateid will not match and again an error is returned to the client.",
      "ja": "サーバーが以前にNFS_Lockowner状態をリリースした後にロック、LockU、Open_DownGrade、またはCloseが再送信される場合、サーバーはNFS_Lockownerにファイルが開いておらず、エラーがクライアントに返されることを発見します。NFS_Lockownerがファイルを開いている場合、StateIDは一致せず、エラーがクライアントに返されます。"
    },
    {
      "indent": 3,
      "text": "In the case that an OPEN is retransmitted and the nfs_lockowner is being used for the first time or the nfs_lockowner state has been previously released by the server, the use of the OPEN_CONFIRM operation will prevent incorrect behavior. When the server observes the use of the nfs_lockowner for the first time, it will direct the client to perform the OPEN_CONFIRM for the corresponding OPEN. This sequence establishes the use of an nfs_lockowner and associated sequence number. See the section \"OPEN_CONFIRM - Confirm Open\" for further details.",
      "ja": "オープンが再送信され、NFS_Lockownerが初めて使用される場合、またはNFS_Lockowner状態が以前にサーバーによってリリースされた場合、Open_Confirm操作の使用は誤った動作を防ぎます。サーバーが初めてnfs_lockownerの使用を観察すると、クライアントに対応するオープンのopen_confirmを実行するよう指示します。このシーケンスは、NFS_Lockownerと関連するシーケンス番号の使用を確立します。詳細については、「open_confirm -confisk open」セクションを参照してください。"
    },
    {
      "indent": 0,
      "text": "8.2. Lock Ranges",
      "section_title": true,
      "ja": "8.2. ロック範囲"
    },
    {
      "indent": 3,
      "text": "The protocol allows a lock owner to request a lock with one byte range and then either upgrade or unlock a sub-range of the initial lock. It is expected that this will be an uncommon type of request. In any case, servers or server file systems may not be able to support sub-range lock semantics. In the event that a server receives a locking request that represents a sub-range of current locking state for the lock owner, the server is allowed to return the error NFS4ERR_LOCK_RANGE to signify that it does not support sub-range lock operations. Therefore, the client should be prepared to receive this error and, if appropriate, report the error to the requesting application.",
      "ja": "このプロトコルにより、ロック所有者は1バイトの範囲のロックを要求し、初期ロックのサブレンジのアップグレードまたはロックを解除できます。これは、珍しいタイプのリクエストになると予想されます。いずれにせよ、サーバーまたはサーバーファイルシステムがサブレンジロックセマンティクスをサポートできない場合があります。サーバーがロック所有者の電流ロック状態のサブレンジを表すロック要求を受信した場合、サーバーはエラーNFS4err_Lock_Rangeを返すことが許可され、サブレンジロック操作をサポートしていないことを示します。したがって、クライアントはこのエラーを受信し、必要に応じて要求アプリケーションにエラーを報告する準備をしている必要があります。"
    },
    {
      "indent": 3,
      "text": "The client is discouraged from combining multiple independent locking ranges that happen to be adjacent into a single request since the server may not support sub-range requests and for reasons related to the recovery of file locking state in the event of server failure. As discussed in the section \"Server Failure and Recovery\" below, the server may employ certain optimizations during recovery that work effectively only when the client's behavior during lock recovery is similar to the client's locking behavior prior to server failure.",
      "ja": "サーバーがサブレンジ要求をサポートしていない可能性があるため、サーバーの障害が発生した場合にファイルロック状態の回復に関連する理由により、クライアントは、たまたま単一の要求に隣接する複数の独立したロック範囲を組み合わせることを妨げられます。以下のセクション「サーバーの障害と回復」で説明したように、サーバーは、ロック回復中のクライアントの動作がサーバーの障害前のクライアントのロック動作に類似している場合にのみ、回復中に特定の最適化を効果的に使用する場合があります。"
    },
    {
      "indent": 0,
      "text": "8.3. Blocking Locks",
      "section_title": true,
      "ja": "8.3. ブロッキングロック"
    },
    {
      "indent": 3,
      "text": "Some clients require the support of blocking locks. The NFS version 4 protocol must not rely on a callback mechanism and therefore is unable to notify a client when a previously denied lock has been granted. Clients have no choice but to continually poll for the lock. This presents a fairness problem. Two new lock types are added, READW and WRITEW, and are used to indicate to the server that the client is requesting a blocking lock. The server should maintain an ordered list of pending blocking locks. When the conflicting lock is released, the server may wait the lease period for the first waiting client to re-request the lock. After the lease period expires the next waiting client request is allowed the lock. Clients are required to poll at an interval sufficiently small that it is likely to acquire the lock in a timely manner. The server is not required to maintain a list of pending blocked locks as it is used to increase fairness and not correct operation. Because of the unordered nature of crash recovery, storing of lock state to stable storage would be required to guarantee ordered granting of blocking locks.",
      "ja": "一部のクライアントは、ブロックロックのサポートを必要とします。NFSバージョン4プロトコルは、コールバックメカニズムに依存してはならないため、以前に拒否されたロックが付与されたときにクライアントに通知することができません。クライアントは、ロックを継続的に投票する以外に選択肢がありません。これは公平な問題を提示します。2つの新しいロックタイプが追加され、readwおよびwritewが追加され、クライアントがブロッキングロックを要求していることをサーバーに示すために使用されます。サーバーは、保留中のブロッキングロックの順序付けられたリストを維持する必要があります。競合するロックがリリースされると、サーバーは、最初の待機クライアントがロックを再クエストするためにリース期間を待つことができます。リース期間が期限切れになった後、次の待機中のクライアントリクエストがロックを許可されます。クライアントは、タイムリーにロックを取得する可能性が高いため、十分に小さい間隔で投票する必要があります。サーバーは、公平性を高め、操作を正しくないために使用されるため、保留中のブロックされたロックのリストを維持する必要はありません。衝突回復の順序付けられていない性質のため、ロック状態を安定したストレージに保管する必要があります。"
    },
    {
      "indent": 3,
      "text": "Servers may also note the lock types and delay returning denial of the request to allow extra time for a conflicting lock to be released, allowing a successful return. In this way, clients can avoid the burden of needlessly frequent polling for blocking locks. The server should take care in the length of delay in the event the client retransmits the request.",
      "ja": "また、サーバーはロックの種類に注意し、競合するロックをリリースするための余分な時間を確保するためにリクエストの拒否を返すことを遅らせ、成功したリターンを可能にすることができます。このようにして、クライアントはロックをブロックするための不必要に頻繁に投票する負担を回避できます。クライアントがリクエストを再送信した場合、サーバーは遅延の長さで注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.4. Lease Renewal",
      "section_title": true,
      "ja": "8.4. リース更新"
    },
    {
      "indent": 3,
      "text": "The purpose of a lease is to allow a server to remove stale locks that are held by a client that has crashed or is otherwise unreachable. It is not a mechanism for cache consistency and lease renewals may not be denied if the lease interval has not expired.",
      "ja": "リースの目的は、サーバーがクラッシュした、または到達不可能なクライアントが保持している古いロックを削除できるようにすることです。これはキャッシュの一貫性のメカニズムではなく、リース間隔が期限切れになっていない場合、リースの更新は拒否されない可能性があります。"
    },
    {
      "indent": 3,
      "text": "The following events cause implicit renewal of all of the leases for a given client (i.e. all those sharing a given clientid). Each of these is a positive indication that the client is still active and that the associated state held at the server, for the client, is still valid.",
      "ja": "以下のイベントは、特定のクライアント（つまり、特定のクライアントを共有するすべての人）のすべてのリースの暗黙的な更新を引き起こします。これらのそれぞれは、クライアントがまだアクティブであり、クライアントにとってサーバーに保持されている関連状態がまだ有効であることを肯定的な兆候であることです。"
    },
    {
      "indent": 3,
      "text": "o An OPEN with a valid clientid.",
      "ja": "o 有効なClientIDを備えたオープン。"
    },
    {
      "indent": 3,
      "text": "o Any operation made with a valid stateid (CLOSE, DELEGRETURN, LOCK, LOCKU, OPEN, OPEN_CONFIRM, READ, RENEW, SETATTR, WRITE). This does not include the special stateids of all bits 0 or all bits 1.",
      "ja": "o 有効なSTATEIDで作成されたすべての操作（閉鎖、delegreturn、lock、locku、open、open_confirm、読み取り、更新、setattr、書き込み）。これには、すべてのビット0またはすべてのビット1の特別なStateIDが含まれません。"
    },
    {
      "indent": 9,
      "text": "Note that if the client had restarted or rebooted, the client would not be making these requests without issuing the SETCLIENTID operation. The use of the SETCLIENTID operation (possibly with the addition of the optional SETCLIENTID_CONFIRM operation) notifies the server to drop the locking state associated with the client.",
      "ja": "クライアントが再起動または再起動した場合、クライアントはSetClientID操作を発行せずにこれらのリクエストを行わないことに注意してください。SetClientID操作の使用（おそらくオプションのSetClientID_CONFIRM操作を追加した場合）は、サーバーにクライアントに関連付けられたロック状態をドロップするように通知します。"
    },
    {
      "indent": 9,
      "text": "If the server has rebooted, the stateids (NFS4ERR_STALE_STATEID error) or the clientid (NFS4ERR_STALE_CLIENTID error) will not be valid hence preventing spurious renewals.",
      "ja": "サーバーが再起動した場合、StateIDS（nfs4err_stale_stateIdエラー）またはclientid（nfs4err_stale_clientidエラー）は有効ではないため、偽りの更新を防ぎます。"
    },
    {
      "indent": 3,
      "text": "This approach allows for low overhead lease renewal which scales well. In the typical case no extra RPC calls are required for lease renewal and in the worst case one RPC is required every lease period (i.e. a RENEW operation). The number of locks held by the client is not a factor since all state for the client is involved with the lease renewal action.",
      "ja": "このアプローチにより、オーバーヘッドリースの低い更新が可能になり、適切にスケーリングされます。典型的なケースでは、リースの更新に追加のRPCコールは必要ありません。最悪の場合、1つのRPCがすべてのリース期間（つまり、更新操作）が必要です。クライアントが保有するロックの数は、クライアントのすべての状態がリース更新措置に関与しているため、要因ではありません。"
    },
    {
      "indent": 3,
      "text": "Since all operations that create a new lease also renew existing leases, the server must maintain a common lease expiration time for all valid leases for a given client. This lease time can then be easily updated upon implicit lease renewal actions.",
      "ja": "新しいリースを作成するすべての操作も既存のリースを更新するため、サーバーは特定のクライアントのすべての有効なリースの一般的なリースの有効期限を維持する必要があります。このリース時間は、暗黙のリース更新アクションを簡単に更新できます。"
    },
    {
      "indent": 0,
      "text": "8.5. Crash Recovery",
      "section_title": true,
      "ja": "8.5. クラッシュ回復"
    },
    {
      "indent": 3,
      "text": "The important requirement in crash recovery is that both the client and the server know when the other has failed. Additionally, it is required that a client sees a consistent view of data across server restarts or reboots. All READ and WRITE operations that may have been queued within the client or network buffers must wait until the client has successfully recovered the locks protecting the READ and WRITE operations.",
      "ja": "クラッシュの回復における重要な要件は、クライアントとサーバーの両方が他者がいつ失敗したかを知っていることです。さらに、クライアントは、サーバーの再起動または再起動全体でデータの一貫したビューを確認する必要があります。クライアントまたはネットワークバッファ内でキューに留められている可能性のあるすべての読み取りおよび書き込み操作は、クライアントが読み取りおよび書き込み操作を保護するロックを正常に回復するまで待つ必要があります。"
    },
    {
      "indent": 0,
      "text": "8.5.1. Client Failure and Recovery",
      "section_title": true,
      "ja": "8.5.1. クライアントの失敗と回復"
    },
    {
      "indent": 3,
      "text": "In the event that a client fails, the server may recover the client's locks when the associated leases have expired. Conflicting locks from another client may only be granted after this lease expiration. If the client is able to restart or reinitialize within the lease period the client may be forced to wait the remainder of the lease period before obtaining new locks.",
      "ja": "クライアントが故障した場合、関連するリースの有効期限が切れたときにサーバーがクライアントのロックを回復する場合があります。別のクライアントからの矛盾するロックは、このリースの満了後にのみ付与される場合があります。クライアントがリース期間内に再起動または再編成できる場合、クライアントは、新しいロックを取得する前に、リース期間の残りの期間を待つことを余儀なくされる場合があります。"
    },
    {
      "indent": 3,
      "text": "To minimize client delay upon restart, lock requests are associated with an instance of the client by a client supplied verifier. This verifier is part of the initial SETCLIENTID call made by the client. The server returns a clientid as a result of the SETCLIENTID operation. The client then confirms the use of the verifier with SETCLIENTID_CONFIRM. The clientid in combination with an opaque owner field is then used by the client to identify the lock owner for OPEN. This chain of associations is then used to identify all locks for a particular client.",
      "ja": "再起動時のクライアントの遅延を最小限に抑えるために、ロックリクエストは、クライアントが提供された検証者によってクライアントのインスタンスに関連付けられています。この検証者は、クライアントが作成した最初のSetClientIDコールの一部です。サーバーは、SetClientID操作の結果としてClientIDを返します。次に、クライアントは、setclientId_confirmで検証剤の使用を確認します。不透明な所有者フィールドと組み合わせたClientIDは、クライアントがロック所有者を識別するために使用されます。この一連の関連付けは、特定のクライアントのすべてのロックを識別するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Since the verifier will be changed by the client upon each initialization, the server can compare a new verifier to the verifier associated with currently held locks and determine that they do not match. This signifies the client's new instantiation and subsequent loss of locking state. As a result, the server is free to release all locks held which are associated with the old clientid which was derived from the old verifier.",
      "ja": "各初期化時にクライアントによって検証剤が変更されるため、サーバーは現在保持されているロックに関連付けられている検証剤と新しい検証剤を比較し、それらが一致していないと判断できます。これは、クライアントの新しいインスタンス化とその後のロック状態の損失を意味します。その結果、サーバーは、古い検証剤から派生した古いClientIDに関連付けられているすべてのロックを自由にリリースできます。"
    },
    {
      "indent": 3,
      "text": "For secure environments, a change in the verifier must only cause the release of locks associated with the authenticated requester. This is required to prevent a rogue entity from freeing otherwise valid locks.",
      "ja": "安全な環境の場合、検証者の変更は、認証された要求者に関連付けられたロックの放出のみを引き起こす必要があります。これは、不正なエンティティがそれ以外の場合は有効なロックを解放するのを防ぐために必要です。"
    },
    {
      "indent": 3,
      "text": "Note that the verifier must have the same uniqueness properties of the verifier for the COMMIT operation.",
      "ja": "Verifierは、コミット操作のために検証剤の同じユニークネスプロパティを持たなければならないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "8.5.2. Server Failure and Recovery",
      "section_title": true,
      "ja": "8.5.2. サーバーの失敗と回復"
    },
    {
      "indent": 3,
      "text": "If the server loses locking state (usually as a result of a restart or reboot), it must allow clients time to discover this fact and re-establish the lost locking state. The client must be able to re-establish the locking state without having the server deny valid requests because the server has granted conflicting access to another client. Likewise, if there is the possibility that clients have not yet re-established their locking state for a file, the server must disallow READ and WRITE operations for that file. The duration of this recovery period is equal to the duration of the lease period.",
      "ja": "サーバーがロック状態を失った場合（通常は再起動または再起動の結果として）、クライアントがこの事実を発見し、失われたロック状態を再確立する時間を確保する必要があります。サーバーが別のクライアントへの矛盾したアクセスを許可しているため、サーバーに有効な要求を拒否することなく、クライアントはロック状態を再確立できる必要があります。同様に、クライアントがファイルのロック状態をまだ再確立していない可能性がある場合、サーバーはそのファイルの操作の読み取りと書き込みを禁止する必要があります。この回復期間の期間は、リース期間の期間に等しくなります。"
    },
    {
      "indent": 3,
      "text": "A client can determine that server failure (and thus loss of locking state) has occurred, when it receives one of two errors. The NFS4ERR_STALE_STATEID error indicates a stateid invalidated by a reboot or restart. The NFS4ERR_STALE_CLIENTID error indicates a clientid invalidated by reboot or restart. When either of these are received, the client must establish a new clientid (See the section \"Client ID\") and re-establish the locking state as discussed below.",
      "ja": "クライアントは、2つのエラーのいずれかを受け取ると、サーバーの障害（したがってロック状態の損失）が発生したと判断できます。nfs4err_stale_stateidエラーは、再起動または再起動によって無効にされたStateIDを示します。nfs4err_stale_clientIDエラーは、再起動または再起動によって無効にされたclientIDを示します。これらのいずれかを受信した場合、クライアントは新しいClientIDを確立し（セクション「クライアントID」を参照）、以下で説明するようにロック状態を再確立する必要があります。"
    },
    {
      "indent": 3,
      "text": "The period of special handling of locking and READs and WRITEs, equal in duration to the lease period, is referred to as the \"grace period\". During the grace period, clients recover locks and the associated state by reclaim-type locking requests (i.e. LOCK requests with reclaim set to true and OPEN operations with a claim type of CLAIM_PREVIOUS). During the grace period, the server must reject READ and WRITE operations and non-reclaim locking requests (i.e. other LOCK and OPEN operations) with an error of NFS4ERR_GRACE.",
      "ja": "リース期間と同等のロックと読み取りと書き込みの特別な取り扱いの期間は、「恵み期間」と呼ばれます。猶予期間中、クライアントはロックと関連状態を回収することでロックと関連状態を回収します（つまり、請求タイプの請求タイプのtrue _previousを使用して、真のオープンオペレーションに設定された再生リクエストをロックリクエスト）。GRACE期間中、サーバーは、nfs4err_graceのエラーを使用して、読み取りおよび書き込み操作と非再生ロック要求（他のロックおよびオープン操作）を拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the server can reliably determine that granting a non-reclaim request will not conflict with reclamation of locks by other clients, the NFS4ERR_GRACE error does not have to be returned and the non-reclaim client request can be serviced. For the server to be able to service READ and WRITE operations during the grace period, it must again be able to guarantee that no possible conflict could arise between an impending reclaim locking request and the READ or WRITE operation. If the server is unable to offer that guarantee, the NFS4ERR_GRACE error must be returned to the client.",
      "ja": "サーバーが、非回復要求を付与することで他のクライアントによるロックの再生と矛盾しないことを確実に判断できる場合、NFS4err_Graceエラーを返す必要はなく、非リファイルクライアントリクエストを修正できます。サーバーが猶予期間中に読み取りおよび書き込み操作をサービスできるようにするためには、差し迫った回収ロックリクエストと読み取りまたは書き込み操作の間に競合が発生しないことを再度保証することができなければなりません。サーバーがその保証を提供できない場合、nfs4err_graceエラーをクライアントに返す必要があります。"
    },
    {
      "indent": 3,
      "text": "For a server to provide simple, valid handling during the grace period, the easiest method is to simply reject all non-reclaim locking requests and READ and WRITE operations by returning the NFS4ERR_GRACE error. However, a server may keep information about granted locks in stable storage. With this information, the server could determine if a regular lock or READ or WRITE operation can be safely processed.",
      "ja": "サーバーがグレース期間中にシンプルで有効な取り扱いを提供するために、最も簡単な方法は、NFS4err_graceエラーを返すことにより、すべての非再生ロック要求を拒否し、操作を読み書きすることです。ただし、サーバーは、許可されたロックに関する情報を安定したストレージに保持する場合があります。この情報を使用すると、サーバーは、通常のロックまたは読み取りまたは書き込み操作を安全に処理できるかどうかを判断できます。"
    },
    {
      "indent": 3,
      "text": "For example, if a count of locks on a given file is available in stable storage, the server can track reclaimed locks for the file and when all reclaims have been processed, non-reclaim locking requests may be processed. This way the server can ensure that non-reclaim locking requests will not conflict with potential reclaim requests. With respect to I/O requests, if the server is able to determine that there are no outstanding reclaim requests for a file by information from stable storage or another similar mechanism, the processing of I/O requests could proceed normally for the file.",
      "ja": "たとえば、特定のファイル上のロックのカウントが安定したストレージで利用可能である場合、サーバーはファイルの再生ロックを追跡でき、すべての再生が処理された場合、非再生ロック要求を処理できます。このようにして、サーバーは、非再生ロックリクエストが潜在的な回収要求と競合しないようにすることができます。I/O要求に関しては、サーバーが安定したストレージまたは別の同様のメカニズムからの情報によるファイルの未解決の回収要求がないことを決定できた場合、I/O要求の処理はファイルの正常に進行する可能性があります。"
    },
    {
      "indent": 3,
      "text": "To reiterate, for a server that allows non-reclaim lock and I/O requests to be processed during the grace period, it MUST determine that no lock subsequently reclaimed will be rejected and that no lock subsequently reclaimed would have prevented any I/O operation processed during the grace period.",
      "ja": "繰り返しになると、非リクライミングロックとI/Oリクエストを猶予期間中に処理できるサーバーの場合、その後のロックが再生されないことを判断する必要があり、その後ロックがI/O操作を妨げていないことを決定する必要があります。猶予期間中に処理されます。"
    },
    {
      "indent": 3,
      "text": "Clients should be prepared for the return of NFS4ERR_GRACE errors for non-reclaim lock and I/O requests. In this case the client should employ a retry mechanism for the request. A delay (on the order of several seconds) between retries should be used to avoid overwhelming the server. Further discussion of the general is included in",
      "ja": "クライアントは、ノンリアムロックとI/O要求のNFS4err_Graceエラーの返却のために準備する必要があります。この場合、クライアントはリクエストのために再試行メカニズムを採用する必要があります。サーバーの圧倒を避けるために、レトリの間の遅延（数秒程度）を使用する必要があります。一般的な議論は含まれています"
    },
    {
      "indent": 3,
      "text": "[Floyd]. The client must account for the server that is able to perform I/O and non-reclaim locking requests within the grace period as well as those that can not do so.",
      "ja": "[フロイド]。クライアントは、I/Oを実行できるサーバーと、GRACE期間内にリクライニングロックリクエストを実行できないサーバーと、できないものを考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "A reclaim-type locking request outside the server's grace period can only succeed if the server can guarantee that no conflicting lock or I/O request has been granted since reboot or restart.",
      "ja": "サーバーのGRACE期間の外側の再生タイプのロック要求は、再起動または再起動以来、競合するロックまたはI/O要求が許可されていないことをサーバーが保証できる場合にのみ成功できます。"
    },
    {
      "indent": 0,
      "text": "8.5.3. Network Partitions and Recovery",
      "section_title": true,
      "ja": "8.5.3. ネットワークパーティションとリカバリ"
    },
    {
      "indent": 3,
      "text": "If the duration of a network partition is greater than the lease period provided by the server, the server will have not received a lease renewal from the client. If this occurs, the server may free all locks held for the client. As a result, all stateids held by the client will become invalid or stale. Once the client is able to reach the server after such a network partition, all I/O submitted by the client with the now invalid stateids will fail with the server returning the error NFS4ERR_EXPIRED. Once this error is received, the client will suitably notify the application that held the lock.",
      "ja": "ネットワークパーティションの期間がサーバーが提供するリース期間よりも大きい場合、サーバーはクライアントからリース更新を受信していません。これが発生した場合、サーバーはクライアント用に保持されているすべてのロックを解放できます。その結果、クライアントが保有するすべてのStateidsは無効または古くなります。このようなネットワークパーティションの後にクライアントがサーバーに到達できるようになると、クライアントが現在無効なStateIDSを使用してクライアントが提出したすべてのI/Oは、エラーNFS4err_Expiredを返すサーバーで失敗します。このエラーが受信されると、クライアントはロックを保持しているアプリケーションに適切に通知します。"
    },
    {
      "indent": 3,
      "text": "As a courtesy to the client or as an optimization, the server may continue to hold locks on behalf of a client for which recent communication has extended beyond the lease period. If the server receives a lock or I/O request that conflicts with one of these courtesy locks, the server must free the courtesy lock and grant the new request.",
      "ja": "クライアントへの礼儀または最適化として、サーバーは、最近の通信がリース期間を超えて延長されたクライアントに代わってロックを保持し続けることができます。サーバーがこれらの礼儀ロックのいずれかと競合するロックまたはI/O要求を受信した場合、サーバーは礼儀ロックを解放し、新しいリクエストを許可する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the server continues to hold locks beyond the expiration of a client's lease, the server MUST employ a method of recording this fact in its stable storage. Conflicting locks requests from another client may be serviced after the lease expiration. There are various scenarios involving server failure after such an event that require the storage of these lease expirations or network partitions. One scenario is as follows:",
      "ja": "サーバーがクライアントのリースの有効期限を超えてロックを保持し続ける場合、サーバーは安定したストレージにこの事実を記録する方法を使用する必要があります。別のクライアントからの競合するロック要求は、リースの満了後にサービスを受けることができます。これらのリースの満了またはネットワークパーティションの保存を必要とするこのようなイベント後のサーバー障害を含むさまざまなシナリオがあります。1つのシナリオは次のとおりです。"
    },
    {
      "indent": 9,
      "text": "A client holds a lock at the server and encounters a network partition and is unable to renew the associated lease. A second client obtains a conflicting lock and then frees the lock. After the unlock request by the second client, the server reboots or reinitializes. Once the server recovers, the network partition heals and the original client attempts to reclaim the original lock.",
      "ja": "クライアントはサーバーにロックを保持し、ネットワークパーティションに遭遇し、関連するリースを更新できません。2番目のクライアントが競合するロックを取得し、ロックを解放します。2番目のクライアントによるロック解除要求の後、サーバーは再起動または再現されます。サーバーが回復すると、ネットワークパーティションが回復し、元のクライアントが元のロックを取り戻そうとします。"
    },
    {
      "indent": 3,
      "text": "In this scenario and without any state information, the server will allow the reclaim and the client will be in an inconsistent state because the server or the client has no knowledge of the conflicting lock.",
      "ja": "このシナリオでは、状態情報がない場合、サーバーまたはクライアントは競合するロックの知識がないため、サーバーは回収を許可し、クライアントは一貫性のない状態になります。"
    },
    {
      "indent": 3,
      "text": "The server may choose to store this lease expiration or network partitioning state in a way that will only identify the client as a whole. Note that this may potentially lead to lock reclaims being denied unnecessarily because of a mix of conflicting and non-conflicting locks. The server may also choose to store information about each lock that has an expired lease with an associated conflicting lock. The choice of the amount and type of state information that is stored is left to the implementor. In any case, the server must have enough state information to enable correct recovery from multiple partitions and multiple server failures.",
      "ja": "サーバーは、クライアント全体を識別する方法で、このリースの有効期限またはネットワークパーティション状態を保存することを選択できます。これは、競合するロックと非紛争のないロックが混在するため、不必要に拒否されることをロックすることにつながる可能性があることに注意してください。サーバーは、関連する競合ロックを備えた期限切れのリースがある各ロックに関する情報を保存することもできます。保存されている州情報の量と種類の選択は、実装者に任されています。いずれにせよ、サーバーには、複数のパーティションと複数のサーバー障害からの正しい回復を可能にするのに十分な状態情報が必要です。"
    },
    {
      "indent": 0,
      "text": "8.6. Recovery from a Lock Request Timeout or Abort",
      "section_title": true,
      "ja": "8.6. ロックリクエストのタイムアウトまたは中止からの回復"
    },
    {
      "indent": 3,
      "text": "In the event a lock request times out, a client may decide to not retry the request. The client may also abort the request when the process for which it was issued is terminated (e.g. in UNIX due to a signal. It is possible though that the server received the request and acted upon it. This would change the state on the server without the client being aware of the change. It is paramount that the client re-synchronize state with server before it attempts any other operation that takes a seqid and/or a stateid with the same nfs_lockowner. This is straightforward to do without a special re-synchronize operation.",
      "ja": "ロックリクエストがタイムアウトする場合、クライアントはリクエストを再試行しないことを決定する場合があります。また、クライアントは、発行されたプロセスが終了したときにリクエストを中止することもできます（たとえば、信号のためにUNIXでは、サーバーがリクエストを受け取って行動した可能性があります。クライアントは変更を認識しています。クライアントは、同じnfs_lockownerを持つseqidおよび/またはstateidを取得する他の操作を試みる前に、サーバーと状態を再同期させることが最も重要です。操作を同期します。"
    },
    {
      "indent": 3,
      "text": "Since the server maintains the last lock request and response received on the nfs_lockowner, for each nfs_lockowner, the client should cache the last lock request it sent such that the lock request did not receive a response. From this, the next time the client does a lock operation for the nfs_lockowner, it can send the cached request, if there is one, and if the request was one that established state (e.g. a LOCK or OPEN operation) the client can follow up with a request to remove the state (e.g. a LOCKU or CLOSE operation). With this approach, the sequencing and stateid information on the client and server for the given nfs_lockowner will re-synchronize and in turn the lock state will re-synchronize.",
      "ja": "サーバーは、NFS_Lockownerで受信された最後のロック要求と応答を維持しているため、各NFS_Lockownerに対して、クライアントはロックリクエストが応答を受信しないように送信した最後のロックリクエストをキャッシュする必要があります。これから、クライアントが次回NFS_Lockownerのロック操作を行うとき、キャッシュされたリクエストがある場合、およびリクエストが状態を確立した場合（ロックまたはオープン操作など）、クライアントはフォローアップできます。状態を削除するリクエスト（例：lockuまたは閉鎖操作）。このアプローチを使用すると、指定されたNFS_Lockownerのクライアントとサーバーに関するシーケンスとSTATEID情報が再同期し、ロック状態が再同期します。"
    },
    {
      "indent": 0,
      "text": "8.7. Server Revocation of Locks",
      "section_title": true,
      "ja": "8.7. ロックのサーバーの取り消し"
    },
    {
      "indent": 3,
      "text": "At any point, the server can revoke locks held by a client and the client must be prepared for this event. When the client detects that its locks have been or may have been revoked, the client is responsible for validating the state information between itself and the server. Validating locking state for the client means that it must verify or reclaim state for each lock currently held.",
      "ja": "いつでも、サーバーはクライアントが保持しているロックを取り消すことができ、クライアントはこのイベントのために準備する必要があります。クライアントがロックが取り消された、または取り消された可能性があることを検出すると、クライアントはそれ自体とサーバーの間の状態情報を検証する責任があります。クライアントのロック状態の検証とは、現在保持されている各ロックの状態を確認または回収する必要があることを意味します。"
    },
    {
      "indent": 3,
      "text": "The first instance of lock revocation is upon server reboot or re-initialization. In this instance the client will receive an error (NFS4ERR_STALE_STATEID or NFS4ERR_STALE_CLIENTID) and the client will proceed with normal crash recovery as described in the previous section.",
      "ja": "ロック撤回の最初のインスタンスは、サーバーの再起動または再目的化にあります。この場合、クライアントはエラー（nfs4err_stale_stateIdまたはnfs4err_stale_clientId）を受け取り、クライアントは前のセクションで説明したように通常のクラッシュ回復を続行します。"
    },
    {
      "indent": 3,
      "text": "The second lock revocation event is the inability to renew the lease period. While this is considered a rare or unusual event, the client must be prepared to recover. Both the server and client will be able to detect the failure to renew the lease and are capable of recovering without data corruption. For the server, it tracks the last renewal event serviced for the client and knows when the lease will expire. Similarly, the client must track operations which will renew the lease period. Using the time that each such request was sent and the time that the corresponding reply was received, the client should bound the time that the corresponding renewal could have occurred on the server and thus determine if it is possible that a lease period expiration could have occurred.",
      "ja": "2番目のロック取消イベントは、リース期間を更新できないことです。これはまれなイベントまたは珍しいイベントと見なされますが、クライアントは回復する準備をしなければなりません。サーバーとクライアントの両方が、リースの更新の失敗を検出することができ、データの破損なしに回復することができます。サーバーの場合、クライアントにサービスされた最後の更新イベントを追跡し、リースがいつ失効するかを知っています。同様に、クライアントはリース期間を更新する操作を追跡する必要があります。そのような各リクエストが送信された時間と、対応する返信が受信された時間を使用して、クライアントは、対応する更新がサーバーで発生した時間を拘束する必要があり、したがって、リース期間の有効期限が発生した可能性があるかどうかを判断する必要があります。。"
    },
    {
      "indent": 3,
      "text": "The third lock revocation event can occur as a result of administrative intervention within the lease period. While this is considered a rare event, it is possible that the server's administrator has decided to release or revoke a particular lock held by the client. As a result of revocation, the client will receive an error of NFS4ERR_EXPIRED and the error is received within the lease period for the lock. In this instance the client may assume that only the nfs_lockowner's locks have been lost. The client notifies the lock holder appropriately. The client may not assume the lease period has been renewed as a result of failed operation.",
      "ja": "3回目のロック取り消しイベントは、リース期間内の管理介入の結果として発生する可能性があります。これはまれなイベントと見なされますが、サーバーの管理者がクライアントが保持している特定のロックをリリースまたは取り消すことを決定した可能性があります。取り消しの結果、クライアントはnfs4err_expiredのエラーを受け取り、ロックのリース期間内にエラーが受信されます。この場合、クライアントは、NFS_Lockownerのロックのみが失われたと仮定する場合があります。クライアントは、ロックホルダーに適切に通知します。クライアントは、操作に失敗した結果、リース期間が更新されたと想定していない場合があります。"
    },
    {
      "indent": 3,
      "text": "When the client determines the lease period may have expired, the client must mark all locks held for the associated lease as \"unvalidated\". This means the client has been unable to re-establish or confirm the appropriate lock state with the server. As described in the previous section on crash recovery, there are scenarios in which the server may grant conflicting locks after the lease period has expired for a client. When it is possible that the lease period has expired, the client must validate each lock currently held to ensure that a conflicting lock has not been granted. The client may accomplish this task by issuing an I/O request, either a pending I/O or a zero-length read, specifying the stateid associated with the lock in question. If the response to the request is success, the client has validated all of the locks governed by that stateid and re-established the appropriate state between itself and the server. If the I/O request is not successful, then one or more of the locks associated with the stateid was revoked by the server and the client must notify the owner.",
      "ja": "クライアントがリース期間が期限切れになったと判断した場合、クライアントは、関連するリースのために保持されているすべてのロックを「未検証」とマークする必要があります。これは、クライアントがサーバーで適切なロック状態を再確立または確認できないことを意味します。クラッシュ回復に関する前のセクションで説明したように、クライアントのリース期間が終了した後、サーバーが競合するロックを付与するシナリオがあります。リース期間が失効した可能性がある場合、クライアントは現在保持されている各ロックを検証して、競合するロックが付与されていないことを確認する必要があります。クライアントは、保留中のI/Oまたはゼロの長さの読み取りのいずれかのI/O要求を発行して、問題のロックに関連付けられたStateIDを指定することにより、このタスクを達成することができます。リクエストへの応答が成功した場合、クライアントはそのStateIDによって支配されたすべてのロックを検証し、それ自体とサーバーの間の適切な状態を再確立しました。I/O要求が成功しない場合、StateIDに関連付けられた1つ以上のロックがサーバーによって取り消され、クライアントは所有者に通知する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.8. Share Reservations",
      "section_title": true,
      "ja": "8.8. 予約を共有します"
    },
    {
      "indent": 3,
      "text": "A share reservation is a mechanism to control access to a file. It is a separate and independent mechanism from record locking. When a client opens a file, it issues an OPEN operation to the server specifying the type of access required (READ, WRITE, or BOTH) and the type of access to deny others (deny NONE, READ, WRITE, or BOTH). If the OPEN fails the client will fail the application's open request.",
      "ja": "共有予約は、ファイルへのアクセスを制御するメカニズムです。これは、レコードロックから独立した独立したメカニズムです。クライアントがファイルを開くと、必要なアクセスの種類（読み取り、書き込み、またはその両方）と他の人を拒否するアクセスの種類（拒否、読み取り、書き込み、またはその両方）を指定するサーバーにオープン操作を発行します。オープンが失敗した場合、クライアントはアプリケーションのオープンリクエストに失敗します。"
    },
    {
      "indent": 3,
      "text": "Pseudo-code definition of the semantics:",
      "ja": "セマンティクスの擬似コード定義："
    },
    {
      "indent": 15,
      "text": "if ((request.access & file_state.deny)) || (request.deny & file_state.access)) return (NFS4ERR_DENIED)",
      "ja": "if（（request.access＆file_state.deny））||（request.deny＆file_state.access））return（nfs4err_denied）"
    },
    {
      "indent": 3,
      "text": "The constants used for the OPEN and OPEN_DOWNGRADE operations for the access and deny fields are as follows:",
      "ja": "アクセスフィールドと拒否フィールドのOpen_DownGrade操作に使用される定数は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "const OPEN4_SHARE_ACCESS_READ   = 0x00000001;\nconst OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;\nconst OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const OPEN4_SHARE_DENY_NONE     = 0x00000000;\nconst OPEN4_SHARE_DENY_READ     = 0x00000001;\nconst OPEN4_SHARE_DENY_WRITE    = 0x00000002;\nconst OPEN4_SHARE_DENY_BOTH     = 0x00000003;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.9. OPEN/CLOSE Operations",
      "section_title": true,
      "ja": "8.9. オープン/クローズ操作"
    },
    {
      "indent": 3,
      "text": "To provide correct share semantics, a client MUST use the OPEN operation to obtain the initial filehandle and indicate the desired access and what if any access to deny. Even if the client intends to use a stateid of all 0's or all 1's, it must still obtain the filehandle for the regular file with the OPEN operation so the appropriate share semantics can be applied. For clients that do not have a deny mode built into their open programming interfaces, deny equal to NONE should be used.",
      "ja": "正しい共有セマンティクスを提供するには、クライアントはオープン操作を使用して最初のファイルハンドルを取得し、目的のアクセスと拒否へのアクセスを示す必要があります。クライアントがすべての0またはすべての1のStateIDを使用しようとしている場合でも、適切な共有セマンティクスを適用できるように、オープン操作を備えた通常のファイルのファイルハンドルを取得する必要があります。オープンプログラミングインターフェイスに拒否モードが組み込まれていないクライアントの場合、使用されるべきではないことを拒否します。"
    },
    {
      "indent": 3,
      "text": "The OPEN operation with the CREATE flag, also subsumes the CREATE operation for regular files as used in previous versions of the NFS protocol. This allows a create with a share to be done atomically.",
      "ja": "Create Flagを使用したオープン操作は、NFSプロトコルの以前のバージョンで使用されている通常のファイルの作成操作も包含します。これにより、共有の作成を原子的に実行できます。"
    },
    {
      "indent": 3,
      "text": "The CLOSE operation removes all share locks held by the nfs_lockowner on that file. If record locks are held, the client SHOULD release all locks before issuing a CLOSE. The server MAY free all outstanding locks on CLOSE but some servers may not support the CLOSE of a file that still has record locks held. The server MUST return failure if any locks would exist after the CLOSE.",
      "ja": "緊密な操作により、そのファイルにNFS_Lockownerが保持しているすべての共有ロックが削除されます。レコードロックが保持されている場合、クライアントは終了する前にすべてのロックをリリースする必要があります。サーバーは、すべての未解決のロックを閉じることができますが、一部のサーバーは、まだレコードロックが保持されているファイルの閉鎖をサポートできない場合があります。終了後にロックが存在する場合、サーバーは障害を返す必要があります。"
    },
    {
      "indent": 3,
      "text": "The LOOKUP operation will return a filehandle without establishing any lock state on the server. Without a valid stateid, the server will assume the client has the least access. For example, a file opened with deny READ/WRITE cannot be accessed using a filehandle obtained through LOOKUP because it would not have a valid stateid (i.e. using a stateid of all bits 0 or all bits 1).",
      "ja": "ルックアップ操作は、サーバー上にロック状態を確立せずにファイルハンドルを返します。有効なStateIDがなければ、サーバーはクライアントのアクセスが最も少ないと想定します。たとえば、拒否された読み取り/書き込みで開かれたファイルは、検索を介して取得したファイルハンドルを使用してアクセスできません。"
    },
    {
      "indent": 0,
      "text": "8.10. Open Upgrade and Downgrade",
      "section_title": true,
      "ja": "8.10. アップグレードとダウングレードを開きます"
    },
    {
      "indent": 3,
      "text": "When an OPEN is done for a file and the lockowner for which the open is being done already has the file open, the result is to upgrade the open file status maintained on the server to include the access and deny bits specified by the new OPEN as well as those for the existing OPEN. The result is that there is one open file, as far as the protocol is concerned, and it includes the union of the access and deny bits for all of the OPEN requests completed. Only a single CLOSE will be done to reset the effects of both OPEN's. Note that the client, when issuing the OPEN, may not know that the same file is in fact being opened. The above only applies if both OPEN's result in the OPEN'ed object being designated by the same filehandle.",
      "ja": "ファイルのオープンが完了し、オープンが完了しているロックオーナーがすでにファイルを開いている場合、サーバーに維持されているオープンファイルステータスをアップグレードして、新しいオープンで指定されたアクセスと拒否ビットを含めるようにアップグレードします。既存のオープンのもの。その結果、プロトコルに関する限り、1つのオープンファイルがあり、完了したすべてのオープンリクエストのアクセスと拒否ビットの結合が含まれます。両方のオープンの効果をリセットするために、1つのクローズのみが行われます。クライアントは、オープンを発行するとき、同じファイルが実際に開かれていることを知らないかもしれないことに注意してください。上記は、両方のOpenの結果が同じファイルハンドルによって指定されているオープンオブジェクトの両方の結果の場合にのみ適用されます。"
    },
    {
      "indent": 3,
      "text": "When the server chooses to export multiple filehandles corresponding to the same file object and returns different filehandles on two different OPEN's of the same file object, the server MUST NOT \"OR\" together the access and deny bits and coalesce the two open files. Instead the server must maintain separate OPEN's with separate stateid's and will require separate CLOSE's to free them.",
      "ja": "サーバーが同じファイルオブジェクトに対応する複数のファイルハンドルをエクスポートすることを選択し、同じファイルオブジェクトの2つの異なるオープンで異なるファイルハンドルを返すことを選択した場合、サーバーは「アクセスして「ビット」を拒否し、2つの開いたファイルを拒否してcoalseしてはなりません。代わりに、サーバーは個別のStateIDを使用して個別のオープンを維持する必要があり、それらを解放するために個別のクローズを必要とします。"
    },
    {
      "indent": 3,
      "text": "When multiple open files on the client are merged into a single open file object on the server, the close of one of the open files (on the client) may necessitate change of the access and deny status of the open file on the server. This is because the union of the access and deny bits for the remaining open's may be smaller (i.e. a proper subset) than previously. The OPEN_DOWNGRADE operation is used to make the necessary change and the client should use it to update the server so that share reservation requests by other clients are handled properly.",
      "ja": "クライアント上の複数の開いたファイルがサーバー上の単一の開いたファイルオブジェクトにマージされると、クライアント上のオープンファイルの1つをクローズすると、サーバー上のオープンファイルのアクセスの変更と拒否を必要とする場合があります。これは、残りのオープンのアクセスと拒否ビットの結合が以前よりも小さい（つまり、適切なサブセット）可能性があるためです。Open_DownGrade操作は、必要な変更を行うために使用され、クライアントはそれを使用してサーバーを更新して、他のクライアントによる予約リクエストが適切に処理されるようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "8.11. Short and Long Leases",
      "section_title": true,
      "ja": "8.11. 短くて長いリース"
    },
    {
      "indent": 3,
      "text": "When determining the time period for the server lease, the usual lease tradeoffs apply. Short leases are good for fast server recovery at a cost of increased RENEW or READ (with zero length) requests. Longer leases are certainly kinder and gentler to large internet servers trying to handle very large numbers of clients. The number of RENEW requests drop in proportion to the lease time. The disadvantages of long leases are slower recovery after server failure (server must wait for leases to expire and grace period before granting new lock requests) and increased file contention (if client fails to transmit an unlock request then server must wait for lease expiration before granting new locks).",
      "ja": "サーバーリースの期間を決定するとき、通常のリーストレードオフが適用されます。短いリースは、更新または読み取り（ゼロの長さ）の要求の増加のコストで高速サーバーの回復に適しています。長いリースは、非常に多数のクライアントを処理しようとする大規模なインターネットサーバーにとって確かに親切で穏やかです。更新リクエストの数は、リース時間に比例して低下します。サーバーの障害後の長いリースの欠点は、回復が遅くなります（サーバーは、新しいロックリクエストを付与する前にリースが期限切れになり、猶予期間を待つ必要があります）。新しいロック）。"
    },
    {
      "indent": 3,
      "text": "Long leases are usable if the server is able to store lease state in non-volatile memory. Upon recovery, the server can reconstruct the lease state from its non-volatile memory and continue operation with its clients and therefore long leases are not an issue.",
      "ja": "サーバーが不揮発性メモリにリース状態を保存できる場合、長いリースが使用可能です。回復すると、サーバーは不揮発性メモリからリース状態を再構築し、クライアントとの操作を継続できるため、長いリースは問題ではありません。"
    },
    {
      "indent": 0,
      "text": "8.12. Clocks and Calculating Lease Expiration",
      "section_title": true,
      "ja": "8.12. クロックと計算リースの有効期限"
    },
    {
      "indent": 3,
      "text": "To avoid the need for synchronized clocks, lease times are granted by the server as a time delta. However, there is a requirement that the client and server clocks do not drift excessively over the duration of the lock. There is also the issue of propagation delay across the network which could easily be several hundred milliseconds as well as the possibility that requests will be lost and need to be retransmitted.",
      "ja": "同期されたクロックの必要性を回避するために、タイムデルタとしてサーバーによってリース時間が付与されます。ただし、クライアントとサーバーのクロックがロックの期間中に過度にドリフトしないという要件があります。また、ネットワーク全体で伝播遅延の問題がありますが、これは簡単に数百ミリ秒になる可能性があり、リクエストが失われ、再送信する必要がある可能性もあります。"
    },
    {
      "indent": 3,
      "text": "To take propagation delay into account, the client should subtract it from lease times (e.g. if the client estimates the one-way propagation delay as 200 msec, then it can assume that the lease is already 200 msec old when it gets it). In addition, it will take another 200 msec to get a response back to the server. So the client must send a lock renewal or write data back to the server 400 msec before the lease would expire.",
      "ja": "伝播遅延を考慮に入れるには、クライアントがリース時間からそれを減算する必要があります（たとえば、クライアントが一方向伝播遅延を200ミリ秒と推定した場合、リースが取得するとすでに200ミリ秒古いと仮定できます）。さらに、サーバーへの応答を取得するにはさらに200ミリ秒かかります。したがって、クライアントは、リースが期限切れになる前に、ロックの更新を送信するか、400ミリ秒のサーバーにデータを書き戻す必要があります。"
    },
    {
      "indent": 0,
      "text": "8.13. Migration, Replication and State",
      "section_title": true,
      "ja": "8.13. 移行、複製、状態"
    },
    {
      "indent": 3,
      "text": "When responsibility for handling a given file system is transferred to a new server (migration) or the client chooses to use an alternate server (e.g. in response to server unresponsiveness) in the context of file system replication, the appropriate handling of state shared between the client and server (i.e. locks, leases, stateid's, and clientid's) is as described below. The handling differs between migration and replication. For related discussion of file server state and recover of such see the sections under \"File Locking and Share Reservations\"",
      "ja": "特定のファイルシステムを処理する責任が新しいサーバー（移行）に転送される場合、またはクライアントがファイルシステムの複製のコンテキストで代替サーバーを使用することを選択します（たとえば、サーバーの無反応性に応じて）。クライアントとサーバー（つまり、ロック、リース、StateID、およびclientID）は、以下に説明します。処理は、移行と複製の間で異なります。ファイルサーバー状態の関連する議論とそのような回復については、「ファイルロックと共有予約」の下のセクションを参照してください"
    },
    {
      "indent": 0,
      "text": "8.13.1. Migration and State",
      "section_title": true,
      "ja": "8.13.1. 移行と状態"
    },
    {
      "indent": 3,
      "text": "In the case of migration, the servers involved in the migration of a file system SHOULD transfer all server state from the original to the new server. This must be done in a way that is transparent to the client. This state transfer will ease the client's transition when a file system migration occurs. If the servers are successful in transferring all state, the client will continue to use stateid's assigned by the original server. Therefore the new server must recognize these stateid's as valid. This holds true for the clientid as well. Since responsibility for an entire file system is transferred with a migration event, there is no possibility that conflicts will arise on the new server as a result of the transfer of locks.",
      "ja": "移行の場合、ファイルシステムの移行に関与するサーバーは、すべてのサーバー状態を元のサーバーから新しいサーバーに転送する必要があります。これは、クライアントに対して透明な方法で行う必要があります。この状態転送は、ファイルシステムの移行が発生したときにクライアントの移行を容易にします。サーバーがすべての状態を転送することに成功した場合、クライアントは元のサーバーによって割り当てられたStateIDを引き続き使用します。したがって、新しいサーバーは、これらのStateIDのものを有効であると認識する必要があります。これは、ClientIDにも当てはまります。ファイルシステム全体の責任は移行イベントで転送されるため、ロックの転送の結果、新しいサーバーで競合が発生する可能性はありません。"
    },
    {
      "indent": 3,
      "text": "As part of the transfer of information between servers, leases would be transferred as well. The leases being transferred to the new server will typically have a different expiration time from those for the same client, previously on the new server. To maintain the property that all leases on a given server for a given client expire at the same time, the server should advance the expiration time to the later of the leases being transferred or the leases already present. This allows the client to maintain lease renewal of both classes without special effort.",
      "ja": "サーバー間で情報の転送の一部として、リースも転送されます。新しいサーバーに転送されるリースは、通常、以前は新しいサーバー上の同じクライアントの有効期限とは異なります。特定のクライアントの特定のサーバー上のすべてのリースが同時に期限切れになるプロパティを維持するために、サーバーは、譲渡されるリースの後半またはすでに存在するリースの後半まで有効期限を進める必要があります。これにより、クライアントは特別な努力なしに両方のクラスのリース更新を維持できます。"
    },
    {
      "indent": 3,
      "text": "The servers may choose not to transfer the state information upon migration. However, this choice is discouraged. In this case, when the client presents state information from the original server, the client must be prepared to receive either NFS4ERR_STALE_CLIENTID or NFS4ERR_STALE_STATEID from the new server. The client should then recover its state information as it normally would in response to a server failure. The new server must take care to allow for the recovery of state information as it would in the event of server restart.",
      "ja": "サーバーは、移行時に状態情報を転送しないことを選択できます。ただし、この選択は落胆しています。この場合、クライアントが元のサーバーから状態情報を提示する場合、クライアントは新しいサーバーからnfs4err_stale_clientidまたはnfs4err_stale_stateidを受信する準備をする必要があります。クライアントは、サーバーの障害に応じて通常の状態情報を回復する必要があります。新しいサーバーは、サーバーの再起動の場合と同様に、状態情報の回復を許可するように注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.13.2. Replication and State",
      "section_title": true,
      "ja": "8.13.2. 複製と状態"
    },
    {
      "indent": 3,
      "text": "Since client switch-over in the case of replication is not under server control, the handling of state is different. In this case, leases, stateid's and clientid's do not have validity across a transition from one server to another. The client must re-establish its locks on the new server. This can be compared to the re-establishment of locks by means of reclaim-type requests after a server reboot. The difference is that the server has no provision to distinguish requests reclaiming locks from those obtaining new locks or to defer the latter. Thus, a client re-establishing a lock on the new server (by means of a LOCK or OPEN request), may have the requests denied due to a conflicting lock. Since replication is intended for read-only use of filesystems, such denial of locks should not pose large difficulties in practice. When an attempt to re-establish a lock on a new server is denied, the client should treat the situation as if his original lock had been revoked.",
      "ja": "複製の場合のクライアントスイッチオーバーはサーバー制御下にないため、状態の取り扱いは異なります。この場合、リース、StateID、およびClientIDは、あるサーバーから別のサーバーへの移行全体で有効性を持っていません。クライアントは、新しいサーバー上のロックを再確立する必要があります。これは、サーバーの再起動後に再生型要求を使用して、ロックの再確立と比較できます。違いは、サーバーに、ロックを再生ロックと新しいロックを取得したものや後者を延期するリクエストを区別するための規定がないことです。したがって、クライアントは（ロックまたはオープンリクエストを使用して）新しいサーバーのロックを再確立するため、競合するロックのためにリクエストを拒否される場合があります。複製はファイルシステムの読み取り専用の使用を目的としているため、ロックのそのような拒否は実際に大きな困難をもたらすべきではありません。新しいサーバーのロックを再確立しようとすると、クライアントは元のロックが取り消されたかのように状況を扱う必要があります。"
    },
    {
      "indent": 0,
      "text": "8.13.3. Notification of Migrated Lease",
      "section_title": true,
      "ja": "8.13.3. 移住リースの通知"
    },
    {
      "indent": 3,
      "text": "In the case of lease renewal, the client may not be submitting requests for a file system that has been migrated to another server. This can occur because of the implicit lease renewal mechanism. The client renews leases for all file systems when submitting a request to any one file system at the server.",
      "ja": "リース更新の場合、クライアントは別のサーバーに移行されたファイルシステムのリクエストを送信していない場合があります。これは、暗黙のリース更新メカニズムのために発生する可能性があります。サーバーの1つのファイルシステムにリクエストを送信する際に、クライアントはすべてのファイルシステムのリースを更新します。"
    },
    {
      "indent": 3,
      "text": "In order for the client to schedule renewal of leases that may have been relocated to the new server, the client must find out about lease relocation before those leases expire. To accomplish this, all operations which implicitly renew leases for a client (i.e. OPEN, CLOSE, READ, WRITE, RENEW, LOCK, LOCKT, LOCKU), will return the error NFS4ERR_LEASE_MOVED if responsibility for any of the leases to be renewed has been transferred to a new server. This condition will continue until the client receives an NFS4ERR_MOVED error and the server receives the subsequent GETATTR(fs_locations) for an access to each file system for which a lease has been moved to a new server.",
      "ja": "クライアントが新しいサーバーに移転した可能性のあるリースの更新をスケジュールするためには、クライアントがこれらのリースの有効期限が切れる前にリースの移転について知る必要があります。これを達成するために、クライアントのリースを暗黙的に更新するすべての操作（つまり、オープン、クローズ、読み取り、書き込み、更新、lockt、locku）は、更新されるリースの責任がある場合、エラーNFS4err_lease_movedを返します。新しいサーバーに。この条件は、クライアントがNFS4err_movedエラーを受信し、サーバーがその後のgetattr（fs_locations）を受信して、リースが新しいサーバーに移動された各ファイルシステムへのアクセスを受信するまで続きます。"
    },
    {
      "indent": 3,
      "text": "When a client receives an NFS4ERR_LEASE_MOVED error, it should perform some operation, such as a RENEW, on each file system associated with the server in question. When the client receives an NFS4ERR_MOVED error, the client can follow the normal process to obtain the new server information (through the fs_locations attribute) and perform renewal of those leases on the new server. If the server has not had state transferred to it transparently, it will receive either NFS4ERR_STALE_CLIENTID or NFS4ERR_STALE_STATEID from the new server, as described above, and can then recover state information as it does in the event of server failure.",
      "ja": "クライアントがNFS4ERR_LEASE_MOVEDエラーを受信すると、問題のサーバーに関連付けられた各ファイルシステムで更新などの操作を実行する必要があります。クライアントがNFS4err_movedエラーを受信すると、クライアントは通常のプロセスに従って新しいサーバー情報（FS_Locations属性を介して）を取得し、新しいサーバーでそれらのリースの更新を実行できます。サーバーが状態を透過的に転送していない場合、上記のように新しいサーバーからNFS4ERR_STALE_CLIENTIDまたはNFS4ERR_STALE_STATEIDのいずれかを受信し、サーバーの障害が発生した場合と同様に状態情報を回復できます。"
    },
    {
      "indent": 0,
      "text": "9. Client-Side Caching",
      "section_title": true,
      "ja": "9. クライアント側のキャッシュ"
    },
    {
      "indent": 3,
      "text": "Client-side caching of data, of file attributes, and of file names is essential to providing good performance with the NFS protocol. Providing distributed cache coherence is a difficult problem and previous versions of the NFS protocol have not attempted it. Instead, several NFS client implementation techniques have been used to reduce the problems that a lack of coherence poses for users. These techniques have not been clearly defined by earlier protocol specifications and it is often unclear what is valid or invalid client behavior.",
      "ja": "データ、ファイル属性、およびファイル名のクライアント側のキャッシュは、NFSプロトコルで優れたパフォーマンスを提供するために不可欠です。分散キャッシュコヒーレンスを提供することは困難な問題であり、NFSプロトコルの以前のバージョンはそれを試みていません。代わりに、いくつかのNFSクライアント実装手法が使用されており、コヒーレンスの欠如がユーザーにもたらす問題を軽減しています。これらの手法は、以前のプロトコル仕様によって明確に定義されていないため、クライアントの動作が何であるかまたは無効なものが何であるかは不明です。"
    },
    {
      "indent": 3,
      "text": "The NFS version 4 protocol uses many techniques similar to those that have been used in previous protocol versions. The NFS version 4 protocol does not provide distributed cache coherence. However, it defines a more limited set of caching guarantees to allow locks and share reservations to be used without destructive interference from client side caching.",
      "ja": "NFSバージョン4プロトコルは、以前のプロトコルバージョンで使用されていた手法と同様の多くの手法を使用しています。NFSバージョン4プロトコルは、分散キャッシュコヒーレンスを提供しません。ただし、クライアントサイドキャッシュからの破壊的な干渉なしにロックと共有予約を使用できるようにするために、より限られたキャッシュ保証を定義します。"
    },
    {
      "indent": 3,
      "text": "In addition, the NFS version 4 protocol introduces a delegation mechanism which allows many decisions normally made by the server to be made locally by clients. This mechanism provides efficient support of the common cases where sharing is infrequent or where sharing is read-only.",
      "ja": "さらに、NFSバージョン4プロトコルは、通常、サーバーがクライアントによってローカルに行うことができる多くの決定を可能にする委任メカニズムを導入します。このメカニズムは、共有がまれである、または共有が読み取り専用である一般的なケースの効率的なサポートを提供します。"
    },
    {
      "indent": 0,
      "text": "9.1. Performance Challenges for Client-Side Caching",
      "section_title": true,
      "ja": "9.1. クライアント側のキャッシュのパフォーマンスの課題"
    },
    {
      "indent": 3,
      "text": "Caching techniques used in previous versions of the NFS protocol have been successful in providing good performance. However, several scalability challenges can arise when those techniques are used with very large numbers of clients. This is particularly true when clients are geographically distributed which classically increases the latency for cache revalidation requests.",
      "ja": "NFSプロトコルの以前のバージョンで使用されていたキャッシュ技術は、優れたパフォーマンスを提供することに成功しています。ただし、非常に多くのクライアントでこれらの手法が使用されると、いくつかのスケーラビリティの課題が生じる可能性があります。これは、クライアントが地理的に分布している場合に特に当てはまります。"
    },
    {
      "indent": 3,
      "text": "The previous versions of the NFS protocol repeat their file data cache validation requests at the time the file is opened. This behavior can have serious performance drawbacks. A common case is one in which a file is only accessed by a single client. Therefore, sharing is infrequent.",
      "ja": "NFSプロトコルの以前のバージョンは、ファイルが開かれた時点でファイルデータキャッシュ検証要求を繰り返します。この動作には、深刻なパフォーマンスの欠点があります。一般的なケースは、ファイルが単一のクライアントによってのみアクセスされる場合です。したがって、共有はまれです。"
    },
    {
      "indent": 3,
      "text": "In this case, repeated reference to the server to find that no conflicts exist is expensive. A better option with regards to performance is to allow a client that repeatedly opens a file to do so without reference to the server. This is done until potentially conflicting operations from another client actually occur.",
      "ja": "この場合、競合が存在しないことを発見するためのサーバーへの繰り返しの参照は高価です。パフォーマンスに関するより良いオプションは、サーバーを参照せずにファイルを繰り返し開いているクライアントを許可することです。これは、別のクライアントからの潜在的に矛盾する操作が実際に発生するまで行われます。"
    },
    {
      "indent": 3,
      "text": "A similar situation arises in connection with file locking. Sending file lock and unlock requests to the server as well as the read and write requests necessary to make data caching consistent with the locking semantics (see the section \"Data Caching and File Locking\") can severely limit performance. When locking is used to provide protection against infrequent conflicts, a large penalty is incurred. This penalty may discourage the use of file locking by applications.",
      "ja": "ファイルロックに関連して同様の状況が発生します。ファイルロックとロック解除リクエストをサーバーに送信し、データのキャッシュをロックセマンティクスと一致させるために必要な読み取りおよび書き込み要求（「データキャッシングとファイルロック」セクションを参照）は、パフォーマンスを厳しく制限できます。まれな紛争に対する保護を提供するためにロックを使用すると、大きなペナルティが発生します。このペナルティは、アプリケーションによるファイルロックの使用を阻止する可能性があります。"
    },
    {
      "indent": 3,
      "text": "The NFS version 4 protocol provides more aggressive caching strategies with the following design goals:",
      "ja": "NFSバージョン4プロトコルは、次の設計目標を備えたより積極的なキャッシュ戦略を提供します。"
    },
    {
      "indent": 3,
      "text": "o Compatibility with a large range of server semantics.",
      "ja": "o 幅広いサーバーセマンティクスとの互換性。"
    },
    {
      "indent": 3,
      "text": "o Provide the same caching benefits as previous versions of the NFS protocol when unable to provide the more aggressive model.",
      "ja": "o より積極的なモデルを提供できない場合、NFSプロトコルの以前のバージョンと同じキャッシュ利点を提供します。"
    },
    {
      "indent": 3,
      "text": "o Requirements for aggressive caching are organized so that a large portion of the benefit can be obtained even when not all of the requirements can be met.",
      "ja": "o 積極的なキャッシュの要件は、すべての要件を満たすことができない場合でも、利益の大部分を取得できるように編成されます。"
    },
    {
      "indent": 3,
      "text": "The appropriate requirements for the server are discussed in later sections in which specific forms of caching are covered. (see the section \"Open Delegation\").",
      "ja": "サーバーの適切な要件については、特定の形式のキャッシュがカバーされる後のセクションで説明します。（セクション「Open Delegation」を参照）。"
    },
    {
      "indent": 0,
      "text": "9.2. Delegation and Callbacks",
      "section_title": true,
      "ja": "9.2. 委任とコールバック"
    },
    {
      "indent": 3,
      "text": "Recallable delegation of server responsibilities for a file to a client improves performance by avoiding repeated requests to the server in the absence of inter-client conflict. With the use of a \"callback\" RPC from server to client, a server recalls delegated responsibilities when another client engages in sharing of a delegated file.",
      "ja": "クライアントへのファイルのサーバーの責任の再委任により、クライアント競合がない場合にサーバーへの繰り返しの要求を回避することにより、パフォーマンスが向上します。サーバーからクライアントへの「コールバック」RPCを使用すると、サーバーは、別のクライアントが委任されたファイルの共有に従事したときに委任された責任を思い出します。"
    },
    {
      "indent": 3,
      "text": "A delegation is passed from the server to the client, specifying the object of the delegation and the type of delegation. There are different types of delegations but each type contains a stateid to be used to represent the delegation when performing operations that depend on the delegation. This stateid is similar to those associated with locks and share reservations but differs in that the stateid for a delegation is associated with a clientid and may be used on behalf of all the nfs_lockowners for the given client. A delegation is made to the client as a whole and not to any specific process or thread of control within it.",
      "ja": "委任がサーバーからクライアントに渡され、代表団のオブジェクトと委任の種類が指定されます。さまざまな種類の代表団がありますが、各タイプには、代表団に依存する操作を実行する際に委任を表すために使用されるステートサイドが含まれています。このStateIDは、ロックや共有の予約に関連するものに似ていますが、代表団のStateIDがClientIDに関連付けられており、特定のクライアントのすべてのNFS_Lockownersに代わって使用される可能性があるという点で異なります。代表団は、クライアント全体に行われ、その中の特定のプロセスやコントロールのスレッドではありません。"
    },
    {
      "indent": 3,
      "text": "Because callback RPCs may not work in all environments (due to firewalls, for example), correct protocol operation does not depend on them. Preliminary testing of callback functionality by means of a CB_NULL procedure determines whether callbacks can be supported. The CB_NULL procedure checks the continuity of the callback path. A server makes a preliminary assessment of callback availability to a given client and avoids delegating responsibilities until it has determined that callbacks are supported. Because the granting of a delegation is always conditional upon the absence of conflicting access, clients must not assume that a delegation will be granted and they must always be prepared for OPENs to be processed without any delegations being granted.",
      "ja": "コールバックRPCはすべての環境で機能しない可能性があるため（たとえば、ファイアウォールなど）、正しいプロトコル操作はそれらに依存しません。CB_NULLプロシージャによるコールバック機能の予備テストにより、コールバックをサポートできるかどうかが決まります。CB_NULLプロシージャは、コールバックパスの連続性をチェックします。サーバーは、特定のクライアントにコールバックの可用性を予備的に評価し、コールバックがサポートされると判断されるまで責任の委任を回避します。代表団の付与は常に対立するアクセスがないことを条件としているため、クライアントは代表団が付与されると仮定してはなりません。"
    },
    {
      "indent": 3,
      "text": "Once granted, a delegation behaves in most ways like a lock. There is an associated lease that is subject to renewal together with all of the other leases held by that client.",
      "ja": "与えられたら、代表団はほとんどの点でロックのように振る舞います。そのクライアントが保有する他のすべてのリースと一緒に更新の対象となる関連するリースがあります。"
    },
    {
      "indent": 3,
      "text": "Unlike locks, an operation by a second client to a delegated file will cause the server to recall a delegation through a callback.",
      "ja": "Locksとは異なり、2番目のクライアントによる委任されたファイルへの操作により、サーバーはコールバックを介して代表団をリコールします。"
    },
    {
      "indent": 3,
      "text": "On recall, the client holding the delegation must flush modified state (such as modified data) to the server and return the delegation. The conflicting request will not receive a response until the recall is complete. The recall is considered complete when the client returns the delegation or the server times out on the recall and revokes the delegation as a result of the timeout. Following the resolution of the recall, the server has the information necessary to grant or deny the second client's request.",
      "ja": "リコールでは、代表団を保持しているクライアントは、変更された状態（変更されたデータなど）をサーバーにフラッシュし、代表団を返す必要があります。競合するリクエストは、リコールが完了するまで応答を受け取りません。リコールは、クライアントが代表団を返したり、サーバーがリコールでタイムアウトしたり、タイムアウトの結果として代表団を取り消すときに完全であると見なされます。リコールの解決に続いて、サーバーには、2番目のクライアントの要求を許可または拒否するために必要な情報があります。"
    },
    {
      "indent": 3,
      "text": "At the time the client receives a delegation recall, it may have substantial state that needs to be flushed to the server. Therefore, the server should allow sufficient time for the delegation to be returned since it may involve numerous RPCs to the server. If the server is able to determine that the client is diligently flushing state to the server as a result of the recall, the server may extend the usual time allowed for a recall. However, the time allowed for recall completion should not be unbounded.",
      "ja": "クライアントが代表団のリコールを受け取るとき、それはサーバーに洗い流す必要があるかなりの状態を持っているかもしれません。したがって、サーバーは、サーバーに多数のRPCが関与する可能性があるため、代表団が返されるのに十分な時間を確保する必要があります。サーバーが、リコールの結果としてクライアントがサーバーに深くフラッシングしていることを判断できる場合、サーバーはリコールに許容される通常の時間を延長する場合があります。ただし、リコールの完了が許可されている時間は、無制限にすべきではありません。"
    },
    {
      "indent": 3,
      "text": "An example of this is when responsibility to mediate opens on a given file is delegated to a client (see the section \"Open Delegation\"). The server will not know what opens are in effect on the client. Without this knowledge the server will be unable to determine if the access and deny state for the file allows any particular open until the delegation for the file has been returned.",
      "ja": "この例は、特定のファイルでオープンする責任がクライアントに委任される場合です（セクション「Open Delegation」を参照）。サーバーは、オープンがクライアントに有効になっているものを知りません。この知識がなければ、ファイルの代表団が返されるまで、ファイルのアクセスと拒否状態が特定の開くことを許可するかどうかをサーバーが判断できません。"
    },
    {
      "indent": 3,
      "text": "A client failure or a network partition can result in failure to respond to a recall callback. In this case, the server will revoke the delegation which in turn will render useless any modified state still on the client.",
      "ja": "クライアントの失敗またはネットワークパーティションにより、リコールコールバックへの応答に失敗する可能性があります。この場合、サーバーは代表団を取り消し、これにより、クライアントのまだ修正された状態が役に立たなくなります。"
    },
    {
      "indent": 0,
      "text": "9.2.1. Delegation Recovery",
      "section_title": true,
      "ja": "9.2.1. 委任回復"
    },
    {
      "indent": 3,
      "text": "There are three situations that delegation recovery must deal with:",
      "ja": "代表団の回復が対処しなければならない3つの状況があります。"
    },
    {
      "indent": 3,
      "text": "o Client reboot or restart",
      "ja": "o クライアントの再起動または再起動"
    },
    {
      "indent": 3,
      "text": "o Server reboot or restart",
      "ja": "o サーバーの再起動または再起動"
    },
    {
      "indent": 3,
      "text": "o Network partition (full or callback-only)",
      "ja": "o ネットワークパーティション（フルまたはコールバックのみ）"
    },
    {
      "indent": 3,
      "text": "In the event the client reboots or restarts, the failure to renew leases will result in the revocation of record locks and share reservations. Delegations, however, may be treated a bit differently.",
      "ja": "クライアントが再起動または再起動した場合、リースを更新できなかったため、レコードロックが取り消され、留保が発生します。ただし、代表団は少し違った扱いを行うことができます。"
    },
    {
      "indent": 3,
      "text": "There will be situations in which delegations will need to be reestablished after a client reboots or restarts. The reason for this is the client may have file data stored locally and this data was associated with the previously held delegations. The client will need to reestablish the appropriate file state on the server.",
      "ja": "クライアントが再起動または再起動した後、代表団を再確立する必要がある状況があります。その理由は、クライアントがローカルに保存されているファイルデータを持っている可能性があり、このデータは以前に保持された代表団に関連付けられていたためです。クライアントは、サーバー上の適切なファイル状態を再確立する必要があります。"
    },
    {
      "indent": 3,
      "text": "To allow for this type of client recovery, the server may extend the period for delegation recovery beyond the typical lease expiration period. This implies that requests from other clients that conflict with these delegations will need to wait. Because the normal recall process may require significant time for the client to flush changed state to the server, other clients need be prepared for delays that occur because of a conflicting delegation. This longer interval would increase the window for clients to reboot and consult stable storage so that the delegations can be reclaimed. For open delegations, such delegations are reclaimed using OPEN with a claim type of CLAIM_DELEGATE_PREV. (see the sections on \"Data Caching and Revocation\" and \"Operation 18: OPEN\" for discussion of open delegation and the details of OPEN respectively).",
      "ja": "このタイプのクライアントの回復を可能にするために、サーバーは、典型的なリースの有効期間を超えて、委任回復の期間を延長する場合があります。これは、これらの代表団と競合する他のクライアントからの要求が待つ必要があることを意味します。通常のリコールプロセスは、クライアントが変更された状態をサーバーにフラッシュするためにかなりの時間を必要とする可能性があるため、他のクライアントは、矛盾する委任のために発生する遅延のために準備する必要があります。この長い間隔は、クライアントが再起動して安定したストレージを再起動して相談するためにウィンドウを増やし、代表団を再生できるようにします。オープンな代表団の場合、そのような代表団は、請求タイプの請求タイプでオープンを使用して回収されます。（オープン委任と開いた詳細の議論については、「データキャッシュと取り消し」と「操作18：オープン」のセクションを参照してください）。"
    },
    {
      "indent": 3,
      "text": "When the server reboots or restarts, delegations are reclaimed (using the OPEN operation with CLAIM_DELEGATE_PREV) in a similar fashion to record locks and share reservations. However, there is a slight semantic difference. In the normal case if the server decides that a delegation should not be granted, it performs the requested action (e.g. OPEN) without granting any delegation. For reclaim, the server grants the delegation but a special designation is applied so that the client treats the delegation as having been granted but recalled by the server. Because of this, the client has the duty to write all modified state to the server and then return the delegation. This process of handling delegation reclaim reconciles three principles of the NFS Version 4 protocol:",
      "ja": "サーバーが再起動または再起動すると、代表団が再生されます（racke_delegate_prevでオープン操作を使用して）ロックを記録して予約を共有します。ただし、わずかな意味の違いがあります。通常の場合、サーバーが代表団に付与されてはならないと判断した場合、代表団を付与せずに要求されたアクション（オープン）を実行します。回収のために、サーバーは代表団を付与しますが、特別な指定が適用され、クライアントが委任を認められたが、サーバーによって想起されるように扱います。このため、クライアントはすべての変更された状態をサーバーに書き込み、代表団を返す義務があります。代表団の取り扱いのこのプロセスは、NFSバージョン4プロトコルの3つの原則を調整します。"
    },
    {
      "indent": 3,
      "text": "o Upon reclaim, a client reporting resources assigned to it by an earlier server instance must be granted those resources.",
      "ja": "o 回収されると、以前のサーバーインスタンスによって割り当てられたリソースを報告するクライアントに、それらのリソースを付与する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The server has unquestionable authority to determine whether delegations are to be granted and, once granted, whether they are to be continued.",
      "ja": "o サーバーには、代表団が付与されるかどうか、および付与が継続されるかどうかを判断する疑いのない権限があります。"
    },
    {
      "indent": 3,
      "text": "o The use of callbacks is not to be depended upon until the client has proven its ability to receive them.",
      "ja": "o クライアントがそれらを受信する能力を証明するまで、コールバックの使用は依存してはなりません。"
    },
    {
      "indent": 3,
      "text": "When a network partition occurs, delegations are subject to freeing by the server when the lease renewal period expires. This is similar to the behavior for locks and share reservations. For delegations, however, the server may extend the period in which conflicting requests are held off. Eventually the occurrence of a conflicting request from another client will cause revocation of the delegation. A loss of the callback path (e.g. by later network configuration change) will have the same effect. A recall request will fail and revocation of the delegation will result.",
      "ja": "ネットワークパーティションが発生すると、リース更新期間が期限切れになったときに、代表団がサーバーによって解放される可能性があります。これは、ロックの動作と予約を共有することに似ています。ただし、代表団の場合、サーバーは、競合するリクエストが延期される期間を延長する場合があります。最終的に、別のクライアントからの矛盾する要求が発生すると、代表団が取り消されます。コールバックパスの損失（たとえば、後のネットワーク構成の変更など）は同じ効果をもたらします。リコール要求が失敗し、代表団の取り消しが生じます。"
    },
    {
      "indent": 3,
      "text": "A client normally finds out about revocation of a delegation when it uses a stateid associated with a delegation and receives the error NFS4ERR_EXPIRED. It also may find out about delegation revocation after a client reboot when it attempts to reclaim a delegation and receives that same error. Note that in the case of a revoked write open delegation, there are issues because data may have been modified by the client whose delegation is revoked and separately by other clients. See the section \"Revocation Recovery for Write Open Delegation\" for a discussion of such issues. Note also that when delegations are revoked, information about the revoked delegation will be written by the server to stable storage (as described in the section \"Crash Recovery\"). This is done to deal with the case in which a server reboots after revoking a delegation but before the client holding the revoked delegation is notified about the revocation.",
      "ja": "クライアントは通常、代表団に関連付けられたStateIDを使用し、エラーNFS4err_Expiredを受け取った場合、代表団の取り消しについて知ります。また、クライアントが代表団を取り戻そうとし、同じエラーを受け取ろうとすると、クライアントが再起動した後に委任の取り消しについても発見されるかもしれません。取り消された書き込みオープン代表団の場合、委任が取り消され、他のクライアントによって別々に委任されたクライアントによって変更された可能性があるため、問題があることに注意してください。このような問題についての議論については、「Open Delegationの書き込みのための取り消し回収」セクションを参照してください。また、代表団が取り消されると、取り消された代表団に関する情報は、サーバーによって安定したストレージに記述されることに注意してください（セクション「クラッシュリカバリー」で説明されています）。これは、代表団を取り消した後にサーバーが再起動し、クライアントが取り消された代表団を保持する前に取り消しについて通知される場合に対処するために行われます。"
    },
    {
      "indent": 0,
      "text": "9.3. Data Caching",
      "section_title": true,
      "ja": "9.3. データキャッシング"
    },
    {
      "indent": 3,
      "text": "When applications share access to a set of files, they need to be implemented so as to take account of the possibility of conflicting access by another application. This is true whether the applications in question execute on different clients or reside on the same client.",
      "ja": "アプリケーションがファイルのセットへのアクセスを共有する場合、別のアプリケーションによる矛盾するアクセスの可能性を考慮するために、それらを実装する必要があります。これは、問題のアプリケーションが異なるクライアントで実行されるか、同じクライアントに居住するかどうかに当てはまります。"
    },
    {
      "indent": 3,
      "text": "Share reservations and record locks are the facilities the NFS version 4 protocol provides to allow applications to coordinate access by providing mutual exclusion facilities. The NFS version 4 protocol's data caching must be implemented such that it does not invalidate the assumptions that those using these facilities depend upon.",
      "ja": "株式予約とレコードロックは、NFSバージョン4プロトコルが提供する施設です。NFSバージョン4プロトコルのデータキャッシュは、これらの施設を使用している人が依存しているという仮定を無効にしないように実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "9.3.1. Data Caching and OPENs",
      "section_title": true,
      "ja": "9.3.1. データキャッシュと開き"
    },
    {
      "indent": 3,
      "text": "In order to avoid invalidating the sharing assumptions that applications rely on, NFS version 4 clients should not provide cached data to applications or modify it on behalf of an application when it would not be valid to obtain or modify that same data via a READ or WRITE operation.",
      "ja": "アプリケーションに依存している共有の仮定の無効化を回避するために、NFSバージョン4クライアントは、読み取りまたは書き込みを介して同じデータを取得または変更することが有効でない場合、アプリケーションにキャッシュされたデータを提供したり、アプリケーションに代わって変更したりするべきではありません。手術。"
    },
    {
      "indent": 3,
      "text": "Furthermore, in the absence of open delegation (see the section \"Open Delegation\") two additional rules apply. Note that these rules are obeyed in practice by many NFS version 2 and version 3 clients.",
      "ja": "さらに、オープン代表団が存在しない場合（セクション「Open Delegation」を参照）、2つの追加ルールが適用されます。これらのルールは、多くのNFSバージョン2およびバージョン3のクライアントによって実際に従っていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "o First, cached data present on a client must be revalidated after doing an OPEN. This is to ensure that the data for the OPENed file is still correctly reflected in the client's cache. This validation must be done at least when the client's OPEN operation includes DENY=WRITE or BOTH thus terminating a period in which other clients may have had the opportunity to open the file with WRITE access. Clients may choose to do the revalidation more often (i.e. at OPENs specifying DENY=NONE) to parallel the NFS version 3 protocol's practice for the benefit of users assuming this degree of cache revalidation.",
      "ja": "o まず、クライアントに存在するキャッシュデータは、オープンした後に再確認する必要があります。これは、開いたファイルのデータがクライアントのキャッシュにまだ正しく反映されるようにするためです。この検証は、少なくともクライアントのオープン操作にdeny = writeまたはその両方が含まれている場合、他のクライアントが書き込みアクセスでファイルを開く機会があった期間を終了する場合に実行する必要があります。クライアントは、この程度のキャッシュの再検証を想定するために、ユーザーの利益のためにNFSバージョン3プロトコルのプラクティスを並行するために、より頻繁に再検証を行うことを選択できます（つまり、deny = noneを指定します）。"
    },
    {
      "indent": 3,
      "text": "o Second, modified data must be flushed to the server before closing a file OPENed for write. This is complementary to the first rule. If the data is not flushed at CLOSE, the revalidation done after client OPENs as file is unable to achieve its purpose. The other aspect to flushing the data before close is that the data must be committed to stable storage, at the server, before the CLOSE operation is requested by the client. In the case of a server reboot or restart and a CLOSEd file, it may not be possible to retransmit the data to be written to the file. Hence, this requirement.",
      "ja": "o 第二に、書き込みのために開いたファイルを閉じる前に、変更されたデータをサーバーにフラッシュする必要があります。これは、最初のルールを補完します。データが近くでフラッシュされない場合、ファイルがその目的を達成できないため、クライアントが開いた後に行われた再検証が行われます。クライアントが操作を要求する前に、データがサーバーで安定したストレージにコミットする必要があるということです。サーバーの再起動または再起動および閉じたファイルの場合、ファイルに書き込まれるデータを再送信することはできない場合があります。したがって、この要件。"
    },
    {
      "indent": 0,
      "text": "9.3.2. Data Caching and File Locking",
      "section_title": true,
      "ja": "9.3.2. データキャッシングとファイルロック"
    },
    {
      "indent": 3,
      "text": "For those applications that choose to use file locking instead of share reservations to exclude inconsistent file access, there is an analogous set of constraints that apply to client side data caching. These rules are effective only if the file locking is used in a way that matches in an equivalent way the actual READ and WRITE operations executed. This is as opposed to file locking that is based on pure convention. For example, it is possible to manipulate a two-megabyte file by dividing the file into two one-megabyte regions and protecting access to the two regions by file locks on bytes zero and one. A lock for write on byte zero of the file would represent the right to do READ and WRITE operations on the first region. A lock for write on byte one of the file would represent the right to do READ and WRITE operations on the second region. As long as all applications manipulating the file obey this convention, they will work on a local file system. However, they may not work with the NFS version 4 protocol unless clients refrain from data caching.",
      "ja": "一貫性のないファイルアクセスを除外して共有予約の代わりにファイルロックを使用することを選択したアプリケーションには、クライアントサイドデータキャッシュに適用される類似の制約セットがあります。これらのルールは、ファイルロックが実際の読み取り操作が実行された同等の方法で一致する方法で使用される場合にのみ有効です。これは、純粋な慣習に基づいたファイルロックとは対照的です。たとえば、ファイルを2つの1メガバイト領域に分割し、バイトゼロと1つのファイルロックで2つの領域へのアクセスを保護することにより、2メガバイトファイルを操作することができます。ファイルのバイトゼロに関する書き込み用のロックは、最初の領域で操作を読み書きする権利を表します。ファイルの1つに書き込みのロックは、2番目の領域で操作を読み書きする権利を表します。ファイルを操作するすべてのアプリケーションがこの慣習に従う限り、彼らはローカルファイルシステムで動作します。ただし、クライアントがデータキャッシングを控えない限り、NFSバージョン4プロトコルで動作しない場合があります。"
    },
    {
      "indent": 3,
      "text": "The rules for data caching in the file locking environment are:",
      "ja": "ファイルロック環境でのデータキャッシュのルールは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o First, when a client obtains a file lock for a particular region, the data cache corresponding to that region (if any cache data exists) must be revalidated. If the change attribute indicates that the file may have been updated since the cached data was obtained, the client must flush or invalidate the cached data for the newly locked region. A client might choose to invalidate all of non-modified cached data that it has for the file but the only requirement for correct operation is to invalidate all of the data in the newly locked region.",
      "ja": "o まず、クライアントが特定の領域のファイルロックを取得する場合、その領域に対応するデータキャッシュ（キャッシュデータが存在する場合）を再確認する必要があります。CACHEDデータが取得されてからファイルが更新された可能性があることを変更属性が示す場合、クライアントは、新しくロックされた領域のキャッシュデータをフラッシュまたは無効にする必要があります。クライアントは、ファイルにある非変更化されていないキャッシュデータをすべて無効にすることを選択する場合がありますが、正しい操作の唯一の要件は、新しくロックされた地域のすべてのデータを無効にすることです。"
    },
    {
      "indent": 3,
      "text": "o Second, before releasing a write lock for a region, all modified data for that region must be flushed to the server. The modified data must also be written to stable storage.",
      "ja": "o 第二に、地域の書き込みロックをリリースする前に、その地域のすべての変更されたデータをサーバーにフラッシュする必要があります。変更されたデータは、安定したストレージにも書き込まなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that flushing data to the server and the invalidation of cached data must reflect the actual byte ranges locked or unlocked. Rounding these up or down to reflect client cache block boundaries will cause problems if not carefully done. For example, writing a modified block when only half of that block is within an area being unlocked may cause invalid modification to the region outside the unlocked area. This, in turn, may be part of a region locked by another client. Clients can avoid this situation by synchronously performing portions of write operations that overlap that portion (initial or final) that is not a full block. Similarly, invalidating a locked area which is not an integral number of full buffer blocks would require the client to read one or two partial blocks from the server if the revalidation procedure shows that the data which the client possesses may not be valid.",
      "ja": "データをサーバーにフラッシングし、キャッシュされたデータの無効化は、ロックまたはロック解除された実際のバイト範囲を反映する必要があることに注意してください。クライアントのキャッシュブロックの境界を反映するためにこれらを丸めたり下にしたりすると、慎重に行わないと問題が発生します。たとえば、そのブロックの半分のみがロック解除されている領域内にある場合に変更されたブロックを作成すると、ロックされていない領域の外側の領域が無効な変更を引き起こす可能性があります。これは、別のクライアントによってロックされた地域の一部である可能性があります。クライアントは、フルブロックではないその部分（初期または最終）を重複させる書き込み操作の一部を同期的に実行することにより、この状況を回避できます。同様に、完全なバッファーブロックの積分数ではないロックされた領域を無効にすると、再確認手順がクライアントが所有するデータが有効でない可能性があることを示している場合、クライアントはサーバーから1つまたは2つの部分ブロックを読み取る必要があります。"
    },
    {
      "indent": 3,
      "text": "The data that is written to the server as a pre-requisite to the unlocking of a region must be written, at the server, to stable storage. The client may accomplish this either with synchronous writes or by following asynchronous writes with a COMMIT operation. This is required because retransmission of the modified data after a server reboot might conflict with a lock held by another client.",
      "ja": "地域のロック解除の前提条件としてサーバーに書き込まれるデータは、サーバーで安定したストレージに記述する必要があります。クライアントは、同期の書き込みでこれを達成するか、非同期の書き込みをコミット操作でフォローすることにより、これを達成することができます。これは、サーバーの再起動後の変更されたデータの再送信が別のクライアントが保持しているロックと競合する可能性があるため、必要です。"
    },
    {
      "indent": 3,
      "text": "A client implementation may choose to accommodate applications which use record locking in non-standard ways (e.g. using a record lock as a global semaphore) by flushing to the server more data upon an LOCKU than is covered by the locked range. This may include modified data within files other than the one for which the unlocks are being done. In such cases, the client must not interfere with applications whose READs and WRITEs are being done only within the bounds of record locks which the application holds. For example, an application locks a single byte of a file and proceeds to write that single byte. A client that chose to handle a LOCKU by flushing all modified data to the server could validly write that single byte in response to an unrelated unlock. However, it would not be valid to write the entire block in which that single written byte was located since it includes an area that is not locked and might be locked by another client. Client implementations can avoid this problem by dividing files with modified data into those for which all modifications are done to areas covered by an appropriate record lock and those for which there are modifications not covered by a record lock. Any writes done for the former class of files must not include areas not locked and thus not modified on the client.",
      "ja": "クライアントの実装では、ロックされた範囲でカバーされるよりも多くのデータをサーバーにフラッシュすることにより、標準以外の方法でレコードロックを使用するアプリケーション（グローバルセマフォとしてレコードロックを使用する）に対応することを選択できます。これには、ロック解除が行われているファイル以外のファイル内の変更されたデータが含まれる場合があります。そのような場合、クライアントは、アプリケーションが保持しているレコードロックの範囲内でのみ読み取りと書き込みが行われているアプリケーションに干渉してはなりません。たとえば、アプリケーションはファイルの単一のバイトをロックし、その単一のバイトを書き込むために進みます。すべての変更されたデータをサーバーにフラッシュすることでLockuを処理することを選択したクライアントは、無関係なロック解除に応じてその単一のバイトを有効に記述できます。ただし、ロックされておらず、別のクライアントによってロックされる可能性のある領域が含まれているため、単一の書かれたバイトが配置されたブロック全体を書き込むことは有効ではありません。クライアントの実装は、ファイルを変更したデータで除算することにより、すべての変更が適切なレコードロックでカバーされている領域と、レコードロックでカバーされていない変更があるものに行われる問題にこの問題を回避できます。以前のクラスのファイルに対して行われた書き込みは、クライアントにロックされていないため変更されていない領域を含めてはなりません。"
    },
    {
      "indent": 0,
      "text": "9.3.3. Data Caching and Mandatory File Locking",
      "section_title": true,
      "ja": "9.3.3. データキャッシングと必須ファイルロック"
    },
    {
      "indent": 3,
      "text": "Client side data caching needs to respect mandatory file locking when it is in effect. The presence of mandatory file locking for a given file is indicated in the result flags for an OPEN. When mandatory locking is in effect for a file, the client must check for an appropriate file lock for data being read or written. If a lock exists for the range being read or written, the client may satisfy the request using the client's validated cache. If an appropriate file lock is not held for the range of the read or write, the read or write request must not be satisfied by the client's cache and the request must be sent to the server for processing. When a read or write request partially overlaps a locked region, the request should be subdivided into multiple pieces with each region (locked or not) treated appropriately.",
      "ja": "クライアントサイドデータキャッシュは、有効な場合、必須ファイルロックを尊重する必要があります。特定のファイルの必須ファイルロックの存在は、Openの結果フラグに示されています。ファイルに対して必須のロックが有効である場合、クライアントは、データが読み取られたり書かれたりするための適切なファイルロックをチェックする必要があります。読み取られている範囲にロックが存在する場合、クライアントはクライアントの検証されたキャッシュを使用してリクエストを満たすことができます。読み取りまたは書き込みの範囲に適切なファイルロックが保持されていない場合、読み取りまたは書き込み要求をクライアントのキャッシュによって満たす必要はなく、リクエストを処理のためにサーバーに送信する必要があります。読み取りまたは書き込み要求がロックされた領域と部分的に重複する場合、各領域（ロックされているかどうか）が適切に処理されている複数のピースにリクエストを細分化する必要があります。"
    },
    {
      "indent": 0,
      "text": "9.3.4. Data Caching and File Identity",
      "section_title": true,
      "ja": "9.3.4. データキャッシングとファイルアイデンティティ"
    },
    {
      "indent": 3,
      "text": "When clients cache data, the file data needs to organized according to the file system object to which the data belongs. For NFS version 3 clients, the typical practice has been to assume for the purpose of caching that distinct filehandles represent distinct file system objects. The client then has the choice to organize and maintain the data cache on this basis.",
      "ja": "クライアントがデータをキャッシュするとき、ファイルデータは、データが属するファイルシステムオブジェクトに従って編成する必要があります。NFSバージョン3のクライアントの場合、典型的なプラクティスは、異なるファイルハンドルが異なるファイルシステムオブジェクトを表すことをキャッシュする目的で想定することでした。その後、クライアントは、これに基づいてデータキャッシュを整理して維持することを選択します。"
    },
    {
      "indent": 3,
      "text": "In the NFS version 4 protocol, there is now the possibility to have significant deviations from a \"one filehandle per object\" model because a filehandle may be constructed on the basis of the object's pathname. Therefore, clients need a reliable method to determine if two filehandles designate the same file system object. If clients were simply to assume that all distinct filehandles denote distinct objects and proceed to do data caching on this basis, caching inconsistencies would arise between the distinct client side objects which mapped to the same server side object.",
      "ja": "NFSバージョン4プロトコルでは、ファイルハンドルがオブジェクトのパス名に基づいて構築される可能性があるため、「オブジェクトごとに1つのファイルハンドル」モデルから重要な逸脱を持つ可能性があります。したがって、クライアントは、2つのファイルハンドルが同じファイルシステムオブジェクトを指定するかどうかを判断するための信頼できる方法を必要とします。クライアントが、すべての異なるファイルハンドルが異なるオブジェクトを示し、これに基づいてデータキャッシュを実行することを単に想定している場合、同じサーバー側オブジェクトにマッピングされた異なるクライアント側オブジェクト間でキャッシュの矛盾が発生します。"
    },
    {
      "indent": 3,
      "text": "By providing a method to differentiate filehandles, the NFS version 4 protocol alleviates a potential functional regression in comparison with the NFS version 3 protocol. Without this method, caching inconsistencies within the same client could occur and this has not been present in previous versions of the NFS protocol. Note that it is possible to have such inconsistencies with applications executing on multiple clients but that is not the issue being addressed here.",
      "ja": "ファイルハンドルを区別する方法を提供することにより、NFSバージョン4プロトコルは、NFSバージョン3プロトコルと比較して潜在的な機能回帰を緩和します。この方法がなければ、同じクライアント内のキャッシュ矛盾が発生する可能性があり、これはNFSプロトコルの以前のバージョンには存在していません。複数のクライアントで実行されるアプリケーションとそのような矛盾を持つことは可能ですが、それはここで対処されている問題ではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "For the purposes of data caching, the following steps allow an NFS version 4 client to determine whether two distinct filehandles denote the same server side object: o If GETATTR directed to two filehandles have different values of the fsid attribute, then the filehandles represent distinct objects.",
      "ja": "データキャッシュの目的のために、次の手順では、NFSバージョン4クライアントが2つの異なるファイルハンドルが同じサーバー側オブジェクトを示すかどうかを判断することができます。O2つのファイルハンドルに向けられたgetattrがFSID属性の値が異なる場合、ファイルハンドルは異なるオブジェクトを表します。"
    },
    {
      "indent": 3,
      "text": "o If GETATTR for any file with an fsid that matches the fsid of the two filehandles in question returns a unique_handles attribute with a value of TRUE, then the two objects are distinct.",
      "ja": "o 問題の2つのファイルハンドルのFSIDに一致するFSIDを備えたファイルのgetattrがtrueの値を持つsinque_handles属性を返している場合、2つのオブジェクトは異なります。"
    },
    {
      "indent": 3,
      "text": "o If GETATTR directed to the two filehandles does not return the fileid attribute for one or both of the handles, then the it cannot be determined whether the two objects are the same. Therefore, operations which depend on that knowledge (e.g. client side data caching) cannot be done reliably.",
      "ja": "o 2つのファイルハンドルに向けられたgetattrが、1つまたは両方のハンドルに対してfileID属性を返さない場合、2つのオブジェクトが同じかどうかを決定することはできません。したがって、その知識に依存する操作（たとえば、クライアントサイドデータキャッシュ）を確実に行うことはできません。"
    },
    {
      "indent": 3,
      "text": "o If GETATTR directed to the two filehandles returns different values for the fileid attribute, then they are distinct objects.",
      "ja": "o GetAttrが2つのFileHandlesに向けられた場合、FileID属性の異なる値を返している場合、それらは異なるオブジェクトです。"
    },
    {
      "indent": 3,
      "text": "o Otherwise they are the same object.",
      "ja": "o それ以外の場合、それらは同じオブジェクトです。"
    },
    {
      "indent": 0,
      "text": "9.4. Open Delegation",
      "section_title": true,
      "ja": "9.4. オープン代表団"
    },
    {
      "indent": 3,
      "text": "When a file is being OPENed, the server may delegate further handling of opens and closes for that file to the opening client. Any such delegation is recallable, since the circumstances that allowed for the delegation are subject to change. In particular, the server may receive a conflicting OPEN from another client, the server must recall the delegation before deciding whether the OPEN from the other client may be granted. Making a delegation is up to the server and clients should not assume that any particular OPEN either will or will not result in an open delegation. The following is a typical set of conditions that servers might use in deciding whether OPEN should be delegated:",
      "ja": "ファイルが開かれている場合、サーバーはそのファイルの開閉をさらに紹介し、オープニングクライアントに閉じます。そのような委任は、代表団を許可した状況が変化の対象となるため、回復可能です。特に、サーバーは他のクライアントから競合するオープンを受信する場合があります。サーバーは、他のクライアントからのオープンが許可されるかどうかを決定する前に、代表団をリコールする必要があります。代表団を作ることはサーバー次第であり、クライアントは特定のオープンがオープン代表団になるかどうかを想定してはなりません。以下は、オープンを委任すべきかどうかを決定する際にサーバーが使用できる典型的な条件セットです。"
    },
    {
      "indent": 3,
      "text": "o The client must be able to respond to the server's callback requests. The server will use the CB_NULL procedure for a test of callback ability.",
      "ja": "o クライアントは、サーバーのコールバック要求に応答できる必要があります。サーバーは、コールバック機能のテストにCB_NULLプロシージャを使用します。"
    },
    {
      "indent": 3,
      "text": "o The client must have responded properly to previous recalls.",
      "ja": "o クライアントは、以前のリコールに適切に応答している必要があります。"
    },
    {
      "indent": 3,
      "text": "o There must be no current open conflicting with the requested delegation.",
      "ja": "o 要求された代表団と対立する現在のオープンはあってはなりません。"
    },
    {
      "indent": 3,
      "text": "o There should be no current delegation that conflicts with the delegation being requested.",
      "ja": "o 要求されている代表団と矛盾する現在の代表団はないはずです。"
    },
    {
      "indent": 3,
      "text": "o The probability of future conflicting open requests should be low based on the recent history of the file.",
      "ja": "o 将来の矛盾するオープンリクエストの確率は、ファイルの最近の履歴に基づいて低くする必要があります。"
    },
    {
      "indent": 3,
      "text": "o The existence of any server-specific semantics of OPEN/CLOSE that would make the required handling incompatible with the prescribed handling that the delegated client would apply (see below).",
      "ja": "o 委任されたクライアントが適用する規定の処理と互換性のない、必要な処理が互換性のないオープン/クローズのサーバー固有のセマンティクスの存在（以下を参照）。"
    },
    {
      "indent": 3,
      "text": "There are two types of open delegations, read and write. A read open delegation allows a client to handle, on its own, requests to open a file for reading that do not deny read access to others. Multiple read open delegations may be outstanding simultaneously and do not conflict. A write open delegation allows the client to handle, on its own, all opens. Only one write open delegation may exist for a given file at a given time and it is inconsistent with any read open delegations.",
      "ja": "読み取りと書き込みのオープン代表団には2つのタイプがあります。読み取りオープン代表団を使用すると、クライアントは、他の人への読み取りアクセスを拒否しない読み取り用のファイルを開くことを自然に処理できます。複数の読み取りオープン代表団は同時に傑出している可能性があり、競合しない可能性があります。オープン代表団の書き込みにより、クライアントはそれ自体ですべてを扱うことができます。特定のファイルのために特定のファイルのために存在する可能性のある1つの書き込みのオープン代表団のみが、読み取りオープン代表団と矛盾しています。"
    },
    {
      "indent": 3,
      "text": "When a client has a read open delegation, it may not make any changes to the contents or attributes of the file but it is assured that no other client may do so. When a client has a write open delegation, it may modify the file data since no other client will be accessing the file's data. The client holding a write delegation may only affect file attributes which are intimately connected with the file data: object_size, time_modify, change.",
      "ja": "クライアントが読み取りオープン代表団を持っている場合、ファイルのコンテンツや属性に変更を加えない場合がありますが、他のクライアントがそうすることはできないことが保証されています。クライアントがOpen Dechrationの書き込みを行うと、他のクライアントがファイルのデータにアクセスしないため、ファイルデータを変更する場合があります。書き込み代表団を保持しているクライアントは、ファイルデータに密接に接続されているファイル属性のみに影響する場合があります：object_size、time_modify、変更。"
    },
    {
      "indent": 3,
      "text": "When a client has an open delegation, it does not send OPENs or CLOSEs to the server but updates the appropriate status internally. For a read open delegation, opens that cannot be handled locally (opens for write or that deny read access) must be sent to the server.",
      "ja": "クライアントがオープンな代表団を持っている場合、サーバーへのオープンまたはクローズを送信することはなく、適切なステータスを内部的に更新します。読み取りオープン代表団の場合、ローカルで処理できないオープン（書き込みのために開くか、読み取りアクセスを拒否）をサーバーに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "When an open delegation is made, the response to the OPEN contains an open delegation structure which specifies the following:",
      "ja": "オープンな委任が行われると、オープンへの応答には、以下を指定するオープンな代表団構造が含まれています。"
    },
    {
      "indent": 3,
      "text": "o the type of delegation (read or write)",
      "ja": "o 代表団の種類（読み書きまたは書き込み）"
    },
    {
      "indent": 3,
      "text": "o space limitation information to control flushing of data on close (write open delegation only, see the section \"Open Delegation and Data Caching\")",
      "ja": "o スペース制限情報は、閉鎖上のデータのフラッシングを制御するための情報を制御するための情報（オープン代表団のみを記述し、セクション「Open Deligation and Data Caching」を参照してください）"
    },
    {
      "indent": 3,
      "text": "o an nfsace4 specifying read and write permissions",
      "ja": "o 読み取りおよび書き込み許可を指定するNFSACE4"
    },
    {
      "indent": 3,
      "text": "o a stateid to represent the delegation for READ and WRITE",
      "ja": "o 読み取りと書き込みの代表団を表すStateid"
    },
    {
      "indent": 3,
      "text": "The stateid is separate and distinct from the stateid for the OPEN proper. The standard stateid, unlike the delegation stateid, is associated with a particular nfs_lockowner and will continue to be valid after the delegation is recalled and the file remains open.",
      "ja": "StateIDは、オープンな適切なためにStateIDとは別に異なります。Standard StateIDは、代表団StateIDとは異なり、特定のNFS_Lockownerに関連付けられており、代表団がリコールされ、ファイルが開いたままである後も引き続き有効になります。"
    },
    {
      "indent": 3,
      "text": "When a request internal to the client is made to open a file and open delegation is in effect, it will be accepted or rejected solely on the basis of the following conditions. Any requirement for other checks to be made by the delegate should result in open delegation being denied so that the checks can be made by the server itself.",
      "ja": "クライアントの内部リクエストがファイルを開き、オープン代表団が有効になると、以下の条件に基づいてのみ受け入れられたり拒否されたりします。代表者が行う他のチェックの要件は、サーバー自体がチェックを行うことができるように、オープンな代表団を拒否されることになります。"
    },
    {
      "indent": 3,
      "text": "o The access and deny bits for the request and the file as described in the section \"Share Reservations\".",
      "ja": "o 「リクエストの共有予約」セクションで説明されているように、リクエストとファイルのアクセスと拒否。"
    },
    {
      "indent": 3,
      "text": "o The read and write permissions as determined below.",
      "ja": "o 以下で決定された読み取りおよび書き込み許可。"
    },
    {
      "indent": 3,
      "text": "The nfsace4 passed with delegation can be used to avoid frequent ACCESS calls. The permission check should be as follows:",
      "ja": "委任で合格したNFSACE4は、頻繁なアクセスコールを避けるために使用できます。許可チェックは次のようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the nfsace4 indicates that the open may be done, then it should be granted without reference to the server.",
      "ja": "o NFSACE4がオープンが実行される可能性があることを示した場合、サーバーを参照せずに付与する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the nfsace4 indicates that the open may not be done, then an ACCESS request must be sent to the server to obtain the definitive answer.",
      "ja": "o NFSACE4がオープンが実行されないことを示した場合、決定的な回答を取得するには、アクセス要求をサーバーに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The server may return an nfsace4 that is more restrictive than the actual ACL of the file. This includes an nfsace4 that specifies denial of all access. Note that some common practices such as mapping the traditional user \"root\" to the user \"nobody\" may make it incorrect to return the actual ACL of the file in the delegation response.",
      "ja": "サーバーは、ファイルの実際のACLよりも制限的なNFSACE4を返す場合があります。これには、すべてのアクセスの拒否を指定するNFSACE4が含まれます。従来のユーザーの「ルート」をユーザーにマッピングするなどのいくつかの一般的なプラクティスは、委任応答のファイルの実際のACLを返すことを間違っている可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The use of delegation together with various other forms of caching creates the possibility that no server authentication will ever be performed for a given user since all of the user's requests might be satisfied locally. Where the client is depending on the server for authentication, the client should be sure authentication occurs for each user by use of the ACCESS operation. This should be the case even if an ACCESS operation would not be required otherwise. As mentioned before, the server may enforce frequent authentication by returning an nfsace4 denying all access with every open delegation.",
      "ja": "他のさまざまな形式のキャッシングと一緒に委任を使用すると、すべてのユーザーの要求がローカルで満たされる可能性があるため、特定のユーザーに対してサーバー認証が実行されない可能性が生まれます。クライアントが認証のためにサーバーに依存している場合、アクセス操作を使用して、各ユーザーに対してクライアントは認証が発生することを確認する必要があります。それ以外の場合は、アクセス操作が必要ない場合でも、これは当てはまります。前述のように、サーバーは、NFSACE4を返すことにより、頻繁な認証を実施することができます。"
    },
    {
      "indent": 0,
      "text": "9.4.1. Open Delegation and Data Caching",
      "section_title": true,
      "ja": "9.4.1. オープン委任とデータキャッシュ"
    },
    {
      "indent": 3,
      "text": "OPEN delegation allows much of the message overhead associated with the opening and closing files to be eliminated. An open when an open delegation is in effect does not require that a validation message be sent to the server. The continued endurance of the \"read open delegation\" provides a guarantee that no OPEN for write and thus no write has occurred. Similarly, when closing a file opened for write and if write open delegation is in effect, the data written does not have to be flushed to the server until the open delegation is recalled. The continued endurance of the open delegation provides a guarantee that no open and thus no read or write has been done by another client.",
      "ja": "Open Delegationにより、オープニングファイルとクロージングファイルに関連付けられたメッセージオーバーヘッドの多くが排除されます。オープンな代表団が有効である場合、オープンでは、検証メッセージをサーバーに送信する必要はありません。「読み取りオープン代表団」の継続的な耐久性は、書き込みのために開かれていないために書き込みが発生していないという保証を提供します。同様に、書き込み用にファイルを閉じた場合、および書き込みオープン代表団が有効になった場合、公開委任がリコールされるまで、記述されたデータをサーバーにフラッシュする必要はありません。オープン代表団の継続的な耐久性は、他のクライアントによって開かれていないため、読み取りや書き込みが行われていないという保証を提供します。"
    },
    {
      "indent": 3,
      "text": "For the purposes of open delegation, READs and WRITEs done without an OPEN are treated as the functional equivalents of a corresponding type of OPEN. This refers to the READs and WRITEs that use the special stateids consisting of all zero bits or all one bits. Therefore, READs or WRITEs with a special stateid done by another client will force the server to recall a write open delegation. A WRITE with a special stateid done by another client will force a recall of read open delegations.",
      "ja": "オープン代表団の目的のために、オープンなしで行われた読み取りと書き込みは、対応するタイプのオープンの機能的な同等物として扱われます。これは、すべてのゼロビットまたはすべてのビットで構成される特別なStateidsを使用する読み取りと書き込みを指します。したがって、別のクライアントによって行われた特別なStateIDを読み書きすることで、サーバーは書き込みオープン委任を思い出させます。別のクライアントによって行われた特別なStateidを使用した書き込みは、読み取りオープン代表団のリコールを強制します。"
    },
    {
      "indent": 3,
      "text": "With delegations, a client is able to avoid writing data to the server when the CLOSE of a file is serviced. The CLOSE operation is the usual point at which the client is notified of a lack of stable storage for the modified file data generated by the application. At the CLOSE, file data is written to the server and through normal accounting the server is able to determine if the available file system space for the data has been exceeded (i.e. server returns NFS4ERR_NOSPC or NFS4ERR_DQUOT). This accounting includes quotas. The introduction of delegations requires that a alternative method be in place for the same type of communication to occur between client and server.",
      "ja": "代表団を使用すると、クライアントは、ファイルの終了がサービスを受けるときにサーバーにデータを書き込むことを避けることができます。緊密な操作は、アプリケーションによって生成された変更されたファイルデータの安定したストレージが不足していることをクライアントが通知される通常のポイントです。終了時に、ファイルデータはサーバーに書き込まれ、通常の会計により、サーバーはデータの利用可能なファイルシステムスペースを超えているかどうかを判断できます（つまり、サーバーはNFS4err_NOSPCまたはNFS4ERR_DQUOTを返します）。この会計には割り当てが含まれます。代表団の導入には、クライアントとサーバーの間で同じタイプの通信が発生するための代替方法が整備される必要があります。"
    },
    {
      "indent": 3,
      "text": "In the delegation response, the server provides either the limit of the size of the file or the number of modified blocks and associated block size. The server must ensure that the client will be able to flush data to the server of a size equal to that provided in the original delegation. The server must make this assurance for all outstanding delegations. Therefore, the server must be careful in its management of available space for new or modified data taking into account available file system space and any applicable quotas. The server can recall delegations as a result of managing the available file system space. The client should abide by the server's state space limits for delegations. If the client exceeds the stated limits for the delegation, the server's behavior is undefined.",
      "ja": "委任応答では、サーバーはファイルのサイズの制限または変更されたブロックの数と関連するブロックサイズのいずれかを提供します。サーバーは、クライアントが元の代表団で提供されているものと等しいサイズのサーバーにデータをフラッシュできるようにする必要があります。サーバーは、すべての未解決の代表団に対してこの保証を行う必要があります。したがって、サーバーは、利用可能なファイルシステムスペースと該当する割り当てを考慮して、利用可能なスペースの管理に注意する必要があります。サーバーは、利用可能なファイルシステムスペースを管理した結果として、代表団を思い出すことができます。クライアントは、代表団のサーバーの状態スペース制限を順守する必要があります。クライアントが代表団の指定された制限を超えた場合、サーバーの動作は未定義です。"
    },
    {
      "indent": 3,
      "text": "Based on server conditions, quotas or available file system space, the server may grant write open delegations with very restrictive space limitations. The limitations may be defined in a way that will always force modified data to be flushed to the server on close.",
      "ja": "サーバーの条件、クォータ、または利用可能なファイルシステムスペースに基づいて、サーバーは非常に制限的なスペースの制限を備えたオープン代表団の書き込みを付与する場合があります。制限は、常に修正されたデータを閉じるサーバーにフラッシュするように強制する方法で定義される場合があります。"
    },
    {
      "indent": 3,
      "text": "With respect to authentication, flushing modified data to the server after a CLOSE has occurred may be problematic. For example, the user of the application may have logged off of the client and unexpired authentication credentials may not be present. In this case, the client may need to take special care to ensure that local unexpired credentials will in fact be available. This may be accomplished by tracking the expiration time of credentials and flushing data well in advance of their expiration or by making private copies of credentials to assure their availability when needed.",
      "ja": "認証に関しては、閉鎖が発生した後に変更されたデータをサーバーにフラッシングすることに問題がある場合があります。たとえば、アプリケーションのユーザーがクライアントからログオフされている可能性があり、期限切れの認証資格情報が存在しない場合があります。この場合、クライアントは、地元の期限切れのない資格情報が実際に利用可能になるように特別な注意を払う必要がある場合があります。これは、資格情報の有効期限を追跡し、有効期限のかなり前にデータをフラッシングするか、必要に応じて可用性を確保するために資格情報の個人コピーを作成することによって達成される場合があります。"
    },
    {
      "indent": 0,
      "text": "9.4.2. Open Delegation and File Locks",
      "section_title": true,
      "ja": "9.4.2. 委任とファイルロックを開きます"
    },
    {
      "indent": 3,
      "text": "When a client holds a write open delegation, lock operations are performed locally. This includes those required for mandatory file locking. This can be done since the delegation implies that there can be no conflicting locks. Similarly, all of the revalidations that would normally be associated with obtaining locks and the flushing of data associated with the releasing of locks need not be done.",
      "ja": "クライアントが書き込みオープン代表団を保持すると、ロック操作がローカルで実行されます。これには、必須ファイルロックに必要なものが含まれます。代表団は、矛盾するロックがないことを意味するため、これを行うことができます。同様に、通常、ロックの取得に関連付けられるすべての再検証と、ロックの解放に関連するデータのフラッシングを行う必要はありません。"
    },
    {
      "indent": 0,
      "text": "9.4.3. Recall of Open Delegation",
      "section_title": true,
      "ja": "9.4.3. オープン代表団のリコール"
    },
    {
      "indent": 3,
      "text": "The following events necessitate recall of an open delegation:",
      "ja": "次のイベントでは、オープンな代表団のリコールが必要です。"
    },
    {
      "indent": 3,
      "text": "o Potentially conflicting OPEN request (or READ/WRITE done with \"special\" stateid)",
      "ja": "o 潜在的に矛盾するオープンリクエスト（または「Special」StateIDで行われた読み取り/書き込み）"
    },
    {
      "indent": 3,
      "text": "o SETATTR issued by another client",
      "ja": "o 別のクライアントが発行したSetattr"
    },
    {
      "indent": 3,
      "text": "o REMOVE request for the file",
      "ja": "o ファイルのリクエストを削除します"
    },
    {
      "indent": 3,
      "text": "o RENAME request for the file as either source or target of the RENAME",
      "ja": "o ファイルのリクエストの名前は、ソースまたは名前のターゲットのいずれかとして変更されます"
    },
    {
      "indent": 3,
      "text": "Whether a RENAME of a directory in the path leading to the file results in recall of an open delegation depends on the semantics of the server file system. If that file system denies such RENAMEs when a file is open, the recall must be performed to determine whether the file in question is, in fact, open.",
      "ja": "ファイルに通じるパス内のディレクトリの名前の変更が、オープン代表団のリコールに依存するかどうかは、サーバーファイルシステムのセマンティクスに依存します。そのファイルシステムがそのような名前を拒否した場合、ファイルが開いている場合、リコールを実行して、問題のファイルが実際に開いているかどうかを判断する必要があります。"
    },
    {
      "indent": 3,
      "text": "In addition to the situations above, the server may choose to recall open delegations at any time if resource constraints make it advisable to do so. Clients should always be prepared for the possibility of recall.",
      "ja": "上記の状況に加えて、サーバーは、リソースの制約がそうすることを勧めている場合、いつでも開いた代表団を思い出すことを選択できます。クライアントは、リコールの可能性について常に準備する必要があります。"
    },
    {
      "indent": 3,
      "text": "The server needs to employ special handling for a GETATTR where the target is a file that has a write open delegation in effect. In this case, the client holding the delegation needs to be interrogated. The server will use a CB_GETATTR callback, if the GETATTR attribute bits include any of the attributes that a write open delegate may modify (object_size, time_modify, change).",
      "ja": "サーバーは、ターゲットが有効に書かれたオープン代表団を備えたファイルであるgetattrに特別な取り扱いを使用する必要があります。この場合、代表団を保持しているクライアントを尋問する必要があります。getattr属性ビットに書き込みオープンデリゲートが変更できる属性（object_size、time_modify、change）のいずれかが含まれる場合、サーバーはcb_getattrコールバックを使用します。"
    },
    {
      "indent": 3,
      "text": "When a client receives a recall for an open delegation, it needs to update state on the server before returning the delegation. These same updates must be done whenever a client chooses to return a delegation voluntarily. The following items of state need to be dealt with:",
      "ja": "クライアントがオープンな代表団のリコールを受け取った場合、代表団を返す前にサーバー上の状態を更新する必要があります。これらの同じ更新は、クライアントが自発的に代表団を返すことを選択するときはいつでも行う必要があります。次の州の項目に対処する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the file associated with the delegation is no longer open and no previous CLOSE operation has been sent to the server, a CLOSE operation must be sent to the server.",
      "ja": "o 代表団に関連付けられたファイルが開いていなくなり、以前の緊密な操作がサーバーに送信されていない場合、緊密な操作をサーバーに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If a file has other open references at the client, then OPEN operations must be sent to the server. The appropriate stateids will be provided by the server for subsequent use by the client since the delegation stateid will not longer be valid. These OPEN requests are done with the claim type of CLAIM_DELEGATE_CUR. This will allow the presentation of the delegation stateid so that the client can establish the appropriate rights to perform the OPEN. (see the section \"Operation 18: OPEN\" for details.)",
      "ja": "o ファイルにクライアントに他のオープン参照がある場合、オープン操作をサーバーに送信する必要があります。代表団のStateIDはもはや有効ではないため、クライアントがその後使用するために、適切なStateIDSがサーバーによって提供されます。これらのオープンリクエストは、請求タイプの請求タイプで行われます。これにより、クライアントがオープンを実行するための適切な権利を確立できるように、代表団StateIDのプレゼンテーションが可能になります。（詳細については、セクション「操作18：オープン」を参照してください。）"
    },
    {
      "indent": 3,
      "text": "o If there are granted file locks, the corresponding LOCK operations need to be performed. This applies to the write open delegation case only.",
      "ja": "o 許可されたファイルロックがある場合、対応するロック操作を実行する必要があります。これは、書き込みオープン委任ケースのみに適用されます。"
    },
    {
      "indent": 3,
      "text": "o For a write open delegation, if at the time of recall the file is not open for write, all modified data for the file must be flushed to the server. If the delegation had not existed, the client would have done this data flush before the CLOSE operation.",
      "ja": "o 書き込みオープン代表団の場合、リコール時にファイルが書き込みのために開かれていない場合、ファイルのすべての変更データをサーバーにフラッシュする必要があります。代表団が存在しなかった場合、クライアントは閉鎖操作の前にこのデータフラッシュを行っていたでしょう。"
    },
    {
      "indent": 3,
      "text": "o For a write open delegation when a file is still open at the time of recall, any modified data for the file needs to be flushed to the server.",
      "ja": "o recallの時点でファイルがまだ開いている場合、委任を開くと、ファイルの変更されたデータをサーバーにフラッシュする必要があります。"
    },
    {
      "indent": 3,
      "text": "o With the write open delegation in place, it is possible that the file was truncated during the duration of the delegation. For example, the truncation could have occurred as a result of an OPEN UNCHECKED with a object_size attribute value of zero. Therefore, if a truncation of the file has occurred and this operation has not been propagated to the server, the truncation must occur before any modified data is written to the server.",
      "ja": "o Write Open Deligationが配置されていると、代表団の期間中にファイルが切り捨てられた可能性があります。たとえば、Object_size属性の値がゼロでオープンチェックされていないオープンの結果として、切り捨てが発生した可能性があります。したがって、ファイルの切り捨てが発生し、この操作がサーバーに伝播されていない場合、変更されたデータがサーバーに書き込まれる前に切り捨てが発生する必要があります。"
    },
    {
      "indent": 3,
      "text": "In the case of write open delegation, file locking imposes some additional requirements. The flushing of any modified data in any region for which a write lock was released while the write open delegation was in effect is what is required to precisely maintain the associated invariant. However, because the write open delegation implies no other locking by other clients, a simpler implementation is to flush all modified data for the file (as described just above) if any write lock has been released while the write open delegation was in effect.",
      "ja": "Open Delegationの書き込みの場合、File Lockingはいくつかの追加要件を課します。書き込みオープン代表団が有効になっている間に書き込みロックがリリースされた任意の地域で変更されたデータをフラッシングすることは、関連する不変を正確に維持するために必要なものです。ただし、書き込みオープン代表団は他のクライアントによる他のロックを意味しないため、書き込みオープン代表団が有効になっている間に書き込みロックがリリースされている場合、ファイルのすべての変更データを（上記のように）フライドしたすべての変更データをフラッシュすることです。"
    },
    {
      "indent": 0,
      "text": "9.4.4. Delegation Revocation",
      "section_title": true,
      "ja": "9.4.4. 委任の取り消し"
    },
    {
      "indent": 3,
      "text": "At the point a delegation is revoked, if there are associated opens on the client, the applications holding these opens need to be notified. This notification usually occurs by returning errors for READ/WRITE operations or when a close is attempted for the open file.",
      "ja": "その時点で、代表団が取り消されます。クライアントに関連付けられたオープンがある場合、これらのオープンを保持するアプリケーションに通知する必要があります。通常、この通知は、読み取り/書き込み操作のエラーを返すこと、または開いたファイルの閉鎖を試みたときに発生します。"
    },
    {
      "indent": 3,
      "text": "If no opens exist for the file at the point the delegation is revoked, then notification of the revocation is unnecessary. However, if there is modified data present at the client for the file, the user of the application should be notified. Unfortunately, it may not be possible to notify the user since active applications may not be present at the client. See the section \"Revocation Recovery for Write Open Delegation\" for additional details.",
      "ja": "代表団が取り消された時点でファイルに開かれていない場合、取り消しの通知は不要です。ただし、ファイルについてクライアントに変更されたデータが存在する場合、アプリケーションのユーザーに通知する必要があります。残念ながら、アクティブなアプリケーションがクライアントに存在しない可能性があるため、ユーザーに通知することはできない場合があります。詳細については、「Open Delegationの書き込みの取り消し回収」セクションを参照してください。"
    },
    {
      "indent": 0,
      "text": "9.5. Data Caching and Revocation",
      "section_title": true,
      "ja": "9.5. データキャッシングと取り消し"
    },
    {
      "indent": 3,
      "text": "When locks and delegations are revoked, the assumptions upon which successful caching depend are no longer guaranteed. The owner of the locks or share reservations which have been revoked needs to be notified. This notification includes applications with a file open that has a corresponding delegation which has been revoked. Cached data associated with the revocation must be removed from the client. In the case of modified data existing in the client's cache, that data must be removed from the client without it being written to the server. As mentioned, the assumptions made by the client are no longer valid at the point when a lock or delegation has been revoked. For example, another client may have been granted a conflicting lock after the revocation of the lock at the first client. Therefore, the data within the lock range may have been modified by the other client. Obviously, the first client is unable to guarantee to the application what has occurred to the file in the case of revocation.",
      "ja": "ロックと代表団が取り消されると、キャッシュの成功が依存する仮定はもはや保証されません。取り消されたロックまたは共有予約の所有者に通知する必要があります。この通知には、取り消された対応する代表団があるファイルを開いたアプリケーションが含まれています。取り消しに関連付けられたキャッシュデータは、クライアントから削除する必要があります。クライアントのキャッシュに存在する変更されたデータの場合、そのデータは、サーバーに書き込まれずにクライアントから削除する必要があります。前述のように、クライアントによってなされた仮定は、ロックまたは代表団が取り消された時点ではもはや有効ではありません。たとえば、別のクライアントには、最初のクライアントでのロックが取り消された後、矛盾するロックが付与されている可能性があります。したがって、ロック範囲内のデータは、他のクライアントによって変更された可能性があります。明らかに、最初のクライアントは、取り消しの場合にファイルに発生したことをアプリケーションに保証することができません。"
    },
    {
      "indent": 3,
      "text": "Notification to a lock owner will in many cases consist of simply returning an error on the next and all subsequent READs/WRITEs to the open file or on the close. Where the methods available to a client make such notification impossible because errors for certain operations may not be returned, more drastic action such as signals or process termination may be appropriate. The justification for this is that an invariant for which an application depends on may be violated. Depending on how errors are typically treated for the client operating environment, further levels of notification including logging, console messages, and GUI pop-ups may be appropriate.",
      "ja": "ロックの所有者への通知は、多くの場合、次のすべての読み取り/書き込み/書き込みにエラーを返すだけで構成されます。特定の操作のエラーが返されないため、クライアントが利用できる方法がそのような通知を不可能にする場合、信号やプロセス終了などのより劇的なアクションが適切かもしれません。これの正当化は、アプリケーションが依存する不変式が違反される可能性があるということです。クライアントの動作環境のエラーが通常どのように扱われるかに応じて、ロギング、コンソールメッセージ、GUIポップアップなどのさらなるレベルの通知が適切かもしれません。"
    },
    {
      "indent": 0,
      "text": "9.5.1. Revocation Recovery for Write Open Delegation",
      "section_title": true,
      "ja": "9.5.1. 委任を書き込むための取り消し回復"
    },
    {
      "indent": 3,
      "text": "Revocation recovery for a write open delegation poses the special issue of modified data in the client cache while the file is not open. In this situation, any client which does not flush modified data to the server on each close must ensure that the user receives appropriate notification of the failure as a result of the revocation. Since such situations may require human action to correct problems, notification schemes in which the appropriate user or administrator is notified may be necessary. Logging and console messages are typical examples.",
      "ja": "書き込みオープン代表団の取り消し回復は、ファイルが開いていない間にクライアントキャッシュに変更されたデータの特別な問題を提起します。この状況では、変更されたデータを各クローズでサーバーにフラッシュしないクライアントは、取り消しの結果としてユーザーが障害の適切な通知を受信することを確認する必要があります。そのような状況は、問題を修正するために人間の行動を必要とする可能性があるため、適切なユーザーまたは管理者が通知される通知スキームが必要になる場合があります。ロギングメッセージとコンソールメッセージは典型的な例です。"
    },
    {
      "indent": 3,
      "text": "If there is modified data on the client, it must not be flushed normally to the server. A client may attempt to provide a copy of the file data as modified during the delegation under a different name in the file system name space to ease recovery. Unless the client can determine that the file has not modified by any other client, this technique must be limited to situations in which a client has a complete cached copy of the file in question. Use of such a technique may be limited to files under a certain size or may only be used when sufficient disk space is guaranteed to be available within the target file system and when the client has sufficient buffering resources to keep the cached copy available until it is properly stored to the target file system.",
      "ja": "クライアントに変更されたデータがある場合は、通常サーバーにフラッシュしてはなりません。クライアントは、リカバリを容易にするために、ファイルシステム名の別の名前で委任中に変更されたファイルデータのコピーを提供しようとすることができます。クライアントが他のクライアントによってファイルが変更されていないと判断できない限り、この手法は、クライアントが問題のファイルの完全なキャッシュコピーを持っている状況に限定されなければなりません。このような手法の使用は、特定のサイズの下のファイルに限定されるか、ターゲットファイルシステム内で十分なディスクスペースが利用可能であることが保証されている場合と、クライアントがキャッシュコピーを利用可能にするのに十分なバッファリングリソースを持っている場合にのみ使用できます。ターゲットファイルシステムに適切に保存されます。"
    },
    {
      "indent": 0,
      "text": "9.6. Attribute Caching",
      "section_title": true,
      "ja": "9.6. 属性キャッシング"
    },
    {
      "indent": 3,
      "text": "The attributes discussed in this section do not include named attributes. Individual named attributes are analogous to files and caching of the data for these needs to be handled just as data caching is for ordinary files. Similarly, LOOKUP results from an OPENATTR directory are to be cached on the same basis as any other pathnames and similarly for directory contents.",
      "ja": "このセクションで説明する属性には、名前の属性は含まれていません。個々の名前の属性は、ファイルに類似しており、データのキャッシングが通常のファイルのためのものであるように、これらのデータのキャッシュを処理する必要があります。同様に、OpenATTRディレクトリからのルックアップ結果は、他のパス名と同じベースで、およびディレクトリコンテンツについても同様にキャッシュされます。"
    },
    {
      "indent": 3,
      "text": "Clients may cache file attributes obtained from the server and use them to avoid subsequent GETATTR requests. Such caching is write through in that modification to file attributes is always done by means of requests to the server and should not be done locally and cached. The exception to this are modifications to attributes that are intimately connected with data caching. Therefore, extending a file by writing data to the local data cache is reflected immediately in the object_size as seen on the client without this change being immediately reflected on the server. Normally such changes are not propagated directly to the server but when the modified data is flushed to the server, analogous attribute changes are made on the server. When open delegation is in effect, the modified attributes may be returned to the server in the response to a CB_RECALL call.",
      "ja": "クライアントは、サーバーから取得したファイル属性をキャッシュし、それらを使用して、その後のGetATTRリクエストを避けることができます。このようなキャッシュは、ファイル属性への変更が常にサーバーへの要求によって行われ、ローカルで実行されてキャッシュされるべきではないという点で書かれています。これの例外は、データキャッシュに密接に関連している属性の変更です。したがって、データをローカルデータキャッシュに書き込むことでファイルを拡張することは、この変更がサーバーにすぐに反映されることなく、クライアントに見られるように、Object_sizeにすぐに反映されます。通常、このような変更はサーバーに直接伝播されませんが、変更されたデータがサーバーにフラッシュされると、サーバーで類似の属性の変更が行われます。オープン委任が有効になっている場合、CB_Recallコールへの応答で、変更された属性がサーバーに返される場合があります。"
    },
    {
      "indent": 3,
      "text": "The result of local caching of attributes is that the attribute caches maintained on individual clients will not be coherent. Changes made in one order on the server may be seen in a different order on one client and in a third order on a different client.",
      "ja": "属性のローカルキャッシュの結果、個々のクライアントに維持されている属性キャッシュは一貫性がありません。サーバー上の1つの注文で行われた変更は、あるクライアントでは別の順序で、別のクライアントで3番目の注文で見られる場合があります。"
    },
    {
      "indent": 3,
      "text": "The typical file system application programming interfaces do not provide means to atomically modify or interrogate attributes for multiple files at the same time. The following rules provide an environment where the potential incoherences mentioned above can be reasonably managed. These rules are derived from the practice of previous NFS protocols.",
      "ja": "典型的なファイルシステムアプリケーションプログラミングインターフェイスは、複数のファイルの属性を原子的に変更または尋問する手段を同時に提供するものではありません。以下のルールは、上記の潜在的なインキュヒーレンスを合理的に管理できる環境を提供します。これらのルールは、以前のNFSプロトコルの実践から派生しています。"
    },
    {
      "indent": 3,
      "text": "o All attributes for a given file (per-fsid attributes excepted) are cached as a unit at the client so that no non-serializability can arise within the context of a single file.",
      "ja": "o 特定のファイルのすべての属性（FSIDごとの属性を除く）は、クライアントのユニットとしてキャッシュされ、単一のファイルのコンテキスト内で非セリア化可能性が生じないようにします。"
    },
    {
      "indent": 3,
      "text": "o An upper time boundary is maintained on how long a client cache entry can be kept without being refreshed from the server.",
      "ja": "o サーバーから更新されることなく、クライアントキャッシュエントリをどれだけ長く保持できるかについて、アッパータイム境界が維持されます。"
    },
    {
      "indent": 3,
      "text": "o When operations are performed that change attributes at the server, the updated attribute set is requested as part of the containing RPC. This includes directory operations that update attributes indirectly. This is accomplished by following the modifying operation with a GETATTR operation and then using the results of the GETATTR to update the client's cached attributes.",
      "ja": "o 操作が実行されると、サーバーで属性を変更すると、RPCを含む一部として更新された属性セットが要求されます。これには、間接的に属性を更新するディレクトリ操作が含まれます。これは、getATTR操作で修正操作に従い、getATTRの結果を使用してクライアントのキャッシュされた属性を更新することによって達成されます。"
    },
    {
      "indent": 3,
      "text": "Note that if the full set of attributes to be cached is requested by READDIR, the results can be cached by the client on the same basis as attributes obtained via GETATTR.",
      "ja": "キャッシュする属性の完全なセットがReadDirによって要求される場合、GetATTRを介して取得した属性と同じベースでクライアントが結果をキャッシュできることに注意してください。"
    },
    {
      "indent": 3,
      "text": "A client may validate its cached version of attributes for a file by fetching only the change attribute and assuming that if the change attribute has the same value as it did when the attributes were cached, then no attributes have changed. The possible exception is the attribute time_access.",
      "ja": "クライアントは、変更属性のみを取得し、変更属性が属性がキャッシュされたときと同じ値を持っている場合、属性が変更されていないと仮定することにより、ファイルの属性のキャッシュバージョンを検証することができます。考えられる例外は、属性time_accessです。"
    },
    {
      "indent": 0,
      "text": "9.7. Name Caching",
      "section_title": true,
      "ja": "9.7. 名前キャッシュ"
    },
    {
      "indent": 3,
      "text": "The results of LOOKUP and READDIR operations may be cached to avoid the cost of subsequent LOOKUP operations. Just as in the case of attribute caching, inconsistencies may arise among the various client caches. To mitigate the effects of these inconsistencies and given the context of typical file system APIs, the following rules should be followed:",
      "ja": "ルックアップおよびReadDIR操作の結果は、後続のルックアップ操作のコストを回避するためにキャッシュされる場合があります。属性キャッシュの場合と同様に、さまざまなクライアントキャッシュの間で矛盾が生じる可能性があります。これらの矛盾の効果を軽減し、典型的なファイルシステムAPIのコンテキストを与えられるには、次のルールに従う必要があります。"
    },
    {
      "indent": 3,
      "text": "o The results of unsuccessful LOOKUPs should not be cached, unless they are specifically reverified at the point of use.",
      "ja": "o 失敗したルックアップの結果は、使用時点で特別に再認識されない限り、キャッシュされるべきではありません。"
    },
    {
      "indent": 3,
      "text": "o An upper time boundary is maintained on how long a client name cache entry can be kept without verifying that the entry has not been made invalid by a directory change operation performed by another client.",
      "ja": "o クライアント名のキャッシュエントリを、別のクライアントが実行するディレクトリ変更操作によってエントリが無効になっていないことを確認せずに、クライアント名キャッシュエントリをどれだけ長く保持できるかについて、上限境界が維持されます。"
    },
    {
      "indent": 3,
      "text": "When a client is not making changes to a directory for which there exist name cache entries, the client needs to periodically fetch attributes for that directory to ensure that it is not being modified. After determining that no modification has occurred, the expiration time for the associated name cache entries may be updated to be the current time plus the name cache staleness bound.",
      "ja": "クライアントが名前キャッシュエントリが存在するディレクトリを変更していない場合、クライアントはそのディレクトリの属性を定期的に取得して、変更されていないことを確認する必要があります。変更が発生していないと判断した後、関連する名前キャッシュエントリの有効期限は、現在の時刻と名前キャッシュの統合性のバウンドに更新される場合があります。"
    },
    {
      "indent": 3,
      "text": "When a client is making changes to a given directory, it needs to determine whether there have been changes made to the directory by other clients. It does this by using the change attribute as reported before and after the directory operation in the associated change_info4 value returned for the operation. The server is able to communicate to the client whether the change_info4 data is provided atomically with respect to the directory operation. If the change values are provided atomically, the client is then able to compare the pre-operation change value with the change value in the client's name cache. If the comparison indicates that the directory was updated by another client, the name cache associated with the modified directory is purged from the client. If the comparison indicates no modification, the name cache can be updated on the client to reflect the directory operation and the associated timeout extended. The post-operation change value needs to be saved as the basis for future change_info4 comparisons.",
      "ja": "クライアントが特定のディレクトリを変更している場合、他のクライアントによってディレクトリに変更が加えられたかどうかを判断する必要があります。これは、操作に返された関連する変更_INFO4値のディレクトリ操作の前後に報告された変更属性を使用することにより行います。サーバーは、Change_Info4データがディレクトリ操作に関して原子的に提供されるかどうかをクライアントに通信できます。変更値が原子的に提供されている場合、クライアントは操作前の変更値をクライアントの名前キャッシュの変更値と比較できます。比較がディレクトリが別のクライアントによって更新されたことを示している場合、変更されたディレクトリに関連付けられた名前のキャッシュはクライアントからパージされます。比較が変更がないことを示している場合、名前のキャッシュをクライアントに更新して、ディレクトリ操作を反映し、関連するタイムアウトが拡張されます。操作後の変更値は、将来のChange_Info4比較の基礎として保存する必要があります。"
    },
    {
      "indent": 3,
      "text": "As demonstrated by the scenario above, name caching requires that the client revalidate name cache data by inspecting the change attribute of a directory at the point when the name cache item was cached. This requires that the server update the change attribute for directories when the contents of the corresponding directory is modified. For a client to use the change_info4 information appropriately and correctly, the server must report the pre and post operation change attribute values atomically. When the server is unable to report the before and after values atomically with respect to the directory operation, the server must indicate that fact in the change_info4 return value. When the information is not atomically reported, the client should not assume that other clients have not changed the directory.",
      "ja": "上記のシナリオで示されているように、名前キャッシュでは、名前キャッシュアイテムがキャッシュされた時点でディレクトリの変更属性を検査することにより、クライアントが名前キャッシュデータを再検証する必要があります。これには、対応するディレクトリの内容が変更されたときに、サーバーがディレクトリの変更属性を更新する必要があります。クライアントがChange_Info4情報を適切かつ正確に使用するには、サーバーが操作前後の変更属性値を原子的に報告する必要があります。サーバーがディレクトリ操作に関して原子的に値を原子的にレポートできない場合、サーバーはその事実をChange_Info4の返品値に示す必要があります。情報が原子的に報告されていない場合、クライアントは他のクライアントがディレクトリを変更していないと想定してはなりません。"
    },
    {
      "indent": 0,
      "text": "9.8. Directory Caching",
      "section_title": true,
      "ja": "9.8. ディレクトリキャッシング"
    },
    {
      "indent": 3,
      "text": "The results of READDIR operations may be used to avoid subsequent READDIR operations. Just as in the cases of attribute and name caching, inconsistencies may arise among the various client caches.",
      "ja": "ReadDIR操作の結果は、その後のReadDIR操作を回避するために使用できます。属性と名前のキャッシュの場合と同様に、さまざまなクライアントキャッシュの間で矛盾が生じる可能性があります。"
    },
    {
      "indent": 3,
      "text": "To mitigate the effects of these inconsistencies, and given the context of typical file system APIs, the following rules should be followed:",
      "ja": "これらの矛盾の効果を軽減し、典型的なファイルシステムAPIのコンテキストを考慮して、次のルールに従う必要があります。"
    },
    {
      "indent": 3,
      "text": "o Cached READDIR information for a directory which is not obtained in a single READDIR operation must always be a consistent snapshot of directory contents. This is determined by using a GETATTR before the first READDIR and after the last of READDIR that contributes to the cache.",
      "ja": "o 単一のReadDir操作で取得されないディレクトリのCached ReadDir情報は、常にディレクトリコンテンツの一貫したスナップショットでなければなりません。これは、最初のreaddirの前にgetattrを使用し、キャッシュに寄与する最後のreaddirの後に決定されます。"
    },
    {
      "indent": 3,
      "text": "o An upper time boundary is maintained to indicate the length of time a directory cache entry is considered valid before the client must revalidate the cached information.",
      "ja": "o クライアントがキャッシュされた情報を再検証する前に、ディレクトリキャッシュエントリが有効であると見なされる時間を示すために、上限境界が維持されます。"
    },
    {
      "indent": 3,
      "text": "The revalidation technique parallels that discussed in the case of name caching. When the client is not changing the directory in question, checking the change attribute of the directory with GETATTR is adequate. The lifetime of the cache entry can be extended at these checkpoints. When a client is modifying the directory, the client needs to use the change_info4 data to determine whether there are other clients modifying the directory. If it is determined that no other client modifications are occurring, the client may update its directory cache to reflect its own changes.",
      "ja": "再検証技術は、名前キャッシュの場合に議論された類似点です。クライアントが問題のディレクトリを変更していない場合、ディレクトリの変更属性をGetATTRで確認するのが適切です。キャッシュエントリの寿命は、これらのチェックポイントで拡張できます。クライアントがディレクトリを変更している場合、クライアントはChange_Info4データを使用して、他のクライアントがディレクトリを変更しているかどうかを判断する必要があります。他のクライアントの変更が発生していないと判断された場合、クライアントは独自の変更を反映するためにディレクトリキャッシュを更新できます。"
    },
    {
      "indent": 3,
      "text": "As demonstrated previously, directory caching requires that the client revalidate directory cache data by inspecting the change attribute of a directory at the point when the directory was cached. This requires that the server update the change attribute for directories when the contents of the corresponding directory is modified. For a client to use the change_info4 information appropriately and correctly, the server must report the pre and post operation change attribute values atomically. When the server is unable to report the before and after values atomically with respect to the directory operation, the server must indicate that fact in the change_info4 return value. When the information is not atomically reported, the client should not assume that other clients have not changed the directory.",
      "ja": "前述のように、ディレクトリキャッシュでは、ディレクトリがキャッシュされた時点でディレクトリの変更属性を検査することにより、クライアントがディレクトリキャッシュデータを再検証する必要があります。これには、対応するディレクトリの内容が変更されたときに、サーバーがディレクトリの変更属性を更新する必要があります。クライアントがChange_Info4情報を適切かつ正確に使用するには、サーバーが操作前後の変更属性値を原子的に報告する必要があります。サーバーがディレクトリ操作に関して原子的に値を原子的にレポートできない場合、サーバーはその事実をChange_Info4の返品値に示す必要があります。情報が原子的に報告されていない場合、クライアントは他のクライアントがディレクトリを変更していないと想定してはなりません。"
    },
    {
      "indent": 0,
      "text": "10. Minor Versioning",
      "section_title": true,
      "ja": "10. マイナーバージョン化"
    },
    {
      "indent": 3,
      "text": "To address the requirement of an NFS protocol that can evolve as the need arises, the NFS version 4 protocol contains the rules and framework to allow for future minor changes or versioning.",
      "ja": "必要に応じて進化できるNFSプロトコルの要件に対処するために、NFSバージョン4プロトコルには、将来のマイナーな変更またはバージョン化を可能にするルールとフレームワークが含まれています。"
    },
    {
      "indent": 3,
      "text": "The base assumption with respect to minor versioning is that any future accepted minor version must follow the IETF process and be documented in a standards track RFC. Therefore, each minor version number will correspond to an RFC. Minor version zero of the NFS version 4 protocol is represented by this RFC. The COMPOUND procedure will support the encoding of the minor version being requested by the client.",
      "ja": "マイナーバージョンの基本的な仮定は、将来の受け入れられたマイナーバージョンは、IETFプロセスに従い、標準トラックRFCに文書化されなければならないということです。したがって、各マイナーバージョン番号はRFCに対応します。NFSバージョン4プロトコルのマイナーバージョンゼロは、このRFCで表されます。複合手順は、クライアントが要求するマイナーバージョンのエンコードをサポートします。"
    },
    {
      "indent": 3,
      "text": "The following items represent the basic rules for the development of minor versions. Note that a future minor version may decide to modify or add to the following rules as part of the minor version definition.",
      "ja": "次の項目は、マイナーバージョンの開発に関する基本的なルールを表しています。将来のマイナーバージョンは、マイナーバージョンの定義の一部として以下のルールを変更または追加することを決定する場合があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "1 Procedures are not added or deleted",
      "ja": "1つの手順は追加または削除されません"
    },
    {
      "indent": 8,
      "text": "To maintain the general RPC model, NFS version 4 minor versions will not add or delete procedures from the NFS program.",
      "ja": "一般的なRPCモデルを維持するために、NFSバージョン4マイナーバージョンは、NFSプログラムから手順を追加または削除しません。"
    },
    {
      "indent": 3,
      "text": "2 Minor versions may add operations to the COMPOUND and CB_COMPOUND procedures.",
      "ja": "2つのマイナーバージョンは、化合物に操作を追加し、CB_Compound手順を追加する場合があります。"
    },
    {
      "indent": 8,
      "text": "The addition of operations to the COMPOUND and CB_COMPOUND procedures does not affect the RPC model.",
      "ja": "化合物およびCB_COMPOUND手順への操作の追加は、RPCモデルに影響しません。"
    },
    {
      "indent": 3,
      "text": "2.1 Minor versions may append attributes to GETATTR4args, bitmap4, and GETATTR4res.",
      "ja": "2.1 マイナーバージョンは、getattr4args、bitmap4、およびgetattr4resに属性を追加する場合があります。"
    },
    {
      "indent": 8,
      "text": "This allows for the expansion of the attribute model to allow for future growth or adaptation.",
      "ja": "これにより、属性モデルの拡張が可能になり、将来の成長や適応が可能になります。"
    },
    {
      "indent": 3,
      "text": "2.2 Minor version X must append any new attributes after the last documented attribute.",
      "ja": "2.2 マイナーバージョンXは、最後に文書化された属性の後に新しい属性を追加する必要があります。"
    },
    {
      "indent": 8,
      "text": "Since attribute results are specified as an opaque array of per-attribute XDR encoded results, the complexity of adding new attributes in the midst of the current definitions will be too burdensome.",
      "ja": "属性の結果は、属性ごとのXDRエンコード結果の不透明な配列として指定されているため、現在の定義の最中に新しい属性を追加する複雑さは負担が大きすぎます。"
    },
    {
      "indent": 3,
      "text": "3 Minor versions must not modify the structure of an existing operation's arguments or results.",
      "ja": "3マイナーバージョンは、既存の操作の引数または結果の構造を変更してはなりません。"
    },
    {
      "indent": 8,
      "text": "Again the complexity of handling multiple structure definitions for a single operation is too burdensome. New operations should be added instead of modifying existing structures for a minor version.",
      "ja": "繰り返しますが、単一の操作の複数の構造定義を処理する複雑さは、負担が大きすぎます。マイナーバージョンの既存の構造を変更する代わりに、新しい操作を追加する必要があります。"
    },
    {
      "indent": 8,
      "text": "This rule does not preclude the following adaptations in a minor version.",
      "ja": "この規則は、マイナーバージョンでの次の適応を排除しません。"
    },
    {
      "indent": 8,
      "text": "o adding bits to flag fields such as new attributes to GETATTR's bitmap4 data type",
      "ja": "o getattrのbitmap4データ型に新しい属性などのフラグフィールドにビットを追加する"
    },
    {
      "indent": 8,
      "text": "o adding bits to existing attributes like ACLs that have flag words",
      "ja": "o フラグワードを持つACLのような既存の属性にビットを追加する"
    },
    {
      "indent": 8,
      "text": "o extending enumerated types (including NFS4ERR_*) with new values",
      "ja": "o 新しい値で列挙型（nfs4err_*を含む）を拡張する"
    },
    {
      "indent": 3,
      "text": "4 Minor versions may not modify the structure of existing attributes.",
      "ja": "4つのマイナーバージョンは、既存の属性の構造を変更しない場合があります。"
    },
    {
      "indent": 3,
      "text": "5 Minor versions may not delete operations.",
      "ja": "5つのマイナーバージョンでは、操作を削除できない場合があります。"
    },
    {
      "indent": 8,
      "text": "This prevents the potential reuse of a particular operation \"slot\" in a future minor version.",
      "ja": "これにより、将来のマイナーバージョンでの特定の操作「スロット」の潜在的な再利用が防止されます。"
    },
    {
      "indent": 3,
      "text": "6 Minor versions may not delete attributes.",
      "ja": "6マイナーバージョンは属性を削除しない場合があります。"
    },
    {
      "indent": 3,
      "text": "7 Minor versions may not delete flag bits or enumeration values.",
      "ja": "7マイナーバージョンは、フラグビットまたは列挙値を削除しない場合があります。"
    },
    {
      "indent": 3,
      "text": "8 Minor versions may declare an operation as mandatory to NOT implement.",
      "ja": "8つのマイナーバージョンは、実装しないように操作を必須であると宣言する場合があります。"
    },
    {
      "indent": 8,
      "text": "Specifying an operation as \"mandatory to not implement\" is equivalent to obsoleting an operation. For the client, it means that the operation should not be sent to the server. For the server, an NFS error can be returned as opposed to \"dropping\" the request as an XDR decode error. This approach allows for the obsolescence of an operation while maintaining its structure so that a future minor version can reintroduce the operation.",
      "ja": "操作を「実装しないように必須」として指定することは、操作の廃止と同等です。クライアントの場合、操作をサーバーに送信しないことを意味します。サーバーの場合、XDRデコードエラーとしてリクエストを「ドロップ」するのではなく、NFSエラーを返すことができます。このアプローチにより、将来のマイナーバージョンが操作を再導入できるように、その構造を維持しながら、操作の陳腐化が可能になります。"
    },
    {
      "indent": 3,
      "text": "8.1 Minor versions may declare attributes mandatory to NOT implement.",
      "ja": "8.1 マイナーバージョンは、実装しないように必須の属性を宣言する場合があります。"
    },
    {
      "indent": 3,
      "text": "8.2 Minor versions may declare flag bits or enumeration values as mandatory to NOT implement.",
      "ja": "8.2 マイナーバージョンは、実装しないように義務付けられているとフラグビットまたは列挙値を宣言する場合があります。"
    },
    {
      "indent": 3,
      "text": "9 Minor versions may downgrade features from mandatory to recommended, or recommended to optional.",
      "ja": "9つのマイナーバージョンは、機能を必須から推奨までダウングレードしたり、オプションに推奨したりする場合があります。"
    },
    {
      "indent": 3,
      "text": "10 Minor versions may upgrade features from optional to recommended or recommended to mandatory.",
      "ja": "10のマイナーバージョンは、オプションから推奨、または推奨されるものまで機能をアップグレードする場合があります。"
    },
    {
      "indent": 3,
      "text": "11 A client and server that support minor version X must support minor versions 0 (zero) through X-1 as well.",
      "ja": "11マイナーバージョンXをサポートするクライアントとサーバーは、X-1からマイナーバージョン0（ゼロ）もサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "12 No new features may be introduced as mandatory in a minor version.",
      "ja": "12マイナーバージョンでは必須として導入される新しい機能はありません。"
    },
    {
      "indent": 8,
      "text": "This rule allows for the introduction of new functionality and forces the use of implementation experience before designating a feature as mandatory.",
      "ja": "このルールにより、新しい機能を導入することができ、機能を必須として指定する前に実装エクスペリエンスの使用を強制します。"
    },
    {
      "indent": 3,
      "text": "13 A client MUST NOT attempt to use a stateid, file handle, or similar returned object from the COMPOUND procedure with minor version X for another COMPOUND procedure with minor version Y, where X != Y.",
      "ja": "13クライアントは、マイナーバージョンyを使用した別の複合手順のために、マイナーバージョンxを使用して、化合物の手順からStateID、ファイルハンドル、または同様の返されたオブジェクトを使用しようとしてはなりません。"
    },
    {
      "indent": 0,
      "text": "11. Internationalization",
      "section_title": true,
      "ja": "11. 国際化"
    },
    {
      "indent": 3,
      "text": "The primary issue in which NFS needs to deal with internationalization, or I18n, is with respect to file names and other strings as used within the protocol. The choice of string representation must allow reasonable name/string access to clients which use various languages. The UTF-8 encoding of the UCS as defined by [ISO10646] allows for this type of access and follows the policy described in \"IETF Policy on Character Sets and Languages\", [RFC2277]. This choice is explained further in the following.",
      "ja": "NFSが国際化（I18N）に対処する必要がある主な問題は、プロトコル内で使用されるファイル名やその他の文字列に関するものです。文字列表現の選択は、さまざまな言語を使用するクライアントへの合理的な名前/文字列アクセスを許可する必要があります。[ISO10646]で定義されているUCSのUTF-8エンコーディングは、このタイプのアクセスを許可し、「文字セットと言語に関するIETFポリシー」、[RFC2277]に記載されているポリシーに従います。この選択については、以下でさらに説明します。"
    },
    {
      "indent": 0,
      "text": "11.1. Universal Versus Local Character Sets",
      "section_title": true,
      "ja": "11.1. ユニバーサルセットとローカルキャラクターセット"
    },
    {
      "indent": 3,
      "text": "[RFC1345] describes a table of 16 bit characters for many different languages (the bit encodings match Unicode, though of course RFC1345 is somewhat out of date with respect to current Unicode assignments). Each character from each language has a unique 16 bit value in the 16 bit character set. Thus this table can be thought of as a universal character set. [RFC1345] then talks about groupings of subsets of the entire 16 bit character set into \"Charset Tables\". For example one might take all the Greek characters from the 16 bit table (which are consecutively allocated), and normalize their offsets to a table that fits in 7 bits. Thus it is determined that \"lower case alpha\" is in the same position as \"upper case a\" in the US-ASCII table, and \"upper case alpha\" is in the same position as \"lower case a\" in the US-ASCII table.",
      "ja": "[RFC1345]は、多くの異なる言語の16ビット文字のテーブルを説明しています（ビットエンコーディングはUnicodeと一致しますが、もちろんRFC1345は現在のユニコード割り当てに関しては多少不十分です）。各言語の各文字は、16ビット文字セットで一意の16ビット値を持っています。したがって、このテーブルは、普遍的なキャラクターセットと考えることができます。[RFC1345]次に、「チャーセットテーブル」に設定された16ビット文字全体のサブセットのグループ化について説明します。たとえば、16ビットテーブル（連続的に割り当てられている）からギリシャ語のすべてのキャラクターを取得し、7ビットに収まるテーブルにオフセットを正規化する場合があります。したがって、「小文字」は、米国ASCIIテーブルの「大文字のA」と同じ位置にあり、「上品なアルファ」は米国ASCIIの「小文字A」と同じ位置にあると判断されます。テーブル。"
    },
    {
      "indent": 3,
      "text": "These normalized subset character sets can be thought of as \"local character sets\", suitable for an operating system locale.",
      "ja": "これらの正規化されたサブセット文字セットは、オペレーティングシステムのロケールに適した「ローカル文字セット」と考えることができます。"
    },
    {
      "indent": 3,
      "text": "Local character sets are not suitable for the NFS protocol. Consider someone who creates a file with a name in a Swedish character set. If someone else later goes to access the file with their locale set to the Swedish language, then there are no problems. But if someone in say the US-ASCII locale goes to access the file, the file name will look very different, because the Swedish characters in the 7 bit table will now be represented in US-ASCII characters on the display. It would be preferable to give the US-ASCII user a way to display the file name using Swedish glyphs. In order to do that, the NFS protocol would have to include the locale with the file name on each operation to create a file.",
      "ja": "ローカル文字セットは、NFSプロトコルには適していません。スウェーデンの文字セットに名前を持つファイルを作成する人を検討してください。他の誰かが後でスウェーデン語に設定された場所でファイルにアクセスする場合、問題はありません。ただし、US-ASCIIロケールがファイルにアクセスすると言う場合、7ビットテーブルのスウェーデン文字がディスプレイのUS-ASCII文字で表現されるため、ファイル名は非常に異なって見えます。Swedish Glyphsを使用してファイル名を表示する方法をUS-ASCIIユーザーに提供することが望ましいでしょう。そのためには、NFSプロトコルは、ファイルを作成するために各操作にファイル名にロケールを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "But then what of the situation when there is a path name on the server like:",
      "ja": "しかし、サーバーにパス名がある場合の状況は次のようです。"
    },
    {
      "indent": 9,
      "text": "/component-1/component-2/component-3",
      "ja": "/Component-1/Component-2/Component-3"
    },
    {
      "indent": 3,
      "text": "Each component could have been created with a different locale. If one issues CREATE with multi-component path name, and if some of the leading components already exist, what is to be done with the existing components? Is the current locale attribute replaced with the user's current one? These types of situations quickly become too complex when there is an alternate solution.",
      "ja": "各コンポーネントは、異なるロケールで作成されている可能性があります。マルチコンポーネントパス名で1つの問題が作成され、主要なコンポーネントの一部がすでに存在する場合、既存のコンポーネントで何をする必要がありますか？現在のロケール属性はユーザーの現在の属性に置き換えられていますか？これらのタイプの状況は、別のソリューションがあるとすぐに複雑になりすぎます。"
    },
    {
      "indent": 3,
      "text": "If the NFS version 4 protocol used a universal 16 bit or 32 bit character set (or an encoding of a 16 bit or 32 bit character set into octets), then the server and client need not care if the locale of the user accessing the file is different than the locale of the user who created the file. The unique 16 bit or 32 bit encoding of the character allows for determination of what language the character is from and also how to display that character on the client. The server need not know what locales are used.",
      "ja": "NFSバージョン4プロトコルがユニバーサル16ビットまたは32ビット文字セット（または16ビットまたは32ビット文字セットのオクテットにエンコード）を使用した場合、サーバーとクライアントは、ファイルにアクセスするユーザーのロケールがアクセスするかどうかを気にしないでくださいファイルを作成したユーザーのロケールとは異なります。キャラクターの一意の16ビットまたは32ビットエンコードにより、キャラクターがどの言語であるか、またそのキャラクターをクライアントに表示する方法を決定できます。サーバーは、どのロケールが使用されているかを知る必要はありません。"
    },
    {
      "indent": 0,
      "text": "11.2. Overview of Universal Character Set Standards",
      "section_title": true,
      "ja": "11.2. ユニバーサル文字セット標準の概要"
    },
    {
      "indent": 3,
      "text": "The previous section makes a case for using a universal character set. This section makes the case for using UTF-8 as the specific universal character set for the NFS version 4 protocol.",
      "ja": "前のセクションでは、ユニバーサル文字セットを使用することをお勧めします。このセクションでは、NFSバージョン4プロトコルの特定のユニバーサル文字セットとしてUTF-8を使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "[RFC2279] discusses UTF-* (UTF-8 and other UTF-XXX encodings), Unicode, and UCS-*. There are two standards bodies managing universal code sets:",
      "ja": "[RFC2279] UTF-*（UTF-8およびその他のUTF-XXXエンコーディング）、Unicode、およびUCS-*について説明します。 ユニバーサルコードセットを管理する2つの標準団体があります。"
    },
    {
      "indent": 3,
      "text": "o ISO/IEC which has the standard 10646-1",
      "ja": "o 標準の10646-1を備えたISO/IEC"
    },
    {
      "indent": 3,
      "text": "o Unicode which has the Unicode standard",
      "ja": "o Unicode標準を備えたUnicode"
    },
    {
      "indent": 3,
      "text": "Both standards bodies have pledged to track each other's assignments of character codes.",
      "ja": "両方の標準団体は、互いの文字コードの割り当てを追跡することを約束しています。"
    },
    {
      "indent": 3,
      "text": "The following is a brief analysis of the various standards.",
      "ja": "以下は、さまざまな基準の簡単な分析です。"
    },
    {
      "indent": 3,
      "text": "UCS Universal Character Set. This is ISO/IEC 10646-1: \"a multi-octet character set called the Universal Character Set (UCS), which encompasses most of the world's writing systems.\"",
      "ja": "UCSユニバーサル文字セット。これはISO/IEC 10646-1です。"
    },
    {
      "indent": 3,
      "text": "UCS-2 a two octet per character encoding that addresses the first 2^16 characters of UCS. Currently there are no UCS characters beyond that range.",
      "ja": "UCS-2 UCSの最初の2^16文字に対処するエンコードごとに2オクテット。現在、その範囲を超えたUCS文字はありません。"
    },
    {
      "indent": 3,
      "text": "UCS-4 a four octet per character encoding that permits the encoding of up to 2^31 characters.",
      "ja": "UCS-4最大2^31文字のエンコードを可能にする文字エンコードあたり4オクテット。"
    },
    {
      "indent": 3,
      "text": "UTF UTF is an abbreviation of the term \"UCS transformation format\" and is used in the naming of various standards for encoding of UCS characters as described below.",
      "ja": "UTF UTFは、「UCS変換形式」という用語の略語であり、以下に説明するように、UCS文字のエンコードに関するさまざまな標準の命名に使用されます。"
    },
    {
      "indent": 3,
      "text": "UTF-1 Only historical interest; it has been removed from 10646-1",
      "ja": "UTF-1のみの歴史的関心。10646-1から削除されました"
    },
    {
      "indent": 3,
      "text": "UTF-7 Encodes the entire \"repertoire\" of UCS \"characters using only octets with the higher order bit clear\". [RFC2152] describes UTF-7. UTF-7 accomplishes this by reserving one of the 7bit US-ASCII characters as a \"shift\" character to indicate non-US-ASCII characters.",
      "ja": "UTF-7は、UCSの「レパートリー」文字全体をエンコードして、高次のビットがクリアされたオクテットのみを使用しています。[RFC2152]はUTF-7を説明しています。UTF-7は、7ビットのUS-ASCIIキャラクターの1つを「シフト」文字として予約して、非US-ASCIIキャラクターを示すことでこれを達成します。"
    },
    {
      "indent": 3,
      "text": "UTF-8 Unlike UTF-7, uses all 8 bits of the octets. US-ASCII characters are encoded as before unchanged. Any octet with the high bit cleared can only mean a US-ASCII character. The high bit set means that a UCS character is being encoded.",
      "ja": "UTF-8 UTF-7とは異なり、オクテットの8ビットすべてを使用します。US-ASCII文字は、変更されていないようにエンコードされます。高いビットをクリアしたオクテットは、US-ASCIIキャラクターを意味するだけです。ハイビットセットは、UCS文字がエンコードされていることを意味します。"
    },
    {
      "indent": 3,
      "text": "UTF-16 Encodes UCS-4 characters into UCS-2 characters using a reserved range in UCS-2.",
      "ja": "UTF-16は、UCS-2の予約範囲を使用して、UCS-4文字をUCS-2文字にエンコードします。"
    },
    {
      "indent": 3,
      "text": "Unicode Unicode and UCS-2 are the same; [RFC2279] states:",
      "ja": "Unicode UnicodeとUCS-2は同じです。[RFC2279]状態："
    },
    {
      "indent": 13,
      "text": "Up to the present time, changes in Unicode and amendments to ISO/IEC 10646 have tracked each other, so that the character repertoires and code point assignments have remained in sync. The relevant standardization committees have committed to maintain this very useful synchronism.",
      "ja": "現在まで、Unicodeの変更とISO/IEC 10646の修正が互いに追跡されているため、キャラクターのレパートリーとコードポイントの割り当ては同期し続けています。関連する標準化委員会は、この非常に有用な同期を維持することを約束しています。"
    },
    {
      "indent": 0,
      "text": "11.3. Difficulties with UCS-4, UCS-2, Unicode",
      "section_title": true,
      "ja": "11.3. UCS-4、UCS-2、Unicodeの難しさ"
    },
    {
      "indent": 3,
      "text": "Adapting existing applications, and file systems to multi-octet schemes like UCS and Unicode can be difficult. A significant amount of code has been written to process streams of bytes. Also there are many existing stored objects described with 7 bit or 8 bit characters. Doubling or quadrupling the bandwidth and storage requirements seems like an expensive way to accomplish I18N.",
      "ja": "既存のアプリケーションとシステムをUCSやUnicodeなどのマルチオクテットスキームに適合させることは困難です。バイトのストリームを処理するために、かなりの量のコードが書き込まれています。また、7ビットまたは8ビット文字で記述された多くの既存の保存オブジェクトがあります。帯域幅とストレージの要件を2倍または4倍にすると、i18nを達成するための高価な方法のようです。"
    },
    {
      "indent": 3,
      "text": "UCS-2 and Unicode are \"only\" 16 bits long. That might seem to be enough but, according to [Unicode1], 49,194 Unicode characters are already assigned. According to [Unicode2] there are still more languages that need to be added.",
      "ja": "UCS-2とUnicodeの長さは16ビットです。それで十分かもしれませんが、[Unicode1]によると、49,194のUnicode文字がすでに割り当てられています。[unicode2]によると、追加する必要がある言語がまだ増えています。"
    },
    {
      "indent": 0,
      "text": "11.4. UTF-8 and its solutions",
      "section_title": true,
      "ja": "11.4. UTF-8とそのソリューション"
    },
    {
      "indent": 3,
      "text": "UTF-8 solves problems for NFS that exist with the use of UCS and Unicode. UTF-8 will encode 16 bit and 32 bit characters in a way that will be compact for most users. The encoding table from UCS-4 to UTF-8, as copied from [RFC2279]:",
      "ja": "UTF-8は、UCSとUnicodeを使用して存在するNFSの問題を解決します。UTF-8は、ほとんどのユーザーにとってコンパクトになる方法で16ビットと32ビットの文字をエンコードします。[RFC2279]からコピーされたUCS-4からUTF-8へのエンコードテーブル："
    },
    {
      "indent": 4,
      "text": " UCS-4 range (hex.) UTF-8 octet sequence (binary) 0000 0000-0000 007F 0xxxxxxx 0000 0080-0000 07FF 110xxxxx 10xxxxxx 0000 0800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-001F FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 0020 0000-03FF FFFF 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 0400 0000-7FFF FFFF 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx",
      "ja": "UCS-4 range (hex.) UTF-8 octet sequence (binary) 0000 0000-0000 007F 0xxxxxxx 0000 0080-0000 07FF 110xxxxx 10xxxxxx 0000 0800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-001F FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 0020 0000-03FFffff 111110xx 10xxxxxx 10xxxxxx 10xxxxxxxxxxxxxxxxxx 0400 0000-7fff ffff 1111110x 10xxxxxxxxxxxxxxxxx10xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
    },
    {
      "indent": 3,
      "text": "See [RFC2279] for precise encoding and decoding rules. Note because of UTF-16, the algorithm from Unicode/UCS-2 to UTF-8 needs to account for the reserved range between D800 and DFFF.",
      "ja": "正確なエンコードとデコードルールについては、[RFC2279]を参照してください。注UTF-16のため、Unicode/UCS-2からUTF-8までのアルゴリズムは、D800とDFFFの間の予約範囲を説明する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that the 16 bit UCS or Unicode characters require no more than 3 octets to encode into UTF-8",
      "ja": "16ビットUCSまたはUnicode文字は、UTF-8にエンコードするために3オクテット以下が必要であることに注意してください"
    },
    {
      "indent": 3,
      "text": "Interestingly, UTF-8 has room to handle characters larger than 31 bits, because the leading octet of form:",
      "ja": "興味深いことに、UTF-8には、31ビットを超える文字を処理する余地があります。"
    },
    {
      "indent": 9,
      "text": "1111111x",
      "ja": "1111111x"
    },
    {
      "indent": 3,
      "text": "is not defined. If needed, ISO could either use that octet to indicate a sequence of an encoded 8 octet character, or perhaps use 11111110 to permit the next octet to indicate an even more expandable character set.",
      "ja": "定義されていません。必要に応じて、ISOはそのオクテットを使用してエンコードされた8オクテット文字のシーケンスを示すか、11111110を使用して次のオクテットを使用して、さらに拡張可能な文字セットを示すことができます。"
    },
    {
      "indent": 3,
      "text": "So using UTF-8 to represent character encodings means never having to run out of room.",
      "ja": "したがって、UTF-8を使用して文字エンコーディングを表すことは、部屋を使い果たす必要がないことを意味します。"
    },
    {
      "indent": 0,
      "text": "11.5. Normalization",
      "section_title": true,
      "ja": "11.5. 正規化"
    },
    {
      "indent": 3,
      "text": "The client and server operating environments may differ in their policies and operational methods with respect to character normalization (See [Unicode1] for a discussion of normalization forms). This difference may also exist between applications on the same client. This adds to the difficulty of providing a single normalization policy for the protocol that allows for maximal interoperability. This issue is similar to the character case issues where the server may or may not support case insensitive file name matching and may or may not preserve the character case when storing file names. The protocol does not mandate a particular behavior but allows for the various permutations.",
      "ja": "クライアントとサーバーの動作環境は、文字の正規化に関してポリシーと運用方法が異なる場合があります（正規化フォームの議論については[Unicode1]を参照）。この違いは、同じクライアントのアプリケーション間にも存在する場合があります。これにより、最大の相互運用性を可能にするプロトコルに単一の正規化ポリシーを提供することが難しくなります。この問題は、サーバーがケースの無感覚なファイル名の一致をサポートする場合とサポートする場合とサポートしている場合と、ファイル名を保存する際に文字ケースを保存しない場合があるキャラクターケースの問題に類似しています。プロトコルは特定の動作を義務付けるものではなく、さまざまな順列を許可します。"
    },
    {
      "indent": 3,
      "text": "The NFS version 4 protocol does not mandate the use of a particular normalization form at this time. A later revision of this specification may specify a particular normalization form. Therefore, the server and client can expect that they may receive unnormalized characters within protocol requests and responses. If the operating environment requires normalization, then the implementation must normalize the various UTF-8 encoded strings within the protocol before presenting the information to an application (at the client) or local file system (at the server).",
      "ja": "NFSバージョン4プロトコルは、現時点で特定の正規化フォームの使用を義務付けていません。この仕様の後の改訂では、特定の正規化フォームを指定できます。したがって、サーバーとクライアントは、プロトコルの要求と応答内で非正規化された文字を受け取ることができると期待できます。動作環境に正規化が必要な場合、実装は、プロトコル内のさまざまなUTF-8エンコードされた文字列を正規化する必要があります。"
    },
    {
      "indent": 0,
      "text": "12. Error Definitions",
      "section_title": true,
      "ja": "12. エラー定義"
    },
    {
      "indent": 3,
      "text": "NFS error numbers are assigned to failed operations within a compound request. A compound request contains a number of NFS operations that have their results encoded in sequence in a compound reply. The results of successful operations will consist of an NFS4_OK status followed by the encoded results of the operation. If an NFS operation fails, an error status will be entered in the reply and the compound request will be terminated.",
      "ja": "NFSエラー番号は、複合リクエスト内で操作に失敗したことに割り当てられます。複合リクエストには、複合応答で結果が順番にエンコードされた多数のNFS操作が含まれています。成功した操作の結果は、NFS4_OKステータスに続いて操作のエンコードされた結果で構成されます。NFS操作が失敗した場合、応答にエラーステータスが入力され、複合リクエストが終了します。"
    },
    {
      "indent": 3,
      "text": "A description of each defined error follows:",
      "ja": "定義された各エラーの説明は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NFS4_OK Indicates the operation completed successfully.",
      "ja": "NFS4_OKは、操作が正常に完了したことを示します。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_ACCES Permission denied. The caller does not have the correct permission to perform the requested operation. Contrast this with NFS4ERR_PERM, which restricts itself to owner or privileged user permission failures.",
      "ja": "nfs4err_acces許可は拒否されました。発信者は、要求された操作を実行する正しい許可を持っていません。これをnfs4err_permとは対照的に、所有者または特権のあるユーザー許可の失敗に制限します。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_BADHANDLE Illegal NFS file handle. The file handle failed internal consistency checks.",
      "ja": "nfs4err_badhandle違法NFSファイルハンドル。ファイルハンドルは、内部一貫性チェックに失敗しました。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_BADTYPE An attempt was made to create an object of a type not supported by the server.",
      "ja": "nfs4err_badtypeサーバーでサポートされていないタイプのオブジェクトを作成する試みがなされました。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_BAD_COOKIE READDIR cookie is stale.",
      "ja": "nfs4err_bad_cookie readdir cookieは古くなっています。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_BAD_SEQID The sequence number in a locking request is neither the next expected number or the last number processed.",
      "ja": "nfs4err_bad_seqidロック要求のシーケンス番号は、次の予想番号でも、処理された最後の番号でもありません。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_BAD_STATEID A stateid generated by the current server instance, but which does not designate any locking state (either current or superseded) for a current lockowner-file pair, was used.",
      "ja": "nfs4err_bad_stateid現在のサーバーインスタンスによって生成されたStateidですが、現在のLockowner-Fileペアのロック状態（現在または置換）を指定していません。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_CLID_INUSE The SETCLIENTID procedure has found that a client id is already in use by another client.",
      "ja": "nfs4err_clid_inuse setClientIDプロシージャは、クライアントIDがすでに別のクライアントによって使用されていることを発見しました。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_DELAY The server initiated the request, but was not able to complete it in a timely fashion. The client should wait and then try the request with a new RPC transaction ID. For example, this error should be returned from a server that supports hierarchical storage and receives a request to process a file that has been migrated. In this case, the server should start the immigration process and respond to client with this error. This error may also occur when a necessary delegation recall makes processing a request in a timely fashion impossible.",
      "ja": "nfs4err_delayサーバーはリクエストを開始しましたが、タイムリーにそれを完了することはできませんでした。クライアントは待ってから、新しいRPCトランザクションIDでリクエストを試してみる必要があります。たとえば、このエラーは、階層ストレージをサポートし、移行されたファイルを処理するリクエストを受信するサーバーから返す必要があります。この場合、サーバーは移民プロセスを開始し、このエラーでクライアントに応答する必要があります。このエラーは、必要な代表団のリコールがタイムリーな方法でリクエストを不可能にする場合にも発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_DENIED An attempt to lock a file is denied. Since this may be a temporary condition, the client is encouraged to retry the lock request until the lock is accepted.",
      "ja": "nfs4err_deniedファイルをロックする試みは拒否されます。これは一時的な条件である可能性があるため、クライアントはロックが受け入れるまでロックリクエストを再試行することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_DQUOT Resource (quota) hard limit exceeded. The user's resource limit on the server has been exceeded.",
      "ja": "nfs4err_dquotリソース（クォータ）ハードリミットを超えました。サーバーのユーザーのリソース制限は超えています。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_EXIST File exists. The file specified already exists.",
      "ja": "nfs4err_existファイルが存在します。指定されたファイルはすでに存在します。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_EXPIRED A lease has expired that is being used in the current procedure.",
      "ja": "nfs4err_expired現在の手順で使用されているリースの有効期限が切れています。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_FBIG File too large. The operation would have caused a file to grow beyond the server's limit.",
      "ja": "nfs4err_fbigファイルが大きすぎます。この操作により、ファイルがサーバーの制限を超えて成長するようになりました。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_FHEXPIRED The file handle provided is volatile and has expired at the server.",
      "ja": "nfs4err_fhexpired提供されたファイルハンドルは揮発性であり、サーバーで有効期限が切れています。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_GRACE The server is in its recovery or grace period which should match the lease period of the server.",
      "ja": "nfs4err_graceサーバーは、サーバーのリース期間に一致するはずの回復または猶予期間にあります。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_INVAL Invalid argument or unsupported argument for an operation. Two examples are attempting a READLINK on an object other than a symbolic link or attempting to SETATTR a time field on a server that does not support this operation.",
      "ja": "nfs4err_invalは、操作に対する主張またはサポートされていない引数を無効にします。2つの例は、シンボリックリンク以外のオブジェクトのREADLINKを試みるか、この操作をサポートしていないサーバー上のタイムフィールドをSetATTRにしようとすることです。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_IO I/O error. A hard error (for example, a disk error) occurred while processing the requested operation.",
      "ja": "nfs4err_io i/oエラー。要求された操作の処理中に、ハードエラー（たとえば、ディスクエラー）が発生しました。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_ISDIR Is a directory. The caller specified a directory in a non-directory operation.",
      "ja": "nfs4err_isdirはディレクトリです。発信者は、非方向性操作でディレクトリを指定しました。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_LEASE_MOVED A lease being renewed is associated with a file system that has been migrated to a new server.",
      "ja": "nfs4err_lease_moved更新されるリースは、新しいサーバーに移行されたファイルシステムに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_LOCKED A read or write operation was attempted on a locked file.",
      "ja": "nfs4err_lockedロックされたファイルで読み取りまたは書き込み操作が試みられました。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_LOCK_RANGE A lock request is operating on a sub-range of a current lock for the lock owner and the server does not support this type of request.",
      "ja": "nfs4err_lock_rangeロックリクエストは、ロック所有者の現在のロックのサブレンジで動作し、サーバーはこのタイプのリクエストをサポートしていません。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_MINOR_VERS_MISMATCH The server has received a request that specifies an unsupported minor version. The server must return a COMPOUND4res with a zero length operations result array.",
      "ja": "nfs4err_minor_vers_mismatchサーバーは、サポートされていないマイナーバージョンを指定するリクエストを受信しました。サーバーは、ゼロの長さ操作結果アレイを備えた化合物4REを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_MLINK Too many hard links.",
      "ja": "nfs4err_mlinkハードリンクが多すぎます。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_MOVED The filesystem which contains the current filehandle object has been relocated or migrated to another server. The client may obtain the new filesystem location by obtaining the \"fs_locations\" attribute for the current filehandle. For further discussion, refer to the section \"Filesystem Migration or Relocation\".",
      "ja": "nfs4err_moved現在のファイルハンドルオブジェクトを含むファイルシステムは、別のサーバーに再配置または移行されました。クライアントは、現在のファイルハンドルの「FS_Locations」属性を取得することにより、新しいファイルシステムの場所を取得できます。詳細については、セクション「ファイルシステムの移行または再配置」を参照してください。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_NAMETOOLONG The filename in an operation was too long.",
      "ja": "nfs4err_nameToolong操作のファイル名は長すぎました。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_NODEV No such device.",
      "ja": "nfs4err_nodevそのようなデバイスはありません。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_NOENT No such file or directory. The file or directory name specified does not exist.",
      "ja": "nfs4err_noentそのようなファイルまたはディレクトリはありません。指定されたファイルまたはディレクトリ名は存在しません。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_NOFILEHANDLE The logical current file handle value has not been set properly. This may be a result of a malformed COMPOUND operation (i.e. no PUTFH or PUTROOTFH before an operation that requires the current file handle be set).",
      "ja": "nfs4err_nofilehandle論理電流ファイルのハンドル値は適切に設定されていません。これは、奇形の複合操作の結果である可能性があります（つまり、現在のファイルハンドルを設定する必要がある操作の前に、putfhまたはputrootfhはありません）。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_NOSPC No space left on device. The operation would have caused the server's file system to exceed its limit.",
      "ja": "nfs4err_nospcデバイスにスペースが残っていません。この操作により、サーバーのファイルシステムが制限を超えるようになりました。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_NOTDIR Not a directory. The caller specified a non-directory in a directory operation.",
      "ja": "nfs4err_notdirディレクトリではありません。発信者は、ディレクトリ操作で非ディレクトリを指定しました。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_NOTEMPTY An attempt was made to remove a directory that was not empty.",
      "ja": "nfs4err_notemptyは、空ではないディレクトリを削除する試みがなされました。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_NOTSUPP Operation is not supported.",
      "ja": "nfs4err_notsupp操作はサポートされていません。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_NOT_SAME This error is returned by the VERIFY operation to signify that the attributes compared were not the same as provided in the client's request.",
      "ja": "nfs4err_not_sameこのエラーは、検証操作によって返され、比較された属性がクライアントの要求で提供されているものと同じではないことを示します。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_NXIO I/O error. No such device or address.",
      "ja": "nfs4err_nxio i/oエラー。そのようなデバイスやアドレスはありません。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_OLD_STATEID A stateid which designates the locking state for a lockowner-file at an earlier time was used.",
      "ja": "nfs4err_old_stateid以前にロックオーナーファイルのロック状態を指定するStateidが使用されました。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_PERM Not owner. The operation was not allowed because the caller is either not a privileged user (root) or not the owner of the target of the operation.",
      "ja": "nfs4err_perm所有者ではありません。発信者は特権ユーザー（root）ではないか、操作のターゲットの所有者ではないため、操作は許可されていませんでした。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_READDIR_NOSPC The encoded response to a READDIR request exceeds the size limit set by the initial request.",
      "ja": "nfs4err_readdir_nospc readdirリクエストに対するエンコードされた応答は、初期リクエストで設定されたサイズ制限を超えています。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_RESOURCE For the processing of the COMPOUND procedure, the server may exhaust available resources and can not continue processing procedures within the COMPOUND operation. This error will be returned from the server in those instances of resource exhaustion related to the processing of the COMPOUND procedure.",
      "ja": "nfs4err_resource化合物手順の処理については、サーバーは利用可能なリソースを排出する場合があり、複合操作内で処理手順を継続することはできません。このエラーは、化合物手順の処理に関連するリソースの疲労のインスタンスでサーバーから返されます。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_ROFS Read-only file system. A modifying operation was attempted on a read-only file system.",
      "ja": "nfs4err_rofs読み取り専用ファイルシステム。読み取り専用ファイルシステムで修正操作が試みられました。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_SAME This error is returned by the NVERIFY operation to signify that the attributes compared were the same as provided in the client's request.",
      "ja": "nfs4err_sameこのエラーは、nverify操作によって返され、比較された属性がクライアントの要求で提供されたものと同じであることを示します。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_SERVERFAULT An error occurred on the server which does not map to any of the legal NFS version 4 protocol error values. The client should translate this into an appropriate error. UNIX clients may choose to translate this to EIO.",
      "ja": "nfs4err_serverfaultリーガルNFSバージョン4プロトコルエラー値のいずれにもマッピングされないエラーがサーバーで発生しました。クライアントはこれを適切なエラーに変換する必要があります。UNIXクライアントは、これをEIOに翻訳することを選択できます。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_SHARE_DENIED An attempt to OPEN a file with a share reservation has failed because of a share conflict.",
      "ja": "nfs4err_share_denied株式予約でファイルを開く試みは、株式の競合のために失敗しました。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_STALE Invalid file handle. The file handle given in the arguments was invalid. The file referred to by that file handle no longer exists or access to it has been revoked.",
      "ja": "nfs4err_stale無効なファイルハンドル。引数に記載されているファイルハンドルは無効でした。そのファイルハンドルで言及されているファイルは、もはや存在しないか、それへのアクセスが取り消されました。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_STALE_CLIENTID A clientid not recognized by the server was used in a locking or SETCLIENTID_CONFIRM request.",
      "ja": "nfs4err_stale_clientidサーバーによって認識されていないクライアントが、ロックまたはsetclientId_confirmリクエストで使用されました。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_STALE_STATEID A stateid generated by an earlier server instance was used.",
      "ja": "nfs4err_stale_stateid以前のサーバーインスタンスによって生成されたStateidが使用されました。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_SYMLINK The current file handle provided for a LOOKUP is not a directory but a symbolic link. Also used if the final component of the OPEN path is a symbolic link.",
      "ja": "nfs4err_symlinkルックアップに提供される現在のファイルハンドルは、ディレクトリではなく、シンボリックリンクです。また、オープンパスの最終コンポーネントがシンボリックリンクである場合にも使用されます。"
    },
    {
      "indent": 25,
      "text": "NFS4ERR_TOOSMALL Buffer or request is too small.",
      "ja": "nfs4err_toosmallバッファまたはリクエストが小さすぎます。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_WRONGSEC The security mechanism being used by the client for the procedure does not match the server's security policy. The client should change the security mechanism being used and retry the operation.",
      "ja": "nfs4err_wrongsec手順にクライアントが使用するセキュリティメカニズムは、サーバーのセキュリティポリシーと一致しません。クライアントは、使用されているセキュリティメカニズムを変更し、操作を再試行する必要があります。"
    },
    {
      "indent": 3,
      "text": "NFS4ERR_XDEV Attempt to do a cross-device hard link.",
      "ja": "nfs4err_xdevクロスデバイスハードリンクを実行しようとします。"
    },
    {
      "indent": 0,
      "text": "13. NFS Version 4 Requests",
      "section_title": true,
      "ja": "13. NFSバージョン4リクエスト"
    },
    {
      "indent": 3,
      "text": "For the NFS version 4 RPC program, there are two traditional RPC procedures: NULL and COMPOUND. All other functionality is defined as a set of operations and these operations are defined in normal XDR/RPC syntax and semantics. However, these operations are encapsulated within the COMPOUND procedure. This requires that the client combine one or more of the NFS version 4 operations into a single request.",
      "ja": "NFSバージョン4 RPCプログラムには、2つの従来のRPC手順があります：nullと化合物。他のすべての機能は一連の操作として定義され、これらの操作は通常のXDR/RPC構文とセマンティクスで定義されます。ただし、これらの操作は複合手順内でカプセル化されています。これには、クライアントが1つ以上のNFSバージョン4操作を単一のリクエストに組み合わせる必要があります。"
    },
    {
      "indent": 3,
      "text": "The NFS4_CALLBACK program is used to provide server to client signaling and is constructed in a similar fashion as the NFS version 4 program. The procedures CB_NULL and CB_COMPOUND are defined in the same way as NULL and COMPOUND are within the NFS program. The CB_COMPOUND request also encapsulates the remaining operations of the NFS4_CALLBACK program. There is no predefined RPC program number for the NFS4_CALLBACK program. It is up to the client to specify a program number in the \"transient\" program range. The program and port number of the NFS4_CALLBACK program are provided by the client as part of the SETCLIENTID operation and therefore is fixed for the life of the client instantiation.",
      "ja": "NFS4_Callbackプログラムは、クライアントシグナリングにサーバーを提供するために使用され、NFSバージョン4プログラムと同様の方法で構築されます。手順CB_NULLとCB_COMPOUNDは、NFSプログラム内でnullと化合物と同じ方法で定義されます。CB_Compound要求は、NFS4_Callbackプログラムの残りの操作もカプセル化します。NFS4_Callbackプログラムには、事前定義されたRPCプログラム番号はありません。「一時的な」プログラム範囲でプログラム番号を指定するのはクライアント次第です。NFS4_Callbackプログラムのプログラムとポート番号は、SetClientID操作の一部としてクライアントによって提供されるため、クライアントのインスタンス化の寿命に合わせて固定されています。"
    },
    {
      "indent": 0,
      "text": "13.1. Compound Procedure",
      "section_title": true,
      "ja": "13.1. 複合手順"
    },
    {
      "indent": 3,
      "text": "The COMPOUND procedure provides the opportunity for better performance within high latency networks. The client can avoid cumulative latency of multiple RPCs by combining multiple dependent operations into a single COMPOUND procedure. A compound operation may provide for protocol simplification by allowing the client to combine basic procedures into a single request that is customized for the client's environment.",
      "ja": "複合手順は、高レイテンシネットワーク内でのパフォーマンスを向上させる機会を提供します。クライアントは、複数の依存操作を単一の化合物手順に組み合わせることにより、複数のRPCの累積レイテンシを回避できます。複合操作は、クライアントが基本手順をクライアントの環境に合わせてカスタマイズされた単一のリクエストに組み合わせることができるようにすることにより、プロトコルの簡素化を提供する場合があります。"
    },
    {
      "indent": 3,
      "text": "The CB_COMPOUND procedure precisely parallels the features of COMPOUND as described above.",
      "ja": "CB_COMPOUND手順は、上記のように化合物の特徴を正確に類似しています。"
    },
    {
      "indent": 3,
      "text": "The basics of the COMPOUND procedures construction is:",
      "ja": "複合手順の構築の基本は次のとおりです。"
    },
    {
      "indent": 18,
      "text": "+-----------+-----------+-----------+--\n| op + args | op + args | op + args |\n+-----------+-----------+-----------+--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "and the reply looks like this:",
      "ja": "そして、返事は次のようになります："
    },
    {
      "indent": 6,
      "text": "+------------+-----------------------+-----------------------+--\n|last status | status + op + results | status + op + results |\n+------------+-----------------------+-----------------------+--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "13.2. Evaluation of a Compound Request",
      "section_title": true,
      "ja": "13.2. 複合リクエストの評価"
    },
    {
      "indent": 3,
      "text": "The server will process the COMPOUND procedure by evaluating each of the operations within the COMPOUND procedure in order. Each component operation consists of a 32 bit operation code, followed by the argument of length determined by the type of operation. The results of each operation are encoded in sequence into a reply buffer. The results of each operation are preceded by the opcode and a status code (normally zero). If an operation results in a non-zero status code, the status will be encoded and evaluation of the compound sequence will halt and the reply will be returned. Note that evaluation stops even in the event of \"non error\" conditions such as NFS4ERR_SAME.",
      "ja": "サーバーは、複合手順内の各操作を順番に評価することにより、複合手順を処理します。各コンポーネント操作は、32ビット操作コードで構成され、その後、操作の種類によって決定される長さの引数が続きます。各操作の結果は、順番に返信バッファーにエンコードされています。各操作の結果の前には、オペコードとステータスコード（通常はゼロ）があります。操作がゼロ以外のステータスコードが発生すると、ステータスがエンコードされ、複合配列の評価が停止し、返信が返されます。NFS4err_Sameなどの「非エラー」条件がある場合でも、評価は停止することに注意してください。"
    },
    {
      "indent": 3,
      "text": "There are no atomicity requirements for the operations contained within the COMPOUND procedure. The operations being evaluated as part of a COMPOUND request may be evaluated simultaneously with other COMPOUND requests that the server receives.",
      "ja": "複合手順に含まれる操作には原子性要件はありません。化合物要求の一部として評価される操作は、サーバーが受信する他の複合要求と同時に評価できます。"
    },
    {
      "indent": 3,
      "text": "It is the client's responsibility for recovering from any partially completed COMPOUND procedure. Partially completed COMPOUND procedures may occur at any point due to errors such as NFS4ERR_RESOURCE and NFS4ERR_LONG_DELAY. This may occur even given an otherwise valid operation string. Further, a server reboot which occurs in the middle of processing a COMPOUND procedure may leave the client with the difficult task of determining how far COMPOUND processing has proceeded. Therefore, the client should avoid overly complex COMPOUND procedures in the event of the failure of an operation within the procedure.",
      "ja": "部分的に完了した複合手順から回復することは、クライアントの責任です。nfs4err_resourceやnfs4err_long_delayなどのエラーにより、部分的に完了した複合手順が任意の時点で発生する場合があります。これは、それ以外の場合は有効な操作文字列を与えられても発生する可能性があります。さらに、化合物の手順の処理の途中で発生するサーバーの再起動により、クライアントは、化合物処理がどこまで進んだかを決定するという難しいタスクを残す場合があります。したがって、クライアントは、手順内で操作が失敗した場合に過度に複雑な複合手順を回避する必要があります。"
    },
    {
      "indent": 3,
      "text": "Each operation assumes a \"current\" and \"saved\" filehandle that is available as part of the execution context of the compound request. Operations may set, change, or return the current filehandle. The \"saved\" filehandle is used for temporary storage of a filehandle value and as operands for the RENAME and LINK operations.",
      "ja": "各操作は、化合物要求の実行コンテキストの一部として利用可能な「現在」および「保存された」ファイルハンドルを想定しています。操作は、現在のファイルハンドルを設定、変更、または返却する場合があります。「保存された」FileHandleは、ファイルハンドル値の一時的なストレージに、および変更およびリンク操作のオペランドとして使用されます。"
    },
    {
      "indent": 0,
      "text": "13.3. Synchronous Modifying Operations",
      "section_title": true,
      "ja": "13.3. 同期修正操作"
    },
    {
      "indent": 3,
      "text": "NFS version 4 operations that modify the file system are synchronous. When an operation is successfully completed at the server, the client can depend that any data associated with the request is now on stable storage (the one exception is in the case of the file data in a WRITE operation with the UNSTABLE option specified).",
      "ja": "ファイルシステムを変更するNFSバージョン4操作は同期です。サーバーで操作が正常に完了した場合、クライアントは、リクエストに関連付けられたデータが安定したストレージ上にあることを依存できます（1つの例外は、指定された不安定なオプションを備えた書き込み操作のファイルデータの場合です）。"
    },
    {
      "indent": 3,
      "text": "This implies that any previous operations within the same compound request are also reflected in stable storage. This behavior enables the client's ability to recover from a partially executed compound request which may resulted from the failure of the server. For example, if a compound request contains operations A and B and the server is unable to send a response to the client, depending on the progress the server made in servicing the request the result of both operations may be reflected in stable storage or just operation A may be reflected. The server must not have just the results of operation B in stable storage.",
      "ja": "これは、同じ複合要求内の以前の操作が安定したストレージにも反映されていることを意味します。この動作により、クライアントの能力は、サーバーの障害から生じる可能性のある部分的に実行された複合要求から回復できます。たとえば、化合物要求に操作AとBが含まれ、サーバーがクライアントに応答を送信できない場合、サーバーがサービスを提供する際に行った進行状況に応じて、両方の操作の結果が安定したストレージまたは単なる操作に反映される場合がありますAが反映される場合があります。サーバーは、安定したストレージで操作Bの結果だけを持ってはなりません。"
    },
    {
      "indent": 0,
      "text": "13.4. Operation Values",
      "section_title": true,
      "ja": "13.4. 操作値"
    },
    {
      "indent": 3,
      "text": "The operations encoded in the COMPOUND procedure are identified by operation values. To avoid overlap with the RPC procedure numbers, operations 0 (zero) and 1 are not defined. Operation 2 is not defined but reserved for future use with minor versioning.",
      "ja": "複合手順でエンコードされた操作は、操作値によって識別されます。RPCプロシージャ数との重複を避けるために、操作0（ゼロ）と1は定義されていません。操作2は定義されていませんが、マイナーバージョンでの将来の使用のために予約されています。"
    },
    {
      "indent": 0,
      "text": "14. NFS Version 4 Procedures",
      "section_title": true,
      "ja": "14. NFSバージョン4手順"
    },
    {
      "indent": 0,
      "text": "14.1. Procedure 0: NULL - No Operation",
      "section_title": true,
      "ja": "14.1. 手順0：null-操作なし"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "<null>",
      "ja": "<null>"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "void;",
      "ja": "空所;"
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "void;",
      "ja": "空所;"
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "Standard NULL procedure. Void argument, void response. This procedure has no functionality associated with it. Because of this it is sometimes used to measure the overhead of processing a service request. Therefore, the server should ensure that no unnecessary work is done in servicing this procedure.",
      "ja": "標準のヌル手順。空の引数、無効な応答。この手順には、それに関連する機能がありません。このため、サービスリクエストの処理のオーバーヘッドを測定するために使用されることがあります。したがって、サーバーは、この手順のサービスに不必要な作業が行われないようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "None.",
      "ja": "なし。"
    },
    {
      "indent": 0,
      "text": "14.2. Procedure 1: COMPOUND - Compound Operations",
      "section_title": true,
      "ja": "14.2. 手順1：化合物 - 複合操作"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "compoundargs -> compoundres",
      "ja": "compountargs-> compounters"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "union nfs_argop4 switch (nfs_opnum4 argop) {\n        case <OPCODE>: <argument>;\n        ...\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct COMPOUND4args {\n        utf8string      tag;\n        uint32_t        minorversion;\n        nfs_argop4      argarray<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 9,
      "text": "union nfs_resop4 switch (nfs_opnum4 resop){\n        case <OPCODE>: <result>;\n        ...\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "struct COMPOUND4res {\n        nfsstat4        status;\n        utf8string      tag;\n        nfs_resop4      resarray<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The COMPOUND procedure is used to combine one or more of the NFS operations into a single RPC request. The main NFS RPC program has two main procedures: NULL and COMPOUND. All other operations use the COMPOUND procedure as a wrapper.",
      "ja": "複合手順は、1つ以上のNFS操作を単一のRPC要求に組み合わせるために使用されます。主なNFS RPCプログラムには、NULLと化合物の2つの主な手順があります。他のすべての操作は、複合手順をラッパーとして使用します。"
    },
    {
      "indent": 6,
      "text": "The COMPOUND procedure is used to combine individual operations into a single RPC request. The server interprets each of the operations in turn. If an operation is executed by the server and the status of that operation is NFS4_OK, then the next operation in the COMPOUND procedure is executed. The server continues this process until there are no more operations to be executed or one of the operations has a status value other than NFS4_OK.",
      "ja": "複合手順は、個々の操作を単一のRPC要求に結合するために使用されます。サーバーは、各操作を順番に解釈します。サーバーによって操作が実行され、その操作のステータスがNFS4_OKである場合、複合手順の次の操作が実行されます。サーバーは、実行する操作がなくなるか、操作のいずれかがNFS4_OK以外のステータス値を持つまで、このプロセスを継続します。"
    },
    {
      "indent": 6,
      "text": "In the processing of the COMPOUND procedure, the server may find that it does not have the available resources to execute any or all of the operations within the COMPOUND sequence. In this case, the error NFS4ERR_RESOURCE will be returned for the particular operation within the COMPOUND procedure where the resource exhaustion occurred. This assumes that all previous operations within the COMPOUND sequence have been evaluated successfully. The results for all of the evaluated operations must be returned to the client.",
      "ja": "化合物手順の処理では、サーバーは、化合物シーケンス内の操作の一部またはすべてを実行するための利用可能なリソースがないことを発見する場合があります。この場合、エラーNFS4ERR_RESOURCEは、リソースの使い果たしが発生した複合手順内の特定の操作に対して返されます。これは、化合物配列内の以前のすべての操作が正常に評価されていることを前提としています。評価されたすべての操作の結果は、クライアントに返品する必要があります。"
    },
    {
      "indent": 6,
      "text": "The COMPOUND arguments contain a \"minorversion\" field. The initial and default value for this field is 0 (zero). This field will be used by future minor versions such that the client can communicate to the server what minor version is being requested.",
      "ja": "複合引数には、「マイナーバージョン」フィールドが含まれています。このフィールドの初期値とデフォルト値は0（ゼロ）です。このフィールドは、クライアントがマイナーバージョンが要求されているものをサーバーに通信できるように、将来のマイナーバージョンで使用されます。"
    },
    {
      "indent": 6,
      "text": "If the server receives a COMPOUND procedure with a minorversion field value that it does not support, the server MUST return an error of NFS4ERR_MINOR_VERS_MISMATCH and a zero length resultdata array.",
      "ja": "サーバーがサポートしていないマイナーバージョンフィールド値を使用して複合手順を受信した場合、サーバーはnfs4err_minor_vers_mismatchのエラーとゼロの長さのresultDataアレイのエラーを返す必要があります。"
    },
    {
      "indent": 6,
      "text": "Contained within the COMPOUND results is a \"status\" field. If the results array length is non-zero, this status must be equivalent to the status of the last operation that was executed within the COMPOUND procedure. Therefore, if an operation incurred an error then the \"status\" value will be the same error value as is being returned for the operation that failed.",
      "ja": "複合結果に含まれるのは、「ステータス」フィールドです。結果アレイの長さがゼロでない場合、このステータスは、複合手順内で実行された最後の操作のステータスと同等でなければなりません。したがって、操作がエラーが発生した場合、「ステータス」値は、失敗した操作に対して返されているのと同じエラー値になります。"
    },
    {
      "indent": 6,
      "text": "Note that operations, 0 (zero) and 1 (one) are not defined for the COMPOUND procedure. If the server receives an operation array with either of these included, an error of NFS4ERR_NOTSUPP must be returned. Operation 2 is not defined but reserved for future definition and use with minor versioning. If the server receives a operation array that contains operation 2 and the minorversion field has a value of 0 (zero), an error of NFS4ERR_NOTSUPP is returned. If an operation array contains an operation 2 and the minorversion field is non-zero and the server does not support the minor version, the server returns an error of NFS4ERR_MINOR_VERS_MISMATCH. Therefore, the NFS4ERR_MINOR_VERS_MISMATCH error takes precedence over all other errors.",
      "ja": "操作、0（ゼロ）および1（1）は、複合手順で定義されていないことに注意してください。サーバーがこれらのいずれかを含む操作配列を受信した場合、nfs4err_notsuppのエラーを返す必要があります。操作2は定義されていませんが、将来の定義とマイナーバージョンの使用のために予約されています。サーバーが操作2を含む操作アレイを受信し、マイナーバージョンフィールドの値は0（ゼロ）の場合、nfs4err_notsuppの誤差が返されます。操作配列に操作2が含まれており、マイナーバージョンフィールドがゼロではなく、サーバーがマイナーバージョンをサポートしていない場合、サーバーはnfs4err_minor_vers_mismatchのエラーを返します。したがって、nfs4err_minor_vers_mismatchエラーは、他のすべてのエラーよりも優先されます。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "Note that the definition of the \"tag\" in both the request and response are left to the implementor. It may be used to summarize the content of the compound request for the benefit of packet sniffers and engineers debugging implementations.",
      "ja": "リクエストと応答の両方の「タグ」の定義は実装者に任されていることに注意してください。パケットスニファーとエンジニアのデバッグ実装の利益のために、複合要求のコンテンツを要約するために使用できます。"
    },
    {
      "indent": 6,
      "text": "Since an error of any type may occur after only a portion of the operations have been evaluated, the client must be prepared to recover from any failure. If the source of an NFS4ERR_RESOURCE error was a complex or lengthy set of operations, it is likely that if the number of operations were reduced the server would be able to evaluate them successfully. Therefore, the client is responsible for dealing with this type of complexity in recovery.",
      "ja": "操作の一部のみが評価された後に任意のタイプのエラーが発生する可能性があるため、クライアントは失敗から回復するために準備する必要があります。NFS4err_Resourceエラーのソースが複雑または長い操作セットである場合、操作の数が削減された場合、サーバーはそれらを正常に評価できる可能性があります。したがって、クライアントは、このタイプの複雑さに対処する責任があります。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "All errors defined in the protocol",
      "ja": "プロトコルで定義されているすべてのエラー"
    },
    {
      "indent": 0,
      "text": "14.2.1. Operation 3: ACCESS - Check Access Rights",
      "section_title": true,
      "ja": "14.2.1. 操作3：アクセス - アクセス権を確認します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 9,
      "text": "(cfh), accessreq -> supported, accessrights",
      "ja": "（CFH）、AccessReq->サポート、アクセス権"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 9,
      "text": "const ACCESS4_READ      = 0x00000001;\nconst ACCESS4_LOOKUP    = 0x00000002;\nconst ACCESS4_MODIFY    = 0x00000004;\nconst ACCESS4_EXTEND    = 0x00000008;\nconst ACCESS4_DELETE    = 0x00000010;\nconst ACCESS4_EXECUTE   = 0x00000020;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "struct ACCESS4args {\n        /* CURRENT_FH: object */\n        uint32_t        access;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 9,
      "text": "struct ACCESS4resok {\n        uint32_t        supported;\n        uint32_t        access;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "union ACCESS4res switch (nfsstat4 status) {\n case NFS4_OK:\n         ACCESS4resok   resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "ACCESS determines the access rights that a user, as identified by the credentials in the RPC request, has with respect to the file system object specified by the current filehandle. The client encodes the set of access rights that are to be checked in the bit mask \"access\". The server checks the permissions encoded in the bit mask. If a status of NFS4_OK is returned, two bit masks are included in the response. The first, \"supported\", represents the access rights for which the server can verify reliably. The second, \"access\", represents the access rights available to the user for the filehandle provided. On success, the current filehandle retains its value.",
      "ja": "アクセスは、RPCリクエストの資格情報によって識別されるように、ユーザーが現在のファイルハンドルで指定されたファイルシステムオブジェクトに関して持つアクセス権を決定します。クライアントは、ビットマスク「アクセス」でチェックされるアクセス権のセットをエンコードします。サーバーは、ビットマスクでエンコードされたアクセス許可をチェックします。NFS4_OKのステータスが返された場合、2つのビットマスクが応答に含まれています。最初の「サポート」は、サーバーが確実に検証できるアクセス権を表します。2番目の「アクセス」は、提供されたファイルハンドルに対してユーザーが利用できるアクセス権を表します。成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 6,
      "text": "Note that the supported field will contain only as many values as was originally sent in the arguments. For example, if the client sends an ACCESS operation with only the ACCESS4_READ value set and the server supports this value, the server will return only ACCESS4_READ even if it could have reliably checked other values.",
      "ja": "サポートされているフィールドには、元々議論で送信されたほど多くの値のみが含まれていることに注意してください。たとえば、クライアントがAccess4_Read値のみを使用してアクセス操作を送信し、サーバーがこの値をサポートしている場合、サーバーは他の値を確実にチェックしている場合でもAccess4_Readのみを返します。"
    },
    {
      "indent": 6,
      "text": "The results of this operation are necessarily advisory in nature. A return status of NFS4_OK and the appropriate bit set in the bit mask does not imply that such access will be allowed to the file system object in the future. This is because access rights can be revoked by the server at any time.",
      "ja": "この操作の結果は、必然的に本質的にアドバイザリーです。NFS4_OKのリターンステータスとビットマスクに設定された適切なビットは、そのようなアクセスが将来ファイルシステムオブジェクトに許可されることを意味しません。これは、アクセス権がいつでもサーバーによって取り消される可能性があるためです。"
    },
    {
      "indent": 6,
      "text": "The following access permissions may be requested:",
      "ja": "次のアクセス許可が要求される場合があります。"
    },
    {
      "indent": 3,
      "text": "ACCESS4_READ Read data from file or read a directory.",
      "ja": "Access4_readファイルからデータを読み取るか、ディレクトリを読み取ります。"
    },
    {
      "indent": 3,
      "text": "ACCESS4_LOOKUP Look up a name in a directory (no meaning for non-directory objects).",
      "ja": "Access4_lookupディレクトリ内の名前を検索します（非方向性オブジェクトの意味はありません）。"
    },
    {
      "indent": 3,
      "text": "ACCESS4_MODIFY Rewrite existing file data or modify existing directory entries.",
      "ja": "Access4_Modify既存のファイルデータを書き換えるか、既存のディレクトリエントリを変更します。"
    },
    {
      "indent": 3,
      "text": "ACCESS4_EXTEND Write new data or add directory entries.",
      "ja": "Access4_Extend新しいデータを書き込むか、ディレクトリエントリを追加します。"
    },
    {
      "indent": 3,
      "text": "ACCESS4_DELETE Delete an existing directory entry (no meaning for non-directory objects).",
      "ja": "Access4_Delete既存のディレクトリエントリを削除します（非方向性オブジェクトの意味はありません）。"
    },
    {
      "indent": 3,
      "text": "ACCESS4_EXECUTE Execute file (no meaning for a directory).",
      "ja": "Access4_Execute Executeファイル（ディレクトリには意味がありません）。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "For the NFS version 4 protocol, the use of the ACCESS procedure when opening a regular file is deprecated in favor of using OPEN.",
      "ja": "NFSバージョン4プロトコルの場合、通常のファイルを開くときのアクセス手順の使用は、オープンの使用を支持して非推奨されます。"
    },
    {
      "indent": 6,
      "text": "In general, it is not sufficient for the client to attempt to deduce access permissions by inspecting the uid, gid, and mode fields in the file attributes or by attempting to interpret the contents of the ACL attribute. This is because the server may perform uid or gid mapping or enforce additional access control restrictions. It is also possible that the server may not be in the same ID space as the client. In these cases (and perhaps others), the client can not reliably perform an access check with only current file attributes.",
      "ja": "一般に、ファイル属性内のUID、GID、およびモードフィールドを検査するか、ACL属性の内容を解釈しようとすることにより、クライアントがアクセス許可を推定しようとするだけでは不十分です。これは、サーバーがUIDまたはGIDマッピングを実行したり、追加のアクセス制御制限を強制したりする可能性があるためです。また、サーバーがクライアントと同じIDスペースにない可能性もあります。これらの場合（およびおそらく他の場合）、クライアントは現在のファイル属性のみでアクセスチェックを確実に実行することはできません。"
    },
    {
      "indent": 6,
      "text": "In the NFS version 2 protocol, the only reliable way to determine whether an operation was allowed was to try it and see if it succeeded or failed. Using the ACCESS procedure in the NFS version 4 protocol, the client can ask the server to indicate whether or not one or more classes of operations are permitted. The ACCESS operation is provided to allow clients to check before doing a series of operations which will result in an access failure. The OPEN operation provides a point where the server can verify access to the file object and method to return that information to the client. The ACCESS operation is still useful for directory operations or for use in the case the UNIX API \"access\" is used on the client.",
      "ja": "NFSバージョン2プロトコルでは、操作が許可されたかどうかを判断する唯一の信頼できる方法は、それを試して、それが成功または失敗したかどうかを確認することでした。NFSバージョン4プロトコルのアクセス手順を使用して、クライアントはサーバーに、1つ以上のクラスの操作が許可されているかどうかを示すように依頼できます。アクセス操作が提供され、クライアントが一連の操作を実行する前にチェックできるようにし、アクセスに失敗します。オープン操作は、サーバーがファイルオブジェクトへのアクセスとメソッドへのアクセスを確認して、その情報をクライアントに返すことができるポイントを提供します。アクセス操作は、ディレクトリ操作やUNIX API「アクセス」がクライアントに使用される場合に使用されます。"
    },
    {
      "indent": 6,
      "text": "The information returned by the server in response to an ACCESS call is not permanent. It was correct at the exact time that the server performed the checks, but not necessarily afterwards. The server can revoke access permission at any time.",
      "ja": "アクセスコールに応じてサーバーによって返される情報は永続的ではありません。サーバーがチェックを実行したことは正確な時間に正しかったが、必ずしもその後はそうではなかった。サーバーは、いつでもアクセス許可を取り消すことができます。"
    },
    {
      "indent": 6,
      "text": "The client should use the effective credentials of the user to build the authentication information in the ACCESS request used to determine access rights. It is the effective user and group credentials that are used in subsequent read and write operations.",
      "ja": "クライアントは、ユーザーの効果的な資格情報を使用して、アクセス権を決定するために使用されるアクセス要求に認証情報を作成する必要があります。それは、その後の読み取りおよび書き込み操作で使用される効果的なユーザーとグループの資格情報です。"
    },
    {
      "indent": 6,
      "text": "Many implementations do not directly support the ACCESS4_DELETE permission. Operating systems like UNIX will ignore the ACCESS4_DELETE bit if set on an access request on a non-directory object. In these systems, delete permission on a file is determined by the access permissions on the directory in which the file resides, instead of being determined by the permissions of the file itself. Therefore, the mask returned enumerating which access rights can be determined will have the ACCESS4_DELETE value set to 0. This indicates to the client that the server was unable to check that particular access right. The ACCESS4_DELETE bit in the access mask returned will then be ignored by the client.",
      "ja": "多くの実装は、Access4_Deleteの許可を直接サポートしていません。UNIXのようなオペレーティングシステムは、非方向オブジェクトのアクセス要求に設定されている場合、Access4_Deleteビットを無視します。これらのシステムでは、ファイルのファイルの削除許可は、ファイル自体の権限によって決定されるのではなく、ファイルが存在するディレクトリのアクセス権限によって決定されます。したがって、マスクは、どのアクセス権を決定できるかを列挙して返し、Access4_Delete値を0に設定します。これは、サーバーが特定のアクセス権を確認できなかったことをクライアントに示します。返されたアクセスマスクのAccess4_Deleteビットは、クライアントによって無視されます。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 9,
      "text": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC",
      "ja": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_DELAY NFS4ERR_FHEXPPIRED NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4err_Stal"
    },
    {
      "indent": 0,
      "text": "14.2.2. Operation 4: CLOSE - Close File",
      "section_title": true,
      "ja": "14.2.2. 操作4：閉じる - 閉じるファイル"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 9,
      "text": "(cfh), seqid, stateid -> stateid",
      "ja": "（cfh）、seqid、stateid-> stateid"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 9,
      "text": "struct CLOSE4args {\n        /* CURRENT_FH: object */\n        seqid4          seqid\n        stateid4        stateid;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 9,
      "text": "union CLOSE4res switch (nfsstat4 status) {\n case NFS4_OK:\n         stateid4       stateid;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The CLOSE operation releases share reservations for the file as specified by the current filehandle. The share reservations and other state information released at the server as a result of this CLOSE is only associated with the supplied stateid. The sequence id provides for the correct ordering. State associated with other OPENs is not affected.",
      "ja": "Close操作は、現在のFileHandleで指定されているように、ファイルの共有予約をリリースします。この終了の結果としてサーバーでリリースされたシェア予約およびその他の州情報は、供給されたStateIDにのみ関連付けられています。シーケンスIDは、正しい順序を提供します。他のオープンに関連する状態は影響を受けません。"
    },
    {
      "indent": 6,
      "text": "If record locks are held, the client SHOULD release all locks before issuing a CLOSE. The server MAY free all outstanding locks on CLOSE but some servers may not support the CLOSE of a file that still has record locks held. The server MUST return failure if any locks would exist after the CLOSE.",
      "ja": "レコードロックが保持されている場合、クライアントは終了する前にすべてのロックをリリースする必要があります。サーバーは、すべての未解決のロックを閉じることができますが、一部のサーバーは、まだレコードロックが保持されているファイルの閉鎖をサポートできない場合があります。終了後にロックが存在する場合、サーバーは障害を返す必要があります。"
    },
    {
      "indent": 6,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 9,
      "text": "NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_DELAY NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID",
      "ja": "NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_DELAY NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID"
    },
    {
      "indent": 0,
      "text": "14.2.3. Operation 5: COMMIT - Commit Cached Data",
      "section_title": true,
      "ja": "14.2.3. 操作5：コミット - キャッシュされたデータをコミットします"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 9,
      "text": "(cfh), offset, count -> verifier",
      "ja": "（cfh）、offset、count-> verifier"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 9,
      "text": "struct COMMIT4args {\n        /* CURRENT_FH: file */\n        offset4         offset;\n        count4          count;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 9,
      "text": "struct COMMIT4resok { verifier4 writeverf; };",
      "ja": "struct commit4resok {verifier4 writeverf;};"
    },
    {
      "indent": 9,
      "text": "union COMMIT4res switch (nfsstat4 status) {\n case NFS4_OK:\n         COMMIT4resok   resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The COMMIT operation forces or flushes data to stable storage for the file specified by the current file handle. The flushed data is that which was previously written with a WRITE operation which had the stable field set to UNSTABLE4.",
      "ja": "コミット操作は、現在のファイルハンドルによって指定されたファイルの安定したストレージにデータを強制またはフラッシュします。フラッシュされたデータは、安定したフィールドがunstable4に設定された書き込み操作で以前に記述されたものです。"
    },
    {
      "indent": 6,
      "text": "The offset specifies the position within the file where the flush is to begin. An offset value of 0 (zero) means to flush data starting at the beginning of the file. The count specifies the number of bytes of data to flush. If count is 0 (zero), a flush from offset to the end of the file is done.",
      "ja": "オフセットは、フラッシュが開始されるファイル内の位置を指定します。0（ゼロ）のオフセット値は、ファイルの先頭から始まるデータをフラッシュすることを意味します。カウントは、フラッシュするデータのバイト数を指定します。カウントが0（ゼロ）の場合、ファイルのオフセットから最後までフラッシュが完了します。"
    },
    {
      "indent": 6,
      "text": "The server returns a write verifier upon successful completion of the COMMIT. The write verifier is used by the client to determine if the server has restarted or rebooted between the initial WRITE(s) and the COMMIT. The client does this by comparing the write verifier returned from the initial writes and the verifier returned by the COMMIT procedure. The server must vary the value of the write verifier at each server event or instantiation that may lead to a loss of uncommitted data. Most commonly this occurs when the server is rebooted; however, other events at the server may result in uncommitted data loss as well.",
      "ja": "サーバーは、コミットが正常に完了すると、書き込み検証者を返します。Write Verifierは、クライアントがサーバーが最初の書き込みとコミットの間で再起動または再起動したかどうかを判断するために使用されます。クライアントは、最初の書き込みから返された書き込み検証と、コミットプロシージャによって返される検証者を比較することにより、これを行います。サーバーは、各サーバーイベントでの書き込み検証者の値またはインスタンス化されている必要があるため、コミットされていないデータが失われる可能性があります。最も一般的に、これはサーバーが再起動されたときに発生します。ただし、サーバーでの他のイベントでは、コミットされていないデータ損失も発生する可能性があります。"
    },
    {
      "indent": 6,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "The COMMIT procedure is similar in operation and semantics to the POSIX fsync(2) system call that synchronizes a file's state with the disk (file data and metadata is flushed to disk or stable storage). COMMIT performs the same operation for a client, flushing any unsynchronized data and metadata on the server to the server's disk or stable storage for the specified file. Like fsync(2), it may be that there is some modified data or no modified data to synchronize. The data may have been synchronized by the server's normal periodic buffer synchronization activity. COMMIT should return NFS4_OK, unless there has been an unexpected error.",
      "ja": "コミットプロシージャは動作が類似しており、SemanticsはPOSIX FSYNC（2）システムコールで、ファイルの状態をディスクと同期させます（ファイルデータとメタデータはディスクまたは安定したストレージに洗い流されます）。コミットは、クライアントに対して同じ操作を実行し、サーバー上の非シネ型データとメタデータをサーバーのディスクまたは指定されたファイルの安定したストレージにフラッシュします。FSYNC（2）と同様に、同期するためにいくつかの変更されたデータがあるか、変更されたデータがない可能性があります。データは、サーバーの通常の定期的なバッファー同期アクティビティによって同期されている可能性があります。予期しないエラーがない限り、コミットはNFS4_OKを返す必要があります。"
    },
    {
      "indent": 6,
      "text": "COMMIT differs from fsync(2) in that it is possible for the client to flush a range of the file (most likely triggered by a buffer-reclamation scheme on the client before file has been completely written).",
      "ja": "コミットはFSYNC（2）とは異なります。これは、クライアントがファイルの範囲をフラッシュできる可能性があるからです（ファイルが完全に記述される前に、クライアントのバッファリトラックスキームによってトリガーされる可能性が最も高い）。"
    },
    {
      "indent": 6,
      "text": "The server implementation of COMMIT is reasonably simple. If the server receives a full file COMMIT request, that is starting at offset 0 and count 0, it should do the equivalent of fsync()'ing the file. Otherwise, it should arrange to have the cached data in the range specified by offset and count to be flushed to stable storage. In both cases, any metadata associated with the file must be flushed to stable storage before returning. It is not an error for there to be nothing to flush on the server. This means that the data and metadata that needed to be flushed have already been flushed or lost during the last server failure.",
      "ja": "コミットのサーバー実装はかなり簡単です。サーバーがフルファイルのコミット要求を受信した場合、オフセット0とカウント0から開始する場合、ファイルをfifsync（） '' 'in fileに相当する必要があります。それ以外の場合は、オフセットで指定され、カウントされる範囲内のキャッシュデータを安定したストレージにフラッシュするように手配する必要があります。どちらの場合も、ファイルに関連付けられているメタデータは、戻る前に安定したストレージにフラッシュする必要があります。サーバーにフラッシュすることは何もないため、エラーではありません。これは、フラッシュする必要があるデータとメタデータが、最後のサーバーの障害中にすでにフラッシュまたは失われていることを意味します。"
    },
    {
      "indent": 6,
      "text": "The client implementation of COMMIT is a little more complex. There are two reasons for wanting to commit a client buffer to stable storage. The first is that the client wants to reuse a buffer. In this case, the offset and count of the buffer are sent to the server in the COMMIT request. The server then flushes any cached data based on the offset and count, and flushes any metadata associated with the file. It then returns the status of the flush and the write verifier. The other reason for the client to generate a COMMIT is for a full file flush, such as may be done at close. In this case, the client would gather all of the buffers for this file that contain uncommitted data, do the COMMIT operation with an offset of 0 and count of 0, and then free all of those buffers. Any other dirty buffers would be sent to the server in the normal fashion.",
      "ja": "Commitのクライアントの実装はもう少し複雑です。クライアントバッファーを安定したストレージにコミットしたい理由は2つあります。1つ目は、クライアントがバッファーを再利用したいということです。この場合、バッファのオフセットとカウントがコミット要求でサーバーに送信されます。サーバーは、オフセットに基づいてキャッシュされたデータをフラッシュし、カウントし、ファイルに関連付けられたメタデータをフラッシュします。次に、フラッシュのステータスと書き込み検証者を返します。クライアントがコミットを生成するもう1つの理由は、近くで行われるような完全なファイルフラッシュのためです。この場合、クライアントは、コミットされていないデータを含むこのファイルのすべてのバッファーを収集し、0のオフセットと0のオフセットでコミット操作を行い、それらのすべてのバッファーを解放します。他の汚れたバッファーは、通常の方法でサーバーに送信されます。"
    },
    {
      "indent": 6,
      "text": "After a buffer is written by the client with the stable parameter set to UNSTABLE4, the buffer must be considered as modified by the client until the buffer has either been flushed via a COMMIT operation or written via a WRITE operation with stable parameter set to FILE_SYNC4 or DATA_SYNC4. This is done to prevent the buffer from being freed and reused before the data can be flushed to stable storage on the server.",
      "ja": "安定したパラメーターをunstable4に設定した安定したパラメーターを使用してクライアントによってバッファーが記述された後、バッファがコミット操作を介してフラッシュされるか、stable file_sync4に設定された安定パラメーターを使用して書き込み操作を介して記述されるまで、バッファーをクライアントが変更すると見なす必要があります。data_sync4。これは、データをサーバー上の安定したストレージにフラッシュする前に、バッファーが解放され、再利用されるのを防ぐために行われます。"
    },
    {
      "indent": 6,
      "text": "When a response is returned from either a WRITE or a COMMIT operation and it contains a write verifier that is different than previously returned by the server, the client will need to retransmit all of the buffers containing uncommitted cached data to the server. How this is to be done is up to the implementor. If there is only one buffer of interest, then it should probably be sent back over in a WRITE request with the appropriate stable parameter. If there is more than one buffer, it might be worthwhile retransmitting all of the buffers in WRITE requests with the stable parameter set to UNSTABLE4 and then retransmitting the COMMIT operation to flush all of the data on the server to stable storage. The timing of these retransmissions is left to the implementor.",
      "ja": "書き込み操作またはコミット操作のいずれかから応答が返され、サーバーによって以前に返されたものとは異なる書き込み検証剤が含まれている場合、クライアントは、コミットされていないキャッシュデータを含むすべてのバッファーをサーバーに再送信する必要があります。これがどのように行われるかは、実装者次第です。関心のあるバッファーが1つしかない場合は、おそらく適切な安定したパラメーターを使用して書き込みリクエストで送り返す必要があります。複数のバッファーがある場合、stableパラメーターをunstable4に設定して、書き込み要求のすべてのバッファーを再送信する価値があるかもしれません。その後、サーバー上のすべてのデータを安定したストレージにフラッシュするためのコミット操作を再送信します。これらの再送信のタイミングは、実装者に任されています。"
    },
    {
      "indent": 6,
      "text": "The above description applies to page-cache-based systems as well as buffer-cache-based systems. In those systems, the virtual memory system will need to be modified instead of the buffer cache.",
      "ja": "上記の説明は、バッファキャッシュベースのシステムだけでなく、ページキャッシュベースのシステムにも適用されます。これらのシステムでは、バッファキャッシュの代わりに仮想メモリシステムを変更する必要があります。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 9,
      "text": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_LOCKED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC",
      "ja": "nfs4err_acces nfs4err_badhandle nfs4err_fhexpired nfs4err_io nfs4err_isdir nfs4err_locked nfs4err_moved nfs4err_nofilehandle nfs4err_resource nfs4err_rofs nfs4erferfault nfsefaust"
    },
    {
      "indent": 0,
      "text": "14.2.4. Operation 6: CREATE - Create a Non-Regular File Object",
      "section_title": true,
      "ja": "14.2.4. 操作6：作成 - 非正規ファイルオブジェクトを作成する"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 9,
      "text": "(cfh), name, type -> (cfh), change_info",
      "ja": "（cfh）、name、type->（cfh）、change_info"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 9,
      "text": "union createtype4 switch (nfs_ftype4 type) {\n case NF4LNK:\n         linktext4      linkdata;\n case NF4BLK:\n case NF4CHR:\n         specdata4      devdata;\n case NF4SOCK:\n case NF4FIFO:\n case NF4DIR:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "struct CREATE4args {\n        /* CURRENT_FH: directory for creation */\n        component4      objname;\n        createtype4     objtype;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 9,
      "text": "struct CREATE4resok { change_info4 cinfo; };",
      "ja": "struct create4resok {change_info4 cinfo;};"
    },
    {
      "indent": 9,
      "text": "union CREATE4res switch (nfsstat4 status) {\n case NFS4_OK:\n         CREATE4resok resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The CREATE operation creates a non-regular file object in a directory with a given name. The OPEN procedure MUST be used to create a regular file.",
      "ja": "作成操作は、特定の名前のディレクトリに非正規ファイルオブジェクトを作成します。オープン手順を使用して、通常のファイルを作成する必要があります。"
    },
    {
      "indent": 6,
      "text": "The objname specifies the name for the new object. If the objname has a length of 0 (zero), the error NFS4ERR_INVAL will be returned. The objtype determines the type of object to be created: directory, symlink, etc.",
      "ja": "objnameは、新しいオブジェクトの名前を指定します。objnameの長さは0（ゼロ）の場合、nfs4err_invalのエラーが返されます。OBJTYPEは、作成するオブジェクトのタイプを決定します：ディレクトリ、Symlinkなど。"
    },
    {
      "indent": 6,
      "text": "If an object of the same name already exists in the directory, the server will return the error NFS4ERR_EXIST.",
      "ja": "同じ名前のオブジェクトがディレクトリに既に存在する場合、サーバーはエラーnfs4err_existを返します。"
    },
    {
      "indent": 6,
      "text": "For the directory where the new file object was created, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the file object creation.",
      "ja": "新しいファイルオブジェクトが作成されたディレクトリの場合、サーバーはCINFOでChange_Info4情報を返します。Change_info4 structの原子フィールドを使用すると、サーバーは、ファイルオブジェクトの作成に関して、前後の変更属性が原子的に取得されたかどうかを示します。"
    },
    {
      "indent": 6,
      "text": "If the objname has a length of 0 (zero), or if objname does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.",
      "ja": "OBJNAMEの長さは0（ゼロ）の場合、またはOBJNAMEがUTF-8の定義に従わない場合、エラーNFS4err_Invalが返されます。"
    },
    {
      "indent": 6,
      "text": "The current filehandle is replaced by that of the new object.",
      "ja": "現在のファイルハンドルは、新しいオブジェクトのファイルハンドルに置き換えられます。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "If the client desires to set attribute values after the create, a SETATTR operation can be added to the COMPOUND request so that the appropriate attributes will be set.",
      "ja": "クライアントが作成後に属性値を設定することを希望する場合、適切な属性が設定されるように、SetatTR操作を複合要求に追加できます。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 9,
      "text": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_BADTYPE NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC",
      "ja": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_BADTYPE NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_FHEXPPIRED NFS4ERR_INVER_IO NFS4ERR_MOVED NFS4ERR_NYTOULONG NFS4ERR_NFS4IRFILLINEBSILILINELILINELILINELINELINEFILLINEBSLEXLEXEL_NFS4ERR_NOPRINEBSILENFSLEXLED4ERREN err_notsupp nfs4err_resource nfs4err_rofs nfs4err_serverfault nfs4err_stale nfs4err_wrongsec"
    },
    {
      "indent": 0,
      "text": "14.2.5. Operation 7: DELEGPURGE - Purge Delegations Awaiting Recovery",
      "section_title": true,
      "ja": "14.2.5. 操作7：Delegpurge-回復を待っているパージ代表団"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 9,
      "text": "clientid ->",
      "ja": "clientid->"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 8,
      "text": " struct DELEGPURGE4args { clientid4 clientid; };",
      "ja": "struct delegpurge4args {clientId4 clientId;};"
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 9,
      "text": "struct DELEGPURGE4res { nfsstat4 status; };",
      "ja": "struct delegpurge4res {nfsstat4 status;};"
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "Purges all of the delegations awaiting recovery for a given client. This is useful for clients which do not commit delegation information to stable storage to indicate that conflicting requests need not be delayed by the server awaiting recovery of delegation information.",
      "ja": "特定のクライアントの回復を待っているすべての代表団をパージします。これは、委任情報の回復を待っているサーバーが競合するリクエストを遅らせる必要がないことを示すために、委任情報を安定したストレージにコミットしないクライアントに役立ちます。"
    },
    {
      "indent": 6,
      "text": "This operation should be used by clients that record delegation information on stable storage on the client. In this case, DELEGPURGE should be issued immediately after doing delegation recovery on all delegations know to the client. Doing so will notify the server that no additional delegations for the client will be recovered allowing it to free resources, and avoid delaying other clients who make requests that conflict with the unrecovered delegations. The set of delegations known to the server and the client may be different. The reason for this is that a client may fail after making a request which resulted in delegation but before it received the results and committed them to the client's stable storage.",
      "ja": "この操作は、クライアントの安定したストレージに関する委任情報を記録するクライアントが使用する必要があります。この場合、Delegpurgeは、クライアントに知っているすべての代表団で代表団の回復を行った直後に発行されるべきです。そうすることで、クライアントの追加の代表団が回復されないことをサーバーに通知し、リソースを解放することができ、反復されていない代表団との競合を要求する他のクライアントが遅れないようにします。サーバーとクライアントに知られている代表団のセットは異なる場合があります。その理由は、クライアントがリクエストを行った後に失敗する可能性があり、その結果、委任が行われたが、結果を受け取ってクライアントの安定したストレージにコミットする前に。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE_CLIENTID",
      "ja": "NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE_CLIENTID"
    },
    {
      "indent": 0,
      "text": "14.2.6. Operation 8: DELEGRETURN - Return Delegation",
      "section_title": true,
      "ja": "14.2.6. オペレーション8：Delegreturn-代表団を返します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 9,
      "text": "stateid ->",
      "ja": "STATEID->"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 9,
      "text": "struct DELEGRETURN4args { stateid4 stateid; };",
      "ja": "struct delegreturn4args {stateid4 stateid;};"
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 9,
      "text": "struct DELEGRETURN4res { nfsstat4 status; };",
      "ja": "struct delegreturn4res {nfsstat4 status;};"
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "Returns the delegation represented by the given stateid.",
      "ja": "与えられたSTATEIDが代表する代表団を返します。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 9,
      "text": "NFS4ERR_BAD_STATEID NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE_STATEID",
      "ja": "NFS4ERR_BAD_STATEID NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE_STATEID"
    },
    {
      "indent": 0,
      "text": "14.2.7. Operation 9: GETATTR - Get Attributes",
      "section_title": true,
      "ja": "14.2.7. 操作9：getattr-属性を取得します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 9,
      "text": "(cfh), attrbits -> attrbits, attrvals",
      "ja": "（cfh）、属性 - >アトリビット、属性"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 9,
      "text": "struct GETATTR4args {\n        /* CURRENT_FH: directory or file */\n        bitmap4         attr_request;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 9,
      "text": "struct GETATTR4resok { fattr4 obj_attributes; };",
      "ja": "struct getattr4resok {fattr4 obj_attributes;};"
    },
    {
      "indent": 9,
      "text": "union GETATTR4res switch (nfsstat4 status) {\n case NFS4_OK:\n         GETATTR4resok  resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The GETATTR operation will obtain attributes for the file system object specified by the current filehandle. The client sets a bit in the bitmap argument for each attribute value that it would like the server to return. The server returns an attribute bitmap that indicates the attribute values for which it was able to return, followed by the attribute values ordered lowest attribute number first.",
      "ja": "getattr操作は、現在のファイルハンドルで指定されたファイルシステムオブジェクトの属性を取得します。クライアントは、サーバーを返したいという各属性値のビットマップ引数に少し設定します。サーバーは、返すことができる属性値を示す属性ビットマップを返し、次に最初に最低の属性番号を順序付けた属性値が続きます。"
    },
    {
      "indent": 6,
      "text": "The server must return a value for each attribute that the client requests if the attribute is supported by the server. If the server does not support an attribute or cannot approximate a useful value then it must not return the attribute value and must not set the attribute bit in the result bitmap. The server must return an error if it supports an attribute but cannot obtain its value. In that case no attribute values will be returned.",
      "ja": "サーバーは、属性がサーバーによってサポートされている場合、クライアントが要求する各属性の値を返す必要があります。サーバーが属性をサポートしていないか、有用な値を近似できない場合、属性値を返してはならず、結果ビットマップに属性ビットを設定してはなりません。サーバーは、属性をサポートしているがその値を取得できない場合、エラーを返す必要があります。その場合、属性値は返されません。"
    },
    {
      "indent": 6,
      "text": "All servers must support the mandatory attributes as specified in the section \"File Attributes\".",
      "ja": "すべてのサーバーは、セクション「ファイル属性」で指定されている必須属性をサポートする必要があります。"
    },
    {
      "indent": 6,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 9,
      "text": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC",
      "ja": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_DELAY NFS4ERR_FHEXPPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILERHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4S4ERR_STALE NFS4ERCEC"
    },
    {
      "indent": 0,
      "text": "14.2.8. Operation 10: GETFH - Get Current Filehandle",
      "section_title": true,
      "ja": "14.2.8. 操作10：getFH-現在のファイルハンドルを取得します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 9,
      "text": "(cfh) -> filehandle",
      "ja": "（CFH） - > fileHandle"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 9,
      "text": "/* CURRENT_FH: */\nvoid;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 9,
      "text": "struct GETFH4resok { nfs_fh4 object; };",
      "ja": "struct getfh4resok {nfs_fh4 object;};"
    },
    {
      "indent": 9,
      "text": "union GETFH4res switch (nfsstat4 status) {\n case NFS4_OK:\n        GETFH4resok     resok4;\n default:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 9,
      "text": "This operation returns the current filehandle value.",
      "ja": "この操作は、現在のファイルハンドル値を返します。"
    },
    {
      "indent": 9,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "Operations that change the current filehandle like LOOKUP or CREATE do not automatically return the new filehandle as a result. For instance, if a client needs to lookup a directory entry and obtain its filehandle then the following request is needed.",
      "ja": "現在のファイルハンドルを変更したり、作成したりする操作は、結果として新しいファイルハンドルを自動的に返しません。たとえば、クライアントがディレクトリエントリを検索してファイルハンドルを取得する必要がある場合は、次のリクエストが必要です。"
    },
    {
      "indent": 15,
      "text": "PUTFH (directory filehandle) LOOKUP (entry name) GETFH",
      "ja": "putfh（ディレクトリファイルハンドル）ルックアップ（エントリ名）getfh"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC",
      "ja": "nfs4err_badhandle nfs4err_fhexpired nfs4err_moved nfs4err_nofilehandle nfs4err_resource nfs4err_serverfault nfs4err_stale nfs4err_wrongsec"
    },
    {
      "indent": 0,
      "text": "14.2.9. Operation 11: LINK - Create Link to a File",
      "section_title": true,
      "ja": "14.2.9. 操作11：リンク - ファイルへのリンクを作成する"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "(sfh), (cfh), newname -> (cfh), change_info",
      "ja": "（sfh）、（cfh）、newname->（cfh）、change_info"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "struct LINK4args {\n        /* SAVED_FH: source object */\n        /* CURRENT_FH: target directory */\n        component4      newname;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct LINK4resok { change_info4 cinfo; };",
      "ja": "struct link4resok {change_info4 cinfo;};"
    },
    {
      "indent": 6,
      "text": "union LINK4res switch (nfsstat4 status) {\n case NFS4_OK:\n         LINK4resok resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The LINK operation creates an additional newname for the file represented by the saved filehandle, as set by the SAVEFH operation, in the directory represented by the current filehandle. The existing file and the target directory must reside within the same file system on the server. On success, the current filehandle will continue to be the target directory.",
      "ja": "リンク操作は、保存されたファイルハンドルで表されるファイルの追加のnewNameを作成します。これは、SavefH操作によって設定されており、現在のファイルハンドルで表されるディレクトリにあります。既存のファイルとターゲットディレクトリは、サーバー上の同じファイルシステム内に存在する必要があります。成功すると、現在のファイルハンドルはターゲットディレクトリであり続けます。"
    },
    {
      "indent": 6,
      "text": "For the target directory, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the link creation.",
      "ja": "ターゲットディレクトリの場合、サーバーはCINFOのChange_Info4情報を返します。Change_Info4 structの原子フィールドを使用すると、サーバーは、リンクの作成に関して前後の変更属性が原子的に取得されたかどうかを示します。"
    },
    {
      "indent": 6,
      "text": "If the newname has a length of 0 (zero), or if newname does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.",
      "ja": "NewNameの長さは0（ゼロ）の場合、またはNewNameがUTF-8定義に従わない場合、エラーNFS4err_invalは返されます。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "Changes to any property of the \"hard\" linked files are reflected in all of the linked files. When a link is made to a file, the attributes for the file should have a value for numlinks that is one greater than the value before the LINK operation.",
      "ja": "「ハード」リンクされたファイルの任意のプロパティの変更は、すべてのリンクされたファイルに反映されます。ファイルにリンクが作成された場合、ファイルの属性には、リンク操作前の値よりも大きいnumlinksの値が必要です。"
    },
    {
      "indent": 6,
      "text": "The comments under RENAME regarding object and target residing on the same file system apply here as well. The comments regarding the target name applies as well.",
      "ja": "同じファイルシステムに存在するオブジェクトとターゲットに関する名前を変更しているコメントもここにも適用されます。ターゲット名に関するコメントも適用されます。"
    },
    {
      "indent": 6,
      "text": "Note that symbolic links are created with the CREATE operation.",
      "ja": "シンボリックリンクは、作成操作で作成されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_MLINK NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC NFS4ERR_XDEV",
      "ja": "nfs4err_acces nfs4err_badhandle nfs4err_delay nfs4err_dquot nfs4err_exist nfs4err_fhexppired nfs4err_inval nfs4err_io nfs4err_isdir nfs4err_mlink nfs4erx4nfer_moved nfs4erdookook nfs4er nfs4rie OSPC nfs4err_notdir nfs4err_notsupp nfs4err_resource nfs4err_rofs nfs4err_serverfault nfs4err_stale nfs4err_wrongsec nfs4err_xdev"
    },
    {
      "indent": 0,
      "text": "14.2.10. Operation 12: LOCK - Create Lock",
      "section_title": true,
      "ja": "14.2.10. 操作12：ロック - ロックを作成します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "(cfh) type, seqid, reclaim, stateid, offset, length -> stateid, access",
      "ja": "（cfh）タイプ、seqid、recaid、stateid、offset、length-> stateid、access"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "enum nfs4_lock_type {\n        READ_LT         = 1,\n        WRITE_LT        = 2,\n        READW_LT        = 3,    /* blocking read */\n        WRITEW_LT       = 4     /* blocking write */ };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct LOCK4args {\n        /* CURRENT_FH: file */\n        nfs_lock_type4  locktype;\n        seqid4          seqid;\n        bool            reclaim;\n        stateid4        stateid;\n        offset4         offset;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "length4         length; };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct LOCK4denied {\n        nfs_lockowner4  owner;\n        offset4         offset;\n        length4         length; };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "union LOCK4res switch (nfsstat4 status) {\n case NFS4_OK:\n         stateid4       stateid;\n case NFS4ERR_DENIED:\n         LOCK4denied    denied;\n default:\n         void; };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The LOCK operation requests a record lock for the byte range specified by the offset and length parameters. The lock type is also specified to be one of the nfs4_lock_types. If this is a reclaim request, the reclaim parameter will be TRUE;",
      "ja": "ロック操作は、オフセットと長さのパラメーターで指定されたバイト範囲のレコードロックを要求します。ロックタイプは、NFS4_LOCK_TYPESの1つとして指定されています。これが再生リクエストの場合、Reclaimパラメーターは真です。"
    },
    {
      "indent": 6,
      "text": "Bytes in a file may be locked even if those bytes are not currently allocated to the file. To lock the file from a specific offset through the end-of-file (no matter how long the file actually is) use a length field with all bits set to 1 (one). To lock the entire file, use an offset of 0 (zero) and a length with all bits set to 1. A length of 0 is reserved and should not be used.",
      "ja": "ファイル内のバイトは、これらのバイトが現在ファイルに割り当てられていない場合でもロックされる場合があります。ファイルを特定のオフセットからファイルの終わりまでロックするには（ファイルが実際にどれだけ長くても）、すべてのビットが1（1）に設定された長さフィールドを使用します。ファイル全体をロックするには、0のオフセット（ゼロ）とすべてのビットが1に設定された長さを使用します。"
    },
    {
      "indent": 6,
      "text": "In the case that the lock is denied, the owner, offset, and length of a conflicting lock are returned.",
      "ja": "ロックが拒否された場合、競合するロックの所有者、オフセット、および長さが返されます。"
    },
    {
      "indent": 6,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "If the server is unable to determine the exact offset and length of the conflicting lock, the same offset and length that were provided in the arguments should be returned in the denied results. The File Locking section contains a full description of this and the other file locking operations.",
      "ja": "サーバーが競合するロックの正確なオフセットと長さを決定できない場合、引数で提供されたのと同じオフセットと長さを拒否された結果で返す必要があります。ファイルロックセクションには、これと他のファイルロック操作の完全な説明が含まれています。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_DELAY NFS4ERR_DENIED NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCK_RANGE NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_CLIENTID NFS4ERR_STALE_STATEID NFS4ERR_WRONGSEC",
      "ja": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID NFS4ERR_STATEID NFS4ERR_DELAY NFS4ERR_DENIED NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4RESED_LESED_LESED_LESED_LESE範囲nfs4err_moved nfs4err_nofilehandle nfs4err_old_stateid nfs4err_resource nfs4err_serverfault nfs4err_stale nfs4err_stale_clientid nfs4err_stale_stateid nfs4err_wrongsecec"
    },
    {
      "indent": 0,
      "text": "14.2.11. Operation 13: LOCKT - Test For Lock",
      "section_title": true,
      "ja": "14.2.11. 操作13：Lockt-ロックのテスト"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "(cfh) type, owner, offset, length -> {void, NFS4ERR_DENIED ->\nowner}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "struct LOCKT4args {\n        /* CURRENT_FH: file */\n        nfs_lock_type4  locktype;\n        nfs_lockowner4  owner;\n        offset4         offset;\n        length4         length; };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "union LOCKT4res switch (nfsstat4 status) {\n case NFS4ERR_DENIED:\n         LOCK4denied    denied;\n case NFS4_OK:\n         void;\n default:\n         void; };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The LOCKT operation tests the lock as specified in the arguments. If a conflicting lock exists, the owner, offset, and length of the conflicting lock are returned; if no lock is held, nothing other than NFS4_OK is returned.",
      "ja": "ロック操作は、引数で指定されているロックをテストします。競合するロックが存在する場合、所有者、オフセット、および競合するロックの長さが返されます。ロックが保持されない場合、NFS4_OK以外は返されません。"
    },
    {
      "indent": 6,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "If the server is unable to determine the exact offset and length of the conflicting lock, the same offset and length that were provided in the arguments should be returned in the denied results. The File Locking section contains further discussion of the file locking mechanisms.",
      "ja": "サーバーが競合するロックの正確なオフセットと長さを決定できない場合、引数で提供されたのと同じオフセットと長さを拒否された結果で返す必要があります。ファイルロックセクションには、ファイルロックメカニズムのさらなる説明が含まれています。"
    },
    {
      "indent": 6,
      "text": "LOCKT uses nfs_lockowner4 instead of a stateid4, as LOCK does, to identify the owner so that the client does not have to open the file to test for the existence of a lock.",
      "ja": "Locktは、LockのようにStateID4の代わりにNFS_Lockowner4を使用して、クライアントがロックの存在をテストするためにファイルを開く必要がないように所有者を識別します。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_DELAY NFS4ERR_DENIED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCK_RANGE NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_CLIENTID NFS4ERR_WRONGSEC",
      "ja": "nfs4err_acces nfs4err_badhandle nfs4err_delay nfs4err_denied nfs4err_fhexpired nfs4err_grace nfs4err_inval nfs4err_isdir nfs4err_lease_moved nfs4err_lock_lock_range nfs4err_nf nfdeved nfsed4er s4err_serverfault nfs4err_stale nfs4err_stale_clientid nfs4err_wrongsec"
    },
    {
      "indent": 0,
      "text": "14.2.12. Operation 14: LOCKU - Unlock File",
      "section_title": true,
      "ja": "14.2.12. 操作14：Locku-ファイルのロックを解除します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "(cfh) type, seqid, stateid, offset, length -> stateid",
      "ja": "（cfh）タイプ、seqid、stateid、offset、length-> stateid"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "struct LOCKU4args {\n        /* CURRENT_FH: file */\n        nfs_lock_type4  locktype;\n        seqid4          seqid;\n        stateid4        stateid;\n        offset4         offset;\n        length4         length;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "union LOCKU4res switch (nfsstat4 status) { case NFS4_OK:",
      "ja": "Union Locku4resスイッチ（NFSSTAT4ステータス）{case nfs4_ok："
    },
    {
      "indent": 6,
      "text": "         stateid4       stateid;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The LOCKU operation unlocks the record lock specified by the parameters.",
      "ja": "Locku操作は、パラメーターによって指定されたレコードロックのロックを解除します。"
    },
    {
      "indent": 6,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "The File Locking section contains a full description of this and the other file locking procedures.",
      "ja": "ファイルロックセクションには、これと他のファイルロック手順の完全な説明が含まれています。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_LOCK_RANGE NFS4ERR_LEASE_MOVED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_CLIENTID NFS4ERR_STALE_STATEID",
      "ja": "nfs4err_acces nfs4err_badhandle nfs4err_bad_seqid nfs4err_bad_stateid nfs4err_expired nfs4err_fhexpired nfs4err_grace nfs4err_inval nfs4err_lock_range nfs4er_nfs4nedeved nfderveved nfdeved nfdeved nfdeved nfsed nfsed nfsed nfsed nfsed nfsed nfsed nfsed nfded nfded nfded nfded err_old_stateid nfs4err_resource nfs4err_serverfault nfs4err_stale nfs4err_stale_clientid nfs4err_stale_stateid"
    },
    {
      "indent": 0,
      "text": "14.2.13. Operation 15: LOOKUP - Lookup Filename",
      "section_title": true,
      "ja": "14.2.13. 操作15：ルックアップ - ルックアップファイル名"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "(cfh), filenames -> (cfh)",
      "ja": "（CFH）、ファイル名 - >（CFH）"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "struct LOOKUP4args {\n        /* CURRENT_FH: directory */\n              pathname4       path;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct LOOKUP4res {\n        /* CURRENT_FH: object */\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "This operation LOOKUPs or finds a file system object starting from the directory specified by the current filehandle. LOOKUP evaluates the pathname contained in the array of names and obtains a new current filehandle from the final name. All but the final name in the list must be the names of directories.",
      "ja": "この操作は、現在のファイルハンドルで指定されたディレクトリから開始するファイルシステムオブジェクトを検索または見つけます。Lookupは、名前の配列に含まれるパス名を評価し、最終名から新しい電流ファイルハンドルを取得します。リストの最後の名前を除くすべては、ディレクトリの名前でなければなりません。"
    },
    {
      "indent": 6,
      "text": "If the pathname cannot be evaluated either because a component does not exist or because the client does not have permission to evaluate a component of the path, then an error will be returned and the current filehandle will be unchanged.",
      "ja": "コンポーネントが存在しないか、クライアントがパスのコンポーネントを評価する許可がないためにパス名を評価できない場合、エラーが返され、現在のファイルハンドルが変更されません。"
    },
    {
      "indent": 6,
      "text": "If the path is a zero length array, if any component does not obey the UTF-8 definition, or if any component in the path is of zero length, the error NFS4ERR_INVAL will be returned.",
      "ja": "パスがゼロの長さアレイの場合、コンポーネントがUTF-8定義に従わない場合、またはパス内のコンポーネントが長さがゼロの場合、エラーNFS4err_invalが返されます。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "If the client prefers a partial evaluation of the path then a sequence of LOOKUP operations can be substituted e.g.",
      "ja": "クライアントがパスの部分的な評価を好む場合、一連のルックアップ操作を置き換えることができます。"
    },
    {
      "indent": 15,
      "text": "PUTFH (directory filehandle) LOOKUP \"pub\" \"foo\" \"bar\" GETFH",
      "ja": "putfh（ディレクトリファイルハンドル）ルックアップ \"pub\" \"foo\" \"bar\" getfh"
    },
    {
      "indent": 6,
      "text": "or, if the client wishes to obtain the intermediate filehandles",
      "ja": "または、クライアントが中間ファイルハンドルを取得したい場合"
    },
    {
      "indent": 15,
      "text": "PUTFH (directory filehandle) LOOKUP \"pub\" GETFH LOOKUP \"foo\" GETFH LOOKUP \"bar\" GETFH",
      "ja": "putfh（ディレクトリファイルハンドル）ルックアップ \"pub\" getfh lookup \"foo\" getfh lookup \"bar\" getfh"
    },
    {
      "indent": 6,
      "text": "NFS version 4 servers depart from the semantics of previous NFS versions in allowing LOOKUP requests to cross mountpoints on the server. The client can detect a mountpoint crossing by comparing the fsid attribute of the directory with the fsid attribute of the directory looked up. If the fsids are different then the new directory is a server mountpoint. Unix clients that detect a mountpoint crossing will need to mount the server's filesystem. This needs to be done to maintain the file object identity checking mechanisms common to Unix clients.",
      "ja": "NFSバージョン4サーバーは、サーバー上のマウントポイントを横断するルックアップリクエストを許可するために、以前のNFSバージョンのセマンティクスから離れています。クライアントは、ディレクトリのFSID属性をディレクトリのFSID属性を検索することにより、マウントポイントの交差点を検出できます。FSIDが異なる場合、新しいディレクトリはサーバーマウントポイントです。マウントポイントの交差点を検出するUNIXクライアントは、サーバーのファイルシステムをマウントする必要があります。これは、クライアントに共通するファイルオブジェクトのアイデンティティチェックメカニズムを維持するために行う必要があります。"
    },
    {
      "indent": 6,
      "text": "Servers that limit NFS access to \"shares\" or \"exported\" filesystems should provide a pseudo-filesystem into which the exported filesystems can be integrated, so that clients can browse the server's name space. The clients view of a pseudo filesystem will be limited to paths that lead to exported filesystems.",
      "ja": "「共有」または「エクスポート」ファイルシステムへのNFSアクセスを制限するサーバーは、エクスポートされたファイルシステムを統合できる擬似ファイルシステムを提供して、クライアントがサーバーの名前スペースを閲覧できるようにする必要があります。擬似ファイルシステムのクライアントビューは、エクスポートされたファイルシステムにつながるパスに限定されます。"
    },
    {
      "indent": 6,
      "text": "Note: previous versions of the protocol assigned special semantics to the names \".\" and \"..\". NFS version 4 assigns no special semantics to these names. The LOOKUPP operator must be used to lookup a parent directory.",
      "ja": "注：プロトコルの以前のバージョンは、名前に特別なセマンティクスを割り当てました」。そして \"..\"。NFSバージョン4は、これらの名前に特別なセマンティクスを割り当てません。Lookuppオペレーターを使用して、親ディレクトリを検索する必要があります。"
    },
    {
      "indent": 6,
      "text": "Note that this procedure does not follow symbolic links. The client is responsible for all parsing of filenames including filenames that are modified by symbolic links encountered during the lookup process.",
      "ja": "この手順はシンボリックリンクに従っていないことに注意してください。クライアントは、ルックアッププロセス中に遭遇するシンボリックリンクによって変更されるファイル名を含む、ファイル名のすべての解析について責任を負います。"
    },
    {
      "indent": 6,
      "text": "If the current file handle supplied is not a directory but a symbolic link, the error NFS4ERR_SYMLINK is returned as the error. For all other non-directory file types, the error NFS4ERR_NOTDIR is returned.",
      "ja": "供給されている現在のファイルハンドルがディレクトリではなく、シンボリックリンクである場合、エラーNFS4err_symlinkがエラーとして返されます。他のすべての非ディレクトリファイルタイプについて、エラーnfs4err_notdirが返されます。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_SYMLINK NFS4ERR_WRONGSEC",
      "ja": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_RESFERFURTERFERFURFERFURTE err_symlink nfs4err_wrongsec"
    },
    {
      "indent": 0,
      "text": "14.2.14. Operation 16: LOOKUPP - Lookup Parent Directory",
      "section_title": true,
      "ja": "14.2.14. 操作16：Lookupp -Lookup Parent Directory"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "(cfh) -> (cfh)",
      "ja": "（CFH） - >（CFH）"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "/* CURRENT_FH: object */\nvoid;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct LOOKUPP4res {\n        /* CURRENT_FH: directory */\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The current filehandle is assumed to refer to a regular directory or a named attribute directory. LOOKUPP assigns the filehandle for its parent directory to be the current filehandle. If there is no parent directory an NFS4ERR_ENOENT error must be returned. Therefore, NFS4ERR_ENOENT will be returned by the server when the current filehandle is at the root or top of the server's file tree.",
      "ja": "現在のファイルハンドルは、通常のディレクトリまたは名前付き属性ディレクトリを参照すると想定されています。Lookuppは、親ディレクトリのFileHandleを現在のファイルハンドルに割り当てます。親ディレクトリがない場合は、nfs4err_enoentエラーを返す必要があります。したがって、現在のファイルハンドルがサーバーのファイルツリーのルートまたは上部にある場合、NFS4ERR_ENOENTはサーバーによって返されます。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "As for LOOKUP, LOOKUPP will also cross mountpoints.",
      "ja": "ルックアップに関しては、Lookuppもマウントポイントを横断します。"
    },
    {
      "indent": 6,
      "text": "If the current filehandle is not a directory or named attribute directory, the error NFS4ERR_NOTDIR is returned.",
      "ja": "現在のファイルハンドルがディレクトリまたは名前付き属性ディレクトリでない場合、エラーNFS4err_NotDirが返されます。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC",
      "ja": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOENT NFS4ERREX"
    },
    {
      "indent": 0,
      "text": "14.2.15. Operation 17: NVERIFY - Verify Difference in Attributes",
      "section_title": true,
      "ja": "14.2.15. 操作17：nverify-属性の違いを確認します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "(cfh), fattr -> -",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "struct NVERIFY4args {\n        /* CURRENT_FH: object */\n        fattr4          obj_attributes;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct NVERIFY4res { nfsstat4 status; };",
      "ja": "struct nverify4res {nfsstat4 status;};"
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "This operation is used to prefix a sequence of operations to be performed if one or more attributes have changed on some filesystem object. If all the attributes match then the error NFS4ERR_SAME must be returned.",
      "ja": "この操作は、一部のファイルシステムオブジェクトで1つ以上の属性が変更された場合に実行される一連の操作のプレフィックを実行するために使用されます。すべての属性が一致する場合、エラーnfs4err_sameを返す必要があります。"
    },
    {
      "indent": 6,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "This operation is useful as a cache validation operator. If the object to which the attributes belong has changed then the following operations may obtain new data associated with that object. For instance, to check if a file has been changed and obtain new data if it has:",
      "ja": "この操作は、キャッシュ検証オペレーターとして役立ちます。属性が属するオブジェクトが変更された場合、次の操作はそのオブジェクトに関連付けられた新しいデータを取得できます。たとえば、ファイルが変更されているかどうかを確認し、次の場合に新しいデータを取得するには。"
    },
    {
      "indent": 15,
      "text": "PUTFH (public) LOOKUP \"pub\" \"foo\" \"bar\" NVERIFY attrbits attrs READ 0 32767",
      "ja": "putfh（public）lookup \"pub\" \"foo\" \"bar\" nverify attrbits attrs read 0 32767"
    },
    {
      "indent": 6,
      "text": "In the case that a recommended attribute is specified in the NVERIFY operation and the server does not support that attribute for the file system object, the error NFS4ERR_NOTSUPP is returned to the client.",
      "ja": "推奨属性がnverify操作で指定されており、サーバーがファイルシステムオブジェクトのその属性をサポートしていない場合、エラーNFS4err_Notsuppはクライアントに返されます。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_SAME NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC",
      "ja": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_DELAY NFS4ERR_FHEXPPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHHANDLE NFS4ERR_NOTSUPP NFS4ERR_RESOURCEORCEORCEORCEORCEORCEORCEORCERCEORCERCERCERCERCERCERCERCERCERCERCE間違い"
    },
    {
      "indent": 0,
      "text": "14.2.16. Operation 18: OPEN - Open a Regular File",
      "section_title": true,
      "ja": "14.2.16. 操作18：開く - 通常のファイルを開きます"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 2,
      "text": "(cfh), claim, openhow, owner, seqid, access, deny -> (cfh), stateid, cinfo, rflags, open_confirm, delegation",
      "ja": "（CFH）、クレーム、openhow、所有者、seqid、アクセス、拒否 - >（cfh）、Stateid、cinfo、rflags、open_confirm、委任"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 2,
      "text": "struct OPEN4args {\n        open_claim4     claim;\n        openflag4       openhow;\n        nfs_lockowner4  owner;\n        seqid4          seqid;\n        uint32_t        share_access;\n        uint32_t        share_deny;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "enum createmode4 { UNCHECKED4 = 0, GUARDED4 = 1, EXCLUSIVE4 = 2 };",
      "ja": "enum createMode4 {unchecked4 = 0、guarded4 = 1、exclusive4 = 2};"
    },
    {
      "indent": 2,
      "text": "union createhow4 switch (createmode4 mode) {\n case UNCHECKED4:\n case GUARDED4:\n         fattr4         createattrs;\n case EXCLUSIVE4:\n         verifier4      createverf;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "enum opentype4 { OPEN4_NOCREATE = 0, OPEN4_CREATE = 1 };",
      "ja": "enum opentype4 {open4_nocreate = 0、open4_create = 1};"
    },
    {
      "indent": 2,
      "text": "union openflag4 switch (opentype4 opentype) {\n case OPEN4_CREATE:\n         createhow4     how;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "/* Next definitions used for OPEN delegation */\nenum limit_by4 {\n        NFS_LIMIT_SIZE          = 1,\n        NFS_LIMIT_BLOCKS        = 2\n        /* others as needed */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "struct nfs_modified_limit4 {\n        uint32_t        num_blocks;\n        uint32_t        bytes_per_block;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "union nfs_space_limit4 switch (limit_by4 limitby) {\n /* limit specified as file size */\n case NFS_LIMIT_SIZE:\n         uint64_t               filesize;\n /* limit specified by number of blocks */\n case NFS_LIMIT_BLOCKS:\n         nfs_modified_limit4    mod_blocks;\n} ;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "enum open_delegation_type4 { OPEN_DELEGATE_NONE = 0, OPEN_DELEGATE_READ = 1, OPEN_DELEGATE_WRITE = 2 };",
      "ja": "enum open_delegation_type4 {open_delegate_none = 0、open_delegate_read = 1、open_delegate_write = 2};"
    },
    {
      "indent": 2,
      "text": "enum open_claim_type4 { CLAIM_NULL = 0, CLAIM_PREVIOUS = 1, CLAIM_DELEGATE_CUR = 2, CLAIM_DELEGATE_PREV = 3 };",
      "ja": "enum open_claim_type4 {rack_null = 0、rack_previous = 1、rack_delegate_cur = 2、rack_delegate_prev = 3};"
    },
    {
      "indent": 2,
      "text": "struct open_claim_delegate_cur4 { pathname4 file;",
      "ja": "struct open_claim_delegate_cur4 {pathname4 file;"
    },
    {
      "indent": 2,
      "text": " stateid4 delegate_stateid; };",
      "ja": "StateId4 Delegate_stateId;};"
    },
    {
      "indent": 2,
      "text": "union open_claim4 switch (open_claim_type4 claim) {\n /*\n  * No special rights to file. Ordinary OPEN of the specified file.\n  */\n case CLAIM_NULL:\n         /* CURRENT_FH: directory */\n         pathname4      file;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Right to the file established by an open previous to server\n * reboot.  File identified by filehandle obtained at that time\n * rather than by name.\n */\ncase CLAIM_PREVIOUS:\n        /* CURRENT_FH: file being reclaimed */\n        uint32_t        delegate_type;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Right to file based on a delegation granted by the server.\n * File is specified by name.\n */\ncase CLAIM_DELEGATE_CUR:\n        /* CURRENT_FH: directory */\n        open_claim_delegate_cur4       delegate_cur_info;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": " /* Right to file based on a delegation granted to a previous boot\n  * instance of the client.  File is specified by name.\n  */\n case CLAIM_DELEGATE_PREV:\n         /* CURRENT_FH: directory */\n         pathname4      file_delegate_prev;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 2,
      "text": "struct open_read_delegation4 {\n        stateid4        stateid;        /* Stateid for delegation*/\n        bool            recall;         /* Pre-recalled flag for\n                                           delegations obtained\n                                           by reclaim\n                                           (CLAIM_PREVIOUS) */\n        nfsace4         permissions;    /* Defines users who don't\n                                           need an ACCESS call to\n                                           open for read */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "struct open_write_delegation4 {\n        stateid4        stateid;        /* Stateid for delegation*/\n        bool            recall;         /* Pre-recalled flag for\n                                           delegations obtained\n                                           by reclaim\n                                           (CLAIM_PREVIOUS) */\n        nfs_space_limit4 space_limit;   /* Defines condition that\n                                           the client must check to\n                                           determine whether the\n                                           file needs to be flushed\n                                           to the server on close.\n                                           */\n        nfsace4         permissions;    /* Defines users who don't\n                                           need an ACCESS call as\n                                           part of a delegated\n                                           open. */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "union open_delegation4\nswitch (open_delegation_type4 delegation_type) {\n        case OPEN_DELEGATE_NONE:\n                void;\n        case OPEN_DELEGATE_READ:\n                open_read_delegation4 read;\n        case OPEN_DELEGATE_WRITE:\n                open_write_delegation4 write;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "const OPEN4_RESULT_MLOCK        = 0x00000001;\nconst OPEN4_RESULT_CONFIRM= 0x00000002;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "struct OPEN4resok {\n        stateid4        stateid;        /* Stateid for open */\n        change_info4    cinfo;          /* Directory Change Info */\n        uint32_t        rflags;         /* Result flags */\n        verifier4       open_confirm;   /* OPEN_CONFIRM verifier */\n        open_delegation4 delegation;    /* Info on any open\n                                           delegation */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "union OPEN4res switch (nfsstat4 status) {\n case NFS4_OK:\n        /* CURRENT_FH: opened file */\n        OPEN4resok      resok4;\n default:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "WARNING TO CLIENT IMPLEMENTORS",
      "ja": "クライアントの実装者への警告"
    },
    {
      "indent": 6,
      "text": "OPEN resembles LOOKUP in that it generates a filehandle for the client to use. Unlike LOOKUP though, OPEN creates server state on the filehandle. In normal circumstances, the client can only release this state with a CLOSE operation. CLOSE uses the current filehandle to determine which file to close. Therefore the client MUST follow every OPEN operation with a GETFH operation in the same COMPOUND procedure. This will supply the client with the filehandle such that CLOSE can be used appropriately.",
      "ja": "オープンは、クライアントが使用するファイルハンドルを生成するという点で、検索に似ています。ただし、ルックアップとは異なり、Openはファイルハンドルにサーバー状態を作成します。通常の状況では、クライアントは緊密な操作でこの状態のみをリリースできます。Closeは、現在のFileHandleを使用して、閉じるファイルを決定します。したがって、クライアントは、同じ複合手順でGETFH操作ですべてのオープン操作に従う必要があります。これにより、クライアントにFileHandleが供給されるため、閉じることができます。"
    },
    {
      "indent": 6,
      "text": "Simply waiting for the lease on the file to expire is insufficient because the server may maintain the state indefinitely as long as another client does not attempt to make a conflicting access to the same file.",
      "ja": "ファイルのリースが期限切れになるのを待つだけでは不十分です。なぜなら、他のクライアントが同じファイルに矛盾するアクセスを試みない限り、サーバーが無期限に状態を維持する可能性があるためです。"
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The OPEN operation creates and/or opens a regular file in a directory with the provided name. If the file does not exist at the server and creation is desired, specification of the method of creation is provided by the openhow parameter. The client has the choice of three creation methods: UNCHECKED, GUARDED, or EXCLUSIVE.",
      "ja": "オープン操作は、指定された名前のあるディレクトリ内に通常のファイルを作成および/または開きます。ファイルがサーバーに存在しない場合、作成が必要な場合、作成方法の仕様はOpenHowパラメーターによって提供されます。クライアントには、未チェック、ガード、または排他的な3つの作成方法があります。"
    },
    {
      "indent": 6,
      "text": "UNCHECKED means that the file should be created if a file of that name does not exist and encountering an existing regular file of that name is not an error. For this type of create, createattrs specifies the initial set of attributes for the file. The set of attributes may includes any writable attribute valid for regular files. When an UNCHECKED create encounters an existing file, the attributes specified by createattrs is not used, except that when an object_size of zero is specified, the existing file is truncated. If GUARDED is specified, the server checks for the presence of a duplicate object by name before performing the create. If a duplicate exists, an error of NFS4ERR_EXIST is returned as the status. If the object does not exist, the request is performed as described for UNCHECKED.",
      "ja": "チェックされていないことは、その名前のファイルが存在せず、その名前の既存の通常のファイルに遭遇してもエラーではない場合、ファイルを作成する必要があることを意味します。このタイプの作成については、createAttrsがファイルの属性の初期セットを指定します。属性のセットには、通常のファイルに有効な任意の書き込み属性が含まれる場合があります。チェックされていないCREATEが既存のファイルに遭遇する場合、createAttrsによって指定された属性は使用されません。警備されている場合、サーバーは作成を実行する前に名前で重複オブジェクトの存在をチェックします。複製が存在する場合、nfs4err_existのエラーがステータスとして返されます。オブジェクトが存在しない場合、リクエストは未チェックの場合に記載されているように実行されます。"
    },
    {
      "indent": 6,
      "text": "EXCLUSIVE specifies that the server is to follow exclusive creation semantics, using the verifier to ensure exclusive creation of the target. The server should check for the presence of a duplicate object by name. If the object does not exist, the server creates the object and stores the verifier with the object. If the object does exist and the stored verifier matches the client provided verifier, the server uses the existing object as the newly created object. If the stored verifier does not match, then an error of NFS4ERR_EXIST is returned. No attributes may be provided in this case, since the server may use an attribute of the target object to store the verifier.",
      "ja": "排他的なのは、サーバーが排他的な作成セマンティクスに従い、検証剤を使用してターゲットの排他的な作成を確保することを指定しています。サーバーは、名前で重複するオブジェクトの存在を確認する必要があります。オブジェクトが存在しない場合、サーバーはオブジェクトを作成し、検証器をオブジェクトに保存します。オブジェクトが存在し、保存された検証剤がクライアントに提供された検証器と一致する場合、サーバーは既存のオブジェクトを新しく作成したオブジェクトとして使用します。保存された検証剤が一致しない場合、nfs4err_existのエラーが返されます。この場合、サーバーはターゲットオブジェクトの属性を使用して検証剤を保存できるため、属性は提供されません。"
    },
    {
      "indent": 6,
      "text": "For the target directory, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the link creation.",
      "ja": "ターゲットディレクトリの場合、サーバーはCINFOのChange_Info4情報を返します。Change_Info4 structの原子フィールドを使用すると、サーバーは、リンクの作成に関して前後の変更属性が原子的に取得されたかどうかを示します。"
    },
    {
      "indent": 6,
      "text": "Upon successful creation, the current filehandle is replaced by that of the new object.",
      "ja": "作成が成功すると、現在のファイルハンドルは新しいオブジェクトのファイルハンドルに置き換えられます。"
    },
    {
      "indent": 6,
      "text": "The OPEN procedure provides for DOS SHARE capability with the use of the access and deny fields of the OPEN arguments. The client specifies at OPEN the required access and deny modes. For clients that do not directly support SHAREs (i.e. Unix), the expected deny value is DENY_NONE. In the case that there is a existing SHARE reservation that conflicts with the OPEN request, the server returns the error NFS4ERR_DENIED. For a complete SHARE request, the client must provide values for the owner and seqid fields for the OPEN argument. For additional discussion of SHARE semantics see the section on 'Share Reservations'.",
      "ja": "オープン手順は、オープン引数のアクセスおよび拒否フィールドを使用して、DOS共有機能を提供します。クライアントは、必要なアクセスと拒否モードを開くと指定します。株式を直接サポートしていないクライアント（つまり、UNIX）の場合、予想される拒否値はdeny_noneです。オープンリクエストと競合する既存の共有予約がある場合、サーバーはエラーNFS4err_deniedを返します。完全な共有リクエストのために、クライアントは、オープン引数のために所有者とseqidフィールドに値を提供する必要があります。共有セマンティクスの詳細については、「共有予約」に関するセクションを参照してください。"
    },
    {
      "indent": 6,
      "text": "In the case that the client is recovering state from a server failure, the reclaim field of the OPEN argument is used to signify that the request is meant to reclaim state previously held.",
      "ja": "クライアントがサーバーの障害から状態を回復している場合、オープン引数の回収フィールドは、リクエストが以前に保持された状態を回収することを意図していることを示すために使用されます。"
    },
    {
      "indent": 6,
      "text": "The \"claim\" field of the OPEN argument is used to specify the file to be opened and the state information which the client claims to possess. There are four basic claim types which cover the various situations for an OPEN. They are as follows:",
      "ja": "開かれた引数の「クレーム」フィールドを使用して、開くファイルと、クライアントが所有すると主張する状態情報を指定します。オープンのさまざまな状況をカバーする4つの基本的なクレームタイプがあります。彼らは次のとおりです："
    },
    {
      "indent": 6,
      "text": "CLAIM_NULL For the client, this is a new OPEN request and there is no previous state associate with the file for the client.",
      "ja": "クライアントの請求_nullこれは新しいオープンリクエストであり、クライアントのファイルに以前の州のアソシエイトはありません。"
    },
    {
      "indent": 6,
      "text": "CLAIM_PREVIOUS The client is claiming basic OPEN state for a file that was held previous to a server reboot. Generally used when a server is returning persistent file handles; the client may not have the file name to reclaim the OPEN.",
      "ja": "請求_previousクライアントは、サーバーの再起動の前に保持されていたファイルの基本的なオープン状態を主張しています。通常、サーバーが永続的なファイルハンドルを返しているときに使用されます。クライアントは、オープンを取り戻すためのファイル名を持っていない場合があります。"
    },
    {
      "indent": 6,
      "text": "CLAIM_DELEGATE_CUR The client is claiming a delegation for OPEN as granted by the server. Generally this is done as part of recalling a delegation.",
      "ja": "rack_delegate_curクライアントは、サーバーが付与されているように、オープンの代表団を主張しています。一般的に、これは代表団のリコールの一部として行われます。"
    },
    {
      "indent": 6,
      "text": "CLAIM_DELEGATE_PREV The client is claiming a delegation granted to a previous client instance; used after the client reboots.",
      "ja": "rack_delegate_prevクライアントは、以前のクライアントインスタンスに付与された代表団を主張しています。クライアントの再起動後に使用されます。"
    },
    {
      "indent": 6,
      "text": "For OPEN requests whose claim type is other than CLAIM_PREVIOUS (i.e. requests other than those devoted to reclaiming opens after a server reboot) that reach the server during its grace or lease expiration period, the server returns an error of NFS4ERR_GRACE.",
      "ja": "クレームタイプが請求型_previous以外のオープンリクエスト（つまり、サーバーの再起動後に開くことに専念するリクエスト以外のリクエスト）の場合、そのグレースまたはリースの有効期間中にサーバーに到達するため、サーバーはnfs4err_graceのエラーを返します。"
    },
    {
      "indent": 6,
      "text": "For any OPEN request, the server may return an open delegation, which allows further opens and closes to be handled locally on the client as described in the section Open Delegation. Note that delegation is up to the server to decide. The client should never assume that delegation will or will not be granted in a particular instance. It should always be prepared for either case. A partial exception is the reclaim (CLAIM_PREVIOUS) case, in which a delegation type is claimed. In this case, delegation will always be granted, although the server may specify an immediate recall in the delegation structure.",
      "ja": "オープンリクエストのために、サーバーはオープン代表団を返す場合があります。これにより、セクションOpen Delegationで説明されているように、クライアントでさらに開閉できます。委任は、決定するためのサーバー次第であることに注意してください。クライアントは、特定のインスタンスで代表団が付与されるか、許可されないと仮定してはなりません。どちらの場合も常に準備する必要があります。部分的な例外は、代表団のタイプが請求されている回復（請求_previous）のケースです。この場合、委任は常に付与されますが、サーバーは委任構造の即時リコールを指定する場合があります。"
    },
    {
      "indent": 6,
      "text": "The rflags returned by a successful OPEN allow the server to return information governing how the open file is to be handled. OPEN4_RESULT_MLOCK indicates to the caller that mandatory locking is in effect for this file and the client should act appropriately with regard to data cached on the client. OPEN4_RESULT_CONFIRM indicates that the client MUST execute an OPEN_CONFIRM operation before using the open file.",
      "ja": "成功したオープンによって返されたRFLAGSにより、サーバーはオープンファイルの処理方法を管理する情報を返すことができます。Open4_RESULT_MLOCKは、このファイルに対して必須のロックが有効であり、クライアントにキャッシュされたデータに関してクライアントが適切に行動する必要があることを発信者に示します。Open4_Result_Confirmは、オープンファイルを使用する前にクライアントがOpen_Confirm操作を実行する必要があることを示します。"
    },
    {
      "indent": 6,
      "text": "If the file is a zero length array, if any component does not obey the UTF-8 definition, or if any component in the path is of zero length, the error NFS4ERR_INVAL will be returned.",
      "ja": "ファイルがゼロの長さ配列の場合、コンポーネントがUTF-8定義に従わない場合、またはパスのコンポーネントが長さがゼロの場合、エラーNFS4err_invalが返されます。"
    },
    {
      "indent": 6,
      "text": "When an OPEN is done and the specified lockowner already has the resulting filehandle open, the result is to \"OR\" together the new share and deny status together with the existing status. In this case, only a single CLOSE need be done, even though multiple OPEN's were completed.",
      "ja": "オープンが完了し、指定されたLockownerが結果のファイルハンドルをすでに開いている場合、結果は「新しい共有と既存のステータスと一緒にステータスを拒否する」となります。この場合、複数のオープンが完了したにもかかわらず、1つのクローズを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "The OPEN procedure contains support for EXCLUSIVE create. The mechanism is similar to the support in NFS version 3 [RFC1813]. As in NFS version 3, this mechanism provides reliable exclusive creation. Exclusive create is invoked when the how parameter is EXCLUSIVE. In this case, the client provides a verifier that can reasonably be expected to be unique. A combination of a client identifier, perhaps the client network address, and a unique number generated by the client, perhaps the RPC transaction identifier, may be appropriate.",
      "ja": "オープン手順には、排他的な作成のサポートが含まれています。メカニズムは、NFSバージョン3 [RFC1813]のサポートに似ています。NFSバージョン3と同様に、このメカニズムは信頼できる排他的な作成を提供します。排他的な作成は、パラメーターが排他的である場合に呼び出されます。この場合、クライアントは一意であると合理的に期待できる検証剤を提供します。クライアント識別子、おそらくクライアントネットワークアドレス、およびクライアントによって生成された一意の番号、おそらくRPCトランザクション識別子の組み合わせが適切かもしれません。"
    },
    {
      "indent": 6,
      "text": "If the object does not exist, the server creates the object and stores the verifier in stable storage. For file systems that do not provide a mechanism for the storage of arbitrary file attributes, the server may use one or more elements of the object meta-data to store the verifier. The verifier must be stored in stable storage to prevent erroneous failure on retransmission of the request. It is assumed that an exclusive create is being performed because exclusive semantics are critical to the application. Because of the expected usage, exclusive CREATE does not rely solely on the normally volatile duplicate request cache for storage of the verifier. The duplicate request cache in volatile storage does not survive a crash and may actually flush on a long network partition, opening failure windows. In the UNIX local file system environment, the expected storage location for the verifier on creation is the meta-data (time stamps) of the object. For this reason, an exclusive object create may not include initial attributes because the server would have nowhere to store the verifier.",
      "ja": "オブジェクトが存在しない場合、サーバーはオブジェクトを作成し、検証器を安定したストレージに保存します。任意のファイル属性のストレージのメカニズムを提供しないファイルシステムの場合、サーバーはオブジェクトメタデータの1つ以上の要素を使用して検証器を保存することができます。検証器は、リクエストの再送信時に誤った障害を防ぐために、安定したストレージに保存する必要があります。排他的なセマンティクスがアプリケーションにとって重要であるため、排他的な作成が実行されていると想定されています。予想される使用のため、排他的なCreateは、検証剤の保存のための通常揮発性の重複要求キャッシュのみに依存するものではありません。揮発性ストレージでの重複リクエストキャッシュは、クラッシュに耐えることはなく、実際に長いネットワークパーティションで飛行し、故障ウィンドウを開きます。UNIXローカルファイルシステム環境では、作成に関する検証剤の予想されるストレージ場所は、オブジェクトのメタデータ（タイムスタンプ）です。このため、サーバーに検証剤を保存する場所がないため、排他的なオブジェクト作成には初期属性が含まれない場合があります。"
    },
    {
      "indent": 6,
      "text": "If the server can not support these exclusive create semantics, possibly because of the requirement to commit the verifier to stable storage, it should fail the OPEN request with the error, NFS4ERR_NOTSUPP.",
      "ja": "サーバーがこれらの排他的な作成セマンティクスをサポートできない場合、おそらく検証剤を安定したストレージにコミットする要件のために、エラー、nfs4err_notsuppでオープン要求に失敗するはずです。"
    },
    {
      "indent": 6,
      "text": "During an exclusive CREATE request, if the object already exists, the server reconstructs the object's verifier and compares it with the verifier in the request. If they match, the server treats the request as a success. The request is presumed to be a duplicate of an earlier, successful request for which the reply was lost and that the server duplicate request cache mechanism did not detect. If the verifiers do not match, the request is rejected with the status, NFS4ERR_EXIST.",
      "ja": "排他的な作成リクエスト中、オブジェクトが既に存在する場合、サーバーはオブジェクトの検証者を再構築し、リクエストの検証器と比較します。それらが一致する場合、サーバーはリクエストを成功として扱います。この要求は、返信が失われた以前の成功した要求の複製であり、サーバーの重複要求キャッシュメカニズムが検出されなかったと推定されます。検証剤が一致しない場合、リクエストはステータス、nfs4err_existで拒否されます。"
    },
    {
      "indent": 6,
      "text": "Once the client has performed a successful exclusive create, it must issue a SETATTR to set the correct object attributes. Until it does so, it should not rely upon any of the object attributes, since the server implementation may need to overload object meta-data to store the verifier. The subsequent SETATTR must not occur in the same COMPOUND request as the OPEN. This separation will guarantee that the exclusive create mechanism will continue to function properly in the face of retransmission of the request.",
      "ja": "クライアントが成功した排他的な作成を実行したら、正しいオブジェクト属性を設定するためにSetATTRを発行する必要があります。そうするまで、サーバーの実装は検証者を保存するためにオブジェクトメタデータをオーバーロードする必要がある場合があるため、オブジェクト属性のいずれにも依存してはいけません。その後のSetattrは、Openと同じ複合要求で発生してはなりません。この分離は、リクエストの再送信に直面して排他的な作成メカニズムが適切に機能し続けることを保証します。"
    },
    {
      "indent": 6,
      "text": "Use of the GUARDED attribute does not provide exactly-once semantics. In particular, if a reply is lost and the server does not detect the retransmission of the request, the procedure can fail with NFS4ERR_EXIST, even though the create was performed successfully.",
      "ja": "Guarded属性の使用は、正確なセマンティクスを提供しません。特に、返信が失われ、サーバーがリクエストの再送信を検出しない場合、作成が正常に実行されたとしても、手順はnfs4err_existで失敗する可能性があります。"
    },
    {
      "indent": 6,
      "text": "For SHARE reservations, the client must specify a value for access that is one of READ, WRITE, or BOTH. For deny, the client must specify one of NONE, READ, WRITE, or BOTH. If the client fails to do this, the server must return NFS4ERR_INVAL.",
      "ja": "共有予約のために、クライアントは、読み取り、書き込み、またはその両方の1つであるアクセスの値を指定する必要があります。否定するために、クライアントは、読み取り、書き込み、またはその両方のいずれかを指定する必要があります。クライアントがこれを実行しなかった場合、サーバーはnfs4err_invalを返す必要があります。"
    },
    {
      "indent": 6,
      "text": "If the final component provided to OPEN is a symbolic link, the error NFS4ERR_SYMLINK will be returned to the client. If an intermediate component of the pathname provided to OPEN is a symbolic link, the error NFS4ERR_NOTDIR will be returned to the client.",
      "ja": "開くために提供される最終コンポーネントがシンボリックリンクである場合、エラーNFS4ERR_SYMLINKがクライアントに返されます。開くように提供されるパス名の中間コンポーネントがシンボリックリンクである場合、エラーNFS4err_NotDirがクライアントに返されます。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_ACCES NFS4ERR_BAD_SEQID NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_SHARE_DENIED NFS4ERR_STALE_CLIENTID NFS4ERR_SYMLINK",
      "ja": "NFS4ERR_ACCES NFS4ERR_BAD_SEQID NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_SHARE_DENIED NFS4ERR_STALE_CLIENTID NFS4ERR_SYMLINK"
    },
    {
      "indent": 0,
      "text": "14.2.17. Operation 19: OPENATTR - Open Named Attribute Directory",
      "section_title": true,
      "ja": "14.2.17. 操作19：OpenATTR -OPEN NAMED ATTRUTION DIRECTORY"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "(cfh) -> (cfh)",
      "ja": "（CFH） - >（CFH）"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 3,
      "text": "/* CURRENT_FH: file or directory */\nvoid;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 3,
      "text": "struct OPENATTR4res {\n        /* CURRENT_FH: name attr directory*/\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The OPENATTR operation is used to obtain the filehandle of the named attribute directory associated with the current filehandle. The result of the OPENATTR will be a filehandle to an object of type NF4ATTRDIR. From this filehandle, READDIR and LOOKUP procedures can be used to obtain filehandles for the various named attributes associated with the original file system object. Filehandles returned within the named attribute directory will have a type of NF4NAMEDATTR.",
      "ja": "OpenATTR操作は、現在のFileHandleに関連付けられている名前の属性ディレクトリのファイルハンドルを取得するために使用されます。OpenATTRの結果は、型NF4ATTRDIRのオブジェクトへのファイルハンドルになります。このFileHandleから、ReadDirおよびLookup Proceduresを使用して、元のファイルシステムオブジェクトに関連付けられたさまざまな名前の属性のファイルハンドルを取得できます。名前付き属性ディレクトリ内で返されるファイルハンドルには、nf4namedattrの種類があります。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "If the server does not support named attributes for the current filehandle, an error of NFS4ERR_NOTSUPP will be returned to the client.",
      "ja": "サーバーが現在のファイルハンドルの名前の属性をサポートしていない場合、nfs4err_notsuppのエラーがクライアントに返されます。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC",
      "ja": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_DELAY NFS4ERR_FHEXPPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTSUPPSPERR_RESFERFART NFSERFERFERFARTE _WRONGSEC"
    },
    {
      "indent": 0,
      "text": "14.2.18. Operation 20: OPEN_CONFIRM - Confirm Open",
      "section_title": true,
      "ja": "14.2.18. 操作20：open_confirm-開くことを確認します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "(cfh), seqid, open_confirm-> stateid",
      "ja": "（CFH）、seqid、open_confirm-> stateid"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 3,
      "text": "struct OPEN_CONFIRM4args {\n        /* CURRENT_FH: opened file */\n        seqid4          seqid;\n        verifier4       open_confirm;   /* OPEN_CONFIRM verifier */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 3,
      "text": "struct OPEN_CONFIRM4resok { stateid4 stateid; };",
      "ja": "struct open_confirm4resok {stateid4 stateid;};"
    },
    {
      "indent": 3,
      "text": "union OPEN_CONFIRM4res switch (nfsstat4 status) {\n case NFS4_OK:\n         OPEN_CONFIRM4resok     resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "This operation is used to confirm the sequence id usage for the first time that a nfs_lockowner is used by a client. The OPEN operation returns a opaque confirmation verifier that is then passed to this operation along with the next sequence id for the nfs_lockowner. The sequence id passed to the OPEN_CONFIRM must be 1 (one) greater than the seqid passed to the OPEN operation from which the open_confirm value was obtained. If the server receives an unexpected sequence id with respect to the original open, then the server assumes that the client will not confirm the original OPEN and all state associated with the original OPEN is released by the server.",
      "ja": "この操作は、NFS_Lockownerがクライアントが使用する初めてシーケンスID使用を確認するために使用されます。オープン操作は不透明な確認検証剤を返し、その後、NFS_Lockownerの次のシーケンスIDとともにこの操作に渡されます。open_confirmに渡されたシーケンスIDは、open_confirm値が取得されたオープンオペレーションに渡されたseqidよりも1（1）大きくなければなりません。サーバーが元のオープンに関して予期しないシーケンスIDを受信した場合、サーバーは、クライアントが元のオープンを確認せず、元のオープンに関連付けられているすべての状態がサーバーによってリリースされると想定します。"
    },
    {
      "indent": 6,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "A given client might generate many nfs_lockowner data structures for a given clientid. The client will periodically either dispose of its nfs_lockowners or stop using them for indefinite periods of time. The latter situation is why the NFS version 4 protocol does not have a an explicit operation to exit an nfs_lockowner: such an operation is of no use in that situation. Instead, to avoid unbounded memory use, the server needs to implement a strategy for disposing of nfs_lockowners that have no current lock, open, or delegation state for any files and have not been used recently. The time period used to determine when to dispose of nfs_lockowners is an implementation choice. The time period should certainly be no less than the lease time plus any grace period the server wishes to implement beyond a lease time. The OPEN_CONFIRM operation allows the server to safely dispose of unused nfs_lockowner data structures.",
      "ja": "特定のクライアントは、特定のClientIDの多くのNFS_Lockownerデータ構造を生成する場合があります。クライアントは定期的にNFS_Lockownersを処分するか、無期限の期間使用を停止します。後者の状況は、NFSバージョン4プロトコルにNFS_Lockownerを終了するための明示的な操作がない理由です。そのような操作はその状況では役に立ちません。代わりに、無制限のメモリの使用を避けるために、サーバーは、ファイルの現在のロック、オープン、または委任状態がなく、最近使用されていないNFS_Lockownersを処分するための戦略を実装する必要があります。NFS_Lockownersをいつ処分するかを決定するために使用される期間は、実装の選択肢です。期間は確かにリース時間と、サーバーがリース時間を超えて実装したい恵み期間にほかなります。Open_Confirm操作により、サーバーは未使用のNFS_Lockownerデータ構造を安全に処分できます。"
    },
    {
      "indent": 6,
      "text": "In the case that a client issues an OPEN operation and the server no longer has a record of the nfs_lockowner, the server needs ensure that this is a new OPEN and not a replay or retransmission.",
      "ja": "クライアントがオープン操作を発行し、サーバーがNFS_Lockownerのレコードを持たなくなった場合、サーバーはこれがリプレイや再送信ではなく新しいオープンであることを確認する必要があります。"
    },
    {
      "indent": 6,
      "text": "A lazy server implementation might require confirmation for every nfs_lockowner for which it has no record. However, this is not necessary until the server records the fact that it has disposed of one nfs_lockowner for the given clientid.",
      "ja": "怠zyなサーバーの実装では、記録がないすべてのNFS_Lockownerの確認が必要になる場合があります。ただし、これは、サーバーが指定されたClientIDの1人のNFS_Lockownerを処分したという事実を記録するまでは必要ありません。"
    },
    {
      "indent": 6,
      "text": "The server must hold unconfirmed OPEN state until one of three events occur. First, the client sends an OPEN_CONFIRM request with the appropriate sequence id and confirmation verifier within the lease period. In this case, the OPEN state on the server goes to confirmed, and the nfs_lockowner on the server is fully established.",
      "ja": "サーバーは、3つのイベントのいずれかが発生するまで、未確認のオープン状態を保持する必要があります。まず、クライアントは、リース期間内に適切なシーケンスIDと確認検証者を使用してOpen_Confirmリクエストを送信します。この場合、サーバー上のオープン状態が確認され、サーバー上のNFS_Lockownerが完全に確立されます。"
    },
    {
      "indent": 6,
      "text": "Second, the client sends another OPEN request with a sequence id that is incorrect for the nfs_lockowner (out of sequence). In this case, the server assumes the second OPEN request is valid and the first one is a replay. The server cancels the OPEN state of the first OPEN request, establishes an unconfirmed OPEN state for the second OPEN request, and responds to the second OPEN request with an indication that an OPEN_CONFIRM is needed. The process then repeats itself. While there is a potential for a denial of service attack on the client, it is mitigated if the client and server require the use of a security flavor based on Kerberos V5, LIPKEY, or some other flavor that uses cryptography.",
      "ja": "第二に、クライアントは、NFS_LockOwner（sequenceなし）に間違っているシーケンスIDを使用して別のオープンリクエストを送信します。この場合、サーバーは2番目のオープン要求が有効であり、最初の要求はリプレイです。サーバーは、最初のオープンリクエストのオープン状態をキャンセルし、2番目のオープンリクエストのために未確認のオープン状態を確立し、Open_Confirmが必要であることを示す2番目のオープンリクエストに応答します。その後、プロセスは繰り返されます。クライアントに対するサービス攻撃の拒否の可能性がありますが、クライアントとサーバーが、Kerberos V5、Lipkey、または暗号化を使用する他のフレーバーに基づくセキュリティフレーバーの使用を必要とする場合、緩和されます。"
    },
    {
      "indent": 6,
      "text": "What if the server is in the unconfirmed OPEN state for a given nfs_lockowner, and it receives an operation on the nfs_lockowner that has a stateid but the operation is not OPEN, or it is OPEN_CONFIRM but with the wrong confirmation verifier? Then, even if the seqid is correct, the server returns NFS4ERR_BAD_STATEID, because the server assumes the operation is a replay: if the server has no established OPEN state, then there is no way, for example, a LOCK operation could be valid.",
      "ja": "サーバーが特定のNFS_Lockownerの未確認のオープン状態にあり、STATEIDを持つNFS_Lockownerの操作を受信した場合はどうなりますが、操作はオープンではありません。次に、SEQIDが正しい場合でも、サーバーは操作がリプレイであると想定しているため、サーバーがNFS4ERR_BAD_STATEIDを返します。サーバーに開かれた状態が確立されていない場合、ロック操作は有効である可能性があります。"
    },
    {
      "indent": 6,
      "text": "Third, neither of the two aforementioned events occur for the nfs_lockowner within the lease period. In this case, the OPEN state is cancelled and disposal of the nfs_lockowner can occur.",
      "ja": "第三に、前述の2つのイベントのいずれも、リース期間内にNFS_Lockownerで発生しません。この場合、オープン状態がキャンセルされ、NFS_Lockownerの処分が発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_MOVED NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC",
      "ja": "NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_MOVED NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC"
    },
    {
      "indent": 0,
      "text": "14.2.19. Operation 21: OPEN_DOWNGRADE - Reduce Open File Access",
      "section_title": true,
      "ja": "14.2.19. 操作21：Open_DownGrade-オープンファイルアクセスを削減します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "(cfh), stateid, seqid, access, deny -> stateid",
      "ja": "（cfh）、Stateid、seqid、access、deny-> stateid"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 3,
      "text": "struct OPEN_DOWNGRADE4args {\n        /* CURRENT_FH: opened file */\n        stateid4        stateid;\n        seqid4          seqid;\n        uint32_t        share_access;\n        uint32_t        share_deny;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT struct OPEN_DOWNGRADE4resok { stateid4 stateid; };",
      "ja": "結果struct open_downgrade4resok {stateid4 stateid;};"
    },
    {
      "indent": 3,
      "text": "union OPEN_DOWNGRADE4res switch(nfsstat4 status) {\n case NFS4_OK:\n        OPEN_DOWNGRADE4resok    resok4;\n default:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This operation is used to adjust the access and deny bits for a given open. This is necessary when a given lockowner opens the same file multiple times with different access and deny flags. In this situation, a close of one of the open's may change the appropriate access and deny flags to remove bits associated with open's no longer in effect.",
      "ja": "この操作は、アクセスを調整し、特定のオープンのビットを拒否するために使用されます。これは、特定のLockownerが異なるアクセスとフラグを拒否して同じファイルを複数回開いた場合に必要です。この状況では、オープンの1つのクローズが適切なアクセスを変更し、フラグを拒否して、Openに関連付けられたビットを削除する可能性があります。"
    },
    {
      "indent": 3,
      "text": "The access and deny bits specified in this operation replace the current ones for the specified open file. If either the access or the deny mode specified includes bits not in effect for the open, the error NFS4ERR_INVAL should be returned. Since access and deny bits are subsets of those already granted, it is not possible for this request to be denied because of conflicting share reservations.",
      "ja": "この操作で指定されたアクセスおよび拒否ビットは、指定されたオープンファイルの現在のビットを置き換えます。指定されたアクセスモードまたはdenyモードがオープンに有効になっていないビットが含まれている場合、エラーNFS4err_invalを返す必要があります。アクセスおよび拒否ビットはすでに付与されているもののサブセットであるため、株式の留保が矛盾するため、この要求が拒否されることは不可能です。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID",
      "ja": "NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4REXERRFERFOURFERFOURFURTERFURTERFURTERFERFORFERFERFERFERFERFERFERFERFERFERFERFERXPERDE err_stale_stateid"
    },
    {
      "indent": 0,
      "text": "14.2.20. Operation 22: PUTFH - Set Current Filehandle",
      "section_title": true,
      "ja": "14.2.20. 操作22：putfh-現在のファイルハンドルを設定します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "filehandle -> (cfh)",
      "ja": "filehandle->（cfh）"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "struct PUTFH4args {\n        nfs4_fh         object; };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct PUTFH4res {",
      "ja": "struct putfh4res {"
    },
    {
      "indent": 14,
      "text": "/* CURRENT_FH: */\nnfsstat4        status; };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "Replaces the current filehandle with the filehandle provided as an argument.",
      "ja": "現在のファイルハンドルを、引数として提供されたファイルハンドルに置き換えます。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "Commonly used as the first operator in an NFS request to set the context for following operations.",
      "ja": "NFS要求の最初の演算子として一般的に使用され、次の操作のコンテキストを設定します。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_MOVED NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC",
      "ja": "nfs4err_badhandle nfs4err_fhexpired nfs4err_moved nfs4err_resource nfs4err_serverfault nfs4err_stale nfs4err_wrongsec"
    },
    {
      "indent": 0,
      "text": "14.2.21. Operation 23: PUTPUBFH - Set Public Filehandle",
      "section_title": true,
      "ja": "14.2.21. 操作23：putpubfh-パブリックファイルハンドルを設定します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "- -> (cfh)",
      "ja": "-  - >（CFH）"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "void;",
      "ja": "空所;"
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct PUTPUBFH4res {\n        /* CURRENT_FH: public fh */\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "Replaces the current filehandle with the filehandle that represents the public filehandle of the server's name space. This filehandle may be different from the \"root\" filehandle which may be associated with some other directory on the server.",
      "ja": "現在のファイルハンドルを、サーバーの名前スペースのパブリックファイルハンドルを表すファイルハンドルに置き換えます。このファイルハンドルは、サーバー上の他のディレクトリに関連付けられる「ルート」ファイルハンドルとは異なる場合があります。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "Used as the first operator in an NFS request to set the context for following operations.",
      "ja": "NFSリクエストの最初の演算子として使用され、次の操作のコンテキストを設定します。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_WRONGSEC",
      "ja": "nfs4err_resource nfs4err_serverfault nfs4err_wrongsec"
    },
    {
      "indent": 0,
      "text": "14.2.22. Operation 24: PUTROOTFH - Set Root Filehandle",
      "section_title": true,
      "ja": "14.2.22. 操作24：putrootfh-ルートファイルハンドルを設定します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "- -> (cfh)",
      "ja": "-  - >（CFH）"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "void;",
      "ja": "空所;"
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct PUTROOTFH4res {\n        /* CURRENT_FH: root fh */\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "Replaces the current filehandle with the filehandle that represents the root of the server's name space. From this filehandle a LOOKUP operation can locate any other filehandle on the server. This filehandle may be different from the \"public\" filehandle which may be associated with some other directory on the server.",
      "ja": "現在のファイルハンドルを、サーバーの名前空間のルートを表すファイルハンドルに置き換えます。このファイルハンドルから、ルックアップ操作はサーバー上の他のファイルハンドルを見つけることができます。このファイルハンドルは、サーバー上の他のディレクトリに関連付けられる「パブリック」ファイルハンドルとは異なる場合があります。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "Commonly used as the first operator in an NFS request to set the context for following operations.",
      "ja": "NFS要求の最初の演算子として一般的に使用され、次の操作のコンテキストを設定します。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_WRONGSEC",
      "ja": "nfs4err_resource nfs4err_serverfault nfs4err_wrongsec"
    },
    {
      "indent": 0,
      "text": "14.2.23. Operation 25: READ - Read from File",
      "section_title": true,
      "ja": "14.2.23. 操作25：読み取り - ファイルから読み取ります"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "(cfh), offset, count, stateid -> eof, data",
      "ja": "（cfh）、offset、count、stateid-> eof、data"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "struct READ4args {\n        /* CURRENT_FH: file */\n        stateid4        stateid;\n        offset4         offset;\n        count4          count;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct READ4resok {\n        bool            eof;\n        opaque          data<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "union READ4res switch (nfsstat4 status) {\n case NFS4_OK:\n         READ4resok     resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The READ operation reads data from the regular file identified by the current filehandle.",
      "ja": "読み取り操作は、現在のファイルハンドルによって識別された通常のファイルからデータを読み取ります。"
    },
    {
      "indent": 6,
      "text": "The client provides an offset of where the READ is to start and a count of how many bytes are to be read. An offset of 0 (zero) means to read data starting at the beginning of the file. If offset is greater than or equal to the size of the file, the status, NFS4_OK, is returned with a data length set to 0 (zero) and eof is set to TRUE. The READ is subject to access permissions checking.",
      "ja": "クライアントは、読み取りが始まる場所のオフセットと、読み取るバイト数のカウントを提供します。0（ゼロ）のオフセットは、ファイルの先頭から始まるデータを読み取ることを意味します。オフセットがファイルのサイズ以上である場合、ステータス、NFS4_OKは、データの長さを0（ゼロ）に設定して返され、EOFはtrueに設定されます。読み取りは、アクセス権限チェックの対象となります。"
    },
    {
      "indent": 6,
      "text": "If the client specifies a count value of 0 (zero), the READ succeeds and returns 0 (zero) bytes of data again subject to access permissions checking. The server may choose to return fewer bytes than specified by the client. The client needs to check for this condition and handle the condition appropriately.",
      "ja": "クライアントが0のカウント値（ゼロ）を指定すると、読み取りが成功し、アクセス権限チェックの対象となるデータの0（ゼロ）バイトを返します。サーバーは、クライアントが指定したよりも少ないバイトを返すことを選択できます。クライアントは、この状態を確認し、状態を適切に処理する必要があります。"
    },
    {
      "indent": 6,
      "text": "The stateid value for a READ request represents a value returned from a previous record lock or share reservation request. Used by the server to verify that the associated lock is still valid and to update lease timeouts for the client.",
      "ja": "読み取り要求のStateID値は、以前のレコードロックまたは共有予約リクエストから返された値を表します。サーバーが使用して、関連するロックがまだ有効であることを確認し、クライアントのタイムアウトのリースを更新します。"
    },
    {
      "indent": 6,
      "text": "If the read ended at the end-of-file (formally, in a correctly formed READ request, if offset + count is equal to the size of the file), or the read request extends beyond the size of the file (if offset + count is greater than the size of the file), eof is returned as TRUE; otherwise it is FALSE. A successful READ of an empty file will always return eof as TRUE.",
      "ja": "読み取りがファイルの終わりに終了した場合（正式には、正確に形成された読み取り要求で、オフセットカウントがファイルのサイズに等しい場合）、または読み取り要求がファイルのサイズを超えて拡張されます（オフセットカウントはファイルのサイズよりも大きい）、EOFはTrueとして返されます。それ以外の場合は偽です。空のファイルの成功した読み取りは、常にEOFを真のものとして返します。"
    },
    {
      "indent": 6,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "It is possible for the server to return fewer than count bytes of data. If the server returns less than the count requested and eof set to FALSE, the client should issue another READ to get the remaining data. A server may return less data than requested under several circumstances. The file may have been truncated by another client or perhaps on the server itself, changing the file size from what the requesting client believes to be the case. This would reduce the actual amount of data available to the client. It is possible that the server may back off the transfer size and reduce the read request return. Server resource exhaustion may also occur necessitating a smaller read return.",
      "ja": "サーバーがカウントバイトのデータよりも少ないデータを返すことができます。サーバーが要求されたカウントよりも少なくなり、EOFがfalseに設定されている場合、クライアントは残りのデータを取得するために別の読み取りを発行する必要があります。サーバーは、いくつかの状況で要求されたよりも少ないデータを返す場合があります。ファイルは、別のクライアントまたはおそらくサーバー自体によって切り捨てられている可能性があり、リクエストクライアントがそうであると信じているものからファイルサイズを変更します。これにより、クライアントが利用できる実際のデータの量が減ります。サーバーが転送サイズから戻って、読み取りリクエストリターンを減らすことができる可能性があります。サーバーリソースの疲労も発生する可能性がありますが、読み取りが小さくなる必要があります。"
    },
    {
      "indent": 6,
      "text": "If the file is locked the server will return an NFS4ERR_LOCKED error. Since the lock may be of short duration, the client may choose to retransmit the READ request (with exponential backoff) until the operation succeeds.",
      "ja": "ファイルがロックされている場合、サーバーはnfs4err_lockedエラーを返します。ロックは短い期間である可能性があるため、クライアントは、操作が成功するまで（指数関数的バックオフを使用して）読み取り要求を再送信することを選択できます。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_DELAY NFS4ERR_DENIED NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_LOCKED NFS4ERR_LEASE_MOVED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NXIO NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID NFS4ERR_WRONGSEC",
      "ja": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERRAY NFS4ERR_DENIED NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_LOCKED NFS4IRED_LESED_LESED4ERSED4ERDED4ERDEBED_MEFED_BEDED4ERDED4ERDED4ERSE _NOFILEHANDLE NFS4ERR_NXIO NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID NFS4ERR_WRONGSEC"
    },
    {
      "indent": 0,
      "text": "14.2.24. Operation 26: READDIR - Read Directory",
      "section_title": true,
      "ja": "14.2.24. 操作26：Readdir -Directoryを読み取ります"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "(cfh), cookie, cookieverf, dircount, maxcount, attrbits ->\ncookieverf { cookie, filename, attrbits, attributes }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "struct READDIR4args {\n        /* CURRENT_FH: directory */\n        nfs_cookie4     cookie;\n        verifier4       cookieverf;\n        count4          dircount;\n        count4          maxcount;\n        bitmap4         attr_request;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct entry4 {\n        nfs_cookie4     cookie;\n        component4      name;\n        fattr4          attrs;\n        entry4          *nextentry;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct dirlist4 {\n        entry4          *entries;\n        bool            eof;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct READDIR4resok {\n        verifier4       cookieverf;\n        dirlist4        reply;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "union READDIR4res switch (nfsstat4 status) {",
      "ja": "Union Readdir4resスイッチ（NFSSTAT4ステータス）{"
    },
    {
      "indent": 6,
      "text": " case NFS4_OK:\n         READDIR4resok  resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The READDIR operation retrieves a variable number of entries from a file system directory and returns client requested attributes for each entry along with information to allow the client to request additional directory entries in a subsequent READDIR.",
      "ja": "ReadDir操作は、ファイルシステムディレクトリから変数数のエントリを取得し、各エントリのクライアント要求属性を返し、クライアントが後続のReadDirで追加のディレクトリエントリをリクエストできるようにします。"
    },
    {
      "indent": 6,
      "text": "The arguments contain a cookie value that represents where the READDIR should start within the directory. A value of 0 (zero) for the cookie is used to start reading at the beginning of the directory. For subsequent READDIR requests, the client specifies a cookie value that is provided by the server on a previous READDIR request.",
      "ja": "引数には、readdirがディレクトリ内で開始する場所を表すCookie値が含まれています。Cookieの値は0（ゼロ）を使用して、ディレクトリの先頭に読み始めるために使用されます。その後のReadDirリクエストの場合、クライアントは以前のReadDirリクエストでサーバーが提供するCookie値を指定します。"
    },
    {
      "indent": 6,
      "text": "The cookieverf value should be set to 0 (zero) when the cookie value is 0 (zero) (first directory read). On subsequent requests, it should be a cookieverf as returned by the server. The cookieverf must match that returned by the READDIR in which the cookie was acquired.",
      "ja": "Cookieverfの値は0（Zero）（最初のディレクトリ読み取り）の場合、0（ゼロ）に設定する必要があります。その後のリクエストでは、サーバーが返品するCookieverfである必要があります。Cookieverfは、Cookieが取得されたReaddirによって返されたものと一致する必要があります。"
    },
    {
      "indent": 6,
      "text": "The dircount portion of the argument is a hint of the maximum number of bytes of directory information that should be returned. This value represents the length of the names of the directory entries and the cookie value for these entries. This length represents the XDR encoding of the data (names and cookies) and not the length in the native format of the server. The server may return less data.",
      "ja": "引数のディレクタント部分は、返されるべきディレクトリ情報の最大バイト数のヒントです。この値は、ディレクトリエントリの名前の長さとこれらのエントリのCookie値を表します。この長さは、サーバーのネイティブ形式の長さではなく、データ（名前とCookie）のXDRエンコードを表します。サーバーは、データを返すことができます。"
    },
    {
      "indent": 6,
      "text": "The maxcount value of the argument is the maximum number of bytes for the result. This maximum size represents all of the data being returned and includes the XDR overhead. The server may return less data. If the server is unable to return a single directory entry within the maxcount limit, the error NFS4ERR_READDIR_NOSPC will be returned to the client.",
      "ja": "引数の最大値は、結果の最大バイト数です。この最大サイズは、返されるすべてのデータを表し、XDRオーバーヘッドを含みます。サーバーは、データを返すことができます。サーバーがMaxCount制限内で単一のディレクトリエントリを返すことができない場合、エラーNFS4err_readDir_NOSPCがクライアントに返されます。"
    },
    {
      "indent": 6,
      "text": "Finally, attrbits represents the list of attributes to be returned for each directory entry supplied by the server.",
      "ja": "最後に、アトリビットは、サーバーが提供するディレクトリエントリごとに返される属性のリストを表します。"
    },
    {
      "indent": 6,
      "text": "On successful return, the server's response will provide a list of directory entries. Each of these entries contains the name of the directory entry, a cookie value for that entry, and the associated attributes as requested.",
      "ja": "返品が成功すると、サーバーの応答はディレクトリエントリのリストを提供します。これらの各エントリには、ディレクトリエントリの名前、そのエントリのCookie値、および要求された関連属性が含まれています。"
    },
    {
      "indent": 6,
      "text": "The cookie value is only meaningful to the server and is used as a \"bookmark\" for the directory entry. As mentioned, this cookie is used by the client for subsequent READDIR operations so that it may continue reading a directory. The cookie is similar in concept to a READ offset but should not be interpreted as such by the client. Ideally, the cookie value should not change if the directory is modified since the client may be caching these values.",
      "ja": "Cookie値はサーバーにとってのみ意味があり、ディレクトリエントリの「ブックマーク」として使用されます。前述のように、このCookieは、クライアントがその後のreaddir操作に使用するため、ディレクトリを読み続けることができます。Cookieは、読み取りオフセットと概念が似ていますが、クライアントによってそのように解釈されるべきではありません。理想的には、クライアントがこれらの値をキャッシュしている可能性があるため、ディレクトリが変更された場合、Cookie値は変更されないはずです。"
    },
    {
      "indent": 6,
      "text": "In some cases, the server may encounter an error while obtaining the attributes for a directory entry. Instead of returning an error for the entire READDIR operation, the server can instead return the attribute 'fattr4_rdattr_error'. With this, the server is able to communicate the failure to the client and not fail the entire operation in the instance of what might be a transient failure. Obviously, the client must request the fattr4_rdattr_error attribute for this method to work properly. If the client does not request the attribute, the server has no choice but to return failure for the entire READDIR operation.",
      "ja": "場合によっては、ディレクトリエントリの属性を取得しながらサーバーがエラーに遭遇する場合があります。ReadDir操作全体のエラーを返す代わりに、サーバーは代わりに属性「FATTR4_RDATTR_ERROR」を返すことができます。これにより、サーバーはクライアントに障害を通知することができ、一時的な障害である可能性のあるインスタンスで操作全体を失敗させることはできません。明らかに、クライアントは、このメソッドが適切に動作するようにFATTR4_RDATTR_ERROR属性を要求する必要があります。クライアントが属性を要求しない場合、サーバーはReadDIR操作全体の障害を返すしかありません。"
    },
    {
      "indent": 6,
      "text": "For some file system environments, the directory entries \".\" and \"..\" have special meaning and in other environments, they may not. If the server supports these special entries within a directory, they should not be returned to the client as part of the READDIR response. To enable some client environments, the cookie values of 0, 1, and 2 are to be considered reserved. Note that the Unix client will use these values when combining the server's response and local representations to enable a fully formed Unix directory presentation to the application.",
      "ja": "一部のファイルシステム環境の場合、ディレクトリエントリ「。」「..」は特別な意味を持ち、他の環境ではそうではないかもしれません。サーバーがディレクトリ内でこれらの特別なエントリをサポートしている場合、ReadDIR応答の一部としてクライアントに返されるべきではありません。一部のクライアント環境を有効にするために、0、1、および2のCookie値は予約されていると見なされます。UNIXクライアントは、サーバーの応答とローカル表現を組み合わせて、完全に形成されたUNIXディレクトリプレゼンテーションをアプリケーションに可能にするときにこれらの値を使用することに注意してください。"
    },
    {
      "indent": 6,
      "text": "For READDIR arguments, cookie values of 1 and 2 should not be used and for READDIR results cookie values of 0, 1, and 2 should not returned.",
      "ja": "Readdir引数の場合、1および2のCookie値を使用しないでください。また、ReadDir結果は0、1、および2のCookie値を返してはなりません。"
    },
    {
      "indent": 6,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "The server's file system directory representations can differ greatly. A client's programming interfaces may also be bound to the local operating environment in a way that does not translate well into the NFS protocol. Therefore the use of the dircount and maxcount fields are provided to allow the client the ability to provide guidelines to the server. If the client is aggressive about attribute collection during a READDIR, the server has an idea of how to limit the encoded response. The dircount field provides a hint on the number of entries based solely on the names of the directory entries. Since it is a hint, it may be possible that a dircount value is zero. In this case, the server is free to ignore the dircount value and return directory information based on the specified maxcount value.",
      "ja": "サーバーのファイルシステムディレクトリ表現は、大きく異なる場合があります。クライアントのプログラミングインターフェイスは、NFSプロトコルにうまく変換されない方法で、ローカルオペレーティング環境にも拘束される場合があります。したがって、クライアントがサーバーにガイドラインを提供できるようにするために、DircountおよびMaxCountフィールドの使用が提供されます。クライアントがreaddir中に属性収集について積極的に攻撃的である場合、サーバーはエンコードされた応答を制限する方法を知っています。Dircountフィールドは、ディレクトリエントリの名前のみに基づいたエントリの数に関するヒントを提供します。ヒントであるため、ひずみ値がゼロである可能性があります。この場合、サーバーは、指定されたMaxCount値に基づいて、Dircount値を自由に無視し、ディレクトリ情報を返すことができます。"
    },
    {
      "indent": 6,
      "text": "The cookieverf may be used by the server to help manage cookie values that may become stale. It should be a rare occurrence that a server is unable to continue properly reading a directory with the provided cookie/cookieverf pair. The server should make every effort to avoid this condition since the application at the client may not be able to properly handle this type of failure.",
      "ja": "Cookieverfは、古くなる可能性のあるCookie値を管理するためにサーバーによって使用される場合があります。サーバーが提供されたCookie/Cookieverfペアでディレクトリを適切に読み続けることができないことはまれなことです。クライアントでのアプリケーションがこのタイプの障害を適切に処理できない可能性があるため、サーバーはこの状態を回避するためにあらゆる努力をする必要があります。"
    },
    {
      "indent": 6,
      "text": "The use of the cookieverf will also protect the client from using READDIR cookie values that may be stale. For example, if the file system has been migrated, the server may or may not be able to use the same cookie values to service READDIR as the previous server used. With the client providing the cookieverf, the server is able to provide the appropriate response to the client. This prevents the case where the server may accept a cookie value but the underlying directory has changed and the response is invalid from the client's context of its previous READDIR.",
      "ja": "Cookieverfの使用は、古くなる可能性のあるReaddir Cookie値の使用からクライアントを保護します。たとえば、ファイルシステムが移行された場合、サーバーは以前のサーバーと同じCookie値を使用してReadDirを使用できる場合とできない場合があります。クライアントがCookieverfを提供することで、サーバーはクライアントに適切な応答を提供できます。これにより、サーバーがCookie値を受け入れる可能性がありますが、基礎となるディレクトリが変更され、以前のReaddirのクライアントのコンテキストから応答が無効になっている場合が防止されます。"
    },
    {
      "indent": 6,
      "text": "Since some servers will not be returning \".\" and \"..\" entries as has been done with previous versions of the NFS protocol, the client that requires these entries be present in READDIR responses must fabricate them.",
      "ja": "一部のサーバーは「」を「」に戻さないため。NFSプロトコルの以前のバージョンで行われた「..」エントリは、これらのエントリを必要とするクライアントがReadDir応答に存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_BAD_COOKIE NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_NOTSUPP NFS4ERR_READDIR_NOSPC NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_TOOSMALL NFS4ERR_WRONGSEC",
      "ja": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_BAD_COOKIE NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVER_INVER NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHHANDLE NFS4ERR_NOTDIN NFSDIDDIDDIDDIN nfsdir nfs4err_notdir nfs4err_notdir nfs4err_notdiddir Ource nfs4err_serverfault nfs4err_stale nfs4err_toosmall nfs4err_wrongsec"
    },
    {
      "indent": 0,
      "text": "14.2.25. Operation 27: READLINK - Read Symbolic Link",
      "section_title": true,
      "ja": "14.2.25. 操作27：ReadLink-シンボリックリンクを読みます"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "(cfh) -> linktext",
      "ja": "（CFH） - > linkText"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "/* CURRENT_FH: symlink */\nvoid;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct READLINK4resok { linktext4 link; };",
      "ja": "struct readlink4resok {linktext4 link;};"
    },
    {
      "indent": 6,
      "text": "union READLINK4res switch (nfsstat4 status) {\n case NFS4_OK:\n         READLINK4resok resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "READLINK reads the data associated with a symbolic link. The data is a UTF-8 string that is opaque to the server. That is, whether created by an NFS client or created locally on the server, the data in a symbolic link is not interpreted when created, but is simply stored.",
      "ja": "ReadLinkは、シンボリックリンクに関連付けられたデータを読み取ります。データは、サーバーに不透明なUTF-8文字列です。つまり、NFSクライアントによって作成された場合でも、サーバー上にローカルに作成された場合でも、シンボリックリンクのデータは作成時に解釈されるのではなく、単に保存されます。"
    },
    {
      "indent": 6,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "A symbolic link is nominally a pointer to another file. The data is not necessarily interpreted by the server, just stored in the file. It is possible for a client implementation to store a path name that is not meaningful to the server operating system in a symbolic link. A READLINK operation returns the data to the client for interpretation. If different implementations want to share access to symbolic links, then they must agree on the interpretation of the data in the symbolic link.",
      "ja": "シンボリックリンクは、名目上、別のファイルへのポインターです。データは必ずしもサーバーによって解釈されるわけではなく、ファイルに保存されているだけです。クライアントの実装では、シンボリックリンク内のサーバーオペレーティングシステムにとって意味のないパス名を保存することができます。ReadLink操作は、解釈のためにデータをクライアントに返します。異なる実装がシンボリックリンクへのアクセスを共有したい場合、彼らはシンボリックリンクのデータの解釈に同意する必要があります。"
    },
    {
      "indent": 6,
      "text": "The READLINK operation is only allowed on objects of type NF4LNK. The server should return the error, NFS4ERR_INVAL, if the object is not of type, NF4LNK.",
      "ja": "ReadLink操作は、型NF4LNKのオブジェクトでのみ許可されます。サーバーは、オブジェクトがタイプでない場合は、エラーnfs4err_invalを返す必要があります。nf4lnk。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC",
      "ja": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_DELAY NFS4ERR_FHEXPPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHHANDLE NFS4ERR_NOTSUPP NFS4ERR_RESOURCEORCEORCERCERCERCERCERCERCERCERFAURE NFSERFAULE NFSERFAULE NFSERFAULE NFSERFAULE NFSERFAULE NFSERFAULE NFSERFAULE NFSERFAULE NFSERFAULE NFSERFAULT"
    },
    {
      "indent": 0,
      "text": "14.2.26. Operation 28: REMOVE - Remove Filesystem Object",
      "section_title": true,
      "ja": "14.2.26. 操作28：削除 - ファイルシステムオブジェクトを削除します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "(cfh), filename -> change_info",
      "ja": "（cfh）、filename-> change_info"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "struct REMOVE4args {\n        /* CURRENT_FH: directory */\n        component4       target;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct REMOVE4resok {\n        change_info4    cinfo;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "union REMOVE4res switch (nfsstat4 status) {\n case NFS4_OK:\n         REMOVE4resok   resok4;\n default:\n         void;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The REMOVE operation removes (deletes) a directory entry named by filename from the directory corresponding to the current filehandle. If the entry in the directory was the last reference to the corresponding file system object, the object may be destroyed.",
      "ja": "削除操作は、現在のファイルハンドルに対応するディレクトリからFilenameによって名前が付けられたディレクトリエントリを削除（削除）します。ディレクトリ内のエントリが対応するファイルシステムオブジェクトへの最後の参照である場合、オブジェクトが破壊される場合があります。"
    },
    {
      "indent": 6,
      "text": "For the directory where the filename was removed, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the removal.",
      "ja": "ファイル名が削除されたディレクトリの場合、サーバーはCINFOでChange_Info4情報を返します。Change_Info4 structの原子フィールドを使用すると、サーバーは、削除に関して前後の変更属性が原子的に取得されたかどうかを示します。"
    },
    {
      "indent": 6,
      "text": "If the target has a length of 0 (zero), or if target does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.",
      "ja": "ターゲットの長さは0（ゼロ）の場合、またはターゲットがUTF-8定義に従わない場合、エラーNFS4err_invalが返されます。"
    },
    {
      "indent": 6,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "NFS versions 2 and 3 required a different operator RMDIR for directory removal. NFS version 4 REMOVE can be used to delete any directory entry independent of its file type.",
      "ja": "NFSバージョン2および3には、ディレクトリの削除に異なるオペレーターRMDIRが必要でした。NFSバージョン4削除を使用して、ファイルタイプに関係なくディレクトリエントリを削除できます。"
    },
    {
      "indent": 6,
      "text": "The concept of last reference is server specific. However, if the numlinks field in the previous attributes of the object had the value 1, the client should not rely on referring to the object via a file handle. Likewise, the client should not rely on the resources (disk space, directory entry, and so on) formerly associated with the object becoming immediately available. Thus, if a client needs to be able to continue to access a file after using REMOVE to remove it, the client should take steps to make sure that the file will still be accessible. The usual mechanism used is to RENAME the file from its old name to a new hidden name.",
      "ja": "最後の参照の概念はサーバー固有です。ただし、オブジェクトの以前の属性のnumlinksフィールドに値1がある場合、クライアントはファイルハンドルを介してオブジェクトを参照することに依存してはなりません。同様に、クライアントは、以前に関連付けられていたオブジェクトにすぐに利用可能になったリソース（ディスクスペース、ディレクトリエントリなど）に依存してはなりません。したがって、クライアントが削除を使用してファイルにアクセスし続ける必要がある場合、クライアントは削除を削除するために、ファイルにアクセスできることを確認するための手順を実行する必要があります。使用される通常のメカニズムは、ファイルを古い名前から新しい非表示名に変更することです。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_NOTEMPTY NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC",
      "ja": "nfs4err_acces nfs4err_badhandle nfs4err_delay nfs4err_fhexppired nfs4err_io nfs4err_moved nfs4err_nametoolong nfs4err_noent nfs4err_nofilehandle nfs4err_notdir nfsdir nfsdir nfsdir neddir neddir neddir neddir nfsdir nfsdir nfsdir nfsdir neddir s4err_rofs nfs4err_serverfault nfs4err_stale nfs4err_wrongsec"
    },
    {
      "indent": 0,
      "text": "14.2.27. Operation 29: RENAME - Rename Directory Entry",
      "section_title": true,
      "ja": "14.2.27. 操作29：名前を変更 - ディレクトリエントリの名前を変更します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "(sfh), oldname (cfh), newname -> source_change_info, target_change_info",
      "ja": "（sfh）、oldname（cfh）、newname-> source_change_info、target_change_info"
    },
    {
      "indent": 6,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "struct RENAME4args {\n        /* SAVED_FH: source directory */\n        component4      oldname;\n        /* CURRENT_FH: target directory */\n        component4      newname;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct RENAME4resok {\n        change_info4    source_cinfo;\n        change_info4    target_cinfo;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "union RENAME4res switch (nfsstat4 status) {\n case NFS4_OK:\n         RENAME4resok   resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The RENAME operation renames the object identified by oldname in the source directory corresponding to the saved filehandle, as set by the SAVEFH operation, to newname in the target directory corresponding to the current filehandle. The operation is required to be atomic to the client. Source and target directories must reside on the same file system on the server. On success, the current filehandle will continue to be the target directory.",
      "ja": "名前の操作は、SaveFH操作によって設定された保存されたファイルハンドルに対応するソースディレクトリのOldNameによって識別されたオブジェクトを、現在のFileHandleに対応するターゲットディレクトリのNewNameに変更します。操作は、クライアントにアトミックである必要があります。ソースおよびターゲットディレクトリは、サーバー上の同じファイルシステムに存在する必要があります。成功すると、現在のファイルハンドルはターゲットディレクトリであり続けます。"
    },
    {
      "indent": 6,
      "text": "If the target directory already contains an entry with the name, newname, the source object must be compatible with the target: either both are non-directories or both are directories and the target must be empty. If compatible, the existing target is removed before the rename occurs. If they are not compatible or if the target is a directory but not empty, the server will return the error, NFS4ERR_EXIST.",
      "ja": "ターゲットディレクトリに名前、newNameのエントリが既に含まれている場合、ソースオブジェクトはターゲットと互換性がある必要があります。どちらも非ディレクトリであるか、両方がディレクトリであり、ターゲットは空でなければなりません。互換性のある場合、名前の変更が発生する前に既存のターゲットが削除されます。それらが互換性がない場合、またはターゲットがディレクトリであるが空でない場合、サーバーはエラー、nfs4err_existを返します。"
    },
    {
      "indent": 6,
      "text": "If oldname and newname both refer to the same file (they might be hard links of each other), then RENAME should perform no action and return success.",
      "ja": "OldNameとNewNameの両方が同じファイルを参照している場合（それらはお互いのハードリンクである可能性があります）、nameはアクションを実行せず、成功を返す必要があります。"
    },
    {
      "indent": 6,
      "text": "For both directories involved in the RENAME, the server returns change_info4 information. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the rename.",
      "ja": "変更に関係する両方のディレクトリについて、サーバーはchange_info4情報を返します。Change_Info4 structの原子フィールドを使用すると、サーバーは、変更前後の属性が変更に対して原子的に取得されたかどうかを示します。"
    },
    {
      "indent": 6,
      "text": "If the oldname or newname has a length of 0 (zero), or if oldname or newname does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.",
      "ja": "oldnameまたはnewNameの長さは0（ゼロ）の場合、またはOldNameまたはNewNameがUTF-8の定義に従わない場合、エラーNFS4err_Invalが返されます。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "The RENAME operation must be atomic to the client. The statement \"source and target directories must reside on the same file system on the server\" means that the fsid fields in the attributes for the directories are the same. If they reside on different file systems, the error, NFS4ERR_XDEV, is returned.",
      "ja": "名前の操作は、クライアントにアトミックでなければなりません。「ソースおよびターゲットディレクトリは、サーバー上の同じファイルシステムに存在する必要がある」というステートメントは、ディレクトリの属性のFSIDフィールドが同じであることを意味します。彼らが異なるファイルシステムに存在する場合、エラー、nfs4err_xdevが返されます。"
    },
    {
      "indent": 6,
      "text": "A filehandle may or may not become stale or expire on a rename. However, server implementors are strongly encouraged to attempt to keep file handles from becoming stale or expiring in this fashion.",
      "ja": "FileHandleは、名前が古くなったり、変更されたりしない場合があります。ただし、サーバーの実装者は、この方法でファイルハンドルが古くなったり期限切れになったりしないようにすることを強くお勧めします。"
    },
    {
      "indent": 6,
      "text": "On some servers, the filenames, \".\" and \"..\", are illegal as either oldname or newname. In addition, neither oldname nor newname can be an alias for the source directory. These servers will return the error, NFS4ERR_INVAL, in these cases.",
      "ja": "一部のサーバーでは、ファイル名「。」そして、「..」は、oldnameまたはNewNameのように違法です。さらに、OldNameもNewNameもソースディレクトリのエイリアスになることはできません。これらのサーバーは、これらの場合にエラーnfs4err_invalを返します。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_NOTEMPTY NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC NFS4ERR_XDEV",
      "ja": "nfs4err_acces nfs4err_badhandle nfs4err_delay nfs4err_dquot nfs4err_exist nfs4err_fhexppired nfs4err_is4err_isdir nfs4err_moved nfs4er_nmetoolong nfs4er_nfs4er_ned4er_nfs4er OSPC nfs4err_notdir nfs4err_notempty nfs4err_notsupp nfs4err_resource nfs4err_rofs nfs4err_serverfault nfs4err_stale nfs4err_wrongsec nfs4err_xdeve"
    },
    {
      "indent": 0,
      "text": "14.2.28. Operation 30: RENEW - Renew a Lease",
      "section_title": true,
      "ja": "14.2.28. 操作30：更新 - リースを更新します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "stateid -> ()",
      "ja": "STATEID->（）"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "struct RENEW4args { stateid4 stateid; };",
      "ja": "struct renew4args {stateid4 stateid;};"
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct RENEW4res { nfsstat4 status; };",
      "ja": "struct renew4res {nfsstat4 status;};"
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The RENEW operation is used by the client to renew leases which it currently holds at a server. In processing the RENEW request, the server renews all leases associated with the client. The associated leases are determined by the client id provided via the SETCLIENTID procedure.",
      "ja": "更新操作は、クライアントが現在サーバーで保持しているリースを更新するために使用されます。更新要求の処理において、サーバーはクライアントに関連付けられたすべてのリースを更新します。関連するリースは、SetClientIDプロシージャを介して提供されるクライアントIDによって決定されます。"
    },
    {
      "indent": 6,
      "text": "The stateid for RENEW may not be one of the special stateids consisting of all bits 0 (zero) or all bits 1.",
      "ja": "StateID for Renewは、すべてのビット0（ゼロ）またはすべてのビット1で構成される特別なStateIDの1つではない場合があります。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_BAD_STATEID NFS4ERR_EXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_LEASE_MOVED NFS4ERR_MOVED NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE_STATEID NFS4ERR_WRONGSEC",
      "ja": "NFS4ERR_BAD_STATEID NFS4ERR_EXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_LEASE_MOVED NFS4ERR_MOVED NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFORUALT NFS4ERR_STALE_STALE_STATEID NFS4ERCECEC"
    },
    {
      "indent": 0,
      "text": "14.2.29. Operation 31: RESTOREFH - Restore Saved Filehandle",
      "section_title": true,
      "ja": "14.2.29. 操作31：RestoreFH-保存されたファイルハンドルを復元します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "(sfh) -> (cfh)",
      "ja": "（SFH） - >（CFH）"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "/* SAVED_FH: */\nvoid;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct RESTOREFH4res {\n        /* CURRENT_FH: value of saved fh */\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "Set the current filehandle to the value in the saved filehandle. If there is no saved filehandle then return an error NFS4ERR_NOFILEHANDLE.",
      "ja": "保存されたファイルハンドルの値に現在のファイルハンドルを設定します。保存されたファイルハンドルがない場合は、エラーnfs4err_nofilehandleを返します。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "Operations like OPEN and LOOKUP use the current filehandle to represent a directory and replace it with a new filehandle. Assuming the previous filehandle was saved with a SAVEFH operator, the previous filehandle can be restored as the current filehandle. This is commonly used to obtain post-operation attributes for the directory, e.g.",
      "ja": "OpenやLookupなどの操作現在のファイルハンドルを使用してディレクトリを表し、新しいFileHandleに置き換えます。以前のFileHandleがSaveFHオペレーターで保存されていると仮定すると、以前のFileHandleを現在のFileHandleとして復元できます。これは、ディレクトリの操作後属性を取得するために一般的に使用されます。"
    },
    {
      "indent": 15,
      "text": "PUTFH (directory filehandle) SAVEFH GETATTR attrbits (pre-op dir attrs) CREATE optbits \"foo\" attrs GETATTR attrbits (file attributes) RESTOREFH GETATTR attrbits (post-op dir attrs)",
      "ja": "putfh（ディレクトリファイルハンドル）savefh getattr attrbits（pre-op dir attrs）Optbits \"foo\" attrs getattr属性（ファイル属性）復元getattr属性（ポストオップdir attrs）"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC",
      "ja": "nfs4err_badhandle nfs4err_fhexpired nfs4err_moved nfs4err_nofilehandle nfs4err_resource nfs4err_serverfault nfs4err_stale nfs4err_wrongsec"
    },
    {
      "indent": 0,
      "text": "14.2.30. Operation 32: SAVEFH - Save Current Filehandle",
      "section_title": true,
      "ja": "14.2.30. 操作32：savefh-現在のファイルハンドルを保存します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "(cfh) -> (sfh)",
      "ja": "（CFH） - >（SFH）"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "/* CURRENT_FH: */\nvoid;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct SAVEFH4res {\n        /* SAVED_FH: value of current fh */\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "Save the current filehandle. If a previous filehandle was saved then it is no longer accessible. The saved filehandle can be restored as the current filehandle with the RESTOREFH operator.",
      "ja": "現在のファイルハンドルを保存します。以前のファイルハンドルが保存された場合、アクセスできなくなります。保存されたファイルハンドルは、restorefhオペレーターを備えた現在のファイルハンドルとして復元できます。"
    },
    {
      "indent": 6,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC",
      "ja": "nfs4err_badhandle nfs4err_fhexpired nfs4err_moved nfs4err_nofilehandle nfs4err_resource nfs4err_serverfault nfs4err_stale nfs4err_wrongsec"
    },
    {
      "indent": 0,
      "text": "14.2.31. Operation 33: SECINFO - Obtain Available Security",
      "section_title": true,
      "ja": "14.2.31. 操作33：SecInfo-利用可能なセキュリティを取得します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "(cfh), name -> { secinfo }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "struct SECINFO4args {\n        /* CURRENT_FH: */\n        component4     name;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "enum rpc_gss_svc_t { RPC_GSS_SVC_NONE = 1, RPC_GSS_SVC_INTEGRITY = 2, RPC_GSS_SVC_PRIVACY = 3 };",
      "ja": "enum rpc_gss_svc_t {rpc_gss_svc_none = 1、rpc_gss_svc_integrity = 2、rpc_gss_svc_privacy = 3};"
    },
    {
      "indent": 6,
      "text": "struct rpcsec_gss_info {\n        sec_oid4        oid;\n        qop4            qop;\n        rpc_gss_svc_t   service;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct secinfo4 {\n        uint32_t flavor;\n        opaque flavor_info<>;   /* null for AUTH_SYS, AUTH_NONE;\n                                   contains rpcsec_gss_info for\n                                   RPCSEC_GSS. */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "typedef secinfo4 SECINFO4resok<>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "union SECINFO4res switch (nfsstat4 status) {\n case NFS4_OK:\n         SECINFO4resok resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The SECINFO operation is used by the client to obtain a list of valid RPC authentication flavors for a specific file handle, file name pair. The result will contain an array which represents the security mechanisms available. The array entries are represented by the secinfo4 structure. The field 'flavor' will contain a value of AUTH_NONE, AUTH_SYS (as defined in [RFC1831]), or RPCSEC_GSS (as defined in [RFC2203]).",
      "ja": "SECINFO操作は、クライアントが特定のファイルハンドル、ファイル名ペアの有効なRPC認証フレーバーのリストを取得するために使用されます。結果には、利用可能なセキュリティメカニズムを表す配列が含まれます。配列エントリは、SECINFO4構造で表されます。フィールド「フレーバー」には、auth_none、auth_sys（[rfc1831]で定義されている）、またはrpcsec_gss（[rfc2203]で定義されている）の値が含まれます。"
    },
    {
      "indent": 6,
      "text": "For the flavors, AUTH_NONE, and AUTH_SYS no additional security information is returned. For a return value of RPCSEC_GSS, a security triple is returned that contains the mechanism object id (as defined in [RFC2078]), the quality of protection (as defined in [RFC2078]) and the service type (as defined in [RFC2203]). It is possible for SECINFO to return multiple entries with flavor equal to RPCSEC_GSS with different security triple values.",
      "ja": "フレーバー、auth_none、およびauth_sysの場合、追加のセキュリティ情報は返されません。RPCSEC_GSSの返品値の場合、メカニズムオブジェクトID（[RFC2078]で定義されている）、保護の質（[RFC2078]で定義）、およびサービスタイプ（[RFC2203]で定義されている保護の質を含むセキュリティトリプルが返されます。）。SECINFOは、さまざまなセキュリティトリプル値を持つRPCSEC_GSSに等しいフレーバーの複数のエントリを返すことができます。"
    },
    {
      "indent": 6,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "The SECINFO operation is expected to be used by the NFS client when the error value of NFS4ERR_WRONGSEC is returned from another NFS operation. This signifies to the client that the server's security policy is different from what the client is currently using. At this point, the client is expected to obtain a list of possible security flavors and choose what best suits its policies.",
      "ja": "SECINFO操作は、NFS4err_WrongSecのエラー値が別のNFS操作から返される場合、NFSクライアントによって使用される予定です。これは、クライアントのセキュリティポリシーがクライアントが現在使用しているものとは異なることをクライアントに意味します。この時点で、クライアントは可能なセキュリティフレーバーのリストを取得し、そのポリシーに最適なものを選択することが期待されます。"
    },
    {
      "indent": 6,
      "text": "It is recommended that the client issue the SECINFO call protected by a security triple that uses either rpc_gss_svc_integrity or rpc_gss_svc_privacy service. The use of rpc_gss_svc_none would allow an attacker in the middle to modify the SECINFO results such that the client might select a weaker algorithm in the set allowed by server, making the client and/or server vulnerable to further attacks.",
      "ja": "クライアントは、RPC_GSS_SVC_INTEGRITYまたはRPC_GSS_SVC_PRIVACYサービスのいずれかを使用するセキュリティトリプルによって保護されたSECINFOコールを発行することをお勧めします。RPC_GSS_SVC_NONEを使用すると、中央の攻撃者がSECINFOの結果を変更できるようになり、クライアントがサーバーで許可されたセットでより弱いアルゴリズムを選択し、クライアントおよび/またはサーバーがさらなる攻撃に対して脆弱になります。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC",
      "ja": "nfs4err_badhandle nfs4err_fhexpired nfs4err_moved nfs4err_nametoolong nfs4err_noent nfs4err_nofilehandle nfs4err_notdir nfs4err_resource nfs4err_serverfault"
    },
    {
      "indent": 0,
      "text": "14.2.32. Operation 34: SETATTR - Set Attributes",
      "section_title": true,
      "ja": "14.2.32. 操作34：SetATTR -SET属性"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "(cfh), attrbits, attrvals -> -",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "struct SETATTR4args {\n        /* CURRENT_FH: target object */\n        stateid4        stateid;\n        fattr4          obj_attributes;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct SETATTR4res {\n        nfsstat4        status;\n        bitmap4         attrsset;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The SETATTR operation changes one or more of the attributes of a file system object. The new attributes are specified with a bitmap and the attributes that follow the bitmap in bit order.",
      "ja": "Setattr操作は、ファイルシステムオブジェクトの属性の1つ以上を変更します。新しい属性は、ビットマップとビットマップに従う属性で指定されています。"
    },
    {
      "indent": 6,
      "text": "The stateid is necessary for SETATTRs that change the size of a file (modify the attribute object_size). This stateid represents a record lock, share reservation, or delegation which must be valid for the SETATTR to modify the file data. A valid stateid would always be specified. When the file size is not changed, the special stateid consisting of all bits 0 (zero) should be used.",
      "ja": "StateIDは、ファイルのサイズを変更するSetattrsに必要です（属性object_sizeを変更します）。このStateIDは、ファイルデータを変更するためにSetATTRが有効にする必要があるレコードロック、共有予約、または代表団を表しています。有効なStateIDが常に指定されます。ファイルサイズが変更されない場合、すべてのビット0（ゼロ）で構成される特別なStateIDを使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "On either success or failure of the operation, the server will return the attrsset bitmask to represent what (if any) attributes were successfully set.",
      "ja": "操作の成功または失敗のいずれかで、サーバーはAttrssetビットマスクを返して、（もしあれば）属性が正常に設定されたものを表します。"
    },
    {
      "indent": 6,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "The file size attribute is used to request changes to the size of a file. A value of 0 (zero) causes the file to be truncated, a value less than the current size of the file causes data from new size to the end of the file to be discarded, and a size greater than the current size of the file causes logically zeroed data bytes to be added to the end of the file. Servers are free to implement this using holes or actual zero data bytes. Clients should not make any assumptions regarding a server's implementation of this feature, beyond that the bytes returned will be zeroed. Servers must support extending the file size via SETATTR.",
      "ja": "ファイルサイズ属性は、ファイルのサイズの変更を要求するために使用されます。0の値（ゼロ）によりファイルが切り捨てられ、ファイルの現在のサイズより低い値により、ファイルの端までのデータが破棄され、ファイルの現在のサイズよりも大きいサイズが廃棄されます。論理的にゼロのデータバイトがファイルの最後に追加されます。サーバーは、穴または実際のゼロデータバイトを使用してこれを無料で実装できます。クライアントは、この機能のサーバーの実装に関して仮定を立てるべきではありません。それを超えて、返されるバイトがゼロになります。サーバーは、Setattrを介してファイルサイズの拡張をサポートする必要があります。"
    },
    {
      "indent": 6,
      "text": "SETATTR is not guaranteed atomic. A failed SETATTR may partially change a file's attributes.",
      "ja": "Setattrはアトミックを保証するものではありません。障害のあるSetattrは、ファイルの属性を部分的に変更する可能性があります。"
    },
    {
      "indent": 6,
      "text": "Changing the size of a file with SETATTR indirectly changes the time_modify. A client must account for this as size changes can result in data deletion.",
      "ja": "Setattrを使用してファイルのサイズを変更すると、time_modifyが変更されます。サイズの変更によりデータが削除される可能性があるため、クライアントはこれを説明する必要があります。"
    },
    {
      "indent": 6,
      "text": "If server and client times differ, programs that compare client time to file times can break. A time maintenance protocol should be used to limit client/server time skew.",
      "ja": "サーバーとクライアントの時間が異なる場合、クライアントの時間をファイル時間を比較するプログラムは壊れる可能性があります。クライアント/サーバーの時間のスキューを制限するために、時間メンテナンスプロトコルを使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "If the server cannot successfully set all the attributes it must return an NFS4ERR_INVAL error. If the server can only support 32 bit offsets and sizes, a SETATTR request to set the size of a file to larger than can be represented in 32 bits will be rejected with this same error.",
      "ja": "サーバーがすべての属性を正常に設定できない場合、nfs4err_invalエラーを返す必要があります。サーバーが32ビットのオフセットとサイズのみをサポートできる場合、32ビットで表現できるよりも大きいファイルのサイズを設定するSetATTRリクエストは、この同じエラーで拒否されます。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_DELAY NFS4ERR_DENIED NFS4ERR_DQUOT NFS4ERR_EXPIRED NFS4ERR_FBIG NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTSUPP NFS4ERR_OLD_STATEID NFS4ERR_PERM NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID NFS4ERR_WRONGSEC",
      "ja": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_DELAY NFS4ERR_DENIED NFS4ERR_DQUOT NFS4ERR_EXPIRED NFS4ERR_FBIG NFS4ERR_FHEXPERS4ERR_GRACE NFS4SERR_INFDEDED4ERRED4ERBED4ERBED4ERBED4IR Ilehandle nfs4err_nospc nfs4err_notsupp nfs4err_old_stateid nfs4err_perm nfs4err_resource nfs4err_rofs nfs4err_serverfault nfs4err_stale nfs4err_stale_staleid nfs4ers4err_wrongsec"
    },
    {
      "indent": 0,
      "text": "14.2.33. Operation 35: SETCLIENTID - Negotiate Clientid",
      "section_title": true,
      "ja": "14.2.33. 操作35：SetClientID -ClientISIDを交渉します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "client, callback -> clientid, setclientid_confirm",
      "ja": "クライアント、コールバック - > clientId、setclientId_confirm"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "struct SETCLIENTID4args {\n        nfs_client_id4  client;\n        cb_client4      callback;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct SETCLIENTID4resok {\n        clientid4       clientid;\n        verifier4       setclientid_confirm;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "union SETCLIENTID4res switch (nfsstat4 status) {\n case NFS4_OK:\n         SETCLIENTID4resok      resok4;\n case NFS4ERR_CLID_INUSE:\n         clientaddr4    client_using;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The SETCLIENTID operation introduces the ability of the client to notify the server of its intention to use a particular client identifier and verifier pair. Upon successful completion the server will return a clientid which is used in subsequent file locking requests and a confirmation verifier. The client will use the SETCLIENTID_CONFIRM operation to return the verifier to the server. At that point, the client may use the clientid in subsequent operations that require an nfs_lockowner.",
      "ja": "SetClientID操作により、クライアントが特定のクライアント識別子と検証剤ペアを使用する意図をサーバーに通知する能力を導入します。正常に完了すると、サーバーは後続のファイルロック要求と確認検証で使用されるClientIDを返します。クライアントは、SetClientID_CONFIRM操作を使用して、Verifierをサーバーに返します。その時点で、クライアントは、NFS_Lockownerを必要とする後続の操作でClientIDを使用できます。"
    },
    {
      "indent": 6,
      "text": "The callback information provided in this operation will be used if the client is provided an open delegation at a future point. Therefore, the client must correctly reflect the program and port numbers for the callback program at the time SETCLIENTID is used.",
      "ja": "この操作で提供されるコールバック情報は、クライアントに将来の時点でオープンな代表団が提供される場合に使用されます。したがって、クライアントは、SetClientIDが使用されている時点でのコールバックプログラムのプログラムとポート番号を正しく反映する必要があります。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "The server takes the verifier and client identification supplied in the nfs_client_id4 and searches for a match of the client identification. If no match is found the server saves the principal/uid information along with the verifier and client identification and returns a unique clientid that is used as a shorthand reference to the supplied information.",
      "ja": "サーバーは、NFS_CLIENT_ID4で提供された検証とクライアントの識別を取得し、クライアント識別の一致を検索します。一致が見つからない場合、サーバーはVerifierおよびクライアントの識別とともにプリンシパル/UID情報を保存し、提供された情報への速記として使用される一意のclientIDを返します。"
    },
    {
      "indent": 6,
      "text": "If the server finds matching client identification and a corresponding match in principal/uid, the server releases all locking state for the client and returns a new clientid.",
      "ja": "サーバーがプリンシパル/UIDで一致するクライアントの識別と対応する一致を見つけた場合、サーバーはクライアントのすべてのロック状態をリリースし、新しいclientIDを返します。"
    },
    {
      "indent": 6,
      "text": "The principal, or principal to user-identifier mapping is taken from the credential presented in the RPC. As mentioned, the server will use the credential and associated principal for the matching with existing clientids. If the client is a traditional host-based client like a Unix NFS client, then the credential presented may be the host credential. If the client is a user level client or lightweight client, the credential used may be the end user's credential. The client should take care in choosing an appropriate credential since denial of service attacks could be attempted by a rogue client that has access to the credential.",
      "ja": "プリンシパルまたはプリンシパルからユーザーIDENTIFIERマッピングは、RPCで提示された資格情報から取得されます。前述のように、サーバーは、既存のclientIDSとのマッチングには、資格情報と関連するプリンシパルを使用します。クライアントがUNIX NFSクライアントのような従来のホストベースのクライアントである場合、提示された資格情報はホスト資格情報である可能性があります。クライアントがユーザーレベルのクライアントまたは軽量クライアントである場合、使用される資格情報はエンドユーザーの資格情報である可能性があります。クライアントは、資格情報にアクセスできる不正なクライアントがサービス拒否攻撃を試みる可能性があるため、適切な資格情報を選択することに注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_CLID_INUSE NFS4ERR_INVAL NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT",
      "ja": "nfs4err_clid_inuse nfs4err_inval nfs4err_resource nfs4err_serverfault"
    },
    {
      "indent": 0,
      "text": "14.2.34. Operation 36: SETCLIENTID_CONFIRM - Confirm Clientid",
      "section_title": true,
      "ja": "14.2.34. 操作36：SetClientId_Confirm -Crience ClientIDを確認します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "setclientid_confirm -> -",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "struct SETCLIENTID_CONFIRM4args { verifier4 setclientid_confirm; };",
      "ja": "struct setclientid_confirm4args {verifier4 setclientId_confirm;};"
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct SETCLIENTID_CONFIRM4res { nfsstat4 status; };",
      "ja": "struct setclientid_confirm4res {nfsstat4 status;};"
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "This operation is used by the client to confirm the results from a previous call to SETCLIENTID. The client provides the server supplied (from a SETCLIENTID response) opaque confirmation verifier. The server responds with a simple status of success or failure.",
      "ja": "この操作は、setclientIDへの以前の呼び出しの結果を確認するためにクライアントによって使用されます。クライアントは、（SetClientID応答から）提供されたサーバーを提供しています。サーバーは、成功または失敗の単純なステータスで応答します。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "The client must use the SETCLIENTID_CONFIRM operation to confirm its use of client identifier. If the server is holding state for a client which has presented a new verifier via SETCLIENTID, then the state will not be released, as described in the section \"Client Failure and Recovery\", until a valid SETCLIENTID_CONFIRM is received. Upon successful confirmation the server will release the previous state held on behalf of the client. The server should choose a confirmation cookie value that is reasonably unique for the client.",
      "ja": "クライアントは、setclientId_confirm操作を使用して、クライアント識別子の使用を確認する必要があります。サーバーがSetClientIDを介して新しい検証剤を提示したクライアントの状態を保持している場合、有効なsetClientID_CONFIRMが受信されるまで、「クライアントの失敗と回復」セクションで説明されているように、状態はリリースされません。確認が成功すると、サーバーはクライアントに代わって保持されている以前の状態をリリースします。サーバーは、クライアントにとってかなり一意の確認クッキー値を選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_CLID_INUSE NFS4ERR_INVAL NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE_CLIENTID",
      "ja": "nfs4err_clid_inuse nfs4err_inval nfs4err_resource nfs4err_serverfault nfs4err_stale_clientid"
    },
    {
      "indent": 0,
      "text": "14.2.35. Operation 37: VERIFY - Verify Same Attributes",
      "section_title": true,
      "ja": "14.2.35. 操作37：検証 - 同じ属性を確認します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "(cfh), fattr -> -",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "struct VERIFY4args {\n        /* CURRENT_FH: object */\n        fattr4          obj_attributes;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct VERIFY4res { nfsstat4 status; };",
      "ja": "struct verify4res {nfsstat4 status;};"
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The VERIFY operation is used to verify that attributes have a value assumed by the client before proceeding with following operations in the compound request. If any of the attributes do not match then the error NFS4ERR_NOT_SAME must be returned. The current filehandle retains its value after successful completion of the operation.",
      "ja": "検証操作は、属性が複合リクエストで次の操作を進める前にクライアントが想定している値を持っていることを確認するために使用されます。属性のいずれかが一致しない場合、エラーnfs4err_not_sameを返す必要があります。現在のファイルハンドルは、操作が正常に完了した後、その値を保持します。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "One possible use of the VERIFY operation is the following compound sequence. With this the client is attempting to verify that the file being removed will match what the client expects to be removed. This sequence can help prevent the unintended deletion of a file.",
      "ja": "検証操作の使用可能な1つの使用は、次の複合配列です。これにより、クライアントは、削除されているファイルがクライアントが削除されると予想されるものと一致することを確認しようとしています。このシーケンスは、ファイルの意図しない削除を防ぐのに役立ちます。"
    },
    {
      "indent": 15,
      "text": "PUTFH (directory filehandle) LOOKUP (file name) VERIFY (filehandle == fh) PUTFH (directory filehandle) REMOVE (file name)",
      "ja": "putfh（directory filehandle）lookup（file name）verify（filehandle == fh）putfh（directory filehandle）remover（file name）"
    },
    {
      "indent": 6,
      "text": "This sequence does not prevent a second client from removing and creating a new file in the middle of this sequence but it does help avoid the unintended result.",
      "ja": "このシーケンスは、2番目のクライアントがこのシーケンスの途中で新しいファイルを削除して作成することを妨げませんが、意図しない結果を回避するのに役立ちます。"
    },
    {
      "indent": 6,
      "text": "In the case that a recommended attribute is specified in the VERIFY operation and the server does not support that attribute for the file system object, the error NFS4ERR_NOTSUPP is returned to the client.",
      "ja": "推奨属性が検証操作で指定され、サーバーがファイルシステムオブジェクトのその属性をサポートしていない場合、エラーNFS4err_Notsuppはクライアントに返されます。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOTSUPP NFS4ERR_NOT_SAME NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC",
      "ja": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOTSUPP NFS4ERR_NOT_SAME NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC"
    },
    {
      "indent": 0,
      "text": "14.2.36. Operation 38: WRITE - Write to File",
      "section_title": true,
      "ja": "14.2.36. 操作38：書き込み - ファイルに書き込みます"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "(cfh), offset, count, stability, stateid, data -> count, committed, verifier",
      "ja": "（cfh）、offset、count、stability、stateid、data-> count、commited、verifier"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "enum stable_how4 { UNSTABLE4 = 0, DATA_SYNC4 = 1, FILE_SYNC4 = 2 };",
      "ja": "enum stable_how4 {unstable4 = 0、data_sync4 = 1、file_sync4 = 2};"
    },
    {
      "indent": 6,
      "text": "struct WRITE4args {\n        /* CURRENT_FH: file */\n        stateid4        stateid;\n        offset4         offset;\n        stable_how4     stable;\n        opaque          data<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct WRITE4resok {\n        count4          count;\n        stable_how4     committed;\n        verifier4       writeverf;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "union WRITE4res switch (nfsstat4 status) {\n case NFS4_OK:\n         WRITE4resok    resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The WRITE operation is used to write data to a regular file. The target file is specified by the current filehandle. The offset specifies the offset where the data should be written. An offset of 0 (zero) specifies that the write should start at the beginning of the file. The count represents the number of bytes of data that are to be written. If the count is 0 (zero), the WRITE will succeed and return a count of 0 (zero) subject to permissions checking. The server may choose to write fewer bytes than requested by the client.",
      "ja": "書き込み操作は、通常のファイルにデータを書き込むために使用されます。ターゲットファイルは、現在のファイルハンドルで指定されています。オフセットは、データを書き込む必要があるオフセットを指定します。0（ゼロ）のオフセットは、ファイルの先頭から書き込みが開始することを指定します。カウントは、記述されるデータのバイト数を表します。カウントが0（ゼロ）の場合、書き込みは成功し、許可チェックの対象となる0（ゼロ）のカウントを返します。サーバーは、クライアントが要求するよりも少ないバイトを書き込むことを選択できます。"
    },
    {
      "indent": 6,
      "text": "Part of the write request is a specification of how the write is to be performed. The client specifies with the stable parameter the method of how the data is to be processed by the server. If stable is FILE_SYNC4, the server must commit the data written plus all file system metadata to stable storage before returning results. This corresponds to the NFS version 2 protocol semantics. Any other behavior constitutes a protocol violation. If stable is DATA_SYNC4, then the server must commit all of the data to stable storage and enough of the metadata to retrieve the data before returning. The server implementor is free to implement DATA_SYNC4 in the same fashion as FILE_SYNC4, but with a possible performance drop. If stable is UNSTABLE4, the server is free to commit any part of the data and the metadata to stable storage, including all or none, before returning a reply to the client. There is no guarantee whether or when any uncommitted data will subsequently be committed to stable storage. The only guarantees made by the server are that it will not destroy any data without changing the value of verf and that it will not commit the data and metadata at a level less than that requested by the client.",
      "ja": "書き込み要求の一部は、書き込みの実行方法の仕様です。クライアントは、Stableパラメーターで、サーバーによってデータの処理方法の方法を指定します。StableがFILE_SYNC4の場合、サーバーは、結果を返す前に、記述されたデータとすべてのファイルシステムメタデータを安定したストレージにコミットする必要があります。これは、NFSバージョン2プロトコルセマンティクスに対応します。その他の動作は、プロトコル違反を構成します。Stableがdata_sync4の場合、サーバーはすべてのデータを安定したストレージと十分なメタデータにコミットする必要があります。サーバー実装者は、file_sync4と同じ方法でdata_sync4を無料で実装できますが、パフォーマンスが低下する可能性があります。Stableがunstable4の場合、サーバーは、クライアントへの返信を返す前に、データとメタデータの一部を安定したストレージに自由にコミットできます。その後、不可能なデータが安定したストレージにコミットされるかどうか、またはいついつでも保証はありません。サーバーによって行われた唯一の保証は、Verfの値を変更せずにデータを破壊せず、クライアントが要求したレベルよりも少ないレベルでデータとメタデータをコミットしないことです。"
    },
    {
      "indent": 6,
      "text": "The stateid returned from a previous record lock or share reservation request is provided as part of the argument. The stateid is used by the server to verify that the associated lock is still valid and to update lease timeouts for the client.",
      "ja": "StateIDは、以前のレコードロックまたは共有予約リクエストから返されたものが、引数の一部として提供されます。StateIDは、関連するロックがまだ有効であることを確認し、クライアントのタイムアウトのリースを更新するためにサーバーによって使用されます。"
    },
    {
      "indent": 6,
      "text": "Upon successful completion, the following results are returned. The count result is the number of bytes of data written to the file. The server may write fewer bytes than requested. If so, the actual number of bytes written starting at location, offset, is returned.",
      "ja": "正常に完了すると、次の結果が返されます。カウント結果は、ファイルに書き込まれたデータのバイト数です。サーバーは、要求されるよりも少ないバイトを書き込む場合があります。その場合、場所で開始されたオフセットから書き込まれた実際のバイト数が返されます。"
    },
    {
      "indent": 6,
      "text": "The server also returns an indication of the level of commitment of the data and metadata via committed. If the server committed all data and metadata to stable storage, committed should be set to FILE_SYNC4. If the level of commitment was at least as strong as DATA_SYNC4, then committed should be set to DATA_SYNC4. Otherwise, committed must be returned as UNSTABLE4. If stable was FILE4_SYNC, then committed must also be FILE_SYNC4: anything else constitutes a protocol violation. If stable was DATA_SYNC4, then committed may be FILE_SYNC4 or DATA_SYNC4: anything else constitutes a protocol violation. If stable was UNSTABLE4, then committed may be either FILE_SYNC4, DATA_SYNC4, or UNSTABLE4.",
      "ja": "サーバーは、コミットを介してデータとメタデータのコミットメントのレベルの兆候も返します。サーバーがすべてのデータとメタデータを安定したストレージにコミットした場合、コミットされたものはfile_sync4に設定する必要があります。コミットメントのレベルが少なくともdata_sync4と同じくらい強い場合、コミットされたものはdata_sync4に設定する必要があります。それ以外の場合は、コミットされたものはunstable4として返品する必要があります。Stableがfile4_syncである場合、コミットされたものもfile_sync4である必要があります。他のすべてはプロトコル違反を構成します。Stableがdata_sync4の場合、コミットされた場合、file_sync4またはdata_sync4：他のものはプロトコル違反を構成する場合があります。Stableがunstable4の場合、コミットされた場合は、file_sync4、data_sync4、またはunstable4のいずれかです。"
    },
    {
      "indent": 6,
      "text": "The final portion of the result is the write verifier, verf. The write verifier is a cookie that the client can use to determine whether the server has changed state between a call to WRITE and a subsequent call to either WRITE or COMMIT. This cookie must be consistent during a single instance of the NFS version 4 protocol service and must be unique between instances of the NFS version 4 protocol server, where uncommitted data may be lost.",
      "ja": "結果の最後の部分は、書き込み検証者であるVerfです。Write Verifierは、クライアントが使用して、サーバーが書き込みの呼び出しとその後の呼び出しの間に状態を変更したかどうかを判断するために使用できるCookieです。このCookieは、NFSバージョン4プロトコルサービスの単一のインスタンス中に一貫性がなければならず、コミットされていないデータが失われる可能性のあるNFSバージョン4プロトコルサーバーのインスタンス間で一意でなければなりません。"
    },
    {
      "indent": 6,
      "text": "If a client writes data to the server with the stable argument set to UNSTABLE4 and the reply yields a committed response of DATA_SYNC4 or UNSTABLE4, the client will follow up some time in the future with a COMMIT operation to synchronize outstanding asynchronous data and metadata with the server's stable storage, barring client error. It is possible that due to client crash or other error that a subsequent COMMIT will not be received by the server.",
      "ja": "クライアントがunstable4に設定された安定した引数を使用してサーバーにデータを書き込み、返信がdata_sync4またはunstable4のコミットされた応答を生成する場合、クライアントは、未解決の非同期データとメタデータを同期させるコミットオペレーションで将来的にフォローアップします。サーバーの安定したストレージ、クライアントエラーがない。クライアントのクラッシュまたはその他のエラーにより、サーバーがその後のコミットを受信しない可能性があります。"
    },
    {
      "indent": 6,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルはその値を保持します。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "It is possible for the server to write fewer than count bytes of data. In this case, the server should not return an error unless no data was written at all. If the server writes less than count bytes, the client should issue another WRITE to write the remaining data.",
      "ja": "サーバーがカウントバイトのデータよりも少ないと記述することができます。この場合、データがまったく記述されていない限り、サーバーはエラーを返すべきではありません。サーバーがカウントバイト未満の書き込みの場合、クライアントは残りのデータを書き込むために別の書き込みを発行する必要があります。"
    },
    {
      "indent": 6,
      "text": "It is assumed that the act of writing data to a file will cause the time_modified of the file to be updated. However, the time_modified of the file should not be changed unless the contents of the file are changed. Thus, a WRITE request with count set to 0 should not cause the time_modified of the file to be updated.",
      "ja": "ファイルにデータを書き込む行為により、ファイルのtime_modifiedが更新されると想定されています。ただし、ファイルの内容が変更されない限り、ファイルのtime_modifiedを変更しないでください。したがって、カウントを0に設定した書き込み要求は、ファイルのtime_modifiedを更新してはなりません。"
    },
    {
      "indent": 6,
      "text": "The definition of stable storage has been historically a point of contention. The following expected properties of stable storage may help in resolving design issues in the implementation. Stable storage is persistent storage that survives:",
      "ja": "安定したストレージの定義は、歴史的に競合のポイントでした。安定したストレージの以下の予想される特性は、実装の設計問題の解決に役立つ場合があります。安定したストレージは、生き残る永続的なストレージです："
    },
    {
      "indent": 15,
      "text": "1. Repeated power failures. 2. Hardware failures (of any board, power supply, etc.). 3. Repeated software crashes, including reboot cycle.",
      "ja": "1. 繰り返し電源障害。2.（ボード、電源など）ハードウェアの障害。3.再起動サイクルを含む繰り返しのソフトウェアクラッシュ。"
    },
    {
      "indent": 6,
      "text": "This definition does not address failure of the stable storage module itself.",
      "ja": "この定義は、安定したストレージモジュール自体の障害に対処しません。"
    },
    {
      "indent": 6,
      "text": "The verifier is defined to allow a client to detect different instances of an NFS version 4 protocol server over which cached, uncommitted data may be lost. In the most likely case, the verifier allows the client to detect server reboots. This information is required so that the client can safely determine whether the server could have lost cached data. If the server fails unexpectedly and the client has uncommitted data from previous WRITE requests (done with the stable argument set to UNSTABLE4 and in which the result committed was returned as UNSTABLE4 as well) it may not have flushed cached data to stable storage. The burden of recovery is on the client and the client will need to retransmit the data to the server.",
      "ja": "検証器は、クライアントがキャッシュされた、コミットされていないデータが失われる可能性があるNFSバージョン4プロトコルサーバーのさまざまなインスタンスを検出できるように定義されています。最も可能性の高い場合、検証剤により、クライアントはサーバーの再起動を検出できます。この情報は、クライアントがサーバーがキャッシュされたデータを失う可能性があるかどうかを安全に判断できるように必要です。サーバーが予期せずに失敗し、クライアントが以前の書き込みリクエストからコミットされていないデータを持っている場合（unstable4に設定された安定した引数で行われ、コミットされた結果もunstable4として返されました）。回復の負担はクライアントにあり、クライアントはデータをサーバーに再送信する必要があります。"
    },
    {
      "indent": 6,
      "text": "A suggested verifier would be to use the time that the server was booted or the time the server was last started (if restarting the server without a reboot results in lost buffers).",
      "ja": "推奨される検証者は、サーバーが起動された時間またはサーバーが最後に開始された時間を使用することです（再起動せずにサーバーを再起動すると、バッファが失われます）。"
    },
    {
      "indent": 6,
      "text": "The committed field in the results allows the client to do more effective caching. If the server is committing all WRITE requests to stable storage, then it should return with committed set to FILE_SYNC4, regardless of the value of the stable field in the arguments. A server that uses an NVRAM accelerator may choose to implement this policy. The client can use this to increase the effectiveness of the cache by discarding cached data that has already been committed on the server.",
      "ja": "結果のコミットされた分野により、クライアントはより効果的なキャッシュを行うことができます。サーバーがすべての書き込み要求を安定したストレージにコミットしている場合、引数内の安定したフィールドの値に関係なく、コミットされたセットをFILE_SYNC4に導入して返す必要があります。NVRAMアクセラレータを使用するサーバーは、このポリシーを実装することを選択できます。クライアントは、これを使用して、サーバーで既にコミットされているキャッシュデータを破棄することにより、キャッシュの有効性を高めることができます。"
    },
    {
      "indent": 6,
      "text": "Some implementations may return NFS4ERR_NOSPC instead of NFS4ERR_DQUOT when a user's quota is exceeded.",
      "ja": "一部の実装では、ユーザーのクォータを超えたときにNFS4err_Dquotの代わりにNFS4err_NoSpcを返す場合があります。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_DELAY NFS4ERR_DENIED NFS4ERR_DQUOT NFS4ERR_EXPIRED NFS4ERR_FBIG NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_LEASE_MOVED NFS4ERR_LOCKED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID NFS4ERR_WRONGSEC",
      "ja": "NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_DELAY NFS4ERR_DENIED NFS4ERR_DQUOT NFS4ERR_EXPIRED NFS4ERR_FBIG NFS4ERR_FHEXPERS4ERR_GRACE NFS4SERR_INBDEREX4ERR_INFS4ERFERED4ERFERED4ERFER_INFS4ERFER_INFS4IR_INBID4ERBER _LOCKED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID NFS4RS4err_Wronsece"
    },
    {
      "indent": 0,
      "text": "15. NFS Version 4 Callback Procedures",
      "section_title": true,
      "ja": "15. NFSバージョン4コールバック手順"
    },
    {
      "indent": 3,
      "text": "The procedures used for callbacks are defined in the following sections. In the interest of clarity, the terms \"client\" and \"server\" refer to NFS clients and servers, despite the fact that for an individual callback RPC, the sense of these terms would be precisely the opposite.",
      "ja": "コールバックに使用される手順は、次のセクションで定義されています。明確にするために、「クライアント」と「サーバー」という用語は、個々のコールバックRPCの場合、これらの用語の感覚がまったく逆になるという事実にもかかわらず、NFSクライアントとサーバーを指します。"
    },
    {
      "indent": 0,
      "text": "15.1. Procedure 0: CB_NULL - No Operation",
      "section_title": true,
      "ja": "15.1. 手順0：CB_NULL-操作なし"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "<null>",
      "ja": "<null>"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "void;",
      "ja": "空所;"
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "void;",
      "ja": "空所;"
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "Standard NULL procedure. Void argument, void response. Even though there is no direct functionality associated with this procedure, the server will use CB_NULL to confirm the existence of a path for RPCs from server to client.",
      "ja": "標準のヌル手順。空の引数、無効な応答。この手順に関連する直接的な機能はありませんが、サーバーはCB_NULLを使用して、サーバーからクライアントへのRPCのパスの存在を確認します。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "None.",
      "ja": "なし。"
    },
    {
      "indent": 0,
      "text": "15.2. Procedure 1: CB_COMPOUND - Compound Operations",
      "section_title": true,
      "ja": "15.2. 手順1：CB_COMPOUND-化合物操作"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "compoundargs -> compoundres",
      "ja": "compountargs-> compounters"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "enum nfs_cb_opnum4 {\n        OP_CB_GETATTR           = 3,\n        OP_CB_RECALL            = 4 };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "union nfs_cb_argop4 switch (unsigned argop) {\n case OP_CB_GETATTR:    CB_GETATTR4args opcbgetattr;\n case OP_CB_RECALL:     CB_RECALL4args  opcbrecall; };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct CB_COMPOUND4args {\n        utf8string      tag;\n        uint32_t        minorversion;\n        nfs_cb_argop4   argarray<>; };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "union nfs_cb_resop4 switch (unsigned resop){\n case OP_CB_GETATTR:    CB_GETATTR4res  opcbgetattr;\n case OP_CB_RECALL:     CB_RECALL4res   opcbrecall; };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct CB_COMPOUND4res {\n        nfsstat4 status;\n        utf8string      tag;\n        nfs_cb_resop4   resarray<>; };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The CB_COMPOUND procedure is used to combine one or more of the callback procedures into a single RPC request. The main callback RPC program has two main procedures: CB_NULL and CB_COMPOUND. All other operations use the CB_COMPOUND procedure as a wrapper.",
      "ja": "CB_COMPOUND手順は、1つ以上のコールバック手順を単一のRPC要求に組み合わせるために使用されます。メインコールバックRPCプログラムには、CB_NULLとCB_COMPOUNDの2つの主な手順があります。他のすべての操作は、cb_compound手順をラッパーとして使用します。"
    },
    {
      "indent": 6,
      "text": "In the processing of the CB_COMPOUND procedure, the client may find that it does not have the available resources to execute any or all of the operations within the CB_COMPOUND sequence. In this case, the error NFS4ERR_RESOURCE will be returned for the particular operation within the CB_COMPOUND procedure where the resource exhaustion occurred. This assumes that all previous operations within the CB_COMPOUND sequence have been evaluated successfully.",
      "ja": "CB_COMPOUND手順の処理では、クライアントは、CB_COMPOUNDシーケンス内の操作のいずれかまたはすべてを実行するための利用可能なリソースがないことを発見する場合があります。この場合、エラーNFS4err_Resourceは、リソースの使い果たしが発生したCB_COMPOUND手順内の特定の操作のために返されます。これは、CB_COMPOUNDシーケンス内の以前のすべての操作が正常に評価されていることを前提としています。"
    },
    {
      "indent": 6,
      "text": "Contained within the CB_COMPOUND results is a 'status' field. This status must be equivalent to the status of the last operation that was executed within the CB_COMPOUND procedure. Therefore, if an operation incurred an error then the 'status' value will be the same error value as is being returned for the operation that failed.",
      "ja": "CB_Compound結果に含まれるのは、「ステータス」フィールドです。このステータスは、CB_Compound手順内で実行された最後の操作のステータスに相当する必要があります。したがって、操作がエラーが発生した場合、「ステータス」値は、失敗した操作に対して返されているエラー値と同じです。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "The CB_COMPOUND procedure is used to combine individual operations into a single RPC request. The client interprets each of the operations in turn. If an operation is executed by the client and the status of that operation is NFS4_OK, then the next operation in the CB_COMPOUND procedure is executed. The client continues this process until there are no more operations to be executed or one of the operations has a status value other than NFS4_OK.",
      "ja": "CB_Compound手順は、個々の操作を単一のRPC要求に結合するために使用されます。クライアントは、各操作を順番に解釈します。操作がクライアントによって実行され、その操作のステータスがNFS4_OKである場合、CB_Compound手順の次の操作が実行されます。クライアントは、実行する操作がなくなるか、操作のいずれかがNFS4_OK以外のステータス値を持つまで、このプロセスを継続します。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_RESOURCE",
      "ja": "nfs4err_badhandle nfs4err_bad_stateid nfs4err_resource"
    },
    {
      "indent": 0,
      "text": "15.2.1. Operation 3: CB_GETATTR - Get Attributes",
      "section_title": true,
      "ja": "15.2.1. 操作3：CB_GETATTR-属性を取得します"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "fh, attrbits -> attrbits, attrvals",
      "ja": "FH、属性 - >アトリビット、アトルバル"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "struct CB_GETATTR4args {\n        nfs_fh4 fh;\n        bitmap4 attr_request;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct CB_GETATTR4resok { fattr4 obj_attributes; };",
      "ja": "struct cb_getattr4resok {fattr4 obj_attributes;};"
    },
    {
      "indent": 6,
      "text": "union CB_GETATTR4res switch (nfsstat4 status) {\n case NFS4_OK:\n         CB_GETATTR4resok       resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The CB_GETATTR operation is used to obtain the attributes modified by an open delegate to allow the server to respond to GETATTR requests for a file which is the subject of an open delegation.",
      "ja": "CB_GETATTR操作は、オープンデリゲートによって変更された属性を取得するために使用され、サーバーがオープン代表団の主題であるファイルのGetATTR要求に応答できるようにします。"
    },
    {
      "indent": 6,
      "text": "If the handle specified is not one for which the client holds a write open delegation, an NFS4ERR_BADHANDLE error is returned.",
      "ja": "指定されたハンドルが、クライアントが書き込みオープン代表団を保持しているものではない場合、NFS4err_Badhandleエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "The client returns attrbits and the associated attribute values only for attributes that it may change (change, time_modify, object_size).",
      "ja": "クライアントは、変更が変更される可能性のある属性に対してのみ属性と関連する属性値を返します（変更、time_modify、object_size）。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_BADHANDLE NFS4ERR_RESOURCE",
      "ja": "nfs4err_badhandle nfs4err_resource"
    },
    {
      "indent": 0,
      "text": "15.2.2. Operation 4: CB_RECALL - Recall an Open Delegation",
      "section_title": true,
      "ja": "15.2.2. 操作4：CB_Recall-オープン代表団を思い出してください"
    },
    {
      "indent": 3,
      "text": "SYNOPSIS",
      "ja": "概要"
    },
    {
      "indent": 6,
      "text": "stateid, truncate, fh -> status",
      "ja": "STATEID、TRUNCATE、FH->ステータス"
    },
    {
      "indent": 3,
      "text": "ARGUMENT",
      "ja": "口論"
    },
    {
      "indent": 6,
      "text": "struct CB_RECALL4args {\n        stateid4        stateid;\n        bool            truncate;\n        nfs_fh4         fh;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RESULT",
      "ja": "結果"
    },
    {
      "indent": 6,
      "text": "struct CB_RECALL4res { nfsstat4 status; };",
      "ja": "struct cb_recall4res {nfsstat4 status;};"
    },
    {
      "indent": 3,
      "text": "DESCRIPTION",
      "ja": "説明"
    },
    {
      "indent": 6,
      "text": "The CB_RECALL operation is used to begin the process of recalling an open delegation and returning it to the server.",
      "ja": "CB_Recall操作は、オープンな代表団をリコールしてサーバーに戻すプロセスを開始するために使用されます。"
    },
    {
      "indent": 6,
      "text": "The truncate flag is used to optimize recall for a file which is about to be truncated to zero. When it is set, the client is freed of obligation to propagate modified data for the file to the server, since this data is irrelevant.",
      "ja": "切り捨てられたフラグは、ゼロに切り捨てようとしているファイルのリコールを最適化するために使用されます。設定されると、クライアントは、このデータが無関係であるため、ファイルの変更されたデータをサーバーに伝播する義務が解放されます。"
    },
    {
      "indent": 6,
      "text": "If the handle specified is not one for which the client holds an open delegation, an NFS4ERR_BADHANDLE error is returned.",
      "ja": "指定されたハンドルがクライアントがオープンな代表団を保持しているものではない場合、NFS4err_badhandleエラーが返されます。"
    },
    {
      "indent": 6,
      "text": "If the stateid specified is not one corresponding to an open delegation for the file specified by the filehandle, an NFS4ERR_BAD_STATEID is returned.",
      "ja": "指定されたStateIDが、FileHandleによって指定されたファイルのオープン代表団に対応していない場合、NFS4err_Bad_StateIDが返されます。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION",
      "ja": "実装"
    },
    {
      "indent": 6,
      "text": "The client should reply to the callback immediately. Replying does not complete the recall. The recall is not complete until the delegation is returned using a DELEGRETURN.",
      "ja": "クライアントはすぐにコールバックに返信する必要があります。返信はリコールを完了しません。削除を使用して代表団が返されるまで、リコールは完全ではありません。"
    },
    {
      "indent": 3,
      "text": "ERRORS",
      "ja": "エラー"
    },
    {
      "indent": 6,
      "text": "NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_RESOURCE",
      "ja": "nfs4err_badhandle nfs4err_bad_stateid nfs4err_resource"
    },
    {
      "indent": 0,
      "text": "16. Security Considerations",
      "section_title": true,
      "ja": "16. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The major security feature to consider is the authentication of the user making the request of NFS service. Consideration should also be given to the integrity and privacy of this NFS request. These specific issues are discussed as part of the section on \"RPC and Security Flavor\".",
      "ja": "考慮すべき主なセキュリティ機能は、NFSサービスのリクエストを行うユーザーの認証です。また、このNFSリクエストの整合性とプライバシーを考慮する必要があります。これらの特定の問題は、「RPCとセキュリティフレーバー」に関するセクションの一部として説明されています。"
    },
    {
      "indent": 0,
      "text": "17. IANA Considerations",
      "section_title": true,
      "ja": "17. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "17.1. Named Attribute Definition",
      "section_title": true,
      "ja": "17.1. 名前付き属性定義"
    },
    {
      "indent": 3,
      "text": "The NFS version 4 protocol provides for the association of named attributes to files. The name space identifiers for these attributes are defined as string names. The protocol does not define the specific assignment of the name space for these file attributes; the application developer or system vendor is allowed to define the attribute, its semantics, and the associated name. Even though this name space will not be specifically controlled to prevent collisions, the application developer or system vendor is strongly encouraged to provide the name assignment and associated semantics for attributes via an Informational RFC. This will provide for interoperability where common interests exist.",
      "ja": "NFSバージョン4プロトコルは、名前付き属性とファイルへの関連付けを提供します。これらの属性の名前空間識別子は、文字列名として定義されます。プロトコルは、これらのファイル属性の名前空間の特定の割り当てを定義しません。アプリケーション開発者またはシステムベンダーは、属性、そのセマンティクス、および関連する名前を定義することができます。この名前のスペースは衝突を防ぐために具体的に制御されませんが、アプリケーション開発者またはシステムベンダーは、情報RFCを介して属性の名前の割り当てと関連するセマンティクスを提供することを強くお勧めします。これにより、共通の利益が存在する場合の相互運用性が提供されます。"
    },
    {
      "indent": 0,
      "text": "18. RPC definition file",
      "section_title": true,
      "ja": "18. RPC定義ファイル"
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (C) The Internet Society (1998,1999,2000).\n *  All Rights Reserved.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *      nfs4_prot.x\n *\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "%#pragma ident  \"@(#)nfs4_prot.x        1.97    00/06/12\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Basic typedefs for RFC 1832 data type definitions\n */\ntypedef int             int32_t;\ntypedef unsigned int    uint32_t;\ntypedef hyper           int64_t;\ntypedef unsigned hyper  uint64_t;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Sizes\n */\nconst NFS4_FHSIZE               = 128;\nconst NFS4_VERIFIER_SIZE        = 8;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * File types\n */\nenum nfs_ftype4 {\n        NF4REG          = 1,    /* Regular File */\n        NF4DIR          = 2,    /* Directory */\n        NF4BLK          = 3,    /* Special File - block device */\n        NF4CHR          = 4,    /* Special File - character device */\n        NF4LNK          = 5,    /* Symbolic Link */\n        NF4SOCK         = 6,    /* Special File - socket */\n        NF4FIFO         = 7,    /* Special File - fifo */\n        NF4ATTRDIR      = 8,    /* Attribute Directory */\n        NF4NAMEDATTR    = 9     /* Named Attribute */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Error status\n */\nenum nfsstat4 {\n        NFS4_OK                 = 0,\n           NFS4ERR_PERM            = 1,\n        NFS4ERR_NOENT           = 2,\n        NFS4ERR_IO              = 5,\n        NFS4ERR_NXIO            = 6,\n        NFS4ERR_ACCES           = 13,\n        NFS4ERR_EXIST           = 17,\n        NFS4ERR_XDEV            = 18,\n        NFS4ERR_NODEV           = 19,\n        NFS4ERR_NOTDIR          = 20,\n        NFS4ERR_ISDIR           = 21,\n        NFS4ERR_INVAL           = 22,\n        NFS4ERR_FBIG            = 27,\n        NFS4ERR_NOSPC           = 28,\n        NFS4ERR_ROFS            = 30,\n        NFS4ERR_MLINK           = 31,\n        NFS4ERR_NAMETOOLONG     = 63,\n        NFS4ERR_NOTEMPTY        = 66,\n        NFS4ERR_DQUOT           = 69,\n        NFS4ERR_STALE           = 70,\n        NFS4ERR_BADHANDLE       = 10001,\n        NFS4ERR_BAD_COOKIE      = 10003,\n        NFS4ERR_NOTSUPP         = 10004,\n        NFS4ERR_TOOSMALL        = 10005,\n        NFS4ERR_SERVERFAULT     = 10006,\n        NFS4ERR_BADTYPE         = 10007,\n        NFS4ERR_DELAY           = 10008,\n        NFS4ERR_SAME            = 10009,/* nverify says attrs same */\n        NFS4ERR_DENIED          = 10010,/* lock unavailable        */\n        NFS4ERR_EXPIRED         = 10011,/* lock lease expired      */\n        NFS4ERR_LOCKED          = 10012,/* I/O failed due to lock  */\n        NFS4ERR_GRACE           = 10013,/* in grace period         */\n        NFS4ERR_FHEXPIRED       = 10014,/* file handle expired     */\n        NFS4ERR_SHARE_DENIED    = 10015,/* share reserve denied    */\n        NFS4ERR_WRONGSEC        = 10016,/* wrong security flavor   */\n        NFS4ERR_CLID_INUSE      = 10017,/* clientid in use         */\n        NFS4ERR_RESOURCE        = 10018,/* resource exhaustion     */\n        NFS4ERR_MOVED           = 10019,/* filesystem relocated    */\n        NFS4ERR_NOFILEHANDLE    = 10020,/* current FH is not set   */\n        NFS4ERR_MINOR_VERS_MISMATCH = 10021,/* minor vers not supp */\n        NFS4ERR_STALE_CLIENTID  = 10022,\n        NFS4ERR_STALE_STATEID   = 10023,\n        NFS4ERR_OLD_STATEID     = 10024,\n        NFS4ERR_BAD_STATEID     = 10025,\n        NFS4ERR_BAD_SEQID       = 10026,\n        NFS4ERR_NOT_SAME        = 10027,/* verify - attrs not same */\n        NFS4ERR_LOCK_RANGE      = 10028,\n        NFS4ERR_SYMLINK         = 10029,\n        NFS4ERR_READDIR_NOSPC   = 10030,\n           NFS4ERR_LEASE_MOVED     = 10031\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Basic data types\n */\ntypedef uint32_t        bitmap4<>;\ntypedef uint64_t        offset4;\ntypedef uint32_t        count4;\ntypedef uint64_t        length4;\ntypedef uint64_t        clientid4;\ntypedef uint64_t        stateid4;\ntypedef uint32_t        seqid4;\ntypedef opaque          utf8string<>;\ntypedef utf8string      component4;\ntypedef component4      pathname4<>;\ntypedef uint64_t        nfs_lockid4;\ntypedef uint64_t        nfs_cookie4;\ntypedef utf8string      linktext4;\ntypedef opaque          sec_oid4<>;\ntypedef uint32_t        qop4;\ntypedef uint32_t        mode4;\ntypedef uint64_t        changeid4;\ntypedef opaque          verifier4[NFS4_VERIFIER_SIZE];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Timeval\n */\nstruct nfstime4 {\n        int64_t         seconds;\n        uint32_t        nseconds;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum time_how4 { SET_TO_SERVER_TIME4 = 0, SET_TO_CLIENT_TIME4 = 1 };",
      "ja": "enum time_how4 {set_to_server_time4 = 0、set_to_client_time4 = 1};"
    },
    {
      "indent": 3,
      "text": "union settime4 switch (time_how4 set_it) {\n case SET_TO_CLIENT_TIME4:\n         nfstime4       time;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * File access handle\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef opaque  nfs_fh4<NFS4_FHSIZE>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * File attribute definitions\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * FSID structure for major/minor\n */\nstruct fsid4 {\n        uint64_t        major;\n        uint64_t        minor;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Filesystem locations attribute for relocation/migration\n */\nstruct fs_location4 {\n        utf8string      server<>;\n        pathname4       rootpath;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct fs_locations4 {\n        pathname4       fs_root;\n        fs_location4    locations<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Various Access Control Entry definitions\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Mask that indicates which Access Control Entries are supported.\n * Values for the fattr4_aclsupport attribute.\n */\nconst ACL4_SUPPORT_ALLOW_ACL    = 0x00000001;\nconst ACL4_SUPPORT_DENY_ACL     = 0x00000002;\nconst ACL4_SUPPORT_AUDIT_ACL    = 0x00000004;\nconst ACL4_SUPPORT_ALARM_ACL    = 0x00000008;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef uint32_t acetype4;",
      "ja": "typedef uint32_t acetype4;"
    },
    {
      "indent": 3,
      "text": "/*\n * acetype4 values, others can be added as needed.\n */\nconst ACE4_ACCESS_ALLOWED_ACE_TYPE      = 0x00000000;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const ACE4_ACCESS_DENIED_ACE_TYPE       = 0x00000001;\nconst ACE4_SYSTEM_AUDIT_ACE_TYPE        = 0x00000002;\nconst ACE4_SYSTEM_ALARM_ACE_TYPE        = 0x00000003;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * ACE flag\n */\ntypedef uint32_t aceflag4;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * ACE flag values\n */\nconst ACE4_FILE_INHERIT_ACE             = 0x00000001;\nconst ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;\nconst ACE4_NO_PROPAGATE_INHERIT_ACE     = 0x00000004;\nconst ACE4_INHERIT_ONLY_ACE             = 0x00000008;\nconst ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;\nconst ACE4_FAILED_ACCESS_ACE_FLAG       = 0x00000020;\nconst ACE4_IDENTIFIER_GROUP             = 0x00000040;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * ACE mask\n */\ntypedef uint32_t        acemask4;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * ACE mask values\n */\nconst ACE4_READ_DATA            = 0x00000001;\nconst ACE4_LIST_DIRECTORY       = 0x00000001;\nconst ACE4_WRITE_DATA           = 0x00000002;\nconst ACE4_ADD_FILE             = 0x00000002;\nconst ACE4_APPEND_DATA          = 0x00000004;\nconst ACE4_ADD_SUBDIRECTORY     = 0x00000004;\nconst ACE4_READ_NAMED_ATTRS     = 0x00000008;\nconst ACE4_WRITE_NAMED_ATTRS    = 0x00000010;\nconst ACE4_EXECUTE              = 0x00000020;\nconst ACE4_DELETE_CHILD         = 0x00000040;\nconst ACE4_READ_ATTRIBUTES      = 0x00000080;\nconst ACE4_WRITE_ATTRIBUTES     = 0x00000100;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const ACE4_DELETE               = 0x00010000;\nconst ACE4_READ_ACL             = 0x00020000;\nconst ACE4_WRITE_ACL            = 0x00040000;\nconst ACE4_WRITE_OWNER          = 0x00080000;\nconst ACE4_SYNCHRONIZE          = 0x00100000;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * ACE4_GENERIC_READ -- defined as combination of\n *      ACE4_READ_ACL |\n *      ACE4_READ_DATA |\n *      ACE4_READ_ATTRIBUTES |\n *      ACE4_SYNCHRONIZE\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const ACE4_GENERIC_READ = 0x00120081;",
      "ja": "const ace4_generic_read = 0x00120081;"
    },
    {
      "indent": 3,
      "text": "/*\n * ACE4_GENERIC_WRITE -- defined as combination of\n *      ACE4_READ_ACL |\n *      ACE4_WRITE_DATA |\n *      ACE4_WRITE_ATTRIBUTES |\n *      ACE4_WRITE_ACL |\n *      ACE4_APPEND_DATA |\n *      ACE4_SYNCHRONIZE\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const ACE4_GENERIC_WRITE = 0x00160106;",
      "ja": "const ace4_generic_write = 0x00160106;"
    },
    {
      "indent": 3,
      "text": "/*\n * ACE4_GENERIC_EXECUTE -- defined as combination of\n *      ACE4_READ_ACL\n *      ACE4_READ_ATTRIBUTES\n *      ACE4_EXECUTE\n *      ACE4_SYNCHRONIZE\n */\nconst ACE4_GENERIC_EXECUTE = 0x001200A0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Access Control Entry definition\n */\nstruct nfsace4 {\n        acetype4        type;\n        aceflag4        flag;\n        acemask4        access_mask;\n        utf8string      who;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Special data/attribute associated with\n * file types NF4BLK and NF4CHR.\n */\nstruct specdata4 {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        uint32_t        specdata1;\n        uint32_t        specdata2;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Values for fattr4_fh_expire_type\n */\nconst   FH4_PERSISTENT          = 0x00000000;\nconst   FH4_NOEXPIRE_WITH_OPEN  = 0x00000001;\nconst   FH4_VOLATILE_ANY        = 0x00000002;\nconst   FH4_VOL_MIGRATION       = 0x00000004;\nconst   FH4_VOL_RENAME          = 0x00000008;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef bitmap4         fattr4_supported_attrs;\ntypedef nfs_ftype4      fattr4_type;\ntypedef uint32_t        fattr4_fh_expire_type;\ntypedef changeid4       fattr4_change;\ntypedef uint64_t        fattr4_size;\ntypedef bool            fattr4_link_support;\ntypedef bool            fattr4_symlink_support;\ntypedef bool            fattr4_named_attr;\ntypedef fsid4           fattr4_fsid;\ntypedef bool            fattr4_unique_handles;\ntypedef uint32_t        fattr4_lease_time;\ntypedef nfsstat4        fattr4_rdattr_error;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef nfsace4         fattr4_acl<>;\ntypedef uint32_t        fattr4_aclsupport;\ntypedef bool            fattr4_archive;\ntypedef bool            fattr4_cansettime;\ntypedef bool            fattr4_case_insensitive;\ntypedef bool            fattr4_case_preserving;\ntypedef bool            fattr4_chown_restricted;\ntypedef uint64_t        fattr4_fileid;\ntypedef uint64_t        fattr4_files_avail;\ntypedef nfs_fh4         fattr4_filehandle;\ntypedef uint64_t        fattr4_files_free;\ntypedef uint64_t        fattr4_files_total;\ntypedef fs_locations4   fattr4_fs_locations;\ntypedef bool            fattr4_hidden;\ntypedef bool            fattr4_homogeneous;\ntypedef uint64_t        fattr4_maxfilesize;\ntypedef uint32_t        fattr4_maxlink;\ntypedef uint32_t        fattr4_maxname;\ntypedef uint64_t        fattr4_maxread;\ntypedef uint64_t        fattr4_maxwrite;\ntypedef utf8string      fattr4_mimetype;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef mode4           fattr4_mode;\ntypedef bool            fattr4_no_trunc;\ntypedef uint32_t        fattr4_numlinks;\ntypedef utf8string      fattr4_owner;\ntypedef utf8string      fattr4_owner_group;\ntypedef uint64_t        fattr4_quota_avail_hard;\ntypedef uint64_t        fattr4_quota_avail_soft;\ntypedef uint64_t        fattr4_quota_used;\ntypedef specdata4       fattr4_rawdev;\ntypedef uint64_t        fattr4_space_avail;\ntypedef uint64_t        fattr4_space_free;\ntypedef uint64_t        fattr4_space_total;\ntypedef uint64_t        fattr4_space_used;\ntypedef bool            fattr4_system;\ntypedef nfstime4        fattr4_time_access;\ntypedef settime4        fattr4_time_access_set;\ntypedef nfstime4        fattr4_time_backup;\ntypedef nfstime4        fattr4_time_create;\ntypedef nfstime4        fattr4_time_delta;\ntypedef nfstime4        fattr4_time_metadata;\ntypedef nfstime4        fattr4_time_modify;\ntypedef settime4        fattr4_time_modify_set;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Mandatory Attributes\n */\nconst FATTR4_SUPPORTED_ATTRS    = 0;\nconst FATTR4_TYPE               = 1;\nconst FATTR4_FH_EXPIRE_TYPE     = 2;\nconst FATTR4_CHANGE             = 3;\nconst FATTR4_SIZE               = 4;\nconst FATTR4_LINK_SUPPORT       = 5;\nconst FATTR4_SYMLINK_SUPPORT    = 6;\nconst FATTR4_NAMED_ATTR         = 7;\nconst FATTR4_FSID               = 8;\nconst FATTR4_UNIQUE_HANDLES     = 9;\nconst FATTR4_LEASE_TIME         = 10;\nconst FATTR4_RDATTR_ERROR       = 11;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Recommended Attributes\n */\nconst FATTR4_ACL                = 12;\nconst FATTR4_ACLSUPPORT         = 13;\nconst FATTR4_ARCHIVE            = 14;\nconst FATTR4_CANSETTIME         = 15;\nconst FATTR4_CASE_INSENSITIVE   = 16;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const FATTR4_CASE_PRESERVING    = 17;\nconst FATTR4_CHOWN_RESTRICTED   = 18;\nconst FATTR4_FILEHANDLE         = 19;\nconst FATTR4_FILEID             = 20;\nconst FATTR4_FILES_AVAIL        = 21;\nconst FATTR4_FILES_FREE         = 22;\nconst FATTR4_FILES_TOTAL        = 23;\nconst FATTR4_FS_LOCATIONS       = 24;\nconst FATTR4_HIDDEN             = 25;\nconst FATTR4_HOMOGENEOUS        = 26;\nconst FATTR4_MAXFILESIZE        = 27;\nconst FATTR4_MAXLINK            = 28;\nconst FATTR4_MAXNAME            = 29;\nconst FATTR4_MAXREAD            = 30;\nconst FATTR4_MAXWRITE           = 31;\nconst FATTR4_MIMETYPE           = 32;\nconst FATTR4_MODE               = 33;\nconst FATTR4_NO_TRUNC           = 34;\nconst FATTR4_NUMLINKS           = 35;\nconst FATTR4_OWNER              = 36;\nconst FATTR4_OWNER_GROUP        = 37;\nconst FATTR4_QUOTA_AVAIL_HARD   = 38;\nconst FATTR4_QUOTA_AVAIL_SOFT   = 39;\nconst FATTR4_QUOTA_USED         = 40;\nconst FATTR4_RAWDEV             = 41;\nconst FATTR4_SPACE_AVAIL        = 42;\nconst FATTR4_SPACE_FREE         = 43;\nconst FATTR4_SPACE_TOTAL        = 44;\nconst FATTR4_SPACE_USED         = 45;\nconst FATTR4_SYSTEM             = 46;\nconst FATTR4_TIME_ACCESS        = 47;\nconst FATTR4_TIME_ACCESS_SET    = 48;\nconst FATTR4_TIME_BACKUP        = 49;\nconst FATTR4_TIME_CREATE        = 50;\nconst FATTR4_TIME_DELTA         = 51;\nconst FATTR4_TIME_METADATA      = 52;\nconst FATTR4_TIME_MODIFY        = 53;\nconst FATTR4_TIME_MODIFY_SET    = 54;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef opaque  attrlist4<>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * File attribute container\n */\nstruct fattr4 {\n        bitmap4         attrmask;\n        attrlist4       attr_vals;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "};",
      "ja": "};"
    },
    {
      "indent": 3,
      "text": "/*\n * Change info for the client\n */\nstruct change_info4 {\n        bool            atomic;\n        changeid4       before;\n        changeid4       after;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct clientaddr4 {\n        /* see struct rpcb in RFC 1833 */\n        string r_netid<>;               /* network id */\n        string r_addr<>;                /* universal address */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Callback program info as provided by the client\n */\nstruct cb_client4 {\n        unsigned int    cb_program;\n        clientaddr4     cb_location;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Client ID\n */\nstruct nfs_client_id4 {\n        verifier4       verifier;\n        opaque          id<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct nfs_lockowner4 {\n        clientid4       clientid;\n        opaque          owner<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum nfs_lock_type4 {\n        READ_LT         = 1,\n        WRITE_LT        = 2,\n        READW_LT        = 3,    /* blocking read */\n        WRITEW_LT       = 4     /* blocking write */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * ACCESS: Check access permission\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const ACCESS4_READ      = 0x00000001;\nconst ACCESS4_LOOKUP    = 0x00000002;\nconst ACCESS4_MODIFY    = 0x00000004;\nconst ACCESS4_EXTEND    = 0x00000008;\nconst ACCESS4_DELETE    = 0x00000010;\nconst ACCESS4_EXECUTE   = 0x00000020;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct ACCESS4args {\n        /* CURRENT_FH: object */\n        uint32_t        access;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct ACCESS4resok {\n        uint32_t        supported;\n        uint32_t        access;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union ACCESS4res switch (nfsstat4 status) {\n case NFS4_OK:\n         ACCESS4resok   resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * CLOSE: Close a file and release share locks\n */\nstruct CLOSE4args {\n        /* CURRENT_FH: object */\n        seqid4          seqid;\n        stateid4        stateid;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union CLOSE4res switch (nfsstat4 status) {\n case NFS4_OK:\n         stateid4       stateid;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * COMMIT: Commit cached data on server to stable storage\n */\nstruct COMMIT4args {\n        /* CURRENT_FH: file */\n        offset4         offset;\n        count4          count;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct COMMIT4resok { verifier4 writeverf; };",
      "ja": "struct commit4resok {verifier4 writeverf;};"
    },
    {
      "indent": 3,
      "text": "union COMMIT4res switch (nfsstat4 status) {\n case NFS4_OK:\n         COMMIT4resok   resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * CREATE: Create a file\n */\nunion createtype4 switch (nfs_ftype4 type) {\n case NF4LNK:\n         linktext4      linkdata;\n case NF4BLK:\n case NF4CHR:\n         specdata4      devdata;\n case NF4SOCK:\n case NF4FIFO:\n case NF4DIR:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct CREATE4args {\n        /* CURRENT_FH: directory for creation */\n        component4      objname;\n        createtype4     objtype;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct CREATE4resok { change_info4 cinfo; };",
      "ja": "struct create4resok {change_info4 cinfo;};"
    },
    {
      "indent": 3,
      "text": "union CREATE4res switch (nfsstat4 status) {\n case NFS4_OK:\n         CREATE4resok resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * DELEGPURGE: Purge Delegations Awaiting Recovery\n */\nstruct DELEGPURGE4args {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " clientid4 clientid; };",
      "ja": "clientId4 clientId;};"
    },
    {
      "indent": 3,
      "text": "struct DELEGPURGE4res { nfsstat4 status; };",
      "ja": "struct delegpurge4res {nfsstat4 status;};"
    },
    {
      "indent": 3,
      "text": "/*\n * DELEGRETURN: Return a delegation\n */\nstruct DELEGRETURN4args {\n        stateid4        stateid;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct DELEGRETURN4res { nfsstat4 status; };",
      "ja": "struct delegreturn4res {nfsstat4 status;};"
    },
    {
      "indent": 3,
      "text": "/*\n * GETATTR: Get file attributes\n */\nstruct GETATTR4args {\n        /* CURRENT_FH: directory or file */\n        bitmap4         attr_request;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct GETATTR4resok { fattr4 obj_attributes; };",
      "ja": "struct getattr4resok {fattr4 obj_attributes;};"
    },
    {
      "indent": 3,
      "text": "union GETATTR4res switch (nfsstat4 status) {\n case NFS4_OK:\n         GETATTR4resok  resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * GETFH: Get current filehandle\n */\nstruct GETFH4resok {\n        nfs_fh4         object;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union GETFH4res switch (nfsstat4 status) { case NFS4_OK: GETFH4resok resok4; default:",
      "ja": "Union getFH4RESスイッチ（NFSSTAT4ステータス）{case nfs4_ok：getfh4resok resok4;デフォルト："
    },
    {
      "indent": 3,
      "text": " void; };",
      "ja": "空所;};"
    },
    {
      "indent": 3,
      "text": "/*\n * LINK: Create link to an object\n */\nstruct LINK4args {\n        /* SAVED_FH: source object */\n        /* CURRENT_FH: target directory */\n        component4      newname;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct LINK4resok { change_info4 cinfo; };",
      "ja": "struct link4resok {change_info4 cinfo;};"
    },
    {
      "indent": 3,
      "text": "union LINK4res switch (nfsstat4 status) {\n case NFS4_OK:\n         LINK4resok resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * LOCK/LOCKT/LOCKU: Record lock management\n */\nstruct LOCK4args {\n        /* CURRENT_FH: file */\n        nfs_lock_type4  locktype;\n        seqid4          seqid;\n        bool            reclaim;\n        stateid4        stateid;\n        offset4         offset;\n        length4         length;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct LOCK4denied {\n        nfs_lockowner4  owner;\n        offset4         offset;\n        length4         length;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union LOCK4res switch (nfsstat4 status) { case NFS4_OK: stateid4 stateid; case NFS4ERR_DENIED: LOCK4denied denied; default:",
      "ja": "Union Lock4res Switch（NFSSTAT4ステータス）{case nfs4_ok：stateid4 stateid;ケースnfs4err_denied：lock4deniedは拒否されました。デフォルト："
    },
    {
      "indent": 3,
      "text": " void; };",
      "ja": "空所;};"
    },
    {
      "indent": 3,
      "text": "struct LOCKT4args {\n        /* CURRENT_FH: file */\n        nfs_lock_type4  locktype;\n        nfs_lockowner4  owner;\n        offset4         offset;\n        length4         length;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union LOCKT4res switch (nfsstat4 status) {\n case NFS4ERR_DENIED:\n         LOCK4denied    denied;\n case NFS4_OK:\n         void;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct LOCKU4args {\n        /* CURRENT_FH: file */\n        nfs_lock_type4  locktype;\n        seqid4          seqid;\n        stateid4        stateid;\n        offset4         offset;\n        length4         length;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union LOCKU4res switch (nfsstat4 status) {\n case   NFS4_OK:\n         stateid4       stateid;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * LOOKUP: Lookup filename\n */\nstruct LOOKUP4args {\n        /* CURRENT_FH: directory */\n        pathname4       path;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct LOOKUP4res {\n        /* CURRENT_FH: object */\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * LOOKUPP: Lookup parent directory\n */\nstruct LOOKUPP4res {\n        /* CURRENT_FH: directory */\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * NVERIFY: Verify attributes different\n */\nstruct NVERIFY4args {\n        /* CURRENT_FH: object */\n        fattr4          obj_attributes;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct NVERIFY4res { nfsstat4 status; };",
      "ja": "struct nverify4res {nfsstat4 status;};"
    },
    {
      "indent": 3,
      "text": "/*\n * Various definitions for OPEN\n */\nenum createmode4 {\n        UNCHECKED4      = 0,\n        GUARDED4        = 1,\n        EXCLUSIVE4      = 2\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union createhow4 switch (createmode4 mode) {\n case UNCHECKED4:\n case GUARDED4:\n         fattr4         createattrs;\n case EXCLUSIVE4:\n         verifier4      createverf;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum opentype4 { OPEN4_NOCREATE = 0, OPEN4_CREATE = 1 };",
      "ja": "enum opentype4 {open4_nocreate = 0、open4_create = 1};"
    },
    {
      "indent": 3,
      "text": "union openflag4 switch (opentype4 opentype) {\n case OPEN4_CREATE:\n         createhow4     how;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Next definitions used for OPEN delegation */\nenum limit_by4 {\n        NFS_LIMIT_SIZE          = 1,\n        NFS_LIMIT_BLOCKS        = 2\n        /* others as needed */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct nfs_modified_limit4 {\n        uint32_t        num_blocks;\n        uint32_t        bytes_per_block;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union nfs_space_limit4 switch (limit_by4 limitby) {\n /* limit specified as file size */\n case NFS_LIMIT_SIZE:\n         uint64_t               filesize;\n /* limit specified by number of blocks */\n case NFS_LIMIT_BLOCKS:\n         nfs_modified_limit4    mod_blocks;\n} ;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Share Access and Deny constants for open argument\n */\nconst OPEN4_SHARE_ACCESS_READ   = 0x00000001;\nconst OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;\nconst OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const OPEN4_SHARE_DENY_NONE     = 0x00000000;\nconst OPEN4_SHARE_DENY_READ     = 0x00000001;\nconst OPEN4_SHARE_DENY_WRITE    = 0x00000002;\nconst OPEN4_SHARE_DENY_BOTH     = 0x00000003;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum open_delegation_type4 { OPEN_DELEGATE_NONE = 0, OPEN_DELEGATE_READ = 1, OPEN_DELEGATE_WRITE = 2 };",
      "ja": "enum open_delegation_type4 {open_delegate_none = 0、open_delegate_read = 1、open_delegate_write = 2};"
    },
    {
      "indent": 3,
      "text": "enum open_claim_type4 { CLAIM_NULL = 0, CLAIM_PREVIOUS = 1, CLAIM_DELEGATE_CUR = 2, CLAIM_DELEGATE_PREV = 3 };",
      "ja": "enum open_claim_type4 {rack_null = 0、rack_previous = 1、rack_delegate_cur = 2、rack_delegate_prev = 3};"
    },
    {
      "indent": 3,
      "text": "struct open_claim_delegate_cur4 { pathname4 file;",
      "ja": "struct open_claim_delegate_cur4 {pathname4 file;"
    },
    {
      "indent": 3,
      "text": " stateid4 delegate_stateid; };",
      "ja": "StateId4 Delegate_stateId;};"
    },
    {
      "indent": 3,
      "text": "union open_claim4 switch (open_claim_type4 claim) {\n /*\n  * No special rights to file. Ordinary OPEN of the specified file.\n  */\n case CLAIM_NULL:\n        /* CURRENT_FH: directory */\n        pathname4       file;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/*\n * Right to the file established by an open previous to server\n * reboot.  File identified by filehandle obtained at that time\n * rather than by name.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "case CLAIM_PREVIOUS:\n       /* CURRENT_FH: file being reclaimed */\n       uint32_t        delegate_type;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/*\n * Right to file based on a delegation granted by the server.\n * File is specified by name.\n */\ncase CLAIM_DELEGATE_CUR:\n       /* CURRENT_FH: directory */\n       open_claim_delegate_cur4        delegate_cur_info;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " /* Right to file based on a delegation granted to a previous boot\n  * instance of the client.  File is specified by name.\n  */\n case CLAIM_DELEGATE_PREV:\n         /* CURRENT_FH: directory */\n        pathname4       file_delegate_prev;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * OPEN: Open a file, potentially receiving an open delegation\n */\nstruct OPEN4args {\n        open_claim4     claim;\n        openflag4       openhow;\n        nfs_lockowner4  owner;\n        seqid4          seqid;\n        uint32_t        share_access;\n        uint32_t        share_deny;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct open_read_delegation4 {\n        stateid4        stateid;        /* Stateid for delegation*/\n        bool            recall;         /* Pre-recalled flag for\n                                           delegations obtained\n                                           by reclaim\n                                           (CLAIM_PREVIOUS) */\n        nfsace4         permissions;    /* Defines users who don't\n                                           need an ACCESS call to\n                                           open for read */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct open_write_delegation4 {\n        stateid4        stateid;        /* Stateid for delegation */\n        bool            recall;         /* Pre-recalled flag for\n                                           delegations obtained\n                                           by reclaim\n                                           (CLAIM_PREVIOUS) */\n        nfs_space_limit4 space_limit;   /* Defines condition that\n                                           the client must check to\n                                           determine whether the\n                                           file needs to be flushed\n                                           to the server on close.\n                                           */\n        nfsace4         permissions;    /* Defines users who don't\n                                           need an ACCESS call as\n                                           part of a delegated\n                                           open. */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union open_delegation4\nswitch (open_delegation_type4 delegation_type) {\n        case OPEN_DELEGATE_NONE:\n                void;\n        case OPEN_DELEGATE_READ:\n                open_read_delegation4 read;\n        case OPEN_DELEGATE_WRITE:\n                open_write_delegation4 write;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Result flags\n */\n/* Mandatory locking is in effect for this file. */\nconst OPEN4_RESULT_MLOCK        = 0x00000001;\n/* Client must confirm open */\nconst OPEN4_RESULT_CONFIRM      = 0x00000002;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct OPEN4resok {",
      "ja": "struct open4resok {"
    },
    {
      "indent": 3,
      "text": "        stateid4        stateid;        /* Stateid for open */\n        change_info4    cinfo;          /* Directory Change Info */\n        uint32_t        rflags;         /* Result flags */\n        verifier4       open_confirm;   /* OPEN_CONFIRM verifier */\n        open_delegation4 delegation;    /* Info on any open\n                                           delegation */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union OPEN4res switch (nfsstat4 status) {\n case NFS4_OK:\n        /* CURRENT_FH: opened file */\n        OPEN4resok      resok4;\n default:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * OPENATTR: open named attributes directory\n */\nstruct OPENATTR4res {\n        /* CURRENT_FH: name attr directory*/\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * OPEN_CONFIRM: confirm the open\n */\nstruct OPEN_CONFIRM4args {\n        /* CURRENT_FH: opened file */\n        seqid4          seqid;\n        verifier4       open_confirm;   /* OPEN_CONFIRM verifier */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct OPEN_CONFIRM4resok { stateid4 stateid; };",
      "ja": "struct open_confirm4resok {stateid4 stateid;};"
    },
    {
      "indent": 3,
      "text": "union OPEN_CONFIRM4res switch (nfsstat4 status) {\n case NFS4_OK:\n         OPEN_CONFIRM4resok     resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * OPEN_DOWNGRADE: downgrade the access/deny for a file\n */\nstruct OPEN_DOWNGRADE4args {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        /* CURRENT_FH: opened file */\n        stateid4        stateid;\n        seqid4          seqid;\n        uint32_t        share_access;\n        uint32_t        share_deny;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct OPEN_DOWNGRADE4resok { stateid4 stateid; };",
      "ja": "struct open_downgrade4resok {stateid4 stateid;};"
    },
    {
      "indent": 3,
      "text": "union OPEN_DOWNGRADE4res switch(nfsstat4 status) {\n case NFS4_OK:\n        OPEN_DOWNGRADE4resok    resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * PUTFH: Set current filehandle\n */\nstruct PUTFH4args {\n        nfs_fh4         object;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct PUTFH4res {\n        /* CURRENT_FH: */\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * PUTPUBFH: Set public filehandle\n */\nstruct PUTPUBFH4res {\n        /* CURRENT_FH: public fh */\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * PUTROOTFH: Set root filehandle\n */\nstruct PUTROOTFH4res {\n        /* CURRENT_FH: root fh */\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * READ: Read from file",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " */\nstruct READ4args {\n        /* CURRENT_FH: file */\n        stateid4        stateid;\n        offset4         offset;\n        count4          count;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct READ4resok {\n        bool            eof;\n        opaque          data<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union READ4res switch (nfsstat4 status) {\n case NFS4_OK:\n         READ4resok     resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * READDIR: Read directory\n */\nstruct READDIR4args {\n        /* CURRENT_FH: directory */\n        nfs_cookie4     cookie;\n        verifier4       cookieverf;\n        count4          dircount;\n        count4          maxcount;\n        bitmap4         attr_request;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct entry4 {\n        nfs_cookie4     cookie;\n        component4      name;\n        fattr4          attrs;\n        entry4          *nextentry;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct dirlist4 {\n        entry4          *entries;\n        bool            eof;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct READDIR4resok {\n        verifier4       cookieverf;\n        dirlist4        reply;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union READDIR4res switch (nfsstat4 status) {\n case NFS4_OK:\n         READDIR4resok  resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * READLINK: Read symbolic link\n */\nstruct READLINK4resok {\n        linktext4       link;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union READLINK4res switch (nfsstat4 status) {\n case NFS4_OK:\n         READLINK4resok resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * REMOVE: Remove filesystem object\n */\nstruct REMOVE4args {\n        /* CURRENT_FH: directory */\n        component4      target;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct REMOVE4resok { change_info4 cinfo; };",
      "ja": "struct remove4resok {change_info4 cinfo;};"
    },
    {
      "indent": 3,
      "text": "union REMOVE4res switch (nfsstat4 status) {\n case NFS4_OK:\n         REMOVE4resok   resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * RENAME: Rename directory entry\n */\nstruct RENAME4args {\n        /* SAVED_FH: source directory */\n        component4      oldname;\n        /* CURRENT_FH: target directory */\n           component4      newname;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct RENAME4resok {\n        change_info4    source_cinfo;\n        change_info4    target_cinfo;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union RENAME4res switch (nfsstat4 status) {\n case NFS4_OK:\n        RENAME4resok    resok4;\n default:\n        void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * RENEW: Renew a Lease\n */\nstruct RENEW4args {\n        stateid4        stateid;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct RENEW4res { nfsstat4 status; };",
      "ja": "struct renew4res {nfsstat4 status;};"
    },
    {
      "indent": 3,
      "text": "/*\n * RESTOREFH: Restore saved filehandle\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct RESTOREFH4res {\n        /* CURRENT_FH: value of saved fh */\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * SAVEFH: Save current filehandle\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct SAVEFH4res {\n        /* SAVED_FH: value of current fh */\n        nfsstat4        status;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * SECINFO: Obtain Available Security Mechanisms\n */\nstruct SECINFO4args {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        /* CURRENT_FH: */\n        component4      name;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * From RFC 2203\n */\nenum rpc_gss_svc_t {\n        RPC_GSS_SVC_NONE        = 1,\n        RPC_GSS_SVC_INTEGRITY   = 2,\n        RPC_GSS_SVC_PRIVACY     = 3\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct rpcsec_gss_info {\n        sec_oid4        oid;\n        qop4            qop;\n        rpc_gss_svc_t   service;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct secinfo4 {\n        uint32_t        flavor;\n        /* null for AUTH_SYS, AUTH_NONE;\n           contains rpcsec_gss_info for\n           RPCSEC_GSS. */\n        opaque          flavor_info<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef secinfo4 SECINFO4resok<>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union SECINFO4res switch (nfsstat4 status) {\n case NFS4_OK:\n         SECINFO4resok resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * SETATTR: Set attributes\n */\nstruct SETATTR4args {\n        /* CURRENT_FH: target object */\n        stateid4        stateid;\n        fattr4          obj_attributes;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "};",
      "ja": "};"
    },
    {
      "indent": 3,
      "text": "struct SETATTR4res { nfsstat4 status;",
      "ja": "struct setattr4res {nfsstat4 status;"
    },
    {
      "indent": 3,
      "text": " bitmap4 attrsset; };",
      "ja": "bitmap4 attrsset;};"
    },
    {
      "indent": 3,
      "text": "/*\n * SETCLIENTID\n */\nstruct SETCLIENTID4args {\n        nfs_client_id4  client;\n        cb_client4      callback;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct SETCLIENTID4resok {\n        clientid4       clientid;\n        verifier4       setclientid_confirm;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union SETCLIENTID4res switch (nfsstat4 status) {\n case NFS4_OK:\n         SETCLIENTID4resok      resok4;\n case NFS4ERR_CLID_INUSE:\n         clientaddr4    client_using;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct SETCLIENTID_CONFIRM4args { verifier4 setclientid_confirm; };",
      "ja": "struct setclientid_confirm4args {verifier4 setclientId_confirm;};"
    },
    {
      "indent": 3,
      "text": "struct SETCLIENTID_CONFIRM4res { nfsstat4 status; };",
      "ja": "struct setclientid_confirm4res {nfsstat4 status;};"
    },
    {
      "indent": 3,
      "text": "/*\n * VERIFY: Verify attributes same\n */\nstruct VERIFY4args {\n        /* CURRENT_FH: object */\n        fattr4          obj_attributes;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct VERIFY4res { nfsstat4 status; };",
      "ja": "struct verify4res {nfsstat4 status;};"
    },
    {
      "indent": 3,
      "text": "/*\n * WRITE: Write to file\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum stable_how4 { UNSTABLE4 = 0, DATA_SYNC4 = 1, FILE_SYNC4 = 2 };",
      "ja": "enum stable_how4 {unstable4 = 0、data_sync4 = 1、file_sync4 = 2};"
    },
    {
      "indent": 3,
      "text": "struct WRITE4args {\n        /* CURRENT_FH: file */\n        stateid4        stateid;\n        offset4         offset;\n        stable_how4     stable;\n        opaque          data<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct WRITE4resok {\n        count4          count;\n        stable_how4     committed;\n        verifier4       writeverf;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union WRITE4res switch (nfsstat4 status) {\n case NFS4_OK:\n         WRITE4resok    resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Operation arrays\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum nfs_opnum4 {\n        OP_ACCESS               = 3,\n        OP_CLOSE                = 4,\n        OP_COMMIT               = 5,\n        OP_CREATE               = 6,\n        OP_DELEGPURGE           = 7,\n        OP_DELEGRETURN          = 8,\n        OP_GETATTR              = 9,\n        OP_GETFH                = 10,\n        OP_LINK                 = 11,\n        OP_LOCK                 = 12,\n        OP_LOCKT                = 13,\n        OP_LOCKU                = 14,\n        OP_LOOKUP               = 15,\n        OP_LOOKUPP              = 16,\n        OP_NVERIFY              = 17,\n        OP_OPEN                 = 18,\n           OP_OPENATTR             = 19,\n        OP_OPEN_CONFIRM         = 20,\n        OP_OPEN_DOWNGRADE       = 21,\n        OP_PUTFH                = 22,\n        OP_PUTPUBFH             = 23,\n        OP_PUTROOTFH            = 24,\n        OP_READ                 = 25,\n        OP_READDIR              = 26,\n        OP_READLINK             = 27,\n        OP_REMOVE               = 28,\n        OP_RENAME               = 29,\n        OP_RENEW                = 30,\n        OP_RESTOREFH            = 31,\n        OP_SAVEFH               = 32,\n        OP_SECINFO              = 33,\n        OP_SETATTR              = 34,\n        OP_SETCLIENTID          = 35,\n        OP_SETCLIENTID_CONFIRM  = 36,\n        OP_VERIFY               = 37,\n        OP_WRITE                = 38\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union nfs_argop4 switch (nfs_opnum4 argop) {\n case OP_ACCESS:        ACCESS4args opaccess;\n case OP_CLOSE:         CLOSE4args opclose;\n case OP_COMMIT:        COMMIT4args opcommit;\n case OP_CREATE:        CREATE4args opcreate;\n case OP_DELEGPURGE:    DELEGPURGE4args opdelegpurge;\n case OP_DELEGRETURN:   DELEGRETURN4args opdelegreturn;\n case OP_GETATTR:       GETATTR4args opgetattr;\n case OP_GETFH:         void;\n case OP_LINK:          LINK4args oplink;\n case OP_LOCK:          LOCK4args oplock;\n case OP_LOCKT:         LOCKT4args oplockt;\n case OP_LOCKU:         LOCKU4args oplocku;\n case OP_LOOKUP:        LOOKUP4args oplookup;\n case OP_LOOKUPP:       void;\n case OP_NVERIFY:       NVERIFY4args opnverify;\n case OP_OPEN:          OPEN4args opopen;\n case OP_OPENATTR:      void;\n case OP_OPEN_CONFIRM:  OPEN_CONFIRM4args opopen_confirm;\n case OP_OPEN_DOWNGRADE:        OPEN_DOWNGRADE4args opopen_downgrade;\n case OP_PUTFH:         PUTFH4args opputfh;\n case OP_PUTPUBFH:      void;\n case OP_PUTROOTFH:     void;\n case OP_READ:          READ4args opread;\n case OP_READDIR:       READDIR4args opreaddir;\n case OP_READLINK:      void;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " case OP_REMOVE:        REMOVE4args opremove;\n case OP_RENAME:        RENAME4args oprename;\n case OP_RENEW:         RENEW4args oprenew;\n case OP_RESTOREFH:     void;\n case OP_SAVEFH:        void;\n case OP_SECINFO:       SECINFO4args opsecinfo;\n case OP_SETATTR:       SETATTR4args opsetattr;\n case OP_SETCLIENTID:   SETCLIENTID4args opsetclientid;\n case OP_SETCLIENTID_CONFIRM:   SETCLIENTID_CONFIRM4args\n                                        opsetclientid_confirm;\n case OP_VERIFY:        VERIFY4args opverify;\n case OP_WRITE:         WRITE4args opwrite;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union nfs_resop4 switch (nfs_opnum4 resop){\n case OP_ACCESS:        ACCESS4res opaccess;\n case OP_CLOSE:         CLOSE4res opclose;\n case OP_COMMIT:        COMMIT4res opcommit;\n case OP_CREATE:        CREATE4res opcreate;\n case OP_DELEGPURGE:    DELEGPURGE4res opdelegpurge;\n case OP_DELEGRETURN:   DELEGRETURN4res opdelegreturn;\n case OP_GETATTR:       GETATTR4res opgetattr;\n case OP_GETFH:         GETFH4res opgetfh;\n case OP_LINK:          LINK4res oplink;\n case OP_LOCK:          LOCK4res oplock;\n case OP_LOCKT:         LOCKT4res oplockt;\n case OP_LOCKU:         LOCKU4res oplocku;\n case OP_LOOKUP:        LOOKUP4res oplookup;\n case OP_LOOKUPP:       LOOKUPP4res oplookupp;\n case OP_NVERIFY:       NVERIFY4res opnverify;\n case OP_OPEN:          OPEN4res opopen;\n case OP_OPENATTR:      OPENATTR4res opopenattr;\n case OP_OPEN_CONFIRM:  OPEN_CONFIRM4res opopen_confirm;\n case OP_OPEN_DOWNGRADE:        OPEN_DOWNGRADE4res opopen_downgrade;\n case OP_PUTFH:         PUTFH4res opputfh;\n case OP_PUTPUBFH:      PUTPUBFH4res opputpubfh;\n case OP_PUTROOTFH:     PUTROOTFH4res opputrootfh;\n case OP_READ:          READ4res opread;\n case OP_READDIR:       READDIR4res opreaddir;\n case OP_READLINK:      READLINK4res opreadlink;\n case OP_REMOVE:        REMOVE4res opremove;\n case OP_RENAME:        RENAME4res oprename;\n case OP_RENEW:         RENEW4res oprenew;\n case OP_RESTOREFH:     RESTOREFH4res oprestorefh;\n case OP_SAVEFH:        SAVEFH4res opsavefh;\n case OP_SECINFO:       SECINFO4res opsecinfo;\n case OP_SETATTR:       SETATTR4res opsetattr;\n case OP_SETCLIENTID:   SETCLIENTID4res opsetclientid;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " case OP_SETCLIENTID_CONFIRM:   SETCLIENTID_CONFIRM4res\n                                        opsetclientid_confirm;\n case OP_VERIFY:        VERIFY4res opverify;\n case OP_WRITE:         WRITE4res opwrite;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct COMPOUND4args {\n        utf8string      tag;\n        uint32_t        minorversion;\n        nfs_argop4      argarray<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct COMPOUND4res {\n        nfsstat4 status;\n        utf8string      tag;\n        nfs_resop4      resarray<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Remote file service routines\n */\nprogram NFS4_PROGRAM {\n        version NFS_V4 {\n                void\n                        NFSPROC4_NULL(void) = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "COMPOUND4res NFSPROC4_COMPOUND(COMPOUND4args) = 1;",
      "ja": "化合物nfsproc4_compound（commount4args）= 1;"
    },
    {
      "indent": 3,
      "text": "        } = 4;\n} = 100003;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * NFS4 Callback Procedure Definitions and Program\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * CB_GETATTR: Get Current Attributes\n */\nstruct CB_GETATTR4args {\n        nfs_fh4 fh;\n        bitmap4 attr_request;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct CB_GETATTR4resok { fattr4 obj_attributes;",
      "ja": "struct cb_getattr4resok {fattr4 obj_attributes;"
    },
    {
      "indent": 3,
      "text": "};",
      "ja": "};"
    },
    {
      "indent": 3,
      "text": "union CB_GETATTR4res switch (nfsstat4 status) {\n case NFS4_OK:\n         CB_GETATTR4resok       resok4;\n default:\n         void;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * CB_RECALL: Recall an Open Delegation\n */\nstruct CB_RECALL4args {\n        stateid4        stateid;\n        bool            truncate;\n        nfs_fh4         fh;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct CB_RECALL4res { nfsstat4 status; };",
      "ja": "struct cb_recall4res {nfsstat4 status;};"
    },
    {
      "indent": 3,
      "text": "/*\n * Various definitions for CB_COMPOUND\n */\nenum nfs_cb_opnum4 {\n        OP_CB_GETATTR           = 3,\n        OP_CB_RECALL            = 4\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union nfs_cb_argop4 switch (unsigned argop) {\n case OP_CB_GETATTR:    CB_GETATTR4args opcbgetattr;\n case OP_CB_RECALL:     CB_RECALL4args  opcbrecall;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "union nfs_cb_resop4 switch (unsigned resop){\n case OP_CB_GETATTR:    CB_GETATTR4res  opcbgetattr;\n case OP_CB_RECALL:     CB_RECALL4res   opcbrecall;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct CB_COMPOUND4args {\n        utf8string      tag;\n        uint32_t        minorversion;\n        nfs_cb_argop4   argarray<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct CB_COMPOUND4res { nfsstat4 status;",
      "ja": "struct cb_compound4res {nfsstat4 status;"
    },
    {
      "indent": 3,
      "text": "        utf8string      tag;\n        nfs_cb_resop4   resarray<>;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Program number is in the transient range since the client\n * will assign the exact transient program number and provide\n * that to the server via the SETCLIENTID operation.\n */\nprogram NFS4_CALLBACK {\n        version NFS_CB {\n                void\n                        CB_NULL(void) = 0;\n                CB_COMPOUND4res\n                        CB_COMPOUND(CB_COMPOUND4args) = 1;\n        } = 1;\n} = 40000000;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "19. Bibliography",
      "section_title": true,
      "ja": "19. 書誌"
    },
    {
      "indent": 3,
      "text": "[Floyd] S. Floyd, V. Jacobson, \"The Synchronization of Periodic Routing Messages,\" IEEE/ACM Transactions on Networking, 2(2), pp. 122-136, April 1994.",
      "ja": "[フロイド] S.フロイド、V。ジェイコブソン、「定期的なルーティングメッセージの同期」、ネットワーキングに関するIEEE/ACMトランザクション、2（2）、pp。122-136、1994年4月。"
    },
    {
      "indent": 3,
      "text": "[Gray] C. Gray, D. Cheriton, \"Leases: An Efficient Fault-Tolerant Mechanism for Distributed File Cache Consistency,\" Proceedings of the Twelfth Symposium on Operating Systems Principles, p. 202-210, December 1989.",
      "ja": "[Gray] C. Gray、D。Cheriton、「リース：分散ファイルキャッシュの一貫性のための効率的な断層耐性メカニズム」、オペレーティングシステムの原則に関する第12回シンポジウムの議事録、p。202-210、1989年12月。"
    },
    {
      "indent": 3,
      "text": "[ISO10646] \"ISO/IEC 10646-1:1993. International Standard -- Information technology -- Universal Multiple-Octet Coded Character Set (UCS) -- Part 1: Architecture and Basic Multilingual Plane.\"",
      "ja": "[ISO10646]「ISO/IEC 10646-1：1993。国際標準 - 情報技術 - ユニバーサルマルチオクテットコード化された文字セット（UCS） - パート1：アーキテクチャと基本的な多言語平面。」"
    },
    {
      "indent": 3,
      "text": "[Juszczak] Juszczak, Chet, \"Improving the Performance and Correctness of an NFS Server,\" USENIX Conference Proceedings, USENIX Association, Berkeley, CA, June 1990, pages 53-63. Describes reply cache implementation that avoids work in the server by handling duplicate requests. More important, though listed as a side-effect, the reply cache aids in the avoidance of destructive non-idempotent operation re-application -- improving correctness.",
      "ja": "[Juszczak] Juszczak、Chet、「NFSサーバーのパフォーマンスと正確性の向上」、Usenix Conference Proceedings、Usenix Association、Berkeley、CA、1990、Pages 53-63。重複リクエストを処理することにより、サーバーでの作業を回避する返信キャッシュの実装について説明します。より重要なのは、副作用としてリストされていますが、返信キャッシュは、破壊的でない非女性的操作の再適用の回避に役立ちます - 正確性の改善。"
    },
    {
      "indent": 3,
      "text": "[Kazar] Kazar, Michael Leon, \"Synchronization and Caching Issues in the Andrew File System,\" USENIX Conference Proceedings, USENIX Association, Berkeley, CA, Dallas Winter 1988, pages 27-36. A description of the cache consistency scheme in AFS. Contrasted with other distributed file systems.",
      "ja": "[Kazar] Kazar、Michael Leon、「Andrew File Systemの同期とキャッシュの問題」、Usenix Conference Proceedings、Usenix Association、Berkeley、CA、Dallas Winter 1988、27-36ページ。AFSのキャッシュの一貫性スキームの説明。他の分散ファイルシステムとは対照的です。"
    },
    {
      "indent": 3,
      "text": "[Macklem] Macklem, Rick, \"Lessons Learned Tuning the 4.3BSD Reno Implementation of the NFS Protocol,\" Winter USENIX Conference Proceedings, USENIX Association, Berkeley, CA, January 1991. Describes performance work in tuning the 4.3BSD Reno NFS implementation. Describes performance improvement (reduced CPU loading) through elimination of data copies.",
      "ja": "[Macklem] Macklem、Rick、「NFSプロトコルの4.3bsd Reno実装の調整を学んだ教訓」、Winter Usenix Conference Proceedings、Usenix Association、Berkeley、CA、1991年。データコピーの排除によるパフォーマンスの改善（CPUの負荷の削減）について説明します。"
    },
    {
      "indent": 3,
      "text": "[Mogul] Mogul, Jeffrey C., \"A Recovery Protocol for Spritely NFS,\" USENIX File System Workshop Proceedings, Ann Arbor, MI, USENIX Association, Berkeley, CA, May 1992. Second paper on Spritely NFS proposes a lease-based scheme for recovering state of consistency protocol.",
      "ja": "[Mogul] Mogul、Jeffrey C.、「Spritety NFSの回復プロトコル」、Usenix File System Workshop Proceedings、Ann Arbor、MI、Usenix Association、Berkeley、CA、1992年。一貫性プロトコルの状態を回復するため。"
    },
    {
      "indent": 3,
      "text": "[Nowicki] Nowicki, Bill, \"Transport Issues in the Network File System,\" ACM SIGCOMM newsletter Computer Communication Review, April 1989. A brief description of the basis for the dynamic retransmission work.",
      "ja": "[Nowicki] Nowicki、Bill、「ネットワークファイルシステムの輸送の問題」、ACM Sigcomm Newsletter Computer Communication Review、1989年4月。動的な再送信作業の基礎の簡単な説明。"
    },
    {
      "indent": 3,
      "text": "[Pawlowski] Pawlowski, Brian, Ron Hixon, Mark Stein, Joseph Tumminaro, \"Network Computing in the UNIX and IBM Mainframe Environment,\" Uniforum `89 Conf. Proc., (1989) Description of an NFS server implementation for IBM's MVS operating system.",
      "ja": "[Pawlowski] Pawlowski、Brian、Ron Hixon、Mark Stein、Joseph Tumminaro、「UNIXおよびIBMメインフレーム環境でのネットワークコンピューティング」、Uniforum `89 Conf。Proc。、（1989）IBMのMVSオペレーティングシステムのNFSサーバー実装の説明。"
    },
    {
      "indent": 3,
      "text": "[RFC1094] Sun Microsystems, Inc., \"NFS: Network File System Protocol Specification\", RFC 1094, March 1989.",
      "ja": "[RFC1094] Sun Microsystems、Inc。、「NFS：ネットワークファイルシステムプロトコル仕様」、RFC 1094、1989年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC1345] Simonsen, K., \"Character Mnemonics & Character Sets\", RFC 1345, June 1992.",
      "ja": "[RFC1345] Simonsen、K。、「キャラクターニーモニックとキャラクターセット」、RFC 1345、1992年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC1700] Reynolds, J. and J. Postel, \"Assigned Numbers\", STD 2, RFC 1700, October 1994.",
      "ja": "[RFC1700] Reynolds、J。およびJ. Postel、「割り当てられた番号」、STD 2、RFC 1700、1994年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1813] Callaghan, B., Pawlowski, B. and P. Staubach, \"NFS Version 3 Protocol Specification\", RFC 1813, June 1995.",
      "ja": "[RFC1813] Callaghan、B.、Pawlowski、B。およびP. Staubach、「NFSバージョン3プロトコル仕様」、RFC 1813、1995年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC1831] Srinivasan, R., \"RPC: Remote Procedure Call Protocol Specification Version 2\", RFC 1831, August 1995.",
      "ja": "[RFC1831] Srinivasan、R。、 \"RPC：リモートプロシージャコールプロトコル仕様バージョン2\"、RFC 1831、1995年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC1832] Srinivasan, R., \"XDR: External Data Representation Standard\", RFC 1832, August 1995.",
      "ja": "[RFC1832] Srinivasan、R。、「XDR：外部データ表現標準」、RFC 1832、1995年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC1833] Srinivasan, R., \"Binding Protocols for ONC RPC Version 2\", RFC 1833, August 1995.",
      "ja": "[RFC1833] Srinivasan、R。、「ONC RPCバージョン2の結合プロトコル」、RFC 1833、1995年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2025] Adams, C., \"The Simple Public-Key GSS-API Mechanism (SPKM)\", RFC 2025, October 1996.",
      "ja": "[RFC2025] Adams、C。、「シンプルなパブリックキーGSS-APIメカニズム（SPKM）」、RFC 2025、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2054] Callaghan, B., \"WebNFS Client Specification\", RFC 2054, October 1996.",
      "ja": "[RFC2054] Callaghan、B。、「Webnfsクライアント仕様」、RFC 2054、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2055] Callaghan, B., \"WebNFS Server Specification\", RFC 2055, October 1996.",
      "ja": "[RFC2055] Callaghan、B。、「Webnfs Server仕様」、RFC 2055、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2078] Linn, J., \"Generic Security Service Application Program Interface, Version 2\", RFC 2078, January 1997.",
      "ja": "[RFC2078] Linn、J。、「ジェネリックセキュリティサービスアプリケーションプログラムインターフェイス、バージョン2」、RFC 2078、1997年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC2152] Goldsmith, D., \"UTF-7 A Mail-Safe Transformation Format of Unicode\", RFC 2152, May 1997.",
      "ja": "[RFC2152] Goldsmith、D。、「UTF-7 Unicodeのメール安全性変換形式」、RFC 2152、1997年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2203] Eisler, M., Chiu, A. and L. Ling, \"RPCSEC_GSS Protocol Specification\", RFC 2203, August 1995.",
      "ja": "[RFC2203] Eisler、M.、Chiu、A。およびL. Ling、「RPCSEC_GSSプロトコル仕様」、RFC 2203、1995年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2277] Alvestrand, H., \"IETF Policy on Character Sets and Languages\", BCP 18, RFC 2277, January 1998.",
      "ja": "[RFC2277] Alvestrand、H。、「キャラクターセットと言語に関するIETFポリシー」、BCP 18、RFC 2277、1998年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC2279] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", RFC 2279, January 1998.",
      "ja": "[RFC2279] Yergeau、F。、「UTF-8、ISO 10646の変換形式」、RFC 2279、1998年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC2623] Eisler, M., \"NFS Version 2 and Version 3 Security Issues and the NFS Protocol's Use of RPCSEC_GSS and Kerberos V5\", RFC 2623, June 1999.",
      "ja": "[RFC2623] Eisler、M。、「NFSバージョン2およびバージョン3セキュリティの問題、およびNFSプロトコルによるRPCSEC_GSSおよびKerberos V5」、RFC 2623、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC2624] Shepler, S., \"NFS Version 4 Design Considerations\", RFC 2624, June 1999.",
      "ja": "[RFC2624] Shepler、S。、「NFSバージョン4の設計上の考慮事項」、RFC 2624、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC2847] Eisler, M., \"LIPKEY - A Low Infrastructure Public Key Mechanism Using SPKM\", RFC 2847, June 2000.",
      "ja": "[RFC2847]アイスラー、M。、「リプキー -  SPKMを使用した低インフラストラクチャ公開キーメカニズム」、RFC 2847、2000年6月。"
    },
    {
      "indent": 3,
      "text": "[Sandberg] Sandberg, R., D. Goldberg, S. Kleiman, D. Walsh, B. Lyon, \"Design and Implementation of the Sun Network Filesystem,\" USENIX Conference Proceedings, USENIX Association, Berkeley, CA, Summer 1985. The basic paper describing the SunOS implementation of the NFS version 2 protocol, and discusses the goals, protocol specification and trade-offs.",
      "ja": "[Sandberg] Sandberg、R.、D。Goldberg、S。Kleiman、D。Walsh、B。Lyon、「サンネットワークファイルシステムの設計と実装」、Usenix Conference Proceedings、Usenix Association、Berkeley、CA、1985。NFSバージョン2プロトコルのSUNOS実装について説明し、目標、プロトコルの仕様、およびトレードオフについて説明する基本的な論文。"
    },
    {
      "indent": 3,
      "text": "[Srinivasan] Srinivasan, V., Jeffrey C. Mogul, \"Spritely NFS: Implementation and Performance of Cache Consistency Protocols\", WRL Research Report 89/5, Digital Equipment Corporation Western Research Laboratory, 100 Hamilton Ave., Palo Alto, CA, 94301, May 1989. This paper analyzes the effect of applying a Sprite-like consistency protocol applied to standard NFS. The issues of recovery in a stateful environment are covered in [Mogul].",
      "ja": "[Srinivasan] Srinivasan、V.、Jeffrey C. Mogul、「Spritey NFS：キャッシュの一貫性プロトコルの実装とパフォーマンス」、WRLリサーチレポート89/5、Digital Equipment Corporation Western Research Laboratory、100 Hamilton Ave.、Palo Alte、CA、94301、1989年5月。この論文では、標準のNFSに適用されるスプライトのような一貫性プロトコルを適用する効果を分析します。ステートフル環境での回復の問題は、[大御所]でカバーされています。"
    },
    {
      "indent": 3,
      "text": "[Unicode1] The Unicode Consortium, \"The Unicode Standard, Version 3.0\", Addison-Wesley Developers Press, Reading, MA, 2000. ISBN 0-201-61633-5. More information available at: http://www.unicode.org/",
      "ja": "[Unicode1] Unicode Consortium、「Unicode Standard、バージョン3.0」、Addison-Wesley Developers Press、Reading、MA、2000。ISBN0-201-61633-5。詳細については、http：//www.unicode.org/で入手できます。"
    },
    {
      "indent": 3,
      "text": "[Unicode2] \"Unsupported Scripts\" Unicode, Inc., The Unicode Consortium, P.O. Box 700519, San Jose, CA 95710-0519 USA, September 1999 http://www.unicode.org/unicode/standard/unsupported.html",
      "ja": "[Unicode2]「サポートされていないスクリプト」Unicode、Inc.、The Unicode Consortium、P.O。Box 700519、サンノゼ、CA 95710-0519 USA、1999年9月http://www.unicode.org/unicode/standard/unsupported.html"
    },
    {
      "indent": 3,
      "text": "[XNFS] The Open Group, Protocols for Interworking: XNFS, Version 3W, The Open Group, 1010 El Camino Real Suite 380, Menlo Park, CA 94025, ISBN 1-85912-184-5, February 1998. HTML version available: http://www.opengroup.org",
      "ja": "[XNFS]オープングループ、インターワーキングのプロトコル：XNFS、バージョン3W、オープングループ、1010 El Camino Real Suite 380、CA 94025、ISBN 1-85912-184-5、1998年2月。：//www.opengroup.org"
    },
    {
      "indent": 0,
      "text": "20. Authors",
      "section_title": true,
      "ja": "20. 著者"
    },
    {
      "indent": 0,
      "text": "20.1. Editor's Address",
      "section_title": true,
      "ja": "20.1. 編集者のアドレス"
    },
    {
      "indent": 3,
      "text": "Spencer Shepler Sun Microsystems, Inc. 7808 Moonflower Drive Austin, Texas 78750",
      "ja": "Spencer Shepler Sun Systems、Inc。7808 Moonflower Drive Austin、Texas 78750"
    },
    {
      "indent": 3,
      "text": "Phone: +1 512-349-9376\nEMail: spencer.shepler@sun.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.2. Authors' Addresses",
      "section_title": true,
      "ja": "20.2. 著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Carl Beame Hummingbird Ltd.",
      "ja": "Carl Beame Hummingbird Ltd."
    },
    {
      "indent": 3,
      "text": "EMail: beame@bws.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Brent Callaghan Sun Microsystems, Inc. 901 San Antonio Road Palo Alto, CA 94303",
      "ja": "Brent Callaghan Sun Systems、Inc。901 San Antonio Road Palo Alto、CA 94303"
    },
    {
      "indent": 3,
      "text": "Phone: +1 650-786-5067\nEMail: brent.callaghan@sun.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Mike Eisler 5565 Wilson Road Colorado Springs, CO 80919",
      "ja": "マイクアイスラー5565ウィルソンロードコロラドスプリングス、コロラド州80919"
    },
    {
      "indent": 3,
      "text": "Phone: +1 719-599-9026\nEMail: mike@eisler.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "David Noveck Network Appliance 375 Totten Pond Road Waltham, MA 02451",
      "ja": "David Noveck Networkアプライアンス375トッテンポンドロードウォルサム、マサチューセッツ州02451"
    },
    {
      "indent": 3,
      "text": "Phone: +1 781-895-4949 E-mail: dnoveck@netapp.com David Robinson Sun Microsystems, Inc. 901 San Antonio Road Palo Alto, CA 94303",
      "ja": "電話：1 781-895-4949電子メール：dnoveck@netapp.com David Robinson Sun Microsystems、Inc。901 San Antonio Road Palo Alte、CA 94303"
    },
    {
      "indent": 3,
      "text": "Phone: +1 650-786-5088\nEMail: david.robinson@sun.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Robert Thurlow Sun Microsystems, Inc. 901 San Antonio Road Palo Alto, CA 94303",
      "ja": "Robert Thurlow Sun Microsystems、Inc。901 San Antonio Road Palo Alto、CA 94303"
    },
    {
      "indent": 3,
      "text": "Phone: +1 650-786-5096\nEMail: robert.thurlow@sun.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.3. Acknowledgements",
      "section_title": true,
      "ja": "20.3. 謝辞"
    },
    {
      "indent": 3,
      "text": "The author thanks and acknowledges:",
      "ja": "著者は感謝し、認めます："
    },
    {
      "indent": 3,
      "text": "Neil Brown for his extensive review and comments of various drafts.",
      "ja": "ニール・ブラウンの広範なレビューとさまざまなドラフトのコメント。"
    },
    {
      "indent": 0,
      "text": "21. Full Copyright Statement",
      "section_title": true,
      "ja": "21. 完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2000). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2000）。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書と本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}