{
  "title": {
    "text": "RFC 3782 - The NewReno Modification to TCP's Fast Recovery Algorithm",
    "ja": "RFC 3782 - TCPの高速回復アルゴリズムへのNewreno変更"
  },
  "number": 3782,
  "created_at": "2023-09-23 11:17:57.868616+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                           S. Floyd\nRequest for Comments: 3782                                          ICSI\nObsoletes: 2582                                             T. Henderson\nCategory: Standards Track                                         Boeing\n                                                               A. Gurtov\n                                                             TeliaSonera\n                                                              April 2004",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "The NewReno Modification to TCP's Fast Recovery Algorithm",
      "ja": "TCPの高速回復アルゴリズムへのNewreno変更"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（c）The Internet Society（2004）。無断転載を禁じます。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "The purpose of this document is to advance NewReno TCP's Fast Retransmit and Fast Recovery algorithms in RFC 2582 from Experimental to Standards Track status.",
      "ja": "このドキュメントの目的は、RFC 2582のNewReno TCPの高速再送信および高速回復アルゴリズムを実験から標準の追跡ステータスまで進めることです。"
    },
    {
      "indent": 3,
      "text": "The main change in this document relative to RFC 2582 is to specify the Careful variant of NewReno's Fast Retransmit and Fast Recovery algorithms. The base algorithm described in RFC 2582 did not attempt to avoid unnecessary multiple Fast Retransmits that can occur after a timeout. However, RFC 2582 also defined \"Careful\" and \"Less Careful\" variants that avoid these unnecessary Fast Retransmits, and recommended the Careful variant. This document specifies the previously-named \"Careful\" variant as the basic version of NewReno TCP.",
      "ja": "RFC 2582に対するこのドキュメントの主な変更は、NewRenoの高速再送信および高速回復アルゴリズムの慎重なバリアントを指定することです。RFC 2582で説明されているベースアルゴリズムは、タイムアウト後に発生する可能性のある不必要な複数の高速再送信を避けようとしませんでした。ただし、RFC 2582は、これらの不必要な高速再送信を回避する「慎重な」および「慎重でない」バリアントを定義し、慎重なバリアントを推奨しました。このドキュメントは、NewReno TCPの基本バージョンとして、以前に名前が付けられていた「慎重な」バリアントを指定します。"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "For the typical implementation of the TCP Fast Recovery algorithm described in [RFC2581] (first implemented in the 1990 BSD Reno release, and referred to as the Reno algorithm in [FF96]), the TCP data sender only retransmits a packet after a retransmit timeout has occurred, or after three duplicate acknowledgements have arrived triggering the Fast Retransmit algorithm. A single retransmit timeout might result in the retransmission of several data packets, but each invocation of the Fast Retransmit algorithm in RFC 2581 leads to the retransmission of only a single data packet.",
      "ja": "[RFC2581]で説明されているTCP高速回復アルゴリズムの典型的な実装について発生した、または3つの重複した謝辞が到着した後、高速再送信アルゴリズムをトリガーしました。単一の再送信タイムアウトにより、いくつかのデータパケットが再送信される可能性がありますが、RFC 2581の高速再送信アルゴリズムの各呼び出しは、単一のデータパケットのみの再送信につながります。"
    },
    {
      "indent": 3,
      "text": "Problems can arise, therefore, when multiple packets are dropped from a single window of data and the Fast Retransmit and Fast Recovery algorithms are invoked. In this case, if the SACK option is available, the TCP sender has the information to make intelligent decisions about which packets to retransmit and which packets not to retransmit during Fast Recovery. This document applies only for TCP connections that are unable to use the TCP Selective Acknowledgement (SACK) option, either because the option is not locally supported or because the TCP peer did not indicate a willingness to use SACK.",
      "ja": "したがって、データの単一のウィンドウから複数のパケットがドロップされ、高速再送信および高速回復アルゴリズムが呼び出されると、問題が発生する可能性があります。この場合、Sackオプションが利用可能な場合、TCP送信者は、再送信するパケットと、迅速な回復中に再送信しないパケットについてインテリジェントな決定を下すための情報を持っています。このドキュメントは、オプションが局所的にサポートされていないか、TCPピアが袋を使用する意欲を示していないため、TCP Selective Aundment（SACK）オプションを使用できないTCP接続にのみ適用されます。"
    },
    {
      "indent": 3,
      "text": "In the absence of SACK, there is little information available to the TCP sender in making retransmission decisions during Fast Recovery. From the three duplicate acknowledgements, the sender infers a packet loss, and retransmits the indicated packet. After this, the data sender could receive additional duplicate acknowledgements, as the data receiver acknowledges additional data packets that were already in flight when the sender entered Fast Retransmit.",
      "ja": "SACKがない場合、TCP送信者は、迅速な回復中に再送信決定を行う際に利用できる情報はほとんどありません。3つの重複謝辞から、送信者はパケット損失を推進し、示されたパケットを再送信します。この後、データ受信者は、送信者が高速再送信に入ったときにすでに飛行中だった追加のデータパケットを認めているため、データ送信者は追加の重複謝辞を受信することができます。"
    },
    {
      "indent": 3,
      "text": "In the case of multiple packets dropped from a single window of data, the first new information available to the sender comes when the sender receives an acknowledgement for the retransmitted packet (that is, the packet retransmitted when Fast Retransmit was first entered). If there is a single packet drop and no reordering, then the acknowledgement for this packet will acknowledge all of the packets transmitted before Fast Retransmit was entered. However, if there are multiple packet drops, then the acknowledgement for the retransmitted packet will acknowledge some but not all of the packets transmitted before the Fast Retransmit. We call this acknowledgement a partial acknowledgment.",
      "ja": "複数のパケットがデータの単一ウィンドウからドロップされた場合、送信者が利用できる最初の新しい情報は、送信者が再送信パケットの謝辞を受け取ったときに発生します（つまり、Fastの再送信が最初に入力されたときに再送信されたパケット）。単一のパケットドロップがあり、並べ替えがない場合、このパケットの承認は、高速再送信が入力される前に送信されるすべてのパケットを確認します。ただし、複数のパケットドロップがある場合、再送信されたパケットの確認は、高速再送信の前に送信されるすべてではなく、一部を確認します。この承認を部分的な謝辞と呼びます。"
    },
    {
      "indent": 3,
      "text": "Along with several other suggestions, [Hoe95] suggested that during Fast Recovery the TCP data sender responds to a partial acknowledgment by inferring that the next in-sequence packet has been lost, and retransmitting that packet. This document describes a modification to the Fast Recovery algorithm in RFC 2581 that incorporates a response to partial acknowledgements received during Fast Recovery. We call this modified Fast Recovery algorithm NewReno, because it is a slight but significant variation of the basic Reno algorithm in RFC 2581. This document does not discuss the other suggestions in [Hoe95] and [Hoe96], such as a change to the ssthresh parameter during Slow-Start, or the proposal to send a new packet for every two duplicate acknowledgements during Fast Recovery. The version of NewReno in this document also draws on other discussions of NewReno in the literature [LM97, Hen98].",
      "ja": "他のいくつかの提案に加えて、[Hoe95]は、速い回復中にTCPデータ送信者が次のシーケンスパケットが失われたと推測し、そのパケットを再送信することにより、部分的な認識に応答することを示唆しました。このドキュメントでは、RFC 2581の高速回復アルゴリズムの変更について説明します。これは、高速回復中に受け取った部分的な承認への応答を組み込んでいます。これは、RFC 2581の基本的なリノアルゴリズムのわずかでありながら有意なバリエーションであるため、この修正された高速回復アルゴリズムをNewRenoと呼びます。このドキュメントでは、[Hoe95]および[hoe96]の他の提案については、ssthreshreshreshの変更などについて説明しません。スロースタート中のパラメーター、または迅速な回復中に2つの重複謝辞ごとに新しいパケットを送信する提案。このドキュメントのNewrenoのバージョンは、文献[LM97、HEN98]のNewrenoの他の議論についても利用しています。"
    },
    {
      "indent": 3,
      "text": "We do not claim that the NewReno version of Fast Recovery described here is an optimal modification of Fast Recovery for responding to partial acknowledgements, for TCP connections that are unable to use SACK. Based on our experiences with the NewReno modification in the NS simulator [NS] and with numerous implementations of NewReno, we believe that this modification improves the performance of the Fast Retransmit and Fast Recovery algorithms in a wide variety of scenarios.",
      "ja": "ここで説明する高速回復のNewrenoバージョンは、袋を使用できないTCP接続のための速い回復の最適な変更であるとは主張していません。NSシミュレーター[NS]でのNewReno修正の経験と、NewRenoの多数の実装との経験に基づいて、この変更により、さまざまなシナリオでの高速再送信および高速回復アルゴリズムのパフォーマンスが向上すると考えています。"
    },
    {
      "indent": 0,
      "text": "2. Terminology and Definitions",
      "section_title": true,
      "ja": "2. 用語と定義"
    },
    {
      "indent": 3,
      "text": "In this document, the key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" are to be interpreted as described in BCP 14, RFC 2119 [RFC2119]. This RFC indicates requirement levels for compliant TCP implementations implementing the NewReno Fast Retransmit and Fast Recovery algorithms described in this document.",
      "ja": "このドキュメントでは、キーワードは「必要はない」、「必須」、「必要」、「shall」、「suff」、 \"nove\"、 \"bulsed\"、 \"becommended\"、 \"、\"、 \"、\" optional \"BCP 14、RFC 2119 [RFC2119]に記載されているとおりに解釈されます。このRFCは、このドキュメントで説明されているNewReno Fast Rectransmitと高速回復アルゴリズムを実装する準拠したTCP実装の要件レベルを示します。"
    },
    {
      "indent": 3,
      "text": "This document assumes that the reader is familiar with the terms SENDER MAXIMUM SEGMENT SIZE (SMSS), CONGESTION WINDOW (cwnd), and FLIGHT SIZE (FlightSize) defined in [RFC2581]. FLIGHT SIZE is defined as in [RFC2581] as follows:",
      "ja": "このドキュメントは、読者が[RFC2581]で定義されている最大セグメントサイズ（SMSS）、輻輳ウィンドウ（CWND）、およびフライトサイズ（フライトサイズ）という用語に精通していることを前提としています。飛行サイズは、次のように[RFC2581]のように定義されます。"
    },
    {
      "indent": 6,
      "text": "FLIGHT SIZE: The amount of data that has been sent but not yet acknowledged.",
      "ja": "飛行サイズ：送信されたがまだ認められていないデータの量。"
    },
    {
      "indent": 0,
      "text": "3. The Fast Retransmit and Fast Recovery Algorithms in NewReno",
      "section_title": true,
      "ja": "3. NewRenoの高速再送信および高速回復アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The standard implementation of the Fast Retransmit and Fast Recovery algorithms is given in [RFC2581]. This section specifies the basic NewReno algorithm. Sections 4 through 6 describe some optional variants, and the motivations behind them, that an implementor may want to consider when tuning performance for certain network scenarios. Sections 7 and 8 provide some guidance to implementors based on experience with NewReno implementations.",
      "ja": "高速再送信および高速回復アルゴリズムの標準的な実装は、[RFC2581]に記載されています。このセクションでは、基本的なNewRenoアルゴリズムを指定します。セクション4〜6は、特定のネットワークシナリオのパフォーマンスを調整する際に実装者が検討したい場合が、いくつかのオプションのバリアントとその背後にある動機について説明します。セクション7と8は、NewRenoの実装の経験に基づいて、実装者へのガイダンスを提供します。"
    },
    {
      "indent": 3,
      "text": "The NewReno modification concerns the Fast Recovery procedure that begins when three duplicate ACKs are received and ends when either a retransmission timeout occurs or an ACK arrives that acknowledges all of the data up to and including the data that was outstanding when the Fast Recovery procedure began.",
      "ja": "Newrenoの変更は、3つの重複したACKを受信し、再送信タイムアウトが発生したときに終了するか、ACKが到着したときに終了する高速回復手順に関するもので、高速回復手順が開始されたときに顕著なデータを含むすべてのデータを認識します。"
    },
    {
      "indent": 3,
      "text": "The NewReno algorithm specified in this document differs from the implementation in [RFC2581] in the introduction of the variable \"recover\" in step 1, in the response to a partial or new acknowledgement in step 5, and in modifications to step 1 and the addition of step 6 for avoiding multiple Fast Retransmits caused by the retransmission of packets already received by the receiver.",
      "ja": "このドキュメントで指定されたNewRenoアルゴリズムは、[RFC2581]の実装とは、ステップ1の「回復」、ステップ5の部分的または新しい承認への応答、およびステップ1および追加の修正とともに、[RFC2581]の導入とは異なります。レシーバーが既に受け取ったパケットの再送信によって引き起こされる複数の高速再送信を回避するためのステップ6の。"
    },
    {
      "indent": 3,
      "text": "The algorithm specified in this document uses a variable \"recover\", whose initial value is the initial send sequence number.",
      "ja": "このドキュメントで指定されたアルゴリズムは、変数「回復」を使用します。その初期値は初期送信シーケンス番号です。"
    },
    {
      "indent": 3,
      "text": "1) Three duplicate ACKs: When the third duplicate ACK is received and the sender is not already in the Fast Recovery procedure, check to see if the Cumulative Acknowledgement field covers more than \"recover\". If so, go to Step 1A. Otherwise, go to Step 1B.",
      "ja": "1) 3つの重複ACK：3番目の重複ACKが受信され、送信者がまだ高速回復手順になっていない場合、累積確認フィールドが「回復」以上のカバーがカバーされているかどうかを確認します。その場合は、ステップ1Aに進みます。それ以外の場合は、ステップ1bに移動します。"
    },
    {
      "indent": 3,
      "text": "1A) Invoking Fast Retransmit: If so, then set ssthresh to no more than the value given in equation 1 below. (This is equation 3 from [RFC2581]).",
      "ja": "1a）高速再送信の呼び出し：その場合、ssthreshを以下の方程式1に示す値を超えて設定します。（これは[RFC2581]の式3です）。"
    },
    {
      "indent": 9,
      "text": "ssthresh = max (FlightSize / 2, 2*SMSS)           (1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "In addition, record the highest sequence number transmitted in the variable \"recover\", and go to Step 2.",
      "ja": "さらに、変数「回復」に送信される最高のシーケンス番号を記録し、ステップ2に進みます。"
    },
    {
      "indent": 3,
      "text": "1B) Not invoking Fast Retransmit: Do not enter the Fast Retransmit and Fast Recovery procedure. In particular, do not change ssthresh, do not go to Step 2 to retransmit the \"lost\" segment, and do not execute Step 3 upon subsequent duplicate ACKs.",
      "ja": "1b）速い再送信を呼び出さない：高速再送信および高速回復手順を入力しないでください。特に、ssthreshを変更せず、ステップ2にアクセスして「失われた」セグメントを再送信しないでください。また、その後の重複ACKでステップ3を実行しないでください。"
    },
    {
      "indent": 3,
      "text": "2) Entering Fast Retransmit: Retransmit the lost segment and set cwnd to ssthresh plus 3*SMSS. This artificially \"inflates\" the congestion window by the number of segments (three) that have left the network and the receiver has buffered.",
      "ja": "2) 高速再送信の入力：失われたセグメントを再送信し、cwndをSSthreshプラス3*SMSSに設定します。これは、ネットワークを離れ、受信機がバッファリングされたセグメントの数（3）だけで、輻輳ウィンドウを人為的に「膨らませる」。"
    },
    {
      "indent": 3,
      "text": "3) Fast Recovery: For each additional duplicate ACK received while in Fast Recovery, increment cwnd by SMSS. This artificially inflates the congestion window in order to reflect the additional segment that has left the network.",
      "ja": "3) 高速回復：迅速な回復中に受信した追加の複製ACKごとに、SMSSによるCWNDを増やします。これにより、ネットワークを去った追加セグメントを反映するために、混雑ウィンドウを人為的に膨らませます。"
    },
    {
      "indent": 3,
      "text": "4) Fast Recovery, continued: Transmit a segment, if allowed by the new value of cwnd and the receiver's advertised window.",
      "ja": "4) 迅速な回復、継続：CWNDの新しい値と受信機の宣伝されたウィンドウで許可されている場合、セグメントを送信します。"
    },
    {
      "indent": 3,
      "text": "5) When an ACK arrives that acknowledges new data, this ACK could be the acknowledgment elicited by the retransmission from step 2, or elicited by a later retransmission.",
      "ja": "5) 新しいデータを認めるACKが到着すると、このACKは、ステップ2からの再送信によって誘発される承認である可能性があります。"
    },
    {
      "indent": 7,
      "text": "Full acknowledgements: If this ACK acknowledges all of the data up to and including \"recover\", then the ACK acknowledges all the intermediate segments sent between the original transmission of the lost segment and the receipt of the third duplicate ACK. Set cwnd to either (1) min (ssthresh, FlightSize + SMSS) or (2) ssthresh, where ssthresh is the value set in step 1; this is termed \"deflating\" the window. (We note that \"FlightSize\" in step 1 referred to the amount of data outstanding in step 1, when Fast Recovery was entered, while \"FlightSize\" in step 5 refers to the amount of data outstanding in step 5, when Fast Recovery is exited.) If the second option is selected, the implementation is encouraged to take measures to avoid a possible burst of data, in case the amount of data outstanding in the network is much less than the new congestion window allows. A simple mechanism is to limit the number of data packets that can be sent in response to a single acknowledgement; this is known as \"maxburst_\" in the NS simulator. Exit the Fast Recovery procedure.",
      "ja": "完全な謝辞：このACKが「回復」までのすべてのデータを認めた場合、ACKは、失われたセグメントの元の送信と3番目の重複ACKの受領の間に送信されるすべての中間セグメントを認めます。CWNDを（1）min（sSthresh、Flightsize SMSS）または（2）SSthreshのいずれかに設定します。ここで、SSthreshはステップ1に設定された値です。これは、ウィンドウを「デフレ」と呼びます。（ステップ1の「フライトサイズ」は、高速回復が入力されたステップ1の未解決のデータの量を指し、ステップ5の「フライトサイズ」は、高速回復が終了するステップ5の未解決のデータの量を指します。。）2番目のオプションが選択されている場合、ネットワーク内の未解決のデータの量が新しい輻輳ウィンドウが許可されている場合よりもはるかに少ない場合に備えて、データのバーストを回避するための措置を講じることが奨励されます。簡単なメカニズムは、単一の承認に応じて送信できるデータパケットの数を制限することです。これは、NSシミュレーターで「maxburst_」として知られています。高速回復手順を終了します。"
    },
    {
      "indent": 7,
      "text": "Partial acknowledgements: If this ACK does *not* acknowledge all of the data up to and including \"recover\", then this is a partial ACK. In this case, retransmit the first unacknowledged segment. Deflate the congestion window by the amount of new data acknowledged by the cumulative acknowledgement field. If the partial ACK acknowledges at least one SMSS of new data, then add back SMSS bytes to the congestion window. As in Step 3, this artificially inflates the congestion window in order to reflect the additional segment that has left the network. Send a new segment if permitted by the new value of cwnd. This \"partial window deflation\" attempts to ensure that, when Fast Recovery eventually ends, approximately ssthresh amount of data will be outstanding in the network. Do not exit the Fast Recovery procedure (i.e., if any duplicate ACKs subsequently arrive, execute Steps 3 and 4 above).",
      "ja": "部分的な承認：このACKが「回復」までのすべてのデータを *認識しない場合、これは部分的なACKです。この場合、最初の未承認セグメントを再送信します。累積認識フィールドによって認められる新しいデータの量だけで、輻輳ウィンドウをデフレートします。部分的なACKが少なくとも1つの新しいデータのSMSSを認識している場合は、SMSSバイトをうっ血ウィンドウに追加します。ステップ3のように、これはネットワークを離れた追加セグメントを反映するために、人為的に混雑ウィンドウを膨らませます。CWNDの新しい値で許可されている場合は、新しいセグメントを送信します。この「部分的なウィンドウデフレーション」は、最終的に速い回復が終了すると、ネットワークで約SSTHRESH量のデータが顕著になることを保証しようとします。高速回復手順を終了しないでください（つまり、重複したACKがその後到着した場合は、上記の手順3と4を実行します）。"
    },
    {
      "indent": 7,
      "text": "For the first partial ACK that arrives during Fast Recovery, also reset the retransmit timer. Timer management is discussed in more detail in Section 4.",
      "ja": "速い回復中に到着する最初の部分的なACKについては、再送信タイマーもリセットします。タイマー管理については、セクション4で詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "6) Retransmit timeouts: After a retransmit timeout, record the highest sequence number transmitted in the variable \"recover\" and exit the Fast Recovery procedure if applicable.",
      "ja": "6) 再送信タイムアウト：再送信タイムアウトの後、変数「回復」に送信された最高のシーケンス番号を記録し、該当する場合は高速回復手順を終了します。"
    },
    {
      "indent": 3,
      "text": "Step 1 specifies a check that the Cumulative Acknowledgement field covers more than \"recover\". Because the acknowledgement field contains the sequence number that the sender next expects to receive, the acknowledgement \"ack_number\" covers more than \"recover\" when:",
      "ja": "ステップ1累積確認フィールドが「回復」以上のものをカバーすることをチェックします。確認フィールドには、送信者が次に受け取る予定のシーケンス番号が含まれているため、「ACK_NUMBER」は次のときに「回復」を超える「ACK_Number」をカバーしています。"
    },
    {
      "indent": 6,
      "text": "ack_number - 1 > recover;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "i.e., at least one byte more of data is acknowledged beyond the highest byte that was outstanding when Fast Retransmit was last entered.",
      "ja": "つまり、少なくとも1つのバイト多くのデータが、速い再送信が最後に入力されたときに未解決の最高バイトを超えて認められています。"
    },
    {
      "indent": 3,
      "text": "Note that in Step 5, the congestion window is deflated after a partial acknowledgement is received. The congestion window was likely to have been inflated considerably when the partial acknowledgement was received. In addition, depending on the original pattern of packet losses, the partial acknowledgement might acknowledge nearly a window of data. In this case, if the congestion window was not deflated, the data sender might be able to send nearly a window of data back-to-back.",
      "ja": "ステップ5では、部分的な認識が受信された後、輻輳ウィンドウが収縮されることに注意してください。部分的な承認を受け取ったとき、輻輳窓はかなり膨らんだ可能性がありました。さらに、パケット損失の元のパターンに応じて、部分的な認識は、ほぼデータのウィンドウを認める可能性があります。この場合、輻輳ウィンドウが収縮していない場合、データ送信者はデータのほぼ窓を連続して送信できる可能性があります。"
    },
    {
      "indent": 3,
      "text": "This document does not specify the sender's response to duplicate ACKs when the Fast Retransmit/Fast Recovery algorithm is not invoked. This is addressed in other documents, such as those describing the Limited Transmit procedure [RFC3042]. This document also does not address issues of adjusting the duplicate acknowledgement threshold, but assumes the threshold specified in the IETF standards; the current standard is RFC 2581, which specifies a threshold of three duplicate acknowledgements.",
      "ja": "このドキュメントでは、高速再送信/高速回復アルゴリズムが呼び出されていない場合、ACKの重複に対する送信者の応答は指定されていません。これは、限られた送信手順[RFC3042]を説明する文書など、他のドキュメントで扱われます。また、このドキュメントは、重複する確認のしきい値を調整する問題にも対処していませんが、IETF標準で指定されたしきい値を想定しています。現在の標準はRFC 2581で、3つの重複謝辞のしきい値を指定しています。"
    },
    {
      "indent": 3,
      "text": "As a final note, we would observe that in the absence of the SACK option, the data sender is working from limited information. When the issue of recovery from multiple dropped packets from a single window of data is of particular importance, the best alternative would be to use the SACK option.",
      "ja": "最後のメモとして、SACKオプションがない場合、データ送信者は限られた情報から動作していることがわかります。データの1つのウィンドウから複数のドロップされたパケットからの回復の問題が特に重要である場合、最良の選択肢はSACKオプションを使用することです。"
    },
    {
      "indent": 0,
      "text": "4. Resetting the Retransmit Timer in Response to Partial Acknowledgements",
      "section_title": true,
      "ja": "4. 部分的な謝辞に応じて再送信タイマーをリセットします"
    },
    {
      "indent": 3,
      "text": "One possible variant to the response to partial acknowledgements specified in Section 3 concerns when to reset the retransmit timer after a partial acknowledgement. The algorithm in Section 3, Step 5, resets the retransmit timer only after the first partial ACK. In this case, if a large number of packets were dropped from a window of data, the TCP data sender's retransmit timer will ultimately expire, and the TCP data sender will invoke Slow-Start. (This is illustrated on page 12 of [F98].) We call this the Impatient variant of NewReno. We note that the Impatient variant in Section 3 doesn't follow the recommended algorithm in RFC 2988 of restarting the retransmit timer after every packet transmission or retransmission [RFC2988, Step 5.1].",
      "ja": "セクション3で指定された部分的な承認に対する応答に対する1つの可能なバリアントは、部分的な承認後に再送信タイマーをリセットするときに懸念されます。セクション3のアルゴリズム、ステップ5は、最初の部分ACKの後にのみ再送信タイマーをリセットします。この場合、データのウィンドウから多数のパケットがドロップされた場合、TCPデータ送信者の再送信タイマーは最終的に期限切れになり、TCPデータ送信者はスロースタートを呼び出します。（これは[F98]の12ページに示されています。）これをNewRenoのせっかちなバリアントと呼びます。セクション3のせっかちなバリアントは、すべてのパケット送信または再送信の後に再送信タイマーを再起動するRFC 2988の推奨されるアルゴリズムに従っていないことに注意してください[RFC2988、ステップ5.1]。"
    },
    {
      "indent": 3,
      "text": "In contrast, the NewReno simulations in [FF96] illustrate the algorithm described above with the modification that the retransmit timer is reset after each partial acknowledgement. We call this the Slow-but-Steady variant of NewReno. In this case, for a window with a large number of packet drops, the TCP data sender retransmits at most one packet per roundtrip time. (This behavior is illustrated in the New-Reno TCP simulation of Figure 5 in [FF96], and on page 11 of [F98]).",
      "ja": "対照的に、[FF96]のNewRenoシミュレーションは、各部分的な認識の後に再送信タイマーがリセットされるという変更とともに、上記のアルゴリズムを示しています。これを、newrenoのゆっくりとした状態の多いバリアントと呼びます。この場合、多数のパケットドロップを備えたウィンドウの場合、TCPデータ送信者は、往復時間ごとに最大1つのパケットで再送信されます。（この動作は、[FF96]の図5のNew-Reno TCPシミュレーションと[F98]の11ページに示されています）。"
    },
    {
      "indent": 3,
      "text": "When N packets have been dropped from a window of data for a large value of N, the Slow-but-Steady variant can remain in Fast Recovery for N round-trip times, retransmitting one more dropped packet each round-trip time; for these scenarios, the Impatient variant gives a faster recovery and better performance. The tests \"ns test-suite-newreno.tcl impatient1\" and \"ns test-suite-newreno.tcl slow1\" in the NS simulator illustrate such a scenario, where the Impatient variant performs better than the Slow-but-Steady variant. The Impatient variant can be particularly important for TCP connections with large congestion windows, as illustrated by the tests \"ns test-suite-newreno.tcl impatient4\" and \"ns test-suite-newreno.tcl slow4\" in the NS simulator.",
      "ja": "NパケットがNの大きな値のデータのウィンドウからドロップされた場合、nラウンドトリップ時間のn-round-trip時間の速い回復のままでいる可能性があり、各往復時間を再び削除します。これらのシナリオでは、せっかちなバリアントが回復を速く、パフォーマンスを向上させます。NSシミュレーターの「NS Test-Suite-Newreno.tcl Impatient1」および「NS Test-Suite-newreno.tcl slow1」のテストは、スローですが、スローが止まったバリアントよりも優れたパフォーマンスを発揮するこのようなシナリオを示しています。NSシミュレーターの「NS Test-Suite-Newreno.tcl Impatient4」および「NS Test-Suite-Newreno.tcl Slow4」と「NS Test-Suite-Newreno.tcl Impleno.tcl slow4」で示されているように、大きなうっ血窓とのTCP接続にとって、せっかちなバリアントは特に重要です。"
    },
    {
      "indent": 3,
      "text": "One can also construct scenarios where the Slow-but-Steady variant gives better performance than the Impatient variant. As an example, this occurs when only a small number of packets are dropped, the RTO is sufficiently small that the retransmit timer expires, and performance would have been better without a retransmit timeout. The tests \"ns test-suite-newreno.tcl impatient2\" and \"ns test-suite-newreno.tcl slow2\" in the NS simulator illustrate such a scenario.",
      "ja": "また、ゆっくりと浸透したバリアントがせっかちなバリアントよりも優れたパフォーマンスを提供するシナリオを構築することもできます。例として、これは少数のパケットのみがドロップされ、RTOが十分に小さく、再送信タイマーの有効期限が切れ、再送信タイムアウトなしでパフォーマンスが向上した場合に発生します。NSシミュレーターの「NS Test-Suite-Newreno.tcl Impatient2」および「NS Test-Suite-Newreno.tcl Slow2」のテストは、このようなシナリオを示しています。"
    },
    {
      "indent": 3,
      "text": "The Slow-but-Steady variant can also achieve higher goodput than the Impatient variant, by avoiding unnecessary retransmissions. This could be of special interest for cellular links, where every transmission costs battery power and money. The tests \"ns test-suite-newreno.tcl impatient3\" and \"ns test-suite-newreno.tcl slow3\" in the NS simulator illustrate such a scenario. The Slow-but-Steady variant can also be more robust to delay variation in the network, where a delay spike might force the Impatient variant into a timeout and go-back-N recovery.",
      "ja": "不必要な再送信を回避することにより、ゆっくりと浸透したバリアントは、せっかちなバリアントよりも高いグッドプットを達成することもできます。これは、すべてのトランスミッションがバッテリーの電源とお金にかかるセルラーリンクにとって特別な関心事である可能性があります。NSシミュレーターの「NS Test-Suite-Newreno.tcl Impatient3」および「NS Test-Suite-Newreno.tcl Slow3」のテストは、このようなシナリオを示しています。また、ゆっくりと浸透しているバリアントは、ネットワークの変動を遅らせるためにより堅牢になります。遅延スパイクにより、焦りのバリアントがタイムアウトとGo-Back-Nの回復に強いられる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Neither of the two variants discussed above are optimal. Our recommendation is for the Impatient variant, as specified in Section 3 of this document, because of the poor performance of the Slow-but-Steady variant for TCP connections with large congestion windows.",
      "ja": "上記の2つのバリアントのいずれも最適ではありません。このドキュメントのセクション3で指定されているように、私たちの推奨事項は、大きな輻輳ウィンドウを備えたTCP接続のゆっくりとした浸透したバリアントのパフォーマンスが低いためです。"
    },
    {
      "indent": 3,
      "text": "One possibility for a more optimal algorithm would be one that recovered from multiple packet drops as quickly as does slow-start, while resetting the retransmit timers after each partial acknowledgement, as described in the section below. We note, however, that there is a limitation to the potential performance in this case in the absence of the SACK option.",
      "ja": "より最適なアルゴリズムの可能性の1つは、以下のセクションで説明されているように、各部分的な確認の後に再送信タイマーをリセットしながら、スロースタートと同じくらい速くスタートするのと同じくらい速く複数のパケットドロップから回復したものです。ただし、サックオプションがない場合、この場合、潜在的なパフォーマンスには制限があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "5. Retransmissions after a Partial Acknowledgement",
      "section_title": true,
      "ja": "5. 部分的な認識後の再送信"
    },
    {
      "indent": 3,
      "text": "One possible variant to the response to partial acknowledgements specified in Section 3 would be to retransmit more than one packet after each partial acknowledgement, and to reset the retransmit timer after each retransmission. The algorithm specified in Section 3 retransmits a single packet after each partial acknowledgement. This is the most conservative alternative, in that it is the least likely to result in an unnecessarily-retransmitted packet. A variant that would recover faster from a window with many packet drops would be to effectively Slow-Start, retransmitting two packets after each partial acknowledgement. Such an approach would take less than N roundtrip times to recover from N losses [Hoe96]. However, in the absence of SACK, recovering as quickly as slow-start introduces the likelihood of unnecessarily retransmitting packets, and this could significantly complicate the recovery mechanisms.",
      "ja": "セクション3で指定された部分的な承認に対する応答の1つの可能なバリアントは、各部分的な確認後に複数のパケットを再送信し、各再送信後に再送信タイマーをリセットすることです。セクション3で指定されたアルゴリズムは、各部分的な確認の後に単一のパケットを再送信します。これは、不必要に再配置されたパケットをもたらす可能性が最も低いという点で、最も保守的な代替手段です。多くのパケットドロップでウィンドウからより速く回復するバリアントは、各部分的な確認後に2つのパケットを再送信して、効果的にスロースタートすることです。このようなアプローチは、N損失から回復するのにnの往復時間がかかりません[Hoe96]。ただし、袋が存在しない場合、スロースタートと同じくらい迅速に回復すると、パケットが不必要に再送信される可能性が導入され、これにより回復メカニズムが大幅に複雑になります。"
    },
    {
      "indent": 3,
      "text": "We note that the response to partial acknowledgements specified in Section 3 of this document and in RFC 2582 differs from the response in [FF96], even though both approaches only retransmit one packet in response to a partial acknowledgement. Step 5 of Section 3 specifies that the TCP sender responds to a partial ACK by deflating the congestion window by the amount of new data acknowledged, adding back SMSS bytes if the partial ACK acknowledges at least SMSS bytes of new data, and sending a new segment if permitted by the new value of cwnd. Thus, only one previously-sent packet is retransmitted in response to each partial acknowledgement, but additional new packets might be transmitted as well, depending on the amount of new data acknowledged by the partial acknowledgement. In contrast, the variant of NewReno illustrated in [FF96] simply set the congestion window to ssthresh when a partial acknowledgement was received. The approach in [FF96] is more conservative, and does not attempt to accurately track the actual number of outstanding packets after a partial acknowledgement is received. While either of these approaches gives acceptable performance, the variant specified in Section 3 recovers more smoothly when multiple packets are dropped from a window of data. (The [FF96] behavior can be seen in the NS simulator by setting the variable \"partial_window_deflation_\" for \"Agent/TCP/Newreno\" to 0; the behavior specified in Section 3 is achieved by setting \"partial_window_deflation_\" to 1.)",
      "ja": "このドキュメントのセクション3およびRFC 2582で指定された部分的な承認への応答は、[FF96]の応答とは異なることに注意してください。セクション3のステップ5は、TCP送信者が、確認された新しいデータの量だけで輻輳ウィンドウをデフレすることにより、部分的なACKに応答し、部分的なACKが少なくとも新しいデータのSMSSバイトを認め、新しいセグメントを送信する場合、SMSSバイテスを追加することにより、部分的なACKに応答することを指定します。CWNDの新しい値によって許可されている場合。したがって、各部分的な承認に応じて再送信された以前にセントしたパケットは1つだけですが、部分的な承認によって認められる新しいデータの量に応じて、追加の新しいパケットも送信される場合があります。対照的に、[FF96]に示されているNewrenoのバリアントは、部分的な認識が受け取られたときに、混雑ウィンドウをSSthreshに設定するだけです。[FF96]のアプローチはより保守的であり、部分的な承認を受け取った後、実際の顕著なパケットの数を正確に追跡しようとはしません。これらのアプローチのいずれかが許容可能なパフォーマンスを提供しますが、セクション3で指定されたバリアントは、データのウィンドウから複数のパケットがドロップされると、よりスムーズに回復します。（[FF96]動作は、「Agent/TCP/NewReno」の変数「partial_window_deflation_」を0に設定することにより、NSシミュレーターで見ることができます。"
    },
    {
      "indent": 0,
      "text": "6. Avoiding Multiple Fast Retransmits",
      "section_title": true,
      "ja": "6. 複数の高速再送信を避けます"
    },
    {
      "indent": 3,
      "text": "This section describes the motivation for the sender's state variable \"recover\", and discusses possible heuristics for distinguishing between a retransmitted packet that was dropped, and three duplicate acknowledgements from the unnecessary retransmission of three packets.",
      "ja": "このセクションでは、送信者の状態変数「回復」の動機について説明し、ドロップされた再送信パケットと、3つのパケットの不必要な再送信からの3つの重複した謝辞を区別するための可能なヒューリスティックについて説明します。"
    },
    {
      "indent": 3,
      "text": "In the absence of the SACK option or timestamps, a duplicate acknowledgement carries no information to identify the data packet or packets at the TCP data receiver that triggered that duplicate acknowledgement. In this case, the TCP data sender is unable to distinguish between a duplicate acknowledgement that results from a lost or delayed data packet, and a duplicate acknowledgement that results from the sender's unnecessary retransmission of a data packet that had already been received at the TCP data receiver. Because of this, with the Retransmit and Fast Recovery algorithms in Reno TCP, multiple segment losses from a single window of data can sometimes result in unnecessary multiple Fast Retransmits (and multiple reductions of the congestion window) [F94].",
      "ja": "SACKオプションまたはタイムスタンプがない場合、重複した謝辞には、その複製の確認をトリガーしたTCPデータ受信機のデータパケットまたはパケットを識別するための情報が含まれていません。この場合、TCPデータ送信者は、データパケットの紛失または遅延されたデータパケットの結果として生じる重複認識と、TCPデータで既に受信されたデータパケットの不必要な再送信に起因する重複した承認を区別することができません。受信機。このため、RENO TCPの再送信および高速回復アルゴリズムにより、単一のデータウィンドウからの複数のセグメント損失により、不必要な複数の高速再送信（および輻輳ウィンドウの複数の削減）が発生する場合があります[F94]。"
    },
    {
      "indent": 3,
      "text": "With the Fast Retransmit and Fast Recovery algorithms in Reno TCP, the performance problems caused by multiple Fast Retransmits are relatively minor compared to the potential problems with Tahoe TCP, which does not implement Fast Recovery. Nevertheless, unnecessary Fast Retransmits can occur with Reno TCP unless some explicit mechanism is added to avoid this, such as the use of the \"recover\" variable. (This modification is called \"bugfix\" in [F98], and is illustrated on pages 7 and 9 of that document. Unnecessary Fast Retransmits for Reno without \"bugfix\" is illustrated on page 6 of [F98].)",
      "ja": "Reno TCPの高速再送信および高速回復アルゴリズムにより、複数の高速再送信によって引き起こされるパフォーマンスの問題は、タホTCPの潜在的な問題と比較して比較的軽微です。それにもかかわらず、「回復」変数の使用など、これを回避するために何らかの明示的なメカニズムが追加されない限り、リノTCPで不必要な高速再送信が発生する可能性があります。（この変更は[F98]の「bugfix」と呼ばれ、そのドキュメントの7ページと9ページに示されています。「bugfix」のないリノの不必要な高速再送信は、[F98]の6ページに示されています。）"
    },
    {
      "indent": 3,
      "text": "Section 3 of [RFC2582] defined a default variant of NewReno TCP that did not use the variable \"recover\", and did not check if duplicate ACKs cover the variable \"recover\" before invoking Fast Retransmit. With this default variant from RFC 2582, the problem of multiple Fast Retransmits from a single window of data can occur after a Retransmit Timeout (as in page 8 of [F98]) or in scenarios with reordering (as in the validation test \"./test-all-newreno newreno5_noBF\" in directory \"tcl/test\" of the NS simulator. This gives performance similar to that on page 8 of [F03].) RFC 2582 also defined Careful and Less Careful variants of the NewReno algorithm, and recommended the Careful variant.",
      "ja": "[RFC2582]のセクション3は、変数「回復」を使用しないNewReno TCPのデフォルトバリアントを定義し、速い再送信を呼び出す前に、ACKが複製する「回復」をカバーしているかどうかを確認しませんでした。RFC 2582からのこのデフォルトのバリアントでは、単一のデータウィンドウから複数の高速再送信の問題は、再送信タイムアウト（[F98]の8ページのように）または並べ替えのシナリオ（検証テストのように」で発生する可能性があります。NSシミュレーターのディレクトリ「TCL/テスト」のテスト-All-Newreno NewReno5_NOBF。これにより、[F03]の8ページのパフォーマンスも同様になります。慎重なバリアント。"
    },
    {
      "indent": 3,
      "text": "The algorithm specified in Section 3 of this document corresponds to the Careful variant of NewReno TCP from RFC 2582, and eliminates the problem of multiple Fast Retransmits. This algorithm uses the variable \"recover\", whose initial value is the initial send sequence number. After each retransmit timeout, the highest sequence number transmitted so far is recorded in the variable \"recover\".",
      "ja": "このドキュメントのセクション3で指定されたアルゴリズムは、RFC 2582のNewReno TCPの慎重なバリアントに対応し、複数の高速再送信の問題を排除します。このアルゴリズムは、変数「回復」を使用します。これは、初期値が初期送信シーケンス番号です。各再送信タイムアウトの後、これまで送信された最高のシーケンス数は変数「回復」に記録されます。"
    },
    {
      "indent": 3,
      "text": "If, after a retransmit timeout, the TCP data sender retransmits three consecutive packets that have already been received by the data receiver, then the TCP data sender will receive three duplicate acknowledgements that do not cover more than \"recover\". In this case, the duplicate acknowledgements are not an indication of a new instance of congestion. They are simply an indication that the sender has unnecessarily retransmitted at least three packets.",
      "ja": "再送信タイムアウトの後、TCPデータ送信者がデータ受信機によって既に受信された3つの連続したパケットを再送信した場合、TCPデータ送信者は、「回復」以上のカバーをカバーしない3つの重複した謝辞を受け取ります。この場合、重複する謝辞は、渋滞の新しいインスタンスの兆候ではありません。それらは、送信者が少なくとも3つのパケットを不必要に再送信したことを単に示しています。"
    },
    {
      "indent": 3,
      "text": "However, when a retransmitted packet is itself dropped, the sender can also receive three duplicate acknowledgements that do not cover more than \"recover\". In this case, the sender would have been better off if it had initiated Fast Retransmit. For a TCP that implements the algorithm specified in Section 3 of this document, the sender does not infer a packet drop from duplicate acknowledgements in this scenario. As always, the retransmit timer is the backup mechanism for inferring packet loss in this case.",
      "ja": "ただし、再送信されたパケット自体がドロップされると、送信者は「回復」以上のカバーをカバーしない3つの重複した謝辞を受け取ることもできます。この場合、送信者は、迅速な再送信を開始した場合、より良いものでした。このドキュメントのセクション3で指定されているアルゴリズムを実装するTCPの場合、送信者は、このシナリオの重複謝辞からのパケットドロップを推測しません。いつものように、再送信タイマーは、この場合のパケット損失を推測するためのバックアップメカニズムです。"
    },
    {
      "indent": 3,
      "text": "There are several heuristics, based on timestamps or on the amount of advancement of the cumulative acknowledgement field, that allow the sender to distinguish, in some cases, between three duplicate acknowledgements following a retransmitted packet that was dropped, and three duplicate acknowledgements from the unnecessary retransmission of three packets [Gur03, GF04]. The TCP sender MAY use such a heuristic to decide to invoke a Fast Retransmit in some cases, even when the three duplicate acknowledgements do not cover more than \"recover\".",
      "ja": "タイムスタンプまたは累積認識フィールドの進歩の量に基づいて、いくつかのヒューリスティックがあり、場合によっては、削除された再送信パケットに続いて3つの重複した謝辞と、不必要な3つの重複した謝辞を区別することができます。3つのパケットの再送信[GUR03、GF04]。TCP送信者は、3つの重複した謝辞が「回復」以上のカバーをカバーしていない場合でも、場合によっては高速な再送信を呼び出すことを決定するために、このようなヒューリスティックを使用する場合があります。"
    },
    {
      "indent": 3,
      "text": "For example, when three duplicate acknowledgements are caused by the unnecessary retransmission of three packets, this is likely to be accompanied by the cumulative acknowledgement field advancing by at least four segments. Similarly, a heuristic based on timestamps uses the fact that when there is a hole in the sequence space, the timestamp echoed in the duplicate acknowledgement is the timestamp of the most recent data packet that advanced the cumulative acknowledgement field [RFC1323]. If timestamps are used, and the sender stores the timestamp of the last acknowledged segment, then the timestamp echoed by duplicate acknowledgements can be used to distinguish between a retransmitted packet that was dropped and three duplicate acknowledgements from the unnecessary retransmission of three packets. The heuristics are illustrated in the NS simulator in the validation test \"./test-all-newreno\".",
      "ja": "たとえば、3つのパケットの不必要な再送信によって3つの重複した謝辞が引き起こされる場合、これには少なくとも4つのセグメントで累積的な確認フィールドが進む可能性があります。同様に、タイムスタンプに基づいたヒューリスティックは、シーケンス空間に穴がある場合、重複した謝辞に響き渡るタイムスタンプが、累積認識フィールド[RFC1323]を進歩させた最新のデータパケットのタイムスタンプであるという事実を使用します。タイムスタンプが使用され、送信者が最後に認められたセグメントのタイムスタンプを保存する場合、重複した謝辞に反映されたタイムスタンプを使用して、ドロップされた再送信パケットと3つのパケットの不必要な再送信からの3つの重複した承認を区別できます。ヒューリスティックは、検証テスト「./test-all-newreno」のNSシミュレーターに示されています。"
    },
    {
      "indent": 0,
      "text": "6.1. ACK Heuristic",
      "section_title": true,
      "ja": "6.1. ACKヒューリスティック"
    },
    {
      "indent": 3,
      "text": "If the ACK-based heuristic is used, then following the advancement of the cumulative acknowledgement field, the sender stores the value of the previous cumulative acknowledgement as prev_highest_ack, and stores the latest cumulative ACK as highest_ack. In addition, the following step is performed if Step 1 in Section 3 fails, before proceeding to Step 1B.",
      "ja": "ACKベースのヒューリスティックが使用され、累積承認フィールドの進歩に続いて、送信者は以前の累積承認の価値をprev_highest_ackとして格納し、最新の累積ACKを最高の累積ACKを保存します。さらに、ステップ1Bに進む前に、セクション3のステップ1が失敗した場合、次のステップが実行されます。"
    },
    {
      "indent": 3,
      "text": "1*) If the Cumulative Acknowledgement field didn't cover more than \"recover\", check to see if the congestion window is greater than SMSS bytes and the difference between highest_ack and prev_highest_ack is at most 4*SMSS bytes. If true, duplicate ACKs indicate a lost segment (proceed to Step 1A in Section 3). Otherwise, duplicate ACKs likely result from unnecessary retransmissions (proceed to Step 1B in Section 3).",
      "ja": "1*）累積承認フィールドが「回復」以上のカバーをカバーしなかった場合、輻輳ウィンドウがSMSSバイトよりも大きいかどうかを確認し、hist_ackとprev__highest_ackの違いは最大4*smssバイトです。Trueの場合、複製ACKは失われたセグメントを示します（セクション3のステップ1Aに進みます）。それ以外の場合、ACKの重複は不必要な再送信に起因する可能性があります（セクション3のステップ1Bに進みます）。"
    },
    {
      "indent": 3,
      "text": "The congestion window check serves to protect against fast retransmit immediately after a retransmit timeout, similar to the \"exitFastRetrans_\" variable in NS. Examples of applying the ACK heuristic are in validation tests \"./test-all-newreno newreno_rto_loss_ack\" and \"./test-all-newreno newreno_rto_dup_ack\" in directory \"tcl/test\" of the NS simulator.",
      "ja": "輻輳ウィンドウチェックは、NSの「ExitFastrans_」変数と同様に、再送信タイムアウトの直後に高速再送信から保護するのに役立ちます。ACKヒューリスティックを適用する例は、検証テスト「./test-all-newreno newreno_rto_loss_ack \"and\" ./test-all-newreno newreno_rto_dup_ack \"nsシミュレーターのディレクトリ「TCL/テスト」にあります。"
    },
    {
      "indent": 3,
      "text": "If several ACKs are lost, the sender can see a jump in the cumulative ACK of more than three segments, and the heuristic can fail. A validation test for this scenario is \"./test-all-newreno newreno_rto_loss_ackf\". RFC 2581 recommends that a receiver should send duplicate ACKs for every out-of-order data packet, such as a data packet received during Fast Recovery. The ACK heuristic is more likely to fail if the receiver does not follow this advice, because then a smaller number of ACK losses are needed to produce a sufficient jump in the cumulative ACK.",
      "ja": "いくつかのACKが失われた場合、送信者は3つ以上のセグメントの累積ACKのジャンプを見ることができ、ヒューリスティックが失敗する可能性があります。このシナリオの検証テストは、「./test-all-newreno newreno_rto_loss_ackf」です。RFC 2581は、迅速な回復中に受信したデータパケットなど、順序外データパケットごとにレシーバーが重複したACKを送信することを推奨しています。ACKヒューリスティックは、受信機がこのアドバイスに従わない場合、失敗する可能性が高くなります。なぜなら、累積ACKで十分なジャンプを生成するために少数のACK損失が必要であるためです。"
    },
    {
      "indent": 0,
      "text": "6.2. Timestamp Heuristic",
      "section_title": true,
      "ja": "6.2. タイムスタンプヒューリスティック"
    },
    {
      "indent": 3,
      "text": "If this heuristic is used, the sender stores the timestamp of the last acknowledged segment. In addition, the second paragraph of step 1 in Section 3 is replaced as follows:",
      "ja": "このヒューリスティックが使用されている場合、送信者は最後に認められたセグメントのタイムスタンプを保存します。さらに、セクション3のステップ1の2番目の段落は、次のように置き換えられます。"
    },
    {
      "indent": 3,
      "text": "1**) If the Cumulative Acknowledgement field didn't cover more than \"recover\", check to see if the echoed timestamp in the last non-duplicate acknowledgment equals the stored timestamp. If true, duplicate ACKs indicate a lost segment (proceed to Step 1A in Section 3). Otherwise, duplicate ACKs likely result from unnecessary retransmissions (proceed to Step 1B in Section 3).",
      "ja": "1 **）累積確認フィールドが「回復」以上のカバーをカバーしなかった場合、最後の非複雑な確認のエコーされたタイムスタンプが保存されたタイムスタンプに等しいかどうかを確認してください。Trueの場合、複製ACKは失われたセグメントを示します（セクション3のステップ1Aに進みます）。それ以外の場合、ACKの重複は不必要な再送信に起因する可能性があります（セクション3のステップ1Bに進みます）。"
    },
    {
      "indent": 3,
      "text": "Examples of applying the timestamp heuristic are in validation tests \"./test-all-newreno newreno_rto_loss_tsh\" and \"./test-all-newreno newreno_rto_dup_tsh\". The timestamp heuristic works correctly, both when the receiver echoes timestamps as specified by [RFC1323], and by its revision attempts. However, if the receiver arbitrarily echoes timestamps, the heuristic can fail. The heuristic can also fail if a timeout was spurious and returning ACKs are not from retransmitted segments. This can be prevented by detection algorithms such as [RFC3522].",
      "ja": "タイムスタンプヒューリスティックを適用する例は、検証テスト「./test-all-newreno newreno_rto_loss_tsh」と「./test-all-newreno newreno_rto_dup_tsh」です。タイムスタンプヒューリスティックは、[RFC1323]で指定されたタイムスタンプをエコーしたときとその改訂の試みによって正しく機能します。ただし、受信者が任意にタイムスタンプをエコーすると、ヒューリスティックが失敗する可能性があります。ヒューリスティックは、タイムアウトがスプリアスであり、戻ってくるACKが再送信セグメントからではない場合にも失敗する可能性があります。これは、[RFC3522]などの検出アルゴリズムによって防止できます。"
    },
    {
      "indent": 0,
      "text": "7. Implementation Issues for the Data Receiver",
      "section_title": true,
      "ja": "7. データ受信機の実装の問題"
    },
    {
      "indent": 3,
      "text": "[RFC2581] specifies that \"Out-of-order data segments SHOULD be acknowledged immediately, in order to accelerate loss recovery.\" Neal Cardwell has noted that some data receivers do not send an immediate acknowledgement when they send a partial acknowledgment, but instead wait first for their delayed acknowledgement timer to expire [C98]. As [C98] notes, this severely limits the potential benefit of NewReno by delaying the receipt of the partial acknowledgement at the data sender. Echoing RFC 2581, our recommendation is that the data receiver send an immediate acknowledgement for an out-of-order segment, even when that out-of-order segment fills a hole in the buffer.",
      "ja": "[RFC2581]は、「損失の回復を加速するために、順序外データセグメントをすぐに確認する必要がある」と指定しています。Neal Cardwellは、一部のデータレシーバーは、部分的な承認を送信するときに即時の承認を送信しないが、代わりに遅延承認タイマーが期限切れになるのを最初に待つことに注目しています[C98]。[C98]が指摘しているように、これはデータ送信者での部分的な承認の受領を遅らせることにより、Newrenoの潜在的な利点を厳しく制限します。RFC 2581を反映して、データ受信者は、そのオーダーセグメントがバッファーの穴を埋めた場合でも、順序外セグメントの即時の確認を送信することです。"
    },
    {
      "indent": 0,
      "text": "8. Implementation Issues for the Data Sender",
      "section_title": true,
      "ja": "8. データ送信者の実装の問題"
    },
    {
      "indent": 3,
      "text": "In Section 3, Step 5 above, it is noted that implementations should take measures to avoid a possible burst of data when leaving Fast Recovery, in case the amount of new data that the sender is eligible to send due to the new value of the congestion window is large. This can arise during NewReno when ACKs are lost or treated as pure window updates, thereby causing the sender to underestimate the number of new segments that can be sent during the recovery procedure. Specifically, bursts can occur when the FlightSize is much less than the new congestion window when exiting from Fast Recovery. One simple mechanism to avoid a burst of data when leaving Fast Recovery is to limit the number of data packets that can be sent in response to a single acknowledgment. (This is known as \"maxburst_\" in the ns simulator.) Other possible mechanisms for avoiding bursts include rate-based pacing, or setting the slow-start threshold to the resultant congestion window and then resetting the congestion window to FlightSize. A recommendation on the general mechanism to avoid excessively bursty sending patterns is outside the scope of this document.",
      "ja": "上記のステップ3のセクション3では、輻輳の新しい値が原因で送信者が送信する資格がある新しいデータの量が迅速に回復するときに、データのバーストを避けるために実装が測定されるべきであることに注意してください。窓は大きいです。これは、ACKが純粋なウィンドウの更新として紛失または扱われると、Newrenoの間に発生する可能性があり、それにより、送信者が回復手順中に送信できる新しいセグメントの数を過小評価します。具体的には、速い回復から出るときにフライトサイズが新しい輻輳ウィンドウよりもはるかに少ないときにバーストが発生する可能性があります。迅速な回復を残すときにデータのバーストを回避するための1つの簡単なメカニズムは、単一の承認に応じて送信できるデータパケットの数を制限することです。（これは、NSシミュレータで「maxburst_」として知られています。）バーストを避けるための他の可能なメカニズムには、レートベースのペーシング、または結果の輻輳ウィンドウにスロースタートしきい値を設定し、輻輳ウィンドウをフライトサイズにリセットすることが含まれます。過度に破裂した送信パターンを避けるための一般的なメカニズムに関する推奨事項は、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "An implementation may want to use a separate flag to record whether or not it is presently in the Fast Recovery procedure. The use of the value of the duplicate acknowledgment counter for this purpose is not reliable because it can be reset upon window updates and out-of-order acknowledgments.",
      "ja": "実装は、現在、速い回復手順にあるかどうかを記録するために別のフラグを使用したい場合があります。この目的のための重複確認カウンターの価値の使用は、ウィンドウの更新やオーダーオブオーダーの謝辞にリセットできるため、信頼できません。"
    },
    {
      "indent": 3,
      "text": "When not in Fast Recovery, the value of the state variable \"recover\" should be pulled along with the value of the state variable for acknowledgments (typically, \"snd_una\") so that, when large amounts of data have been sent and acked, the sequence space does not wrap and falsely indicate that Fast Recovery should not be entered (Section 3, step 1, last paragraph).",
      "ja": "迅速な回復がない場合、状態変数の「回復」の値は、確認のために状態変数の値（通常は「snd_una」）とともにプルする必要があります。シーケンススペースは包まれず、高速回復を入力しないでください（セクション3、ステップ1、最後の段落）。"
    },
    {
      "indent": 3,
      "text": "It is important for the sender to respond correctly to duplicate ACKs received when the sender is no longer in Fast Recovery (e.g., because of a Retransmit Timeout). The Limited Transmit procedure [RFC3042] describes possible responses to the first and second duplicate acknowledgements. When three or more duplicate acknowledgements are received, the Cumulative Acknowledgement field doesn't cover more than \"recover\", and a new Fast Recovery is not invoked, it is important that the sender not execute the Fast Recovery steps (3) and (4) in Section 3. Otherwise, the sender could end up in a chain of spurious timeouts. We mention this only because several NewReno implementations had this bug, including the implementation in the NS simulator. (This bug in the NS simulator was fixed in July 2003, with the variable \"exitFastRetrans_\".)",
      "ja": "送信者は、送信者が速い回復にならなくなったときに受け取った重複ACKに正しく応答することが重要です（たとえば、再送信タイムアウトのため）。限られた送信手順[RFC3042]は、最初と2番目の重複謝辞に対する可能な応答を説明します。3つ以上の重複謝辞を受信した場合、累積的な確認フィールドは「回復」以上のものをカバーせず、新しい高速回復が呼び出されないため、送信者が高速回復ステップ（3）と（4を実行しないことが重要です。）セクション3では、そうでなければ、送信者は偽のタイムアウトのチェーンに到達する可能性があります。これは、NSシミュレーターでの実装を含む、いくつかのNewrenoの実装にこのバグがあったためにのみ言及しています。（NSシミュレーターのこのバグは、2003年7月に変数「ExitFastrans_」で修正されました。）"
    },
    {
      "indent": 0,
      "text": "9. Simulations",
      "section_title": true,
      "ja": "9. シミュレーション"
    },
    {
      "indent": 3,
      "text": "Simulations with NewReno are illustrated with the validation test \"tcl/test/test-all-newreno\" in the NS simulator. The command \"../../ns test-suite-newreno.tcl reno\" shows a simulation with Reno TCP, illustrating the data sender's lack of response to a partial acknowledgement. In contrast, the command \"../../ns test-suite-newreno.tcl newreno_B\" shows a simulation with the same scenario using the NewReno algorithms described in this paper.",
      "ja": "NSシミュレーターの検証テスト「TCL/TEST/TEST-ALL-NEWRENO」を使用して、NewRenoを使用したシミュレーションが示されています。コマンド「..//NS TestSuite-newreno.tcl reno」は、Reno TCPのシミュレーションを示しており、データ送信者の部分的な認識に対する応答の欠如を示しています。対照的に、コマンド「..//NS TestSuite-newreno.tcl newreno_b」は、このペーパーで説明されているNewRenoアルゴリズムを使用して、同じシナリオのシミュレーションを表示します。"
    },
    {
      "indent": 0,
      "text": "10. Comparisons between Reno and NewReno TCP",
      "section_title": true,
      "ja": "10. RenoとNewreno TCPの比較"
    },
    {
      "indent": 3,
      "text": "As we stated in the introduction, we believe that the NewReno modification described in this document improves the performance of the Fast Retransmit and Fast Recovery algorithms of Reno TCP in a wide variety of scenarios. This has been discussed in some depth in [FF96], which illustrates Reno TCP's poor performance when multiple packets are dropped from a window of data and also illustrates NewReno TCP's good performance in that scenario.",
      "ja": "紹介で述べたように、このドキュメントで説明されているNewrenoの変更により、さまざまなシナリオでのReno TCPの高速再送信および高速回復アルゴリズムのパフォーマンスが向上すると考えています。これは[FF96]で何らかの深みで議論されています。これは、データのウィンドウから複数のパケットが削除された場合のReno TCPのパフォーマンスの低下を示し、そのシナリオでのNewreno TCPの優れたパフォーマンスを示しています。"
    },
    {
      "indent": 3,
      "text": "We do, however, know of one scenario where Reno TCP gives better performance than NewReno TCP, that we describe here for the sake of completeness. Consider a scenario with no packet loss, but with sufficient reordering so that the TCP sender receives three duplicate acknowledgements. This will trigger the Fast Retransmit and Fast Recovery algorithms. With Reno TCP or with Sack TCP, this will result in the unnecessary retransmission of a single packet, combined with a halving of the congestion window (shown on pages 4 and 6 of [F03]). With NewReno TCP, however, this reordering will also result in the unnecessary retransmission of an entire window of data (shown on page 5 of [F03]).",
      "ja": "ただし、Reno TCPがNewreno TCPよりも優れたパフォーマンスを提供する1つのシナリオを知っています。これは、完全性のためにここで説明しています。パケットの損失がないが、TCP送信者が3つの重複した謝辞を受け取るように十分な並べ替えを伴うシナリオを検討してください。これにより、高速再送信および高速回復アルゴリズムがトリガーされます。Reno TCPまたはSack TCPを使用すると、これにより、単一のパケットの不必要な再送信が行われ、混雑ウィンドウの半分と組み合わされます（[F03]の4ページと6ページに示されています）。ただし、Newreno TCPを使用すると、この並べ替えにより、データのウィンドウ全体が不必要な再送信も行われます（[F03]の5ページに示されています）。"
    },
    {
      "indent": 3,
      "text": "While Reno TCP performs better than NewReno TCP in the presence of reordering, NewReno's superior performance in the presence of multiple packet drops generally outweighs its less optimal performance in the presence of reordering. (Sack TCP is the preferred solution, with good performance in both scenarios.) This document recommends the Fast Retransmit and Fast Recovery algorithms of NewReno TCP instead of those of Reno TCP for those TCP connections that do not support SACK. We would also note that NewReno's Fast Retransmit and Fast Recovery mechanisms are widely deployed in TCP implementations in the Internet today, as documented in [PF01]. For example, tests of TCP implementations in several thousand web servers in 2001 showed that for those TCP connections where the web browser was not SACK-capable, more web servers used the Fast Retransmit and Fast Recovery algorithms of NewReno than those of Reno or Tahoe TCP [PF01].",
      "ja": "Reno TCPは、並べ替えの存在下でNewreno TCPよりも優れていますが、複数のパケットドロップの存在下でのNewrenoの優れたパフォーマンスは、一般的に、並べ替えの存在下での最適性の低いパフォーマンスを上回ります。（SACK TCPは、両方のシナリオで優れたパフォーマンスを備えた優れたソリューションです。）このドキュメントでは、サックをサポートしていないTCP接続のReno TCPの代わりに、NewReno TCPの高速な再送信および高速回復アルゴリズムを推奨します。また、[PF01]に記載されているように、Newrenoの高速再送信および高速回復メカニズムは、今日のインターネットでのTCP実装に広く展開されていることに注意してください。たとえば、2001年の数千のWebサーバーでのTCP実装のテストでは、Webブラウザーがサックに対応できないTCP接続について、より多くのWebサーバーがRenoまたはTahoe TCPのものよりも速い再送信と高速回復アルゴリズムを使用したことが示されました。[PF01]。"
    },
    {
      "indent": 0,
      "text": "11. Changes Relative to RFC 2582",
      "section_title": true,
      "ja": "11. RFC 2582に関連する変更"
    },
    {
      "indent": 3,
      "text": "The purpose of this document is to advance the NewReno's Fast Retransmit and Fast Recovery algorithms in RFC 2582 to Standards Track.",
      "ja": "このドキュメントの目的は、RFC 2582のNewrenoの高速再送信および高速回復アルゴリズムを標準追跡に進めることです。"
    },
    {
      "indent": 3,
      "text": "The main change in this document relative to RFC 2582 is to specify the Careful variant of NewReno's Fast Retransmit and Fast Recovery algorithms. The base algorithm described in RFC 2582 did not attempt to avoid unnecessary multiple Fast Retransmits that can occur after a timeout (described in more detail in the section above). However, RFC 2582 also defined \"Careful\" and \"Less Careful\" variants that avoid these unnecessary Fast Retransmits, and recommended the Careful variant. This document specifies the previously-named \"Careful\" variant as the basic version of NewReno. As described below, this algorithm uses a variable \"recover\", whose initial value is the send sequence number.",
      "ja": "RFC 2582に対するこのドキュメントの主な変更は、NewRenoの高速再送信および高速回復アルゴリズムの慎重なバリアントを指定することです。RFC 2582で説明されているベースアルゴリズムは、タイムアウト後に発生する可能性のある不必要な複数の高速再送信を避けようとしませんでした（上記のセクションで詳細に説明します）。ただし、RFC 2582は、これらの不必要な高速再送信を回避する「慎重な」および「慎重でない」バリアントを定義し、慎重なバリアントを推奨しました。このドキュメントは、以前に名前が付けられていた「慎重な」バリアントをNewrenoの基本バージョンとして指定しています。以下で説明するように、このアルゴリズムは変数「回復」を使用します。その初期値は送信シーケンス番号です。"
    },
    {
      "indent": 3,
      "text": "The algorithm specified in Section 3 checks whether the acknowledgement field of a partial acknowledgement covers *more* than \"recover\", as defined in Section 3. Another possible variant would be to simply require that the acknowledgement field covers *more than or equal to* \"recover\" before initiating another Fast Retransmit. We called this the Less Careful variant in RFC 2582.",
      "ja": "セクション3で指定されたアルゴリズムは、セクション3で定義されているように、部分的な確認フィールドが「回復」をカバーするかどうかを確認します。別の高速再送信を開始する前に「回復」します。これをRFC 2582のあまり慎重なバリアントと呼びました。"
    },
    {
      "indent": 3,
      "text": "There are two separate scenarios in which the TCP sender could receive three duplicate acknowledgements acknowledging \"recover\" but no more than \"recover\". One scenario would be that the data sender transmitted four packets with sequence numbers higher than \"recover\", that the first packet was dropped in the network, and the following three packets triggered three duplicate acknowledgements acknowledging \"recover\". The second scenario would be that the sender unnecessarily retransmitted three packets below \"recover\", and that these three packets triggered three duplicate acknowledgements acknowledging \"recover\". In the absence of SACK, the TCP sender is unable to distinguish between these two scenarios.",
      "ja": "TCP送信者が「回復」を認めるが「回復」以外の3つの重複した謝辞を受け取ることができる2つの別々のシナリオがあります。1つのシナリオは、データ送信者が「回復」よりも高いシーケンス番号を持つ4つのパケットを送信し、最初のパケットがネットワークで削除され、次の3つのパケットが「回復」を認める3つの重複した謝辞をトリガーしたことです。2番目のシナリオは、送信者が「Recover」の下に不必要に3つのパケットを再送信し、これら3つのパケットが「回復」を認める3つの重複した謝辞をトリガーしたことです。袋がない場合、TCP送信者はこれら2つのシナリオを区別することができません。"
    },
    {
      "indent": 3,
      "text": "For the Careful variant of Fast Retransmit, the data sender would have to wait for a retransmit timeout in the first scenario, but would not have an unnecessary Fast Retransmit in the second scenario. For the Less Careful variant to Fast Retransmit, the data sender would Fast Retransmit as desired in the first scenario, and would unnecessarily Fast Retransmit in the second scenario. This document only specifies the Careful variant in Section 3. Unnecessary Fast Retransmits with the Less Careful variant in scenarios with reordering are illustrated in page 8 of [F03].",
      "ja": "高速再送信の慎重なバリアントの場合、データ送信者は最初のシナリオで再送信タイムアウトを待つ必要がありますが、2番目のシナリオでは不必要な高速再送信はありません。慎重でないバリアントが急速に再送信するために、データ送信者は最初のシナリオで必要に応じて迅速に再送信され、2番目のシナリオでは不必要に高速な再送信を行います。このドキュメントは、セクション3の慎重なバリアントのみを指定します。順序付きシナリオであまり注意深いバリアントを使用した不必要な高速再送信は、[F03]の8ページに示されています。"
    },
    {
      "indent": 3,
      "text": "The document also specifies two heuristics that the TCP sender MAY use to decide to invoke Fast Retransmit even when the three duplicate acknowledgements do not cover more than \"recover\". These heuristics, an ACK-based heuristic and a timestamp heuristic, are described in Sections 6.1 and 6.2 respectively.",
      "ja": "また、このドキュメントは、TCP送信者が3つの重複した謝辞が「回復」以上のカバーをカバーしていない場合でも、高速再送信を呼び出すことを決定するために使用できる2つのヒューリスティックを指定します。これらのヒューリスティックは、ACKベースのヒューリスティックであり、タイムスタンプヒューリスティックであり、それぞれセクション6.1と6.2に記載されています。"
    },
    {
      "indent": 0,
      "text": "12. Conclusions",
      "section_title": true,
      "ja": "12. 結論"
    },
    {
      "indent": 3,
      "text": "This document specifies the NewReno Fast Retransmit and Fast Recovery algorithms for TCP. This NewReno modification to TCP can even be important for TCP implementations that support the SACK option, because the SACK option can only be used for TCP connections when both TCP end-nodes support the SACK option. NewReno performs better than Reno (RFC 2581) in a number of scenarios discussed herein.",
      "ja": "このドキュメントは、TCPのNewReno Fast再送信および高速回復アルゴリズムを指定します。SACKオプションは、両方のTCPエンドノードがSACKオプションをサポートしている場合にのみTCP接続にのみ使用できるため、TCPへのこのNewReno変更は、SACKオプションをサポートするTCP実装にとっても重要です。Newrenoは、ここで説明する多くのシナリオで、Reno（RFC 2581）よりも優れたパフォーマンスを発揮します。"
    },
    {
      "indent": 3,
      "text": "A number of options to the basic algorithm presented in Section 3 are also described. These include the handling of the retransmission timer (Section 4), the response to partial acknowledgments (Section 5), and the value of the congestion window when leaving Fast Recovery (section 3, step 5). Our belief is that the differences between these variants of NewReno are small compared to the differences between Reno and NewReno. That is, the important thing is to implement NewReno instead of Reno, for a TCP connection without SACK; it is less important exactly which of the variants of NewReno is implemented.",
      "ja": "セクション3で提示された基本アルゴリズムの多くのオプションについても説明します。これらには、再送信タイマー（セクション4）の取り扱い、部分的な承認（セクション5）への応答、および速い回復を残すときの輻輳ウィンドウの値（セクション3、ステップ5）が含まれます。私たちの信念は、Newrenoのこれらのバリアントの違いは、RenoとNewrenoの違いに比べて小さいということです。つまり、重要なことは、袋のないTCP接続のために、リノの代わりにnewrenoを実装することです。Newrenoのバリエーションのどれが実装されているかは、それほど重要ではありません。"
    },
    {
      "indent": 0,
      "text": "13. Security Considerations",
      "section_title": true,
      "ja": "13. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "RFC 2581 discusses general security considerations concerning TCP congestion control. This document describes a specific algorithm that conforms with the congestion control requirements of RFC 2581, and so those considerations apply to this algorithm, too. There are no known additional security concerns for this specific algorithm.",
      "ja": "RFC 2581は、TCP混雑制御に関する一般的なセキュリティ上の考慮事項について説明しています。このドキュメントでは、RFC 2581の輻輳制御要件に準拠する特定のアルゴリズムについて説明しているため、これらの考慮事項もこのアルゴリズムに適用されます。この特定のアルゴリズムに関する追加のセキュリティ上の懸念はありません。"
    },
    {
      "indent": 0,
      "text": "14. Acknowledgements",
      "section_title": true,
      "ja": "14. 謝辞"
    },
    {
      "indent": 3,
      "text": "Many thanks to Anil Agarwal, Mark Allman, Armando Caro, Jeffrey Hsu, Vern Paxson, Kacheong Poon, Keyur Shah, and Bernie Volz for detailed feedback on this document or on its precursor, RFC 2582.",
      "ja": "Anil Agarwal、Mark Allman、Armando Caro、Jeffrey Hsu、Vern Paxson、Kacheong Poon、Keyur Shah、およびBernie Volzに感謝します。"
    },
    {
      "indent": 0,
      "text": "15. References",
      "section_title": true,
      "ja": "15. 参考文献"
    },
    {
      "indent": 0,
      "text": "15.1. Normative References",
      "section_title": true,
      "ja": "15.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2018] Mathis, M., Mahdavi, J., Floyd, S. and A. Romanow, \"TCP Selective Acknowledgement Options\", RFC 2018, October 1996.",
      "ja": "[RFC2018] Mathis、M.、Mahdavi、J.、Floyd、S。、およびA. Romanow、「TCP Selective Aumponredcement Options」、RFC 2018、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2581] Allman, M., Paxson, V. and W. Stevens, \"TCP Congestion Control\", RFC 2581, April 1999.",
      "ja": "[RFC2581] Allman、M.、Paxson、V。and W. Stevens、「TCP混雑制御」、RFC 2581、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2582] Floyd, S. and T. Henderson, \"The NewReno Modification to TCP's Fast Recovery Algorithm\", RFC 2582, April 1999.",
      "ja": "[RFC2582] Floyd、S。およびT. Henderson、「TCPの高速回復アルゴリズムへのNewreno修正」、RFC 2582、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2988] Paxson, V. and M. Allman, \"Computing TCP's Retransmission Timer\", RFC 2988, November 2000.",
      "ja": "[RFC2988] Paxson、V。およびM. Allman、「TCPの再送信タイマーのコンピューティング」、RFC 2988、2000年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3042] Allman, M., Balakrishnan, H. and S. Floyd, \"Enhancing TCP's Loss Recovery Using Limited Transmit\", RFC 3042, January 2001.",
      "ja": "[RFC3042] Allman、M.、Balakrishnan、H。およびS. Floyd、「限定送信を使用したTCPの損失回復の強化」、RFC 3042、2001年1月。"
    },
    {
      "indent": 0,
      "text": "15.2. Informative References",
      "section_title": true,
      "ja": "15.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[C98] Cardwell, N., \"delayed ACKs for retransmitted packets: ouch!\". November 1998, Email to the tcpimpl mailing list, Message-ID \"Pine.LNX.4.02A.9811021421340.26785- 100000@sake.cs.washington.edu\", archived at \"http://tcp-impl.lerc.nasa.gov/tcp-impl\".",
      "ja": "[C98] Cardwell、N。、「再送信パケットの遅延ACK：OUCH！」。1998年11月、TCPIMPLメーリングリスト、Message-ID \"Pine.lnx.4.02a.9811021421340.26785-100000@sake.cs.washington.edu\"にメールを送信します。/TCP-IMPL \"。"
    },
    {
      "indent": 3,
      "text": "[F98] Floyd, S., Revisions to RFC 2001, \"Presentation to the TCPIMPL Working Group\", August 1998. URLs \"ftp://ftp.ee.lbl.gov/talks/sf-tcpimpl-aug98.ps\" and \"ftp://ftp.ee.lbl.gov/talks/sf-tcpimpl-aug98.pdf\".",
      "ja": "[F98] Floyd、S.、RFC 2001の改訂、「TCPIMPLワーキンググループへのプレゼンテーション」、1998年8月。URLS「FTP://FTP.EE.LBL.GOV/TALKS/SF-TCPIMPL-AUG98.PS」および\"ftp://ftp.ee.lbl.gov/talks/sf-tcpimpl-aug98.pdf\"。"
    },
    {
      "indent": 3,
      "text": "[F03] Floyd, S., \"Moving NewReno from Experimental to Proposed Standard? Presentation to the TSVWG Working Group\", March 2003. URLs \"http://www.icir.org/floyd/talks/newreno-Mar03.ps\" and \"http://www.icir.org/floyd/talks/newreno-Mar03.pdf\".",
      "ja": "[F03] Floyd、S。、「Newrenoを実験的から提案された標準への移動？TSVWGワーキンググループへのプレゼンテーション」、2003年3月。URLS「http://www.icir.org/floyd/talks/newreno-mar03.ps \"\"および「http://www.icir.org/floyd/talks/newreno-mar03.pdf」。"
    },
    {
      "indent": 3,
      "text": "[FF96] Fall, K. and S. Floyd, \"Simulation-based Comparisons of Tahoe, Reno and SACK TCP\", Computer Communication Review, July 1996. URL \"ftp://ftp.ee.lbl.gov/papers/sacks.ps.Z\".",
      "ja": "[FF96] Fall、K。およびS. Floyd、「Tahoe、RenoおよびSack TCPのシミュレーションベースの比較」、コンピューターコミュニケーションレビュー、1996年7月。.ps.z \"。"
    },
    {
      "indent": 3,
      "text": "[F94] Floyd, S., \"TCP and Successive Fast Retransmits\", Technical report, October 1994. URL \"ftp://ftp.ee.lbl.gov/papers/fastretrans.ps\".",
      "ja": "[F94] Floyd、S。、「TCPおよび連続した高速再送信」、テクニカルレポート、1994年10月。URL「ftp://ftp.ee.lbl.gov/papers/fastretrans.ps」。"
    },
    {
      "indent": 3,
      "text": "[GF04] Gurtov, A. and S. Floyd, \"Resolving Acknowledgment Ambiguity in non-SACK TCP\", Next Generation Teletraffic and Wired/Wireless Advanced Networking (NEW2AN'04), February 2004. URL \"http://www.cs.helsinki.fi/u/gurtov/papers/ heuristics.html\".",
      "ja": "[GF04] Gurtov、A。およびS. Floyd、「非サックTCPの曖昧さの解決」、次世代のテレトラフィックおよびワイヤレス/ワイヤレスアドバンスネットワーキング（New2AN'04）、2004年2月。URL \"http：//www.css.helsinki.fi/u/gurtov/papers/heuristics.html \"。"
    },
    {
      "indent": 3,
      "text": "[Gur03] Gurtov, A., \"[Tsvwg] resolving the problem of unnecessary fast retransmits in go-back-N\", email to the tsvwg mailing list, message ID <3F25B467.9020609@cs.helsinki.fi>, July 28, 2003. URL \"http://www1.ietf.org/mail-archive/working-groups/tsvwg/current/msg04334.html\".",
      "ja": "[Gur03] Gurtov、A。、「[TSVWG] Go-Back-Nの不必要な高速再送信の問題を解決する」、TSVWGメーリングリストにメールを送信し、メッセージID <3F25B467.9020609@cs.helsinki.fi>、7月28日、2003。URL \"http://www1.ietf.org/mail-archive/working-groups/tsvwg/current/msg04334.html\"。"
    },
    {
      "indent": 3,
      "text": "[Hen98] Henderson, T., Re: NewReno and the 2001 Revision. September 1998. Email to the tcpimpl mailing list, Message ID \"Pine.BSI.3.95.980923224136.26134A-100000@raptor.CS.Berkeley.EDU\", archived at \"http://tcp-impl.lerc.nasa.gov/tcp-impl\".",
      "ja": "[Hen98] Henderson、T.、Re：Newrenoおよび2001 Revision。1998年9月。TCPIMPLメーリングリスト、メッセージID \"Pine.bsi.3.98092324136.26134a-100000@raptor.cs.berkeley.eduへのメール]、\" http://tcp-impl.lerc.nasa.gov/TCP-IMPL \"。"
    },
    {
      "indent": 3,
      "text": "[Hoe95] Hoe, J., \"Startup Dynamics of TCP's Congestion Control and Avoidance Schemes\", Master's Thesis, MIT, 1995.",
      "ja": "[Hoe95] Hoe、J。、「TCPの混雑制御と回避スキームのスタートアップダイナミクス」、修士論文、MIT、1995。"
    },
    {
      "indent": 3,
      "text": "[Hoe96] Hoe, J., \"Improving the Start-up Behavior of a Congestion Control Scheme for TCP\", ACM SIGCOMM, August 1996. URL \"http://www.acm.org/sigcomm/sigcomm96/program.html\".",
      "ja": "[Hoe96] Hoe、J。、「TCPの混雑制御スキームの起動動作の改善」、ACM Sigcomm、1996年8月。URL「http://www.acm.org/sigcomm/sigcomm96/program.html」。"
    },
    {
      "indent": 3,
      "text": "[LM97] Lin, D. and R. Morris, \"Dynamics of Random Early Detection\", SIGCOMM 97, September 1997. URL \"http://www.acm.org/sigcomm/sigcomm97/program.html\".",
      "ja": "[LM97] Lin、D。およびR. Morris、「ランダムアーリー検出のダイナミクス」、Sigcomm 97、1997年9月。url \"http://www.acm.org/sigcomm/sigcomm97/program.html\"。"
    },
    {
      "indent": 3,
      "text": "[NS] The Network Simulator (NS). URL \"http://www.isi.edu/nsnam/ns/\".",
      "ja": "[NS]ネットワークシミュレーター（NS）。url \"http://www.isi.edu/nsnam/ns/\"。"
    },
    {
      "indent": 3,
      "text": "[PF01] Padhye, J. and S. Floyd, \"Identifying the TCP Behavior of Web Servers\", June 2001, SIGCOMM 2001.",
      "ja": "[PF01] Padhye、J。およびS. Floyd、「WebサーバーのTCP動作の識別」、2001年6月、Sigcomm 2001。"
    },
    {
      "indent": 3,
      "text": "[RFC1323] Jacobson, V., Braden, R. and D. Borman, \"TCP Extensions for High Performance\", RFC 1323, May 1992.",
      "ja": "[RFC1323] Jacobson、V.、Braden、R。およびD. Borman、「TCP拡張機能のためのTCP拡張」、RFC 1323、1992年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC3517] Blanton, E., Allman, M., Fall, K. and L. Wang, \"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP\", RFC 3517, April 2003.",
      "ja": "[RFC3517] Blanton、E.、Allman、M.、Fall、K。、およびL. Wang、「保守的な選択的承認（SACK）ベースの損失回復アルゴリズムのTCP」、RFC 3517、2003年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC3522] Ludwig, R. and M. Meyer, \"The Eifel Detection Algorithm for TCP\", RFC 3522, April 2003.",
      "ja": "[RFC3522] Ludwig、R。およびM. Meyer、「TCPのEIFEL検出アルゴリズム」、RFC 3522、2003年4月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Sally Floyd International Computer Science Institute",
      "ja": "Sally Floyd International Computer Science Institute"
    },
    {
      "indent": 3,
      "text": "Phone: +1 (510) 666-2989\nEMail: floyd@acm.org\nURL: http://www.icir.org/floyd/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Tom Henderson The Boeing Company",
      "ja": "ボーイングカンパニーのトムヘンダーソン"
    },
    {
      "indent": 3,
      "text": "EMail: thomas.r.henderson@boeing.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Andrei Gurtov TeliaSonera",
      "ja": "アンドレイ・ガルトフ・テリアソネラ"
    },
    {
      "indent": 3,
      "text": "EMail: andrei.gurtov@teliasonera.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2004). This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "著作権（c）The Internet Society（2004）。この文書は、BCP 78に含まれる権利、ライセンス、および制限の対象となり、そこに記載されている場合を除き、著者はすべての権利を保持しています。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は、「現状のまま」に基づいて提供されています。また、貢献者、彼/彼女が代表する組織（もしあれば）が後援する組織、インターネット協会とインターネット工学タスクフォースは、すべての保証、明示的または明示的、またはすべての保証を否認します。本書の情報の使用が、商品性または特定の目的に対する適合性の権利または黙示的な保証を侵害しないという保証を含むがこれらに限定されないことを含む。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、知的財産権またはその他の権利の有効性または範囲に関して、この文書に記載されている技術の実装または使用、またはそのような権利に基づくライセンスがどの程度であるかについての使用に関連すると主張する可能性があるという立場はありません。利用可能になります。また、そのような権利を特定するために独立した努力をしたことも表明していません。RFCドキュメントの権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に行われたIPR開示のコピーと、利用可能にするライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような独自の権利の使用のための一般的なライセンスまたは許可を取得しようとする試みの結果を取得できます。http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、関心のある当事者に、著作権、特許、または特許出願、またはこの基準を実装するために必要な技術をカバーする可能性のあるその他の独自の権利を注意深く招待するよう招待しています。ietf-ipr@ietf.orgのIETFへの情報をお問い合わせください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}