{
  "title": {
    "text": "RFC 3338 - Dual Stack Hosts Using \"Bump-in-the-API\" (BIA)",
    "ja": "RFC 3338 - 「Bumb-in-the-API」（BIA）を使用してデュアルスタックホスト"
  },
  "number": 3338,
  "created_at": "2023-11-19 11:18:11.234137+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                             S. Lee\nRequest for Comments: 3338                                     M-K. Shin\nCategory: Experimental                                          Y-J. Kim\n                                                                    ETRI\n                                                             E. Nordmark\n                                                               A. Durand\n                                                        Sun Microsystems\n                                                            October 2002",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Dual Stack Hosts Using \"Bump-in-the-API\" (BIA)",
      "ja": "「Bumb-in-the-API」（BIA）を使用してデュアルスタックホスト"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind. Discussion and suggestions for improvement are requested. Distribution of this memo is unlimited.",
      "ja": "このメモは、インターネットコミュニティの実験プロトコルを定義します。いかなる種類のインターネット標準を指定しません。改善のための議論と提案が要求されます。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2002). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2002）。無断転載を禁じます。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document specifies a mechanism of dual stack hosts using a technique called \"Bump-in-the-API\"(BIA) which allows for the hosts to communicate with other IPv6 hosts using existing IPv4 applications. The goal of this mechanism is the same as that of the Bump-in-the-stack mechanism, but this mechanism provides the translation method between the IPv4 APIs and IPv6 APIs. Thus, the goal is simply achieved without IP header translation.",
      "ja": "このドキュメントは、ホストが既存のIPv4アプリケーションを使用して他のIPv6ホストと通信できる「Bump-in-api」（BIA）と呼ばれる手法を使用して、デュアルスタックホストのメカニズムを指定します。このメカニズムの目標は、スタックの隆起メカニズムの目標と同じですが、このメカニズムはIPv4 APIとIPv6 APIの間の翻訳方法を提供します。したがって、目標は、IPヘッダーの翻訳なしで単に達成されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents:",
      "ja": "目次："
    },
    {
      "indent": 3,
      "text": "1.  Introduction ................................................  2\n2.  Applicability and Disclaimer ................................  3\n2.1 Applicability ...............................................  3\n2.2 Disclaimer ..................................................  4\n3.  Dual Stack Host Architecture Using BIA ......................  4\n3.1 Function Mapper .............................................  4\n3.2 Name Resolver ...............................................  5\n3.3 Address Mapper ..............................................  5\n4.  Behavior Example ............................................  6\n4.1 Originator Behavior .........................................  6\n4.2 Recipient Behavior ..........................................  8\n5.  Considerations  ............................................. 10\n5.1 Socket API Conversion ....................................... 10\n5.2 ICMP Messages Handling ...................................... 10\n5.3 IPv4 Address Pool and Mapping Table ......................... 10\n5.4 Internally Assigned IPv4 Addresses .......................... 10\n5.5 Mismatch Between DNS Result and Peer Application Version .... 11\n5.6 Implementation Issues ....................................... 11\n6.  Limitations ................................................. 12\n7.  Security Considerations ..................................... 12\n8.  Acknowledgments ............................................. 12\n9.  References .................................................. 12\nAppendix:  API list intercepted by BIA .......................... 14\nAuthors Addresses ............................................... 16\nFull Copyright Statement ........................................ 17",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "RFC2767 [BIS] specifies a host translation mechanism using a technique called \"Bump-in-the-Stack\". It translates IPv4 into IPv6, and vice versa using the IP conversion mechanism defined in [SIIT]. BIS allows hosts to communicate with other IPv6 hosts using existing IPv4 applications. However, this approach is to use an API translator which is inserted between the TCP/IP module and network card driver, so that it has the same limitations as the [SIIT] based IP header translation methods. In addition, its implementation is dependent upon the network interface driver.",
      "ja": "RFC2767 [BIS]「Bump-in-the-Stack」と呼ばれる手法を使用して、ホスト翻訳メカニズムを指定します。IPv4をIPv6に変換し、[SIIT]で定義されたIP変換メカニズムを使用してその逆を使用します。BISを使用すると、ホストは既存のIPv4アプリケーションを使用して他のIPv6ホストと通信できます。ただし、このアプローチは、TCP/IPモジュールとネットワークカードドライバーの間に挿入されたAPI翻訳者を使用して、[SIIT]ベースのIPヘッダー翻訳方法と同じ制限を持つことです。さらに、その実装は、ネットワークインターフェイスドライバーに依存します。"
    },
    {
      "indent": 3,
      "text": "This document specifies a new mechanism of dual stack hosts called Bump-in-the-API(BIA) technique. The BIA technique inserts an API translator between the socket API module and the TCP/IP module in the dual stack hosts, so that it translates the IPv4 socket API function into IPv6 socket API function and vice versa. With this mechanism, the translation can be simplified without IP header translation.",
      "ja": "このドキュメントは、Bump-in-the-API（BIA）技術と呼ばれるデュアルスタックホストの新しいメカニズムを指定します。BIAテクニックは、デュアルスタックホストのソケットAPIモジュールとTCP/IPモジュールの間にAPI翻訳者を挿入するため、IPv4ソケットAPI関数をIPv6ソケットAPI機能に変換し、その逆にします。このメカニズムを使用すると、IPヘッダーの翻訳なしで翻訳を簡素化できます。"
    },
    {
      "indent": 3,
      "text": "Using BIA, the dual stack host assumes that there exists both TCP(UDP)/IPv4 and TCP(UDP)/IPv6 stacks on the local node.",
      "ja": "BIAを使用して、デュアルスタックホストは、ローカルノードにTCP（UDP）/IPv4（UDP）/IPv6スタックの両方が存在することを前提としています。"
    },
    {
      "indent": 3,
      "text": "When IPv4 applications on the dual stack communicate with other IPv6 hosts, the API translator detects the socket API functions from IPv4 applications and invokes the IPv6 socket API functions to communicate with the IPv6 hosts, and vice versa. In order to support communication between IPv4 applications and the target IPv6 hosts, pooled IPv4 addresses will be assigned through the name resolver in the API translator.",
      "ja": "デュアルスタックのIPv4アプリケーションが他のIPv6ホストと通信すると、API翻訳者はIPv4アプリケーションからソケットAPI機能を検出し、IPv6ソケットAPI関数を呼び出してIPv6ホストと通信します。IPv4アプリケーションとターゲットIPv6ホスト間の通信をサポートするために、プールされたIPv4アドレスは、API翻訳者の名前リゾルバーを介して割り当てられます。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC 2119].",
      "ja": "「必須」、「そうしない」、「必須」、「必要」、「「しない」、「そうでない」、「そうではない」、「そうでない」、「推奨」、「5月」、および「オプション」は、[RFC 2119]で説明されているように解釈される。"
    },
    {
      "indent": 3,
      "text": "This document uses terms defined in [IPv6],[TRANS-MECH] and [BIS].",
      "ja": "このドキュメントでは、[IPv6]、[Trans-Mech]、[BIS]で定義された用語を使用します。"
    },
    {
      "indent": 0,
      "text": "2. Applicability and Disclaimer",
      "section_title": true,
      "ja": "2. 適用可能性と免責事項"
    },
    {
      "indent": 0,
      "text": "2.1 Applicability",
      "section_title": true,
      "ja": "2.1 適用可能性"
    },
    {
      "indent": 3,
      "text": "The main purposes of BIA are the same as BIS [BIS]. It makes IPv4 applications communicate with IPv6 hosts without any modification of those IPv4 applications. However, while BIS is for systems with no IPv6 stack, BIA is for systems with an IPv6 stack, but on which some applications are not yet available on IPv6 and source code is not available preventing the application from being ported. It's good for early adopters who do not have all applications handy, but not for mainstream production usage.",
      "ja": "BIAの主な目的は、BI [BIS]と同じです。これらのIPv4アプリケーションを変更することなく、IPv4アプリケーションをIPv6ホストと通信します。ただし、BISはIPv6スタックのないシステム用ですが、BIAはIPv6スタックを備えたシステム用ですが、IPv6でまだいくつかのアプリケーションは使用できず、ソースコードはアプリケーションが移植されないようにしています。すべてのアプリケーションが便利ではないが、主流の生産使用にはないアーリーアダプターに適しています。"
    },
    {
      "indent": 3,
      "text": "There is an issue about a client node running BIA trying to contact a dual stack node on a port number that is only associated with an IPv4 application (see section 5.5). There are 2 approaches.",
      "ja": "BIAを実行しているクライアントノードが、IPv4アプリケーションにのみ関連付けられているポート番号のデュアルスタックノードに連絡しようとするクライアントノードについて問題があります（セクション5.5を参照）。2つのアプローチがあります。"
    },
    {
      "indent": 3,
      "text": "- The client application SHOULD cycle through all the addresses and end up trying the IPv4 one.",
      "ja": "- クライアントアプリケーションは、すべてのアドレスをサイクリングし、最終的にIPv4のアプリケーションを試してみてください。"
    },
    {
      "indent": 3,
      "text": "- BIA SHOULD do the work.",
      "ja": "- BIAは仕事をすべきです。"
    },
    {
      "indent": 3,
      "text": "It is not clear at this time which behavior is desirable (it may very well be application dependent), so we need to get feedback from experimentation.",
      "ja": "現時点では、どの動作が望ましいか（アプリケーションに依存する可能性が非常に高い）ことは明らかではないため、実験からフィードバックを取得する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.2 Disclaimer",
      "section_title": true,
      "ja": "2.2 免責事項"
    },
    {
      "indent": 3,
      "text": "BIA SHOULD NOT be used for an IPv4 application for which source code is available. We strongly recommend that application programmers SHOULD NOT use this mechanism when application source code is available. As well, it SHOULD NOT be used as an excuse not to port software or delay porting.",
      "ja": "BIAは、ソースコードが利用可能なIPv4アプリケーションに使用しないでください。アプリケーションソースコードが利用可能な場合、アプリケーションプログラマーはこのメカニズムを使用しないでください。同様に、ソフトウェアを移植したり、移植を遅らせたりしないという言い訳として使用すべきではありません。"
    },
    {
      "indent": 0,
      "text": "3. Dual Stack Host Architecture Using BIA",
      "section_title": true,
      "ja": "3. BIAを使用したデュアルスタックホストアーキテクチャ"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows the architecture of the host in which BIA is installed.",
      "ja": "図1は、BIAが設置されているホストのアーキテクチャを示しています。"
    },
    {
      "indent": 15,
      "text": "+----------------------------------------------+\n| +------------------------------------------+ |\n| |                                          | |\n| |             IPv4 applications            | |\n| |                                          | |\n| +------------------------------------------+ |\n| +------------------------------------------+ |\n| |           Socket API (IPv4, IPv6)        | |\n| +------------------------------------------+ |\n| +-[ API translator]------------------------+ |\n| | +-----------+ +---------+ +------------+ | |\n| | | Name      | | Address | | Function   | | |\n| | | Resolver  | | Mapper  | | Mapper     | | |\n| | +-----------+ +---------+ +------------+ | |\n| +------------------------------------------+ |\n| +--------------------+ +-------------------+ |\n| |                    | |                   | |\n| |    TCP(UDP)/IPv4   | |   TCP(UDP)/IPv6   | |\n| |                    | |                   | |\n| +--------------------+ +-------------------+ |\n+----------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "Figure 1 Architecture of the dual stack host using BIA",
      "ja": "図1BIAを使用したデュアルスタックホストのアーキテクチャ"
    },
    {
      "indent": 3,
      "text": "Dual stack hosts defined in RFC2893 [TRANS-MECH] need applications, TCP/IP modules and addresses for both IPv4 and IPv6. The proposed hosts in this document have an API translator to communicate with other IPv6 hosts using existing IPv4 applications. The API translator consists of 3 modules, a name resolver, an address mapper and a function mapper.",
      "ja": "RFC2893 [Trans-Mech]で定義されたデュアルスタックホストは、IPv4とIPv6の両方のアプリケーション、TCP/IPモジュール、アドレスを必要とします。このドキュメントで提案されているホストには、既存のIPv4アプリケーションを使用して他のIPv6ホストと通信するAPI翻訳者がいます。API翻訳者は、3つのモジュール、名前リゾルバー、アドレスマッパー、および機能マッパーで構成されています。"
    },
    {
      "indent": 0,
      "text": "3.1 Function Mapper",
      "section_title": true,
      "ja": "3.1 機能マッパー"
    },
    {
      "indent": 3,
      "text": "It translates an IPv4 socket API function into an IPv6 socket API function, and vice versa.",
      "ja": "IPv4ソケットAPI関数をIPv6ソケットAPI関数に変換し、その逆も同様です。"
    },
    {
      "indent": 3,
      "text": "When detecting the IPv4 socket API functions from IPv4 applications, it intercepts the function call and invokes new IPv6 socket API functions which correspond to the IPv4 socket API functions. Those IPv6 API functions are used to communicate with the target IPv6 hosts. When detecting the IPv6 socket API functions from the data received from the IPv6 hosts, it works symmetrically in relation to the previous case.",
      "ja": "IPv4アプリケーションからIPv4ソケットAPI機能を検出すると、関数呼び出しをインターセプトし、IPv4ソケットAPI関数に対応する新しいIPv6ソケットAPI機能を呼び出します。これらのIPv6 API関数は、ターゲットIPv6ホストと通信するために使用されます。IPv6ホストから受信したデータからIPv6ソケットAPI機能を検出すると、前のケースに関連して対称的に機能します。"
    },
    {
      "indent": 0,
      "text": "3.2 Name Resolver",
      "section_title": true,
      "ja": "3.2 名前リゾルバー"
    },
    {
      "indent": 3,
      "text": "It returns a proper answer in response to the IPv4 application's request.",
      "ja": "IPv4アプリケーションの要求に応じて、適切な回答を返します。"
    },
    {
      "indent": 3,
      "text": "When an IPv4 application tries to resolve names via the resolver library (e.g. gethostbyname()), BIA intercept the function call and instead call the IPv6 equivalent functions (e.g. getnameinfo()) that will resolve both A and AAAA records.",
      "ja": "IPv4アプリケーションがResolverライブラリ（gethostbyname（）などを介して名前を解決しようとすると、BIAは関数呼び出しを傍受し、代わりにAとAAAの両方のレコードを解決するIPv6等価関数（getNameInfo（））を呼び出します。"
    },
    {
      "indent": 3,
      "text": "If the AAAA record is available, it requests the address mapper to assign an IPv4 address corresponding to the IPv6 address, then creates the A record for the assigned IPv4 address, and returns the A record to the application.",
      "ja": "AAAAレコードが利用可能な場合、アドレスマッパーにIPv6アドレスに対応するIPv4アドレスを割り当てるように要求し、割り当てられたIPv4アドレスのAレコードを作成し、Aレコードをアプリケーションに返します。"
    },
    {
      "indent": 0,
      "text": "3.3 Address Mapper",
      "section_title": true,
      "ja": "3.3 アドレスマッパー"
    },
    {
      "indent": 3,
      "text": "It internally maintains a table of the pairs of an IPv4 address and an IPv6 address. The IPv4 addresses are assigned from an IPv4 address pool. It uses the unassigned IPv4 addresses (e.g., 0.0.0.1 ~ 0.0.0.255).",
      "ja": "IPv4アドレスとIPv6アドレスのペアのテーブルを内部的に維持します。IPv4アドレスは、IPv4アドレスプールから割り当てられます。割り当てられていないIPv4アドレス（0.0.0.1〜0.0.0.255など）を使用します。"
    },
    {
      "indent": 3,
      "text": "When the name resolver or the function mapper requests it to assign an IPv4 address corresponding to an IPv6 address, it selects and returns an IPv4 address out of the pool, and registers a new entry into the table dynamically. The registration occurs in the following 2 cases:",
      "ja": "名前のリゾルバーまたは関数マッパーがIPv6アドレスに対応するIPv4アドレスを割り当てるように要求すると、プールからIPv4アドレスを選択して返し、テーブルへの新しいエントリを動的に登録します。登録は、次の2つのケースで発生します。"
    },
    {
      "indent": 3,
      "text": "(1) When the name resolver gets only an 'AAAA' record for the target host name and there is not a mapping entry for the IPv6 address.",
      "ja": "(1) 名前のリゾルバーがターゲットホスト名の「AAAA」レコードのみを取得し、IPv6アドレスのマッピングエントリがない場合。"
    },
    {
      "indent": 3,
      "text": "(2) When the function mapper gets a socket API function call from the data received and there is not a mapping entry for the IPv6 source address.",
      "ja": "(2) 関数マッパーが受信したデータからソケットAPI関数呼び出しを取得し、IPv6ソースアドレスのマッピングエントリはありません。"
    },
    {
      "indent": 3,
      "text": "NOTE: This is the same as that of the Address Mapper in [BIS].",
      "ja": "注：これは、[bis]のアドレスマッパーと同じです。"
    },
    {
      "indent": 0,
      "text": "4. Behavior Examples",
      "section_title": true,
      "ja": "4. 行動の例"
    },
    {
      "indent": 3,
      "text": "This section describes behaviors of the proposed dual stack host called \"dual stack\", which communicates with an IPv6 host called \"host6\" using an IPv4 application.",
      "ja": "このセクションでは、「デュアルスタック」と呼ばれる提案されたデュアルスタックホストの動作について説明します。これは、IPv4アプリケーションを使用して「host6」と呼ばれるIPv6ホストと通信します。"
    },
    {
      "indent": 3,
      "text": "In this section, the meanings of arrows are as follows:",
      "ja": "このセクションでは、矢印の意味は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "---> A DNS message for name resolving created by the applications\n     and the name resolver in the API translator.\n+++> An IPv4 address request to and reply from the address mapper\n     for the name resolver and the function mapper.\n===> Data flow by socket API functions created by the\n     applications and the function mapper in the API translator.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.1 Originator Behavior",
      "section_title": true,
      "ja": "4.1 オリジネーターの動作"
    },
    {
      "indent": 3,
      "text": "This sub-section describes the behavior when the \"dual stack\" sends data to \"host6\".",
      "ja": "このサブセクションは、「デュアルスタック」がデータを「host6」に送信するときの動作を説明します。"
    },
    {
      "indent": 3,
      "text": "When an IPv4 application sends a DNS query to its name server, the name resolver intercepts the query and then creates a new query to resolve both A and AAAA records. When only the AAAA record is resolved, the name resolver requests the address mapper to assign an IPv4 address corresponding to the IPv6 address.",
      "ja": "IPv4アプリケーションがDNSクエリをName Serverに送信すると、名前リゾルバーがクエリをインターセプトし、AとAAAAレコードの両方を解決するための新しいクエリを作成します。AAAAレコードのみが解決された場合、名前リゾルバーはアドレスマッパーにIPv6アドレスに対応するIPv4アドレスを割り当てるように要求します。"
    },
    {
      "indent": 3,
      "text": "The name resolver creates an A record for the assigned IPv4 address and returns it to the IPv4 applications.",
      "ja": "名前リゾルバーは、割り当てられたIPv4アドレスのAレコードを作成し、IPv4アプリケーションに返します。"
    },
    {
      "indent": 3,
      "text": "In order for the IPv4 application to send IPv4 packets to host6, it calls the IPv4 socket API function.",
      "ja": "IPv4アプリケーションがIPv4パケットをHost6に送信するために、IPv4ソケットAPI関数を呼び出します。"
    },
    {
      "indent": 3,
      "text": "The function mapper detects the socket API function from the application. If the result is from IPv6 applications, it skips the translation. In the case of IPv4 applications, it requires an IPv6 address to invoke the IPv6 socket API function, thus the function mapper requests an IPv6 address to the address mapper. The address mapper selects an IPv4 address from the table and returns the destination IPv6 address. Using this IPv6 address, the function mapper invokes an IPv6 socket API function corresponding to the IPv4 socket API function.",
      "ja": "関数マッパーは、アプリケーションからソケットAPI機能を検出します。結果がIPv6アプリケーションの場合、翻訳をスキップします。IPv4アプリケーションの場合、IPv6ソケットAPI関数を呼び出すためにIPv6アドレスが必要なため、関数マッパーはアドレスマッパーにIPv6アドレスを要求します。アドレスマッパーは、テーブルからIPv4アドレスを選択し、宛先IPv6アドレスを返します。このIPv6アドレスを使用して、関数マッパーはIPv4ソケットAPI関数に対応するIPv6ソケットAPI関数を呼び出します。"
    },
    {
      "indent": 3,
      "text": "When the function mapper receives an IPv6 function call,it requests the IPv4 address to the address mapper in order to translate the IPv6 socket API function into an IPv4 socket API function. Then, the function mapper invokes the socket API function for the IPv4 applications.",
      "ja": "関数マッパーがIPv6関数呼び出しを受信すると、IPv6ソケットAPI関数をIPv4ソケットAPI関数に変換するために、アドレスマッパーにIPv4アドレスを要求します。次に、関数マッパーはIPv4アプリケーションのソケットAPI関数を呼び出します。"
    },
    {
      "indent": 3,
      "text": "Figure 2 illustrates the behavior described above:",
      "ja": "図2は、上記の動作を示しています。"
    },
    {
      "indent": 0,
      "text": "\"dual stack\"                                                \"host6\"\nIPv4    Socket |     [ API Translator ]    | TCP(UDP)/IP          Name\nappli-  API    |Name      Address  Function| (v6/v4)             Server\ncation         |Resolver  Mapper   Mapper  |\n |        |        |        |        |         |              |       |\n<<Resolve an IPv4 address for \"host6\".>>       |              |       |\n |        |        |        |        |         |              |       |\n |--------|------->|  Query of 'A' records for host6.         |       |\n |        |        |        |        |         |              |       |\n |        |        |--------|--------|---------|--------------|------>|\n |        |        |  Query of 'A' records and 'AAAA' for host6       |\n |        |        |        |        |         |              |       |\n |        |        |<-------|--------|---------|--------------|-------|\n |        |        |  Reply with the 'AAAA' record.           |       |\n |        |        |        |        |         |              |\n |        |        |<<The 'AAAA' record is resolved.>>        |\n |        |        |        |        |         |              |\n |        |        |+++++++>|  Request one IPv4 address       |\n |        |        |        |  corresponding to the IPv6 address.\n |        |        |        |        |         |              |\n |        |        |        |<<Assign one IPv4 address.>>     |\n |        |        |        |        |         |              |\n |        |        |<+++++++|  Reply with the IPv4 address.   |\n |        |        |        |        |         |              |\n |        |        |<<Create 'A' record for the IPv4 address.>>\n |        |        |        |        |         |              |\n |<-------|--------| Reply with the 'A' record.|              |\n |        |        |        |        |         |              |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "Figure 2 Behavior of the originator (1/2)",
      "ja": "図2オリジネーターの動作（1/2）"
    },
    {
      "indent": 0,
      "text": "\"dual stack\"                                               \"host6\"\nIPv4    Socket |     [ API Translator ]    | TCP(UDP)/IP\nappli-  API    |Name      Address  Function| (v6/v4)\ncation         |Resolver  Mapper   Mapper  |\n |        |        |        |        |         |              |\n<<Call IPv4 Socket API function >>   |         |              |\n |        |        |        |        |         |              |\n |========|========|========|=======>|An IPv4 Socket API function Call\n |        |        |        |        |         |              |\n |        |        |        |<+++++++|  Request IPv6 addresses|\n |        |        |        |        |  corresponding to the  |\n |        |        |        |        |  IPv4 addresses.       |\n |        |        |        |        |         |              |\n |        |        |        |+++++++>| Reply with the IPv6 addresses.\n |        |        |        |        |         |              |\n |        |        |        |        |<<Translate IPv4 into IPv6.>>\n |        |        |        |        |         |              |\n |  An IPv6 Socket API function call.|=========|=============>|\n |        |        |        |        |         |              |\n |        |        |        |        |<<Reply an IPv6 data    |\n |        |        |        |        |  to dual stack.>>      |\n |        |        |        |        |         |              |\n |  An IPv6 Socket API function call.|<========|==============|\n |        |        |        |        |         |              |\n |        |        |        |        |<<Translate IPv6 into IPv4.>>\n |        |        |        |        |         |              |\n |        |        |        |<+++++++|  Request IPv4 addresses|\n |        |        |        |        |  corresponding to the  |\n |        |        |        |        |  IPv6 addresses.       |\n |        |        |        |        |         |              |\n |        |        |        |+++++++>| Reply with the IPv4 addresses.\n |        |        |        |        |         |              |\n |<=======|========|========|========|  An IPv4 Socket function call.\n |        |        |        |        |         |              |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "Figure 2 Behavior of the originator (2/2)",
      "ja": "図2オリジネーターの動作（2/2）"
    },
    {
      "indent": 0,
      "text": "4.2 Recipient Behavior",
      "section_title": true,
      "ja": "4.2 受信者の動作"
    },
    {
      "indent": 3,
      "text": "This subsection describes the recipient behavior of \"dual stack\". The communication is triggered by \"host6\".",
      "ja": "このサブセクションでは、「デュアルスタック」の受信者の動作について説明しています。通信は「host6」によってトリガーされます。"
    },
    {
      "indent": 3,
      "text": "\"host6\" resolves the address of \"dual stack\" with 'AAAA' records through its name server, and then sends an IPv6 packet to the \"dual stack\".",
      "ja": "「host6」は、「デュアルスタック」のアドレスを名前サーバーを介して「AAAA」レコードを使用して解決し、「デュアルスタック」にIPv6パケットを送信します。"
    },
    {
      "indent": 3,
      "text": "The IPv6 packet reaches the \"dual stack\" and the function mapper detects it.",
      "ja": "IPv6パケットは「デュアルスタック」に到達し、関数マッパーはそれを検出します。"
    },
    {
      "indent": 3,
      "text": "The function mapper requests the IPv4 address to the address mapper in order to invoke the IPv4 socket API function to communicate with the IPv4 application. Then the function mapper invokes the corresponding IPv4 socket API function for the IPv4 applications corresponding to the IPv6 functions.",
      "ja": "関数マッパーは、IPv4ソケットAPI関数を呼び出してIPv4アプリケーションと通信するために、IPv4アドレスをアドレスマッパーに要求します。次に、関数マッパーは、IPv6関数に対応するIPv4アプリケーションの対応するIPv4ソケットAPI関数を呼び出します。"
    },
    {
      "indent": 3,
      "text": "Figure 3 illustrates the behavior described above:",
      "ja": "図3は、上記の動作を示しています。"
    },
    {
      "indent": 3,
      "text": "\"dual stack\"                                               \"host6\"\nIPv4    Socket |     [ API Translator ]    | TCP(UDP)/IP\nappli-  API    |Name      Address  Function| (v6/v4)\ncation         |Resolver  Mapper   Mapper  |\n |        |        |        |        |         |              |\n<<Receive data from \"host6\".>>       |         |              |\n |        |        |        |        |         |              |\n |      An IPv6 Socket function call.|<========|==============|\n |        |        |        |        |         |              |\n |        |        |        |<+++++++|  Request IPv4 addresses|\n |        |        |        |        |  corresponding to the IPv6\n |        |        |        |        |  addresses.            |\n |        |        |        |        |         |              |\n |        |        |        |+++++++>| Reply with the IPv4 addresses.\n |        |        |        |        |         |              |\n |        |        |        |        |<<Translate IPv6 into IPv4.>>\n |        |        |        |        |         |              |\n |<=======|========|========|========|  An IPv4 function call |\n |        |        |        |        |         |              |\n<<Reply an IPv4 data to \"host6\".>>   |         |              |\n |        |        |        |        |         |              |\n |========|========|========|=======>|  An IPv4 function call |\n |        |        |        |        |         |              |\n |        |        |        |        |<<Translate IPv4 into IPv6.>>\n |        |        |        |        |         |              |\n |        |        |        |<+++++++|  Request IPv6 addresses|\n |        |        |        |        |  corresponding to the IPv4\n |        |        |        |        |  addresses.            |\n |        |        |        |        |         |              |\n |        |        |        |+++++++>| Reply with the IPv6 addresses.\n |        |        |        |        |         |              |\n |      An IPv6 Socket function call.|=========|=============>|\n |        |        |        |        |         |              |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 3 Behavior of Receiving data from IPv6 host",
      "ja": "図3IPv6ホストからのデータ受信の動作"
    },
    {
      "indent": 0,
      "text": "5. Considerations",
      "section_title": true,
      "ja": "5. 考慮事項"
    },
    {
      "indent": 0,
      "text": "5.1 Socket API Conversion",
      "section_title": true,
      "ja": "5.1 ソケットAPI変換"
    },
    {
      "indent": 3,
      "text": "IPv4 socket API functions are translated into semantically the same IPv6 socket API functions and vice versa. See Appendix A for the API list intercepted by BIA. IP addresses embedded in application layer protocols (e.g., FTP) can be translated in API functions. Its implementation depends on operating systems.",
      "ja": "IPv4ソケットAPI関数は、同じIPv6ソケットAPI関数と同じように翻訳され、その逆も同様です。BIAが傍受したAPIリストについては、付録Aを参照してください。アプリケーションレイヤープロトコル（FTPなど）に埋め込まれたIPアドレスは、API関数に翻訳できます。その実装は、オペレーティングシステムに依存します。"
    },
    {
      "indent": 3,
      "text": "NOTE: Basically, IPv4 socket API functions are not fully compatible with IPv6 since the IPv6 has new advanced features.",
      "ja": "注：基本的に、IPv4には新しい高度な機能があるため、IPv4ソケットAPI関数はIPv6と完全に互換性がありません。"
    },
    {
      "indent": 0,
      "text": "5.2 ICMP Message Handling",
      "section_title": true,
      "ja": "5.2 ICMPメッセージ処理"
    },
    {
      "indent": 3,
      "text": "When an application needs ICMP messages values (e.g., Type, Code, etc.) sent from a network layer, ICMPv4 message values MAY be translated into ICMPv6 message values based on [SIIT], and vice versa. It can be implemented using raw socket.",
      "ja": "アプリケーションがネットワークレイヤーから送信されたICMPメッセージ値（タイプ、コードなど）が必要な場合、ICMPV4メッセージ値は[SIIT]に基づいてICMPV6メッセージ値に変換され、逆も同様です。生のソケットを使用して実装できます。"
    },
    {
      "indent": 0,
      "text": "5.3 IPv4 Address Pool and Mapping Table",
      "section_title": true,
      "ja": "5.3 IPv4アドレスプールとマッピングテーブル"
    },
    {
      "indent": 3,
      "text": "The address pool consists of the unassigned IPv4 addresses. This pool can be implemented at different granularity in the node e.g., a single pool per node, or at some finer granularity such as per user or per process. However, if a number of IPv4 applications communicate with IPv6 hosts, the available address spaces will be exhausted. As a result, it will be impossible for IPv4 applications to communicate with IPv6 nodes. It requires smart management techniques for address pool. For example, it is desirable for the mapper to free the oldest entry and reuse the IPv4 address for creating a new entry. This issues is the same as [BIS]. In case of a per-node address mapping table, it MAY cause a larger risk of running out of address.",
      "ja": "アドレスプールは、割り当てられていないIPv4アドレスで構成されています。このプールは、ノードのさまざまな粒度など、ノードごとに単一のプール、またはユーザーまたはプロセスごとなどのより細かい粒度などで実装できます。ただし、多数のIPv4アプリケーションがIPv6ホストと通信した場合、利用可能なアドレススペースが使い果たされます。その結果、IPv4アプリケーションがIPv6ノードと通信することは不可能です。アドレスプールにはスマート管理手法が必要です。たとえば、マッパーが最古のエントリを解放し、新しいエントリを作成するためにIPv4アドレスを再利用することが望ましいです。この問題は[bis]と同じです。ノードごとのアドレスマッピングテーブルの場合、住所が不足するリスクが大きくなる場合があります。"
    },
    {
      "indent": 0,
      "text": "5.4 Internally Assigned IPv4 Addresses",
      "section_title": true,
      "ja": "5.4 内部的に割り当てられたIPv4アドレス"
    },
    {
      "indent": 3,
      "text": "The IPv4 addresses, which are internally assigned to IPv6 target hosts out of the pool, are the unassigned IPv4 addresses (e.g., 0.0.0.1 ~ 0.0.0.255). There is no potential collision with another use of the private address space when the IPv4 address flows out from the host.",
      "ja": "IPv4アドレスは、プールからIPv6ターゲットホストに内部的に割り当てられており、割り当てられていないIPv4アドレス（0.0.0.1〜0.0.0.255など）です。IPv4アドレスがホストから流出する場合、プライベートアドレススペースの別の使用との潜在的な衝突はありません。"
    },
    {
      "indent": 0,
      "text": "5.5 Mismatch between DNS result(AAAA) and Peer Application Version(v4)",
      "section_title": true,
      "ja": "5.5 DNS結果（AAAA）とピアアプリケーションバージョン（V4）の間の不一致"
    },
    {
      "indent": 3,
      "text": "If a server application you are using does not support IPv6 yet, but runs on a machine that supports other IPv6 services and this is listed with a AAAA record in the DNS, a client IPv4 application using BIA might fail to connect to the server application, because there is a mismatch between DNS query result (i.e., AAAA) and a server application version(i.e., IPv4). A solution is to try all the addresses listed in the DNS and just not fail after the first attempt. We have two approaches: the client application itself SHOULD cycle through all the addresses and end up trying the IPv4 one. Or it SHOULD be done by some extensions of name resolver and API translator in BIA. For this, BIA SHOULD do iterated jobs for finding the working address used by the other application out of addresses returned by the extended name resolver. It may very well be application dependent. Note that BIA might be able to do the iteraction over all addresses for TCP sockets, since BIA can observe when the connect call fails. But for UDP sockets it is hard if not impossible for BIA to know which address worked, hence the application must do the iteraction over all addresses until it finds a working address.",
      "ja": "使用しているサーバーアプリケーションはまだIPv6をサポートしていませんが、他のIPv6サービスをサポートするマシンで実行され、これがDNSのAAAAレコードでリストされている場合、BIAを使用したクライアントIPv4アプリケーションはサーバーアプリケーションに接続できない場合があります。DNSクエリ結果（つまり、AAAA）とサーバーアプリケーションバージョン（つまり、IPv4）の間に不一致があるためです。解決策は、DNSにリストされているすべてのアドレスを試すことであり、最初の試みの後に失敗しないことです。2つのアプローチがあります。クライアントアプリケーション自体がすべてのアドレスを循環し、IPv4のアプリケーションを試してみる必要があります。または、BIAの名前ResolverとAPI翻訳者のいくつかの拡張機能によって行う必要があります。このために、BIAは、拡張名リゾルバーによって返されるアドレスから他のアプリケーションで使用される作業アドレスを見つけるために、繰り返しジョブを行う必要があります。アプリケーションに依存する場合があります。BIAは、TCPソケットのすべてのアドレスに対して反復を行うことができる可能性があることに注意してください。BIAは、接続コールが失敗したときに観察できるためです。しかし、UDPソケットの場合、BIAがどのアドレスが機能するかを知ることは不可能ではないにしても困難です。したがって、アプリケーションは、作業アドレスが見つかるまですべてのアドレスに対して反復を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "Another way to avoid this type of problems is to make BIA only come into effect when no A records exist for the peer. Thus traffic from an application using BIA on a dual-stack host to a dual-stack host would use IPv4.",
      "ja": "このタイプの問題を回避する別の方法は、ピアの記録が存在しない場合にのみBIAを実施することです。したがって、デュアルスタックホストのBIAを使用したアプリケーションからデュアルスタックホストへのトラフィックは、IPv4を使用します。"
    },
    {
      "indent": 0,
      "text": "5.6 Implementation Issues",
      "section_title": true,
      "ja": "5.6 実装の問題"
    },
    {
      "indent": 3,
      "text": "Some operating systems support the preload library functions, so it is easy to implement the API translator by using it. For example, the user can replace all existing socket API functions with user-defined socket API functions which translate the socket API function. In this case, every IPv4 application has its own translation library using a preloaded library which will be bound into the application before executing it dynamically.",
      "ja": "一部のオペレーティングシステムは、プリロードライブラリ機能をサポートするため、API翻訳者を使用して簡単に実装できます。たとえば、ユーザーは、すべての既存のソケットAPI関数をユーザー定義のソケットAPI関数に置き換えることができ、ソケットAPI関数を変換できます。この場合、すべてのIPv4アプリケーションには、動的に実行する前にアプリケーションにバインドされるプリロードライブラリを使用して、独自の翻訳ライブラリがあります。"
    },
    {
      "indent": 3,
      "text": "Some other operating systems support the user-defined layered protocol allowing a user to develop some additional protocols and put them in the existing protocol stack. In this case, the API translator can be implemented as a layered protocol module.",
      "ja": "他のいくつかのオペレーティングシステムは、ユーザー定義のレイヤードプロトコルをサポートしているため、ユーザーはいくつかの追加のプロトコルを開発し、既存のプロトコルスタックに配置できます。この場合、API翻訳者は層状プロトコルモジュールとして実装できます。"
    },
    {
      "indent": 3,
      "text": "In the above two approaches, it is assumed that there exists both TCP(UDP)/IPv4 and TCP(UDP)/IPv6 stacks and there is no need to modify or to add a new TCP-UDP/IPv6 stack.",
      "ja": "上記の2つのアプローチでは、TCP（UDP）/IPv4とTCP（UDP）/IPv6スタックの両方が存在すると想定されており、新しいTCP-UUDP/IPv6スタックを変更または追加する必要はありません。"
    },
    {
      "indent": 0,
      "text": "6. Limitations",
      "section_title": true,
      "ja": "6. 制限"
    },
    {
      "indent": 3,
      "text": "In common with [NAT-PT], BIA needs to translate IP addresses embedded in application layer protocols, e.g., FTP. So it may not work for new applications which embed addresses in payloads.",
      "ja": "[NAT-PT]と一般的に、BIAは、アプリケーション層プロトコルに埋め込まれたIPアドレスを翻訳する必要があります。たとえば、FTP。そのため、ペイロードにアドレスを埋め込む新しいアプリケーションでは機能しない場合があります。"
    },
    {
      "indent": 3,
      "text": "This mechanism supports unicast communications only. In order to support multicast functions, some other additional functionalities must be considered in the function mapper module.",
      "ja": "このメカニズムは、ユニキャスト通信のみをサポートします。マルチキャスト関数をサポートするには、関数マッパーモジュールで他の追加の機能を考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "Since the IPv6 API has new advanced features, it is difficult to translate such kinds of IPv6 APIs into IPv4 APIs. Thus, IPv6 inbound communication with advanced features may be discarded.",
      "ja": "IPv6 APIには新しい高度な機能があるため、このような種類のIPv6 APIをIPv4 APIに変換することは困難です。したがって、高度な機能とのIPv6インバウンド通信が破棄される場合があります。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The security consideration of BIA mostly relies on that of [NAT-PT]. The differences are due to the address translation occurring at the API and not in the network layer. That is, since the mechanism uses the API translator at the socket API level, hosts can utilize the security of the network layer (e.g., IPsec) when they communicate with IPv6 hosts using IPv4 applications via the mechanism. As well, there isn't a DNS ALG as in NAT-PT, so there is no interference with DNSSEC.",
      "ja": "BIAのセキュリティに関する考慮事項は、主に[nat-pt]のセキュリティに依存しています。違いは、APIで発生するアドレス変換によるものであり、ネットワークレイヤーではありません。つまり、メカニズムはソケットAPIレベルでAPI翻訳者を使用するため、ホストはメカニズムを介してIPv4アプリケーションを使用してIPv6ホストと通信するときにネットワークレイヤー（IPSECなど）のセキュリティを利用できます。同様に、NAT-PTのようにDNSアルグはないため、DNSSECに干渉はありません。"
    },
    {
      "indent": 3,
      "text": "The use of address pooling may open a denial of service attack vulnerability. So BIA should employ the same sort of protection techniques as [NAT-PT] does.",
      "ja": "アドレスプーリングの使用は、サービス拒否攻撃の脆弱性を開く可能性があります。したがって、BIAは[NAT-PT]と同じ種類の保護技術を採用する必要があります。"
    },
    {
      "indent": 0,
      "text": "8. Acknowledgments",
      "section_title": true,
      "ja": "8. 謝辞"
    },
    {
      "indent": 3,
      "text": "We would like to acknowledge the implementation contributions by Wanjik Lee (wjlee@arang.miryang.ac.kr) and i2soft Corporation (www.i2soft.net).",
      "ja": "Wanjik Lee（wjlee@arang.miryang.ac.kr）とi2soft Corporation（www.i2soft.net）による実装の貢献を認めたいと思います。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9. 参考文献"
    },
    {
      "indent": 3,
      "text": "[TRANS-MECH] Gilligan, R. and E. Nordmark, \"Transition Mechanisms for IPv6 Hosts and Routers\", RFC 2893, August 2000.",
      "ja": "[Trans-Mech] Gilligan、R。およびE. Nordmark、「IPv6ホストとルーターの遷移メカニズム」、RFC 2893、2000年8月。"
    },
    {
      "indent": 3,
      "text": "[SIIT] Nordmark, E., \"Stateless IP/ICMP Translator (SIIT)\", RFC 2765, February 2000.",
      "ja": "[SIIT] Nordmark、E。、「Stateless IP/ICMP Translator（SIIT）」、RFC 2765、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[FTP] Postel, J. and J. Reynolds, \"File Transfer Protocol\", STD 9, RFC 959, October 1985.",
      "ja": "[FTP] Postel、J。およびJ. Reynolds、「ファイル転送プロトコル」、STD 9、RFC 959、1985年10月。"
    },
    {
      "indent": 3,
      "text": "[NAT] Srisuresh, P. and K. Egevang, \"Traditional IP Network Address Translator (Traditional NAT)\", RFC 3022, January 2001.",
      "ja": "[Nat] Srisuresh、P。およびK. Egevang、「従来のIPネットワークアドレス翻訳者（従来のNAT）」、RFC 3022、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[IPV4] Postel, J., \"Internet Protocol\", STD 5, RFC 791, September 1981.",
      "ja": "[IPv4] Postel、J。、「インターネットプロトコル」、STD 5、RFC 791、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[IPV6] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[IPv6] Deering、S。and R. Hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[NAT-PT] Tsirtsis, G. and P. Srisuresh, \"Network Address Translation - Protocol Translation (NAT-PT)\", RFC 2766, February 2000.",
      "ja": "[Nat-Pt] Tsirtsis、G。およびP. Srisuresh、「ネットワークアドレス変換 - プロトコル翻訳（NAT-PT）」、RFC 2766、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[BIS] Tsuchiya, K., Higuchi, H. and Y. Atarashi, \"Dual Stack Hosts using the \"Bump-In-the-Stack\" Technique (BIS)\", RFC 2767, February 2000.",
      "ja": "[Bis] Tsuchiya、K.、Higuchi、H。、およびY. Atarashi、「Bump-in-the-Stack」テクニック（BIS）を使用してデュアルスタックホスト」、RFC 2767、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[SOCK-EXT] Gilligan, R., Thomson, S., Bound, J. and W. Stevens, \"Basic Socket Interface Extensions for IPv6\", RFC 2553, March 1999.",
      "ja": "[Sock-Ext] Gilligan、R.、Thomson、S.、Bound、J。and W. Stevens、「IPv6の基本ソケットインターフェイス拡張機能」、RFC 2553、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC 2119] Bradner S., \"Key words for use in RFCs to indicate Requirement Levels\", RFC 2119, March 1997.",
      "ja": "[RFC 2119] Bradner S.、「要件レベルを示すためにRFCで使用するためのキーワード」、RFC 2119、1997年3月。"
    },
    {
      "indent": 0,
      "text": "Appendix A : API list intercepted by BIA",
      "ja": "付録A：BIAによって傍受されたAPIリスト"
    },
    {
      "indent": 3,
      "text": "The following functions are the API list which SHOULD be intercepted by BIA module.",
      "ja": "次の機能は、BIAモジュールで傍受する必要があるAPIリストです。"
    },
    {
      "indent": 3,
      "text": "The functions that the application uses to pass addresses into the system are:",
      "ja": "アプリケーションがアドレスをシステムに渡すために使用する機能は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "bind() connect() sendmsg() sendto()",
      "ja": "bind（）connect（）sendmsg（）sendto（）"
    },
    {
      "indent": 3,
      "text": "The functions that return an address from the system to an application are:",
      "ja": "システムからアプリケーションにアドレスを返す機能は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "accept() recvfrom() recvmsg() getpeername() getsockname()",
      "ja": "Accept（）recvfrom（）recvmsg（）getPeername（）getSockName（）"
    },
    {
      "indent": 3,
      "text": "The functions that are related to socket options are:",
      "ja": "ソケットオプションに関連する機能は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "getsocketopt() setsocketopt()",
      "ja": "getsockopt（）setsockopt（）"
    },
    {
      "indent": 3,
      "text": "The functions that are used for conversion of IP addresses embedded in application layer protocol (e.g., FTP, DNS, etc.) are:",
      "ja": "アプリケーションレイヤープロトコル（FTP、DNSなどなど）に埋め込まれたIPアドレスの変換に使用される関数は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "recv() send() read() write()",
      "ja": "recv（）send（）read（）write（）"
    },
    {
      "indent": 3,
      "text": "As well, raw sockets for IPv4 and IPv6 MAY be intercepted.",
      "ja": "同様に、IPv4およびIPv6の生のソケットが傍受される場合があります。"
    },
    {
      "indent": 3,
      "text": "Most of the socket functions require a pointer to the socket address structure as an argument. Each IPv4 argument is mapped into corresponding an IPv6 argument, and vice versa.",
      "ja": "ほとんどのソケット機能には、引数としてソケットアドレス構造へのポインターが必要です。各IPv4引数は、対応するIPv6引数にマッピングされ、その逆も同様です。"
    },
    {
      "indent": 3,
      "text": "According to [SOCK-EXT], the following new IPv6 basic APIs and structures are required.",
      "ja": "[Sock-Ext]によると、次の新しいIPv6基本APIと構造が必要です。"
    },
    {
      "indent": 6,
      "text": "IPv4                     new IPv6\n------------------------------------------------\nAF_INET                  AF_INET6\nsockaddr_in              sockaddr_in6\ngethostbyname()          getaddrinfo()\ngethostbyaddr()          getnameinfo()\ninet_ntoa()/inet_addr()  inet_pton()/inet_ntop()\nINADDR_ANY               in6addr_any",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "BIA MAY intercept inet_ntoa() and inet_addr() and use the address mapper for those. Doing that enables BIA to support literal IP addresses.",
      "ja": "BIAは、INET_NTOA（）およびINET_ADDR（）を傍受し、それらにアドレスマッパーを使用できます。それを行うことで、BIAは文字通りのIPアドレスをサポートできます。"
    },
    {
      "indent": 3,
      "text": "The gethostbyname() call return a list of addresses. When the name resolver function invokes getaddrinfo() and getaddrinfo() returns multiple IP addresses, whether IPv4 or IPv6, they SHOULD all be represented in the addresses returned by gethostbyname(). Thus if getaddrinfo() returns multiple IPv6 addresses, this implies that multiple address mappings will be created; one for each IPv6 address.",
      "ja": "gethostbyname（）callアドレスのリストを返します。名前のResolver関数がgetaddrinfo（）を呼び出し、getaddrinfo（）が複数のIPアドレスを返す場合、IPv4またはIPv6であろうと、Gethostbyname（）によって返されるアドレスですべてを表す必要があります。したがって、getAddrinfo（）が複数のIPv6アドレスを返す場合、これは複数のアドレスマッピングが作成されることを意味します。IPv6アドレスごとに1つ。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Seungyun Lee ETRI PEC 161 Kajong-Dong, Yusong-Gu, Taejon 305-350, Korea Tel: +82 42 860 5508 Fax: +82 42 861 5404 EMail: syl@pec.etri.re.kr",
      "ja": "Seungyun Lee Etri Pec 161 Kajong-Dong、Yusong-Gu、Taejon 305-350、韓国Tel：82 42 860 5508 Fax：82 42 861 5404電子メール：syl@pec.etri.re.kr"
    },
    {
      "indent": 3,
      "text": "Myung-Ki Shin ETRI PEC 161 Kajong-Dong, Yusong-Gu, Taejon 305-350, Korea Tel: +82 42 860 4847 Fax: +82 42 861 5404 EMail: mkshin@pec.etri.re.kr",
      "ja": "myung-ki shin etri pec 161 Kajong-Dong、Yusong-gu、Taejon 305-350、韓国Tel：82 42 860 4847 Fax：82 42 861 5404メール：mkshin@pec.etri.re.kr"
    },
    {
      "indent": 3,
      "text": "Yong-Jin Kim ETRI 161 Kajong-Dong, Yusong-Gu, Taejon 305-350, Korea Tel: +82 42 860 6564 Fax: +82 42 861 1033 EMail: yjkim@pec.etri.re.kr",
      "ja": "Yong-Jin Kim Etri 161 Kajong-Dong、Yusong-Gu、Taejon 305-350、韓国Tel：82 42 860 6564 Fax：82 42 861 1033電子メール：yjkim@pec.etri.re.kr"
    },
    {
      "indent": 3,
      "text": "Alain Durand Sun Microsystems, inc. 25 Network circle Menlo Park, CA 94025, USA Fax: +1 650 786 5896 EMail: Alain.Durand@sun.com",
      "ja": "Alain Durand Sun Microsystems、Inc。25ネットワークサークルメンロパーク、CA 94025、米国ファックス：1 650 786 5896メール：alain.durand@sun.com"
    },
    {
      "indent": 3,
      "text": "Erik Nordmark Sun Microsystems Laboratories 180, avenue de l'Europe 38334 SAINT ISMIER Cedex, France Tel: +33 (0)4 76 18 88 03 Fax: +33 (0)4 76 18 88 88 EMail: erik.nordmark@sun.com",
      "ja": "Erik Nordmark Sun Microsystems Laboratories 180、Avenue de l'Europe 38334 Saint Ismier Cedex、France Tel：33（0）4 76 18 88 03 Fax：33（0）4 76 18 88 88 ERIK.NORDMARK@sun.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2002). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2002）。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントと本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}