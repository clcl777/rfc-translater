{
  "title": {
    "text": "RFC 2614 - An API for Service Location",
    "ja": "RFC 2614 - サービス場所のAPI"
  },
  "number": 2614,
  "created_at": "2024-02-18 19:17:29.034575+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          J. Kempf\nRequest for Comments: 2614                                   E. Guttman\nCategory: Informational                                Sun Microsystems\n                                                              June 1999",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "An API for Service Location",
      "ja": "サービス場所のAPI"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモは、インターネットコミュニティに情報を提供します。いかなる種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "The Service Location Protocol (SLP) provides a new way for clients to dynamically discovery network services. With SLP, it is simple to offer highly available services that require no user configuration or assistance from network administrators prior to use. This document describes standardized APIs for SLP in C and Java. The APIs are modular and are designed to allow implementations to offer just the feature set needed. In addition, standardized file formats for configuration and serialized registrations are defined, allowing SLP agents to set network and other parameters in a portable way. The serialized file format allows legacy services to be registered with SLP directory agents in cases where modifying the legacy service program code is difficult or impossible, and to portably exchange a registration database.",
      "ja": "サービスロケーションプロトコル（SLP）は、クライアントがネットワークサービスを動的に発見する新しい方法を提供します。SLPを使用すると、使用前にユーザーの構成やネットワーク管理者からの支援を必要としない非常に利用可能なサービスを提供するのは簡単です。このドキュメントでは、CおよびJavaのSLPの標準化されたAPIについて説明しています。APIはモジュラーであり、実装が必要な機能セットのみを提供できるように設計されています。さらに、構成およびシリアル化された登録用の標準化されたファイル形式が定義されているため、SLPエージェントはネットワークやその他のパラメーターをポータブルな方法で設定できます。シリアル化されたファイル形式により、レガシーサービスプログラムコードの変更が困難または不可能である場合、レガシーサービスをSLPディレクトリエージェントに登録し、登録データベースを携帯的に交換することができます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 4,
      "text": "1. Introduction                                                    4\n    1.1. Goals  . . . . . . . . . . . . . . . . . . . . . . . .    4\n    1.2. Terminology  . . . . . . . . . . . . . . . . . . . . .    4\n2. File Formats                                                    7\n    2.1. Configuration File Format  . . . . . . . . . . . . . .    8\n          2.1.1. DA configuration   . . . . . . . . . . . . . .    9\n          2.1.2. Static Scope Configuration . . . . . . . . . .    9\n          2.1.3. Tracing and Logging  . . . . . . . . . . . . .   11\n          2.1.4. Serialized Proxy Registrations . . . . . . . .   11\n          2.1.5. Network Configuration Properties . . . . . . .   12\n          2.1.6. SA Configuration . . . . . . . . . . . . . . .   14\n          2.1.7. UA Configuration . . . . . . . . . . . . . . .   14\n          2.1.8. Security   . . . . . . . . . . . . . . . . . .   15\n    2.2. Multihomed Machines. . . . . . . . . . . . . . . . . .   16\n    2.3. Serialized Registration File . . . . . . . . . . . . .   16\n        2.4. Processing Serialized Registration and Configuration\n         Files  . . . . . . . . . . . . . . . . . . . . . . . .   18\n3. Binding Independent Implementation Considerations              18\n    3.1. Multithreading . . . . . . . . . . . . . . . . . . . .   18\n    3.2. Asynchronous and Incremental . . . . . . . . . . . . .   19\n    3.3. Type Checking for Service Types. . . . . . . . . . . .   19\n    3.4. Refreshing Registrations . . . . . . . . . . . . . . .   19\n    3.5. Configuration File Processing  . . . . . . . . . . . .   19\n    3.6. Attribute Types  . . . . . . . . . . . . . . . . . . .   20\n    3.7. Removal of Duplicates  . . . . . . . . . . . . . . . .   20\n    3.8. Character Set Encoding . . . . . . . . . . . . . . . .   20\n    3.9. Error Semantics  . . . . . . . . . . . . . . . . . . .   20\n   3.10. Modular Implementations  . . . . . . . . . . . . . . .   24\n   3.11. Handling Special Service Types . . . . . . . . . . . .   24\n   3.12. Scope Discovery and Handling . . . . . . . . . . . . .   24\n4. C Language Binding                                             25\n    4.1. Constant Types . . . . . . . . . . . . . . . . . . . .   26\n          4.1.1. URL Lifetimes. . . . . . . . . . . . . . . . .   26\n          4.1.2. Error Codes. . . . . . . . . . . . . . . . . .   26\n          4.1.3. SLPBoolean . . . . . . . . . . . . . . . . . .   27\n    4.2. Struct Types   . . . . . . . . . . . . . . . . . . . .   28\n          4.2.1. SLPSrvURL  . . . . . . . . . . . . . . . . . .   28\n          4.2.2. SLPHandle  . . . . . . . . . . . . . . . . . .   29\n    4.3. Callbacks  . . . . . . . . . . . . . . . . . . . . . .   29\n          4.3.1. SLPRegReport   . . . . . . . . . . . . . . . .   30\n          4.3.2. SLPSrvTypeCallback . . . . . . . . . . . . . .   30\n          4.3.3. SLPSrvURLCallback  . . . . . . . . . . . . . .   31\n          4.3.4. SLPAttrCallback  . . . . . . . . . . . . . . .   33\n    4.4. Opening and Closing an SLPHandle . . . . . . . . . . .   34\n          4.4.1. SLPOpen. . . . . . . . . . . . . . . . . . . .   34\n          4.4.2. SLPClose . . . . . . . . . . . . . . . . . . .   35\n    4.5. Protocol API   . . . . . . . . . . . . . . . . . . . .   36\n          4.5.1. SLPReg . . . . . . . . . . . . . . . . . . . .   36\n          4.5.2. SLPDereg . . . . . . . . . . . . . . . . . . .   37\n          4.5.3. SLPDelAttrs  . . . . . . . . . . . . . . . . .   38\n          4.5.4. SLPFindSrvTypes. . . . . . . . . . . . . . . .   39\n          4.5.5. SLPFindSrvs  . . . . . . . . . . . . . . . . .   41\n          4.5.6. SLPFindAttrs . . . . . . . . . . . . . . . . .   42\n    4.6. Miscellaneous Functions  . . . . . . . . . . . . . . .   43\n          4.6.1. SLPGetRefreshInterval  . . . . . . . . . . . .   44\n          4.6.2. SLPFindScopes  . . . . . . . . . . . . . . . .   44\n          4.6.3. SLPParseSrvURL . . . . . . . . . . . . . . . .   45\n          4.6.4. SLPEscape  . . . . . . . . . . . . . . . . . .   46\n          4.6.5. SLPUnescape  . . . . . . . . . . . . . . . . .   47\n          4.6.6. SLPFree  . . . . . . . . . . . . . . . . . . .   48\n          4.6.7. SLPGetProperty . . . . . . . . . . . . . . . .   48\n          4.6.8. SLPSetProperty . . . . . . . . . . . . . . . .   49\n    4.7. Implementation Notes   . . . . . . . . . . . . . . . .   49",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "           4.7.1. Refreshing Registrations . . . . . . . . . . .   49\n           4.7.2. Syntax for String Parameters . . . . . . . . .   49\n           4.7.3. Client Side Syntax Checking  . . . . . . . . .   50\n           4.7.4. System Properties  . . . . . . . . . . . . . .   50\n           4.7.5. Memory Management  . . . . . . . . . . . . . .   51\n           4.7.6. Asynchronous and Incremental Return Semantics.   51\n     4.8. Example. . . . . . . . . . . . . . . . . . . . . . . .   52\n 5. Java Language Binding                                          56\n     5.1. Introduction . . . . . . . . . . . . . . . . . . . . .   56\n     5.2. Exceptions and Errors  . . . . . . . . . . . . . . . .   56\n           5.2.1. Class ServiceLocationException . . . . . . . .   57\n     5.3. Basic Data Structures  . . . . . . . . . . . . . . . .   58\n           5.3.1. Interface ServiceLocationEnumeration . . . . .   58\n           5.3.2. Class ServiceLocationAttribute   . . . . . . .   58\n           5.3.3. Class ServiceType  . . . . . . . . . . . . . .   61\n           5.3.4. Class ServiceURL   . . . . . . . . . . . . . .   63\n     5.4. SLP Access Interfaces  . . . . . . . . . . . . . . . .   67\n           5.4.1. Interface Advertiser . . . . . . . . . . . . .   67\n           5.4.2. Interface Locator  . . . . . . . . . . . . . .   69\n     5.5. The Service Location Manager . . . . . . . . . . . . .   72\n           5.5.1. Class ServiceLocationManager . . . . . . . . .   72\n     5.6. Service Template Introspection . . . . . . . . . . . .   74\n           5.6.1. Abstract Class TemplateRegistry  . . . . . . .   74\n           5.6.2. Interface ServiceLocationAttributeVerifier . .   77\n           5.6.3. Interface ServiceLocationAttributeDescriptor .   79\n     5.7. Implementation Notes . . . . . . . . . . . . . . . . .   81\n           5.7.1. Refreshing Registrations . . . . . . . . . . .   81\n           5.7.2. Parsing Alternate Transports in ServiceURL . .   81\n           5.7.3. String Attribute Values  . . . . . . . . . . .   82\n           5.7.4. Client Side Syntax Checking. . . . . . . . . .   82\n           5.7.5. Language Locale Handling . . . . . . . . . . .   82\n           5.7.6. Setting SLP System Properties. . . . . . . . .   83\n           5.7.7. Multithreading . . . . . . . . . . . . . . . .   83\n           5.7.8. Modular Implementations  . . . . . . . . . . .   83\n           5.7.9. Asynchronous and Incremental Return Semantics.   84\n     5.8. Example. . . . . . . . . . . . . . . . . . . . . . . .   85\n 6. Internationalization Considerations                            87\n     6.1. service URL. . . . . . . . . . . . . . . . . . . . . .   87\n     6.2. Character Set Encoding . . . . . . . . . . . . . . . .   87\n     6.3. Language Tagging   . . . . . . . . . . . . . . . . . .   88\n 7. Security Considerations                                        88\n 8. Acknowledgements                                               88\n 9. References                                                     89\n10. Authors' Addresses                                             90\n11. Full Copyright Statement                                       91",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The Service Location API is designed for standardized access to the Service Location Protocol (SLP). The APIs allow client and service programs to be be written or modified in a very simple manner to provide dynamic service discovery and selection. Bindings in the C and Java languages are defined in this document. In addition, standardized formats for configuration files and for serialized registration files are presented. These files allow SLP agents to configure network parameters, to register legacy services that have not been SLP enabled, and to portably exchange registration databases.",
      "ja": "サービスロケーションAPIは、サービスロケーションプロトコル（SLP）への標準化されたアクセス用に設計されています。APIにより、クライアントとサービスプログラムを非常に簡単な方法で記述または変更して、動的なサービスの発見と選択を提供できます。CおよびJava言語のバインディングは、このドキュメントで定義されています。さらに、構成ファイルおよびシリアル化された登録ファイルの標準化された形式が表示されます。これらのファイルにより、SLPエージェントはネットワークパラメーターを構成し、SLPが有効になっていないレガシーサービスを登録し、登録データベースをポータブルに交換することができます。"
    },
    {
      "indent": 0,
      "text": "1.1. Goals",
      "section_title": true,
      "ja": "1.1. 目標"
    },
    {
      "indent": 3,
      "text": "The overall goal of the API is to enable source portability of applications that use the API between different implementations of SLP. The result should facilitate the adoption of SLP, and conversion of clients and service programs to SLP.",
      "ja": "APIの全体的な目標は、SLPの異なる実装間でAPIを使用するアプリケーションのソースポータビリティを有効にすることです。結果は、SLPの採用、およびクライアントとサービスプログラムのSLPへの変換を容易にするはずです。"
    },
    {
      "indent": 3,
      "text": "The goals of the C binding are to create a minimal but complete access to the functionality of the SLP protocol, allowing for simple memory management and limited code size.",
      "ja": "Cバインディングの目標は、SLPプロトコルの機能に最小限であるが完全なアクセスを作成し、シンプルなメモリ管理とコードサイズが制限されることです。"
    },
    {
      "indent": 3,
      "text": "The Java API provides for modular implementations (where unneeded features can be omitted) and an object oriented interface to the complete set of SLP data and functionality.",
      "ja": "Java APIは、モジュラー実装（不要な機能を省略できる場合）と、SLPデータと機能の完全なセットへのオブジェクト指向インターフェイスを提供します。"
    },
    {
      "indent": 3,
      "text": "The standardized configuration file and serialized file formats provide a simple syntax with complete functional coverage of the protocol, but without system dependent properties and secure information.",
      "ja": "標準化された構成ファイルとシリアル化されたファイル形式は、プロトコルの完全な機能カバレッジを備えた単純な構文を提供しますが、システムに依存するプロパティと安全な情報はありません。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology",
      "section_title": true,
      "ja": "1.2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [1].",
      "ja": "「必須」、「そうしない」、「必須」、「必要」、「「しない」、「そうでない」、「そうではない」、「そうでない」、「推奨」、「5月」、および「オプション」は、RFC 2119 [1]に記載されているように解釈される。"
    },
    {
      "indent": 6,
      "text": "Service Location Protocol (SLP)",
      "ja": "サービスロケーションプロトコル（SLP）"
    },
    {
      "indent": 9,
      "text": "The underlying protocol allowing dynamic and scalable service discovery. This protocol is specified in the Service Location Protocol Version 2 [7].",
      "ja": "動的でスケーラブルなサービスの発見を可能にする基礎となるプロトコル。このプロトコルは、サービスロケーションプロトコルバージョン2 [7]で指定されています。"
    },
    {
      "indent": 6,
      "text": "SLP framework",
      "ja": "SLPフレームワーク"
    },
    {
      "indent": 9,
      "text": "When a 'Service Location framework' is mentioned, it refers to both the SLP implementation and interface implementation; i.e. whatever provides the SLP functionality to user level programs. This includes remote agents.",
      "ja": "「サービスロケーションフレームワーク」が言及されている場合、SLP実装とインターフェイスの実装の両方を指します。つまり、ユーザーレベルプログラムにSLP機能を提供するものは何でも。これには、リモートエージェントが含まれます。"
    },
    {
      "indent": 6,
      "text": "Directory Agent (DA)",
      "ja": "ディレクトリエージェント（DA）"
    },
    {
      "indent": 9,
      "text": "A service that automatically gathers service advertisements from SAs in order to provide them to UAs.",
      "ja": "UASに提供するためにSASからサービス広告を自動的に収集するサービス。"
    },
    {
      "indent": 6,
      "text": "User Agent (UA)",
      "ja": "ユーザーエージェント（UA）"
    },
    {
      "indent": 9,
      "text": "This is the Service Location process or library that allows SLP requests to be made on behalf of a client process. UAs automatically direct requests to DAs when they exist. In their absence, UAs make requests to SAs.",
      "ja": "これは、クライアントプロセスに代わってSLPリクエストを行うことを可能にするサービスロケーションプロセスまたはライブラリです。UASが存在するときにDASにリクエストを自動的に指示します。彼らの不在の場合、UASはSASにリクエストを行います。"
    },
    {
      "indent": 6,
      "text": "Service Agent (SA)",
      "ja": "サービスエージェント（SA）"
    },
    {
      "indent": 9,
      "text": "This is the Service Location process or library that allows service software to register and deregister itself with the SLP framework. SAs respond to UA service requests, detect DAs and register service advertisements with them.",
      "ja": "これは、サービスソフトウェアがSLPフレームワークに登録および登録を可能にするサービスロケーションプロセスまたはライブラリです。SASはUAサービスリクエストに応答し、DASを検出し、サービス広告を登録します。"
    },
    {
      "indent": 6,
      "text": "SA Server",
      "ja": "SAサーバー"
    },
    {
      "indent": 9,
      "text": "Many operating system platforms only allow a single process to listen on a particular port number. Since SAs are required to listen on a multicast address for SLP service requests, implementations of the SLP framework on such platforms that want to support multiple SAs on one machine need to arrange for a single process to do the listening while the advertising SAs communicate with that process through another mechanism. The single listening process is called an SA server. SA servers share many characteristics with DAs, but they are not the same.",
      "ja": "多くのオペレーティングシステムプラットフォームでは、単一のプロセスが特定のポート番号で聞くことができます。SASはSLPサービスリクエストのマルチキャストアドレスでリッスンする必要があるため、1つのマシンで複数のSASをサポートしたいプラットフォームでのSLPフレームワークの実装は、広告SASがそれと通信している間にリスニングを行うための単一のプロセスを手配する必要があります別のメカニズムを介した処理。単一のリスニングプロセスは、SAサーバーと呼ばれます。SAサーバーはDASと多くの特性を共有していますが、それらは同じではありません。"
    },
    {
      "indent": 6,
      "text": "Service Advertisement",
      "ja": "サービス広告"
    },
    {
      "indent": 9,
      "text": "A URL possibly combined with service attributes. These are made available to UAs by SAs, either directly or via a DA.",
      "ja": "おそらくサービス属性と組み合わされたURL。これらは、直接またはDAを介して、SASによってUASが利用できるようになります。"
    },
    {
      "indent": 6,
      "text": "Locale",
      "ja": "ロケール"
    },
    {
      "indent": 9,
      "text": "The language localization that applies to strings passed into or returned from the SLP API. The Locale is expressed using a Language Tag [6]. All attribute strings are associated with a particular locale. The locale is completely orthogonal to the ANSI C locale. The SLP locale is mapped into the Java locale in the Java API.",
      "ja": "SLP APIに渡されたり返された文字列に適用される言語ローカリゼーション。ロケールは、言語タグ[6]を使用して表現されます。すべての属性文字列は、特定のロケールに関連付けられています。ロケールは、ANSI Cロケールに対して完全に直交しています。SLPロケールは、Java APIのJavaロケールにマッピングされます。"
    },
    {
      "indent": 6,
      "text": "Service Template",
      "ja": "サービステンプレート"
    },
    {
      "indent": 9,
      "text": "A document that describes the syntax of the URL for a given service type and a definition of all service attributes including the meaning, defaults, and constraints on values the attributes may take. See [8] for more information on service templates.",
      "ja": "特定のサービスタイプのURLの構文と、属性が取る可能性のある値の意味、デフォルト、および制約を含むすべてのサービス属性の定義を説明するドキュメント。サービステンプレートの詳細については、[8]を参照してください。"
    },
    {
      "indent": 6,
      "text": "The service: URL",
      "ja": "サービス：URL"
    },
    {
      "indent": 9,
      "text": "A service of a particular type announces its availability with a service: URL that includes its service access point (domain name or IP address, and possibly its port number) and optionally basic configuration parameters. The syntax of the service: URL is defined in the service template. Other URL's can be used in service advertisements if desired.",
      "ja": "特定のタイプのサービスは、サービスアクセスポイント（ドメイン名またはIPアドレス、場合によってはポート番号）、およびオプションで基本的な構成パラメーターを含むサービスでの可用性を発表します。サービスの構文：URLは、サービステンプレートで定義されています。他のURLは、必要に応じてサービス広告で使用できます。"
    },
    {
      "indent": 6,
      "text": "Service Attributes",
      "ja": "サービス属性"
    },
    {
      "indent": 9,
      "text": "The attributes associated with a given service. The values that can be assigned to service attributes are defined by the service template.",
      "ja": "特定のサービスに関連付けられた属性。サービス属性に割り当てることができる値は、サービステンプレートによって定義されます。"
    },
    {
      "indent": 6,
      "text": "Scope",
      "ja": "範囲"
    },
    {
      "indent": 9,
      "text": "A string used to control the availability of service advertisements. Every SLP Agent is configured with one or more scope strings. Scopes are assigned by site administrators to group services for many purposes, but chiefly as a means of scalability. DAs store only services advertised having a scope string matching the scopes with which they are configured.",
      "ja": "サービス広告の可用性を制御するために使用される文字列。すべてのSLPエージェントは、1つ以上のスコープ文字列で構成されています。スコープは、サイト管理者によって多くの目的のためにグループサービスに割り当てられますが、主にスケーラビリティの手段として割り当てられます。DAS Storeのみのサービスは、構成されているスコープに一致するスコープ文字列を持つ広告のみです。"
    },
    {
      "indent": 6,
      "text": "Naming Authority (NA)",
      "ja": "命名権限（NA）"
    },
    {
      "indent": 9,
      "text": "This is a 'suffix' to the service type string. It completely changes the meaning of the service type. NAs are used for private definitions of well known Service Types and experimental Service Type extensions. The default NA is \"IANA\", which must not be explicitly included. Service types with the IANA naming authority are registered with the Internet Assigned Numbers Authority (see [8] for more information on the registration procedure).",
      "ja": "これは、サービスタイプの文字列に対する「接尾辞」です。サービスタイプの意味を完全に変更します。NASは、よく知られているサービスタイプと実験的なサービスタイプの拡張のプライベート定義に使用されます。デフォルトのNAは「IANA」であり、明示的に含めてはなりません。IANA Naming Authorityのサービスタイプは、登録手順の詳細については、インターネットに割り当てられた数字局に登録されています（[8]を参照）。"
    },
    {
      "indent": 0,
      "text": "2. File Formats",
      "section_title": true,
      "ja": "2. ファイル形式"
    },
    {
      "indent": 3,
      "text": "This section describes the configuration and serialized registration file formats. Both files are defined in the UTF-8 character set [3].",
      "ja": "このセクションでは、構成とシリアル化された登録ファイル形式について説明します。両方のファイルは、UTF-8文字セット[3]で定義されています。"
    },
    {
      "indent": 3,
      "text": "Attribute tags and values in the serialized registration file require SLP reserved characters to be escaped. The SLP reserved characters are `(', `)', `,', `\\', `!', `<', `=', `>', `~' and control characters (characters with UTF codes less than 0x0020 and the character 0x007f, which is US-ASCII DEL). The escapes are formed exactly as for the wire protocol, i.e. a backslash followed by two hex digits representing the character. For example, the escape for ' ,' is '\\2c'. In addition, the characters `\\n', `\\r', `\\t', and `_' are prohibited from attribute tags by the SLP wire syntax grammar. [7]",
      "ja": "シリアル化された登録ファイルの属性タグと値では、SLP予約文字を逃がす必要があります。SLP予約文字は、 `（ '、`）'、 `、 '、'、` \\ '、 `！'、` <'、 `='、`> '、 `〜'、およびコントロール文字です（UTFコードを持つ文字が低い文字0x0020およびキャラクター0x007f、これはus-ascii del）。エスケープは、ワイヤープロトコル、つまりバックスラッシュに続いて、文字を表す2ヘクスの数字が続くように形成されます。たとえば、「 'for'、 '、'、 '\\ 2c'）。さらに、文字「\\ n」、 `\\ r '、` \\ t'、および `_ 'は、SLPワイヤの構文文法による属性タグを禁止されています。[7]"
    },
    {
      "indent": 3,
      "text": "In serialized registration files, escaped strings beginning with `\\ff`, an encoding for a nonUTF-8 character, are treated as opaques. Exactly as in the wire protocol, syntactically correct opaque encodings consist of a string beginning with `\\ff` and containing *only* escaped characters that are transformed to bytes. Such strings are only syntactically correct in the serialized registration file as attribute values. In other cases, whenever an escape is encountered and the character is not an SLP reserved character, an error is signaled.",
      "ja": "シリアル化された登録ファイルでは、非UTF-8文字のエンコーディングである「\\ ff」から始まる文字列が脱出され、オパークとして扱われます。ワイヤープロトコルのように、構文的に正しい不透明エンコーディングは、「\\ ff」で始まり、バイトに変換される *逃げた *のみ *のみを含む文字列で構成されています。このような文字列は、属性値としてシリアル化された登録ファイルでの構文的にのみ正しいです。他の場合では、脱出が遭遇し、キャラクターがSLP予約型のキャラクターではない場合はいつでも、エラーが合図されます。"
    },
    {
      "indent": 3,
      "text": "Escaped characters in URLs in serialized registration files use the URL escape convention. [2].",
      "ja": "シリアル化された登録ファイルのURLの脱出文字は、URLエスケープ条約を使用します。[2]。"
    },
    {
      "indent": 3,
      "text": "Property names and values in the configuration file have a few reserved characters that are involved in file's lexical definition. The characters '.' and '=' are reserved in property names and must be escape. The characters ',', '(', and ')' are reserved in property values and must be escaped. In addition, scope names in the net.slp.useScopes property use the SLP wire format escape convention for SLP reserved characters. This simplifies implementation, since the same code can be used to unescape scope names as is used in processing the serialized registration file or for formatting wire messages.",
      "ja": "構成ファイルのプロパティ名と値には、ファイルの語彙定義に関係するいくつかの予約された文字があります。キャラクター '。'および '='は不動産名で予約されており、脱出する必要があります。キャラクター「」、 '、'（ '、および'） 'はプロパティ値で予約されており、逃げる必要があります。さらに、net.slp.usescopesプロパティ内のスコープ名は、SLP予約文字にSLPワイヤ形式のエスケープコンベンションを使用します。同じコードを使用して、シリアル化された登録ファイルの処理やワイヤーメッセージのフォーマットに使用されるように、同じコードを使用してスコープ名を無効にすることができるため、実装が簡素化されます。"
    },
    {
      "indent": 3,
      "text": "On platforms that only support US-ASCII and not UTF-8, the upper bit of bytes incoming from the configuration and registration files determines whether the character is US-ASCII or not US-ASCII. According to the standard UTF-8 encoding, the upper bit is zero if the character is US-ASCII and one if the character is multibyte and thus not US-ASCII. Platforms without intrinsic UTF-8 support are required to parse the multibyte character and store it in an appropriate internal format. Support for UTF-8 is required to implement the SLP protocol (see [7]), and can therefore be used in file processing as well.",
      "ja": "UTF-8ではなくUS-ASCIIのみをサポートするプラットフォームでは、構成ファイルと登録ファイルからのバイトの上部ビットが、キャラクターがUS-ASCIIであるかどうかを決定します。標準のUTF-8エンコーディングによると、キャラクターがus-asciiの場合は上部ビットはゼロで、キャラクターがマルチバイトであり、したがってus-asciiではない場合はゼロです。本質的なUTF-8サポートのないプラットフォームは、マルチバイト文字を解析し、適切な内部形式で保存するために必要です。UTF-8のサポートは、SLPプロトコルを実装するために必要であるため（[7]を参照）、ファイル処理でも使用できます。"
    },
    {
      "indent": 3,
      "text": "The location and name of the configuration file is system-dependent, but implementations of the API are encouraged to locate it together with other configuration files and name it consistently.",
      "ja": "構成ファイルの場所と名前はシステム依存ですが、APIの実装は、他の構成ファイルと一緒に配置し、一貫して名前を付けることが推奨されます。"
    },
    {
      "indent": 0,
      "text": "2.1. Configuration File Format",
      "section_title": true,
      "ja": "2.1. 構成ファイル形式"
    },
    {
      "indent": 3,
      "text": "The configuration file format consists of a newline delimited list of zero or more property definitions. Each property definition corresponds to a particular configurable SLP, network, or other parameter in one or more of the three SLP agents. The file format grammar in ABNF [5] syntax is:",
      "ja": "構成ファイル形式は、ゼロ以上のプロパティ定義のNewline Delimitedリストで構成されています。各プロパティ定義は、3つのSLPエージェントの1つ以上の特定の構成可能なSLP、ネットワーク、またはその他のパラメーターに対応しています。ABNF [5]のファイル形式の文法は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "config-file   =  line-list\nline-list     =  line / line line-list\nline          =  property-line / comment-line\ncomment-line  =  ( \"#\" / \";\" ) 1*allchar newline\nproperty-line =  property newline\nproperty      =  tag \"=\" value-list\ntag           =  prop / prop \".\" tag\nprop          =  1*tagchar\nvalue-list    =  value / value \",\" value-list\nvalue         =  int / bool /\n                 \"(\" value-list \")\" / string\nint           =  1*DIGIT\nbool          =  \"true\" / \"false\" / \"TRUE\" / \"FALSE\"\nnewline       =  CR / ( CRLF )\nstring        =  1*stringchar\ntagchar       =  DIGIT / ALPHA / tother / escape\ntother        =  %x21-%x2d / %x2f /\n                 %x3a / %x3c-%x40 /\n                 %x5b-%x60 / %7b-%7e\n                 ; i.e., all characters except `.',\n                 ; and `='.\nstringchar    =  DIGIT / ALPHA / sother / escape\nsother        =  %x21-%x29 / %x2a-%x2b /\n                 %x2d-%x2f / %x3a-%x40 /\n                 %x5b-%x60 / %7b-%7e\n                 ; i.e., all characters except `,'\nallchar       =  DIGIT / ALPHA / HTAB / SP\nescape        =  \"\\\" HEXDIG HEXDIG\n                 ; Used for reserved characters",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "With the exception of net.slp.useScopes, net.slp.DAAddresses, and net.slp.isBroadcastOnly, all other properties can be changed through property accessors in the C and Java APIs. The property accessors only change the property values in the running agent program and do not affect the values in the configuration file. The net.slp.useScopes and net.slp.DAAddresses properties are read-only because they control the agent's view of the scopes and DAs and are therefore critical to the function of the API scope discovery algorithm. Attempts to modify them are unlikely to yield productive results, and could harm the ability of the agent to find scopes and use DAs. The net.slp.isBroadcastOnly property is read-only because the API library needs to configure networking upon start up and changing this property might invalidate the configuration. Whether the local network uses broadcast or multicast is not likely to change during the course of the program's execution.",
      "ja": "net.slp.usescopes、net.slp.daaddresses、およびnet.slp.isbroadcastonlyを除き、他のすべてのプロパティは、CおよびJava APIのプロパティアクセサを介して変更できます。プロパティアクセサは、実行中のエージェントプログラムのプロパティ値のみを変更し、構成ファイルの値に影響しません。net.slp.usescopesおよびnet.slp.daaddressesプロパティは、スコープとDAのエージェントのビューを制御するため、APIスコープ発見アルゴリズムの機能にとって重要であるため、読み取り専用です。それらを変更しようとする試みは、生産的な結果をもたらす可能性が低く、エージェントがスコープを見つけてDAを使用する能力を損なう可能性があります。net.slp.isbroadcastonlyプロパティは、APIライブラリが起動時にネットワークを構成する必要があるため、読み取り専用です。このプロパティを変更すると、構成が無効になる可能性があります。ローカルネットワークがブロードキャストを使用しているのかマルチキャストを使用しているのかは、プログラムの実行中に変更される可能性は低いです。"
    },
    {
      "indent": 3,
      "text": "The properties break down into the following subsections describes an area and its properties.",
      "ja": "次のサブセクションに分類されるプロパティは、エリアとそのプロパティを説明しています。"
    },
    {
      "indent": 0,
      "text": "2.1.1. DA configuration",
      "section_title": true,
      "ja": "2.1.1. DA構成"
    },
    {
      "indent": 3,
      "text": "Important configuration properties for DAs are included in this section. These are:",
      "ja": "このセクションには、DASの重要な構成プロパティが含まれています。これらは："
    },
    {
      "indent": 6,
      "text": "net.slp.isDA",
      "ja": "net.slp.isda"
    },
    {
      "indent": 9,
      "text": "A boolean indicating if the SLP server is to act as a DA. If false, not run as a DA. Default is false.",
      "ja": "SLPサーバーがDAとして機能するかどうかを示すブール値。falseの場合、DAとして実行されません。デフォルトはfalseです。"
    },
    {
      "indent": 6,
      "text": "net.slp.DAHeartBeat",
      "ja": "net.slp.daheartbeat"
    },
    {
      "indent": 9,
      "text": "A 32 bit integer giving the number of seconds for the DA heartbeat. Default is 3 hours (10800 seconds). This property corresponds to the protocol specification parameter CONFIG_DA_BEAT [7]. Ignored if isDA is false.",
      "ja": "DAハートビートの秒数を与える32ビット整数。デフォルトは3時間（10800秒）です。このプロパティは、プロトコル仕様パラメーターconfig_da_beat [7]に対応しています。ISDAが偽である場合は無視されます。"
    },
    {
      "indent": 6,
      "text": "net.slp.DAAttributes",
      "ja": "net.slp.daattributes"
    },
    {
      "indent": 9,
      "text": "A comma-separated list of parenthesized attribute/value list pairs that the DA must advertise in DAAdverts. The property must be in the SLP attribute list wire format, including escapes for reserved characters. [7]",
      "ja": "DAがDAADVERTSで宣伝しなければならない括弧付き属性/値リストペアのコンマ分離されたリスト。プロパティは、予約済みの文字の脱出を含む、SLP属性リストワイヤ形式でなければなりません。[7]"
    },
    {
      "indent": 0,
      "text": "2.1.2. Static Scope Configuration",
      "section_title": true,
      "ja": "2.1.2. 静的スコープ構成"
    },
    {
      "indent": 3,
      "text": "These properties allow various aspects of scope handling to be configured.",
      "ja": "これらのプロパティにより、スコープ処理のさまざまな側面を構成できます。"
    },
    {
      "indent": 6,
      "text": "net.slp.useScopes",
      "ja": "net.slp.usescopes"
    },
    {
      "indent": 9,
      "text": "A value-list of strings indicating the only scopes a UA or SA is allowed to use when making requests or registering, or the scopes a DA must support. If not present for the DA and SA, then in the absence of scope information from DHCP, the default scope \"DEFAULT\" is used. If not present for the UA, and there is no scope information available from DHCP, then the user scoping model is in force. Active and passive DA discovery or SA discovery are used for scope discovery, and the scope \"DEFAULT\" is used if no other information is available. If a DA or SA gets another scope in a request, a SCOPE_NOT_SUPPORTED error should be returned, unless the request was multicast, in which case it should be dropped. If a DA gets another scope in a registration, a SCOPE_NOT_SUPPORTED error must be returned. Unlike other properties, this property is \"read-only\", so attempts to change it after the configuration file has been read are ignored. See Section 3.12 for the algorithm the API uses in determining what scope information to present.",
      "ja": "リクエストまたは登録時にUAまたはSAの唯一のスコープが使用されることを示す文字列の値リスト、またはDAがサポートする必要があるスコープ。DAとSAに存在しない場合は、DHCPからスコープ情報がない場合、デフォルトのスコープ「デフォルト」が使用されます。UAに存在しない場合、DHCPから利用可能なスコープ情報がない場合、ユーザースコープモデルが有効です。アクティブでパッシブDAの発見またはSA発見がスコープディスカバリーに使用され、他の情報が利用できない場合はスコープ「デフォルト」が使用されます。DAまたはSAがリクエストで別のスコープを取得した場合、要求がマルチキャストでない限り、scope_not_supportedエラーを返す必要があります。その場合、削除する必要があります。DAが登録で別のスコープを取得する場合、SCOPE_NOT_SUPPORTEDエラーを返す必要があります。他のプロパティとは異なり、このプロパティは「読み取り専用」であるため、構成ファイルが読み取られた後に変更しようとする試みは無視されます。APIが提示するスコープ情報を決定する際に使用するアルゴリズムについては、セクション3.12を参照してください。"
    },
    {
      "indent": 6,
      "text": "net.slp.DAAddresses",
      "ja": "net.slp.daaddresses"
    },
    {
      "indent": 9,
      "text": "A value-list of IP addresses or DNS resolvable host names giving the SLPv2 DAs to use for statically configured UAs and SAs. Ignored by DAs (unless the DA is also an SA server). Default is none. Unlike other properties, this property is \"read-only\", so attempts to change it after the configuration file has been read are ignored.",
      "ja": "IPアドレスまたはDNS解決可能なホスト名の値リストは、SLPV2 DASに静的に構成されたUASおよびSASに使用することを可能にします。DASによって無視されます（DAもSAサーバーでない限り）。デフォルトはなしです。他のプロパティとは異なり、このプロパティは「読み取り専用」であるため、構成ファイルが読み取られた後に変更しようとする試みは無視されます。"
    },
    {
      "indent": 9,
      "text": "The following grammar describes the property:",
      "ja": "次の文法では、プロパティについて説明しています。"
    },
    {
      "indent": 15,
      "text": "addr-list     =  addr / addr \",\" addr-list\naddr          =  fqdn / hostnumber\nfqdn          =  ALPHA / ALPHA *[ anum / \"-\" ] anum\nanum          =  ALPHA / DIGIT\nhostnumber    =  1*3DIGIT 3(\".\" 1*3DIGIT)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "An example is:",
      "ja": "例は次のとおりです。"
    },
    {
      "indent": 16,
      "text": "sawah,mandi,sambal",
      "ja": "Sawah、Mandi、Sambal"
    },
    {
      "indent": 9,
      "text": "IP addresses can be used instead of host names in networks where DNS is not deployed, but network administrators are reminded that using IP addresses will complicate machine renumbering, since the SLP configuration property files in statically configured networks will have to be changed. Similarly, if host names are used, implementors must be careful that a name service is available before SLP starts, in other words, SLP cannot be used to find the name service.",
      "ja": "DNSが展開されていないネットワークのホスト名の代わりにIPアドレスを使用できますが、ネットワーク管理者は、静的に構成されたネットワークのSLP構成プロパティファイルを変更する必要があるため、IPアドレスを使用するとマシンの変更が複雑になることを思い出させます。同様に、ホスト名が使用されている場合、実装者はSLPが開始する前に名前サービスを利用できることに注意する必要があります。つまり、SLPを使用して名前サービスを見つけることができません。"
    },
    {
      "indent": 0,
      "text": "2.1.3. Tracing and Logging",
      "section_title": true,
      "ja": "2.1.3. トレースとロギング"
    },
    {
      "indent": 3,
      "text": "This section allows tracing and logging information to be printed by the various agents.",
      "ja": "このセクションでは、さまざまなエージェントによって情報を印刷することができます。"
    },
    {
      "indent": 6,
      "text": "net.slp.traceDATraffic",
      "ja": "net.slp.tracedatraffic"
    },
    {
      "indent": 9,
      "text": "A boolean controlling printing of messages about traffic with DAs. Default is false.",
      "ja": "DASを使用したトラフィックに関するメッセージの印刷を制御するブールの制御。デフォルトはfalseです。"
    },
    {
      "indent": 6,
      "text": "net.slp.traceMsg",
      "ja": "net.slp.tracemsg"
    },
    {
      "indent": 9,
      "text": "A boolean controlling printing of details on SLP messages. The fields in all incoming messages and outgoing replies are printed. Default is false.",
      "ja": "SLPメッセージの詳細の印刷を制御するブールの制御。すべての着信メッセージと発信応答のフィールドが印刷されます。デフォルトはfalseです。"
    },
    {
      "indent": 6,
      "text": "net.slp.traceDrop",
      "ja": "net.slp.tracedrop"
    },
    {
      "indent": 9,
      "text": "A boolean controlling printing details when a SLP message is dropped for any reason. Default is false.",
      "ja": "何らかの理由でSLPメッセージが削除されたときの印刷の詳細を制御するブールの制御。デフォルトはfalseです。"
    },
    {
      "indent": 6,
      "text": "net.slp.traceReg",
      "ja": "net.slp.tracereg"
    },
    {
      "indent": 9,
      "text": "A boolean controlling dumps of all registered services upon registration and deregistration. If true, the contents of the DA or SA server are dumped after a registration or deregistration occurs. Default is false.",
      "ja": "登録と登録時に登録されたすべてのサービスのブール制御ダンプ。Trueの場合、DAまたはSAサーバーのコンテンツは、登録または登録が発生した後にダンプされます。デフォルトはfalseです。"
    },
    {
      "indent": 0,
      "text": "2.1.4. Serialized Proxy Registrations",
      "section_title": true,
      "ja": "2.1.4. シリアル化されたプロキシ登録"
    },
    {
      "indent": 3,
      "text": "These properties control the reading and writing of serialized registrations.",
      "ja": "これらのプロパティは、シリアル化された登録の読み取りと書き込みを制御します。"
    },
    {
      "indent": 6,
      "text": "net.slp.serializedRegURL",
      "ja": "net.slp.serializedregurl"
    },
    {
      "indent": 9,
      "text": "A string containing a URL pointing to a document containing serialized registrations that should be processed when the DA or SA server starts up. Default is none.",
      "ja": "DAまたはSAサーバーが起動したときに処理する必要があるシリアル化された登録を含むドキュメントを指すURLを含む文字列。デフォルトはなしです。"
    },
    {
      "indent": 0,
      "text": "2.1.5. Network Configuration Properties",
      "section_title": true,
      "ja": "2.1.5. ネットワーク構成プロパティ"
    },
    {
      "indent": 3,
      "text": "The properties in this section allow various network configuration properties to be set.",
      "ja": "このセクションのプロパティにより、さまざまなネットワーク構成プロパティを設定できます。"
    },
    {
      "indent": 6,
      "text": "net.slp.isBroadcastOnly",
      "ja": "net.slp.isbroadcastonly"
    },
    {
      "indent": 9,
      "text": "A boolean indicating if broadcast should be used instead of multicast. Like the net.slp.useScopes and net.slp.DAAddresses properties, this property is \"read-only\", so attempts to change it after the configuration file has been read are ignored. Default is false.",
      "ja": "マルチキャストの代わりにブロードキャストを使用するかどうかを示すブール値。net.slp.usescopesやnet.slp.daaddressesプロパティのように、このプロパティは「読み取り専用」であるため、構成ファイルが読み取られた後に変更しようとする試みは無視されます。デフォルトはfalseです。"
    },
    {
      "indent": 6,
      "text": "net.slp.passiveDADetection",
      "ja": "net.slp.passivedadeTection"
    },
    {
      "indent": 9,
      "text": "A boolean indicating whether passive DA detection should be used. Default is true.",
      "ja": "パッシブDA検出を使用すべきかどうかを示すブール値。デフォルトはtrueです。"
    },
    {
      "indent": 6,
      "text": "net.slp.multicastTTL",
      "ja": "net.slp.multicastttl"
    },
    {
      "indent": 9,
      "text": "A positive integer less than or equal to 255, giving the multicast TTL. Default is 255.",
      "ja": "255以下の正の整数で、マルチキャストTTLが得られます。デフォルトは255です。"
    },
    {
      "indent": 6,
      "text": "net.slp.DAActiveDiscoveryInterval",
      "ja": "net.slp.daactivediscoveryinterval"
    },
    {
      "indent": 9,
      "text": "A 16 bit positive integer giving the number of seconds between DA active discovery queries. Default is 900 seconds (15 minutes). This property corresponds to the protocol specification parameter CONFIG_DA_FIND [7]. If the property is set to zero, active discovery is turned off. This is useful when the DAs available are explicitly restricted to those obtained from DHCP or the net.slp.DAAddresses property.",
      "ja": "DA Active Discoveryクエリの間に秒数を与える16ビットの正の整数。デフォルトは900秒（15分）です。このプロパティは、プロトコル仕様パラメーターconfig_da_find [7]に対応しています。プロパティがゼロに設定されている場合、アクティブな発見がオフになります。これは、利用可能なDASがDHCPまたはnet.slp.daaddressesプロパティから取得したものに明示的に制限されている場合に役立ちます。"
    },
    {
      "indent": 6,
      "text": "net.slp.multicastMaximumWait",
      "ja": "net.slp.multicastmaximumwait"
    },
    {
      "indent": 9,
      "text": "A 32 bit integer giving the maximum amount of time to perform multicast, in milliseconds. Default is 15000 ms (15 sec.). This property corresponds to the CONFIG_MC_MAX parameter in the protocol specification [7].",
      "ja": "32ビット整数がミリ秒単位でマルチキャストを実行するのに最大の時間を与えます。デフォルトは15000ミリ秒（15秒）です。このプロパティは、プロトコル仕様[7]のconfig_mc_maxパラメーターに対応しています。"
    },
    {
      "indent": 6,
      "text": "net.slp.multicastTimeouts",
      "ja": "net.slp.multicasttimeouts"
    },
    {
      "indent": 9,
      "text": "A value-list of 32 bit integers used as timeouts, in milliseconds, to implement the multicast convergence algorithm. Each value specifies the time to wait before sending the next request, or until nothing new has been learned from two successive requests. Default is: 3000,3000,3000,3000,3000. In a fast network the aggressive values of 1000,1250,1500,2000,4000 allow better performance. This property corresponds to the CONFIG_MC_RETRY parameter in the protocol specification [7]. Note that the net.slp.DADiscoveryTimeouts property must be used for active DA discovery.",
      "ja": "マルチキャスト収束アルゴリズムを実装するために、ミリ秒単位でタイムアウトとして使用される32ビット整数の値リスト。各値は、次のリクエストを送信する前に待つ時間を指定します。デフォルトは次のとおりです。3000,3000,3000,3000,3000。高速ネットワークでは、1000,1250,1500,2000,4000の積極的な値により、パフォーマンスが向上します。このプロパティは、プロトコル仕様[7]のconfig_mc_retryパラメーターに対応しています。Net.slp.DadiscoveryTimeAutsプロパティは、アクティブなDA発見に使用する必要があることに注意してください。"
    },
    {
      "indent": 6,
      "text": "net.slp.DADiscoveryTimeouts",
      "ja": "net.slp.dadiscoverytimeAuts"
    },
    {
      "indent": 9,
      "text": "A value-list of 32 bit integers used as timeouts, in milliseconds, to implement the multicast convergence algorithm during active DA discovery. Each value specifies the time to wait before sending the next request, or until nothing new has been learned from two successive requests. This property corresponds to the protocol specification parameter CONFIG_RETRY [7]. Default is: 2000,2000,2000,2000,3000,4000.",
      "ja": "アクティブなDA発見中にマルチキャスト収束アルゴリズムを実装するために、ミリ秒単位でタイムアウトとして使用される32ビット整数の値リスト。各値は、次のリクエストを送信する前に待つ時間を指定します。このプロパティは、プロトコル仕様パラメーターconfig_retry [7]に対応しています。デフォルトは：2000,2000,2000,2000,3000,4000です。"
    },
    {
      "indent": 6,
      "text": "net.slp.datagramTimeouts",
      "ja": "net.slp.datagramtimeouts"
    },
    {
      "indent": 9,
      "text": "A value-list of 32 bit integers used as timeouts, in milliseconds, to implement unicast datagram transmission to DAs. The nth value gives the time to block waiting for a reply on the nth try to contact the DA. The sum of these values is the protocol specification property CONFIG_RETRY_MAX [7].",
      "ja": "Millisecondsでタイムアウトとして使用される32ビット整数の値リストは、DASにユニキャストデータグラム伝送を実装します。nth値は、DAに連絡しようとするnthの返信を待つのをブロックする時間を与えます。これらの値の合計は、プロトコル仕様Property config_retry_max [7]です。"
    },
    {
      "indent": 6,
      "text": "net.slp.randomWaitBound",
      "ja": "net.slp.randomwaitbound"
    },
    {
      "indent": 9,
      "text": "A 32 bit integer giving the maximum value for all random wait parameters, in milliseconds. Default is 1000 (1 sec.). This value corresponds to the protocol specification parameters CONFIG_START_WAIT, CONFIG_REG_PASSIVE, and CONFIG_REG_ACTIVE [7].",
      "ja": "ミリ秒単位で、すべてのランダム待機パラメーターの最大値を与える32ビット整数。デフォルトは1000（1秒）です。この値は、プロトコル仕様パラメーターconfig_start_wait、config_reg_passive、およびconfig_reg_active [7]に対応します。"
    },
    {
      "indent": 6,
      "text": "net.slp.MTU",
      "ja": "net.slp.mtu"
    },
    {
      "indent": 9,
      "text": "A 16 bit integer giving the network packet MTU, in bytes. This is the maximum size of any datagram to send, but the implementation might receive a larger datagram. The maximum size includes IP, and UDP or TCP headers. Default is 1400.",
      "ja": "ネットワークパケットMTUをバイトで与える16ビット整数。これは、送信するデータグラムの最大サイズですが、実装はより大きなデータグラムを受信する場合があります。最大サイズには、IP、UDPまたはTCPヘッダーが含まれます。デフォルトは1400です。"
    },
    {
      "indent": 6,
      "text": "net.slp.interfaces",
      "ja": "net.slp.interfaces"
    },
    {
      "indent": 9,
      "text": "Value-list of strings giving the IP addresses of network interfaces on which the DA or SA should listen on port 427 for multicast, unicast UDP, and TCP messages. Default is empty, i.e. use the default network interface. The grammar for this property is:",
      "ja": "DAまたはSAがマルチキャスト、ユニキャストUDP、およびTCPメッセージについてポート427でリッスンするネットワークインターフェイスのIPアドレスを与える文字列の値リスト。デフォルトは空です。つまり、デフォルトのネットワークインターフェイスを使用します。このプロパティの文法は次のとおりです。"
    },
    {
      "indent": 15,
      "text": "addr-list     =  hostnumber / hostnumber \",\" addr-list\nhostnumber    =  1*3DIGIT 3(\".\" 1*3DIGIT)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "An example is:",
      "ja": "例は次のとおりです。"
    },
    {
      "indent": 18,
      "text": "195.42.42.42,195.42.142.1,195.42.120.1",
      "ja": "195.42.42.42,195.42.142.1,195.42.120.1"
    },
    {
      "indent": 9,
      "text": "The example machine has three interfaces on which the DA should listen.",
      "ja": "サンプルマシンには、DAがリッスンする3つのインターフェイスがあります。"
    },
    {
      "indent": 9,
      "text": "Note that since this property only takes IP addresses, it will need to be changed if the network is renumbered.",
      "ja": "このプロパティはIPアドレスのみを使用するため、ネットワークを変更する場合は変更する必要があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "2.1.6. SA Configuration",
      "section_title": true,
      "ja": "2.1.6. SA構成"
    },
    {
      "indent": 3,
      "text": "This section contains configuration properties for the SA. These properties are typically set programmatically by the SA, since they are specific to each SA.",
      "ja": "このセクションには、SAの構成プロパティが含まれています。これらのプロパティは通常、各SAに固有のため、SAによってプログラムで設定されます。"
    },
    {
      "indent": 6,
      "text": "net.slp.SAAttributes",
      "ja": "net.slp.saattributes"
    },
    {
      "indent": 9,
      "text": "A comma-separated list of parenthesized attribute/value list pairs that the SA must advertise in SAAdverts. The property must be in the SLP attribute list wire format, including escapes for reserved characters. [7]",
      "ja": "SAがSaadvertsで宣伝しなければならない括弧付き属性/値リストのコンマ分離されたリスト。プロパティは、予約済みの文字の脱出を含む、SLP属性リストワイヤ形式でなければなりません。[7]"
    },
    {
      "indent": 0,
      "text": "2.1.7. UA Configuration",
      "section_title": true,
      "ja": "2.1.7. UA構成"
    },
    {
      "indent": 3,
      "text": "This section contains configuration properties for the UA. These properties can be set either programmatically by the UA or in the configuration file.",
      "ja": "このセクションには、UAの構成プロパティが含まれています。これらのプロパティは、UAによってプログラム的に設定されるか、構成ファイルで設定できます。"
    },
    {
      "indent": 6,
      "text": "net.slp.locale",
      "ja": "net.slp.locale"
    },
    {
      "indent": 9,
      "text": "A RFC 1766 Language Tag [6] for the language locale. Setting this property causes the property value to become the default locale for SLP messages. Default is \"en\". This property is also used for SA and DA configuration.",
      "ja": "言語ロケール用のRFC 1766言語タグ[6]。このプロパティを設定すると、プロパティ値がSLPメッセージのデフォルトロケールになります。デフォルトは「en」です。このプロパティは、SAおよびDA構成にも使用されます。"
    },
    {
      "indent": 6,
      "text": "net.slp.maxResults",
      "ja": "net.slp.maxresults"
    },
    {
      "indent": 9,
      "text": "A 32 bit integer giving the maximum number of results to accumulate and return for a synchronous request before the timeout, or the maximum number of results to return through a callback if the request results are reported asynchronously.",
      "ja": "32ビットの整数が、タイムアウト前に同期要求のために蓄積して結果の最大数を蓄積し、リクエスト結果が非同期に報告された場合にコールバックを介して戻る結果の最大数を返すことを示します。"
    },
    {
      "indent": 9,
      "text": "Positive integers and -1 are legal values. If -1, indicates that all results should be returned. Default value is -1.",
      "ja": "正の整数と-1は法的価値です。-1の場合、すべての結果を返す必要があることを示します。デフォルト値は-1です。"
    },
    {
      "indent": 9,
      "text": "DAs and SAs always return all results that match the request. This configuration value applies only to UAs, that filter incoming results and only return as many values as net.slp.maxResults indicates.",
      "ja": "DASとSASは、常にリクエストに一致するすべての結果を返します。この構成値はUASにのみ適用され、その結果をフィルタリングし、net.slp.maxresultsが示すほど多くの値を返すだけです。"
    },
    {
      "indent": 6,
      "text": "net.slp.typeHint",
      "ja": "net.slp.typehint"
    },
    {
      "indent": 9,
      "text": "A value-list of service type names. In the absence of any DAs, UAs perform SA discovery for finding scopes. These SA discovery requests may contain a request for service types as an attribute.",
      "ja": "サービスタイプ名の値リスト。DASがない場合、UASはスコープを見つけるためにSA発見を行います。これらのSA Discoveryリクエストには、属性としてサービスタイプのリクエストが含まれる場合があります。"
    },
    {
      "indent": 9,
      "text": "The API implementation will use the service type names supplied by this property to discover only those SAs (and their scopes) which support the desired service type or types. For example, if net.slp.typeHint is set to \"service:imap,service:pop3\" then SA discovery requests will include the search filter:",
      "ja": "API実装では、このプロパティが提供するサービスタイプ名を使用して、目的のサービスタイプまたはタイプをサポートするSA（およびそのスコープ）のみを発見します。たとえば、net.slp.typehintが「service：imap、service：pop3」に設定されている場合、SAディスカバリーリクエストには検索フィルターが含まれます。"
    },
    {
      "indent": 9,
      "text": "(|(service-type=service:imap)(service-type=service:pop3))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "The API library can also use unicast to contact the discovered SAs for subsequent requests for these service types, to optimize network access.",
      "ja": "APIライブラリは、ユニキャストを使用して、これらのサービスタイプのその後のリクエストのために発見されたSASに連絡して、ネットワークアクセスを最適化することもできます。"
    },
    {
      "indent": 0,
      "text": "2.1.8. Security",
      "section_title": true,
      "ja": "2.1.8. 安全"
    },
    {
      "indent": 3,
      "text": "The property in this section allows security for all agents to be set on or off. When the property is true, then the agent must include security information on all SLP messages transacted by that agent. Since security policy must be set network wide to be effective, a single property controls security for all agents. Key management and management of SLP SPI strings [7] are implementation and policy dependent.",
      "ja": "このセクションのプロパティにより、すべてのエージェントのセキュリティをオンまたはオフにすることができます。プロパティが当てはまる場合、エージェントはそのエージェントによって取引されたすべてのSLPメッセージにセキュリティ情報を含める必要があります。セキュリティポリシーは効果的にネットワークを大きく設定する必要があるため、単一のプロパティはすべてのエージェントのセキュリティを管理します。SLP SPI文字列の主要な管理と管理[7]は、実装とポリシーに依存しています。"
    },
    {
      "indent": 6,
      "text": "net.slp.securityEnabled",
      "ja": "net.slp.securityEnabled"
    },
    {
      "indent": 9,
      "text": "A boolean indicating whether the agent should enable security for URLs, attribute lists, DAAdverts, and SAAdverts. Each agent is responsible for interpreting the property appropriately. Default is false.",
      "ja": "エージェントがURL、属性リスト、daAdverts、およびsaAdvertのセキュリティを有効にする必要があるかどうかを示すブール。各エージェントは、プロパティを適切に解釈する責任があります。デフォルトはfalseです。"
    },
    {
      "indent": 0,
      "text": "2.2. Multihomed Machines",
      "section_title": true,
      "ja": "2.2. マルチホームマシン"
    },
    {
      "indent": 3,
      "text": "On multihomed machines, the bandwidth and latency characteristics on different network interfaces may differ considerably, to the point where different configuration properties are necessary to achieve optimal performance. The net.slp.interfaces property indicates which network interfaces are SLP enabled. An API library implementation may support configuration customization on a per network interface basis by allowing the interface IP address to be appended to the property name. In that case, the values of the property are only used for that particular interface, the generic property (or defaults if no generic property is set) applies to all others.",
      "ja": "マルチホームマシンでは、さまざまなネットワークインターフェイスの帯域幅と潜時特性は、最適なパフォーマンスを実現するために異なる構成プロパティが必要な点まで、かなり異なる場合があります。net.slp.interfacesプロパティは、どのネットワークインターフェイスがSLPを有効にしているかを示します。APIライブラリの実装は、インターフェイスIPアドレスをプロパティ名に追加できるようにすることにより、Network Interfaceごとに構成のカスタマイズをサポートできます。その場合、プロパティの値はその特定のインターフェイスにのみ使用され、一般的なプロパティ（または一般的なプロパティが設定されていない場合はデフォルト）が他のすべてに適用されます。"
    },
    {
      "indent": 3,
      "text": "For example, if a configuration has the following properties:",
      "ja": "たとえば、構成に次のプロパティがある場合："
    },
    {
      "indent": 6,
      "text": "net.slp.interfaces=125.196.42.41,125.196.42.42,125.196.42.43 net.slp.multicastTTL.125.196.42.42=1",
      "ja": "net.slp.interfaces = 125.196.42.41,125.196.42.42,125.196.42.43 net.slp.multicastttl.125.196.42.42 = 1"
    },
    {
      "indent": 3,
      "text": "then the network interface on subnet 42 is restricted to a TTL of 1, while the interfaces on the other subnets have the default multicast radius, 255.",
      "ja": "次に、サブネット42のネットワークインターフェイスは1のTTLに制限され、他のサブネットのインターフェイスにはデフォルトのマルチキャスト半径255があります。"
    },
    {
      "indent": 3,
      "text": "The net.slp.interfaces property must only be set if there is no routing between the interfaces. If the property is set, the DA (if any) and SAs should advertise with the IP address or host name appropriate to the interface on the interfaces in the list. If packets are routed between the interfaces, then the DA and SAs should only advertise on the default interface. The property should also be set if broadcast is used rather than multicast on the subnets connected to the interfaces. Note that even if unicast packets are not routed between the interfaces, multicast may be routed through another router. The danger in listening for multicast on multiple interfaces when multicast packets are routed is that the DA or SA may receive the same multicast request via more than one interface. Since the IP address is different on each interface, the DA or SA cannot identify the request as having already being answered via the previous responder's list. The requesting agent will end up getting URLs that refer to the same DA or service but have different addresses or host names.",
      "ja": "net.slp.interfacesプロパティは、インターフェイス間にルーティングがない場合にのみ設定する必要があります。プロパティが設定されている場合、DA（もしあれば）とSASは、リスト内のインターフェイス上のインターフェイスに適したIPアドレスまたはホスト名で宣伝する必要があります。パケットがインターフェイス間でルーティングされている場合、DAとSASはデフォルトのインターフェイスでのみ広告する必要があります。インターフェイスに接続されたサブネットのマルチキャストではなく、ブロードキャストを使用する場合は、プロパティも設定する必要があります。ユニキャストパケットがインターフェイス間でルーティングされていなくても、マルチキャストは別のルーターを介してルーティングされる場合があることに注意してください。マルチキャストパケットがルーティングされている場合の複数のインターフェイスでマルチキャストをリッスンする危険性は、DAまたはSAが複数のインターフェイスを介して同じマルチキャストリクエストを受信できることです。IPアドレスは各インターフェイスで異なるため、DAまたはSAは、以前のResponderのリストを介して既に回答されているとリクエストを特定できません。要求エージェントは、同じDAまたはサービスを参照しているが、異なるアドレスまたはホスト名を持つURLを取得することになります。"
    },
    {
      "indent": 0,
      "text": "2.3. Serialized Registration File",
      "section_title": true,
      "ja": "2.3. シリアル化された登録ファイル"
    },
    {
      "indent": 3,
      "text": "The serialized registration file contains a group of registrations that a DA or SA server (if one exists) registers when it starts up. These registrations are primarily for older service programs that do not internally support SLP and cannot be converted, and for portably exchanging registrations between SLP implementations. The character encoding of the registrations is required to be UTF-8.",
      "ja": "シリアル化された登録ファイルには、DAまたはSAサーバー（存在する場合）が起動時に登録される登録グループが含まれています。これらの登録は、主にSLPを内部的にサポートしておらず、変換できない古いサービスプログラムと、SLP実装間の登録を携帯的に交換するためです。登録の文字エンコードは、UTF-8である必要があります。"
    },
    {
      "indent": 3,
      "text": "The syntax of the serialized registration file, in ABNF format [5], is as follows:",
      "ja": "ABNF形式[5]のシリアル化登録ファイルの構文は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "ser-file      =  reg-list\nreg-list      =  reg / reg reg-list\nreg           =  creg / ser-reg\ncreg          =  comment-line ser-reg\ncomment-line  =  ( \"#\" / \";\" ) 1*allchar newline\nser-reg       =  url-props [slist] [attr-list] newline\nurl-props     =  surl \",\" lang \",\" ltime [ \",\" type ] newline\nsurl          =  ;The registration's URL. See\n                 ; [8] for syntax.\nlang          =  1*8ALPHA [ \"-\" 1*8ALPHA ]\n                 ;RFC 1766 Language Tag see [6].\nltime         =  1*5DIGIT\n                 ; A positive 16-bit integer\n                 ; giving the lifetime\n                 ; of the registration.\ntype          =  ; The service type name, see [7]\n                 ; and [8] for syntax.\nslist         =  \"scopes\" \"=\" scope-list newline\nscope-list    =  scope-name / scope-name \",\" scope-list\nscope         =  ; See grammar of [7] for\n                 ; scope-name syntax.\nattr-list     =  attr-def / attr-def attr-list\nattr-def      =  ( attr / keyword ) newline\nkeyword       =  attr-id\nattr          =  attr-id \"=\" attr-val-list\nattr-id       =  ;Attribute id, see [7] for syntax.\nattr-val-list =  attr-val / attr-val \",\" attr-val-list\nattr-val      =  ;Attribute value, see [7] for syntax.\nallchar       =  char / WSP\nchar          =  DIGIT / ALPHA / other\nother         =  %x21-%x2f / %x3a-%x40 /\n                 %x5b-%x60 / %7b-%7e\n                 ; All printable, nonwhitespace US-ASCII\n                 ; characters.\nnewline       =  CR / ( CRLF )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The syntax for scope names, attribute tags, and attribute values requires escapes for special characters as specified in [7]. DAs and SA servers that process serialized registrations must handle them exactly as if they were registered by an SA. In the url-props production, the type token is optional. If the type token is present for a service: URL, a warning is signaled and the type name is ignored. If the maximum lifetime is specified (65535 sec.), the registration is taken to be permanent, and is continually refreshed by the DA or SA server until it exits. Scopes can be included in a registration by including an attribute definition with tag \"scopes\" followed by a comma separated list of scope names immediately after the url-props production. If the optional scope list is present, the registrations are made in the indicated scopes; otherwise, they are registered in the scopes with which the DA or SA server was configured through the net.slp.useScopes property.",
      "ja": "[7]で指定されているように、スコープ名、属性タグ、および属性値の構文には、特殊文字のエスケープが必要です。シリアル化された登録を処理するDASおよびSAサーバーは、SAによって登録されているかのように正確に処理する必要があります。URLプロップの生産では、タイプトークンはオプションです。タイプトークンがサービスに存在する場合：URL、警告が信号が表示され、タイプ名は無視されます。最大寿命が指定されている場合（65535秒）、登録は永続的であると見なされ、DAまたはSAサーバーが終了するまで継続的に更新されます。Scopesは、URL-Propsの生産直後にタグ「Scopes」に属性定義を「スコープ」に分離したスコープ名のリストを分離することにより、登録に含めることができます。オプションのスコープリストが存在する場合、登録は示されたスコープで行われます。それ以外の場合は、DAまたはSAサーバーがnet.slp.usescopesプロパティを介して構成されているスコープに登録されています。"
    },
    {
      "indent": 3,
      "text": "If the scope list contains scopes that are not in the net.slp.useScopes property (provided that property is set) or are not specified by DHCP, the API library should reject the registration and issue a warning message.",
      "ja": "スコープリストにnet.slp.usescopesプロパティにないスコープ（プロパティが設定されている場合）が含まれている場合、またはDHCPによって指定されていない場合、APIライブラリは登録を拒否し、警告メッセージを発行する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.4. Processing Serialized Registration and Configuration Files",
      "section_title": true,
      "ja": "2.4. シリアル化された登録および構成ファイルの処理"
    },
    {
      "indent": 3,
      "text": "Implementations are encouraged to make processing of configuration and serialized files as transparent as possible to clients of the API. At the latest, errors must be caught when the relevant configuration item is used. At the earliest, errors may be caught when the relevant file is loaded into the executing agent. Errors should be reported by logging to the appropriate platform logging file, error output, or log device, and the default value substituted. Serialized registration file entries should be caught and reported when the file is loaded.",
      "ja": "実装は、APIのクライアントに可能な限り透過的に構成とシリアル化されたファイルの処理を行うように推奨されます。最新の状態では、関連する構成アイテムが使用されるときにエラーをキャッチする必要があります。最も早い時期には、関連するファイルが実行エージェントにロードされると、エラーがキャッチされる場合があります。エラーは、適切なプラットフォームログファイル、エラー出力、またはログデバイス、およびデフォルトの値に置き換えられたデフォルト値にログすることにより、報告する必要があります。シリアル化された登録ファイルエントリは、ファイルがロードされたときにキャッチして報告する必要があります。"
    },
    {
      "indent": 3,
      "text": "Configuration file loading must be complete prior to the initiation of the first networking connection. Serialized registration must be complete before the DA accepts the first network request.",
      "ja": "構成ファイルの読み込みは、最初のネットワーク接続の開始前に完了する必要があります。DAが最初のネットワークリクエストを受け入れる前に、シリアル化された登録は完了する必要があります。"
    },
    {
      "indent": 0,
      "text": "3. Binding Independent Implementation Considerations",
      "section_title": true,
      "ja": "3. 独立した実装の考慮事項を拘束します"
    },
    {
      "indent": 3,
      "text": "This section discusses a number of implementation considerations independent of language binding, with language specific notes where applicable.",
      "ja": "このセクションでは、言語拘束に依存しない多くの実装に関する考慮事項について説明し、言語固有のメモが該当する場合は説明します。"
    },
    {
      "indent": 0,
      "text": "3.1. Multithreading",
      "section_title": true,
      "ja": "3.1. マルチスレッド"
    },
    {
      "indent": 3,
      "text": "Implementations of both the C and Java APIs are required to make API calls thread-safe. Access to data structures shared between threads must be co-ordinated to avoid corruption or invalid access. One way to achieve this goal is to allow only one thread at a time in the implementing library. Performance in such an implementation suffers, however. Therefore, where possible, implementations are encouraged to allow multiple threads within the SLP API library.",
      "ja": "CとJava APIの両方の実装は、API呼び出しをスレッドセーフにするために必要です。スレッド間で共有されるデータ構造へのアクセスは、腐敗や無効なアクセスを避けるために調整する必要があります。この目標を達成する1つの方法は、実装ライブラリで一度に1つのスレッドのみを許可することです。ただし、このような実装のパフォーマンスは低下します。したがって、可能であれば、SLP APIライブラリ内の複数のスレッドを許可するように実装が推奨されます。"
    },
    {
      "indent": 0,
      "text": "3.2. Asynchronous and Incremental",
      "section_title": true,
      "ja": "3.2. 非同期および増分"
    },
    {
      "indent": 3,
      "text": "The APIs are designed to encourage implementations supporting asynchronous and incremental client interaction. The goal is to allow large numbers of returned service URLs, service types, and attributes without requiring the allocation of huge chunks of memory. The particular design features to support this goal differ in the two language bindings.",
      "ja": "APIは、非同期および漸進的なクライアントの相互作用をサポートする実装を促進するように設計されています。目標は、メモリの巨大なチャンクの割り当てを必要とせずに、多数の返品されたサービスURL、サービスタイプ、および属性を許可することです。この目標をサポートする特定のデザイン機能は、2つの言語バインディングで異なります。"
    },
    {
      "indent": 0,
      "text": "3.3. Type Checking for Service Types",
      "section_title": true,
      "ja": "3.3. サービスタイプのタイプチェック"
    },
    {
      "indent": 3,
      "text": "Service templates [8] allow SLP registrations to be type checked for correctness. Implementations of the API are free to make use of service type information for type checking, but are not required to do so. If a type error occurs, the registration should terminate with TYPE_ERROR.",
      "ja": "サービステンプレート[8]により、SLP登録をタイプチェックしてください。APIの実装は、タイプチェックのためにサービスタイプ情報を自由に使用できますが、そうする必要はありません。タイプエラーが発生した場合、登録はtype_errorで終了する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.4. Refreshing Registrations",
      "section_title": true,
      "ja": "3.4. リフレッシュ登録"
    },
    {
      "indent": 3,
      "text": "SLP advertisements carry an explicit lifetime with them. After the lifetime expires, the DA flushes the registration from its cache. In some cases, an application may want to have the URL continue being registered for the entire time during which the application is executing. The API includes provision for clients to indicate whether they want URLs to be automatically refreshed. Implementations of the SA API must provide this automatic refreshing capability. Note that a client which uses this facility should explicitly deregister the service URL before exiting, since the API implementation may not be able to assure that the URL is deregistered when the application exits, although it will time out in the DA eventually.",
      "ja": "SLP広告には、明示的な生涯があります。寿命が切れた後、DAはキャッシュから登録を洗い流します。場合によっては、アプリケーションがアプリケーションが実行されている間ずっとURLを登録し続けることをお勧めします。APIには、クライアントがURLを自動的に更新したいかどうかを示すための提供が含まれています。SA APIの実装では、この自動リフレッシュ機能を提供する必要があります。APIの実装は、アプリケーションが終了するとURLが登録されていることを保証できないため、この施設を使用するクライアントは、終了する前にサービスURLを明示的に登録する必要があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.5. Configuration File Processing",
      "section_title": true,
      "ja": "3.5. 構成ファイル処理"
    },
    {
      "indent": 3,
      "text": "DAs, SAs and UAs processing the configuration file, and DAs and SA servers processing the serialized registration file are required to log any errors using whatever underlying error mechanism is appropriate for the platform. Examples include writing error messages to the standard output, writing to a system logging device, or displaying the errors to a logging window. After the error is reported, the offending property must be set to the default and program execution continued. An agent MUST NOT fail if a file format error occurs.",
      "ja": "DAS、SAS、およびUAS構成ファイルを処理し、DASおよびSAサーバーの処理シリアル化登録ファイルを処理する必要があります。プラットフォームに適した基礎となるエラーメカニズムを使用してエラーを記録する必要があります。例には、標準の出力へのエラーメッセージの書き込み、システムロギングデバイスへの書き込み、ロギングウィンドウへのエラーの表示が含まれます。エラーが報告された後、問題のプロパティをデフォルトに設定し、プログラムの実行を継続する必要があります。ファイル形式のエラーが発生した場合、エージェントは失敗してはなりません。"
    },
    {
      "indent": 0,
      "text": "3.6. Attribute Types",
      "section_title": true,
      "ja": "3.6. 属性タイプ"
    },
    {
      "indent": 3,
      "text": "String encoded attribute values do not include explicit type information. All UA implementations and those SA and DA implementations that choose to support type checking should use the type rules described in [8] in order to convert from the string representation on the wire to an object typed appropriately.",
      "ja": "文字列エンコードされた属性値には、明示的なタイプ情報は含まれません。すべてのUA実装およびタイプチェックをサポートすることを選択するSAおよびDAの実装は、[8]で説明されているタイプルールを使用して、ワイヤーの文字列表現から適切に入力されたオブジェクトに変換する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.7. Removal of Duplicates",
      "section_title": true,
      "ja": "3.7. 重複の除去"
    },
    {
      "indent": 3,
      "text": "The UA implementation SHOULD always collate results to remove duplicates during synchronous operations and for the Java API. During asynchronous operation in C, the UA implementation SHOULD forgo duplicate elimination to reduce memory requirements in the library. This allows the API library to simply take the returned attribute value list strings, URL strings, or service type list strings and call the callback function with it, without any additional processing. Naturally, the burden of duplicate elimination is thrown onto the client in this case.",
      "ja": "UA実装は、同期操作およびJava APIの重複を削除するために、常に結果を照合する必要があります。Cでの非同期操作中、UAの実装は、ライブラリのメモリ要件を削減するために重複する排除を控える必要があります。これにより、APIライブラリは、返された属性値リスト文字列、URL文字列、またはサービスタイプリスト文字列を単純に処理し、追加の処理なしにコールバック関数を呼び出すことができます。当然のことながら、この場合、重複する排除の負担がクライアントに投げ込まれます。"
    },
    {
      "indent": 0,
      "text": "3.8. Character Set Encoding",
      "section_title": true,
      "ja": "3.8. 文字セットエンコーディング"
    },
    {
      "indent": 3,
      "text": "Character string parameters in the Java API are all represented in Unicode internally because that is the Java-supported character set. Characters buffer parameters in the C API are represented in UTF-8 to maintain maximum compatibility on platforms that only support US-ASCII and not UTF-8. API functions are still required to handle the full range of UTF-8 characters because the SLP protocol requires it, but the API implementation can represent the characters internally in any convenient way. On the wire, all characters are converted to UTF-8. Inside URLs, characters that are not allowed by URL syntax [2] must be escaped according to the URL escape character convention. Strings that are included in SLP messages may include SLP reserved characters and can be escaped by clients through convenience functions provided by the API. The character encoding used in escapes is UTF-8.",
      "ja": "Java APIの文字文字列パラメーターはすべて、Javaがサポートする文字セットであるため、すべてUnicodeで内部的に表されます。C APIの文字バッファーパラメーターは、UTF-8で表され、UTF-8ではなくUS-ASCIIのみをサポートするプラットフォームで最大の互換性を維持します。SLPプロトコルには必要なため、API関数はUTF-8文字の全範囲を処理するために必要ですが、API実装は、あらゆる便利な方法で内部的に文字を表すことができます。ワイヤー上では、すべての文字がUTF-8に変換されます。URL内では、URL構文[2]で許可されていない文字は、URLエスケープ文字条約に従って逃げる必要があります。SLPメッセージに含まれる文字列には、SLP予約文字が含まれ、APIが提供する利便性関数を介してクライアントが逃れることができます。エスケープで使用されるキャラクターエンコーディングはUTF-8です。"
    },
    {
      "indent": 3,
      "text": "Due to constraints in SLP, no string parameter passed to the C or Java API may exceed 64K bytes in length.",
      "ja": "SLPの制約により、CまたはJava APIに渡される文字列パラメーターは、長さ64Kバイトを超えることはありません。"
    },
    {
      "indent": 0,
      "text": "3.9. Error Semantics",
      "section_title": true,
      "ja": "3.9. エラーセマンティクス"
    },
    {
      "indent": 3,
      "text": "All errors encountered processing SLP messages should be logged. For synchronous calls, an error is only reported on a call if no successful replies were received from any SLP framework entity. If an error occurred among one of several successful replies, then the error should be logged and the successful replies returned. For asynchronous calls, an error occurring during correspondence with a particular remote SLP agent is reported through the first callback (in the C API) or enumeration method invocation (in the Java API) after the error occurs, which would normally report the results of the correspondence. This allows the callback or client code to determine whether the operation should be terminated or continue. In some cases, the error returned from the SLP framework may be fatal (SLP_PARSE_ERROR, etc.). In these cases, the API library terminates the operation.",
      "ja": "SLPメッセージの処理に遭遇したすべてのエラーが記録する必要があります。同期呼び出しの場合、SLPフレームワークエンティティから成功した返信が受信されなかった場合にのみ、コールでエラーが報告されます。いくつかの成功した返信の1つでエラーが発生した場合、エラーを記録し、成功した返信を返します。非同期呼び出しの場合、特定のリモートSLPエージェントとの対応中に発生するエラーが、エラーが発生した後に最初のコールバック（C API）または列挙メソッドの呼び出し（Java API）を介して報告されます。対応。これにより、コールバックまたはクライアントコードが操作を終了するか継続するかを判断することができます。場合によっては、SLPフレームワークから返されたエラーが致命的である可能性があります（SLP_PARSE_ERRORなど）。これらの場合、APIライブラリは操作を終了します。"
    },
    {
      "indent": 3,
      "text": "Both the Java and C APIs contain language specific error code mechanisms for returning error information. The names of the error codes are consistent between the two implementations, however.",
      "ja": "JavaとC APIの両方に、エラー情報を返すための言語固有のエラーコードメカニズムが含まれています。ただし、エラーコードの名前は2つの実装間で一貫しています。"
    },
    {
      "indent": 3,
      "text": "The following error codes are returned from a remote agent (DA or SA server):",
      "ja": "次のエラーコードは、リモートエージェント（DAまたはSAサーバー）から返されます。"
    },
    {
      "indent": 6,
      "text": "LANGUAGE_NOT_SUPPORTED",
      "ja": "Language_not_supported"
    },
    {
      "indent": 9,
      "text": "No DA or SA has service advertisement or attribute information in the language requested, but at least one DA or SA indicated, via the LANGUAGE_NOT_SUPPORTED error code, that it might have information for that service in another language.",
      "ja": "DAやSAには、要求された言語にサービス広告または属性情報がありませんが、少なくとも1つのDAまたはSAは、言語_NOT_SUPPORTEDエラーコードを介して、そのサービスの情報が別の言語である可能性があることを示しています。"
    },
    {
      "indent": 6,
      "text": "PARSE_ERROR",
      "ja": "パースエラー"
    },
    {
      "indent": 9,
      "text": "The SLP message was rejected by a remote SLP agent. The API returns this error only when no information was retrieved, and at least one SA or DA indicated a protocol error. The data supplied through the API may be malformed or a may have been damaged in transit.",
      "ja": "SLPメッセージは、リモートSLPエージェントによって拒否されました。APIは、情報が取得されなかった場合にのみこのエラーを返し、少なくとも1つのSAまたはDAがプロトコルエラーを示しました。APIを介して提供されるデータは、輸送中に奇形で損傷している可能性があります。"
    },
    {
      "indent": 6,
      "text": "INVALID_REGISTRATION",
      "ja": "Invalid_registration"
    },
    {
      "indent": 9,
      "text": "The API may return this error if an attempt to register a service was rejected by all DAs because of a malformed URL or attributes. SLP does not return the error if at least one DA accepted the registration.",
      "ja": "不正なURLまたは属性のために、サービスを登録しようとする試みがすべてのDASによって拒否された場合、APIはこのエラーを返す場合があります。少なくとも1つのDAが登録を受け入れた場合、SLPはエラーを返しません。"
    },
    {
      "indent": 6,
      "text": "AUTHENTICATION_ABSENT",
      "ja": "Authentication_absent"
    },
    {
      "indent": 9,
      "text": "If the SLP framework supports authentication, this error arises when the UA or SA failed to send an authenticator for requests or registrations in a protected scope.",
      "ja": "SLPフレームワークが認証をサポートしている場合、このエラーは、UAまたはSAが保護されたスコープでリクエストまたは登録の認証者を送信できなかったときに発生します。"
    },
    {
      "indent": 6,
      "text": "INVALID_UPDATE",
      "ja": "Invalid_update"
    },
    {
      "indent": 9,
      "text": "An update for a non-existing registration was issued, or the update includes a service type or scope different than that in the initial registration, etc.",
      "ja": "存在しない登録のアップデートが発行されたか、更新には、最初の登録などとは異なるサービスタイプまたは範囲が含まれています。"
    },
    {
      "indent": 3,
      "text": "The following errors result from interactions with remote agents or can occur locally:",
      "ja": "次のエラーは、リモートエージェントとの相互作用から生じます。または、ローカルで発生する可能性があります。"
    },
    {
      "indent": 6,
      "text": "AUTHENTICATION_FAILED",
      "ja": "認証に失敗しました"
    },
    {
      "indent": 9,
      "text": "If the SLP framework supports authentication, this error arises when a authentication on an SLP message failed.",
      "ja": "SLPフレームワークが認証をサポートしている場合、このエラーはSLPメッセージの認証が失敗したときに発生します。"
    },
    {
      "indent": 6,
      "text": "SCOPE_NOT_SUPPORTED",
      "ja": "scope_not_supported"
    },
    {
      "indent": 9,
      "text": "The API returns this error if the SA has been configured with net.slp.useScopes value-list of scopes and the SA request did not specify one or more of these allowable scopes, and no others. It may be returned by a DA or SA if the scope included in a request is not supported by the DA or SA.",
      "ja": "saがnet.slp.usescopesスコープの値リストで構成されている場合、APIはこのエラーを返し、SAリクエストはこれらの許容スコープの1つ以上を指定せず、その他も指定しませんでした。リクエストに含まれるスコープがDAまたはSAによってサポートされていない場合、DAまたはSAによって返される場合があります。"
    },
    {
      "indent": 6,
      "text": "REFRESH_REJECTED",
      "ja": "refresh_rejed"
    },
    {
      "indent": 9,
      "text": "The SA attempted to refresh a registration more frequently than the minimum refresh interval. The SA should call the appropriate API function to obtain the minimum refresh interval to use.",
      "ja": "SAは、最小更新間隔よりも頻繁に登録を更新しようとしました。SAは、適切なAPI関数を呼び出して、使用する最小更新間隔を取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "The following errors are generated through a program interacting with the API implementation. They do not involve a remote SLP agent.",
      "ja": "次のエラーは、API実装と相互作用するプログラムを通じて生成されます。リモートSLPエージェントは関与しません。"
    },
    {
      "indent": 6,
      "text": "NOT_IMPLEMENTED",
      "ja": "not_implemented"
    },
    {
      "indent": 9,
      "text": "If an unimplemented feature is used, this error is returned.",
      "ja": "実装されていない機能を使用すると、このエラーが返されます。"
    },
    {
      "indent": 6,
      "text": "NETWORK_INIT_FAILED",
      "ja": "network_init_failed"
    },
    {
      "indent": 9,
      "text": "If the network cannot initialize properly, this error is returned.",
      "ja": "ネットワークが適切に初期化できない場合、このエラーが返されます。"
    },
    {
      "indent": 6,
      "text": "NETWORK_TIMED_OUT",
      "ja": "network_timed_out"
    },
    {
      "indent": 9,
      "text": "When no reply can be obtained in the time specified by the configured timeout interval for a unicast request, this error is returned.",
      "ja": "ユニキャスト要求のために構成されたタイムアウト間隔で指定された時間に返信がない場合、このエラーは返されます。"
    },
    {
      "indent": 6,
      "text": "NETWORK_ERROR",
      "ja": "ネットワークエラー"
    },
    {
      "indent": 9,
      "text": "The failure of networking during normal operations causes this error to be returned.",
      "ja": "通常の操作中のネットワーキングの障害により、このエラーが返されます。"
    },
    {
      "indent": 6,
      "text": "BUFFER_OVERFLOW",
      "ja": "buffer_overflow"
    },
    {
      "indent": 9,
      "text": "An outgoing request overflowed the maximum network MTU size. The request should be reduced in size or broken into pieces and tried again.",
      "ja": "発信要求により、最大ネットワークMTUサイズがオーバーフローされました。リクエストのサイズが削減されるか、バラバラに分割され、再試行される必要があります。"
    },
    {
      "indent": 6,
      "text": "MEMORY_ALLOC_FAILED",
      "ja": "memory_alloc_failed"
    },
    {
      "indent": 9,
      "text": "If the API fails to allocate memory, the operation is aborted and returns this.",
      "ja": "APIがメモリの割り当てに失敗した場合、操作は中止され、これを返します。"
    },
    {
      "indent": 6,
      "text": "PARAMETER_BAD",
      "ja": "parameter_bad"
    },
    {
      "indent": 9,
      "text": "If a parameter passed into an interface is bad, this error is returned.",
      "ja": "インターフェイスに渡されたパラメーターが悪い場合、このエラーは返されます。"
    },
    {
      "indent": 6,
      "text": "INTERNAL_SYSTEM_ERROR",
      "ja": "internal_system_error"
    },
    {
      "indent": 9,
      "text": "A basic failure of the API causes this error to be returned. This occurs when a system call or library fails. The operation could not recover.",
      "ja": "APIの基本的な障害により、このエラーが返されます。これは、システムコールまたはライブラリが失敗したときに発生します。操作は回復できませんでした。"
    },
    {
      "indent": 6,
      "text": "HANDLE_IN_USE",
      "ja": "handle_in_use"
    },
    {
      "indent": 9,
      "text": "In the C API, callback functions are not permitted to recursively call into the API on the same SLPHandle, either directly or indirectly. If an attempt is made to do so, this error is returned from the called API function.",
      "ja": "C APIでは、コールバック関数は、直接的または間接的に同じSlphandleでAPIを再帰的に呼び出すことは許可されていません。そうする試みが行われた場合、このエラーは呼び出されたAPI関数から返されます。"
    },
    {
      "indent": 6,
      "text": "TYPE_ERROR",
      "ja": "Type_Error"
    },
    {
      "indent": 9,
      "text": "If the API supports type checking of registrations against service type templates, this error can arise if the attributes in a registration do not match the service type template for the service.",
      "ja": "APIがサービスタイプテンプレートに対する登録のタイプチェックをサポートする場合、登録内の属性がサービスのサービスタイプテンプレートと一致しない場合、このエラーが発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Some error codes are handled differently in the Java API. These differences are discussed in Section 5.",
      "ja": "一部のエラーコードは、Java APIで異なる方法で処理されます。これらの違いについては、セクション5で説明します。"
    },
    {
      "indent": 3,
      "text": "The SLP protocol errors OPTION_NOT_UNDERSTOOD, VERSION_NOT_SUPPORTED, INTERNAL_ERROR, MSG_NOT_SUPPORTED, AUTHENTICATON_UNKNOWN, and DA_BUSY_NOW should be handled internally and not surfaced to clients through the API.",
      "ja": "SLPプロトコルエラーoption_not_understood、version_not_supported、internal_error、msg_not_supported、authenticaton_unknown、およびda_busy_nowは内部で処理する必要があり、APIを介してクライアントに表面化するものではありません。"
    },
    {
      "indent": 0,
      "text": "3.10. Modular Implementations",
      "section_title": true,
      "ja": "3.10. モジュラー実装"
    },
    {
      "indent": 3,
      "text": "Subset implementations that do not support the full range of functionality are required to nevertheless support every interface in order to maintain link compatibility between compliant API implementations and applications. If a particular operation is not supported, a NOT_IMPLEMENTED error should be returned. The Java API has some additional conventions for handling subsets. Applications that are expected to run on a wide variety of platforms should be prepared for subset API implementations by checking returned error codes.",
      "ja": "それにもかかわらず、完全な範囲の機能をサポートしていないサブセットの実装は、準拠したAPI実装とアプリケーション間のリンク互換性を維持するために、すべてのインターフェイスをサポートするために必要です。特定の操作がサポートされていない場合、not_implementedエラーを返す必要があります。Java APIには、サブセットを処理するための追加の規則があります。さまざまなプラットフォームで実行されると予想されるアプリケーションは、返されたエラーコードをチェックすることにより、サブセットAPI実装のために準備する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.11. Handling Special Service Types",
      "section_title": true,
      "ja": "3.11. 特別なサービスタイプの処理"
    },
    {
      "indent": 3,
      "text": "The service types service:directory-agent and service:service-agent are used internally in the SLP framework to discover DAs and SAs. The mechanism of DA and SA discovery is not normally exposed to the API client; however, the client may have interest in discovering DAs and SAs independently of their role in discovering other services. For example, a network management application may want to determine which machines are running SLP DAs. To facilitate that, API implementations must handle requests to find services and attributes for these two service types so that API clients obtain the information they expect.",
      "ja": "サービスタイプサービス：ディレクトリエージェントとサービス：Service-Agentは、SLPフレームワークでDASとSASを発見するために内部的に使用されます。DAおよびSA発見のメカニズムは、通常APIクライアントにさらされていません。ただし、クライアントは、他のサービスを発見する上での役割とは無関係に、DASとSASを発見することに関心がある場合があります。たとえば、ネットワーク管理アプリケーションは、どのマシンがSLP DASを実行しているかを決定することをお勧めします。それを容易にするために、APIの実装は、APIクライアントが予想される情報を取得できるように、これら2つのサービスタイプのサービスと属性を見つけるリクエストを処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "In particular, if the UA is using a DA, SrvRqst and AttrRqst for these service types must be multicast and not unicast to the DA, as is the case for other service types. If the requests are not multicast, the DA will respond with an empty reply to a request for services of type service:service-agent and with its URL only to a request for services of type service:directory-agent. The UA would therefore not obtain a complete picture of the available DAs and SAs.",
      "ja": "特に、UAがDAを使用している場合、これらのサービスタイプにSRVRQSTとATTRRQSTは、他のサービスタイプの場合のように、DAのユニカストではなくマルチキャストでなければなりません。リクエストがマルチキャストでない場合、DAはタイプサービスのサービスのリクエストに対する空の返信で応答します：Service-AgentおよびそのURLは、Services of Servicesのリクエストに対するみです：Directory-Agent。したがって、UAは利用可能なDASとSASの完全な画像を取得しません。"
    },
    {
      "indent": 0,
      "text": "3.12. Scope Discovery and Handling",
      "section_title": true,
      "ja": "3.12. スコープの発見と取り扱い"
    },
    {
      "indent": 3,
      "text": "Both APIs contain an operation to obtain a list of currently known scope names. This scope information comes from a variety of places: DHCP, the net.slp.useScopes property, unicast to DAs configured via DHCP or the net.slp.DAAddresses property, and active and passive discovery.",
      "ja": "両方のAPIには、現在既知のスコープ名のリストを取得する操作が含まれています。このスコープ情報は、DHCP、net.slp.usescopesプロパティ、dhcpまたはnet.slp.daaddressesプロパティを介して構成されたDASのユニキャスト、およびアクティブおよびパッシブ発見のさまざまな場所からのものです。"
    },
    {
      "indent": 3,
      "text": "The API is required to be implemented in a way that re-enforces the administrative and user scoping models described in [7]. SA clients only support the administrative scoping model. SAs must know a priori what DAs they need to register with since there is typically no human intervention in scope selection for SAs. UAs must support both administrative and user scoping because an application may require human intervention in scope selection.",
      "ja": "APIは、[7]で説明されている管理モデルとユーザースコーピングモデルを再強化するように実装する必要があります。SAクライアントは、管理スコーピングモデルのみをサポートしています。SASは、SASの範囲選択に通常人間の介入がないため、DASが登録する必要があるDASを先験的に知る必要があります。UASは、アプリケーションにはスコープ選択に人間の介入が必要になる可能性があるため、管理とユーザーの両方のスコーピングをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "API implementations are required to support administrative scoping in the following way. Scopes configured by DHCP and scopes of DAs configured by DHCP have first priority (in that order) and must be returned if they are available. The net.slp.useScopes property has second priority, and scopes discovered through the net.slp.useScopes property must be returned if this property is set and there are no scopes available from DHCP. If scopes are not available from either of these sources and the net.slp.DAAddresses property is set, then the scopes available from the configured DAs must be returned. Note that if both DAs and scopes are configured, the scopes of the configured DAs must match the configured scope list; otherwise and error is signaled and agent execution is terminated. If no configured scope information is available, then an SA client has default scope, \"DEFAULT\", and a UA client employs user scoping.",
      "ja": "APIの実装は、次の方法で管理スコーピングをサポートするために必要です。DHCPで構成されたスコープとDHCPで構成されたDASのスコープは（その順序で）最優先され、利用可能な場合は返される必要があります。net.slp.usescopesプロパティには2番目の優先度があり、net.slp.usescopesプロパティを介して発見されたスコープは、このプロパティが設定されていて、DHCPから利用可能なスコープがない場合は返品する必要があります。これらのソースとnet.slp.daaddressesプロパティのいずれかからスコープが利用できない場合、構成されたDASから使用可能なスコープを返す必要があります。DASとスコープの両方が構成されている場合、構成されたDASのスコープは構成されたスコープリストと一致する必要があることに注意してください。それ以外の場合は、エラーが通知され、エージェントの実行が終了します。構成されたスコープ情報が利用できない場合、SAクライアントにはデフォルトのスコープ「デフォルト」があり、UAクライアントはユーザースコーピングを採用します。"
    },
    {
      "indent": 3,
      "text": "User scoping is supported in the following way. Scopes discovered from active DA discovery, and from passive DA discovery all must be returned. If no information is available from active and passive DA discovery, then the API library may perform SA discovery, using the service types in the net.slp.typeHint property to limit the search to SAs supporting particular service types. If no net.slp.typeHint property is set, the UA may perform SA discovery without any service type query. In the absence of any of the above sources of information, the API must return the default scope, \"DEFAULT\". Note that the API must always return some scope information.",
      "ja": "ユーザーのスコープは、次の方法でサポートされています。アクティブなDA発見から発見されたスコープ、およびパッシブDA発見からすべてを返す必要があります。ActiveおよびPassive DAの発見から情報がない場合、APIライブラリはSA発見を実行し、net.slp.typehintプロパティのサービスタイプを使用して、特定のサービスタイプをサポートするSASに検索を制限します。net.slp.typehintプロパティが設定されていない場合、UAはサービスタイプのクエリなしでSAディスカバリーを実行する場合があります。上記の情報源のいずれかがない場合、APIはデフォルトのスコープ「デフォルト」を返す必要があります。APIは常にいくつかのスコープ情報を返す必要があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "SLP requires that SAs must perform their operations in all scopes currently known to them. [7]. The API enforces this constraint by not requiring the API client to supply any scopes as parameters to API operations. The API library must obtain all currently known scopes and use them in SA operations. UA API clients should use a scope obtained through one of the API operations for finding scopes. Any other scope name may result in a SCOPE_NOT_SUPPORTED error from a remote agent. The UA API library can optionally check the scope and return the error without contacting a remote agent.",
      "ja": "SLPでは、SASが現在知られているすべてのスコープで操作を実行する必要があります。[7]。APIは、APIクライアントがAPI操作にパラメーターとしてスコープを提供する必要がないことにより、この制約を強制します。APIライブラリは、現在既知のすべてのスコープを取得し、SA操作で使用する必要があります。UA APIクライアントは、スコープを見つけるためにAPI操作のいずれかを介して取得したスコープを使用する必要があります。他のスコープ名は、リモートエージェントからscope_not_supportedエラーになる場合があります。UA APIライブラリは、オプションでスコープを確認し、リモートエージェントに連絡せずにエラーを返すことができます。"
    },
    {
      "indent": 0,
      "text": "4. C Language Binding",
      "section_title": true,
      "ja": "4. C言語バインディング"
    },
    {
      "indent": 3,
      "text": "The C language binding presents a minimal overhead implementation that maps directly into the protocol. There is one C language function per protocol request, with the exception of the SLPDereg() and SLPDelAttrs() functions, which map into different uses of the SLP deregister request. Parameters are for the most part character buffers. Memory management is kept simple by having the client allocate most memory and requiring that client callback functions copy incoming parameters into memory allocated by the client code. Any memory returned directly from the API functions is deallocated using the SLPFree() function.",
      "ja": "C言語結合は、プロトコルに直接マップする最小限のオーバーヘッド実装を示します。SLPDEREG（）およびSLPDELATTRS（）関数を除き、プロトコル要求ごとに1つのC言語関数があり、SLP DereGisterリクエストの異なる使用にマッピングされます。パラメーターは、ほとんどの部分の文字バッファーです。メモリ管理は、クライアントにほとんどのメモリを割り当て、クライアントのコールバック関数をクライアントコードによって割り当てられたメモリにコピーすることを要求することにより、シンプルに保たれます。API関数から直接返されるメモリは、SLPFREE（）関数を使用して扱われます。"
    },
    {
      "indent": 3,
      "text": "To conform with standard C practice, all character strings passed to and returned through the API are null terminated, even though the SLP protocol does not use null terminated strings. Strings passed as parameters are UTF-8 but they may still be passed as a C string (a null terminated sequence of bytes.) Escaped characters must be encoded by the API client as UTF-8. In the common case of US-ASCII, the usual one byte per character C strings work. API functions assist in escaping and unescaping strings.",
      "ja": "SLPプロトコルではNULL終端文字列を使用していない場合でも、標準のCプラクティスに準拠するために、APIに渡されて返されるすべての文字文字列はnull終了します。パラメーターとして渡された文字列はUTF-8ですが、c文字列（バイトのnull終了シーケンス）として渡される場合があります。エスケープされた文字は、APIクライアントによってUTF-8としてエンコードする必要があります。US-ASCIIの一般的なケースでは、文字C文字列ごとに通常の1バイトが機能します。API関数は、文字列の脱出と解除を支援します。"
    },
    {
      "indent": 3,
      "text": "Unless otherwise noted, parameters to API functions and callbacks are non-NULL. Some parameters may have other restrictions. If any parameter fails to satisfy the restrictions on its value, the operation returns a PARAMETER_BAD error.",
      "ja": "特に明記しない限り、API関数とコールバックへのパラメーターは非ヌルです。一部のパラメーターには他の制限がある場合があります。任意のパラメーターがその値の制限を満たさない場合、操作はparameter_badエラーを返します。"
    },
    {
      "indent": 0,
      "text": "4.1. Constant Types",
      "section_title": true,
      "ja": "4.1. 定数タイプ"
    },
    {
      "indent": 0,
      "text": "4.1.1. URL Lifetimes",
      "section_title": true,
      "ja": "4.1.1. URL寿命"
    },
    {
      "indent": 0,
      "text": "4.1.1.1. Synopsis",
      "section_title": true,
      "ja": "4.1.1.1. 概要"
    },
    {
      "indent": 3,
      "text": "typedef enum {\n  SLP_LIFETIME_DEFAULT = 10800,\n  SLP_LIFETIME_MAXIMUM = 65535\n} SLPURLLifetime;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.1.1.2. Description",
      "section_title": true,
      "ja": "4.1.1.2. 説明"
    },
    {
      "indent": 3,
      "text": "The SLPURLLifetime enum type contains URL lifetime values, in seconds, that are frequently used. SLP_LIFETIME_DEFAULT is 3 hours, while SLP_LIFETIME_MAXIMUM is about 18 hours and corresponds to the maximum size of the lifetime field in SLP messages.",
      "ja": "slpurllifetime enumタイプには、頻繁に使用される秒単位でのurl寿命の値が含まれています。SLP_LIFETIME_DEFAULTは3時間ですが、SLP_LIFETIME_MAXIMUMは約18時間で、SLPメッセージの生涯フィールドの最大サイズに対応しています。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Error Codes",
      "section_title": true,
      "ja": "4.1.2. エラーコード"
    },
    {
      "indent": 0,
      "text": "4.1.2.1. Synopsis",
      "section_title": true,
      "ja": "4.1.2.1. 概要"
    },
    {
      "indent": 3,
      "text": "typedef enum {\n  SLP_LAST_CALL                    = 1,\n  SLP_OK                           = 0,\n  SLP_LANGUAGE_NOT_SUPPORTED       = -1,\n  SLP_PARSE_ERROR                  = -2,\n  SLP_INVALID_REGISTRATION         = -3,\n  SLP_SCOPE_NOT_SUPPORTED          = -4,\n  SLP_AUTHENTICATION_ABSENT        = -6,\n  SLP_AUTHENTICATION_FAILED        = -7,\n     SLP_INVALID_UPDATE               = -13,\n  SLP_REFRESH_REJECTED             = -15,\n  SLP_NOT_IMPLEMENTED              = -17,\n  SLP_BUFFER_OVERFLOW              = -18,\n  SLP_NETWORK_TIMED_OUT            = -19,\n  SLP_NETWORK_INIT_FAILED          = -20,\n  SLP_MEMORY_ALLOC_FAILED          = -21,\n  SLP_PARAMETER_BAD                = -22,\n  SLP_NETWORK_ERROR                = -23,\n  SLP_INTERNAL_SYSTEM_ERROR        = -24,\n  SLP_HANDLE_IN_USE                = -25,\n  SLP_TYPE_ERROR                   = -26\n} SLPError ;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.1.2.2. Description",
      "section_title": true,
      "ja": "4.1.2.2. 説明"
    },
    {
      "indent": 3,
      "text": "The SLPError enum contains error codes that are returned from API functions.",
      "ja": "Slperror enumには、API関数から返されるエラーコードが含まれています。"
    },
    {
      "indent": 3,
      "text": "The SLP_OK code indicates that the no error occurred during the operation.",
      "ja": "SLP_OKコードは、操作中にエラーなしが発生したことを示しています。"
    },
    {
      "indent": 3,
      "text": "The SLP_LAST_CALL code is passed to callback functions when the API library has no more data for them and therefore no further calls will be made to the callback on the currently outstanding operation. The callback can use this to signal the main body of the client code that no more data will be forthcoming on the operation, so that the main body of the client code can break out of data collection loops. On the last call of a callback during both a synchronous and asynchronous call, the error code parameter has value SLP_LAST_CALL, and the other parameters are all NULL. If no results are returned by an API operation, then only one call is made, with the error parameter set to SLP_LAST_CALL.",
      "ja": "SLP_LAST_CALLコードは、APIライブラリにこれ以上のデータがない場合にコールバック関数に渡され、したがって、現在未払いの操作に関するコールバックに対してそれ以上の呼び出しが行われません。コールバックはこれを使用して、クライアントコードの本文を操作でこれ以上データが届かないことを示すため、クライアントコードの本体がデータ収集ループから抜け出すことができます。同期コールと非同期呼び出しの両方でコールバックの最後の呼び出しで、エラーコードパラメーターには値slp_last_callがあり、他のパラメーターはすべてnullです。API操作によって結果が返されない場合、エラーパラメーターがSLP_LAST_CALLに設定されている場合、1つの呼び出しのみが行われます。"
    },
    {
      "indent": 0,
      "text": "4.1.3. SLPBoolean",
      "section_title": true,
      "ja": "4.1.3. slpboolean"
    },
    {
      "indent": 0,
      "text": "4.1.3.1. Synopsis",
      "section_title": true,
      "ja": "4.1.3.1. 概要"
    },
    {
      "indent": 3,
      "text": "typedef enum {\n   SLP_FALSE = 0,\n   SLP_TRUE = 1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "} SLPBoolean;",
      "ja": "} slpboolean;"
    },
    {
      "indent": 0,
      "text": "4.1.3.2. Description",
      "section_title": true,
      "ja": "4.1.3.2. 説明"
    },
    {
      "indent": 3,
      "text": "The SLPBoolean enum is used as a boolean flag.",
      "ja": "slpbooleの列挙は、ブールフラグとして使用されます。"
    },
    {
      "indent": 0,
      "text": "4.2. Struct Types",
      "section_title": true,
      "ja": "4.2. 構造タイプ"
    },
    {
      "indent": 0,
      "text": "4.2.1. SLPSrvURL",
      "section_title": true,
      "ja": "4.2.1. slpsrvurl"
    },
    {
      "indent": 0,
      "text": "4.2.1.1. Synopsis",
      "section_title": true,
      "ja": "4.2.1.1. 概要"
    },
    {
      "indent": 3,
      "text": "typedef struct srvurl {\n  char *s_pcSrvType;\n  char *s_pcHost;\n  int   s_iPort;\n  char *s_pcNetFamily;\n  char *s_pcSrvPart;\n} SLPSrvURL;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.2.1.2. Description",
      "section_title": true,
      "ja": "4.2.1.2. 説明"
    },
    {
      "indent": 3,
      "text": "The SLPSrvURL structure is filled in by the SLPParseSrvURL() function with information parsed from a character buffer containing a service URL. The fields correspond to different parts of the URL. Note that the structure is in conformance with the standard Berkeley sockets struct servent, with the exception that the pointer to an array of characters for aliases (s_aliases field) is replaced by the pointer to host name (s_pcHost field).",
      "ja": "SLPSRVURL構造は、サービスURLを含む文字バッファーから解析された情報を使用して、slpparsesrvurl（）関数によって埋められます。フィールドは、URLのさまざまな部分に対応しています。構造は、エイリアス（S_Aliaseフィールド）の文字の配列へのポインターがホスト名（S_PCHOSTフィールド）へのポインターに置き換えられていることを除いて、標準のバークレーソケット構造体に準拠していることに注意してください。"
    },
    {
      "indent": 6,
      "text": "s_pcSrvType",
      "ja": "s_pcsrvtype"
    },
    {
      "indent": 9,
      "text": "A pointer to a character string containing the service type name, including naming authority. The service type name includes the \"service:\" if the URL is of the service: scheme. [7]",
      "ja": "命名機関を含むサービスタイプ名を含む文字文字列へのポインター。サービスタイプ名には、URLがサービス：スキームの「サービス：」が含まれます。[7]"
    },
    {
      "indent": 6,
      "text": "s_pcHost",
      "ja": "S_PCHOST"
    },
    {
      "indent": 9,
      "text": "A pointer to a character string containing the host identification information.",
      "ja": "ホスト識別情報を含む文字文字列へのポインター。"
    },
    {
      "indent": 6,
      "text": "s_iPort",
      "ja": "s_iport"
    },
    {
      "indent": 9,
      "text": "The port number, or zero if none. The port is only available if the transport is IP.",
      "ja": "ポート番号、またはなしの場合はゼロ。ポートは、トランスポートがIPの場合にのみ使用可能です。"
    },
    {
      "indent": 6,
      "text": "s_pcNetFamily",
      "ja": "s_pcnetfamily"
    },
    {
      "indent": 9,
      "text": "A pointer to a character string containing the network address family identifier. Possible values are \"ipx\" for the IPX family, \"at\" for the Appletalk family, and \"\" (i.e. the empty string) for the IP address family.",
      "ja": "ネットワークアドレスファミリ識別子を含む文字文字列へのポインター。考えられる値は、AppleTalkファミリーの「IPXファミリーのIPX」、およびIPアドレスファミリーの「（つまり空の文字列）」での「IPX」です。"
    },
    {
      "indent": 6,
      "text": "s_pcSrvPart",
      "ja": "S_PCSRVPART"
    },
    {
      "indent": 9,
      "text": "The remainder of the URL, after the host identification.",
      "ja": "ホスト識別後のURLの残り。"
    },
    {
      "indent": 3,
      "text": "The host and port should be sufficient to open a socket to the machine hosting the service, and the remainder of the URL should allow further differentiation of the service.",
      "ja": "ホストとポートは、サービスをホストするマシンにソケットを開くのに十分である必要があり、残りのURLはサービスのさらなる差別化を可能にする必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2.2. SLPHandle",
      "section_title": true,
      "ja": "4.2.2. slphandle"
    },
    {
      "indent": 0,
      "text": "4.2.2.1. Synopsis",
      "section_title": true,
      "ja": "4.2.2.1. 概要"
    },
    {
      "indent": 3,
      "text": "typedef void* SLPHandle;",
      "ja": "typedef void* slphandle;"
    },
    {
      "indent": 3,
      "text": "The SLPHandle type is returned by SLPOpen() and is a parameter to all SLP functions. It serves as a handle for all resources allocated on behalf of the process by the SLP library. The type is opaque, since the exact nature differs depending on the implementation.",
      "ja": "slphandleタイプはslpopen（）によって返され、すべてのSLP関数のパラメーターです。SLPライブラリによってプロセスに代わって割り当てられたすべてのリソースのハンドルとして機能します。正確な性質は実装によって異なるため、タイプは不透明です。"
    },
    {
      "indent": 0,
      "text": "4.3. Callbacks",
      "section_title": true,
      "ja": "4.3. コールバック"
    },
    {
      "indent": 3,
      "text": "A function pointer to a callback function specific to a particular API operation is included in the parameter list when the API function is invoked. The callback function is called with the results of the operation in both the synchronous and asynchronous cases. The memory included in the callback parameters is owned by the API library, and the client code in the callback must copy out the contents if it wants to maintain the information longer than the duration of the current callback call.",
      "ja": "特定のAPI操作に固有のコールバック関数への関数ポインターは、API関数が呼び出されたときにパラメーターリストに含まれます。コールバック関数は、同期と非同期の両方の場合に操作の結果と呼ばれます。コールバックパラメーターに含まれるメモリはAPIライブラリが所有しており、コールバックのクライアントコードは、現在のコールバックコールの期間よりも長く情報を維持したい場合は、コンテンツをコピーする必要があります。"
    },
    {
      "indent": 3,
      "text": "In addition to parameters for reporting the results of the operation, each callback parameter list contains an error code parameter and a cookie parameter. The error code parameter reports the error status of the ongoing (for asynchronous) or completed (for synchronous) operation. The cookie parameter allows the client code that starts the operation by invoking the API function to pass information down to the callback without using global variables. The callback returns an SLPBoolean to indicate whether the API library should continue processing the operation. If the value returned from the callback is SLP_TRUE, asynchronous operations are terminated, synchronous operations ignore the return (since the operation is already complete).",
      "ja": "操作の結果を報告するためのパラメーターに加えて、各コールバックパラメーターリストにはエラーコードパラメーターとCookieパラメーターが含まれています。エラーコードパラメーターは、進行中（非同期）または完了（同期の場合）操作のエラーステータスを報告します。Cookieパラメーターを使用すると、API関数を呼び出してグローバル変数を使用せずにコールバックに情報を渡すことにより、操作を開始するクライアントコードを許可します。コールバックはSLPBooleanを返し、APIライブラリが操作の処理を継続するかどうかを示します。コールバックから返される値がSLP_TRUEである場合、非同期操作は終了します。同期操作はリターンを無視します（操作はすでに完了しているため）。"
    },
    {
      "indent": 0,
      "text": "4.3.1. SLPRegReport",
      "section_title": true,
      "ja": "4.3.1. slpregreport"
    },
    {
      "indent": 0,
      "text": "4.3.1.1. Synopsis",
      "section_title": true,
      "ja": "4.3.1.1. 概要"
    },
    {
      "indent": 3,
      "text": "typedef void SLPRegReport(SLPHandle hSLP, SLPError errCode, void *pvCookie);",
      "ja": "typedef void slpregreport（slphandle hslp、slperror errcode、void *pvcookie）;"
    },
    {
      "indent": 0,
      "text": "4.3.1.2. Description",
      "section_title": true,
      "ja": "4.3.1.2. 説明"
    },
    {
      "indent": 3,
      "text": "The SLPRegReport callback type is the type of the callback function to the SLPReg(), SLPDereg(), and SLPDelAttrs() functions.",
      "ja": "slpregreportコールバックタイプは、slpreg（）、slpdereg（）、およびslpdelattrs（）関数のコールバック関数のタイプです。"
    },
    {
      "indent": 0,
      "text": "4.3.1.3. Parameters",
      "section_title": true,
      "ja": "4.3.1.3. パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "HSLP"
    },
    {
      "indent": 9,
      "text": "The SLPHandle used to initiate the operation.",
      "ja": "操作の開始に使用されていました。"
    },
    {
      "indent": 6,
      "text": "errCode",
      "ja": "errcode"
    },
    {
      "indent": 9,
      "text": "An error code indicating if an error occurred during the operation.",
      "ja": "操作中にエラーが発生したかどうかを示すエラーコード。"
    },
    {
      "indent": 6,
      "text": "pvCookie",
      "ja": "pvcookie"
    },
    {
      "indent": 9,
      "text": "Memory passed down from the client code that called the original API function, starting the operation. May be NULL.",
      "ja": "メモリは、操作を開始し、元のAPI関数を呼び出すクライアントコードから渡されました。ヌルかもしれません。"
    },
    {
      "indent": 0,
      "text": "4.3.2. SLPSrvTypeCallback",
      "section_title": true,
      "ja": "4.3.2. slpsrvtypecallback"
    },
    {
      "indent": 0,
      "text": "4.3.2.1. Synopsis",
      "section_title": true,
      "ja": "4.3.2.1. 概要"
    },
    {
      "indent": 3,
      "text": "typedef SLPBoolean SLPSrvTypeCallback(SLPHandle hSLP, const char* pcSrvTypes, SLPError errCode, void *pvCookie);",
      "ja": "typedef slpboolean slpsrvtypecallback（slphandle hslp、const char * pcsrvtypes、slperror errcode、void * pvcookie）;"
    },
    {
      "indent": 0,
      "text": "4.3.2.2. Description",
      "section_title": true,
      "ja": "4.3.2.2. 説明"
    },
    {
      "indent": 3,
      "text": "The SLPSrvTypeCallback type is the type of the callback function parameter to SLPFindSrvTypes() function. If the hSLP handle parameter was opened asynchronously, the results returned through the callback MAY be uncollated. If the hSLP handle parameter was opened synchronously, then the returned results must be collated and duplicates eliminated.",
      "ja": "SLPSRVTYPECALLBACKタイプは、SLPFINDSRVTYPES（）関数のコールバック関数パラメーターのタイプです。HSLPハンドルパラメーターが非同期に開かれた場合、コールバックを介して返された結果がcollされていない場合があります。HSLPハンドルパラメーターが同期的に開かれた場合、返された結果を照合し、複製する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3.2.3. Parameters",
      "section_title": true,
      "ja": "4.3.2.3. パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "HSLP"
    },
    {
      "indent": 9,
      "text": "The SLPHandle used to initiate the operation.",
      "ja": "操作の開始に使用されていました。"
    },
    {
      "indent": 6,
      "text": "pcSrvTypes",
      "ja": "PCSRVTYPES"
    },
    {
      "indent": 9,
      "text": "A character buffer containing a comma separated, null terminated list of service types.",
      "ja": "分離されたNULLのサービスタイプのリスト終了コンマを含むキャラクターバッファー。"
    },
    {
      "indent": 6,
      "text": "errCode",
      "ja": "errcode"
    },
    {
      "indent": 9,
      "text": "An error code indicating if an error occurred during the operation. The callback should check this error code before processing the parameters. If the error code is other than SLP_OK, then the API library may choose to terminate the outstanding operation.",
      "ja": "操作中にエラーが発生したかどうかを示すエラーコード。パラメーターを処理する前に、コールバックはこのエラーコードを確認する必要があります。エラーコードがSLP_OK以外の場合、APIライブラリは未解決の操作を終了することを選択できます。"
    },
    {
      "indent": 6,
      "text": "pvCookie",
      "ja": "pvcookie"
    },
    {
      "indent": 9,
      "text": "Memory passed down from the client code that called the original API function, starting the operation. May be NULL.",
      "ja": "メモリは、操作を開始し、元のAPI関数を呼び出すクライアントコードから渡されました。ヌルかもしれません。"
    },
    {
      "indent": 0,
      "text": "4.3.2.4. Returns",
      "section_title": true,
      "ja": "4.3.2.4. 戻り値"
    },
    {
      "indent": 3,
      "text": "The client code should return SLP_TRUE if more data is desired, otherwise SLP_FALSE.",
      "ja": "クライアントコードは、より多くのデータが必要な場合はslp_trueを返す必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3.3. SLPSrvURLCallback",
      "section_title": true,
      "ja": "4.3.3. slpsrvurlcallback"
    },
    {
      "indent": 0,
      "text": "4.3.3.1. Synopsis",
      "section_title": true,
      "ja": "4.3.3.1. 概要"
    },
    {
      "indent": 3,
      "text": "typedef SLPBoolean SLPSrvURLCallback(SLPHandle hSLP, const char* pcSrvURL, unsigned short sLifetime, SLPError errCode, void *pvCookie);",
      "ja": "typedef slpboolean slpsrvurlcallback（slphandle hslp、const char * pcsrvurl、unsigned short slifetime、slperror errcode、void * pvcookie）;"
    },
    {
      "indent": 0,
      "text": "4.3.3.2. Description",
      "section_title": true,
      "ja": "4.3.3.2. 説明"
    },
    {
      "indent": 3,
      "text": "The SLPSrvURLCallback type is the type of the callback function parameter to SLPFindSrvs() function. If the hSLP handle parameter was opened asynchronously, the results returned through the callback MAY be uncollated. If the hSLP handle parameter was opened synchronously, then the returned results must be collated and duplicates eliminated.",
      "ja": "slpsrvurlcallbackタイプは、slpfindsrvs（）関数のコールバック関数パラメーターのタイプです。HSLPハンドルパラメーターが非同期に開かれた場合、コールバックを介して返された結果がcollされていない場合があります。HSLPハンドルパラメーターが同期的に開かれた場合、返された結果を照合し、複製する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3.3.3. Parameters",
      "section_title": true,
      "ja": "4.3.3.3. パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "HSLP"
    },
    {
      "indent": 9,
      "text": "The SLPHandle used to initiate the operation.",
      "ja": "操作の開始に使用されていました。"
    },
    {
      "indent": 6,
      "text": "pcSrvURL",
      "ja": "pcsrvurl"
    },
    {
      "indent": 9,
      "text": "A character buffer containing the returned service URL.",
      "ja": "返されたサービスURLを含む文字バッファー。"
    },
    {
      "indent": 6,
      "text": "sLifetime",
      "ja": "スライフタイム"
    },
    {
      "indent": 9,
      "text": "An unsigned short giving the life time of the service advertisement, in seconds. The value must be an unsigned integer less than or equal to SLP_LIFETIME_MAXIMUM.",
      "ja": "署名されていないショートは、秒単位でサービス広告の寿命を与える。値は、slp_lifetime_maximumよりも等または等しい符号なしの整数でなければなりません。"
    },
    {
      "indent": 6,
      "text": "errCode",
      "ja": "errcode"
    },
    {
      "indent": 9,
      "text": "An error code indicating if an error occurred during the operation. The callback should check this error code before processing the parameters. If the error code is other than SLP_OK, then the API library may choose to terminate the outstanding operation.",
      "ja": "操作中にエラーが発生したかどうかを示すエラーコード。パラメーターを処理する前に、コールバックはこのエラーコードを確認する必要があります。エラーコードがSLP_OK以外の場合、APIライブラリは未解決の操作を終了することを選択できます。"
    },
    {
      "indent": 6,
      "text": "pvCookie",
      "ja": "pvcookie"
    },
    {
      "indent": 9,
      "text": "Memory passed down from the client code that called the original API function, starting the operation. May be NULL.",
      "ja": "メモリは、操作を開始し、元のAPI関数を呼び出すクライアントコードから渡されました。ヌルかもしれません。"
    },
    {
      "indent": 0,
      "text": "4.3.3.4. Returns",
      "section_title": true,
      "ja": "4.3.3.4. 戻り値"
    },
    {
      "indent": 3,
      "text": "The client code should return SLP_TRUE if more data is desired, otherwise SLP_FALSE.",
      "ja": "クライアントコードは、より多くのデータが必要な場合はslp_trueを返す必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3.4. SLPAttrCallback",
      "section_title": true,
      "ja": "4.3.4. slpattrcallback"
    },
    {
      "indent": 0,
      "text": "4.3.4.1. Synopsis",
      "section_title": true,
      "ja": "4.3.4.1. 概要"
    },
    {
      "indent": 3,
      "text": "typedef SLPBoolean SLPAttrCallback(SLPHandle hSLP, const char* pcAttrList, SLPError errCode, void *pvCookie);",
      "ja": "typedef slpboolean slpattrcallback（slphandle hslp、const char * pcattrlist、slperror errcode、void * pvcookie）;"
    },
    {
      "indent": 0,
      "text": "4.3.4.2. Description",
      "section_title": true,
      "ja": "4.3.4.2. 説明"
    },
    {
      "indent": 3,
      "text": "The SLPAttrCallback type is the type of the callback function parameter to SLPFindAttrs() function.",
      "ja": "slpattrcallbackタイプは、slpfindattrs（）関数のコールバック関数パラメーターのタイプです。"
    },
    {
      "indent": 3,
      "text": "The behavior of the callback differs depending on whether the attribute request was by URL or by service type. If the SLPFindAttrs() operation was originally called with a URL, the callback is called once regardless of whether the handle was opened asynchronously or synchronously. The pcAttrList parameter contains the requested attributes as a comma separated list (or is empty if no attributes matched the original tag list).",
      "ja": "コールバックの動作は、属性要求がURLまたはサービスタイプであるかどうかによって異なります。SLPFindattrs（）操作が元々URLで呼び出された場合、ハンドルが非同期に開かれたのか同期しているかに関係なく、コールバックは一度呼び出されます。PCATTRLISTパラメーターには、要求された属性がコンマ分離リストとして含まれています（または、属性が元のタグリストと一致していない場合は空です）。"
    },
    {
      "indent": 3,
      "text": "If the SLPFindAttrs() operation was originally called with a service type, the value of pcAttrList and calling behavior depend on whether the handle was opened asynchronously or synchronously. If the handle was opened asynchronously, the callback is called every time the API library has results from a remote agent. The pcAttrList parameter MAY be uncollated between calls. It contains a comma separated list with the results from the agent that immediately returned results. If the handle was opened synchronously, the results must be collated from all returning agents and the callback is called once, with the pcAttrList parameter set to the collated result.",
      "ja": "SLPFINDATTRS（）操作が元々サービスタイプで呼び出された場合、PCATTRLISTと呼び出しの動作の値は、ハンドルが非同期的または同期して開かれたかどうかによって異なります。ハンドルが非同期に開かれた場合、APIライブラリがリモートエージェントの結果を得るたびにコールバックが呼び出されます。PCATTRLISTパラメーターは、呼び出し間でcollされていない場合があります。すぐに結果を返すエージェントの結果を含むコンマ分離リストが含まれています。ハンドルが同期して開かれた場合、結果をすべての返信エージェントから照合する必要があり、コールバックは1回呼び出され、PCATTRLISTパラメーターが照合結果に設定されています。"
    },
    {
      "indent": 0,
      "text": "4.3.4.3. Parameters",
      "section_title": true,
      "ja": "4.3.4.3. パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "HSLP"
    },
    {
      "indent": 9,
      "text": "The SLPHandle used to initiate the operation.",
      "ja": "操作の開始に使用されていました。"
    },
    {
      "indent": 6,
      "text": "pcAttrList",
      "ja": "PCATTRLIST"
    },
    {
      "indent": 9,
      "text": "A character buffer containing a comma separated, null terminated list of attribute id/value assignments, in SLP wire format; i.e. \"(attr-id=attr-value-list)\" [7].",
      "ja": "SLPワイヤ形式の属性ID/値割り当ての分離されたNULLの終了リストを含むキャラクターバッファー。つまり、「（attr-id = attr-value-list）」[7]。"
    },
    {
      "indent": 6,
      "text": "errCode",
      "ja": "errcode"
    },
    {
      "indent": 9,
      "text": "An error code indicating if an error occurred during the operation. The callback should check this error code before processing the parameters. If the error code is other than SLP_OK, then the API library may choose to terminate the outstanding operation.",
      "ja": "操作中にエラーが発生したかどうかを示すエラーコード。パラメーターを処理する前に、コールバックはこのエラーコードを確認する必要があります。エラーコードがSLP_OK以外の場合、APIライブラリは未解決の操作を終了することを選択できます。"
    },
    {
      "indent": 6,
      "text": "pvCookie",
      "ja": "pvcookie"
    },
    {
      "indent": 9,
      "text": "Memory passed down from the client code that called the original API function, starting the operation. May be NULL.",
      "ja": "メモリは、操作を開始し、元のAPI関数を呼び出すクライアントコードから渡されました。ヌルかもしれません。"
    },
    {
      "indent": 0,
      "text": "4.3.4.4. Returns",
      "section_title": true,
      "ja": "4.3.4.4. 戻り値"
    },
    {
      "indent": 3,
      "text": "The client code should return SLP_TRUE if more data is desired, otherwise SLP_FALSE.",
      "ja": "クライアントコードは、より多くのデータが必要な場合はslp_trueを返す必要があります。"
    },
    {
      "indent": 0,
      "text": "4.4. Opening and Closing an SLPHandle",
      "section_title": true,
      "ja": "4.4. Slphandleを開閉します"
    },
    {
      "indent": 0,
      "text": "4.4.1. SLPOpen",
      "section_title": true,
      "ja": "4.4.1. slpopen"
    },
    {
      "indent": 0,
      "text": "4.4.1.1. Synopsis",
      "section_title": true,
      "ja": "4.4.1.1. 概要"
    },
    {
      "indent": 3,
      "text": "SLPError SLPOpen(const char *pcLang, SLPBoolean isAsync, SLPHandle\n*phSLP);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.4.1.2. Description",
      "section_title": true,
      "ja": "4.4.1.2. 説明"
    },
    {
      "indent": 3,
      "text": "Returns a SLPHandle handle in the phSLP parameter for the language locale passed in as the pcLang parameter. The client indicates if operations on the handle are to be synchronous or asynchronous through the isAsync parameter. The handle encapsulates the language locale for SLP requests issued through the handle, and any other resources required by the implementation. However, SLP properties are not encapsulated by the handle; they are global. The return value of the function is an SLPError code indicating the status of the operation. Upon failure, the phSLP parameter is NULL.",
      "ja": "PCLANGパラメーターとして渡された言語ロケールのPHSLPパラメーターのSLPHANDLEハンドルを返します。クライアントは、ハンドル上の操作がISASYNCパラメーターを介して同期または非同期であるかどうかを示します。ハンドルは、ハンドルを介して発行されたSLPリクエストの言語ロケール、および実装に必要なその他のリソースをカプセル化します。ただし、SLPプロパティはハンドルによってカプセル化されていません。彼らはグローバルです。関数の返品値は、操作のステータスを示すSLPERRORコードです。障害時に、PHSLPパラメーターはnullです。"
    },
    {
      "indent": 3,
      "text": "An SLPHandle can only be used for one SLP API operation at a time. If the original operation was started asynchronously, any attempt to start an additional operation on the handle while the original operation is pending results in the return of an SLP_HANDLE_IN_USE error from the API function. The SLPClose() API function terminates any outstanding calls on the handle. If an implementation is unable to support a asynchronous( resp. synchronous) operation, due to memory constraints or lack of threading support, the SLP_NOT_IMPLEMENTED flag may be returned when the isAsync flag is SLP_TRUE (resp. SLP_FALSE).",
      "ja": "SLPHANDLEは、一度に1つのSLP API操作にのみ使用できます。元の操作が非同期に開始された場合、元の操作が保留中にハンドルで追加操作を開始しようとすると、API関数からSLP_HANDLE_IN_USEエラーが返されます。SlpClose（）API関数は、ハンドルの未解決の呼び出しを終了します。メモリの制約またはスレッドサポートの欠如により、実装が非同期（Resp。Synchronous）操作をサポートできない場合、IsasyncフラグがSLP_True（rep。SLP_FALSE）の場合、SLP_NOT_IMPLEMENTEDフラグが返される場合があります。"
    },
    {
      "indent": 0,
      "text": "4.4.1.3. Parameters",
      "section_title": true,
      "ja": "4.4.1.3. パラメーター"
    },
    {
      "indent": 6,
      "text": "pcLang",
      "ja": "pclang"
    },
    {
      "indent": 9,
      "text": "A pointer to an array of characters containing the RFC 1766 Language Tag [6] for the natural language locale of requests and registrations issued on the handle.",
      "ja": "ハンドルに発行されたリクエストと登録の自然言語ロケールのRFC 1766言語タグ[6]を含む一連の文字へのポインター。"
    },
    {
      "indent": 6,
      "text": "isAsync",
      "ja": "Isasync"
    },
    {
      "indent": 9,
      "text": "An SLPBoolean indicating whether the SLPHandle should be opened for asynchronous operation or not.",
      "ja": "非同期操作のためにSlphandleを開くべきかどうかを示すSLPBoolean。"
    },
    {
      "indent": 6,
      "text": "phSLP",
      "ja": "phslp"
    },
    {
      "indent": 9,
      "text": "A pointer to an SLPHandle, in which the open SLPHandle is returned. If an error occurs, the value upon return is NULL.",
      "ja": "開いたスルファンドルが返されるslphandleへのポインター。エラーが発生した場合、返された値はnullです。"
    },
    {
      "indent": 0,
      "text": "4.4.2. SLPClose",
      "section_title": true,
      "ja": "4.4.2. slpclose"
    },
    {
      "indent": 0,
      "text": "4.4.2.1. Synopsis",
      "section_title": true,
      "ja": "4.4.2.1. 概要"
    },
    {
      "indent": 3,
      "text": "void SLPClose(SLPHandle hSLP);",
      "ja": "void slpclose（slphandle hslp）;"
    },
    {
      "indent": 0,
      "text": "4.4.2.2. Description",
      "section_title": true,
      "ja": "4.4.2.2. 説明"
    },
    {
      "indent": 3,
      "text": "Frees all resources associated with the handle. If the handle was invalid, the function returns silently. Any outstanding synchronous or asynchronous operations are cancelled so their callback functions will not be called any further.",
      "ja": "ハンドルに関連付けられたすべてのリソースを解放します。ハンドルが無効な場合、関数は静かに戻ります。発行済みの同期または非同期操作はキャンセルされるため、コールバック機能はそれ以上呼び出されません。"
    },
    {
      "indent": 0,
      "text": "4.4.2.3. Parameters",
      "section_title": true,
      "ja": "4.4.2.3. パラメーター"
    },
    {
      "indent": 6,
      "text": "SLPHandle",
      "ja": "slphandle"
    },
    {
      "indent": 9,
      "text": "A SLPHandle handle returned from a call to SLPOpen().",
      "ja": "slpopen（）への呼び出しから返されたslphandleハンドル。"
    },
    {
      "indent": 0,
      "text": "4.5. Protocol API",
      "section_title": true,
      "ja": "4.5. プロトコルAPI"
    },
    {
      "indent": 0,
      "text": "4.5.1. SLPReg",
      "section_title": true,
      "ja": "4.5.1. slpreg"
    },
    {
      "indent": 0,
      "text": "4.5.1.1. Synopsis",
      "section_title": true,
      "ja": "4.5.1.1. 概要"
    },
    {
      "indent": 3,
      "text": "SLPError SLPReg(SLPHandle hSLP, const char *pcSrvURL, const unsigned short usLifetime, const char *pcSrvType, const char *pcAttrs SLPBoolean fresh, SLPRegReport callback, void *pvCookie);",
      "ja": "slperror slpreg（slphandle hslp、const char *pcsrvurl、const unsigned short uslifetime、const char *pcsrvtype、const char *pcattrs slpbooles fresh、slpregreport callback、void *pvcookie）;"
    },
    {
      "indent": 0,
      "text": "4.5.1.2. Description",
      "section_title": true,
      "ja": "4.5.1.2. 説明"
    },
    {
      "indent": 3,
      "text": "Registers the URL in pcSrvURL having the lifetime usLifetime with the attribute list in pcAttrs. The pcAttrs list is a comma separated list of attribute assignments in the wire format (including escaping of reserved characters). The usLifetime parameter must be nonzero and less than or equal to SLP_LIFETIME_MAXIMUM. If the fresh flag is SLP_TRUE, then the registration is new (the SLP protocol FRESH flag is set) and the registration replaces any existing registrations. The pcSrvType parameter is a service type name and can be included for service URLs that are not in the service: scheme. If the URL is in the service: scheme, the pcSrvType parameter is ignored. If the fresh flag is SLP_FALSE, then an existing registration is updated. Rules for new and updated registrations, and the format for pcAttrs and pcScopeList can be found in [7]. Registrations and updates take place in the language locale of the hSLP handle.",
      "ja": "PCSRVURLのURLを登録します。PCATTRの属性リストを持つ寿命のUSLIFETIMEを有する。PCATTRSリストは、ワイヤー形式の属性割り当てのコンマ分離リストです（予約された文字の脱出を含む）。USLIFETIMEパラメーターは、ゼロではなく、SLP_LIFETIME_MAXIMUM以下でなければなりません。新鮮なフラグがSLP_TRUEの場合、登録は新しく（SLPプロトコルフレッシュフラグが設定されています）、登録は既存の登録を置き換えます。PCSRVTYPEパラメーターはサービスタイプ名であり、サービスにないサービスURLに含めることができます：スキーム。URLがサービスにある場合：スキーム、PCSRVTYPEパラメーターは無視されます。新鮮なフラグがSLP_FALSEの場合、既存の登録が更新されます。新規および更新された登録のルール、およびPCATTRSおよびPCSCOPELISTの形式は[7]に記載されています。登録と更新は、HSLPハンドルの言語ロケールで行われます。"
    },
    {
      "indent": 3,
      "text": "The API library is required to perform the operation in all scopes obtained through configuration.",
      "ja": "APIライブラリは、構成を通じて取得したすべてのスコープで操作を実行するために必要です。"
    },
    {
      "indent": 0,
      "text": "4.5.1.3. Parameters",
      "section_title": true,
      "ja": "4.5.1.3. パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "HSLP"
    },
    {
      "indent": 9,
      "text": "The language specific SLPHandle on which to register the advertisement.",
      "ja": "広告を登録するための言語固有のslphandle。"
    },
    {
      "indent": 6,
      "text": "pcSrvURL",
      "ja": "pcsrvurl"
    },
    {
      "indent": 9,
      "text": "The URL to register. May not be the empty string.",
      "ja": "登録するURL。空の文字列ではないかもしれません。"
    },
    {
      "indent": 6,
      "text": "usLifetime",
      "ja": "USLIFETIME"
    },
    {
      "indent": 9,
      "text": "An unsigned short giving the life time of the service advertisement, in seconds. The value must be an unsigned integer less than or equal to SLP_LIFETIME_MAXIMUM and greater than zero.",
      "ja": "署名されていないショートは、秒単位でサービス広告の寿命を与える。値は、slp_lifetime_maximum以下でゼロよりも大きい符号なしの整数でなければなりません。"
    },
    {
      "indent": 6,
      "text": "pcSrvType",
      "ja": "PCSRVTYPE"
    },
    {
      "indent": 9,
      "text": "The service type. If pURL is a service: URL, then this parameter is ignored.",
      "ja": "サービスタイプ。purlがサービスである場合：URL、このパラメーターは無視されます。"
    },
    {
      "indent": 6,
      "text": "pcAttrs",
      "ja": "pcattrs"
    },
    {
      "indent": 9,
      "text": "A comma separated list of attribute assignment expressions for the attributes of the advertisement. Use empty string, \"\" for no attributes.",
      "ja": "広告の属性の属性割り当て式のコンマ分離リスト。属性なしに空の文字列 \"を使用します。"
    },
    {
      "indent": 6,
      "text": "fresh",
      "ja": "新鮮な新鮮新た爽やかみずみずしい清々しい生々しいほやほや清清しい生生しい出来立てさっぱりしたイキがいい独創的"
    },
    {
      "indent": 9,
      "text": "An SLPBoolean that is SLP_TRUE if the registration is new or SLP_FALSE if a reregistration.",
      "ja": "登録が新規または再登録の場合はslp_trueであるslpboolean。"
    },
    {
      "indent": 6,
      "text": "callback",
      "ja": "折り返し電話コールバック"
    },
    {
      "indent": 9,
      "text": "A callback to report the operation completion status.",
      "ja": "操作完了ステータスを報告するためのコールバック。"
    },
    {
      "indent": 6,
      "text": "pvCookie",
      "ja": "pvcookie"
    },
    {
      "indent": 9,
      "text": "Memory passed to the callback code from the client. May be NULL.",
      "ja": "メモリは、クライアントからコールバックコードに渡されました。ヌルかもしれません。"
    },
    {
      "indent": 0,
      "text": "4.5.1.4. Returns",
      "section_title": true,
      "ja": "4.5.1.4. 戻り値"
    },
    {
      "indent": 3,
      "text": "If an error occurs in starting the operation, one of the SLPError codes is returned.",
      "ja": "操作の開始時にエラーが発生した場合、Slperrorコードの1つが返されます。"
    },
    {
      "indent": 0,
      "text": "4.5.2. SLPDereg",
      "section_title": true,
      "ja": "4.5.2. slpdereg"
    },
    {
      "indent": 0,
      "text": "4.5.2.1. Synopsis",
      "section_title": true,
      "ja": "4.5.2.1. 概要"
    },
    {
      "indent": 3,
      "text": "SLPError SLPDereg(SLPHandle hSLP, const char *pcURL, SLPRegReport callback, void *pvCookie);",
      "ja": "slperror slpdereg（slphandle hslp、const char *pcurl、slpregreportコールバック、void *pvcookie）;"
    },
    {
      "indent": 0,
      "text": "4.5.2.2. Description",
      "section_title": true,
      "ja": "4.5.2.2. 説明"
    },
    {
      "indent": 3,
      "text": "Deregisters the advertisement for URL pcURL in all scopes where the service is registered and all language locales. The deregistration is not just confined to the locale of the SLPHandle, it is in all locales. The API library is required to perform the operation in all scopes obtained through configuration.",
      "ja": "Deregistersサービスが登録されているすべてのスコープおよびすべての言語ロケーションでのURL PCURLの広告。解雇は、Slphandleのロケールに限定されているだけでなく、すべての場所にあります。APIライブラリは、構成を通じて取得したすべてのスコープで操作を実行するために必要です。"
    },
    {
      "indent": 0,
      "text": "4.5.2.3. Parameters",
      "section_title": true,
      "ja": "4.5.2.3. パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "HSLP"
    },
    {
      "indent": 9,
      "text": "The language specific SLPHandle to use for deregistering.",
      "ja": "登録に使用する言語固有のslphandle。"
    },
    {
      "indent": 6,
      "text": "pcURL",
      "ja": "pcurl"
    },
    {
      "indent": 9,
      "text": "The URL to deregister. May not be the empty string.",
      "ja": "登録者へのURL。空の文字列ではないかもしれません。"
    },
    {
      "indent": 6,
      "text": "callback",
      "ja": "折り返し電話コールバック"
    },
    {
      "indent": 9,
      "text": "A callback to report the operation completion status.",
      "ja": "操作完了ステータスを報告するためのコールバック。"
    },
    {
      "indent": 6,
      "text": "pvCookie",
      "ja": "pvcookie"
    },
    {
      "indent": 9,
      "text": "Memory passed to the callback code from the client. May be NULL.",
      "ja": "メモリは、クライアントからコールバックコードに渡されました。ヌルかもしれません。"
    },
    {
      "indent": 0,
      "text": "4.5.2.4. Returns",
      "section_title": true,
      "ja": "4.5.2.4. 戻り値"
    },
    {
      "indent": 3,
      "text": "If an error occurs in starting the operation, one of the SLPError codes is returned.",
      "ja": "操作の開始時にエラーが発生した場合、Slperrorコードの1つが返されます。"
    },
    {
      "indent": 0,
      "text": "4.5.3. SLPDelAttrs",
      "section_title": true,
      "ja": "4.5.3. slpdelattrs"
    },
    {
      "indent": 0,
      "text": "4.5.3.1. Synopsis",
      "section_title": true,
      "ja": "4.5.3.1. 概要"
    },
    {
      "indent": 3,
      "text": "SLPError SLPDelAttrs(SLPHandle hSLP, const char *pcURL, const char *pcAttrs, SLPRegReport callback, void *pvCookie);",
      "ja": "slperror slpdelattrs（slphandle hslp、const char *pcurl、const char *pcattrs、slpregreportコールバック、void *pvcookie）;"
    },
    {
      "indent": 0,
      "text": "4.5.3.2. Description",
      "section_title": true,
      "ja": "4.5.3.2. 説明"
    },
    {
      "indent": 3,
      "text": "Delete the selected attributes in the locale of the SLPHandle. The API library is required to perform the operation in all scopes obtained through configuration.",
      "ja": "Slphandleのロケールで選択した属性を削除します。APIライブラリは、構成を通じて取得したすべてのスコープで操作を実行するために必要です。"
    },
    {
      "indent": 0,
      "text": "4.5.3.3. Parameters",
      "section_title": true,
      "ja": "4.5.3.3. パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "HSLP"
    },
    {
      "indent": 9,
      "text": "The language specific SLPHandle to use for deleting attributes.",
      "ja": "属性を削除するために使用する言語固有のslphandle。"
    },
    {
      "indent": 6,
      "text": "pcURL",
      "ja": "pcurl"
    },
    {
      "indent": 9,
      "text": "The URL of the advertisement from which the attributes should be deleted. May not be the empty string.",
      "ja": "属性を削除する広告のURL。空の文字列ではないかもしれません。"
    },
    {
      "indent": 6,
      "text": "pcAttrs",
      "ja": "pcattrs"
    },
    {
      "indent": 9,
      "text": "A comma separated list of attribute ids for the attributes to deregister. See Section 9.8 in [7] for a description of the list format. May not be the empty string.",
      "ja": "登録者への属性の属性IDのコンマ分離リスト。リスト形式の説明については、[7]のセクション9.8を参照してください。空の文字列ではないかもしれません。"
    },
    {
      "indent": 6,
      "text": "callback",
      "ja": "折り返し電話コールバック"
    },
    {
      "indent": 9,
      "text": "A callback to report the operation completion status.",
      "ja": "操作完了ステータスを報告するためのコールバック。"
    },
    {
      "indent": 6,
      "text": "pvCookie",
      "ja": "pvcookie"
    },
    {
      "indent": 9,
      "text": "Memory passed to the callback code from the client. May be NULL.",
      "ja": "メモリは、クライアントからコールバックコードに渡されました。ヌルかもしれません。"
    },
    {
      "indent": 0,
      "text": "4.5.3.4. Returns",
      "section_title": true,
      "ja": "4.5.3.4. 戻り値"
    },
    {
      "indent": 3,
      "text": "If an error occurs in starting the operation, one of the SLPError codes is returned.",
      "ja": "操作の開始時にエラーが発生した場合、Slperrorコードの1つが返されます。"
    },
    {
      "indent": 0,
      "text": "4.5.4. SLPFindSrvTypes",
      "section_title": true,
      "ja": "4.5.4. slpfindsrvtypes"
    },
    {
      "indent": 0,
      "text": "4.5.4.1. Synopsis",
      "section_title": true,
      "ja": "4.5.4.1. 概要"
    },
    {
      "indent": 3,
      "text": "SLPError SLPFindSrvTypes(SLPHandle hSLP, const char *pcNamingAuthority, const char *pcScopeList, SLPSrvTypeCallback callback, void *pvCookie);",
      "ja": "slperror slpfindsrvtypes（slphandle hslp、const char *pcnamingauthority、const char *pcscopelist、slpsrvtypecallbackコールバック、void *pvcookie）;"
    },
    {
      "indent": 3,
      "text": "The SLPFindSrvType() function issues an SLP service type request for service types in the scopes indicated by the pcScopeList. The results are returned through the callback parameter. The service types are independent of language locale, but only for services registered in one of scopes and for the indicated naming authority.",
      "ja": "SLPFINDSRVTYPE（）関数は、PCSCOPELISTが示すスコープ内のサービスタイプのSLPサービスタイプの要求を発行します。結果は、コールバックパラメーターから返されます。サービスタイプは言語のロケールに依存しませんが、スコープのいずれかに登録されているサービスと、指定された命名当局に対してのみです。"
    },
    {
      "indent": 3,
      "text": "If the naming authority is \"*\", then results are returned for all naming authorities. If the naming authority is the empty string, i.e. \"\", then the default naming authority, \"IANA\", is used. \"IANA\" is not a valid naming authority name, and it is a PARAMETER_BAD error to include it explicitly.",
      "ja": "命名当局が「*」である場合、すべての命名当局に対して結果が返されます。命名権限が空の文字列、つまり「」である場合、デフォルトの命名権限「IANA」が使用されます。「IANA」は有効な命名機関の名前ではなく、明示的に含めることはパラメーター_BADエラーです。"
    },
    {
      "indent": 3,
      "text": "The service type names are returned with the naming authority intact. If the naming authority is the default (i.e. empty string) then it is omitted, as is the separating \".\". Service type names from URLs of the service: scheme are returned with the \"service:\" prefix intact. [7] See [8] for more information on the syntax of service type names.",
      "ja": "サービスタイプ名は、命名機関がそのままで返されます。命名当局がデフォルト（つまり空の文字列）である場合、分離するように、省略されます。サービスのURLからのサービスタイプ名：スキームは、「サービス：」プレフィックスが無傷で返されます。[7]サービスタイプ名の構文の詳細については、[8]を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.5.4.2. Parameters",
      "section_title": true,
      "ja": "4.5.4.2. パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "HSLP"
    },
    {
      "indent": 9,
      "text": "The SLPHandle on which to search for types.",
      "ja": "タイプを検索するslphandle。"
    },
    {
      "indent": 6,
      "text": "pcNamingAuthority",
      "ja": "pcnamingauthority"
    },
    {
      "indent": 9,
      "text": "The naming authority to search. Use \"*\" for all naming authorities and the empty string, \"\", for the default naming authority.",
      "ja": "検索する命名権限。デフォルトの命名機関には、すべての命名当局と空の文字列「「空の文字列」に「*」を使用します。"
    },
    {
      "indent": 6,
      "text": "pcScopeList",
      "ja": "PCSCOPELIST"
    },
    {
      "indent": 9,
      "text": "A pointer to a char containing comma separated list of scope names to search for service types. May not be the empty string, \"\".",
      "ja": "サービスタイプを検索するために、スコープ名の分離されたコンマを含むCharへのポインター。空の文字列ではないかもしれません」。"
    },
    {
      "indent": 6,
      "text": "callback",
      "ja": "折り返し電話コールバック"
    },
    {
      "indent": 9,
      "text": "A callback function through which the results of the operation are reported.",
      "ja": "操作の結果が報告されるコールバック関数。"
    },
    {
      "indent": 6,
      "text": "pvCookie",
      "ja": "pvcookie"
    },
    {
      "indent": 9,
      "text": "Memory passed to the callback code from the client. May be NULL.",
      "ja": "メモリは、クライアントからコールバックコードに渡されました。ヌルかもしれません。"
    },
    {
      "indent": 0,
      "text": "4.5.4.3. Returns",
      "section_title": true,
      "ja": "4.5.4.3. 戻り値"
    },
    {
      "indent": 3,
      "text": "If an error occurs in starting the operation, one of the SLPError codes is returned.",
      "ja": "操作の開始時にエラーが発生した場合、Slperrorコードの1つが返されます。"
    },
    {
      "indent": 0,
      "text": "4.5.5. SLPFindSrvs",
      "section_title": true,
      "ja": "4.5.5. slpfindsrvs"
    },
    {
      "indent": 0,
      "text": "4.5.5.1. Synopsis",
      "section_title": true,
      "ja": "4.5.5.1. 概要"
    },
    {
      "indent": 3,
      "text": "SLPError SLPFindSrvs(SLPHandle hSLP, const char *pcServiceType, const char *pcScopeList, const char *pcSearchFilter, SLPSrvURLCallback callback, void *pvCookie);",
      "ja": "slperror slpfindsrvs（slphandle hslp、const char *pcservicetype、const char *pcscopelist、const char *pcsearchfilter、slpsrvurlcallback callback、void *pvcookie）;"
    },
    {
      "indent": 0,
      "text": "4.5.5.2. Description",
      "section_title": true,
      "ja": "4.5.5.2. 説明"
    },
    {
      "indent": 3,
      "text": "Issue the query for services on the language specific SLPHandle and return the results through the callback. The parameters determine the results",
      "ja": "言語固有のslphandleでサービスのクエリを発行し、コールバックを介して結果を返します。パラメーターが結果を決定します"
    },
    {
      "indent": 0,
      "text": "4.5.5.3. Parameters",
      "section_title": true,
      "ja": "4.5.5.3. パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "HSLP"
    },
    {
      "indent": 9,
      "text": "The language specific SLPHandle on which to search for services.",
      "ja": "サービスを検索するための言語固有のSlphandle。"
    },
    {
      "indent": 6,
      "text": "pcServiceType",
      "ja": "PCServiceType"
    },
    {
      "indent": 9,
      "text": "The Service Type String, including authority string if any, for the request, such as can be discovered using SLPSrvTypes(). This could be, for example \"service:printer:lpr\" or \"service:nfs\". May not be the empty string.",
      "ja": "slpsrvtypes（）を使用して検出できるなど、リクエストに対して、authority stringがある場合は、局の文字列を含むサービスタイプの文字列。これは、たとえば「サービス：プリンター：LPR」または「サービス：NFS」などです。空の文字列ではないかもしれません。"
    },
    {
      "indent": 6,
      "text": "pcScopeList",
      "ja": "PCSCOPELIST"
    },
    {
      "indent": 9,
      "text": "A pointer to a char containing comma separated list of scope names. May not be the empty string, \"\".",
      "ja": "スコープ名の分離されたコンマを含む文字へのポインター。空の文字列ではないかもしれません」。"
    },
    {
      "indent": 6,
      "text": "pcSearchFilter",
      "ja": "PCSearchFilter"
    },
    {
      "indent": 9,
      "text": "A query formulated of attribute pattern matching expressions in the form of a LDAPv3 Search Filter, see [4]. If this filter is empty, i.e. \"\", all services of the requested type in the specified scopes are returned.",
      "ja": "LDAPV3検索フィルターの形で式を一致させる属性パターンの式の定式化されたクエリ、[4]を参照してください。このフィルターが空になっている場合、つまり「」、指定されたスコープの要求されたタイプのすべてのサービスが返されます。"
    },
    {
      "indent": 6,
      "text": "callback",
      "ja": "折り返し電話コールバック"
    },
    {
      "indent": 9,
      "text": "A callback function through which the results of the operation are reported.",
      "ja": "操作の結果が報告されるコールバック関数。"
    },
    {
      "indent": 6,
      "text": "pvCookie",
      "ja": "pvcookie"
    },
    {
      "indent": 9,
      "text": "Memory passed to the callback code from the client. May be NULL.",
      "ja": "メモリは、クライアントからコールバックコードに渡されました。ヌルかもしれません。"
    },
    {
      "indent": 0,
      "text": "4.5.5.4. Returns",
      "section_title": true,
      "ja": "4.5.5.4. 戻り値"
    },
    {
      "indent": 3,
      "text": "If an error occurs in starting the operation, one of the SLPError codes is returned.",
      "ja": "操作の開始時にエラーが発生した場合、Slperrorコードの1つが返されます。"
    },
    {
      "indent": 0,
      "text": "4.5.6. SLPFindAttrs",
      "section_title": true,
      "ja": "4.5.6. slpfindattrs"
    },
    {
      "indent": 0,
      "text": "4.5.6.1. Synopsis",
      "section_title": true,
      "ja": "4.5.6.1. 概要"
    },
    {
      "indent": 3,
      "text": "SLPError SLPFindAttrs(SLPHandle hSLP, const char *pcURLOrServiceType, const char *pcScopeList, const char *pcAttrIds, SLPAttrCallback callback, void *pvCookie);",
      "ja": "slperror slpfindattrs（slphandle hslp、const char *pcurlorservicetype、const char *pcscopelist、const char *pcattrids、slpattrcallback callback、void *pvcookie）;"
    },
    {
      "indent": 0,
      "text": "4.5.6.2. Description",
      "section_title": true,
      "ja": "4.5.6.2. 説明"
    },
    {
      "indent": 3,
      "text": "This function returns service attributes matching the attribute ids for the indicated service URL or service type. If pcURLOrServiceType is a service URL, the attribute information returned is for that particular advertisement in the language locale of the SLPHandle.",
      "ja": "この関数は、指定されたサービスURLまたはサービスタイプの属性IDを一致させるサービス属性を返します。PCURLORSERVICETYPEがサービスURLである場合、返される属性情報は、SLPHANDLEの言語ロケールの特定の広告のものです。"
    },
    {
      "indent": 3,
      "text": "If pcURLOrServiceType is a service type name (including naming authority if any), then the attributes for all advertisements of that service type are returned regardless of the language of registration. Results are returned through the callback.",
      "ja": "PCURLORSERVICETYPEがサービスタイプ名（もしあれば命名当局を含む）である場合、そのサービスタイプのすべての広告の属性は、登録の言語に関係なく返されます。結果はコールバックから返されます。"
    },
    {
      "indent": 3,
      "text": "The result is filtered with an SLP attribute request filter string parameter, the syntax of which is described in [7]. If the filter string is the empty string, i.e. \"\", all attributes are returned.",
      "ja": "結果は、SLP属性要求フィルター文字列パラメーターでフィルタリングされ、その構文は[7]で説明されています。フィルター文字列が空の文字列、つまり \"\"である場合、すべての属性が返されます。"
    },
    {
      "indent": 0,
      "text": "4.5.6.3. Parameters",
      "section_title": true,
      "ja": "4.5.6.3. パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "HSLP"
    },
    {
      "indent": 9,
      "text": "The language specific SLPHandle on which to search for attributes.",
      "ja": "属性を検索するための言語固有のslphandle。"
    },
    {
      "indent": 6,
      "text": "pcURLOrServiceType",
      "ja": "pcurlorserviceType"
    },
    {
      "indent": 9,
      "text": "The service URL or service type. See [7] for URL and service type syntax. May not be the empty string.",
      "ja": "サービスURLまたはサービスタイプ。URLおよびサービスタイプの構文については[7]を参照してください。空の文字列ではないかもしれません。"
    },
    {
      "indent": 6,
      "text": "pcScopeList",
      "ja": "PCSCOPELIST"
    },
    {
      "indent": 9,
      "text": "A pointer to a char containing a comma separated list of scope names. May not be the empty string, \"\".",
      "ja": "スコープ名のコンマ分離リストを含む文字へのポインター。空の文字列ではないかもしれません」。"
    },
    {
      "indent": 6,
      "text": "pcAttrIds",
      "ja": "pcattrids"
    },
    {
      "indent": 9,
      "text": "The filter string indicating which attribute values to return. Use empty string, \"\", to indicate all values. Wildcards matching all attribute ids having a particular prefix or suffix are also possible. See [7] for the exact format of the filter string.",
      "ja": "どの属性値を返すかを示すフィルター文字列。空の文字列 \"\"を使用して、すべての値を示します。特定のプレフィックスまたは接尾辞を持つすべての属性IDを一致させるワイルドカードも可能です。フィルター文字列の正確な形式については、[7]を参照してください。"
    },
    {
      "indent": 6,
      "text": "callback",
      "ja": "折り返し電話コールバック"
    },
    {
      "indent": 9,
      "text": "A callback function through which the results of the operation are reported.",
      "ja": "操作の結果が報告されるコールバック関数。"
    },
    {
      "indent": 6,
      "text": "pvCookie",
      "ja": "pvcookie"
    },
    {
      "indent": 9,
      "text": "Memory passed to the callback code from the client. May be NULL.",
      "ja": "メモリは、クライアントからコールバックコードに渡されました。ヌルかもしれません。"
    },
    {
      "indent": 0,
      "text": "4.5.6.4. Returns",
      "section_title": true,
      "ja": "4.5.6.4. 戻り値"
    },
    {
      "indent": 3,
      "text": "If an error occurs in starting the operation, one of the SLPError codes is returned.",
      "ja": "操作の開始時にエラーが発生した場合、Slperrorコードの1つが返されます。"
    },
    {
      "indent": 0,
      "text": "4.6. Miscellaneous Functions",
      "section_title": true,
      "ja": "4.6. その他の機能"
    },
    {
      "indent": 0,
      "text": "4.6.1. SLPGetRefreshInterval",
      "section_title": true,
      "ja": "4.6.1. slpgetrefreshinterval"
    },
    {
      "indent": 0,
      "text": "4.6.1.1. Synopsis",
      "section_title": true,
      "ja": "4.6.1.1. 概要"
    },
    {
      "indent": 3,
      "text": "unsigned short SLPGetRefreshInterval();",
      "ja": "unsigned short slpgetrefreshinterval（）;"
    },
    {
      "indent": 0,
      "text": "4.6.1.2. Description",
      "section_title": true,
      "ja": "4.6.1.2. 説明"
    },
    {
      "indent": 3,
      "text": "Returns the maximum across all DAs of the min-refresh-interval attribute. This value satisfies the advertised refresh interval bounds for all DAs, and, if used by the SA, assures that no refresh registration will be rejected. If no DA advertises a min-refresh-interval attribute, a value of 0 is returned.",
      "ja": "Min-Refresh-Interval属性のすべてのDASにわたって最大値を返します。この値は、すべてのDAの広告された更新間隔の境界を満たし、SAが使用する場合、更新登録が拒否されないことを保証します。DAが最小限のインターバル属性を宣伝していない場合、0の値が返されます。"
    },
    {
      "indent": 0,
      "text": "4.6.1.3. Returns",
      "section_title": true,
      "ja": "4.6.1.3. 戻り値"
    },
    {
      "indent": 3,
      "text": "If no error, the maximum refresh interval value allowed by all DAs (a positive integer). If no DA advertises a min-refresh-interval attribute, returns 0. If an error occurs, returns an SLP error code.",
      "ja": "エラーがない場合、すべてのDAS（正の整数）で許可される最大更新間隔値。DAがない場合は、Min-Refresh-Interval属性を宣伝する場合、0を返します。エラーが発生した場合、SLPエラーコードを返します。"
    },
    {
      "indent": 0,
      "text": "4.6.2. SLPFindScopes",
      "section_title": true,
      "ja": "4.6.2. slpfindscopes"
    },
    {
      "indent": 0,
      "text": "4.6.2.1. Synopsis",
      "section_title": true,
      "ja": "4.6.2.1. 概要"
    },
    {
      "indent": 3,
      "text": "SLPError SLPFindScopes(SLPHandle hSLP,\n                       char** ppcScopeList);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.6.2.2. Description",
      "section_title": true,
      "ja": "4.6.2.2. 説明"
    },
    {
      "indent": 3,
      "text": "Sets ppcScopeList parameter to a pointer to a comma separated list including all available scope values. The list of scopes comes from a variety of sources: the configuration file's net.slp.useScopes property, unicast to DAs on the net.slp.DAAddresses property, DHCP, or through the DA discovery process. If there is any order to the scopes, preferred scopes are listed before less desirable scopes. There is always at least one name in the list, the default scope, \"DEFAULT\".",
      "ja": "PPCSCOPELISTパラメーターを、利用可能なすべてのスコープ値を含むコンマ分離リストへのポインタに設定します。スコープのリストは、構成ファイルのnet.slp.usescopesプロパティ、net.slp.daaddressesプロパティ、dhcp、またはda discoveryプロセスを通じて、さまざまなソースからのものです。スコープに順序がある場合、望ましいスコープが望ましくないスコープの前にリストされます。リストには常に少なくとも1つの名前があります。デフォルトスコープ「デフォルト」です。"
    },
    {
      "indent": 0,
      "text": "4.6.2.3. Parameters",
      "section_title": true,
      "ja": "4.6.2.3. パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "HSLP"
    },
    {
      "indent": 9,
      "text": "The SLPHandle on which to search for scopes.",
      "ja": "スコープを検索するslphandle。"
    },
    {
      "indent": 6,
      "text": "ppcScopeList",
      "ja": "PPCSCOPELIST"
    },
    {
      "indent": 9,
      "text": "A pointer to char pointer into which the buffer pointer is placed upon return. The buffer is null terminated. The memory should be freed by calling SLPFree().",
      "ja": "バッファーポインターが戻ってきたときに配置されるcharポインターへのポインター。バッファーは終了します。メモリは、slpfree（）を呼び出すことで解放する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.6.2.4. Returns",
      "section_title": true,
      "ja": "4.6.2.4. 戻り値"
    },
    {
      "indent": 3,
      "text": "If no error occurs, returns SLP_OK, otherwise, the appropriate error code.",
      "ja": "エラーが発生しない場合、SLP_OKを返します。それ以外の場合は、適切なエラーコードを返します。"
    },
    {
      "indent": 0,
      "text": "4.6.3. SLPParseSrvURL",
      "section_title": true,
      "ja": "4.6.3. slpparsesrvurl"
    },
    {
      "indent": 0,
      "text": "4.6.3.1. Synopsis",
      "section_title": true,
      "ja": "4.6.3.1. 概要"
    },
    {
      "indent": 3,
      "text": "SLPError SLPParseSrvURL(char *pcSrvURL\n                        SLPSrvURL** ppSrvURL);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.6.3.2. Description",
      "section_title": true,
      "ja": "4.6.3.2. 説明"
    },
    {
      "indent": 3,
      "text": "Parses the URL passed in as the argument into a service URL structure and returns it in the ppSrvURL pointer. If a parse error occurs, returns SLP_PARSE_ERROR. The input buffer pcSrvURL is destructively modified during the parse and used to fill in the fields of the return structure. The structure returned in ppSrvURL should be freed with SLPFreeURL(). If the URL has no service part, the s_pcSrvPart string is the empty string, \"\", i.e. not NULL. If pcSrvURL is not a service: URL, then the s_pcSrvType field in the returned data structure is the URL's scheme, which might not be the same as the service type under which the URL was registered. If the transport is IP, the s_pcTransport field is the empty string. If the transport is not IP or there is no port number, the s_iPort field is zero.",
      "ja": "対引数として渡されたURLをサービスURL構造に解析し、PPSRVURLポインターに返します。解析エラーが発生した場合、SLP_PARSE_ERRORを返します。入力バッファーPCSRVURLは、解析中に破壊的に変更され、リターン構造のフィールドを埋めるために使用されます。ppsrvurlで返される構造は、slpfreeurl（）で解放する必要があります。URLにサービスパーツがない場合、S_PCSRVPART文字列は空の文字列 \"\"、つまりnullではありません。PCSRVURLがサービスではない場合：URLでは、返されたデータ構造のS_PCSRVTYPEフィールドはURLのスキームであり、URLが登録されたサービスタイプと同じではない場合があります。トランスポートがIPの場合、S_PCTRANSPORTフィールドは空の文字列です。トランスポートがIPでない場合、またはポート番号がない場合、S_IPORTフィールドはゼロです。"
    },
    {
      "indent": 0,
      "text": "4.6.3.3. Parameters",
      "section_title": true,
      "ja": "4.6.3.3. パラメーター"
    },
    {
      "indent": 6,
      "text": "pcSrvURL",
      "ja": "pcsrvurl"
    },
    {
      "indent": 9,
      "text": "A pointer to a character buffer containing the null terminated URL string to parse. It is destructively modified to produce the output structure.",
      "ja": "null終端URL文字列を含む文字バッファーへのポインター。出力構造を生成するために破壊的に変更されています。"
    },
    {
      "indent": 6,
      "text": "ppSrvURL",
      "ja": "ppsrvurl"
    },
    {
      "indent": 9,
      "text": "A pointer to a pointer for the SLPSrvURL structure to receive the parsed URL. The memory should be freed by a call to SLPFree() when no longer needed.",
      "ja": "解析されたURLを受信するためのSLPSRVURL構造のポインターへのポインター。メモリは、不要になったときにSLPFREE（）への呼び出しによって解放される必要があります。"
    },
    {
      "indent": 0,
      "text": "4.6.3.4. Returns",
      "section_title": true,
      "ja": "4.6.3.4. 戻り値"
    },
    {
      "indent": 3,
      "text": "If no error occurs, the return value is SLP_OK. Otherwise, the appropriate error code is returned.",
      "ja": "エラーが発生しない場合、返品値はSLP_OKです。それ以外の場合、適切なエラーコードが返されます。"
    },
    {
      "indent": 0,
      "text": "4.6.4. SLPEscape",
      "section_title": true,
      "ja": "4.6.4. slpescape"
    },
    {
      "indent": 0,
      "text": "4.6.4.1. Synopsis",
      "section_title": true,
      "ja": "4.6.4.1. 概要"
    },
    {
      "indent": 3,
      "text": "SLPError SLPEscape(const char* pcInbuf,\n                   char** ppcOutBuf,\n                   SLPBoolean isTag);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.6.4.2. Description",
      "section_title": true,
      "ja": "4.6.4.2. 説明"
    },
    {
      "indent": 3,
      "text": "Process the input string in pcInbuf and escape any SLP reserved characters. If the isTag parameter is SLPTrue, then look for bad tag characters and signal an error if any are found by returning the SLP_PARSE_ERROR code. The results are put into a buffer allocated by the API library and returned in the ppcOutBuf parameter. This buffer should be deallocated using SLPFree() when the memory is no longer needed.",
      "ja": "PCINBUFで入力文字列を処理し、SLP予約文字をエスケープします。ISTAGパラメーターがslptrueの場合は、悪いタグ文字を探して、slp_parse_errorコードを返すことで見つかった場合はエラーを信号します。結果は、APIライブラリによって割り当てられたバッファーに入れられ、PPCOUTBUFパラメーターに返されます。このバッファーは、メモリが不要になったときにslpfree（）を使用して扱う必要があります。"
    },
    {
      "indent": 0,
      "text": "4.6.4.3. Parameters",
      "section_title": true,
      "ja": "4.6.4.3. パラメーター"
    },
    {
      "indent": 6,
      "text": "pcInbuf",
      "ja": "pcinbuf"
    },
    {
      "indent": 9,
      "text": "Pointer to he input buffer to process for escape characters.",
      "ja": "入力バッファーへのポインタは、脱出文字を処理します。"
    },
    {
      "indent": 6,
      "text": "ppcOutBuf",
      "ja": "ppcoutbuf"
    },
    {
      "indent": 9,
      "text": "Pointer to a pointer for the output buffer with the SLP reserved characters escaped. Must be freed using SLPFree() when the memory is no longer needed.",
      "ja": "SLP予約文字が逃げた出力バッファーのポインターへのポインター。メモリが不要になった場合は、slpfree（）を使用して解放する必要があります。"
    },
    {
      "indent": 6,
      "text": "isTag",
      "ja": "ISTAG"
    },
    {
      "indent": 9,
      "text": "When true, the input buffer is checked for bad tag characters.",
      "ja": "Trueの場合、入力バッファーに悪いタグ文字が確認されます。"
    },
    {
      "indent": 0,
      "text": "4.6.4.4. Returns",
      "section_title": true,
      "ja": "4.6.4.4. 戻り値"
    },
    {
      "indent": 3,
      "text": "Return SLP_PARSE_ERROR if any characters are bad tag characters and the isTag flag is true, otherwise SLP_OK, or the appropriate error code if another error occurs.",
      "ja": "SLP_PARSE_ERRORを返す文字が悪いタグ文字であり、ISTAGフラグがtrue、そうでなければSLP_OK、または別のエラーが発生した場合は適切なエラーコードを返します。"
    },
    {
      "indent": 0,
      "text": "4.6.5. SLPUnescape",
      "section_title": true,
      "ja": "4.6.5. slpunescape"
    },
    {
      "indent": 0,
      "text": "4.6.5.1. Synopsis",
      "section_title": true,
      "ja": "4.6.5.1. 概要"
    },
    {
      "indent": 3,
      "text": "SLPError SLPUnescape(const char* pcInbuf,\n                     char** ppcOutBuf,\n                     SLPBoolean isTag);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.6.5.2. Description",
      "section_title": true,
      "ja": "4.6.5.2. 説明"
    },
    {
      "indent": 3,
      "text": "Process the input string in pcInbuf and unescape any SLP reserved characters. If the isTag parameter is SLPTrue, then look for bad tag characters and signal an error if any are found with the SLP_PARSE_ERROR code. No transformation is performed if the input string is an opaque. The results are put into a buffer allocated by the API library and returned in the ppcOutBuf parameter. This buffer should be deallocated using SLPFree() when the memory is no longer needed.",
      "ja": "PCINBUFの入力文字列を処理し、SLP予約文字を除外します。ISTAGパラメーターがslptrueの場合、悪いタグ文字を探して、slp_parse_errorコードで見つかった場合はエラーを信号します。入力文字列が不透明である場合、変換は実行されません。結果は、APIライブラリによって割り当てられたバッファーに入れられ、PPCOUTBUFパラメーターに返されます。このバッファーは、メモリが不要になったときにslpfree（）を使用して扱う必要があります。"
    },
    {
      "indent": 0,
      "text": "4.6.5.3. Parameters",
      "section_title": true,
      "ja": "4.6.5.3. パラメーター"
    },
    {
      "indent": 6,
      "text": "pcInbuf",
      "ja": "pcinbuf"
    },
    {
      "indent": 9,
      "text": "Pointer to he input buffer to process for escape characters.",
      "ja": "入力バッファーへのポインタは、脱出文字を処理します。"
    },
    {
      "indent": 6,
      "text": "ppcOutBuf",
      "ja": "ppcoutbuf"
    },
    {
      "indent": 9,
      "text": "Pointer to a pointer for the output buffer with the SLP reserved characters escaped. Must be freed using SLPFree() when the memory is no longer needed.",
      "ja": "SLP予約文字が逃げた出力バッファーのポインターへのポインター。メモリが不要になった場合は、slpfree（）を使用して解放する必要があります。"
    },
    {
      "indent": 6,
      "text": "isTag",
      "ja": "ISTAG"
    },
    {
      "indent": 9,
      "text": "When true, the input buffer is checked for bad tag characters.",
      "ja": "Trueの場合、入力バッファーに悪いタグ文字が確認されます。"
    },
    {
      "indent": 0,
      "text": "4.6.5.4. Returns",
      "section_title": true,
      "ja": "4.6.5.4. 戻り値"
    },
    {
      "indent": 3,
      "text": "Return SLP_PARSE_ERROR if any characters are bad tag characters and the isTag flag is true, otherwise SLP_OK, or the appropriate error code if another error occurs.",
      "ja": "SLP_PARSE_ERRORを返す文字が悪いタグ文字であり、ISTAGフラグがtrue、そうでなければSLP_OK、または別のエラーが発生した場合は適切なエラーコードを返します。"
    },
    {
      "indent": 0,
      "text": "4.6.6. SLPFree",
      "section_title": true,
      "ja": "4.6.6. slpfree"
    },
    {
      "indent": 0,
      "text": "4.6.6.1. Synopsis",
      "section_title": true,
      "ja": "4.6.6.1. 概要"
    },
    {
      "indent": 6,
      "text": "void SLPFree(void* pvMem);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.6.6.2. Description",
      "section_title": true,
      "ja": "4.6.6.2. 説明"
    },
    {
      "indent": 3,
      "text": "Frees memory returned from SLPParseSrvURL(), SLPFindScopes(), SLPEscape(), and SLPUnescape().",
      "ja": "slpparsesrvurl（）、slpfindscopes（）、slpescape（）、およびslpunescape（）から返されたメモリを解放します。"
    },
    {
      "indent": 0,
      "text": "4.6.6.3. Parameters",
      "section_title": true,
      "ja": "4.6.6.3. パラメーター"
    },
    {
      "indent": 6,
      "text": "pvMem",
      "ja": "pvmem"
    },
    {
      "indent": 9,
      "text": "A pointer to the storage allocated by the SLPParseSrvURL(), SLPEscape(), SLPUnescape(), or SLPFindScopes() function. Ignored if NULL.",
      "ja": "slpparsesrvurl（）、slpescape（）、slpunescape（）、またはslpfindscopes（）関数によって割り当てられたストレージへのポインター。nullの場合は無視されます。"
    },
    {
      "indent": 0,
      "text": "4.6.7. SLPGetProperty",
      "section_title": true,
      "ja": "4.6.7. SlpgetProperty"
    },
    {
      "indent": 0,
      "text": "4.6.7.1. Synopsis",
      "section_title": true,
      "ja": "4.6.7.1. 概要"
    },
    {
      "indent": 3,
      "text": "const char* SLPGetProperty(const char* pcName);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.6.7.2. Description",
      "section_title": true,
      "ja": "4.6.7.2. 説明"
    },
    {
      "indent": 3,
      "text": "Returns the value of the corresponding SLP property name. The returned string is owned by the library and MUST NOT be freed.",
      "ja": "対応するSLPプロパティ名の値を返します。返された文字列は図書館が所有しており、解放されてはなりません。"
    },
    {
      "indent": 0,
      "text": "4.6.7.3. Parameters",
      "section_title": true,
      "ja": "4.6.7.3. パラメーター"
    },
    {
      "indent": 6,
      "text": "pcName",
      "ja": "pcname"
    },
    {
      "indent": 9,
      "text": "Null terminated string with the property name, from Section 2.1.",
      "ja": "セクション2.1から、プロパティ名で文字列を終了しました。"
    },
    {
      "indent": 0,
      "text": "4.6.7.4. Returns",
      "section_title": true,
      "ja": "4.6.7.4. 戻り値"
    },
    {
      "indent": 3,
      "text": "If no error, returns a pointer to a character buffer containing the property value. If the property was not set, returns the default value. If an error occurs, returns NULL. The returned string MUST NOT be freed.",
      "ja": "エラーがない場合は、プロパティ値を含む文字バッファーへのポインターを返します。プロパティが設定されていない場合は、デフォルト値を返します。エラーが発生した場合、nullを返します。返された文字列を解放してはなりません。"
    },
    {
      "indent": 0,
      "text": "4.6.8. SLPSetProperty",
      "section_title": true,
      "ja": "4.6.8. slpsetProperty"
    },
    {
      "indent": 0,
      "text": "4.6.8.1. Synopsis",
      "section_title": true,
      "ja": "4.6.8.1. 概要"
    },
    {
      "indent": 6,
      "text": "void SLPSetProperty(const char *pcName,\n                    const char *pcValue);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.6.8.2. Description",
      "section_title": true,
      "ja": "4.6.8.2. 説明"
    },
    {
      "indent": 3,
      "text": "Sets the value of the SLP property to the new value. The pcValue parameter should be the property value as a string.",
      "ja": "SLPプロパティの値を新しい値に設定します。PCValueパラメーターは、文字列としてのプロパティ値である必要があります。"
    },
    {
      "indent": 0,
      "text": "4.6.8.3. Parameters",
      "section_title": true,
      "ja": "4.6.8.3. パラメーター"
    },
    {
      "indent": 6,
      "text": "pcName",
      "ja": "pcname"
    },
    {
      "indent": 9,
      "text": "Null terminated string with the property name, from Section 2.1.",
      "ja": "セクション2.1から、プロパティ名で文字列を終了しました。"
    },
    {
      "indent": 6,
      "text": "pcValue",
      "ja": "PCValue"
    },
    {
      "indent": 9,
      "text": "Null terminated string with the property value, in UTF-8 character encoding.",
      "ja": "nullは、UTF-8文字エンコードで、プロパティ値を持つ文字列を終了しました。"
    },
    {
      "indent": 0,
      "text": "4.7. Implementation Notes",
      "section_title": true,
      "ja": "4.7. 実装ノート"
    },
    {
      "indent": 0,
      "text": "4.7.1. Refreshing Registrations",
      "section_title": true,
      "ja": "4.7.1. リフレッシュ登録"
    },
    {
      "indent": 3,
      "text": "Clients indicate that they want URLs to be automatically refreshed by setting the usLifetime parameter in the SLPReg() function call to SLP_LIFETIME_MAXIMUM. This will cause the API implementation to refresh the URL before it times out. Although using SLP_LIFETIME_MAXIMUM to designate automatic reregistration means that a transient URL can't be registered for the maximum lifetime, little hardship is likely to occur, since service URL lifetimes are measured in seconds and the client can simply use a lifetime of SLP_LIFETIME_MAXIMUM - 1 if a transient URL near the maximum lifetime is desired. API implementations MUST provide this facility.",
      "ja": "クライアントは、slp_lifetime_maximumにslpreg（）関数呼び出しにuslifetimeパラメーターを設定することにより、URLを自動的に更新したいことを示しています。これにより、APIの実装は、URLがタイムアウトする前に更新されます。SLP_LIFETIME_MAXIMUMを使用して自動再登録を指定することは、一時的なURLを最大寿命に登録できないことを意味しますが、サービスURLの寿命は数秒で測定され、クライアントはSLP_LIFETIME_MAXIMUM -1の寿命を使用することができるため、ほとんど困難は発生しません。最大寿命の近くの一時的なURLが望まれます。APIの実装は、この機能を提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.7.2. Syntax for String Parameters",
      "section_title": true,
      "ja": "4.7.2. 文字列パラメーターの構文"
    },
    {
      "indent": 3,
      "text": "Query strings, attribute registration lists, attribute deregistration lists, scope lists, and attribute selection lists follow the syntax described in [7] for the appropriate requests. The API directly reflects the strings passed in from clients into protocol requests, and directly reflects out strings returned from protocol replies to clients. As a consequence, clients are responsible for formatting request strings, including escaping and converting opaque values to escaped byte encoded strings. Similarly, on output, clients are required to unescape strings and convert escaped string encoded opaques to binary. The functions SLPEscape() and SLPUnescape() can be used for escaping SLP reserved characters, but perform no opaque processing.",
      "ja": "クエリ文字列、属性登録リスト、属性控除リスト、スコープリスト、および属性選択リストは、適切な要求について[7]で説明した構文に従います。APIは、クライアントからプロトコル要求に渡された文字列を直接反映し、プロトコルの返信からクライアントへの返された文字列を直接反映します。結果として、クライアントは、脱出したり、不透明な値を逃げたバイトエンコードされた文字列に変換するなど、要求文字列のフォーマットを担当します。同様に、出力では、クライアントは文字列を無効にし、エスケープされた文字列エンコードされたオパークをバイナリに変換する必要があります。関数slpescape（）およびslpunescape（）は、SLP予約文字の脱出に使用できますが、不透明な処理は実行されません。"
    },
    {
      "indent": 3,
      "text": "Opaque values consist of a character buffer containing a UTF-8- encoded string, the first characters of which are the nonUTF-8 encoding '\\ff'. Subsequent characters are the escaped values for the original bytes in the opaque. The escape convention is relatively simple. An escape consists of a backslash followed by the two hexadecimal digits encoding the byte. An example is '\\2c' for the byte 0x2c. Clients handle opaque processing themselves, since the algorithm is relatively simple and uniform.",
      "ja": "不透明値は、UTF-8エンコードされた文字列を含む文字バッファーで構成されており、その最初の文字はnonutf-8エンコード「\\ ff」です。後続の文字は、不透明の元のバイトの逃げられた値です。脱出条約は比較的簡単です。エスケープは、バックスラッシュに続いて、バイトをエンコードする2つの16進数桁が続きます。例は、バイト0x2cの「\\ 2c」です。アルゴリズムは比較的単純で均一であるため、クライアントは不透明な処理を処理します。"
    },
    {
      "indent": 0,
      "text": "4.7.3. Client Side Syntax Checking",
      "section_title": true,
      "ja": "4.7.3. クライアント側の構文チェック"
    },
    {
      "indent": 3,
      "text": "Client side API implementations may do syntax checking of scope names, naming authority names, and service type names, but are not required to do so. Since the C API is designed to be a thin layer over the protocol, some low memory SA implementations may find extensive syntax checking on the client side to be burdensome. If syntax checking uncovers an error in a parameter, the SLP_PARAMETER_BAD error must be returned. If any parameter is NULL and is required to be nonNULL, SLP_PARAMETER_BAD is returned.",
      "ja": "クライアント側のAPI実装は、スコープ名の構文チェック、命名当局名、およびサービスタイプ名を実行する場合がありますが、そうする必要はありません。C APIはプロトコル上の薄い層になるように設計されているため、一部の低メモリSA実装では、クライアント側の広範な構文チェックが負担になることがあります。構文チェックがパラメーターのエラーを明らかにする場合、slp_parameter_badエラーを返す必要があります。任意のパラメーターがnullであり、非ヌルである必要がある場合、slp_parameter_badが返されます。"
    },
    {
      "indent": 0,
      "text": "4.7.4. System Properties",
      "section_title": true,
      "ja": "4.7.4. システムプロパティ"
    },
    {
      "indent": 3,
      "text": "The system properties established in the configuration file are accessible through the SLPGetProperty() and SLPSetProperty() functions. The SLPSetProperty() function only modifies properties in the running process, not in the configuration file. Properties are global to the process, affecting all threads and all handles created with SLPOpen. Errors are checked when the property is used and, as with parsing the configuration file, are logged. Program execution continues without interruption by substituting the default for the erroneous parameter. With the exception of net.slp.locale, net.slp.typeHint, and net.slp.maxResults, clients of the API should rarely be required to override these properties, since they reflect properties of the SLP network that are not of concern to individual agents. If changes are required, system administrators should modify the configuration file.",
      "ja": "構成ファイルに確立されたシステムプロパティは、slpgetProperty（）およびslpsetProperty（）関数を介してアクセス可能です。slpsetProperty（）関数は、構成ファイルではなく、実行プロセスのプロパティのみを変更します。プロパティはプロセスにとってグローバルであり、すべてのスレッドとSLPOPENで作成されたすべてのハンドルに影響を与えます。プロパティが使用されるときにエラーがチェックされ、構成ファイルを解析する場合と同様に、ログが記録されます。プログラムの実行は、誤ったパラメーターのデフォルトを置き換えることにより、中断することなく継続します。net.slp.locale、net.slp.typehint、およびnet.slp.maxresultsを除き、APIのクライアントは、これらのプロパティをオーバーライドするためにめったに必要ありません。個々のエージェント。変更が必要な場合、システム管理者は構成ファイルを変更する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.7.5. Memory Management",
      "section_title": true,
      "ja": "4.7.5. メモリ管理"
    },
    {
      "indent": 3,
      "text": "The only API functions returning memory specifically requiring deallocation on the part of the client are SLPParseSrvURL(), SLPFindScopes(), SLPEscape(), and SLPUnescape(). This memory should be freed using SLPFree() when no longer needed. Character strings returned via the SLPGetProperty() function should NOT be freed, they are owned by the SLP library.",
      "ja": "クライアントの側での取引を特に必要とするメモリを返す唯一のAPI関数は、slpparsesrvurl（）、slpfindscopes（）、slpescape（）、およびslpunescape（）です。このメモリは、不要になったときにslpfree（）を使用して解放する必要があります。slpgetProperty（）関数を介して返される文字文字列は解放されるべきではなく、SLPライブラリが所有しています。"
    },
    {
      "indent": 3,
      "text": "Memory passed to callbacks belongs to the library and MUST NOT be retained by the client code. Otherwise, crashes are possible. Clients are required to copy data out of the callback parameters. No other use of the parameter memory in callback parameters is allowed.",
      "ja": "コールバックに渡されたメモリはライブラリに属し、クライアントコードによって保持されてはなりません。それ以外の場合、クラッシュが可能です。クライアントは、コールバックパラメーターからデータをコピーする必要があります。コールバックパラメーターでのパラメーターメモリの他の使用は許可されていません。"
    },
    {
      "indent": 0,
      "text": "4.7.6. Asynchronous and Incremental Return Semantics",
      "section_title": true,
      "ja": "4.7.6. 非同期および増分リターンセマンティクス"
    },
    {
      "indent": 3,
      "text": "If a handle parameter to an API function was opened asynchronously, API function calls on the handle check the other parameters, open the appropriate operation and return immediately. In an error occurs in the process of starting the operation, an error code is returned. If the handle parameter was opened synchronously, the API function call blocks until all results are available, and returns only after the results are reported through the callback function. The return code indicates whether any errors occurred both starting and during the operation.",
      "ja": "API関数へのハンドルパラメーターが非同期に開かれた場合、API関数はハンドルに呼び出し、他のパラメーターをチェックし、適切な操作を開き、すぐに戻ります。操作を開始するプロセスでエラーが発生すると、エラーコードが返されます。ハンドルパラメーターが同期的に開かれた場合、API関数はすべての結果が利用可能になるまでブロックを呼び出し、コールバック関数を介して結果が報告された後にのみ戻ります。戻りコードは、操作中と操作中にエラーが発生したかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "The callback function is called whenever the API library has results to report. The callback code is required to check the error code parameter before looking at the other parameters. If the error code is not SLP_OK, the other parameters may be invalid. The API library has the option of terminating any outstanding operation on which an error occurs. The callback code can similarly indicate that the operation should be terminated by passing back SLP_FALSE. Callback functions are not permitted to recursively call into the API on the same SLPHandle. If an attempt is made to recursively call into the API, the API function returns SLP_HANDLE_IN_USE. Prohibiting recursive callbacks on the same handle simplifies implementation of thread safe code, since locks held on the handle will not be in place during a second outcall on the handle. On the other hand, it means that handle creation should be fairly lightweight so a client program can easily support multiple outstanding calls.",
      "ja": "APIライブラリにレポートする結果がある場合はいつでも、コールバック関数が呼び出されます。コールバックコードは、他のパラメーターを調べる前にエラーコードパラメーターを確認するために必要です。エラーコードがSLP_OKでない場合、他のパラメーターが無効になる場合があります。APIライブラリには、エラーが発生する未解決の操作を終了するオプションがあります。コールバックコードも同様に、slp_falseを渡すことで操作を終了する必要があることを示します。コールバック関数は、同じSlphandleでAPIを再帰的に呼び出すことは許可されていません。APIを再帰的に呼び出す試みが行われた場合、API関数はslp_handle_in_useを返します。同じハンドルで再帰的なコールバックを禁止すると、ハンドルに保持されているロックがハンドルの2番目のアウトコール中には整っていないため、スレッドセーフコードの実装が簡素化されます。一方、それは、クライアントプログラムが複数の未解決の呼び出しを簡単にサポートできるため、ハンドル作成はかなり軽量である必要があることを意味します。"
    },
    {
      "indent": 3,
      "text": "The total number of results received can be controlled by setting the net.slp.maxResults parameter.",
      "ja": "受信した結果の総数は、net.slp.maxresultsパラメーターを設定することで制御できます。"
    },
    {
      "indent": 3,
      "text": "On the last call to a callback, whether asynchronous or synchronous, the status code passed to the callback has value SLP_LAST_CALL. There are four reasons why the call can terminate:",
      "ja": "非同期であろうと同期しているかどうかにかかわらず、コールバックへの最後の呼び出しで、コールバックに渡されたステータスコードには値のSLP_LAST_CALLがあります。コールが終了できる4つの理由があります。"
    },
    {
      "indent": 6,
      "text": "DA reply received",
      "ja": "DA返信を受け取った"
    },
    {
      "indent": 9,
      "text": "A reply from a DA has been received and therefore nothing more is expected.",
      "ja": "DAからの返信が受信されたため、これ以上予想されません。"
    },
    {
      "indent": 6,
      "text": "Multicast terminated",
      "ja": "マルチキャスト終了"
    },
    {
      "indent": 9,
      "text": "The multicast convergence time has elapsed and the API library multicast code is giving up.",
      "ja": "マルチキャストの収束時間が経過し、APIライブラリマルチキャストコードがあきらめています。"
    },
    {
      "indent": 6,
      "text": "Multicast null results",
      "ja": "マルチキャストヌルの結果"
    },
    {
      "indent": 9,
      "text": "Nothing new has been received during multicast for a while and the API library multicast code is giving up on that (as an optimization).",
      "ja": "しばらくの間、マルチキャスト中に新しいものは何も受け取られておらず、APIライブラリマルチキャストコードはそれをあきらめています（最適化として）。"
    },
    {
      "indent": 6,
      "text": "Maximum results",
      "ja": "最大結果"
    },
    {
      "indent": 9,
      "text": "The user has set the net.slp.maxResults property and that number of replies has been collected and returned",
      "ja": "ユーザーはnet.slp.maxresultsプロパティを設定しており、その回答数が収集されて返されました"
    },
    {
      "indent": 0,
      "text": "4.8. Example",
      "section_title": true,
      "ja": "4.8. 例"
    },
    {
      "indent": 3,
      "text": "This example illustrates how to discover a mailbox.",
      "ja": "この例は、メールボックスの発見方法を示しています。"
    },
    {
      "indent": 3,
      "text": "A POP3 server registers itself with the SLP framework. The attributes it registers are \"USER\", a list of all users whose mail is available through the POP3 server.",
      "ja": "POP3サーバーは、SLPフレームワークを使用して自分自身を登録します。ITレジスタの属性は「ユーザー」であり、POP3サーバーを介してメールが利用可能なすべてのユーザーのリストです。"
    },
    {
      "indent": 3,
      "text": "The POP3 server code is the following:",
      "ja": "POP3サーバーコードは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "SLPHandle slph; SLPRegReport errCallback = POPRegErrCallback;",
      "ja": "slphandle slph;slpregreport errcallback = popregerrcallback;"
    },
    {
      "indent": 3,
      "text": "/* Create an English SLPHandle, asynchronous processing. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "SLPError err = SLPOpen(\"en\", SLP_TRUE, &slph);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "if( err != SLP_OK ) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "/* Deal with error. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 3,
      "text": "/* Create the service: URL and attribute parameters. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const char* surl = \"service:pop3://mail.netsurf.de\"; /* the URL */\n   const char *pcAttrs = \"(user=zaphod,trillian,roger,marvin)\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Perform the registration. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "err = SLPReg(slph, surl, SLP_LIFETIME_DEFAULT, ppcAttrs, errCallback, NULL);",
      "ja": "err = slpreg（slph、surl、slp_lifetime_default、ppcattrs、errcallback、null）;"
    },
    {
      "indent": 3,
      "text": "if (err != SLP_OK ) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/*Deal with error.*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 3,
      "text": "The errCallback reports any errors:",
      "ja": "errcallbackはエラーを報告します。"
    },
    {
      "indent": 3,
      "text": "void POPRegErrCallback(SLPHandle hSLP, SLPError errCode, unsigned short usLifetime, void* pvCookie) {",
      "ja": "void popregerrcallback（slphandle hslp、slperror errcode、unsigned short uslifetime、void* pvcookie）{"
    },
    {
      "indent": 6,
      "text": "if( errCode != SLP_OK ) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "/* Report error through a dialog, message, etc. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 6,
      "text": "/*Use lifetime interval to update periodically. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 3,
      "text": "The POP3 client locates the server for the user with the following code:",
      "ja": "POP3クライアントは、次のコードを使用してユーザーのサーバーを見つけます。"
    },
    {
      "indent": 3,
      "text": "/*\n * The client calls SLPOpen(), exactly as above.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const char *pcSrvType   = \"service:pop3\"; /* the service type  */\nconst char *pcScopeList = \"default\";      /* the scope         */\nconst char *pcFilter    = \"(user=roger)\"; /* the search filter */\nSLPSrvURLCallback srvCallback =           /* the callback      */\n                                POPSrvURLCallback;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "err = SLPFindSrvs(slph, pcSrvType, pcScopeList, pcFilter, srvCallback, NULL);",
      "ja": "err = slpfindsrvs（slph、pcsrvtype、pcscopelist、pcfilter、srvcallback、null）;"
    },
    {
      "indent": 3,
      "text": "if( err != SLP_OK ) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Deal with error. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 3,
      "text": "Within the callback, the client code can use the returned POP service:",
      "ja": "コールバック内で、クライアントコードは返されたポップサービスを使用できます。"
    },
    {
      "indent": 2,
      "text": "SLPBoolean POPSrvURLCallback(SLPHandle hSLP, const char* pcSrvURL, unsigned short sLifetime, SLPError errCode, void* pvCookie) {",
      "ja": "slpboolean popsrvurlcallback（slphandle hslp、const char* pcsrvurl、unsigned short slifetime、slperror errcode、void* pvcookie）{"
    },
    {
      "indent": 5,
      "text": "if( errCode != SLP_OK ) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "/* Deal with error. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 5,
      "text": "SLPSrvURL* pSrvURL;",
      "ja": "slpsrvurl* psrvurl;"
    },
    {
      "indent": 5,
      "text": "errCode = SLPParseSrvURL(pcSrvURL, &pSrvURL);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "if (err != SLP_OK ) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Deal with error. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "} else {",
      "ja": "} それ以外 {"
    },
    {
      "indent": 7,
      "text": "/* get the server's address */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "struct hostent *phe = gethostbyname(pSrvURL.s_pcHost);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* use hostname in pSrvURL to connect to the POP3 server\n *     . . .\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  SLPFreeSrvURL((void*)pSrvURL);  /* Free the pSrvURL storage */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "return SLP_FALSE;                 /* Done! */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 3,
      "text": "A client that wanted to discover all the users receiving mail at the server uses with the following query:",
      "ja": "サーバーでメールを受信しているすべてのユーザーが次のクエリを使用して使用したいクライアントを使用しました。"
    },
    {
      "indent": 3,
      "text": "/*\n * The client calls SLPOpen(), exactly as above. We assume the\n * service: URL was retrieved into surl.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const char *pcScopeList = \"default\";      /* the scope            */\nconst char *pcAttrFilter    = \"use\";      /* the attribute filter */\nSLPAttrCallback attrCallBack =            /* the callback         */\n                               POPUsersCallback",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "err = SLPFindAttrs(slph, surl, pcScopeList, pcAttrFilter, attrCallBack, NULL);",
      "ja": "err = slpfindattrs（slph、surl、pcscopelist、pcattrfilter、attrcallback、null）;"
    },
    {
      "indent": 3,
      "text": "if( err != SLP_OK ) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "/* Deal with error. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 3,
      "text": "The callback processes the attributes:",
      "ja": "コールバックは属性を処理します："
    },
    {
      "indent": 3,
      "text": "SLPBoolean POPUsersCallback(const char* pcAttrList, SLPError errCode, void* pvCookie) {",
      "ja": "slpboolean popuserscallback（const char* pcattrlist、slperror errcode、void* pvcookie）{"
    },
    {
      "indent": 5,
      "text": "if( errCode != SLP_OK ) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Deal with error. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "} else {",
      "ja": "} それ以外 {"
    },
    {
      "indent": 7,
      "text": "/* Parse attributes. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 5,
      "text": "return SLP_FALSE;  /* Done! */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 0,
      "text": "5. Java Language Binding",
      "section_title": true,
      "ja": "5. Java言語バインディング"
    },
    {
      "indent": 0,
      "text": "5.1. Introduction",
      "section_title": true,
      "ja": "5.1. はじめに"
    },
    {
      "indent": 3,
      "text": "The Java API is designed to model the various SLP entities in classes and objects. APIs are provided for SA, UA, and service type template access capabilities. The ServiceLocationManager class contains methods that return instances of objects implementing SA and UA capability. Each of these is modeled in an interface. The Locator interface provides UA capability and the Advertiser interface provides SA capability. The TemplateRegistry abstract class contains methods that return objects for template introspection and attribute type checking. The ServiceURL, ServiceType, and ServiceLocationAttribute classes model the basic SLP concepts. A concrete subclass instance of TemplateRegistry is returned by a class method.",
      "ja": "Java APIは、クラスとオブジェクトのさまざまなSLPエンティティをモデル化するように設計されています。APIは、SA、UA、およびサービスタイプテンプレートアクセス機能に提供されます。ServicelocationManagerクラスには、SAおよびUA機能を実装するオブジェクトのインスタンスを返すメソッドが含まれています。これらはそれぞれインターフェイスでモデル化されています。ロケーターインターフェイスはUA機能を提供し、Advertiser InterfaceはSA機能を提供します。Templateregistry Abstractクラスには、テンプレートの内省と属性タイプチェックのオブジェクトを返すメソッドが含まれています。ServiceUrl、ServiceType、およびServicelocationAttributeクラスは、基本的なSLPの概念をモデル化します。Templateregistryの具体的なサブクラスインスタンスは、クラスメソッドによって返されます。"
    },
    {
      "indent": 3,
      "text": "All SLP classes and interfaces are located within a single package. The package name should begin with the name of the implementation and conclude with the suffix \"slp\". Thus, the name for a hypothetical implementation from the University of Michigan would look like:",
      "ja": "すべてのSLPクラスとインターフェイスは、単一のパッケージ内にあります。パッケージ名は、実装の名前で始まり、接尾辞「SLP」で終了する必要があります。したがって、ミシガン大学からの仮想的な実装の名前は次のようになります。"
    },
    {
      "indent": 29,
      "text": "edu.umich.slp",
      "ja": "edu.umich.slp"
    },
    {
      "indent": 3,
      "text": "This follows the Java convention of prepending the top level DNS domain name for the organization implementing the package onto the organization's name and using that as the package prefix.",
      "ja": "これは、組織の名前にパッケージを実装し、それをパッケージプレフィックスとして使用する組織のトップレベルDNSドメイン名を準備するJavaコンベンションに続きます。"
    },
    {
      "indent": 0,
      "text": "5.2. Exceptions and Errors",
      "section_title": true,
      "ja": "5.2. 例外とエラー"
    },
    {
      "indent": 3,
      "text": "Most parameters to API methods are required to be non-null. The API description indicates if a null parameter is acceptable, or if other restrictions constrain a parameter. When parameters are checked for validity (such as not being null) or their syntax is checked, an error results in the RuntimeException subclass IllegalArgumentException being thrown. Clients of the API are reminded that IllegalArgumentException, derived from RuntimeException, is unchecked by the compiler. Clients should thus be careful to include try/catch blocks for it if the relevant parameters could be erroneous.",
      "ja": "APIメソッドのほとんどのパラメーターは、非ヌルである必要があります。APIの説明は、nullパラメーターが許容できるかどうか、または他の制限がパラメーターを制限するかどうかを示します。パラメーターの有効性（nullではないなど）がチェックされたり、構文がチェックされたりすると、runtimeexceptionサブクラスIllegalargumentexceptionがスローされます。APIのクライアントは、runtimeexceptionから派生したIllegalargumentexceptionがコンパイラによってチェックされていないことを思い出させます。したがって、関連するパラメーターが誤っている可能性がある場合、クライアントはTry/Catchブロックをそのために含めるように注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "Standard Java practice is to encode every exceptional condition as a separate subclass of Exception. Because of the relatively high cost in code size of Exception subclasses, the API contains only a single Exception subclass with different conditions being determined by an integer error code property. A subset, appropriate to Java, of the error codes described in Section 3 are available as constants on the ServiceLocationException class. The subset excludes error codes such as MEMORY_ALLOC_FAILED.",
      "ja": "標準的なJavaの実践は、例外の別のサブクラスとして、すべての例外的な条件をエンコードすることです。例外サブクラスのコードサイズが比較的高いため、APIには、整数エラーコードプロパティによって決定される条件が異なる単一の例外サブクラスのみが含まれています。セクション3で説明されているエラーコードのJavaに適したサブセットは、ServicElocationExceptionクラスの定数として使用できます。サブセットは、memory_alloc_failedなどのエラーコードを除外します。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Class ServiceLocationException",
      "section_title": true,
      "ja": "5.2.1. クラスServiceLocationException"
    },
    {
      "indent": 0,
      "text": "5.2.1.1. Synopsis",
      "section_title": true,
      "ja": "5.2.1.1. 概要"
    },
    {
      "indent": 3,
      "text": "public class ServiceLocationException extends Exception",
      "ja": "パブリッククラスServicElocationExceptionは例外を拡張します"
    },
    {
      "indent": 0,
      "text": "5.2.1.2. Description",
      "section_title": true,
      "ja": "5.2.1.2. 説明"
    },
    {
      "indent": 3,
      "text": "The ServiceLocationException class is thrown by all methods when exceptional conditions occur in the SLP framework. The error code property determines the exact nature of the condition, and an optional message may provide more information.",
      "ja": "ServicelocationExceptionクラスは、SLPフレームワークで例外的な条件が発生した場合、すべての方法によってスローされます。エラーコードプロパティは条件の正確な性質を決定し、オプションのメッセージはより多くの情報を提供する場合があります。"
    },
    {
      "indent": 0,
      "text": "5.2.1.3. Fields",
      "section_title": true,
      "ja": "5.2.1.3. 田畑"
    },
    {
      "indent": 3,
      "text": "public static final short LANGUAGE_NOT_SUPPORTED = 1 public static final short PARSE_ERROR = 2 public static final short INVALID_REGISTRATION = 3 public static final short SCOPE_NOT_SUPPORTED = 4 public static final short AUTHENTICATION_ABSENT = 6 public static final short AUTHENTICATION_FAILED = 7 public static final short INVALID_UPDATE = 13 public static final short REFRESH_REJECTED = 15 public static final short NOT_IMPLEMENTED = 16 public static final short NETWORK_INIT_FAILED 17 public static final short NETWORK_TIMED_OUT = 18 public static final short NETWORK_ERROR = 19 public static final short INTERNAL_SYSTEM_ERROR = 20 public static final short TYPE_ERROR = 21 public static final short BUFFER_OVERFLOW = 22",
      "ja": "public static final short LANGUAGE_NOT_SUPPORTED = 1 public static final short PARSE_ERROR = 2 public static final short INVALID_REGISTRATION = 3 public static final short SCOPE_NOT_SUPPORTED = 4 public static final short AUTHENTICATION_ABSENT = 6 public static final short AUTHENTICATION_FAILED = 7 public static final short INVALID_UPDATE = 13 public静的最終短い短いrefresh_rejected = 15 public static final short not_implemented = 16 public static final short network_init_failed 17 public static final network_timed_out = 18 public static final short network_error = 19 public static internal_system_error = 20 public static final static fany final static fan短いbuffer_overflow = 22"
    },
    {
      "indent": 0,
      "text": "5.2.1.4. Instance Methods",
      "section_title": true,
      "ja": "5.2.1.4. インスタンスメソッド"
    },
    {
      "indent": 3,
      "text": "public short getErrorCode()",
      "ja": "public short getErrorCode（）"
    },
    {
      "indent": 3,
      "text": "Return the error code. The error code takes on one of the static field values.",
      "ja": "エラーコードを返します。エラーコードは、静的フィールド値の1つを使用します。"
    },
    {
      "indent": 0,
      "text": "5.3. Basic Data Structures",
      "section_title": true,
      "ja": "5.3. 基本的なデータ構造"
    },
    {
      "indent": 0,
      "text": "5.3.1. Interface ServiceLocationEnumeration",
      "section_title": true,
      "ja": "5.3.1. インターフェイスServicElocationEnumeration"
    },
    {
      "indent": 3,
      "text": "public interface ServiceLocationEnumeration extends Enumeration",
      "ja": "パブリックインターフェイスServicElocationEnumerationは列挙を拡張します"
    },
    {
      "indent": 0,
      "text": "5.3.1.1. Description",
      "section_title": true,
      "ja": "5.3.1.1. 説明"
    },
    {
      "indent": 3,
      "text": "The ServiceLocationEnumeration class is the return type for all Locator SLP operations. The Java API library may implement this class to block until results are available from the SLP operation, so that the client can achieve asynchronous operation by retrieving results from the enumeration in a separate thread. Clients use the superclass nextElement() method if they are unconcerned with SLP exceptions.",
      "ja": "ServicelocationEnumerationクラスは、すべてのロケーターSLP操作のリターンタイプです。Java APIライブラリは、SLP操作から結果が利用できるまでブロックするようにこのクラスを実装する場合があり、クライアントは別のスレッドの列挙から結果を取得することで非同期操作を達成できます。クライアントは、SLPの例外を除いて無関心である場合、SuperClass NextElement（）メソッドを使用します。"
    },
    {
      "indent": 0,
      "text": "5.3.1.2. Instance Methods",
      "section_title": true,
      "ja": "5.3.1.2. インスタンスメソッド"
    },
    {
      "indent": 3,
      "text": "public abstract Object next() throws ServiceLocationException",
      "ja": "public Abstract Object next（）はServicelocationExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Return the next value or block until it becomes available.",
      "ja": "使用可能になるまで次の値またはブロックを返します。"
    },
    {
      "indent": 3,
      "text": "Throws:",
      "ja": "スロー："
    },
    {
      "indent": 6,
      "text": "ServiceLocationException",
      "ja": "ServicelocationException"
    },
    {
      "indent": 9,
      "text": "Thrown if the SLP operation encounters an error.",
      "ja": "SLP操作がエラーに遭遇した場合にスローされます。"
    },
    {
      "indent": 6,
      "text": "NoSuchElementException",
      "ja": "nosuchelementexception"
    },
    {
      "indent": 9,
      "text": "If there are no more elements to return.",
      "ja": "返す要素がこれ以上ない場合。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Class ServiceLocationAttribute",
      "section_title": true,
      "ja": "5.3.2. クラスServicElocationAttribute"
    },
    {
      "indent": 0,
      "text": "5.3.2.1. Synopsis",
      "section_title": true,
      "ja": "5.3.2.1. 概要"
    },
    {
      "indent": 3,
      "text": "public class ServiceLocationAttribute extends Object implements Serializable",
      "ja": "パブリッククラスのserviceLocationAttribute拡張オブジェクトはシリアル化可能です"
    },
    {
      "indent": 0,
      "text": "5.3.2.2. Description",
      "section_title": true,
      "ja": "5.3.2.2. 説明"
    },
    {
      "indent": 3,
      "text": "The ServiceLocationAttribute class models SLP attributes. Instances of this class are returned by Locator.findAttributes() and are communicated along with register/deregister requests.",
      "ja": "ServicelocationAttributeクラスモデルSLP属性。このクラスのインスタンスは、locator.findattributes（）によって返され、登録/登録簿のリクエストとともに通信されます。"
    },
    {
      "indent": 0,
      "text": "5.3.2.3. Constructors",
      "section_title": true,
      "ja": "5.3.2.3. コンストラクター"
    },
    {
      "indent": 3,
      "text": "public ServiceLocationAttribute(String id,Vector values)",
      "ja": "public servicelocationAttribute（string id、vector値）"
    },
    {
      "indent": 3,
      "text": "Construct a service location attribute. Errors in the id or values vector result in an IllegalArgumentException.",
      "ja": "サービスロケーション属性を作成します。IDまたは値ベクトルのエラーは、違法なメディメンツェセプトになります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "id",
      "ja": "id"
    },
    {
      "indent": 9,
      "text": "The attribute name. The String can consist of any Unicode character.",
      "ja": "属性名。文字列は、任意のユニコード文字で構成できます。"
    },
    {
      "indent": 6,
      "text": "values",
      "ja": "値価値観"
    },
    {
      "indent": 9,
      "text": "A Vector of one or more attribute values. Vector contents must be uniform in type and one of Integer, String, Boolean, or byte[]. If the attribute is a keyword attribute, then the parameter should be null. String values can consist of any Unicode character.",
      "ja": "1つ以上の属性値のベクトル。ベクトルの内容は、型が均一で、整数、弦、ブール波、またはバイトのいずれかでなければなりません[]。属性がキーワード属性の場合、パラメーターはnullである必要があります。文字列値は、任意のユニコード文字で構成できます。"
    },
    {
      "indent": 0,
      "text": "5.3.2.4. Class Methods",
      "section_title": true,
      "ja": "5.3.2.4. クラスメソッド"
    },
    {
      "indent": 3,
      "text": "public static String escapeId(String id)",
      "ja": "public static string escaseid（string id）"
    },
    {
      "indent": 3,
      "text": "Returns an escaped version of the id parameter, suitable for inclusion in a query. Any reserved characters as specified in [7] are escaped using UTF-8 encoding. If any characters in the tag are illegal, throws IllegalArgumentException.",
      "ja": "クエリに含めるのに適したIDパラメーターの脱出バージョンを返します。[7]で指定されている予約された文字は、UTF-8エンコーディングを使用して逃げられます。タグ内の文字が違法である場合は、違法なものをスローします。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "id",
      "ja": "id"
    },
    {
      "indent": 9,
      "text": "The attribute id to escape. ServiceLocationException is thrown if any characters are illegal for an attribute tag.",
      "ja": "エスケープする属性ID。ServicElocationExceptionは、属性タグに対して違法である文字が違法である場合にスローされます。"
    },
    {
      "indent": 3,
      "text": "public static String escapeValue(Object value)",
      "ja": "public static string escapevalue（オブジェクト値）"
    },
    {
      "indent": 3,
      "text": "Returns a String containing the escaped value parameter as a string, suitable for inclusion in a query. If the parameter is a string, any reserved characters as specified in [7] are escaped using UTF-8 encoding. If the parameter is a byte array, then the escaped string begins with the nonUTF-8 sequence `\\ff` and the rest of the string consists of the escaped bytes, which is the encoding for opaques. If the value parameter is a Boolean or Integer, then the returned string contains the object converted into a string. If the value is any type other than String, Integer, Boolean or byte[], an IllegalArgumentException is thrown.",
      "ja": "クエリに含めるのに適した、脱出された値パラメーターを文字列として含む文字列を返します。パラメーターが文字列の場合、[7]で指定されている予約された文字は、UTF-8エンコーディングを使用して逃げられます。パラメーターがバイト配列の場合、脱出された文字列はnonUTF-8シーケンス「\\ ff」から始まり、文字列の残りは脱出されたバイトで構成されます。これはオパークのエンコードです。値パラメーターがブール値または整数の場合、返された文字列には文字列に変換されたオブジェクトが含まれます。値が文字列、整数、ブール値、またはbyte []以外の任意のタイプである場合、違法者がスローされます。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "value",
      "ja": "価値値バリュー価価格値打ち金高珍重尊ぶ貴ぶ直評価する愛玩する"
    },
    {
      "indent": 9,
      "text": "The attribute value to be converted into a string and escaped.",
      "ja": "属性値は文字列に変換されて逃げます。"
    },
    {
      "indent": 0,
      "text": "5.3.2.5. Instance Methods",
      "section_title": true,
      "ja": "5.3.2.5. インスタンスメソッド"
    },
    {
      "indent": 3,
      "text": "public Vector getValues()",
      "ja": "public vector getValues（）"
    },
    {
      "indent": 3,
      "text": "Returns a cloned vector of attribute values, or null if the attribute is a keyword attribute. If the attribute is single-valued, then the vector contains only one object.",
      "ja": "属性値のクローン化されたベクトルを返し、属性がキーワード属性である場合はnullを返します。属性が単一値の場合、ベクトルには1つのオブジェクトのみが含まれます。"
    },
    {
      "indent": 3,
      "text": "public String getId()",
      "ja": "public string getId（）"
    },
    {
      "indent": 3,
      "text": "Returns the attribute's name.",
      "ja": "属性の名前を返します。"
    },
    {
      "indent": 3,
      "text": "public boolean equals(Object o)",
      "ja": "パブリックブールの等しい（オブジェクトO）"
    },
    {
      "indent": 3,
      "text": "Overrides Object.equals(). Two attributes are equal if their identifiers are equal and their value vectors contain the same number of equal values as determined by the Object equals() method. Values having byte[] type are equal if the contents of all byte arrays in both attribute vectors match. Note that the SLP string matching algorithm [7] MUST NOT be used for comparing attribute identifiers or string values.",
      "ja": "Object.equals（）をオーバーライドします。2つの属性は、識別子が等しく、値ベクトルにオブジェクト等しい（）メソッドによって決定されるのと同じ数の等しい値が含まれている場合、等しくなります。両方の属性ベクトルのすべてのバイト配列の内容が一致する場合、バイト[]タイプを持つ値は等しくなります。SLP文字列マッチングアルゴリズム[7]は、属性識別子または文字列値を比較するために使用しないでください。"
    },
    {
      "indent": 3,
      "text": "public String toString()",
      "ja": "public string toString（）"
    },
    {
      "indent": 3,
      "text": "Overrides Object.toString(). The string returned contains a formatted representation of the attribute, giving the attribute's id, values, and the Java type of the values. The returned string is suitable for debugging purposes, but is not in SLP wire format.",
      "ja": "Object.ToString（）をOverrides。返された文字列には、属性のフォーマットされた表現が含まれており、属性のID、値、および値のJavaタイプが与えられます。返された文字列は、デバッグの目的に適していますが、SLPワイヤ形式ではありません。"
    },
    {
      "indent": 3,
      "text": "public int hashCode()",
      "ja": "public int hashcode（）"
    },
    {
      "indent": 3,
      "text": "Overrides Object.hashCode(). Hashes on the attribute's identifier.",
      "ja": "Object.hashcode（）をOverrides。属性の識別子にハッシュします。"
    },
    {
      "indent": 0,
      "text": "5.3.3. Class ServiceType",
      "section_title": true,
      "ja": "5.3.3. クラスサービスタイプ"
    },
    {
      "indent": 0,
      "text": "5.3.3.1. Synopsis",
      "section_title": true,
      "ja": "5.3.3.1. 概要"
    },
    {
      "indent": 3,
      "text": "public class ServiceType extends Object implements Serializable",
      "ja": "パブリッククラスServiceType拡張オブジェクトはシリアル化可能です"
    },
    {
      "indent": 0,
      "text": "5.3.3.2. Description",
      "section_title": true,
      "ja": "5.3.3.2. 説明"
    },
    {
      "indent": 3,
      "text": "The ServiceType object models the SLP service type. It parses a string based service type specifier into its various components, and contains property accessors to return the components. URL schemes, protocol service types, and abstract service types are all handled.",
      "ja": "ServiceTypeオブジェクトは、SLPサービスタイプをモデル化します。文字列ベースのサービスタイプ仕様をさまざまなコンポーネントに解析し、コンポーネントを返すためにプロパティアクセターが含まれています。URLスキーム、プロトコルサービスタイプ、および抽象サービスタイプはすべて処理されます。"
    },
    {
      "indent": 0,
      "text": "5.3.3.3. Constructors",
      "section_title": true,
      "ja": "5.3.3.3. コンストラクター"
    },
    {
      "indent": 3,
      "text": "public ServiceType(String type)",
      "ja": "public ServiceType（文字列タイプ）"
    },
    {
      "indent": 3,
      "text": "Construct a service type object from the service type specifier. Throws IllegalArgumentException if the type name is syntactically incorrect.",
      "ja": "サービスタイプ仕様からサービスタイプオブジェクトを作成します。タイプ名が構文的に間違っている場合、違法な記念科目をスローします。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "type",
      "ja": "タイプ種類形字体質気質代表典型試供品"
    },
    {
      "indent": 9,
      "text": "The service type name as a String. If the service type is from a service: URL, the \"service:\" prefix must be intact.",
      "ja": "文字列としてのサービスタイプ名。サービスタイプがサービスからのものである場合：URL、「サービス：」プレフィックスは無傷でなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3.3.4. Methods",
      "section_title": true,
      "ja": "5.3.3.4. 方法"
    },
    {
      "indent": 3,
      "text": "public boolean isServiceURL()",
      "ja": "public boolean isserviceurl（）"
    },
    {
      "indent": 3,
      "text": "Returns true if the type name contains the \"service:\" prefix.",
      "ja": "タイプ名に「サービス：」プレフィックスが含まれている場合、trueを返します。"
    },
    {
      "indent": 3,
      "text": "public boolean isAbstractType()",
      "ja": "public boolean isabstracttype（）"
    },
    {
      "indent": 3,
      "text": "Returns true if the type name is for an abstract type.",
      "ja": "タイプ名が抽象型の場合はtrueを返します。"
    },
    {
      "indent": 3,
      "text": "public boolean isNADefault()",
      "ja": "public boolean isnadefault（）"
    },
    {
      "indent": 3,
      "text": "Returns true if the naming authority is the default, i.e. is the empty string.",
      "ja": "命名権限がデフォルトである場合、つまり空の文字列である場合、trueを返します。"
    },
    {
      "indent": 3,
      "text": "public String getConcreteTypeName()",
      "ja": "public string getConcreteTypename（）"
    },
    {
      "indent": 3,
      "text": "Returns the concrete type name in an abstract type, or the empty string if the service type is not abstract. For example, if the type name is \"service:printing:ipp\", the method returns \"ipp\". If the type name is \"service:ftp\", the method returns \"\".",
      "ja": "コンクリートタイプの名前を抽象型で返し、サービスタイプが抽象的でない場合は空の文字列を返します。たとえば、タイプ名が「サービス：印刷：IPP」の場合、メソッドは「IPP」を返します。タイプ名が「service：ftp」の場合、メソッドは \"\" \"を返します。"
    },
    {
      "indent": 3,
      "text": "public String getPrincipleTypeName()",
      "ja": "パブリック文字"
    },
    {
      "indent": 3,
      "text": "Returns the abstract type name for an abstract type, the protocol name in a protocol type, or the URL scheme for a generic URL. For example, in the abstract type name \"service:printing:ipp\", the method returns \"printing\". In the protocol type name \"service:ftp\", the method returns \"ftp\".",
      "ja": "抽象タイプの抽象タイプ名、プロトコルタイプのプロトコル名、または汎用URLのURLスキームを返します。たとえば、抽象タイプ名「サービス：印刷：IPP」では、メソッドは「印刷」を返します。プロトコルタイプ名「サービス：FTP」では、メソッドは「FTP」を返します。"
    },
    {
      "indent": 3,
      "text": "public String getAbstractTypeName()",
      "ja": "public string getAbstractTypename（）"
    },
    {
      "indent": 3,
      "text": "If the type is an abstract type, returns the fully formatted abstract type name including the \"service:\" and naming authority but without the concrete type name or intervening colon. If not an abstract type, returns the empty string. For example, in the abstract type name \"service:printing:ipp\", the method returns \"service:printing\".",
      "ja": "タイプが抽象型の場合、「サービス：」と命名権限を含む完全にフォーマットされた抽象タイプ名を返しますが、具体的なタイプ名または介在するコロンはありません。抽象型ではない場合は、空の文字列を返します。たとえば、抽象タイプ名「サービス：印刷：IPP」で、メソッドは「サービス：印刷」を返します。"
    },
    {
      "indent": 3,
      "text": "public String getNamingAuthority()",
      "ja": "public string getnamingauthority（）"
    },
    {
      "indent": 3,
      "text": "Return the naming authority name, or the empty string if the naming authority is the default.",
      "ja": "命名権限がデフォルトである場合は、命名当局名、または空の文字列を返します。"
    },
    {
      "indent": 3,
      "text": "public boolean equals(Object obj)",
      "ja": "パブリックブールエコール（オブジェクトOBJ）"
    },
    {
      "indent": 3,
      "text": "Overrides Object.equals(). The two objects are equal if they are both ServiceType objects and the components of both are equal.",
      "ja": "Object.equals（）をオーバーライドします。2つのオブジェクトは、両方ともServiceTypeオブジェクトであり、両方のコンポーネントが等しい場合に等しくなります。"
    },
    {
      "indent": 3,
      "text": "public String toString()",
      "ja": "public string toString（）"
    },
    {
      "indent": 3,
      "text": "Returns the fully formatted type name, including the \"service:\" if the type was originally from a service: URL.",
      "ja": "「サービス：」を含む完全にフォーマットされたタイプ名を返します。タイプが元々サービスからのものであった場合：url。"
    },
    {
      "indent": 3,
      "text": "public int hashCode()",
      "ja": "public int hashcode（）"
    },
    {
      "indent": 3,
      "text": "Overrides Object.hashCode(). Hashes on the string value of the \"service\" prefix, naming authority, if any, abstract and concrete type names for abstract types, protocol type name for protocol types, and URL scheme for generic URLs.",
      "ja": "Object.hashcode（）をOverrides。「サービス」プレフィックスの文字列値、アブストラクトタイプの抽象的および具体的なタイプ名、プロトコルタイプのプロトコルタイプ名、およびジェネリックURLのURLスキームをハッシュします。"
    },
    {
      "indent": 0,
      "text": "5.3.4. Class ServiceURL",
      "section_title": true,
      "ja": "5.3.4. クラスserviceurl"
    },
    {
      "indent": 0,
      "text": "5.3.4.1. Synopsis",
      "section_title": true,
      "ja": "5.3.4.1. 概要"
    },
    {
      "indent": 3,
      "text": "public class ServiceURL extends Object implements Serializable",
      "ja": "Public Class ServiceUrlは、オブジェクトを拡張し、シリアル化可能です"
    },
    {
      "indent": 0,
      "text": "5.3.4.2. Description",
      "section_title": true,
      "ja": "5.3.4.2. 説明"
    },
    {
      "indent": 3,
      "text": "The ServiceURL object models the advertised SLP service URL. It can be either a service: URL or a regular URL. These objects are returned from service lookup requests, and describe the registered services. This class should be a subclass of java.net.URL but can't since that class is final.",
      "ja": "ServiceUrlオブジェクトは、広告されたSLPサービスURLをモデル化します。それは、URLまたは通常のURL：サービスのいずれかです。これらのオブジェクトは、サービスルックアップリクエストから返され、登録サービスを説明します。このクラスはjava.net.urlのサブクラスである必要がありますが、そのクラスが最終的なものであるため、できません。"
    },
    {
      "indent": 0,
      "text": "5.3.4.3. Class Variables",
      "section_title": true,
      "ja": "5.3.4.3. クラス変数"
    },
    {
      "indent": 3,
      "text": "public static final int NO_PORT = 0",
      "ja": "public static final int no_port = 0"
    },
    {
      "indent": 3,
      "text": "Indicates that no port information is required or was returned for this URL.",
      "ja": "このURLにはポート情報が不要であるか、返されたことを示します。"
    },
    {
      "indent": 3,
      "text": "public static final int LIFETIME_NONE = 0",
      "ja": "public static final int lifetime_none = 0"
    },
    {
      "indent": 3,
      "text": "Indicates that the URL has a zero lifetime. This value is never returned from the API, but can be used to create a ServiceURL object to deregister, delete attributes, or find attributes.",
      "ja": "URLの寿命はゼロであることを示します。この値はAPIから返されることはありませんが、登録、属性の削除、または属性の検索にserversurlオブジェクトを作成するために使用できます。"
    },
    {
      "indent": 3,
      "text": "public static final int LIFETIME_DEFAULT = 10800",
      "ja": "public static final int lifetime_default = 10800"
    },
    {
      "indent": 3,
      "text": "The default URL lifetime (3 hours) in seconds.",
      "ja": "デフォルトのURLライフタイム（3時間）秒単位。"
    },
    {
      "indent": 3,
      "text": "public static final int LIFETIME_MAXIMUM = 65535",
      "ja": "public static final int lifetime_maximum = 65535"
    },
    {
      "indent": 3,
      "text": "The maximum URL lifetime (about 18 hours) in seconds.",
      "ja": "最大URL寿命（約18時間）秒で。"
    },
    {
      "indent": 3,
      "text": "public static final int LIFETIME_PERMANENT = -1",
      "ja": "public static final int lifetime_permanent = -1"
    },
    {
      "indent": 3,
      "text": "Indicates that the API implementation should continuously re-register the URL until the application exits.",
      "ja": "API実装は、アプリケーションが終了するまでURLを継続的に再登録する必要があることを示します。"
    },
    {
      "indent": 0,
      "text": "5.3.4.4. Constructors",
      "section_title": true,
      "ja": "5.3.4.4. コンストラクター"
    },
    {
      "indent": 3,
      "text": "public ServiceURL(String URL,int lifetime)",
      "ja": "public serviceurl（string url、int lifetime）"
    },
    {
      "indent": 3,
      "text": "Construct a service URL object having the specified lifetime.",
      "ja": "指定された寿命を持つサービスURLオブジェクトを作成します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "URL",
      "ja": "URL"
    },
    {
      "indent": 9,
      "text": "The URL as a string. Must be either a service: URL or a valid generic URL according to RFC 2396 [2].",
      "ja": "文字列としてのURL。RFC 2396 [2]に従って、URLまたは有効な汎用URLであるサービスである必要があります。"
    },
    {
      "indent": 6,
      "text": "lifetime",
      "ja": "一生生涯一生涯一代生存期間"
    },
    {
      "indent": 9,
      "text": "The service advertisement lifetime in seconds. This value may be between LIFETIME_NONE and LIFETIME_MAXIMUM.",
      "ja": "秒単位のサービス広告寿命。この値は、lifetime_noneとlifetime_maximumの間にある場合があります。"
    },
    {
      "indent": 0,
      "text": "5.3.4.5. Methods",
      "section_title": true,
      "ja": "5.3.4.5. 方法"
    },
    {
      "indent": 3,
      "text": "public ServiceType getServiceType()",
      "ja": "public ServiceType getServiceType（）"
    },
    {
      "indent": 3,
      "text": "Returns the service type object representing the service type name of the URL.",
      "ja": "URLのサービスタイプ名を表すサービスタイプオブジェクトを返します。"
    },
    {
      "indent": 2,
      "text": "public final void setServiceType(ServiceType type) throws ServiceLocationException",
      "ja": "public final void setServiceType（ServiceType Type）をServicElocationException"
    },
    {
      "indent": 3,
      "text": "Set the service type name to the object. Ignored if the URL is a service: URL.",
      "ja": "サービスタイプ名をオブジェクトに設定します。URLがサービスである場合、無視されます：URL。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "type",
      "ja": "タイプ種類形字体質気質代表典型試供品"
    },
    {
      "indent": 9,
      "text": "The service type object.",
      "ja": "サービスタイプオブジェクト。"
    },
    {
      "indent": 3,
      "text": "public String getTransport()",
      "ja": "public string getTransport（）"
    },
    {
      "indent": 3,
      "text": "Get the network layer transport identifier. If the transport is IP, an empty string, \"\", is returned.",
      "ja": "ネットワークレイヤートランスポート識別子を取得します。トランスポートがIPの場合、空の文字列「」が返されます。"
    },
    {
      "indent": 3,
      "text": "public String getHost() Returns the host identifier. For IP, this will be the machine name or IP address.",
      "ja": "public string gethost（）は、ホスト識別子を返します。IPの場合、これはマシン名またはIPアドレスになります。"
    },
    {
      "indent": 3,
      "text": "public int getPort()",
      "ja": "public int getport（）"
    },
    {
      "indent": 3,
      "text": "Returns the port number, if any. For non-IP transports, always returns NO_PORT.",
      "ja": "ある場合は、ポート番号を返します。非IPトランスポートの場合、常にno_portを返します。"
    },
    {
      "indent": 3,
      "text": "public String getURLPath()",
      "ja": "パブリックストリングgeturlpath（）"
    },
    {
      "indent": 3,
      "text": "Returns the URL path description, if any.",
      "ja": "ある場合、URLパスの説明を返します。"
    },
    {
      "indent": 3,
      "text": "public int getLifetime()",
      "ja": "public int getLifetime（）"
    },
    {
      "indent": 3,
      "text": "Returns the service advertisement lifetime. This will be a positive int between LIFETIME_NONE and LIFETIME_MAXIMUM.",
      "ja": "Service Advertisement Lifetimeを返します。これは、lifetime_noneとlifetime_maximumの間の肯定的なintになります。"
    },
    {
      "indent": 3,
      "text": "public boolean equals(Object obj)",
      "ja": "パブリックブールエコール（オブジェクトOBJ）"
    },
    {
      "indent": 3,
      "text": "Compares the object to the ServiceURL and returns true if the two are the same. Two ServiceURL objects are equal if their current service types match and they have the same host, port, transport, and URL path.",
      "ja": "オブジェクトをServiceUrlと比較し、2つが同じ場合はtrueを返します。現在のサービスタイプが一致し、同じホスト、ポート、トランスポート、およびURLパスを持っている場合、2つのServiceUrlオブジェクトは等しくなります。"
    },
    {
      "indent": 3,
      "text": "public String toString()",
      "ja": "public string toString（）"
    },
    {
      "indent": 3,
      "text": "Returns a formatted string with the URL. Overrides Object.toString(). The returned URL has the original service type or URL scheme, not the current service type.",
      "ja": "URLでフォーマットされた文字列を返します。Object.ToString（）をOverrides。返されたURLには、現在のサービスタイプではなく、元のサービスタイプまたはURLスキームがあります。"
    },
    {
      "indent": 3,
      "text": "public int hashCode()",
      "ja": "public int hashcode（）"
    },
    {
      "indent": 3,
      "text": "Overrides Object.hashCode(). Hashes on the current service type, transport, host, port, and URL part.",
      "ja": "Object.hashcode（）をOverrides。現在のサービスタイプ、トランスポート、ホスト、ポート、およびURLパーツをハッシュします。"
    },
    {
      "indent": 0,
      "text": "5.4. SLP Access Interfaces",
      "section_title": true,
      "ja": "5.4. SLPアクセスインターフェイス"
    },
    {
      "indent": 0,
      "text": "5.4.1. Interface Advertiser",
      "section_title": true,
      "ja": "5.4.1. インターフェイス広告主"
    },
    {
      "indent": 0,
      "text": "5.4.1.1. Synopsis",
      "section_title": true,
      "ja": "5.4.1.1. 概要"
    },
    {
      "indent": 3,
      "text": "public interface Advertiser",
      "ja": "パブリックインターフェイス広告主"
    },
    {
      "indent": 0,
      "text": "5.4.1.2. Description",
      "section_title": true,
      "ja": "5.4.1.2. 説明"
    },
    {
      "indent": 3,
      "text": "The Advertiser is the SA interface, allowing clients to register new service instances with SLP, to change the attributes of existing services, and to deregister service instances. New registrations and modifications of attributes are made in the language locale with which the Advertiser was created, deregistrations of service instances are made for all locales.",
      "ja": "広告主はSAインターフェイスであり、クライアントがSLPに新しいサービスインスタンスを登録したり、既存のサービスの属性を変更したり、サービスインスタンスを登録したりできます。属性の新しい登録と変更は、広告主が作成された言語ロケールで行われます。すべてのロケールに対してサービスインスタンスの登録が行われます。"
    },
    {
      "indent": 0,
      "text": "5.4.1.3. Instance Methods",
      "section_title": true,
      "ja": "5.4.1.3. インスタンスメソッド"
    },
    {
      "indent": 3,
      "text": "public abstract Locale getLocale()",
      "ja": "パブリックアブストラクトロケールgetLocale（）"
    },
    {
      "indent": 3,
      "text": "Return the language locale with which this object was created.",
      "ja": "このオブジェクトが作成された言語ロケールを返します。"
    },
    {
      "indent": 3,
      "text": "public abstract void register(ServiceURL URL, Vector attributes) throws ServiceLocationException",
      "ja": "パブリックアブストラクトボイドレジスタ（serveryurl url、vector属性）がservicelocationexceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Register a new service with SLP having the given attributes.",
      "ja": "与えられた属性を持つSLPに新しいサービスを登録します。"
    },
    {
      "indent": 3,
      "text": "The API library is required to perform the operation in all scopes obtained through configuration.",
      "ja": "APIライブラリは、構成を通じて取得したすべてのスコープで操作を実行するために必要です。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "URL",
      "ja": "URL"
    },
    {
      "indent": 9,
      "text": "The URL for the service.",
      "ja": "サービスのURL。"
    },
    {
      "indent": 6,
      "text": "attributes",
      "ja": "属性"
    },
    {
      "indent": 9,
      "text": "A vector of ServiceLocationAttribute objects describing the service.",
      "ja": "サービスを記述するServicelocationAttributeオブジェクトのベクトル。"
    },
    {
      "indent": 3,
      "text": "public abstract void deregister(ServiceURL URL) throws ServiceLocationException",
      "ja": "パブリックアブストラクトvoid deregister（serviceurl url）はservicelocationexceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Deregister a service from the SLP framework. This has the effect of deregistering the service from every language locale. The API library is required to perform the operation in all scopes obtained through configuration.",
      "ja": "SLPフレームワークからサービスを登録します。これは、すべての言語ロケールからサービスを登録する効果があります。APIライブラリは、構成を通じて取得したすべてのスコープで操作を実行するために必要です。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "URL",
      "ja": "URL"
    },
    {
      "indent": 9,
      "text": "The URL for the service.",
      "ja": "サービスのURL。"
    },
    {
      "indent": 3,
      "text": "public abstract void addAttributes(ServiceURL URL, Vector attributes) throws ServiceLocationException",
      "ja": "パブリックアブストラクトvoid addattributes（serveryurl url、vector属性）がservicelocationexceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Update the registration by adding the given attributes. The API library is required to perform the operation in all scopes obtained through configuration.",
      "ja": "指定された属性を追加して登録を更新します。APIライブラリは、構成を通じて取得したすべてのスコープで操作を実行するために必要です。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "URL",
      "ja": "URL"
    },
    {
      "indent": 9,
      "text": "The URL for the service.",
      "ja": "サービスのURL。"
    },
    {
      "indent": 6,
      "text": "attributes",
      "ja": "属性"
    },
    {
      "indent": 9,
      "text": "A Vector of ServiceLocationAttribute objects to add to the existing registration. Use an empty vector to update the URL alone. May not be null.",
      "ja": "既存の登録に追加するServicelocationAttributeオブジェクトのベクトル。空のベクトルを使用して、URLを単独で更新します。ヌルではないかもしれません。"
    },
    {
      "indent": 3,
      "text": "public abstract void deleteAttributes(ServiceURL URL, Vector attributeIds) throws ServiceLocationException",
      "ja": "パブリックアブストラクトvoid deleteattributes（serversurl url、vector属性）をスローServicElocationException"
    },
    {
      "indent": 3,
      "text": "Delete the attributes from a URL for the locale with which the Advertiser was created. The API library is required to perform the operation in all scopes obtained through configuration.",
      "ja": "広告主が作成されたロケールのURLから属性を削除します。APIライブラリは、構成を通じて取得したすべてのスコープで操作を実行するために必要です。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "URL",
      "ja": "URL"
    },
    {
      "indent": 9,
      "text": "The URL for the service.",
      "ja": "サービスのURL。"
    },
    {
      "indent": 6,
      "text": "attributeIds",
      "ja": "AttributeIds"
    },
    {
      "indent": 9,
      "text": "A vector of Strings indicating the ids of the attributes to remove. The strings may be attribute ids or they may be wildcard patterns to match ids. See [7] for the syntax of wildcard patterns. The strings may include SLP reserved characters, they will be escaped by the API before transmission. May not be the empty vector or null.",
      "ja": "削除する属性のIDを示す文字列のベクトル。文字列は属性IDである場合があります。または、IDに一致するワイルドカードパターンである場合があります。ワイルドカードパターンの構文については[7]を参照してください。文字列にはSLP予約文字が含まれている場合があり、送信前にAPIによって逃げられます。空のベクトルやヌルではない可能性があります。"
    },
    {
      "indent": 0,
      "text": "5.4.2. Interface Locator",
      "section_title": true,
      "ja": "5.4.2. インターフェイスロケーター"
    },
    {
      "indent": 0,
      "text": "5.4.2.1. Synopsis",
      "section_title": true,
      "ja": "5.4.2.1. 概要"
    },
    {
      "indent": 3,
      "text": "public interface Locator",
      "ja": "パブリックインターフェイスロケーター"
    },
    {
      "indent": 0,
      "text": "5.4.2.2. Description",
      "section_title": true,
      "ja": "5.4.2.2. 説明"
    },
    {
      "indent": 3,
      "text": "The Locator is the UA interface, allowing clients to query the SLP framework about existing service types, services instances, and about the attributes of an existing service instance or service type. Queries for services and attributes are made in the locale with which the Locator was created, queries for service types are independent of locale.",
      "ja": "ロケーターはUAインターフェイスであり、クライアントは既存のサービスタイプ、サービスインスタンス、および既存のサービスインスタンスまたはサービスタイプの属性に関するSLPフレームワークを照会できるようにします。サービスと属性のクエリは、ロケーターが作成されたロケールで作成され、サービスタイプのクエリはロケールに依存しません。"
    },
    {
      "indent": 0,
      "text": "5.4.2.3. Instance Methods",
      "section_title": true,
      "ja": "5.4.2.3. インスタンスメソッド"
    },
    {
      "indent": 3,
      "text": "public abstract Locale getLocale()",
      "ja": "パブリックアブストラクトロケールgetLocale（）"
    },
    {
      "indent": 3,
      "text": "Return the language locale with which this object was created.",
      "ja": "このオブジェクトが作成された言語ロケールを返します。"
    },
    {
      "indent": 3,
      "text": "public abstract ServiceLocationEnumeration findServiceTypes(String namingAuthority, Vector scopes) throws ServiceLocationException Returns an enumeration of ServiceType objects giving known service types for the given scopes and given naming authority. If no service types are found, an empty enumeration is returned.",
      "ja": "パブリックアブストラクトServicElocationEnumeration FindServiceTypes（String NamingAuthority、Vector Scopes）Strows ServicelocationExceptionは、特定のスコープおよび与えられた命名権限の既知のサービスタイプを提供するServiceTypeオブジェクトの列挙を返します。サービスタイプが見つからない場合、空の列挙が返されます。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "namingAuthority",
      "ja": "namingauthority"
    },
    {
      "indent": 9,
      "text": "The naming authority. Use \"\" for the default naming authority and \"*\" for all naming authorities.",
      "ja": "命名権限。デフォルトの命名機関に \"\"を使用し、すべての命名当局に「*」を使用します。"
    },
    {
      "indent": 6,
      "text": "scopes",
      "ja": "スコープ"
    },
    {
      "indent": 9,
      "text": "A Vector of scope names. The vector should be selected from the results of a findScopes() API invocation. Use \"DEFAULT\" for the default scope.",
      "ja": "スコープ名のベクトル。ベクトルは、FindScopes（）API Inkocationの結果から選択する必要があります。デフォルトスコープに「デフォルト」を使用します。"
    },
    {
      "indent": 3,
      "text": "public abstract ServiceLocationEnumeration findServices(ServiceType type, Vector scopes, String searchFilter) throws ServiceLocationException",
      "ja": "パブリックアブストラクトServicElocationEnumeration FindServices（ServiceType Type、Vector Scopes、String SearchFilter）Strows ServicElocationException"
    },
    {
      "indent": 3,
      "text": "Returns a vector of ServiceURL objects for services matching the query, and having a matching type in the given scopes. If no services are found, an empty enumeration is returned.",
      "ja": "クエリに一致するサービス用のServiceUrlオブジェクトのベクトルを返し、指定されたスコープに一致するタイプを持っています。サービスが見つからない場合、空の列挙が返されます。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "type",
      "ja": "タイプ種類形字体質気質代表典型試供品"
    },
    {
      "indent": 9,
      "text": "The SLP service type of the service.",
      "ja": "サービスのSLPサービスタイプ。"
    },
    {
      "indent": 6,
      "text": "scopes",
      "ja": "スコープ"
    },
    {
      "indent": 9,
      "text": "A Vector of scope names. The vector should be selected from the results of a findScopes() API invocation. Use \"DEFAULT\" for the default scope.",
      "ja": "スコープ名のベクトル。ベクトルは、FindScopes（）API Inkocationの結果から選択する必要があります。デフォルトスコープに「デフォルト」を使用します。"
    },
    {
      "indent": 6,
      "text": "searchFilter",
      "ja": "SearchFilter"
    },
    {
      "indent": 9,
      "text": "An LDAPv3 [4] string encoded query. If the filter is empty, i.e. \"\", all services of the requested type in the specified scopes are returned. SLP reserved characters must be escaped in the query. Use ServiceLocationAttribute.escapeId() and ServiceLocationAttribute.escapeValue() to construct the query.",
      "ja": "LDAPV3 [4]文字列エンコードクエリ。フィルターが空の場合、つまり「」である場合、指定されたスコープの要求されたタイプのすべてのサービスが返されます。SLP予約文字は、クエリで逃げる必要があります。servicelocationattribute.escapeid（）およびservicelocationattribute.escapevalue（）を使用して、クエリを作成します。"
    },
    {
      "indent": 3,
      "text": "public abstract ServiceLocationEnumeration findAttributes(ServiceURL URL, Vector scopes, Vector attributeIds) throws ServiceLocationException",
      "ja": "パブリックアブストラクトServicElocationEnumeration findattributes（serveryurl url、vector scopes、vector属性）がServicelocationexceptionをスローします"
    },
    {
      "indent": 3,
      "text": "For the URL and scope, return a Vector of ServiceLocationAttribute objects whose ids match the String patterns in the attributeIds Vector. The request is made in the language locale of the Locator. If no attributes match, an empty enumeration is returned.",
      "ja": "URLとスコープの場合、IDが属性IDSベクトルの文字列パターンに一致するServicelocationAttributeオブジェクトのベクトルを返します。リクエストは、ロケーターの言語ロケールで行われます。属性が一致しない場合、空の列挙が返されます。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "URL",
      "ja": "URL"
    },
    {
      "indent": 9,
      "text": "The URL for which the attributes are desired.",
      "ja": "属性が望まれるURL。"
    },
    {
      "indent": 6,
      "text": "scopes",
      "ja": "スコープ"
    },
    {
      "indent": 9,
      "text": "A Vector of scope names. The vector should be selected from the results of a findScopes() API invocation. Use \"DEFAULT\" for the default scope.",
      "ja": "スコープ名のベクトル。ベクトルは、FindScopes（）API Inkocationの結果から選択する必要があります。デフォルトスコープに「デフォルト」を使用します。"
    },
    {
      "indent": 6,
      "text": "attributeIds",
      "ja": "AttributeIds"
    },
    {
      "indent": 9,
      "text": "A Vector of String patterns identifying the desired attributes. An empty vector means return all attributes. As described in [7], the patterns may include wildcards to match substrings. The strings may include SLP reserved characters, they will be escaped by the API before transmission.",
      "ja": "目的の属性を識別する文字列パターンのベクトル。空のベクトルは、すべての属性を返すことを意味します。[7]で説明されているように、パターンには、サブストリングを一致させるワイルドカードが含まれる場合があります。文字列にはSLP予約文字が含まれている場合があり、送信前にAPIによって逃げられます。"
    },
    {
      "indent": 3,
      "text": "public abstract ServiceLocationEnumeration findAttributes(ServiceType type, Vector scopes, Vector attributeIds) throws ServiceLocationException",
      "ja": "パブリックアブストラクトServicElocationEnumeration findattributes（ServiceType Type、Vector Scopes、Vector属性）がServicElocationExceptionをスローする"
    },
    {
      "indent": 3,
      "text": "For the type and scope, return a Vector of all ServiceLocationAttribute objects whose ids match the String patterns in the attributeIds Vector regardless of the Locator's locale. The request is made independent of language locale. If no attributes are found, an empty vector is returned.",
      "ja": "タイプとスコープの場合、Locatorのロケールに関係なく、IDが属性IDSベクトルの文字列パターンと一致するすべてのServicElocationAttributeオブジェクトのベクトルを返します。リクエストは、言語のロケールとは無関係に行われます。属性が見つからない場合、空のベクトルが返されます。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "serviceType",
      "ja": "サービスの種類"
    },
    {
      "indent": 9,
      "text": "The service type.",
      "ja": "サービスタイプ。"
    },
    {
      "indent": 6,
      "text": "scopes",
      "ja": "スコープ"
    },
    {
      "indent": 9,
      "text": "A Vector of scope names. The vector should be selected from the results of a findScopes() API invocation. Use \"DEFAULT\" for the default scope.",
      "ja": "スコープ名のベクトル。ベクトルは、FindScopes（）API Inkocationの結果から選択する必要があります。デフォルトスコープに「デフォルト」を使用します。"
    },
    {
      "indent": 6,
      "text": "attributeIds",
      "ja": "AttributeIds"
    },
    {
      "indent": 9,
      "text": "A Vector of String patterns identifying the desired attributes. An empty vector means return all attributes. As described in [7], the patterns may include wildcards to match all prefixes or suffixes. The patterns may include SLP reserved characters, they will be escaped by the API before transmission.",
      "ja": "目的の属性を識別する文字列パターンのベクトル。空のベクトルは、すべての属性を返すことを意味します。[7]で説明されているように、パターンには、すべてのプレフィックスまたはサフィックスに一致するワイルドカードが含まれる場合があります。パターンにはSLP予約文字が含まれる場合があり、伝送前にAPIによって逃げられます。"
    },
    {
      "indent": 0,
      "text": "5.5. The Service Location Manager",
      "section_title": true,
      "ja": "5.5. サービスロケーションマネージャー"
    },
    {
      "indent": 0,
      "text": "5.5.1. Class ServiceLocationManager",
      "section_title": true,
      "ja": "5.5.1. クラスServicElocationManager"
    },
    {
      "indent": 0,
      "text": "5.5.1.1. Synopsis",
      "section_title": true,
      "ja": "5.5.1.1. 概要"
    },
    {
      "indent": 4,
      "text": "public class ServiceLocationManager extends Object",
      "ja": "パブリッククラスServicElocationManagerはオブジェクトを拡張します"
    },
    {
      "indent": 0,
      "text": "5.5.1.2. Description",
      "section_title": true,
      "ja": "5.5.1.2. 説明"
    },
    {
      "indent": 3,
      "text": "The ServiceLocationManager manages access to the service location framework. Clients obtain the Locator and Advertiser objects for UA and SA, and a Vector of known scope names from the ServiceLocationManager.",
      "ja": "ServicelocationManagerは、サービスロケーションフレームワークへのアクセスを管理します。クライアントは、UAとSAのロケーターと広告主のオブジェクト、およびServicelocationManagerから既知のスコープ名のベクトルを取得します。"
    },
    {
      "indent": 0,
      "text": "5.5.1.3. Class Methods",
      "section_title": true,
      "ja": "5.5.1.3. クラスメソッド"
    },
    {
      "indent": 3,
      "text": "public static int getRefreshInterval() throws ServiceLocationException Returns the maximum across all DAs of the min-refresh-interval attribute. This value satisfies the advertised refresh interval bounds for all DAs, and, if used by the SA, assures that no refresh registration will be rejected. If no DA advertises a min-refresh-interval attribute, a value of 0 is returned.",
      "ja": "public static int getRefreshinterval（）throws servicelocationexceptionは、最小refreshインターバル属性のすべてのdasにわたって最大値を返します。この値は、すべてのDAの広告された更新間隔の境界を満たし、SAが使用する場合、更新登録が拒否されないことを保証します。DAが最小限のインターバル属性を宣伝していない場合、0の値が返されます。"
    },
    {
      "indent": 3,
      "text": "public static Vector findScopes() throws ServiceLocationException",
      "ja": "public static vector findScopes（）はServicElocationExceptionをスローします"
    },
    {
      "indent": 3,
      "text": "Returns an Vector of strings with all available scope names. The list of scopes comes from a variety of sources, see Section 2.1 for the scope discovery algorithm. There is always at least one string in the Vector, the default scope, \"DEFAULT\".",
      "ja": "利用可能なすべてのスコープ名で文字列のベクトルを返します。スコープのリストは、さまざまなソースからのものです。ScopeDiscoveryアルゴリズムについては、セクション2.1を参照してください。ベクトルには常に少なくとも1つの文字列、デフォルトスコープ「デフォルト」があります。"
    },
    {
      "indent": 3,
      "text": "public static Locator getLocator(Locale locale) throws ServiceLocationException",
      "ja": "public staticlocator getLocator（Locale Locale）Throws ServicElocationExcept"
    },
    {
      "indent": 3,
      "text": "Return a Locator object for the given language Locale. If the implementation does not support UA functionality, returns null.",
      "ja": "指定された言語ロケールのロケーターオブジェクトを返します。実装がUA機能をサポートしていない場合、NULLを返します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "locale",
      "ja": "ロケール附近付近"
    },
    {
      "indent": 9,
      "text": "The language locale of the Locator. The default SLP locale is used if null.",
      "ja": "ロケーターの言語ロケール。nullの場合、デフォルトのSLPロケールが使用されます。"
    },
    {
      "indent": 3,
      "text": "public static Advertiser getAdvertiser(Locale locale) throws ServiceLocationException",
      "ja": "public static Advertiser getAdvertiser（Locale Locale）Slows ServicElocationExcept"
    },
    {
      "indent": 3,
      "text": "Return an Advertiser object for the given language locale. If the implementation does not support SA functionality, returns null.",
      "ja": "指定された言語ロケールの広告主オブジェクトを返します。実装がSA機能をサポートしていない場合、NULLを返します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "locale",
      "ja": "ロケール附近付近"
    },
    {
      "indent": 9,
      "text": "The language locale of the Advertiser. The default SLP locale is used if null.",
      "ja": "広告主の言語ロケール。nullの場合、デフォルトのSLPロケールが使用されます。"
    },
    {
      "indent": 0,
      "text": "5.6. Service Template Introspection",
      "section_title": true,
      "ja": "5.6. サービステンプレート内省"
    },
    {
      "indent": 0,
      "text": "5.6.1. Abstract Class TemplateRegistry",
      "section_title": true,
      "ja": "5.6.1. 抽象クラスTemplateregistry"
    },
    {
      "indent": 0,
      "text": "5.6.1.1. Synopsis",
      "section_title": true,
      "ja": "5.6.1.1. 概要"
    },
    {
      "indent": 3,
      "text": "public abstract class TemplateRegistry",
      "ja": "パブリックアブストラクトクラスTemplateregistry"
    },
    {
      "indent": 0,
      "text": "5.6.1.2. Description",
      "section_title": true,
      "ja": "5.6.1.2. 説明"
    },
    {
      "indent": 3,
      "text": "Subclasses of the TemplateRegistry abstract class provide access to service location templates [8]. Classes implementing TemplateRegistry perform a variety of functions. They manage the registration and access of service type template documents. They create attribute verifiers from service templates, for verification of attributes and introspection on template documents. Note that clients of the Advertiser are not required to verify attributes before registering (though they may get a TYPE_ERROR if the implementation supports type checking and there is a mismatch with the template).",
      "ja": "Templateregistry Abstractクラスのサブクラスは、サービスロケーションテンプレートへのアクセスを提供します[8]。Templateregistryを実装するクラスは、さまざまな機能を実行します。サービスタイプのテンプレートドキュメントの登録とアクセスを管理します。テンプレートドキュメントの属性と内省の検証のために、サービステンプレートから属性検証剤を作成します。広告主のクライアントは、登録する前に属性を確認する必要がないことに注意してください（ただし、実装がタイプチェックをサポートし、テンプレートに不一致がある場合はType_Errorを取得する場合があります）。"
    },
    {
      "indent": 0,
      "text": "5.6.1.3. Class Methods",
      "section_title": true,
      "ja": "5.6.1.3. クラスメソッド"
    },
    {
      "indent": 3,
      "text": "public static TemplateRegistry getTemplateRegistry();",
      "ja": "public static templateregistry gettemplateregistry（）;"
    },
    {
      "indent": 3,
      "text": "Returns the distinguished TemplateRegistry object for performing operations on and with service templates. Returns null if the implementation doesn't support TemplateRegistry functionality.",
      "ja": "サービステンプレートで操作を実行するための著名なTemplateregistryオブジェクトを返します。実装がtemplateregistry機能をサポートしていない場合、nullを返します。"
    },
    {
      "indent": 0,
      "text": "5.6.1.4. Instance Methods",
      "section_title": true,
      "ja": "5.6.1.4. インスタンスメソッド"
    },
    {
      "indent": 3,
      "text": "public abstract void registerServiceTemplate(ServiceType type, String documentURL, Locale locale, String version) throws ServiceLocationException",
      "ja": "public abstract void registerserviceTemplate（serviceTypeタイプ、文字列documenturl、locale locale、stringバージョン）ServicelocationException"
    },
    {
      "indent": 3,
      "text": "Register the service template with the template registry.",
      "ja": "テンプレートレジストリにサービステンプレートを登録します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "type",
      "ja": "タイプ種類形字体質気質代表典型試供品"
    },
    {
      "indent": 9,
      "text": "The service type.",
      "ja": "サービスタイプ。"
    },
    {
      "indent": 6,
      "text": "documentURL",
      "ja": "documenturl"
    },
    {
      "indent": 9,
      "text": "A string containing the URL of the template document. May not be the empty string.",
      "ja": "テンプレートドキュメントのURLを含む文字列。空の文字列ではないかもしれません。"
    },
    {
      "indent": 6,
      "text": "locale",
      "ja": "ロケール附近付近"
    },
    {
      "indent": 9,
      "text": "A Locale object containing the language locale of the template.",
      "ja": "テンプレートの言語ロケールを含むロケールオブジェクト。"
    },
    {
      "indent": 6,
      "text": "version",
      "ja": "バージョン稿改作説明"
    },
    {
      "indent": 9,
      "text": "The version number identifier of template document.",
      "ja": "テンプレートドキュメントのバージョン番号識別子。"
    },
    {
      "indent": 3,
      "text": "public abstract void",
      "ja": "パブリックアブストラクトボイド"
    },
    {
      "indent": 3,
      "text": "deregisterServiceTemplate(ServiceType type, Locale locale, String version) throws ServiceLocationException",
      "ja": "deregisterserviceTemplate（ServiceType Type、Locale Locale、Stringバージョン）Throws ServicElocationException"
    },
    {
      "indent": 3,
      "text": "Deregister the template for the service type.",
      "ja": "サービスタイプのテンプレートを登録します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "type",
      "ja": "タイプ種類形字体質気質代表典型試供品"
    },
    {
      "indent": 9,
      "text": "The service type.",
      "ja": "サービスタイプ。"
    },
    {
      "indent": 6,
      "text": "locale",
      "ja": "ロケール附近付近"
    },
    {
      "indent": 9,
      "text": "A Locale object containing the language locale of the template.",
      "ja": "テンプレートの言語ロケールを含むロケールオブジェクト。"
    },
    {
      "indent": 6,
      "text": "version",
      "ja": "バージョン稿改作説明"
    },
    {
      "indent": 9,
      "text": "A String containing the version number. Use null to indicate the latest version.",
      "ja": "バージョン番号を含む文字列。nullを使用して、最新バージョンを示します。"
    },
    {
      "indent": 3,
      "text": "public abstract String findTemplateURL(ServiceType type, Locale locale, String version) throws ServiceLocationException",
      "ja": "public abstract string findTemplateUrl（ServiceType Type、Locale Locale、Stringバージョン）SREVICELOCATIONEXCEPTION"
    },
    {
      "indent": 3,
      "text": "Returns the URL for the template document.",
      "ja": "テンプレートドキュメントのURLを返します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "type",
      "ja": "タイプ種類形字体質気質代表典型試供品"
    },
    {
      "indent": 9,
      "text": "The service type.",
      "ja": "サービスタイプ。"
    },
    {
      "indent": 6,
      "text": "locale",
      "ja": "ロケール附近付近"
    },
    {
      "indent": 9,
      "text": "A Locale object containing the language locale of the template.",
      "ja": "テンプレートの言語ロケールを含むロケールオブジェクト。"
    },
    {
      "indent": 6,
      "text": "version",
      "ja": "バージョン稿改作説明"
    },
    {
      "indent": 9,
      "text": "A String containing the version number. Use null to indicate the latest version.",
      "ja": "バージョン番号を含む文字列。nullを使用して、最新バージョンを示します。"
    },
    {
      "indent": 3,
      "text": "public abstract ServiceLocationAttributeVerifier attributeVerifier(String documentURL) throws ServiceLocationException",
      "ja": "パブリックアブストラクトServicElocationAttributeVerifier artibutionVerifier（String Documenturl）Sthrows ServicElocationException"
    },
    {
      "indent": 3,
      "text": "Reads the template document URL and returns an attribute verifier for the service type. The attribute verifier can be used for verifying that registration attributes match the template, and for introspection on the template definition.",
      "ja": "テンプレートドキュメントURLを読み取り、サービスタイプの属性検証者を返します。属性検証者は、登録属性がテンプレートと一致することを確認し、テンプレート定義の内省を確認するために使用できます。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "documentURL",
      "ja": "documenturl"
    },
    {
      "indent": 9,
      "text": "A String containing the template document's URL. May not be the empty string.",
      "ja": "テンプレートドキュメントのURLを含む文字列。空の文字列ではないかもしれません。"
    },
    {
      "indent": 0,
      "text": "5.6.2. Interface ServiceLocationAttributeVerifier",
      "section_title": true,
      "ja": "5.6.2. インターフェイスServicElocationAttributeverifier"
    },
    {
      "indent": 0,
      "text": "5.6.2.1. Synopsis",
      "section_title": true,
      "ja": "5.6.2.1. 概要"
    },
    {
      "indent": 3,
      "text": "public interface ServiceLocationAttributeVerifier",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.6.2.2. Description",
      "section_title": true,
      "ja": "5.6.2.2. 説明"
    },
    {
      "indent": 3,
      "text": "The ServiceLocationAttributeVerifier provides access to service templates. Classes implementing this interface parse SLP template definitions, provide information on attribute definitions for service types, and verify whether a ServiceLocationAttribute object matches a template for a particular service type. Clients obtain ServiceLocationAttributeVerifier objects for specific SLP service types through the TemplateRegistry.",
      "ja": "ServicelocationAttributeverifierは、サービステンプレートへのアクセスを提供します。このインターフェイスの解析SLPテンプレート定義を実装し、サービスタイプの属性定義に関する情報を提供し、ServicelocationAttributeオブジェクトが特定のサービスタイプのテンプレートと一致するかどうかを確認します。クライアントは、Templateregistryを介して特定のSLPサービスタイプのServicelocationAttributeverifierオブジェクトを取得します。"
    },
    {
      "indent": 0,
      "text": "5.6.2.3. Instance Methods",
      "section_title": true,
      "ja": "5.6.2.3. インスタンスメソッド"
    },
    {
      "indent": 3,
      "text": "public abstract ServiceType getServiceType()",
      "ja": "public abstract ServiceType getServicetype（）"
    },
    {
      "indent": 3,
      "text": "Returns the SLP service type for which this is the verifier.",
      "ja": "これが検証剤であるSLPサービスタイプを返します。"
    },
    {
      "indent": 3,
      "text": "public abstract Locale getLocale()",
      "ja": "パブリックアブストラクトロケールgetLocale（）"
    },
    {
      "indent": 3,
      "text": "Return the language locale of the template.",
      "ja": "テンプレートの言語ロケールを返します。"
    },
    {
      "indent": 3,
      "text": "public abstract String getVersion()",
      "ja": "パブリックアブストラクトストリングgetVersion（）"
    },
    {
      "indent": 3,
      "text": "Return the template version number identifier.",
      "ja": "テンプレートバージョン番号識別子を返します。"
    },
    {
      "indent": 3,
      "text": "public abstract String getURLSyntax()",
      "ja": "パブリックアブストラクトストリングgeturlsyntax（）"
    },
    {
      "indent": 3,
      "text": "Return the URL syntax expression for the service: URL.",
      "ja": "サービスのURL構文式を返します：URL。"
    },
    {
      "indent": 3,
      "text": "public abstract String getDescription() Return the descriptive help text for the template.",
      "ja": "public Abstract String getDescription（）テンプレートの記述ヘルプテキストを返します。"
    },
    {
      "indent": 3,
      "text": "public abstract ServiceLocationAttributeDescriptor getAttributeDescriptor(String attrId)",
      "ja": "パブリックアブストラクトservicelocationAttributedEscriptor getAttributedescriptor（StringAttrid）"
    },
    {
      "indent": 3,
      "text": "Return the ServiceLocationAttributeDescriptor for the attribute having the named id. If no such attribute exists in this template, return null. This method is primarily for GUI tools to display attribute information. Programmatic verification of attributes should use the verifyAttribute() method.",
      "ja": "名前付きIDを持つ属性のServicElocationAttributedEscriptorを返します。このテンプレートにそのような属性が存在しない場合は、nullを返します。この方法は、主にGUIツールが属性情報を表示するためのものです。属性のプログラム検証は、verifyattribute（）メソッドを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "public abstract Enumeration getAttributeDescriptors()",
      "ja": "パブリックアブストラクト列挙getattributedescriptors（）"
    },
    {
      "indent": 3,
      "text": "Returns an Enumeration allowing introspection on the attribute definition in the service template. The Enumeration returns ServiceLocationAttributeDescriptor objects for the attributes. This method is primarily for GUI tools to display attribute information. Programmatic verification of attributes should use the verifyAttribute() method.",
      "ja": "列挙を返し、サービステンプレートの属性定義の内省を可能にします。列挙は、属性のServicElocationAttributedEscriptorオブジェクトを返します。この方法は、主にGUIツールが属性情報を表示するためのものです。属性のプログラム検証は、verifyattribute（）メソッドを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "public abstract void verifyAttribute( ServiceLocationAttribute attribute) throws ServiceLocationException",
      "ja": "public abstract void verifyattribute（servicelocationAttribute属性）をスローServicelocationExcept"
    },
    {
      "indent": 3,
      "text": "Verify that the attribute matches the template definition. If the attribute doesn't match, ServiceLocationException is thrown with the error code as ServiceLocationException.PARSE_ERROR.",
      "ja": "属性がテンプレート定義と一致することを確認します。属性が一致しない場合、servicelocationexceptionはservicelocationexception.parse_errorとしてエラーコードを使用してスローされます。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "attribute",
      "ja": "属性アトリビュート象徴記号気質"
    },
    {
      "indent": 9,
      "text": "The ServiceLocationAttribute object to be verified.",
      "ja": "検証するServicElocationAttributeオブジェクト。"
    },
    {
      "indent": 3,
      "text": "public abstract void verifyRegistration( Vector attributeVector) throws ServiceLocationException Verify that the Vector of ServiceLocationAttribute objects matches the template for this service type. The vector must contain all the required attributes, and all attributes must match their template definitions. If the attributes don't match, ServiceLocationException is thrown with the error code as ServiceLocationException.PARSE_ERROR",
      "ja": "public abstract void verifyifyRegistration（vector ributionevector）スローServicelocationException ServicelocationAttributeオブジェクトのベクトルがこのサービスタイプのテンプレートと一致することを確認します。ベクトルには、必要なすべての属性を含める必要があり、すべての属性がテンプレート定義と一致する必要があります。属性が一致しない場合、servicelocationexceptionはservicelocationexception.parse_errorとしてエラーコードでスローされます"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "attributeVector",
      "ja": "aTtibiontevector"
    },
    {
      "indent": 9,
      "text": "A Vector of ServiceLocationAttribute objects for the registration.",
      "ja": "登録用のServicelocationAttributeオブジェクトのベクトル。"
    },
    {
      "indent": 0,
      "text": "5.6.3. Interface ServiceLocationAttributeDescriptor",
      "section_title": true,
      "ja": "5.6.3. Interface ServicElocationAttributeDescriptor"
    },
    {
      "indent": 0,
      "text": "5.6.3.1. Synopsis",
      "section_title": true,
      "ja": "5.6.3.1. 概要"
    },
    {
      "indent": 3,
      "text": "public interface\nServiceLocationAttributeDescriptor",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.6.3.2. Description",
      "section_title": true,
      "ja": "5.6.3.2. 説明"
    },
    {
      "indent": 3,
      "text": "The ServiceLocationAttributeDescriptor interface provides introspection on a template attribute definition. Classes implementing the ServiceLocationAttributeDescriptor interface return information on a particular service location attribute definition from the service template. This information is primarily for GUI tools. Programmatic attribute verification should be done through the ServiceLocationAttributeVerifier.",
      "ja": "ServicelocationAttributedEscriptorインターフェイスは、テンプレート属性定義で内省を提供します。ServicelocationAttributedEscriptorインターフェイスの実装クラスは、サービステンプレートの特定のサービスロケーション属性定義に関する情報を返します。この情報は主にGUIツール向けです。プログラム属性の検証は、ServicelocationAttributeverifierを介して行う必要があります。"
    },
    {
      "indent": 0,
      "text": "5.6.3.3. Instance Methods",
      "section_title": true,
      "ja": "5.6.3.3. インスタンスメソッド"
    },
    {
      "indent": 3,
      "text": "public abstract String getId()",
      "ja": "パブリックアブストラクトストリングgetId（）"
    },
    {
      "indent": 3,
      "text": "Return a String containing the attribute's id.",
      "ja": "属性のIDを含む文字列を返します。"
    },
    {
      "indent": 3,
      "text": "public abstract String getValueType()",
      "ja": "パブリックアブストラクトストリングgetValueetype（）"
    },
    {
      "indent": 3,
      "text": "Return a String containing the fully package-qualified Java type of the attribute. SLP types are translated into Java types as follows:",
      "ja": "属性の完全なパッケージ資格のJavaタイプを含む文字列を返します。SLPタイプは、次のようにJavaタイプに翻訳されます。"
    },
    {
      "indent": 6,
      "text": "STRING",
      "ja": "弦"
    },
    {
      "indent": 9,
      "text": "\"java.lang.String\"",
      "ja": "「java.lang.String」"
    },
    {
      "indent": 6,
      "text": "INTEGER",
      "ja": "整数"
    },
    {
      "indent": 9,
      "text": "\"java.lang.Integer\"",
      "ja": "「java.lang.integer」"
    },
    {
      "indent": 6,
      "text": "BOOLEAN",
      "ja": "ブール"
    },
    {
      "indent": 9,
      "text": "\"java.lang.Boolean\"",
      "ja": "「java.lang.boolean」"
    },
    {
      "indent": 6,
      "text": "OPAQUE",
      "ja": "不透明"
    },
    {
      "indent": 9,
      "text": "\"[B\" (i.e. array of byte, byte[])",
      "ja": "「[b」（すなわち、バイトの配列、byte []）"
    },
    {
      "indent": 6,
      "text": "KEYWORD",
      "ja": "キーワード"
    },
    {
      "indent": 9,
      "text": "empty string, \"\"",
      "ja": "空の文字列、 \"\""
    },
    {
      "indent": 1,
      "text": "public abstract String getDescription()",
      "ja": "パブリックアブストラクトストリングgetDescription（）"
    },
    {
      "indent": 3,
      "text": "Return a String containing the attribute's help text.",
      "ja": "属性のヘルプテキストを含む文字列を返します。"
    },
    {
      "indent": 3,
      "text": "public abstract Enumeration getAllowedValues()",
      "ja": "パブリックアブストラクト列挙GetAllowedValues（）"
    },
    {
      "indent": 3,
      "text": "Return an Enumeration of allowed values for the attribute type. For keyword attributes returns null. For no allowed values (i.e. unrestricted) returns an empty Enumeration.",
      "ja": "属性タイプの許容値の列挙を返します。キーワード属性の場合、nullを返します。許可された値（つまり、無制限）は空の列挙を返しません。"
    },
    {
      "indent": 3,
      "text": "public abstract Enumeration getDefaultValues()",
      "ja": "パブリックアブストラクト列挙getDefaultValues（）"
    },
    {
      "indent": 3,
      "text": "Return an Enumeration of default values for the attribute type. For keyword attributes returns null. For no allowed values (i.e. unrestricted) returns an empty Enumeration.",
      "ja": "属性タイプのデフォルト値の列挙を返します。キーワード属性の場合、nullを返します。許可された値（つまり、無制限）は空の列挙を返しません。"
    },
    {
      "indent": 3,
      "text": "public abstract boolean getRequiresExplicitMatch() Returns true if the \"X\"\" flag is set, indicating that the attribute should be included in an any Locator.findServices() request search filter.",
      "ja": "public boolean getRequiresexplicitMatch（）は、「x」フラグが設定されている場合にtrueを返します。"
    },
    {
      "indent": 3,
      "text": "public abstract boolean getIsMultivalued()",
      "ja": "パブリックアブストラクトブールのgetismultivalued（）"
    },
    {
      "indent": 3,
      "text": "Returns true if the \"M\" flag is set.",
      "ja": "「M」フラグが設定されている場合、trueを返します。"
    },
    {
      "indent": 3,
      "text": "public abstract boolean getIsOptional()",
      "ja": "public abstract boolean getisoptional（）"
    },
    {
      "indent": 3,
      "text": "Returns true if the \"O\"\" flag is set.",
      "ja": "「o」フラグが設定されている場合、trueを返します。"
    },
    {
      "indent": 3,
      "text": "public abstract boolean getIsLiteral()",
      "ja": "パブリックアブストラクトブール値getIsliteral（）"
    },
    {
      "indent": 3,
      "text": "Returns true if the \"L\" flag is set.",
      "ja": "「L」フラグが設定されている場合、trueを返します。"
    },
    {
      "indent": 3,
      "text": "public abstract boolean getIsKeyword()",
      "ja": "パブリックアブストラクトブールgetiskeyword（）"
    },
    {
      "indent": 3,
      "text": "Returns true if the attribute is a keyword attribute.",
      "ja": "属性がキーワード属性である場合、trueを返します。"
    },
    {
      "indent": 0,
      "text": "5.7. Implementation Notes",
      "section_title": true,
      "ja": "5.7. 実装ノート"
    },
    {
      "indent": 0,
      "text": "5.7.1. Refreshing Registrations",
      "section_title": true,
      "ja": "5.7.1. リフレッシュ登録"
    },
    {
      "indent": 3,
      "text": "A special lifetime constant, ServiceURL.LIFETIME_PERMANENT, is used by clients to indicate that the URL should be automatically refreshed until the application exits. The API implementation should interpret this flag as indicating that the URL lifetime is ServiceURL.LIFETIME_MAXIMUM, and MUST arrange for automatic refresh to occur.",
      "ja": "特別な寿命定数、Serviceurl.lifetime_permanentは、クライアントがアプリケーションが終了するまでURLを自動的に更新する必要があることを示すために使用されます。APIの実装は、このフラグをURL寿命がserviceurl.lifetime_maximumであることを示すものとして解釈する必要があり、自動更新が発生するように手配する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.7.2. Parsing Alternate Transports in ServiceURL",
      "section_title": true,
      "ja": "5.7.2. Serviceurlでの代替輸送の解析"
    },
    {
      "indent": 3,
      "text": "The ServiceURL class is designed to handle multiple transports. The standard API performs no additional processing on transports other than IP except to separate out the host identifier and the URL path. However, implementations are free to subclass ServiceURL and support additional methods that provide more detailed parsing of alternate transport information. For IP transport, the port number, if any, is returned from the getPort() method. For non-IP transports, the getPort() method returns NO_PORT.",
      "ja": "ServiceUrlクラスは、複数の輸送を処理するように設計されています。標準APIは、ホスト識別子とURLパスを分離することを除き、IP以外のトランスポートで追加の処理を実行しません。ただし、実装はServiceUrlを無料でサブセルでき、代替輸送情報のより詳細な解析を提供する追加の方法をサポートします。IPトランスポートの場合、ポート番号がある場合は、getport（）メソッドから返されます。非IPトランスポートの場合、getport（）メソッドはno_portを返します。"
    },
    {
      "indent": 0,
      "text": "5.7.3. String Attribute Values",
      "section_title": true,
      "ja": "5.7.3. 文字列属性値"
    },
    {
      "indent": 3,
      "text": "In general, translation between Java types for attribute values and the SLP on-the-wire string is straightforward. However, there are two corner cases. If the Java attribute value type is String and the value of the string has an on-the-wire representation that is inferred by SLP as an integer, the registered attribute value may not be what the API client intended. A similar problem could result if the Java attribute value is the string \"true\" or \"false\", in which case the on-the-wire representation is inferred to boolean. To handle these corner cases, the Java API prepends a space onto the string. So, for example, if the string attribute value is \"123\", the Java API transforms the value to \"123 \", which will have an on-the-wire representation that is inferred by SLP to be string. Since appended and prepended spaces have no effect on query handling, this procedure should cause no problem with queries. API clients need to be aware, however, that the transformation is occurring.",
      "ja": "一般に、属性値のJavaタイプとSLPオンザワイヤ文字列の間の翻訳は簡単です。ただし、2つのコーナーケースがあります。Java属性の値タイプが文字列であり、文字列の値が整数としてSLPによって推測されるワイヤ表現を持っている場合、登録された属性値はAPIクライアントが意図したものではない場合があります。Java属性値が文字列「True」または「False」である場合、同様の問題が生じる可能性があります。これらのコーナーケースを処理するために、Java APIは文字列にスペースを準備します。したがって、たとえば、文字列属性値が「123」の場合、Java APIは値を「123」に変換します。追加されたスペースと準備されたスペースはクエリ処理に影響を与えないため、この手順はクエリに問題を引き起こさないはずです。ただし、APIクライアントは、変換が発生していることに注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.7.4. Client Side Syntax Checking",
      "section_title": true,
      "ja": "5.7.4. クライアント側の構文チェック"
    },
    {
      "indent": 3,
      "text": "The syntax of scope names, service type names, naming authority names, and URLs is described in [7] and [8]. The various methods and classes taking String parameters for these entities SHOULD type check the parameters for syntax errors on the client side, and throw an IllegalArgumentException if an error occurs. In addition, character escaping SHOULD be implemented before network transmission for escapable characters in attribute ids and String values. This reduces the number of error messages transmitted. The ServiceLocationAttribute class provides methods for clients to obtain escaped attribute id and value strings to facilitate query construction.",
      "ja": "スコープ名、サービスタイプ名、命名当局名、およびURLの構文は、[7]および[8]で説明されています。これらのエンティティの文字列パラメーターを使用するさまざまなメソッドとクラスは、クライアント側の構文エラーのパラメーターをチェックし、エラーが発生した場合に違法行為をスローする必要があります。さらに、属性IDと文字列値の脱出可能な文字のネットワーク伝送の前に、文字の脱出を実装する必要があります。これにより、送信されるエラーメッセージの数が減ります。ServicElocationAttributeクラスは、クライアントの構築を容易にするために、クライアントがEscaped属性IDとバリュー文字列を取得する方法を提供します。"
    },
    {
      "indent": 0,
      "text": "5.7.5. Language Locale Handling",
      "section_title": true,
      "ja": "5.7.5. 言語ロケール処理"
    },
    {
      "indent": 3,
      "text": "The Locator and Advertiser interfaces are created with a Locale parameter. The language locale with which these objects are created is used in all SLP requests issued through the object. If the Locale parameter is null, the default SLP locale is used. The default SLP locale is determined by, first, checking the net.slp.locale System property. If that is unset, then the default SLP locale [7] is used, namely \"en\". Note that the default SLP locale may not be the same as the default Java locale.",
      "ja": "ロケーターと広告主のインターフェイスは、ロケールパラメーターで作成されます。これらのオブジェクトが作成される言語ロケールは、オブジェクトを介して発行されたすべてのSLP要求で使用されます。ロケールパラメーターがnullの場合、デフォルトのSLPロケールが使用されます。デフォルトのSLPロケールは、最初に、net.slp.localeシステムプロパティをチェックすることによって決定されます。それが設定されていない場合、デフォルトのSLPロケール[7]、つまり「en」が使用されます。デフォルトのSLPロケールは、デフォルトのJavaロケールと同じではない場合があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.7.6. Setting SLP System Properties",
      "section_title": true,
      "ja": "5.7.6. SLPシステムプロパティの設定"
    },
    {
      "indent": 3,
      "text": "SLP system properties that are originally set in the configuration file can be overridden programmatically in API clients by simply invoking the System.getProperties() operation to get a copy of the system properties, modifying or adding the SLP property in question, then using System.setProperties() to set the properties to the modified Property object. Program execution continues without interruption by substituting the default for the erroneous parameter. Errors are checked when the property is used and are logged.",
      "ja": "元々構成ファイルに設定されたSLPシステムプロパティは、System.GetProperties（）操作を呼び出すだけでAPIクライアントでプログラムで上書きされ、システムプロパティのコピーを取得し、問題のSLPプロパティを変更または追加してからシステムを使用します。setProperties（）は、プロパティを変更されたプロパティオブジェクトに設定します。プログラムの実行は、誤ったパラメーターのデフォルトを置き換えることにより、中断することなく継続します。プロパティが使用され、記録されているときにエラーがチェックされます。"
    },
    {
      "indent": 3,
      "text": "The SLP configuration file cannot be read with the java.util.Properties file reader because there are some syntactic differences. The SLP configuration file syntax defines a different escape convention for non-ASCII characters than the Java syntax. However, after the file has been read, the properties are stored and retrieved from java.util.Properties objects.",
      "ja": "SLP構成ファイルは、java.util.propertiesファイルリーダーで読み取ることができません。これは、構文の違いがあるためです。SLP構成ファイルの構文は、Java構文とは異なるASCII文字の異なるエスケープ条約を定義します。ただし、ファイルが読み取られた後、プロパティはjava.util.propertiesオブジェクトから保存および取得されます。"
    },
    {
      "indent": 3,
      "text": "Properties are global for a process, affecting all threads and all Locator and Advertiser objects obtained through the ServiceLocationManager. With the exception of the net.slp.locale, net.slp.typeHint, and net.slp.maxResults properties, clients should rarely be required to override these properties, since they reflect properties of the SLP network that are not of concern to individual agents. If changes are required, system administrators should modify the configuration file.",
      "ja": "プロパティはプロセスのグローバルであり、ServicelocationManagerを介して取得したすべてのスレッドとすべてのロケーターおよび広告主オブジェクトに影響を与えます。net.slp.locale、net.slp.typehint、およびnet.slp.maxresultsプロパティを除き、クライアントは、個々の懸念事項を反映しているため、これらのプロパティをオーバーライドするためにめったに必要ありません。エージェント。変更が必要な場合、システム管理者は構成ファイルを変更する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.7.7. Multithreading",
      "section_title": true,
      "ja": "5.7.7. マルチスレッド"
    },
    {
      "indent": 3,
      "text": "Thread-safe operation is relatively easy to achieve in Java. By simply making each method in the classes implementing the Locator and Advertiser interfaces synchronized, and by synchronizing access to any shared data structures within the class, the Locator and Advertiser interfaces are made safe. Alternatively, finer grained synchronization is also possible within the classes implementing Advertiser and Locator.",
      "ja": "スレッドセーフ操作は、Javaでは比較的簡単に達成できます。ロケーターと広告主のインターフェイスを同期し、クラス内の共有データ構造へのアクセスを同期させるクラスの各メソッドを単に作成するだけで、ロケーターと広告主インターフェイスが安全になります。あるいは、広告主とロケーターを実装するクラス内でも、より細かい粒子の同期が可能です。"
    },
    {
      "indent": 0,
      "text": "5.7.8. Modular Implementations",
      "section_title": true,
      "ja": "5.7.8. モジュラー実装"
    },
    {
      "indent": 3,
      "text": "While, at first glance, the API may look rather heavyweight, the design has been carefully arranged so that modular implementations that provide only SA, only UA, or only service template access capability, or any combination of the three, are possible.",
      "ja": "一見、APIはかなりヘビー級に見えるかもしれませんが、設計は慎重に配置されているため、SA、UA、またはサービステンプレートのアクセス機能のみ、または3つの組み合わせのみを提供するモジュラー実装が可能になります。"
    },
    {
      "indent": 3,
      "text": "Because the objects returned from the ServiceLocationManager.getLocator() and ServiceLocationManager.getAdvertiser() operations are interfaces, and because the objects returned through those interfaces are in the set of base data structures, an implementation is free to omit either UA or SA capability by simply returning null from the instance creation operation if the classes implementing the missing function cannot be dynamically linked. API clients are encouraged to check for such a contingency, and to signal an exception if it occurs. Similarly, the TemplateRegistry concrete subclass can simply be omitted from an implementation that only supports UA and/or SA clients, and the TemplateRegistry.getRegistry() method can return null. In this way, the API implementation can be tailored for the particular memory requirements at hand.",
      "ja": "ServicelocationManager.getLocator（）およびServicelocationManager.getAdvertiser（）操作から返されるオブジェクトはインターフェイスであり、それらのインターフェイスを介して返されるオブジェクトはベースデータ構造のセットにあるため、実装はUAまたはSAの能力を省略できます。欠落している関数を実装するクラスを動的にリンクできない場合、インスタンス作成操作からnullを返すだけです。APIクライアントは、このような不測の事態を確認し、それが発生した場合に例外を通知することをお勧めします。同様に、Templateregistryコンクリートサブクラスは、UAおよび/またはSAクライアントのみをサポートする実装から省略でき、templateregistry.getRegistry（）メソッドはnullを返すことができます。このようにして、API実装は、手元の特定のメモリ要件に合わせて調整できます。"
    },
    {
      "indent": 3,
      "text": "In addition, if an implementation only supports the minimal subset of SLP [7], the unsupported Locator and Advertiser interface operations can throw an exception with ServiceLocationException.NOT_IMPLEMENTED as the error code. This supports better source portability between low and high memory platforms.",
      "ja": "さらに、実装がSLP [7]の最小サブセットのみをサポートする場合、サポートされていないロケーターと広告主インターフェイス操作は、servicelocationexception.not_implementedを使用して例外をスローすることができます。これは、低メモリプラットフォームと高メモリプラットフォーム間のより良いソースポータビリティをサポートします。"
    },
    {
      "indent": 0,
      "text": "5.7.9. Asynchronous and Incremental Return Semantics",
      "section_title": true,
      "ja": "5.7.9. 非同期および増分リターンセマンティクス"
    },
    {
      "indent": 3,
      "text": "The Java API contains no specific support for asynchronous operation. Incremental return is not needed for the Advertiser because service registrations can be broken up into pieces when large. Asynchronous return is also not needed because clients can always issue the Advertiser operation in a separate thread if the calling thread can't block.",
      "ja": "Java APIには、非同期操作に対する特定のサポートが含まれていません。広大なときにサービス登録を細かく分割できるため、広告主には増分リターンは必要ありません。クライアントは、呼び出しスレッドがブロックできない場合、クライアントは常に別のスレッドで広告主の操作を発行できるため、非同期リターンも必要ありません。"
    },
    {
      "indent": 3,
      "text": "The Locator can be implemented either synchronously or asynchronously. Since the return type for Locator calls is ServiceLocationEnumeration, a Java API implementation that supports asynchronous semantics can implement ServiceLocationEnumeration to dole results out as they come in, blocking when no results are available. If the client code needs to support other processing while the results are trickling in, the call into the enumeration to retrieve the results can be done in a separate thread.",
      "ja": "ロケーターは、同期または非同期に実装できます。ロケーター呼び出しの返品タイプはServicElocationEnumerationであるため、非同期セマンティクスをサポートするJava API実装は、ServiceLocationEnumerationを実装して、結果が入っていないときにブロックします。結果が流れている間にクライアントコードが他の処理をサポートする必要がある場合、結果を取得するための列挙の呼び出しは別のスレッドで実行できます。"
    },
    {
      "indent": 3,
      "text": "Unlike the C case, collation semantics for return of attributes when an attribute request by service type is made require that the API collate returned values so that only one attribute having a collation of all returned values appear to the API client. In practice, this may limit the amount of asynchronous processing possible with the findAttributes() method. This requirement is imposed because memory management is much easier in Java and so implementing collation as part of the API should not be as difficult as in C, and it saves the client from having to do the collation.",
      "ja": "Cケースとは異なり、サービスタイプごとに属性要求が作成された場合の属性の返品の照合セマンティクスAPIが返された値を要求して、すべての返された値の照合がAPIクライアントに表示されるようにします。実際には、これにより、findattributes（）メソッドで可能な非同期処理の量が制限される場合があります。この要件は、Javaでメモリ管理がはるかに簡単であるため、APIの一部として照合を実装することはCのように難しくなく、クライアントが照合を行わなければならないようにするためです。"
    },
    {
      "indent": 0,
      "text": "5.8. Example",
      "section_title": true,
      "ja": "5.8. 例"
    },
    {
      "indent": 3,
      "text": "In this example, a printer server advertises its availability to clients. Additionally, the server advertises a service template for use by client software in validating service requests:",
      "ja": "この例では、プリンターサーバーがクライアントへの可用性を宣伝しています。さらに、サーバーは、サービスリクエストを検証する際にクライアントソフトウェアが使用するサービステンプレートを宣伝しています。"
    },
    {
      "indent": 2,
      "text": "//Get the Advertiser and TemplateRegistry.",
      "ja": "//広告主とtemplateregistryを取得します。"
    },
    {
      "indent": 2,
      "text": "Advertiser adv = null; TemplateRegistry tr = null",
      "ja": "Advertiser Adv = null;templateregistry tr = null"
    },
    {
      "indent": 2,
      "text": "try {",
      "ja": "試す {"
    },
    {
      "indent": 4,
      "text": "adv = ServiceLocationManager.getAdvertiser(\"en\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "tr = TemplateRegistry.getTemplateRegistry();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "} catch( ServiceLocationException ex ) { } //Deal with error.",
      "ja": "} catch（servicelocationexception ex）{} //エラーを処理します。"
    },
    {
      "indent": 2,
      "text": "if( adv == null ) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "//Serious error as printer can't be registered\n//  if the implementation doesn't support SA\n//  functionality.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 2,
      "text": "//Get the printer's attributes, from a file or\n//  otherwise. We assume that the attributes\n//  conform to the template, otherwise, we\n//  could register the template here and verify\n//  them.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "Vector attributes = getPrinterAttributes();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "//Create the service: URL for the printer.",
      "ja": "//サービスの作成：プリンター用のURL。"
    },
    {
      "indent": 2,
      "text": "ServiceURL printerURL =\n  new ServiceURL(\n    \"service:printer:lpr://printshop/color2\",\n    ServiceURL.LIFETIME_MAXIMUM);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "try {",
      "ja": "試す {"
    },
    {
      "indent": 4,
      "text": "//Register the printer.",
      "ja": "//プリンターを登録します。"
    },
    {
      "indent": 4,
      "text": "adv.register(printerURL, attributes);",
      "ja": "adv.register（printerurl、属性）;"
    },
    {
      "indent": 4,
      "text": "//If the template registry is available, // register the printer's template.",
      "ja": "//テンプレートレジストリが利用可能な場合は、//プリンターのテンプレートを登録します。"
    },
    {
      "indent": 4,
      "text": "if( tr != null ) {\n  tr.registerServiceTemplate(\n    new ServiceType(\"service:printer:lpr\"),\n    \"http://shop.arv/printer/printer-lpr.slp\",\n    new Locale(\"en\",\"\"),\n    \"1.0\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 2,
      "text": "} catch( ServiceLocationException ex ) { } //Deal with error.",
      "ja": "} catch（servicelocationexception ex）{} //エラーを処理します。"
    },
    {
      "indent": 3,
      "text": "Suppose a client is looking for color printer. The following code is used to issue a request for printer advertisements:",
      "ja": "クライアントがカラープリンターを探しているとします。次のコードは、プリンター広告のリクエストを発行するために使用されます。"
    },
    {
      "indent": 2,
      "text": "Locator loc = null;\nTemplateRegistry tr = null;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "try {",
      "ja": "試す {"
    },
    {
      "indent": 4,
      "text": "loc = ServiceLocationManager.getLocator(\"en\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "} catch( ServiceLocationException ex ) { } //Deal with error.",
      "ja": "} catch（servicelocationexception ex）{} //エラーを処理します。"
    },
    {
      "indent": 2,
      "text": "if( loc == null ) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "//Serious error as client can't be located\n//  if the implementation doesn't support\n//  UA functionality.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 2,
      "text": "//We want a color printer that does CMYK // and prints at least 600 dpi.",
      "ja": "// cmyk //を実行し、少なくとも600 dpiを印刷するカラープリンターが必要です。"
    },
    {
      "indent": 2,
      "text": "String query = \"(&(marker-type=CMYK)(resolution=600))\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "//Get scopes.",
      "ja": "//スコープを取得します。"
    },
    {
      "indent": 2,
      "text": "Vector scopes = ServiceLocationManager.findScopes();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "Enumeration services;",
      "ja": "列挙サービス;"
    },
    {
      "indent": 2,
      "text": "try {",
      "ja": "試す {"
    },
    {
      "indent": 4,
      "text": "services =\n  loc.findServices(new ServiceType(\"service:printer\"),scopes,query);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "} catch { } //Deal with error.",
      "ja": "} catch {} //エラーを処理します。"
    },
    {
      "indent": 2,
      "text": "if (services.hasMoreElements() ) {",
      "ja": "if（services.hasmoreElements（））{"
    },
    {
      "indent": 4,
      "text": "//Printers can now be used.\nServiceURL surl = (ServiceURL) services.next();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Socket sock = new Socket(surl.getHost, surl.getPort());",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "// Use the Socket...",
      "ja": "//ソケットを使用してください..."
    },
    {
      "indent": 2,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 0,
      "text": "6. Internationalization Considerations",
      "section_title": true,
      "ja": "6. 国際化の考慮事項"
    },
    {
      "indent": 0,
      "text": "6.1. service URL",
      "section_title": true,
      "ja": "6.1. サービスURL"
    },
    {
      "indent": 3,
      "text": "The service URL itself must be encoded using the rules set forth in [2]. The character set encoding is limited to specific ranges within the UTF-8 character set [3].",
      "ja": "[2]に記載されているルールを使用して、サービスURL自体をエンコードする必要があります。文字セットエンコーディングは、UTF-8文字セット内の特定の範囲に限定されています[3]。"
    },
    {
      "indent": 3,
      "text": "The attribute information associated with the service URL must be expressed in UTF-8. See [8] for attribute internationalization guidelines.",
      "ja": "サービスURLに関連付けられた属性情報は、UTF-8で表現する必要があります。属性国際化ガイドラインについては[8]を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.2. Character Set Encoding",
      "section_title": true,
      "ja": "6.2. 文字セットエンコーディング"
    },
    {
      "indent": 3,
      "text": "Configuration and serialized registration files are encoded in the UTF-8 character set [3]. This is fully compatible with US-ASCII character values. C platforms that do not support UTF-8 are required to check the top bit of input bytes to determine whether the incoming character is multibyte. If it is, the character should be dealt with accordingly. This should require no additional implementation effort, since the SLP wire protocol requires that strings are encoded as UTF-8. C platforms without UTF-8 support need to supply their own support, if only in the form of multibyte string handling.",
      "ja": "構成およびシリアル化された登録ファイルは、UTF-8文字セット[3]でエンコードされています。これは、US-ASCII文字値と完全に互換性があります。UTF-8をサポートしていないCプラットフォームは、入力バイトの上部ビットをチェックして、着信文字がマルチバイトであるかどうかを判断する必要があります。もしそうなら、それに応じてキャラクターを処理する必要があります。SLPワイヤプロトコルでは、文字列がUTF-8としてエンコードされる必要があるため、これには追加の実装努力は必要ありません。UTF-8のサポートのないcプラットフォームは、マルチバイト文字列処理の形でのみ、独自のサポートを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "At the API level, the character encoding is specified to be Unicode for Java and UTF-8 for C. Unicode is the default in Java. For C, the standard US-ASCII 8 bits per character, null terminated C strings are a subset of the UTF-8 character set, and so work in the API. Because the C API is very simple, the API library needs to do a minimum of processing on UTF-8 strings. The strings primarily just need to be reflected into the outgoing SLP messages, and reflected out of the API from incoming SLP messages.",
      "ja": "APIレベルでは、キャラクターエンコーディングはJavaのUnicodeとCのUTF-8であるように指定されています。UnicodeはJavaのデフォルトです。Cの場合、標準のUS-ASCII 8ビットあたり8ビットで、NULL ENTERNAMED C文字列はUTF-8文字セットのサブセットであるため、APIで動作します。C APIは非常にシンプルであるため、APIライブラリはUTF-8文字列で最小限の処理を行う必要があります。文字列は主に発信SLPメッセージに反映され、着信SLPメッセージからAPIから反映されるだけです。"
    },
    {
      "indent": 0,
      "text": "6.3. Language Tagging",
      "section_title": true,
      "ja": "6.3. 言語タグ付け"
    },
    {
      "indent": 3,
      "text": "All SLP requests and registrations are tagged to indicate in which language the strings included are encoded. This allows multiple languages to be supported. It also presents the possibility that error conditions result when a request is made in a language that is not supported. In this case, an error is only returned when there is data available, but not obtainable in the language requested.",
      "ja": "すべてのSLPリクエストと登録には、文字列が含まれる言語がエンコードされていることを示すようにタグ付けされています。これにより、複数の言語をサポートできます。また、サポートされていない言語でリクエストが行われたときにエラー条件が生じる可能性も示します。この場合、使用可能なデータがある場合にのみエラーが返されますが、要求された言語では取得できません。"
    },
    {
      "indent": 3,
      "text": "The dialect portion of the Language Tag is used on 'best effort' basis for matching strings by SLP. Dialects that match are preferred over those which don't. Dialects that do not match will not prevent string matching or comparisons from occurring.",
      "ja": "言語タグの方言部分は、SLPによる文字列を一致させるために「最適な努力」ベースで使用されます。一致する方言は、そうでないものよりも好まれます。一致しない方言では、文字列の一致や比較が発生しないようにします。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Security is handled within the API library and is not exposed to API clients except in the form of exceptions. The net.slp.securityEnabled, property determines whether an SA client's messages are signed, but a UA client should be prepared for an authentication exception at any time, because it may contact a DA with authenticated advertisements.",
      "ja": "セキュリティはAPIライブラリ内で処理され、例外の形式を除いてAPIクライアントにさらされません。net.slp.securityEnabledでは、プロパティはSAクライアントのメッセージが署名されているかどうかを決定しますが、UAクライアントは、認証された広告でDAに連絡する可能性があるため、いつでも認証例外に準備する必要があります。"
    },
    {
      "indent": 3,
      "text": "An adversary could delete valid service advertisements, provide false service information and deny UAs knowledge of existing services unless the mechanisms in SLP for authenticating SLP messages are used. These mechanisms allow DAAdverts, SAAdverts, Service URLs and Service Attributes to be verified using digital cryptography. For this reason, all SLP agents should be configured to use SLP SPIs. See [7] for a description of how this mechanism works.",
      "ja": "敵は、有効なサービス広告を削除し、誤ったサービス情報を提供し、SLPメッセージを認証するためのSLPのメカニズムが使用されない限り、既存のサービスに関するUASの知識を拒否できます。これらのメカニズムにより、DaAdvert、SaAdvert、サービスURL、およびサービス属性をデジタル暗号化を使用して検証できます。このため、すべてのSLPエージェントはSLP SPIを使用するように構成する必要があります。このメカニズムの仕組みの説明については、[7]を参照してください。"
    },
    {
      "indent": 0,
      "text": "8. Acknowledgements",
      "section_title": true,
      "ja": "8. 謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Don Provan for his pioneering work during the initial stages of API definition.",
      "ja": "著者は、API定義の初期段階で彼の先駆的な仕事についてDon Provanに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9. 参考文献"
    },
    {
      "indent": 4,
      "text": "[1] Bradner, S., \"Key Words for Use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[1] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 4,
      "text": "[2] Berners-Lee, T., Fielding, R. and L. Masinter, \"Uniform Resource Identifiers (URI): Generic Syntax\", RFC 2396, August 1998.",
      "ja": "[2] Berners-Lee、T.、Fielding、R。and L. Masinter、「ユニフォームリソース識別子（URI）：Generic Syntax」、RFC 2396、1998年8月。"
    },
    {
      "indent": 4,
      "text": "[3] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", RFC 2279, January 1998.",
      "ja": "[3] Yergeau、F。、「UTF-8、ISO 10646の変換形式」、RFC 2279、1998年1月。"
    },
    {
      "indent": 4,
      "text": "[4] Howes, T., \"The String Representation of LDAP Search Filters\", RFC 2254 December 1997.",
      "ja": "[4] Howes、T。、「LDAP検索フィルターの文字列表現」、RFC 2254 1997年12月。"
    },
    {
      "indent": 4,
      "text": "[5] Crocker, D. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", RFC 2234, November 1997.",
      "ja": "[5] Crocker、D。およびP. Overell、「構文仕様のためのBNFの増強：ABNF」、RFC 2234、1997年11月。"
    },
    {
      "indent": 4,
      "text": "[6] Alvestrand, H., \"Tags for the Identification of Languages\", RFC 1766, March 1995.",
      "ja": "[6] Alvestrand、H。、「言語の識別のためのタグ」、RFC 1766、1995年3月。"
    },
    {
      "indent": 4,
      "text": "[7] Guttman, E., Perkins, C., Veizades, J. and M. Day, \"Service Location Protocol, Version 2\", RFC 2608, June 1999.",
      "ja": "[7] Guttman、E.、Perkins、C.、Veizades、J。and M. Day、「Service Location Protocol、Version 2」、RFC 2608、1999年6月。"
    },
    {
      "indent": 4,
      "text": "[8] Guttman, E., Perkins, C. and J. Kempf, \"Service Templates and Service: Schemes\", RFC 2609, June 1999.",
      "ja": "[8] Guttman、E.、Perkins、C。and J. Kempf、「サービステンプレートとサービス：スキーム」、RFC 2609、1999年6月。"
    },
    {
      "indent": 0,
      "text": "10. Authors' Addresses",
      "section_title": true,
      "ja": "10. 著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Questions about this memo can be directed to:",
      "ja": "このメモに関する質問は、次のように向けることができます。"
    },
    {
      "indent": 3,
      "text": "James Kempf Sun Microsystems 901 San Antonio Rd. Palo Alto, CA, 94303 USA",
      "ja": "James Kempf Sun Microsystems 901 San Antonio Rd。カリフォルニア州パロアルト、94303 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 650 786 5890\nFax:   +1 650 786 6445\nEMail: james.kempf@sun.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Erik Guttman Sun Microsystems Bahnstr. 2 74915 Waibstadt Germany",
      "ja": "Erik Guttman Sun Microsystems Bahnstr。2 74915 Waibstadtドイツ"
    },
    {
      "indent": 3,
      "text": "Phone: +49 7263 911 701\nEMail: erik.guttman@sun.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "11. Full Copyright Statement",
      "section_title": true,
      "ja": "11. 完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（1999）。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\"",
      "ja": "この文書と本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性またはフィットネスの権利または黙示的な保証を侵害します。」"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}