{
  "title": {
    "text": "RFC 2582 - The NewReno Modification to TCP's Fast Recovery Algorithm",
    "ja": "RFC 2582 - TCPの高速回復アルゴリズムへのNewreno変更"
  },
  "number": 2582,
  "created_at": "2024-02-23 12:39:42.305464+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                           S. Floyd\nRequest for Comments: 2582                                         ACIRI\nCategory: Experimental                                      T. Henderson\n                                                           U.C. Berkeley\n                                                              April 1999",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "The NewReno Modification to TCP's Fast Recovery Algorithm",
      "ja": "TCPの高速回復アルゴリズムへのNewreno変更"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind. Discussion and suggestions for improvement are requested. Distribution of this memo is unlimited.",
      "ja": "このメモは、インターネットコミュニティの実験プロトコルを定義します。いかなる種類のインターネット標準を指定しません。改善のための議論と提案が要求されます。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（1999）。無断転載を禁じます。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "RFC 2001 [RFC2001] documents the following four intertwined TCP congestion control algorithms: Slow Start, Congestion Avoidance, Fast Retransmit, and Fast Recovery. RFC 2581 [RFC2581] explicitly allows certain modifications of these algorithms, including modifications that use the TCP Selective Acknowledgement (SACK) option [MMFR96], and modifications that respond to \"partial acknowledgments\" (ACKs which cover new data, but not all the data outstanding when loss was detected) in the absence of SACK. This document describes a specific algorithm for responding to partial acknowledgments, referred to as NewReno. This response to partial acknowledgments was first proposed by Janey Hoe in [Hoe95].",
      "ja": "RFC 2001 [RFC2001]は、次の4つの絡み合ったTCP混雑制御アルゴリズムを文書化します：スロースタート、混雑回避、迅速な再送信、および高速回復。RFC 2581 [RFC2581]は、TCP Selective Aundment（SACK）オプション[MMFR96]を使用する変更や、「部分的な承認」（新しいデータをカバーするACK）に応答する変更を含む、これらのアルゴリズムの特定の変更を明示的に許可します。損失が検出されたときに未払い）袋がない場合。このドキュメントでは、NewRenoと呼ばれる部分的な謝辞に応答するための特定のアルゴリズムについて説明します。部分的な承認に対するこの応答は、[Hoe95]でJaney Hoeによって最初に提案されました。"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "For the typical implementation of the TCP Fast Recovery algorithm described in [RFC2581] (first implemented in the 1990 BSD Reno release, and referred to as the Reno algorithm in [FF96]), the TCP data sender only retransmits a packet after a retransmit timeout has occurred, or after three duplicate acknowledgements have arrived triggering the Fast Retransmit algorithm. A single retransmit timeout might result in the retransmission of several data packets, but each invocation of the Reno Fast Retransmit algorithm leads to the retransmission of only a single data packet.",
      "ja": "[RFC2581]で説明されているTCP高速回復アルゴリズムの典型的な実装について発生した、または3つの重複した謝辞が到着した後、高速再送信アルゴリズムをトリガーしました。単一の再送信タイムアウトにより、いくつかのデータパケットが再送信される可能性がありますが、RENO高速再送信アルゴリズムの各呼び出しは、単一のデータパケットのみの再送信につながります。"
    },
    {
      "indent": 3,
      "text": "Problems can arise, therefore, when multiple packets have been dropped from a single window of data and the Fast Retransmit and Fast Recovery algorithms are invoked. In this case, if the SACK option is available, the TCP sender has the information to make intelligent decisions about which packets to retransmit and which packets not to retransmit during Fast Recovery. This document applies only for TCP connections that are unable to use the TCP Selective Acknowledgement (SACK) option.",
      "ja": "したがって、複数のパケットが単一のデータウィンドウから削除され、高速再送信および高速回復アルゴリズムが呼び出されると、問題が発生する可能性があります。この場合、Sackオプションが利用可能な場合、TCP送信者は、再送信するパケットと、迅速な回復中に再送信しないパケットについてインテリジェントな決定を下すための情報を持っています。このドキュメントは、TCP Selective Aundment（SACK）オプションを使用できないTCP接続に対してのみ適用されます。"
    },
    {
      "indent": 3,
      "text": "In the absence of SACK, there is little information available to the TCP sender in making retransmission decisions during Fast Recovery. From the three duplicate acknowledgements, the sender infers a packet loss, and retransmits the indicated packet. After this, the data sender could receive additional duplicate acknowledgements, as the data receiver acknowledges additional data packets that were already in flight when the sender entered Fast Retransmit.",
      "ja": "SACKがない場合、TCP送信者は、迅速な回復中に再送信決定を行う際に利用できる情報はほとんどありません。3つの重複謝辞から、送信者はパケット損失を推進し、示されたパケットを再送信します。この後、データ受信者は、送信者が高速再送信に入ったときにすでに飛行中だった追加のデータパケットを認めているため、データ送信者は追加の重複謝辞を受信することができます。"
    },
    {
      "indent": 3,
      "text": "In the case of multiple packets dropped from a single window of data, the first new information available to the sender comes when the sender receives an acknowledgement for the retransmitted packet (that is the packet retransmitted when Fast Retransmit was first entered). If there had been a single packet drop, then the acknowledgement for this packet will acknowledge all of the packets transmitted before Fast Retransmit was entered (in the absence of reordering). However, when there were multiple packet drops, then the acknowledgement for the retransmitted packet will acknowledge some but not all of the packets transmitted before the Fast Retransmit. We call this packet a partial acknowledgment.",
      "ja": "複数のパケットがデータの単一ウィンドウからドロップされた場合、送信者が使用できる最初の新しい情報は、送信者が再送信パケットの謝辞を受け取ったときに発生します（つまり、Fastの再送信が最初に入力されたときに再送信されたパケット）。単一のパケットドロップがあった場合、このパケットの確認は、速い再送信が入力される前に送信されるすべてのパケットを確認します（並べ替えがない場合）。ただし、複数のパケットドロップがあった場合、再送信パケットの確認は、高速再送信の前に送信されたすべてのパケットではなく、一部を認めます。このパケットを部分的な承認と呼びます。"
    },
    {
      "indent": 3,
      "text": "Along with several other suggestions, [Hoe95] suggested that during Fast Recovery the TCP data sender respond to a partial acknowledgment by inferring that the indicated packet has been lost, and retransmitting that packet. This document describes a modification to the Fast Recovery algorithm in Reno TCP that incorporates a response to partial acknowledgements received during Fast Recovery. We call this modified Fast Recovery algorithm NewReno, because it is a slight but significant variation of the basic Reno algorithm. This document does not discuss the other suggestions in [Hoe95] and [Hoe96], such as a change to the ssthresh parameter during Slow-Start, or the proposal to send a new packet for every two duplicate acknowledgements during Fast Recovery. The version of NewReno in this document also draws on other discussions of NewReno in the literature [LM97].",
      "ja": "他のいくつかの提案とともに、[Hoe95]は、迅速な回復中に、示されたパケットが失われたことを推測し、そのパケットを再送信することにより、TCPデータ送信者が部分的な認識に応答することを示唆しました。このドキュメントでは、Reno TCPの高速回復アルゴリズムへの変更について説明します。これは、高速回復中に受け取った部分的な承認への応答を組み込んでいます。これは、基本的なリノアルゴリズムのわずかであるが大幅なバリエーションであるため、この修正された高速回復アルゴリズムをNewRenoと呼びます。このドキュメントでは、スロースタート中のSSthreshパラメーターの変更や、速い回復中に2つの重複謝辞ごとに新しいパケットを送信する提案など、[Hoe95]および[hoe96]の他の提案については説明しません。このドキュメントのNewrenoのバージョンは、文献[LM97]のNewrenoの他の議論も利用しています。"
    },
    {
      "indent": 3,
      "text": "We do not claim that the NewReno version of Fast Recovery described here is an optimal modification of Fast Recovery for responding to partial acknowledgements, for TCPs that are unable to use SACK. Based on our experiences with the NewReno modification in the NS simulator [NS], we believe that this modification improves the performance of the Fast Retransmit and Fast Recovery algorithms in a wide variety of scenarios, and we are simply documenting it for the benefit of the IETF community. We encourage the use of this modification to Fast Recovery, and we further encourage feedback about operational experiences with this or related modifications.",
      "ja": "ここで説明する高速回復のNewrenoバージョンは、袋を使用できないTCPの場合、部分的な認識に応答するための高速回復の最適な変更であるとは主張していません。NSシミュレーター[NS]でのNewReno修正の経験に基づいて、この変更により、さまざまなシナリオでの高速再送信および高速回復アルゴリズムのパフォーマンスが向上すると考えています。IETFコミュニティ。この修正の使用を促進するために、回復を迅速に行うことを奨励し、この変更または関連する変更に関する運用経験に関するフィードバックをさらに奨励します。"
    },
    {
      "indent": 0,
      "text": "2. Definitions",
      "section_title": true,
      "ja": "2. 定義"
    },
    {
      "indent": 3,
      "text": "This document assumes that the reader is familiar with the terms MAXIMUM SEGMENT SIZE (MSS), CONGESTION WINDOW (cwnd), and FLIGHT SIZE (FlightSize) defined in [RFC2581]. FLIGHT SIZE is defined as in [RFC2581] as follows:",
      "ja": "このドキュメントは、読者が[RFC2581]で定義されている最大セグメントサイズ（MSS）、輻輳ウィンドウ（CWND）、およびフライトサイズ（フライトサイズ）という用語に精通していることを前提としています。飛行サイズは、次のように[RFC2581]のように定義されます。"
    },
    {
      "indent": 6,
      "text": "FLIGHT SIZE: The amount of data that has been sent but not yet acknowledged.",
      "ja": "飛行サイズ：送信されたがまだ認められていないデータの量。"
    },
    {
      "indent": 0,
      "text": "3. The Fast Retransmit and Fast Recovery algorithms in NewReno",
      "section_title": true,
      "ja": "3. NewRenoの高速再送信および高速回復アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The standard implementation of the Fast Retransmit and Fast Recovery algorithms is given in [RFC2581]. The NewReno modification of these algorithms is given below. This NewReno modification differs from the implementation in [RFC2581] only in the introduction of the variable \"recover\" in step 1, and in the response to a partial or new acknowledgement in step 5. The modification defines a \"Fast Recovery procedure\" that begins when three duplicate ACKs are received and ends when either a retransmission timeout occurs or an ACK arrives that acknowledges all of the data up to and including the data that was outstanding when the Fast Recovery procedure began.",
      "ja": "高速再送信および高速回復アルゴリズムの標準的な実装は、[RFC2581]に記載されています。これらのアルゴリズムのNewReno変更を以下に示します。このNewRenoの変更は、[RFC2581]の実装とは、ステップ1の変数「回復」の導入と、ステップ5の部分的または新しい認識への応答でのみ異なります。変更は、開始される「高速回復手順」を定義します。3つの重複したACKを受信し、再送信タイムアウトが発生したときに終了するか、ACKが到着すると、高速回復手順が開始されたときに未解決のデータを含むすべてのデータを確認します。"
    },
    {
      "indent": 3,
      "text": "1. When the third duplicate ACK is received and the sender is not already in the Fast Recovery procedure, set ssthresh to no more than the value given in equation 1 below. (This is equation 3 from [RFC2581]).",
      "ja": "1. 3番目の複製ACKが受信され、送信者がまだ高速回復手順になっていない場合、ssthreshを以下の方程式1に示す値にすぎません。（これは[RFC2581]の式3です）。"
    },
    {
      "indent": 9,
      "text": "ssthresh = max (FlightSize / 2, 2*MSS)           (1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Record the highest sequence number transmitted in the variable \"recover\".",
      "ja": "変数「回復」に送信される最高のシーケンス番号を記録します。"
    },
    {
      "indent": 3,
      "text": "2. Retransmit the lost segment and set cwnd to ssthresh plus 3*MSS. This artificially \"inflates\" the congestion window by the number of segments (three) that have left the network and which the receiver has buffered.",
      "ja": "2. 失われたセグメントを再送信し、CWNDをSSTHRESH Plus 3*MSSに設定します。これは、ネットワークを離れて受信機がバッファリングしたセグメントの数（3）だけで、輻輳ウィンドウを人為的に「膨らませる」。"
    },
    {
      "indent": 3,
      "text": "3. For each additional duplicate ACK received, increment cwnd by MSS. This artificially inflates the congestion window in order to reflect the additional segment that has left the network.",
      "ja": "3. 受信した追加の複製ACKごとに、MSSがCWNDを増加させます。これにより、ネットワークを去った追加セグメントを反映するために、混雑ウィンドウを人為的に膨らませます。"
    },
    {
      "indent": 3,
      "text": "4. Transmit a segment, if allowed by the new value of cwnd and the receiver's advertised window.",
      "ja": "4. CWNDの新しい値とレシーバーの宣伝されたウィンドウで許可されている場合、セグメントを送信します。"
    },
    {
      "indent": 3,
      "text": "5. When an ACK arrives that acknowledges new data, this ACK could be the acknowledgment elicited by the retransmission from step 2, or elicited by a later retransmission.",
      "ja": "5. 新しいデータを認めるACKが到着すると、このACKは、ステップ2からの再送信によって誘発される承認である可能性があります。"
    },
    {
      "indent": 7,
      "text": "If this ACK acknowledges all of the data up to and including \"recover\", then the ACK acknowledges all the intermediate segments sent between the original transmission of the lost segment and the receipt of the third duplicate ACK. Set cwnd to either (1) min (ssthresh, FlightSize + MSS); or (2) ssthresh, where ssthresh is the value set in step 1; this is termed \"deflating\" the window. (We note that \"FlightSize\" in step 1 referred to the amount of data outstanding in step 1, when Fast Recovery was entered, while \"FlightSize\" in step 5 refers to the amount of data outstanding in step 5, when Fast Recovery is exited.) If the second option is selected, the implementation should take measures to avoid a possible burst of data, in case the amount of data outstanding in the network was much less than the new congestion window allows [HTH98]. Exit the Fast Recovery procedure.",
      "ja": "このACKが「回復」までのすべてのデータを認めた場合、ACKは、失われたセグメントの元の送信と3番目の複製ACKの受領との間に送信されるすべての中間セグメントを認めます。CWNDを（1）min（SSthresh、Flightsize MSS）に設定します。または（2）SSthresh、ここで、SSthreshはステップ1に設定された値です。これは、ウィンドウを「デフレ」と呼びます。（ステップ1の「フライトサイズ」は、高速回復が入力されたステップ1の未解決のデータの量を指し、ステップ5の「フライトサイズ」は、高速回復が終了するステップ5の未解決のデータの量を指します。。）2番目のオプションが選択されている場合、ネットワーク内のデータの量が新しい輻輳ウィンドウよりもはるかに少ない場合に、データのバーストの可能性を回避するための実装が測定を行う必要があります[HTH98]。高速回復手順を終了します。"
    },
    {
      "indent": 7,
      "text": "If this ACK does *not* acknowledge all of the data up to and including \"recover\", then this is a partial ACK. In this case, retransmit the first unacknowledged segment. Deflate the congestion window by the amount of new data acknowledged, then add back one MSS and send a new segment if permitted by the new value of cwnd. This \"partial window deflation\" attempts to ensure that, when Fast Recovery eventually ends, approximately ssthresh amount of data will be outstanding in the network. Do not exit the Fast Recovery procedure (i.e., if any duplicate ACKs subsequently arrive, execute Steps 3 and 4 above).",
      "ja": "このACKが「回復」までのすべてのデータを *認識しない場合、これは部分的なACKです。この場合、最初の未承認セグメントを再送信します。確認された新しいデータの量だけで輻輳ウィンドウをデフレートし、1つのMSSを追加して、CWNDの新しい値で許可されている場合は新しいセグメントを送信します。この「部分的なウィンドウデフレーション」は、最終的に迅速な回復が終了すると、ネットワークで約SSTHRESH量のデータが顕著になることを保証しようとします。高速回復手順を終了しないでください（つまり、重複したACKがその後到着した場合は、上記の手順3と4を実行します）。"
    },
    {
      "indent": 7,
      "text": "For the first partial ACK that arrives during Fast Recovery, also reset the retransmit timer.",
      "ja": "速い回復中に到着する最初の部分的なACKについては、再送信タイマーもリセットします。"
    },
    {
      "indent": 3,
      "text": "Note that in Step 5, the congestion window is deflated when a partial acknowledgement is received. The congestion window was likely to have been inflated considerably when the partial acknowledgement was received. In addition, depending on the original pattern of packet losses, the partial acknowledgement might acknowledge nearly a window of data. In this case, if the congestion window was not deflated, the data sender might be able to send nearly a window of data back-to-back.",
      "ja": "ステップ5では、部分的な認識が受信されると、輻輳ウィンドウがデクレートされることに注意してください。部分的な承認を受け取ったとき、輻輳窓はかなり膨らんだ可能性がありました。さらに、パケット損失の元のパターンに応じて、部分的な認識は、ほぼデータのウィンドウを認める可能性があります。この場合、輻輳ウィンドウが収縮していない場合、データ送信者はデータのほぼ窓を連続して送信できる可能性があります。"
    },
    {
      "indent": 3,
      "text": "There are several possible variants to the simple response to partial acknowledgements described above. First, there is a question of when to reset the retransmit timer after a partial acknowledgement. This is discussed further in Section 4 below.",
      "ja": "上記の部分的な承認に対する簡単な応答には、いくつかの可能なバリアントがあります。まず、部分的な認識の後に再送信タイマーをいつリセットするかという疑問があります。これについては、以下のセクション4でさらに説明します。"
    },
    {
      "indent": 3,
      "text": "There is a related question of how many packets to retransmit after each partial acknowledgement. The algorithm described above retransmits a single packet after each partial acknowledgement. This is the most conservative alternative, in that it is the least likely to result in an unnecessarily-retransmitted packet. A variant that would recover faster from a window with many packet drops would be to effectively Slow-Start, requiring less than N roundtrip times to recover from N losses [Hoe96]. With this slightly-more-aggressive response to partial acknowledgements, it would be advantageous to reset the retransmit timer after each retransmission. Because we have not experimented with this variant in our simulator, we do not discuss this variant further in this document.",
      "ja": "各部分的な承認後に再送信するパケットの数については、関連する質問があります。上記のアルゴリズムは、各部分的な確認の後に単一のパケットを再送信します。これは、不必要に再配置されたパケットをもたらす可能性が最も低いという点で、最も保守的な代替手段です。多くのパケットドロップでウィンドウからより速く回復するバリアントは、効果的にスロースタートすることであり、N損失から回復するためにNの往復時間未満が必要です[Hoe96]。部分的な謝辞に対するこのわずかに攻撃的な反応により、再送信ごとに再送信タイマーをリセットすることが有利です。シミュレータでこのバリアントを試していないため、このドキュメントではこのバリアントについてはこれ以上説明しません。"
    },
    {
      "indent": 3,
      "text": "A third question involves avoiding multiple Fast Retransmits caused by the retransmission of packets already received by the receiver. This is discussed in Section 5 below. Avoiding multiple Fast Retransmits is particularly important if more aggressive responses to partial acknowledgements are implemented, because in this case the sender is more likely to retransmit packets already received by the receiver.",
      "ja": "3番目の質問では、既に受信者が受け取ったパケットの再送信によって引き起こされる複数の高速再送信を回避することが含まれます。これについては、以下のセクション5で説明します。この場合、送信者は既に受信者が受け取ったパケットを再送信する可能性が高いため、部分的な承認に対するより積極的な応答が実装されている場合、複数の高速再送信を避けることは特に重要です。"
    },
    {
      "indent": 3,
      "text": "As a final note, we would observe that in the absence of the SACK option, the data sender is working from limited information. One could spend a great deal of time considering exactly which variant of Fast Recovery is optimal for which scenario in this case. When the issue of recovery from multiple dropped packets from a single window of data is of particular importance, the best alternative would be to use the SACK option.",
      "ja": "最後のメモとして、SACKオプションがない場合、データ送信者は限られた情報から動作していることがわかります。この場合、どのシナリオで最適なのかを正確に考慮して、かなりの時間を費やすことができます。データの1つのウィンドウから複数のドロップされたパケットからの回復の問題が特に重要である場合、最良の選択肢はSACKオプションを使用することです。"
    },
    {
      "indent": 0,
      "text": "4. Resetting the retransmit timer.",
      "ja": "4. 再送信タイマーのリセット。"
    },
    {
      "indent": 3,
      "text": "The algorithm in Section 3 resets the retransmit timer only after the first partial ACK. In this case, if a large number of packets were dropped from a window of data, the TCP data sender's retransmit timer will ultimately expire, and the TCP data sender will invoke Slow-Start. (This is illustrated on page 12 of [F98].) We call this the Impatient variant of NewReno.",
      "ja": "セクション3のアルゴリズムは、最初の部分ACKの後にのみ再送信タイマーをリセットします。この場合、データのウィンドウから多数のパケットがドロップされた場合、TCPデータ送信者の再送信タイマーが最終的に期限切れになり、TCPデータ送信者がスロースタートを呼び出します。（これは[F98]の12ページに示されています。）これをNewRenoのせっかちなバリアントと呼びます。"
    },
    {
      "indent": 3,
      "text": "In contrast, the NewReno simulations in [FF96] illustrate the algorithm described above, with the modification that the retransmit timer is reset after each partial acknowledgement. We call this the Slow-but-Steady variant of NewReno. In this case, for a window with a large number of packet drops, the TCP data sender retransmits at most one packet per roundtrip time. (This behavior is illustrated in the New-Reno TCP simulation of Figure 5 in [FF96], and on page 11 of [F98].)",
      "ja": "対照的に、[FF96]のNewRenoシミュレーションは、上記のアルゴリズムを示しており、各部分的な確認の後に再送信タイマーがリセットされるという変更となります。これを、newrenoのゆっくりとした状態の多いバリアントと呼びます。この場合、多数のパケットドロップを備えたウィンドウの場合、TCPデータ送信者は、往復時間ごとに最大1つのパケットで再送信されます。（この動作は、[FF96]の図5のNew-Reno TCPシミュレーションと[F98]の11ページに示されています。）"
    },
    {
      "indent": 3,
      "text": "For TCP implementations where the Retransmission Timeout Value (RTO) is generally not much larger than the round-trip time (RTT), the Impatient variant can result in a retransmit timeout even in a scenario with a small number of packet drops. For TCP implementations where the Retransmission Timeout Value (RTO) is usually considerably larger than the round-trip time (RTT), the Slow-but-Steady variant can remain in Fast Recovery for a long time when multiple packets have been dropped from a window of data. Neither of these variants are optimal; one possibility for a more optimal algorithm might be one that recovered more quickly from multiple packet drops, and combined this with the Slow-but-Steady variant in terms of resetting the retransmit timers. We note, however, that there is a limitation to the potential performance in this case in the absence of the SACK option.",
      "ja": "再送信タイムアウト値（RTO）が一般的に往復時間（RTT）よりもそれほど大きくないTCP実装の場合、せっかちなバリアントは、少数のパケットドロップを備えたシナリオでも再発タイムアウトをもたらす可能性があります。再送信タイムアウト値（RTO）が通常往復時間（RTT）よりもかなり大きいTCP実装の場合、窓から複数のパケットがドロップされている場合、ゆっくりとした状態の良いバリアントは長い間迅速に回復し続けることができますデータの。これらのバリアントはどちらも最適ではありません。より最適なアルゴリズムの可能性の1つは、複数のパケットドロップからより迅速に回復したものであり、これを再送信タイマーのリセットに関してゆっくりと浸透したバリアントと組み合わせたものです。ただし、サックオプションがない場合、この場合、潜在的なパフォーマンスには制限があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "5. Avoiding Multiple Fast Retransmits",
      "section_title": true,
      "ja": "5. 複数の高速再送信を避けます"
    },
    {
      "indent": 3,
      "text": "In the absence of the SACK option, a duplicate acknowledgement carries no information to identify the data packet or packets at the TCP data receiver that triggered that duplicate acknowledgement. The TCP data sender is unable to distinguish between a duplicate acknowledgement that results from a lost or delayed data packet, and a duplicate acknowledgement that results from the sender's retransmission of a data packet that had already been received at the TCP data receiver. Because of this, multiple segment losses from a single window of data can sometimes result in unnecessary multiple Fast Retransmits (and multiple reductions of the congestion window) [Flo94].",
      "ja": "SACKオプションがない場合、重複した承認には、その複製の確認をトリガーしたTCPデータ受信機のデータパケットまたはパケットを識別するための情報が含まれていません。TCPデータ送信者は、紛失または遅延のデータパケットから生じる重複した承認と、TCPデータ受信機ですでに受信されたデータパケットの送信者の再送信に起因する重複した承認を区別することができません。このため、単一のデータウィンドウからの複数のセグメントの損失により、不必要な複数の高速再送信（および渋滞ウィンドウの複数の削減）が発生する場合があります[Flo94]。"
    },
    {
      "indent": 3,
      "text": "With the Fast Retransmit and Fast Recovery algorithms in Reno or NewReno TCP, the performance problems caused by multiple Fast Retransmits are relatively minor (compared to the potential problems with Tahoe TCP, which does not implement Fast Recovery). Nevertheless, unnecessary Fast Retransmits can occur with Reno or NewReno TCP, particularly if a Retransmit Timeout occurs during Fast Recovery. (This is illustrated for Reno on page 6 of [F98], and for NewReno on page 8 of [F98].) With NewReno, the data sender remains in Fast Recovery until either a Retransmit Timeout, or until all of the data outstanding when Fast Retransmit was entered has been acknowledged. Thus with NewReno, the problem of multiple Fast Retransmits from a single window of data can only occur after a Retransmit Timeout.",
      "ja": "RENOまたはNewReno TCPの高速再送信および高速回復アルゴリズムにより、複数の高速再送信によって引き起こされるパフォーマンスの問題は比較的マイナーです（Tahoe TCPの潜在的な問題と比較して、高速回復を実装しません）。それにもかかわらず、特に速い回復中に再送信タイムアウトが発生した場合、RENOまたはNewReno TCPで不必要な高速再送信が発生する可能性があります。（これは、[F98]の6ページのRENO、および[F98]の8ページのNewRenoの場合と、NewRenoの場合、データ送信者は再び回復タイムアウトまで、またはすべてのデータが発行されるまで迅速に回復し続けます。高速再送信が入力されました。したがって、Newrenoでは、単一のデータウィンドウからの複数の高速再送信の問題は、再送信タイムアウト後にのみ発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "The following modification to the algorithms in Section 3 eliminates the problem of multiple Fast Retransmits. (This modification is called \"bugfix\" in [F98], and is illustrated on pages 7 and 9.) This modification uses a new variable \"send_high\", whose initial value is the initial send sequence number. After each retransmit timeout, the highest sequence numbers transmitted so far is recorded in the variable \"send_high\".",
      "ja": "セクション3のアルゴリズムの以下の変更により、複数の高速再送信の問題がなくなります。（この変更は[F98]の「bugfix」と呼ばれ、7ページと9ページに示されています。）この変更は、初期値が初期送信シーケンス番号である新しい変数「send_high」を使用します。各再送信タイムアウトの後、これまでに送信された最高のシーケンス番号は、変数「send_high」に記録されます。"
    },
    {
      "indent": 3,
      "text": "If, after a retransmit timeout, the TCP data sender retransmits three consecutive packets that have already been received by the data receiver, then the TCP data sender will receive three duplicate acknowledgements that do not acknowledge \"send_high\". In this case, the duplicate acknowledgements are not an indication of a new instance of congestion. They are simply an indication that the sender has unnecessarily retransmitted at least three packets.",
      "ja": "再送信タイムアウトの後、TCPデータ送信者がデータ受信機によってすでに受信されている3つの連続したパケットを再送信した場合、TCPデータ送信者は「Send_high」を認めない3つの重複謝辞を受け取ります。この場合、重複する謝辞は、渋滞の新しいインスタンスの兆候ではありません。それらは、送信者が少なくとも3つのパケットを不必要に再送信したことを単に示しています。"
    },
    {
      "indent": 3,
      "text": "We note that if the TCP data sender receives three duplicate acknowledgements that do not acknowledge \"send_high\", the sender does not know whether these duplicate acknowledgements resulted from a new packet drop or not. For a TCP that implements the bugfix described in this section for avoiding multiple fast retransmits, the sender does not infer a packet drop from duplicate acknowledgements in these circumstances. As always, the retransmit timer is the backup mechanism for inferring packet loss in this case.",
      "ja": "TCPデータ送信者が「send_high」を認めない3つの重複謝辞を受け取った場合、送信者はこれらの重複した謝辞が新しいパケットドロップに起因するかどうかを知らないことに注意してください。複数の高速再送信を回避するためにこのセクションで説明したバグフィックスを実装するTCPの場合、送信者は、これらの状況で重複した謝辞からパケットドロップを推測しません。いつものように、再送信タイマーは、この場合のパケット損失を推測するためのバックアップメカニズムです。"
    },
    {
      "indent": 3,
      "text": "The modification to Fast Retransmit for avoiding multiple Fast Retransmits replaces Step 1 in Section 3 with Step 1A below. In addition, the modification adds Step 6 below:",
      "ja": "複数の高速再送信を回避するための高速再送信の変更は、セクション3のステップ1を以下のステップ1aに置き換えます。さらに、変更は以下のステップ6を追加します。"
    },
    {
      "indent": 3,
      "text": "1A. When the third duplicate ACK is received and the sender is not already in the Fast Recovery procedure, check to see if those duplicate ACKs cover more than \"send_high\". If they do, then set ssthresh to no more than the value given in equation 1, record the the highest sequence number transmitted in the variable \"recover\", and go to Step 2. If the duplicate ACKs don't cover \"send_high\", then do nothing. That is, do not enter the Fast Retransmit and Fast Recovery procedure, do not change ssthresh, do not go to Step 2 to retransmit the \"lost\" segment, and do not execute Step 3 upon subsequent duplicate ACKs.",
      "ja": "1a。3番目の複製ACKが受信され、送信者がまだ高速回復手順になっていない場合は、それらの重複ACKが「send_high」を超えてカバーするかどうかを確認してください。そうした場合、ssthreshを式1で指定された値にすぎないように設定し、変数「回復」に送信される最高のシーケンス数を記録し、ステップ2に進みます。その後、何もしません。つまり、高速な再送信および高速回復手順を入力しないでください。SSthreshを変更しないでください。ステップ2にアクセスして「失われた」セグメントを再送信しないでください。後続の重複ACKでステップ3を実行しないでください。"
    },
    {
      "indent": 3,
      "text": "Steps 2-5 are the same as those steps in Section 3 above.",
      "ja": "ステップ2-5は、上記のセクション3の手順と同じです。"
    },
    {
      "indent": 3,
      "text": "6. After a retransmit timeout, record the highest sequence number transmitted in the variable \"send_high\" and exit the Fast Recovery procedure if applicable.",
      "ja": "6. 再送信タイムアウトの後、変数「send_high」に送信された最高のシーケンス番号を記録し、該当する場合は高速回復手順を終了します。"
    },
    {
      "indent": 3,
      "text": "Step 1A above, in checking whether the duplicate ACKs cover *more* than \"send_high\", is the Careful variant of this algorithm. Another possible variant would be to require simply that the three duplicate acknowledgements *cover* \"send_high\" before initiating another Fast Retransmit. We call this the Less Careful variant to Fast Retransmit.",
      "ja": "上記のステップ1aは、「send_high」よりも *より多くの *カバー *をカバーするかどうかを確認する際に、このアルゴリズムの慎重なバリアントです。別の可能性のあるバリアントは、別の高速再送信を開始する前に、3つの重複した謝辞 *カバー *「send_high」を単に要求することです。これを、再送信を高速にするために、あまり慎重でないバリアントと呼びます。"
    },
    {
      "indent": 3,
      "text": "There are two separate scenarios in which the TCP sender could receive three duplicate acknowledgements acknowledging \"send_high\" but no more than \"send_high\". One scenario would be that the data sender transmitted four packets with sequence numbers higher than \"send_high\", that the first packet was dropped in the network, and the following three packets triggered three duplicate acknowledgements acknowledging \"send_high\". The second scenario would be that the sender unnecessarily retransmitted three packets below \"send_high\", and that these three packets triggered three duplicate acknowledgements acknowledging \"send_high\". In the absence of SACK, the TCP sender in unable to distinguish between these two scenarios.",
      "ja": "TCP送信者が「send_high」を認めるが「send_high」以外の3つの重複した謝辞を受け取ることができる2つの個別のシナリオがあります。1つのシナリオは、データ送信者が「send_high」よりも高いシーケンス番号を持つ4つのパケットを送信し、最初のパケットがネットワークで削除され、次の3つのパケットが「send_high」を認める3つの重複した謝辞をトリガーしたことです。2番目のシナリオは、送信者が「send_high」の下に3つのパケットを不必要に再送信し、これら3つのパケットが「send_high」を認める3つの重複した謝辞をトリガーしたことです。袋がない場合、TCP送信者は、これら2つのシナリオを区別できません。"
    },
    {
      "indent": 3,
      "text": "For the Careful variant of Fast Retransmit, the data sender would have to wait for a retransmit timeout in the first scenario, but would not have an unnecessary Fast Retransmit in the second scenario. For the Less Careful variant to Fast Retransmit, the data sender would Fast Retransmit as desired in the first scenario, and would unnecessarily Fast Retransmit in the second scenario. The NS simulator has implemented the Less Careful variant of NewReno, and the TCP implementation in Sun's Solaris 7 implements the Careful variant. This document recommends the Careful variant given in Step 1A above.",
      "ja": "高速再送信の慎重なバリアントの場合、データ送信者は最初のシナリオで再送信タイムアウトを待つ必要がありますが、2番目のシナリオでは不必要な高速再送信はありません。慎重でないバリアントが急速に再送信するために、データ送信者は最初のシナリオで必要に応じて迅速に再送信され、2番目のシナリオでは不必要に高速な再送信を行います。NSシミュレーターは、NewRenoの慎重でないバリアントを実装しており、SunのSolaris 7のTCP実装は慎重なバリアントを実装しています。このドキュメントでは、上記のステップ1Aに示されている慎重なバリアントを推奨します。"
    },
    {
      "indent": 0,
      "text": "6. Implementation issues for the data receiver.",
      "ja": "6. データ受信機の実装の問題。"
    },
    {
      "indent": 3,
      "text": "[RFC2001] specifies that \"Out-of-order data segments SHOULD be acknowledged immediately, in order to trigger the fast retransmit algorithm.\" Neal Cardwell has noted [C98] that some data receivers do not send an immediate acknowledgement when they send a partial acknowledgment, but instead wait first for their delayed acknowledgement timer to expire. As [C98] notes, this severely limits the potential benefit from NewReno by delaying the receipt of the partial acknowledgement at the data sender. Our recommendation is that the data receiver send an immediate acknowledgement for an out-of-order segment, even when that out-of-order segment fills a hole in the buffer.",
      "ja": "[RFC2001]は、「高速再送信アルゴリズムをトリガーするために、「注文外のデータセグメント」を直ちに確認する必要がある」と指定しています。Neal Cardwellは、一部のデータ受信機は部分的な承認を送信する際に即時の謝辞を送信しないが、代わりに遅延承認タイマーが期限切れになるのを最初に待つことであると指摘しています。[C98]が指摘しているように、これはデータ送信者での部分的な承認の受領を遅らせることにより、Newrenoの潜在的な利益を厳しく制限します。私たちの推奨事項は、データレシーバーが、そのオーダーアウトセグメントがバッファーの穴を埋めた場合でも、順序外セグメントの即時の謝辞を送信することです。"
    },
    {
      "indent": 0,
      "text": "7. Simulations",
      "section_title": true,
      "ja": "7. シミュレーション"
    },
    {
      "indent": 3,
      "text": "Simulations with NewReno are illustrated with the validation test \"tcl/test/test-all-newreno\" in the NS simulator. The command \"../../ns test-suite-newreno.tcl reno\" shows a simulation with Reno TCP, illustrating the data sender's lack of response to a partial acknowledgement. In contrast, the command \"../../ns test-suite-newreno.tcl newreno_B\" shows a simulation with the same scenario using the NewReno algorithms described in this paper.",
      "ja": "NSシミュレーターの検証テスト「TCL/TEST/TEST-ALL-NEWRENO」を使用して、NewRenoを使用したシミュレーションが示されています。コマンド「..//NS TestSuite-newreno.tcl reno」は、Reno TCPのシミュレーションを示しており、データ送信者の部分的な認識に対する応答の欠如を示しています。対照的に、コマンド「..//NS TestSuite-newreno.tcl newreno_b」は、このペーパーで説明されているNewRenoアルゴリズムを使用して、同じシナリオのシミュレーションを表示します。"
    },
    {
      "indent": 3,
      "text": "The tests \"../../ns test-suite-newreno.tcl newreno1_B0\" and \"../../ns test-suite-newreno.tcl newreno1_B\" show the Slow-but-Steady and the Impatient variants of NewReno, respectively.",
      "ja": "テスト「..///NS TestSuite-newreno.tcl newreno1_b0」および「..///NS TestSuite-newreno.tcl newreno1_b」、 それぞれ。"
    },
    {
      "indent": 0,
      "text": "8. Conclusions",
      "section_title": true,
      "ja": "8. 結論"
    },
    {
      "indent": 3,
      "text": "Our recommendation is that TCP implementations include the NewReno modification to the Fast Recovery algorithm given in Section 3, along with the modification for avoiding multiple Fast Retransmits given in Section 5. The NewReno modification given in Section 3 can be important even for TCP implementations that support the SACK option, because the SACK option can only be used for TCP connections when both TCP end-nodes support the SACK option. The NewReno modification given in Section 3 implements the Impatient rather than the Slow-but-Steady variant of NewReno.",
      "ja": "TCPの実装には、セクション3で与えられた高速回復アルゴリズムへのNewrenoの変更と、セクション5で与えられた複数の高速再送信を回避するための変更が含まれることです。SACKオプションは、両方のTCPエンドノードがサックオプションをサポートしている場合にのみ、TCP接続にのみ使用できるためです。セクション3に記載されているNewrenoの変更は、Newrenoのゆっくりとした浸透したバリアントではなく、せっかちなものを実装しています。"
    },
    {
      "indent": 3,
      "text": "While this document mentions several possible variations to the NewReno algorithm, we have not explored all of these possible variations, and therefore are unable to make recommendations about some of them. Our belief is that the differences between any two variants of NewReno are small compared to the differences between Reno and NewReno. That is, the important thing is to implement NewReno instead of Reno, for a TCP invocation without SACK; it is less important exactly which variant of NewReno is implemented.",
      "ja": "このドキュメントでは、NewRenoアルゴリズムにいくつかの可能なバリエーションを言及していますが、これらの可能なバリエーションのすべてを調査していないため、それらのいくつかについて推奨することができません。私たちの信念は、Newrenoの任意の2つのバリアントの違いは、RenoとNewrenoの違いに比べて小さいということです。つまり、重要なことは、袋のないTCPの呼び出しのために、リノの代わりにnewrenoを実装することです。NewRenoのどのバリアントが実装されているかは正確には重要ではありません。"
    },
    {
      "indent": 0,
      "text": "9. Acknowledgements",
      "section_title": true,
      "ja": "9. 謝辞"
    },
    {
      "indent": 3,
      "text": "Many thanks to Anil Agarwal, Mark Allman, Vern Paxson, Kacheong Poon, and Bernie Volz for detailed feedback on this document.",
      "ja": "このドキュメントに関する詳細なフィードバックについては、Anil Agarwal、Mark Allman、Vern Paxson、Kacheong Poon、およびBernie Volzに感謝します。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 3,
      "text": "[C98] Neal Cardwell, \"delayed ACKs for retransmitted packets: ouch!\". November 1998. Email to the tcpimpl mailing list, Message-ID \"Pine.LNX.4.02A.9811021421340.26785- 100000@sake.cs.washington.edu\", archived at \"http://tcp-impl.lerc.nasa.gov/tcp-impl\".",
      "ja": "[C98] Neal Cardwell、「再送信パケットの遅延Acks：Ouch！」。1998年11月。TCPIMPLメーリングリスト、Message-ID \"Pine.lnx.4.02a.9811021421340.26785-100000@sake.cs.washington.edu\"にメールを送信します。/TCP-IMPL \"。"
    },
    {
      "indent": 3,
      "text": "[F98] Sally Floyd. Revisions to RFC 2001. Presentation to the TCPIMPL Working Group, August 1998. URLs \"ftp://ftp.ee.lbl.gov/talks/sf-tcpimpl-aug98.ps\" and \"ftp://ftp.ee.lbl.gov/talks/sf-tcpimpl-aug98.pdf\".",
      "ja": "[F98]サリー・フロイド。RFC 2001の改訂。TCPIMPLワーキンググループへのプレゼンテーション、1998年8月。URLS「FTP://ftp.ee.lbl.gov/talks/SF-tcpimpl-aug98.ps」および「ftp：//ftp.ee.lbl.gov/talks/sf-tcpimpl-aug98.pdf \"。"
    },
    {
      "indent": 3,
      "text": "[FF96] Kevin Fall and Sally Floyd. Simulation-based",
      "ja": "[FF96]ケビンフォールとサリーフロイド。シミュレーションベース"
    },
    {
      "indent": 17,
      "text": "Comparisons of Tahoe, Reno and SACK TCP. Computer Communication Review, July 1996. URL \"ftp://ftp.ee.lbl.gov/papers/sacks.ps.Z\".",
      "ja": "タホ、リノ、サックTCPの比較。コンピューター通信レビュー、1996年7月。URL「ftp://ftp.ee.lbl.gov/papers/sacks.ps.z」。"
    },
    {
      "indent": 3,
      "text": "[Flo94] S. Floyd, TCP and Successive Fast Retransmits. Technical report, October 1994. URL \"ftp://ftp.ee.lbl.gov/papers/fastretrans.ps\".",
      "ja": "[flo94] S.フロイド、TCPおよび連続した高速再送信。テクニカルレポート、1994年10月。URL「ftp://ftp.ee.lbl.gov/papers/fastretrans.ps」。"
    },
    {
      "indent": 3,
      "text": "[Hen98] Tom Henderson, Re: NewReno and the 2001 Revision. September 1998. Email to the tcpimpl mailing list, Message ID \"Pine.BSI.3.95.980923224136.26134A-100000@raptor.CS.Berkeley.EDU\", archived at \"http://tcp-impl.lerc.nasa.gov/tcp-impl\".",
      "ja": "[HEN98] Tom Henderson、Re：Newreno and The 2001 Revision。1998年9月。TCPIMPLメーリングリスト、メッセージID \"Pine.bsi.3.98092324136.26134a-100000@raptor.cs.berkeley.eduへのメール]、\" http://tcp-impl.lerc.nasa.gov/TCP-IMPL \"。"
    },
    {
      "indent": 3,
      "text": "[Hoe95] J. Hoe, Startup Dynamics of TCP's Congestion Control and Avoidance Schemes. Master's Thesis, MIT, 1995. URL \"http://ana-www.lcs.mit.edu/anaweb/ps-papers/hoe-thesis.ps\".",
      "ja": "[Hoe95] J. Hoe、TCPの混雑制御と回避スキームのスタートアップダイナミクス。Master's論文、MIT、1995。"
    },
    {
      "indent": 3,
      "text": "[Hoe96] J. Hoe, \"Improving the Start-up Behavior of a Congestion Control Scheme for TCP\", In ACM SIGCOMM, August 1996. URL \"http://www.acm.org/sigcomm/sigcomm96/program.html\".",
      "ja": "[Hoe96] J. Hoe、「TCPの混雑制御スキームのスタートアップ動作の改善」、ACM Sigcomm、1996年8月。URL「http://www.acm.org/sigcomm/sigcomm96/program.html」」。"
    },
    {
      "indent": 3,
      "text": "[HTH98] Hughes, A., Touch, J. and J. Heidemann, \"Issues in TCP Slow-Start Restart After Idle\", Work in Progress, March 1998.",
      "ja": "[HTH98] Hughes、A.、Touch、J。およびJ. Heidemann、「アイドル後のTCPスロースタート再起動の問題」、1998年3月、進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[LM97] Dong Lin and Robert Morris, \"Dynamics of Random Early Detection\", SIGCOMM 97, September 1997. URL \"http://www.acm.org/sigcomm/sigcomm97/program.html\".",
      "ja": "[LM97]ドン・リンとロバート・モリス、「ランダムアーリー検出のダイナミクス」、Sigcomm 97、1997年9月。URL「http://www.acm.org/sigcomm/sigcomm97/program.html」。"
    },
    {
      "indent": 3,
      "text": "[MMFR96] Mathis, M., Mahdavi, J., Floyd, S. and A. Romanow, \"TCP Selective Acknowledgement Options\", RFC 2018, October 1996.",
      "ja": "[MMFR96] Mathis、M.、Mahdavi、J.、Floyd、S。、およびA. Romanow、「TCP選択的承認オプション」、RFC 2018、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[NS] The UCB/LBNL/VINT Network Simulator (NS). URL \"http://www-mash.cs.berkeley.edu/ns/\".",
      "ja": "[NS] UCB/LBNL/VINTネットワークシミュレーター（NS）。url \"http://www-mash.cs.berkeley.edu/ns/\"。"
    },
    {
      "indent": 3,
      "text": "[RFC2001] Stevens, W., \"TCP Slow Start, Congestion Avoidance, Fast Retransmit, and Fast Recovery Algorithms\", RFC 2001, January 1997.",
      "ja": "[RFC2001] Stevens、W。、「TCPスロースタート、混雑回避、高速再送信、および高速回復アルゴリズム」、RFC 2001、1997年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC2581] Stevens, W., Allman, M. and V. Paxson, \"TCP Congestion Control\", RFC 2581, April 1999.",
      "ja": "[RFC2581] Stevens、W.、Allman、M。and V. Paxson、「TCP混雑制御」、RFC 2581、1999年4月。"
    },
    {
      "indent": 0,
      "text": "11. Security Considerations",
      "section_title": true,
      "ja": "11. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "RFC 2581 discusses general security considerations concerning TCP congestion control. This document describes a specific algorithm that conforms with the congestion control requirements of RFC 2581, and so those considerations apply to this algorithm, too. There are no known additional security concerns for this specific algorithm.",
      "ja": "RFC 2581は、TCP混雑制御に関する一般的なセキュリティ上の考慮事項について説明しています。このドキュメントでは、RFC 2581の輻輳制御要件に準拠する特定のアルゴリズムについて説明しているため、これらの考慮事項もこのアルゴリズムに適用されます。この特定のアルゴリズムに関する追加のセキュリティ上の懸念はありません。"
    },
    {
      "indent": 0,
      "text": "12. AUTHORS' ADDRESSES",
      "section_title": true,
      "ja": "12. 著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Sally Floyd AT&T Center for Internet Research at ICSI (ACIRI)",
      "ja": "ICSIのインターネット研究のためのSally Floyd AT＆Tセンター（Aciri）"
    },
    {
      "indent": 3,
      "text": "Phone: +1 (510) 642-4274 x189\nEMail: floyd@acm.org\nURL:  http://www.aciri.org/floyd/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Tom Henderson University of California at Berkeley",
      "ja": "カリフォルニア大学バークレー校トムヘンダーソン校"
    },
    {
      "indent": 3,
      "text": "Phone: +1 (510) 642-8919\nEMail: tomh@cs.berkeley.edu\nURL: http://www.cs.berkeley.edu/~tomh/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "13. Full Copyright Statement",
      "section_title": true,
      "ja": "13. 完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（1999）。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書と本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。"
    }
  ]
}