{
  "title": {
    "text": "RFC 2723 - SRL: A Language for Describing Traffic Flows and Specifying Actions for Flow Groups",
    "ja": "RFC 2723 - SRL：トラフィックフローを説明し、フローグループのアクションを指定するための言語"
  },
  "number": 2723,
  "created_at": "2024-02-05 09:17:28.463497+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                        N. Brownlee\nRequest for Comments: 2723                    The University of Auckland\nCategory: Informational                                     October 1999",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "SRL: A Language for Describing Traffic Flows and Specifying Actions for Flow Groups",
      "ja": "SRL：トラフィックフローを説明し、フローグループのアクションを指定するための言語"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモは、インターネットコミュニティに情報を提供します。いかなる種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（1999）。無断転載を禁じます。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes a language for specifying rulesets, i.e. configuration files which may be loaded into a traffic flow meter so as to specify which traffic flows are measured by the meter, and the information it will store for each flow.",
      "ja": "このドキュメントでは、ルールセットを指定するための言語、つまり、メーターによって測定されるトラフィックフローと、各フローに対して保存される情報を指定するために、トラフィックフローメーターにロードされる構成ファイルについて説明します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1  Purpose and Scope . . . . . . . . . . . . . . . . . . . . . .    2\n   1.1 RTFM Meters and Traffic Flows . . . . . . . . . . . . . .    2\n   1.2 SRL Overview  . . . . . . . . . . . . . . . . . . . . . .    3\n2  SRL Language Description  . . . . . . . . . . . . . . . . . .    4\n   2.1 Define Directive  . . . . . . . . . . . . . . . . . . . .    4\n   2.2 Program . . . . . . . . . . . . . . . . . . . . . . . . .    5\n   2.3 Declaration . . . . . . . . . . . . . . . . . . . . . . .    5\n3  Statement . . . . . . . . . . . . . . . . . . . . . . . . . .    5\n   3.1 IF_statement  . . . . . . . . . . . . . . . . . . . . . .    6\n       3.1.1 expression  . . . . . . . . . . . . . . . . . . . .    6\n       3.1.2 term  . . . . . . . . . . . . . . . . . . . . . . .    6\n       3.1.3 factor  . . . . . . . . . . . . . . . . . . . . . .    6\n       3.1.4 operand_list  . . . . . . . . . . . . . . . . . . .    6\n       3.1.5 operand . . . . . . . . . . . . . . . . . . . . . .    6\n       3.1.6 Test Part . . . . . . . . . . . . . . . . . . . . .    7\n       3.1.7 Action Part . . . . . . . . . . . . . . . . . . . .    8\n       3.1.8 ELSE Clause . . . . . . . . . . . . . . . . . . . .    8\n   3.2 Compound_statement  . . . . . . . . . . . . . . . . . . .    8\n   3.3 Imperative_statement  . . . . . . . . . . . . . . . . . .    9\n       3.3.1 SAVE Statement  . . . . . . . . . . . . . . . . . .    9\n       3.3.2 COUNT Statement . . . . . . . . . . . . . . . . . .   10\n          3.3.3 EXIT Statement  . . . . . . . . . . . . . . . . . .   10\n       3.3.4 IGNORE Statement  . . . . . . . . . . . . . . . . .   10\n       3.3.5 NOMATCH Statement . . . . . . . . . . . . . . . . .   10\n       3.3.6 STORE Statement . . . . . . . . . . . . . . . . . .   11\n       3.3.7 RETURN Statement  . . . . . . . . . . . . . . . . .   11\n   3.4 Subroutine_declaration  . . . . . . . . . . . . . . . . .   11\n   3.5 CALL_statement  . . . . . . . . . . . . . . . . . . . . .   12\n4  Example Programs  . . . . . . . . . . . . . . . . . . . . . .   13\n   4.1 Classify IP Port Numbers  . . . . . . . . . . . . . . . .   13\n   4.2 Classify Traffic into Groups of Networks  . . . . . . . .   14\n5  Security Considerations . . . . . . . . . . . . . . . . . . .   15\n6  IANA Considerations . . . . . . . . . . . . . . . . . . . . .   15\n7  APPENDICES  . . . . . . . . . . . . . . . . . . . . . . . . .   16\n   7.1 Appendix A: SRL Syntax in BNF . . . . . . . . . . . . . .   16\n   7.2 Appendix B: Syntax for Values and Masks . . . . . . . . .   18\n   7.3 Appendix C: RTFM Attribute Information  . . . . . . . . .   19\n8  Acknowledgments . . . . . . . . . . . . . . . . . . . . . . .   20\n9  References  . . . . . . . . . . . . . . . . . . . . . . . . .   20\n10 Author's Address  . . . . . . . . . . . . . . . . . . . . . .   21\n11 Full Copyright Statement  . . . . . . . . . . . . . . . . . .   22",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1 Purpose and Scope",
      "ja": "1つの目的と範囲"
    },
    {
      "indent": 3,
      "text": "A ruleset for an RTFM Meter is a sequence of instructions to be executed by the meter's Pattern Matching Engine (PME). The form of these instructions is described in detail in the 'RTFM Architecture' and 'RTFM Meter MIB' documents [RTFM-ARC, RTFM-MIB], but most users - at least initially - find them confusing and difficult to write, mainly because the effect of each instruction is strongly dependent on the state of the meter's Packet Matching Engine at the moment of its execution.",
      "ja": "RTFMメーターのルールセットは、メーターのパターンマッチングエンジン（PME）によって実行される一連の命令です。これらの指示の形式は、「RTFMアーキテクチャ」および「RTFMメーターMIB」ドキュメント[RTFM -ARC、RTFM -MIB]で詳細に説明されていますが、ほとんどのユーザーは、少なくとも最初は混乱して書くのが難しいと感じています。各命令の効果は、実行時にメーターのパケットマッチングエンジンの状態に強く依存しています。"
    },
    {
      "indent": 3,
      "text": "SRL (the Simple Ruleset Language) is a procedural language for creating RTFM rulesets. It has been designed to be simple for people to understand, using statements which help to clarify the execution context in which they operate. SRL programs will be compiled into rulesets which can then be downloaded to RTFM meters.",
      "ja": "SRL（シンプルルールセット言語）は、RTFMルールセットを作成するための手続き言語です。人々が理解するのが簡単であるように設計されており、動作する実行コンテキストを明確にするのに役立つステートメントを使用しています。SRLプログラムは、RTFMメーターにダウンロードできるルールセットにまとめられます。"
    },
    {
      "indent": 3,
      "text": "An SRL compiler is available as part of NeTraMet (a free-software implementation of the RTFM meter and manager), version 4.2 [NETRAMET].",
      "ja": "SRLコンパイラは、NetRamet（RTFMメーターとマネージャーのフリーソフトウェア実装）の一部として利用できます。バージョン4.2 [Netramet]。"
    },
    {
      "indent": 0,
      "text": "1.1 RTFM Meters and Traffic Flows",
      "section_title": true,
      "ja": "1.1 RTFMメーターとトラフィックフロー"
    },
    {
      "indent": 3,
      "text": "The RTFM Architecture [RTFM-ARC] defines a set of 'attributes' which apply to network traffic. Among the attributes are 'address attributes,' such as PeerType, PeerAddress, TransType and TransAddress, which have meaning for many protocols, e.g. for IPv4 traffic (PeerType == 1) PeerAddress is an IP address, TransType is TCP(6), UDP(17), ICMP(1), etc., and TransAddress is usually an IP port number.",
      "ja": "RTFMアーキテクチャ[RTFM-ARC]は、ネットワークトラフィックに適用される「属性」のセットを定義します。属性には、PeerType、PeerAddress、TranStype、TransAddressなどの「アドレス属性」があります。これらは、多くのプロトコルに意味があります。IPv4トラフィック（Peertype == 1）の場合、PeerAddressはIPアドレスであり、TranStypeはTCP（6）、UDP（17）、ICMP（1）など、およびTransAddressは通常IPポート番号です。"
    },
    {
      "indent": 3,
      "text": "An 'RTFM Traffic Flow' is simply a stream of packets observed by a meter as they pass across a network between two end points (or to/from a single end point). Each 'end point' of a flow is specified by the set of values of its address attributes.",
      "ja": "「RTFMトラフィックフロー」は、2つのエンドポイント（または単一のエンドポイントから）の間のネットワークを通過するときに、メーターで観察されるパケットのストリームです。フローの各「エンドポイント」は、アドレス属性の値のセットによって指定されます。"
    },
    {
      "indent": 3,
      "text": "An 'RTFM Meter' is a measuring device - e.g. a program running on a Unix or PC host - which observes passing packets and builds 'Flow Data Records' for the flows of interest.",
      "ja": "「RTFMメーター」は測定デバイスです。UNIXまたはPCホストで実行されるプログラムは、対象の流れのためにパケットを通過させ、「フローデータレコード」を構築します。"
    },
    {
      "indent": 3,
      "text": "RTFM traffic flows have another important property - they are bi-directional. This means that each flow data record in the meter has two sets of counters, one for packets travelling from source to destination, the other for returning packets. Within the RTFM architecture such counters appear as further attributes of the flow.",
      "ja": "RTFMトラフィックフローには別の重要な特性があります - それらは双方向です。これは、メーター内の各フローデータレコードには2つのカウンターがあり、1つはソースから目的地へと移動するパケット用、もう1つはパケットを返すパケット用です。RTFMアーキテクチャ内では、このようなカウンターは、フローのさらなる属性として表示されます。"
    },
    {
      "indent": 3,
      "text": "An RTFM meter must be configured by the user, which means creating a 'Ruleset' so as to specify which flows are to be measured, and how much information (i.e. which attributes) should be stored for each of them. A ruleset is effectively a program for a minimal virtual machine, the 'Packet Matching Engine (PME),' which is described in detail in [RTFM-ARC]. An RTFM meter may run multiple rule sets, with every passing packet being processed by each of the rulesets. The rule 'actions' in this document are described as though only a single ruleset were running.",
      "ja": "RTFMメーターはユーザーが構成する必要があります。これは、測定するフローと、それぞれにどの程度の情報（つまりどの属性）を保存するかを指定するために「ルールセット」を作成することを意味します。ルールセットは、事実上、最小限の仮想マシンである「パケットマッチングエンジン（PME）」のプログラムであり、[RTFM-ARC]で詳細に説明されています。RTFMメーターは複数のルールセットを実行する場合があり、各ルールセットによって処理されるすべてのパケットが処理されます。このドキュメントのルール「アクション」は、単一のルールセットのみが実行されているかのように説明されています。"
    },
    {
      "indent": 3,
      "text": "In the past creating a ruleset has meant writing machine code for the PME, which has proved rather difficult to do. SRL provides a high-level language which should enable users to create effective rulesets without having to understand the details of the PME.",
      "ja": "過去には、ルールセットを作成することは、PMEのマシンコードを作成することを意味していました。SRLは、PMEの詳細を理解することなく、ユーザーが効果的なルールセットを作成できるようにする高レベルの言語を提供します。"
    },
    {
      "indent": 3,
      "text": "The language may be useful in other applications, being suitable for any application area which involves selecting traffic flows from a stream of packets.",
      "ja": "言語は、他のアプリケーションで役立つ場合があり、パケットのストリームからトラフィックフローを選択することを伴うアプリケーションエリアに適しています。"
    },
    {
      "indent": 0,
      "text": "1.2 SRL Overview",
      "section_title": true,
      "ja": "1.2 SRLの概要"
    },
    {
      "indent": 3,
      "text": "An SRL program is executed from the beginning for each new packet arriving at the meter. It has two essential goals.",
      "ja": "SRLプログラムは、メーターに到着する新しいパケットごとに最初から実行されます。2つの重要な目標があります。"
    },
    {
      "indent": 3,
      "text": "(a) Decide whether the current packet is part of a flow which is of interest and, if necessary, determine its direction (i.e. decide which of its end-points is considered to be its source). Other packets will be ignored.",
      "ja": "(a) 現在のパケットが関心のあるフローの一部であるかどうかを決定し、必要に応じてその方向を決定します（つまり、そのエンドポイントのどれがそのソースと見なされているかを決定します）。他のパケットは無視されます。"
    },
    {
      "indent": 3,
      "text": "(b) SAVE whatever information is required to identify the flow and accumulate (COUNT) quantitative information for that flow.",
      "ja": "(b) 流れを識別するために必要な情報を保存し、そのフローの定量情報を蓄積します（カウント）。"
    },
    {
      "indent": 3,
      "text": "At execution, the meter's Packet Matching Engine (PME) begins by using source and destination attributes as they appear 'on the wire.' If the attributes do not match those of a flow to be recorded, the PME will normally execute the program again, this time with the source and destination addresses interchanged. Because of this bi-directional matching, an RTFM meter is able to build up tables of flows with two sets of counters - one for forward packets, the other for backward packets. The programmer can, if required, suppress the reverse-direction matching and assign 'forward' and 'backward' directions which conform to the conventions of the external context.",
      "ja": "実行時に、メーターのパケットマッチングエンジン（PME）は、「ワイヤー上」に表示されるソースと宛先の属性を使用することから始まります。記録されるフローの属性と一致しない場合、PMEは通常、プログラムを再度実行します。今回はソースと宛先アドレスが交換されます。この双方向のマッチングにより、RTFMメーターは、2セットのカウンターでフローのテーブルを構築できます。1つは前方パケット用、もう1つは後方パケット用です。プログラマーは、必要に応じて、逆方向の一致を抑制し、外部コンテキストの慣習に適合する「フォワード」方向と「後方」方向を割り当てることができます。"
    },
    {
      "indent": 3,
      "text": "Goal (a) is achieved using IF statements which perform comparisons on information from the packet or from SRL variables. Goal (b) is achieved using one or more SAVE statements to store the flow's identification attributes; a COUNT statement then increments the statistical data accumulating for it.",
      "ja": "目標（a）は、パケットまたはSRL変数からの情報の比較を実行するステートメントを使用して達成されます。目標（b）は、1つ以上の保存ステートメントを使用して達成され、フローの識別属性を保存します。その後、カウントステートメントは、それに蓄積する統計データを増加させます。"
    },
    {
      "indent": 0,
      "text": "2 SRL Language Description",
      "ja": "2 SRL言語の説明"
    },
    {
      "indent": 3,
      "text": "The SRL language is explained below using 'railway diagrams' to describe the syntax. Flow through a diagram is from left to right. The only exception to this is that lines carrying a left arrow may only be traversed right to left. In the diagrams, keywords are written in capital letters; in practice an SRL compiler must be insensitive to case. Lower-case identifiers are explained in the text, or they refer to another diagram.",
      "ja": "SRL言語は、「鉄道図」を使用して構文を記述して以下で説明します。図を通る流れは左から右にあります。これの唯一の例外は、左矢印を運ぶ線が左から右にしか横断されないことです。図では、キーワードは大文字で書かれています。実際には、SRLコンパイラはケースに鈍感でなければなりません。低ケースの識別子がテキストで説明されているか、別の図を参照します。"
    },
    {
      "indent": 3,
      "text": "The tokens of an SRL program obey the following rules:",
      "ja": "SRLプログラムのトークンは、次のルールに従います。"
    },
    {
      "indent": 3,
      "text": "- Comments may appear on any line of an SRL program, following a # - White space is used to separate tokens - Semicolon is used as the terminator for most statements - Identifiers (e.g. for defines and labels) must start with a letter - Identifiers may contain letters, digits and underscores - The case of letters is not significant - Reserved words (shown in upper case in this document) may not be used as identifiers",
      "ja": "- コメントは、＃-ホワイトスペースを使用してトークンを分離するために使用されるSRLプログラムの任意の行に表示される場合があります - セミコロンはほとんどのステートメントのターミネーターとして使用されます - 識別子（例：定義およびラベルなど）は、文字から始める必要があります - 識別子に含まれる場合があります文字、数字、アンダースコア - 文字のケースは重要ではありません - 予約済みの単語（このドキュメントの上級で示されています）は識別子として使用できません"
    },
    {
      "indent": 0,
      "text": "2.1 Define Directive",
      "section_title": true,
      "ja": "2.1 指令を定義します"
    },
    {
      "indent": 3,
      "text": "--- DEFINE -- defname ---- = ---- defined_text ------------------ ;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Simple parameterless defines are supported via the syntax above. The define name, defname, is an identifier. The defined text starts after the equal sign, and continues up to (but not including) the closing semicolon. If a semicolon is required within the defined text it must be preceded by a backslash, i.e. \\; in an SRL define produces ; in the text.",
      "ja": "単純なパラメーターレス定義は、上記の構文を介してサポートされています。定義名、defnameは識別子です。定義されたテキストは等しい符号の後に始まり、閉じたセミコロンまで続きます（ただしません）。定義されたテキスト内でセミコロンが必要な場合、バックスラッシュの前に先行する必要があります。SRLで定義の生成。テキストで。"
    },
    {
      "indent": 3,
      "text": "Wherever defname appears elsewhere in the program, it will be replaced by the defined text.",
      "ja": "defnameがプログラムの他の場所に表示される場所では、定義されたテキストに置き換えられます。"
    },
    {
      "indent": 3,
      "text": "For example,",
      "ja": "例えば、"
    },
    {
      "indent": 3,
      "text": "DEFINE ftp = (20, 21);  # Well-known Port numbers from [ASG-NBR]\nDEFINE telnet = 23;\nDEFINE www = 80;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.2 Program",
      "section_title": true,
      "ja": "2.2 プログラム"
    },
    {
      "indent": 3,
      "text": "------------+-------+-------- Statement -------+-------+-----------\n            |       |                          |       |\n            |       +------- Declaration ------+       |\n            |                                          |\n            +---------------------<--------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An SRL program is a sequence of statements or declarations. It does not have any special enclosing symbols. Statements and declarations terminate with a semicolon, except for compound statements, which terminate with a right brace.",
      "ja": "SRLプログラムは、一連のステートメントまたは宣言です。特別な囲いシンボルはありません。声明と宣言は、右装具で終了する複合ステートメントを除き、セミコロンで終了します。"
    },
    {
      "indent": 0,
      "text": "2.3 Declaration",
      "section_title": true,
      "ja": "2.3 宣言"
    },
    {
      "indent": 3,
      "text": "---------------------- Subroutine_declaration ---------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "SRL's only explicit declaration is the subroutine declaration. Other implicit declarations are labels (declared where they appear in front of a statement) and subroutine parameters (declared in the subroutine header).",
      "ja": "SRLの唯一の明示的な宣言は、サブルーチン宣言です。その他の暗黙の宣言は、ラベル（声明の前に表示される場所で宣言）とサブルーチンパラメーター（サブルーチンヘッダーで宣言）です。"
    },
    {
      "indent": 0,
      "text": "3 Statement",
      "ja": "3ステートメント"
    },
    {
      "indent": 3,
      "text": "----------------+---- IF_statement ----------------+---------------\n                |                                  |\n                +---- Compound_statement ----------+\n                |                                  |\n                +---- Imperative_statement --------+\n                |                                  |\n                +---- CALL_statement --------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An SRL program is a sequence of SRL statements. There are four kinds of statements, as follows.",
      "ja": "SRLプログラムは、SRLステートメントのシーケンスです。次のように、4種類のステートメントがあります。"
    },
    {
      "indent": 0,
      "text": "3.1 IF_statement",
      "section_title": true,
      "ja": "3.1 if_statement"
    },
    {
      "indent": 13,
      "text": "  Test Part                Action Part\n.............            ...............",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "--- IF --- expression ---+------------+---- Statement ----+--->\n                         |            |                   |\n                         +-- SAVE , --+                   |\n                         |                                |\n                         +-- SAVE ; ----------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": ">-----------+-----------------------------+-----------------\n            |                             |\n            +-----ELSE --- Statement -----+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.1.1 expression",
      "section_title": true,
      "ja": "3.1.1 表現表明表出言い回し発想句血相顔色口調言葉遣い表示表白観風姿口回し申し様"
    },
    {
      "indent": 3,
      "text": "-------- term --------+------------------------+-------------------\n                      |                        |\n                      +--<-- term ----- || ----+    logical OR",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.1.2 term",
      "section_title": true,
      "ja": "3.1.2 学期用語期間ターム期限年度年限言い表す一季際体様一期"
    },
    {
      "indent": 3,
      "text": "------- factor -------+------------------------+-------------------\n                      |                        |\n                      +--<-- factor --- && ----+    logical AND",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.1.3 factor",
      "section_title": true,
      "ja": "3.1.3 要素因子ファクター要因因数因"
    },
    {
      "indent": 3,
      "text": "------------+-------- attrib  ==  operand_list --------+-----------\n            |                                          |\n            +------------ ( expression ) --------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.1.4 operand_list",
      "section_title": true,
      "ja": "3.1.4 operand_list"
    },
    {
      "indent": 3,
      "text": "----------+------------------ operand -----------------+-----------\n          |                                            |\n          +-- ( operand ---+-------------------+-- ) --+\n                           |                   |\n                           +-<-- operand  , ---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.1.5 operand",
      "section_title": true,
      "ja": "3.1.5 オペランド"
    },
    {
      "indent": 3,
      "text": "------------- value ---------+----------------------+--------------\n                             |                      |\n                             +------- / width ------+\n                             |                      |\n                             +------- & mask -------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.1.6 Test Part",
      "section_title": true,
      "ja": "3.1.6 テスト部品"
    },
    {
      "indent": 3,
      "text": "The IF statement evaluates a logical expression. If the expression value is TRUE, the action indicated in the 'Action Part' of the diagram is executed. If the value is FALSE and the IF has an ELSE clause, that ELSE clause is executed (see below).",
      "ja": "IFステートメントは論理式を評価します。式値が真である場合、図の「アクション部分」に示されているアクションが実行されます。値がfalseであり、IFが他の条項を持っている場合、その範囲の条項が実行されます（以下を参照）。"
    },
    {
      "indent": 3,
      "text": "The simplest form of expression is a test for equality (== operator); in this an RTFM attribute value (from the packet or from an SRL variable) is ANDed with a mask and compared with a value. A list of RTFM attributes is given in Appendix C. More complicated expressions may be built up using parentheses and the && (logical AND) and || (logical OR) operators.",
      "ja": "最も単純な表現形式は、平等のテストです（==演算子）。これでは、RTFM属性値（パケットからまたはSRL変数から）は、マスクでANDEDであり、値と比較されます。RTFM属性のリストは、付録Cに記載されています。より複雑な式は、括弧と&&（論理および）および||を使用して構築できます。（論理または）演算子。"
    },
    {
      "indent": 3,
      "text": "Operand values may be specified as dotted decimal, hexadecimal or as a character constant (enclosed in apostrophes). The syntax for operand values is given in Appendix B.",
      "ja": "オペランド値は、点線10進数、16進数、または文字定数（アポストロフィで囲まれている）として指定できます。オペランド値の構文は付録Bに示されています。"
    },
    {
      "indent": 3,
      "text": "Masks may be specified as numbers, dotted decimal e.g. &255.255 or hexadecimal e.g. &FF-FF or as a width in bits e.g. /16",
      "ja": "マスクは、数字として指定されている場合があります。＆255.255または16進数＆ff-ffまたはビットの幅として/16"
    },
    {
      "indent": 3,
      "text": "If a mask is not specified, an all-ones mask is used.",
      "ja": "マスクが指定されていない場合は、オールオンマスクが使用されます。"
    },
    {
      "indent": 3,
      "text": "In SRL a value is always combined with a mask; this combination is referred to as an operand. For example, if we were interested in flows originating from IP network 130.216, we might write:",
      "ja": "SRLでは、値は常にマスクと組み合わされます。この組み合わせは、オペランドと呼ばれます。たとえば、IPネットワーク130.216に由来するフローに興味がある場合は、次のことを記述できます。"
    },
    {
      "indent": 6,
      "text": "IF SourcePeerAddress == 130.216.0.0 & 255.255.0.0  SAVE;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "or equivalently",
      "ja": "または同等に"
    },
    {
      "indent": 6,
      "text": "IF SourcePeerAddress == 130.216/16  SAVE;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A list of values enclosed in parentheses may also be specified; the test succeeds if the masked attribute equals any of the values in the list. For example:",
      "ja": "括弧内に囲まれた値のリストも指定できます。マスクされた属性がリスト内の値のいずれかに等しい場合、テストは成功します。例えば："
    },
    {
      "indent": 6,
      "text": "IF SourcePeerAddress == ( 130.216.7/24, 130.216.34/24 ) SAVE;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "As this last example indicates, values are right-padded with zeroes, i.e. the given numbers specify the leading bytes of masks and values.",
      "ja": "この最後の例が示すように、値はゼロで右にパッドされます。つまり、指定された数値はマスクと値の主要なバイトを指定します。"
    },
    {
      "indent": 3,
      "text": "The operand values and masks used in an IF statement must be consistent with the attribute being tested. For example, a four-byte value is acceptable as a peer address, but would not be accepted as a transport address (which may not be longer than two bytes).",
      "ja": "IFステートメントで使用されるオペランド値とマスクは、テスト対象の属性と一致する必要があります。たとえば、4バイトの値はピアアドレスとして受け入れられますが、輸送アドレスとして受け入れられません（これは2バイト以下ではない場合があります）。"
    },
    {
      "indent": 0,
      "text": "3.1.7 Action Part",
      "section_title": true,
      "ja": "3.1.7 アクションパーツ"
    },
    {
      "indent": 3,
      "text": "A SAVE action (i.e. SAVE , or SAVE ;) saves attribute(s), mask(s) and value(s) as given in the statement. If the IF expression tests more than one attribute, the masks and values are saved for all the matched attributes. For each value_list in the statement the value saved is the one which the packet actually matched. See below for further description of SAVE statements.",
      "ja": "保存アクション（つまり、保存、または保存;）は、ステートメントに記載されている属性、マスク、および値を保存します。IF式が複数の属性をテストする場合、マスクと値はすべての一致した属性に対して保存されます。ステートメントの各value_listについて、保存された値は、パケットが実際に一致した値です。保存ステートメントの詳細については、以下を参照してください。"
    },
    {
      "indent": 3,
      "text": "Other actions are described in detail under \"Imperative statements\" below. Note that the RETURN action is valid only within subroutines.",
      "ja": "他のアクションについては、以下の「命令声明」で詳しく説明しています。返品アクションは、サブルーチン内でのみ有効であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.1.8 ELSE Clause",
      "section_title": true,
      "ja": "3.1.8 それ以外の条項"
    },
    {
      "indent": 3,
      "text": "An ELSE Clause provides a statement which will be executed if the IF's test fails. The statement following ELSE will often be another IF statement, providing SRL's version of a 'select' statement. Note that an ELSE clause always matches the immediately preceding IF.",
      "ja": "Else句は、IFのテストが失敗した場合に実行されるステートメントを提供します。他の声明は、多くの場合、別のIFステートメントであり、SRLの「Select」ステートメントのバージョンを提供します。Else句は、常に直前のifと一致することに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.2 Compound_statement",
      "section_title": true,
      "ja": "3.2 化合物_statement"
    },
    {
      "indent": 3,
      "text": "-------+-------------+----- { ---+---- Statement ----+--- } -------\n       |             |           |                   |\n       +-- label : --+           +--------<----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A compound statement is a sequence of statements enclosed in braces. Each statement will terminate with a semicolon, unless it is another compound statement (which terminates with a right brace).",
      "ja": "複合ステートメントは、ブレースに囲まれた一連のステートメントです。各ステートメントは、別の複合ステートメントでない限り、セミコロンで終了します（右ブレースで終了します）。"
    },
    {
      "indent": 3,
      "text": "A compound statement may be labelled, i.e. preceded by an identifier followed by a semi-colon. Each statement inside the braces is executed in sequence unless an EXIT statement is performed, as explained below.",
      "ja": "複合ステートメントにラベル付けされる場合があります。つまり、識別子が続いて半膜が続くことができます。ブレース内の各ステートメントは、以下で説明するように、exitステートメントが実行されない限り、順番に実行されます。"
    },
    {
      "indent": 3,
      "text": "Labels have a well-defined scope, within which they must be unique. Labels within a subroutine (i.e. between a SUBROUTINE and its matching ENDSUB) are local to that subroutine and are not visible outside it. Labels outside subroutines are part of a program's outer block.",
      "ja": "ラベルには明確に定義された範囲があり、その中では一意でなければなりません。サブルーチン内のラベル（すなわち、サブルーチンとその一致するエンドブの間）は、そのサブルーチンのローカルであり、その外側には見えません。サブルーチン以外のラベルは、プログラムの外側ブロックの一部です。"
    },
    {
      "indent": 0,
      "text": "3.3 Imperative_statement",
      "section_title": true,
      "ja": "3.3 Imperative_statement"
    },
    {
      "indent": 3,
      "text": "------+---------------------------------------------------+------ ;\n      |                                                   |\n      +-- SAVE attrib --+--+-----------+--+---------------+\n      |                 |  |           |  |               |\n      |                 |  +- / width -+  |               |\n      |                 |  |           |  |               |\n      |                 |  +- & mask --+  |               |\n      |                 |                 |               |\n      |                 +--- = operand ---+               |\n      |                                                   |\n      +-- COUNT ------------------------------------------+\n      |                                                   |\n      +-- EXIT label  ------------------------------------+\n      |                                                   |\n      +-- IGNORE -----------------------------------------+\n      |                                                   |\n      +-- NOMATCH ----------------------------------------+\n      |                                                   |\n      +-- RETURN --+-------+------------------------------+\n      |            |       |                              |\n      |            +-- n --+                              |\n      |                                                   |\n      +-- STORE variable := value ------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3.1 SAVE Statement",
      "section_title": true,
      "ja": "3.3.1 ステートメントを保存します"
    },
    {
      "indent": 3,
      "text": "The SAVE statement saves information which will (later) identify the flow in the meter's flow table. It does not actually record anything in the table; this is done when a subsequent COUNT statement executes.",
      "ja": "Saveステートメントは、メーターのフローテーブルのフローを（後）識別する情報を保存します。実際にはテーブルに何も記録しません。これは、後続のカウントステートメントが実行されたときに行われます。"
    },
    {
      "indent": 3,
      "text": "SAVE has two possible forms:",
      "ja": "保存には2つの可能なフォームがあります。"
    },
    {
      "indent": 3,
      "text": "SAVE attrib = operand ; saves the attribute, mask and value as given in the statement. This form of the SAVE statement is similar to that allowed in an IF statement, except that - since imperative statements do not perform a test - you may save an arbitrary value.",
      "ja": "attrib = operandを保存します。ステートメントに記載されているように、属性、マスク、値を保存します。保存ステートメントのこの形式は、IFステートメントで許可されているものと似ていますが、それを除いて - 命令的なステートメントはテストを実行しないため、任意の値を保存することができます。"
    },
    {
      "indent": 3,
      "text": "SAVE attrib ; SAVE attrib / width ; SAVE attrib & mask ; saves the attribute and mask from the statement, and the value resulting from their application to the current packet. This is most useful when used to save a value with a wider mask than than was used to select the packet. For example:",
      "ja": "attribを保存します。attrib / widthを保存します。attrib＆maskを保存;ステートメントから属性とマスクを保存し、そのアプリケーションから生じる値を現在のパケットに保存します。これは、パケットの選択に使用するよりも、より広いマスクで値を保存するために使用する場合に最も便利です。例えば："
    },
    {
      "indent": 13,
      "text": "IF DestPeerAddress == 130.216/16\n        NOMATCH;\nELSE IF SourcePeerAddress == 130.216/16 {\n        SAVE SourcePeerAddress /24;\n        COUNT;\n        }\nELSE IGNORE;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3.2 COUNT Statement",
      "section_title": true,
      "ja": "3.3.2 カウントステートメント"
    },
    {
      "indent": 3,
      "text": "The COUNT statement appears after all testing and saving is complete; it instructs the PME to build the flow identifier from the attributes which have been SAVEd, find it in the meter's flow table (creating a new entry if this is the first packet observed for the flow), and increment its counters. The meter then moves on to examine the next incoming packet.",
      "ja": "カウントステートメントは、すべてのテストと保存が完了した後に表示されます。PMEに、保存された属性からフロー識別子を構築し、メーターのフローテーブルで見つけ（これがフローで観察された最初のパケットである場合は新しいエントリを作成）、カウンターを増やすように指示します。メーターは、次の着信パケットを調べるために移動します。"
    },
    {
      "indent": 0,
      "text": "3.3.3 EXIT Statement",
      "section_title": true,
      "ja": "3.3.3 終了ステートメント"
    },
    {
      "indent": 3,
      "text": "The EXIT statement exits a labelled compound statement. The next statement to be executed will be the one following that compound statement. This provides a well-defined way to jump to a clearly identified point in a program. For example:",
      "ja": "Exitステートメントは、ラベル付きの複合ステートメントを終了します。実行される次の声明は、その複合声明に続くものになります。これは、プログラムで明確に識別されたポイントにジャンプする明確に定義された方法を提供します。例えば："
    },
    {
      "indent": 3,
      "text": "outer: {\n   ...\n   if SourcePeerAddress == 192.168/16\n      exit outer;  # exits the statement labelled 'outer'\n   ...\n   }\n# execution resumes here",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In practice the language provides sufficient logical structure that one seldom - if ever - needs to use the EXIT statement.",
      "ja": "実際には、この言語は十分な論理構造を提供するため、exitステートメントを使用する必要がない場合はめったにありません。"
    },
    {
      "indent": 0,
      "text": "3.3.4 IGNORE Statement",
      "section_title": true,
      "ja": "3.3.4 ステートメントを無視します"
    },
    {
      "indent": 3,
      "text": "The IGNORE statement terminates examination of the current packet without saving any information from it. The meter then moves on to examine the next incoming packet, beginning again at the first statement of its program.",
      "ja": "無視されたステートメントは、情報を保存せずに現在のパケットの検査を終了します。その後、メーターは次の着信パケットを調べて、プログラムの最初のステートメントで再び始まります。"
    },
    {
      "indent": 0,
      "text": "3.3.5 NOMATCH Statement",
      "section_title": true,
      "ja": "3.3.5 Nomatchステートメント"
    },
    {
      "indent": 3,
      "text": "The NOMATCH statement indicates that matching has failed for this execution of the program. If it is executed when a packet is being processed with its addresses in 'on the wire' order, the PME will perform the program again from the beginning with source and destination addresses interchanged. If it is executed following such an interchange, the packet will be IGNOREd.",
      "ja": "Nomatchステートメントは、このプログラムの実行に一致していないことを示しています。「On the Wire」の順序でアドレスを使用してパケットが処理されているときに実行される場合、PMEはソースと宛先アドレスが交換された最初から再びプログラムを実行します。そのようなインターチェンジに続いて実行されると、パケットは無視されます。"
    },
    {
      "indent": 3,
      "text": "NOMATCH is illustrated in the SAVE example (section 3.3.1), where it is used to ensure that flows having 130.216/16 as an end-point are counted as though 130.216 had been those flows' source peer (IP) address.",
      "ja": "Nomatchは、保存例（セクション3.3.1）に示されています。130.216/16を持つフローが、130.216がそれらのFlowsのソースピア（IP）アドレスであるかのようにカウントされるようにします。"
    },
    {
      "indent": 0,
      "text": "3.3.6 STORE Statement",
      "section_title": true,
      "ja": "3.3.6 ストアステートメント"
    },
    {
      "indent": 3,
      "text": "The STORE statement assigns a value to an SRL variable and SAVEs it. There are six SRL variables:",
      "ja": "Storeステートメントは、SRL変数に値を割り当て、保存します。6つのSRL変数があります。"
    },
    {
      "indent": 11,
      "text": "SourceClass        SourceKind\nDestClass          DestKind\nFlowClass          FlowKind",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Their names have no particular significance; they were arbitrarily chosen as likely RTFM attributes but can be used to store any single-byte integer values. Their values are set to zero each time examination of a new packet begins. For example:",
      "ja": "彼らの名前は特に重要ではありません。それらは、RTFM属性の可能性が高いと任意に選択されましたが、単一バイトの整数値を保存するために使用できます。それらの値は、新しいパケットの検査が開始されるたびにゼロに設定されます。例えば："
    },
    {
      "indent": 3,
      "text": "STORE SourceClass := 3;\nSTORE FlowKind := 'W'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3.7 RETURN Statement",
      "section_title": true,
      "ja": "3.3.7 returnステートメント"
    },
    {
      "indent": 3,
      "text": "The RETURN statement is used to return from subroutines and can be used only within the context of a subroutine. It is described in detail below (CALL statement).",
      "ja": "リターンステートメントは、サブルーチンから戻るために使用され、サブルーチンのコンテキスト内でのみ使用できます。以下で詳しく説明します（声明）。"
    },
    {
      "indent": 0,
      "text": "3.4 Subroutine_declaration",
      "section_title": true,
      "ja": "3.4 subroutine_declaration"
    },
    {
      "indent": 3,
      "text": "-- SUBROUTINE subname ( --+-----------------------------+-- ) -->\n                          |                             |\n                          +--+-- ADDRESS --- pname --+--+\n                             |                       |\n                             +-- VARIABLE -- pname --+\n                             |                       |\n                             +------<------- , ------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": ">------+-------- Statement ---------+----- ENDSUB -------- ;\n       |                            |\n       +-------------<--------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A Subroutine declaration has three parts:",
      "ja": "サブルーチン宣言には3つの部分があります。"
    },
    {
      "indent": 6,
      "text": "the subname is an identifier, used to name the subroutine.",
      "ja": "サブ名は識別子であり、サブルーチンの名前を付けるために使用されます。"
    },
    {
      "indent": 6,
      "text": "the parameter list specifies the subroutine's parameters. Each parameter is preceded with a keyword indicating its type - VARIABLE indicates an SRL variable (see the STORE statement above), ADDRESS indicates any other RTFM attribute. A parameter name may be any identifier, and its scope is limited to the subroutine's body.",
      "ja": "パラメーターリストは、サブルーチンのパラメーターを指定します。各パラメーターの前には、そのタイプを示すキーワードが付いています。変数はSRL変数を示します（上記のストアステートメントを参照）、アドレスは他のRTFM属性を示します。パラメーター名は任意の識別子である場合があり、そのスコープはサブルーチンの本体に限定されます。"
    },
    {
      "indent": 6,
      "text": "the body specifies what processing the subroutine will perform. This is simply a sequence of Statements, terminated by the ENDSUB keyword.",
      "ja": "ボディは、サブルーチンの処理が実行されるものを指定します。これは、Endinaubキーワードによって終了する一連のステートメントのシーケンスです。"
    },
    {
      "indent": 3,
      "text": "Note that EXITs in a subroutine may not refer to labels outside it. The only way to leave a subroutine is via a RETURN statement.",
      "ja": "サブルーチンの出口は、その外側のラベルを参照しない場合があることに注意してください。サブルーチンを離れる唯一の方法は、返品声明を介してです。"
    },
    {
      "indent": 0,
      "text": "3.5 CALL_statement",
      "section_title": true,
      "ja": "3.5 call_statement"
    },
    {
      "indent": 3,
      "text": "---- CALL subname ( --+---------------------+-- ) ---->\n                      |                     |\n                      +--+-- parameter --+--+\n                         |               |\n                         +----<--- , ----+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": ">---+-------------------------------------+--- ENDCALL ---- ;\n    |                                     |\n    +---+--+-- n : --+--- Statement --+---+\n        |  |         |                |\n        |  +----<----+                |\n        |                             |\n        +--------------<--------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The CALL statement invokes an SRL subroutine. The parameters are SRL variables or other RTFM attributes, and their types must match those in the subroutine declaration. Following the parameters is a sequence of statements, each preceded by an integer label. These labels will normally be 1:, 2:, 3:, etc, but they do not have to be contiguous, nor in any particular order. They are referred to in RETURN statements within the subroutine body.",
      "ja": "コールステートメントは、SRLサブルーチンを呼び出します。パラメーターはSRL変数または他のRTFM属性であり、それらのタイプはサブルーチン宣言のタイプと一致する必要があります。パラメーターに従うのは、それぞれが整数ラベルが前に続く一連のステートメントです。これらのラベルは通常1：、2：、3：、などになりますが、隣接する必要も、特定の順序でも必要ありません。それらは、サブルーチン本体内の見返りで言及されています。"
    },
    {
      "indent": 3,
      "text": "e.g. RETURN 2; would return to the statement labelled 2: within in the CALL statement.",
      "ja": "例えば戻る2;コールステートメント内のラベル2のラベルのあるステートメントに戻ります。"
    },
    {
      "indent": 3,
      "text": "Execution of the labelled statement completes the CALL.",
      "ja": "ラベル付きステートメントの実行は、コールが完了します。"
    },
    {
      "indent": 3,
      "text": "If the return statement does not specify a return label, the first statement executed after RETURN will be the statement immediately following ENDCALL.",
      "ja": "Return StatementがReturn Labelを指定していない場合、Returnの後に実行された最初のステートメントは、EndCallの直後のステートメントになります。"
    },
    {
      "indent": 0,
      "text": "4 Example Programs",
      "ja": "4つの例プログラム"
    },
    {
      "indent": 0,
      "text": "4.1 Classify IP Port Numbers",
      "section_title": true,
      "ja": "4.1 IPポート番号を分類します"
    },
    {
      "indent": 3,
      "text": "#\n#  Classify IP port numbers\n#\n   define IPv4 = 1;  # Address Family number from [ASG-NBR]\n#\n   define ftp = (20, 21);  # Well-Known Port numbers from [ASG-NBR]\n   define telnet = 23;\n   define www = 80;\n#\n   define tcp = 6;  # Protocol numbers from [ASG-NBR]\n   define udp = 17;\n#\n   if SourcePeerType == IPv4 save;\n   else ignore;  # Not an IPv4 packet\n#\n   if (SourceTransType == tcp || SourceTransType == udp) save, {\n      if SourceTransAddress == (www, ftp, telnet)  nomatch;\n         # We want the well-known port as Dest\n#\n      if DestTransAddress == telnet\n         save, store FlowKind := 'T';\n      else if DestTransAddress == www\n         save, store FlowKind := 'W';\n      else if DestTransAddress == ftp\n         save, store FlowKind := 'F';\n      else {\n         save DestTransAddress;\n         store FlowKind := '?';\n         }\n      }\n   else save SourceTransType = 0;\n#\n   save SourcePeerAddress /32;\n   save DestPeerAddress   /32;\n   count;\n#\n   This program counts only IP packets, saving SourceTransType (tcp, udp\nor 0), Source- and DestPeerAddress (32-bit IP addresses) and FlowKind\n('W' for www, 'F' for ftp, 'T' for telnet, '?' for unclassified).\nThe program uses a NOMATCH action to specify the packet direction -\nits resulting flows will have the well-known ports as their\ndestination.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.2 Classify Traffic into Groups of Networks",
      "section_title": true,
      "ja": "4.2 トラフィックをネットワークのグループに分類します"
    },
    {
      "indent": 3,
      "text": "#\n# SRL program to classify traffic into network groups\n#\ndefine my_net = 130.216/16;\ndefine k_nets = ( 130.217/16, 130.123/16, 130.195/16,\n                 132.181/16, 138.75/16, 139.80/16 );\n#\n   call net_kind (SourcePeerAddress, SourceKind)\n      endcall;\n   call net_kind (DestPeerAddress,   DestKind)\n      endcall;\n   count;\n#\n   subroutine net_kind (address addr, variable net)\n      if addr == my_net save, {\n         store net := 10;  return 1;\n         }\n      else if addr == k_nets save, {\n         store net := 20;  return 2;\n         }\n      save addr/24;  # Not my_net or in k_nets\n      store net := 30;  return 3;\n      endsub;\n#",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The net_kind subroutine determines whether addr is my network (130.216), one of the Kawaihiko networks (in the k_nets list), or some other network. It saves the network address from addr (16 bits for my_net and the k_net networks, 24 bits for others), stores a value of 10, 20 or 30 in net, and returns to 1:, 2: or 3:. Note that the network numbers used are contained within the two DEFINEs, making them easy to change.",
      "ja": "Net_kind Subroutineは、ADDRが私のネットワーク（130.216）であるか、Kawaihikoネットワークの1つ（K_NETSリスト内）であるか、または他のネットワークであるかを決定します。ネットワークアドレスをADDR（MY_NETおよびK_NETネットワークの16ビット、その他の24ビット）から保存し、ネットで10、20、または30の値を保存し、1：、2：または3：に戻します。使用されるネットワーク番号は2つの定義に含まれており、それらを簡単に変更しやすくすることに注意してください。"
    },
    {
      "indent": 3,
      "text": "net_kind is called twice, saving Source- and DestPeerAddress and Source- and DestKind; the COUNT statement produces flows identified by these four RTFM attributes, with no particular source-dest ordering.",
      "ja": "net_kindは2回呼び出され、ソースとデスペイアドドレスとソースとデスキンドを保存します。カウントステートメントは、これらの4つのRTFM属性によって識別されるフローを生成し、特定のソースデスト順序はありません。"
    },
    {
      "indent": 3,
      "text": "In the program no use is made of return numbers and they could have been omitted. However, we might wish to re-use the subroutine in another program doing different things for different return numbers, as in the version below.",
      "ja": "プログラムでは、返品番号では役に立たず、省略できた可能性があります。ただし、以下のバージョンのように、異なる返品数に対して異なることを行う別のプログラムでサブルーチンを再利用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "call net_kind (DestPeerAddress, DestKind)\n   1: nomatch;  # We want my_net as source\n      endcall;\ncall net_kind (SourcePeerAddress, SourceKind)\n   1: count;    # my_net -> other networks\n      endcall;\nsave SourcePeerAddress /24;\nsave DestPeerAddress /24;\ncount;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This version uses a NOMATCH statement to ensure that its resulting flows have my_net as their source. The NOMATCH also rejects my_net -> my_net traffic. Traffic which doesn't have my_net as source or destination saves 24 bits of its peer addresses (the subroutine might only have saved 16) before counting such an unusual flow.",
      "ja": "このバージョンでは、Nomatchステートメントを使用して、結果として得られたフローがMy_Netをソースとして確保していることを確認します。Nomatchは、my_net-> my_netトラフィックも拒否します。ソースまたは宛先としてmy_netを持っていないトラフィックは、このような異常な流れをカウントする前に、24ビットのピアアドレス（サブルーチンは16しか節約できない可能性がある）を節約できます。"
    },
    {
      "indent": 0,
      "text": "5 Security Considerations",
      "ja": "5つのセキュリティ上の考慮事項"
    },
    {
      "indent": 3,
      "text": "SRL is a language for creating rulesets (i.e. configuration files) for RTFM Traffic Meters - it does not present any security issues in itself.",
      "ja": "SRLは、RTFMトラフィックメーターのルールセット（つまり、構成ファイル）を作成するための言語です。セキュリティの問題自体は提示しません。"
    },
    {
      "indent": 3,
      "text": "On the other hand, flow data gathered using such rulesets may well be valuable. It is therefore important to take proper precautions to ensure that access to the meter and its data is secure. Ways to achieve this are discussed in detail in the Architecture and Meter MIB documents [RTFM-ARC, RTFM-MIB].",
      "ja": "一方、このようなルールセットを使用して収集されたフローデータは価値があるかもしれません。したがって、メーターへのアクセスとそのデータが安全であることを保証するために、適切な予防措置を講じることが重要です。これを達成する方法は、アーキテクチャおよびメーターMIBドキュメント[RTFM-ARC、RTFM-MIB]で詳細に説明されています。"
    },
    {
      "indent": 0,
      "text": "6 IANA Considerations",
      "ja": "6 IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "Appendix C below lists the RTFM attributes by name. Since SRL only refers to attributes by name, SRL users do not have to know the attribute numbers.",
      "ja": "下の付録Cには、RTFM属性を名前で示します。SRLは名前の属性のみを指すため、SRLユーザーは属性番号を知る必要はありません。"
    },
    {
      "indent": 3,
      "text": "The size (in bytes) of the various attribute values is also listed in Appendix C. These sizes reflect the object sizes for the attribute values as they are stored in the RTFM Meter MIB [RTFM-MIB].",
      "ja": "さまざまな属性値のサイズ（バイト単位）は、付録Cにもリストされています。これらのサイズは、RTFMメーターMIB [RTFM-MIB]に保存されている属性値のオブジェクトサイズを反映しています。"
    },
    {
      "indent": 3,
      "text": "IANA considerations for allocating new attributes are discussed in detail in the RTFM Architecture document [RTFM-ARC].",
      "ja": "新しい属性を割り当てるためのIANAの考慮事項については、RTFMアーキテクチャドキュメント[RTFM-ARC]で詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "7 APPENDICES",
      "ja": "7つの付録"
    },
    {
      "indent": 0,
      "text": "7.1 Appendix A: SRL Syntax in BNF",
      "section_title": true,
      "ja": "7.1 付録A：BNFのSRL構文"
    },
    {
      "indent": 6,
      "text": "<SRL program>    ::=  <S or D> | <SRL program> <S or D>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<S or D>         ::=  <statement> | <declaration>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<declaration>    ::=  <Subroutine declaration>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<statement>      ::=  <IF statement> |\n                      <Compound statement> |\n                      <Imperative statement> |\n                      <CALL statement>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<IF statement>   ::=  IF <expression> <if action> <opt else>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<if action>      ::=  SAVE ; |\n                      SAVE , <statement> |\n                      <statement>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<opt else>       ::=  <null> |\n                      ELSE <statement>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<expression>     ::=  <term> | <term> || <term>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<term>           ::=  <factor> | <factor> && <factor>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<factor>         ::=  <attribute> == <operand list> |\n                      ( <expression> )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<operand list>   ::=  <operand> | ( <actual operand list> )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<actual operand list> ::= <operand> |\n                      <actual operand list> , <operand>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<operand>        ::=  <value> |\n                      <value> / <width> |\n                      <value> & <mask>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<Compound statement> ::= <opt label> { <statement seq> }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<opt label>      ::=  <null> |\n                      <identifier> :",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<statement seq>  ::=  <statement> | <statement seq> <statement>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<Imperative statement> ::=  ; |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": "SAVE <attribute> <opt operand> ; |\nCOUNT ; |\nEXIT <label> ; |\nIGNORE ; |\nNOMATCH ; |\nRETURN <integer> ; |\nRETURN ; |\nSTORE <variable> := <value> ;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<opt operand>    ::=  <null> |\n                      <width or mask> |\n                      = <operand>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<width or mask>   ::= / <width> | & <mask>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<Subroutine declaration> ::=\n                      SUBROUTINE <sub header> <sub body> ENDSUB ;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<sub header>     ::=  <subname> ( ) |\n                      <subname> ( <sub param list> )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<sub param list> ::= <sub param> | <sub param list> , <sub param>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<sub param>      ::=  ADDRESS <pname> | VARIABLE <pname>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<pname>          ::=  <identifier>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<sub body>       ::=  <statement sequence>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<CALL statement> ::=  CALL <call header> <opt call body> ENDCALL ;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<call header>    ::=  <subname> ( ) |\n                      <subname> ( <call param list> )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<call param list> ::= <call param> |\n                      <call param list> , <call param>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<call param>     ::=  <attribute> | <variable>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<opt call body>  ::=  <null> |\n                      <actual call body>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<actual call body> ::=  <numbered statement> |\n                      <actual call body> <numbered statement>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<numbered statement> ::= <int label seq> <statement>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<int label seq>  ::=  <integer> : | <int label seq> <integer> :",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following are terminals, recognised by the scanner:",
      "ja": "以下は、スキャナーによって認識されている端子です。"
    },
    {
      "indent": 6,
      "text": "<identifier>     Described in section 2\n<integer>        A decimal integer",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<attribute> Attribute name, as listed in Appendix C",
      "ja": "<属性>属性名、付録Cにリストされています"
    },
    {
      "indent": 6,
      "text": "<value>, <mask>  Described in section 5.2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<width>     ::= <integer>\n<label>     ::= <identifier>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<variable>  ::=  SourceClass | DestClass | FlowClass |\n                  SourceKind | DestKind | FlowKind",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.2 Appendix B: Syntax for Values and Masks",
      "section_title": true,
      "ja": "7.2 付録B：値とマスクの構文"
    },
    {
      "indent": 3,
      "text": "Values and masks consist of sequences of numeric fields, each of one or more bytes. The non-blank character following a field indicates the field width, and whether the number is decimal or hexadecimal. These 'field type' characters may be:",
      "ja": "値とマスクは、それぞれ1つ以上のバイトの数値フィールドのシーケンスで構成されています。フィールドに続く非ブランク文字は、フィールドの幅と、数値が小数点または16進数かどうかを示します。これらの「フィールドタイプ」文字は次のとおりです。"
    },
    {
      "indent": 5,
      "text": ". period decimal, single byte - minus hex, single byte ! exclaim decimal, two bytes",
      "ja": "。ピリオドリシマル、シングルバイト - マイナスヘックス、シングルバイト！小数点、2バイトを叫んでいます"
    },
    {
      "indent": 3,
      "text": "For example, 130.216.0.0 is an IP address (in dotted decimal), and FF-FF-00-00 is an IP address in hexadecimal.",
      "ja": "たとえば、130.216.0.0はIPアドレス（点線で小数点以下）であり、FF-FF-00-00は16進数のIPアドレスです。"
    },
    {
      "indent": 3,
      "text": "The last field of a value or mask has no field width character. Instead it takes the same width as the preceding field. For example, 1.3.10!50 and 1.3.0.10.0.50 are two different ways to specify the same value.",
      "ja": "値またはマスクの最後のフィールドには、フィールド幅の文字がありません。代わりに、前のフィールドと同じ幅を取得します。たとえば、1.3.10！50および1.3.0.10.0.50は、同じ値を指定する2つの異なる方法です。"
    },
    {
      "indent": 3,
      "text": "Unspecified fields (at the right-hand side of a value or mask) are set to zero, i.e. 130.216 is the same as 130.216.0.0.",
      "ja": "不特定のフィールド（値またはマスクの右側）はゼロに設定されています。つまり、130.216は130.216.0.0と同じです。"
    },
    {
      "indent": 3,
      "text": "If only a single field is specified (no field width character), the value given fills the whole field. For example, 23 and 0.23 specify the same value for a SourceTransAddress operand. For variables (which have one-byte values) a C-style character constant may also be used.",
      "ja": "単一のフィールドのみが指定されている場合（フィールド幅の文字なし）、与えられた値はフィールド全体を埋めます。たとえば、23と0.23は、SourcetransAddressオペランドの同じ値を指定します。変数（1バイト値を持つ）の場合、Cスタイルの文字定数も使用できます。"
    },
    {
      "indent": 3,
      "text": "IPv6 addresses and masks may also be used, following the conventions set out in the IP Version 6 Addressing Architecture RFC [V6-ADR].",
      "ja": "IPバージョン6のアドレス指定アーキテクチャRFC [V6-ADR]に記載されている規則に従って、IPv6アドレスとマスクも使用できます。"
    },
    {
      "indent": 0,
      "text": "7.3 Appendix C: RTFM Attribute Information",
      "section_title": true,
      "ja": "7.3 付録C：RTFM属性情報"
    },
    {
      "indent": 3,
      "text": "The following attributes may be tested in an IF statement, and their values may be SAVEd (except for MatchingStoD). Their maximum size (in bytes) is shown to the left, and a brief description is given for each. The names given here are reserved words in SRL (they are <attribute> terminals in the grammar given in Appendix A).",
      "ja": "次の属性はIFステートメントでテストされる場合があり、その値は保存される場合があります（一致することを除く）。最大サイズ（バイト単位）が左に表示され、それぞれについて簡単な説明が記載されています。ここに記載されている名前は、SRLの予約単語です（付録Aに示す文法の<属性>端子です）。"
    },
    {
      "indent": 3,
      "text": "Note that this table gives only a very brief summary. The Meter MIB [RTFM-MIB] provides the definitive specification of attributes and their allowed values. The MIB variables which represent flow attributes have 'flowData' prepended to their names to indicate that they belong to the MIB's flowData table.",
      "ja": "このテーブルは非常に簡単な要約のみを提供していることに注意してください。Meter MIB [RTFM-MIB]は、属性とその許可された値の決定的な仕様を提供します。フロー属性を表すMIB変数には、「FlowData」が名前に加えて、MIBのFlowDataテーブルに属していることを示しています。"
    },
    {
      "indent": 3,
      "text": "1 SourceInterface, DestInterface Interface(s) on which the flow was observed",
      "ja": "1 SourceInterface、Flowが観測されたDaterinterfaceインターフェイス"
    },
    {
      "indent": 3,
      "text": "1 SourceAdjacentType, DestAdjacentType Indicates the interface type(s), i.e. an ifType from [ASG-NBR], or an Address Family Number (if metering within a tunnel)",
      "ja": "1 sourceadjacentType、destadjacentTypeは、インターフェイスタイプ、つまり[asg-nbr]からのiftype、またはアドレスファミリ番号（トンネル内での測定の場合）を示します。"
    },
    {
      "indent": 3,
      "text": "0 SourceAdjacentAddress, DestAdjacentAddress For IEEE 802.x interfaces, the MAC addresses for the flow",
      "ja": "0 SourceadjacentAddress、IEEE 802.xインターフェイスのDestadjacentAddress、FlowのMACアドレス"
    },
    {
      "indent": 3,
      "text": "1 SourcePeerType, DestPeerType Peer protocol types, i.e. Address Family Number from [ASG-NBR], such as IPv4, Novell, Ethertalk, ..",
      "ja": "1 SourcePeertype、DestPeertype PEERプロトコルタイプ、つまり、IPv4、Novell、Ethertalkなど、[ASG-NBR]の[ASG-NBR]のファミリ番号をアドレスします。"
    },
    {
      "indent": 3,
      "text": "0 SourcePeerAddress, DestPeerAddress Peer Addresses (size varies, e.g. 4 for IPv4, 3 for Ethertalk))",
      "ja": "0 SourcePeerAddress、DestPeerAddressピアアドレス（サイズは異なります。たとえば、IPv4の場合は4、Ethertalkの場合は3））"
    },
    {
      "indent": 3,
      "text": "1 SourceTransType, DestTransType Transport layer type, i.e. Protocol Number from [ASG-NBR] such as tcp(6), udp(17), ospf(89), ..",
      "ja": "1 SourcetranStype、DestTranStype Transport Layer Type、つまりTCP（6）、UDP（17）、OSPF（89）、..などの[ASG-NBR]のプロトコル番号。"
    },
    {
      "indent": 3,
      "text": "2 SourceTransAddress, DestTransAddress Transport layer addresses (e.g. port numbers for TCP and UDP)",
      "ja": "2 SourcetransAddress、Dest TransAddress Transport Layerアドレス（TCPおよびUDPのポート番号など）"
    },
    {
      "indent": 3,
      "text": "1 FlowRuleset Rule set number for the flow",
      "ja": "フローのフロールルレセットルールセット番号"
    },
    {
      "indent": 3,
      "text": "1 MatchingStoD Indicates whether the packet is being matched with its addresses in 'wire order.' See [RTFM-ARC] for details.",
      "ja": "1 MatchingStodは、パケットが「ワイヤ順」のアドレスと一致しているかどうかを示します。詳細については、[RTFM-ARC]を参照してください。"
    },
    {
      "indent": 3,
      "text": "The following variables may be tested in an IF, and their values may be set by a STORE. They all have one-byte values.",
      "ja": "次の変数はIFでテストされ、その値はストアによって設定される場合があります。それらはすべて1バイトの値を持っています。"
    },
    {
      "indent": 6,
      "text": "SourceClass, DestClass, FlowClass, SourceKind, DestKind, FlowKind",
      "ja": "sourceclass、destclass、flowclass、sourcekind、destkind、flowkind"
    },
    {
      "indent": 3,
      "text": "The following RTFM attributes are not address attributes - they are measured attributes of a flow. Their values may be read from an RTFM meter. (For example, NeTraMet uses a FORMAT statement to specify which attribute values are to be read from the meter.)",
      "ja": "次のRTFM属性はアドレス属性ではありません - それらはフローの測定された属性です。それらの値は、RTFMメーターから読み取ることができます。（たとえば、Netrametはフォーマットステートメントを使用して、メーターから読み取られる属性値を指定します。）"
    },
    {
      "indent": 3,
      "text": "8 ToOctets, FromOctets Total number of octets seen for each direction of the flow",
      "ja": "8つのtooctets、fromoctetsフローの各方向に見られるオクテットの総数"
    },
    {
      "indent": 3,
      "text": "8 ToPDUs, FromPDUs Total number of PDUs seen for each direction of the flow",
      "ja": "8 Topdus、frompdusフローの各方向に見られるpdusの総数"
    },
    {
      "indent": 3,
      "text": "4 FirstTime, LastActiveTime Time (in centiseconds) that first and last PDUs were seen for the flow",
      "ja": "4初めて、Flowで最初と最後のPDUが見られたLastActivetime Time（セント秒単位）"
    },
    {
      "indent": 3,
      "text": "Other attributes will be defined by the RTFM working group from time to time.",
      "ja": "その他の属性は、RTFMワーキンググループによって時々定義されます。"
    },
    {
      "indent": 0,
      "text": "8 Acknowledgments",
      "ja": "8謝辞"
    },
    {
      "indent": 3,
      "text": "The SRL language is part of the RTFM Working Group's efforts to make the RTFM traffic measurement system easier to use. Initial work on the language was done by Cyndi Mills and Brad Frazee in Boston. SRL was developed in Auckland; it was greatly assisted by detailed discussion with John White and Russell Fulton. Discussion has continued on the RTFM and NeTraMet mailing lists.",
      "ja": "SRL言語は、RTFMトラフィック測定システムを使いやすくするためのRTFMワーキンググループの取り組みの一部です。言語に関する最初の作業は、ボストンのCyndi MillsとBrad Frazeeによって行われました。SRLはオークランドで開発されました。ジョン・ホワイトとラッセル・フルトンとの詳細な議論によって大いに助けられました。RTFMおよびNetrametのメーリングリストについては、議論が続いています。"
    },
    {
      "indent": 0,
      "text": "9 References",
      "ja": "9参照"
    },
    {
      "indent": 3,
      "text": "[ASG-NBR] Reynolds, J. and J. Postel, \"Assigned Numbers\", STD 2, RFC 1700, October 1994.",
      "ja": "[ASG-NBR] Reynolds、J。およびJ. Postel、「割り当てられた番号」、STD 2、RFC 1700、1994年10月。"
    },
    {
      "indent": 3,
      "text": "[NETRAMET] Brownlee, N., NeTraMet home page, http://www.auckland.ac.nz/net/NeTraMet",
      "ja": "[Netramet] Brownlee、N.、Netramet Home Page、http：//www.auckland.ac.nz/net/netramet"
    },
    {
      "indent": 3,
      "text": "[RTFM-ARC] Brownlee, N., Mills, C. and G. Ruth, \"Traffic Flow Measurement: Architecture\", RFC 2722, October 1999.",
      "ja": "[RTFM-ARC] Brownlee、N.、Mills、C。and G. Ruth、「トラフィックフロー測定：アーキテクチャ」、RFC 2722、1999年10月。"
    },
    {
      "indent": 3,
      "text": "[RTFM-MIB] Brownlee, N., \"Traffic Flow Measurement: Meter MIB\", RFC 2720, October 1999.",
      "ja": "[RTFM-MIB]ブラウンリー、N。、「トラフィックフロー測定：Meter MIB」、RFC 2720、1999年10月。"
    },
    {
      "indent": 3,
      "text": "[V6-ADDR] Hinden, R. and S. Deering, \"IP Version 6 Addressing Architecture,\" RFC 2373, July 1998.",
      "ja": "[V6-ADDR] Hinden、R。およびS. Deering、「IPバージョン6アドレス指定アーキテクチャ」、RFC 2373、1998年7月。"
    },
    {
      "indent": 0,
      "text": "10 Author's Address",
      "ja": "10著者の住所"
    },
    {
      "indent": 3,
      "text": "Nevil Brownlee Information Technology Systems & Services The University of Auckland Private Bag 92-019 Auckland, New Zealand",
      "ja": "Nevil Brownlee Information Technology Systems＆Servicesオークランド大学プライベートバッグ92-019オークランド、ニュージーランド"
    },
    {
      "indent": 3,
      "text": "Phone: +64 9 373 7599 x8941\nEMail: n.brownlee@auckland.ac.nz",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "11 Full Copyright Statement",
      "ja": "11完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（1999）。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書と本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}