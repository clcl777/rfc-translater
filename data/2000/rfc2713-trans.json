{
  "title": {
    "text": "RFC 2713 - Schema for Representing Java(tm) Objects in an LDAP Directory",
    "ja": "RFC 2713 - LDAPディレクトリでJava（TM）オブジェクトを表すスキーマ"
  },
  "number": 2713,
  "created_at": "2024-02-06 13:17:18.993688+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                            V. Ryan\nRequest for Comments: 2713                                   S. Seligman\nCategory: Informational                                           R. Lee\n                                                  Sun Microsystems, Inc.\n                                                            October 1999",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Schema for Representing Java(tm) Objects in an LDAP Directory",
      "ja": "LDAPディレクトリでJava（TM）オブジェクトを表すスキーマ"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモは、インターネットコミュニティに情報を提供します。いかなる種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（1999）。無断転載を禁じます。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document defines the schema for representing Java(tm) objects in an LDAP directory [LDAPv3]. It defines schema elements to represent a Java serialized object [Serial], a Java marshalled object [RMI], a Java remote object [RMI], and a JNDI reference [JNDI].",
      "ja": "このドキュメントでは、LDAPディレクトリ[LDAPV3]でJava（TM）オブジェクトを表すスキーマを定義しています。Schema要素を定義して、Javaシリアル化オブジェクト[シリアル]、Javaマーシャルオブジェクト[RMI]、Javaリモートオブジェクト[RMI]、およびJNDI参照[JNDI]を表します。"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document assumes that the reader has a general knowledge of the Java programming language [Java]. For brevity we use the term \"Java object\" in place of \"object in the Java programming language\" throughout this text.",
      "ja": "このドキュメントは、読者がJavaプログラミング言語[Java]に関する一般的な知識を持っていることを前提としています。簡潔にするために、このテキスト全体で「Javaプログラミング言語のオブジェクト」の代わりに「Javaオブジェクト」という用語を使用します。"
    },
    {
      "indent": 3,
      "text": "Traditionally, LDAP directories have been used to store data. Users and programmers think of the directory as a hierarchy of directory entries, each containing a set of attributes. You look up an entry from the directory and extract the attribute(s) of interest. For example, you can look up a person's telephone number from the directory. Alternatively, you can search the directory for entries with a particular set of attributes. For example, you can search for all persons in the directory with the surname \"Smith\".",
      "ja": "従来、LDAPディレクトリはデータの保存に使用されてきました。ユーザーとプログラマーは、ディレクトリをディレクトリエントリの階層と考えており、それぞれに属性のセットが含まれています。ディレクトリからエントリを検索し、関心のある属性を抽出します。たとえば、ディレクトリから人の電話番号を調べることができます。または、特定の属性セットを使用したエントリをディレクトリに検索することもできます。たとえば、姓「スミス」でディレクトリ内のすべての人を検索できます。"
    },
    {
      "indent": 3,
      "text": "For applications written in the Java programming language, a kind of data that is typically shared are Java objects themselves. For such applications, it makes sense to be able to use the directory as a repository for Java objects. The directory provides a centrally administered, and possibly replicated, service for use by Java applications distributed across the network.",
      "ja": "Javaプログラミング言語に記述されたアプリケーションの場合、通常共有される一種のデータはJavaオブジェクト自体です。このようなアプリケーションでは、ディレクトリをJavaオブジェクトのリポジトリとして使用できることは理にかなっています。ディレクトリは、ネットワーク全体に配布されるJavaアプリケーションが使用するための中央で管理されている、場合によっては複製されたサービスを提供します。"
    },
    {
      "indent": 3,
      "text": "For example, an application server might use the directory for \"registering\" objects representing the services that it manages, so that a client can later search the directory to locate those services as it needs.",
      "ja": "たとえば、アプリケーションサーバーは、管理するサービスを表すオブジェクトを「登録」するためにディレクトリを使用して、クライアントが後でディレクトリを検索して必要に応じてそれらのサービスを見つけることができます。"
    },
    {
      "indent": 3,
      "text": "The motivation for this document is to define a common way for applications to store and retrieve Java objects from the directory. Using this common schema, any Java application that needs to read or store Java objects in the directory can do so in an interoperable way.",
      "ja": "このドキュメントの動機は、アプリケーションがディレクトリからJavaオブジェクトを保存および取得するための一般的な方法を定義することです。この一般的なスキーマを使用して、ディレクトリにJavaオブジェクトを読み取ったり保管したりする必要があるJavaアプリケーションは、相互運用可能な方法でこれを行うことができます。"
    },
    {
      "indent": 0,
      "text": "2 Representation of Java Objects",
      "ja": "2 Javaオブジェクトの表現"
    },
    {
      "indent": 3,
      "text": "This document defines schema elements to represent three types of Java objects: a Java serialized object, a Java marshalled object, and a JNDI reference. A Java remote object is stored as either a Java marshalled object or a JNDI reference.",
      "ja": "このドキュメントでは、3種類のJavaオブジェクトを表すスキーマ要素を定義しています。Javaシリアル化オブジェクト、Javaマーシャルオブジェクト、JNDIリファレンスです。Javaリモートオブジェクトは、JavaマーシャルオブジェクトまたはJNDIリファレンスのいずれかとして保存されます。"
    },
    {
      "indent": 0,
      "text": "2.1 Common Representations",
      "section_title": true,
      "ja": "2.1 一般的な表現"
    },
    {
      "indent": 3,
      "text": "A Java object is stored in the LDAP directory by using the object class javaObject. This is the base class from which other Java object related classes derive: javaSerializedObject, javaMarshalledObject, and javaNamingReference. javaObject is an abstract object class, which means that a javaObject cannot exist by itself in the directory; only auxiliary or structural subclasses of it can exist in the directory.",
      "ja": "Javaオブジェクトは、オブジェクトクラスJavaObjectを使用してLDAPディレクトリに保存されます。これは、他のJavaオブジェクト関連クラスが派生する基本クラスです：JavaSerializedObject、JavamarShalledObject、およびJavanAmingReference。JavaObjectは抽象的なオブジェクトクラスです。つまり、JavaObjectはそれ自体でディレクトリに存在することはできません。それの補助的または構造的なサブクラスのみがディレクトリに存在する可能性があります。"
    },
    {
      "indent": 3,
      "text": "The object class javaContainer represents a directory entry dedicated to storing a Java object. It is a structural object class. In cases where a subclass of javaObject is mixed in with another structural object class, javaContainer is not required.",
      "ja": "オブジェクトクラスのJavacontainerは、Javaオブジェクトの保存専用のディレクトリエントリを表します。構造オブジェクトクラスです。JavaObjectのサブクラスが別の構造オブジェクトクラスと混合されている場合、Javacontainerは必要ありません。"
    },
    {
      "indent": 3,
      "text": "The definitions for the object classes javaObject and javaContainer are presented in Section 4.",
      "ja": "JavaobjectとJavacontainerのオブジェクトクラスの定義は、セクション4に示されています。"
    },
    {
      "indent": 3,
      "text": "The javaObject class has one mandatory attribute (javaClassName) and four optional attributes (javaClassNames, javaCodebase, javaDoc, description). javaClassName is a single valued attribute that is used to store the fully qualified name of the object's Java class (for example, \"java.lang.String\"). This may be the object's most derived class's name, but does not have to be; that of a superclass or interface in some cases might be most appropriate. This attribute is intended for storing the name of the object's \"distinguished\" class, that is, the class or interface with which the object should be identified.",
      "ja": "JavaObjectクラスには、1つの必須属性（javaclassname）と4つのオプションの属性（javaclassnames、javacodebase、javadoc、description）があります。JavaclassNameは、オブジェクトのJavaクラスの完全な資格のある名前を保存するために使用される単一の価値のある属性です（たとえば、「Java.lang.String」）。これは、オブジェクトの最も派生したクラスの名前かもしれませんが、そうである必要はありません。場合によっては、スーパークラスまたはインターフェイスのそれが最も適切かもしれません。この属性は、オブジェクトの「著名な」クラスの名前、つまりオブジェクトを識別するクラスまたはインターフェイスを保存することを目的としています。"
    },
    {
      "indent": 3,
      "text": "javaClassNames is a multivalued attribute that is used to store the fully qualified names of the object's Java classes and interfaces (for example, \"java.lang.Byte\"). Like all multivalued attributes, the javaClassNames attribute's values are unordered and so no one value is more \"distinguished\" than the others. This attribute is intended for storing an object's class and interface names and those of its ancestor classes and interfaces, although the list of values does not have to be complete. If the javaClassNames attribute is present, it should include the value of javaClassName.",
      "ja": "JavaclassNamesは、オブジェクトのJavaクラスとインターフェイス（たとえば、「Java.lang.byte」）の完全に適格な名前を保存するために使用される多バリュー属性です。すべての多価属性と同様に、JavaclassNames属性の値は順序付けられていないため、他の値よりも「区別」されていません。この属性は、オブジェクトのクラスとインターフェイス名、およびその祖先クラスとインターフェイスの名前を保存することを目的としていますが、値のリストは完全である必要はありません。JavaclassNames属性が存在する場合、JavaclassNameの値を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, suppose an object is stored in the directory with a javaClassName attribute of \"java.io.FilePermission\", and a javaClassNames attribute of {\"java.security.Permission\", \"java.io.FilePermission\", \"java.security.Guard\", \"java.io.Serializable\"}. An application searching a directory for Java objects might use javaClassName to produce a summary of the names and types of Java objects in that directory. Another application might use the javaClassNames attribute to find, for example, all java.security.Permission objects.",
      "ja": "たとえば、オブジェクトが「java.io.filepermission」のjavaclassname属性と{\"java.security.permission\"のjavaclassnames属性を備えたディレクトリに保存されているとします。.guard \"、\" java.io.serializable \"}。Javaオブジェクトのディレクトリを検索するアプリケーションでは、JavaclassNameを使用して、そのディレクトリにJavaオブジェクトの名前と種類の概要を作成する場合があります。別のアプリケーションは、javaclassNames属性を使用して、たとえばすべてのjava.security.permissionオブジェクトを見つけることができます。"
    },
    {
      "indent": 3,
      "text": "javaCodebase is a multivalued attribute that is used to store the location(s) of the object's class definition. javaDoc is used to store a pointer (URL) to the Java documentation for the class. description is used to store a textual description of a Java object and is defined in [v3Schema]. The definitions of these attributes are presented in Section 3.",
      "ja": "JavacodeBaseは、オブジェクトのクラス定義の場所を保存するために使用される多バリュー属性です。Javadocは、クラスのJavaドキュメントにポインター（URL）を保存するために使用されます。説明は、Javaオブジェクトのテキスト説明を保存するために使用され、[V3Schema]で定義されています。これらの属性の定義は、セクション3に示されています。"
    },
    {
      "indent": 0,
      "text": "2.2 Serialized Objects",
      "section_title": true,
      "ja": "2.2 シリアル化されたオブジェクト"
    },
    {
      "indent": 3,
      "text": "To \"serialize\" an object means to convert its state into a byte stream in such a way that the byte stream can be converted back into a copy of the object. A Java object is \"serializable\" if its class or any of its superclasses implements either the java.io.Serializable interface or its subinterface java.io.Externalizable. \"Deserialization\" is the process of converting the serialized form of an object back into a copy of the object. When an object is serialized, the entire tree of objects rooted at the object is also serialized. When it is deserialized, the tree is reconstructed. For example, suppose a serializable Book object contains (a serializable field of) an array of Page objects. When a Book object is serialized, so is the array of Page objects.",
      "ja": "オブジェクトは、バイトストリームをオブジェクトのコピーに戻すことができるように状態をバイトストリームに変換することを意味します。Javaオブジェクトは、そのクラスまたはそのスーパークラスがjava.io.serializableインターフェイスまたはサブインターフェイスjava.io.externalizableのいずれかを実装する場合、「シリアル化可能」です。「Deserialization」とは、オブジェクトのシリアル化された形式をオブジェクトのコピーに戻すプロセスです。オブジェクトがシリアル化されると、オブジェクトにルート化されたオブジェクトのツリー全体もシリアル化されます。それが脱色されると、木は再構築されます。たとえば、シリアル化可能な本オブジェクトに、ページオブジェクトの配列（のシリアル化可能なフィールド）が含まれているとします。本のオブジェクトがシリアル化されている場合、ページオブジェクトの配列も同様です。"
    },
    {
      "indent": 3,
      "text": "The Java platform specifies a default algorithm by which serializable objects are serialized. A Java class can also override this default serialization with its own algorithm. [Serial] describes object serialization in detail.",
      "ja": "Javaプラットフォームは、シリアル化可能なオブジェクトがシリアル化されるデフォルトのアルゴリズムを指定します。Javaクラスは、独自のアルゴリズムでこのデフォルトのシリアル化をオーバーライドすることもできます。[シリアル]オブジェクトのシリアル化について詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "When an object is serialized, information that identifies its class is recorded in the serialized stream. However, the class's definition (\"class file\") itself is not recorded. It is the responsibility of the system that is deserializing the object to determine the mechanism to use for locating and loading the associated class definitions. For example, the Java application might include in its classpath a JAR file containing the class definitions of the serialized object, or load the class definitions using information from the directory, as explained below.",
      "ja": "オブジェクトがシリアル化されると、そのクラスを識別する情報はシリアル化されたストリームに記録されます。ただし、クラスの定義（「クラスファイル」）自体は記録されていません。関連するクラスの定義を見つけてロードするために使用するメカニズムを決定するために、オブジェクトをゆったりとしているのはシステムの責任です。たとえば、Javaアプリケーションには、以下で説明するように、ClassPathにシリアル化オブジェクトのクラス定義を含むJARファイルを含めるか、ディレクトリからの情報を使用してクラス定義をロードする場合があります。"
    },
    {
      "indent": 0,
      "text": "2.2.1 Representation in the Directory",
      "section_title": true,
      "ja": "2.2.1 ディレクトリ内の表現"
    },
    {
      "indent": 3,
      "text": "A serialized object is represented in the directory by the attributes javaClassName, javaClassNames, javaCodebase, and javaSerializedData, as defined in Section 3. The mandatory attribute, javaSerializedData, contains the serialized form of the object. Although the serialized form already contains the class name, the mandatory javaClassName attribute also records the class name of the serialized object so that applications can determined class information without having to first deserialize the object. The optional javaClassNames attribute is used to record additional class information about the serialized object. The optional javaCodebase attribute is used to record the locations of the class definitions needed to deserialize the serialized object.",
      "ja": "シリアル化されたオブジェクトは、セクション3で定義されているように、javaclassname、javaclassnames、javacodebase、およびjavaserializedDataの属性によってディレクトリに表されます。シリアル化されたフォームには既にクラス名が含まれていますが、必須のJavaclassName属性は、シリアル化されたオブジェクトのクラス名も記録して、アプリケーションが最初にオブジェクトを脱必要にせずにクラス情報を決定できるようにします。オプションのJavaclassNames属性は、シリアル化されたオブジェクトに関する追加のクラス情報を記録するために使用されます。オプションのJavacodeBase属性は、シリアル化されたオブジェクトを脱色するために必要なクラス定義の位置を記録するために使用されます。"
    },
    {
      "indent": 3,
      "text": "A directory entry that contains a serialized object is represented by the object class javaSerializedObject, which is a subclass of javaObject. javaSerializedObject is an auxiliary object class, which means that it needs to be mixed in with a structural object class. javaSerializedObject's definition is given in Section 4.",
      "ja": "シリアル化されたオブジェクトを含むディレクトリエントリは、JavaObjectのサブクラスであるオブジェクトクラスJavaSerializedObjectで表されます。JavaSerializedObjectは、補助オブジェクトクラスです。つまり、構造オブジェクトクラスと混合する必要があります。JavaserializedObjectの定義はセクション4に示されています。"
    },
    {
      "indent": 0,
      "text": "2.3 Marshalled Objects",
      "section_title": true,
      "ja": "2.3 マーシャルされたオブジェクト"
    },
    {
      "indent": 3,
      "text": "To \"marshal\" an object means to record its state and codebase(s) in such a way that when the marshalled object is \"unmarshalled,\" a copy of the original object is obtained, possibly by automatically loading the class definitions of the object. You can marshal any object that is serializable or remote (that is, implements the java.rmi.Remote interface). Marshalling is like serialization, except marshalling also records codebases. Marshalling is different from serialization in that marshalling treats remote objects specially. If an object is a java.rmi.Remote object, marshalling records the remote object's \"stub\" (see Section 2.5), instead of the remote object itself. Like serialization, when an object is marshalled, the entire tree of objects rooted at the object is marshalled. When it is unmarshalled, the tree is reconstructed.",
      "ja": "オブジェクトは、オブジェクトを「マーシャル」することを意味します。これは、マーシャルされたオブジェクトが「非攻撃」されている場合、オブジェクトのクラス定義を自動的にロードすることにより、元のオブジェクトのコピーが取得されるようにします。シリアル化可能またはリモートのオブジェクト（つまり、java.rmi.remoteインターフェイスを実装する）をマーシャリングできます。マーシャリングはシリアル化のようなものですが、マーシャルはコードベースも記録します。マーシャリングは、マーシャリングがリモートオブジェクトを特別に扱うという点でシリアル化とは異なります。オブジェクトがjava.rmi.remoteオブジェクトである場合、Marshallingはリモートオブジェクト自体の代わりに、リモートオブジェクトの「スタブ」（セクション2.5を参照）を記録します。シリアル化のように、オブジェクトがマーシャルされている場合、オブジェクトに根付いたオブジェクトのツリー全体がマーシャルされます。それが無視されると、ツリーが再構築されます。"
    },
    {
      "indent": 3,
      "text": "A \"marshalled\" object is the represented by the java.rmi.MarshalledObject class. Here's an example of how to create MarshalledObjects for serializable and remote objects:",
      "ja": "「マーシャルされた」オブジェクトは、java.rmi.marshalledobjectクラスで表されます。シリアル化可能なオブジェクトとリモートオブジェクトのMarshalledObjectsを作成する方法の例は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "java.io.Serializable sobj = ...;\njava.rmi.MarshalledObject mobj1 =\n    new java.rmi.MarshalledObject(sobj);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "java.rmi.Remote robj = ...;\njava.rmi.MarshalledObject mobj2 =\n    new java.rmi.MarshalledObject(robj);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Then, to retrieve the original objects from the MarshalledObjects, do as follows:",
      "ja": "次に、元のオブジェクトをMarshalledObjectsから取得するには、次のように実行します。"
    },
    {
      "indent": 7,
      "text": "java.io.Serializable sobj = (java.io.Serializable) mobj1.get();\njava.io.Remote rstub = (java.io.Remote) mobj2.get();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "MarshalledObject is available only on the Java 2 Platform, Standard Edition, v1.2, and higher releases.",
      "ja": "MarshalledObjectは、Java 2プラットフォーム、Standard Edition、v1.2、およびHigherリリースでのみ利用できます。"
    },
    {
      "indent": 0,
      "text": "2.3.1 Representation in the Directory",
      "section_title": true,
      "ja": "2.3.1 ディレクトリ内の表現"
    },
    {
      "indent": 3,
      "text": "A marshalled object is represented in the directory by the attributes javaClassName, javaClassNames, and javaSerializedData, as defined in Section 3. The mandatory attribute, javaSerializedData, contains the serialized form of the marshalled object (that is, the serialized form of a MarshalledObject instance). The mandatory javaClassName attribute records the distinguished class name of the object before it has been marshalled. The optional javaClassNames attribute is used to record additional class information about the object before it has been marshalled.",
      "ja": "マーシャルされたオブジェクトは、セクション3で定義されているように、javaclassname、javaclassnames、およびjavaserializedDataの属性によってディレクトリに表示されます。。必須のJavaclassName属性は、オブジェクトがマーシャルされる前に、オブジェクトの著名なクラス名を記録します。オプションのJavaclassNames属性は、オブジェクトがマーシャルされる前に追加のクラス情報を記録するために使用されます。"
    },
    {
      "indent": 3,
      "text": "A directory entry that contains a marshalled object is represented by the object class javaMarshalledObject, which is a subclass of javaObject. javaMarshalledObject is an auxiliary object class, which means that it needs to be mixed in with a structural object class. javaMarshalledObject's definition is given in Section 4.",
      "ja": "マーシャルされたオブジェクトを含むディレクトリエントリは、JavaObjectのサブクラスであるオブジェクトクラスのJavamarShalledObjectで表されます。JavamarShalledObjectは、補助オブジェクトクラスです。つまり、構造オブジェクトクラスと混合する必要があります。JavamarshalledObjectの定義はセクション4に示されています。"
    },
    {
      "indent": 3,
      "text": "As evident in this description, a javaMarshalledObject differs from a javaSerializedObject only in the interpretation of the javaClassName and javaClassNames attributes.",
      "ja": "この説明で明らかなように、JavamarshalledObjectは、JavaclassNameとJavaclassNamesの属性の解釈でのみJavaSerializedObjectとは異なります。"
    },
    {
      "indent": 0,
      "text": "2.4 JNDI References",
      "section_title": true,
      "ja": "2.4 JNDI参照"
    },
    {
      "indent": 3,
      "text": "Java Naming and Directory Interface(tm) (JNDI) is a directory access API specified in the Java programming language [JNDI]. It provides an object-oriented view of the directory, allowing Java objects to be added to and retrieved from the directory without requiring the client to manage data representation issues.",
      "ja": "Javaネーミングおよびディレクトリインターフェイス（TM）（JNDI）は、Javaプログラミング言語[JNDI]で指定されたディレクトリアクセスAPIです。ディレクトリのオブジェクト指向ビューを提供し、クライアントにデータ表現の問題を管理することなく、Javaオブジェクトをディレクトリに追加して取得できるようにします。"
    },
    {
      "indent": 3,
      "text": "JNDI defines the notion of a \"reference\" for use when an object cannot be stored in the directory directly, or when it is inappropriate or undesirable to do so. An object with an associated reference is stored in the directory indirectly, by storing its reference instead.",
      "ja": "JNDIは、オブジェクトをディレクトリに直接保存できない場合、または不適切または望ましくない場合に使用するための「参照」の概念を定義します。関連する参照を持つオブジェクトは、代わりに参照を保存することにより、ディレクトリに間接的に保存されます。"
    },
    {
      "indent": 0,
      "text": "2.4.1 Contents of a Reference",
      "section_title": true,
      "ja": "2.4.1 参照の内容"
    },
    {
      "indent": 3,
      "text": "A JNDI reference is a Java object of class javax.naming.Reference. It consists of class information about the object being referenced and an ordered list of addresses. An address is a Java object of class javax.naming.RefAddr. Each address contains information on how to construct the object.",
      "ja": "JNDIリファレンスは、クラスjavax.naming.referenceのJavaオブジェクトです。これは、参照されているオブジェクトに関するクラス情報と、順序付けられたアドレスのリストで構成されています。アドレスは、クラスjavax.naming.refaddrのJavaオブジェクトです。各アドレスには、オブジェクトの構築方法に関する情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "A common use for JNDI references is to represent connections to a network service such as a database, directory, or file system. Each address may then identify a \"communications endpoint\" for that service, containing information on how to contact the service. Multiple addresses may arise for various reasons, such as replication or the object offering interfaces over more than one communication mechanism.",
      "ja": "JNDI参照の一般的な用途は、データベース、ディレクトリ、ファイルシステムなどのネットワークサービスへの接続を表すことです。各アドレスは、サービスに連絡する方法に関する情報を含む、そのサービスの「通信エンドポイント」を特定することができます。複数のアドレスが、複数の通信メカニズムを超えるレプリケーションやオブジェクトを提供するオブジェクトなど、さまざまな理由で発生する場合があります。"
    },
    {
      "indent": 3,
      "text": "A reference also contains information to assist in the creation of an instance of the object to which the reference refers. It contains the Java class name of that object, and the class name and location of the object factory to be used to create the object. The procedures for creating an object given its reference and the reverse are described in [JNDI].",
      "ja": "参照には、参照が参照するオブジェクトのインスタンスの作成を支援する情報も含まれています。そのオブジェクトのJavaクラス名と、オブジェクトを作成するために使用されるオブジェクト工場のクラス名と場所が含まれています。その参照と逆に与えられたオブジェクトを作成する手順は、[JNDI]で説明されています。"
    },
    {
      "indent": 0,
      "text": "2.4.2 Representation in the Directory",
      "section_title": true,
      "ja": "2.4.2 ディレクトリ内の表現"
    },
    {
      "indent": 3,
      "text": "A JNDI reference is stored in the directory by using the attributes javaClassName, javaClassNames, javaCodebase, javaReferenceAddress, and javaFactory, defined in Section 3. These attributes store information corresponding to the contents of a reference described above. javaReferenceAddress is a multivalued optional attribute for storing reference addresses. javaFactory is the optional attribute for storing the object factory's fully qualified class name. The mandatory javaClassName attribute is used to store the name of the distinguished class of the object. The optional javaClassNames attribute is used to record additional class and interface names. The optional javaCodebase attribute is used to store the locations of the object factory's and the object's class definitions.",
      "ja": "JNDI参照は、javaclassname、javaclassnames、javacodebase、javareferenceaddress、およびjavafactoryの属性を使用してディレクトリに保存されます。これらの属性は、上記の参照の内容に対応する情報を保存します。JavareferEnceaddressは、参照アドレスを保存するための多面的なオプション属性です。JavaFactoryは、オブジェクトファクトリーの完全資格のあるクラス名を保存するためのオプションの属性です。必須のJavaclassName属性は、オブジェクトの著名なクラスの名前を保存するために使用されます。オプションのJavaclassNames属性は、追加のクラス名とインターフェイス名を記録するために使用されます。オプションのJavacodeBase属性は、オブジェクト工場の場所とオブジェクトのクラス定義の場所を保存するために使用されます。"
    },
    {
      "indent": 3,
      "text": "A directory entry containing a JNDI reference is represented by the object class javaNamingReference, which is a subclass of javaObject. javaNamingReference is an auxiliary object class, which means that it needs to be mixed in with a structural object class. javaNamingReference's definition is given in Section 4.",
      "ja": "JNDIリファレンスを含むディレクトリエントリは、JavaObjectのサブクラスであるオブジェクトクラスJavanAmingReferenceで表されます。JavanAmingReferenceは補助オブジェクトクラスです。つまり、構造オブジェクトクラスと混合する必要があります。JavanamingReferenceの定義はセクション4に示されています。"
    },
    {
      "indent": 0,
      "text": "2.5 Remote Objects",
      "section_title": true,
      "ja": "2.5 リモートオブジェクト"
    },
    {
      "indent": 3,
      "text": "The Java Remote Method Invocation (RMI) system [RMI] is a mechanism that enables an object on one Java virtual machine to invoke methods on an object in another Java virtual machine. Any object whose methods can be invoked in this way must implement the java.rmi.Remote interface. When such an object is invoked, its arguments are marshalled and sent from the local virtual machine to the remote one, where the arguments are unmarshalled and used. When the method terminates, the results are marshalled from the remote machine and sent to the caller's virtual machine.",
      "ja": "Java Remote Method Invocation（RMI）システム[RMI]は、1つのJava仮想マシン上のオブジェクトが別のJava仮想マシンのオブジェクトにメソッドを呼び出すことができるメカニズムです。この方法でメソッドを呼び出すことができるオブジェクトは、java.rmi.remoteインターフェイスを実装する必要があります。そのようなオブジェクトが呼び出されると、その引数はマーシャルされ、ローカル仮想マシンからリモートマシンに送信されます。メソッドが終了すると、結果はリモートマシンからマーシャルされ、発信者の仮想マシンに送信されます。"
    },
    {
      "indent": 3,
      "text": "To make a remote object accessible to other virtual machines, a program typically registers it with the RMI registry. The program supplies to the RMI registry the string name of the remote object and the remote object itself. When a program wants to access a remote object, it supplies the object's string name to the RMI registry on the same machine as the remote object. The RMI registry returns to the caller a reference (called \"stub\") to the remote object. When the program receives the stub for the remote object, it can invoke methods on the remote object (through the stub). A program can also obtain references to remote objects as a result of remote calls to other remote objects or from other naming services. For example, the program can look up a reference to a remote object from an LDAP server that supports the schema defined in this document.",
      "ja": "リモートオブジェクトを他の仮想マシンにアクセスできるようにするために、プログラムは通常、RMIレジストリでそれを登録します。プログラムは、RMIレジストリにリモートオブジェクトの文字列名とリモートオブジェクト自体を提供します。プログラムがリモートオブジェクトにアクセスしたい場合、オブジェクトの文字列名はリモートオブジェクトと同じマシン上のRMIレジストリに供給されます。RMIレジストリは、リモートオブジェクトへの参照（「スタブ」と呼ばれる）を発信者に返します。プログラムがリモートオブジェクトのスタブを受信すると、リモートオブジェクトにメソッドを呼び出すことができます（スタブを介して）。プログラムは、他のリモートオブジェクトまたは他のネーミングサービスからのリモート呼び出しの結果として、リモートオブジェクトへの参照を取得することもできます。たとえば、プログラムは、このドキュメントで定義されているスキーマをサポートするLDAPサーバーからリモートオブジェクトへの参照を検索できます。"
    },
    {
      "indent": 3,
      "text": "The string name accepted by the RMI registry has the syntax \"rmi://hostname:port/remoteObjectName\", where \"hostname\" and \"port\" identify the machine and port on which the RMI registry is running, respectively, and \"remoteObjectName\" is the string name of the remote object. \"hostname\", \"port\", and the prefix, \"rmi:\", are optional. If \"hostname\" is not specified, it defaults to the local host. If \"port\" is not specified, it defaults to 1099. If \"remoteObjectName\" is not specified, then the object being named is the RMI registry itself. See [RMI] for details.",
      "ja": "RMIレジストリによって受け入れられた文字列名には、「rmi：// hostname：port/remoteObjectName」という構文があり、「ホスト名」と「ポート」は、それぞれRMIレジストリが実行されているマシンとポートを識別し、「remoteObjectName」を識別します。リモートオブジェクトの文字列名です。「ホスト名」、「ポート」、およびプレフィックス「RMI：」はオプションです。「ホスト名」が指定されていない場合、デフォルトはローカルホストになります。「ポート」が指定されていない場合、デフォルトは1099になります。「remoteObjectName」が指定されていない場合、名前が付けられているオブジェクトはRMIレジストリ自体です。詳細については、[RMI]を参照してください。"
    },
    {
      "indent": 3,
      "text": "RMI can be supported using different protocols: the Java Remote Method Protocol (JRMP) and the Internet Inter-ORB Protocol (IIOP). The JRMP is a specialized protocol designed for RMI; the IIOP is the standard protocol for communication between CORBA objects [CORBA]. RMI over IIOP allows Java remote objects to communicate with CORBA objects which might be written in a non-Java programming language [RMI-IIOP].",
      "ja": "RMIは、Java Remote Method Protocol（JRMP）とインターネット間ORBプロトコル（IIOP）のさまざまなプロトコルを使用してサポートできます。JRMPは、RMI向けに設計された専門的なプロトコルです。IIOPは、Corbaオブジェクト間の通信のための標準プロトコル[Corba]です。RMI over IIOPを使用すると、Javaリモートオブジェクトは、非Javaプログラミング言語[RMI-IIOP]で書かれているCorbaオブジェクトと通信できます。"
    },
    {
      "indent": 0,
      "text": "2.5.1 Representation in the Directory",
      "section_title": true,
      "ja": "2.5.1 ディレクトリ内の表現"
    },
    {
      "indent": 3,
      "text": "Remote objects that use the IIOP are represented in the directory as CORBA object references [CORBA-LDAP]. Remote objects that use the JRMP are represented in the directory in one of two ways: as a marshalled object, or as a JNDI reference.",
      "ja": "IIOPを使用するリモートオブジェクトは、ディレクトリでCorba Object References [corba-ldap]として表されます。JRMPを使用するリモートオブジェクトは、2つの方法のいずれかのいずれかでディレクトリに表されます。"
    },
    {
      "indent": 3,
      "text": "A marshalled object records the codebases of the remote object's stub and any serializable or remote objects that it references, and replaces remote objects with their stubs. To store a Remote object as a marshalled object (java.rmi.MarshalledObject), you first create a java.rmi.MarshalledObject instance for it.",
      "ja": "マーシャルされたオブジェクトは、リモートオブジェクトのスタブのコードベースと、参照するシリアル化可能またはリモートオブジェクトを記録し、リモートオブジェクトをスタブに置き換えます。リモートオブジェクトをマーシャルオブジェクト（java.rmi.marshalledobject）として保存するには、最初にjava.rmi.marshalledobjectインスタンスを作成します。"
    },
    {
      "indent": 7,
      "text": "java.rmi.Remote robj = ...;\njava.rmi.MarshalledObject mobj =\n    new java.rmi.MarshalledObject(robj);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "You can then store the MarshalledObject instance as a javaMarshalledObject. The javaClassName attribute should contain the fully qualified name of the distinguished class of the remote object. The javaClassNames attribute should contain the names of the classes and interfaces of the remote object. To read the remote object back from the directory, first deserialize the contents of the javaSerializedData to get a MarshalledObject (mobj), then retrieve it from the MarshalledObject as follows:",
      "ja": "その後、JavamarshalledObjectとしてMarshalledObjectインスタンスを保存できます。JavaclassName属性には、リモートオブジェクトの著名なクラスの完全に適格な名前を含める必要があります。JavaclassNames属性には、リモートオブジェクトのクラスとインターフェイスの名前を含める必要があります。ディレクトリからリモートオブジェクトを読み戻すには、最初にJavaSerializedDataの内容を脱骨化してMarshalledObject（MOBJ）を取得し、次のようにMarshalLedObjectから取得します。"
    },
    {
      "indent": 7,
      "text": "java.rmi.Remote robj = (java.rmi.Remote)mobj.get();",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This returns the remote stub, which you can then use to invoke remote methods.",
      "ja": "これにより、リモートスタブが返され、リモートメソッドを呼び出すために使用できます。"
    },
    {
      "indent": 3,
      "text": "MarshalledObject is available only on the Java 2 Platform, Standard Edition, v1.2 and higher releases. Therefore, a remote object stored as a MarshalledObject can only be read by clients using the the Java 2 Platform, Standard Edition, v1.2 or higher releases.",
      "ja": "MarshalledObjectは、Java 2プラットフォーム、標準版、v1.2以降のリリースでのみ利用できます。したがって、MarshalledObjectとして保存されているリモートオブジェクトは、Java 2プラットフォーム、標準版、v1.2以降のリリースを使用してクライアントによってのみ読み取ることができます。"
    },
    {
      "indent": 3,
      "text": "To store a remote object as a JNDI reference, you first create a javax.naming.Reference object instance for it using the remote object's string name as it has been, or will be, recorded with the RMI registry, with the additional restriction that the \"rmi:\" prefix must be present. Here's an example:",
      "ja": "リモートオブジェクトをJNDIリファレンスとして保存するには、最初にjavax.naming.Referenceオブジェクトインスタンスを作成します。RMIレジストリでリモートオブジェクトの文字列名を使用して、またはRMIレジストリで記録します。「RMI：」プレフィックスが存在する必要があります。これが例です："
    },
    {
      "indent": 7,
      "text": "javax.naming.Reference ref = new javax.naming.Reference(\n  obj.getClass().getName(),\n  new javax.naming.StringRefAddr(\"URL\",\n      \"rmi://rserver/AppRemoteObjectX\"));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "You then store the javax.naming.Reference instance as a javaNamingReference. The advantage of using a JNDI reference is that this can be done without a reference to the remote object. In fact, the remote object does not have to exist at the time that this recording in the directory is made. The remote object needs to exist and be bound with the RMI registry when the object is looked up from the directory.",
      "ja": "次に、javax.naming.ReferenceインスタンスをJavanAmingReferenceとして保存します。JNDI参照を使用する利点は、これをリモートオブジェクトへの参照なしで実行できることです。実際、リモートオブジェクトは、ディレクトリ内のこの記録が作成された時点で存在する必要はありません。リモートオブジェクトは、オブジェクトがディレクトリから検索されたときに存在し、RMIレジストリに拘束される必要があります。"
    },
    {
      "indent": 0,
      "text": "2.6 Serialized Objects Vs. Marshalled Objects Vs. References",
      "section_title": true,
      "ja": "2.6 シリアル化されたオブジェクトとマーシャルされたオブジェクトVs参照"
    },
    {
      "indent": 3,
      "text": "The object classes defined in this document store different aspects of the Java objects.",
      "ja": "このドキュメントストアで定義されたオブジェクトクラスは、Javaオブジェクトのさまざまな側面です。"
    },
    {
      "indent": 3,
      "text": "A javaSerializedObject or a serializable object stored as a javaMarshalledObject represents the object itself, while a javaNamingReference or a remote object stored as a javaMarshalledObject represents a \"pointer\" to the object.",
      "ja": "JavaSerializedObjectまたはJavamarshalledObjectとして保存されているシリアル化可能なオブジェクトは、オブジェクト自体を表しますが、JavanAmingReferenceまたはJavamarShalledObjectとして保存されているリモートオブジェクトは、オブジェクトの「ポインター」を表します。"
    },
    {
      "indent": 3,
      "text": "When storing a serializable object in the directory, you have a choice of storing it as a javaSerializedObject or a javaMarshalledObject. The javaSerializedObject object class provides the basic way in which to store serializable objects. When you create an LDAP entry using the javaSerializableObject object class, you must explicitly set the javaCodebase attribute if you want readers of that entry to know where to load the class definitions of the object. When you create an LDAP entry using the javaMarshalledObject object class, you use the MarshalledObject class. The MarshalledObject class uses the RMI infrastructure available on the Java platform to automate how codebase information is gathered and recorded, thus freeing you from having to set the javaCodebase attribute. On the other hand, the javaCodebase attribute is human-readable and can be updated easily by using text-based tools without having to change other parts of the entry. This allows you, for instance, to move the class definitions to another location and then update the javaCodebase attribute to reflect the move without having to update the serialized object itself.",
      "ja": "シリアル化可能なオブジェクトをディレクトリに保存する場合、JavaSerializedObjectまたはJavamarShalledObjectとして保存することを選択できます。JavaSerializedObjectオブジェクトクラスは、シリアル化可能なオブジェクトを保存するための基本的な方法を提供します。JavaSerializableObject Objectクラスを使用してLDAPエントリを作成する場合、そのエントリの読者がオブジェクトのクラス定義をロードする場所を知っている場合は、JavacodeBase属性を明示的に設定する必要があります。JavamarShalledObject Objectクラスを使用してLDAPエントリを作成すると、MarshalledObjectクラスを使用します。MarshalledObjectクラスは、Javaプラットフォームで利用可能なRMIインフラストラクチャを使用して、コードベース情報の収集と記録の自動化を行うため、JavacodeBase属性を設定する必要がなくなります。一方、JavacodeBase属性は人間が読みやすく、エントリの他の部分を変更せずにテキストベースのツールを使用して簡単に更新できます。これにより、たとえば、クラスの定義を別の場所に移動し、JavacodeBase属性を更新して、シリアル化されたオブジェクト自体を更新することなく動きを反映することができます。"
    },
    {
      "indent": 3,
      "text": "A javaNamingReference provides a way of recording address information about an object which itself is not directly stored in the directory. A remote object stored as a javaMarshalledObject also records address information (the object's \"stub\") of an object which itself is not directory stored in the directory. In other words, you can think of these as compact representations of the information required to access the object.",
      "ja": "JavanAmingReferenceは、ディレクトリに直接保存されていないオブジェクトに関するアドレス情報を記録する方法を提供します。JavamarshalledObjectとして保存されているリモートオブジェクトは、ディレクトリにディレクトリに保存されていないオブジェクトのアドレス情報（オブジェクトの「スタブ」）を記録します。言い換えれば、これらはオブジェクトにアクセスするために必要な情報のコンパクトな表現と考えることができます。"
    },
    {
      "indent": 3,
      "text": "A javaNamingReference typically consists of a small number of human-readable strings. Standard text-based tools for directory administration may therefore be used to add, read, or modify reference entries -- if so desired -- quite easily. Serialized and marshalled objects are not intended to be read or manipulated directly by humans.",
      "ja": "通常、JavanAmingReferenceは、人間が読み取る少数の文字列で構成されています。したがって、ディレクトリ管理用の標準的なテキストベースのツールは、参照エントリを追加、読み取り、または変更するために使用できます（必要に応じて、非常に簡単に）。シリアル化されているオブジェクトとマーシャルされたオブジェクトは、人間によって直接読まれたり操作されることを意図していません。"
    },
    {
      "indent": 0,
      "text": "3 Attribute Type Definitions",
      "ja": "3属性タイプ定義"
    },
    {
      "indent": 3,
      "text": "The following attribute types are defined in this document:",
      "ja": "次の属性タイプは、このドキュメントで定義されています。"
    },
    {
      "indent": 7,
      "text": "javaClassName javaClassNames javaCodebase javaSerializedData javaFactory javaReferenceAddress javaDoc",
      "ja": "javaclassname javaclassnames javacodebase javaserializeddata javafactory javareferenceaddress javadoc"
    },
    {
      "indent": 0,
      "text": "3.1 javaClassName",
      "section_title": true,
      "ja": "3.1 javaclassname"
    },
    {
      "indent": 3,
      "text": "This attribute stores the fully qualified name of the Java object's \"distinguished\" class or interface (for example, \"java.lang.String\"). It is a single-valued attribute. This attribute's syntax is ' Directory String' and its case is significant.",
      "ja": "この属性は、Javaオブジェクトの「Distinguished」クラスまたはインターフェイス（たとえば、「Java.lang.String」）の完全に適格な名前を保存します。これは単一値の属性です。この属性の構文は「ディレクトリ文字列」であり、そのケースは重要です。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.6 NAME 'javaClassName' DESC 'Fully qualified name of distinguished Java class or interface' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 SINGLE-VALUE )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.1.6名 'Javaclassname' desc '著名なJavaクラスまたはインターフェイスの完全資格の名前' equality caseexactmatch Syntax 1.3.6.1.4.1.1466.115.121.1.15単一値）"
    },
    {
      "indent": 0,
      "text": "3.2 javaCodebase",
      "section_title": true,
      "ja": "3.2 JavacodeBase"
    },
    {
      "indent": 3,
      "text": "This attribute stores the Java class definition's locations. It specifies the locations from which to load the class definition for the class specified by the javaClassName attribute. Each value of the attribute contains an ordered list of URLs, separated by spaces. For example, a value of \"url1 url2 url3\" means that the three (possibly interdependent) URLs (url1, url2, and url3) form the codebase for loading in the Java class definition.",
      "ja": "この属性は、Javaクラスの定義の場所を保存します。JavaclassName属性によって指定されたクラスのクラス定義をロードする場所を指定します。属性の各値には、スペースで区切られたURLの順序付けられたリストが含まれています。たとえば、「URL1 URL2 URL3」の値は、3つの（おそらく相互依存性）URL（URL1、URL2、およびURL3）がJavaクラス定義にロードするためのコードベースを形成することを意味します。"
    },
    {
      "indent": 3,
      "text": "If the javaCodebase attribute contains more than one value, each value is an independent codebase. That is, there is no relationship between the URLs in one value and those in another; each value can be viewed as an alternate source for loading the Java class definition. See [Java] for information regarding class loading.",
      "ja": "JavacodeBase属性に複数の値が含まれている場合、各値は独立したコードベースです。つまり、ある値のURLと別の値のURLの間に関係はありません。各値は、Javaクラス定義をロードするための代替ソースとして表示できます。クラスの読み込みに関する情報については、[Java]を参照してください。"
    },
    {
      "indent": 3,
      "text": "This attribute's syntax is 'IA5 String' and its case is significant.",
      "ja": "この属性の構文は「IA5文字列」であり、そのケースは重要です。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.7 NAME 'javaCodebase' DESC 'URL(s) specifying the location of class definition' EQUALITY caseExactIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.1.7名「JavacodeBase」DESC 'URLクラス定義の位置を指定する' equality caseexactia5match Syntax 1.3.6.1.4.1.1466.115.121.1.1.1.26）"
    },
    {
      "indent": 0,
      "text": "3.3 javaClassNames",
      "section_title": true,
      "ja": "3.3 JavaclassNames"
    },
    {
      "indent": 3,
      "text": "This attribute stores the Java object's fully qualified class or interface names (for example, \"java.lang.String\"). It is a multivalued attribute. When more than one value is present, each is the name of a class or interface, or ancestor class or interface, of this object.",
      "ja": "この属性は、Javaオブジェクトの完全に適格なクラスまたはインターフェイス名（たとえば、「java.lang.string」）を保存します。多面的な属性です。複数の値が存在する場合、それぞれがこのオブジェクトのクラスまたはインターフェイス、または祖先クラスまたはインターフェイスの名前です。"
    },
    {
      "indent": 3,
      "text": "This attribute's syntax is 'Directory String' and its case is significant.",
      "ja": "この属性の構文は「ディレクトリ文字列」であり、そのケースは重要です。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.13 NAME 'javaClassNames' DESC 'Fully qualified Java class or interface name' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.1.13名 'Javaclassnames' desc '完全資格のあるJavaクラスまたはインターフェイス名' Equality Caseexactmatch Syntax 1.3.6.1.4.1.1466.115.121.1.15）"
    },
    {
      "indent": 0,
      "text": "3.4 javaSerializedData",
      "section_title": true,
      "ja": "3.4 JavaSerializedData"
    },
    {
      "indent": 3,
      "text": "This attribute stores the serialized form of a Java object. The serialized form is described in [Serial].",
      "ja": "この属性は、Javaオブジェクトのシリアル化された形式を保存します。シリアル化されたフォームは[シリアル]で説明されています。"
    },
    {
      "indent": 3,
      "text": "This attribute's syntax is 'Octet String'.",
      "ja": "この属性の構文は「Octet String」です。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.8 NAME 'javaSerializedData DESC 'Serialized form of a Java object' SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 SINGLE-VALUE )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.1.8名 'JavaserializedData Desc' Javaオブジェクトのシリアル化された形式 '構文1.3.6.1.4.1.1.1466.115.121.1.40単一値）"
    },
    {
      "indent": 0,
      "text": "3.5 javaFactory",
      "section_title": true,
      "ja": "3.5 JavaFactory"
    },
    {
      "indent": 3,
      "text": "This attribute stores the fully qualified class name of the object factory (for example, \"com.wiz.jndi.WizObjectFactory\") that can be used to create an instance of the object identified by the javaClassName attribute.",
      "ja": "この属性は、JavaclassName属性によって識別されたオブジェクトのインスタンスを作成するために使用できるオブジェクト工場の完全に適格なクラス名（たとえば、com.wiz.jndi.wizobjectfactory」）を保存します。"
    },
    {
      "indent": 3,
      "text": "This attribute's syntax is 'Directory String' and its case is significant.",
      "ja": "この属性の構文は「ディレクトリ文字列」であり、そのケースは重要です。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.10 NAME 'javaFactory' DESC 'Fully qualified Java class name of a JNDI object factory' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 SINGLE-VALUE )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.1.10名 'JavaFactory' desc '' jndiオブジェクト工場の完全資格のJavaクラス名 'equality caseexactmatch Syntax 1.3.6.1.4.1.1466.115.121.1.15単位）"
    },
    {
      "indent": 0,
      "text": "3.6 javaReferenceAddress",
      "section_title": true,
      "ja": "3.6 Javareferenceaddress"
    },
    {
      "indent": 3,
      "text": "This attribute represents the sequence of addresses of a JNDI reference. Each of its values represents one address, a Java object of type javax.naming.RefAddr. Its value is a concatenation of the address type and address contents, preceded by a sequence number (the order of addresses in a JNDI reference is significant). For example:",
      "ja": "この属性は、JNDI参照のアドレスのシーケンスを表します。その値のそれぞれは、タイプjavax.naming.refaddrのJavaオブジェクトである1つのアドレスを表します。その値は、アドレスタイプとアドレスコンテンツの連結であり、シーケンス番号が前にあります（JNDI参照のアドレスの順序は重要です）。例えば："
    },
    {
      "indent": 7,
      "text": "#0#TypeA#ValA\n#1#TypeB#ValB\n#2#TypeC##rO0ABXNyABpq...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In more detail, the value is encoded as follows: The delimiter is the first character of the value. For readability the character '#' is recommended when it is not otherwise used anywhere in the value, but any character may be used subject to restrictions given below.",
      "ja": "より詳細には、値は次のようにエンコードされます。デリミッターは値の最初の文字です。読みやすさのために、キャラクター「＃」は、値のどこにも使用されない場合に推奨されますが、以下に示す制限の対象となるキャラクターは使用できます。"
    },
    {
      "indent": 3,
      "text": "The first delimiter is followed by the sequence number. The sequence number of an address is its position in the JNDI reference, with the first address being numbered 0. It is represented by its shortest string form, in decimal notation.",
      "ja": "最初の区切り文字の後にシーケンス番号が続きます。アドレスのシーケンス番号は、JNDI参照の位置であり、最初のアドレスには数が数えられます。これは、10進表記で最短の文字列形式で表されます。"
    },
    {
      "indent": 3,
      "text": "The sequence number is followed by a delimiter, then by the address type, and then by another delimiter. If the address is of Java class javax.naming.StringRefAddr, then this delimiter is followed by the value of the address contents (which is a string). Otherwise, this delimiter is followed immediately by another delimiter, and then by the Base64 encoding of the serialized form of the entire address.",
      "ja": "シーケンス番号の後に区切り文字が続き、次にアドレスタイプが続き、次に別の区切り文字が続きます。アドレスがJavaクラスjavax.naming.stringrefaddrの場合、この区切り文字の後にアドレスコンテンツの値（文字列です）が続きます。それ以外の場合、この区切り文字の後には、すぐに別のデリミッターが続き、その後、アドレス全体のシリアル化された形式のbase64エンコードが続きます。"
    },
    {
      "indent": 3,
      "text": "The delimiter may be any character other than a digit or a character contained in the address type. In addition, if the address contents is a string, the delimiter may not be the first character of that string.",
      "ja": "区切り文字は、桁またはアドレスタイプに含まれる文字以外の任意の文字である場合があります。さらに、アドレスの内容が文字列の場合、区切り文字はその文字列の最初の文字ではない場合があります。"
    },
    {
      "indent": 3,
      "text": "This attribute's syntax is 'Directory String' and its case is significant. It can contain multiple values.",
      "ja": "この属性の構文は「ディレクトリ文字列」であり、そのケースは重要です。複数の値を含めることができます。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.11 NAME 'javaReferenceAddress' DESC 'Addresses associated with a JNDI Reference' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.1.11名「JNDI参照」に関連付けられた「JavareferEnceaddress 'DESC」アドレス「equality caseexactmatch構文1.3.6.1.4.1.14666.115.121.1.15）"
    },
    {
      "indent": 0,
      "text": "3.7 javaDoc",
      "section_title": true,
      "ja": "3.7 Javadoc"
    },
    {
      "indent": 3,
      "text": "This attribute stores a pointer to the Java documentation for the class. It's value is a URL. For example, the following URL points to the specification of the java.lang.String class: http://java.sun.com/products/jdk/1.2/docs/api/java/lang/String.html",
      "ja": "この属性は、クラスのJavaドキュメントへのポインターを保存します。値はURLです。たとえば、次のURLはjava.lang.stringクラスの仕様を指します：http：//java.sun.com/products/jdk/1.2/docs/api/java/lang/string.html"
    },
    {
      "indent": 3,
      "text": "This attribute's syntax is 'IA5 String' and its case is significant.",
      "ja": "この属性の構文は「IA5文字列」であり、そのケースは重要です。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.12 NAME 'javaDoc' DESC 'The Java documentation for the class' EQUALITY caseExactIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.1.12 Name 'Javadoc' desc 'クラスのJavaドキュメント' equality caseexactia5match Syntax 1.3.6.1.4.1.1466.115.121.1.1.26）"
    },
    {
      "indent": 0,
      "text": "4 Object Class Definitions",
      "ja": "4オブジェクトクラスの定義"
    },
    {
      "indent": 3,
      "text": "The following object classes are defined in this document:",
      "ja": "次のオブジェクトクラスは、このドキュメントで定義されています。"
    },
    {
      "indent": 7,
      "text": "javaContainer javaObject javaSerializedObject javaMarshalledObject javaNamingReference",
      "ja": "javacontainer javaobject javaserialized object javamarshalledobject javanamingreference"
    },
    {
      "indent": 0,
      "text": "4.1 javaContainer",
      "section_title": true,
      "ja": "4.1 Javacontainer"
    },
    {
      "indent": 3,
      "text": "This structural object class represents a container for a Java object.",
      "ja": "この構造オブジェクトクラスは、Javaオブジェクトのコンテナを表します。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.1 NAME 'javaContainer' DESC 'Container for a Java object' SUP top STRUCTURAL MUST ( cn ) )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.2.1名「Javacontainer」javaオブジェクト用のコンテナ 'SUPトップ構造マスト（CN））"
    },
    {
      "indent": 0,
      "text": "4.2 javaObject",
      "section_title": true,
      "ja": "4.2 JavaObject"
    },
    {
      "indent": 3,
      "text": "This abstract object class represents a Java object. A javaObject cannot exist in the directory; only auxiliary or structural subclasses of it can exist in the directory.",
      "ja": "この抽象オブジェクトクラスは、Javaオブジェクトを表します。JavaObjectはディレクトリに存在できません。それの補助的または構造的なサブクラスのみがディレクトリに存在する可能性があります。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.4 NAME 'javaObject' DESC 'Java object representation' SUP top ABSTRACT MUST ( javaClassName ) MAY ( javaClassNames $ javaCodebase $ javaDoc $ description ) )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.2.4名 'Javaobject' desc 'Javaオブジェクト表現' Sup Top Abstract（javaclassname）5月（javaclassnames $ javacodebase $ javadoc $ description））"
    },
    {
      "indent": 0,
      "text": "4.3 javaSerializedObject",
      "section_title": true,
      "ja": "4.3 JavaSerializedObject"
    },
    {
      "indent": 3,
      "text": "This auxiliary object class represents a Java serialized object. It must be mixed in with a structural object class.",
      "ja": "この補助オブジェクトクラスは、Javaシリアル化されたオブジェクトを表します。構造オブジェクトクラスと混合する必要があります。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.5 NAME 'javaSerializedObject' DESC 'Java serialized object' SUP javaObject AUXILIARY MUST ( javaSerializedData ) )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.2.5名 'JavaserializedObject' desc 'Javaシリアル化オブジェクト' sup javaobject Auxiliary（javaserializeddata）））"
    },
    {
      "indent": 0,
      "text": "4.4 javaMarshalledObject",
      "section_title": true,
      "ja": "4.4 JavamarshalledObject"
    },
    {
      "indent": 3,
      "text": "This auxiliary object class represents a Java marshalled object. It must be mixed in with a structural object class.",
      "ja": "この補助オブジェクトクラスは、Javaマーシャルオブジェクトを表します。構造オブジェクトクラスと混合する必要があります。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.8 NAME 'javaMarshalledObject' DESC 'Java marshalled object' SUP javaObject AUXILIARY MUST ( javaSerializedData ) )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.2.8名 'Javamarshalledobject' desc 'Java Marshalled Object' sup JavaObject Auxiliary Must（JavaSerializedData）））"
    },
    {
      "indent": 0,
      "text": "4.5 javaNamingReference",
      "section_title": true,
      "ja": "4.5 JavanAmingReference"
    },
    {
      "indent": 3,
      "text": "This auxiliary object class represents a JNDI reference. It must be mixed in with a structural object class.",
      "ja": "この補助オブジェクトクラスは、JNDIリファレンスを表します。構造オブジェクトクラスと混合する必要があります。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.7 NAME 'javaNamingReference' DESC 'JNDI reference' SUP javaObject AUXILIARY MAY ( javaReferenceAddress $ javaFactory ) )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.2.7名 'JavanamingReference' desc 'Jndiリファレンス' sup javaobject Auxiliary 5月（javareferenceaddress $ javafactory））"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Serializing an object and storing it into the directory enables (a copy of) the object to be examined and used outside the environment in which it was originally created. The directory entry containing the serialized object could be read and modified within the constraints imposed by the access control mechanisms of the directory. If an object contains sensitive information or information that could be misused outside of the context in which it was created, the object should not be stored in the directory. For more details on security issues relating to serialization in general, see [Serial].",
      "ja": "オブジェクトをシリアル化してディレクトリに保存することで、最初に作成された環境の外で検査および使用するオブジェクトを（コピー）することができます。シリアル化されたオブジェクトを含むディレクトリエントリは、ディレクトリのアクセス制御メカニズムによって課される制約内で読み取りおよび変更できます。オブジェクトに、作成されたコンテキストの外で誤用される可能性のある機密情報または情報が含まれている場合、オブジェクトをディレクトリに保存しないでください。一般的なシリアル化に関するセキュリティ問題の詳細については、[シリアル]を参照してください。"
    },
    {
      "indent": 0,
      "text": "6. Acknowledgements",
      "section_title": true,
      "ja": "6. 謝辞"
    },
    {
      "indent": 3,
      "text": "We would like to thank Joseph Fialli, Peter Jones, Roger Riggs, Bob Scheifler, and Ann Wollrath of Sun Microsystems for their comments and suggestions.",
      "ja": "ジョセフ・フィアリ、ピーター・ジョーンズ、ロジャー・リッグス、ボブ・シーフラー、サン・マイクロシステムズのアン・ウォロラスのコメントと提案に感謝します。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7. 参考文献"
    },
    {
      "indent": 3,
      "text": "[CORBA] The Object Management Group, \"Common Object Request Broker Architecture Specification 2.0,\" http://www.omg.org",
      "ja": "[Corba]オブジェクト管理グループ、「Common Object Request Broker Architecture Specification 2.0」、http://www.omg.org"
    },
    {
      "indent": 3,
      "text": "[CORBA-LDAP] Ryan, V., Lee, R. and S. Seligman, \"Schema for Representing CORBA Object References in an LDAP Directory\", RFC 2714, October 1999.",
      "ja": "[Corba-ldap] Ryan、V.、Lee、R。、およびS. Seligman、「LDAPディレクトリでCorbaオブジェクト参照を表すためのスキーマ」、RFC 2714、1999年10月。"
    },
    {
      "indent": 3,
      "text": "[Java] Ken Arnold and James Gosling, \"The Java(tm) Programming Language,\" Second Edition, ISBN 0-201-31006-6.",
      "ja": "[Java] Ken ArnoldとJames Gosling、「The Java（TM）プログラミング言語」、第2版、ISBN 0-201-31006-6。"
    },
    {
      "indent": 3,
      "text": "[JNDI] Java Software, Sun Microsystems, Inc., \"The Java(tm) Naming and Directory Interface (tm) Specification,\" February 1998. http://java.sun.com/products/jndi/",
      "ja": "[JNDI] Java Software、Sun Microsystems、Inc。、「The Java（TM）Naming and Directory Interface（TM）仕様」、1998年2月。http：//java.sun.com/products/jndi//"
    },
    {
      "indent": 3,
      "text": "[LDAPv3] Wahl, M., Howes, T. and S. Kille, \"Lightweight Directory Access Protocol (v3)\", RFC 2251, December 1997.",
      "ja": "[LDAPV3] Wahl、M.、Howes、T。およびS. Kille、「Lightweight Directory Access Protocol（V3）」、RFC 2251、1997年12月。"
    },
    {
      "indent": 3,
      "text": "[RMI] Java Software, Sun Microsystems, Inc., \"Remote Method Invocation,\" November 1998. http://java.sun.com/products/jdk/1.2/docs/guide/rmi",
      "ja": "[RMI] Java Software、Sun Microsystems、Inc。、「Remote Method Invocation」、1998年11月。http：//java.sun.com/products/jdk/1.2/docs/guide/rmi"
    },
    {
      "indent": 3,
      "text": "[RMI-IIOP] IBM and Java Software, Sun Microsystems, Inc., \"RMI over IIOP\", June 1999. http://java.sun.com/products/rmi-iiop/",
      "ja": "[RMI-IIOP] IBM and Java Software、Sun Microsystems、Inc。、「RMI Over IIOP」、1999年6月。http：//java.sun.com/products/rmi-iiop/"
    },
    {
      "indent": 3,
      "text": "[Serial] Java Software, Sun Microsystems, Inc., \"Object Serialization Specification,\" November 1998. http://java.sun.com/products/jdk/1.2/docs/guide/ serialization",
      "ja": "[シリアル] Java Software、Sun Microsystems、Inc。、「Object Serialization Specification」、1998年11月。http：//java.sun.com/products/jdk/1.2/docs/guide/ serialization"
    },
    {
      "indent": 3,
      "text": "[v3Schema] Wahl, M., \"A Summary of the X.500(96) User Schema for use with LDAPv3\", RFC 2256, December 1997.",
      "ja": "[V3Schema] Wahl、M。、「LDAPV3で使用するX.500（96）ユーザースキーマの要約」、RFC 2256、1997年12月。"
    },
    {
      "indent": 0,
      "text": "8. Authors' Addresses",
      "section_title": true,
      "ja": "8. 著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Vincent Ryan Sun Microsystems, Inc. Mail Stop EDUB03 901 San Antonio Road Palo Alto, CA 94303 USA",
      "ja": "Vincent Ryan Sun Systems、Inc。Mail Stop Edub03 901 San Antonio Road Palo Alto、CA 94303 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +353 1 819 9151\nEMail: vincent.ryan@ireland.sun.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Scott Seligman Sun Microsystems, Inc. Mail Stop UCUP02-209 901 San Antonio Road Palo Alto, CA 94303 USA",
      "ja": "Scott Seligman Sun Systems、Inc。Mail Stop UCUP02-209 901 San Antonio Road Palo Alto、CA 94303 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 408 863 3222\nEMail: scott.seligman@eng.sun.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Rosanna Lee Sun Microsystems, Inc. Mail Stop UCUP02-206 901 San Antonio Road Palo Alto, CA 94303 USA",
      "ja": "Rosanna Lee Sun Systems、Inc。Mail Stop UCUP02-206 901 San Antonio Road Palo Alto、CA 94303 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 408 863 3221\nEMail: rosanna.lee@eng.sun.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix - LDAP Schema",
      "ja": "付録-LDAPスキーマ"
    },
    {
      "indent": 2,
      "text": "-- Attribute types --",
      "ja": " - 属性タイプ - "
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.6 NAME 'javaClassName' DESC 'Fully qualified name of distinguished Java class or interface' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 SINGLE-VALUE )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.1.6名 'Javaclassname' desc '著名なJavaクラスまたはインターフェイスの完全資格の名前' equality caseexactmatch Syntax 1.3.6.1.4.1.1466.115.121.1.15単一値）"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.7 NAME 'javaCodebase' DESC 'URL(s) specifying the location of class definition' EQUALITY caseExactIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.1.7名「JavacodeBase」DESC 'URLクラス定義の位置を指定する' equality caseexactia5match Syntax 1.3.6.1.4.1.1466.115.121.1.1.1.26）"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.8 NAME 'javaSerializedData' DESC 'Serialized form of a Java object' SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 SINGLE-VALUE )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.1.8名 'JavaserializedData' desc 'javaオブジェクトのシリアル化された形式'構文1.3.6.1.4.1.1.1466.1155.121.1.40単一値）"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.10 NAME 'javaFactory' DESC 'Fully qualified Java class name of a JNDI object factory' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 SINGLE-VALUE )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.1.10名 'JavaFactory' desc '' jndiオブジェクト工場の完全資格のJavaクラス名 'equality caseexactmatch Syntax 1.3.6.1.4.1.1466.115.121.1.15単位）"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.11 NAME 'javaReferenceAddress' DESC 'Addresses associated with a JNDI Reference' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.1.11名「JNDI参照」に関連付けられた「JavareferEnceaddress 'DESC」アドレス「equality caseexactmatch構文1.3.6.1.4.1.14666.115.121.1.15）"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.12 NAME 'javaDoc' DESC 'The Java documentation for the class' EQUALITY caseExactIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 ) ( 1.3.6.1.4.1.42.2.27.4.1.13 NAME 'javaClassNames' DESC 'Fully qualified Java class or interface name' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.1.12 Name 'Javadoc' desc 'クラスのJavaドキュメント' equality caseexactia5match Syntax 1.3.6.1.4.1.1466.115.121.1.26）（1.3.6.1.4.1.42.2.27.4.4..1.13名「JavaclassNames 'desc'完全資格のJavaクラスまたはインターフェイス名 'equality caseexactmatch構文1.3.6.1.4.1.1466.115.121.1.15）"
    },
    {
      "indent": 2,
      "text": "-- from RFC-2256 --",
      "ja": "-RFC-2256から - "
    },
    {
      "indent": 2,
      "text": "( 2.5.4.13 NAME 'description' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15{1024} )",
      "ja": "（2.5.4.13名前 '説明' equality caseignorematch substr caseignoresubstringsmatch構文1.3.6.1.4.1.146.115.121.15 {1024}）"
    },
    {
      "indent": 2,
      "text": "-- Object classes --",
      "ja": " - オブジェクトクラス - "
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.1 NAME 'javaContainer' DESC 'Container for a Java object' SUP top STRUCTURAL MUST ( cn ) )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.2.1名「Javacontainer」javaオブジェクト用のコンテナ 'SUPトップ構造マスト（CN））"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.4 NAME 'javaObject' DESC 'Java object representation' SUP top ABSTRACT MUST ( javaClassName ) MAY ( javaClassNames $ javaCodebase $ javaDoc $ description ) )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.2.4名 'Javaobject' desc 'Javaオブジェクト表現' Sup Top Abstract（javaclassname）5月（javaclassnames $ javacodebase $ javadoc $ description））"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.5 NAME 'javaSerializedObject' DESC 'Java serialized object' SUP javaObject AUXILIARY MUST ( javaSerializedData ) ) ( 1.3.6.1.4.1.42.2.27.4.2.7 NAME 'javaNamingReference' DESC 'JNDI reference' SUP javaObject AUXILIARY MAY ( javaReferenceAddress $ javaFactory ) )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.2.5名 'JavaserializedObject' desc 'Javaシリアル化オブジェクト' Sup Javaobject Auxiliary Must（JavaserializedData））（1.3.6.1.4.4.1.42.2.2.2.27.4.2.2.7名 'JavanamimingReference' desc 'dec' dec 'dec' dec 'dec' jndi'sup javaobject Auxiliary May（Javareferenceaddress $ javafactory））"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.8 NAME 'javaMarshalledObject' DESC 'Java marshalled object' SUP javaObject AUXILIARY MUST ( javaSerializedData ) )",
      "ja": "（1.3.6.1.4.1.42.2.2.27.4.2.8名 'Javamarshalledobject' desc 'Java Marshalled Object' sup JavaObject Auxiliary Must（JavaSerializedData）））"
    },
    {
      "indent": 2,
      "text": "-- Matching rule from ISO X.520 --",
      "ja": "-ISO X.520からの一致ルール - "
    },
    {
      "indent": 2,
      "text": "( 2.5.13.5 NAME 'caseExactMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",
      "ja": "（2.5.13.5 name 'caseexactmatch'構文1.3.6.1.4.1.146.115.121.15）"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（1999）。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書と本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}