{
  "title": {
    "text": "RFC 2631 - Diffie-Hellman Key Agreement Method",
    "ja": "RFC 2631 - Diffie-Hellmanキー鍵交換"
  },
  "number": 2631,
  "created_at": "2023-01-01 20:37:13.918138+09:00",
  "updated_by": "自動生成＆有志による翻訳・編集",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                       E. Rescorla\nRequest for Comments: 2631                                    RTFM Inc.\nCategory: Standards Track                                     June 1999",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Diffie-Hellman Key Agreement Method",
      "ja": "Diffie-Hellmanキー鍵交換"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（1999）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document standardizes one particular Diffie-Hellman variant, based on the ANSI X9.42 draft, developed by the ANSI X9F1 working group. Diffie-Hellman is a key agreement algorithm used by two parties to agree on a shared secret. An algorithm for converting the shared secret into an arbitrary amount of keying material is provided. The resulting keying material is used as a symmetric encryption key. The Diffie-Hellman variant described requires the recipient to have a certificate, but the originator may have a static key pair (with the public key placed in a certificate) or an ephemeral key pair.",
      "ja": "このドキュメントは、ANSI X9F1ワーキンググループによって開発されたANSI X9.42ドラフトに基づいて、特定のDiffie-Hellmanバリアントを標準化しています。Diffie-Hellmanは、共有された秘密に同意するために2つの当事者が使用する重要な契約アルゴリズムです。共有秘密を任意の量のキーイング材料に変換するためのアルゴリズムが提供されます。結果のキーイング材料は、対称暗号化キーとして使用されます。説明されているdiffie-hellmanバリアントでは、受信者に証明書を持つ必要がありますが、オリジネーターには静的キーペア（公開キーが証明書に配置されています）または一時的なキーペアがある場合があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction  . . . . . . . . . . . . . . . . . . . . . . .   2\n1.1. Requirements Terminology  . . . . . . . . . . . . . . . .   2\n2. Overview Of Method  . . . . . . . . . . . . . . . . . . . .   2\n2.1. Key Agreement . . . . . . . . . . . . . . . . . . . . . .   2\n2.1.1. Generation of ZZ  . . . . . . . . . . . . . . . . . . .   3\n2.1.2. Generation of Keying Material . . . . . . . . . . . . .   3\n2.1.3. KEK Computation . . . . . . . . . . . . . . . . . . . .   4\n2.1.4. Keylengths for common algorithms  . . . . . . . . . . .   5\n2.1.5. Public Key Validation . . . . . . . . . . . . . . . . .   5\n2.1.6. Example 1 . . . . . . . . . . . . . . . . . . . . . . .   5\n2.1.7. Example 2 . . . . . . . . . . . . . . . . . . . . . . .   6\n2.2. Key and Parameter Requirements  . . . . . . . . . . . . .   7\n2.2.1. Group Parameter Generation  . . . . . . . . . . . . . .   7\n2.2.1.1. Generation of p, q  . . . . . . . . . . . . . . . . .   8\n2.2.1.2. Generation of g . . . . . . . . . . . . . . . . . . .   9\n2.2.2. Group Parameter Validation  . . . . . . . . . . . . . .   9\n2.3. Ephemeral-Static Mode . . . . . . . . . . . . . . . . . .  10\n2.4. Static-Static Mode  . . . . . . . . . . . . . . . . . . .  10\n2.4. Acknowledgements  . . . . . . . . . . . . . . . . . . . .  10\n2.4. References  . . . . . . . . . . . . . . . . . . . . . . .  11\nSecurity Considerations  . . . . . . . . . . . . . . . . . . .  12\nAuthor's Address . . . . . . . . . . . . . . . . . . . . . . .  12\nFull Copyright Statement . . . . . . . . . . . . . . . . . . .  13",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "In [DH76] Diffie and Hellman describe a means for two parties to agree upon a shared secret in such a way that the secret will be unavailable to eavesdroppers. This secret may then be converted into cryptographic keying material for other (symmetric) algorithms. A large number of minor variants of this process exist. This document describes one such variant, based on the ANSI X9.42 specification.",
      "ja": "[DH76]では、DiffieとHellmanは、秘密が盗聴者に利用できないように、共有された秘密に同意する2つの当事者が同意する手段を説明しています。この秘密は、その後、他の（対称）アルゴリズムの暗号化キーリング材料に変換される可能性があります。このプロセスの多数の小さなバリエーションが存在します。このドキュメントでは、ANSI X9.42仕様に基づいて、そのようなバリアントの1つについて説明します。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Terminology",
      "section_title": true,
      "ja": "1.1. 要件用語"
    },
    {
      "indent": 3,
      "text": "Keywords \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHOULD\", \"SHOULD NOT\" and \"MAY\" that appear in this document are to be interpreted as described in [RFC2119].",
      "ja": "このドキュメントで使われるキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHOULD\", \"SHOULD NOT\", \"MAY\" は[RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Overview Of Method",
      "section_title": true,
      "ja": "2. メソッドの概要"
    },
    {
      "indent": 3,
      "text": "Diffie-Hellman key agreement requires that both the sender and recipient of a message have key pairs. By combining one's private key and the other party's public key, both parties can compute the same shared secret number. This number can then be converted into cryptographic keying material. That keying material is typically used as a key-encryption key (KEK) to encrypt (wrap) a content-encryption key (CEK) which is in turn used to encrypt the message data.",
      "ja": "Diffie-Hellmanキー契約では、メッセージの送信者と受信者の両方が重要なペアを持つことが必要です。自分の秘密鍵と他者の公開鍵を組み合わせることにより、両当事者は同じ共有秘密番号を計算できます。この数値は、暗号化キーイング材料に変換できます。キーイン素材は通常、キー暗号化キー（KEK）として使用され、コンテンツ暗号化キー（CEK）を暗号化（wrap）します。これは、メッセージデータの暗号化に使用されます。"
    },
    {
      "indent": 0,
      "text": "2.1. Key Agreement",
      "section_title": true,
      "ja": "2.1. 重要な契約"
    },
    {
      "indent": 3,
      "text": "The first stage of the key agreement process is to compute a shared secret number, called ZZ. When the same originator and recipient public/private key pairs are used, the same ZZ value will result. The ZZ value is then converted into a shared symmetric cryptographic key. When the originator employs a static private/public key pair, the introduction of a public random value ensures that the resulting symmetric key will be different for each key agreement.",
      "ja": "主要な契約プロセスの最初の段階は、ZZと呼ばれる共有秘密番号を計算することです。同じオリジネーターと受信者のパブリック/プライベートキーペアを使用すると、同じZZ値が生じます。ZZ値は、共有対称暗号化キーに変換されます。オリジネーターが静的なプライベート/公開キーペアを採用すると、パブリックランダム値の導入により、結果の対称キーが各キー契約で異なることが保証されます。"
    },
    {
      "indent": 0,
      "text": "2.1.1. Generation of ZZ",
      "section_title": true,
      "ja": "2.1.1. ZZの生成"
    },
    {
      "indent": 3,
      "text": "X9.42 defines that the shared secret ZZ is generated as follows:",
      "ja": "X9.42は、共有秘密ZZが次のように生成されることを定義しています。"
    },
    {
      "indent": 5,
      "text": "ZZ = g ^ (xb * xa) mod p",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that the individual parties actually perform the computations:",
      "ja": "個々の当事者が実際に計算を実行することに注意してください。"
    },
    {
      "indent": 5,
      "text": "ZZ = (yb ^ xa)  mod p  = (ya ^ xb)  mod p",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where ^ denotes exponentiation",
      "ja": "ここで、 ^は指数を示します"
    },
    {
      "indent": 9,
      "text": "ya is party a's public key; ya = g ^ xa mod p\nyb is party b's public key; yb = g ^ xb mod p\nxa is party a's private key\nxb is party b's private key\np is a large prime\nq is a large prime\ng = h^{(p-1)/q} mod p, where\nh is any integer with 1 < h < p-1 such that h{(p-1)/q} mod p > 1\n  (g has order q mod p; i.e. g^q mod p = 1 if g!=1)\nj a large integer such that p=qj + 1\n(See Section 2.2 for criteria for keys and parameters)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In [CMS], the recipient's key is identified by the CMS RecipientIdentifier, which points to the recipient's certificate. The sender's public key is identified using the OriginatorIdentifierOrKey field, either by reference to the sender's certificate or by inline inclusion of a public key.",
      "ja": "[CMS]では、受信者のキーは、受信者の証明書を指すCMS Recipientientifientifierによって識別されます。送信者の公開キーは、送信者の証明書を参照するか、公開鍵をインラインで含めることにより、Originatorideidierorkeyフィールドを使用して識別されます。"
    },
    {
      "indent": 0,
      "text": "2.1.2. Generation of Keying Material",
      "section_title": true,
      "ja": "2.1.2. キーイング素材の生成"
    },
    {
      "indent": 3,
      "text": "X9.42 provides an algorithm for generating an essentially arbitrary amount of keying material from ZZ. Our algorithm is derived from that algorithm by mandating some optional fields and omitting others.",
      "ja": "X9.42は、ZZから本質的に任意の量のキーイング材料を生成するためのアルゴリズムを提供します。私たちのアルゴリズムは、いくつかのオプションのフィールドを義務付け、他のフィールドを省略することにより、そのアルゴリズムから派生しています。"
    },
    {
      "indent": 5,
      "text": "KM = H ( ZZ || OtherInfo)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "H is the message digest function SHA-1 [FIPS-180] ZZ is the shared secret value computed in Section 2.1.1. Leading zeros MUST be preserved, so that ZZ occupies as many octets as p. For instance, if p is 1024 bits, ZZ should be 128 bytes long. OtherInfo is the DER encoding of the following structure:",
      "ja": "Hはメッセージダイジェスト関数SHA-1 [FIPS-180] ZZは、セクション2.1.1で計算された共有秘密の値です。主要なゼロは保存する必要があります。そうすれば、ZZがpと同じくらい多くのオクテットを占めるようにします。たとえば、Pが1024ビットの場合、ZZは128バイトの長さでなければなりません。otherinfoは、次の構造のderエンコードです。"
    },
    {
      "indent": 5,
      "text": "OtherInfo ::= SEQUENCE {\n  keyInfo KeySpecificInfo,\n  partyAInfo [0] OCTET STRING OPTIONAL,\n  suppPubInfo [2] OCTET STRING\n}\n\nKeySpecificInfo ::= SEQUENCE {\n  algorithm OBJECT IDENTIFIER,\n  counter OCTET STRING SIZE (4..4) }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that these ASN.1 definitions use EXPLICIT tagging. (In ASN.1, EXPLICIT tagging is implicit unless IMPLICIT is explicitly specified.)",
      "ja": "これらのasn.1定義は明示的なタグ付けを使用していることに注意してください。（ASN.1では、明示的なタグ付けは明示的に指定されていない限り、暗黙的です。）"
    },
    {
      "indent": 3,
      "text": "algorithm is the ASN.1 algorithm OID of the CEK wrapping algorithm with which this KEK will be used. Note that this is NOT an AlgorithmIdentifier, but simply the OBJECT IDENTIFIER. No parameters are used.",
      "ja": "アルゴリズムは、このKEKが使用されるCEKラッピングアルゴリズムのASN.1アルゴリズムOIDです。これはAlgorithmidentifierではなく、単にオブジェクト識別子であることに注意してください。パラメーターは使用されません。"
    },
    {
      "indent": 3,
      "text": "counter is a 32 bit number, represented in network byte order. Its initial value is 1 for any ZZ, i.e. the byte sequence 00 00 00 01 (hex), and it is incremented by one every time the above key generation function is run for a given KEK.",
      "ja": "カウンターは32ビット数で、ネットワークバイトの順序で表されます。その初期値は、ZZの場合、つまりバイトシーケンス 00 00 00 01（16進数）で、上記のキー生成関数が特定のKEKに対して実行されるたびに1つずつ増加します。"
    },
    {
      "indent": 3,
      "text": "partyAInfo is a random string provided by the sender. In CMS, it is provided as a parameter in the UserKeyingMaterial field (encoded as an OCTET STRING). If provided, partyAInfo MUST contain 512 bits.",
      "ja": "partyainfoは、送信者によって提供されるランダムな文字列です。CMSでは、userkeyingmaterialフィールド（オクテット文字列としてエンコード）のパラメーターとして提供されます。提供されている場合、partyainfoには512ビットが含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "suppPubInfo is the length of the generated KEK, in bits, represented as a 32 bit number in network byte order. E.g. for 3DES it would be the byte sequence 00 00 00 C0.",
      "ja": "duppubinfoは、生成されたkekの長さ、ビットで、ネットワークバイトの順序で32ビット数として表されます。例えば。3DESの場合、それはバイトシーケンス 00 00 00 C0 です。"
    },
    {
      "indent": 3,
      "text": "To generate a KEK, one generates one or more KM blocks (incrementing counter appropriately) until enough material has been generated. The KM blocks are concatenated left to right I.e. KM(counter=1) || KM(counter=2)...",
      "ja": "KEKを生成するには、十分な材料が生成されるまで1つ以上のkmブロック（適切に拡大する）を生成します。KMブロックは左から右に連結されています。km(counter=1) || km(counter=2)..."
    },
    {
      "indent": 3,
      "text": "Note that the only source of secret entropy in this computation is ZZ. Even if a string longer than ZZ is generated, the effective key space of the KEK is limited by the size of ZZ, in addition to any security level considerations imposed by the parameters p and q. However, if partyAInfo is different for each message, a different KEK will be generated for each message. Note that partyAInfo MUST be used in Static-Static mode, but MAY appear in Ephemeral-Static mode.",
      "ja": "この計算における秘密エントロピーの唯一の原因はZZであることに注意してください。ZZより長い文字列が生成されたとしても、KEKの有効なキー空間は、パラメーターPとQによって課されるセキュリティレベルの考慮事項に加えて、ZZのサイズによって制限されます。ただし、各メッセージごとにpartyainfoが異なる場合、各メッセージに対して異なるKEKが生成されます。PartyAinfoは静的静的モードで使用する必要がありますが、はかない静的モードで表示される場合があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "2.1.3. KEK Computation",
      "section_title": true,
      "ja": "2.1.3. KEK計算"
    },
    {
      "indent": 3,
      "text": "Each key encryption algorithm requires a specific size key (n). The KEK is generated by mapping the left n-most bytes of KM onto the key. For 3DES, which requires 192 bits of keying material, the algorithm must be run twice, once with a counter value of 1 (to generate K1', K2', and the first 32 bits of K3') and once with a counter value of 2 (to generate the last 32 bits of K3). K1',K2' and K3' are then parity adjusted to generate the 3 DES keys K1,K2 and K3. For RC2-128, which requires 128 bits of keying material, the algorithm is run once, with a counter value of 1, and the left-most 128 bits are directly converted to an RC2 key. Similarly, for RC2-40, which requires 40 bits of keying material, the algorithm is run once, with a counter value of 1, and the leftmost 40 bits are used as the key.",
      "ja": "各キー暗号化アルゴリズムには、特定のサイズキー（n）が必要です。kekは、左n最大バイトのkmをキーにマッピングすることにより生成されます。192ビットのキーイング材料を必要とする3DESの場合、アルゴリズムは2回実行する必要があります。1回（K1 '、k2'、および最初の32ビットのK3 'を生成するために）、1回のカウンター値で1回実行する必要があります。2（K3の最後の32ビットを生成するため）。K1 '、K2'、K3 'は、パリティが調整され、3 DESキーK1、K2、K3が生成されます。128ビットのキーイング材料を必要とするRC2-128の場合、アルゴリズムは1回実行され、カウンター値は1で、左128ビットはRC2キーに直接変換されます。同様に、40ビットのキーイン素材を必要とするRC2-40の場合、アルゴリズムが1回実行され、カウンター値は1で、左端40ビットがキーとして使用されます。"
    },
    {
      "indent": 0,
      "text": "2.1.4. Keylengths for common algorithms",
      "section_title": true,
      "ja": "2.1.4. 一般的なアルゴリズムのキーレングス"
    },
    {
      "indent": 3,
      "text": "Some common key encryption algorithms have KEKs of the following lengths.",
      "ja": "いくつかの一般的なキー暗号化アルゴリズムには、次の長さのKEKsがあります。"
    },
    {
      "indent": 5,
      "text": "3-key 3DES      192 bits\nRC2-128        128 bits\nRC2-40         40 bits",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RC2 effective key lengths are equal to RC2 real key lengths.",
      "ja": "RC2有効キー長は、RC2の実際のキー長に等しくなります。"
    },
    {
      "indent": 0,
      "text": "2.1.5. Public Key Validation",
      "section_title": true,
      "ja": "2.1.5. 公開鍵の検証"
    },
    {
      "indent": 3,
      "text": "The following algorithm MAY be used to validate a received public key y.",
      "ja": "次のアルゴリズムを使用して、受信した公開キーYを検証することができます。"
    },
    {
      "indent": 5,
      "text": "1. Verify that y lies within the interval [2,p-1]. If it does not, the key is invalid.",
      "ja": "1. yが間隔内にあることを確認します [2,p-1]。そうでない場合、キーは無効です。"
    },
    {
      "indent": 5,
      "text": "2. Compute y^q mod p. If the result == 1, the key is valid. Otherwise the key is invalid.",
      "ja": "2. y^q mod pを計算します。結果が1の場合、キーは有効です。それ以外の場合、キーは無効です。"
    },
    {
      "indent": 3,
      "text": "The primary purpose of public key validation is to prevent a small subgroup attack [LAW98] on the sender's key pair. If Ephemeral-Static mode is used, this check may not be necessary. See also [P1363] for more information on Public Key validation.",
      "ja": "公開キー検証の主な目的は、送信者のキーペアで小さなサブグループ攻撃[Law98]を防ぐことです。短命帯状モードを使用している場合、このチェックは必要ない場合があります。公開キーの検証の詳細については、[P1363]も参照してください。"
    },
    {
      "indent": 3,
      "text": "Note that this procedure may be subject to pending patents.",
      "ja": "この手順は、保留中の特許の対象となる可能性があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "2.1.6. Example 1",
      "section_title": true,
      "ja": "2.1.6. 例1"
    },
    {
      "indent": 3,
      "text": "ZZ is the 20 bytes 00 01 02 03 04 05 06 07 08 09\n                   0a 0b 0c 0d 0e 0f 10 11 12 13",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The key wrap algorithm is 3DES-EDE wrap.",
      "ja": "キーラップアルゴリズムは3DES-EDEラップです。"
    },
    {
      "indent": 3,
      "text": "No partyAInfo is used.",
      "ja": "partyainfoは使用されません。"
    },
    {
      "indent": 3,
      "text": "Consequently, the input to the first invocation of SHA-1 is:",
      "ja": "その結果、SHA-1の最初の呼び出しへの入力は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 ; ZZ\n30 1d\n   30 13\n      06 0b 2a 86 48 86 f7 0d 01 09 10 03 06          ; 3DES wrap OID\n      04 04\n         00 00 00 01                                        ; Counter\n   a2 06\n      04 04\n      00 00 00 c0                                        ; key length",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "And the output is the 20 bytes:",
      "ja": "出力は20バイトです。"
    },
    {
      "indent": 3,
      "text": "a0 96 61 39 23 76 f7 04 4d 90 52 a3 97 88 32 46 b6 7f 5f 1e",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The input to the second invocation of SHA-1 is:",
      "ja": "SHA-1の2回目の呼び出しへの入力は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 ; ZZ\n30 1d\n   30 13\n      06 0b 2a 86 48 86 f7 0d 01 09 10 03 06          ; 3DES wrap OID\n      04 04\n         00 00 00 02                                        ; Counter\n   a2 06\n      04 04\n      00 00 00 c0                                        ; key length",
      "raw": true,
      "ja": ""
    },
    
    {
      "indent": 3,
      "text": "And the output is the 20 bytes:",
      "ja": "出力は20バイトです。"
    },
    {
      "indent": 3,
      "text": "f6 3e b5 fb 5f 56 d9 b6 a8 34 03 91 c2 d3 45 34 93 2e 11 30",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Consequently,\nK1'=a0 96 61 39 23 76 f7 04\nK2'=4d 90 52 a3 97 88 32 46\nK3'=b6 7f 5f 1e f6 3e b5 fb",
      "raw": true,
      "ja": ""
    },    
    {
      "indent": 3,
      "text": "Note: These keys are not parity adjusted",
      "ja": "注：これらのキーはパリティ調整されていません"
    },
    {
      "indent": 0,
      "text": "2.1.7. Example 2",
      "section_title": true,
      "ja": "2.1.7. 例2"
    },
    {
      "indent": 3,
      "text": "ZZ is the 20 bytes 00 01 02 03 04 05 06 07 08 09\n                   0a 0b 0c 0d 0e 0f 10 11 12 13",
      "raw": true,
      "ja": ""
    },    
    {
      "indent": 3,
      "text": "The key wrap algorithm is RC2-128 key wrap, so we need 128 bits (16 bytes) of keying material.",
      "ja": "キーラップアルゴリズムはRC2-128キーラップであるため、キーイング材料の128ビット（16バイト）が必要です。"
    },
    {
      "indent": 3,
      "text": "The partyAInfo used is the 64 bytes",
      "ja": "使用されるpartyainfoは64バイトです"
    },
    {
      "indent": 3,
      "text": "01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01\n01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01\n01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01\n01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Consequently, the input to SHA-1 is:",
      "ja": "したがって、SHA-1への入力は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 ; ZZ\n30 61\n   30 13\n      06 0b 2a 86 48 86 f7 0d 01 09 10 03 07           ; RC2 wrap OID\n      04 04\n         00 00 00 01                                        ; Counter\n   a0 42\n      04 40\n         01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01 ; partyAInfo\n         01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01\n         01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01\n         01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 01\n   a2 06\n      04 04\n         00 00 00 80                                     ; key length",
      "raw": true,
      "ja": ""
    },    
    {
      "indent": 3,
      "text": "And the output is the 20 bytes:",
      "ja": "出力は20バイトです。"
    },
    {
      "indent": 3,
      "text": "48 95 0c 46 e0 53 00 75 40 3c ce 72 88 96 04 e0 3e 7b 5d e9",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Consequently,\nK=48 95 0c 46 e0 53 00 75 40 3c ce 72 88 96 04 e0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.2. Key and Parameter Requirements",
      "section_title": true,
      "ja": "2.2. キーおよびパラメーターの要件"
    },
    {
      "indent": 3,
      "text": "X9.42 requires that the group parameters be of the form p=jq + 1 where q is a large prime of length m and j>=2. An algorithm for generating primes of this form (derived from the algorithms in FIPS PUB 186-1[FIPS-186] and [X942]can be found in appendix A.",
      "ja": "x9.42では、グループパラメーターがp = jq 1の形式であることが必要です。ここで、qは長さmとj> = 2の大きな素数です。このフォームのプライムを生成するためのアルゴリズム（FIPS Pub 186-1 [FIPS-186]および[X942]のアルゴリズムから派生したものは、付録Aにあります。"
    },
    {
      "indent": 3,
      "text": "X9.42 requires that the private key x be in the interval [2, (q - 2)]. x should be randomly generated in this interval. y is then computed by calculating g^x mod p. To comply with this memo, m MUST be >=160 bits in length, (consequently, q MUST be at least 160 bits long). When symmetric ciphers stronger than DES are to be used, a larger m may be advisable. p must be a minimum of 512 bits long.",
      "ja": "x9.42では、秘密キーxが間隔[2、（q -2）]にあることが必要です。xは、この間隔でランダムに生成する必要があります。yは、g^x mod pを計算して計算されます。このメモに準拠するには、mは長さが> = 160ビットでなければなりません（その結果、Qは少なくとも160ビット長くする必要があります）。DESよりも強い対称暗号を使用する場合、より大きなMをお勧めします。Pは最低512ビットの長さでなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.2.1. Group Parameter Generation",
      "section_title": true,
      "ja": "2.2.1. グループパラメーター生成"
    },
    {
      "indent": 3,
      "text": "Agents SHOULD generate domain parameters (g,p,q) using the following algorithm, derived from [FIPS-186] and [X942]. When this algorithm is used, the correctness of the generation procedure can be verified by a third party by the algorithm of 2.2.2.",
      "ja": "エージェントは、[FIPS-186]および[x942]から派生した次のアルゴリズムを使用して、ドメインパラメーター（g、p、q）を生成する必要があります。このアルゴリズムを使用すると、生成手順の正確性は、2.2.2のアルゴリズムによって第三者によって検証できます。"
    },
    {
      "indent": 0,
      "text": "2.2.1.1. Generation of p, q",
      "section_title": true,
      "ja": "2.2.1.1. pとqの生成"
    },
    {
      "indent": 3,
      "text": "This algorithm generates a p, q pair where q is of length m and p is of length L.",
      "ja": "このアルゴリズムは、p、qペアを生成します。ただし、qは長さmで、pは長さLです。"
    },
    {
      "indent": 3,
      "text": "1. Set m' = m/160 where / represents integer division with rounding upwards. I.e. 200/160 = 2.",
      "ja": "1. m' = m/160 を設定します。ここで / は整数除算を表し、上向きに丸めます。すなわち 200/160 = 2 です。"
    },
    {
      "indent": 3,
      "text": "2. Set L'= L/160",
      "ja": "2. L' = L/160 を設定します"
    },
    {
      "indent": 3,
      "text": "3. Set N'= L/1024",
      "ja": "3. N' = L/1024 を設定します"
    },
    {
      "indent": 3,
      "text": "4. Select an arbitrary bit string SEED such that the length of SEED >= m",
      "ja": "4. シードの長さ >= m になるように、任意のビットストリングシードを選択します"
    },
    {
      "indent": 3,
      "text": "5. Set U = 0",
      "ja": "5. U = 0 を設定します"
    },
    {
      "indent": 3,
      "text": "6. For i = 0 to m' - 1",
      "ja": "6. i = 0 から m'-1 で以下を繰り返します："
    },
    {
      "indent": 8,
      "text": "U = U + (SHA1[SEED + i] XOR SHA1[(SEED + m' + i)) * 2^(160 * i)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that for m=160, this reduces to the algorithm of [FIPS-186]",
      "ja": "m = 160 の場合、これは[FIPS-186]のアルゴリズムに減少することに注意してください。"
    },
    {
      "indent": 8,
      "text": "U = SHA1[SEED] XOR SHA1[(SEED+1) mod 2^160 ].",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "5. Form q from U by computing U mod (2^m) and setting the most significant bit (the 2^(m-1) bit) and the least significant bit to 1. In terms of boolean operations, q = U OR 2^(m-1) OR 1. Note that 2^(m-1) < q < 2^m",
      "ja": "5. u mod（2^m）を計算し、最も重要なビット（2^(m-1) ビット）を設定し、1に対して最も重要なビットを設定することにより、U から q を形成します。ブール操作に関しては、q = U または 2^(m-1) または 1。ただし、2^(m-1) < q < 2^m であることに注意してください"
    },
    {
      "indent": 3,
      "text": "6. Use a robust primality algorithm to test whether q is prime.",
      "ja": "6. 堅牢なプライマリティアルゴリズムを使用して、qが素数かどうかをテストします。"
    },
    {
      "indent": 3,
      "text": "7. If q is not prime then go to 4.",
      "ja": "7. qが素数でない場合は、4に移動します。"
    },
    {
      "indent": 3,
      "text": "8. Let counter = 0",
      "ja": "8. counter = 0 とします。"
    },
    {
      "indent": 3,
      "text": "9. Set R = seed + 2*m' + (L' * counter)",
      "ja": "9. Set R = seed + 2*m' + (L' * counter)"
    },
    {
      "indent": 3,
      "text": "10. Set V = 0",
      "ja": "10. V = 0 を設定します"
    },
    {
      "indent": 3,
      "text": "12. For i = 0 to L'-1 do",
      "ja": "12. i = 0 から L'-1 まで以下を繰り返します："
    },
    {
      "indent": 7,
      "text": "V = V + SHA1(R + i) * 2^(160 * i)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "13. Set W = V mod 2^L",
      "ja": "13. W = V mod 2^L を設定します"
    },
    {
      "indent": 3,
      "text": "14. Set X = W OR 2^(L-1) Note that 0 <= W < 2^(L-1) and hence X >= 2^(L-1)",
      "ja": "14. X = W OR 2^(L-1) を計算します。ただし、0 <= W < 2^(L-1) なので X >= 2^(L-1) です。"
    },
    {
      "indent": 3,
      "text": "15. Set p = X - (X mod (2*q)) + 1",
      "ja": "15. p = X - (X mod (2*q)) + 1 を設定します。"
    },
    {
      "indent": 3,
      "text": "6. If p > 2^(L-1) use a robust primality test to test whether p is prime. Else go to 18.",
      "ja": "6. p > 2^(l-1) の場合、堅牢な素数テストを使用して、pが素数かどうかをテストします。素数ではない場合は18に行きます。"
    },
    {
      "indent": 3,
      "text": "17. If p is prime output p, q, seed, counter and stop.",
      "ja": "17. pが素数の場合、p、q、シード、カウンターを出力して停止します。"
    },
    {
      "indent": 3,
      "text": "18. Set counter = counter + 1",
      "ja": "18. counter = counter + 1 を設定します。"
    },
    {
      "indent": 3,
      "text": "19. If counter < (4096 * N) then go to 8.",
      "ja": "19. counter < (4096 * N) の場合、8に移動します。"
    },
    {
      "indent": 3,
      "text": "20. Output \"failure\"",
      "ja": "20. 「失敗」を出力します。"
    },
    {
      "indent": 3,
      "text": "Note: A robust primality test is one where the probability of a non-prime number passing the test is at most 2^-80. [FIPS-186] provides a suitable algorithm, as does [X942].",
      "ja": "注：堅牢な素数テストとは、テストに合格しないプライム数が最大 2^-80 である可能性があるものです。[FIPS-186]は、[x942]と同様に、適切なアルゴリズムを提供します。"
    },
    {
      "indent": 0,
      "text": "2.2.1.2. Generation of g",
      "section_title": true,
      "ja": "2.2.1.2. gの生成"
    },
    {
      "indent": 3,
      "text": "This section gives an algorithm (derived from [FIPS-186]) for generating g.",
      "ja": "このセクションでは、gを生成するためのアルゴリズム（[FIPS-186]から派生）を示します。"
    },
    {
      "indent": 3,
      "text": "1. Let j = (p - 1)/q.",
      "ja": "1. j = (p - 1)/q とします。"
    },
    {
      "indent": 3,
      "text": "2. Set h = any integer, where 1 < h < p - 1 and h differs from any value previously tried.",
      "ja": "2. hを任意の整数を設定します。ここで、1 < h < p - 1 と h は以前に試された任意の値と異なります。"
    },
    {
      "indent": 3,
      "text": "3. Set g = h^j mod p",
      "ja": "3. g = h^j mod p を設定します"
    },
    {
      "indent": 3,
      "text": "4. If g = 1 go to step 2",
      "ja": "4. g = 1 の場合は、ステップ2に進みます"
    },
    {
      "indent": 0,
      "text": "2.2.2. Group Parameter Validation",
      "section_title": true,
      "ja": "2.2.2. グループパラメーター検証"
    },
    {
      "indent": 3,
      "text": "The ASN.1 for DH keys in [PKIX] includes elements j and validation-Parms which MAY be used by recipients of a key to verify that the group parameters were correctly generated. Two checks are possible:",
      "ja": "[PKIX]のDHキーのASN.1には、グループパラメーターが正しく生成されたことを確認するためにキーの受信者が使用できる要素Jと検証パーマムが含まれています。2つのチェックが可能です。"
    },
    {
      "indent": 5,
      "text": "1. Verify that p=qj + 1. This demonstrates that the parameters meet the X9.42 parameter criteria. 2. Verify that when the p,q generation procedure of [FIPS-186] Appendix 2 is followed with seed 'seed', that p is found when 'counter' = pgenCounter.",
      "ja": "1. p = qj + 1. これは、パラメーターがx9.42パラメーター基準を満たしていることを示しています。2. [FIPS-186]のp、q生成手順の付録2のq生成手順がシード「種」に続くと、pが「counter」= pgenCounter のときに見つかったことを確認します。"
    },
    {
      "indent": 5,
      "text": "This demonstrates that the parameters were randomly chosen and do not have a special form.",
      "ja": "これは、パラメーターがランダムに選択され、特別なフォームがないことを示しています。"
    },
    {
      "indent": 3,
      "text": "Whether agents provide validation information in their certificates is a local matter between the agents and their CA.",
      "ja": "エージェントが証明書に検証情報を提供するかどうかは、エージェントとCAの間のローカルな問題です。"
    },
    {
      "indent": 0,
      "text": "2.3. Ephemeral-Static Mode",
      "section_title": true,
      "ja": "2.3. 短命帯状モード"
    },
    {
      "indent": 3,
      "text": "In Ephemeral-Static mode, the recipient has a static (and certified) key pair, but the sender generates a new key pair for each message and sends it using the originatorKey production. If the sender's key is freshly generated for each message, the shared secret ZZ will be similarly different for each message and partyAInfo MAY be omitted, since it serves merely to decouple multiple KEKs generated by the same set of pairwise keys. If, however, the same ephemeral sender key is used for multiple messages (e.g. it is cached as a performance optimization) then a separate partyAInfo MUST be used for each message. All implementations of this standard MUST implement Ephemeral-Static mode.",
      "ja": "短命モードでは、受信者は静的（および認定された）キーペアを持っていますが、送信者は各メッセージの新しいキーペアを生成し、OriginatorKeyの生産を使用して送信します。送信者のキーが各メッセージに対して新たに生成された場合、共有された秘密ZZはメッセージごとに同様に異なり、PartyAinfoは省略される可能性があります。ただし、複数のメッセージに同じはかない送信者キーが使用されている場合（たとえば、パフォーマンスの最適化としてキャッシュされます）、各メッセージに対して個別のpartyainfoを使用する必要があります。この標準のすべての実装は、一時的な静的モードを実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "In order to resist small subgroup attacks, the recipient SHOULD perform the check described in 2.1.5. If an opponent cannot determine success or failure of a decryption operation by the recipient, the recipient MAY choose to omit this check. See also [LL97] for a method of generating keys which are not subject to small subgroup attack.",
      "ja": "小規模なサブグループ攻撃に抵抗するために、受信者は2.1.5で説明されているチェックを実行する必要があります。対戦相手が受信者による復号化操作の成功または失敗を判断できない場合、受信者はこのチェックを省略することを選択できます。小さなサブグループ攻撃の対象ではないキーを生成する方法については、[LL97]も参照してください。"
    },
    {
      "indent": 0,
      "text": "2.4. Static-Static Mode",
      "section_title": true,
      "ja": "2.4. 静的静的モード"
    },
    {
      "indent": 3,
      "text": "In Static-Static mode, both the sender and the recipient have a static (and certified) key pair. Since the sender's and recipient's keys are therefore the same for each message, ZZ will be the same for each message. Thus, partyAInfo MUST be used (and different for each message) in order to ensure that different messages use different KEKs. Implementations MAY implement Static-Static mode.",
      "ja": "静的静的モードでは、送信者と受信者の両方が静的（および認定された）キーペアを持っています。したがって、送信者と受信者のキーは各メッセージに対して同じであるため、ZZは各メッセージに対して同じです。したがって、異なるメッセージが異なるKEKを使用するようにするには、partyainfoを使用する（および各メッセージに対して異なる）必要があります。実装は静的静的モードを実装する場合があります。"
    },
    {
      "indent": 3,
      "text": "In order to prevent small subgroup attacks, both originator and recipient SHOULD either perform the validation step described in Section 2.1.5 or verify that the CA has properly verified the validity of the key. See also [LL97] for a method of generating keys which are not subject to small subgroup attack.",
      "ja": "小規模なサブグループ攻撃を防ぐために、発信者と受信者の両方がセクション2.1.5で説明されている検証ステップを実行するか、CAがキーの有効性を適切に検証していることを確認する必要があります。小さなサブグループ攻撃の対象ではないキーを生成する方法については、[LL97]も参照してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "section_title": true,
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The Key Agreement method described in this document is based on work done by the ANSI X9F1 working group. The author wishes to extend his thanks for their assistance.",
      "ja": "このドキュメントで説明されている主要な合意方法は、ANSI X9F1ワーキンググループによって行われた作業に基づいています。著者は、彼らの支援に感謝を捧げたいと考えています。"
    },
    {
      "indent": 3,
      "text": "The author also wishes to thank Stephen Henson, Paul Hoffman, Russ Housley, Burt Kaliski, Brian Korver, John Linn, Jim Schaad, Mark Schertler, Peter Yee, and Robert Zuccherato for their expert advice and review.",
      "ja": "著者はまた、スティーブン・ヘンソン、ポール・ホフマン、ラス・ヒューズリー、バート・カリスキ、ブライアン・コルバー、ジョン・リン、ジム・シャード、マーク・シェルトラー、ピーター・イー、ロバート・ズッチェラートの専門家のアドバイスとレビューに感謝したいと考えています。"
    },
    {
      "indent": 0,
      "text": "References",
      "section_title": true,
      "ja": "参考文献"
    },
    {
      "indent": 3,
      "text": "[CMS] Housley, R., \"Cryptographic Message Syntax\", RFC 2630, June 1999.",
      "ja": "[CMS] Housley、R。、「暗号化メッセージ構文」、RFC 2630、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[FIPS-46-1] Federal Information Processing Standards Publication (FIPS PUB) 46-1, Data Encryption Standard, Reaffirmed 1988 January 22 (supersedes FIPS PUB 46, 1977 January 15).",
      "ja": "[FIPS-46-1]連邦情報処理基準出版（FIPS Pub）46-1、データ暗号化標準、1988年1月22日の再確認（Supersedes Fips Pub 46、1977年1月15日）。"
    },
    {
      "indent": 3,
      "text": "[FIPS-81] Federal Information Processing Standards Publication (FIPS PUB) 81, DES Modes of Operation, 1980 December 2.",
      "ja": "[FIPS-81]連邦情報処理標準出版（FIPS Pub）81、DES Modes of Operation、1980 12月2日。"
    },
    {
      "indent": 3,
      "text": "[FIPS-180] Federal Information Processing Standards Publication (FIPS PUB) 180-1, \"Secure Hash Standard\", 1995 April 17.",
      "ja": "[FIPS-180]連邦情報処理標準出版（FIPS Pub）180-1、「Secure Hash Standard」、1995年4月17日。"
    },
    {
      "indent": 3,
      "text": "[FIPS-186] Federal Information Processing Standards Publication (FIPS PUB) 186, \"Digital Signature Standard\", 1994 May 19.",
      "ja": "[FIPS-186]連邦情報処理標準出版（FIPS Pub）186、「Digital Signature Standard」、1994年5月19日。"
    },
    {
      "indent": 3,
      "text": "[P1363] \"Standard Specifications for Public Key Cryptography\", IEEE P1363 working group draft, 1998, Annex D.",
      "ja": "[P1363]「公開キー暗号化の標準仕様」、IEEE P1363ワーキンググループドラフト、1998、Annex D."
    },
    {
      "indent": 3,
      "text": "[PKIX] Housley, R., Ford, W., Polk, W. and D. Solo, \"Internet X.509 Public Key Infrastructure Certificate and CRL Profile\", RFC 2459, January 1999.",
      "ja": "[Pkix] Housley、R.、Ford、W.、Polk、W。and D. Solo、「Internet X.509公開鍵インフラストラクチャ証明書とCRLプロファイル」、RFC 2459、1999年1月。"
    },
    {
      "indent": 3,
      "text": "[LAW98] L. Law, A. Menezes, M. Qu, J. Solinas and S. Vanstone, \"An efficient protocol for authenticated key agreement\", Technical report CORR 98-05, University of Waterloo, 1998.",
      "ja": "[Law98] L. Law、A。Menezes、M。Qu、J。SolinasおよびS. Vanstone、「認証された主要な合意のための効率的なプロトコル」、テクニカルレポートCorr 98-05、Waterloo、University of Waterloo、1998。"
    },
    {
      "indent": 3,
      "text": "[LL97] C.H. Lim and P.J. Lee, \"A key recovery attack on discrete log-based schemes using a prime order subgroup\", B.S. Kaliski, Jr., editor, Advances in Cryptology - Crypto '97, Lecture Notes in Computer Science, vol. 1295, 1997, Springer-Verlag, pp. 249-263.",
      "ja": "[LL97] C.H.LimとP.J. Lee、「Prime Order Subgroupを使用した離散ログベースのスキームに対する重要な回復攻撃」、B.S。Kaliski、Jr。、編集者、CryptologyのAdvances -Crypto '97、講義ノートのComputer Science、Vol。1295、1997、Springer-Verlag、pp。249-263。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[X942] \"Agreement Of Symmetric Keys Using Diffie-Hellman and MQV Algorithms\", ANSI draft, 1998.",
      "ja": "[X942]「Diffie-HellmanおよびMQV Algorithmsを使用した対称キーの一致」、ANSI Draft、1998。"
    },
    {
      "indent": 0,
      "text": "Security Considerations",
      "ja": "セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "All the security in this system is provided by the secrecy of the private keying material. If either sender or recipient private keys are disclosed, all messages sent or received using that key are compromised. Similarly, loss of the private key results in an inability to read messages sent using that key.",
      "ja": "このシステムのすべてのセキュリティは、プライベートキーイング資料の秘密によって提供されます。送信者または受信者のいずれかのプライベートキーが開示されている場合、そのキーを使用して送信または受信したすべてのメッセージが侵害されます。同様に、秘密鍵の喪失は、そのキーを使用して送信されたメッセージを読み取ることができないことをもたらします。"
    },
    {
      "indent": 3,
      "text": "Static Diffie-Hellman keys are vulnerable to a small subgroup attack [LAW98]. In practice, this issue arises for both sides in Static-Static mode and for the receiver during Ephemeral-Static mode. Sections 2.3 and 2.4 describe appropriate practices to protect against this attack. Alternatively, it is possible to generate keys in such a fashion that they are resistant to this attack. See [LL97]",
      "ja": "静的diffie-hellmanキーは、小さなサブグループ攻撃に対して脆弱です[Law98]。実際には、この問題は、静的静的モードでの両側、および一時的な静的モード中のレシーバーに対して発生します。セクション2.3および2.4は、この攻撃から保護するための適切な慣行について説明します。あるいは、この攻撃に耐性があるような方法でキーを生成することが可能です。[ll97]を参照してください"
    },
    {
      "indent": 3,
      "text": "The security level provided by these methods depends on several factors. It depends on the length of the symmetric key (typically, a 2^l security level if the length is l bits); the size of the prime q (a 2^{m/2} security level); and the size of the prime p (where the security level grows as a subexponential function of the size in bits). A good design principle is to have a balanced system, where all three security levels are approximately the same. If many keys are derived from a given pair of primes p and q, it may be prudent to have higher levels for the primes. In any case, the overall security is limited by the lowest of the three levels.",
      "ja": "これらの方法で提供されるセキュリティレベルは、いくつかの要因に依存します。対称キーの長さに依存します（通常、長さがLビットの場合は2^lセキュリティレベル）。プライムq（a 2^{m/2}セキュリティレベル）のサイズ;プライムPのサイズ（セキュリティレベルがビット内のサイズのサブエクスポンシャル関数として成長します）。優れた設計の原則は、3つのセキュリティレベルすべてがほぼ同じであるバランスの取れたシステムを持つことです。多くのキーが特定のプライムPとQのペアから派生している場合、プライムのより高いレベルを持つことは賢明かもしれません。いずれにせよ、全体的なセキュリティは3つのレベルの中で最低に制限されます。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者の連絡先"
    },
    {
      "indent": 3,
      "text": "Eric Rescorla RTFM Inc. 30 Newell Road, #16 East Palo Alto, CA 94303",
      "ja": "Eric Rescorla RTFM Inc. 30 Newell Road、＃16 East Palo Alto、CA 94303"
    },
    {
      "indent": 3,
      "text": "EMail: ekr@rtfm.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（1999）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントと翻訳は他の人にコピーされて提供される場合があり、それについてコメントまたは説明するか、その実装を支援する派生作品は、いかなる種類の制限なしに、準備、コピー、公開、配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準のプロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書と本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}