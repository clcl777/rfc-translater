{
  "title": {
    "text": "RFC 2960 - Stream Control Transmission Protocol",
    "ja": "RFC 2960 - ストリーム制御伝送プロトコル"
  },
  "number": 2960,
  "created_at": "2024-01-07 09:17:48.064281+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                         R. Stewart\nRequest for Comments: 2960                                        Q. Xie\nCategory: Standards Track                                       Motorola\n                                                            K. Morneault\n                                                                C. Sharp\n                                                                   Cisco\n                                                         H. Schwarzbauer\n                                                                 Siemens\n                                                               T. Taylor\n                                                         Nortel Networks\n                                                               I. Rytina\n                                                                Ericsson\n                                                                M. Kalla\n                                                               Telcordia\n                                                                L. Zhang\n                                                                    UCLA\n                                                               V. Paxson\n                                                                   ACIRI\n                                                            October 2000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Stream Control Transmission Protocol",
      "ja": "ストリーム制御伝送プロトコル"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2000). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2000）。無断転載を禁じます。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes the Stream Control Transmission Protocol (SCTP). SCTP is designed to transport PSTN signaling messages over IP networks, but is capable of broader applications.",
      "ja": "このドキュメントでは、ストリーム制御伝送プロトコル（SCTP）について説明します。SCTPは、IPネットワークを介してPSTNシグナリングメッセージを輸送するように設計されていますが、より広範なアプリケーションが可能です。"
    },
    {
      "indent": 3,
      "text": "SCTP is a reliable transport protocol operating on top of a connectionless packet network such as IP. It offers the following services to its users:",
      "ja": "SCTPは、IPなどのコネクションレスパケットネットワークの上で動作する信頼性の高いトランスポートプロトコルです。次のサービスをユーザーに提供します。"
    },
    {
      "indent": 6,
      "text": "-- acknowledged error-free non-duplicated transfer of user data,\n-- data fragmentation to conform to discovered path MTU size,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "-- sequenced delivery of user messages within multiple streams,\n   with an option for order-of-arrival delivery of individual user\n   messages,\n-- optional bundling of multiple user messages into a single SCTP\n   packet, and\n-- network-level fault tolerance through supporting of multi-\n   homing at either or both ends of an association.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The design of SCTP includes appropriate congestion avoidance behavior and resistance to flooding and masquerade attacks.",
      "ja": "SCTPの設計には、適切な混雑回避行動と洪水および仮面舞踏会攻撃に対する抵抗が含まれます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction..................................................  5\n  1.1 Motivation..................................................  6\n  1.2 Architectural View of SCTP..................................  6\n  1.3 Functional View of SCTP.....................................  7\n    1.3.1 Association Startup and Takedown........................  8\n    1.3.2 Sequenced Delivery within Streams.......................  9\n    1.3.3 User Data Fragmentation.................................  9\n    1.3.4 Acknowledgement and Congestion Avoidance................  9\n    1.3.5 Chunk Bundling ......................................... 10\n    1.3.6 Packet Validation....................................... 10\n    1.3.7 Path Management......................................... 11\n  1.4 Key Terms................................................... 11\n  1.5 Abbreviations............................................... 15\n  1.6 Serial Number Arithmetic.................................... 15\n2. Conventions.................................................... 16\n3.  SCTP packet Format............................................ 16\n  3.1 SCTP Common Header Field Descriptions....................... 17\n  3.2 Chunk Field Descriptions.................................... 18\n    3.2.1 Optional/Variable-length Parameter Format............... 20\n  3.3 SCTP Chunk Definitions...................................... 21\n    3.3.1 Payload Data (DATA)..................................... 22\n    3.3.2 Initiation (INIT)....................................... 24\n      3.3.2.1 Optional or Variable Length Parameters.............. 26\n    3.3.3 Initiation Acknowledgement (INIT ACK)................... 30\n      3.3.3.1 Optional or Variable Length Parameters.............. 33\n    3.3.4 Selective Acknowledgement (SACK)........................ 33\n    3.3.5 Heartbeat Request (HEARTBEAT)........................... 37\n    3.3.6 Heartbeat Acknowledgement (HEARTBEAT ACK)............... 38\n    3.3.7 Abort Association (ABORT)............................... 39\n    3.3.8 Shutdown Association (SHUTDOWN)......................... 40\n    3.3.9 Shutdown Acknowledgement (SHUTDOWN ACK)................. 40\n    3.3.10 Operation Error (ERROR)................................ 41\n      3.3.10.1 Invalid Stream Identifier.......................... 42\n      3.3.10.2 Missing Mandatory Parameter........................ 43\n      3.3.10.3 Stale Cookie Error................................. 43\n      3.3.10.4 Out of Resource.................................... 44\n      3.3.10.5 Unresolvable Address............................... 44\n      3.3.10.6 Unrecognized Chunk Type............................ 44\n      3.3.10.7 Invalid Mandatory Parameter........................ 45\n      3.3.10.8 Unrecognized Parameters............................ 45\n      3.3.10.9 No User Data....................................... 46\n      3.3.10.10 Cookie Received While Shutting Down............... 46\n    3.3.11 Cookie Echo (COOKIE ECHO).............................. 46\n    3.3.12 Cookie Acknowledgement (COOKIE ACK).................... 47\n    3.3.13 Shutdown Complete (SHUTDOWN COMPLETE).................. 48\n4. SCTP Association State Diagram................................. 48\n   5. Association Initialization..................................... 52\n  5.1 Normal Establishment of an Association...................... 52\n    5.1.1 Handle Stream Parameters................................ 54\n    5.1.2 Handle Address Parameters............................... 54\n    5.1.3 Generating State Cookie................................. 56\n    5.1.4 State Cookie Processing................................. 57\n    5.1.5 State Cookie Authentication............................. 57\n    5.1.6 An Example of Normal Association Establishment.......... 58\n  5.2 Handle Duplicate or unexpected INIT, INIT ACK, COOKIE ECHO,\n      and COOKIE ACK.............................................. 60\n    5.2.1 Handle Duplicate INIT in COOKIE-WAIT\n          or COOKIE-ECHOED States................................. 60\n    5.2.2 Unexpected INIT in States Other than CLOSED,\n          COOKIE-ECHOED, COOKIE-WAIT and SHUTDOWN-ACK-SENT........ 61\n    5.2.3 Unexpected INIT ACK..................................... 61\n    5.2.4 Handle a COOKIE ECHO when a TCB exists.................. 62\n      5.2.4.1 An Example of a Association Restart................. 64\n    5.2.5 Handle Duplicate COOKIE ACK............................. 66\n    5.2.6 Handle Stale COOKIE Error............................... 66\n  5.3 Other Initialization Issues................................. 67\n    5.3.1 Selection of Tag Value.................................. 67\n6. User Data Transfer............................................. 67\n  6.1 Transmission of DATA Chunks................................. 69\n  6.2 Acknowledgement on Reception of DATA Chunks................. 70\n    6.2.1 Tracking Peer's Receive Buffer Space.................... 73\n  6.3 Management Retransmission Timer............................. 75\n    6.3.1 RTO Calculation......................................... 75\n    6.3.2 Retransmission Timer Rules.............................. 76\n    6.3.3 Handle T3-rtx Expiration................................ 77\n  6.4 Multi-homed SCTP Endpoints.................................. 78\n    6.4.1 Failover from Inactive Destination Address.............. 79\n  6.5 Stream Identifier and Stream Sequence Number................ 80\n  6.6 Ordered and Unordered Delivery.............................. 80\n  6.7 Report Gaps in Received DATA TSNs........................... 81\n  6.8 Adler-32 Checksum Calculation............................... 82\n  6.9 Fragmentation............................................... 83\n  6.10 Bundling .................................................. 84\n7. Congestion Control   .......................................... 85\n  7.1 SCTP Differences from TCP Congestion Control................ 85\n  7.2 SCTP Slow-Start and Congestion Avoidance.................... 87\n    7.2.1 Slow-Start.............................................. 87\n    7.2.2 Congestion Avoidance.................................... 89\n    7.2.3 Congestion Control...................................... 89\n    7.2.4 Fast Retransmit on Gap Reports.......................... 90\n  7.3 Path MTU Discovery.......................................... 91\n8.  Fault Management.............................................. 92\n  8.1 Endpoint Failure Detection.................................. 92\n  8.2 Path Failure Detection...................................... 92\n     8.3 Path Heartbeat.............................................. 93\n  8.4 Handle \"Out of the blue\" Packets............................ 95\n  8.5 Verification Tag............................................ 96\n    8.5.1 Exceptions in Verification Tag Rules.................... 97\n9. Termination of Association..................................... 98\n  9.1 Abort of an Association..................................... 98\n  9.2 Shutdown of an Association.................................. 98\n10. Interface with Upper Layer....................................101\n  10.1 ULP-to-SCTP................................................101\n  10.2 SCTP-to-ULP................................................111\n11. Security Considerations.......................................114\n  11.1 Security Objectives........................................114\n  11.2 SCTP Responses To Potential Threats........................115\n    11.2.1 Countering Insider Attacks.............................115\n    11.2.2 Protecting against Data Corruption in the Network......115\n    11.2.3 Protecting Confidentiality.............................115\n    11.2.4 Protecting against Blind Denial of Service Attacks.....116\n      11.2.4.1 Flooding...........................................116\n      11.2.4.2 Blind Masquerade...................................118\n      11.2.4.3 Improper Monopolization of Services................118\n  11.3 Protection against Fraud and Repudiation...................119\n12. Recommended Transmission Control Block (TCB) Parameters.......120\n  12.1 Parameters necessary for the SCTP instance.................120\n  12.2 Parameters necessary per association (i.e. the TCB)........120\n  12.3 Per Transport Address Data.................................122\n  12.4 General Parameters Needed..................................123\n13. IANA Considerations...........................................123\n  13.1 IETF-defined Chunk Extension...............................123\n  13.2 IETF-defined Chunk Parameter Extension.....................124\n  13.3 IETF-defined Additional Error Causes.......................124\n  13.4 Payload Protocol Identifiers...............................125\n14. Suggested SCTP Protocol Parameter Values......................125\n15. Acknowledgements..............................................126\n16. Authors' Addresses............................................126\n17. References....................................................128\n18. Bibliography..................................................129\nAppendix A .......................................................131\nAppendix B .......................................................132\nFull Copyright Statement .........................................134",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This section explains the reasoning behind the development of the Stream Control Transmission Protocol (SCTP), the services it offers, and the basic concepts needed to understand the detailed description of the protocol.",
      "ja": "このセクションでは、ストリーム制御伝送プロトコル（SCTP）の開発の背後にある理由、提供するサービス、およびプロトコルの詳細な説明を理解するために必要な基本概念について説明します。"
    },
    {
      "indent": 0,
      "text": "1.1 Motivation",
      "section_title": true,
      "ja": "1.1 モチベーション"
    },
    {
      "indent": 3,
      "text": "TCP [RFC793] has performed immense service as the primary means of reliable data transfer in IP networks. However, an increasing number of recent applications have found TCP too limiting, and have incorporated their own reliable data transfer protocol on top of UDP [RFC768]. The limitations which users have wished to bypass include the following:",
      "ja": "TCP [RFC793]は、IPネットワークでの信頼できるデータ転送の主要な手段として計り知れないサービスを実行しました。ただし、最近のアプリケーションの数が増えているため、TCPは制限が大きすぎることがわかり、UDPの上に独自の信頼できるデータ転送プロトコルを組み込んでいます[RFC768]。ユーザーがバイパスを望んでいた制限には、以下が含まれます。"
    },
    {
      "indent": 6,
      "text": "-- TCP provides both reliable data transfer and strict order-of-transmission delivery of data. Some applications need reliable transfer without sequence maintenance, while others would be satisfied with partial ordering of the data. In both of these cases the head-of-line blocking offered by TCP causes unnecessary delay.",
      "ja": "-TCPは、信頼できるデータ転送とデータの移動順序配信の両方の両方を提供します。シーケンスメンテナンスなしで信頼できる転送が必要なアプリケーションもあれば、データの部分的な順序に満足するアプリケーションもあります。これらの両方のケースで、TCPが提供する頭のブロッキングは不必要な遅延を引き起こします。"
    },
    {
      "indent": 6,
      "text": "-- The stream-oriented nature of TCP is often an inconvenience. Applications must add their own record marking to delineate their messages, and must make explicit use of the push facility to ensure that a complete message is transferred in a reasonable time.",
      "ja": " -  TCPのストリーム指向の性質は、多くの場合不便です。アプリケーションは、メッセージを描くために独自のレコードマーキングを追加する必要があり、プッシュ機能を明示的に使用して、完全なメッセージが合理的な時間に転送されるようにする必要があります。"
    },
    {
      "indent": 6,
      "text": "-- The limited scope of TCP sockets complicates the task of providing highly-available data transfer capability using multi-homed hosts.",
      "ja": "-TCPソケットの限られた範囲は、マルチホームのホストを使用して、非常に利用可能なデータ転送機能を提供するタスクを複雑にします。"
    },
    {
      "indent": 6,
      "text": "-- TCP is relatively vulnerable to denial of service attacks, such as SYN attacks.",
      "ja": "-TCPは、Syn攻撃などのサービス拒否攻撃に対して比較的脆弱です。"
    },
    {
      "indent": 3,
      "text": "Transport of PSTN signaling across the IP network is an application for which all of these limitations of TCP are relevant. While this application directly motivated the development of SCTP, other applications may find SCTP a good match to their requirements.",
      "ja": "IPネットワークを介したPSTNシグナル伝達の輸送は、TCPのこれらすべての制限が関連するアプリケーションです。このアプリケーションはSCTPの開発を直接動機付けましたが、他のアプリケーションはSCTPが要件に適していると感じる可能性があります。"
    },
    {
      "indent": 0,
      "text": "1.2 Architectural View of SCTP",
      "section_title": true,
      "ja": "1.2 SCTPの建築ビュー"
    },
    {
      "indent": 3,
      "text": "SCTP is viewed as a layer between the SCTP user application (\"SCTP user\" for short) and a connectionless packet network service such as IP. The remainder of this document assumes SCTP runs on top of IP. The basic service offered by SCTP is the reliable transfer of user messages between peer SCTP users. It performs this service within the context of an association between two SCTP endpoints. Section 10 of this document sketches the API which should exist at the boundary between the SCTP and the SCTP user layers.",
      "ja": "SCTPは、SCTPユーザーアプリケーション（略して「SCTPユーザー」）とIPなどのConnectionLess Packetネットワークサービスの間のレイヤーと見なされます。このドキュメントの残りの部分は、SCTPがIPの上で実行されると仮定しています。SCTPが提供する基本サービスは、ピアSCTPユーザー間でユーザーメッセージの信頼できる転送です。2つのSCTPエンドポイント間の関連性のコンテキスト内でこのサービスを実行します。このドキュメントのセクション10では、SCTPとSCTPユーザーレイヤーの境界に存在するはずのAPIをスケッチします。"
    },
    {
      "indent": 3,
      "text": "SCTP is connection-oriented in nature, but the SCTP association is a broader concept than the TCP connection. SCTP provides the means for each SCTP endpoint (Section 1.4) to provide the other endpoint (during association startup) with a list of transport addresses (i.e., multiple IP addresses in combination with an SCTP port) through which that endpoint can be reached and from which it will originate SCTP packets. The association spans transfers over all of the possible source/destination combinations which may be generated from each endpoint's lists.",
      "ja": "SCTPは本質的に接続指向ですが、SCTP関連はTCP接続よりも広範な概念です。SCTPは、各SCTPエンドポイント（セクション1.4）の手段を提供し、他のエンドポイント（アソシエーションスタートアップ中）にトランスポートアドレスのリスト（つまり、SCTPポートと組み合わせた複数のIPアドレス）を提供します。SCTPパケットが発生します。アソシエーションは、各エンドポイントのリストから生成される可能性のあるすべてのソース/宛先の組み合わせにまたがります。"
    },
    {
      "indent": 6,
      "text": " _____________                                      _____________\n|  SCTP User  |                                    |  SCTP User  |\n| Application |                                    | Application |\n|-------------|                                    |-------------|\n|    SCTP     |                                    |    SCTP     |\n|  Transport  |                                    |  Transport  |\n|   Service   |                                    |   Service   |\n|-------------|                                    |-------------|\n|             |One or more    ----      One or more|             |\n| IP Network  |IP address      \\/        IP address| IP Network  |\n|   Service   |appearances     /\\       appearances|   Service   |\n|_____________|               ----                 |_____________|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "SCTP Node A |<-------- Network transport ------->| SCTP Node B",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "Figure 1: An SCTP Association",
      "ja": "図1：SCTP協会"
    },
    {
      "indent": 0,
      "text": "1.3 Functional View of SCTP",
      "section_title": true,
      "ja": "1.3 SCTPの機能的ビュー"
    },
    {
      "indent": 3,
      "text": "The SCTP transport service can be decomposed into a number of functions. These are depicted in Figure 2 and explained in the remainder of this section.",
      "ja": "SCTP輸送サービスは、多くの機能に分解できます。これらは図2に示されており、このセクションの残りの部分で説明されています。"
    },
    {
      "indent": 27,
      "text": "SCTP User Application",
      "ja": "SCTPユーザーアプリケーション"
    },
    {
      "indent": 9,
      "text": "-----------------------------------------------------\n _____________                  ____________________\n|             |                | Sequenced delivery |\n| Association |                |   within streams   |\n|             |                |____________________|\n|   startup   |\n|             |         ____________________________\n|     and     |        |    User Data Fragmentation |\n|             |        |____________________________|\n|   takedown  |\n|             |         ____________________________\n|             |        |     Acknowledgement        |\n|             |        |          and               |\n|             |        |    Congestion Avoidance    |\n|             |        |____________________________|\n|             |\n|             |         ____________________________\n|             |        |       Chunk Bundling       |\n|             |        |____________________________|\n|             |\n|             |     ________________________________\n|             |    |      Packet Validation         |\n|             |    |________________________________|\n|             |\n|             |     ________________________________\n|             |    |     Path Management            |\n|_____________|    |________________________________|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Figure 2: Functional View of the SCTP Transport Service",
      "ja": "図2：SCTP輸送サービスの機能的ビュー"
    },
    {
      "indent": 0,
      "text": "1.3.1 Association Startup and Takedown",
      "section_title": true,
      "ja": "1.3.1 協会のスタートアップとテイクダウン"
    },
    {
      "indent": 3,
      "text": "An association is initiated by a request from the SCTP user (see the description of the ASSOCIATE (or SEND) primitive in Section 10).",
      "ja": "Associationは、SCTPユーザーからのリクエストによって開始されます（セクション10のアソシエイト（または送信）原始の説明を参照）。"
    },
    {
      "indent": 3,
      "text": "A cookie mechanism, similar to one described by Karn and Simpson in [RFC2522], is employed during the initialization to provide protection against security attacks. The cookie mechanism uses a four-way handshake, the last two legs of which are allowed to carry user data for fast setup. The startup sequence is described in Section 5 of this document.",
      "ja": "[RFC2522]でKarnとSimpsonによって説明されているCookieメカニズムは、セキュリティ攻撃に対する保護を提供するために、初期化中に採用されています。Cookieメカニズムは、4方向の握手を使用します。最後の2脚は、高速セットアップのためにユーザーデータを運ぶことができます。スタートアップシーケンスについては、このドキュメントのセクション5で説明します。"
    },
    {
      "indent": 3,
      "text": "SCTP provides for graceful close (i.e., shutdown) of an active association on request from the SCTP user. See the description of the SHUTDOWN primitive in Section 10. SCTP also allows ungraceful close (i.e., abort), either on request from the user (ABORT primitive) or as a result of an error condition detected within the SCTP layer. Section 9 describes both the graceful and the ungraceful close procedures.",
      "ja": "SCTPは、SCTPユーザーからのリクエストに応じて、アクティブな関連付けの優雅なクローズ（つまり、シャットダウン）を提供します。セクション10のシャットダウンプリミティブの説明を参照してください。SCTPでは、ユーザーからの要求（Abort Primitive）またはSCTP層内で検出されたエラー条件の結果として、非graceful的なクローズ（つまり、中止）も許可されています。セクション9では、優雅な手順と不名誉な緊密な手順の両方について説明します。"
    },
    {
      "indent": 3,
      "text": "SCTP does not support a half-open state (like TCP) wherein one side may continue sending data while the other end is closed. When either endpoint performs a shutdown, the association on each peer will stop accepting new data from its user and only deliver data in queue at the time of the graceful close (see Section 9).",
      "ja": "SCTPは、一方の側がデータの送信を継続し、もう一方の端が閉じている半分のオープン状態（TCPなど）をサポートしていません。いずれかのエンドポイントがシャットダウンを実行すると、各ピアの関連付けはユーザーから新しいデータの受け入れを停止し、優雅なクローズの時点でキュー内のデータを配信するのを停止します（セクション9を参照）。"
    },
    {
      "indent": 0,
      "text": "1.3.2 Sequenced Delivery within Streams",
      "section_title": true,
      "ja": "1.3.2 ストリーム内のシーケンス配信"
    },
    {
      "indent": 3,
      "text": "The term \"stream\" is used in SCTP to refer to a sequence of user messages that are to be delivered to the upper-layer protocol in order with respect to other messages within the same stream. This is in contrast to its usage in TCP, where it refers to a sequence of bytes (in this document a byte is assumed to be eight bits).",
      "ja": "「ストリーム」という用語は、SCTPで使用されて、同じストリーム内の他のメッセージに関して、上層層プロトコルに配信される一連のユーザーメッセージを指します。これは、TCPでの使用法とは対照的であり、バイトのシーケンスを指します（このドキュメントでは、バイトは8ビットであると想定されています）。"
    },
    {
      "indent": 3,
      "text": "The SCTP user can specify at association startup time the number of streams to be supported by the association. This number is negotiated with the remote end (see Section 5.1.1). User messages are associated with stream numbers (SEND, RECEIVE primitives, Section 10). Internally, SCTP assigns a stream sequence number to each message passed to it by the SCTP user. On the receiving side, SCTP ensures that messages are delivered to the SCTP user in sequence within a given stream. However, while one stream may be blocked waiting for the next in-sequence user message, delivery from other streams may proceed.",
      "ja": "SCTPユーザーは、アソシエーションの起動時に、アソシエーションによってサポートされるストリームの数を指定できます。この番号は、リモートエンドと交渉されます（セクション5.1.1を参照）。ユーザーメッセージは、ストリーム番号に関連付けられています（送信、プリミティブの受信、セクション10）。内部的には、SCTPはSCTPユーザーによって渡された各メッセージにストリームシーケンス番号を割り当てます。受信側では、SCTPは、特定のストリーム内で順番にメッセージがSCTPユーザーに配信されることを保証します。ただし、次のシーケンスユーザーメッセージを待っている1つのストリームがブロックされる場合がありますが、他のストリームからの配信が進行する場合があります。"
    },
    {
      "indent": 3,
      "text": "SCTP provides a mechanism for bypassing the sequenced delivery service. User messages sent using this mechanism are delivered to the SCTP user as soon as they are received.",
      "ja": "SCTPは、シーケンスされた配信サービスをバイパスするためのメカニズムを提供します。このメカニズムを使用して送信されたユーザーメッセージは、受信したらすぐにSCTPユーザーに配信されます。"
    },
    {
      "indent": 0,
      "text": "1.3.3 User Data Fragmentation",
      "section_title": true,
      "ja": "1.3.3 ユーザーデータの断片化"
    },
    {
      "indent": 3,
      "text": "When needed, SCTP fragments user messages to ensure that the SCTP packet passed to the lower layer conforms to the path MTU. On receipt, fragments are reassembled into complete messages before being passed to the SCTP user.",
      "ja": "必要に応じて、SCTPはユーザーメッセージをフラグメントして、SCTPパケットが下層に渡されることを確認します。受領すると、SCTPユーザーに渡される前に、フラグメントが完全なメッセージに再組み立てされます。"
    },
    {
      "indent": 0,
      "text": "1.3.4 Acknowledgement and Congestion Avoidance",
      "section_title": true,
      "ja": "1.3.4 謝辞と混雑の回避"
    },
    {
      "indent": 3,
      "text": "SCTP assigns a Transmission Sequence Number (TSN) to each user data fragment or unfragmented message. The TSN is independent of any stream sequence number assigned at the stream level. The receiving end acknowledges all TSNs received, even if there are gaps in the sequence. In this way, reliable delivery is kept functionally separate from sequenced stream delivery.",
      "ja": "SCTPは、各ユーザーデータフラグメントまたはフラージメントされていないメッセージに送信シーケンス番号（TSN）を割り当てます。TSNは、ストリームレベルで割り当てられたストリームシーケンス番号から独立しています。受信側は、シーケンスにギャップがある場合でも、受信したすべてのTSNを認めます。このようにして、信頼できる配信は、シーケンスされたストリーム配信とは機能的には分離されています。"
    },
    {
      "indent": 3,
      "text": "The acknowledgement and congestion avoidance function is responsible for packet retransmission when timely acknowledgement has not been received. Packet retransmission is conditioned by congestion avoidance procedures similar to those used for TCP. See Sections 6 and 7 for a detailed description of the protocol procedures associated with this function.",
      "ja": "謝辞と輻輳回避機能は、タイムリーな謝辞が受け取られていない場合のパケットの再送信の原因です。パケットの再送信は、TCPに使用されるものと同様の輻輳回避手順によって条件付けられます。この関数に関連するプロトコル手順の詳細な説明については、セクション6および7を参照してください。"
    },
    {
      "indent": 0,
      "text": "1.3.5 Chunk Bundling",
      "section_title": true,
      "ja": "1.3.5 チャンクバンドル"
    },
    {
      "indent": 3,
      "text": "As described in Section 3, the SCTP packet as delivered to the lower layer consists of a common header followed by one or more chunks. Each chunk may contain either user data or SCTP control information. The SCTP user has the option to request bundling of more than one user messages into a single SCTP packet. The chunk bundling function of SCTP is responsible for assembly of the complete SCTP packet and its disassembly at the receiving end.",
      "ja": "セクション3で説明されているように、下層に配信されるSCTPパケットは、共通のヘッダーと1つ以上のチャンクが続きます。各チャンクには、ユーザーデータまたはSCTP制御情報のいずれかが含まれている場合があります。SCTPユーザーには、複数のユーザーメッセージのバンドリングを単一のSCTPパケットにバンドリングするオプションがあります。SCTPのチャンクバンドル機能は、完全なSCTPパケットのアセンブリと受信側でのその分解を担当します。"
    },
    {
      "indent": 3,
      "text": "During times of congestion an SCTP implementation MAY still perform bundling even if the user has requested that SCTP not bundle. The user's disabling of bundling only affects SCTP implementations that may delay a small period of time before transmission (to attempt to encourage bundling). When the user layer disables bundling, this small delay is prohibited but not bundling that is performed during congestion or retransmission.",
      "ja": "混雑の時点で、SCTPの実装は、ユーザーがSCTPがバンドルではなく要求している場合でもバンドルを実行する場合があります。ユーザーのバンドルの無効化は、送信前（バンドルを促進するため）の少数の期間を遅らせる可能性のあるSCTP実装のみに影響します。ユーザーレイヤーがバンドリングを無効にすると、この小さな遅延は禁止されていますが、混雑または再送信中に実行されるバンドルは禁止されていません。"
    },
    {
      "indent": 0,
      "text": "1.3.6 Packet Validation",
      "section_title": true,
      "ja": "1.3.6 パケット検証"
    },
    {
      "indent": 3,
      "text": "A mandatory Verification Tag field and a 32 bit checksum field (see Appendix B for a description of the Adler-32 checksum) are included in the SCTP common header. The Verification Tag value is chosen by each end of the association during association startup. Packets received without the expected Verification Tag value are discarded, as a protection against blind masquerade attacks and against stale SCTP packets from a previous association. The Adler-32 checksum should be set by the sender of each SCTP packet to provide additional protection against data corruption in the network. The receiver of an SCTP packet with an invalid Adler-32 checksum silently discards the packet.",
      "ja": "必須確認タグフィールドと32ビットチェックサムフィールド（Adler-32チェックサムの説明については、付録Bを参照）がSCTP共通ヘッダーに含まれています。確認タグ値は、協会のスタートアップ中に協会の各端によって選択されます。予想される検証タグ値なしで受け取ったパケットは、盲検マスカレード攻撃に対する保護および以前の関連付けからの古いSCTPパケットに対する保護として破棄されます。Adler-32チェックサムは、各SCTPパケットの送信者によって設定され、ネットワーク内のデータ腐敗に対する追加の保護を提供する必要があります。無効なAdler-32チェックサムを備えたSCTPパケットの受信機は、パケットを静かに破棄します。"
    },
    {
      "indent": 0,
      "text": "1.3.7 Path Management",
      "section_title": true,
      "ja": "1.3.7 パス管理"
    },
    {
      "indent": 3,
      "text": "The sending SCTP user is able to manipulate the set of transport addresses used as destinations for SCTP packets through the primitives described in Section 10. The SCTP path management function chooses the destination transport address for each outgoing SCTP packet based on the SCTP user's instructions and the currently perceived reachability status of the eligible destination set. The path management function monitors reachability through heartbeats when other packet traffic is inadequate to provide this information and advises the SCTP user when reachability of any far-end transport address changes. The path management function is also responsible for reporting the eligible set of local transport addresses to the far end during association startup, and for reporting the transport addresses returned from the far end to the SCTP user.",
      "ja": "送信SCTPユーザーは、セクション10で説明されているプリミティブを介してSCTPパケットの目的地として使用される輸送アドレスのセットを操作できます。SCTPパス管理機能は、SCTPユーザーの命令とSCTPユーザーの命令に基づいて、各発信SCTPパケットの宛先輸送アドレスを選択します。現在、適格な宛先セットの到達可能性ステータスが認識されています。パス管理関数は、他のパケットトラフィックがこの情報を提供するのが不十分な場合、ハートビートを通じて到達可能性を監視し、遠端の輸送アドレスの変更の到達可能性の場合にSCTPユーザーにアドバイスします。パス管理機能は、協会のスタートアップ中に適格なローカルトランスポートアドレスのセットを遠端に報告し、遠端からSCTPユーザーに返された輸送アドレスを報告する責任があります。"
    },
    {
      "indent": 3,
      "text": "At association start-up, a primary path is defined for each SCTP endpoint, and is used for normal sending of SCTP packets.",
      "ja": "Association Startingでは、各SCTPエンドポイントに対して主要なパスが定義され、SCTPパケットの通常の送信に使用されます。"
    },
    {
      "indent": 3,
      "text": "On the receiving end, the path management is responsible for verifying the existence of a valid SCTP association to which the inbound SCTP packet belongs before passing it for further processing.",
      "ja": "受信側では、パス管理は、インバウンドSCTPパケットが属する有効なSCTP関連の存在を検証する責任があります。"
    },
    {
      "indent": 3,
      "text": "Note: Path Management and Packet Validation are done at the same time, so although described separately above, in reality they cannot be performed as separate items.",
      "ja": "注：パス管理とパケットの検証は同時に行われるため、上記で別々に説明しますが、実際には個別のアイテムとして実行することはできません。"
    },
    {
      "indent": 0,
      "text": "1.4 Key Terms",
      "section_title": true,
      "ja": "1.4 重要な用語"
    },
    {
      "indent": 3,
      "text": "Some of the language used to describe SCTP has been introduced in the previous sections. This section provides a consolidated list of the key terms and their definitions.",
      "ja": "SCTPを説明するために使用される言語の一部は、前のセクションで紹介されています。このセクションでは、主要な用語とその定義の統合リストを提供します。"
    },
    {
      "indent": 3,
      "text": "o Active destination transport address: A transport address on a peer endpoint which a transmitting endpoint considers available for receiving user messages.",
      "ja": "o アクティブな宛先輸送住所：ユーザーメッセージを受信するために利用可能なエンドポイントを送信するピアエンドポイント上の輸送アドレス。"
    },
    {
      "indent": 3,
      "text": "o Bundling: An optional multiplexing operation, whereby more than one user message may be carried in the same SCTP packet. Each user message occupies its own DATA chunk.",
      "ja": "o バンドリング：オプションの多重化操作。これにより、同じSCTPパケットで複数のユーザーメッセージを携帯できます。各ユーザーメッセージは、独自のデータチャンクを占有します。"
    },
    {
      "indent": 3,
      "text": "o Chunk: A unit of information within an SCTP packet, consisting of a chunk header and chunk-specific content.",
      "ja": "o Chunk：チャンクヘッダーとチャンク固有のコンテンツで構成されるSCTPパケット内の情報単位。"
    },
    {
      "indent": 3,
      "text": "o Congestion Window (cwnd): An SCTP variable that limits the data, in number of bytes, a sender can send to a particular destination transport address before receiving an acknowledgement.",
      "ja": "o 輻輳ウィンドウ（CWND）：データを制限するSCTP変数、バイト数で、送信者は確認を受ける前に特定の宛先輸送アドレスに送信できます。"
    },
    {
      "indent": 3,
      "text": "o Cumulative TSN Ack Point: The TSN of the last DATA chunk acknowledged via the Cumulative TSN Ack field of a SACK.",
      "ja": "o 累積TSN ACKポイント：サックの累積TSN ACKフィールドを介して認められた最後のデータチャンクのTSN。"
    },
    {
      "indent": 3,
      "text": "o Idle destination address: An address that has not had user messages sent to it within some length of time, normally the HEARTBEAT interval or greater.",
      "ja": "o アイドル宛先アドレス：ある時間内にユーザーメッセージが送信されていないアドレス、通常はハートビート間隔以上です。"
    },
    {
      "indent": 3,
      "text": "o Inactive destination transport address: An address which is considered inactive due to errors and unavailable to transport user messages.",
      "ja": "o 非アクティブな宛先輸送アドレス：エラーのために非アクティブであると見なされ、ユーザーメッセージの輸送に利用できないアドレス。"
    },
    {
      "indent": 3,
      "text": "o Message = user message: Data submitted to SCTP by the Upper Layer Protocol (ULP).",
      "ja": "o メッセージ=ユーザーメッセージ：上層層プロトコル（ULP）によってSCTPに提出されたデータ。"
    },
    {
      "indent": 3,
      "text": "o Message Authentication Code (MAC): An integrity check mechanism based on cryptographic hash functions using a secret key. Typically, message authentication codes are used between two parties that share a secret key in order to validate information transmitted between these parties. In SCTP it is used by an endpoint to validate the State Cookie information that is returned from the peer in the COOKIE ECHO chunk. The term \"MAC\" has different meanings in different contexts. SCTP uses this term with the same meaning as in [RFC2104].",
      "ja": "o メッセージ認証コード（MAC）：シークレットキーを使用した暗号化ハッシュ関数に基づく整合性チェックメカニズム。通常、メッセージ認証コードは、これらの関係者間で送信される情報を検証するために、秘密の鍵を共有する2つの関係者間で使用されます。SCTPでは、クッキーエコーチャンクのピアから返される状態Cookie情報を検証するためにエンドポイントによって使用されます。「Mac」という用語は、さまざまなコンテキストで異なる意味を持っています。SCTPは、[RFC2104]と同じ意味でこの用語を使用します。"
    },
    {
      "indent": 3,
      "text": "o Network Byte Order: Most significant byte first, a.k.a., Big Endian.",
      "ja": "o ネットワークバイト順序：最も重要なバイトファースト、別名、ビッグエンディアン。"
    },
    {
      "indent": 3,
      "text": "o Ordered Message: A user message that is delivered in order with respect to all previous user messages sent within the stream the message was sent on.",
      "ja": "o 注文されたメッセージ：メッセージが送信されたストリーム内で送信されたすべての以前のユーザーメッセージに関して順番に配信されるユーザーメッセージ。"
    },
    {
      "indent": 3,
      "text": "o Outstanding TSN (at an SCTP endpoint): A TSN (and the associated DATA chunk) that has been sent by the endpoint but for which it has not yet received an acknowledgement.",
      "ja": "o 未解決のTSN（SCTPエンドポイント）：エンドポイントによって送信されたが、まだ確認を受けていないTSN（および関連するデータチャンク）。"
    },
    {
      "indent": 3,
      "text": "o Path: The route taken by the SCTP packets sent by one SCTP endpoint to a specific destination transport address of its peer SCTP endpoint. Sending to different destination transport addresses does not necessarily guarantee getting separate paths.",
      "ja": "o パス：1つのSCTPエンドポイントから送信されたSCTPパケットがピアSCTPエンドポイントの特定の宛先輸送アドレスに送信したルート。さまざまな宛先輸送アドレスに送信しても、必ずしも個別のパスを取得することを保証するものではありません。"
    },
    {
      "indent": 3,
      "text": "o Primary Path: The primary path is the destination and source address that will be put into a packet outbound to the peer endpoint by default. The definition includes the source address since an implementation MAY wish to specify both destination and source address to better control the return path taken by reply chunks and on which interface the packet is transmitted when the data sender is multi-homed.",
      "ja": "o プライマリパス：プライマリパスは、デフォルトでピアエンドポイントにアウトバウンドするパケットに配置される宛先およびソースアドレスです。定義にはソースアドレスが含まれます。実装は、データ送信者がマルチホームされているときに返信パスをより適切に制御し、返信チャンクによって実行されるリターンパスをより適切に制御し、パケットが送信されるため、ソースアドレスが含まれます。"
    },
    {
      "indent": 3,
      "text": "o Receiver Window (rwnd): An SCTP variable a data sender uses to store the most recently calculated receiver window of its peer, in number of bytes. This gives the sender an indication of the space available in the receiver's inbound buffer.",
      "ja": "o 受信機ウィンドウ（RWND）：SCTP変数データ送信者が使用して、最近計算されたピアのレシーバーウィンドウをバイト数で保存します。これにより、送信者はレシーバーのインバウンドバッファーで利用可能なスペースを示します。"
    },
    {
      "indent": 3,
      "text": "o SCTP association: A protocol relationship between SCTP endpoints, composed of the two SCTP endpoints and protocol state information including Verification Tags and the currently active set of Transmission Sequence Numbers (TSNs), etc. An association can be uniquely identified by the transport addresses used by the endpoints in the association. Two SCTP endpoints MUST NOT have more than one SCTP association between them at any given time.",
      "ja": "o SCTP Association：2つのSCTPエンドポイントと検証タグを含むプロトコル状態情報と現在アクティブな伝送シーケンス番号（TSN）などで構成されるSCTPエンドポイント間のプロトコル関係。アソシエーションは、使用するトランスポートアドレスによってユニークに特定できます。協会のエンドポイント。2つのSCTPエンドポイントには、それらの間に1つ以上のSCTP関連がある必要があります。"
    },
    {
      "indent": 3,
      "text": "o SCTP endpoint: The logical sender/receiver of SCTP packets. On a multi-homed host, an SCTP endpoint is represented to its peers as a combination of a set of eligible destination transport addresses to which SCTP packets can be sent and a set of eligible source transport addresses from which SCTP packets can be received. All transport addresses used by an SCTP endpoint must use the same port number, but can use multiple IP addresses. A transport address used by an SCTP endpoint must not be used by another SCTP endpoint. In other words, a transport address is unique to an SCTP endpoint.",
      "ja": "o SCTPエンドポイント：SCTPパケットの論理送信者/受信機。マルチホームのホストでは、SCTPエンドポイントは、SCTPパケットを送信できる適格な宛先輸送アドレスのセットと、SCTPパケットを受信できる適格なソーストランスポートアドレスのセットの組み合わせとして、同僚に表されます。SCTPエンドポイントで使用されるすべての輸送アドレスは、同じポート番号を使用する必要がありますが、複数のIPアドレスを使用できます。SCTPエンドポイントで使用されるトランスポートアドレスは、別のSCTPエンドポイントで使用しないでください。言い換えれば、トランスポートアドレスはSCTPエンドポイントに固有のものです。"
    },
    {
      "indent": 3,
      "text": "o SCTP packet (or packet): The unit of data delivery across the interface between SCTP and the connectionless packet network (e.g., IP). An SCTP packet includes the common SCTP header, possible SCTP control chunks, and user data encapsulated within SCTP DATA chunks.",
      "ja": "o SCTPパケット（またはパケット）：SCTPとConnectionless Packetネットワーク（IPなど）の間のインターフェイス全体のデータ配信の単位。SCTPパケットには、一般的なSCTPヘッダー、可能なSCTP制御チャンク、およびSCTPデータチャンク内でカプセル化されたユーザーデータが含まれます。"
    },
    {
      "indent": 3,
      "text": "o SCTP user application (SCTP user): The logical higher-layer application entity which uses the services of SCTP, also called the Upper-layer Protocol (ULP).",
      "ja": "o SCTPユーザーアプリケーション（SCTPユーザー）：SCTPのサービスを使用する論理的高レイヤーアプリケーションエンティティ（上位層プロトコル（ULP））。"
    },
    {
      "indent": 3,
      "text": "o Slow Start Threshold (ssthresh): An SCTP variable. This is the threshold which the endpoint will use to determine whether to perform slow start or congestion avoidance on a particular destination transport address. Ssthresh is in number of bytes.",
      "ja": "o スロースタートしきい値（SSthresh）：SCTP変数。これは、特定の宛先輸送アドレスでスロースタートまたは輻輳回避を実行するかどうかを判断するためにエンドポイントが使用するしきい値です。SSthreshはバイト数です。"
    },
    {
      "indent": 3,
      "text": "o Stream: A uni-directional logical channel established from one to another associated SCTP endpoint, within which all user messages are delivered in sequence except for those submitted to the unordered delivery service.",
      "ja": "o ストリーム：1つの直方向の論理チャンネルから別の関連するSCTPエンドポイントに確立されます。その中には、すべてのユーザーメッセージが順序付けられていない配信サービスに提出されたものを除き、順番に配信されます。"
    },
    {
      "indent": 3,
      "text": "Note: The relationship between stream numbers in opposite directions is strictly a matter of how the applications use them. It is the responsibility of the SCTP user to create and manage these correlations if they are so desired.",
      "ja": "注：反対方向のストリーム番号の関係は、アプリケーションがそれらを使用する方法の厳密な問題です。SCTPユーザーの責任は、これらの相関が非常に望まれている場合に作成および管理することです。"
    },
    {
      "indent": 3,
      "text": "o Stream Sequence Number: A 16-bit sequence number used internally by SCTP to assure sequenced delivery of the user messages within a given stream. One stream sequence number is attached to each user message.",
      "ja": "o ストリームシーケンス番号：SCTPが内部的に使用する16ビットシーケンス番号は、特定のストリーム内のユーザーメッセージのシーケンスされた配信を保証します。1つのストリームシーケンス番号が各ユーザーメッセージに添付されています。"
    },
    {
      "indent": 3,
      "text": "o Tie-Tags: Verification Tags from a previous association. These Tags are used within a State Cookie so that the newly restarting association can be linked to the original association within the endpoint that did not restart.",
      "ja": "o タイタグ：以前の協会からの検証タグ。これらのタグは、州のCookie内で使用されているため、新しく再起動する関連付けは、再起動しなかったエンドポイント内の元の関連付けにリンクできます。"
    },
    {
      "indent": 3,
      "text": "o Transmission Control Block (TCB): An internal data structure created by an SCTP endpoint for each of its existing SCTP associations to other SCTP endpoints. TCB contains all the status and operational information for the endpoint to maintain and manage the corresponding association.",
      "ja": "o トランスミッションコントロールブロック（TCB）：既存の各SCTP関連性のSCTPエンドポイントによって作成された内部データ構造は、他のSCTPエンドポイントになります。TCBには、対応する関連付けを維持および管理するためのエンドポイントのすべてのステータスと運用情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "o Transmission Sequence Number (TSN): A 32-bit sequence number used internally by SCTP. One TSN is attached to each chunk containing user data to permit the receiving SCTP endpoint to acknowledge its receipt and detect duplicate deliveries.",
      "ja": "o 送信シーケンス番号（TSN）：SCTPが内部で使用する32ビットシーケンス番号。1つのTSNが各チャンクを含むユーザーデータに接続されており、受信SCTPエンドポイントが領収書を認め、重複配信を検出できるようにします。"
    },
    {
      "indent": 3,
      "text": "o Transport address: A Transport Address is traditionally defined by Network Layer address, Transport Layer protocol and Transport Layer port number. In the case of SCTP running over IP, a transport address is defined by the combination of an IP address and an SCTP port number (where SCTP is the Transport protocol).",
      "ja": "o 輸送アドレス：輸送アドレスは、従来、ネットワーク層アドレス、輸送層プロトコル、輸送層ポート番号によって定義されています。IPを介して実行されているSCTPの場合、トランスポートアドレスはIPアドレスとSCTPポート番号（SCTPが輸送プロトコル）の組み合わせによって定義されます。"
    },
    {
      "indent": 3,
      "text": "o Unacknowledged TSN (at an SCTP endpoint): A TSN (and the associated DATA chunk) which has been received by the endpoint but for which an acknowledgement has not yet been sent. Or in the opposite case, for a packet that has been sent but no acknowledgement has been received.",
      "ja": "o 未承認のTSN（SCTPエンドポイント）：エンドポイントで受信されたが、確認はまだ送信されていないTSN（および関連するデータチャンク）。または、反対の場合、送信されたが謝辞が受け取られていないパケットの場合。"
    },
    {
      "indent": 3,
      "text": "o Unordered Message: Unordered messages are \"unordered\" with respect to any other message, this includes both other unordered messages as well as other ordered messages. Unordered message might be delivered prior to or later than ordered messages sent on the same stream.",
      "ja": "o 順序付けられていないメッセージ：他のメッセージに関しては、順序付けられていないメッセージは「順序付けられていない」です。これには、他の順序のメッセージと他の順序付けメッセージの両方が含まれます。順序付けられていないメッセージは、同じストリームで送信された順序付けメッセージよりも前後に配信される場合があります。"
    },
    {
      "indent": 3,
      "text": "o User message: The unit of data delivery across the interface between SCTP and its user.",
      "ja": "o ユーザーメッセージ：SCTPとそのユーザーの間のインターフェイス全体のデータ配信ユニット。"
    },
    {
      "indent": 3,
      "text": "o Verification Tag: A 32 bit unsigned integer that is randomly generated. The Verification Tag provides a key that allows a receiver to verify that the SCTP packet belongs to the current association and is not an old or stale packet from a previous association.",
      "ja": "o 検証タグ：ランダムに生成される32ビットの署名されていない整数。検証タグは、受信者がSCTPパケットが現在の協会に属し、以前の協会の古いまたは古いパケットではないことを確認できるキーを提供します。"
    },
    {
      "indent": 0,
      "text": "1.5. Abbreviations",
      "section_title": true,
      "ja": "1.5. 略語"
    },
    {
      "indent": 3,
      "text": "MAC - Message Authentication Code [RFC2104]",
      "ja": "MAC-メッセージ認証コード[RFC2104]"
    },
    {
      "indent": 3,
      "text": "RTO - Retransmission Time-out",
      "ja": "RTO-再送信タイムアウト"
    },
    {
      "indent": 3,
      "text": "RTT - Round-trip Time",
      "ja": "RTT-往復時間"
    },
    {
      "indent": 3,
      "text": "RTTVAR - Round-trip Time Variation",
      "ja": "RTTVAR-往復タイムバリエーション"
    },
    {
      "indent": 3,
      "text": "SCTP - Stream Control Transmission Protocol",
      "ja": "SCTP-ストリーム制御伝送プロトコル"
    },
    {
      "indent": 3,
      "text": "SRTT - Smoothed RTT",
      "ja": "SRTT-スムーズ化されたRTT"
    },
    {
      "indent": 3,
      "text": "TCB - Transmission Control Block",
      "ja": "TCB-送信制御ブロック"
    },
    {
      "indent": 3,
      "text": "TLV - Type-Length-Value Coding Format",
      "ja": "TLV-Type-Length-Valueコーディング形式"
    },
    {
      "indent": 3,
      "text": "TSN - Transmission Sequence Number",
      "ja": "TSN-送信シーケンス番号"
    },
    {
      "indent": 3,
      "text": "ULP - Upper-layer Protocol",
      "ja": "ULP-上層層プロトコル"
    },
    {
      "indent": 0,
      "text": "1.6 Serial Number Arithmetic",
      "section_title": true,
      "ja": "1.6 シリアル番号算術"
    },
    {
      "indent": 3,
      "text": "It is essential to remember that the actual Transmission Sequence Number space is finite, though very large. This space ranges from 0 to 2**32 - 1. Since the space is finite, all arithmetic dealing with Transmission Sequence Numbers must be performed modulo 2**32. This unsigned arithmetic preserves the relationship of sequence numbers as they cycle from 2**32 - 1 to 0 again. There are some subtleties to computer modulo arithmetic, so great care should be taken in programming the comparison of such values. When referring to TSNs, the symbol \"=<\" means \"less than or equal\"(modulo 2**32).",
      "ja": "非常に大きいものの、実際の伝送シーケンス番号スペースは有限であることを覚えておくことが不可欠です。このスペースの範囲は0から2 ** 32-1。スペースの有限であるため、伝送シーケンス番号を扱うすべての算術番号を実行する必要があります。この署名されていない算術は、2 ** 32-1から0に再びサイクリングする際のシーケンス番号の関係を保持します。コンピューターモジュロの算術にはいくつかの微妙さがあるので、そのような値の比較をプログラミングする際には細心の注意を払う必要があります。TSNSを参照する場合、シンボル \"= <\"は「より低いか等しく」を意味します（Modulo 2 ** 32）。"
    },
    {
      "indent": 3,
      "text": "Comparisons and arithmetic on TSNs in this document SHOULD use Serial Number Arithmetic as defined in [RFC1982] where SERIAL_BITS = 32.",
      "ja": "このドキュメントのTSNSの比較と算術は、serial_bits = 32で[RFC1982]で定義されているようにシリアル番号算術を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD NOT transmit a DATA chunk with a TSN that is more than 2**31 - 1 above the beginning TSN of its current send window. Doing so will cause problems in comparing TSNs.",
      "ja": "エンドポイントは、現在の送信ウィンドウの最初のTSNの上に2 ** 31-1を超えるTSNを使用してデータチャンクを送信してはなりません。そうすることで、TSNを比較する際に問題が発生します。"
    },
    {
      "indent": 3,
      "text": "Transmission Sequence Numbers wrap around when they reach 2**32 - 1. That is, the next TSN a DATA chunk MUST use after transmitting TSN = 2*32 - 1 is TSN = 0.",
      "ja": "トランスミッションシーケンス番号が2 ** 32-1に達したときにラップを巻き付けます。つまり、TSN = 2*32-1を送信した後にデータチャンクが使用する必要がある次のTSNはTSN = 0です。"
    },
    {
      "indent": 3,
      "text": "Any arithmetic done on Stream Sequence Numbers SHOULD use Serial Number Arithmetic as defined in [RFC1982] where SERIAL_BITS = 16.",
      "ja": "ストリームシーケンス番号で行われた算術は、[RFC1982]で定義されているシリアル番号算術を使用して、serial_bits = 16を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "All other arithmetic and comparisons in this document uses normal arithmetic.",
      "ja": "このドキュメントの他のすべての算術と比較は、通常の算術を使用します。"
    },
    {
      "indent": 0,
      "text": "2. Conventions",
      "section_title": true,
      "ja": "2. 規約"
    },
    {
      "indent": 3,
      "text": "The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, NOT RECOMMENDED, MAY, and OPTIONAL, when they appear in this document, are to be interpreted as described in [RFC2119].",
      "ja": "キーワードは、このドキュメントに表示される場合、[RFC2119]に記載されているように解釈される場合、必要な、必須、必要は、推奨、推奨、推奨、推奨、推奨、推奨、推奨、推奨、およびオプションでなければなりません。"
    },
    {
      "indent": 0,
      "text": "3. SCTP packet Format",
      "section_title": true,
      "ja": "3. SCTPパケット形式"
    },
    {
      "indent": 3,
      "text": "An SCTP packet is composed of a common header and chunks. A chunk contains either control information or user data.",
      "ja": "SCTPパケットは、共通のヘッダーとチャンクで構成されています。チャンクには、制御情報またはユーザーデータのいずれかが含まれます。"
    },
    {
      "indent": 3,
      "text": "The SCTP packet format is shown below:",
      "ja": "SCTPパケット形式を以下に示します。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Common Header                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          Chunk #1                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           ...                                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          Chunk #n                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Multiple chunks can be bundled into one SCTP packet up to the MTU size, except for the INIT, INIT ACK, and SHUTDOWN COMPLETE chunks. These chunks MUST NOT be bundled with any other chunk in a packet. See Section 6.10 for more details on chunk bundling.",
      "ja": "INIT、INIT ACK、およびシャットダウン完全チャンクを除き、複数のチャンクをMTUサイズまで1つのSCTPパケットにバンドルできます。これらのチャンクは、パケットに他のチャンクにバンドルされてはなりません。チャンクバンドリングの詳細については、セクション6.10を参照してください。"
    },
    {
      "indent": 3,
      "text": "If a user data message doesn't fit into one SCTP packet it can be fragmented into multiple chunks using the procedure defined in Section 6.9.",
      "ja": "ユーザーデータメッセージが1つのSCTPパケットに収まらない場合、セクション6.9で定義されている手順を使用して、複数のチャンクに断片化できます。"
    },
    {
      "indent": 3,
      "text": "All integer fields in an SCTP packet MUST be transmitted in network byte order, unless otherwise stated.",
      "ja": "SCTPパケット内のすべての整数フィールドは、特に明記しない限り、ネットワークバイトの順序で送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.1 SCTP Common Header Field Descriptions",
      "section_title": true,
      "ja": "3.1 SCTP共通ヘッダーフィールドの説明"
    },
    {
      "indent": 25,
      "text": "SCTP Common Header Format",
      "ja": "SCTP共通ヘッダー形式"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Source Port Number        |     Destination Port Number   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Verification Tag                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           Checksum                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Source Port Number: 16 bits (unsigned integer)",
      "ja": "ソースポート番号：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This is the SCTP sender's port number. It can be used by the receiver in combination with the source IP address, the SCTP destination port and possibly the destination IP address to identify the association to which this packet belongs.",
      "ja": "これはSCTP送信者のポート番号です。レシーバーは、ソースIPアドレス、SCTP宛先ポート、および場合によっては宛先IPアドレスと組み合わせて使用して、このパケットが属する関連付けを識別できます。"
    },
    {
      "indent": 3,
      "text": "Destination Port Number: 16 bits (unsigned integer)",
      "ja": "宛先ポート番号：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This is the SCTP port number to which this packet is destined. The receiving host will use this port number to de-multiplex the SCTP packet to the correct receiving endpoint/application.",
      "ja": "これは、このパケットが運命づけられているSCTPポート番号です。受信ホストは、このポート番号を使用して、sctpパケットを正しい受信エンドポイント/アプリケーションに測定します。"
    },
    {
      "indent": 3,
      "text": "Verification Tag: 32 bits (unsigned integer)",
      "ja": "検証タグ：32ビット（署名されていない整数）"
    },
    {
      "indent": 6,
      "text": "The receiver of this packet uses the Verification Tag to validate the sender of this SCTP packet. On transmit, the value of this Verification Tag MUST be set to the value of the Initiate Tag received from the peer endpoint during the association initialization, with the following exceptions:",
      "ja": "このパケットの受信機は、検証タグを使用して、このSCTPパケットの送信者を検証します。送信時、この検証タグの値は、協会の初期化中にピアエンドポイントから受信した開始タグの値に設定する必要があります。"
    },
    {
      "indent": 6,
      "text": "- A packet containing an INIT chunk MUST have a zero Verification Tag. - A packet containing a SHUTDOWN-COMPLETE chunk with the T-bit set MUST have the Verification Tag copied from the packet with the SHUTDOWN-ACK chunk. - A packet containing an ABORT chunk may have the verification tag copied from the packet which caused the ABORT to be sent. For details see Section 8.4 and 8.5.",
      "ja": "- initチャンクを含むパケットには、ゼロ検証タグが必要です。-T-BITセットにシャットダウンコンプリートチャンクを含むパケットには、シャットダウンのチャンクでパケットからコピーされた検証タグが必要です。 - 中止塊を含むパケットには、中止が送信される原因となったパケットから検証タグがコピーされる場合があります。詳細については、セクション8.4および8.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "An INIT chunk MUST be the only chunk in the SCTP packet carrying it.",
      "ja": "initチャンクは、それを運ぶSCTPパケットの唯一のチャンクでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Checksum: 32 bits (unsigned integer)",
      "ja": "チェックサム：32ビット（符号なし整数）"
    },
    {
      "indent": 9,
      "text": "This field contains the checksum of this SCTP packet. Its calculation is discussed in Section 6.8. SCTP uses the Adler-32 algorithm as described in Appendix B for calculating the checksum",
      "ja": "このフィールドには、このSCTPパケットのチェックサムが含まれています。その計算については、セクション6.8で説明します。SCTPは、チェックサムを計算するために付録Bで説明したAdler-32アルゴリズムを使用します"
    },
    {
      "indent": 0,
      "text": "3.2 Chunk Field Descriptions",
      "section_title": true,
      "ja": "3.2 チャンクフィールドの説明"
    },
    {
      "indent": 3,
      "text": "The figure below illustrates the field format for the chunks to be transmitted in the SCTP packet. Each chunk is formatted with a Chunk Type field, a chunk-specific Flag field, a Chunk Length field, and a Value field.",
      "ja": "以下の図は、SCTPパケットで送信されるチャンクのフィールド形式を示しています。各チャンクは、チャンクタイプフィールド、チャンク固有のフラグフィールド、チャンク長フィールド、および値フィールドでフォーマットされています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Chunk Type  | Chunk  Flags  |        Chunk Length           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/                          Chunk Value                          /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Type: 8 bits (unsigned integer)",
      "ja": "チャンクタイプ：8ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This field identifies the type of information contained in the Chunk Value field. It takes a value from 0 to 254. The value of 255 is reserved for future use as an extension field.",
      "ja": "このフィールドは、チャンク値フィールドに含まれる情報のタイプを識別します。値が0から254になります。255の値は、拡張フィールドとして将来使用するために予約されています。"
    },
    {
      "indent": 3,
      "text": "The values of Chunk Types are defined as follows:",
      "ja": "チャンクタイプの値は次のように定義されます。"
    },
    {
      "indent": 3,
      "text": "ID Value    Chunk Type\n-----       ----------\n0          - Payload Data (DATA)\n1          - Initiation (INIT)\n2          - Initiation Acknowledgement (INIT ACK)\n3          - Selective Acknowledgement (SACK)\n4          - Heartbeat Request (HEARTBEAT)\n5          - Heartbeat Acknowledgement (HEARTBEAT ACK)\n6          - Abort (ABORT)\n7          - Shutdown (SHUTDOWN)\n8          - Shutdown Acknowledgement (SHUTDOWN ACK)\n9          - Operation Error (ERROR)\n10         - State Cookie (COOKIE ECHO)\n11         - Cookie Acknowledgement (COOKIE ACK)\n12         - Reserved for Explicit Congestion Notification Echo (ECNE)\n13         - Reserved for Congestion Window Reduced (CWR)\n   14         - Shutdown Complete (SHUTDOWN COMPLETE)\n15 to 62   - reserved by IETF\n63         - IETF-defined Chunk Extensions\n64 to 126  - reserved by IETF\n127        - IETF-defined Chunk Extensions\n128 to 190 - reserved by IETF\n191        - IETF-defined Chunk Extensions\n192 to 254 - reserved by IETF\n255        - IETF-defined Chunk Extensions",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Types are encoded such that the highest-order two bits specify the action that must be taken if the processing endpoint does not recognize the Chunk Type.",
      "ja": "チャンクタイプは、最大の2ビットが処理エンドポイントがチャンクタイプを認識しない場合に実行する必要があるアクションを指定するようにエンコードされます。"
    },
    {
      "indent": 3,
      "text": "00 - Stop processing this SCTP packet and discard it, do not process any further chunks within it.",
      "ja": "00-このSCTPパケットの処理を停止して破棄し、その中にそれ以上のチャンクを処理しないでください。"
    },
    {
      "indent": 3,
      "text": "01 - Stop processing this SCTP packet and discard it, do not process any further chunks within it, and report the unrecognized parameter in an 'Unrecognized Parameter Type' (in either an ERROR or in the INIT ACK).",
      "ja": "01-このSCTPパケットの処理を停止して破棄し、その中のそれ以上のチャンクを処理しないでください、そして、認識されていないパラメーターを「認識されていないパラメータータイプ」（エラーまたはinit ACKのいずれか）で報告しません。"
    },
    {
      "indent": 3,
      "text": "10 - Skip this chunk and continue processing.",
      "ja": "10-このチャンクをスキップして、処理を続けます。"
    },
    {
      "indent": 3,
      "text": "11 - Skip this chunk and continue processing, but report in an ERROR Chunk using the 'Unrecognized Chunk Type' cause of error.",
      "ja": "11-このチャンクをスキップして処理を続けますが、「認識されていないチャンクタイプ」の原因を使用してエラーチャンクで報告します。"
    },
    {
      "indent": 3,
      "text": "Note: The ECNE and CWR chunk types are reserved for future use of Explicit Congestion Notification (ECN).",
      "ja": "注：ECNEおよびCWRチャンクタイプは、明示的な混雑通知（ECN）の将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 6,
      "text": "The usage of these bits depends on the chunk type as given by the Chunk Type. Unless otherwise specified, they are set to zero on transmit and are ignored on receipt.",
      "ja": "これらのビットの使用は、チャンクタイプで与えられたチャンクタイプに依存します。特に指定されていない限り、送信時にゼロに設定され、受領時に無視されます。"
    },
    {
      "indent": 3,
      "text": "Chunk Length: 16 bits (unsigned integer)",
      "ja": "チャンク長：16ビット（署名されていない整数）"
    },
    {
      "indent": 6,
      "text": "This value represents the size of the chunk in bytes including the Chunk Type, Chunk Flags, Chunk Length, and Chunk Value fields. Therefore, if the Chunk Value field is zero-length, the Length field will be set to 4. The Chunk Length field does not count any padding.",
      "ja": "この値は、チャンクタイプ、チャンクフラグ、チャンク長、およびチャンク値フィールドを含むバイトのチャンクのサイズを表します。したがって、チャンク値フィールドがゼロ長の場合、長さフィールドは4に設定されます。チャンク長フィールドはパディングをカウントしません。"
    },
    {
      "indent": 3,
      "text": "Chunk Value: variable length",
      "ja": "チャンク値：変数長"
    },
    {
      "indent": 6,
      "text": "The Chunk Value field contains the actual information to be transferred in the chunk. The usage and format of this field is dependent on the Chunk Type.",
      "ja": "チャンク値フィールドには、チャンクで転送される実際の情報が含まれています。このフィールドの使用法と形式は、チャンクタイプに依存します。"
    },
    {
      "indent": 3,
      "text": "The total length of a chunk (including Type, Length and Value fields) MUST be a multiple of 4 bytes. If the length of the chunk is not a multiple of 4 bytes, the sender MUST pad the chunk with all zero bytes and this padding is not included in the chunk length field. The sender should never pad with more than 3 bytes. The receiver MUST ignore the padding bytes.",
      "ja": "チャンクの全長（タイプ、長さ、値フィールドを含む）は、4バイトの倍数でなければなりません。チャンクの長さが4バイトの倍数ではない場合、送信者はすべてのゼロバイトでチャンクを埋める必要があり、このパディングはチャンク長フィールドに含まれていません。送信者は、3バイト以上のパッドではないでください。受信機は、パディングバイトを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "SCTP defined chunks are described in detail in Section 3.3. The guidelines for IETF-defined chunk extensions can be found in Section 13.1 of this document.",
      "ja": "SCTP定義されたチャンクについては、セクション3.3で詳しく説明しています。IETF定義のチャンク拡張機能のガイドラインは、このドキュメントのセクション13.1に記載されています。"
    },
    {
      "indent": 0,
      "text": "3.2.1 Optional/Variable-length Parameter Format",
      "section_title": true,
      "ja": "3.2.1 オプション/変数長パラメーター形式"
    },
    {
      "indent": 3,
      "text": "Chunk values of SCTP control chunks consist of a chunk-type-specific header of required fields, followed by zero or more parameters. The optional and variable-length parameters contained in a chunk are defined in a Type-Length-Value format as shown below.",
      "ja": "SCTPコントロールチャンクのチャンク値は、必要なフィールドのチャンクタイプ固有のヘッダーで構成され、その後はゼロ以上のパラメーターが続きます。チャンクに含まれるオプションおよび可変長さのパラメーターは、以下に示すように、タイプ長価値形式で定義されます。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Parameter Type       |       Parameter Length        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/                       Parameter Value                         /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Parameter Type: 16 bits (unsigned integer)",
      "ja": "チャンクパラメータータイプ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "The Type field is a 16 bit identifier of the type of parameter. It takes a value of 0 to 65534.",
      "ja": "タイプフィールドは、パラメーターのタイプの16ビット識別子です。0〜65534の値が必要です。"
    },
    {
      "indent": 6,
      "text": "The value of 65535 is reserved for IETF-defined extensions. Values other than those defined in specific SCTP chunk description are reserved for use by IETF.",
      "ja": "65535の値は、IETF定義の拡張機能に予約されています。特定のSCTPチャンク説明で定義されている値以外の値は、IETFが使用するために予約されています。"
    },
    {
      "indent": 3,
      "text": "Chunk Parameter Length: 16 bits (unsigned integer)",
      "ja": "チャンクパラメーターの長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "The Parameter Length field contains the size of the parameter in bytes, including the Parameter Type, Parameter Length, and Parameter Value fields. Thus, a parameter with a zero-length Parameter Value field would have a Length field of 4. The Parameter Length does not include any padding bytes.",
      "ja": "パラメーターの長さフィールドには、パラメータータイプ、パラメーターの長さ、パラメーター値フィールドなど、バイト内のパラメーターのサイズが含まれています。したがって、ゼロの長さのパラメーター値フィールドを持つパラメーターの長さフィールドは4です。パラメーターの長さには、パディングバイトは含まれません。"
    },
    {
      "indent": 3,
      "text": "Chunk Parameter Value: variable-length.",
      "ja": "チャンクパラメーター値：変数長。"
    },
    {
      "indent": 6,
      "text": "The Parameter Value field contains the actual information to be transferred in the parameter.",
      "ja": "パラメーター値フィールドには、パラメーターに転送される実際の情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "The total length of a parameter (including Type, Parameter Length and Value fields) MUST be a multiple of 4 bytes. If the length of the parameter is not a multiple of 4 bytes, the sender pads the Parameter at the end (i.e., after the Parameter Value field) with all zero bytes. The length of the padding is not included in the parameter length field. A sender SHOULD NOT pad with more than 3 bytes. The receiver MUST ignore the padding bytes.",
      "ja": "パラメーターの総長さ（タイプ、パラメーターの長さ、値フィールドを含む）は、4バイトの倍数でなければなりません。パラメーターの長さが4バイトの倍数でない場合、送信者は、すべてのゼロバイトを持つ最後のパラメーター（つまり、パラメーター値フィールドの後）にパッドをパッドします。パディングの長さは、パラメーターの長さフィールドに含まれていません。送信者は、3バイト以上のパッドではありません。受信機は、パディングバイトを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "The Parameter Types are encoded such that the highest-order two bits specify the action that must be taken if the processing endpoint does not recognize the Parameter Type.",
      "ja": "パラメータータイプは、最大の2つのビットが、処理エンドポイントがパラメータータイプを認識しない場合に実行する必要があるアクションを指定するようにエンコードされます。"
    },
    {
      "indent": 3,
      "text": "00 - Stop processing this SCTP packet and discard it, do not process any further chunks within it.",
      "ja": "00-このSCTPパケットの処理を停止して破棄し、その中にそれ以上のチャンクを処理しないでください。"
    },
    {
      "indent": 3,
      "text": "01 - Stop processing this SCTP packet and discard it, do not process any further chunks within it, and report the unrecognized parameter in an 'Unrecognized Parameter Type' (in either an ERROR or in the INIT ACK).",
      "ja": "01-このSCTPパケットの処理を停止して破棄し、その中のそれ以上のチャンクを処理しないでください、そして、認識されていないパラメーターを「認識されていないパラメータータイプ」（エラーまたはinit ACKのいずれか）で報告しません。"
    },
    {
      "indent": 3,
      "text": "10 - Skip this parameter and continue processing.",
      "ja": "10-このパラメーターをスキップして、処理を続行します。"
    },
    {
      "indent": 3,
      "text": "11 - Skip this parameter and continue processing but report the unrecognized parameter in an 'Unrecognized Parameter Type' (in either an ERROR or in the INIT ACK).",
      "ja": "11-このパラメーターをスキップして処理を続行しますが、認識されていないパラメーターを「認識されていないパラメータータイプ」（エラーまたはinit ACKのいずれか）に報告します。"
    },
    {
      "indent": 3,
      "text": "The actual SCTP parameters are defined in the specific SCTP chunk sections. The rules for IETF-defined parameter extensions are defined in Section 13.2.",
      "ja": "実際のSCTPパラメーターは、特定のSCTPチャンクセクションで定義されています。IETF定義のパラメーター拡張機能のルールは、セクション13.2で定義されています。"
    },
    {
      "indent": 0,
      "text": "3.3 SCTP Chunk Definitions",
      "section_title": true,
      "ja": "3.3 SCTPチャンク定義"
    },
    {
      "indent": 3,
      "text": "This section defines the format of the different SCTP chunk types.",
      "ja": "このセクションでは、さまざまなSCTPチャンクタイプの形式を定義します。"
    },
    {
      "indent": 0,
      "text": "3.3.1 Payload Data (DATA) (0)",
      "section_title": true,
      "ja": "3.3.1 ペイロードデータ（データ）（0）"
    },
    {
      "indent": 3,
      "text": "The following format MUST be used for the DATA chunk:",
      "ja": "次の形式は、データチャンクに使用する必要があります。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 0    | Reserved|U|B|E|    Length                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                              TSN                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Stream Identifier S      |   Stream Sequence Number n    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  Payload Protocol Identifier                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/                 User Data (seq n of Stream S)                 /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Reserved: 5 bits",
      "ja": "予約済み：5ビット"
    },
    {
      "indent": 6,
      "text": "Should be set to all '0's and ignored by the receiver.",
      "ja": "すべての '0に設定し、受信機によって無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "U bit: 1 bit",
      "ja": "uビット：1ビット"
    },
    {
      "indent": 6,
      "text": "The (U)nordered bit, if set to '1', indicates that this is an unordered DATA chunk, and there is no Stream Sequence Number assigned to this DATA chunk. Therefore, the receiver MUST ignore the Stream Sequence Number field.",
      "ja": "（u）norderedビットは、「1」に設定されている場合、これが順序付けられていないデータチャンクであり、このデータチャンクに割り当てられたストリームシーケンス番号がないことを示します。したがって、レシーバーはストリームシーケンス番号フィールドを無視する必要があります。"
    },
    {
      "indent": 6,
      "text": "After re-assembly (if necessary), unordered DATA chunks MUST be dispatched to the upper layer by the receiver without any attempt to re-order.",
      "ja": "再組み立て後（必要に応じて）、順序付けられていないデータチャンクを、再注文の試みなしに受信機によって上層に派遣する必要があります。"
    },
    {
      "indent": 6,
      "text": "If an unordered user message is fragmented, each fragment of the message MUST have its U bit set to '1'.",
      "ja": "順序付けられていないユーザーメッセージが断片化されている場合、メッセージの各フラグメントはuビットを「1」に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "B bit: 1 bit",
      "ja": "Bビット：1ビット"
    },
    {
      "indent": 6,
      "text": "The (B)eginning fragment bit, if set, indicates the first fragment of a user message.",
      "ja": "（b）eginningフラグメントビットは、設定されている場合、ユーザーメッセージの最初のフラグメントを示します。"
    },
    {
      "indent": 3,
      "text": "E bit: 1 bit",
      "ja": "Eビット：1ビット"
    },
    {
      "indent": 6,
      "text": "The (E)nding fragment bit, if set, indicates the last fragment of a user message.",
      "ja": "（e）ndingフラグメントビットは、設定されている場合、ユーザーメッセージの最後のフラグメントを示します。"
    },
    {
      "indent": 3,
      "text": "An unfragmented user message shall have both the B and E bits set to '1'. Setting both B and E bits to '0' indicates a middle fragment of a multi-fragment user message, as summarized in the following table:",
      "ja": "不正確なユーザーメッセージには、bとeビットの両方が「1」に設定されている必要があります。次の表に要約されているように、bとeの両方のビットを「0」に設定すると、マルチフラグメントユーザーメッセージの中間フラグメントが示されます。"
    },
    {
      "indent": 9,
      "text": "   B E                  Description\n============================================================\n|  1 0 | First piece of a fragmented user message          |\n+----------------------------------------------------------+\n|  0 0 | Middle piece of a fragmented user message         |\n+----------------------------------------------------------+\n|  0 1 | Last piece of a fragmented user message           |\n+----------------------------------------------------------+\n|  1 1 | Unfragmented Message                              |\n============================================================\n|             Table 1: Fragment Description Flags          |\n============================================================",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When a user message is fragmented into multiple chunks, the TSNs are used by the receiver to reassemble the message. This means that the TSNs for each fragment of a fragmented user message MUST be strictly sequential.",
      "ja": "ユーザーメッセージが複数のチャンクに断片化されると、TSNは受信者によって使用されてメッセージを再組み立てします。これは、断片化されたユーザーメッセージの各フラグメントのTSNSが厳密に順次必要でなければならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "Length: 16 bits (unsigned integer)",
      "ja": "長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This field indicates the length of the DATA chunk in bytes from the beginning of the type field to the end of the user data field excluding any padding. A DATA chunk with no user data field will have Length set to 16 (indicating 16 bytes).",
      "ja": "このフィールドは、型フィールドの先頭からパディングを除くユーザーデータフィールドの最後までバイト単位のデータチャンクの長さを示します。ユーザーデータフィールドのないデータチャンクの長さは16に設定されます（16バイトを示します）。"
    },
    {
      "indent": 3,
      "text": "TSN : 32 bits (unsigned integer)",
      "ja": "TSN：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This value represents the TSN for this DATA chunk. The valid range of TSN is from 0 to 4294967295 (2**32 - 1). TSN wraps back to 0 after reaching 4294967295.",
      "ja": "この値は、このデータチャンクのTSNを表します。TSNの有効な範囲は0〜4294967295（2 ** 32-1）です。TSNは4294967295に達した後、0に戻ります。"
    },
    {
      "indent": 3,
      "text": "Stream Identifier S: 16 bits (unsigned integer)",
      "ja": "ストリーム識別子s：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Identifies the stream to which the following user data belongs.",
      "ja": "次のユーザーデータが属するストリームを識別します。"
    },
    {
      "indent": 3,
      "text": "Stream Sequence Number n: 16 bits (unsigned integer)",
      "ja": "ストリームシーケンス番号n：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This value represents the stream sequence number of the following user data within the stream S. Valid range is 0 to 65535.",
      "ja": "この値は、Stream S内の次のユーザーデータのストリームシーケンス番号を表します。有効な範囲は0〜65535です。"
    },
    {
      "indent": 6,
      "text": "When a user message is fragmented by SCTP for transport, the same stream sequence number MUST be carried in each of the fragments of the message.",
      "ja": "ユーザーメッセージが輸送のためにSCTPによって断片化される場合、メッセージの各フラグメントに同じストリームシーケンス番号を掲載する必要があります。"
    },
    {
      "indent": 3,
      "text": "Payload Protocol Identifier: 32 bits (unsigned integer)",
      "ja": "ペイロードプロトコル識別子：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This value represents an application (or upper layer) specified protocol identifier. This value is passed to SCTP by its upper layer and sent to its peer. This identifier is not used by SCTP but can be used by certain network entities as well as the peer application to identify the type of information being carried in this DATA chunk. This field must be sent even in fragmented DATA chunks (to make sure it is available for agents in the middle of the network).",
      "ja": "この値は、アプリケーション（または上層）指定されたプロトコル識別子を表します。この値は、上層によってSCTPに渡され、ピアに送信されます。この識別子はSCTPでは使用されませんが、特定のネットワークエンティティとピアアプリケーションで使用することができ、このデータチャンクで実行される情報の種類を特定することができます。このフィールドは、断片化されたデータチャンクでも送信する必要があります（ネットワークの中央にあるエージェントが利用できることを確認してください）。"
    },
    {
      "indent": 6,
      "text": "The value 0 indicates no application identifier is specified by the upper layer for this payload data.",
      "ja": "値0は、このペイロードデータの上層によって指定されているアプリケーション識別子がないことを示します。"
    },
    {
      "indent": 3,
      "text": "User Data: variable length",
      "ja": "ユーザーデータ：変数長"
    },
    {
      "indent": 6,
      "text": "This is the payload user data. The implementation MUST pad the end of the data to a 4 byte boundary with all-zero bytes. Any padding MUST NOT be included in the length field. A sender MUST never add more than 3 bytes of padding.",
      "ja": "これはペイロードユーザーデータです。実装では、データの端をすべてゼロバイトを使用して4バイトの境界に埋めなければなりません。パディングは長さフィールドに含めてはなりません。送信者は、3バイト以上のパディングを追加してはいけません。"
    },
    {
      "indent": 0,
      "text": "3.3.2 Initiation (INIT) (1)",
      "section_title": true,
      "ja": "3.3.2 開始（init）（1）"
    },
    {
      "indent": 3,
      "text": "This chunk is used to initiate a SCTP association between two endpoints. The format of the INIT chunk is shown below:",
      "ja": "このチャンクは、2つのエンドポイント間のSCTP関連を開始するために使用されます。initチャンクの形式を以下に示します。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 1    |  Chunk Flags  |      Chunk Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Initiate Tag                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Advertised Receiver Window Credit (a_rwnd)          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Number of Outbound Streams   |  Number of Inbound Streams    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          Initial TSN                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/              Optional/Variable-Length Parameters              /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The INIT chunk contains the following parameters. Unless otherwise noted, each parameter MUST only be included once in the INIT chunk.",
      "ja": "initチャンクには、次のパラメーターが含まれています。特に明記しない限り、各パラメーターはinit chunkに1回しか含める必要があります。"
    },
    {
      "indent": 9,
      "text": "Fixed Parameters                     Status\n----------------------------------------------\nInitiate Tag                        Mandatory\nAdvertised Receiver Window Credit   Mandatory\nNumber of Outbound Streams          Mandatory\nNumber of Inbound Streams           Mandatory\nInitial TSN                         Mandatory",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Variable Parameters                  Status     Type Value\n-------------------------------------------------------------\nIPv4 Address (Note 1)               Optional    5\nIPv6 Address (Note 1)               Optional    6\nCookie Preservative                 Optional    9\nReserved for ECN Capable (Note 2)   Optional    32768 (0x8000)\nHost Name Address (Note 3)          Optional    11\nSupported Address Types (Note 4)    Optional    12",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note 1: The INIT chunks can contain multiple addresses that can be IPv4 and/or IPv6 in any combination.",
      "ja": "注1：initチャンクには、任意の組み合わせでIPv4および/またはIPv6になる可能性のある複数のアドレスを含めることができます。"
    },
    {
      "indent": 3,
      "text": "Note 2: The ECN capable field is reserved for future use of Explicit Congestion Notification.",
      "ja": "注2：ECN有能フィールドは、明示的な輻輳通知の将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "Note 3: An INIT chunk MUST NOT contain more than one Host Name address parameter. Moreover, the sender of the INIT MUST NOT combine any other address types with the Host Name address in the INIT. The receiver of INIT MUST ignore any other address types if the Host Name address parameter is present in the received INIT chunk.",
      "ja": "注3：initチャンクには、ホスト名アドレスパラメーターを1つ以上含めてはなりません。さらに、initの送信者は、他のアドレスタイプとINITのホスト名アドレスを組み合わせるべきではありません。initの受信者は、受信したinitチャンクにホスト名アドレスパラメーターが存在する場合、他のアドレスタイプを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note 4: This parameter, when present, specifies all the address types the sending endpoint can support. The absence of this parameter indicates that the sending endpoint can support any address type.",
      "ja": "注4：このパラメーターは、存在する場合、送信エンドポイントがサポートできるすべてのアドレスタイプを指定します。このパラメーターがないことは、送信エンドポイントが任意のアドレスタイプをサポートできることを示しています。"
    },
    {
      "indent": 3,
      "text": "The Chunk Flags field in INIT is reserved and all bits in it should be set to 0 by the sender and ignored by the receiver. The sequence of parameters within an INIT can be processed in any order.",
      "ja": "initのチャンクフラグフィールドは予約されており、その中のすべてのビットは送信者によって0に設定され、レシーバーによって無視される必要があります。init内のパラメーターのシーケンスは、任意の順序で処理できます。"
    },
    {
      "indent": 3,
      "text": "Initiate Tag: 32 bits (unsigned integer)",
      "ja": "タグを開始：32ビット（署名のない整数）"
    },
    {
      "indent": 6,
      "text": "The receiver of the INIT (the responding end) records the value of the Initiate Tag parameter. This value MUST be placed into the Verification Tag field of every SCTP packet that the receiver of the INIT transmits within this association.",
      "ja": "initの受信者（応答端）は、initiateタグパラメーターの値を記録します。この値は、initの受信者がこの関連付け内に送信するすべてのSCTPパケットの検証タグフィールドに配置する必要があります。"
    },
    {
      "indent": 6,
      "text": "The Initiate Tag is allowed to have any value except 0. See Section 5.3.1 for more on the selection of the tag value.",
      "ja": "Initiateタグには、0以外の値が許可されます。タグ値の選択については、セクション5.3.1を参照してください。"
    },
    {
      "indent": 6,
      "text": "If the value of the Initiate Tag in a received INIT chunk is found to be 0, the receiver MUST treat it as an error and close the association by transmitting an ABORT.",
      "ja": "受信したinitチャンクの開始タグの値が0であることが判明した場合、受信者はそれをエラーとして扱い、中止を送信することにより関連性を閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "Advertised Receiver Window Credit (a_rwnd): 32 bits (unsigned integer)",
      "ja": "広告レシーバーウィンドウクレジット（A_RWND）：32ビット（署名されていない整数）"
    },
    {
      "indent": 6,
      "text": "This value represents the dedicated buffer space, in number of bytes, the sender of the INIT has reserved in association with this window. During the life of the association this buffer space SHOULD not be lessened (i.e. dedicated buffers taken away from this association); however, an endpoint MAY change the value of a_rwnd it sends in SACK chunks.",
      "ja": "この値は、専用のバッファー空間を表します。これは、バイト数で、このウィンドウに関連してinitの送信者が予約されています。協会の存続期間中、このバッファースペースを減らすべきではありません（つまり、この協会から奪われた専用のバッファー）。ただし、エンドポイントは、サックチャンクで送信するA_RWNDの値を変更する場合があります。"
    },
    {
      "indent": 3,
      "text": "Number of Outbound Streams (OS): 16 bits (unsigned integer)",
      "ja": "アウトバウンドストリームの数（OS）：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Defines the number of outbound streams the sender of this INIT chunk wishes to create in this association. The value of 0 MUST NOT be used.",
      "ja": "このInit Chunkの送信者がこの協会で作成したいという送信者の数を定義します。0の値を使用してはなりません。"
    },
    {
      "indent": 6,
      "text": "Note: A receiver of an INIT with the OS value set to 0 SHOULD abort the association.",
      "ja": "注：OS値が0に設定されたinitの受信者は、関連性を中止する必要があります。"
    },
    {
      "indent": 3,
      "text": "Number of Inbound Streams (MIS) : 16 bits (unsigned integer)",
      "ja": "インバウンドストリームの数（MIS）：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Defines the maximum number of streams the sender of this INIT chunk allows the peer end to create in this association. The value 0 MUST NOT be used.",
      "ja": "このinit Chunkの送信者がピアエンドをこの協会で作成できるストリームの最大数を定義します。値0を使用してはなりません。"
    },
    {
      "indent": 6,
      "text": "Note: There is no negotiation of the actual number of streams but instead the two endpoints will use the min(requested, offered). See Section 5.1.1 for details.",
      "ja": "注：実際のストリーム数の交渉はありませんが、代わりに2つのエンドポイントはMIN（要求、提供された）を使用します。詳細については、セクション5.1.1を参照してください。"
    },
    {
      "indent": 6,
      "text": "Note: A receiver of an INIT with the MIS value of 0 SHOULD abort the association.",
      "ja": "注：0のMIS値を持つinitの受信者は、関連性を中止する必要があります。"
    },
    {
      "indent": 3,
      "text": "Initial TSN (I-TSN) : 32 bits (unsigned integer)",
      "ja": "初期TSN（I-TSN）：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Defines the initial TSN that the sender will use. The valid range is from 0 to 4294967295. This field MAY be set to the value of the Initiate Tag field.",
      "ja": "送信者が使用する最初のTSNを定義します。有効な範囲は0〜4294967295です。このフィールドは、開始タグフィールドの値に設定できます。"
    },
    {
      "indent": 0,
      "text": "3.3.2.1 Optional/Variable Length Parameters in INIT",
      "section_title": true,
      "ja": "3.3.2.1 initのオプション/可変長パラメーター"
    },
    {
      "indent": 3,
      "text": "The following parameters follow the Type-Length-Value format as defined in Section 3.2.1. Any Type-Length-Value fields MUST come after the fixed-length fields defined in the previous section.",
      "ja": "次のパラメーターは、セクション3.2.1で定義されているタイプ長価値形式に従います。任意のタイプ長価値フィールドは、前のセクションで定義された固定長フィールドの後に来る必要があります。"
    },
    {
      "indent": 3,
      "text": "IPv4 Address Parameter (5)",
      "ja": "IPv4アドレスパラメーター（5）"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Type = 5               |      Length = 8               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        IPv4 Address                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "IPv4 Address: 32 bits (unsigned integer)",
      "ja": "IPv4アドレス：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Contains an IPv4 address of the sending endpoint. It is binary encoded.",
      "ja": "送信エンドポイントのIPv4アドレスが含まれています。バイナリエンコードされています。"
    },
    {
      "indent": 3,
      "text": "IPv6 Address Parameter (6)",
      "ja": "IPv6アドレスパラメーター（6）"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            Type = 6           |          Length = 20          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                         IPv6 Address                          |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "IPv6 Address: 128 bit (unsigned integer)",
      "ja": "IPv6アドレス：128ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Contains an IPv6 address of the sending endpoint. It is binary encoded.",
      "ja": "送信エンドポイントのIPv6アドレスが含まれています。バイナリエンコードされています。"
    },
    {
      "indent": 6,
      "text": "Note: A sender MUST NOT use an IPv4-mapped IPv6 address [RFC2373] but should instead use an IPv4 Address Parameter for an IPv4 address.",
      "ja": "注：送信者は、IPv4-Mapped IPv6アドレス[RFC2373]を使用してはなりませんが、代わりにIPv4アドレスにIPv4アドレスパラメーターを使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "Combined with the Source Port Number in the SCTP common header, the value passed in an IPv4 or IPv6 Address parameter indicates a transport address the sender of the INIT will support for the association being initiated. That is, during the lifetime of this association, this IP address can appear in the source address field of an IP datagram sent from the sender of the INIT, and can be used as a destination address of an IP datagram sent from the receiver of the INIT.",
      "ja": "SCTP共通ヘッダーのソースポート番号と組み合わせることで、IPv4またはIPv6アドレスパラメーターで渡される値は、INITの送信者が開始される関連付けをサポートするトランスポートアドレスを示します。つまり、この関連付けの存続期間中、このIPアドレスは、INITの送信者から送信されたIPデータグラムのソースアドレスフィールドに表示され、の受信者から送信されたIPデータグラムの宛先アドレスとして使用できます。初期化。"
    },
    {
      "indent": 6,
      "text": "More than one IP Address parameter can be included in an INIT chunk when the INIT sender is multi-homed. Moreover, a multi-homed endpoint may have access to different types of network, thus more than one address type can be present in one INIT chunk, i.e., IPv4 and IPv6 addresses are allowed in the same INIT chunk.",
      "ja": "INIT送信者がマルチホームされている場合、INITチャンクに複数のIPアドレスパラメーターを含めることができます。さらに、マルチホームのエンドポイントは異なるタイプのネットワークにアクセスできる場合があるため、1つのinitチャンクに複数のアドレスタイプが存在する可能性があります。"
    },
    {
      "indent": 6,
      "text": "If the INIT contains at least one IP Address parameter, then the source address of the IP datagram containing the INIT chunk and any additional address(es) provided within the INIT can be used as destinations by the endpoint receiving the INIT. If the INIT does not contain any IP Address parameters, the endpoint receiving the INIT MUST use the source address associated with the received IP datagram as its sole destination address for the association.",
      "ja": "initに少なくとも1つのIPアドレスパラメーターが含まれている場合、initチャンクを含むIPデータグラムのソースアドレスと、init内で提供される追加のアドレスを含む任意のアドレスは、initを受信するエンドポイントによって目的地として使用できます。INITにIPアドレスパラメーターが含まれていない場合、INITを受信するエンドポイントは、受信したIPデータグラムに関連付けられたソースアドレスを、関連付けの唯一の宛先アドレスとして使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "Note that not using any IP address parameters in the INIT and INIT-ACK is an alternative to make an association more likely to work across a NAT box.",
      "ja": "initとinit-ackでIPアドレスパラメーターを使用しないことは、AssociationがNATボックスで動作する可能性が高くなるための代替手段であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Cookie Preservative (9)",
      "ja": "クッキー防腐剤（9）"
    },
    {
      "indent": 6,
      "text": "The sender of the INIT shall use this parameter to suggest to the receiver of the INIT for a longer life-span of the State Cookie.",
      "ja": "initの送信者は、このパラメーターを使用して、州のクッキーのより長い寿命のためにinitの受信者に提案するものとします。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Type = 9             |          Length = 8           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Suggested Cookie Life-span Increment (msec.)          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Suggested Cookie Life-span Increment: 32 bits (unsigned integer)",
      "ja": "提案されたクッキーライフスパン増分：32ビット（署名されていない整数）"
    },
    {
      "indent": 6,
      "text": "This parameter indicates to the receiver how much increment in milliseconds the sender wishes the receiver to add to its default cookie life-span.",
      "ja": "このパラメーターは、送信者がレシーバーにデフォルトのCookie Life-Spanに追加することを望んでいるミリ秒単位でどれだけの増分を受信者に示します。"
    },
    {
      "indent": 6,
      "text": "This optional parameter should be added to the INIT chunk by the sender when it re-attempts establishing an association with a peer to which its previous attempt of establishing the association failed due to a stale cookie operation error. The receiver MAY choose to ignore the suggested cookie life-span increase for its own security reasons.",
      "ja": "このオプションのパラメーターは、陳腐化するクッキー操作エラーのために関連性を確立する以前の試みが失敗したピアとの関連を確立することを再検討するときに、送信者によってinitチャンクに追加される必要があります。受信者は、独自のセキュリティ上の理由で提案されたCookieのライフスパンの増加を無視することを選択できます。"
    },
    {
      "indent": 3,
      "text": "Host Name Address (11)",
      "ja": "ホスト名アドレス（11）"
    },
    {
      "indent": 6,
      "text": "The sender of INIT uses this parameter to pass its Host Name (in place of its IP addresses) to its peer. The peer is responsible for resolving the name. Using this parameter might make it more likely for the association to work across a NAT box.",
      "ja": "initの送信者は、このパラメーターを使用して、ホスト名（IPアドレスの代わりに）をピアに渡します。ピアは名前を解決する責任があります。このパラメーターを使用すると、AssociationがNATボックスで動作する可能性が高くなる可能性があります。"
    },
    {
      "indent": 6,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Type = 11            |          Length               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                          Host Name                            /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Host Name: variable length",
      "ja": "ホスト名：変数長"
    },
    {
      "indent": 6,
      "text": "This field contains a host name in \"host name syntax\" per RFC1123 Section 2.1 [RFC1123]. The method for resolving the host name is out of scope of SCTP.",
      "ja": "このフィールドには、RFC1123セクション2.1 [RFC1123]ごとに「ホスト名構文」にホスト名が含まれています。ホスト名を解決する方法は、SCTPの範囲外です。"
    },
    {
      "indent": 6,
      "text": "Note: At least one null terminator is included in the Host Name string and must be included in the length.",
      "ja": "注：少なくとも1つのnullターミネーターがホスト名文字列に含まれており、長さに含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Supported Address Types (12)",
      "ja": "サポートされているアドレスタイプ（12）"
    },
    {
      "indent": 6,
      "text": "The sender of INIT uses this parameter to list all the address types it can support.",
      "ja": "initの送信者は、このパラメーターを使用して、サポートできるすべてのアドレスタイプをリストします。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Type = 12            |          Length               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Address Type #1        |        Address Type #2        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        ......\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Address Type: 16 bits (unsigned integer)",
      "ja": "アドレスタイプ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This is filled with the type value of the corresponding address TLV (e.g., IPv4 = 5, IPv6 = 6, Hostname = 11).",
      "ja": "これは、対応するアドレスTLVのタイプ値（例：IPv4 = 5、IPv6 = 6、ホスト名= 11）で満たされています。"
    },
    {
      "indent": 0,
      "text": "3.3.3 Initiation Acknowledgement (INIT ACK) (2):",
      "ja": "3.3.3 開始承認（init ack）（2）："
    },
    {
      "indent": 3,
      "text": "The INIT ACK chunk is used to acknowledge the initiation of an SCTP association.",
      "ja": "init ackチャンクは、SCTP協会の開始を認めるために使用されます。"
    },
    {
      "indent": 3,
      "text": "The parameter part of INIT ACK is formatted similarly to the INIT chunk. It uses two extra variable parameters: The State Cookie and the Unrecognized Parameter:",
      "ja": "init ackのパラメーター部分は、initチャンクと同様にフォーマットされます。2つの追加の変数パラメーターを使用します。状態Cookieと認識されていないパラメーター："
    },
    {
      "indent": 3,
      "text": "The format of the INIT ACK chunk is shown below:",
      "ja": "init ackチャンクの形式を以下に示します。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 2    |  Chunk Flags  |      Chunk Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Initiate Tag                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|              Advertised Receiver Window Credit                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Number of Outbound Streams   |  Number of Inbound Streams    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          Initial TSN                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/              Optional/Variable-Length Parameters              /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Initiate Tag: 32 bits (unsigned integer)",
      "ja": "タグを開始：32ビット（署名のない整数）"
    },
    {
      "indent": 6,
      "text": "The receiver of the INIT ACK records the value of the Initiate Tag parameter. This value MUST be placed into the Verification Tag field of every SCTP packet that the INIT ACK receiver transmits within this association.",
      "ja": "INIT ACKの受信者は、Initiateタグパラメーターの値を記録します。この値は、INIT ACKレシーバーがこの関連付け内で送信するすべてのSCTPパケットの検証タグフィールドに配置する必要があります。"
    },
    {
      "indent": 6,
      "text": "The Initiate Tag MUST NOT take the value 0. See Section 5.3.1 for more on the selection of the Initiate Tag value.",
      "ja": "Initiateタグは値0を取得してはなりません。EtiateAteタグ値の選択の詳細については、セクション5.3.1を参照してください。"
    },
    {
      "indent": 6,
      "text": "If the value of the Initiate Tag in a received INIT ACK chunk is found to be 0, the receiver MUST treat it as an error and close the association by transmitting an ABORT.",
      "ja": "受信したInitACKチャンクの開始タグの値が0であることがわかった場合、受信者はそれをエラーとして扱い、中止を送信することにより関連性を閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "Advertised Receiver Window Credit (a_rwnd): 32 bits (unsigned integer)",
      "ja": "広告レシーバーウィンドウクレジット（A_RWND）：32ビット（署名されていない整数）"
    },
    {
      "indent": 6,
      "text": "This value represents the dedicated buffer space, in number of bytes, the sender of the INIT ACK has reserved in association with this window. During the life of the association this buffer space SHOULD not be lessened (i.e. dedicated buffers taken away from this association).",
      "ja": "この値は、専用のバッファー空間を表します。バイト数で、init ACKの送信者はこのウィンドウに関連して予約されています。協会の存続期間中、このバッファースペースを減らすべきではありません（つまり、この協会から奪われた専用バッファー）。"
    },
    {
      "indent": 3,
      "text": "Number of Outbound Streams (OS): 16 bits (unsigned integer)",
      "ja": "アウトバウンドストリームの数（OS）：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Defines the number of outbound streams the sender of this INIT ACK chunk wishes to create in this association. The value of 0 MUST NOT be used.",
      "ja": "このINIT ACK Chunkの送信者がこの協会で作成したいと思うアウトバウンドストリームの数を定義します。0の値を使用してはなりません。"
    },
    {
      "indent": 6,
      "text": "Note: A receiver of an INIT ACK with the OS value set to 0 SHOULD destroy the association discarding its TCB.",
      "ja": "注：OS値が0に設定されたINIT ACKの受信機は、TCBを破棄する関連付けを破壊するはずです。"
    },
    {
      "indent": 3,
      "text": "Number of Inbound Streams (MIS) : 16 bits (unsigned integer)",
      "ja": "インバウンドストリームの数（MIS）：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Defines the maximum number of streams the sender of this INIT ACK chunk allows the peer end to create in this association. The value 0 MUST NOT be used.",
      "ja": "このinit ackチャンクの送信者がピアエンドをこの協会で作成できるストリームの最大数を定義します。値0を使用してはなりません。"
    },
    {
      "indent": 6,
      "text": "Note: There is no negotiation of the actual number of streams but instead the two endpoints will use the min(requested, offered). See Section 5.1.1 for details.",
      "ja": "注：実際のストリーム数の交渉はありませんが、代わりに2つのエンドポイントはMIN（要求、提供された）を使用します。詳細については、セクション5.1.1を参照してください。"
    },
    {
      "indent": 6,
      "text": "Note: A receiver of an INIT ACK with the MIS value set to 0 SHOULD destroy the association discarding its TCB.",
      "ja": "注：MIS値が0に設定されたINIT ACKの受信機は、TCBを破棄する協会を破壊するはずです。"
    },
    {
      "indent": 3,
      "text": "Initial TSN (I-TSN) : 32 bits (unsigned integer)",
      "ja": "初期TSN（I-TSN）：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Defines the initial TSN that the INIT-ACK sender will use. The valid range is from 0 to 4294967295. This field MAY be set to the value of the Initiate Tag field.",
      "ja": "init-ack送信者が使用する最初のTSNを定義します。有効な範囲は0〜4294967295です。このフィールドは、開始タグフィールドの値に設定できます。"
    },
    {
      "indent": 6,
      "text": "Fixed Parameters                     Status\n----------------------------------------------\nInitiate Tag                        Mandatory\nAdvertised Receiver Window Credit   Mandatory\nNumber of Outbound Streams          Mandatory\nNumber of Inbound Streams           Mandatory\nInitial TSN                         Mandatory\n      Variable Parameters                  Status     Type Value\n-------------------------------------------------------------\nState Cookie                        Mandatory   7\nIPv4 Address (Note 1)               Optional    5\nIPv6 Address (Note 1)               Optional    6\nUnrecognized Parameters             Optional    8\nReserved for ECN Capable (Note 2)   Optional    32768 (0x8000)\nHost Name Address (Note 3)          Optional    11",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note 1: The INIT ACK chunks can contain any number of IP address parameters that can be IPv4 and/or IPv6 in any combination.",
      "ja": "注1：init ACKチャンクには、任意の組み合わせでIPv4および/またはIPv6になる可能性のあるIPアドレスパラメーターを任意の数に含めることができます。"
    },
    {
      "indent": 3,
      "text": "Note 2: The ECN capable field is reserved for future use of Explicit Congestion Notification.",
      "ja": "注2：ECN有能フィールドは、明示的な輻輳通知の将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "Note 3: The INIT ACK chunks MUST NOT contain more than one Host Name address parameter. Moreover, the sender of the INIT ACK MUST NOT combine any other address types with the Host Name address in the INIT ACK. The receiver of the INIT ACK MUST ignore any other address types if the Host Name address parameter is present.",
      "ja": "注3：init ackチャンクには、ホスト名アドレスパラメーターを1つ以上含めてはなりません。さらに、init ackの送信者は、他のアドレスタイプとinit ackのホスト名アドレスと組み合わせることはできません。INIT ACKの受信機は、ホスト名アドレスパラメーターが存在する場合、他のアドレスタイプを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: An implementation MUST be prepared to receive a INIT ACK that is quite large (more than 1500 bytes) due to the variable size of the state cookie AND the variable address list. For example if a responder to the INIT has 1000 IPv4 addresses it wishes to send, it would need at least 8,000 bytes to encode this in the INIT ACK.",
      "ja": "実装注：状態Cookieの変動サイズと変数アドレスリストのために、非常に大きい（1500バイト以上）INIT ACKを受信するために実装を準備する必要があります。たとえば、INITへのレスポンダーが送信したい1000のIPv4アドレスを持っている場合、INIT ACKでこれをエンコードするには少なくとも8,000バイトが必要になります。"
    },
    {
      "indent": 3,
      "text": "In combination with the Source Port carried in the SCTP common header, each IP Address parameter in the INIT ACK indicates to the receiver of the INIT ACK a valid transport address supported by the sender of the INIT ACK for the lifetime of the association being initiated.",
      "ja": "SCTP共通ヘッダーにあるソースポートと組み合わせて、init ACKの各IPアドレスパラメーターは、INIT ACKの受信者に、開始される協会の寿命のためにINIT ACKの送信者がサポートする有効な輸送アドレスを示します。"
    },
    {
      "indent": 3,
      "text": "If the INIT ACK contains at least one IP Address parameter, then the source address of the IP datagram containing the INIT ACK and any additional address(es) provided within the INIT ACK may be used as destinations by the receiver of the INIT-ACK. If the INIT ACK does not contain any IP Address parameters, the receiver of the INIT-ACK MUST use the source address associated with the received IP datagram as its sole destination address for the association.",
      "ja": "INIT ACKに少なくとも1つのIPアドレスパラメーターが含まれている場合、INIT ACKを含むIPデータグラムのソースアドレスとINIT ACK内で提供される追加アドレスを含む任意のアドレスは、init-ackの受信者によって宛先として使用できます。init ACKにIPアドレスパラメーターが含まれていない場合、INIT-ackの受信者は、受信したIPデータグラムに関連付けられたソースアドレスを、関連付けの唯一の宛先アドレスとして使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The State Cookie and Unrecognized Parameters use the Type-Length-Value format as defined in Section 3.2.1 and are described below. The other fields are defined the same as their counterparts in the INIT chunk.",
      "ja": "State Cookieおよび認識されていないパラメーターは、セクション3.2.1で定義されているタイプ長値形式を使用し、以下に説明します。他のフィールドは、init chunkのカウンターパートと同じと定義されています。"
    },
    {
      "indent": 0,
      "text": "3.3.3.1 Optional or Variable Length Parameters",
      "section_title": true,
      "ja": "3.3.3.1 オプションまたは変数の長さパラメーター"
    },
    {
      "indent": 3,
      "text": "State Cookie",
      "ja": "ステートクッキー"
    },
    {
      "indent": 6,
      "text": "Parameter Type Value: 7",
      "ja": "パラメータータイプ値：7"
    },
    {
      "indent": 6,
      "text": "Parameter Length: variable size, depending on Size of Cookie",
      "ja": "パラメーターの長さ：Cookieのサイズに応じて、可変サイズ"
    },
    {
      "indent": 6,
      "text": "Parameter Value:",
      "ja": "パラメーター値："
    },
    {
      "indent": 9,
      "text": "This parameter value MUST contain all the necessary state and parameter information required for the sender of this INIT ACK to create the association, along with a Message Authentication Code (MAC). See Section 5.1.3 for details on State Cookie definition.",
      "ja": "このパラメーター値には、メッセージ認証コード（MAC）とともに、このINIT ACKの送信者に必要なすべての必要な状態およびパラメーター情報を含める必要があります。State Cookieの定義の詳細については、セクション5.1.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Unrecognized Parameters:",
      "ja": "認識されていないパラメーター："
    },
    {
      "indent": 6,
      "text": "Parameter Type Value: 8",
      "ja": "パラメータータイプ値：8"
    },
    {
      "indent": 6,
      "text": "Parameter Length: Variable Size.",
      "ja": "パラメーター長：可変サイズ。"
    },
    {
      "indent": 6,
      "text": "Parameter Value:",
      "ja": "パラメーター値："
    },
    {
      "indent": 9,
      "text": "This parameter is returned to the originator of the INIT chunk when the INIT contains an unrecognized parameter which has a value that indicates that it should be reported to the sender. This parameter value field will contain unrecognized parameters copied from the INIT chunk complete with Parameter Type, Length and Value fields.",
      "ja": "このパラメーターは、initに送信者に報告されるべき値を示す値を持つ認識されていないパラメーターを含む場合、initチャンクの発信者に返されます。このパラメーター値フィールドには、パラメータータイプ、長さ、および値フィールドを備えたinitチャンクからコピーされた認識されていないパラメーターが含まれます。"
    },
    {
      "indent": 0,
      "text": "3.3.4 Selective Acknowledgement (SACK) (3):",
      "ja": "3.3.4 選択的承認（袋）（3）："
    },
    {
      "indent": 3,
      "text": "This chunk is sent to the peer endpoint to acknowledge received DATA chunks and to inform the peer endpoint of gaps in the received subsequences of DATA chunks as represented by their TSNs.",
      "ja": "このチャンクはピアエンドポイントに送信され、受信したデータチャンクを確認し、TSNSで表されるデータチャンクの受信サブセンスのギャップのピアエンドポイントに通知します。"
    },
    {
      "indent": 3,
      "text": "The SACK MUST contain the Cumulative TSN Ack and Advertised Receiver Window Credit (a_rwnd) parameters.",
      "ja": "袋には、累積TSN ACKと広告されたレシーバーウィンドウクレジット（A_RWND）パラメーターが含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "By definition, the value of the Cumulative TSN Ack parameter is the last TSN received before a break in the sequence of received TSNs occurs; the next TSN value following this one has not yet been received at the endpoint sending the SACK. This parameter therefore acknowledges receipt of all TSNs less than or equal to its value.",
      "ja": "定義上、累積TSN ACKパラメーターの値は、受信したTSNSのシーケンスの休憩が発生する前に受信した最後のTSNです。これに続く次のTSN値は、袋を送信するエンドポイントでまだ受信されていません。したがって、このパラメーターは、その値以下のすべてのTSNの受領を確認します。"
    },
    {
      "indent": 3,
      "text": "The handling of a_rwnd by the receiver of the SACK is discussed in detail in Section 6.2.1.",
      "ja": "袋の受信者によるA_RWNDの取り扱いについては、セクション6.2.1で詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "The SACK also contains zero or more Gap Ack Blocks. Each Gap Ack Block acknowledges a subsequence of TSNs received following a break in the sequence of received TSNs. By definition, all TSNs acknowledged by Gap Ack Blocks are greater than the value of the Cumulative TSN Ack.",
      "ja": "サックには、ゼロ以上のギャップACKブロックも含まれています。各GAP ACKブロックは、受信したTSNSのシーケンスの休憩後に受信されたTSNSのサブシーケンスを認めています。定義上、GAP ACKブロックによって認められるすべてのTSNは、累積TSN ACKの値よりも大きくなります。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 3    |Chunk  Flags   |      Chunk Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Cumulative TSN Ack                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Advertised Receiver Window Credit (a_rwnd)           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Number of Gap Ack Blocks = N  |  Number of Duplicate TSNs = X |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Gap Ack Block #1 Start       |   Gap Ack Block #1 End        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                                                               /\n\\                              ...                              \\\n/                                                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Gap Ack Block #N Start      |  Gap Ack Block #N End         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Duplicate TSN 1                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                                                               /\n\\                              ...                              \\\n/                                                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Duplicate TSN X                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 6,
      "text": "Set to all zeros on transmit and ignored on receipt.",
      "ja": "送信時にすべてのゼロに設定し、受領時に無視されます。"
    },
    {
      "indent": 3,
      "text": "Cumulative TSN Ack: 32 bits (unsigned integer)",
      "ja": "累積TSN ACK：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This parameter contains the TSN of the last DATA chunk received in sequence before a gap.",
      "ja": "このパラメーターには、ギャップの前に順番に受け取った最後のデータチャンクのTSNが含まれています。"
    },
    {
      "indent": 3,
      "text": "Advertised Receiver Window Credit (a_rwnd): 32 bits (unsigned integer)",
      "ja": "広告レシーバーウィンドウクレジット（A_RWND）：32ビット（署名されていない整数）"
    },
    {
      "indent": 6,
      "text": "This field indicates the updated receive buffer space in bytes of the sender of this SACK, see Section 6.2.1 for details.",
      "ja": "このフィールドは、このサックの送信者のバイトで更新された受信バッファースペースを示しています。詳細については、セクション6.2.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Number of Gap Ack Blocks: 16 bits (unsigned integer)",
      "ja": "ギャップACKブロックの数：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Indicates the number of Gap Ack Blocks included in this SACK.",
      "ja": "このサックに含まれるギャップACKブロックの数を示します。"
    },
    {
      "indent": 3,
      "text": "Number of Duplicate TSNs: 16 bit",
      "ja": "重複するTSNSの数：16ビット"
    },
    {
      "indent": 6,
      "text": "This field contains the number of duplicate TSNs the endpoint has received. Each duplicate TSN is listed following the Gap Ack Block list.",
      "ja": "このフィールドには、エンドポイントが受信した重複TSNの数が含まれています。各重複TSNは、GAP ACKブロックリストに従ってリストされています。"
    },
    {
      "indent": 3,
      "text": "Gap Ack Blocks:",
      "ja": "ギャップACKブロック："
    },
    {
      "indent": 6,
      "text": "These fields contain the Gap Ack Blocks. They are repeated for each Gap Ack Block up to the number of Gap Ack Blocks defined in the Number of Gap Ack Blocks field. All DATA chunks with TSNs greater than or equal to (Cumulative TSN Ack + Gap Ack Block Start) and less than or equal to (Cumulative TSN Ack + Gap Ack Block End) of each Gap Ack Block are assumed to have been received correctly.",
      "ja": "これらのフィールドには、ギャップACKブロックが含まれています。それらは、GAP ACKブロックの数で定義されているギャップACKブロックの数まで、各ギャップACKブロックについて繰り返されます。各ギャップACKブロックの（累積TSN ACKギャップACKブロック開始）以下（累積TSN ACKギャップACKブロックの開始）以下（累積TSN ACKギャップACKブロックの開始）以下のすべてのデータチャンクは、正しく受信されたと考えられています。"
    },
    {
      "indent": 3,
      "text": "Gap Ack Block Start: 16 bits (unsigned integer)",
      "ja": "ギャップACKブロック開始：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Indicates the Start offset TSN for this Gap Ack Block. To calculate the actual TSN number the Cumulative TSN Ack is added to this offset number. This calculated TSN identifies the first TSN in this Gap Ack Block that has been received.",
      "ja": "このギャップACKブロックの開始オフセットTSNを示します。実際のTSN番号を計算するために、このオフセット番号に累積TSN ACKが追加されます。この計算されたTSNは、受信されたこのギャップACKブロックの最初のTSNを識別します。"
    },
    {
      "indent": 3,
      "text": "Gap Ack Block End: 16 bits (unsigned integer)",
      "ja": "ギャップACKブロックエンド：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Indicates the End offset TSN for this Gap Ack Block. To calculate the actual TSN number the Cumulative TSN Ack is added to this offset number. This calculated TSN identifies the TSN of the last DATA chunk received in this Gap Ack Block.",
      "ja": "このギャップACKブロックの終了オフセットTSNを示します。実際のTSN番号を計算するために、このオフセット番号に累積TSN ACKが追加されます。この計算されたTSNは、このギャップACKブロックで受信した最後のデータチャンクのTSNを識別します。"
    },
    {
      "indent": 3,
      "text": "For example, assume the receiver has the following DATA chunks newly arrived at the time when it decides to send a Selective ACK,",
      "ja": "たとえば、受信者が選択的なACKを送信することを決定したときに新たに到着した次のデータチャンクがあると仮定します。"
    },
    {
      "indent": 24,
      "text": "----------\n| TSN=17 |\n----------\n|        | <- still missing\n----------\n| TSN=15 |\n----------\n| TSN=14 |\n----------\n|        | <- still missing\n----------\n| TSN=12 |\n----------\n| TSN=11 |\n----------\n| TSN=10 |\n----------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "then, the parameter part of the SACK MUST be constructed as follows (assuming the new a_rwnd is set to 4660 by the sender):",
      "ja": "次に、サックのパラメーター部分を次のように構築する必要があります（新しいA_RWNDが送信者によって4660に設定されていると仮定します）。"
    },
    {
      "indent": 18,
      "text": "+--------------------------------+\n|   Cumulative TSN Ack = 12      |\n+--------------------------------+\n|        a_rwnd = 4660           |\n+----------------+---------------+\n| num of block=2 | num of dup=0  |\n+----------------+---------------+\n|block #1 strt=2 |block #1 end=3 |\n+----------------+---------------+\n|block #2 strt=5 |block #2 end=5 |\n+----------------+---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Duplicate TSN: 32 bits (unsigned integer)",
      "ja": "重複TSN：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Indicates the number of times a TSN was received in duplicate since the last SACK was sent. Every time a receiver gets a duplicate TSN (before sending the SACK) it adds it to the list of duplicates. The duplicate count is re-initialized to zero after sending each SACK.",
      "ja": "最後の袋が送信されてから、TSNが重複して受信した回数を示します。レシーバーが（袋を送信する前に）重複するTSNを取得するたびに、複製のリストに追加します。重複カウントは、各袋を送信した後、ゼロに再初期化されます。"
    },
    {
      "indent": 6,
      "text": "For example, if a receiver were to get the TSN 19 three times it would list 19 twice in the outbound SACK. After sending the SACK if it received yet one more TSN 19 it would list 19 as a duplicate once in the next outgoing SACK.",
      "ja": "たとえば、受信者がTSN 19を3回取得する場合、アウトバウンドサックに19を2回リストします。もう1つのTSN 19を受け取った場合、袋を送信した後、次の発信袋で1回複製として19をリストします。"
    },
    {
      "indent": 0,
      "text": "3.3.5 Heartbeat Request (HEARTBEAT) (4):",
      "ja": "3.3.5 ハートビートリクエスト（ハートビート）（4）："
    },
    {
      "indent": 3,
      "text": "An endpoint should send this chunk to its peer endpoint to probe the reachability of a particular destination transport address defined in the present association.",
      "ja": "エンドポイントは、このチャンクをピアエンドポイントに送信して、現在の協会で定義されている特定の宛先輸送アドレスの到達可能性を調査する必要があります。"
    },
    {
      "indent": 3,
      "text": "The parameter field contains the Heartbeat Information which is a variable length opaque data structure understood only by the sender.",
      "ja": "パラメーターフィールドには、送信者のみが理解する可変長さの不透明なデータ構造であるハートビート情報が含まれています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 4    | Chunk  Flags  |      Heartbeat Length         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/            Heartbeat Information TLV (Variable-Length)        /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 6,
      "text": "Set to zero on transmit and ignored on receipt.",
      "ja": "送信時にゼロに設定され、受領時に無視されます。"
    },
    {
      "indent": 3,
      "text": "Heartbeat Length: 16 bits (unsigned integer)",
      "ja": "ハートビートの長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Set to the size of the chunk in bytes, including the chunk header and the Heartbeat Information field.",
      "ja": "チャンクヘッダーやハートビート情報フィールドなど、バイトのチャンクのサイズに設定されています。"
    },
    {
      "indent": 3,
      "text": "Heartbeat Information: variable length",
      "ja": "ハートビート情報：可変長"
    },
    {
      "indent": 6,
      "text": "Defined as a variable-length parameter using the format described in Section 3.2.1, i.e.:",
      "ja": "セクション3.2.1で説明されている形式を使用して、可変長パラメーターとして定義されています。"
    },
    {
      "indent": 6,
      "text": "Variable Parameters                  Status     Type Value\n-------------------------------------------------------------\nHeartbeat Info                       Mandatory   1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Heartbeat Info Type=1      |         HB Info Length        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                  Sender-specific Heartbeat Info               /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      The Sender-specific Heartbeat Info field should normally include\ninformation about the sender's current time when this HEARTBEAT\nchunk is sent and the destination transport address to which this\nHEARTBEAT is sent (see Section 8.3).",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3.6 Heartbeat Acknowledgement (HEARTBEAT ACK) (5):",
      "ja": "3.3.6 ハートビートの謝辞（ハートビートACK）（5）："
    },
    {
      "indent": 3,
      "text": "An endpoint should send this chunk to its peer endpoint as a response to a HEARTBEAT chunk (see Section 8.3). A HEARTBEAT ACK is always sent to the source IP address of the IP datagram containing the HEARTBEAT chunk to which this ack is responding.",
      "ja": "エンドポイントは、ハートビートチャンクへの応答として、このチャンクをピアエンドポイントに送信する必要があります（セクション8.3を参照）。ハートビートACKは、このACKが応答しているハートビートチャンクを含むIPデータグラムのソースIPアドレスに常に送信されます。"
    },
    {
      "indent": 3,
      "text": "The parameter field contains a variable length opaque data structure.",
      "ja": "パラメーターフィールドには、可変長さの不透明なデータ構造が含まれています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 5    | Chunk  Flags  |    Heartbeat Ack Length       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/            Heartbeat Information TLV (Variable-Length)        /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 6,
      "text": "Set to zero on transmit and ignored on receipt.",
      "ja": "送信時にゼロに設定され、受領時に無視されます。"
    },
    {
      "indent": 3,
      "text": "Heartbeat Ack Length: 16 bits (unsigned integer)",
      "ja": "ハートビートACK長：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Set to the size of the chunk in bytes, including the chunk header and the Heartbeat Information field.",
      "ja": "チャンクヘッダーやハートビート情報フィールドなど、バイトのチャンクのサイズに設定されています。"
    },
    {
      "indent": 3,
      "text": "Heartbeat Information: variable length",
      "ja": "ハートビート情報：可変長"
    },
    {
      "indent": 6,
      "text": "This field MUST contain the Heartbeat Information parameter of the Heartbeat Request to which this Heartbeat Acknowledgement is responding.",
      "ja": "このフィールドには、このハートビートの確認が応答しているハートビートリクエストのハートビート情報パラメーターを含める必要があります。"
    },
    {
      "indent": 6,
      "text": "Variable Parameters                  Status     Type Value\n-------------------------------------------------------------\nHeartbeat Info                       Mandatory   1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3.7 Abort Association (ABORT) (6):",
      "ja": "3.3.7 中止協会（中止）（6）："
    },
    {
      "indent": 3,
      "text": "The ABORT chunk is sent to the peer of an association to close the association. The ABORT chunk may contain Cause Parameters to inform the receiver the reason of the abort. DATA chunks MUST NOT be bundled with ABORT. Control chunks (except for INIT, INIT ACK and SHUTDOWN COMPLETE) MAY be bundled with an ABORT but they MUST be placed before the ABORT in the SCTP packet, or they will be ignored by the receiver.",
      "ja": "中止チャンクは、協会を閉鎖するために協会のピアに送られます。中止チャンクには、原因のパラメーターが含まれている場合があり、受信者に中止の理由を通知します。データチャンクを中止にバンドルしてはなりません。コントロールチャンク（init、init ack、およびshutdown completeを除く）は、中止にバンドルされる場合がありますが、sctpパケットに中止する前に配置する必要があります。または、レシーバーによって無視されます。"
    },
    {
      "indent": 3,
      "text": "If an endpoint receives an ABORT with a format error or for an association that doesn't exist, it MUST silently discard it. Moreover, under any circumstances, an endpoint that receives an ABORT MUST NOT respond to that ABORT by sending an ABORT of its own.",
      "ja": "エンドポイントがフォーマットエラーまたは存在しない関連付けの場合、中止を受信した場合、静かに破棄する必要があります。さらに、いかなる状況でも、中止を受け取るエンドポイントは、独自の中止を送信してその中断に応答してはなりません。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 6    |Reserved     |T|           Length              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/                   zero or more Error Causes                   /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 3,
      "text": "Reserved: 7 bits",
      "ja": "予約済み：7ビット"
    },
    {
      "indent": 6,
      "text": "Set to 0 on transmit and ignored on receipt.",
      "ja": "送信時に0に設定され、受領時に無視されます。"
    },
    {
      "indent": 3,
      "text": "T bit: 1 bit",
      "ja": "Tビット：1ビット"
    },
    {
      "indent": 6,
      "text": "The T bit is set to 0 if the sender had a TCB that it destroyed. If the sender did not have a TCB it should set this bit to 1.",
      "ja": "送信者が破壊したTCBを持っていた場合、tビットは0に設定されます。送信者がTCBを持っていなかった場合、このビットを1に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: Special rules apply to this chunk for verification, please see Section 8.5.1 for details.",
      "ja": "注：検証のためにこのチャンクに特別なルールが適用されます。詳細については、セクション8.5.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Length: 16 bits (unsigned integer)",
      "ja": "長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Set to the size of the chunk in bytes, including the chunk header and all the Error Cause fields present.",
      "ja": "チャンクヘッダーとすべてのエラー原因フィールドを含む、バイトのチャンクのサイズに設定されています。"
    },
    {
      "indent": 3,
      "text": "See Section 3.3.10 for Error Cause definitions.",
      "ja": "エラー原因の定義については、セクション3.3.10を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.3.8 Shutdown Association (SHUTDOWN) (7):",
      "ja": "3.3.8 シャットダウン協会（シャットダウン）（7）："
    },
    {
      "indent": 3,
      "text": "An endpoint in an association MUST use this chunk to initiate a graceful close of the association with its peer. This chunk has the following format.",
      "ja": "協会のエンドポイントは、このチャンクを使用して、そのピアとの関連性の優雅な密接を開始する必要があります。このチャンクには次の形式があります。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 7    | Chunk  Flags  |      Length = 8               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Cumulative TSN Ack                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 6,
      "text": "Set to zero on transmit and ignored on receipt.",
      "ja": "送信時にゼロに設定され、受領時に無視されます。"
    },
    {
      "indent": 3,
      "text": "Length: 16 bits (unsigned integer)",
      "ja": "長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Indicates the length of the parameter. Set to 8.",
      "ja": "パラメーターの長さを示します。8に設定します。"
    },
    {
      "indent": 3,
      "text": "Cumulative TSN Ack: 32 bits (unsigned integer)",
      "ja": "累積TSN ACK：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This parameter contains the TSN of the last chunk received in sequence before any gaps.",
      "ja": "このパラメーターには、ギャップの前に順番に受け取った最後のチャンクのTSNが含まれています。"
    },
    {
      "indent": 6,
      "text": "Note: Since the SHUTDOWN message does not contain Gap Ack Blocks, it cannot be used to acknowledge TSNs received out of order. In a SACK, lack of Gap Ack Blocks that were previously included indicates that the data receiver reneged on the associated DATA chunks. Since SHUTDOWN does not contain Gap Ack Blocks, the receiver of the SHUTDOWN shouldn't interpret the lack of a Gap Ack Block as a renege. (see Section 6.2 for information on reneging)",
      "ja": "注：シャットダウンメッセージにはギャップACKブロックが含まれていないため、故障したTSNを確認するために使用することはできません。袋では、以前に含まれていたギャップACKブロックの欠如は、関連するデータチャンクでre辱されたデータ受信機が示されています。シャットダウンにはギャップACKブロックが含まれていないため、シャットダウンの受信者は、ギャップACKブロックの欠如をRenegeとして解釈してはなりません。（Renegingの詳細については、セクション6.2を参照してください）"
    },
    {
      "indent": 0,
      "text": "3.3.9 Shutdown Acknowledgement (SHUTDOWN ACK) (8):",
      "ja": "3.3.9 シャットダウン承認（シャットダウンACK）（8）："
    },
    {
      "indent": 3,
      "text": "This chunk MUST be used to acknowledge the receipt of the SHUTDOWN chunk at the completion of the shutdown process, see Section 9.2 for details.",
      "ja": "このチャンクは、シャットダウンプロセスの完了時にシャットダウンチャンクの受領を確認するために使用する必要があります。詳細については、セクション9.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "The SHUTDOWN ACK chunk has no parameters.",
      "ja": "シャットダウンACKチャンクにはパラメーターがありません。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 8    |Chunk  Flags   |      Length = 4               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 6,
      "text": "Set to zero on transmit and ignored on receipt.",
      "ja": "送信時にゼロに設定され、受領時に無視されます。"
    },
    {
      "indent": 0,
      "text": "3.3.10 Operation Error (ERROR) (9):",
      "ja": "3.3.10 操作エラー（エラー）（9）："
    },
    {
      "indent": 3,
      "text": "An endpoint sends this chunk to its peer endpoint to notify it of certain error conditions. It contains one or more error causes. An Operation Error is not considered fatal in and of itself, but may be used with an ABORT chunk to report a fatal condition. It has the following parameters:",
      "ja": "エンドポイントは、このチャンクをピアエンドポイントに送信して、特定のエラー条件を通知します。1つ以上のエラー原因が含まれています。操作エラーはそれ自体で致命的ではないとは見なされませんが、致命的な状態を報告するために中止塊で使用される場合があります。次のパラメーターがあります。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 9    | Chunk  Flags  |           Length              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/                    one or more Error Causes                   /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 6,
      "text": "Set to zero on transmit and ignored on receipt.",
      "ja": "送信時にゼロに設定され、受領時に無視されます。"
    },
    {
      "indent": 3,
      "text": "Length: 16 bits (unsigned integer)",
      "ja": "長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Set to the size of the chunk in bytes, including the chunk header and all the Error Cause fields present.",
      "ja": "チャンクヘッダーとすべてのエラー原因フィールドを含む、バイトのチャンクのサイズに設定されています。"
    },
    {
      "indent": 3,
      "text": "Error causes are defined as variable-length parameters using the format described in 3.2.1, i.e.:",
      "ja": "エラーの原因は、3.2.1、つまり、次の形式を使用して可変長パラメーターとして定義されます。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Cause Code          |       Cause Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                    Cause-specific Information                 /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Cause Code: 16 bits (unsigned integer)",
      "ja": "原因コード：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Defines the type of error conditions being reported.",
      "ja": "報告されているエラー条件のタイプを定義します。"
    },
    {
      "indent": 6,
      "text": "Cause Code\nValue           Cause Code\n---------      ----------------\n 1              Invalid Stream Identifier\n 2              Missing Mandatory Parameter\n 3              Stale Cookie Error\n 4              Out of Resource\n 5              Unresolvable Address\n 6              Unrecognized Chunk Type\n 7              Invalid Mandatory Parameter\n 8              Unrecognized Parameters\n 9              No User Data\n10              Cookie Received While Shutting Down",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Cause Length: 16 bits (unsigned integer)",
      "ja": "原因の長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Set to the size of the parameter in bytes, including the Cause Code, Cause Length, and Cause-Specific Information fields",
      "ja": "原因コード、原因の長さ、原因固有の情報フィールドなど、バイト内のパラメーターのサイズに設定"
    },
    {
      "indent": 3,
      "text": "Cause-specific Information: variable length",
      "ja": "原因固有の情報：変数長"
    },
    {
      "indent": 6,
      "text": "This field carries the details of the error condition.",
      "ja": "このフィールドには、エラー条件の詳細が記載されています。"
    },
    {
      "indent": 3,
      "text": "Sections 3.3.10.1 - 3.3.10.10 define error causes for SCTP. Guidelines for the IETF to define new error cause values are discussed in Section 13.3.",
      "ja": "セクション3.3.10.1-3.3.10.10SCTPのエラー原因を定義します。新しいエラー原因値を定義するIETFのガイドラインについては、セクション13.3で説明します。"
    },
    {
      "indent": 0,
      "text": "3.3.10.1 Invalid Stream Identifier (1)",
      "section_title": true,
      "ja": "3.3.10.1 無効なストリーム識別子（1）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n---------------\nInvalid Stream Identifier:  Indicates endpoint received a DATA chunk\nsent to a nonexistent stream.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Cause Code=1              |      Cause Length=8           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Stream Identifier      |         (Reserved)            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Stream Identifier: 16 bits (unsigned integer)",
      "ja": "ストリーム識別子：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Contains the Stream Identifier of the DATA chunk received in error.",
      "ja": "誤って受信したデータチャンクのストリーム識別子が含まれています。"
    },
    {
      "indent": 3,
      "text": "Reserved: 16 bits",
      "ja": "予約済み：16ビット"
    },
    {
      "indent": 6,
      "text": "This field is reserved. It is set to all 0's on transmit and Ignored on receipt.",
      "ja": "このフィールドは予約されています。送信時にすべての0に設定され、受領時に無視されます。"
    },
    {
      "indent": 0,
      "text": "3.3.10.2 Missing Mandatory Parameter (2)",
      "section_title": true,
      "ja": "3.3.10.2 欠落している必須パラメーター（2）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n---------------\nMissing Mandatory Parameter:  Indicates that one or more mandatory\nTLV parameters are missing in a received INIT or INIT ACK.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Cause Code=2              |      Cause Length=8+N*2       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   Number of missing params=N                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Missing Param Type #1       |   Missing Param Type #2       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Missing Param Type #N-1     |   Missing Param Type #N       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Number of Missing params: 32 bits (unsigned integer)",
      "ja": "不足しているパラメージの数：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This field contains the number of parameters contained in the Cause-specific Information field.",
      "ja": "このフィールドには、原因固有の情報フィールドに含まれるパラメーターの数が含まれています。"
    },
    {
      "indent": 3,
      "text": "Missing Param Type: 16 bits (unsigned integer)",
      "ja": "欠落したパラマイプタイプ：16ビット（署名されていない整数）"
    },
    {
      "indent": 6,
      "text": "Each field will contain the missing mandatory parameter number.",
      "ja": "各フィールドには、欠落している必須パラメーター番号が含まれます。"
    },
    {
      "indent": 0,
      "text": "3.3.10.3 Stale Cookie Error (3)",
      "section_title": true,
      "ja": "3.3.10.3 古いクッキーエラー（3）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n--------------\nStale Cookie Error:  Indicates the receipt of a valid State Cookie\nthat has expired.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Cause Code=3              |       Cause Length=8          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Measure of Staleness (usec.)                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Measure of Staleness: 32 bits (unsigned integer)",
      "ja": "老化の測定：32ビット（署名されていない整数）"
    },
    {
      "indent": 6,
      "text": "This field contains the difference, in microseconds, between the current time and the time the State Cookie expired.",
      "ja": "このフィールドには、現在の時刻と状態クッキーの期限が切れた間の間に、マイクロ秒単位での差が含まれています。"
    },
    {
      "indent": 6,
      "text": "The sender of this error cause MAY choose to report how long past expiration the State Cookie is by including a non-zero value in the Measure of Staleness field. If the sender does not wish to provide this information it should set the Measure of Staleness field to the value of zero.",
      "ja": "このエラー原因の送信者は、stalcookieの測定フィールドにゼロ以外の値を含めることにより、州のCookieが過去の有効期限がどれだけの期間であるかを報告することを選択できます。送信者がこの情報を提供したくない場合は、統合フィールドの尺度をゼロの値に設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3.10.4 Out of Resource (4)",
      "section_title": true,
      "ja": "3.3.10.4 リソースから（4）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n---------------\nOut of Resource: Indicates that the sender is out of resource.  This\nis usually sent in combination with or within an ABORT.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Cause Code=4              |      Cause Length=4           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3.10.5 Unresolvable Address (5)",
      "section_title": true,
      "ja": "3.3.10.5 解決不可能なアドレス（5）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n---------------\nUnresolvable Address: Indicates that the sender is not able to\nresolve the specified address parameter (e.g., type of address is not\nsupported by the sender).  This is usually sent in combination with\nor within an ABORT.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Cause Code=5              |      Cause Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                  Unresolvable Address                         /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Unresolvable Address: variable length",
      "ja": "解決不可能なアドレス：可変長"
    },
    {
      "indent": 6,
      "text": "The unresolvable address field contains the complete Type, Length and Value of the address parameter (or Host Name parameter) that contains the unresolvable address or host name.",
      "ja": "解決不可能なアドレスフィールドには、解決不可能なアドレスまたはホスト名を含むアドレスパラメーター（またはホスト名パラメーター）の完全なタイプ、長さ、および値が含まれています。"
    },
    {
      "indent": 0,
      "text": "3.3.10.6 Unrecognized Chunk Type (6)",
      "section_title": true,
      "ja": "3.3.10.6 認識されていないチャンクタイプ（6）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n---------------\nUnrecognized Chunk Type:  This error cause is returned to the\noriginator of the chunk if the receiver does not understand the chunk\nand the upper bits of the 'Chunk Type' are set to 01 or 11.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Cause Code=6              |      Cause Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                  Unrecognized Chunk                           /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Unrecognized Chunk: variable length",
      "ja": "認識されていないチャンク：可変長"
    },
    {
      "indent": 6,
      "text": "The Unrecognized Chunk field contains the unrecognized Chunk from the SCTP packet complete with Chunk Type, Chunk Flags and Chunk Length.",
      "ja": "認識されていないチャンクフィールドには、チャンクタイプ、チャンクフラグ、チャンクの長さを備えたSCTPパケットからの認識されていないチャンクが含まれています。"
    },
    {
      "indent": 0,
      "text": "3.3.10.7 Invalid Mandatory Parameter (7)",
      "section_title": true,
      "ja": "3.3.10.7 無効な必須パラメーター（7）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n---------------\nInvalid Mandatory Parameter:  This error cause is returned to the\noriginator of an INIT or INIT ACK chunk when one of the mandatory\nparameters is set to a invalid value.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Cause Code=7              |      Cause Length=4           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3.10.8 Unrecognized Parameters (8)",
      "section_title": true,
      "ja": "3.3.10.8 認識されていないパラメーター（8）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n---------------\nUnrecognized Parameters:  This error cause is returned to the\noriginator of the INIT ACK chunk if the receiver does not recognize\none or more Optional TLV parameters in the INIT ACK chunk.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Cause Code=8              |      Cause Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                  Unrecognized Parameters                      /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Unrecognized Parameters: variable length",
      "ja": "認識されていないパラメーター：変数長"
    },
    {
      "indent": 6,
      "text": "The Unrecognized Parameters field contains the unrecognized parameters copied from the INIT ACK chunk complete with TLV. This error cause is normally contained in an ERROR chunk bundled with the COOKIE ECHO chunk when responding to the INIT ACK, when the sender of the COOKIE ECHO chunk wishes to report unrecognized parameters.",
      "ja": "認識されていないパラメーターフィールドには、TLVを備えたinit ackチャンクからコピーされた認識されていないパラメーターが含まれています。このエラー原因は、通常、Cookie Echo Chunkの送信者が認識されていないパラメーターを報告したい場合、Init ACKに応答するときにCookie Echo Chunkにバンドルされたエラーチャンクに含まれます。"
    },
    {
      "indent": 0,
      "text": "3.3.10.9 No User Data (9)",
      "section_title": true,
      "ja": "3.3.10.9 ユーザーデータはありません（9）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n---------------\nNo User Data:  This error cause is returned to the originator of a\nDATA chunk if a received DATA chunk has no user data.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Cause Code=9              |      Cause Length=8           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                  TSN value                                    /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "TSN value: 32 bits (+unsigned integer)",
      "ja": "TSN値：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "The TSN value field contains the TSN of the DATA chunk received with no user data field.",
      "ja": "TSN値フィールドには、ユーザーデータフィールドなしで受信したデータチャンクのTSNが含まれています。"
    },
    {
      "indent": 6,
      "text": "This cause code is normally returned in an ABORT chunk (see Section 6.2)",
      "ja": "この原因コードは通常、中止塊で返されます（セクション6.2を参照）"
    },
    {
      "indent": 0,
      "text": "3.3.10.10 Cookie Received While Shutting Down (10)",
      "section_title": true,
      "ja": "3.3.10.10 シャットダウン中に受け取ったクッキー（10）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n---------------\nCookie Received While Shutting Down:  A COOKIE ECHO was received\nWhile the endpoint was in SHUTDOWN-ACK-SENT state.  This error is\nusually returned in an ERROR chunk bundled with the retransmitted\nSHUTDOWN ACK.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Cause Code=10              |      Cause Length=4          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3.11 Cookie Echo (COOKIE ECHO) (10):",
      "ja": "3.3.11 Cookie Echo（Cookie Echo）（10）："
    },
    {
      "indent": 3,
      "text": "This chunk is used only during the initialization of an association. It is sent by the initiator of an association to its peer to complete the initialization process. This chunk MUST precede any DATA chunk sent within the association, but MAY be bundled with one or more DATA chunks in the same packet.",
      "ja": "このチャンクは、関連付けの初期化中にのみ使用されます。協会のイニシエーターからピアに送信され、初期化プロセスを完了します。このチャンクは、協会内で送信されたデータチャンクの前に先行する必要がありますが、同じパケット内の1つ以上のデータチャンクにバンドルされる場合があります。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 10   |Chunk  Flags   |         Length                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                     Cookie                                    /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bit",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 6,
      "text": "Set to zero on transmit and ignored on receipt.",
      "ja": "送信時にゼロに設定され、受領時に無視されます。"
    },
    {
      "indent": 3,
      "text": "Length: 16 bits (unsigned integer)",
      "ja": "長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Set to the size of the chunk in bytes, including the 4 bytes of the chunk header and the size of the Cookie.",
      "ja": "チャンクヘッダーの4バイトとCookieのサイズを含む、バイトのチャンクのサイズに設定されています。"
    },
    {
      "indent": 3,
      "text": "Cookie: variable size",
      "ja": "Cookie：可変サイズ"
    },
    {
      "indent": 6,
      "text": "This field must contain the exact cookie received in the State Cookie parameter from the previous INIT ACK.",
      "ja": "このフィールドには、以前のinit ACKから州のCookieパラメーターで受信した正確なCookieが含まれている必要があります。"
    },
    {
      "indent": 6,
      "text": "An implementation SHOULD make the cookie as small as possible to insure interoperability.",
      "ja": "実装では、相互運用性を保証するために、Cookieをできるだけ小さくする必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3.12 Cookie Acknowledgement (COOKIE ACK) (11):",
      "ja": "3.3.12 Cookie Aumponedment（Cookie Ack）（11）："
    },
    {
      "indent": 3,
      "text": "This chunk is used only during the initialization of an association. It is used to acknowledge the receipt of a COOKIE ECHO chunk. This chunk MUST precede any DATA or SACK chunk sent within the association, but MAY be bundled with one or more DATA chunks or SACK chunk in the same SCTP packet.",
      "ja": "このチャンクは、関連付けの初期化中にのみ使用されます。クッキーエコーチャンクの受領を認めるために使用されます。このチャンクは、協会内で送信されたデータまたはサックチャンクに先行する必要がありますが、同じSCTPパケットに1つ以上のデータチャンクまたはサックチャンクにバンドルされる場合があります。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 11   |Chunk  Flags   |     Length = 4                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 6,
      "text": "Set to zero on transmit and ignored on receipt.",
      "ja": "送信時にゼロに設定され、受領時に無視されます。"
    },
    {
      "indent": 0,
      "text": "3.3.13 Shutdown Complete (SHUTDOWN COMPLETE) (14):",
      "ja": "3.3.13 シャットダウン完全（シャットダウン完全）（14）："
    },
    {
      "indent": 3,
      "text": "This chunk MUST be used to acknowledge the receipt of the SHUTDOWN ACK chunk at the completion of the shutdown process, see Section 9.2 for details.",
      "ja": "このチャンクは、シャットダウンプロセスの完了時にシャットダウンACKチャンクの受領を確認するために使用する必要があります。詳細については、セクション9.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "The SHUTDOWN COMPLETE chunk has no parameters.",
      "ja": "シャットダウン完全チャンクにはパラメーターがありません。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 14   |Reserved     |T|      Length = 4               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 3,
      "text": "Reserved: 7 bits",
      "ja": "予約済み：7ビット"
    },
    {
      "indent": 6,
      "text": "Set to 0 on transmit and ignored on receipt.",
      "ja": "送信時に0に設定され、受領時に無視されます。"
    },
    {
      "indent": 3,
      "text": "T bit: 1 bit",
      "ja": "Tビット：1ビット"
    },
    {
      "indent": 6,
      "text": "The T bit is set to 0 if the sender had a TCB that it destroyed. If the sender did not have a TCB it should set this bit to 1.",
      "ja": "送信者が破壊したTCBを持っていた場合、tビットは0に設定されます。送信者がTCBを持っていなかった場合、このビットを1に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: Special rules apply to this chunk for verification, please see Section 8.5.1 for details.",
      "ja": "注：検証のためにこのチャンクに特別なルールが適用されます。詳細については、セクション8.5.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "4. SCTP Association State Diagram",
      "section_title": true,
      "ja": "4. SCTP協会の状態図"
    },
    {
      "indent": 3,
      "text": "During the lifetime of an SCTP association, the SCTP endpoint's association progress from one state to another in response to various events. The events that may potentially advance an association's state include:",
      "ja": "SCTP協会の存続期間中、SCTPエンドポイントの協会は、さまざまなイベントに応じて、ある状態から別の状態に進みます。協会の状態を潜在的に前進させる可能性のある出来事は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o SCTP user primitive calls, e.g., [ASSOCIATE], [SHUTDOWN], [ABORT],",
      "ja": "o SCTPユーザープリミティブコール、例えば[アソシエイト]、[シャットダウン]、[Abort]、"
    },
    {
      "indent": 3,
      "text": "o Reception of INIT, COOKIE ECHO, ABORT, SHUTDOWN, etc., control chunks, or",
      "ja": "o init、cookie echo、abort、shutdownなどの受信、コントロールチャンク、または"
    },
    {
      "indent": 3,
      "text": "o Some timeout events.",
      "ja": "o いくつかのタイムアウトイベント。"
    },
    {
      "indent": 3,
      "text": "The state diagram in the figures below illustrates state changes, together with the causing events and resulting actions. Note that some of the error conditions are not shown in the state diagram. Full description of all special cases should be found in the text.",
      "ja": "以下の図の状態図は、原因となるイベントと結果のアクションとともに、状態の変化を示しています。エラー条件の一部は状態図に示されていないことに注意してください。すべての特別なケースの完全な説明は、テキストに記載されている必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: Chunk names are given in all capital letters, while parameter names have the first letter capitalized, e.g., COOKIE ECHO chunk type vs. State Cookie parameter. If more than one event/message can occur which causes a state transition it is labeled (A), (B) etc.",
      "ja": "注：チャンク名はすべての大文字で与えられますが、パラメーター名には最初の文字が大文字になります。状態遷移を引き起こす複数のイベント/メッセージが発生する可能性がある場合、それはラベル付けされています（a）、（b）など。"
    },
    {
      "indent": 4,
      "text": "                   -----          -------- (frm any state)\n                 /       \\      /  rcv ABORT      [ABORT]\nrcv INIT        |         |    |   ----------  or ----------\n--------------- |         v    v   delete TCB     snd ABORT\ngenerate Cookie  \\    +---------+                 delete TCB\nsnd INIT ACK       ---|  CLOSED |\n                      +---------+\n                       /      \\      [ASSOCIATE]\n                      /        \\     ---------------\n                     |          |    create TCB\n                     |          |    snd INIT\n                     |          |    strt init timer\n      rcv valid      |          |\n    COOKIE  ECHO     |          v\n(1) ---------------- |      +------------+\n    create TCB       |      | COOKIE-WAIT| (2)\n    snd COOKIE ACK   |      +------------+\n                     |          |\n                     |          |    rcv INIT ACK\n                     |          |    -----------------\n                     |          |    snd COOKIE ECHO\n                     |          |    stop init timer\n                     |          |    strt cookie timer\n                     |          v\n                     |      +--------------+\n                     |      | COOKIE-ECHOED| (3)\n                     |      +--------------+\n                     |          |\n                     |          |    rcv COOKIE ACK\n                     |          |    -----------------\n                     |          |    stop cookie timer\n                     v          v\n                   +---------------+\n                   |  ESTABLISHED  |\n                   +---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "                  (from the ESTABLISHED state only)\n                                |\n                                |\n                       /--------+--------\\\n   [SHUTDOWN]         /                   \\\n   -------------------|                   |\n   check outstanding  |                   |\n   DATA chunks        |                   |\n                      v                   |\n                 +---------+              |\n                 |SHUTDOWN-|              | rcv SHUTDOWN/check\n                 |PENDING  |              | outstanding DATA\n                 +---------+              | chunks\n                      |                   |------------------\n No more outstanding  |                   |\n ---------------------|                   |\n snd SHUTDOWN         |                   |\n strt shutdown timer  |                   |\n                      v                   v\n                 +---------+        +-----------+\n             (4) |SHUTDOWN-|        | SHUTDOWN- |  (5,6)\n                 |SENT     |        | RECEIVED  |\n                 +---------+        +-----------+\n                      |  \\                |\n(A) rcv SHUTDOWN ACK  |   \\               |\n----------------------|    \\              |\nstop shutdown timer   |     \\rcv:SHUTDOWN |\nsend SHUTDOWN COMPLETE|      \\  (B)       |\ndelete TCB            |       \\           |\n                      |        \\          | No more outstanding\n                      |         \\         |-----------------\n                      |          \\        | send SHUTDOWN ACK\n(B)rcv SHUTDOWN       |           \\       | strt shutdown timer\n----------------------|            \\      |\nsend SHUTDOWN ACK     |             \\     |\nstart shutdown timer  |              \\    |\nmove to SHUTDOWN-     |               \\   |\nACK-SENT              |                |  |\n                      |                v  |\n                      |             +-----------+\n                      |             | SHUTDOWN- | (7)\n                      |             | ACK-SENT  |\n                      |             +----------+-\n                      |                   | (C)rcv SHUTDOWN COMPLETE\n                      |                   |-----------------\n                      |                   | stop shutdown timer\n                      |                   | delete TCB\n                      |                   |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 26,
      "text": "|                   | (D)rcv SHUTDOWN ACK\n|                   |--------------\n|                   | stop shutdown timer\n|                   | send SHUTDOWN COMPLETE\n|                   | delete TCB\n|                   |\n\\    +---------+    /\n \\-->| CLOSED  |<--/\n     +---------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "Figure 3: State Transition Diagram of SCTP",
      "ja": "図3：SCTPの状態遷移図"
    },
    {
      "indent": 3,
      "text": "Notes:",
      "ja": "ノート："
    },
    {
      "indent": 3,
      "text": "1) If the State Cookie in the received COOKIE ECHO is invalid (i.e., failed to pass the integrity check), the receiver MUST silently discard the packet. Or, if the received State Cookie is expired (see Section 5.1.5), the receiver MUST send back an ERROR chunk. In either case, the receiver stays in the CLOSED state.",
      "ja": "1) 受信したCookieエコーの状態Cookieが無効である場合（つまり、整合性チェックに合格できなかった場合）、受信者はパケットを静かに廃棄する必要があります。または、受信した状態Cookieの有効期限が切れている場合（セクション5.1.5を参照）、受信者はエラーチャンクを送信する必要があります。どちらの場合でも、受信者は閉じた状態にとどまります。"
    },
    {
      "indent": 3,
      "text": "2) If the T1-init timer expires, the endpoint MUST retransmit INIT and re-start the T1-init timer without changing state. This MUST be repeated up to 'Max.Init.Retransmits' times. After that, the endpoint MUST abort the initialization process and report the error to SCTP user.",
      "ja": "2) T1-ISITタイマーの有効期限が切れる場合、エンドポイントは、状態を変更せずにinitを再送信してT1-ISITタイマーを再起動する必要があります。これは、「max.init.retransmits」の時代まで繰り返す必要があります。その後、エンドポイントは初期化プロセスを中止し、エラーをSCTPユーザーに報告する必要があります。"
    },
    {
      "indent": 3,
      "text": "3) If the T1-cookie timer expires, the endpoint MUST retransmit COOKIE ECHO and re-start the T1-cookie timer without changing state. This MUST be repeated up to 'Max.Init.Retransmits' times. After that, the endpoint MUST abort the initialization process and report the error to SCTP user.",
      "ja": "3) T1-Cookieタイマーの有効期限が切れる場合、エンドポイントはCookieエコーを再送信し、状態を変更せずにT1-Cookieタイマーを再起動する必要があります。これは、「max.init.retransmits」の時代まで繰り返す必要があります。その後、エンドポイントは初期化プロセスを中止し、エラーをSCTPユーザーに報告する必要があります。"
    },
    {
      "indent": 3,
      "text": "4) In SHUTDOWN-SENT state the endpoint MUST acknowledge any received DATA chunks without delay.",
      "ja": "4) シャットダウン状態では、エンドポイントは遅滞なく受信したデータチャンクを認める必要があります。"
    },
    {
      "indent": 3,
      "text": "5) In SHUTDOWN-RECEIVED state, the endpoint MUST NOT accept any new send request from its SCTP user.",
      "ja": "5) シャットダウン状態では、エンドポイントはSCTPユーザーからの新しい送信要求を受け入れてはなりません。"
    },
    {
      "indent": 3,
      "text": "6) In SHUTDOWN-RECEIVED state, the endpoint MUST transmit or retransmit data and leave this state when all data in queue is transmitted.",
      "ja": "6) シャットダウン状態では、エンドポイントはデータを送信または再送信し、キュー内のすべてのデータが送信されたときにこの状態を離れる必要があります。"
    },
    {
      "indent": 3,
      "text": "7) In SHUTDOWN-ACK-SENT state, the endpoint MUST NOT accept any new send request from its SCTP user.",
      "ja": "7) Shutdown-ack-Sent状態では、エンドポイントはSCTPユーザーからの新しい送信要求を受け入れてはなりません。"
    },
    {
      "indent": 3,
      "text": "The CLOSED state is used to indicate that an association is not created (i.e., doesn't exist).",
      "ja": "閉じた状態は、関連性が作成されていないことを示すために使用されます（つまり、存在しません）。"
    },
    {
      "indent": 0,
      "text": "5. Association Initialization",
      "section_title": true,
      "ja": "5. 協会の初期化"
    },
    {
      "indent": 3,
      "text": "Before the first data transmission can take place from one SCTP endpoint (\"A\") to another SCTP endpoint (\"Z\"), the two endpoints must complete an initialization process in order to set up an SCTP association between them.",
      "ja": "最初のデータ送信が1つのSCTPエンドポイント（ \"A\"）から別のSCTPエンドポイント（ \"z\"）に行われる前に、2つのエンドポイントは、それらの間にSCTP関連を設定するために初期化プロセスを完了する必要があります。"
    },
    {
      "indent": 3,
      "text": "The SCTP user at an endpoint should use the ASSOCIATE primitive to initialize an SCTP association to another SCTP endpoint.",
      "ja": "エンドポイントのSCTPユーザーは、アソシエイトプリミティブを使用して、SCTPアソシエーションを別のSCTPエンドポイントに初期化する必要があります。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: From an SCTP-user's point of view, an association may be implicitly opened, without an ASSOCIATE primitive (see 10.1 B) being invoked, by the initiating endpoint's sending of the first user data to the destination endpoint. The initiating SCTP will assume default values for all mandatory and optional parameters for the INIT/INIT ACK.",
      "ja": "実装注：SCTPユーザーの視点から、エンドポイントが最初のユーザーデータを宛先エンドポイントに送信することにより、アソシエイトプリミティブ（10.1 bを参照）が呼び出されることなく、関連性が暗黙的に開かれる場合があります。開始SCTPは、init/init ackのすべての必須およびオプションのパラメーターのデフォルト値を想定します。"
    },
    {
      "indent": 3,
      "text": "Once the association is established, unidirectional streams are open for data transfer on both ends (see Section 5.1.1).",
      "ja": "関連が確立されると、両端のデータ転送のために一方向のストリームが開かれています（セクション5.1.1を参照）。"
    },
    {
      "indent": 0,
      "text": "5.1 Normal Establishment of an Association",
      "section_title": true,
      "ja": "5.1 協会の通常の確立"
    },
    {
      "indent": 3,
      "text": "The initialization process consists of the following steps (assuming that SCTP endpoint \"A\" tries to set up an association with SCTP endpoint \"Z\" and \"Z\" accepts the new association):",
      "ja": "初期化プロセスは、次の手順で構成されています（SCTPエンドポイント「A」がSCTPエンドポイント「Z」との関連付けを設定しようとすると仮定し、「Z」は新しい関連付けを受け入れます）："
    },
    {
      "indent": 3,
      "text": "A) \"A\" first sends an INIT chunk to \"Z\". In the INIT, \"A\" must provide its Verification Tag (Tag_A) in the Initiate Tag field. Tag_A SHOULD be a random number in the range of 1 to 4294967295 (see 5.3.1 for Tag value selection). After sending the INIT, \"A\" starts the T1-init timer and enters the COOKIE-WAIT state.",
      "ja": "a）「a」は、最初に「z」にinit chunkを送信します。initでは、「a」は、開始タグフィールドに検証タグ（tag_a）を提供する必要があります。TAG_Aは、1〜4294967295の範囲の乱数である必要があります（タグ値の選択については5.3.1を参照）。initを送信した後、「a」はT1-Initタイマーを開始し、Cookie-Wait状態に入ります。"
    },
    {
      "indent": 3,
      "text": "B) \"Z\" shall respond immediately with an INIT ACK chunk. The destination IP address of the INIT ACK MUST be set to the source IP address of the INIT to which this INIT ACK is responding. In the response, besides filling in other parameters, \"Z\" must set the Verification Tag field to Tag_A, and also provide its own Verification Tag (Tag_Z) in the Initiate Tag field.",
      "ja": "b）「z」は、init ackチャンクですぐに応答するものとします。init ACKの宛先IPアドレスは、このINIT ACKが応答しているinitのソースIPアドレスに設定する必要があります。応答では、他のパラメーターに記入することに加えて、「z」は検証タグフィールドをtag_aに設定する必要があり、また、開始タグフィールドに独自の検証タグ（tag_z）を提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "Moreover, \"Z\" MUST generate and send along with the INIT ACK a State Cookie. See Section 5.1.3 for State Cookie generation.",
      "ja": "さらに、「z」は、init ack a state cookieとともに生成して送信する必要があります。州のクッキー生成については、セクション5.1.3を参照してください。"
    },
    {
      "indent": 6,
      "text": "Note: After sending out INIT ACK with the State Cookie parameter, \"Z\" MUST NOT allocate any resources, nor keep any states for the new association. Otherwise, \"Z\" will be vulnerable to resource attacks.",
      "ja": "注：State Cookieパラメーターでinit Ackを送信した後、「z」はリソースを割り当てたり、新しい協会のために州を維持したりしてはなりません。それ以外の場合、「Z」はリソース攻撃に対して脆弱になります。"
    },
    {
      "indent": 3,
      "text": "C) Upon reception of the INIT ACK from \"Z\", \"A\" shall stop the T1- init timer and leave COOKIE-WAIT state. \"A\" shall then send the State Cookie received in the INIT ACK chunk in a COOKIE ECHO chunk, start the T1-cookie timer, and enter the COOKIE-ECHOED state.",
      "ja": "c）「Z」からのINIT ACKを受信すると、「A」はT1- INITタイマーを停止し、Cookie-Wait状態を離れます。「A」は、Cookie Echo ChunkでINIT ACK Chunkで受け取った状態Cookieを送信し、T1-Cookieタイマーを開始し、Cookieエコー状態に入ります。"
    },
    {
      "indent": 6,
      "text": "Note: The COOKIE ECHO chunk can be bundled with any pending outbound DATA chunks, but it MUST be the first chunk in the packet and until the COOKIE ACK is returned the sender MUST NOT send any other packets to the peer.",
      "ja": "注：Cookie Echo Chunkは、保留中のアウトバウンドデータチャンクにバンドルできますが、パケットの最初のチャンクであり、Cookie ACKが返されるまで、送信者は他のパケットをピアに送信してはなりません。"
    },
    {
      "indent": 3,
      "text": "D) Upon reception of the COOKIE ECHO chunk, Endpoint \"Z\" will reply with a COOKIE ACK chunk after building a TCB and moving to the ESTABLISHED state. A COOKIE ACK chunk may be bundled with any pending DATA chunks (and/or SACK chunks), but the COOKIE ACK chunk MUST be the first chunk in the packet.",
      "ja": "d）Cookie Echo Chunkを受信すると、Endpoint「Z」は、TCBを構築して確立された状態に移動した後、Cookie ACK Chunkで返信します。Cookie ACKチャンクは、保留中のデータチャンク（および/またはサックチャンク）にバンドルされる場合がありますが、Cookie ACKチャンクはパケットの最初のチャンクでなければなりません。"
    },
    {
      "indent": 6,
      "text": "IMPLEMENTATION NOTE: An implementation may choose to send the Communication Up notification to the SCTP user upon reception of a valid COOKIE ECHO chunk.",
      "ja": "実装注：実装は、有効なCookie Echo Chunkを受信すると、通信通知をSCTPユーザーに送信することを選択できます。"
    },
    {
      "indent": 3,
      "text": "E) Upon reception of the COOKIE ACK, endpoint \"A\" will move from the COOKIE-ECHOED state to the ESTABLISHED state, stopping the T1- cookie timer. It may also notify its ULP about the successful establishment of the association with a Communication Up notification (see Section 10).",
      "ja": "e）Cookie ACKを受信すると、エンドポイント \"a\"は、Cookieでエコードされた状態から確立された状態に移動し、T1-Cookieタイマーを停止します。また、コミュニケーションのアップ通知との関連の確立の成功についてULPに通知する場合があります（セクション10を参照）。"
    },
    {
      "indent": 3,
      "text": "An INIT or INIT ACK chunk MUST NOT be bundled with any other chunk. They MUST be the only chunks present in the SCTP packets that carry them.",
      "ja": "initまたはinit ackチャンクを他のチャンクにバンドルしてはなりません。それらは、それらを運ぶSCTPパケットに存在する唯一のチャンクでなければなりません。"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST send the INIT ACK to the IP address from which it received the INIT.",
      "ja": "エンドポイントは、INIT ACKをINITを受け取ったIPアドレスに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: T1-init timer and T1-cookie timer shall follow the same rules given in Section 6.3.",
      "ja": "注：T1-ISITタイマーとT1-Cookieタイマーは、セクション6.3に記載されているのと同じルールに従うものとします。"
    },
    {
      "indent": 3,
      "text": "If an endpoint receives an INIT, INIT ACK, or COOKIE ECHO chunk but decides not to establish the new association due to missing mandatory parameters in the received INIT or INIT ACK, invalid parameter values, or lack of local resources, it MUST respond with an ABORT chunk. It SHOULD also specify the cause of abort, such as the type of the missing mandatory parameters, etc., by including the error cause parameters with the ABORT chunk. The Verification Tag field in the common header of the outbound SCTP packet containing the ABORT chunk MUST be set to the Initiate Tag value of the peer.",
      "ja": "エンドポイントがinit、init、またはcookieエコーチャンクを受信しますが、受信したinitまたはinit ackの必須パラメーター、無効なパラメーター値、またはローカルリソースの欠如のために新しい関連性を確立しないことを決定した場合、それは応答する必要があります。チャンクを中止します。また、エラー原因のパラメーターを中止チャンクに含めることにより、欠落している必須パラメーターなどのタイプなど、中止の原因を指定する必要があります。アコートチャンクを含むアウトバウンドSCTPパケットの共通ヘッダーの検証タグフィールドは、ピアの開始タグ値に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "After the reception of the first DATA chunk in an association the endpoint MUST immediately respond with a SACK to acknowledge the DATA chunk. Subsequent acknowledgements should be done as described in Section 6.2.",
      "ja": "関連性における最初のデータチャンクの受信後、エンドポイントはすぐにサックで応答して、データチャンクを確認する必要があります。セクション6.2で説明されているように、後続の承認を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "When the TCB is created, each endpoint MUST set its internal Cumulative TSN Ack Point to the value of its transmitted Initial TSN minus one.",
      "ja": "TCBが作成されると、各エンドポイントは、内部累積TSN ACKポイントを送信された初期TSNから1つの値の値に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: The IP addresses and SCTP port are generally used as the key to find the TCB within an SCTP instance.",
      "ja": "実装注：IPアドレスとSCTPポートは、通常、SCTPインスタンス内でTCBを見つけるためのキーとして使用されます。"
    },
    {
      "indent": 0,
      "text": "5.1.1 Handle Stream Parameters",
      "section_title": true,
      "ja": "5.1.1 ストリームパラメーターを処理します"
    },
    {
      "indent": 3,
      "text": "In the INIT and INIT ACK chunks, the sender of the chunk shall indicate the number of outbound streams (OS) it wishes to have in the association, as well as the maximum inbound streams (MIS) it will accept from the other endpoint.",
      "ja": "init and init ackチャンクでは、チャンクの送信者は、協会に希望するアウトバウンドストリーム（OS）の数と、最大インバウンドストリーム（MIS）を他のエンドポイントから受け入れることを示します。"
    },
    {
      "indent": 3,
      "text": "After receiving the stream configuration information from the other side, each endpoint shall perform the following check: If the peer's MIS is less than the endpoint's OS, meaning that the peer is incapable of supporting all the outbound streams the endpoint wants to configure, the endpoint MUST either use MIS outbound streams, or abort the association and report to its upper layer the resources shortage at its peer.",
      "ja": "反対側からストリーム構成情報を受信した後、各エンドポイントは次のチェックを実行するものとします。ピアのMISがエンドポイントのOSよりも少ない場合、ピアはエンドポイントが設定したいすべてのアウトバウンドストリームをサポートできないことを意味します。MISアウトバウンドストリームを使用するか、アソシエーションを中止し、そのピアのリソース不足をその上層に報告する必要があります。"
    },
    {
      "indent": 3,
      "text": "After the association is initialized, the valid outbound stream identifier range for either endpoint shall be 0 to min(local OS, remote MIS)-1.",
      "ja": "関連が初期化された後、いずれかのエンドポイントの有効なアウトバウンドストリーム識別子範囲は0〜min（ローカルOS、リモートMIS）-1でなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.1.2 Handle Address Parameters",
      "section_title": true,
      "ja": "5.1.2 アドレスパラメーターを処理します"
    },
    {
      "indent": 3,
      "text": "During the association initialization, an endpoint shall use the following rules to discover and collect the destination transport address(es) of its peer.",
      "ja": "協会の初期化中、エンドポイントは、次のルールを使用して、ピアの宛先輸送アドレス（ES）を発見および収集するものとします。"
    },
    {
      "indent": 3,
      "text": "A) If there are no address parameters present in the received INIT or INIT ACK chunk, the endpoint shall take the source IP address from which the chunk arrives and record it, in combination with the SCTP source port number, as the only destination transport address for this peer.",
      "ja": "a）受信したinitまたはinit ackチャンクにアドレスパラメーターが存在しない場合、エンドポイントは、sctpソースポート番号と組み合わせて、チャンクが到着するソースIPアドレスを取得し、それを記録し、唯一の宛先輸送アドレスとして記録するものとします。このピアのために。"
    },
    {
      "indent": 3,
      "text": "B) If there is a Host Name parameter present in the received INIT or INIT ACK chunk, the endpoint shall resolve that host name to a list of IP address(es) and derive the transport address(es) of this peer by combining the resolved IP address(es) with the SCTP source port.",
      "ja": "b）受信したinitまたはinit ackチャンクにホスト名パラメーターが存在する場合、エンドポイントはそのホスト名をIPアドレスのリストに解決し、解決されたものを組み合わせてこのピアの輸送アドレス（ES）を導き出すものとします。SCTPソースポートを備えたIPアドレス（ES）。"
    },
    {
      "indent": 6,
      "text": "The endpoint MUST ignore any other IP address parameters if they are also present in the received INIT or INIT ACK chunk.",
      "ja": "エンドポイントは、受信したinitまたはinit ackチャンクにも存在する場合、他のIPアドレスパラメーターを無視する必要があります。"
    },
    {
      "indent": 6,
      "text": "The time at which the receiver of an INIT resolves the host name has potential security implications to SCTP. If the receiver of an INIT resolves the host name upon the reception of the chunk, and the mechanism the receiver uses to resolve the host name involves potential long delay (e.g. DNS query), the receiver may open itself up to resource attacks for the period of time while it is waiting for the name resolution results before it can build the State Cookie and release local resources.",
      "ja": "INITの受信者がホスト名を解決する時間は、SCTPに潜在的なセキュリティに影響を与えます。INITの受信者がチャンクの受信時にホスト名を解決し、受信者がホスト名を解決するために使用するメカニズムには、潜在的な長い遅延（DNSクエリなど）が含まれる場合、受信者は期間のリソース攻撃に自らを開くことができます。State Cookieを構築してローカルリソースをリリースする前に、名前の解決策の結果が待機している間です。"
    },
    {
      "indent": 6,
      "text": "Therefore, in cases where the name translation involves potential long delay, the receiver of the INIT MUST postpone the name resolution till the reception of the COOKIE ECHO chunk from the peer. In such a case, the receiver of the INIT SHOULD build the State Cookie using the received Host Name (instead of destination transport addresses) and send the INIT ACK to the source IP address from which the INIT was received.",
      "ja": "したがって、名前の翻訳が潜在的な長い遅延を伴う場合、INITの受信者は、ピアからのCookie Echo Chunkの受信まで、名前の解決を延期する必要があります。そのような場合、INITの受信者は、（宛先輸送アドレスの代わりに）受信されたホスト名を使用して状態Cookieを構築し、INITを受信したソースIPアドレスにINIT ACKを送信する必要があります。"
    },
    {
      "indent": 6,
      "text": "The receiver of an INIT ACK shall always immediately attempt to resolve the name upon the reception of the chunk.",
      "ja": "INIT ACKの受信者は、常にチャンクの受信時に名前を解決しようとするものとします。"
    },
    {
      "indent": 6,
      "text": "The receiver of the INIT or INIT ACK MUST NOT send user data (piggy-backed or stand-alone) to its peer until the host name is successfully resolved.",
      "ja": "initまたはinit ackの受信者は、ホスト名が正常に解決されるまで、ユーザーデータ（ピギーバックまたはスタンドアロン）をピアに送信してはなりません。"
    },
    {
      "indent": 6,
      "text": "If the name resolution is not successful, the endpoint MUST immediately send an ABORT with \"Unresolvable Address\" error cause to its peer. The ABORT shall be sent to the source IP address from which the last peer packet was received.",
      "ja": "名前の解像度が成功しない場合、エンドポイントはすぐに「解決できないアドレス」エラーの原因で中止をピアに送信する必要があります。中止は、最後のピアパケットが受信されたソースIPアドレスに送信されます。"
    },
    {
      "indent": 3,
      "text": "C) If there are only IPv4/IPv6 addresses present in the received INIT or INIT ACK chunk, the receiver shall derive and record all the transport address(es) from the received chunk AND the source IP address that sent the INIT or INIT ACK. The transport address(es) are derived by the combination of SCTP source port (from the common header) and the IP address parameter(s) carried in the INIT or INIT ACK chunk and the source IP address of the IP datagram. The receiver should use only these transport addresses as destination transport addresses when sending subsequent packets to its peer.",
      "ja": "c）受信したinitまたはinit ackチャンクに存在するIPv4/IPv6アドレスのみがある場合、受信したチャンクからすべての輸送アドレス（ES）とINITまたはINIT ACKを送信したソースIPアドレスからすべての輸送アドレスを導出して記録するものとします。トランスポートアドレスは、SCTPソースポート（共通ヘッダーから）とINITまたはINIT ACKチャンクで運ばれるIPアドレスパラメーターとIPデータグラムのソースIPアドレスの組み合わせによって導出されます。レシーバーは、後続のパケットをピアに送信する際に、これらの輸送アドレスのみを宛先輸送アドレスとして使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "IMPLEMENTATION NOTE: In some cases (e.g., when the implementation doesn't control the source IP address that is used for transmitting), an endpoint might need to include in its INIT or INIT ACK all possible IP addresses from which packets to the peer could be transmitted.",
      "ja": "実装注：場合によっては（たとえば、実装が送信に使用されるソースIPアドレスを制御しない場合）、エンドポイントは、ピアへのパケットが可能なすべての可能なIPアドレスをINITまたはINITに含める必要がある場合があります。送信されます。"
    },
    {
      "indent": 3,
      "text": "After all transport addresses are derived from the INIT or INIT ACK chunk using the above rules, the endpoint shall select one of the transport addresses as the initial primary path.",
      "ja": "上記のルールを使用して、すべての輸送アドレスがinitまたはinit ackチャンクから派生した後、エンドポイントは、輸送アドレスの1つを初期プライマリパスとして選択するものとします。"
    },
    {
      "indent": 3,
      "text": "Note: The INIT-ACK MUST be sent to the source address of the INIT.",
      "ja": "注：init-ackは、initのソースアドレスに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The sender of INIT may include a 'Supported Address Types' parameter in the INIT to indicate what types of address are acceptable. When this parameter is present, the receiver of INIT (initiatee) MUST either use one of the address types indicated in the Supported Address Types parameter when responding to the INIT, or abort the association with an \"Unresolvable Address\" error cause if it is unwilling or incapable of using any of the address types indicated by its peer.",
      "ja": "initの送信者には、initに「サポートされているアドレスタイプ」パラメーターを含めることができ、どのタイプのアドレスが許容できるかを示します。このパラメーターが存在する場合、init（initiatee）の受信者は、initに応答するときにサポートされているアドレスタイプパラメーターに示されているアドレスタイプのいずれかを使用するか、「解決不可能なアドレス」エラー原因で「解決不可能なアドレス」エラーの原因と関連する必要があります。または、ピアで示されているアドレスタイプのいずれかを使用できません。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: In the case that the receiver of an INIT ACK fails to resolve the address parameter due to an unsupported type, it can abort the initiation process and then attempt a re-initiation by using a 'Supported Address Types' parameter in the new INIT to indicate what types of address it prefers.",
      "ja": "実装注：init ACKの受信者がサポートされていないタイプのためにアドレスパラメーターを解決できない場合、開始プロセスを中止してから、新しいものの「サポートされているアドレスタイプ」パラメーターを使用して再開始を試みることができます。どのタイプのアドレスが好むかを示すため。"
    },
    {
      "indent": 0,
      "text": "5.1.3 Generating State Cookie",
      "section_title": true,
      "ja": "5.1.3 ステートクッキーを生成します"
    },
    {
      "indent": 3,
      "text": "When sending an INIT ACK as a response to an INIT chunk, the sender of INIT ACK creates a State Cookie and sends it in the State Cookie parameter of the INIT ACK. Inside this State Cookie, the sender should include a MAC (see [RFC2104] for an example), a time stamp on when the State Cookie is created, and the lifespan of the State Cookie, along with all the information necessary for it to establish the association.",
      "ja": "init chunkへの応答としてinit ackを送信すると、init ackの送信者は状態クッキーを作成し、init ackの状態クッキーパラメーターに送信します。この状態クッキー内には、送信者には、Mac（例については[RFC2104]を参照）、状態Cookieが作成されたときのタイムスタンプ、およびState Cookieの寿命を含める必要があります。協会。"
    },
    {
      "indent": 3,
      "text": "The following steps SHOULD be taken to generate the State Cookie:",
      "ja": "状態Cookieを生成するために、次の手順を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "1) Create an association TCB using information from both the received INIT and the outgoing INIT ACK chunk,",
      "ja": "1) 受信したinitと発信init ackチャンクの両方からの情報を使用して、関連性TCBを作成します。"
    },
    {
      "indent": 3,
      "text": "2) In the TCB, set the creation time to the current time of day, and the lifespan to the protocol parameter 'Valid.Cookie.Life',",
      "ja": "2) TCBで、作成時間を現在の時刻まで設定し、寿命をプロトコルパラメーター 'balid.cookie.life'に設定します。"
    },
    {
      "indent": 3,
      "text": "3) From the TCB, identify and collect the minimal subset of information needed to re-create the TCB, and generate a MAC using this subset of information and a secret key (see [RFC2104] for an example of generating a MAC), and",
      "ja": "3) TCBから、TCBを再作成するために必要な情報の最小限のサブセットを識別して収集し、この情報のサブセットと秘密キー（MACを生成する例については[RFC2104]を参照）を使用してMACを生成し、"
    },
    {
      "indent": 3,
      "text": "4) Generate the State Cookie by combining this subset of information and the resultant MAC.",
      "ja": "4) この情報のサブセットと結果のMacを組み合わせて、状態Cookieを生成します。"
    },
    {
      "indent": 3,
      "text": "After sending the INIT ACK with the State Cookie parameter, the sender SHOULD delete the TCB and any other local resource related to the new association, so as to prevent resource attacks.",
      "ja": "State Cookieパラメーターを使用してINIT ACKを送信した後、送信者は、リソース攻撃を防ぐために、TCBおよび新しい協会に関連するその他のローカルリソースを削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "The hashing method used to generate the MAC is strictly a private matter for the receiver of the INIT chunk. The use of a MAC is mandatory to prevent denial of service attacks. The secret key SHOULD be random ([RFC1750] provides some information on randomness guidelines); it SHOULD be changed reasonably frequently, and the timestamp in the State Cookie MAY be used to determine which key should be used to verify the MAC.",
      "ja": "MACを生成するために使用されるハッシュメソッドは、initチャンクの受信者にとって厳密に私的な問題です。Macの使用は、サービス攻撃の拒否を防ぐために必須です。シークレットキーはランダムでなければなりません（[RFC1750]は、ランダム性ガイドラインに関するいくつかの情報を提供します）。合理的に頻繁に変更する必要があり、州のクッキーのタイムスタンプを使用して、MACを検証するために使用するキーを決定することができます。"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD make the cookie as small as possible to insure interoperability.",
      "ja": "実装では、相互運用性を保証するために、Cookieをできるだけ小さくする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1.4 State Cookie Processing",
      "section_title": true,
      "ja": "5.1.4 状態クッキー処理"
    },
    {
      "indent": 3,
      "text": "When an endpoint (in the COOKIE WAIT state) receives an INIT ACK chunk with a State Cookie parameter, it MUST immediately send a COOKIE ECHO chunk to its peer with the received State Cookie. The sender MAY also add any pending DATA chunks to the packet after the COOKIE ECHO chunk.",
      "ja": "エンドポイント（Cookie待機状態）がState Cookieパラメーターを使用してinit ackチャンクを受け取る場合、受け取った状態Cookieで同僚にCookie Echo Chunkをすぐに送信する必要があります。送信者は、Cookie Echo Chunkの後、保留中のデータチャンクをパケットに追加することもできます。"
    },
    {
      "indent": 3,
      "text": "The endpoint shall also start the T1-cookie timer after sending out the COOKIE ECHO chunk. If the timer expires, the endpoint shall retransmit the COOKIE ECHO chunk and restart the T1-cookie timer. This is repeated until either a COOKIE ACK is received or ' Max.Init.Retransmits' is reached causing the peer endpoint to be marked unreachable (and thus the association enters the CLOSED state).",
      "ja": "エンドポイントは、Cookie Echo Chunkを送信した後、T1-Cookieタイマーも起動するものとします。タイマーの有効期限が切れた場合、エンドポイントはCookie Echo Chunkを再送信し、T1-Cookieタイマーを再起動するものとします。これは、Cookie ACKを受信するか、「max.init.retransmits」に到達し、ピアエンドポイントに到達不能にマークされます（したがって、関連付けが閉じた状態に入る）まで繰り返されます。"
    },
    {
      "indent": 0,
      "text": "5.1.5 State Cookie Authentication",
      "section_title": true,
      "ja": "5.1.5 状態クッキー認証"
    },
    {
      "indent": 3,
      "text": "When an endpoint receives a COOKIE ECHO chunk from another endpoint with which it has no association, it shall take the following actions:",
      "ja": "エンドポイントが関連性のない別のエンドポイントからクッキーエコーチャンクを受信する場合、次のアクションを取るものとします。"
    },
    {
      "indent": 3,
      "text": "1) Compute a MAC using the TCB data carried in the State Cookie and the secret key (note the timestamp in the State Cookie MAY be used to determine which secret key to use). Reference [RFC2104] can be used as a guideline for generating the MAC,",
      "ja": "1) State CookieおよびSecret Keyに携帯されているTCBデータを使用してMACを計算します（State Cookieのタイムスタンプを使用して、使用する秘密キーを決定することができます）。参照[RFC2104]は、Macを生成するためのガイドラインとして使用できます。"
    },
    {
      "indent": 3,
      "text": "2) Authenticate the State Cookie as one that it previously generated by comparing the computed MAC against the one carried in the State Cookie. If this comparison fails, the SCTP packet, including the COOKIE ECHO and any DATA chunks, should be silently discarded,",
      "ja": "2) State Cookieを、計算されたMacをState Cookieで運んだものと比較することによって以前に生成されたものとして認証されます。この比較が失敗した場合、Cookieエコーやデータチャンクを含むSCTPパケットは静かに廃棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "3) Compare the creation timestamp in the State Cookie to the current local time. If the elapsed time is longer than the lifespan carried in the State Cookie, then the packet, including the COOKIE ECHO and any attached DATA chunks, SHOULD be discarded and the endpoint MUST transmit an ERROR chunk with a \"Stale Cookie\" error cause to the peer endpoint,",
      "ja": "3) 州のクッキーの作成タイムスタンプを現在の現地時間と比較してください。経過時間が状態Cookieで運ばれる寿命よりも長い場合、Cookieエコーや接続されたデータチャンクを含むパケットを破棄し、エンドポイントは「古いクッキー」エラーの原因でエラーチャンクを送信する必要があります。ピアエンドポイント、"
    },
    {
      "indent": 3,
      "text": "4) If the State Cookie is valid, create an association to the sender of the COOKIE ECHO chunk with the information in the TCB data carried in the COOKIE ECHO, and enter the ESTABLISHED state,",
      "ja": "4) State Cookieが有効な場合は、Cookie EchoにあるTCBデータの情報とCookie Echo Chunkの送信者との関連を作成し、確立された状態を入力します。"
    },
    {
      "indent": 3,
      "text": "5) Send a COOKIE ACK chunk to the peer acknowledging reception of the COOKIE ECHO. The COOKIE ACK MAY be bundled with an outbound DATA chunk or SACK chunk; however, the COOKIE ACK MUST be the first chunk in the SCTP packet.",
      "ja": "5) Cookie Ack Chunkをピアに承認するCookie Echoの受信を承認します。Cookie ACKには、アウトバウンドデータチャンクまたはサックチャンクがバンドルされる場合があります。ただし、Cookie ACKはSCTPパケットの最初のチャンクでなければなりません。"
    },
    {
      "indent": 3,
      "text": "6) Immediately acknowledge any DATA chunk bundled with the COOKIE ECHO with a SACK (subsequent DATA chunk acknowledgement should follow the rules defined in Section 6.2). As mentioned in step 5), if the SACK is bundled with the COOKIE ACK, the COOKIE ACK MUST appear first in the SCTP packet.",
      "ja": "6) すぐにサックでクッキーエコーにバンドルされたデータチャンクを確認します（後続のデータチャンク承認は、セクション6.2で定義されているルールに従う必要があります）。ステップ5で述べたように、袋にCookie ACKにバンドルされている場合、Cookie ACKは最初にSCTPパケットに表示する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a COOKIE ECHO is received from an endpoint with which the receiver of the COOKIE ECHO has an existing association, the procedures in Section 5.2 should be followed.",
      "ja": "Cookie EchoがCookie Echoの受信機に既存の関連性があるエンドポイントからCookie Echoが受信される場合、セクション5.2の手順に従う必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1.6 An Example of Normal Association Establishment",
      "section_title": true,
      "ja": "5.1.6 通常の協会の施設の例"
    },
    {
      "indent": 3,
      "text": "In the following example, \"A\" initiates the association and then\nsends a user message to \"Z\", then \"Z\" sends two user messages to \"A\"\nlater (assuming no bundling or fragmentation occurs):\n   Endpoint A                                          Endpoint Z\n{app sets association with Z}\n(build TCB)\nINIT [I-Tag=Tag_A\n      & other info]  --------\\\n(Start T1-init timer)         \\\n(Enter COOKIE-WAIT state)      \\---> (compose temp TCB and Cookie_Z)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "                                /--- INIT ACK [Veri Tag=Tag_A,\n                               /              I-Tag=Tag_Z,\n(Cancel T1-init timer) <------/               Cookie_Z, & other info]\n                                     (destroy temp TCB)\nCOOKIE ECHO [Cookie_Z] ------\\\n(Start T1-init timer)         \\\n(Enter COOKIE-ECHOED state)    \\---> (build TCB enter ESTABLISHED\n                                      state)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "                               /---- COOKIE-ACK\n                              /\n(Cancel T1-init timer, <-----/\n Enter ESTABLISHED state)\n{app sends 1st user data; strm 0}\nDATA [TSN=initial TSN_A\n    Strm=0,Seq=1 & user data]--\\\n (Start T3-rtx timer)            \\\n                                  \\->\n                              /----- SACK [TSN Ack=init\n                                          TSN_A,Block=0]\n(Cancel T3-rtx timer) <------/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "                                     ...\n                                     {app sends 2 messages;strm 0}\n                               /---- DATA\n                              /        [TSN=init TSN_Z\n                          <--/          Strm=0,Seq=1 & user data 1]\nSACK [TSN Ack=init TSN_Z,      /---- DATA\n      Block=0]     --------\\  /        [TSN=init TSN_Z +1,\n                            \\/          Strm=0,Seq=2 & user data 2]\n                     <------/\\\n                              \\\n                               \\------>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 4: INITiation Example",
      "ja": "図4：開始の例"
    },
    {
      "indent": 3,
      "text": "If the T1-init timer expires at \"A\" after the INIT or COOKIE ECHO chunks are sent, the same INIT or COOKIE ECHO chunk with the same Initiate Tag (i.e., Tag_A) or State Cookie shall be retransmitted and the timer restarted. This shall be repeated Max.Init.Retransmits times before \"A\" considers \"Z\" unreachable and reports the failure to its upper layer (and thus the association enters the CLOSED state). When retransmitting the INIT, the endpoint MUST follow the rules defined in 6.3 to determine the proper timer value.",
      "ja": "INITまたはCookieエコーチャンクが送信された後、T1-INITタイマーが「A」で期限切れになる場合、同じinitiateタグ（つまり、tag_a）または状態Cookieを使用して同じinitまたはcookieエコーチャンクが再送信され、タイマーが再起動されます。これは、「A」が「Z」を到達できないと考える前に、max.init.retransmitsの時間を繰り返し、その上層層への失敗を報告します（したがって、関連付けは閉じた状態に入ります）。initを再送信する場合、エンドポイントは6.3で定義されたルールに従って適切なタイマー値を決定する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2 Handle Duplicate or Unexpected INIT, INIT ACK, COOKIE ECHO, and COOKIE ACK",
      "section_title": true,
      "ja": "5.2 重複または予期しないinit、init ack、cookie echo、cookie ackを処理する"
    },
    {
      "indent": 3,
      "text": "During the lifetime of an association (in one of the possible states), an endpoint may receive from its peer endpoint one of the setup chunks (INIT, INIT ACK, COOKIE ECHO, and COOKIE ACK). The receiver shall treat such a setup chunk as a duplicate and process it as described in this section.",
      "ja": "協会の存続期間中（可能な状態の1つで）、エンドポイントは、ピアエンドポイントからセットアップチャンクの1つ（init、init ack、cookie echo、and cookie ack）の1つを受け取る場合があります。受信者は、このセットチャンクを複製として扱い、このセクションで説明したように処理するものとします。"
    },
    {
      "indent": 3,
      "text": "Note: An endpoint will not receive the chunk unless the chunk was sent to a SCTP transport address and is from a SCTP transport address associated with this endpoint. Therefore, the endpoint processes such a chunk as part of its current association.",
      "ja": "注：チャンクがSCTPトランスポートアドレスに送信され、このエンドポイントに関連付けられたSCTP輸送アドレスからのものでない限り、エンドポイントはチャンクを受け取りません。したがって、エンドポイントは、現在の関連付けの一部としてそのようなチャンクを処理します。"
    },
    {
      "indent": 3,
      "text": "The following scenarios can cause duplicated or unexpected chunks:",
      "ja": "次のシナリオは、重複または予期しないチャンクを引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "A) The peer has crashed without being detected, re-started itself and sent out a new INIT chunk trying to restore the association,",
      "ja": "a）ピアは、検出されずにクラッシュし、再起動し、協会を復元しようとして新しいイニシ額を送りました、"
    },
    {
      "indent": 3,
      "text": "B) Both sides are trying to initialize the association at about the same time,",
      "ja": "b）双方がほぼ同時に協会を初期化しようとしている、"
    },
    {
      "indent": 3,
      "text": "C) The chunk is from a stale packet that was used to establish the present association or a past association that is no longer in existence,",
      "ja": "c）チャンクは、現在の関連性または存在しなくなった過去の関連性を確立するために使用された古いパケットからのものです。"
    },
    {
      "indent": 3,
      "text": "D) The chunk is a false packet generated by an attacker, or",
      "ja": "d）チャンクは、攻撃者によって生成された誤ったパケットです。"
    },
    {
      "indent": 3,
      "text": "E) The peer never received the COOKIE ACK and is retransmitting its COOKIE ECHO.",
      "ja": "e）ピアはCookie ACKを受け取ったことがなく、Cookie Echoを再送信しています。"
    },
    {
      "indent": 3,
      "text": "The rules in the following sections shall be applied in order to identify and correctly handle these cases.",
      "ja": "これらのケースを特定して正しく処理するために、次のセクションのルールを適用するものとします。"
    },
    {
      "indent": 0,
      "text": "5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State (Item B)",
      "section_title": true,
      "ja": "5.2.1 Cookie-WaitまたはCookie-Eched状態で受け取ったinit（アイテムB）"
    },
    {
      "indent": 3,
      "text": "This usually indicates an initialization collision, i.e., each endpoint is attempting, at about the same time, to establish an association with the other endpoint.",
      "ja": "これは通常、初期化の衝突を示しています。つまり、各エンドポイントは、ほぼ同時に、他のエンドポイントとの関連を確立しようとしています。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of an INIT in the COOKIE-WAIT or COOKIE-ECHOED state, an endpoint MUST respond with an INIT ACK using the same parameters it sent in its original INIT chunk (including its Initiation Tag, unchanged). These original parameters are combined with those from the newly received INIT chunk. The endpoint shall also generate a State Cookie with the INIT ACK. The endpoint uses the parameters sent in its INIT to calculate the State Cookie.",
      "ja": "Cookie-WaitまたはCookieエコー状態でのinitを受信すると、エンドポイントは、元のINITチャンク（開始タグを含む、変更されていない）で送信した同じパラメーターを使用してINIT ACKで応答する必要があります。これらの元のパラメーターは、新しく受け取ったinitチャンクのパラメーターと組み合わされます。エンドポイントは、init ackを使用してステートクッキーも生成するものとします。エンドポイントは、initで送信されたパラメーターを使用して、状態Cookieを計算します。"
    },
    {
      "indent": 3,
      "text": "After that, the endpoint MUST NOT change its state, the T1-init timer shall be left running and the corresponding TCB MUST NOT be destroyed. The normal procedures for handling State Cookies when a TCB exists will resolve the duplicate INITs to a single association.",
      "ja": "その後、エンドポイントは状態を変更してはなりません。T1-ISITタイマーは実行されたままになり、対応するTCBを破壊してはなりません。TCBが存在する場合の状態Cookieを処理するための通常の手順は、重複したINITを単一の関連付けに解決します。"
    },
    {
      "indent": 3,
      "text": "For an endpoint that is in the COOKIE-ECHOED state it MUST populate its Tie-Tags with the Tag information of itself and its peer (see section 5.2.2 for a description of the Tie-Tags).",
      "ja": "クッキーエコー状態にあるエンドポイントの場合、タイタグ自身とピアのタグ情報にタイタグを入力する必要があります（タイタグの説明については、セクション5.2.2を参照）。"
    },
    {
      "indent": 0,
      "text": "5.2.2 Unexpected INIT in States Other than CLOSED, COOKIE-ECHOED, COOKIE-WAIT and SHUTDOWN-ACK-SENT",
      "section_title": true,
      "ja": "5.2.2 クローズド、クッキーエコー、クッキーワイト、シャットダウンのセント以外の州での予期しない初期"
    },
    {
      "indent": 3,
      "text": "Unless otherwise stated, upon reception of an unexpected INIT for this association, the endpoint shall generate an INIT ACK with a State Cookie. In the outbound INIT ACK the endpoint MUST copy its current Verification Tag and peer's Verification Tag into a reserved place within the state cookie. We shall refer to these locations as the Peer's-Tie-Tag and the Local-Tie-Tag. The outbound SCTP packet containing this INIT ACK MUST carry a Verification Tag value equal to the Initiation Tag found in the unexpected INIT. And the INIT ACK MUST contain a new Initiation Tag (randomly generated see Section 5.3.1). Other parameters for the endpoint SHOULD be copied from the existing parameters of the association (e.g. number of outbound streams) into the INIT ACK and cookie.",
      "ja": "特に明記しない限り、この関連性の予期しない初期を受信すると、エンドポイントは状態Cookieを使用してinit ackを生成するものとします。アウトバウンドINIT ACKでは、エンドポイントは現在の検証タグとピアの検証タグを州のクッキー内の予約場所にコピーする必要があります。これらの場所を、ピアのタイタグおよびローカルタイタグと呼びます。このinit ACKを含むアウトバウンドSCTPパケットは、予期しないinitで見つかった開始タグに等しい検証タグ値を運ぶ必要があります。INIT ACKには新しい開始タグを含める必要があります（ランダムに生成されたセクション5.3.1を参照）。エンドポイントのその他のパラメーターは、協会の既存のパラメーター（例：アウトバウンドストリームの数）からINIT ACKおよびCookieにコピーする必要があります。"
    },
    {
      "indent": 3,
      "text": "After sending out the INIT ACK, the endpoint shall take no further actions, i.e., the existing association, including its current state, and the corresponding TCB MUST NOT be changed.",
      "ja": "INIT ACKを送信した後、エンドポイントはそれ以上のアクション、つまり、その現在の状態を含む既存の関連付けを取得しません。また、対応するTCBを変更してはなりません。"
    },
    {
      "indent": 3,
      "text": "Note: Only when a TCB exists and the association is not in a COOKIE-WAIT state are the Tie-Tags populated. For a normal association INIT (i.e. the endpoint is in a COOKIE-WAIT state), the Tie-Tags MUST be set to 0 (indicating that no previous TCB existed). The INIT ACK and State Cookie are populated as specified in section 5.2.1.",
      "ja": "注：TCBが存在し、協会がCookie-Wait状態にない場合にのみ、タイタグが人口がかかっています。通常の関連性init（つまり、エンドポイントはCookie-Wait状態です）の場合、タイタグは0に設定する必要があります（以前のTCBが存在しなかったことを示します）。init ackと状態クッキーは、セクション5.2.1で指定されているように入力されています。"
    },
    {
      "indent": 0,
      "text": "5.2.3 Unexpected INIT ACK",
      "section_title": true,
      "ja": "5.2.3 予期しないinit ack"
    },
    {
      "indent": 3,
      "text": "If an INIT ACK is received by an endpoint in any state other than the COOKIE-WAIT state, the endpoint should discard the INIT ACK chunk. An unexpected INIT ACK usually indicates the processing of an old or duplicated INIT chunk.",
      "ja": "INIT ACKがCookie-Wait状態以外の任意の状態のエンドポイントによって受信された場合、エンドポイントはinit ackチャンクを破棄する必要があります。予期しないinit ACKは通常、古いまたは重複したinitチャンクの処理を示します。"
    },
    {
      "indent": 0,
      "text": "5.2.4 Handle a COOKIE ECHO when a TCB exists",
      "section_title": true,
      "ja": "5.2.4 TCBが存在するときにクッキーエコーを処理します"
    },
    {
      "indent": 3,
      "text": "When a COOKIE ECHO chunk is received by an endpoint in any state for an existing association (i.e., not in the CLOSED state) the following rules shall be applied:",
      "ja": "Cookie Echo Chunkが既存の関連付けのためにどの状態のエンドポイントによって受信される場合（つまり、閉じた状態ではありません）、次のルールを適用するものとします。"
    },
    {
      "indent": 3,
      "text": "1) Compute a MAC as described in Step 1 of Section 5.1.5,",
      "ja": "1) セクション5.1.5のステップ1で説明されているように、Macを計算します。"
    },
    {
      "indent": 3,
      "text": "2) Authenticate the State Cookie as described in Step 2 of Section 5.1.5 (this is case C or D above).",
      "ja": "2) セクション5.1.5のステップ2で説明されているように、状態Cookieを認証します（これは上記のケースCまたはDです）。"
    },
    {
      "indent": 3,
      "text": "3) Compare the timestamp in the State Cookie to the current time. If the State Cookie is older than the lifespan carried in the State Cookie and the Verification Tags contained in the State Cookie do not match the current association's Verification Tags, the packet, including the COOKIE ECHO and any DATA chunks, should be discarded. The endpoint also MUST transmit an ERROR chunk with a \"Stale Cookie\" error cause to the peer endpoint (this is case C or D in section 5.2).",
      "ja": "3) 州のクッキーのタイムスタンプを現在の時刻と比較してください。状態CookieがState Cookieで運ばれた寿命よりも古く、State Cookieに含まれる検証タグが現在の協会の検証タグと一致しない場合、Cookie Echoやデータチャンクを含むパケットは廃棄する必要があります。また、エンドポイントは、「古いクッキー」エラー原因でエラーチャンクをピアエンドポイントに送信する必要があります（これはセクション5.2のケースCまたはDです）。"
    },
    {
      "indent": 6,
      "text": "If both Verification Tags in the State Cookie match the Verification Tags of the current association, consider the State Cookie valid (this is case E of section 5.2) even if the lifespan is exceeded.",
      "ja": "状態Cookieの両方の検証タグが現在の協会の検証タグと一致する場合、寿命を超えている場合でも、状態Cookie有効（これはセクション5.2のケースE）を検討してください。"
    },
    {
      "indent": 3,
      "text": "4) If the State Cookie proves to be valid, unpack the TCB into a temporary TCB.",
      "ja": "4) State Cookieが有効であることが証明されている場合は、TCBを一時的なTCBに解除します。"
    },
    {
      "indent": 3,
      "text": "5) Refer to Table 2 to determine the correct action to be taken.",
      "ja": "5) 表2を参照して、取られる正しいアクションを決定します。"
    },
    {
      "indent": 0,
      "text": "+------------+------------+---------------+--------------+-------------+\n|  Local Tag | Peer's Tag | Local-Tie-Tag |Peer's-Tie-Tag|   Action/   |\n|            |            |               |              | Description |\n+------------+------------+---------------+--------------+-------------+\n|    X       |     X      |      M        |      M       |     (A)     |\n+------------+------------+---------------+--------------+-------------+\n|    M       |     X      |      A        |      A       |     (B)     |\n+------------+------------+---------------+--------------+-------------+\n|    M       |     0      |      A        |      A       |     (B)     |\n+------------+------------+---------------+--------------+-------------+\n|    X       |     M      |      0        |      0       |     (C)     |\n+------------+------------+---------------+--------------+-------------+\n|    M       |     M      |      A        |      A       |     (D)     |\n+======================================================================+\n|       Table 2: Handling of a COOKIE ECHO when a TCB exists           |\n+======================================================================+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Legend:",
      "ja": "伝説："
    },
    {
      "indent": 6,
      "text": "X - Tag does not match the existing TCB M - Tag matches the existing TCB. 0 - No Tie-Tag in Cookie (unknown). A - All cases, i.e. M, X or 0.",
      "ja": "X -TAGは既存のTCB Mと一致しません - タグは既存のTCBと一致します。0-クッキーのタイタグなし（不明）。A-すべての場合、つまりm、x、または0。"
    },
    {
      "indent": 3,
      "text": "Note: For any case not shown in Table 2, the cookie should be silently discarded.",
      "ja": "注：表2に示されていない場合は、Cookieを静かに廃棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "Action",
      "ja": "アクション"
    },
    {
      "indent": 3,
      "text": "A) In this case, the peer may have restarted. When the endpoint recognizes this potential 'restart', the existing session is treated the same as if it received an ABORT followed by a new COOKIE ECHO with the following exceptions:",
      "ja": "a）この場合、ピアが再起動した可能性があります。エンドポイントがこの潜在的な「再起動」を認識すると、既存のセッションは、以下の例外を除いて、中止を受け取った場合と同じように扱われます。"
    },
    {
      "indent": 6,
      "text": "- Any SCTP DATA Chunks MAY be retained (this is an implementation specific option).",
      "ja": "- SCTPデータチャンクが保持される場合があります（これは実装固有のオプションです）。"
    },
    {
      "indent": 6,
      "text": "- A notification of RESTART SHOULD be sent to the ULP instead of a \"COMMUNICATION LOST\" notification.",
      "ja": "- 再起動の通知は、「通信が失われた」通知の代わりにULPに送信する必要があります。"
    },
    {
      "indent": 6,
      "text": "All the congestion control parameters (e.g., cwnd, ssthresh) related to this peer MUST be reset to their initial values (see Section 6.2.1).",
      "ja": "このピアに関連するすべての混雑制御パラメーター（例：CWND、SSTHRESH）は、初期値にリセットする必要があります（セクション6.2.1を参照）。"
    },
    {
      "indent": 6,
      "text": "After this the endpoint shall enter the ESTABLISHED state.",
      "ja": "この後、エンドポイントは確立された状態に入ります。"
    },
    {
      "indent": 6,
      "text": "If the endpoint is in the SHUTDOWN-ACK-SENT state and recognizes the peer has restarted (Action A), it MUST NOT setup a new association but instead resend the SHUTDOWN ACK and send an ERROR chunk with a \"Cookie Received while Shutting Down\" error cause to its peer.",
      "ja": "エンドポイントがShutdown-ack-Sent状態にあり、ピアが再起動したことを認識している場合（アクションA）、新しい関連付けをセットアップしないでください。エラーはピアに原因です。"
    },
    {
      "indent": 3,
      "text": "B) In this case, both sides may be attempting to start an association at about the same time but the peer endpoint started its INIT after responding to the local endpoint's INIT. Thus it may have picked a new Verification Tag not being aware of the previous Tag it had sent this endpoint. The endpoint should stay in or enter the ESTABLISHED state but it MUST update its peer's Verification Tag from the State Cookie, stop any init or cookie timers that may running and send a COOKIE ACK.",
      "ja": "b）この場合、双方はほぼ同時に協会を開始しようとしているかもしれませんが、ピアエンドポイントはローカルエンドポイントのinitに応答した後、INITを開始しました。したがって、このエンドポイントを送信した以前のタグを認識していない新しい検証タグを選択した可能性があります。エンドポイントは、確立された状態にとどまるか入力する必要がありますが、州のCookieからピアの検証タグを更新し、実行してCookie ACKを送信する可能性のあるInitまたはCookieタイマーを停止する必要があります。"
    },
    {
      "indent": 3,
      "text": "C) In this case, the local endpoint's cookie has arrived late. Before it arrived, the local endpoint sent an INIT and received an INIT-ACK and finally sent a COOKIE ECHO with the peer's same tag but a new tag of its own. The cookie should be silently discarded. The endpoint SHOULD NOT change states and should leave any timers running.",
      "ja": "c）この場合、ローカルエンドポイントのCookieが遅れて到着しました。到着する前に、ローカルのエンドポイントは初期的なものを送信し、イニシックを受け取り、最終的にピアの同じタグを使用してCookieエコーを送信しましたが、それ自体の新しいタグを送信しました。Cookieは静かに廃棄する必要があります。エンドポイントは状態を変更してはならず、タイマーを実行したままにしておく必要があります。"
    },
    {
      "indent": 3,
      "text": "D) When both local and remote tags match the endpoint should always enter the ESTABLISHED state, if it has not already done so. It should stop any init or cookie timers that may be running and send a COOKIE ACK.",
      "ja": "d）ローカルとリモートの両方のタグが一致する場合、エンドポイントは、まだ行っていない場合は常に確立された状態に入る必要があります。実行している可能性のあるinitまたはcookieタイマーを停止し、Cookie ACKを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: The \"peer's Verification Tag\" is the tag received in the Initiate Tag field of the INIT or INIT ACK chunk.",
      "ja": "注：「ピアの検証タグ」は、initまたはinit ackチャンクの開始タグフィールドで受信したタグです。"
    },
    {
      "indent": 0,
      "text": "5.2.4.1 An Example of a Association Restart",
      "section_title": true,
      "ja": "5.2.4.1 アソシエーションの再起動の例"
    },
    {
      "indent": 3,
      "text": "In the following example, \"A\" initiates the association after a restart has occurred. Endpoint \"Z\" had no knowledge of the restart until the exchange (i.e. Heartbeats had not yet detected the failure of \"A\"). (assuming no bundling or fragmentation occurs):",
      "ja": "次の例では、再起動が発生した後、「A」が協会を開始します。Endpoint \"z\"は、交換まで再起動の知識がありませんでした（つまり、Heartbeatsはまだ「A」の障害を検出していませんでした）。（バンドルや断片化が発生しないと仮定）："
    },
    {
      "indent": 0,
      "text": "Endpoint A                                          Endpoint Z\n<-------------- Association is established---------------------->\nTag=Tag_A                                             Tag=Tag_Z\n<--------------------------------------------------------------->\n{A crashes and restarts}\n{app sets up a association with Z}\n(build TCB)\nINIT [I-Tag=Tag_A'\n      & other info]  --------\\\n(Start T1-init timer)         \\\n(Enter COOKIE-WAIT state)      \\---> (find a existing TCB\n                                      compose temp TCB and Cookie_Z\n                                      with Tie-Tags to previous\n                                      association)\n                                /--- INIT ACK [Veri Tag=Tag_A',\n                               /               I-Tag=Tag_Z',\n(Cancel T1-init timer) <------/                Cookie_Z[TieTags=\n                                               Tag_A,Tag_Z\n                                                & other info]\n                                     (destroy temp TCB,leave original\n                                      in place)\nCOOKIE ECHO [Veri=Tag_Z',\n             Cookie_Z\n             Tie=Tag_A,\n             Tag_Z]----------\\\n(Start T1-init timer)         \\\n(Enter COOKIE-ECHOED state)    \\---> (Find existing association,\n                                      Tie-Tags match old tags,\n                                      Tags do not match i.e.\n                                      case X X M M above,\n                                      Announce Restart to ULP\n                                      and reset association).\n                               /---- COOKIE-ACK\n                              /\n(Cancel T1-init timer, <-----/\n Enter ESTABLISHED state)\n{app sends 1st user data; strm 0}\nDATA [TSN=initial TSN_A\n     Strm=0,Seq=1 & user data]--\\\n(Start T3-rtx timer)            \\\n                                 \\->\n                              /----- SACK [TSN Ack=init TSN_A,Block=0]\n(Cancel T3-rtx timer) <------/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Figure 5: A Restart Example",
      "ja": "図5：再起動例"
    },
    {
      "indent": 0,
      "text": "5.2.5 Handle Duplicate COOKIE-ACK.",
      "ja": "5.2.5 重複したクッキー - を処理します。"
    },
    {
      "indent": 3,
      "text": "At any state other than COOKIE-ECHOED, an endpoint should silently discard a received COOKIE ACK chunk.",
      "ja": "Cookieエコー以外のどの状態でも、エンドポイントは、受け取ったCookie ACKチャンクを静かに廃棄する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.6 Handle Stale COOKIE Error",
      "section_title": true,
      "ja": "5.2.6 古いクッキーエラーを処理します"
    },
    {
      "indent": 3,
      "text": "Receipt of an ERROR chunk with a \"Stale Cookie\" error cause indicates one of a number of possible events:",
      "ja": "「古いクッキー」エラーの原因でエラーチャンクの受信は、可能なイベントの1つを示しています。"
    },
    {
      "indent": 3,
      "text": "A) That the association failed to completely setup before the State Cookie issued by the sender was processed.",
      "ja": "a）送信者が発行した州のCookieが処理される前に、協会が完全にセットアップできなかったこと。"
    },
    {
      "indent": 3,
      "text": "B) An old State Cookie was processed after setup completed.",
      "ja": "b）セットアップが完了した後、古い州のクッキーが処理されました。"
    },
    {
      "indent": 3,
      "text": "C) An old State Cookie is received from someone that the receiver is not interested in having an association with and the ABORT chunk was lost.",
      "ja": "c）古い州のクッキーは、レシーバーが関連性を持つことに興味がなく、中止チャンクが失われた人から受け取られます。"
    },
    {
      "indent": 3,
      "text": "When processing an ERROR chunk with a \"Stale Cookie\" error cause an endpoint should first examine if an association is in the process of being setup, i.e. the association is in the COOKIE-ECHOED state. In all cases if the association is not in the COOKIE-ECHOED state, the ERROR chunk should be silently discarded.",
      "ja": "「古いCookie」エラーでエラーチャンクを処理する場合、エンドポイントは、関連性がセットアップの過程にあるかどうか、つまり、関連性がCookieでエコーされた状態であるかどうかを最初に調べる必要があります。すべての場合において、協会がCookieでエコーされた状態にない場合、エラーチャンクは静かに廃棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the association is in the COOKIE-ECHOED state, the endpoint may elect one of the following three alternatives.",
      "ja": "協会がCookieでエコーされた状態にある場合、エンドポイントは次の3つの選択肢のいずれかを選択する場合があります。"
    },
    {
      "indent": 3,
      "text": "1) Send a new INIT chunk to the endpoint to generate a new State Cookie and re-attempt the setup procedure.",
      "ja": "1) 新しい状態Cookieを生成するために、新しいInitチャンクをエンドポイントに送信し、セットアップ手順を再検討します。"
    },
    {
      "indent": 3,
      "text": "2) Discard the TCB and report to the upper layer the inability to setup the association.",
      "ja": "2) TCBを廃棄し、関連性をセットアップできないことを上層に報告します。"
    },
    {
      "indent": 3,
      "text": "3) Send a new INIT chunk to the endpoint, adding a Cookie Preservative parameter requesting an extension to the lifetime of the State Cookie. When calculating the time extension, an implementation SHOULD use the RTT information measured based on the previous COOKIE ECHO / ERROR exchange, and should add no more than 1 second beyond the measured RTT, due to long State Cookie lifetimes making the endpoint more subject to a replay attack.",
      "ja": "3) エンドポイントに新しいinit chunkを送信し、州のクッキーの寿命の延長を要求するCookie防腐剤パラメーターを追加します。時間延長を計算する場合、実装は、以前のCookieエコー /エラー交換に基づいて測定されたRTT情報を使用する必要があります。長い状態Cookieの寿命により、エンドポイントがより多くの対象となるため、測定されたRTTを超えて1秒以内に追加する必要があります。リプレイ攻撃。"
    },
    {
      "indent": 0,
      "text": "5.3 Other Initialization Issues",
      "section_title": true,
      "ja": "5.3 その他の初期化の問題"
    },
    {
      "indent": 0,
      "text": "5.3.1 Selection of Tag Value",
      "section_title": true,
      "ja": "5.3.1 タグ値の選択"
    },
    {
      "indent": 3,
      "text": "Initiate Tag values should be selected from the range of 1 to 2**32 - 1. It is very important that the Initiate Tag value be randomized to help protect against \"man in the middle\" and \"sequence number\" attacks. The methods described in [RFC1750] can be used for the Initiate Tag randomization. Careful selection of Initiate Tags is also necessary to prevent old duplicate packets from previous associations being mistakenly processed as belonging to the current association.",
      "ja": "タグ値を開始すると、1〜2 ** 32-1の範囲から選択する必要があります。「中央の男性」および「シーケンス番号」攻撃から保護するために、開始タグ値をランダム化することが非常に重要です。[RFC1750]で説明されている方法は、開始タグのランダム化に使用できます。開始タグの慎重な選択は、現在の関連付けに属すると誤って処理される以前の関連付けから古い重複パケットを防ぐためにも必要です。"
    },
    {
      "indent": 3,
      "text": "Moreover, the Verification Tag value used by either endpoint in a given association MUST NOT change during the lifetime of an association. A new Verification Tag value MUST be used each time the endpoint tears-down and then re-establishes an association to the same peer.",
      "ja": "さらに、特定の関連付けのいずれかのエンドポイントで使用される検証タグ値は、協会の存続期間中に変更されてはなりません。エンドポイントが引き裂かれ、同じピアに関連性を再確立するたびに、新しい検証タグ値を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "6. User Data Transfer",
      "section_title": true,
      "ja": "6. ユーザーデータ転送"
    },
    {
      "indent": 3,
      "text": "Data transmission MUST only happen in the ESTABLISHED, SHUTDOWN-PENDING, and SHUTDOWN-RECEIVED states. The only exception to this is that DATA chunks are allowed to be bundled with an outbound COOKIE ECHO chunk when in COOKIE-WAIT state.",
      "ja": "データ送信は、確立された、シャットダウンペンディング、およびシャットダウンが推定される状態でのみ発生する必要があります。これの唯一の例外は、Cookie-Wait状態の場合、データチャンクをアウトバウンドクッキーエコーチャンクにバンドルできることです。"
    },
    {
      "indent": 3,
      "text": "DATA chunks MUST only be received according to the rules below in ESTABLISHED, SHUTDOWN-PENDING, SHUTDOWN-SENT. A DATA chunk received in CLOSED is out of the blue and SHOULD be handled per 8.4. A DATA chunk received in any other state SHOULD be discarded.",
      "ja": "データチャンクは、以下のルールに従って、確立されたシャットダウンペンディング、シャットダウンセントでのみ受信する必要があります。閉じた状態で受け取ったデータチャンクは青から外れており、8.4あたり処理する必要があります。他の州で受け取ったデータチャンクは廃棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "A SACK MUST be processed in ESTABLISHED, SHUTDOWN-PENDING, and SHUTDOWN-RECEIVED. An incoming SACK MAY be processed in COOKIE-ECHOED. A SACK in the CLOSED state is out of the blue and SHOULD be processed according to the rules in 8.4. A SACK chunk received in any other state SHOULD be discarded.",
      "ja": "袋は、確立されたシャットダウンペンディング、およびシャットダウンで処理される必要があります。入ってくる袋は、Cookieエコーで処理される場合があります。閉じた状態の袋は青から外れており、8.4のルールに従って処理する必要があります。他の州で受け取った袋の塊は廃棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "A SCTP receiver MUST be able to receive a minimum of 1500 bytes in one SCTP packet. This means that a SCTP endpoint MUST NOT indicate less than 1500 bytes in its Initial a_rwnd sent in the INIT or INIT ACK.",
      "ja": "SCTPレシーバーは、1つのSCTPパケットで最低1500バイトを受信できる必要があります。これは、SCTPエンドポイントが、initまたはinit ackで送信された最初のa_rwndで1500バイト未満を示してはならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "For transmission efficiency, SCTP defines mechanisms for bundling of small user messages and fragmentation of large user messages. The following diagram depicts the flow of user messages through SCTP.",
      "ja": "送信効率のために、SCTPは、小さなユーザーメッセージのバンドルと大規模なユーザーメッセージの断片化のメカニズムを定義します。次の図は、SCTPを介したユーザーメッセージのフローを示しています。"
    },
    {
      "indent": 3,
      "text": "In this section the term \"data sender\" refers to the endpoint that transmits a DATA chunk and the term \"data receiver\" refers to the endpoint that receives a DATA chunk. A data receiver will transmit SACK chunks.",
      "ja": "このセクションでは、「データ送信者」という用語は、データチャンクを送信するエンドポイントを指し、「データレシーバー」という用語は、データチャンクを受信するエンドポイントを指します。データレシーバーは、サックチャンクを送信します。"
    },
    {
      "indent": 6,
      "text": "           +--------------------------+\n           |      User Messages       |\n           +--------------------------+\n SCTP user        ^  |\n==================|==|=======================================\n                  |  v (1)\n       +------------------+    +--------------------+\n       | SCTP DATA Chunks |    |SCTP Control Chunks |\n       +------------------+    +--------------------+\n                  ^  |             ^  |\n                  |  v (2)         |  v (2)\n               +--------------------------+\n               |      SCTP packets        |\n               +--------------------------+\n SCTP                      ^  |\n===========================|==|===========================\n                           |  v\n       Connectionless Packet Transfer Service (e.g., IP)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Notes:",
      "ja": "ノート："
    },
    {
      "indent": 6,
      "text": "1) When converting user messages into DATA chunks, an endpoint will fragment user messages larger than the current association path MTU into multiple DATA chunks. The data receiver will normally reassemble the fragmented message from DATA chunks before delivery to the user (see Section 6.9 for details).",
      "ja": "1) ユーザーメッセージをデータチャンクに変換すると、エンドポイントは現在のAssociation Path MTUよりも大きいユーザーメッセージを複数のデータチャンクに分割します。データレシーバーは通常、ユーザーに配信する前に、データチャンクからの断片化されたメッセージを再組み立てします（詳細については、セクション6.9を参照）。"
    },
    {
      "indent": 6,
      "text": "2) Multiple DATA and control chunks may be bundled by the sender into a single SCTP packet for transmission, as long as the final size of the packet does not exceed the current path MTU. The receiver will unbundle the packet back into the original chunks. Control chunks MUST come before DATA chunks in the packet.",
      "ja": "2) パケットの最終サイズが現在のパスMTUを超えない限り、複数のデータと制御チャンクが送信者によって単一のSCTPパケットにバンドルされる場合があります。受信機は、パケットを元のチャンクに戻します。パケット内のデータチャンクの前に、コントロールチャンクが来なければなりません。"
    },
    {
      "indent": 16,
      "text": "Figure 6: Illustration of User Data Transfer",
      "ja": "図6：ユーザーデータ転送の図"
    },
    {
      "indent": 3,
      "text": "The fragmentation and bundling mechanisms, as detailed in Sections 6.9 and 6.10, are OPTIONAL to implement by the data sender, but they MUST be implemented by the data receiver, i.e., an endpoint MUST properly receive and process bundled or fragmented data.",
      "ja": "セクション6.9および6.10で詳述されているように、断片化とバンドルメカニズムはデータ送信者によって実装するためにオプションですが、データ受信機によって実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1 Transmission of DATA Chunks",
      "section_title": true,
      "ja": "6.1 データチャンクの送信"
    },
    {
      "indent": 3,
      "text": "This document is specified as if there is a single retransmission timer per destination transport address, but implementations MAY have a retransmission timer for each DATA chunk.",
      "ja": "このドキュメントは、宛先輸送アドレスごとに単一の再送信タイマーがあるかのように指定されていますが、実装には各データチャンクの再送信タイマーがある場合があります。"
    },
    {
      "indent": 3,
      "text": "The following general rules MUST be applied by the data sender for transmission and/or retransmission of outbound DATA chunks:",
      "ja": "以下の一般的なルールは、送信および/またはアウトバウンドデータチャンクの再送信のためにデータ送信者によって適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "A) At any given time, the data sender MUST NOT transmit new data to any destination transport address if its peer's rwnd indicates that the peer has no buffer space (i.e. rwnd is 0, see Section 6.2.1). However, regardless of the value of rwnd (including if it is 0), the data sender can always have one DATA chunk in flight to the receiver if allowed by cwnd (see rule B below). This rule allows the sender to probe for a change in rwnd that the sender missed due to the SACK having been lost in transit from the data receiver to the data sender.",
      "ja": "a）特定の時間に、ピアのRWNDがピアにバッファスペースがないことを示している場合、データ送信者は任意の宛先輸送アドレスに新しいデータを送信してはなりません（つまり、RWNDは0、セクション6.2.1を参照）。ただし、RWNDの値（0の場合を含む）に関係なく、データ送信者は、CWNDで許可されている場合は常に1つのデータチャンクを受信機に渡すことができます（以下のルールBを参照）。このルールにより、送信者は、データ受信者からデータ送信者への輸送中に袋が失われたために送信者が逃したRWNDの変更のために調査することができます。"
    },
    {
      "indent": 3,
      "text": "B) At any given time, the sender MUST NOT transmit new data to a given transport address if it has cwnd or more bytes of data outstanding to that transport address.",
      "ja": "b）特定の時間に、送信者は、CWND以上のデータのバイトがその輸送アドレスに存在する場合、特定の輸送アドレスに新しいデータを送信してはなりません。"
    },
    {
      "indent": 3,
      "text": "C) When the time comes for the sender to transmit, before sending new DATA chunks, the sender MUST first transmit any outstanding DATA chunks which are marked for retransmission (limited by the current cwnd).",
      "ja": "c）新しいデータチャンクを送信する前に送信者が送信する時が来たとき、送信者は最初に再送信のためにマークされた未解決のデータチャンクを送信する必要があります（現在のCWNDによって制限されます）。"
    },
    {
      "indent": 3,
      "text": "D) Then, the sender can send out as many new DATA chunks as Rule A and Rule B above allow.",
      "ja": "d）その後、送信者は、上記のルールAおよびルールBが許可するのと同じくらい多くの新しいデータチャンクを送信できます。"
    },
    {
      "indent": 3,
      "text": "Multiple DATA chunks committed for transmission MAY be bundled in a single packet. Furthermore, DATA chunks being retransmitted MAY be bundled with new DATA chunks, as long as the resulting packet size does not exceed the path MTU. A ULP may request that no bundling is performed but this should only turn off any delays that a SCTP implementation may be using to increase bundling efficiency. It does not in itself stop all bundling from occurring (i.e. in case of congestion or retransmission).",
      "ja": "送信のためにコミットされた複数のデータチャンクは、単一のパケットにバンドルされる場合があります。さらに、再送信されるデータチャンクは、結果のパケットサイズがPATH MTUを超えない限り、新しいデータチャンクにバンドルされる場合があります。ULPは、バンドルが実行されないことを要求する場合がありますが、これはSCTP実装がバンドル効率を高めるために使用している遅延のみをオフにするだけです。それ自体は、すべてのバンドルが発生するのを止めません（つまり、混雑または再送信の場合）。"
    },
    {
      "indent": 3,
      "text": "Before an endpoint transmits a DATA chunk, if any received DATA chunks have not been acknowledged (e.g., due to delayed ack), the sender should create a SACK and bundle it with the outbound DATA chunk, as long as the size of the final SCTP packet does not exceed the current MTU. See Section 6.2.",
      "ja": "エンドポイントがデータチャンクを送信する前に、受信したデータチャンクが認められていない場合（たとえば、ACKが遅延したため）、送信者はサックを作成し、最終的なSCTPのサイズのサイズがある限り、アウトバウンドデータチャンクでそれをバンドルする必要がありますパケットは現在のMTUを超えません。セクション6.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: When the window is full (i.e., transmission is disallowed by Rule A and/or Rule B), the sender MAY still accept send requests from its upper layer, but MUST transmit no more DATA chunks until some or all of the outstanding DATA chunks are acknowledged and transmission is allowed by Rule A and Rule B again.",
      "ja": "実装注：ウィンドウがいっぱいになった場合（つまり、伝送がルールAおよび/またはルールBによって許可されていない場合）、送信者は引き続き上層からの送信要求を受け入れることができますが、未払いの一部またはすべてが発行済みの一部またはすべてになるまで、これ以上のデータチャンクを送信する必要があります。データチャンクが認められ、ルールAとルールBによって再度送信が許可されます。"
    },
    {
      "indent": 3,
      "text": "Whenever a transmission or retransmission is made to any address, if the T3-rtx timer of that address is not currently running, the sender MUST start that timer. If the timer for that address is already running, the sender MUST restart the timer if the earliest (i.e., lowest TSN) outstanding DATA chunk sent to that address is being retransmitted. Otherwise, the data sender MUST NOT restart the timer.",
      "ja": "アドレスに送信または再送信が行われるたびに、そのアドレスのT3-RTXタイマーが現在実行されていない場合、送信者はそのタイマーを開始する必要があります。そのアドレスのタイマーが既に実行されている場合、そのアドレスに送信された最も早い（つまり、最も低いTSN）顕著なデータチャンクが再送信されている場合、送信者はタイマーを再起動する必要があります。それ以外の場合、データ送信者はタイマーを再起動してはなりません。"
    },
    {
      "indent": 3,
      "text": "When starting or restarting the T3-rtx timer, the timer value must be adjusted according to the timer rules defined in Sections 6.3.2, and 6.3.3.",
      "ja": "T3-RTXタイマーを起動または再起動するときは、セクション6.3.2および6.3.3で定義されているタイマールールに従ってタイマー値を調整する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: The data sender SHOULD NOT use a TSN that is more than 2**31 - 1 above the beginning TSN of the current send window.",
      "ja": "注：データ送信者は、現在の送信ウィンドウの最初のTSNの上に2 ** 31-1を超えるTSNを使用しないでください。"
    },
    {
      "indent": 0,
      "text": "6.2 Acknowledgement on Reception of DATA Chunks",
      "section_title": true,
      "ja": "6.2 データチャンクの受信に関する謝辞"
    },
    {
      "indent": 3,
      "text": "The SCTP endpoint MUST always acknowledge the reception of each valid DATA chunk.",
      "ja": "SCTPエンドポイントは、常に有効なデータチャンクの受信を常に確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "The guidelines on delayed acknowledgement algorithm specified in Section 4.2 of [RFC2581] SHOULD be followed. Specifically, an acknowledgement SHOULD be generated for at least every second packet (not every second DATA chunk) received, and SHOULD be generated within 200 ms of the arrival of any unacknowledged DATA chunk. In some situations it may be beneficial for an SCTP transmitter to be more conservative than the algorithms detailed in this document allow. However, an SCTP transmitter MUST NOT be more aggressive than the following algorithms allow.",
      "ja": "[RFC2581]のセクション4.2で指定された遅延承認アルゴリズムに関するガイドラインに従う必要があります。具体的には、少なくとも2秒ごとのパケット（各2秒のデータチャンクではない）ごとに確認を生成する必要があり、未解決のデータチャンクの到着から200ミリ秒以内に生成する必要があります。状況によっては、SCTP送信機がこのドキュメントで詳述されているアルゴリズムよりも保守的であることが有益である可能性があります。ただし、SCTP送信機は、次のアルゴリズムが許可するよりも攻撃的であってはなりません。"
    },
    {
      "indent": 3,
      "text": "A SCTP receiver MUST NOT generate more than one SACK for every incoming packet, other than to update the offered window as the receiving application consumes new data.",
      "ja": "SCTPレシーバーは、受信アプリケーションが新しいデータを消費するため、提供されるウィンドウを更新する以外に、着信パケットごとに複数のサックを生成してはなりません。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: The maximum delay for generating an acknowledgement may be configured by the SCTP administrator, either statically or dynamically, in order to meet the specific timing requirement of the protocol being carried.",
      "ja": "実装注：確認を生成するための最大遅延は、実行中のプロトコルの特定のタイミング要件を満たすために、静的または動的にSCTP管理者によって構成される場合があります。"
    },
    {
      "indent": 3,
      "text": "An implementation MUST NOT allow the maximum delay to be configured to be more than 500 ms. In other words an implementation MAY lower this value below 500ms but MUST NOT raise it above 500ms.",
      "ja": "実装により、最大遅延を500ミリ秒以上構成することを許可してはなりません。言い換えれば、実装はこの値を500mm未満に下げる可能性がありますが、500msを超えて上昇してはなりません。"
    },
    {
      "indent": 3,
      "text": "Acknowledgements MUST be sent in SACK chunks unless shutdown was requested by the ULP in which case an endpoint MAY send an acknowledgement in the SHUTDOWN chunk. A SACK chunk can acknowledge the reception of multiple DATA chunks. See Section 3.3.4 for SACK chunk format. In particular, the SCTP endpoint MUST fill in the Cumulative TSN Ack field to indicate the latest sequential TSN (of a valid DATA chunk) it has received. Any received DATA chunks with TSN greater than the value in the Cumulative TSN Ack field SHOULD also be reported in the Gap Ack Block fields.",
      "ja": "ULPによってシャットダウンが要求されない限り、謝辞はサックチャンクで送信する必要があります。サックチャンクは、複数のデータチャンクの受信を認めることができます。サックチャンク形式については、セクション3.3.4を参照してください。特に、SCTPエンドポイントは、累積TSN ACKフィールドを埋めて、受け取った最新の順次TSN（有効なデータチャンクの）を示す必要があります。累積TSN ACKフィールドの値よりも大きいTSNを持つ受信したデータチャンクも、GAP ACKブロックフィールドで報告する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: The SHUTDOWN chunk does not contain Gap Ack Block fields. Therefore, the endpoint should use a SACK instead of the SHUTDOWN chunk to acknowledge DATA chunks received out of order .",
      "ja": "注：シャットダウンチャンクには、ギャップACKブロックフィールドは含まれていません。したがって、エンドポイントは、シャットダウンチャンクの代わりにサックを使用して、故障したデータチャンクを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "When a packet arrives with duplicate DATA chunk(s) and with no new DATA chunk(s), the endpoint MUST immediately send a SACK with no delay. If a packet arrives with duplicate DATA chunk(s) bundled with new DATA chunks, the endpoint MAY immediately send a SACK. Normally receipt of duplicate DATA chunks will occur when the original SACK chunk was lost and the peer's RTO has expired. The duplicate TSN number(s) SHOULD be reported in the SACK as duplicate.",
      "ja": "複製データチャンクでパケットが到着し、新しいデータチャンクなしで到着すると、エンドポイントはすぐに遅延なしで袋を送信する必要があります。新しいデータチャンクにバンドルされた複製データチャンクでパケットが到着すると、エンドポイントはすぐに袋を送信する場合があります。通常、重複したデータチャンクの受領は、元のサックチャンクが失われ、ピアのRTOが失効したときに発生します。重複したTSN番号は、袋に複製として報告する必要があります。"
    },
    {
      "indent": 3,
      "text": "When an endpoint receives a SACK, it MAY use the Duplicate TSN information to determine if SACK loss is occurring. Further use of this data is for future study.",
      "ja": "エンドポイントが袋を受け取ると、重複したTSN情報を使用して、袋の損失が発生しているかどうかを判断する場合があります。このデータのさらなる使用は、将来の研究のためです。"
    },
    {
      "indent": 3,
      "text": "The data receiver is responsible for maintaining its receive buffers. The data receiver SHOULD notify the data sender in a timely manner of changes in its ability to receive data. How an implementation manages its receive buffers is dependent on many factors (e.g., Operating System, memory management system, amount of memory, etc.). However, the data sender strategy defined in Section 6.2.1 is based on the assumption of receiver operation similar to the following:",
      "ja": "データレシーバーは、受信バッファーを維持する責任があります。データ受信者は、データを受信する機能をタイムリーに変更してデータ送信者に通知する必要があります。実装が受信バッファーを管理する方法は、多くの要因（オペレーティングシステム、メモリ管理システム、メモリ量など）に依存します。ただし、セクション6.2.1で定義されているデータ送信者戦略は、以下と同様のレシーバー操作の仮定に基づいています。"
    },
    {
      "indent": 6,
      "text": "A) At initialization of the association, the endpoint tells the peer how much receive buffer space it has allocated to the association in the INIT or INIT ACK. The endpoint sets a_rwnd to this value.",
      "ja": "a）協会の初期化時に、エンドポイントはピアに、initまたはinit ackの協会に割り当てられたバッファースペースを受け取る量を伝えます。エンドポイントは、A_RWNDをこの値に設定します。"
    },
    {
      "indent": 6,
      "text": "B) As DATA chunks are received and buffered, decrement a_rwnd by the number of bytes received and buffered. This is, in effect, closing rwnd at the data sender and restricting the amount of data it can transmit.",
      "ja": "b）データチャンクが受信および緩衝されると、受信およびバッファーされたバイト数によってA_RWNDを減少させます。これは、実際には、データ送信者でRWNDを閉じ、送信できるデータの量を制限することです。"
    },
    {
      "indent": 6,
      "text": "C) As DATA chunks are delivered to the ULP and released from the receive buffers, increment a_rwnd by the number of bytes delivered to the upper layer. This is, in effect, opening up rwnd on the data sender and allowing it to send more data. The data receiver SHOULD NOT increment a_rwnd unless it has released bytes from its receive buffer. For example, if the receiver is holding fragmented DATA chunks in a reassembly queue, it should not increment a_rwnd.",
      "ja": "c）データチャンクがULPに配信され、受信バッファーから解放されると、上層に配信されるバイト数によってA_RWNDを増やします。これは、実際には、データ送信者にRWNDを開き、より多くのデータを送信できるようにしています。データレシーバーは、受信バッファーからバイトをリリースしない限り、A_RWNDを増やすべきではありません。たとえば、受信者が断片化されたデータチャンクを再組み立てキューに保持している場合、A_RWNDを増やす必要はありません。"
    },
    {
      "indent": 6,
      "text": "D) When sending a SACK, the data receiver SHOULD place the current value of a_rwnd into the a_rwnd field. The data receiver SHOULD take into account that the data sender will not retransmit DATA chunks that are acked via the Cumulative TSN Ack (i.e., will drop from its retransmit queue).",
      "ja": "d）袋を送信するとき、データレシーバーはA_RWNDの現在の値をA_RWNDフィールドに配置する必要があります。データ受信者は、データ送信者が累積TSN ACKを介してAckされるデータチャンクを再送信しないことを考慮に入れる必要があります（つまり、再送信キューからドロップします）。"
    },
    {
      "indent": 3,
      "text": "Under certain circumstances, the data receiver may need to drop DATA chunks that it has received but hasn't released from its receive buffers (i.e., delivered to the ULP). These DATA chunks may have been acked in Gap Ack Blocks. For example, the data receiver may be holding data in its receive buffers while reassembling a fragmented user message from its peer when it runs out of receive buffer space. It may drop these DATA chunks even though it has acknowledged them in Gap Ack Blocks. If a data receiver drops DATA chunks, it MUST NOT include them in Gap Ack Blocks in subsequent SACKs until they are received again via retransmission. In addition, the endpoint should take into account the dropped data when calculating its a_rwnd.",
      "ja": "特定の状況では、データ受信機は、受信したが受信バッファーから放出されていないデータチャンクをドロップする必要がある場合があります（つまり、ULPに配信されます）。これらのデータチャンクは、ギャップACKブロックでAckedされている可能性があります。たとえば、データレシーバーは、受信バッファースペースがなくなったときにピアから断片化されたユーザーメッセージを再組み立てしながら、受信バッファーにデータを保持している場合があります。GAPACKブロックでそれらを認めているにもかかわらず、これらのデータチャンクをドロップする可能性があります。データレシーバーがデータチャンクをドロップする場合、再送信により再び受信されるまで、後続のサックのGAPACKブロックにそれらを含めてはなりません。さらに、エンドポイントは、A_RWNDを計算するときに削除されたデータを考慮に入れる必要があります。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD NOT revoke a SACK and discard data. Only in extreme circumstance should an endpoint use this procedure (such as out of buffer space). The data receiver should take into account that dropping data that has been acked in Gap Ack Blocks can result in suboptimal retransmission strategies in the data sender and thus in suboptimal performance.",
      "ja": "エンドポイントは、袋を取り消してデータを破棄してはなりません。極端な状況でのみ、エンドポイントがこの手順（バッファスペースからの外など）を使用する必要があります。データレシーバーは、GAP ACKブロックでAckされているデータをドロップすると、データ送信者の最適ではない再送信戦略が発生し、したがって最適ではないパフォーマンスが発生する可能性があることを考慮に入れる必要があります。"
    },
    {
      "indent": 3,
      "text": "The following example illustrates the use of delayed acknowledgements: Endpoint A Endpoint Z",
      "ja": "次の例は、遅延承認の使用を示しています：エンドポイントAエンドポイントZ"
    },
    {
      "indent": 3,
      "text": "{App sends 3 messages; strm 0}\nDATA [TSN=7,Strm=0,Seq=3] ------------> (ack delayed)\n(Start T3-rtx timer)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DATA [TSN=8,Strm=0,Seq=4] ------------> (send ack)\n                              /------- SACK [TSN Ack=8,block=0]\n(cancel T3-rtx timer)  <-----/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DATA [TSN=9,Strm=0,Seq=5] ------------> (ack delayed)\n(Start T3-rtx timer)\n                                       ...\n                                       {App sends 1 message; strm 1}\n                                       (bundle SACK with DATA)\n                                /----- SACK [TSN Ack=9,block=0] \\\n                               /         DATA [TSN=6,Strm=1,Seq=2]\n(cancel T3-rtx timer)  <------/        (Start T3-rtx timer)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(ack delayed)\n(send ack)\nSACK [TSN Ack=6,block=0] -------------> (cancel T3-rtx timer)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Figure 7: Delayed Acknowledgment Example",
      "ja": "図7：承認の遅延例"
    },
    {
      "indent": 3,
      "text": "If an endpoint receives a DATA chunk with no user data (i.e., the Length field is set to 16) it MUST send an ABORT with error cause set to \"No User Data\".",
      "ja": "エンドポイントがユーザーデータなしでデータチャンクを受信した場合（つまり、長さフィールドが16に設定されています）、エラー原因を「ユーザーデータなし」に設定して中断を送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD NOT send a DATA chunk with no user data part.",
      "ja": "エンドポイントは、ユーザーデータパーツなしでデータチャンクを送信しないでください。"
    },
    {
      "indent": 0,
      "text": "6.2.1 Processing a Received SACK",
      "section_title": true,
      "ja": "6.2.1 受信した袋を処理します"
    },
    {
      "indent": 3,
      "text": "Each SACK an endpoint receives contains an a_rwnd value. This value represents the amount of buffer space the data receiver, at the time of transmitting the SACK, has left of its total receive buffer space (as specified in the INIT/INIT ACK). Using a_rwnd, Cumulative TSN Ack and Gap Ack Blocks, the data sender can develop a representation of the peer's receive buffer space.",
      "ja": "エンドポイントを受信する各袋には、A_RWND値が含まれています。この値は、サックを送信する時点で、データレシーバーが総受信バッファースペース（init/init ackで指定されているように）の左側にあるバッファスペースの量を表します。A_RWND、累積TSN ACKおよびGAP ACKブロックを使用して、データ送信者はピアの受信バッファースペースの表現を開発できます。"
    },
    {
      "indent": 3,
      "text": "One of the problems the data sender must take into account when processing a SACK is that a SACK can be received out of order. That is, a SACK sent by the data receiver can pass an earlier SACK and be received first by the data sender. If a SACK is received out of order, the data sender can develop an incorrect view of the peer's receive buffer space.",
      "ja": "サックを処理する際にデータ送信者が考慮しなければならない問題の1つは、袋を故障して受け取ることができるということです。つまり、データレシーバーから送信された袋は、以前の袋を渡して、最初にデータ送信者が受信することができます。袋が故障していない場合、データ送信者はピアの受信バッファースペースの誤ったビューを開発できます。"
    },
    {
      "indent": 3,
      "text": "Since there is no explicit identifier that can be used to detect out-of-order SACKs, the data sender must use heuristics to determine if a SACK is new.",
      "ja": "秩序外のサックを検出するために使用できる明示的な識別子はないため、データ送信者はヒューリスティックを使用してサックが新しいかどうかを判断する必要があります。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD use the following rules to calculate the rwnd, using the a_rwnd value, the Cumulative TSN Ack and Gap Ack Blocks in a received SACK.",
      "ja": "エンドポイントは、A_RWND値、累積TSN ACK、および受信したサック内のGAP ACKブロックを使用して、RWNDを計算するために次のルールを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "A) At the establishment of the association, the endpoint initializes the rwnd to the Advertised Receiver Window Credit (a_rwnd) the peer specified in the INIT or INIT ACK.",
      "ja": "a）協会の確立時に、エンドポイントは、rwndを広告されたレシーバーウィンドウクレジット（a_rwnd）に初期化します。"
    },
    {
      "indent": 3,
      "text": "B) Any time a DATA chunk is transmitted (or retransmitted) to a peer, the endpoint subtracts the data size of the chunk from the rwnd of that peer.",
      "ja": "b）データチャンクがピアに送信（または再送信）される場合、エンドポイントはそのピアのRWNDからチャンクのデータサイズを差し引きます。"
    },
    {
      "indent": 3,
      "text": "C) Any time a DATA chunk is marked for retransmission (via either T3-rtx timer expiration (Section 6.3.3)or via fast retransmit (Section 7.2.4)), add the data size of those chunks to the rwnd.",
      "ja": "c）データチャンクが再送信のためにマークされた場合（T3-RTXタイマーの有効期限（セクション6.3.3）または高速再送信（セクション7.2.4）を介して）、それらのチャンクのデータサイズをRWNDに追加します。"
    },
    {
      "indent": 6,
      "text": "Note: If the implementation is maintaining a timer on each DATA chunk then only DATA chunks whose timer expired would be marked for retransmission.",
      "ja": "注：実装が各データチャンクのタイマーを維持している場合、タイマーの有効期限が切れたデータチャンクのみが再送信のためにマークされます。"
    },
    {
      "indent": 3,
      "text": "D) Any time a SACK arrives, the endpoint performs the following:",
      "ja": "d）袋が到着するたびに、エンドポイントは次のことを実行します。"
    },
    {
      "indent": 9,
      "text": "i) If Cumulative TSN Ack is less than the Cumulative TSN Ack Point, then drop the SACK. Since Cumulative TSN Ack is monotonically increasing, a SACK whose Cumulative TSN Ack is less than the Cumulative TSN Ack Point indicates an out-of-order SACK.",
      "ja": "i) 累積TSN ACKが累積TSN ACKポイントよりも少ない場合は、袋をドロップします。累積TSN ACKは単調に増加しているため、累積TSN ACKが累積TSN ACKポイントよりも累積的なTSN ACKよりも少ないサックは、オーダーオブオーダーサックを示しています。"
    },
    {
      "indent": 9,
      "text": "ii) Set rwnd equal to the newly received a_rwnd minus the number of bytes still outstanding after processing the Cumulative TSN Ack and the Gap Ack Blocks.",
      "ja": "ii）累積TSN ACKとGAP ACKブロックを処理した後、まだ未解決のバイト数を差し引いた新しく受信したA_RWNDから等しく設定します。"
    },
    {
      "indent": 9,
      "text": "iii) If the SACK is missing a TSN that was previously acknowledged via a Gap Ack Block (e.g., the data receiver reneged on the data), then mark the corresponding DATA chunk as available for retransmit: Mark it as missing for fast retransmit as described in Section 7.2.4 and if no retransmit timer is running for the destination address to which the DATA chunk was originally transmitted, then T3-rtx is started for that destination address.",
      "ja": "iii）袋にGAP ACKブロック（たとえば、データにre折したデータ受信機など）を介して以前に認められていたTSNが欠落している場合、対応するデータチャンクを再検討するために使用可能なものにマークします。セクション7.2.4では、データチャンクが元々送信された宛先アドレスに対して再送信タイマーが実行されていない場合、その宛先アドレスに対してT3-RTXが開始されます。"
    },
    {
      "indent": 0,
      "text": "6.3 Management of Retransmission Timer",
      "section_title": true,
      "ja": "6.3 再送信タイマーの管理"
    },
    {
      "indent": 3,
      "text": "An SCTP endpoint uses a retransmission timer T3-rtx to ensure data delivery in the absence of any feedback from its peer. The duration of this timer is referred to as RTO (retransmission timeout).",
      "ja": "SCTPエンドポイントは、再送信タイマーT3-RTXを使用して、ピアからのフィードバックがない場合にデータ配信を確保します。このタイマーの持続時間は、RTO（再送信タイムアウト）と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "When an endpoint's peer is multi-homed, the endpoint will calculate a separate RTO for each different destination transport address of its peer endpoint.",
      "ja": "エンドポイントのピアがマルチホームの場合、エンドポイントは、ピアエンドポイントの異なる宛先輸送アドレスごとに個別のRTOを計算します。"
    },
    {
      "indent": 3,
      "text": "The computation and management of RTO in SCTP follows closely how TCP manages its retransmission timer. To compute the current RTO, an endpoint maintains two state variables per destination transport address: SRTT (smoothed round-trip time) and RTTVAR (round-trip time variation).",
      "ja": "SCTPでのRTOの計算と管理は、TCPが再送信タイマーを管理する方法に密接に続きます。現在のRTOを計算するために、エンドポイントは、宛先輸送アドレスごとに2つの状態変数を維持します：SRTT（滑らかな往復時間）とRTTVAR（往復時間の変動）。"
    },
    {
      "indent": 0,
      "text": "6.3.1 RTO Calculation",
      "section_title": true,
      "ja": "6.3.1 RTO計算"
    },
    {
      "indent": 3,
      "text": "The rules governing the computation of SRTT, RTTVAR, and RTO are as follows:",
      "ja": "SRTT、RTTVAR、およびRTOの計算を管理するルールは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "C1) Until an RTT measurement has been made for a packet sent to the given destination transport address, set RTO to the protocol parameter 'RTO.Initial'.",
      "ja": "c1）特定の宛先輸送アドレスに送信されたパケットに対してRTT測定が行われるまで、RTOをプロトコルパラメーター「RTO.Initial」に設定します。"
    },
    {
      "indent": 3,
      "text": "C2) When the first RTT measurement R is made, set SRTT <- R, RTTVAR <- R/2, and RTO <- SRTT + 4 * RTTVAR.",
      "ja": "c2）最初のRTT測定rが作成されたら、SRTT <-R、RTTVAR <-R/2、およびRTO <-SRTT 4 * RTTVARを設定します。"
    },
    {
      "indent": 3,
      "text": "C3) When a new RTT measurement R' is made, set",
      "ja": "c3）新しいRTT測定r 'が作成されたら、設定します"
    },
    {
      "indent": 7,
      "text": "RTTVAR <- (1 - RTO.Beta) * RTTVAR + RTO.Beta * |SRTT - R'| SRTT\n<- (1 - RTO.Alpha) * SRTT + RTO.Alpha * R'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Note: The value of SRTT used in the update to RTTVAR is its value before updating SRTT itself using the second assignment.",
      "ja": "注：RTTVARのアップデートで使用されるSRTTの値は、2番目の割り当てを使用してSRTT自体を更新する前の値です。"
    },
    {
      "indent": 7,
      "text": "After the computation, update RTO <- SRTT + 4 * RTTVAR.",
      "ja": "計算後、RTO <-SRTT 4 * RTTVARを更新します。"
    },
    {
      "indent": 3,
      "text": "C4) When data is in flight and when allowed by rule C5 below, a new RTT measurement MUST be made each round trip. Furthermore, new RTT measurements SHOULD be made no more than once per round-trip for a given destination transport address. There are two reasons for this recommendation: First, it appears that measuring more frequently often does not in practice yield any significant benefit [ALLMAN99]; second, if measurements are made more often, then the values of RTO.Alpha and RTO.Beta in rule C3 above should be adjusted so that SRTT and RTTVAR still adjust to changes at roughly the same rate (in terms of how many round trips it takes them to reflect new values) as they would if making only one measurement per round-trip and using RTO.Alpha and RTO.Beta as given in rule C3. However, the exact nature of these adjustments remains a research issue.",
      "ja": "c4）データが飛行中で、ルールC5で許可されている場合、各往復旅行を行う必要があります。さらに、特定の宛先輸送アドレスのラウンドトリップごとに、新しいRTT測定値を1回しか行わない必要があります。この推奨事項には2つの理由があります。まず、より頻繁に測定することは実際には重要な利益をもたらさないことが多いようです[Allman99]。第二に、測定値がより頻繁に行われる場合、上記のルールC3のRTO.alphaとrto.betaの値を調整する必要があります。ルールC3で示されているように、RTO.alphaとrto.betaを使用して、ラウンドトリップごとに1つの測定を行う場合のように、新しい値を反映するようにそれらを取得します。ただし、これらの調整の正確な性質は、研究問題のままです。"
    },
    {
      "indent": 3,
      "text": "C5) Karn's algorithm: RTT measurements MUST NOT be made using packets that were retransmitted (and thus for which it is ambiguous whether the reply was for the first instance of the packet or a later instance).",
      "ja": "c5）Karnのアルゴリズム：RTT測定は、再送信されたパケット（したがって、パケットの最初のインスタンスまたは後のインスタンスの最初のインスタンスであったかどうかがあいまいな場合）を使用して行わないでください。"
    },
    {
      "indent": 3,
      "text": "C6) Whenever RTO is computed, if it is less than RTO.Min seconds then it is rounded up to RTO.Min seconds. The reason for this rule is that RTOs that do not have a high minimum value are susceptible to unnecessary timeouts [ALLMAN99].",
      "ja": "c6）RTOが計算されるたびに、RTO.min秒未満の場合、RTO.min秒まで切り上げられます。この規則の理由は、最小値が高いRTOSが不必要なタイムアウトの影響を受けやすいためです[Allman99]。"
    },
    {
      "indent": 3,
      "text": "C7) A maximum value may be placed on RTO provided it is at least RTO.max seconds.",
      "ja": "c7）少なくともrto.max秒である場合、RTOに最大値を配置できます。"
    },
    {
      "indent": 3,
      "text": "There is no requirement for the clock granularity G used for computing RTT measurements and the different state variables, other than:",
      "ja": "RTT測定とさまざまな状態変数の計算に使用されるクロック粒度Gには、以外の要件はありません。"
    },
    {
      "indent": 3,
      "text": "G1) Whenever RTTVAR is computed, if RTTVAR = 0, then adjust RTTVAR <- G.",
      "ja": "g1）rttvarが計算されるときはいつでも、rttvar = 0の場合、rttvar <-gを調整します。"
    },
    {
      "indent": 3,
      "text": "Experience [ALLMAN99] has shown that finer clock granularities (<= 100 msec) perform somewhat better than more coarse granularities.",
      "ja": "Experience [allman99]は、より細かいクロック粒度（<= 100ミリ秒）が粗い粒度よりもやや優れたパフォーマンスを発揮することを示しています。"
    },
    {
      "indent": 0,
      "text": "6.3.2 Retransmission Timer Rules",
      "section_title": true,
      "ja": "6.3.2 再送信タイマールール"
    },
    {
      "indent": 3,
      "text": "The rules for managing the retransmission timer are as follows:",
      "ja": "再送信タイマーを管理するためのルールは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "R1) Every time a DATA chunk is sent to any address (including a retransmission), if the T3-rtx timer of that address is not running, start it running so that it will expire after the RTO of that address. The RTO used here is that obtained after any doubling due to previous T3-rtx timer expirations on the corresponding destination address as discussed in rule E2 below.",
      "ja": "R1）データチャンクが任意のアドレス（再送信を含む）に送信されるたびに、そのアドレスのT3-RTXタイマーが実行されていない場合、そのアドレスのRTOの後に期限切れになるように実行してください。ここで使用されているRTOは、以下のルールE2で説明したように、対応する宛先アドレスでの以前のT3-RTXタイマーの有効期限のために倍増した後に得られたものです。"
    },
    {
      "indent": 3,
      "text": "R2) Whenever all outstanding data sent to an address have been acknowledged, turn off the T3-rtx timer of that address.",
      "ja": "R2）アドレスに送信されたすべての未解決のデータが確認されたときはいつでも、そのアドレスのT3-RTXタイマーをオフにします。"
    },
    {
      "indent": 3,
      "text": "R3) Whenever a SACK is received that acknowledges the DATA chunk with the earliest outstanding TSN for that address, restart T3-rtx timer for that address with its current RTO (if there is still outstanding data on that address).",
      "ja": "R3）そのアドレスの最初の未解決のTSNを使用したデータチャンクを認めるサックが受信されるたびに、そのアドレスのT3-RTXタイマーを現在のRTOで再起動します（そのアドレスにまだ未解決のデータがある場合）。"
    },
    {
      "indent": 3,
      "text": "R4) Whenever a SACK is received missing a TSN that was previously acknowledged via a Gap Ack Block, start T3-rtx for the destination address to which the DATA chunk was originally transmitted if it is not already running.",
      "ja": "R4）GAP ACKブロックを介して以前に認められていたTSNが袋を受け取ったときはいつでも、データチャンクがまだ実行されていない場合に元々送信された宛先アドレスのT3-RTXを開始します。"
    },
    {
      "indent": 3,
      "text": "The following example shows the use of various timer rules (assuming the receiver uses delayed acks).",
      "ja": "次の例は、さまざまなタイマールールの使用を示しています（レシーバーが遅延ACKを使用すると仮定します）。"
    },
    {
      "indent": 3,
      "text": "Endpoint A                                         Endpoint Z\n{App begins to send}\nData [TSN=7,Strm=0,Seq=3] ------------> (ack delayed)\n(Start T3-rtx timer)\n                                        {App sends 1 message; strm 1}\n                                        (bundle ack with data)\nDATA [TSN=8,Strm=0,Seq=4] ----\\     /-- SACK [TSN Ack=7,Block=0]\n                               \\   /      DATA [TSN=6,Strm=1,Seq=2]\n                                \\ /     (Start T3-rtx timer)\n                                 \\\n                                / \\\n(Re-start T3-rtx timer) <------/   \\--> (ack delayed)\n(ack delayed)\n{send ack}\nSACK [TSN Ack=6,Block=0] --------------> (Cancel T3-rtx timer)\n                                        ..\n                                        (send ack)\n(Cancel T3-rtx timer)  <-------------- SACK [TSN Ack=8,Block=0]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 8 - Timer Rule Examples",
      "ja": "図8-タイマールールの例"
    },
    {
      "indent": 0,
      "text": "6.3.3 Handle T3-rtx Expiration",
      "section_title": true,
      "ja": "6.3.3 T3-RTXの有効期限を処理します"
    },
    {
      "indent": 3,
      "text": "Whenever the retransmission timer T3-rtx expires for a destination address, do the following:",
      "ja": "再送信タイマーT3-RTXが宛先アドレスの有効期限が切れるときはいつでも、次のことを行います。"
    },
    {
      "indent": 3,
      "text": "E1) For the destination address for which the timer expires, adjust its ssthresh with rules defined in Section 7.2.3 and set the cwnd <- MTU.",
      "ja": "e1）タイマーの有効期限が切れる宛先アドレスについては、セクション7.2.3で定義されたルールを使用してSSThreshを調整し、CWND <-MTUを設定します。"
    },
    {
      "indent": 3,
      "text": "E2) For the destination address for which the timer expires, set RTO <- RTO * 2 (\"back off the timer\"). The maximum value discussed in rule C7 above (RTO.max) may be used to provide an upper bound to this doubling operation.",
      "ja": "e2）タイマーの有効期限が切れる宛先アドレスの場合、rto <-rto * 2（ \"タイマーからバックオフ\"）を設定します。上記のルールC7で説明されている最大値（RTO.max）を使用して、この倍増操作の上限を提供できます。"
    },
    {
      "indent": 3,
      "text": "E3) Determine how many of the earliest (i.e., lowest TSN) outstanding DATA chunks for the address for which the T3-rtx has expired will fit into a single packet, subject to the MTU constraint for the path corresponding to the destination transport address to which the retransmission is being sent (this may be different from the address for which the timer expires [see Section 6.4]). Call this value K. Bundle and retransmit those K DATA chunks in a single packet to the destination endpoint.",
      "ja": "E3）T3-RTXが有効期限を取ったアドレスの最も早い（つまり、最低TSN）未発行データチャンクの数を決定すると、宛先輸送アドレスに対応するパスのMTU制約の対象となる単一のパケットに適合します。再送信が送信されています（これは、タイマーが期限切れになるアドレスとは異なる場合があります[セクション6.4を参照]）。この値Kを呼び出します。1つのパケットでこれらのKデータチャンクを宛先エンドポイントに再送信します。"
    },
    {
      "indent": 3,
      "text": "E4) Start the retransmission timer T3-rtx on the destination address to which the retransmission is sent, if rule R1 above indicates to do so. The RTO to be used for starting T3-rtx should be the one for the destination address to which the retransmission is sent, which, when the receiver is multi-homed, may be different from the destination address for which the timer expired (see Section 6.4 below).",
      "ja": "e4）上記のルールR1がそうすることを示している場合、再送信が送信される宛先アドレスで再送信タイマーT3-RTXを開始します。T3-RTXを開始するために使用されるRTOは、再送信が送信される宛先アドレスのものである必要があります。これは、受信者がマルチホームされている場合、タイマーの有効期限が切れる宛先アドレスとは異なる場合があります（セクションを参照6.4以下）。"
    },
    {
      "indent": 3,
      "text": "After retransmitting, once a new RTT measurement is obtained (which can happen only when new data has been sent and acknowledged, per rule C5, or for a measurement made from a HEARTBEAT [see Section 8.3]), the computation in rule C3 is performed, including the computation of RTO, which may result in \"collapsing\" RTO back down after it has been subject to doubling (rule E2).",
      "ja": "再送信後、新しいRTT測定が取得されると（これは、ルールC5ごとに新しいデータが送信および承認された場合にのみ発生する可能性があります。、RTOの計算を含む。これにより、RTOが2倍になった後に「崩壊」したRTOが戻ってくる可能性があります（ルールE2）。"
    },
    {
      "indent": 3,
      "text": "Note: Any DATA chunks that were sent to the address for which the T3-rtx timer expired but did not fit in one MTU (rule E3 above), should be marked for retransmission and sent as soon as cwnd allows (normally when a SACK arrives).",
      "ja": "注：T3-RTXタイマーが期限切れになったが1つのMTU（上記のルールE3）に収まらないアドレスに送信されたデータチャンクは、再送信のためにマークされ、CWNDが許可するとすぐに送信する必要があります（通常、サックが到着したときに）。"
    },
    {
      "indent": 3,
      "text": "The final rule for managing the retransmission timer concerns failover (see Section 6.4.1):",
      "ja": "再送信タイマーを管理するための最終規則は、フェールオーバーに関するものです（セクション6.4.1を参照）："
    },
    {
      "indent": 3,
      "text": "F1) Whenever an endpoint switches from the current destination transport address to a different one, the current retransmission timers are left running. As soon as the endpoint transmits a packet containing DATA chunk(s) to the new transport address, start the timer on that transport address, using the RTO value of the destination address to which the data is being sent, if rule R1 indicates to do so.",
      "ja": "f1）エンドポイントが現在の宛先輸送アドレスから別の輸送アドレスに切り替わるたびに、現在の再送信タイマーは実行されたままです。エンドポイントがデータチャンクを含むパケットを新しいトランスポートアドレスに送信するとすぐに、ルールR1が行うことを示している場合、データが送信されている宛先アドレスのRTO値を使用して、そのトランスポートアドレスのタイマーを開始します。それで。"
    },
    {
      "indent": 0,
      "text": "6.4 Multi-homed SCTP Endpoints",
      "section_title": true,
      "ja": "6.4 マルチホームのSCTPエンドポイント"
    },
    {
      "indent": 3,
      "text": "An SCTP endpoint is considered multi-homed if there are more than one transport address that can be used as a destination address to reach that endpoint.",
      "ja": "SCTPエンドポイントは、そのエンドポイントに到達するための宛先アドレスとして使用できる輸送アドレスが複数ある場合、マルチホームと見なされます。"
    },
    {
      "indent": 3,
      "text": "Moreover, the ULP of an endpoint shall select one of the multiple destination addresses of a multi-homed peer endpoint as the primary path (see Sections 5.1.2 and 10.1 for details).",
      "ja": "さらに、エンドポイントのULPは、マルチホームのピアエンドポイントの複数の宛先アドレスのいずれかをプライマリパスとして選択するものとします（詳細については、セクション5.1.2および10.1を参照）。"
    },
    {
      "indent": 3,
      "text": "By default, an endpoint SHOULD always transmit to the primary path, unless the SCTP user explicitly specifies the destination transport address (and possibly source transport address) to use.",
      "ja": "デフォルトでは、SCTPユーザーが使用する宛先輸送アドレス（および場合によってはソーストランスポートアドレス）を明示的に指定しない限り、エンドポイントは常にプライマリパスに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD transmit reply chunks (e.g., SACK, HEARTBEAT ACK, etc.) to the same destination transport address from which it received the DATA or control chunk to which it is replying. This rule should also be followed if the endpoint is bundling DATA chunks together with the reply chunk.",
      "ja": "エンドポイントは、返信チャンク（サック、ハートビートACKなど）を、応答しているデータまたはコントロールチャンクを受け取った同じ宛先輸送アドレスに送信する必要があります。このルールは、エンドポイントがデータチャンクを返信チャンクと一緒にバンドリングしている場合にも従う必要があります。"
    },
    {
      "indent": 3,
      "text": "However, when acknowledging multiple DATA chunks received in packets from different source addresses in a single SACK, the SACK chunk may be transmitted to one of the destination transport addresses from which the DATA or control chunks being acknowledged were received.",
      "ja": "ただし、単一のサック内のさまざまなソースアドレスからパケットで受信された複数のデータチャンクを確認すると、サックチャンクは、認められているデータまたは制御チャンクが受信される宛先輸送アドレスの1つに送信される場合があります。"
    },
    {
      "indent": 3,
      "text": "When a receiver of a duplicate DATA chunk sends a SACK to a multi-homed endpoint it MAY be beneficial to vary the destination address and not use the source address of the DATA chunk. The reason being that receiving a duplicate from a multi-homed endpoint might indicate that the return path (as specified in the source address of the DATA chunk) for the SACK is broken.",
      "ja": "複製データチャンクのレシーバーがマルチホームのエンドポイントに袋を送信する場合、宛先アドレスを変更し、データチャンクのソースアドレスを使用しないことが有益である場合があります。マルチホームのエンドポイントから複製を受信することは、サックのリターンパス（データチャンクのソースアドレスで指定）が壊れていることを示している可能性があるためです。"
    },
    {
      "indent": 3,
      "text": "Furthermore, when its peer is multi-homed, an endpoint SHOULD try to retransmit a chunk to an active destination transport address that is different from the last destination address to which the DATA chunk was sent.",
      "ja": "さらに、ピアがマルチホームの場合、エンドポイントは、データチャンクが送信された最後の宛先アドレスとは異なるアクティブな宛先輸送アドレスにチャンクを再送信しようとする必要があります。"
    },
    {
      "indent": 3,
      "text": "Retransmissions do not affect the total outstanding data count. However, if the DATA chunk is retransmitted onto a different destination address, both the outstanding data counts on the new destination address and the old destination address to which the data chunk was last sent shall be adjusted accordingly.",
      "ja": "再送信は、未発生のデータカウント全体に影響しません。ただし、データチャンクが別の宛先アドレスに再送信される場合、新しい宛先アドレスの未解決のデータカウントと、データチャンクが最後に送信された古い宛先アドレスの両方がそれに応じて調整されるものとします。"
    },
    {
      "indent": 0,
      "text": "6.4.1 Failover from Inactive Destination Address",
      "section_title": true,
      "ja": "6.4.1 非アクティブな宛先アドレスからのフェールオーバー"
    },
    {
      "indent": 3,
      "text": "Some of the transport addresses of a multi-homed SCTP endpoint may become inactive due to either the occurrence of certain error conditions (see Section 8.2) or adjustments from SCTP user.",
      "ja": "マルチホームのSCTPエンドポイントの輸送アドレスの一部は、特定のエラー条件（セクション8.2を参照）またはSCTPユーザーからの調整のいずれかのために、非アクティブになる可能性があります。"
    },
    {
      "indent": 3,
      "text": "When there is outbound data to send and the primary path becomes inactive (e.g., due to failures), or where the SCTP user explicitly requests to send data to an inactive destination transport address, before reporting an error to its ULP, the SCTP endpoint should try to send the data to an alternate active destination transport address if one exists.",
      "ja": "送信するアウトバウンドデータがあり、プライマリパスが非アクティブになり（障害により）、またはSCTPユーザーがULPにエラーを報告する前に、SCTPユーザーが非アクティブな宛先輸送アドレスにデータを送信するように明示的に要求する場合、SCTPエンドポイントは必要なはずです存在する場合は、データを代替アクティブな宛先輸送アドレスに送信してみてください。"
    },
    {
      "indent": 3,
      "text": "When retransmitting data, if the endpoint is multi-homed, it should consider each source-destination address pair in its retransmission selection policy. When retransmitting the endpoint should attempt to pick the most divergent source-destination pair from the original source-destination pair to which the packet was transmitted.",
      "ja": "データを再送信する場合、エンドポイントがマルチホームの場合、再送信選択ポリシーで各ソース照明アドレスペアを考慮する必要があります。エンドポイントを再送信するときは、パケットが送信された元のソース照明ペアから最も多様なソース照明ペアを選択しようとする必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: Rules for picking the most divergent source-destination pair are an implementation decision and is not specified within this document.",
      "ja": "注：最も多様なソース照明ペアを選択するためのルールは、実装決定であり、このドキュメント内では指定されていません。"
    },
    {
      "indent": 0,
      "text": "6.5 Stream Identifier and Stream Sequence Number",
      "section_title": true,
      "ja": "6.5 ストリーム識別子とストリームシーケンス番号"
    },
    {
      "indent": 3,
      "text": "Every DATA chunk MUST carry a valid stream identifier. If an endpoint receives a DATA chunk with an invalid stream identifier, it shall acknowledge the reception of the DATA chunk following the normal procedure, immediately send an ERROR chunk with cause set to \"Invalid Stream Identifier\" (see Section 3.3.10) and discard the DATA chunk. The endpoint may bundle the ERROR chunk in the same packet as the SACK as long as the ERROR follows the SACK.",
      "ja": "すべてのデータチャンクには、有効なストリーム識別子が含まれている必要があります。エンドポイントが無効なストリーム識別子を使用してデータチャンクを受信した場合、通常の手順に従ってデータチャンクの受信を確認する必要があります。データチャンク。エンドポイントは、エラーがサックに従う限り、サックと同じパケットでエラーチャンクをバンドルする場合があります。"
    },
    {
      "indent": 3,
      "text": "The stream sequence number in all the streams shall start from 0 when the association is established. Also, when the stream sequence number reaches the value 65535 the next stream sequence number shall be set to 0.",
      "ja": "すべてのストリームのストリームシーケンス番号は、アソシエーションが確立されたときに0から開始するものとします。また、ストリームシーケンス番号が値65535に達すると、次のストリームシーケンス番号は0に設定されます。"
    },
    {
      "indent": 0,
      "text": "6.6 Ordered and Unordered Delivery",
      "section_title": true,
      "ja": "6.6 注文されていない配達"
    },
    {
      "indent": 3,
      "text": "Within a stream, an endpoint MUST deliver DATA chunks received with the U flag set to 0 to the upper layer according to the order of their stream sequence number. If DATA chunks arrive out of order of their stream sequence number, the endpoint MUST hold the received DATA chunks from delivery to the ULP until they are re-ordered.",
      "ja": "ストリーム内で、エンドポイントは、uフラグを0に設定して、ストリームシーケンス番号の順序に応じて上層層に0に設定されたデータチャンクを配信する必要があります。データチャンクがストリームシーケンス番号の順序から外れて到着した場合、エンドポイントは、順序付けられるまで、受信したデータチャンクをULPへの配信から保持する必要があります。"
    },
    {
      "indent": 3,
      "text": "However, an SCTP endpoint can indicate that no ordered delivery is required for a particular DATA chunk transmitted within the stream by setting the U flag of the DATA chunk to 1.",
      "ja": "ただし、SCTPエンドポイントは、データチャンクのUフラグを1に設定することにより、ストリーム内に送信される特定のデータチャンクに順序付けられた配信が不要であることを示すことができます。"
    },
    {
      "indent": 3,
      "text": "When an endpoint receives a DATA chunk with the U flag set to 1, it must bypass the ordering mechanism and immediately deliver the data to the upper layer (after re-assembly if the user data is fragmented by the data sender).",
      "ja": "Uフラグが1に設定されたエンドポイントがデータチャンクを受信した場合、順序付けメカニズムをバイパスし、すぐにデータを上層に配信する必要があります（ユーザーデータがデータ送信者によって断片化された場合）。"
    },
    {
      "indent": 3,
      "text": "This provides an effective way of transmitting \"out-of-band\" data in a given stream. Also, a stream can be used as an \"unordered\" stream by simply setting the U flag to 1 in all DATA chunks sent through that stream.",
      "ja": "これにより、特定のストリームで「帯域外」データを送信する効果的な方法が提供されます。また、ストリームは、そのストリームから送信されたすべてのデータチャンクでUフラグを1に設定するだけで、「順序付けられていない」ストリームとして使用できます。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: When sending an unordered DATA chunk, an implementation may choose to place the DATA chunk in an outbound packet that is at the head of the outbound transmission queue if possible.",
      "ja": "実装注：順序付けられていないデータチャンクを送信する場合、実装は、可能であれば、アウトバウンド送信キューのヘッドにあるアウトバウンドパケットにデータチャンクを配置することを選択できます。"
    },
    {
      "indent": 3,
      "text": "The 'Stream Sequence Number' field in a DATA chunk with U flag set to 1 has no significance. The sender can fill it with arbitrary value, but the receiver MUST ignore the field.",
      "ja": "Uフラグを1に設定したデータチャンクの「ストリームシーケンス番号」フィールドは重要ではありません。送信者はそれを任意の価値で満たすことができますが、受信者はフィールドを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: When transmitting ordered and unordered data, an endpoint does not increment its Stream Sequence Number when transmitting a DATA chunk with U flag set to 1.",
      "ja": "注：順序付きデータと順序付けられていないデータを送信すると、uフラグを1に設定してデータチャンクを送信すると、エンドポイントがストリームシーケンス番号を増分しません。"
    },
    {
      "indent": 0,
      "text": "6.7 Report Gaps in Received DATA TSNs",
      "section_title": true,
      "ja": "6.7 受信したデータTSNのギャップを報告します"
    },
    {
      "indent": 3,
      "text": "Upon the reception of a new DATA chunk, an endpoint shall examine the continuity of the TSNs received. If the endpoint detects a gap in the received DATA chunk sequence, it SHOULD send a SACK with Gap Ack Blocks immediately. The data receiver continues sending a SACK after receipt of each SCTP packet that doesn't fill the gap.",
      "ja": "新しいデータチャンクを受信すると、エンドポイントは、受け取ったTSNの連続性を調べなければなりません。エンドポイントが受信したデータチャンクシーケンスのギャップを検出した場合、GAP ACKブロックを備えたサックをすぐに送信する必要があります。データレシーバーは、ギャップを埋めない各SCTPパケットを受け取った後、袋を送信し続けます。"
    },
    {
      "indent": 3,
      "text": "Based on the Gap Ack Block from the received SACK, the endpoint can calculate the missing DATA chunks and make decisions on whether to retransmit them (see Section 6.2.1 for details).",
      "ja": "受信したサックからのギャップACKブロックに基づいて、エンドポイントは欠落したデータチャンクを計算し、それらを再送信するかどうかを決定することができます（詳細については、セクション6.2.1を参照）。"
    },
    {
      "indent": 3,
      "text": "Multiple gaps can be reported in one single SACK (see Section 3.3.4).",
      "ja": "複数のギャップが1つの袋に報告できます（セクション3.3.4を参照）。"
    },
    {
      "indent": 3,
      "text": "When its peer is multi-homed, the SCTP endpoint SHOULD always try to send the SACK to the same destination address from which the last DATA chunk was received.",
      "ja": "ピアがマルチホームの場合、SCTPエンドポイントは常に、最後のデータチャンクが受信された同じ宛先アドレスに袋を送信しようとする必要があります。"
    },
    {
      "indent": 3,
      "text": "Upon the reception of a SACK, the endpoint MUST remove all DATA chunks which have been acknowledged by the SACK's Cumulative TSN Ack from its transmit queue. The endpoint MUST also treat all the DATA chunks with TSNs not included in the Gap Ack Blocks reported by the SACK as \"missing\". The number of \"missing\" reports for each outstanding DATA chunk MUST be recorded by the data sender in order to make retransmission decisions. See Section 7.2.4 for details.",
      "ja": "サックを受信すると、エンドポイントは、送信キューからサックの累積TSN ACKによって認められたすべてのデータチャンクを削除する必要があります。また、エンドポイントは、サックによって報告されたGAPACKブロックに含まれていないTSNを使用して、すべてのデータチャンクを「欠落」として扱う必要があります。再送信の決定を下すために、発行された各データチャンクの「欠落」レポートの数は、データ送信者によって記録する必要があります。詳細については、セクション7.2.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "The following example shows the use of SACK to report a gap.",
      "ja": "次の例は、ギャップを報告するために袋の使用を示しています。"
    },
    {
      "indent": 6,
      "text": "Endpoint A                                    Endpoint Z\n{App sends 3 messages; strm 0}\nDATA [TSN=6,Strm=0,Seq=2] ---------------> (ack delayed)\n(Start T3-rtx timer)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DATA [TSN=7,Strm=0,Seq=3] --------> X (lost)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DATA [TSN=8,Strm=0,Seq=4] ---------------> (gap detected,\n                                            immediately send ack)\n                                /----- SACK [TSN Ack=6,Block=1,\n                               /             Strt=2,End=2]\n                        <-----/\n(remove 6 from out-queue,\n and mark 7 as \"1\" missing report)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 9 - Reporting a Gap using SACK",
      "ja": "図9-袋を使用してギャップを報告します"
    },
    {
      "indent": 3,
      "text": "The maximum number of Gap Ack Blocks that can be reported within a single SACK chunk is limited by the current path MTU. When a single SACK can not cover all the Gap Ack Blocks needed to be reported due to the MTU limitation, the endpoint MUST send only one SACK, reporting the Gap Ack Blocks from the lowest to highest TSNs, within the size limit set by the MTU, and leave the remaining highest TSN numbers unacknowledged.",
      "ja": "単一のサックチャンク内で報告できるギャップACKブロックの最大数は、現在のパスMTUによって制限されます。単一のサックがMTU制限のために報告する必要があるすべてのギャップACKブロックをカバーできない場合、エンドポイントは1つのサックのみを送信する必要があります。、そして残りの最高のTSN数を未委託のままにしておきます。"
    },
    {
      "indent": 0,
      "text": "6.8 Adler-32 Checksum Calculation",
      "section_title": true,
      "ja": "6.8 Adler-32チェックサムの計算"
    },
    {
      "indent": 3,
      "text": "When sending an SCTP packet, the endpoint MUST strengthen the data integrity of the transmission by including the Adler-32 checksum value calculated on the packet, as described below.",
      "ja": "SCTPパケットを送信する場合、エンドポイントは、以下に説明するように、パケットに計算されたAdler-32チェックサム値を含めることにより、伝送のデータの整合性を強化する必要があります。"
    },
    {
      "indent": 3,
      "text": "After the packet is constructed (containing the SCTP common header and one or more control or DATA chunks), the transmitter shall:",
      "ja": "パケットが構築された後（SCTP共通ヘッダーと1つ以上の制御またはデータチャンクを含む）、送信機は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1) Fill in the proper Verification Tag in the SCTP common header and initialize the checksum field to 0's.",
      "ja": "1) SCTP共通ヘッダーの適切な確認タグを入力し、チェックサムフィールドを0に初期化します。"
    },
    {
      "indent": 3,
      "text": "2) Calculate the Adler-32 checksum of the whole packet, including the SCTP common header and all the chunks. Refer to appendix B for details of the Adler-32 algorithm. And,",
      "ja": "2) SCTP共通ヘッダーとすべてのチャンクを含む、パケット全体のAdler-32チェックサムを計算します。Adler-32アルゴリズムの詳細については、付録Bを参照してください。そして、"
    },
    {
      "indent": 3,
      "text": "3) Put the resultant value into the checksum field in the common header, and leave the rest of the bits unchanged.",
      "ja": "3) 結果の値を共通のヘッダーのチェックサムフィールドに入れ、残りの部分を変更せずに残します。"
    },
    {
      "indent": 3,
      "text": "When an SCTP packet is received, the receiver MUST first check the Adler-32 checksum:",
      "ja": "SCTPパケットを受信した場合、受信者は最初にAdler-32チェックサムをチェックする必要があります。"
    },
    {
      "indent": 3,
      "text": "1) Store the received Adler-32 checksum value aside, 2) Replace the 32 bits of the checksum field in the received SCTP packet with all '0's and calculate an Adler-32 checksum value of the whole received packet. And,",
      "ja": "1) 受信したAdler-32チェックサム値を脇に保存します。2）受信したSCTPパケットのチェックサムフィールドの32ビットをすべての '0に置き換え、受信したパケット全体のAdler-32チェックサム値を計算します。そして、"
    },
    {
      "indent": 3,
      "text": "3) Verify that the calculated Adler-32 checksum is the same as the received Adler-32 checksum. If not, the receiver MUST treat the packet as an invalid SCTP packet.",
      "ja": "3) 計算されたAdler-32チェックサムが受信したAdler-32チェックサムと同じであることを確認します。そうでない場合、受信者はパケットを無効なSCTPパケットとして扱う必要があります。"
    },
    {
      "indent": 3,
      "text": "The default procedure for handling invalid SCTP packets is to silently discard them.",
      "ja": "無効なSCTPパケットを処理するためのデフォルトの手順は、それらを静かに破棄することです。"
    },
    {
      "indent": 0,
      "text": "6.9 Fragmentation and Reassembly",
      "section_title": true,
      "ja": "6.9 断片化と再組み立て"
    },
    {
      "indent": 3,
      "text": "An endpoint MAY support fragmentation when sending DATA chunks, but MUST support reassembly when receiving DATA chunks. If an endpoint supports fragmentation, it MUST fragment a user message if the size of the user message to be sent causes the outbound SCTP packet size to exceed the current MTU. If an implementation does not support fragmentation of outbound user messages, the endpoint must return an error to its upper layer and not attempt to send the user message.",
      "ja": "エンドポイントは、データチャンクを送信するときに断片化をサポートする場合がありますが、データチャンクを受信するときは再組み立てをサポートする必要があります。エンドポイントがフラグメンテーションをサポートする場合、ユーザーメッセージのサイズが送信される場合、ユーザーメッセージをフラグメントする必要があります。実装がアウトバウンドユーザーメッセージの断片化をサポートしていない場合、エンドポイントはエラーを上層層に返す必要があり、ユーザーメッセージの送信を試みません。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: In this error case, the Send primitive discussed in Section 10.1 would need to return an error to the upper layer.",
      "ja": "実装注：このエラーの場合、セクション10.1で説明されている原始的な送信は、エラーを上層に返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If its peer is multi-homed, the endpoint shall choose a size no larger than the association Path MTU. The association Path MTU is the smallest Path MTU of all destination addresses.",
      "ja": "ピアがマルチホームの場合、エンドポイントは、関連付けパスMTUよりも大きいサイズを選択するものとします。Association Path MTUは、すべての宛先アドレスの最小パスMTUです。"
    },
    {
      "indent": 3,
      "text": "Note: Once a message is fragmented it cannot be re-fragmented. Instead if the PMTU has been reduced, then IP fragmentation must be used. Please see Section 7.3 for details of PMTU discovery.",
      "ja": "注：メッセージが断片化されると、再燃させることはできません。代わりに、PMTUが削減されている場合は、IPフラグメンテーションを使用する必要があります。PMTU発見の詳細については、セクション7.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "When determining when to fragment, the SCTP implementation MUST take into account the SCTP packet header as well as the DATA chunk header(s). The implementation MUST also take into account the space required for a SACK chunk if bundling a SACK chunk with the DATA chunk.",
      "ja": "いつ断片化するかを決定するとき、SCTP実装では、SCTPパケットヘッダーとデータチャンクヘッダーを考慮する必要があります。また、データチャンクにサックチャンクをバンドする場合、サックチャンクに必要なスペースを実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "Fragmentation takes the following steps:",
      "ja": "フラグメンテーションは次の手順を実行します。"
    },
    {
      "indent": 3,
      "text": "1) The data sender MUST break the user message into a series of DATA chunks such that each chunk plus SCTP overhead fits into an IP datagram smaller than or equal to the association Path MTU.",
      "ja": "1) データ送信者は、ユーザーメッセージを一連のデータチャンクに分割する必要があります。これにより、各チャンクとSCTPオーバーヘッドがAssociation Path MTU以下のIPデータグラムに収まります。"
    },
    {
      "indent": 3,
      "text": "2) The transmitter MUST then assign, in sequence, a separate TSN to each of the DATA chunks in the series. The transmitter assigns the same SSN to each of the DATA chunks. If the user indicates that the user message is to be delivered using unordered delivery, then the U flag of each DATA chunk of the user message MUST be set to 1.",
      "ja": "2) その後、送信機は、シリーズの各データチャンクに個別のTSNを順番に割り当てる必要があります。送信機は、各データチャンクに同じSSNを割り当てます。ユーザーがユーザーメッセージが順序付けられていない配信を使用して配信されることを示した場合、ユーザーメッセージの各データチャンクのUフラグを1に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "3) The transmitter MUST also set the B/E bits of the first DATA chunk in the series to '10', the B/E bits of the last DATA chunk in the series to '01', and the B/E bits of all other DATA chunks in the series to '00'.",
      "ja": "3) トランスミッターは、シリーズの最初のデータチャンクのB/Eビットを「10」に、シリーズの最後のデータチャンクのB/Eビットを「01」に設定する必要があります。シリーズのデータチャンクは「00」までです。"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST recognize fragmented DATA chunks by examining the B/E bits in each of the received DATA chunks, and queue the fragmented DATA chunks for re-assembly. Once the user message is reassembled, SCTP shall pass the re-assembled user message to the specific stream for possible re-ordering and final dispatching.",
      "ja": "エンドポイントは、受信した各データチャンクのB/Eビットを調べることにより、断片化されたデータチャンクを認識し、再組み立てのために断片化されたデータチャンクをキューする必要があります。ユーザーメッセージが再組み立てされると、SCTPは再注文および最終的なディスパッチの可能性のために、再組み立てされたユーザーメッセージを特定のストリームに渡すものとします。"
    },
    {
      "indent": 3,
      "text": "Note: If the data receiver runs out of buffer space while still waiting for more fragments to complete the re-assembly of the message, it should dispatch part of its inbound message through a partial delivery API (see Section 10), freeing some of its receive buffer space so that the rest of the message may be received.",
      "ja": "注：データの受信機がバッファスペースを使い果たしている場合、メッセージの再組み立てを完了するためのより多くのフラグメントがまだ待機している場合は、部分配信APIを介してインバウンドメッセージの一部をディスパッチし（セクション10を参照）、その一部を解放する必要があります。メッセージの残りの部分を受信できるように、バッファスペースを受信します。"
    },
    {
      "indent": 0,
      "text": "6.10 Bundling",
      "section_title": true,
      "ja": "6.10 バンドリング"
    },
    {
      "indent": 3,
      "text": "An endpoint bundles chunks by simply including multiple chunks in one outbound SCTP packet. The total size of the resultant IP datagram, including the SCTP packet and IP headers, MUST be less or equal to the current Path MTU.",
      "ja": "エンドポイントは、1つのアウトバウンドSCTPパケットに複数のチャンクを含めるだけでチャンクをバンドルします。SCTPパケットおよびIPヘッダーを含む結果のIPデータグラムの合計サイズは、現在のPATH MTUに等しく、または等しくなければなりません。"
    },
    {
      "indent": 3,
      "text": "If its peer endpoint is multi-homed, the sending endpoint shall choose a size no larger than the latest MTU of the current primary path.",
      "ja": "ピアエンドポイントがマルチホームである場合、送信エンドポイントは、現在のプライマリパスの最新のMTUよりも大きいサイズを選択するものとします。"
    },
    {
      "indent": 3,
      "text": "When bundling control chunks with DATA chunks, an endpoint MUST place control chunks first in the outbound SCTP packet. The transmitter MUST transmit DATA chunks within a SCTP packet in increasing order of TSN.",
      "ja": "データチャンクを使用してコントロールチャンクをバンドルするとき、エンドポイントは、最初にアウトバウンドSCTPパケットにコントロールチャンクを配置する必要があります。送信機は、TSNの順序を増やしてSCTPパケット内でデータチャンクを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: Since control chunks must be placed first in a packet and since DATA chunks must be transmitted before SHUTDOWN or SHUTDOWN ACK chunks, DATA chunks cannot be bundled with SHUTDOWN or SHUTDOWN ACK chunks.",
      "ja": "注：コントロールチャンクは最初にパケットに配置する必要があり、データチャンクをシャットダウンまたはシャットダウンACKチャンクの前に送信する必要があるため、データチャンクをシャットダウンまたはシャットダウンACKチャンクにバンドルすることはできません。"
    },
    {
      "indent": 3,
      "text": "Partial chunks MUST NOT be placed in an SCTP packet.",
      "ja": "部分的なチャンクをSCTPパケットに入れてはいけません。"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST process received chunks in their order in the packet. The receiver uses the chunk length field to determine the end of a chunk and beginning of the next chunk taking account of the fact that all chunks end on a 4 byte boundary. If the receiver detects a partial chunk, it MUST drop the chunk.",
      "ja": "エンドポイントは、受信したチャンクをパケットで注文して処理する必要があります。受信機は、チャンク長フィールドを使用して、すべてのチャンクが4バイト境界で終了するという事実を考慮して、チャンクの終わりと次のチャンクの始まりを決定します。受信機が部分的なチャンクを検出した場合、チャンクを落とす必要があります。"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST NOT bundle INIT, INIT ACK or SHUTDOWN COMPLETE with any other chunks.",
      "ja": "エンドポイントは、他のチャンクを備えたinit、init ack、またはシャットダウンをバンドルしてはなりません。"
    },
    {
      "indent": 0,
      "text": "7. Congestion control",
      "section_title": true,
      "ja": "7. 混雑制御"
    },
    {
      "indent": 3,
      "text": "Congestion control is one of the basic functions in SCTP. For some applications, it may be likely that adequate resources will be allocated to SCTP traffic to assure prompt delivery of time-critical data - thus it would appear to be unlikely, during normal operations, that transmissions encounter severe congestion conditions. However SCTP must operate under adverse operational conditions, which can develop upon partial network failures or unexpected traffic surges. In such situations SCTP must follow correct congestion control steps to recover from congestion quickly in order to get data delivered as soon as possible. In the absence of network congestion, these preventive congestion control algorithms should show no impact on the protocol performance.",
      "ja": "輻輳制御は、SCTPの基本機能の1つです。一部のアプリケーションでは、適切なリソースがSCTPトラフィックに割り当てられて、時間批判的なデータの迅速な配信を保証する可能性があります。したがって、通常の操作中に、送信が深刻な輻輳条件に遭遇する可能性は低いようです。ただし、SCTPは、部分的なネットワーク障害または予期しないトラフィックの急増時に発生する可能性がある不利な運用条件下で動作する必要があります。このような状況では、SCTPは、できるだけ早くデータを提供するために、輻輳から迅速に回復するための正しい混雑制御手順に従う必要があります。ネットワーク輻輳がない場合、これらの予防渋滞制御アルゴリズムは、プロトコルのパフォーマンスに影響を与えないはずです。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: As far as its specific performance requirements are met, an implementation is always allowed to adopt a more conservative congestion control algorithm than the one defined below.",
      "ja": "実装注：特定のパフォーマンス要件が満たされている限り、実装は常に、以下に定義されているものよりも保守的な混雑制御アルゴリズムを採用することができます。"
    },
    {
      "indent": 3,
      "text": "The congestion control algorithms used by SCTP are based on [RFC2581]. This section describes how the algorithms defined in RFC2581 are adapted for use in SCTP. We first list differences in protocol designs between TCP and SCTP, and then describe SCTP's congestion control scheme. The description will use the same terminology as in TCP congestion control whenever appropriate.",
      "ja": "SCTPで使用される混雑制御アルゴリズムは、[RFC2581]に基づいています。このセクションでは、RFC2581で定義されているアルゴリズムがSCTPで使用するためにどのように適合しているかについて説明します。最初に、TCPとSCTPの間のプロトコル設計の違いをリストし、SCTPの混雑制御スキームを説明します。この説明は、適切な場合はいつでもTCP輻輳制御と同じ用語を使用します。"
    },
    {
      "indent": 3,
      "text": "SCTP congestion control is always applied to the entire association, and not to individual streams.",
      "ja": "SCTPの混雑制御は、個々のストリームではなく、常に協会全体に適用されます。"
    },
    {
      "indent": 0,
      "text": "7.1 SCTP Differences from TCP Congestion control",
      "section_title": true,
      "ja": "7.1 TCP混雑制御とのSCTPの違い"
    },
    {
      "indent": 3,
      "text": "Gap Ack Blocks in the SCTP SACK carry the same semantic meaning as the TCP SACK. TCP considers the information carried in the SACK as advisory information only. SCTP considers the information carried in the Gap Ack Blocks in the SACK chunk as advisory. In SCTP, any DATA chunk that has been acknowledged by SACK, including DATA that arrived at the receiving end out of order, are not considered fully delivered until the Cumulative TSN Ack Point passes the TSN of the DATA chunk (i.e., the DATA chunk has been acknowledged by the Cumulative TSN Ack field in the SACK). Consequently, the value of cwnd controls the amount of outstanding data, rather than (as in the case of non-SACK TCP) the upper bound between the highest acknowledged sequence number and the latest DATA chunk that can be sent within the congestion window. SCTP SACK leads to different implementations of fast-retransmit and fast-recovery than non-SACK TCP. As an example see [FALL96].",
      "ja": "SCTPサックのギャップACKブロックは、TCPサックと同じ意味の意味を持ちます。TCPは、袋に掲載された情報をアドバイザリー情報のみと見なします。SCTPは、サックチャンクのギャップACKブロックにある情報をアドバイザリーと見なします。SCTPでは、受信端に到達したデータを含むSACKによって認められたデータチャンクは、累積TSN ACKポイントがデータチャンクのTSNを通過するまで完全に配信されるとは見なされません（つまり、データチャンクはデータチャンクが持っています。袋の累積TSN ACKフィールドによって認められました）。したがって、CWNDの値は、（非サックTCPの場合のように）最高の認識されたシーケンス番号と輻輳ウィンドウ内で送信できる最新のデータチャンクの間の上限ではなく、未解決のデータの量を制御します。SCTPサックは、非サックTCPとは異なる高速再輸送と高速回復の実装につながります。例として、[fall96]を参照してください。"
    },
    {
      "indent": 3,
      "text": "The biggest difference between SCTP and TCP, however, is multi-homing. SCTP is designed to establish robust communication associations between two endpoints each of which may be reachable by more than one transport address. Potentially different addresses may lead to different data paths between the two endpoints, thus ideally one may need a separate set of congestion control parameters for each of the paths. The treatment here of congestion control for multi-homed receivers is new with SCTP and may require refinement in the future. The current algorithms make the following assumptions:",
      "ja": "ただし、SCTPとTCPの最大の違いは、マルチホミングです。SCTPは、2つのエンドポイント間に堅牢な通信関連を確立するように設計されており、それぞれが複数の輸送住所で到達可能になる可能性があります。潜在的に異なるアドレスは、2つのエンドポイント間で異なるデータパスにつながる可能性があります。したがって、理想的には、各パスに対して個別の混雑制御パラメーターが必要になる場合があります。ここでのマルチホームレシーバーの混雑制御の治療は、SCTPで新しく、将来的に改良が必要になる場合があります。現在のアルゴリズムは、次の仮定を作成します。"
    },
    {
      "indent": 3,
      "text": "o The sender usually uses the same destination address until being instructed by the upper layer otherwise; however, SCTP may change to an alternate destination in the event an address is marked inactive (see Section 8.2). Also, SCTP may retransmit to a different transport address than the original transmission.",
      "ja": "o 送信者は通常、それ以外の場合は上層層によって指示されるまで同じ宛先アドレスを使用します。ただし、SCTPは、アドレスが非アクティブであるとマークされている場合の代替宛先に変更される場合があります（セクション8.2を参照）。また、SCTPは、元の送信とは異なる輸送アドレスに再送信される場合があります。"
    },
    {
      "indent": 3,
      "text": "o The sender keeps a separate congestion control parameter set for each of the destination addresses it can send to (not each source-destination pair but for each destination). The parameters should decay if the address is not used for a long enough time period.",
      "ja": "o 送信者は、送信できる宛先アドレスごとに個別の混雑制御パラメーターセットを保持します（各ソース照明ペアではなく、各宛先に対して）。アドレスが十分に長い期間使用されない場合、パラメーターは減衰する必要があります。"
    },
    {
      "indent": 3,
      "text": "o For each of the destination addresses, an endpoint does slow-start upon the first transmission to that address.",
      "ja": "o 宛先アドレスのそれぞれについて、エンドポイントはそのアドレスへの最初の送信時にスロースタートします。"
    },
    {
      "indent": 3,
      "text": "Note: TCP guarantees in-sequence delivery of data to its upper-layer protocol within a single TCP session. This means that when TCP notices a gap in the received sequence number, it waits until the gap is filled before delivering the data that was received with sequence numbers higher than that of the missing data. On the other hand, SCTP can deliver data to its upper-layer protocol even if there is a gap in TSN if the Stream Sequence Numbers are in sequence for a particular stream (i.e., the missing DATA chunks are for a different stream) or if unordered delivery is indicated. Although this does not affect cwnd, it might affect rwnd calculation.",
      "ja": "注：TCPは、単一のTCPセッション内での上層層プロトコルへのデータの配列配信を保証します。これは、TCPが受信したシーケンス番号のギャップに気付いた場合、ギャップが入力されるまで待機してから、欠落データのシーケンス番号よりも高いシーケンス番号で受信したデータを配信することを意味します。一方、SCTPは、特定のストリームのストリームシーケンス番号がシーケンスにある場合（つまり、欠落データチャンクが異なるストリーム用）、または場合でもTSNにギャップがある場合でも、上層層プロトコルにデータを配信できます。順序付けられていない配達が示されています。これはCWNDには影響しませんが、RWND計算に影響する可能性があります。"
    },
    {
      "indent": 0,
      "text": "7.2 SCTP Slow-Start and Congestion Avoidance",
      "section_title": true,
      "ja": "7.2 SCTPスロースタートおよび混雑回避"
    },
    {
      "indent": 3,
      "text": "The slow start and congestion avoidance algorithms MUST be used by an endpoint to control the amount of data being injected into the network. The congestion control in SCTP is employed in regard to the association, not to an individual stream. In some situations it may be beneficial for an SCTP sender to be more conservative than the algorithms allow; however, an SCTP sender MUST NOT be more aggressive than the following algorithms allow.",
      "ja": "スロースタートおよび輻輳回避アルゴリズムは、ネットワークに注入されるデータの量を制御するためにエンドポイントで使用する必要があります。SCTPの混雑制御は、個々のストリームではなく、協会に関して採用されています。状況によっては、SCTP送信者がアルゴリズムが許可するよりも保守的であることが有益かもしれません。ただし、SCTP送信者は、次のアルゴリズムが許可するよりも攻撃的であってはなりません。"
    },
    {
      "indent": 3,
      "text": "Like TCP, an SCTP endpoint uses the following three control variables to regulate its transmission rate.",
      "ja": "TCPと同様に、SCTPエンドポイントは、次の3つの制御変数を使用して、その伝送速度を調節します。"
    },
    {
      "indent": 3,
      "text": "o Receiver advertised window size (rwnd, in bytes), which is set by the receiver based on its available buffer space for incoming packets.",
      "ja": "o 受信機は、窓のサイズ（RWND、バイト単位）を宣伝します。これは、着信パケット用の利用可能なバッファースペースに基づいて受信機によって設定されています。"
    },
    {
      "indent": 6,
      "text": "Note: This variable is kept on the entire association.",
      "ja": "注：この変数は、関連性全体に保持されます。"
    },
    {
      "indent": 3,
      "text": "o Congestion control window (cwnd, in bytes), which is adjusted by the sender based on observed network conditions.",
      "ja": "o 輻輳制御ウィンドウ（CWND、バイト）。これは、観測されたネットワーク条件に基づいて送信者によって調整されます。"
    },
    {
      "indent": 6,
      "text": "Note: This variable is maintained on a per-destination address basis.",
      "ja": "注：この変数は、設定ごとのアドレスベースで維持されます。"
    },
    {
      "indent": 3,
      "text": "o Slow-start threshold (ssthresh, in bytes), which is used by the sender to distinguish slow start and congestion avoidance phases.",
      "ja": "o スロースタートしきい値（SSTHRESH、バイト）。これは、スロースタートと混雑回避フェーズを区別するために送信者が使用します。"
    },
    {
      "indent": 6,
      "text": "Note: This variable is maintained on a per-destination address basis.",
      "ja": "注：この変数は、設定ごとのアドレスベースで維持されます。"
    },
    {
      "indent": 3,
      "text": "SCTP also requires one additional control variable, partial_bytes_acked, which is used during congestion avoidance phase to facilitate cwnd adjustment.",
      "ja": "SCTPには、CWND調整を容易にするために混雑回避段階で使用される追加の制御変数Partial_bytes_ackedも必要です。"
    },
    {
      "indent": 3,
      "text": "Unlike TCP, an SCTP sender MUST keep a set of these control variables cwnd, ssthresh and partial_bytes_acked for EACH destination address of its peer (when its peer is multi-homed). Only one rwnd is kept for the whole association (no matter if the peer is multi-homed or has a single address).",
      "ja": "TCPとは異なり、SCTP送信者は、ピアの各宛先アドレスに対してこれらの制御変数、SSThresh、およびpartial_bytes_ackedのセットを保持する必要があります（ピアがマルチホームの場合）。Association全体に1つのRWNDのみが保持されています（ピアがマルチホームであるか、単一のアドレスがあるかに関係なく）。"
    },
    {
      "indent": 0,
      "text": "7.2.1 Slow-Start",
      "section_title": true,
      "ja": "7.2.1 スロースタート"
    },
    {
      "indent": 3,
      "text": "Beginning data transmission into a network with unknown conditions or after a sufficiently long idle period requires SCTP to probe the network to determine the available capacity. The slow start algorithm is used for this purpose at the beginning of a transfer, or after repairing loss detected by the retransmission timer.",
      "ja": "未知の条件のあるネットワークへのデータ送信を開始するか、十分に長いアイドル期間の後には、SCTPがネットワークをプローブして利用可能な容量を決定する必要があります。スロースタートアルゴリズムは、転送の開始時、または再送信タイマーによって検出された損失を修復した後、この目的に使用されます。"
    },
    {
      "indent": 3,
      "text": "o The initial cwnd before DATA transmission or after a sufficiently long idle period MUST be <= 2*MTU.",
      "ja": "o データ送信前または十分に長いアイドル期間の後の最初のcwndは<= 2*mtuでなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The initial cwnd after a retransmission timeout MUST be no more than 1*MTU.",
      "ja": "o 再送信タイムアウト後の最初のCWNDは1*mtu以下でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The initial value of ssthresh MAY be arbitrarily high (for example, implementations MAY use the size of the receiver advertised window).",
      "ja": "o SSthreshの初期値は任意に高くなる可能性があります（たとえば、実装ではレシーバーの広告ウィンドウのサイズを使用する場合があります）。"
    },
    {
      "indent": 3,
      "text": "o Whenever cwnd is greater than zero, the endpoint is allowed to have cwnd bytes of data outstanding on that transport address.",
      "ja": "o CWNDがゼロを超える場合はいつでも、エンドポイントは、その輸送アドレスで発行されるデータのCWNDバイトを持つことができます。"
    },
    {
      "indent": 3,
      "text": "o When cwnd is less than or equal to ssthresh an SCTP endpoint MUST use the slow start algorithm to increase cwnd (assuming the current congestion window is being fully utilized). If an incoming SACK advances the Cumulative TSN Ack Point, cwnd MUST be increased by at most the lesser of 1) the total size of the previously outstanding DATA chunk(s) acknowledged, and 2) the destination's path MTU. This protects against the ACK-Splitting attack outlined in [SAVAGE99].",
      "ja": "o CWNDがSSTHRESH以下の場合、SCTPエンドポイントはスロースタートアルゴリズムを使用してCWNDを増加させる必要があります（現在の輻輳ウィンドウが完全に利用されていると仮定します）。着信サックが累積TSN ACKポイントを進める場合、CWNDを最大で増やす必要があります。これは、[savage99]で概説されているACK分割攻撃から保護します。"
    },
    {
      "indent": 3,
      "text": "In instances where its peer endpoint is multi-homed, if an endpoint receives a SACK that advances its Cumulative TSN Ack Point, then it should update its cwnd (or cwnds) apportioned to the destination addresses to which it transmitted the acknowledged data. However if the received SACK does not advance the Cumulative TSN Ack Point, the endpoint MUST NOT adjust the cwnd of any of the destination addresses.",
      "ja": "ピアエンドポイントがマルチホームになっている場合、エンドポイントが累積TSN ACKポイントを進めるサックを受け取る場合、認められたデータを送信した宛先アドレスに配分されたCWND（またはCWND）を更新する必要があります。ただし、受信したサックが累積TSN ACKポイントを前進させない場合、エンドポイントは宛先アドレスのいずれかのCWNDを調整してはなりません。"
    },
    {
      "indent": 3,
      "text": "Because an endpoint's cwnd is not tied to its Cumulative TSN Ack Point, as duplicate SACKs come in, even though they may not advance the Cumulative TSN Ack Point an endpoint can still use them to clock out new data. That is, the data newly acknowledged by the SACK diminishes the amount of data now in flight to less than cwnd; and so the current, unchanged value of cwnd now allows new data to be sent. On the other hand, the increase of cwnd must be tied to the Cumulative TSN Ack Point advancement as specified above. Otherwise the duplicate SACKs will not only clock out new data, but also will adversely clock out more new data than what has just left the network, during a time of possible congestion.",
      "ja": "エンドポイントのCWNDは、累積TSN ACKポイントを進めない可能性がある場合でも、エンドポイントを使用して新しいデータをクロックアウトすることができます。つまり、袋によって新たに認められたデータは、現在Flight on CWND未満に飛行中のデータの量を減少させます。したがって、CWNDの現在の変更されていない値により、新しいデータが送信されるようになりました。一方、CWNDの増加は、上記のように累積TSN ACKポイントの進歩に結び付けられなければなりません。それ以外の場合、重複したサックは、新しいデータをクロックするだけでなく、輻輳の可能性がある間、ネットワークを離れたものよりも多くの新しいデータを逆にクロックすることもできます。"
    },
    {
      "indent": 3,
      "text": "o When the endpoint does not transmit data on a given transport address, the cwnd of the transport address should be adjusted to max(cwnd/2, 2*MTU) per RTO.",
      "ja": "o エンドポイントが特定の輸送アドレスにデータを送信しない場合、輸送アドレスのCWNDは、RTOごとにMAX（CWND/2、2*MTU）に調整する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.2.2 Congestion Avoidance",
      "section_title": true,
      "ja": "7.2.2 混雑回避"
    },
    {
      "indent": 3,
      "text": "When cwnd is greater than ssthresh, cwnd should be incremented by 1*MTU per RTT if the sender has cwnd or more bytes of data outstanding for the corresponding transport address.",
      "ja": "CWNDがSSTHRESHよりも大きい場合、送信者が対応するトランスポートアドレスに対してCWND以上のデータのバイト以上のバイトを持っている場合、CWNDはRTTごとに1*MTUで増分する必要があります。"
    },
    {
      "indent": 3,
      "text": "In practice an implementation can achieve this goal in the following way:",
      "ja": "実際には、実装は次の方法でこの目標を達成できます。"
    },
    {
      "indent": 3,
      "text": "o partial_bytes_acked is initialized to 0.",
      "ja": "o partial_bytes_ackedは0に初期化されます。"
    },
    {
      "indent": 3,
      "text": "o Whenever cwnd is greater than ssthresh, upon each SACK arrival that advances the Cumulative TSN Ack Point, increase partial_bytes_acked by the total number of bytes of all new chunks acknowledged in that SACK including chunks acknowledged by the new Cumulative TSN Ack and by Gap Ack Blocks.",
      "ja": "o CWNDがSSTHRESHよりも大きいときはいつでも、累積TSN ACKポイントを前進させる各袋到着時に、新しい累積TSN ACKによって認められたチャンクを含むすべての新しいチャンクの総バイト数とギャップACKブロックを含む部分のバイトの総数によってpartial_bytes_akeを増やします。"
    },
    {
      "indent": 3,
      "text": "o When partial_bytes_acked is equal to or greater than cwnd and before the arrival of the SACK the sender had cwnd or more bytes of data outstanding (i.e., before arrival of the SACK, flightsize was greater than or equal to cwnd), increase cwnd by MTU, and reset partial_bytes_acked to (partial_bytes_acked - cwnd).",
      "ja": "o Partial_bytes_ackedがCWND以上であり、サックの到着前に、送信者はCWND以上のデータのバイトを持っていた場合（つまり、サックの到着前に、Flight -SizeはCWND以上でした）、MTUごとにCWNDを増やします。およびpartial_bytes_acked（partial_bytes_acked -cwnd）にリセットします。"
    },
    {
      "indent": 3,
      "text": "o Same as in the slow start, when the sender does not transmit DATA on a given transport address, the cwnd of the transport address should be adjusted to max(cwnd / 2, 2*MTU) per RTO.",
      "ja": "o スロースタートと同じように、送信者が特定の輸送アドレスでデータを送信しない場合、輸送アドレスのCWNDは、RTOごとにMAX（CWND / 2、2*MTU）に調整する必要があります。"
    },
    {
      "indent": 3,
      "text": "o When all of the data transmitted by the sender has been acknowledged by the receiver, partial_bytes_acked is initialized to 0.",
      "ja": "o 送信者によって送信されるすべてのデータが受信機によって認められている場合、partial_bytes_ackedは0に初期化されます。"
    },
    {
      "indent": 0,
      "text": "7.2.3 Congestion Control",
      "section_title": true,
      "ja": "7.2.3 混雑制御"
    },
    {
      "indent": 3,
      "text": "Upon detection of packet losses from SACK (see Section 7.2.4), An endpoint should do the following:",
      "ja": "袋からのパケット損失を検出すると（セクション7.2.4を参照）、エンドポイントは次のことを行う必要があります。"
    },
    {
      "indent": 6,
      "text": "ssthresh = max(cwnd/2, 2*MTU)\ncwnd = ssthresh",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Basically, a packet loss causes cwnd to be cut in half.",
      "ja": "基本的に、パケットの損失により、CWNDが半分に削減されます。"
    },
    {
      "indent": 3,
      "text": "When the T3-rtx timer expires on an address, SCTP should perform slow start by:",
      "ja": "T3-RTXタイマーがアドレスで期限切れになると、SCTPは次のようにスロースタートを実行する必要があります。"
    },
    {
      "indent": 6,
      "text": "ssthresh = max(cwnd/2, 2*MTU)\ncwnd = 1*MTU",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "and assure that no more than one SCTP packet will be in flight for that address until the endpoint receives acknowledgement for successful delivery of data to that address.",
      "ja": "また、エンドポイントがそのアドレスへの成功したデータの配信の承認を受信するまで、そのアドレスのSCTPパケットが1つしか飛行しないことを保証します。"
    },
    {
      "indent": 0,
      "text": "7.2.4 Fast Retransmit on Gap Reports",
      "section_title": true,
      "ja": "7.2.4 ギャップレポートの高速再送信"
    },
    {
      "indent": 3,
      "text": "In the absence of data loss, an endpoint performs delayed acknowledgement. However, whenever an endpoint notices a hole in the arriving TSN sequence, it SHOULD start sending a SACK back every time a packet arrives carrying data until the hole is filled.",
      "ja": "データの損失がない場合、エンドポイントは遅延承認を実行します。ただし、エンドポイントが到着するTSNシーケンスの穴に気付いたときはいつでも、穴が充填されるまでパケットが届くたびにパケットが到着するたびにサックを送信し始めるはずです。"
    },
    {
      "indent": 3,
      "text": "Whenever an endpoint receives a SACK that indicates some TSN(s) missing, it SHOULD wait for 3 further miss indications (via subsequent SACK's) on the same TSN(s) before taking action with regard to Fast Retransmit.",
      "ja": "エンドポイントがTSNが欠落していることを示すサックを受け取るときはいつでも、同じTSNで（後続のサックを介して）さらに3回のミス適応症を待つ前に、速い再送信に関して行動を起こす必要があります。"
    },
    {
      "indent": 3,
      "text": "When the TSN(s) is reported as missing in the fourth consecutive SACK, the data sender shall:",
      "ja": "TSNが4回連続のサックで欠落していると報告されている場合、データ送信者は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1) Mark the missing DATA chunk(s) for retransmission,",
      "ja": "1) 再送信のために欠落データチャンクをマークし、"
    },
    {
      "indent": 3,
      "text": "2) Adjust the ssthresh and cwnd of the destination address(es) to which the missing DATA chunks were last sent, according to the formula described in Section 7.2.3.",
      "ja": "2) セクション7.2.3で説明した式に従って、欠落データチャンクが最後に送信された宛先アドレス（ES）のSSTHRESHとCWNDを調整します。"
    },
    {
      "indent": 3,
      "text": "3) Determine how many of the earliest (i.e., lowest TSN) DATA chunks marked for retransmission will fit into a single packet, subject to constraint of the path MTU of the destination transport address to which the packet is being sent. Call this value K. Retransmit those K DATA chunks in a single packet.",
      "ja": "3) 再送信のためにマークされた最も早い（つまり、最も低いTSN）データチャンクが、パケットが送信されている宛先輸送アドレスのパスMTUの制約を条件として、単一のパケットに収まるものの数を決定します。この値Kを呼び出します。1つのパケットでこれらのKデータチャンクを再送信します。"
    },
    {
      "indent": 3,
      "text": "4) Restart T3-rtx timer only if the last SACK acknowledged the lowest outstanding TSN number sent to that address, or the endpoint is retransmitting the first outstanding DATA chunk sent to that address.",
      "ja": "4) T3-RTXタイマーを再起動します。最後のサックがそのアドレスに送信された最低の未解決のTSN番号を認めた場合、またはエンドポイントがそのアドレスに送信された最初の未解決のデータチャンクを再送信します。"
    },
    {
      "indent": 3,
      "text": "Note: Before the above adjustments, if the received SACK also acknowledges new DATA chunks and advances the Cumulative TSN Ack Point, the cwnd adjustment rules defined in Sections 7.2.1 and 7.2.2 must be applied first.",
      "ja": "注：上記の調整の前に、受信したサックが新しいデータのチャンクを認め、累積TSN ACKポイントを進めている場合、セクション7.2.1および7.2.2で定義されているCWND調整ルールを最初に適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "A straightforward implementation of the above keeps a counter for each TSN hole reported by a SACK. The counter increments for each consecutive SACK reporting the TSN hole. After reaching 4 and starting the fast retransmit procedure, the counter resets to 0.",
      "ja": "上記の簡単な実装は、袋によって報告された各TSNホールのカウンターを保持します。TSNホールを報告する各連続サックのカウンター増分。4に達し、高速再送信手順を開始した後、カウンターは0にリセットします。"
    },
    {
      "indent": 3,
      "text": "Because cwnd in SCTP indirectly bounds the number of outstanding TSN's, the effect of TCP fast-recovery is achieved automatically with no adjustment to the congestion control window size.",
      "ja": "SCTPのCWNDは間接的に優れたTSNの数を境界に導くため、TCPファースト回復の効果は、混雑制御ウィンドウサイズに調整せずに自動的に達成されます。"
    },
    {
      "indent": 0,
      "text": "7.3 Path MTU Discovery",
      "section_title": true,
      "ja": "7.3 パスMTU発見"
    },
    {
      "indent": 3,
      "text": "[RFC1191] specifies \"Path MTU Discovery\", whereby an endpoint maintains an estimate of the maximum transmission unit (MTU) along a given Internet path and refrains from sending packets along that path which exceed the MTU, other than occasional attempts to probe for a change in the Path MTU (PMTU). RFC 1191 is thorough in its discussion of the MTU discovery mechanism and strategies for determining the current end-to-end MTU setting as well as detecting changes in this value. [RFC1981] specifies the same mechanisms for IPv6. An SCTP sender using IPv6 MUST use Path MTU Discovery unless all packets are less than the minimum IPv6 MTU [RFC2460].",
      "ja": "[RFC1191]は「パスMTU発見」を指定します。これにより、エンドポイントは、特定のインターネットパスに沿って最大送信ユニット（MTU）の推定値を維持し、MTUを超えるパスに沿ってパケットを送信することを控えます。Path MTU（PMTU）の変更。RFC 1191は、現在のエンドツーエンドのMTU設定を決定するためのMTU発見メカニズムと戦略の議論において徹底的です。また、この値の変更を検出します。[RFC1981]は、IPv6の同じメカニズムを指定します。IPv6を使用したSCTP送信者は、すべてのパケットが最小IPv6 MTU [RFC2460]未満でない限り、PATH MTUディスカバリーを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD apply these techniques, and SHOULD do so on a per-destination-address basis.",
      "ja": "エンドポイントはこれらの手法を適用する必要があり、命令ごとにそれを行う必要があります。"
    },
    {
      "indent": 3,
      "text": "There are 4 ways in which SCTP differs from the description in RFC 1191 of applying MTU discovery to TCP:",
      "ja": "MTU発見をTCPに適用するRFC 1191の説明とSCTPが異なる4つの方法があります。"
    },
    {
      "indent": 3,
      "text": "1) SCTP associations can span multiple addresses. An endpoint MUST maintain separate MTU estimates for each destination address of its peer.",
      "ja": "1) SCTPアソシエーションは、複数のアドレスにまたがる可能性があります。エンドポイントは、ピアの各宛先アドレスの個別のMTU推定値を維持する必要があります。"
    },
    {
      "indent": 3,
      "text": "2) Elsewhere in this document, when the term \"MTU\" is discussed, it refers to the MTU associated with the destination address corresponding to the context of the discussion.",
      "ja": "2) このドキュメントの他の場所では、「MTU」という用語が議論されている場合、議論のコンテキストに対応する宛先アドレスに関連付けられたMTUを指します。"
    },
    {
      "indent": 3,
      "text": "3) Unlike TCP, SCTP does not have a notion of \"Maximum Segment Size\". Accordingly, the MTU for each destination address SHOULD be initialized to a value no larger than the link MTU for the local interface to which packets for that remote destination address will be routed.",
      "ja": "3) TCPとは異なり、SCTPには「最大セグメントサイズ」の概念はありません。したがって、各宛先アドレスのMTUは、そのリモート宛先アドレスのパケットがルーティングされるローカルインターフェイスのリンクMTUより大きい値のない値に初期化する必要があります。"
    },
    {
      "indent": 3,
      "text": "4) Since data transmission in SCTP is naturally structured in terms of TSNs rather than bytes (as is the case for TCP), the discussion in Section 6.5 of RFC 1191 applies: When retransmitting an IP datagram to a remote address for which the IP datagram appears too large for the path MTU to that address, the IP datagram SHOULD be retransmitted without the DF bit set, allowing it to possibly be fragmented. Transmissions of new IP datagrams MUST have DF set.",
      "ja": "4) SCTPのデータ伝送はバイトではなくTSNSの観点から自然に構成されているため（TCPの場合のように）、RFC 1191のセクション6.5の議論が適用されます。IPデータグラムをIPデータグラムも再送信する場合、そのアドレスへのパスMTUの場合、IPデータグラムはDFビットセットなしで再送信する必要があり、断片化する可能性があります。新しいIPデータグラムの送信には、DFセットが必要です。"
    },
    {
      "indent": 3,
      "text": "5) The sender should track an association PMTU which will be the smallest PMTU discovered for all of the peer's destination addresses. When fragmenting messages into multiple parts this association PMTU should be used to calculate the size of each fragment. This will allow retransmissions to be seamlessly sent to an alternate address without encountering IP fragmentation.",
      "ja": "5) 送信者は、ピアの宛先アドレスのすべてで発見された最小のPMTUとなるAssociation PMTUを追跡する必要があります。メッセージを複数の部分に断片化する場合、この関連付けPMTUを使用して、各フラグメントのサイズを計算する必要があります。これにより、IPの断片化に遭遇することなく、再送信を代替アドレスにシームレスに送信できます。"
    },
    {
      "indent": 3,
      "text": "Other than these differences, the discussion of TCP's use of MTU discovery in RFCs 1191 and 1981 applies to SCTP on a per-destination-address basis.",
      "ja": "これらの違いを除いて、RFCS 1191および1981でのTCPのMTU発見の使用に関する議論は、候補者ごとにSCTPに適用されます。"
    },
    {
      "indent": 3,
      "text": "Note: For IPv6 destination addresses the DF bit does not exist, instead the IP datagram must be fragmented as described in [RFC2460].",
      "ja": "注：IPv6宛先アドレスの場合、DFビットは存在しません。代わりに、[RFC2460]で説明されているようにIPデータグラムを断片化する必要があります。"
    },
    {
      "indent": 0,
      "text": "8. Fault Management",
      "section_title": true,
      "ja": "8. 障害管理"
    },
    {
      "indent": 0,
      "text": "8.1 Endpoint Failure Detection",
      "section_title": true,
      "ja": "8.1 エンドポイント障害検出"
    },
    {
      "indent": 3,
      "text": "An endpoint shall keep a counter on the total number of consecutive retransmissions to its peer (including retransmissions to all the destination transport addresses of the peer if it is multi-homed). If the value of this counter exceeds the limit indicated in the protocol parameter 'Association.Max.Retrans', the endpoint shall consider the peer endpoint unreachable and shall stop transmitting any more data to it (and thus the association enters the CLOSED state). In addition, the endpoint shall report the failure to the upper layer, and optionally report back all outstanding user data remaining in its outbound queue. The association is automatically closed when the peer endpoint becomes unreachable.",
      "ja": "エンドポイントは、ピアへの連続した再送信の総数にカウンターを維持するものとします（マルチホームの場合、ピアのすべての宛先輸送アドレスへの再送信を含む）。このカウンターの値が、プロトコルパラメーター「Association.max.retrans」に示されている制限を超える場合、エンドポイントはピアエンドポイントを到達不可能と見なし、それ以上のデータの送信を停止するものとします（したがって、関連付けは閉じた状態に入ります）。さらに、エンドポイントは上層層に障害を報告し、オプションでアウトバウンドキューに残っているすべての未解決のユーザーデータを報告するものとします。ピアエンドポイントが到達不可能になると、関連性は自動的に閉じられます。"
    },
    {
      "indent": 3,
      "text": "The counter shall be reset each time a DATA chunk sent to that peer endpoint is acknowledged (by the reception of a SACK), or a HEARTBEAT-ACK is received from the peer endpoint.",
      "ja": "カウンターは、そのピアエンドポイントに送信されるデータチャンクが（袋の受信によって）認められるたびにリセットされるか、ピアエンドポイントからハートビートックが受信されます。"
    },
    {
      "indent": 0,
      "text": "8.2 Path Failure Detection",
      "section_title": true,
      "ja": "8.2 パス障害検出"
    },
    {
      "indent": 3,
      "text": "When its peer endpoint is multi-homed, an endpoint should keep a error counter for each of the destination transport addresses of the peer endpoint.",
      "ja": "ピアエンドポイントがマルチホームの場合、エンドポイントは、ピアエンドポイントの各宛先輸送アドレスのエラーカウンターを保持する必要があります。"
    },
    {
      "indent": 3,
      "text": "Each time the T3-rtx timer expires on any address, or when a HEARTBEAT sent to an idle address is not acknowledged within a RTO, the error counter of that destination address will be incremented. When the value in the error counter exceeds the protocol parameter 'Path.Max.Retrans' of that destination address, the endpoint should mark the destination transport address as inactive, and a notification SHOULD be sent to the upper layer.",
      "ja": "T3-RTXタイマーが任意のアドレスで期限切れになるたびに、またはアイドル状態のアドレスに送られたハートビートがRTO内で確認されない場合、その宛先アドレスのエラーカウンターが増加します。エラーカウンターの値がその宛先アドレスのプロトコルパラメーター「path.max.retrans」を超える場合、エンドポイントは宛先輸送アドレスを非アクティブとしてマークし、通知を上層に送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "When an outstanding TSN is acknowledged or a HEARTBEAT sent to that address is acknowledged with a HEARTBEAT ACK, the endpoint shall clear the error counter of the destination transport address to which the DATA chunk was last sent (or HEARTBEAT was sent). When the peer endpoint is multi-homed and the last chunk sent to it was a retransmission to an alternate address, there exists an ambiguity as to whether or not the acknowledgement should be credited to the address of the last chunk sent. However, this ambiguity does not seem to bear any significant consequence to SCTP behavior. If this ambiguity is undesirable, the transmitter may choose not to clear the error counter if the last chunk sent was a retransmission.",
      "ja": "未解決のTSNが認められている場合、またはそのアドレスに送信されたハートビートがハートビートACKで確認される場合、エンドポイントは、データチャンクが最後に送信された（またはハートビートが送信された）宛先輸送アドレスのエラーカウンターをクリアするものとします。ピアエンドポイントがマルチホームであり、最後に送られたチャンクが代替アドレスへの再送信であった場合、承認が最後のチャンクの住所にクレジットされるべきかどうかについての曖昧さが存在します。ただし、このあいまいさは、SCTP行動に重大な結果をもたらすものではないようです。このあいまいさが望ましくない場合、送信者が送信された最後のチャンクが再送信であった場合、送信機はエラーカウンターをクリアしないことを選択できます。"
    },
    {
      "indent": 3,
      "text": "Note: When configuring the SCTP endpoint, the user should avoid having the value of 'Association.Max.Retrans' larger than the summation of the 'Path.Max.Retrans' of all the destination addresses for the remote endpoint. Otherwise, all the destination addresses may become inactive while the endpoint still considers the peer endpoint reachable. When this condition occurs, how the SCTP chooses to function is implementation specific.",
      "ja": "注：SCTPエンドポイントを構成する場合、ユーザーは、リモートエンドポイントのすべての宛先アドレスの「association.max.retrans」の合計よりも大きくなることを避けます。それ以外の場合、エンドポイントがピアエンドポイントに到達可能と見なされている間、すべての宛先アドレスが非アクティブになる場合があります。この条件が発生すると、SCTPが機能することを選択する方法は実装固有です。"
    },
    {
      "indent": 3,
      "text": "When the primary path is marked inactive (due to excessive retransmissions, for instance), the sender MAY automatically transmit new packets to an alternate destination address if one exists and is active. If more than one alternate address is active when the primary path is marked inactive only ONE transport address SHOULD be chosen and used as the new destination transport address.",
      "ja": "一次パスが不活性とマークされている場合（たとえば、過度の再送信のため）、送信者は、存在してアクティブな場合、新しいパケットを代替宛先アドレスに自動的に送信できます。プライマリパスが不活性にマークされている場合、複数の代替アドレスがアクティブである場合、1つの輸送アドレスのみを選択し、新しい宛先輸送アドレスとして使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.3 Path Heartbeat",
      "section_title": true,
      "ja": "8.3 パスハートビート"
    },
    {
      "indent": 3,
      "text": "By default, an SCTP endpoint shall monitor the reachability of the idle destination transport address(es) of its peer by sending a HEARTBEAT chunk periodically to the destination transport address(es).",
      "ja": "デフォルトでは、SCTPエンドポイントは、宛先輸送アドレス（ES）に定期的にハートビートチャンクを送信することにより、ピアのアイドル宛先輸送アドレスの到達可能性を監視するものとします。"
    },
    {
      "indent": 3,
      "text": "A destination transport address is considered \"idle\" if no new chunk which can be used for updating path RTT (usually including first transmission DATA, INIT, COOKIE ECHO, HEARTBEAT etc.) and no HEARTBEAT has been sent to it within the current heartbeat period of that address. This applies to both active and inactive destination addresses.",
      "ja": "宛先輸送アドレスは、パスRTT（通常は最初の伝送データ、init、cookieエコー、ハートビートなど）の更新に使用できる新しいチャンクがなく、現在のハートビート期間内にハートビートが送信されていない場合、「アイドル」と見なされます。そのアドレスの。これは、アクティブおよび非アクティブな宛先アドレスの両方に適用されます。"
    },
    {
      "indent": 3,
      "text": "The upper layer can optionally initiate the following functions:",
      "ja": "上層層は、オプションで次の機能を開始できます。"
    },
    {
      "indent": 3,
      "text": "A) Disable heartbeat on a specific destination transport address of a given association,",
      "ja": "a）特定の関連付けの特定の目的地輸送アドレスでハートビートを無効にする、"
    },
    {
      "indent": 3,
      "text": "B) Change the HB.interval, C) Re-enable heartbeat on a specific destination transport address of a given association, and,",
      "ja": "b）hb.intervalを変更する、c）特定の協会の特定の宛先輸送住所で再生可能なハートビート、および、"
    },
    {
      "indent": 3,
      "text": "D) Request an on-demand HEARTBEAT on a specific destination transport address of a given association.",
      "ja": "d）特定の関連付けの特定の宛先輸送アドレスにオンデマンドの鼓動をリクエストします。"
    },
    {
      "indent": 3,
      "text": "The endpoint should increment the respective error counter of the destination transport address each time a HEARTBEAT is sent to that address and not acknowledged within one RTO.",
      "ja": "エンドポイントは、ハートビートがそのアドレスに送信され、1つのRTO内で確認されないたびに、宛先輸送アドレスのそれぞれのエラーカウンターをインクリメントする必要があります。"
    },
    {
      "indent": 3,
      "text": "When the value of this counter reaches the protocol parameter ' Path.Max.Retrans', the endpoint should mark the corresponding destination address as inactive if it is not so marked, and may also optionally report to the upper layer the change of reachability of this destination address. After this, the endpoint should continue HEARTBEAT on this destination address but should stop increasing the counter.",
      "ja": "このカウンターの値がプロトコルパラメーター「path.max.retrans」に到達した場合、エンドポイントは、それがそれほどマークされていない場合、対応する宛先アドレスを非アクティブとしてマークする必要があり、またオプションで上層にこれの到達可能性の変化を報告することもできます。宛先アドレス。この後、エンドポイントはこの宛先アドレスのハートビートを継続する必要がありますが、カウンターの増加を停止する必要があります。"
    },
    {
      "indent": 3,
      "text": "The sender of the HEARTBEAT chunk should include in the Heartbeat Information field of the chunk the current time when the packet is sent out and the destination address to which the packet is sent.",
      "ja": "ハートビートチャンクの送信者は、パケットが送信される現在の時刻とパケットが送信される宛先アドレスのハートビート情報フィールドに、チャンクのハートビート情報フィールドに含める必要があります。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: An alternative implementation of the heartbeat mechanism that can be used is to increment the error counter variable every time a HEARTBEAT is sent to a destination. Whenever a HEARTBEAT ACK arrives, the sender SHOULD clear the error counter of the destination that the HEARTBEAT was sent to. This in effect would clear the previously stroked error (and any other error counts as well).",
      "ja": "実装注：使用できるハートビートメカニズムの代替実装は、ハートビートが宛先に送信されるたびにエラーカウンター変数をインクリメントすることです。ハートビートACKが到着するたびに、送信者はハートビートが送信された宛先のエラーカウンターをクリアする必要があります。これにより、以前にstrokedしたエラーがクリアされます（および他のエラーもカウントされます）。"
    },
    {
      "indent": 3,
      "text": "The receiver of the HEARTBEAT should immediately respond with a HEARTBEAT ACK that contains the Heartbeat Information field copied from the received HEARTBEAT chunk.",
      "ja": "ハートビートの受信機は、受信したハートビートチャンクからコピーされたハートビート情報フィールドを含むハートビートACKですぐに応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT should clear the error counter of the destination transport address to which the HEARTBEAT was sent, and mark the destination transport address as active if it is not so marked. The endpoint may optionally report to the upper layer when an inactive destination address is marked as active due to the reception of the latest HEARTBEAT ACK. The receiver of the HEARTBEAT ACK must also clear the association overall error count as well (as defined in section 8.1).",
      "ja": "ハートビートACKを受け取ると、ハートビートの送信者は、ハートビートが送信された宛先輸送アドレスのエラーカウンターをクリアし、マークされていない場合は宛先輸送アドレスをアクティブとしてマークします。エンドポイントは、最新のハートビートACKの受信により、非アクティブな宛先アドレスがアクティブとしてマークされている場合、オプションで上層に報告する場合があります。ハートビートACKの受信機も、関連性全体のエラーカウントをクリアする必要があります（セクション8.1で定義されているように）。"
    },
    {
      "indent": 3,
      "text": "The receiver of the HEARTBEAT ACK should also perform an RTT measurement for that destination transport address using the time value carried in the HEARTBEAT ACK chunk.",
      "ja": "ハートビートACKの受信機は、ハートビートACKチャンクで運ばれる時間値を使用して、その宛先輸送アドレスのRTT測定を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "On an idle destination address that is allowed to heartbeat, a HEARTBEAT chunk is RECOMMENDED to be sent once per RTO of that destination address plus the protocol parameter 'HB.interval' , with jittering of +/- 50%, and exponential back-off of the RTO if the previous HEARTBEAT is unanswered.",
      "ja": "ハートビートに許可されているアイドル宛先アドレスでは、その宛先アドレスのRTOとプロトコルパラメーター「hb.interval」のRTOに1回送信することをお勧めします。以前のハートビートが未回答の場合、RTO。"
    },
    {
      "indent": 3,
      "text": "A primitive is provided for the SCTP user to change the HB.interval and turn on or off the heartbeat on a given destination address. The heartbeat interval set by the SCTP user is added to the RTO of that destination (including any exponential backoff). Only one heartbeat should be sent each time the heartbeat timer expires (if multiple destinations are idle). It is a implementation decision on how to choose which of the candidate idle destinations to heartbeat to (if more than one destination is idle).",
      "ja": "SCTPユーザーがHB.INTERVALを変更し、特定の宛先アドレスのハートビートをオンまたはオフにするためのプリミティブが提供されます。SCTPユーザーによって設定されたハートビート間隔は、その宛先のRTOに追加されます（指数関数的バックオフを含む）。ハートビートタイマーが期限切れになるたびに1つのハートビートを送信する必要があります（複数の宛先がアイドル状態にある場合）。これは、ハートビートする候補者のアイドル目的地を選択する方法に関する実装決定です（複数の宛先がアイドル状態である場合）。"
    },
    {
      "indent": 3,
      "text": "Note: When tuning the heartbeat interval, there is a side effect that SHOULD be taken into account. When this value is increased, i.e. the HEARTBEAT takes longer, the detection of lost ABORT messages takes longer as well. If a peer endpoint ABORTs the association for any reason and the ABORT chunk is lost, the local endpoint will only discover the lost ABORT by sending a DATA chunk or HEARTBEAT chunk (thus causing the peer to send another ABORT). This must be considered when tuning the HEARTBEAT timer. If the HEARTBEAT is disabled only sending DATA to the association will discover a lost ABORT from the peer.",
      "ja": "注：ハートビート間隔を調整するとき、考慮すべき副作用があります。この値が増加すると、つまり、ハートビートの時間がかかります。失われた中止メッセージの検出には時間がかかります。ピアエンドポイントが何らかの理由で協会を中止し、中止チャンクが失われた場合、ローカルエンドポイントはデータチャンクまたはハートビートチャンクを送信することによって失われた中止を発見します（したがって、ピアが別の中断を送信します）。これは、ハートビートタイマーを調整するときに考慮する必要があります。ハートビートが無効になっている場合、協会にデータを送信するだけで、ピアから失われた中止が発見されます。"
    },
    {
      "indent": 0,
      "text": "8.4 Handle \"Out of the blue\" Packets",
      "section_title": true,
      "ja": "8.4 「青から」パケットを処理します"
    },
    {
      "indent": 3,
      "text": "An SCTP packet is called an \"out of the blue\" (OOTB) packet if it is correctly formed, i.e., passed the receiver's Adler-32 check (see Section 6.8), but the receiver is not able to identify the association to which this packet belongs.",
      "ja": "SCTPパケットは、正しく形成されている場合、「ブルーから」（OOTB）パケットと呼ばれます。つまり、受信者のAdler-32チェックに合格しました（セクション6.8を参照）が、受信機はこれとの関連性を識別できません。パケットは属します。"
    },
    {
      "indent": 3,
      "text": "The receiver of an OOTB packet MUST do the following:",
      "ja": "OOTBパケットの受信者は、次のことを行う必要があります。"
    },
    {
      "indent": 3,
      "text": "1) If the OOTB packet is to or from a non-unicast address, silently discard the packet. Otherwise,",
      "ja": "1) OOTBパケットが非ユニカストアドレスとの間で、またはそれ以外の場合は、パケットを静かに破棄します。さもないと、"
    },
    {
      "indent": 3,
      "text": "2) If the OOTB packet contains an ABORT chunk, the receiver MUST silently discard the OOTB packet and take no further action. Otherwise,",
      "ja": "2) OOTBパケットに中止チャンクが含まれている場合、受信者はooTBパケットを静かに廃棄し、それ以上のアクションを実行する必要があります。さもないと、"
    },
    {
      "indent": 3,
      "text": "3) If the packet contains an INIT chunk with a Verification Tag set to '0', process it as described in Section 5.1. Otherwise,",
      "ja": "3) パケットに「0」に設定された検証タグが付いたinitチャンクが含まれている場合は、セクション5.1で説明されているように処理します。さもないと、"
    },
    {
      "indent": 3,
      "text": "4) If the packet contains a COOKIE ECHO in the first chunk, process it as described in Section 5.1. Otherwise,",
      "ja": "4) パケットに最初のチャンクにCookieエコーが含まれている場合は、セクション5.1で説明されているように処理します。さもないと、"
    },
    {
      "indent": 3,
      "text": "5) If the packet contains a SHUTDOWN ACK chunk, the receiver should respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE. When sending the SHUTDOWN COMPLETE, the receiver of the OOTB packet must fill in the Verification Tag field of the outbound packet with the Verification Tag received in the SHUTDOWN ACK and set the T-bit in the Chunk Flags to indicate that no TCB was found. Otherwise,",
      "ja": "5) パケットにシャットダウンACKチャンクが含まれている場合、受信者はシャットダウンが完了してOOTBパケットの送信者に応答する必要があります。シャットダウンを完了すると、OOTBパケットの受信機は、アウトバウンドパケットの検証タグフィールドにシャットダウンACKで受信した検証タグを入力し、チャンクフラグにTビットを設定して、TCBが見つからないことを示します。さもないと、"
    },
    {
      "indent": 3,
      "text": "6) If the packet contains a SHUTDOWN COMPLETE chunk, the receiver should silently discard the packet and take no further action. Otherwise,",
      "ja": "6) パケットにシャットダウンの完全なチャンクが含まれている場合、受信者はパケットを静かに廃棄し、それ以上のアクションを実行しません。さもないと、"
    },
    {
      "indent": 3,
      "text": "7) If the packet contains a \"Stale cookie\" ERROR or a COOKIE ACK the SCTP Packet should be silently discarded. Otherwise,",
      "ja": "7) パケットに「古いCookie」エラーまたはCookie ACKが含まれている場合、SCTPパケットは静かに破棄する必要があります。さもないと、"
    },
    {
      "indent": 3,
      "text": "8) The receiver should respond to the sender of the OOTB packet with an ABORT. When sending the ABORT, the receiver of the OOTB packet MUST fill in the Verification Tag field of the outbound packet with the value found in the Verification Tag field of the OOTB packet and set the T-bit in the Chunk Flags to indicate that no TCB was found. After sending this ABORT, the receiver of the OOTB packet shall discard the OOTB packet and take no further action.",
      "ja": "8) 受信者は、中止でOOTBパケットの送信者に応答する必要があります。中止を送信するとき、OOTBパケットの受信機は、OOTBパケットの検証タグフィールドにある値にアウトバウンドパケットの検証タグフィールドに記入し、チャンクフラグにTビットを設定してTCBがないことを示す必要があります。発見された。この中止を送信した後、OOTBパケットの受信機はOOTBパケットを廃棄し、それ以上のアクションを実行しません。"
    },
    {
      "indent": 0,
      "text": "8.5 Verification Tag",
      "section_title": true,
      "ja": "8.5 検証タグ"
    },
    {
      "indent": 3,
      "text": "The Verification Tag rules defined in this section apply when sending or receiving SCTP packets which do not contain an INIT, SHUTDOWN COMPLETE, COOKIE ECHO (see Section 5.1), ABORT or SHUTDOWN ACK chunk. The rules for sending and receiving SCTP packets containing one of these chunk types are discussed separately in Section 8.5.1.",
      "ja": "このセクションで定義されている検証タグルールは、init、shutdown Complete、cookieエコー（セクション5.1を参照）、中止またはシャットダウンACKチャンクを含むSCTPパケットを送信または受信するときに適用されます。これらのチャンクタイプのいずれかを含むSCTPパケットを送信および受信するためのルールについては、セクション8.5.1で個別に説明します。"
    },
    {
      "indent": 3,
      "text": "When sending an SCTP packet, the endpoint MUST fill in the Verification Tag field of the outbound packet with the tag value in the Initiate Tag parameter of the INIT or INIT ACK received from its peer.",
      "ja": "SCTPパケットを送信する場合、エンドポイントは、ピアから受信したinitまたはinit ackのinitiateタグパラメーターのタグ値をアウトバウンドパケットの検証タグフィールドに記入する必要があります。"
    },
    {
      "indent": 3,
      "text": "When receiving an SCTP packet, the endpoint MUST ensure that the value in the Verification Tag field of the received SCTP packet matches its own Tag. If the received Verification Tag value does not match the receiver's own tag value, the receiver shall silently discard the packet and shall not process it any further except for those cases listed in Section 8.5.1 below.",
      "ja": "SCTPパケットを受信するとき、エンドポイントは、受信したSCTPパケットの検証タグフィールドの値が独自のタグと一致することを確認する必要があります。受信した検証タグ値がレシーバー自身のタグ値と一致しない場合、受信者はパケットを静かに廃棄し、以下のセクション8.5.1にリストされているケースを除いて、それをさらに処理してはなりません。"
    },
    {
      "indent": 0,
      "text": "8.5.1 Exceptions in Verification Tag Rules",
      "section_title": true,
      "ja": "8.5.1 検証タグルールの例外"
    },
    {
      "indent": 3,
      "text": "A) Rules for packet carrying INIT:",
      "ja": "a）パケット運ぶinitのルール："
    },
    {
      "indent": 6,
      "text": "- The sender MUST set the Verification Tag of the packet to 0.",
      "ja": "- 送信者は、パケットの検証タグを0に設定する必要があります。"
    },
    {
      "indent": 6,
      "text": "- When an endpoint receives an SCTP packet with the Verification Tag set to 0, it should verify that the packet contains only an INIT chunk. Otherwise, the receiver MUST silently discard the packet.",
      "ja": "- エンドポイントが0に設定された検証タグを持つSCTPパケットを受信すると、パケットにinitチャンクのみが含まれていることを確認する必要があります。それ以外の場合、受信者はパケットを静かに破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "B) Rules for packet carrying ABORT:",
      "ja": "b）中止を携帯するためのルール："
    },
    {
      "indent": 6,
      "text": "- The endpoint shall always fill in the Verification Tag field of the outbound packet with the destination endpoint's tag value if it is known.",
      "ja": "- エンドポイントは、アウトバウンドパケットの検証タグフィールドに、既知の場合、宛先エンドポイントのタグ値を常に記入する必要があります。"
    },
    {
      "indent": 6,
      "text": "- If the ABORT is sent in response to an OOTB packet, the endpoint MUST follow the procedure described in Section 8.4.",
      "ja": "- OOTBパケットに応じて中止が送信される場合、エンドポイントはセクション8.4で説明されている手順に従う必要があります。"
    },
    {
      "indent": 6,
      "text": "- The receiver MUST accept the packet if the Verification Tag matches either its own tag, OR the tag of its peer. Otherwise, the receiver MUST silently discard the packet and take no further action.",
      "ja": "- 確認タグが独自のタグまたはそのピアのタグと一致する場合、受信者はパケットを受け入れる必要があります。それ以外の場合、受信者は静かにパケットを破棄し、それ以上のアクションを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "C) Rules for packet carrying SHUTDOWN COMPLETE:",
      "ja": "c）パケットキャリングシャットダウンのルール完全："
    },
    {
      "indent": 6,
      "text": "- When sending a SHUTDOWN COMPLETE, if the receiver of the SHUTDOWN ACK has a TCB then the destination endpoint's tag MUST be used. Only where no TCB exists should the sender use the Verification Tag from the SHUTDOWN ACK.",
      "ja": "- シャットダウンを完了すると、シャットダウンACKの受信機にTCBがある場合、宛先エンドポイントのタグを使用する必要があります。TCBが存在しない場合のみ、送信者はシャットダウンACKから検証タグを使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "- The receiver of a SHUTDOWN COMPLETE shall accept the packet if the Verification Tag field of the packet matches its own tag OR it is set to its peer's tag and the T bit is set in the Chunk Flags. Otherwise, the receiver MUST silently discard the packet and take no further action. An endpoint MUST ignore the SHUTDOWN COMPLETE if it is not in the SHUTDOWN-ACK-SENT state.",
      "ja": "- シャットダウンの受信者は、パケットの検証タグフィールドが独自のタグと一致する場合、またはピアのタグに設定され、tビットがチャンクフラグに設定されている場合、パケットを受け入れるものとします。それ以外の場合、受信者は静かにパケットを破棄し、それ以上のアクションを実行する必要があります。エンドポイントは、シャットダウンの停止状態にない場合、完全なシャットダウンを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "D) Rules for packet carrying a COOKIE ECHO",
      "ja": "d）クッキーエコーを運ぶパケットのルール"
    },
    {
      "indent": 6,
      "text": "- When sending a COOKIE ECHO, the endpoint MUST use the value of the Initial Tag received in the INIT ACK.",
      "ja": "- クッキーエコーを送信するとき、エンドポイントはinit ackで受信した初期タグの値を使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "- The receiver of a COOKIE ECHO follows the procedures in Section 5.",
      "ja": "- Cookie Echoの受信機は、セクション5の手順に従います。"
    },
    {
      "indent": 3,
      "text": "E) Rules for packet carrying a SHUTDOWN ACK",
      "ja": "e）シャットダウンACKを運ぶパケットのルール"
    },
    {
      "indent": 6,
      "text": "- If the receiver is in COOKIE-ECHOED or COOKIE-WAIT state the procedures in section 8.4 SHOULD be followed, in other words it should be treated as an Out Of The Blue packet.",
      "ja": "- 受信機がCookieエコーまたはCookie-Waitが記載されている場合、セクション8.4の手順に従う必要があります。つまり、青いパケットから扱う必要があります。"
    },
    {
      "indent": 0,
      "text": "9. Termination of Association",
      "section_title": true,
      "ja": "9. 関連付けの終了"
    },
    {
      "indent": 3,
      "text": "An endpoint should terminate its association when it exits from service. An association can be terminated by either abort or shutdown. An abort of an association is abortive by definition in that any data pending on either end of the association is discarded and not delivered to the peer. A shutdown of an association is considered a graceful close where all data in queue by either endpoint is delivered to the respective peers. However, in the case of a shutdown, SCTP does not support a half-open state (like TCP) wherein one side may continue sending data while the other end is closed. When either endpoint performs a shutdown, the association on each peer will stop accepting new data from its user and only deliver data in queue at the time of sending or receiving the SHUTDOWN chunk.",
      "ja": "エンドポイントは、サービスを終了するときに関連性を終了する必要があります。関連付けは、中止またはシャットダウンによって終了できます。協会のいずれかの端で保留中のデータが廃棄され、ピアに届けられていないという点で、協会の中絶は定義上中絶します。協会のシャットダウンは、いずれかのエンドポイントによるキュー内のすべてのデータがそれぞれのピアに配信される優雅な近接と見なされます。ただし、シャットダウンの場合、SCTPは、一方の側が閉じている間に一方の側がデータの送信を継続する可能性がある半分のオープン状態（TCPのような）をサポートしていません。いずれかのエンドポイントがシャットダウンを実行すると、各ピアの関連付けはユーザーから新しいデータの受け入れを停止し、シャットダウンチャンクの送信または受信時にキュー内のデータのみを配信します。"
    },
    {
      "indent": 0,
      "text": "9.1 Abort of an Association",
      "section_title": true,
      "ja": "9.1 協会の中絶"
    },
    {
      "indent": 3,
      "text": "When an endpoint decides to abort an existing association, it shall send an ABORT chunk to its peer endpoint. The sender MUST fill in the peer's Verification Tag in the outbound packet and MUST NOT bundle any DATA chunk with the ABORT.",
      "ja": "エンドポイントが既存の関連付けを中止することを決定した場合、ピアエンドポイントに中止チャンクを送信します。送信者は、アウトバウンドパケットのピアの検証タグを記入し、データチャンクを中断してバンドルしてはなりません。"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST NOT respond to any received packet that contains an ABORT chunk (also see Section 8.4).",
      "ja": "エンドポイントは、中止チャンクを含む受信したパケットに応答してはなりません（セクション8.4も参照）。"
    },
    {
      "indent": 3,
      "text": "An endpoint receiving an ABORT shall apply the special Verification Tag check rules described in Section 8.5.1.",
      "ja": "中止を受信するエンドポイントは、セクション8.5.1で説明されている特別な検証タグチェックルールを適用するものとします。"
    },
    {
      "indent": 3,
      "text": "After checking the Verification Tag, the receiving endpoint shall remove the association from its record, and shall report the termination to its upper layer.",
      "ja": "検証タグを確認した後、受信エンドポイントはその記録から協会を削除し、その上部層に終了を報告するものとします。"
    },
    {
      "indent": 0,
      "text": "9.2 Shutdown of an Association",
      "section_title": true,
      "ja": "9.2 協会のシャットダウン"
    },
    {
      "indent": 3,
      "text": "Using the SHUTDOWN primitive (see Section 10.1), the upper layer of an endpoint in an association can gracefully close the association. This will allow all outstanding DATA chunks from the peer of the shutdown initiator to be delivered before the association terminates.",
      "ja": "シャットダウンプリミティブ（セクション10.1を参照）を使用して、関連性のエンドポイントの上層層は、関連性を優雅に閉じることができます。これにより、協会が終了する前に、Shutdownイニシエーターのピアからのすべての未解決のデータチャンクが配信されます。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the SHUTDOWN primitive from its upper layer, the endpoint enters SHUTDOWN-PENDING state and remains there until all outstanding data has been acknowledged by its peer. The endpoint accepts no new data from its upper layer, but retransmits data to the far end if necessary to fill gaps.",
      "ja": "上層層からプリミティブを受け取ると、エンドポイントはシャットダウンの保留状態に入り、すべての未解決のデータがピアによって認められるまでそこにとどまります。エンドポイントは、上層から新しいデータを受け入れませんが、必要に応じてギャップを埋めるためにデータを遠端に再送信します。"
    },
    {
      "indent": 3,
      "text": "Once all its outstanding data has been acknowledged, the endpoint shall send a SHUTDOWN chunk to its peer including in the Cumulative TSN Ack field the last sequential TSN it has received from the peer. It shall then start the T2-shutdown timer and enter the SHUTDOWN-SENT state. If the timer expires, the endpoint must re-send the SHUTDOWN with the updated last sequential TSN received from its peer.",
      "ja": "すべての未解決のデータが認められたら、エンドポイントは、累積TSN ACKフィールドにピアから受け取った最後のシーケンシャルTSNを含め、そのピアにシャットダウンチャンクを送信するものとします。その後、T2-Shutdownタイマーを開始し、シャットダウンセント状態に入ります。タイマーの有効期限が切れた場合、エンドポイントは、ピアから受け取った更新された最後のシーケンシャルTSNでシャットダウンを再送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The rules in Section 6.3 MUST be followed to determine the proper timer value for T2-shutdown. To indicate any gaps in TSN, the endpoint may also bundle a SACK with the SHUTDOWN chunk in the same SCTP packet.",
      "ja": "T2-Shutdownの適切なタイマー値を決定するには、セクション6.3のルールに従う必要があります。TSNのギャップを示すために、エンドポイントは、同じSCTPパケットにシャットダウンチャンクで袋をバンドルすることもできます。"
    },
    {
      "indent": 3,
      "text": "An endpoint should limit the number of retransmissions of the SHUTDOWN chunk to the protocol parameter 'Association.Max.Retrans'. If this threshold is exceeded the endpoint should destroy the TCB and MUST report the peer endpoint unreachable to the upper layer (and thus the association enters the CLOSED state). The reception of any packet from its peer (i.e. as the peer sends all of its queued DATA chunks) should clear the endpoint's retransmission count and restart the T2-Shutdown timer, giving its peer ample opportunity to transmit all of its queued DATA chunks that have not yet been sent.",
      "ja": "エンドポイントは、プロトコルパラメーター「Association.max.retrans」へのシャットダウンチャンクの再送信の数を制限する必要があります。このしきい値を超える場合、エンドポイントはTCBを破壊し、上層に到達できないピアエンドポイントを報告する必要があります（したがって、関連付けは閉じた状態に入ります）。ピアからのパケットの受信（つまり、ピアがキューに登録されたデータチャンクをすべて送信するため）は、エンドポイントの再送信数をクリアし、T2-shutdownタイマーを再起動し、ピアがキューになったすべてのデータチャンクをすべて送信する十分な機会を与えます。まだ送信されていません。"
    },
    {
      "indent": 3,
      "text": "Upon the reception of the SHUTDOWN, the peer endpoint shall",
      "ja": "シャットダウンを受信すると、ピアエンドポイントは"
    },
    {
      "indent": 3,
      "text": "- enter the SHUTDOWN-RECEIVED state,",
      "ja": "- シャットダウンが推定される状態を入力し、"
    },
    {
      "indent": 3,
      "text": "- stop accepting new data from its SCTP user",
      "ja": "- SCTPユーザーから新しいデータの受け入れを停止します"
    },
    {
      "indent": 3,
      "text": "- verify, by checking the Cumulative TSN Ack field of the chunk, that all its outstanding DATA chunks have been received by the SHUTDOWN sender.",
      "ja": "- チャンクの累積TSN ACKフィールドを確認して、その未解決のデータチャンクがすべてシャットダウン送信者によって受信されたことを確認します。"
    },
    {
      "indent": 3,
      "text": "Once an endpoint as reached the SHUTDOWN-RECEIVED state it MUST NOT send a SHUTDOWN in response to a ULP request, and should discard subsequent SHUTDOWN chunks.",
      "ja": "シャットダウンが認識された状態に到達した場合、EndpointがULP要求に応じてシャットダウンを送信してはならず、その後のシャンクダウンのチャンクを破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "If there are still outstanding DATA chunks left, the SHUTDOWN receiver shall continue to follow normal data transmission procedures defined in Section 6 until all outstanding DATA chunks are acknowledged; however, the SHUTDOWN receiver MUST NOT accept new data from its SCTP user.",
      "ja": "未解決のデータチャンクがまだ残っている場合、シャットダウンレシーバーは、すべての未解決のデータチャンクが認められるまで、セクション6で定義されている通常のデータ送信手順に続き続けるものとします。ただし、シャットダウンレシーバーは、SCTPユーザーから新しいデータを受け入れてはなりません。"
    },
    {
      "indent": 3,
      "text": "While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately respond to each received packet containing one or more DATA chunk(s) with a SACK, a SHUTDOWN chunk, and restart the T2-shutdown timer. If it has no more outstanding DATA chunks, the SHUTDOWN receiver shall send a SHUTDOWN ACK and start a T2-shutdown timer of its own, entering the SHUTDOWN-ACK-SENT state. If the timer expires, the endpoint must re-send the SHUTDOWN ACK.",
      "ja": "シャットダウン状態では、シャットダウン送信者は、サック、シャットダウンチャンク、T2-Shutdownタイマーを再起動した1つ以上のデータチャンクを含む各受信パケットに直ちに応答する必要があります。これ以上の未解決のデータチャンクがない場合、シャットダウンレシーバーはシャットダウンACKを送信し、独自のT2-Shutdownタイマーを開始し、シャットダウン済みの状態に入ります。タイマーの有効期限が切れた場合、エンドポイントはシャットダウンACKを再送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The sender of the SHUTDOWN ACK should limit the number of retransmissions of the SHUTDOWN ACK chunk to the protocol parameter ' Association.Max.Retrans'. If this threshold is exceeded the endpoint should destroy the TCB and may report the peer endpoint unreachable to the upper layer (and thus the association enters the CLOSED state).",
      "ja": "シャットダウンACKの送信者は、Shutdown ACKチャンクの再送信数をプロトコルパラメーター 'Association.max.Retrans'に制限する必要があります。このしきい値を超えた場合、エンドポイントはTCBを破壊し、上層に到達できないピアエンドポイントを報告する場合があります（したがって、関連付けは閉じた状態に入ります）。"
    },
    {
      "indent": 3,
      "text": "Upon the receipt of the SHUTDOWN ACK, the SHUTDOWN sender shall stop the T2-shutdown timer, send a SHUTDOWN COMPLETE chunk to its peer, and remove all record of the association.",
      "ja": "シャットダウンACKを受信すると、シャットダウン送信者はT2-Shutdownタイマーを停止し、ピアにシャットダウン完全チャンクを送信し、協会のすべての記録を削除します。"
    },
    {
      "indent": 3,
      "text": "Upon reception of the SHUTDOWN COMPLETE chunk the endpoint will verify that it is in SHUTDOWN-ACK-SENT state, if it is not the chunk should be discarded. If the endpoint is in the SHUTDOWN-ACK-SENT state the endpoint should stop the T2-shutdown timer and remove all knowledge of the association (and thus the association enters the CLOSED state).",
      "ja": "シャットダウンが完了したことを受け取ると、エンドポイントは、チャンクを破棄する必要がある場合、シャットダウンの停止状態にあることを確認します。エンドポイントがShutdown-ack-Sent状態にある場合、エンドポイントはT2-Shutdownタイマーを停止し、関連性のすべての知識を削除する必要があります（したがって、協会は閉じた状態に入ります）。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD assure that all its outstanding DATA chunks have been acknowledged before initiating the shutdown procedure.",
      "ja": "エンドポイントは、シャットダウン手順を開始する前に、すべての未解決のデータチャンクが認められていることを保証する必要があります。"
    },
    {
      "indent": 3,
      "text": "An endpoint should reject any new data request from its upper layer if it is in SHUTDOWN-PENDING, SHUTDOWN-SENT, SHUTDOWN-RECEIVED, or SHUTDOWN-ACK-SENT state.",
      "ja": "エンドポイントは、シャットダウンペンディング、シャットダウンセント、シャットダウン、またはシャットダウン済み状態にある場合、上層から新しいデータ要求を拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "If an endpoint is in SHUTDOWN-ACK-SENT state and receives an INIT chunk (e.g., if the SHUTDOWN COMPLETE was lost) with source and destination transport addresses (either in the IP addresses or in the INIT chunk) that belong to this association, it should discard the INIT chunk and retransmit the SHUTDOWN ACK chunk.",
      "ja": "エンドポイントがShutdown-ack-Sent状態にあり、この関連に属するソースおよび宛先輸送アドレス（IPアドレスまたはINITチャンクのいずれか）を使用して、initチャンク（たとえば、シャットダウンが完了した場合）を受け取る場合、init chunkを破棄し、シャットダウンACKチャンクを再送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: Receipt of an INIT with the same source and destination IP addresses as used in transport addresses assigned to an endpoint but with a different port number indicates the initialization of a separate association.",
      "ja": "注：エンドポイントに割り当てられた輸送アドレスで使用されているが、異なるポート番号を持つ同じソースと宛先IPアドレスを含むINITの受領は、個別の関連付けの初期化を示します。"
    },
    {
      "indent": 3,
      "text": "The sender of the INIT or COOKIE ECHO should respond to the receipt of a SHUTDOWN-ACK with a stand-alone SHUTDOWN COMPLETE in an SCTP packet with the Verification Tag field of its common header set to the same tag that was received in the SHUTDOWN ACK packet. This is considered an Out of the Blue packet as defined in Section 8.4. The sender of the INIT lets T1-init continue running and remains in the COOKIE-WAIT or COOKIE-ECHOED state. Normal T1-init timer expiration will cause the INIT or COOKIE chunk to be retransmitted and thus start a new association.",
      "ja": "initまたはcookieエコーの送信者は、シャットダウンACKで受信した同じタグに共通ヘッダーセットの検証タグフィールドを備えたSCTPパケットに完全なスタンドアロンシャットダウンを備えたシャットダウン攻撃の受領に応答する必要がありますパケット。これは、セクション8.4で定義されているように、青色のパケットと見なされます。INITの送信者により、T1-Initは実行を続け、Cookie-WaitまたはCookieエコー状態にとどまります。通常のT1-ISITタイマーの有効期限は、INITまたはCookieチャンクを再送信し、新しい関連付けを開始します。"
    },
    {
      "indent": 3,
      "text": "If a SHUTDOWN is received in COOKIE WAIT or COOKIE ECHOED states the SHUTDOWN chunk SHOULD be silently discarded.",
      "ja": "Cookieでシャットダウンを受け取った場合、またはCookieがエコーした状態で、シャットダウンチャンクは静かに廃棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "If an endpoint is in SHUTDOWN-SENT state and receives a SHUTDOWN chunk from its peer, the endpoint shall respond immediately with a SHUTDOWN ACK to its peer, and move into a SHUTDOWN-ACK-SENT state restarting its T2-shutdown timer.",
      "ja": "エンドポイントがシャットダウン状態にあり、ピアからシャットダウンチャンクを受け取る場合、エンドポイントはすぐにピアにシャットダウンACKを使用して応答し、T2-Shutdownタイマーを再起動するシャットダウンのセント状態に移動します。"
    },
    {
      "indent": 3,
      "text": "If an endpoint is in the SHUTDOWN-ACK-SENT state and receives a SHUTDOWN ACK, it shall stop the T2-shutdown timer, send a SHUTDOWN COMPLETE chunk to its peer, and remove all record of the association.",
      "ja": "エンドポイントがShutdown-ack-Sent状態にあり、シャットダウンACKを受け取る場合、T2-Shutdownタイマーを停止し、ピアに完全なチャンクを送信し、協会のすべての記録を削除します。"
    },
    {
      "indent": 0,
      "text": "10. Interface with Upper Layer",
      "section_title": true,
      "ja": "10. 上層とのインターフェース"
    },
    {
      "indent": 3,
      "text": "The Upper Layer Protocols (ULP) shall request for services by passing primitives to SCTP and shall receive notifications from SCTP for various events.",
      "ja": "上層層プロトコル（ULP）は、SCTPにプリミティブを渡すことによりサービスを要求し、さまざまなイベントのSCTPから通知を受け取るものとします。"
    },
    {
      "indent": 3,
      "text": "The primitives and notifications described in this section should be used as a guideline for implementing SCTP. The following functional description of ULP interface primitives is shown for illustrative purposes. Different SCTP implementations may have different ULP interfaces. However, all SCTPs must provide a certain minimum set of services to guarantee that all SCTP implementations can support the same protocol hierarchy.",
      "ja": "このセクションで説明するプリミティブと通知は、SCTPを実装するためのガイドラインとして使用する必要があります。ULP界面のプリミティブの次の機能的な説明は、説明のために示されています。異なるSCTP実装には、ULPインターフェイスが異なる場合があります。ただし、すべてのSCTPは、すべてのSCTP実装が同じプロトコル階層をサポートできることを保証するために、特定の最小サービスセットを提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.1 ULP-to-SCTP",
      "section_title": true,
      "ja": "10.1 ULP-to-SCTP"
    },
    {
      "indent": 3,
      "text": "The following sections functionally characterize a ULP/SCTP interface. The notation used is similar to most procedure or function calls in high level languages.",
      "ja": "次のセクションは、ULP/SCTPインターフェイスを機能的に特徴付けます。使用される表記は、高レベルの言語でのほとんどの手順または関数呼び出しに似ています。"
    },
    {
      "indent": 3,
      "text": "The ULP primitives described below specify the basic functions the SCTP must perform to support inter-process communication. Individual implementations must define their own exact format, and may provide combinations or subsets of the basic functions in single calls.",
      "ja": "以下に説明するULPプリミティブは、SCTPがプロセス間通信をサポートするために実行する必要がある基本的な機能を指定します。個々の実装は、独自の正確な形式を定義する必要があり、単一呼び出しで基本関数の組み合わせまたはサブセットを提供する場合があります。"
    },
    {
      "indent": 3,
      "text": "A) Initialize",
      "ja": "a）初期化"
    },
    {
      "indent": 3,
      "text": "Format: INITIALIZE ([local port], [local eligible address list]) -> local SCTP instance name This primitive allows SCTP to initialize its internal data structures and allocate necessary resources for setting up its operation environment. Once SCTP is initialized, ULP can communicate directly with other endpoints without re-invoking this primitive.",
      "ja": "形式：初期化（[ローカルポート]、[ローカル対象のアドレスリスト]） - >ローカルSCTPインスタンス名このプリミティブにより、SCTPは内部データ構造を初期化し、操作環境を設定するために必要なリソースを割り当てることができます。SCTPが初期化されると、ULPはこのプリミティブを再拒否せずに他のエンドポイントと直接通信できます。"
    },
    {
      "indent": 3,
      "text": "SCTP will return a local SCTP instance name to the ULP.",
      "ja": "SCTPは、ローカルSCTPインスタンス名をULPに返します。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須属性："
    },
    {
      "indent": 3,
      "text": "None.",
      "ja": "なし。"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "The following types of attributes may be passed along with the primitive:",
      "ja": "次のタイプの属性は、原始と渡すことができます。"
    },
    {
      "indent": 3,
      "text": "o local port - SCTP port number, if ULP wants it to be specified;",
      "ja": "o ローカルポート-SCTPポート番号、ULPが指定したい場合。"
    },
    {
      "indent": 3,
      "text": "o local eligible address list - An address list that the local SCTP endpoint should bind. By default, if an address list is not included, all IP addresses assigned to the host should be used by the local endpoint.",
      "ja": "o ローカル資格のあるアドレスリスト - ローカルSCTPエンドポイントがバインドするアドレスリスト。デフォルトでは、アドレスリストが含まれていない場合、ホストに割り当てられたすべてのIPアドレスをローカルエンドポイントで使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: If this optional attribute is supported by an implementation, it will be the responsibility of the implementation to enforce that the IP source address field of any SCTP packets sent out by this endpoint contains one of the IP addresses indicated in the local eligible address list.",
      "ja": "実装注：このオプションの属性が実装によってサポートされている場合、このエンドポイントによって送信されたSCTPパケットのIPソースアドレスフィールドに、ローカル適格アドレスに示されているIPアドレスの1つが含まれていることを実施するのは実装の責任です。リスト。"
    },
    {
      "indent": 3,
      "text": "B) Associate",
      "ja": "b）アソシエイト"
    },
    {
      "indent": 3,
      "text": "Format: ASSOCIATE(local SCTP instance name, destination transport addr, outbound stream count) -> association id [,destination transport addr list] [,outbound stream count]",
      "ja": "フォーマット：Associate（ローカルSCTPインスタンス名、宛先輸送ADDR、アウトバウンドストリームカウント） - > Association ID [、Destination Transport addr List] [、アウトバウンドストリームカウント]"
    },
    {
      "indent": 3,
      "text": "This primitive allows the upper layer to initiate an association to a specific peer endpoint.",
      "ja": "この原始により、上層が特定のピアエンドポイントに関連性を開始できます。"
    },
    {
      "indent": 3,
      "text": "The peer endpoint shall be specified by one of the transport addresses which defines the endpoint (see Section 1.4). If the local SCTP instance has not been initialized, the ASSOCIATE is considered an error.",
      "ja": "ピアエンドポイントは、エンドポイントを定義する輸送アドレスの1つによって指定されなければなりません（セクション1.4を参照）。ローカルSCTPインスタンスが初期化されていない場合、アソシエイトはエラーと見なされます。"
    },
    {
      "indent": 3,
      "text": "An association id, which is a local handle to the SCTP association, will be returned on successful establishment of the association. If SCTP is not able to open an SCTP association with the peer endpoint, an error is returned.",
      "ja": "SCTP協会のローカルハンドルであるAssociation IDは、協会の成功した設立で返されます。SCTPがピアエンドポイントとSCTP関連を開くことができない場合、エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "Other association parameters may be returned, including the complete destination transport addresses of the peer as well as the outbound stream count of the local endpoint. One of the transport address from the returned destination addresses will be selected by the local endpoint as default primary path for sending SCTP packets to this peer. The returned \"destination transport addr list\" can be used by the ULP to change the default primary path or to force sending a packet to a specific transport address.",
      "ja": "ピアの完全な宛先輸送アドレスやローカルエンドポイントのアウトバウンドストリームカウントなど、他の関連付けパラメーターが返される場合があります。返された宛先アドレスからの輸送アドレスの1つは、SCTPパケットをこのピアに送信するためのデフォルトのプライマリパスとしてローカルエンドポイントによって選択されます。返された「Destination Transport AddRリスト」は、ULPがデフォルトのプライマリパスを変更するか、特定の輸送アドレスにパケットを強制的に送信するために使用できます。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: If ASSOCIATE primitive is implemented as a blocking function call, the ASSOCIATE primitive can return association parameters in addition to the association id upon successful establishment. If ASSOCIATE primitive is implemented as a non-blocking call, only the association id shall be returned and association parameters shall be passed using the COMMUNICATION UP notification.",
      "ja": "実装注：アソシエイトプリミティブがブロッキング関数呼び出しとして実装されている場合、アソシエイトプリミティブは、成功した施設時にアソシエーションIDに加えてアソシエーションパラメーターを返すことができます。アソシエイトプリミティブが非ブロッキングコールとして実装されている場合、Association IDのみが返され、通信アップ通知を使用してアソシエーションパラメーターが渡されます。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須属性："
    },
    {
      "indent": 3,
      "text": "o local SCTP instance name - obtained from the INITIALIZE operation.",
      "ja": "o ローカルSCTPインスタンス名 - 初期化操作から取得。"
    },
    {
      "indent": 3,
      "text": "o destination transport addr - specified as one of the transport addresses of the peer endpoint with which the association is to be established.",
      "ja": "o 宛先輸送ADDR-協会が確立されるピアエンドポイントの輸送アドレスの1つとして指定されています。"
    },
    {
      "indent": 3,
      "text": "o outbound stream count - the number of outbound streams the ULP would like to open towards this peer endpoint.",
      "ja": "o アウトバウンドストリームカウント -  ULPがこのピアエンドポイントに向けて開きたいアウトバウンドストリームの数。"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "None.",
      "ja": "なし。"
    },
    {
      "indent": 3,
      "text": "C) Shutdown",
      "ja": "c）シャットダウン"
    },
    {
      "indent": 3,
      "text": "Format: SHUTDOWN(association id) -> result",
      "ja": "フォーマット：Shutdown（AssociationID） - > result"
    },
    {
      "indent": 3,
      "text": "Gracefully closes an association. Any locally queued user data will be delivered to the peer. The association will be terminated only after the peer acknowledges all the SCTP packets sent. A success code will be returned on successful termination of the association. If attempting to terminate the association results in a failure, an error code shall be returned.",
      "ja": "関連性を優雅に閉じます。ローカルでキューに囲まれたユーザーデータは、ピアに配信されます。協会は、ピアが送信されたすべてのSCTPパケットを認めた後にのみ終了します。成功コードは、協会の成功した終了時に返されます。協会を終了しようとすると、障害が発生した場合、エラーコードが返されます。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association Optional attributes:",
      "ja": "o Association ID- SCTP Associationのローカルハンドルオプション属性："
    },
    {
      "indent": 3,
      "text": "None.",
      "ja": "なし。"
    },
    {
      "indent": 3,
      "text": "D) Abort",
      "ja": "d）中止"
    },
    {
      "indent": 3,
      "text": "Format: ABORT(association id [, cause code]) -> result",
      "ja": "形式：Abort（AssociationID [、cause code]） - > result"
    },
    {
      "indent": 3,
      "text": "Ungracefully closes an association. Any locally queued user data will be discarded and an ABORT chunk is sent to the peer. A success code will be returned on successful abortion of the association. If attempting to abort the association results in a failure, an error code shall be returned.",
      "ja": "協会を不平を言っています。ローカルでキューに囲まれたユーザーデータは破棄され、中止チャンクがピアに送信されます。成功コードは、協会の成功した中絶で返されます。協会を中止しようとすると、障害が発生した場合、エラーコードが返されます。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association",
      "ja": "o 協会ID- SCTP協会のローカルハンドル"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "o cause code - reason of the abort to be passed to the peer.",
      "ja": "o 原因コード - 中止の理由がピアに渡される理由。"
    },
    {
      "indent": 3,
      "text": "None.",
      "ja": "なし。"
    },
    {
      "indent": 3,
      "text": "E) Send",
      "ja": "e）送信"
    },
    {
      "indent": 3,
      "text": "Format: SEND(association id, buffer address, byte count [,context] [,stream id] [,life time] [,destination transport address] [,unorder flag] [,no-bundle flag] [,payload protocol-id] ) -> result",
      "ja": "Format：send（Association ID、Buffer Address、Byte Count [、Context] [、Stream ID] [、Life Time] [、Destination Transport Address] [、Unorder Flag] [、No-Bundle Flag] [、Payload Protocol-ID]  - >結果"
    },
    {
      "indent": 3,
      "text": "This is the main method to send user data via SCTP.",
      "ja": "これは、SCTPを介してユーザーデータを送信する主な方法です。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association",
      "ja": "o 協会ID- SCTP協会のローカルハンドル"
    },
    {
      "indent": 3,
      "text": "o buffer address - the location where the user message to be transmitted is stored;",
      "ja": "o バッファアドレス - 送信されるユーザーメッセージが保存される場所。"
    },
    {
      "indent": 3,
      "text": "o byte count - The size of the user data in number of bytes;",
      "ja": "o バイトカウント - バイト数のユーザーデータのサイズ。"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "o context - an optional 32 bit integer that will be carried in the sending failure notification to the ULP if the transportation of this User Message fails.",
      "ja": "o コンテキスト - このユーザーメッセージの輸送が失敗した場合に、故障通知をULPに送信通知で携帯するオプションの32ビット整数。"
    },
    {
      "indent": 3,
      "text": "o stream id - to indicate which stream to send the data on. If not specified, stream 0 will be used.",
      "ja": "o ストリームID-データを送信するストリームを示すため。指定されていない場合、ストリーム0が使用されます。"
    },
    {
      "indent": 3,
      "text": "o life time - specifies the life time of the user data. The user data will not be sent by SCTP after the life time expires. This parameter can be used to avoid efforts to transmit stale user messages. SCTP notifies the ULP if the data cannot be initiated to transport (i.e. sent to the destination via SCTP's send primitive) within the life time variable. However, the user data will be transmitted if SCTP has attempted to transmit a chunk before the life time expired.",
      "ja": "o 寿命 - ユーザーデータの寿命を指定します。ユーザーデータは、寿命が経過した後、SCTPによって送信されません。このパラメーターは、古いユーザーメッセージを送信する努力を回避するために使用できます。SCTPは、寿命変数内でデータを輸送するためにデータを開始できない場合（つまり、SCTPのSend Primitiveを介して宛先に送信される）、ULPに通知します。ただし、SCTPが寿命の期限が切れる前にチャンクを送信しようとした場合、ユーザーデータは送信されます。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: In order to better support the data lifetime option, the transmitter may hold back the assigning of the TSN number to an outbound DATA chunk to the last moment. And, for implementation simplicity, once a TSN number has been assigned the sender should consider the send of this DATA chunk as committed, overriding any lifetime option attached to the DATA chunk.",
      "ja": "実装注：データライフタイムオプションをより適切にサポートするために、トランスミッターはTSN番号のアウトバウンドデータチャンクへの割り当てを最後の瞬間に抑制することができます。また、実装の単純さのために、TSN番号が割り当てられたら、送信者はこのデータチャンクの送信をコミットし、データチャンクに添付された生涯オプションをオーバーライドする必要があります。"
    },
    {
      "indent": 3,
      "text": "o destination transport address - specified as one of the destination transport addresses of the peer endpoint to which this packet should be sent. Whenever possible, SCTP should use this destination transport address for sending the packets, instead of the current primary path.",
      "ja": "o 宛先輸送アドレス - このパケットを送信するピアエンドポイントの宛先輸送アドレスの1つとして指定されています。可能な限り、SCTPは、現在のプライマリパスではなく、パケットを送信するためにこの宛先輸送アドレスを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o unorder flag - this flag, if present, indicates that the user would like the data delivered in an unordered fashion to the peer (i.e., the U flag is set to 1 on all DATA chunks carrying this message).",
      "ja": "o UNORDERフラグ - このフラグは、存在する場合、ユーザーがピアに順序付けられていないファッションで配信されるデータを望んでいることを示します（つまり、Uフラグは、このメッセージを伝えるすべてのデータチャンクで1に設定されます）。"
    },
    {
      "indent": 3,
      "text": "o no-bundle flag - instructs SCTP not to bundle this user data with other outbound DATA chunks. SCTP MAY still bundle even when this flag is present, when faced with network congestion.",
      "ja": "o バンドルフラグなし -  SCTPに、このユーザーデータを他のアウトバウンドデータチャンクにバンドルしないように指示します。SCTPは、ネットワークの混雑に直面している場合でも、このフラグが存在する場合でもバンドルする場合があります。"
    },
    {
      "indent": 3,
      "text": "o payload protocol-id - A 32 bit unsigned integer that is to be passed to the peer indicating the type of payload protocol data being transmitted. This value is passed as opaque data by SCTP.",
      "ja": "o ペイロードプロトコル-ID-送信されるペイロードプロトコルデータのタイプを示すピアに渡される32ビットの署名整合体。この値は、SCTPによって不透明なデータとして渡されます。"
    },
    {
      "indent": 3,
      "text": "F) Set Primary",
      "ja": "f）プライマリを設定します"
    },
    {
      "indent": 3,
      "text": "Format: SETPRIMARY(association id, destination transport address, [source transport address] ) -> result",
      "ja": "フォーマット：SetPrimary（Association ID、宛先輸送アドレス、[ソース輸送アドレス]） - >結果"
    },
    {
      "indent": 3,
      "text": "Instructs the local SCTP to use the specified destination transport address as primary path for sending packets.",
      "ja": "ローカルSCTPに、指定された宛先輸送アドレスをパケットを送信するためのプライマリパスとして使用するよう指示します。"
    },
    {
      "indent": 3,
      "text": "The result of attempting this operation shall be returned. If the specified destination transport address is not present in the \"destination transport address list\" returned earlier in an associate command or communication up notification, an error shall be returned.",
      "ja": "この操作を試みた結果は返されます。指定された宛先輸送アドレスが「宛先輸送アドレスリスト」に存在しない場合、関連するコマンドまたは通信アップ通知で早期に返された場合、エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association",
      "ja": "o 協会ID- SCTP協会のローカルハンドル"
    },
    {
      "indent": 3,
      "text": "o destination transport address - specified as one of the transport addresses of the peer endpoint, which should be used as primary address for sending packets. This overrides the current primary address information maintained by the local SCTP endpoint.",
      "ja": "o 宛先輸送アドレス - ピアエンドポイントの輸送アドレスの1つとして指定されています。これは、パケットを送信するためのプライマリアドレスとして使用する必要があります。これは、ローカルSCTPエンドポイントによって維持されている現在のプライマリアドレス情報をオーバーライドします。"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "o source transport address - optionally, some implementations may allow you to set the default source address placed in all outgoing IP datagrams.",
      "ja": "o ソーストランスポートアドレス - オプションで、一部の実装では、すべての発信IPデータグラムに配置されたデフォルトのソースアドレスを設定できる場合があります。"
    },
    {
      "indent": 3,
      "text": "G) Receive",
      "ja": "g）受信"
    },
    {
      "indent": 3,
      "text": "Format: RECEIVE(association id, buffer address, buffer size [,stream id]) -> byte count [,transport address] [,stream id] [,stream sequence number] [,partial flag] [,delivery number] [,payload protocol-id]",
      "ja": "フォーマット：受信（Association ID、バッファアドレス、バッファサイズ[、ストリームID]） - >バイトカウント[、トランスポートアドレス] [、ストリームID] [、ストリームシーケンス番号] [、部分フラグ] [、配信番号] [、ペイロードプロトコルID]"
    },
    {
      "indent": 3,
      "text": "This primitive shall read the first user message in the SCTP in-queue into the buffer specified by ULP, if there is one available. The size of the message read, in bytes, will be returned. It may, depending on the specific implementation, also return other information such as the sender's address, the stream id on which it is received, whether there are more messages available for retrieval, etc. For ordered messages, their stream sequence number may also be returned.",
      "ja": "このプリミティブは、利用可能なものがある場合、ULPで指定されたバッファーにSCTPインクエー内の最初のユーザーメッセージを読み取ります。読み取られたメッセージのサイズは、バイトで返されます。特定の実装に応じて、送信者のアドレス、受信したストリームID、検索に利用できるメッセージなど、順序付けられたメッセージなどの他の情報を返します。戻ってきた。"
    },
    {
      "indent": 3,
      "text": "Depending upon the implementation, if this primitive is invoked when no message is available the implementation should return an indication of this condition or should block the invoking process until data does become available.",
      "ja": "実装に応じて、メッセージが使用可能な場合にこのプリミティブが呼び出された場合、実装はこの条件の表示を返すか、データが利用可能になるまで呼び出しプロセスをブロックする必要があります。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association",
      "ja": "o 協会ID- SCTP協会のローカルハンドル"
    },
    {
      "indent": 3,
      "text": "o buffer address - the memory location indicated by the ULP to store the received message.",
      "ja": "o バッファアドレス - 受信したメッセージを保存するためにULPが示すメモリの位置。"
    },
    {
      "indent": 3,
      "text": "o buffer size - the maximum size of data to be received, in bytes.",
      "ja": "o バッファサイズ - バイト単位で受信するデータの最大サイズ。"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "o stream id - to indicate which stream to receive the data on.",
      "ja": "o ストリームID-データを受信するストリームを示すため。"
    },
    {
      "indent": 3,
      "text": "o stream sequence number - the stream sequence number assigned by the sending SCTP peer.",
      "ja": "o ストリームシーケンス番号-SCTPピアの送信によって割り当てられたストリームシーケンス番号。"
    },
    {
      "indent": 3,
      "text": "o partial flag - if this returned flag is set to 1, then this Receive contains a partial delivery of the whole message. When this flag is set, the stream id and stream sequence number MUST accompany this receive. When this flag is set to 0, it indicates that no more deliveries will be received for this stream sequence number.",
      "ja": "o 部分フラグ - この返されたフラグが1に設定されている場合、この受信にはメッセージ全体の部分的な配信が含まれます。このフラグが設定されている場合、ストリームIDとストリームシーケンス番号にこの受信に付随する必要があります。このフラグが0に設定されている場合、このストリームシーケンス番号に対してこれ以上配信が受信されないことを示します。"
    },
    {
      "indent": 3,
      "text": "o payload protocol-id - A 32 bit unsigned integer that is received from the peer indicating the type of payload protocol of the received data. This value is passed as opaque data by SCTP.",
      "ja": "o ペイロードプロトコル-ID-受信データのペイロードプロトコルのタイプを示すピアから受信される32ビットの署名整数。この値は、SCTPによって不透明なデータとして渡されます。"
    },
    {
      "indent": 3,
      "text": "H) Status",
      "ja": "h）ステータス"
    },
    {
      "indent": 3,
      "text": "Format: STATUS(association id) -> status data",
      "ja": "フォーマット：ステータス（AssociationID） - >ステータスデータ"
    },
    {
      "indent": 3,
      "text": "This primitive should return a data block containing the following information: association connection state, destination transport address list, destination transport address reachability states, current receiver window size, current congestion window sizes, number of unacknowledged DATA chunks, number of DATA chunks pending receipt, primary path, most recent SRTT on primary path, RTO on primary path, SRTT and RTO on other destination addresses, etc.",
      "ja": "このプリミティブは、次の情報を含むデータブロックを返す必要があります。関連付け接続状態、宛先輸送アドレスリスト、宛先輸送アドレスの到達可能性状態、現在の渋滞ウィンドウサイズ、未販売のデータチャンクの数、保留中のデータチャンクの数、プライマリパス、プライマリパスに関する最新のSRTT、プライマリパスでのRTO、SRTTおよびRTOの他の宛先アドレスなど。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association",
      "ja": "o 協会ID- SCTP協会のローカルハンドル"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 4,
      "text": "None.",
      "ja": "なし。"
    },
    {
      "indent": 3,
      "text": "I) Change Heartbeat",
      "ja": "i）ハートビートを変更します"
    },
    {
      "indent": 3,
      "text": "Format: CHANGEHEARTBEAT(association id, destination transport address, new state [,interval]) -> result",
      "ja": "フォーマット：ChangeHeartBeat（Association ID、宛先輸送アドレス、新しい状態[、間隔]） - >結果"
    },
    {
      "indent": 3,
      "text": "Instructs the local endpoint to enable or disable heartbeat on the specified destination transport address.",
      "ja": "指定された宛先輸送アドレスでハートビートを有効または無効にするようにローカルエンドポイントに指示します。"
    },
    {
      "indent": 3,
      "text": "The result of attempting this operation shall be returned.",
      "ja": "この操作を試みた結果は返されます。"
    },
    {
      "indent": 3,
      "text": "Note: Even when enabled, heartbeat will not take place if the destination transport address is not idle.",
      "ja": "注：有効にしても、宛先輸送アドレスがアイドル状態でない場合、ハートビートは行われません。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association",
      "ja": "o 協会ID- SCTP協会のローカルハンドル"
    },
    {
      "indent": 3,
      "text": "o destination transport address - specified as one of the transport addresses of the peer endpoint.",
      "ja": "o 宛先輸送アドレス - ピアエンドポイントの輸送アドレスの1つとして指定されています。"
    },
    {
      "indent": 3,
      "text": "o new state - the new state of heartbeat for this destination transport address (either enabled or disabled).",
      "ja": "o 新しい状態 - この目的地輸送アドレスの新しいハートビートの状態（有効または無効）。"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "o interval - if present, indicates the frequency of the heartbeat if this is to enable heartbeat on a destination transport address. This value is added to the RTO of the destination transport address. This value, if present, effects all destinations.",
      "ja": "o 間隔 - 存在する場合は、これが宛先輸送アドレスでハートビートを有効にするためにハートビートの頻度を示します。この値は、宛先輸送アドレスのRTOに追加されます。この値が存在する場合、すべての目的地に影響します。"
    },
    {
      "indent": 3,
      "text": "J) Request HeartBeat",
      "ja": "j）ハートビートをリクエストします"
    },
    {
      "indent": 3,
      "text": "Format: REQUESTHEARTBEAT(association id, destination transport address) -> result",
      "ja": "フォーマット：RequestHeartBeat（Association ID、宛先輸送アドレス） - >結果"
    },
    {
      "indent": 3,
      "text": "Instructs the local endpoint to perform a HeartBeat on the specified destination transport address of the given association. The returned result should indicate whether the transmission of the HEARTBEAT chunk to the destination address is successful.",
      "ja": "指定された協会の指定された宛先輸送アドレスで鼓動を実行するようにローカルエンドポイントに指示します。返された結果は、宛先アドレスへのハートビートチャンクの送信が成功しているかどうかを示す必要があります。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association",
      "ja": "o 協会ID- SCTP協会のローカルハンドル"
    },
    {
      "indent": 3,
      "text": "o destination transport address - the transport address of the association on which a heartbeat should be issued.",
      "ja": "o 宛先輸送住所 - ハートビートを発行する協会の輸送住所。"
    },
    {
      "indent": 3,
      "text": "K) Get SRTT Report",
      "ja": "k）SRTTレポートを取得します"
    },
    {
      "indent": 3,
      "text": "Format: GETSRTTREPORT(association id, destination transport address) -> srtt result",
      "ja": "フォーマット：getsrttreport（協会ID、宛先輸送アドレス） - > srtt result"
    },
    {
      "indent": 3,
      "text": "Instructs the local SCTP to report the current SRTT measurement on the specified destination transport address of the given association. The returned result can be an integer containing the most recent SRTT in milliseconds.",
      "ja": "地元のSCTPに、指定された関連付けの指定された宛先輸送アドレスに関する現在のSRTT測定を報告するよう指示します。返された結果は、ミリ秒単位での最新のSRTTを含む整数である可能性があります。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association",
      "ja": "o 協会ID- SCTP協会のローカルハンドル"
    },
    {
      "indent": 3,
      "text": "o destination transport address - the transport address of the association on which the SRTT measurement is to be reported.",
      "ja": "o 宛先輸送住所 -  SRTT測定が報告される協会の輸送住所。"
    },
    {
      "indent": 3,
      "text": "L) Set Failure Threshold",
      "ja": "l）障害のしきい値を設定します"
    },
    {
      "indent": 3,
      "text": "Format: SETFAILURETHRESHOLD(association id, destination transport address, failure threshold) -> result",
      "ja": "形式：SetFailureThreshold（Association ID、宛先輸送アドレス、障害のしきい値） - >結果"
    },
    {
      "indent": 3,
      "text": "This primitive allows the local SCTP to customize the reachability failure detection threshold 'Path.Max.Retrans' for the specified destination address.",
      "ja": "この原始により、ローカルSCTPは、指定された宛先アドレスの到達可能性障害検出しきい値「path.max.retrans」をカスタマイズできます。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association",
      "ja": "o 協会ID- SCTP協会のローカルハンドル"
    },
    {
      "indent": 3,
      "text": "o destination transport address - the transport address of the association on which the failure detection threshold is to be set.",
      "ja": "o 宛先輸送住所 - 故障検出しきい値を設定する関連付けの輸送アドレス。"
    },
    {
      "indent": 3,
      "text": "o failure threshold - the new value of 'Path.Max.Retrans' for the destination address.",
      "ja": "o 障害のしきい値 - 宛先アドレスの「path.max.retrans」の新しい値。"
    },
    {
      "indent": 3,
      "text": "M) Set Protocol Parameters",
      "ja": "m）プロトコルパラメーターを設定します"
    },
    {
      "indent": 3,
      "text": "Format: SETPROTOCOLPARAMETERS(association id, [,destination transport address,] protocol parameter list) -> result",
      "ja": "形式：SetProtocolParameters（Association ID、[、宛先輸送アドレス、]プロトコルパラメーターリスト） - >結果"
    },
    {
      "indent": 3,
      "text": "This primitive allows the local SCTP to customize the protocol parameters.",
      "ja": "この原始により、ローカルSCTPはプロトコルパラメーターをカスタマイズできます。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association",
      "ja": "o 協会ID- SCTP協会のローカルハンドル"
    },
    {
      "indent": 3,
      "text": "o protocol parameter list - The specific names and values of the protocol parameters (e.g., Association.Max.Retrans [see Section 14]) that the SCTP user wishes to customize.",
      "ja": "o プロトコルパラメーターリスト -  SCTPユーザーがカスタマイズしたいプロトコルパラメーターの特定の名前と値（Association.max.retrans [セクション14を参照]）。"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "o destination transport address - some of the protocol parameters may be set on a per destination transport address basis.",
      "ja": "o 宛先輸送アドレス - プロトコルパラメーターの一部は、宛先輸送アドレスごとに設定できます。"
    },
    {
      "indent": 3,
      "text": "N) Receive unsent message",
      "ja": "n）無関係なメッセージを受信します"
    },
    {
      "indent": 3,
      "text": "Format: RECEIVE_UNSENT(data retrieval id, buffer address, buffer size [,stream id] [, stream sequence number] [,partial flag] [,payload protocol-id])",
      "ja": "形式：Receid_unsent（データ取得ID、バッファアドレス、バッファサイズ[、ストリームID] [、ストリームシーケンス番号] [、部分フラグ] [、ペイロードプロトコルID]））"
    },
    {
      "indent": 3,
      "text": "o data retrieval id - The identification passed to the ULP in the failure notification.",
      "ja": "o データ検索ID-障害通知でULPに渡された識別。"
    },
    {
      "indent": 3,
      "text": "o buffer address - the memory location indicated by the ULP to store the received message.",
      "ja": "o バッファアドレス - 受信したメッセージを保存するためにULPが示すメモリの位置。"
    },
    {
      "indent": 3,
      "text": "o buffer size - the maximum size of data to be received, in bytes.",
      "ja": "o バッファサイズ - バイト単位で受信するデータの最大サイズ。"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "o stream id - this is a return value that is set to indicate which stream the data was sent to.",
      "ja": "o ストリームID-これは、データが送信されたストリームを示すように設定されているリターン値です。"
    },
    {
      "indent": 3,
      "text": "o stream sequence number - this value is returned indicating the stream sequence number that was associated with the message.",
      "ja": "o ストリームシーケンス番号 - この値は、メッセージに関連付けられていたストリームシーケンス番号を示して返されます。"
    },
    {
      "indent": 3,
      "text": "o partial flag - if this returned flag is set to 1, then this message is a partial delivery of the whole message. When this flag is set, the stream id and stream sequence number MUST accompany this receive. When this flag is set to 0, it indicates that no more deliveries will be received for this stream sequence number.",
      "ja": "o 部分フラグ - この返されたフラグが1に設定されている場合、このメッセージはメッセージ全体の部分的な配信です。このフラグが設定されている場合、ストリームIDとストリームシーケンス番号にこの受信に付随する必要があります。このフラグが0に設定されている場合、このストリームシーケンス番号に対してこれ以上配信が受信されないことを示します。"
    },
    {
      "indent": 3,
      "text": "o payload protocol-id - The 32 bit unsigned integer that was sent to be sent to the peer indicating the type of payload protocol of the received data.",
      "ja": "o ペイロードプロトコルID-受信データのペイロードプロトコルのタイプを示すピアに送信されるように送信された32ビットの符号なし整数。"
    },
    {
      "indent": 3,
      "text": "O) Receive unacknowledged message",
      "ja": "o）承認されていないメッセージを受信します"
    },
    {
      "indent": 3,
      "text": "Format: RECEIVE_UNACKED(data retrieval id, buffer address, buffer size, [,stream id] [, stream sequence number] [,partial flag] [,payload protocol-id])",
      "ja": "形式：receive_unacked（データ取得ID、バッファアドレス、バッファサイズ、[、ストリームID] [、ストリームシーケンス番号] [、部分フラグ] [、ペイロードプロトコルID]））"
    },
    {
      "indent": 3,
      "text": "o data retrieval id - The identification passed to the ULP in the failure notification.",
      "ja": "o データ検索ID-障害通知でULPに渡された識別。"
    },
    {
      "indent": 3,
      "text": "o buffer address - the memory location indicated by the ULP to store the received message.",
      "ja": "o バッファアドレス - 受信したメッセージを保存するためにULPが示すメモリの位置。"
    },
    {
      "indent": 3,
      "text": "o buffer size - the maximum size of data to be received, in bytes.",
      "ja": "o バッファサイズ - バイト単位で受信するデータの最大サイズ。"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "o stream id - this is a return value that is set to indicate which stream the data was sent to.",
      "ja": "o ストリームID-これは、データが送信されたストリームを示すように設定されているリターン値です。"
    },
    {
      "indent": 3,
      "text": "o stream sequence number - this value is returned indicating the stream sequence number that was associated with the message.",
      "ja": "o ストリームシーケンス番号 - この値は、メッセージに関連付けられていたストリームシーケンス番号を示して返されます。"
    },
    {
      "indent": 3,
      "text": "o partial flag - if this returned flag is set to 1, then this message is a partial delivery of the whole message. When this flag is set, the stream id and stream sequence number MUST accompany this receive. When this flag is set to 0, it indicates that no more deliveries will be received for this stream sequence number.",
      "ja": "o 部分フラグ - この返されたフラグが1に設定されている場合、このメッセージはメッセージ全体の部分的な配信です。このフラグが設定されている場合、ストリームIDとストリームシーケンス番号にこの受信に付随する必要があります。このフラグが0に設定されている場合、このストリームシーケンス番号に対してこれ以上配信が受信されないことを示します。"
    },
    {
      "indent": 3,
      "text": "o payload protocol-id - The 32 bit unsigned integer that was sent to be sent to the peer indicating the type of payload protocol of the received data.",
      "ja": "o ペイロードプロトコルID-受信データのペイロードプロトコルのタイプを示すピアに送信されるように送信された32ビットの符号なし整数。"
    },
    {
      "indent": 3,
      "text": "P) Destroy SCTP instance",
      "ja": "p）SCTPインスタンスを破壊します"
    },
    {
      "indent": 3,
      "text": "Format: DESTROY(local SCTP instance name)",
      "ja": "形式：Destroy（ローカルSCTPインスタンス名）"
    },
    {
      "indent": 3,
      "text": "o local SCTP instance name - this is the value that was passed to the application in the initialize primitive and it indicates which SCTP instance to be destroyed.",
      "ja": "o ローカルSCTPインスタンス名 - これは、初期化のプリミティブ化のアプリケーションに渡された値であり、どのSCTPインスタンスが破壊されるかを示します。"
    },
    {
      "indent": 0,
      "text": "10.2 SCTP-to-ULP",
      "section_title": true,
      "ja": "10.2 sctp-to-unp"
    },
    {
      "indent": 3,
      "text": "It is assumed that the operating system or application environment provides a means for the SCTP to asynchronously signal the ULP process. When SCTP does signal an ULP process, certain information is passed to the ULP.",
      "ja": "オペレーティングシステムまたはアプリケーション環境は、SCTPがULPプロセスを非同期的に通知する手段を提供すると想定されています。SCTPがULPプロセスを通知すると、特定の情報がULPに渡されます。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: In some cases this may be done through a separate socket or error channel.",
      "ja": "実装注：場合によっては、これは別のソケットまたはエラーチャネルを介して実行される場合があります。"
    },
    {
      "indent": 3,
      "text": "A) DATA ARRIVE notification",
      "ja": "a）データが通知に到着します"
    },
    {
      "indent": 3,
      "text": "SCTP shall invoke this notification on the ULP when a user message is successfully received and ready for retrieval.",
      "ja": "SCTPは、ユーザーメッセージが正常に受信され、検索の準備ができたときにULPに関するこの通知を呼び出すものとします。"
    },
    {
      "indent": 3,
      "text": "The following may be optionally be passed with the notification:",
      "ja": "以下は、通知でオプションで渡される場合があります。"
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association",
      "ja": "o 協会ID- SCTP協会のローカルハンドル"
    },
    {
      "indent": 3,
      "text": "o stream id - to indicate which stream the data is received on.",
      "ja": "o ストリームID-データが受信されるストリームを示すため。"
    },
    {
      "indent": 3,
      "text": "B) SEND FAILURE notification",
      "ja": "b）失敗通知を送信します"
    },
    {
      "indent": 3,
      "text": "If a message can not be delivered SCTP shall invoke this notification on the ULP.",
      "ja": "メッセージを配信できない場合、SCTPはULPに関するこの通知を呼び出すものとします。"
    },
    {
      "indent": 3,
      "text": "The following may be optionally be passed with the notification:",
      "ja": "以下は、通知でオプションで渡される場合があります。"
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association",
      "ja": "o 協会ID- SCTP協会のローカルハンドル"
    },
    {
      "indent": 3,
      "text": "o data retrieval id - an identification used to retrieve unsent and unacknowledged data.",
      "ja": "o データ取得ID-無関心で承認されていないデータを取得するために使用される識別。"
    },
    {
      "indent": 3,
      "text": "o cause code - indicating the reason of the failure, e.g., size too large, message life-time expiration, etc.",
      "ja": "o 原因コード - 障害の理由を示します。たとえば、サイズが大きすぎる、メッセージの寿命の有効期限など。"
    },
    {
      "indent": 3,
      "text": "o context - optional information associated with this message (see D in Section 10.1).",
      "ja": "o コンテキスト - このメッセージに関連付けられたオプションの情報（セクション10.1のDを参照）。"
    },
    {
      "indent": 3,
      "text": "C) NETWORK STATUS CHANGE notification",
      "ja": "c）ネットワークステータスの変更通知"
    },
    {
      "indent": 3,
      "text": "When a destination transport address is marked inactive (e.g., when SCTP detects a failure), or marked active (e.g., when SCTP detects a recovery), SCTP shall invoke this notification on the ULP.",
      "ja": "宛先輸送アドレスが非アクティブにマークされている場合（たとえば、SCTPが障害を検出する場合）、またはマークされたアクティブ（たとえば、SCTPが回復を検出する場合）、SCTPはULPに関するこの通知を呼び出します。"
    },
    {
      "indent": 3,
      "text": "The following shall be passed with the notification:",
      "ja": "以下は通知とともに渡されるものとします。"
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association",
      "ja": "o 協会ID- SCTP協会のローカルハンドル"
    },
    {
      "indent": 3,
      "text": "o destination transport address - This indicates the destination transport address of the peer endpoint affected by the change;",
      "ja": "o 宛先輸送住所 - これは、変更の影響を受けるピアエンドポイントの宛先輸送アドレスを示します。"
    },
    {
      "indent": 3,
      "text": "o new-status - This indicates the new status.",
      "ja": "o New -status-これは、新しいステータスを示します。"
    },
    {
      "indent": 3,
      "text": "D) COMMUNICATION UP notification",
      "ja": "d）通信通知"
    },
    {
      "indent": 3,
      "text": "This notification is used when SCTP becomes ready to send or receive user messages, or when a lost communication to an endpoint is restored.",
      "ja": "この通知は、SCTPがユーザーメッセージを送信または受信する準備ができたとき、またはエンドポイントへの通信の紛失が復元されたときに使用されます。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: If ASSOCIATE primitive is implemented as a blocking function call, the association parameters are returned as a result of the ASSOCIATE primitive itself. In that case, COMMUNICATION UP notification is optional at the association initiator's side.",
      "ja": "実装注：アソシエイトプリミティブがブロッキング関数呼び出しとして実装されている場合、アソシエイトプリミティブ自体の結果としてアソシエーションパラメーターが返されます。その場合、Association Initiatorの側では、通信通知がオプションです。"
    },
    {
      "indent": 3,
      "text": "The following shall be passed with the notification:",
      "ja": "以下は通知とともに渡されるものとします。"
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association",
      "ja": "o 協会ID- SCTP協会のローカルハンドル"
    },
    {
      "indent": 3,
      "text": "o status - This indicates what type of event has occurred",
      "ja": "o ステータス - これは、どのタイプのイベントが発生したかを示します"
    },
    {
      "indent": 3,
      "text": "o destination transport address list - the complete set of transport addresses of the peer",
      "ja": "o 宛先輸送アドレスリスト - ピアの輸送アドレスの完全なセット"
    },
    {
      "indent": 3,
      "text": "o outbound stream count - the maximum number of streams allowed to be used in this association by the ULP",
      "ja": "o アウトバウンドストリームカウント -  ULPがこの関連付けで使用できるストリームの最大数"
    },
    {
      "indent": 3,
      "text": "o inbound stream count - the number of streams the peer endpoint has requested with this association (this may not be the same number as 'outbound stream count').",
      "ja": "o インバウンドストリームカウント - ピアエンドポイントがこの関連付けで要求したストリームの数（これは「アウトバウンドストリームカウント」と同じではない場合があります）。"
    },
    {
      "indent": 3,
      "text": "E) COMMUNICATION LOST notification",
      "ja": "e）通信が通知を失った"
    },
    {
      "indent": 3,
      "text": "When SCTP loses communication to an endpoint completely (e.g., via Heartbeats) or detects that the endpoint has performed an abort operation, it shall invoke this notification on the ULP.",
      "ja": "SCTPがエンドポイントへの通信を完全に（ハートビート経由で）完全に失った場合、またはエンドポイントが中止操作を実行したことを検出すると、ULPに関するこの通知を呼び出すものとします。"
    },
    {
      "indent": 3,
      "text": "The following shall be passed with the notification:",
      "ja": "以下は通知とともに渡されるものとします。"
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association",
      "ja": "o 協会ID- SCTP協会のローカルハンドル"
    },
    {
      "indent": 3,
      "text": "o status - This indicates what type of event has occurred; The status may indicate a failure OR a normal termination event occurred in response to a shutdown or abort request.",
      "ja": "o ステータス - これは、どのタイプのイベントが発生したかを示します。ステータスは、シャットダウンまたは中止リクエストに応じて発生した障害または通常の終了イベントを示している場合があります。"
    },
    {
      "indent": 3,
      "text": "The following may be passed with the notification:",
      "ja": "通知とともに以下に渡すことができます。"
    },
    {
      "indent": 3,
      "text": "o data retrieval id - an identification used to retrieve unsent and unacknowledged data.",
      "ja": "o データ取得ID-無関心で承認されていないデータを取得するために使用される識別。"
    },
    {
      "indent": 3,
      "text": "o last-acked - the TSN last acked by that peer endpoint;",
      "ja": "o 最後にックされた-TSNは、そのピアエンドポイントによって最後にアクセスされました。"
    },
    {
      "indent": 3,
      "text": "o last-sent - the TSN last sent to that peer endpoint;",
      "ja": "o 最終セント-TSNは最後にそのピアエンドポイントに送信されました。"
    },
    {
      "indent": 3,
      "text": "F) COMMUNICATION ERROR notification",
      "ja": "f）通信エラー通知"
    },
    {
      "indent": 3,
      "text": "When SCTP receives an ERROR chunk from its peer and decides to notify its ULP, it can invoke this notification on the ULP.",
      "ja": "SCTPがピアからエラーチャンクを受け取り、ULPに通知することを決定した場合、ULPに関するこの通知を呼び出すことができます。"
    },
    {
      "indent": 3,
      "text": "The following can be passed with the notification:",
      "ja": "通知で以下を渡すことができます。"
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association",
      "ja": "o 協会ID- SCTP協会のローカルハンドル"
    },
    {
      "indent": 3,
      "text": "o error info - this indicates the type of error and optionally some additional information received through the ERROR chunk.",
      "ja": "o エラー情報 - これは、エラーのタイプと、オプションでエラーチャンクから受信した追加情報を示します。"
    },
    {
      "indent": 3,
      "text": "G) RESTART notification",
      "ja": "g）通知を再起動します"
    },
    {
      "indent": 3,
      "text": "When SCTP detects that the peer has restarted, it may send this notification to its ULP.",
      "ja": "SCTPがピアが再起動したことを検出すると、この通知をULPに送信する場合があります。"
    },
    {
      "indent": 3,
      "text": "The following can be passed with the notification:",
      "ja": "通知で以下を渡すことができます。"
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association",
      "ja": "o 協会ID- SCTP協会のローカルハンドル"
    },
    {
      "indent": 3,
      "text": "H) SHUTDOWN COMPLETE notification",
      "ja": "h）完全な通知をシャットダウンします"
    },
    {
      "indent": 3,
      "text": "When SCTP completes the shutdown procedures (section 9.2) this notification is passed to the upper layer.",
      "ja": "SCTPがシャットダウン手順を完了すると（セクション9.2）、この通知は上層に渡されます。"
    },
    {
      "indent": 3,
      "text": "The following can be passed with the notification:",
      "ja": "通知で以下を渡すことができます。"
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association",
      "ja": "o 協会ID- SCTP協会のローカルハンドル"
    },
    {
      "indent": 0,
      "text": "11. Security Considerations",
      "section_title": true,
      "ja": "11. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "11.1 Security Objectives",
      "section_title": true,
      "ja": "11.1 セキュリティ目標"
    },
    {
      "indent": 3,
      "text": "As a common transport protocol designed to reliably carry time-sensitive user messages, such as billing or signaling messages for telephony services, between two networked endpoints, SCTP has the following security objectives.",
      "ja": "2つのネットワーク化されたエンドポイント間のテレフォニーサービスの請求や信号メッセージなど、時間に敏感なユーザーメッセージを確実に伝達するように設計された一般的なトランスポートプロトコルとして、SCTPには次のセキュリティ目標があります。"
    },
    {
      "indent": 3,
      "text": "- availability of reliable and timely data transport services - integrity of the user-to-user information carried by SCTP",
      "ja": "- 信頼できるタイムリーなデータ輸送サービスの可用性 -  SCTPが運ぶユーザーからユーザーへの情報の整合性"
    },
    {
      "indent": 0,
      "text": "11.2 SCTP Responses To Potential Threats",
      "section_title": true,
      "ja": "11.2 潜在的な脅威に対するSCTP応答"
    },
    {
      "indent": 3,
      "text": "SCTP may potentially be used in a wide variety of risk situations. It is important for operator(s) of systems running SCTP to analyze their particular situations and decide on the appropriate counter-measures.",
      "ja": "SCTPは、さまざまなリスク状況で使用される可能性があります。SCTPを実行しているシステムのオペレーターが特定の状況を分析し、適切な対策を決定することが重要です。"
    },
    {
      "indent": 3,
      "text": "Operators of systems running SCTP should consult [RFC2196] for guidance in securing their site.",
      "ja": "SCTPを実行しているシステムのオペレーターは、サイトを確保するためのガイダンスについて[RFC2196]を参照する必要があります。"
    },
    {
      "indent": 0,
      "text": "11.2.1 Countering Insider Attacks",
      "section_title": true,
      "ja": "11.2.1 インサイダー攻撃に対抗します"
    },
    {
      "indent": 3,
      "text": "The principles of [RFC2196] should be applied to minimize the risk of theft of information or sabotage by insiders. Such procedures include publication of security policies, control of access at the physical, software, and network levels, and separation of services.",
      "ja": "[RFC2196]の原則を適用して、インサイダーによる情報または妨害行為のリスクを最小限に抑える必要があります。このような手順には、セキュリティポリシーの公開、物理、ソフトウェア、ネットワークレベルでのアクセスの制御、およびサービスの分離が含まれます。"
    },
    {
      "indent": 0,
      "text": "11.2.2 Protecting against Data Corruption in the Network",
      "section_title": true,
      "ja": "11.2.2 ネットワーク内のデータ腐敗から保護します"
    },
    {
      "indent": 3,
      "text": "Where the risk of undetected errors in datagrams delivered by the lower layer transport services is considered to be too great, additional integrity protection is required. If this additional protection were provided in the application-layer, the SCTP header would remain vulnerable to deliberate integrity attacks. While the existing SCTP mechanisms for detection of packet replays are considered sufficient for normal operation, stronger protections are needed to protect SCTP when the operating environment contains significant risk of deliberate attacks from a sophisticated adversary.",
      "ja": "下層輸送サービスによって配信されたデータグラムの検出されないエラーのリスクが大きすぎると考えられている場合、追加の完全性保護が必要です。この追加の保護がアプリケーション層に提供された場合、SCTPヘッダーは意図的な整合性攻撃に対して脆弱なままになります。パケットリプレイを検出するための既存のSCTPメカニズムは通常の操作に十分であると考えられていますが、操作環境に洗練された敵からの意図的な攻撃の重大なリスクが含まれている場合、SCTPを保護するために強力な保護が必要です。"
    },
    {
      "indent": 3,
      "text": "In order to promote software code-reuse, to avoid re-inventing the wheel, and to avoid gratuitous complexity to SCTP, the IP Authentication Header [RFC2402] SHOULD be used when the threat environment requires stronger integrity protections, but does not require confidentiality.",
      "ja": "ソフトウェアコードリューズを促進し、ホイールの再発明を避け、SCTPに対する無償の複雑さを回避するために、脅威環境がより強力な整合性保護を必要とするが、機密保護を必要としない場合、IP認証ヘッダー[RFC2402]を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "A widely implemented BSD Sockets API extension exists for applications to request IP security services, such as AH or ESP from an operating system kernel. Applications can use such an API to request AH whenever AH use is appropriate.",
      "ja": "広く実装されているBSDソケットAPI拡張機能は、アプリケーション用に存在し、オペレーティングシステムカーネルからAHやESPなどのIPセキュリティサービスを要求します。アプリケーションは、このようなAPIを使用して、AHの使用が適切な場合はいつでもAHを要求できます。"
    },
    {
      "indent": 0,
      "text": "11.2.3 Protecting Confidentiality",
      "section_title": true,
      "ja": "11.2.3 機密性の保護"
    },
    {
      "indent": 3,
      "text": "In most cases, the risk of breach of confidentiality applies to the signaling data payload, not to the SCTP or lower-layer protocol overheads. If that is true, encryption of the SCTP user data only might be considered. As with the supplementary checksum service, user data encryption MAY be performed by the SCTP user application.",
      "ja": "ほとんどの場合、機密性の違反のリスクは、SCTPまたは低層プロトコルのオーバーヘッドではなく、信号データペイロードに適用されます。それが本当なら、SCTPユーザーデータの暗号化は考慮される場合があります。補足チェックサムサービスと同様に、SCTPユーザーアプリケーションによってユーザーデータ暗号化が実行される場合があります。"
    },
    {
      "indent": 3,
      "text": "Alternately, the user application MAY use an implementation-specific API to request that the IP Encapsulating Security Payload (ESP) [RFC2406] be used to provide confidentiality and integrity.",
      "ja": "あるいは、ユーザーアプリケーションは実装固有のAPIを使用して、IPカプセル化セキュリティペイロード（ESP）[RFC2406]を使用して機密性と整合性を提供することを要求する場合があります。"
    },
    {
      "indent": 3,
      "text": "Particularly for mobile users, the requirement for confidentiality might include the masking of IP addresses and ports. In this case ESP SHOULD be used instead of application-level confidentiality. If ESP is used to protect confidentiality of SCTP traffic, an ESP cryptographic transform that includes cryptographic integrity protection MUST be used, because if there is a confidentiality threat there will also be a strong integrity threat.",
      "ja": "特にモバイルユーザーにとって、機密性の要件には、IPアドレスとポートのマスキングが含まれる場合があります。この場合、アプリケーションレベルの機密性の代わりにESPを使用する必要があります。SCTPトラフィックの機密性を保護するためにESPを使用する場合、暗号化の脅威がある場合は強力な整合性の脅威があるため、暗号化の整合性保護を含むESP暗号化変換を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Whenever ESP is in use, application-level encryption is not generally required.",
      "ja": "ESPが使用されている場合はいつでも、アプリケーションレベルの暗号化は一般に必要ありません。"
    },
    {
      "indent": 3,
      "text": "Regardless of where confidentiality is provided, the ISAKMP [RFC2408] and the Internet Key Exchange (IKE) [RFC2409] SHOULD be used for key management.",
      "ja": "機密性が提供される場所に関係なく、ISAKMP [RFC2408]とインターネットキーエクスチェンジ（IKE）[RFC2409]をキー管理に使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Operators should consult [RFC2401] for more information on the security services available at and immediately above the Internet Protocol layer.",
      "ja": "オペレーターは、インターネットプロトコルレイヤーのすぐ上で利用可能なセキュリティサービスの詳細については、[RFC2401]を参照する必要があります。"
    },
    {
      "indent": 0,
      "text": "11.2.4 Protecting against Blind Denial of Service Attacks",
      "section_title": true,
      "ja": "11.2.4 盲目的なサービス拒否攻撃から保護する"
    },
    {
      "indent": 3,
      "text": "A blind attack is one where the attacker is unable to intercept or otherwise see the content of data flows passing to and from the target SCTP node. Blind denial of service attacks may take the form of flooding, masquerade, or improper monopolization of services.",
      "ja": "ブラインド攻撃とは、攻撃者がターゲットSCTPノードとの間を通過するデータフローのコンテンツを傍受または確認できない場合です。盲目的なサービス拒否攻撃は、サービスの洪水、仮面舞踏会、または不適切な独占の形をとることがあります。"
    },
    {
      "indent": 0,
      "text": "11.2.4.1 Flooding",
      "section_title": true,
      "ja": "11.2.4.1 洪水"
    },
    {
      "indent": 3,
      "text": "The objective of flooding is to cause loss of service and incorrect behavior at target systems through resource exhaustion, interference with legitimate transactions, and exploitation of buffer-related software bugs. Flooding may be directed either at the SCTP node or at resources in the intervening IP Access Links or the Internet. Where the latter entities are the target, flooding will manifest itself as loss of network services, including potentially the breach of any firewalls in place.",
      "ja": "洪水の目的は、リソースの疲労、合法的なトランザクションへの干渉、およびバッファ関連ソフトウェアのバグの活用を通じて、ターゲットシステムでサービスの損失と誤った動作を引き起こすことです。洪水は、SCTPノードまたは介在するIPアクセスリンクまたはインターネットのリソースのいずれかに向けられます。後者のエンティティがターゲットである場合、洪水は、潜在的にファイアウォールの違反を含むネットワークサービスの損失として現れます。"
    },
    {
      "indent": 3,
      "text": "In general, protection against flooding begins at the equipment design level, where it includes measures such as:",
      "ja": "一般に、洪水に対する保護は、次のような手段が含まれます。"
    },
    {
      "indent": 3,
      "text": "- avoiding commitment of limited resources before determining that the request for service is legitimate",
      "ja": "- サービスの要求が合法であると判断する前に、限られたリソースのコミットメントを回避する"
    },
    {
      "indent": 3,
      "text": "- giving priority to completion of processing in progress over the acceptance of new work",
      "ja": "- 新しい仕事の受け入れを介して進行中の処理の完了を優先する"
    },
    {
      "indent": 3,
      "text": "- identification and removal of duplicate or stale queued requests for service.",
      "ja": "- 重複または古いキューのあるサービスのリクエストの識別と削除。"
    },
    {
      "indent": 3,
      "text": "- not responding to unexpected packets sent to non-unicast addresses.",
      "ja": "- 非ユニカストアドレスに送信された予期しないパケットに応答しません。"
    },
    {
      "indent": 3,
      "text": "Network equipment should be capable of generating an alarm and log if a suspicious increase in traffic occurs. The log should provide information such as the identity of the incoming link and source address(es) used which will help the network or SCTP system operator to take protective measures. Procedures should be in place for the operator to act on such alarms if a clear pattern of abuse emerges.",
      "ja": "ネットワーク機器は、トラフィックの不審な増加が発生した場合、アラームとログを生成できる必要があります。ログは、ネットワークまたはSCTPシステムオペレーターが保護対策を講じるのに役立つ、使用される着信リンクとソースアドレスのIDなどの情報を提供する必要があります。乱用の明確なパターンが出現した場合、オペレーターがそのようなアラームに作用する手順を整える必要があります。"
    },
    {
      "indent": 3,
      "text": "The design of SCTP is resistant to flooding attacks, particularly in its use of a four-way start-up handshake, its use of a cookie to defer commitment of resources at the responding SCTP node until the handshake is completed, and its use of a Verification Tag to prevent insertion of extraneous packets into the flow of an established association.",
      "ja": "SCTPの設計は、特に四方の起動握手の使用、握手が完了するまで応答するSCTPノードでのリソースのコミットメントを延期するためのCookieの使用、およびその使用の使用、およびその使用において、洪水攻撃に耐性があります。確立された関連付けの流れへの外部パケットの挿入を防ぐための検証タグ。"
    },
    {
      "indent": 3,
      "text": "The IP Authentication Header and Encapsulating Security Payload might be useful in reducing the risk of certain kinds of denial of service attacks.\"",
      "ja": "IP認証ヘッダーとセキュリティペイロードのカプセル化は、特定の種類のサービス攻撃のリスクを減らすのに役立つ可能性があります。」"
    },
    {
      "indent": 3,
      "text": "The use of the Host Name feature in the INIT chunk could be used to flood a target DNS server. A large backlog of DNS queries, resolving the Host Name received in the INIT chunk to IP addresses, could be accomplished by sending INIT's to multiple hosts in a given domain. In addition, an attacker could use the Host Name feature in an indirect attack on a third party by sending large numbers of INITs to random hosts containing the host name of the target. In addition to the strain on DNS resources, this could also result in large numbers of INIT ACKs being sent to the target. One method to protect against this type of attack is to verify that the IP addresses received from DNS include the source IP address of the original INIT. If the list of IP addresses received from DNS does not include the source IP address of the INIT, the endpoint MAY silently discard the INIT. This last option will not protect against the attack against the DNS.",
      "ja": "init chunkでのホスト名機能の使用は、ターゲットDNSサーバーに浸水するために使用できます。DNSクエリの大きなバックログは、INIT塊からIPアドレスで受信されたホスト名を解決することで、特定のドメインの複数のホストにinitを送信することで実現できます。さらに、攻撃者は、ターゲットのホスト名を含むランダムなホストに多数のINITを送信することにより、サードパーティの間接攻撃でホスト名機能を使用できます。DNSリソースのひずみに加えて、これにより、ターゲットに多数のinit Ackが送信される可能性があります。このタイプの攻撃から保護する1つの方法は、DNSから受信したIPアドレスに元のinitのソースIPアドレスが含まれていることを確認することです。DNSから受信したIPアドレスのリストにinitのソースIPアドレスが含まれていない場合、エンドポイントはINITを静かに破棄する場合があります。この最後のオプションは、DNSに対する攻撃から保護しません。"
    },
    {
      "indent": 0,
      "text": "11.2.4.2 Blind Masquerade",
      "section_title": true,
      "ja": "11.2.4.2 ブラインドマスカレード"
    },
    {
      "indent": 3,
      "text": "Masquerade can be used to deny service in several ways:",
      "ja": "マスカレードは、いくつかの方法でサービスを拒否するために使用できます。"
    },
    {
      "indent": 3,
      "text": "- by tying up resources at the target SCTP node to which the impersonated node has limited access. For example, the target node may by policy permit a maximum of one SCTP association with the impersonated SCTP node. The masquerading attacker may attempt to establish an association purporting to come from the impersonated node so that the latter cannot do so when it requires it.",
      "ja": "- ターゲットSCTPノードでリソースを結び付けることにより、成績のついたノードにアクセスが制限されています。たとえば、ターゲットノードは、ポリシーにより、偽装されたSCTPノードとの最大1つのSCTP関連を許可する場合があります。仮面舞台の攻撃者は、成功したノードから来ると主張する協会を確立しようとするかもしれないので、後者はそれを必要とするときにそうすることができません。"
    },
    {
      "indent": 3,
      "text": "- by deliberately allowing the impersonation to be detected, thereby provoking counter-measures which cause the impersonated node to be locked out of the target SCTP node.",
      "ja": "- 意図的になりすましを検出できるようにすることにより、ターゲットSCTPノードからなりすましたノードをロックアウトする対抗測定を引き起こします。"
    },
    {
      "indent": 3,
      "text": "- by interfering with an established association by inserting extraneous content such as a SHUTDOWN request.",
      "ja": "- シャットダウンリクエストなどの無関係なコンテンツを挿入することにより、確立された関連性を妨害することにより。"
    },
    {
      "indent": 3,
      "text": "SCTP reduces the risk of blind masquerade attacks through IP spoofing by use of the four-way startup handshake. Man-in-the-middle masquerade attacks are discussed in Section 11.3 below. Because the initial exchange is memoryless, no lockout mechanism is triggered by blind masquerade attacks. In addition, the INIT ACK containing the State Cookie is transmitted back to the IP address from which it received the INIT. Thus the attacker would not receive the INIT ACK containing the State Cookie. SCTP protects against insertion of extraneous packets into the flow of an established association by use of the Verification Tag.",
      "ja": "SCTPは、4方向のスタートアップハンドシェイクを使用して、IPスプーフィングを通じて盲目的な仮面舞踏会攻撃のリスクを減らします。中間の仮面舞踏会攻撃については、以下のセクション11.3で説明します。最初の交換はメモリレスであるため、ブラインドマスカレード攻撃によってロックアウトメカニズムがトリガーされません。さらに、状態Cookieを含むINIT ACKは、INITを受け取ったIPアドレスに送信されます。したがって、攻撃者は状態Cookieを含むinit ackを受け取りません。SCTPは、検証タグを使用することにより、確立された関連付けの流れへの外部パケットの挿入から保護します。"
    },
    {
      "indent": 3,
      "text": "Logging of received INIT requests and abnormalities such as unexpected INIT ACKs might be considered as a way to detect patterns of hostile activity. However, the potential usefulness of such logging must be weighed against the increased SCTP startup processing it implies, rendering the SCTP node more vulnerable to flooding attacks. Logging is pointless without the establishment of operating procedures to review and analyze the logs on a routine basis.",
      "ja": "受信したINITリクエストの伐採と、予期しないINIT ACKなどの異常は、敵対的な活動のパターンを検出する方法と見なされる場合があります。ただし、このようなロギングの潜在的な有用性は、SCTPスタートアップ処理の増加と比較検討する必要があり、SCTPノードの洪水攻撃に対してより脆弱になります。ロギングは、ルーチンベースでログをレビューおよび分析するための操作手順を確立することなく無意味です。"
    },
    {
      "indent": 0,
      "text": "11.2.4.3 Improper Monopolization of Services",
      "section_title": true,
      "ja": "11.2.4.3 サービスの不適切な独占"
    },
    {
      "indent": 3,
      "text": "Attacks under this heading are performed openly and legitimately by the attacker. They are directed against fellow users of the target SCTP node or of the shared resources between the attacker and the target node. Possible attacks include the opening of a large number of associations between the attacker's node and the target, or transfer of large volumes of information within a legitimately-established association.",
      "ja": "この見出しの下での攻撃は、攻撃者によって公然と合法的に行われます。ターゲットSCTPノードまたは攻撃者とターゲットノードの間の共有リソースの仲間のユーザーに向けられています。考えられる攻撃には、攻撃者のノードとターゲットの間に多数の関連性が開かれ、合法的に確立された関連付けの中で大量の情報を転送することが含まれます。"
    },
    {
      "indent": 3,
      "text": "Policy limits should be placed on the number of associations per adjoining SCTP node. SCTP user applications should be capable of detecting large volumes of illegitimate or \"no-op\" messages within a given association and either logging or terminating the association as a result, based on local policy.",
      "ja": "隣接するSCTPノードあたりの関連付けの数には、ポリシー制限を掲載する必要があります。SCTPユーザーアプリケーションは、特定の協会内で大量の違法または「ノーオップ」メッセージを検出し、現地ポリシーに基づいて結果として協会を記録または終了することができる必要があります。"
    },
    {
      "indent": 0,
      "text": "11.3 Protection against Fraud and Repudiation",
      "section_title": true,
      "ja": "11.3 詐欺と拒否に対する保護"
    },
    {
      "indent": 3,
      "text": "The objective of fraud is to obtain services without authorization and specifically without paying for them. In order to achieve this objective, the attacker must induce the SCTP user application at the target SCTP node to provide the desired service while accepting invalid billing data or failing to collect it. Repudiation is a related problem, since it may occur as a deliberate act of fraud or simply because the repudiating party kept inadequate records of service received.",
      "ja": "詐欺の目的は、承認なしに、特にそれらにお金を払うことなくサービスを取得することです。この目的を達成するために、攻撃者は、ターゲットSCTPノードでSCTPユーザーアプリケーションを誘導して、無効な請求データを受け入れたり、収集しなかったりしながら、目的のサービスを提供する必要があります。拒否は、詐欺の意図的な行為として発生する可能性があるため、または単に拒否当事者が受け取ったサービスの不十分な記録を維持していたために発生する可能性があるため、関連する問題です。"
    },
    {
      "indent": 3,
      "text": "Potential fraudulent attacks include interception and misuse of authorizing information such as credit card numbers, blind masquerade and replay, and man-in-the middle attacks which modify the packets passing through a target SCTP association in real time.",
      "ja": "潜在的な詐欺攻撃には、クレジットカード番号、ブラインドマスカレードやリプレイなどの情報の承認の傍受と誤用、およびターゲットSCTP協会をリアルタイムで通過するパケットを変更する中間攻撃が含まれます。"
    },
    {
      "indent": 3,
      "text": "The interception attack is countered by the confidentiality measures discussed in Section 11.2.3 above.",
      "ja": "傍受攻撃は、上記のセクション11.2.3で説明されている機密保持措置によって反論されます。"
    },
    {
      "indent": 3,
      "text": "Section 11.2.4.2 describes how SCTP is resistant to blind masquerade attacks, as a result of the four-way startup handshake and the Verification Tag. The Verification Tag and TSN together are protections against blind replay attacks, where the replay is into an existing association.",
      "ja": "セクション11.2.4.2では、四方のスタートアップハンドシェイクと検証タグの結果として、SCTPが盲検マスカレード攻撃に対してどのように耐性があるかについて説明します。検証タグとTSNは一緒になって、リプレイが既存の関連付けに属するブラインドリプレイ攻撃に対する保護です。"
    },
    {
      "indent": 3,
      "text": "However, SCTP does not protect against man-in-the-middle attacks where the attacker is able to intercept and alter the packets sent and received in an association. For example, the INIT ACK will have sufficient information sent on the wire for an adversary in the middle to hijack an existing SCTP association. Where a significant possibility of such attacks is seen to exist, or where possible repudiation is an issue, the use of the IPSEC AH service is recommended to ensure both the integrity and the authenticity of the SCTP packets passed.",
      "ja": "ただし、SCTPは、攻撃者が協会で送信および受信したパケットを傍受して変更できる場合、中間の攻撃から保護しません。たとえば、init ACKには、既存のSCTP協会をハイジャックするために、真ん中の敵のためにワイヤーに十分な情報が送られます。そのような攻撃の重要な可能性が存在すると見られている場合、または可能な場合は否認が問題である場合、IPSEC AHサービスの使用が推奨され、SCTPパケットの整合性と信頼性の両方が合格します。"
    },
    {
      "indent": 3,
      "text": "SCTP also provides no protection against attacks originating at or beyond the SCTP node and taking place within the context of an existing association. Prevention of such attacks should be covered by appropriate security policies at the host site, as discussed in Section 11.2.1.",
      "ja": "また、SCTPは、SCTPノードまたはそれ以降の攻撃に対する保護を提供しません。既存の関連付けのコンテキスト内で行われます。このような攻撃の防止は、セクション11.2.1で説明したように、ホストサイトでの適切なセキュリティポリシーでカバーする必要があります。"
    },
    {
      "indent": 0,
      "text": "12. Recommended Transmission Control Block (TCB) Parameters",
      "section_title": true,
      "ja": "12. 推奨される伝送制御ブロック（TCB）パラメーター"
    },
    {
      "indent": 3,
      "text": "This section details a recommended set of parameters that should be contained within the TCB for an implementation. This section is for illustrative purposes and should not be deemed as requirements on an implementation or as an exhaustive list of all parameters inside an SCTP TCB. Each implementation may need its own additional parameters for optimization.",
      "ja": "このセクションでは、実装のためにTCB内に含める必要がある推奨されるパラメーターのセットを詳しく説明します。このセクションは、説明のためのものであり、実装に関する要件、またはSCTP TCB内のすべてのパラメーターの徹底的なリストとして見なされるべきではありません。各実装には、最適化のために独自の追加パラメーターが必要になる場合があります。"
    },
    {
      "indent": 0,
      "text": "12.1 Parameters necessary for the SCTP instance",
      "section_title": true,
      "ja": "12.1 SCTPインスタンスに必要なパラメーター"
    },
    {
      "indent": 3,
      "text": "Associations: A list of current associations and mappings to the data consumers for each association. This may be in the form of a hash table or other implementation dependent structure. The data consumers may be process identification information such as file descriptors, named pipe pointer, or table pointers dependent on how SCTP is implemented.",
      "ja": "協会：各協会のデータ消費者への現在の関連付けとマッピングのリスト。これは、ハッシュテーブルまたはその他の実装依存構造の形である場合があります。データ消費者は、SCTPの実装方法に依存するファイル記述子、パイプポインターという名前のプロセス識別情報、またはテーブルポインターです。"
    },
    {
      "indent": 3,
      "text": "Secret Key: A secret key used by this endpoint to compute the MAC. This SHOULD be a cryptographic quality random number with a sufficient length. Discussion in [RFC1750] can be helpful in selection of the key.",
      "ja": "シークレットキー：Macを計算するためにこのエンドポイントで使用されるシークレットキー。これは、十分な長さの暗号化品質の乱数である必要があります。[RFC1750]での議論は、キーの選択に役立ちます。"
    },
    {
      "indent": 3,
      "text": "Address List: The list of IP addresses that this instance has bound. This information is passed to one's peer(s) in INIT and INIT ACK chunks.",
      "ja": "アドレスリスト：このインスタンスがバインドしているIPアドレスのリスト。この情報は、initとinit ackチャンクでピアに渡されます。"
    },
    {
      "indent": 3,
      "text": "SCTP Port: The local SCTP port number the endpoint is bound to.",
      "ja": "SCTPポート：ローカルSCTPポート番号エンドポイントはバインドされています。"
    },
    {
      "indent": 0,
      "text": "12.2 Parameters necessary per association (i.e. the TCB)",
      "section_title": true,
      "ja": "12.2 アソシエーションごとに必要なパラメーター（つまり、TCB）"
    },
    {
      "indent": 3,
      "text": "Peer : Tag value to be sent in every packet and is received Verification: in the INIT or INIT ACK chunk. Tag :",
      "ja": "ピア：すべてのパケットで送信されるタグ値と受信された確認：initまたはinit ackチャンクで。鬼ごっこ ："
    },
    {
      "indent": 3,
      "text": "My : Tag expected in every inbound packet and sent in the Verification: INIT or INIT ACK chunk. Tag :",
      "ja": "my：すべてのインバウンドパケットで期待され、検証で送信されるタグ：initまたはinit ackチャンク。鬼ごっこ ："
    },
    {
      "indent": 3,
      "text": "State       : A state variable indicating what state the association\n            : is in, i.e. COOKIE-WAIT, COOKIE-ECHOED, ESTABLISHED,\n            : SHUTDOWN-PENDING, SHUTDOWN-SENT, SHUTDOWN-RECEIVED,\n            : SHUTDOWN-ACK-SENT.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Note: No \"CLOSED\" state is illustrated since if a association is \"CLOSED\" its TCB SHOULD be removed.",
      "ja": "注：Associationが「閉じられている」場合、TCBを削除する必要があるため、「閉じた」状態は示されていません。"
    },
    {
      "indent": 3,
      "text": "Peer : A list of SCTP transport addresses that the peer is Transport : bound to. This information is derived from the INIT or Address : INIT ACK and is used to associate an inbound packet List : with a given association. Normally this information is : hashed or keyed for quick lookup and access of the TCB.",
      "ja": "ピア：SCTP輸送のリストは、ピアが輸送していることをアドレスしています。この情報は、initまたは住所から導き出されます。INITACKは、インバウンドパケットリストを関連付けるために使用されます。通常、この情報は次のとおりです。TCBの迅速な検索とアクセスのためにハッシュまたはキー付き。"
    },
    {
      "indent": 3,
      "text": "Primary : This is the current primary destination transport Path : address of the peer endpoint. It may also specify a : source transport address on this endpoint.",
      "ja": "プライマリ：これは、現在のプライマリ宛先輸送パス：ピアエンドポイントのアドレスです。また、このエンドポイントでA：ソーストランスポートアドレスを指定することもできます。"
    },
    {
      "indent": 3,
      "text": "Overall : The overall association error count. Error Count :",
      "ja": "全体：全体的な関連性エラーカウント。エラー数："
    },
    {
      "indent": 3,
      "text": "Overall : The threshold for this association that if the Overall Error : Error Count reaches will cause this association to be Threshold : torn down.",
      "ja": "全体：この関連付けのしきい値は、全体的なエラー：エラーカウントに到達すると、この関連付けがしきい値になります：取り壊します。"
    },
    {
      "indent": 3,
      "text": "Peer Rwnd : Current calculated value of the peer's rwnd.",
      "ja": "ピアRWND：ピアのRWNDの現在の計算値。"
    },
    {
      "indent": 3,
      "text": "Next TSN    : The next TSN number to be assigned to a new DATA chunk.\n            : This is sent in the INIT or INIT ACK chunk to the peer\n            : and incremented each time a DATA chunk is assigned a\n            : TSN (normally just prior to transmit or during\n            : fragmentation).",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Last Rcvd : This is the last TSN received in sequence. This value TSN : is set initially by taking the peer's Initial TSN, : received in the INIT or INIT ACK chunk, and : subtracting one from it.",
      "ja": "最後のRCVD：これは、順番に受け取った最後のTSNです。この値TSN：は、最初にピアの最初のTSNを取得することによって設定され、initまたはinit ackチャンクで受信し、それを差し引くことによって設定されます。"
    },
    {
      "indent": 3,
      "text": "Mapping     : An array of bits or bytes indicating which out of\nArray       : order TSN's have been received (relative to the\n            : Last Rcvd TSN).  If no gaps exist, i.e. no out of order\n            : packets have been received, this array will be set to\n            : all zero.  This structure may be in the form of a\n            : circular buffer or bit array.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Ack State   : This flag indicates if the next received packet\n            : is to be responded to with a SACK.  This is initialized\n            : to 0.  When a packet is received it is incremented.\n            : If this value reaches 2 or more, a SACK is sent and the\n            : value is reset to 0.  Note: This is used only when no\n            : DATA chunks are received out of order.  When DATA chunks\n            : are out of order, SACK's are not delayed (see Section\n            : 6).",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Inbound : An array of structures to track the inbound streams. Streams : Normally including the next sequence number expected : and possibly the stream number.",
      "ja": "インバウンド：インバウンドストリームを追跡するための一連の構造。ストリーム：通常、予想される次のシーケンス番号を含めます：および場合によってはストリーム番号。"
    },
    {
      "indent": 3,
      "text": "Outbound : An array of structures to track the outbound streams. Streams : Normally including the next sequence number to : be sent on the stream.",
      "ja": "アウトバウンド：アウトバウンドストリームを追跡するための一連の構造。ストリーム：通常、次のシーケンス番号を含む：ストリームで送信されます。"
    },
    {
      "indent": 3,
      "text": "Reasm Queue : A re-assembly queue.",
      "ja": "reasm queue：再組み立てキュー。"
    },
    {
      "indent": 3,
      "text": "Local : The list of local IP addresses bound in to this Transport : association. Address : List :",
      "ja": "ローカル：このトランスポートに縛られたローカルIPアドレスのリスト：関連付け。住所：リスト："
    },
    {
      "indent": 3,
      "text": "Association : The smallest PMTU discovered for all of the PMTU : peer's transport addresses.",
      "ja": "協会：すべてのPMTU：ピアの輸送アドレスについて発見された最小のPMTU。"
    },
    {
      "indent": 0,
      "text": "12.3 Per Transport Address Data",
      "section_title": true,
      "ja": "12.3 輸送アドレスデータごと"
    },
    {
      "indent": 3,
      "text": "For each destination transport address in the peer's address list derived from the INIT or INIT ACK chunk, a number of data elements needs to be maintained including:",
      "ja": "initまたはinit ackチャンクから派生したピアのアドレスリストの各宛先輸送アドレスについて、以下を含む多くのデータ要素を維持する必要があります。"
    },
    {
      "indent": 3,
      "text": "Error count : The current error count for this destination.",
      "ja": "エラーカウント：この宛先の現在のエラーカウント。"
    },
    {
      "indent": 3,
      "text": "Error : Current error threshold for this destination i.e. Threshold : what value marks the destination down if Error count : reaches this value.",
      "ja": "エラー：この宛先の現在のエラーしきい値、つまりしきい値：エラーカウントの場合、宛先をマークする値：この値に達します。"
    },
    {
      "indent": 3,
      "text": "cwnd : The current congestion window.",
      "ja": "CWND：現在の混雑ウィンドウ。"
    },
    {
      "indent": 3,
      "text": "ssthresh : The current ssthresh value.",
      "ja": "SSTHRESH：現在のSSthresh値。"
    },
    {
      "indent": 3,
      "text": "RTO : The current retransmission timeout value.",
      "ja": "RTO：現在の再送信タイムアウト値。"
    },
    {
      "indent": 3,
      "text": "SRTT : The current smoothed round trip time.",
      "ja": "SRTT：現在の滑らかな往復時間。"
    },
    {
      "indent": 3,
      "text": "RTTVAR : The current RTT variation.",
      "ja": "RTTVAR：現在のRTTバリエーション。"
    },
    {
      "indent": 3,
      "text": "partial : The tracking method for increase of cwnd when in bytes acked : congestion avoidance mode (see Section 6.2.2)",
      "ja": "部分的：バイトがアクセスされたときのCWNDの増加の追跡方法：輻輳回避モード（セクション6.2.2を参照）"
    },
    {
      "indent": 3,
      "text": "state : The current state of this destination, i.e. DOWN, UP, : ALLOW-HB, NO-HEARTBEAT, etc.",
      "ja": "状態：この目的地の現在の状態、つまりダウン、アップ、：Allow-HB、No-HeartBeatなど。"
    },
    {
      "indent": 3,
      "text": "PMTU : The current known path MTU.",
      "ja": "PMTU：現在の既知のパスMTU。"
    },
    {
      "indent": 3,
      "text": "Per : A timer used by each destination. Destination : Timer :",
      "ja": "Per：各宛先が使用するタイマー。宛先：タイマー："
    },
    {
      "indent": 3,
      "text": "RTO-Pending : A flag used to track if one of the DATA chunks sent to this address is currently being used to compute a RTT. If this flag is 0, the next DATA chunk sent to this destination should be used to compute a RTT and this flag should be set. Every time the RTT calculation completes (i.e. the DATA chunk is SACK'd) clear this flag.",
      "ja": "RTOペンディング：このアドレスに送信されたデータチャンクの1つが現在RTTの計算に使用されているかどうかを追跡するために使用されるフラグ。このフラグが0の場合、この宛先に送信される次のデータチャンクを使用してRTTを計算する必要があり、このフラグを設定する必要があります。RTT計算が完了するたびに（つまり、データチャンクが袋に入っています）このフラグをクリアします。"
    },
    {
      "indent": 3,
      "text": "last-time : The time this destination was last sent to. This can be used : used to determine if a HEARTBEAT is needed.",
      "ja": "最後の時間：この目的地が最後に送られた時間。これを使用できます。ハートビートが必要かどうかを判断するために使用できます。"
    },
    {
      "indent": 0,
      "text": "12.4 General Parameters Needed",
      "section_title": true,
      "ja": "12.4 必要な一般的なパラメーター"
    },
    {
      "indent": 3,
      "text": "Out Queue : A queue of outbound DATA chunks.",
      "ja": "アウトキュー：アウトバウンドデータチャンクのキュー。"
    },
    {
      "indent": 3,
      "text": "In Queue : A queue of inbound DATA chunks.",
      "ja": "キューで：インバウンドデータチャンクのキュー。"
    },
    {
      "indent": 0,
      "text": "13. IANA Considerations",
      "section_title": true,
      "ja": "13. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This protocol will require port reservation like TCP for the use of \"well known\" servers within the Internet. All current TCP ports shall be automatically reserved in the SCTP port address space. New requests should follow IANA's current mechanisms for TCP.",
      "ja": "このプロトコルでは、インターネット内で「よく知られている」サーバーを使用するために、TCPのようなポート予約が必要です。現在のすべてのTCPポートは、SCTPポートアドレススペースに自動的に予約されます。新しい要求は、TCPのIANAの現在のメカニズムに従う必要があります。"
    },
    {
      "indent": 3,
      "text": "This protocol may also be extended through IANA in three ways:",
      "ja": "このプロトコルは、3つの方法でIANAを介して拡張することもできます。"
    },
    {
      "indent": 4,
      "text": "-- through definition of additional chunk types,\n-- through definition of additional parameter types, or\n-- through definition of additional cause codes within\n   ERROR chunks",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the case where a particular ULP using SCTP desires to have its own ports, the ULP should be responsible for registering with IANA for getting its ports assigned.",
      "ja": "SCTPを使用して特定のULPが独自のポートを持つことを望んでいる場合、ULPは、ポートを割り当てるためにIANAに登録する責任を負う必要があります。"
    },
    {
      "indent": 0,
      "text": "13.1 IETF-defined Chunk Extension",
      "section_title": true,
      "ja": "13.1 IETF定義のチャンク拡張"
    },
    {
      "indent": 3,
      "text": "The definition and use of new chunk types is an integral part of SCTP. Thus, new chunk types are assigned by IANA through an IETF Consensus action as defined in [RFC2434].",
      "ja": "新しいチャンクタイプの定義と使用は、SCTPの不可欠な部分です。したがって、[RFC2434]で定義されているIETFコンセンサスアクションを通じて、新しいチャンクタイプはIANAによって割り当てられます。"
    },
    {
      "indent": 3,
      "text": "The documentation for a new chunk code type must include the following information: a) A long and short name for the new chunk type;",
      "ja": "新しいチャンクコードタイプのドキュメントには、次の情報を含める必要があります。a）新しいチャンクタイプの長くて短い名前。"
    },
    {
      "indent": 3,
      "text": "b) A detailed description of the structure of the chunk, which MUST conform to the basic structure defined in Section 3.2;",
      "ja": "b) セクション3.2で定義されている基本構造に準拠する必要があるチャンクの構造の詳細な説明。"
    },
    {
      "indent": 3,
      "text": "c) A detailed definition and description of intended use of each field within the chunk, including the chunk flags if any;",
      "ja": "c) チャンクフラグを含む、チャンク内の各フィールドの使用の使用の詳細な定義と説明。"
    },
    {
      "indent": 3,
      "text": "d) A detailed procedural description of the use of the new chunk type within the operation of the protocol.",
      "ja": "d) プロトコルの操作内での新しいチャンクタイプの使用に関する詳細な手続き的説明。"
    },
    {
      "indent": 3,
      "text": "The last chunk type (255) is reserved for future extension if necessary.",
      "ja": "最後のチャンクタイプ（255）は、必要に応じて将来の拡張のために予約されています。"
    },
    {
      "indent": 0,
      "text": "13.2 IETF-defined Chunk Parameter Extension",
      "section_title": true,
      "ja": "13.2 IETF定義のチャンクパラメーター拡張"
    },
    {
      "indent": 3,
      "text": "The assignment of new chunk parameter type codes is done through an IETF Consensus action as defined in [RFC2434]. Documentation of the chunk parameter MUST contain the following information:",
      "ja": "[RFC2434]で定義されているIETFコンセンサスアクションを通じて、新しいChunkパラメータータイプコードの割り当ては行われます。チャンクパラメーターのドキュメントには、次の情報が含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "a) Name of the parameter type.",
      "ja": "a) パラメータータイプの名前。"
    },
    {
      "indent": 3,
      "text": "b) Detailed description of the structure of the parameter field. This structure MUST conform to the general type-length-value format described in Section 3.2.1.",
      "ja": "b) パラメーターフィールドの構造の詳細な説明。この構造は、セクション3.2.1で説明されている一般的なタイプ長価値形式に準拠する必要があります。"
    },
    {
      "indent": 3,
      "text": "c) Detailed definition of each component of the parameter value.",
      "ja": "c) パラメーター値の各コンポーネントの詳細な定義。"
    },
    {
      "indent": 3,
      "text": "d) Detailed description of the intended use of this parameter type, and an indication of whether and under what circumstances multiple instances of this parameter type may be found within the same chunk.",
      "ja": "d) このパラメータータイプの使用の使用の詳細な説明、およびこのパラメータータイプの複数のインスタンスが同じチャンク内で見つかるかどうか、およびどのような状況でどのような状況で表示されるかを示しています。"
    },
    {
      "indent": 0,
      "text": "13.3 IETF-defined Additional Error Causes",
      "section_title": true,
      "ja": "13.3 IETF定義の追加エラー原因"
    },
    {
      "indent": 3,
      "text": "Additional cause codes may be allocated in the range 11 to 65535 through a Specification Required action as defined in [RFC2434]. Provided documentation must include the following information:",
      "ja": "[RFC2434]で定義されているように、追加の原因コードは、11〜65535の範囲11〜65535に割り当てられる場合があります。提供されたドキュメントには、次の情報を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "a) Name of the error condition.",
      "ja": "a) エラー条件の名前。"
    },
    {
      "indent": 3,
      "text": "b) Detailed description of the conditions under which an SCTP endpoint should issue an ERROR (or ABORT) with this cause code.",
      "ja": "b) SCTPエンドポイントがこの原因コードでエラー（または中止）を発行する条件の詳細な説明。"
    },
    {
      "indent": 3,
      "text": "c) Expected action by the SCTP endpoint which receives an ERROR (or ABORT) chunk containing this cause code.",
      "ja": "c) この原因コードを含むエラー（または中止）チャンクを受信するSCTPエンドポイントによる予想アクション。"
    },
    {
      "indent": 3,
      "text": "d) Detailed description of the structure and content of data fields which accompany this cause code.",
      "ja": "d) この原因コードに伴うデータフィールドの構造と内容の詳細な説明。"
    },
    {
      "indent": 3,
      "text": "The initial word (32 bits) of a cause code parameter MUST conform to the format shown in Section 3.3.10, i.e.:",
      "ja": "原因コードパラメーターの最初の単語（32ビット）は、セクション3.3.10に示す形式に準拠する必要があります。"
    },
    {
      "indent": 3,
      "text": "-- first two bytes contain the cause code value\n-- last two bytes contain length of the Cause Parameter.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "13.4 Payload Protocol Identifiers",
      "section_title": true,
      "ja": "13.4 ペイロードプロトコル識別子"
    },
    {
      "indent": 3,
      "text": "Except for value 0 which is reserved by SCTP to indicate an unspecified payload protocol identifier in a DATA chunk, SCTP will not be responsible for standardizing or verifying any payload protocol identifiers; SCTP simply receives the identifier from the upper layer and carries it with the corresponding payload data.",
      "ja": "SCTPによって予約されている値0を除き、データチャンクで不特定のペイロードプロトコル識別子を示すため、SCTPはペイロードプロトコル識別子の標準化または検証に責任を負いません。SCTPは、単に上層から識別子を受信し、対応するペイロードデータで識別子を運びます。"
    },
    {
      "indent": 3,
      "text": "The upper layer, i.e., the SCTP user, SHOULD standardize any specific protocol identifier with IANA if it is so desired. The use of any specific payload protocol identifier is out of the scope of SCTP.",
      "ja": "上層、つまりSCTPユーザーは、IANAとの特定のプロトコル識別子を非常に望んでいる場合は標準化する必要があります。特定のペイロードプロトコル識別子の使用は、SCTPの範囲外です。"
    },
    {
      "indent": 0,
      "text": "14. Suggested SCTP Protocol Parameter Values",
      "section_title": true,
      "ja": "14. 提案されたSCTPプロトコルパラメーター値"
    },
    {
      "indent": 3,
      "text": "The following protocol parameters are RECOMMENDED:",
      "ja": "次のプロトコルパラメーターが推奨されます。"
    },
    {
      "indent": 3,
      "text": "RTO.Initial - 3 seconds RTO.Min - 1 second RTO.Max - 60 seconds RTO.Alpha - 1/8 RTO.Beta - 1/4 Valid.Cookie.Life - 60 seconds Association.Max.Retrans - 10 attempts Path.Max.Retrans - 5 attempts (per destination address) Max.Init.Retransmits - 8 attempts HB.interval - 30 seconds",
      "ja": "RTO.INITIAL -3秒rto.min -1秒rto.max -60秒rto.alpha -1/8 rto.beta -1/4 balid.cookie.life -60秒協会。max.retrans -5試行（宛先アドレスごと）max.init.retransmits -8試行HB.INTERVAL -30秒"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: The SCTP implementation may allow ULP to customize some of these protocol parameters (see Section 10).",
      "ja": "実装注：SCTP実装により、ULPはこれらのプロトコルパラメーターの一部をカスタマイズできる場合があります（セクション10を参照）。"
    },
    {
      "indent": 3,
      "text": "Note: RTO.Min SHOULD be set as recommended above.",
      "ja": "注：RTO.minは、上記のように設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "15. Acknowledgements",
      "section_title": true,
      "ja": "15. 謝辞"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank Mark Allman, R.J. Atkinson, Richard Band, Scott Bradner, Steve Bellovin, Peter Butler, Ram Dantu, R. Ezhirpavai, Mike Fisk, Sally Floyd, Atsushi Fukumoto, Matt Holdrege, Henry Houh, Christian Huitema, Gary Lehecka, Jonathan Lee, David Lehmann, John Loughney, Daniel Luan, Barry Nagelberg, Thomas Narten, Erik Nordmark, Lyndon Ong, Shyamal Prasad, Kelvin Porter, Heinz Prantner, Jarno Rajahalme, Raymond E. Reeves, Renee Revis, Ivan Arias Rodriguez, A. Sankar, Greg Sidebottom, Brian Wyld, La Monte Yarroll, and many others for their invaluable comments.",
      "ja": "著者は、マーク・オールマン、R.J。アトキンソン、リチャード・バンド、スコット・ブラッドナー、スティーブ・ベロヴィン、ピーター・バトラー、ラム・ダントゥ、R。エジルパヴァイ、マイク・フィスク、サリー・フロイド、アトシュ・フクモト、マット・ホールデジ、ヘンリー・ホウ、クリスチャン・フイテマ、ゲイリー・レヘッカ、ジョン・リー、デイビッド・レフマン、ジョン・ラウニー、ダニエル・ルアン、バリー・ナゲルバーグ、トーマス・ナルテン、エリック・ノードマーク、リンドン・オング、シャマル・プラサド、ケルビン・ポーター、ハインツ・プラントナー、ジャルノ・ラジャハルム、レイモンド・E・リーブス、レニー・レブ、イヴァン・アリアス・ロディゲス、A。ラ・モンテ・ヤロル、そして彼らの貴重なコメントのために他の多く。"
    },
    {
      "indent": 0,
      "text": "16. Authors' Addresses",
      "section_title": true,
      "ja": "16. 著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Randall R. Stewart 24 Burning Bush Trail. Crystal Lake, IL 60012 USA",
      "ja": "ランドールR.スチュワート24バーニングブッシュトレイル。イリノイ州クリスタルレイク60012 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1-815-477-2127\nEMail: rrs@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Qiaobing Xie Motorola, Inc. 1501 W. Shure Drive, #2309 Arlington Heights, IL 60004 USA",
      "ja": "Qiaobing Xie Motorola、Inc。1501 W. Shure Drive、＃2309 Arlington Heights、IL 60004 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1-847-632-3028\nEMail: qxie1@email.mot.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Ken Morneault Cisco Systems Inc. 13615 Dulles Technology Drive Herndon, VA. 20171 USA",
      "ja": "Ken Morneault Cisco Systems Inc. 13615 Dulles Technology Drive Herndon、VA。20171 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1-703-484-3323 EMail: kmorneau@cisco.com Chip Sharp Cisco Systems Inc. 7025 Kit Creek Road Research Triangle Park, NC 27709 USA",
      "ja": "電話：1-703-484-3323メール：kmorneau@cisco.comチップSharp Cisco Systems Inc. 7025 Kit Creek Road Research Triangle Park、NC 27709 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1-919-392-3121\nEMail: chsharp@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hanns Juergen Schwarzbauer SIEMENS AG Hofmannstr. 51 81359 Munich Germany",
      "ja": "Hanns Juergen Schwarzbauer Siemens Ag Hofmannstr。51 81359ミュンヘンドイツ"
    },
    {
      "indent": 3,
      "text": "Phone: +49-89-722-24236\nEMail: HannsJuergen.Schwarzbauer@icn.siemens.de",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Tom Taylor Nortel Networks 1852 Lorraine Ave. Ottawa, Ontario Canada K1H 6Z8",
      "ja": "トムテイラーノルテルネットワーク1852ロレーヌアベニューオタワ、オンタリオカナダK1H 6Z8"
    },
    {
      "indent": 3,
      "text": "Phone: +1-613-736-0961\nEMail: taylor@nortelnetworks.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Ian Rytina Ericsson Australia 37/360 Elizabeth Street Melbourne, Victoria 3000 Australia",
      "ja": "Ian Rytina Ericsson Australia 37/360 Elizabeth Street Melbourne、Victoria 3000 Australia"
    },
    {
      "indent": 3,
      "text": "Phone: +61-3-9301-6164 EMail: ian.rytina@ericsson.com Malleswar Kalla Telcordia Technologies 3 Corporate Place PYA-2J-341 Piscataway, NJ 08854 USA",
      "ja": "電話：61-3-9301-6164メール：ian.rytina@ericsson.com Malleswar Kalla Telcordia Technologies 3 Corporate Place PYA-2J-341 PISCATAWAY、NJ 08854 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1-732-699-3728\nEMail: mkalla@telcordia.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Lixia Zhang UCLA Computer Science Department 4531G Boelter Hall Los Angeles, CA 90095-1596 USA",
      "ja": "Lixia Zhang UCLA Computer Science Department 4531G Boelter Hall Los Angeles、CA 90095-1596 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1-310-825-2695\nEMail: lixia@cs.ucla.edu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Vern Paxson ACIRI 1947 Center St., Suite 600, Berkeley, CA 94704-1198 USA",
      "ja": "Vern Paxson Aciri 1947 Center St.、Suite 600、Berkeley、CA 94704-1198 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1-510-666-2882\nEMail: vern@aciri.org",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "17. References",
      "section_title": true,
      "ja": "17. 参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC768] Postel, J. (ed.), \"User Datagram Protocol\", STD 6, RFC 768, August 1980.",
      "ja": "[RFC768] Postel、J。（ed。）、 \"User Datagram Protocol\"、Std 6、RFC 768、1980年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC793] Postel, J. (ed.), \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[RFC793] Postel、J。（ed。）、「Transmission Control Protocol」、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC1123] Braden, R., \"Requirements for Internet hosts - application and support\", STD 3, RFC 1123, October 1989.",
      "ja": "[RFC1123] Braden、R。、「インターネットホストの要件 - アプリケーションとサポート」、STD 3、RFC 1123、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1191] Mogul, J. and S. Deering, \"Path MTU Discovery\", RFC 1191, November 1990.",
      "ja": "[RFC1191] Mogul、J。およびS. Deering、「Path MTU Discovery」、RFC 1191、1990年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC1700] Reynolds, J. and J. Postel, \"Assigned Numbers\", STD 2, RFC 1700, October 1994.",
      "ja": "[RFC1700] Reynolds、J。およびJ. Postel、「割り当てられた番号」、STD 2、RFC 1700、1994年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1981] McCann, J., Deering, S. and J. Mogul, \"Path MTU Discovery for IP version 6\", RFC 1981, August 1996.",
      "ja": "[RFC1981] McCann、J.、Deering、S。、およびJ. Mogul、「IPバージョン6のPath MTU Discovery」、RFC 1981、1996年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC1982] Elz, R. and R. Bush, \"Serial Number Arithmetic\", RFC 1982, August 1996.",
      "ja": "[RFC1982] Elz、R。およびR. Bush、「シリアル番号算術」、RFC 1982、1996年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2026] Bradner, S., \"The Internet Standards Process -- Revision 3\", BCP 9, RFC 2026, October 1996.",
      "ja": "[RFC2026] Bradner、S。、「インターネット標準プロセス - リビジョン3」、BCP 9、RFC 2026、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2401] Kent, S. and R. Atkinson, \"Security Architecture for the Internet Protocol\", RFC 2401, November 1998.",
      "ja": "[RFC2401] Kent、S。およびR. Atkinson、「インターネットプロトコルのセキュリティアーキテクチャ」、RFC 2401、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2402] Kent, S. and R. Atkinson, \"IP Authentication Header\", RFC 2402, November 1998.",
      "ja": "[RFC2402]ケント、S。およびR.アトキンソン、「IP認証ヘッダー」、RFC 2402、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2406] Kent, S. and R. Atkinson, \"IP Encapsulating Security Payload (ESP)\", RFC 2406, November 1998.",
      "ja": "[RFC2406] Kent、S。およびR. Atkinson、「IPカプセンシングセキュリティペイロード（ESP）」、RFC 2406、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2408] Maughan, D., Schertler, M., Schneider, M. and J. Turner, \"Internet Security Association and Key Management Protocol\", RFC 2408, November 1998.",
      "ja": "[RFC2408] Maughan、D.、Schertler、M.、Schneider、M.およびJ. Turner、「インターネットセキュリティ協会および主要管理プロトコル」、RFC 2408、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2409] Harkins, D. and D. Carrel, \"The Internet Key Exchange (IKE)\", RFC 2409, November 1998.",
      "ja": "[RFC2409] Harkins、D。およびD. Carrel、「The Internet Key Exchange（IKE）」、RFC 2409、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2434] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[RFC2434] Narten、T。およびH. Alvestrand、「RFCSでIANA考慮事項セクションを書くためのガイドライン」、BCP 26、RFC 2434、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2460] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[RFC2460] Deering、S。およびR. Hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC2581] Allman, M., Paxson, V. and W. Stevens, \"TCP Congestion Control\", RFC 2581, April 1999.",
      "ja": "[RFC2581] Allman、M.、Paxson、V。and W. Stevens、「TCP混雑制御」、RFC 2581、1999年4月。"
    },
    {
      "indent": 0,
      "text": "18. Bibliography",
      "section_title": true,
      "ja": "18. 書誌"
    },
    {
      "indent": 3,
      "text": "[ALLMAN99] Allman, M. and Paxson, V., \"On Estimating End-to-End Network Path Properties\", Proc. SIGCOMM'99, 1999.",
      "ja": "[Allman99] Allman、M。and Paxson、V。、「エンドツーエンドネットワークパスプロパティの推定について」、Proc。Sigcomm'99、1999。"
    },
    {
      "indent": 3,
      "text": "[FALL96] Fall, K. and Floyd, S., Simulation-based Comparisons of Tahoe, Reno, and SACK TCP, Computer Communications Review, V. 26 N. 3, July 1996, pp. 5-21.",
      "ja": "[Fall96] Fall、K。およびFloyd、S.、Tahoe、Reno、およびSack TCPのシミュレーションベースの比較、コンピューターコミュニケーションレビュー、V。26N. 3、1996年7月、pp。5-21。"
    },
    {
      "indent": 3,
      "text": "[RFC1750] Eastlake, D. (ed.), \"Randomness Recommendations for Security\", RFC 1750, December 1994.",
      "ja": "[RFC1750] EastLake、D。（ed。）、「セキュリティのためのランダム性の推奨」、RFC 1750、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC1950] Deutsch P. and J. Gailly, \"ZLIB Compressed Data Format Specification version 3.3\", RFC 1950, May 1996.",
      "ja": "[RFC1950] Deutsch P.およびJ. Gailly、「Zlib圧縮データ形式の仕様バージョン3.3」、RFC 1950、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M. and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, March 1997.",
      "ja": "[RFC2104] Krawczyk、H.、Bellare、M。and R. Canetti、「HMAC：メッセージ認証のためのキー付きハッシング」、RFC 2104、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2196] Fraser, B., \"Site Security Handbook\", FYI 8, RFC 2196, September 1997.",
      "ja": "[RFC2196] Fraser、B。、「サイトセキュリティハンドブック」、FYI 8、RFC 2196、1997年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC2522] Karn, P. and W. Simpson, \"Photuris: Session-Key Management Protocol\", RFC 2522, March 1999.",
      "ja": "[RFC2522] Karn、P。およびW. Simpson、「Phyuris：Session-Key Management Protocol」、RFC 2522、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[SAVAGE99] Savage, S., Cardwell, N., Wetherall, D., and Anderson, T., \"TCP Congestion Control with a Misbehaving Receiver\", ACM Computer Communication Review, 29(5), October 1999.",
      "ja": "[Savage99] Savage、S.、Cardwell、N.、Wetherall、D。、およびAnderson、T。、「不正行為レシーバーによるTCP混雑制御」、ACMコンピューター通信レビュー、29（5）、1999年10月。"
    },
    {
      "indent": 0,
      "text": "Appendix A: Explicit Congestion Notification",
      "ja": "付録A：明示的な混雑通知"
    },
    {
      "indent": 3,
      "text": "ECN (Ramakrishnan, K., Floyd, S., \"Explicit Congestion Notification\", RFC 2481, January 1999) describes a proposed extension to IP that details a method to become aware of congestion outside of datagram loss. This is an optional feature that an implementation MAY choose to add to SCTP. This appendix details the minor differences implementers will need to be aware of if they choose to implement this feature. In general RFC 2481 should be followed with the following exceptions.",
      "ja": "ECN（Ramakrishnan、K.、Floyd、S。、「明示的な混雑通知」、RFC 2481、1999年1月）は、データグラムの損失以外の輻輳を認識する方法を詳述するIPの提案された拡張を説明しています。これは、実装がSCTPに追加することを選択できるオプションの機能です。この付録の詳細は、実装者がこの機能を実装することを選択した場合に注意する必要があるマイナーな違いを確認する必要があります。一般に、RFC 2481は、以下の例外を除いて追跡する必要があります。"
    },
    {
      "indent": 3,
      "text": "Negotiation:",
      "ja": "交渉："
    },
    {
      "indent": 3,
      "text": "RFC2481 details negotiation of ECN during the SYN and SYN-ACK stages of a TCP connection. The sender of the SYN sets two bits in the TCP flags, and the sender of the SYN-ACK sets only 1 bit. The reasoning behind this is to assure both sides are truly ECN capable. For SCTP this is not necessary. To indicate that an endpoint is ECN capable an endpoint SHOULD add to the INIT and or INIT ACK chunk the TLV reserved for ECN. This TLV contains no parameters, and thus has the following format:",
      "ja": "RFC2481 TCP接続のSyn-syn-ack段階でのECNの交渉の詳細。Synの送信者は、TCPフラグに2ビットを設定し、Syn-ackの送信者は1ビットしか設定しません。この背後にある理由は、双方が本当に能力があることを保証することです。SCTPの場合、これは必要ありません。エンドポイントがECN能力であることを示すために、エンドポイントはinitに追加する必要があります。このTLVにはパラメーターが含まれていないため、次の形式があります。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Parameter Type = 32768      |     Parameter Length = 4      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ECN-Echo:",
      "ja": "ECNエコー："
    },
    {
      "indent": 3,
      "text": "RFC 2481 details a specific bit for a receiver to send back in its TCP acknowledgements to notify the sender of the Congestion Experienced (CE) bit having arrived from the network. For SCTP this same indication is made by including the ECNE chunk. This chunk contains one data element, i.e. the lowest TSN associated with the IP datagram marked with the CE bit, and looks as follows:",
      "ja": "RFC 2481は、レシーバーがTCP謝辞に戻すために特定のビットを詳述し、ネットワークから到着した経験豊富な（CE）ビットを送信者に通知します。SCTPの場合、これと同じ兆候がECNEチャンクを含めることによって行われます。このチャンクには、1つのデータ要素、つまりCEビットがマークされたIPデータグラムに関連付けられている最低のTSNが含まれており、次のように見えます。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Chunk Type=12 | Flags=00000000|    Chunk Length = 8           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Lowest TSN Number                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Note: The ECNE is considered a Control chunk.",
      "ja": "注：ECNEはコントロールチャンクと見なされます。"
    },
    {
      "indent": 3,
      "text": "CWR:",
      "ja": "CWR："
    },
    {
      "indent": 3,
      "text": "RFC 2481 details a specific bit for a sender to send in the header of its next outbound TCP segment to indicate to its peer that it has reduced its congestion window. This is termed the CWR bit. For SCTP the same indication is made by including the CWR chunk. This chunk contains one data element, i.e. the TSN number that was sent in the ECNE chunk. This element represents the lowest TSN number in the datagram that was originally marked with the CE bit.",
      "ja": "RFC 2481は、送信者が次のアウトバウンドTCPセグメントのヘッダーを送信して、輻輳ウィンドウを削減したことをピアに示す特定のビットを詳述します。これはCWRビットと呼ばれます。SCTPの場合、CWRチャンクを含めることにより、同じ適応症が行われます。このチャンクには、1つのデータ要素、つまりECNEチャンクで送信されたTSN番号が含まれています。この要素は、もともとCEビットがマークされていたデータグラムで最も低いTSN数を表します。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Chunk Type=13 | Flags=00000000|    Chunk Length = 8           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Lowest TSN Number                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Note: The CWR is considered a Control chunk.",
      "ja": "注：CWRはコントロールチャンクと見なされます。"
    },
    {
      "indent": 0,
      "text": "Appendix B Alder 32 bit checksum calculation",
      "ja": "付録Bアルダー32ビットチェックサムの計算"
    },
    {
      "indent": 3,
      "text": "The Adler-32 checksum calculation given in this appendix is copied from [RFC1950].",
      "ja": "この付録に記載されているAdler-32チェックサムの計算は、[RFC1950]からコピーされています。"
    },
    {
      "indent": 3,
      "text": "Adler-32 is composed of two sums accumulated per byte: s1 is the sum of all bytes, s2 is the sum of all s1 values. Both sums are done modulo 65521. s1 is initialized to 1, s2 to zero. The Adler-32 checksum is stored as s2*65536 + s1 in network byte order.",
      "ja": "Adler-32は、バイトごとに蓄積された2つの合計で構成されています。S1はすべてのバイトの合計で、S2はすべてのS1値の合計です。どちらの合計もModulo65521に行われます。S1は1、S2からゼロに初期化されます。Adler-32チェックサムは、ネットワークバイトの順序でS2*65536 S1として保存されます。"
    },
    {
      "indent": 3,
      "text": "The following C code computes the Adler-32 checksum of a data buffer. It is written for clarity, not for speed. The sample code is in the ANSI C programming language. Non C users may find it easier to read with these hints:",
      "ja": "次のCコードは、データバッファーのAdler-32チェックサムを計算します。速度ではなく、明確に書かれています。サンプルコードは、ANSI Cプログラミング言語にあります。非Cユーザーは、これらのヒントで読みやすいと感じるかもしれません。"
    },
    {
      "indent": 3,
      "text": "&      Bitwise AND operator.\n>>     Bitwise right shift operator.  When applied to an\n       unsigned quantity, as here, right shift inserts zero bit(s)\n       at the left.\n<<     Bitwise left shift operator.  Left shift inserts zero\n       bit(s) at the right.\n++     \"n++\" increments the variable n.\n%      modulo operator: a % b is the remainder of a divided by b.\n #define BASE 65521 /* largest prime smaller than 65536 */\n /*\n   Update a running Adler-32 checksum with the bytes buf[0..len-1]\n   and return the updated checksum.  The Adler-32 checksum should be\n   initialized to 1.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Usage example:",
      "ja": "使用例："
    },
    {
      "indent": 9,
      "text": "unsigned long adler = 1L;",
      "ja": "符号なしのlong adler = 1L;"
    },
    {
      "indent": 6,
      "text": "   while (read_buffer(buffer, length) != EOF) {\n     adler = update_adler32(adler, buffer, length);\n   }\n   if (adler != original_adler) error();\n*/\nunsigned long update_adler32(unsigned long adler,\n   unsigned char *buf, int len)\n{\n  unsigned long s1 = adler & 0xffff;\n  unsigned long s2 = (adler >> 16) & 0xffff;\n  int n;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "  for (n = 0; n < len; n++) {\n    s1 = (s1 + buf[n]) % BASE;\n    s2 = (s2 + s1)     % BASE;\n  }\n  return (s2 << 16) + s1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Return the adler32 of the bytes buf[0..len-1] */\nunsigned long adler32(unsigned char *buf, int len)\n{\n  return update_adler32(1L, buf, len);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2000). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2000）。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書と本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}