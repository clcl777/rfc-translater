{
  "title": {
    "text": "RFC 2765 - Stateless IP/ICMP Translation Algorithm (SIIT)",
    "ja": "RFC 2765 - ステートレスIP/ICMP翻訳アルゴリズム（SIIT）"
  },
  "number": 2765,
  "created_at": "2024-01-31 09:17:46.171715+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                     E. Nordmark\nRequest for Comments: 2765                           Sun Microsystems\nCategory: Standards Track                               February 2000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Stateless IP/ICMP Translation Algorithm (SIIT)",
      "ja": "ステートレスIP/ICMP翻訳アルゴリズム（SIIT）"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2000). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2000）。無断転載を禁じます。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document specifies a transition mechanism algorithm in addition to the mechanisms already specified in [TRANS-MECH]. The algorithm translates between IPv4 and IPv6 packet headers (including ICMP headers) in separate translator \"boxes\" in the network without requiring any per-connection state in those \"boxes\". This new algorithm can be used as part of a solution that allows IPv6 hosts, which do not have a permanently assigned IPv4 addresses, to communicate with IPv4-only hosts. The document neither specifies address assignment nor routing to and from the IPv6 hosts when they communicate with the IPv4-only hosts.",
      "ja": "このドキュメントは、[Trans-Mech]ですでに指定されているメカニズムに加えて、遷移メカニズムアルゴリズムを指定します。このアルゴリズムは、IPv4とIPv6パケットヘッダー（ICMPヘッダーを含む）間で、「ボックス」に接続ごとの状態を必要とせずに、ネットワーク内の個別の翻訳者「ボックス」に変換します。この新しいアルゴリズムは、永続的に割り当てられたIPv4アドレスを持たないIPv6ホストを許可するソリューションの一部として、IPv4のみのホストと通信することができます。このドキュメントは、IPv4のみのホストと通信したときに、IPv6ホストとのアドレス割り当てもルーティングも指定しません。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This document is a product of the NGTRANS working group. Some text has been extracted from an old Internet Draft titled \"IPAE: The SIPP Interoperability and Transition Mechanism\" authored by R. Gilligan, E. Nordmark, and B. Hinden. George Tsirtsis provides the figures for Section 1. Keith Moore provided a careful review of the document.",
      "ja": "このドキュメントは、NGTRANSワーキンググループの製品です。R. Gilligan、E。Nordmark、およびB. Hindenが作成した「IPAE：SIPPの相互運用性と遷移メカニズム」というタイトルの古いインターネットドラフトからいくつかのテキストが抽出されています。George Tsirtsisは、セクション1の数値を提供します。キースムーアは、文書の慎重なレビューを提供しました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction and Motivation..............................    2\n   1.1.  Applicability and Limitations.......................    5\n   1.2.  Assumptions.........................................    7\n   1.3.  Impact Outside the Network Layer....................    7\n2.  Terminology..............................................    8\n   2.1.  Addresses...........................................    9\n   2.2.  Requirements........................................    9\n3.  Translating from IPv4 to IPv6............................    9\n   3.1.  Translating IPv4 Headers into IPv6 Headers..........   11\n   3.2.  Translating UDP over IPv4...........................   13\n   3.3.  Translating ICMPv4 Headers into ICMPv6 Headers......   13\n   3.4.  Translating ICMPv4 Error Messages into ICMPv6.......   16\n   3.5.  Knowing when to Translate...........................   16\n4.  Translating from IPv6 to IPv4............................   17\n   4.1.  Translating IPv6 Headers into IPv4 Headers..........   18\n   4.2.  Translating ICMPv6 Headers into ICMPv4 Headers......   20\n   4.3.  Translating ICMPv6 Error Messages into ICMPv4.......   22\n   4.4.  Knowing when to Translate...........................   22\n5.  Implications for IPv6-Only Nodes.........................   22\n6.  Security Considerations..................................   23\nReferences...................................................   24\nAuthor's Address.............................................   25\nFull Copyright Statement.....................................   26",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction and Motivation",
      "section_title": true,
      "ja": "1. 紹介と動機付け"
    },
    {
      "indent": 3,
      "text": "The transition mechanisms specified in [TRANS-MECH] handle the case of dual IPv4/IPv6 hosts interoperating with both dual hosts and IPv4-only hosts, which is needed early in the transition to IPv6. The dual hosts are assigned both an IPv4 and one or more IPv6 addresses. As the number of available globally unique IPv4 addresses becomes smaller and smaller as the Internet grows there will be a desire to take advantage of the large IPv6 address and not require that every new Internet node have a permanently assigned IPv4 address.",
      "ja": "[Trans-Mech]で指定されている遷移メカニズムは、Dual HostsとIPv4のみのホストの両方と相互緩和するデュアルIPv4/IPv6ホストのケースを処理します。これは、IPv6への移行の初期に必要です。デュアルホストには、IPv4と1つ以上のIPv6アドレスの両方が割り当てられます。インターネットが成長するにつれて、利用可能なグローバルに一意のIPv4アドレスの数が小さくなるにつれて、大規模なIPv6アドレスを利用したいという願望があり、すべての新しいインターネットノードに永続的に割り当てられたIPv4アドレスがあることを要求しません。"
    },
    {
      "indent": 3,
      "text": "There are several different scenarios where there might be IPv6-only hosts that need to communicate with IPv4-only hosts. These IPv6 hosts might be IPv4-capable, i.e. include an IPv4 implementation but not be assigned an IPv4 address, or they might not even include an IPv4 implementation.",
      "ja": "IPv4のみのホストと通信する必要があるIPv6のみのホストがあるかもしれないいくつかの異なるシナリオがあります。これらのIPv6ホストはIPv4対応である可能性があります。つまり、IPv4の実装を含めますが、IPv4アドレスを割り当てないか、IPv4の実装さえ含まない場合があります。"
    },
    {
      "indent": 3,
      "text": "- A completely new network with new devices that all support IPv6. In this case it might be beneficial to not have to configure the routers within the new network to route IPv4 since none of the hosts in the new network are configured with IPv4 addresses. But these new IPv6 devices might occasionally need to communicate with some IPv4 nodes out on the Internet.",
      "ja": "- すべてがIPv6をサポートする新しいデバイスを備えた完全に新しいネットワーク。この場合、新しいネットワーク内のホストはIPv4アドレスで構成されていないため、IPv4をルーティングするために新しいネットワーク内のルーターを構成する必要がないことが有益かもしれません。しかし、これらの新しいIPv6デバイスは、インターネット上でいくつかのIPv4ノードと通信する必要がある場合があります。"
    },
    {
      "indent": 3,
      "text": "- An existing network where a large number of IPv6 devices are added. The IPv6 devices might have both an IPv4 and an IPv6 protocol stack but there is not enough global IPv4 address space to give each one of them a permanent IPv4 address. In this case it is more likely that the routers in the network already route IPv4 and are upgraded to dual routers.",
      "ja": "- 多数のIPv6デバイスが追加される既存のネットワーク。IPv6デバイスには、IPv4とIPv6プロトコルスタックの両方がある場合がありますが、それぞれが永続的なIPv4アドレスを提供するのに十分なグローバルIPv4アドレススペースがありません。この場合、ネットワーク内のルーターがすでにIPv4をルーティングし、デュアルルーターにアップグレードされる可能性が高くなります。"
    },
    {
      "indent": 3,
      "text": "However, there are other potential solutions in this area:",
      "ja": "ただし、この分野には他の潜在的な解決策があります。"
    },
    {
      "indent": 3,
      "text": "- If there is no IPv4 routing inside the network i.e., the cloud that contains the new devices, some possible solutions are to either use the translators specified in this document at the boundary of the cloud, or to use Application Layer Gateways (ALG) on dual nodes at the cloud's boundary. The ALG solution is less flexible in that it is application protocol specific and it is also less robust since an ALG box is likely to be a single point of failure for a connection using that box.",
      "ja": "- ネットワーク内にIPv4ルーティングがない場合、つまり新しいデバイスを含むクラウドがある場合、いくつかの可能なソリューションは、クラウドの境界でこのドキュメントで指定されている翻訳者を使用するか、デュアルでアプリケーションレイヤーゲートウェイ（ALG）を使用することです。クラウドの境界にあるノード。ALGソリューションは、アプリケーションプロトコル固有であり、ALGボックスがそのボックスを使用した接続の単一の障害ポイントになる可能性が高いため、柔軟性が低くなります。"
    },
    {
      "indent": 3,
      "text": "- Otherwise, if IPv4 routing is supported inside the cloud and the implementations support both IPv6 and IPv4 it might suffice to have a mechanism for allocating a temporary address IPv4 and use IPv4 end to end when communicating with IPv4-only nodes. However, it would seem that such a solution would require the pool of temporary IPv4 addresses to be partitioned across all the subnets in the cloud which would either require a larger pool of IPv4 addresses or result in cases where communication would fail due to no available IPv4 address for the node's subnet.",
      "ja": "- それ以外の場合、IPv4ルーティングがクラウド内でサポートされ、実装がIPv6とIPv4の両方をサポートする場合、IPv4のみのアドレスを割り当てるメカニズムがあり、IPv4のみのノードと通信するときにIPv4 ENDを使用してENDを使用するだけで十分かもしれません。ただし、このようなソリューションでは、クラウド内のすべてのサブネットに一時的なIPv4アドレスのプールを分割する必要があるように思われます。ノードのサブネットのアドレス。"
    },
    {
      "indent": 3,
      "text": "This document specifies an algorithm that is one of the components needed to make IPv6-only nodes interoperate with IPv4-only nodes. Other components, not specified in this document, are a mechanism for the IPv6-only node to somehow acquire a temporary IPv4 address, and a mechanism for providing routing (perhaps using tunneling) to and from the temporary IPv4 address assigned to the node.",
      "ja": "このドキュメントは、IPv6のみのノードをIPv4のみのノードと相互運用するために必要なコンポーネントの1つであるアルゴリズムを指定します。このドキュメントで指定されていない他のコンポーネントは、IPv6のみのノードが一時的なIPv4アドレスを何らかの形で取得するメカニズムであり、ノードに割り当てられた一時的なIPv4アドレスにルーティング（おそらくトンネリングを使用）を提供するメカニズムです。"
    },
    {
      "indent": 3,
      "text": "The temporary IPv4 address will be used as an IPv4-translated IPv6 address and the packets will travel through a stateless IP/ICMP translator that will translate the packet headers between IPv4 and IPv6 and translate the addresses in those headers between IPv4 addresses on one side and IPv4-translated or IPv4-mapped IPv6 addresses on the other side.",
      "ja": "一時的なIPv4アドレスはIPv4翻訳IPv6アドレスとして使用され、パケットはIPv4とIPv6の間のパケットヘッダーを翻訳し、IPv4アドレス間のヘッダーのアドレスを翻訳するステートレスIP/ICMP翻訳者を介して移動します。IPv4-TranslatedまたはIPv4-Mapped IPv6アドレスは反対側にあります。"
    },
    {
      "indent": 3,
      "text": "This specification does not cover how an IPv6 node can acquire a temporary IPv4 address and how such a temporary address be registered in the DNS. The DHCP protocol, perhaps with some extensions, could probably be used to acquire temporary addresses with short leases but that is outside the scope of this document. Also, the mechanism for routing this IPv4-translated IPv6 address in the site is not specified in this document.",
      "ja": "この仕様では、IPv6ノードが一時的なIPv4アドレスを取得する方法と、そのような一時アドレスがDNSに登録される方法をカバーしていません。おそらくいくつかの拡張機能を備えたDHCPプロトコルは、おそらく短いリースで一時的な住所を取得するために使用できますが、それはこのドキュメントの範囲外です。また、サイト内のこのIPv4翻訳IPv6アドレスをルーティングするメカニズムは、このドキュメントでは指定されていません。"
    },
    {
      "indent": 3,
      "text": "The figures below show how the Stateless IP/ICMP Translation algorithm (SIIT) can be used initially for small networks (e.g., a single subnet) and later for a site which has IPv6-only hosts in a dual IPv4/IPv6 network. This use assumes a mechanism for the IPv6 nodes to acquire a temporary address from the pool of IPv4 addresses. Note that SIIT is not likely to be useful later during transition when most of the Internet is IPv6 and there are only small islands of IPv4 nodes, since such use would either require the IPv6 nodes to acquire temporary IPv4 addresses from a \"distant\" SIIT box operated by a different administration, or require that the IPv6 routing contain routes for IPv6-mapped addresses. (The latter is known to be a very bad idea due to the size of the IPv4 routing table that would potentially be injected into IPv6 routing in the form of IPv4-mapped addresses.)",
      "ja": "以下の図は、ステートレスIP/ICMP翻訳アルゴリズム（SIIT）を最初に小さなネットワーク（単一のサブネットなど）に使用する方法を示しており、その後は、デュアルIPv4/IPv6ネットワークにIPv6のみのホストを持つサイトで使用できます。この使用は、IPv6ノードがIPv4アドレスのプールから一時的なアドレスを取得するメカニズムを想定しています。SIITは、インターネットのほとんどがIPv6であり、IPv4ノードの小さな島のみがある場合、移行中に後で役立つ可能性が低いことに注意してください。そのような使用は、「遠い」SIITボックスから一時的なIPv4アドレスを取得するためにIPv6ノードを必要とするため異なる管理によって運用されるか、IPv6ルーティングにIPv6マップアドレスのルートが含まれることを要求します。（後者は、IPv4マップのアドレスの形でIPv6ルーティングに挿入される可能性があるIPv4ルーティングテーブルのサイズにより、非常に悪い考えであることが知られています。）"
    },
    {
      "indent": 6,
      "text": "                               ___________\n                              /           \\\n[IPv6 Host]---[SIIT]---------< IPv4 network>--[IPv4 Host]\n                 |            \\___________/\n          (pool of IPv4 addresses)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "IPv4-translatable -> IPv4->IPv4 addresser IPv4-mapped",
      "ja": "IPv4-Translatable-> IPv4-> IPv4アドレスダーIPv4-Mapped"
    },
    {
      "indent": 11,
      "text": "Figure 1. Using SIIT for a single IPv6-only subnet.",
      "ja": "図1.単一のIPv6のみのサブネットにSIITを使用します。"
    },
    {
      "indent": 6,
      "text": "               ___________              ___________\n              /           \\            /           \\\n[IPv6 Host]--< Dual network>--[SIIT]--< IPv4 network>--[IPv4 Host]\n              \\___________/     |      \\___________/\n                       (pool of IPv4 addresses)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "IPv4-translatable -> IPv4->IPv4 addresser IPv4-mapped",
      "ja": "IPv4-Translatable-> IPv4-> IPv4アドレスダーIPv4-Mapped"
    },
    {
      "indent": 4,
      "text": "Figure 2. Using SIIT for an IPv6-only or dual cloud (e.g. a site) which contains some IPv6-only hosts as well as IPv4 hosts.",
      "ja": "図2. IPv6のみのクラウドまたはデュアルクラウド（サイト）にSIITを使用して、IPv6のみのホストとIPv4ホストを含む。"
    },
    {
      "indent": 3,
      "text": "The protocol translators are assumed to fit around some piece of topology that includes some IPv6-only nodes and that may also include IPv4 nodes as well as dual nodes. There has to be a translator on each path used by routing the \"translatable\" packets in and out of this cloud to ensure that such packets always get translated. This does not require a translator at every physical connection between the cloud and the rest of the Internet since the routing can be used to deliver the packets to the translator.",
      "ja": "プロトコル翻訳者は、IPv6のみのノードを含むいくつかのトポロジーに適合し、IPv4ノードとデュアルノードも含まれる場合があると想定されています。このクラウドの内外で「翻訳可能な」パケットをルーティングして、そのようなパケットが常に翻訳されるようにすることで使用される各パスに翻訳者がいる必要があります。これは、ルーティングを使用してパケットを翻訳者に配信できるため、クラウドと他のインターネットの間のすべての物理的接続で翻訳者を必要としません。"
    },
    {
      "indent": 3,
      "text": "The IPv6-only node communicating with an IPv4 node through a translator will see an IPv4-mapped address for the peer and use an IPv4-translatable address for its local address for that communication. When the IPv6-only node sends packets the IPv4-mapped address indicates that the translator needs to translate the packets. When the IPv4 node sends packets those will translated to have the IPv4-translatable address as a destination; it is not possible to use an IPv4-mapped or an IPv4-compatible address as a destination since that would either route the packet back to the translator (for the IPv4-mapped address) or make the packet be encapsulated in IPv4 (for the IPv4-compatible address). Thus this specification introduces the new notion of an IPv4-translatable address.",
      "ja": "翻訳者を介してIPv4ノードと通信するIPv6のみのノードは、ピアのIPv4マップアドレスが表示され、その通信のためにローカルアドレスにIPv4翻訳可能アドレスを使用します。IPv6のみのノードがパケットを送信すると、IPv4マップされたアドレスは、翻訳者がパケットを翻訳する必要があることを示します。IPv4ノードがパケットを送信すると、IPv4翻訳可能なアドレスを宛先として持つように翻訳されます。IPv4-MappedまたはIPv4互換のアドレスを宛先として使用することはできません。これは、パケットをトランスレータに戻す（IPv4マップアドレス用）か、IPv4でパケットをカプセル化するか（IPv4の場合）-Compatibleアドレス）。したがって、この仕様では、IPv4翻訳可能なアドレスの新しい概念を紹介します。"
    },
    {
      "indent": 0,
      "text": "1.1. Applicability and Limitations",
      "section_title": true,
      "ja": "1.1. 適用性と制限"
    },
    {
      "indent": 3,
      "text": "The use of this translation algorithm assumes that the IPv6 network is somehow well connected i.e. when an IPv6 node wants to communicate with another IPv6 node there is an IPv6 path between them. Various tunneling schemes exist that can provide such a path, but those mechanisms and their use is outside the scope of this document.",
      "ja": "この翻訳アルゴリズムの使用は、IPv6ネットワークが何らかの形で適切に接続されていることを前提としています。つまり、IPv6ノードが別のIPv6ノードと通信したい場合、それらの間にIPv6パスがあります。このようなパスを提供できるさまざまなトンネルスキームが存在しますが、それらのメカニズムとその使用はこのドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "The IPv6 protocol [IPv6] has been designed so that the TCP and UDP pseudo-header checksums are not affected by the translations specified in this document, thus the translator does not need to modify normal TCP and UDP headers. The only exceptions are unfragmented IPv4 UDP packets which need to have a UDP checksum computed since a pseudo-header checksum is required for UDP in IPv6. Also, ICMPv6 include a pseudo-header checksum but it is not present in ICMPv4 thus the checksum in ICMP messages need to be modified by the translator. In addition, ICMP error messages contain an IP header as part of the payload thus the translator need to rewrite those parts of the packets to make the receiver be able to understand the included IP header. However, all of the translator's operations, including path MTU discovery, are stateless in the sense that the translator operates independently on each packet and does not retain any state from one packet to another. This allows redundant translator boxes without any coordination and a given TCP connection can have the two directions of packets go through different translator boxes.",
      "ja": "IPv6プロトコル[IPv6]は、TCPおよびUDP擬似ヘッダーチェックサムがこのドキュメントで指定された翻訳の影響を受けないように設計されているため、翻訳者は通常のTCPヘッダーとUDPヘッダーを変更する必要はありません。唯一の例外は、IPv6のUDPには擬似ヘッダーチェックサムが必要であるため、UDPチェックサムを計算する必要があるfragmentmentmented IPv4 UDPパケットです。また、ICMPv6には擬似ヘッダーチェックサムが含まれていますが、ICMPV4には存在しないため、ICMPメッセージのチェックサムは翻訳者によって変更する必要があります。さらに、ICMPエラーメッセージにはペイロードの一部としてIPヘッダーが含まれているため、翻訳者はパケットのそれらの部分を書き換えて、受信者が含まれるIPヘッダーを理解できるようにする必要があります。ただし、Path MTUの発見を含む翻訳者のすべての操作は、翻訳者が各パケットで独立して動作し、あるパケットから別のパケットに状態を保持していないという意味で無国籍です。これにより、調整なしの冗長翻訳ボックスが可能になり、特定のTCP接続により、パケットの2つの方向が異なる翻訳ボックスを通過できます。"
    },
    {
      "indent": 3,
      "text": "The translating function as specified in this document does not translate any IPv4 options and it does not translate IPv6 routing headers, hop-by-hop extension headers, or destination options headers. It could be possible to define a translation between source routing in IPv4 and IPv6. However such a translation would not be semantically correct due to the slight differences between the IPv4 and IPv6 source routing. Also, the usefulness of source routing when going through a header translator might be limited since all the IPv6-only routers would need to have an IPv4-translated IPv6 address since the IPv4-only node will send a source route option containing only IPv4 addresses.",
      "ja": "このドキュメントで指定されている翻訳関数は、IPv4オプションを翻訳せず、IPv6ルーティングヘッダー、ホップバイホップ拡張ヘッダー、または宛先オプションヘッダーを翻訳しません。IPv4とIPv6のソースルーティング間の変換を定義することが可能です。ただし、IPv4とIPv6ソースルーティングのわずかな違いのため、このような翻訳は意味的に正しいものではありません。また、IPv4のみのノードにはIPv4アドレスのみを含むソースルートオプションを送信するため、すべてのIPv6のみのルーターがIPv4翻訳IPv6アドレスを持つ必要があるため、ヘッダー翻訳者を通過する際のソースルーティングの有用性は制限される可能性があります。"
    },
    {
      "indent": 3,
      "text": "At first sight it might appear that the IPsec functionality [IPv6-SA, IPv6-ESP, IPv6-AH] can not be carried across the translator. However, since the translator does not modify any headers above the logical IP layer (IP headers, IPv6 fragment headers, and ICMP messages) packets encrypted using ESP in Transport-mode can be carried through the translator. [Note that this assumes that the key management can operate between the IPv6-only node and the IPv4-only node.] The AH computation covers parts of the IPv4 header fields such as IP addresses, and the identification field (fields that are either immutable or predictable by the sender) [IPv6-AUTH]. While the SIIT algorithm is specified so that those IPv4 fields can be predicted by the IPv6 sender it is not possible for the IPv6 receiver to determine the value of the IPv4 Identification field in packets sent by the IPv4 node. Thus as the translation algorithm is specified in this document it is not possible to use end-to-end AH through the translator.",
      "ja": "一見、IPSEC機能[IPv6-SA、IPv6-ESP、IPv6-AH]を翻訳者全体に運ぶことができないように見えるかもしれません。ただし、翻訳者は論理IPレイヤー（IPヘッダー、IPv6フラグメントヘッダー、ICMPメッセージ）の上のヘッダーを変更しないため、トランスポートモードでESPを使用して暗号化されたパケットは、翻訳者を介して運ぶことができます。[これは、Key ManagementがIPv6のみのノードとIPv4のみのノードの間で動作できることを前提としていることに注意してください。] AH計算は、IPアドレスなどのIPv4ヘッダーフィールドの一部と識別フィールド（不変のフィールドの一部をカバーしています。または送信者が予測可能）[IPv6-Auth]。SIITアルゴリズムは指定されているため、IPv6送信者によってこれらのIPv4フィールドを予測できるようになりますが、IPv6レシーバーはIPv4ノードによって送信されたパケットのIPv4識別フィールドの値を決定することはできません。したがって、このドキュメントで翻訳アルゴリズムが指定されているため、翻訳者を介してエンドツーエンドAHを使用することはできません。"
    },
    {
      "indent": 3,
      "text": "For ESP Tunnel-mode to work through the translator the IPv6 node would have to be able to both parse and generate \"inner\" IPv4 headers since the inner IP will be encrypted together with the transport protocol.",
      "ja": "ESP Tunnel-Modeが翻訳者を介して動作するためには、IPv6ノードは、インナーIPがトランスポートプロトコルと一緒に暗号化されるため、「内側」のIPv4ヘッダーを解析して生成できる必要があります。"
    },
    {
      "indent": 3,
      "text": "Thus in practise, only ESP transport mode is relatively easy to make work through a translator.",
      "ja": "したがって、実際には、ESP輸送モードのみが比較的簡単に翻訳者を介して作業を行うことができます。"
    },
    {
      "indent": 3,
      "text": "IPv4 multicast addresses can not be mapped to IPv6 multicast addresses. For instance, ::ffff:224.1.2.3 is an IPv4 mapped IPv6 address with a class D address, however it is not an IPv6 multicast address. While the IP/ICMP header translation aspect of this memo in theory works for multicast packets this address mapping limitation makes it impossible to apply the techniques in this memo for multicast traffic.",
      "ja": "IPv4マルチキャストアドレスは、IPv6マルチキャストアドレスにマッピングできません。たとえば、:: FFFF：224.1.2.3は、クラスDアドレスを持つIPv4マッピングIPv6アドレスですが、IPv6マルチキャストアドレスではありません。理論のこのメモのIP/ICMPヘッダー翻訳の側面は、マルチキャストパケットで機能しますが、このアドレスマッピング制限により、マルチキャストトラフィックに関するこのメモのテクニックを適用することは不可能です。"
    },
    {
      "indent": 0,
      "text": "1.2. Assumptions",
      "section_title": true,
      "ja": "1.2. 仮定"
    },
    {
      "indent": 3,
      "text": "The IPv6 nodes using the translator must have an IPv4-translated IPv6 address while it is communicating with IPv4-only nodes.",
      "ja": "翻訳者を使用したIPv6ノードは、IPv4のみのノードと通信している間に、IPv4翻訳IPv6アドレスを持っている必要があります。"
    },
    {
      "indent": 3,
      "text": "The use of the algorithm assumes that there is an IPv4 address pool used to generate IPv4-translated addresses. Routing needs to be able to route any IPv4 packets, whether generated \"outside\" or \"inside\" the translator, destined to addresses in this pool towards the translator. This implies that the address pool can not be assigned to subnets but must be separated from the IPv4 subnets used on the \"inside\" of the translator.",
      "ja": "アルゴリズムの使用は、IPv4翻訳アドレスを生成するために使用されるIPv4アドレスプールがあることを前提としています。ルーティングは、「外部」または「内部」であろうと、翻訳者に「内側」であろうと、任意のIPv4パケットをルーティングできる必要があります。これは、アドレスプールをサブネットに割り当てることはできませんが、翻訳者の「内部」で使用されるIPv4サブネットから分離する必要があることを意味します。"
    },
    {
      "indent": 3,
      "text": "Fragmented IPv4 UDP packets that do not contain a UDP checksum (i.e. the UDP checksum field is zero) are not of significant use over wide-areas in the Internet and will not be translated by the translator. An informal trace [MILLER] in the backbone showed that out of 34,984,468 IP packets there were 769 fragmented UDP packets with a zero checksum. However, all of them were due to malicious or broken behavior; a port scan and first fragments of IP packets that are not a multiple of 8 bytes.",
      "ja": "UDPチェックサムを含まない断片化されたIPv4 UDPパケット（つまり、UDPチェックサムフィールドはゼロです）は、インターネットの広い人気で大きな使用ではなく、翻訳者によって翻訳されません。バックボーン内の非公式の痕跡[Miller]は、34,984,468個のIPパケットのうち、ゼロチェックサムを備えた769個の断片化されたUDPパケットがあることを示しました。しかし、それらはすべて悪意のあるまたは壊れた行動によるものでした。ポートスキャンと8バイトの倍数ではないIPパケットの最初のフラグメント。"
    },
    {
      "indent": 0,
      "text": "1.3. Impact Outside the Network Layer",
      "section_title": true,
      "ja": "1.3. ネットワークレイヤーの外側に衝撃を与えます"
    },
    {
      "indent": 3,
      "text": "The potential existence of stateless IP/ICMP translators is already taken care of from a protocol perspective in [IPv6]. However, an IPv6 node that wants to be able to use translators needs some additional logic in the network layer.",
      "ja": "Stateless IP/ICMP翻訳者の潜在的な存在は、[IPv6]のプロトコルの観点からすでに処理されています。ただし、翻訳者を使用できるようにしたいIPv6ノードには、ネットワークレイヤーに追加のロジックが必要です。"
    },
    {
      "indent": 3,
      "text": "The network layer in an IPv6-only node, when presented by the application with either an IPv4 destination address or an IPv4-mapped IPv6 destination address, is likely to drop the packet and return some error message to the application. In order to take advantage of translators such a node should instead send an IPv6 packet where the destination address is the IPv4-mapped address and the source address is the node's temporarily assigned IPv4-translated address. If the node does not have a temporarily assigned IPv4-translated address it should acquire one using mechanisms that are not discussed in this document.",
      "ja": "IPv6のみのノードのネットワークレイヤーは、IPv4宛先アドレスまたはIPv4マップのIPv6宛先アドレスのいずれかでアプリケーションによって表示される場合、パケットをドロップし、アプリケーションにエラーメッセージを返す可能性があります。翻訳者を利用するには、そのようなノードなど、宛先アドレスがIPv4マップのアドレスであり、ソースアドレスが一時的に割り当てられたIPv4翻訳アドレスであるIPv6パケットを送信する必要があります。ノードに一時的に割り当てられたIPv4翻訳されたアドレスがない場合、このドキュメントで説明されていないメカニズムを使用して1つを取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that the above also applies to a dual IPv4/IPv6 implementation node which is not configured with any IPv4 address.",
      "ja": "上記は、IPv4アドレスで構成されていないデュアルIPv4/IPv6実装ノードにも適用されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "There are no extra changes needed to applications to operate through a translator beyond what applications already need to do to operate on a dual node. The applications that have been modified to work on a dual node already have the mechanisms to determine whether they are communicating with an IPv4 or an IPv6 peer. Thus if the applications need to modify their behavior depending on the type of the peer, such as ftp determining whether to fallback to using the PORT/PASV command when EPRT/EPSV fails (as specified in [FTPEXT]), they already need to do that when running on dual nodes and the presense of translators does not add anything. For example, when using the socket API [BSDAPI] the applications know that the peer is IPv6 if they get an AF_INET6 address from the name service and the address is not an IPv4-mapped address (i.e., IN6_IS_ADDR_V4MAPPED returns false). If this is not the case, i.e., the address is AF_INET or an IPv4-mapped IPv6 address, the peer is IPv4.",
      "ja": "デュアルノードで動作するためにアプリケーションが既に行う必要があることを超えて、翻訳者を介して動作するためにアプリケーションに追加の変更は必要ありません。デュアルノードで動作するように変更されたアプリケーションには、IPv4またはIPv6ピアと通信しているかどうかを判断するメカニズムが既にあります。したがって、eprt/epsvが失敗したときにポート/PASVコマンドを使用するかどうかをFTPに決定するなど、ピアのタイプに応じてアプリケーションが動作を変更する必要がある場合（[ftpext]で指定されている）、すでに行う必要がありますデュアルノードと翻訳者のプレゼンスで実行しても何も追加しないこと。たとえば、ソケットAPI [BSDAPI]を使用する場合、アプリケーションは、名前サービスからAF_INET6アドレスを取得し、アドレスがIPv4マップアドレスではない場合、ピアがIPv6であることを知っています（つまり、IN6_IS_ADDR_V4MAPPはfalse）。そうでない場合、つまり、アドレスがAF_INETまたはIPv4-Mapped IPv6アドレスである場合、ピアはIPv4です。"
    },
    {
      "indent": 3,
      "text": "One way of viewing the translator, which might help clarify why applications do not need to know that a translator is used, is to look at the information that is passed from the transport layer to the network layer. If the transport passes down an IPv4 address (whether or not is in the IPv4-mapped encoding) this means that at some point there will be IPv4 packets generated. In a dual node the generation of the IPv4 packets takes place in the sending node. In an IPv6-only node conceptually the only difference is that the IPv4 packet is generated by the translator - all the information that the transport layer passed to the network layer will be conveyed to the translator in some form. That form just \"happens\" to be in the form of an IPv6 header.",
      "ja": "翻訳者を表示する1つの方法は、アプリケーションが翻訳者が使用されていることを知る必要がない理由を明確にするのに役立つかもしれませんが、輸送層からネットワーク層に渡される情報を調べることです。トランスポートがIPv4アドレスを通過した場合（IPv4-Mapped Encodingにあるかどうか）、これはある時点でIPv4パケットが生成されることを意味します。デュアルノードでは、送信ノードでIPv4パケットの生成が行われます。概念的にはIPv6のみのノードでは、唯一の違いは、IPv4パケットが翻訳者によって生成されることです - ネットワークレイヤーに渡されたトランスポートレイヤーが何らかの形で翻訳者に伝えられます。その形式は、IPv6ヘッダーの形であるように「起こる」だけです。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "This documents uses the terminology defined in [IPv6] and [TRANS-MECH] with these clarifications:",
      "ja": "この文書は、これらの明確化を使用して[IPv6]および[trans-mech]で定義された用語を使用します。"
    },
    {
      "indent": 9,
      "text": "IPv4 capable node: A node which has an IPv4 protocol stack. In order for the stack to be usable the node must be assigned one or more IPv4 addresses.",
      "ja": "IPv4対応ノード：IPv4プロトコルスタックを備えたノード。スタックを使用できるためには、ノードに1つ以上のIPv4アドレスを割り当てる必要があります。"
    },
    {
      "indent": 9,
      "text": "IPv4 enabled node: A node which has an IPv4 protocol stack and is assigned one or more IPv4 addresses. Both IPv4-only and IPv6/IPv4 nodes are IPv4 enabled.",
      "ja": "IPv4有効ノード：IPv4プロトコルスタックを備え、1つ以上のIPv4アドレスが割り当てられているノード。IPv4のみとIPv6/IPv4ノードの両方がIPv4の有効です。"
    },
    {
      "indent": 9,
      "text": "IPv6 capable node: A node which has an IPv6 protocol stack. In order for the stack to be usable the node must be assigned one or more IPv6 addresses.",
      "ja": "IPv6対応ノード：IPv6プロトコルスタックを備えたノード。スタックを使用できるためには、ノードに1つ以上のIPv6アドレスを割り当てる必要があります。"
    },
    {
      "indent": 9,
      "text": "IPv6 enabled node: A node which has an IPv6 protocol stack and is assigned one or more IPv6 addresses. Both IPv6-only and IPv6/IPv4 nodes are IPv6 enabled.",
      "ja": "IPv6有効ノード：IPv6プロトコルスタックを備えており、1つ以上のIPv6アドレスが割り当てられているノード。IPv6のみとIPv6/IPv4ノードの両方がIPv6を有効にしています。"
    },
    {
      "indent": 0,
      "text": "2.1. Addresses",
      "section_title": true,
      "ja": "2.1. アドレス"
    },
    {
      "indent": 3,
      "text": "In addition to the forms of addresses defined in [ADDR-ARCH] this document also introduces the new form of IPv4-translated address. This is needed to avoid using IPv4-compatible addresses outside the intended use of automatic tunneling. Thus the address forms are:",
      "ja": "[addr-arch]で定義されているアドレスの形式に加えて、このドキュメントでは、新しい形式のIPv4翻訳アドレスも紹介します。これは、自動トンネリングの意図した使用以外のIPv4互換アドレスの使用を避けるために必要です。したがって、アドレスフォームは次のとおりです。"
    },
    {
      "indent": 9,
      "text": "IPv4-mapped: An address of the form 0::ffff:a.b.c.d which refers to a node that is not IPv6-capable. In addition to its use in the API this protocol uses IPv4-mapped addresses in IPv6 packets to refer to an IPv4 node.",
      "ja": "IPv4-Mapped：IPv6対応ではないノードを指すフォーム0 :: FFFF：A.B.C.Dのアドレス。APIでの使用に加えて、このプロトコルはIPv6パケットでIPv4マップアドレスを使用してIPv4ノードを参照します。"
    },
    {
      "indent": 9,
      "text": "IPv4-compatible: An address of the form 0::0:a.b.c.d which refers to an IPv6/IPv4 node that supports automatic tunneling. Such addresses are not used in this protocol.",
      "ja": "IPv4互換：自動トンネリングをサポートするIPv6/IPv4ノードを指すフォーム0 :: 0：A.B.C.Dのアドレス。このようなアドレスは、このプロトコルでは使用されていません。"
    },
    {
      "indent": 9,
      "text": "IPv4-translated: An address of the form 0::ffff:0:a.b.c.d which refers to an IPv6-enabled node. Note that the prefix 0::ffff:0:0:0/96 is chosen to checksum to zero to avoid any changes to the transport protocol's pseudo header checksum.",
      "ja": "IPv4-Translated：IPv6対応ノードを指すフォーム0 :: FFFF：0：A.B.C.Dのアドレス。接頭辞0 :: FFFF：0：0：0/96は、輸送プロトコルの擬似ヘッダーチェックサムの変更を避けるために、チェックサムにゼロに選択されていることに注意してください。"
    },
    {
      "indent": 0,
      "text": "2.2. Requirements",
      "section_title": true,
      "ja": "2.2. 要件"
    },
    {
      "indent": 3,
      "text": "The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in this document, are to be interpreted as described in [KEYWORDS].",
      "ja": "キーワードは、[キーワード]で説明されているように解釈される場合、キーワードは[キーワード]で説明されているように解釈される場合、[キーワード]で説明されているように解釈する必要がある、必要ではない、、必要ではない、、勧められない、そうでなければならない、そうでなければならない。"
    },
    {
      "indent": 0,
      "text": "3. Translating from IPv4 to IPv6",
      "section_title": true,
      "ja": "3. IPv4からIPv6への翻訳"
    },
    {
      "indent": 3,
      "text": "When an IPv4-to-IPv6 translator receives an IPv4 datagram addressed to a destination that lies outside of the attached IPv4 island, it translates the IPv4 header of that packet into an IPv6 header. It then forwards the packet based on the IPv6 destination address. The original IPv4 header on the packet is removed and replaced by an IPv6 header. Except for ICMP packets the transport layer header and data portion of the packet are left unchanged.",
      "ja": "IPv4-to-IPV6 Translatorが、添付のIPv4アイランドの外側にある宛先にアドレス指定されたIPv4データグラムを受信すると、そのパケットのIPv4ヘッダーをIPv6ヘッダーに変換します。次に、IPv6宛先アドレスに基づいてパケットを転送します。パケットの元のIPv4ヘッダーが削除され、IPv6ヘッダーに置き換えられます。ICMPパケットを除き、トランスポートレイヤーヘッダーとパケットのデータ部分は変更されません。"
    },
    {
      "indent": 8,
      "text": "+-------------+                 +-------------+\n|    IPv4     |                 |    IPv6     |\n|   Header    |                 |   Header    |\n+-------------+                 +-------------+\n|  Transport  |                 |  Fragment   |\n|   Layer     |      ===>       |   Header    |\n|   Header    |                 |(not always) |\n+-------------+                 +-------------+\n|             |                 |  Transport  |\n~    Data     ~                 |   Layer     |\n|             |                 |   Header    |\n+-------------+                 +-------------+\n                                |             |\n                                ~    Data     ~\n                                |             |\n                                +-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "IPv4-to-IPv6 Translation",
      "ja": "IPv4-to-IPV6翻訳"
    },
    {
      "indent": 3,
      "text": "One of the differences between IPv4 and IPv6 is that in IPv6 path MTU discovery is mandatory but it is optional in IPv4. This implies that IPv6 routers will never fragment a packet - only the sender can do fragmentation.",
      "ja": "IPv4とIPv6の違いの1つは、IPv6 PathでMTU発見が必須であるが、IPv4ではオプションであることです。これは、IPv6ルーターがパケットを断片化することは決してないことを意味します - 送信者のみが断片化を行うことができます。"
    },
    {
      "indent": 3,
      "text": "When the IPv4 node performs path MTU discovery (by setting the DF bit in the header) the path MTU discovery can operate end-to-end i.e. across the translator. In this case either IPv4 or IPv6 routers might send back ICMP \"packet too big\" messages to the sender. When these ICMP errors are sent by the IPv6 routers they will pass through a translator which will translate the ICMP error to a form that the IPv4 sender can understand. In this case an IPv6 fragment header is only included if the IPv4 packet is already fragmented.",
      "ja": "IPv4ノードがPATH MTUディスカバリーを実行すると（ヘッダーにDFビットを設定することにより）、PATH MTUディスカバリーはエンドツーエンド、つまり翻訳者全体で動作できます。この場合、IPv4またはIPv6ルーターのいずれかが、送信者にICMPの「パケットが大きすぎる」メッセージを送り返す可能性があります。これらのICMPエラーがIPv6ルーターによって送信されると、翻訳者を通過し、ICMPエラーをIPv4送信者が理解できるフォームに変換します。この場合、IPv4パケットが既に断片化されている場合にのみIPv6フラグメントヘッダーが含まれています。"
    },
    {
      "indent": 3,
      "text": "However, when the IPv4 sender does not perform path MTU discovery the translator has to ensure that the packet does not exceed the path MTU on the IPv6 side. This is done by fragmenting the IPv4 packet so that it fits in 1280 byte IPv6 packet since IPv6 guarantees that 1280 byte packets never need to be fragmented. Also, when the IPv4 sender does not perform path MTU discovery the translator MUST always include an IPv6 fragment header to indicate that the sender allows fragmentation. That is needed should the packet pass through an IPv6-to-IPv4 translator.",
      "ja": "ただし、IPv4送信者がPATH MTU発見を実行しない場合、翻訳者はパケットがIPv6側のPATH MTUを超えないことを確認する必要があります。これは、IPv4パケットが1280バイトパケットを断片化する必要がないことを保証するため、1280バイトIPv6パケットに適合するようにIPv4パケットを断片化することによって行われます。また、IPv4送信者がPATH MTUディスカバリーを実行しない場合、翻訳者は常にIPv6フラグメントヘッダーを含めて、送信者が断片化を許可することを示す必要があります。IPv6-to-IPV4翻訳者をパケットが通過した場合に必要です。"
    },
    {
      "indent": 3,
      "text": "The above rules ensure that when packets are fragmented either by the sender or by IPv4 routers that the low-order 16 bits of the fragment identification is carried end-end to ensure that packets are correctly reassembled. In addition, the rules use the presence of an IPv6 fragment header to indicate that the sender might not be using path MTU discovery i.e. the packet should not have the DF flag set should it later be translated back to IPv4.",
      "ja": "上記のルールでは、パケットが送信者またはIPv4ルーターによって断片化された場合、フラグメント識別の低次の16ビットがエンドエンドを運ばれ、パケットが正しく再組み立てされることを保証します。さらに、ルールはIPv6フラグメントヘッダーの存在を使用して、送信者がPATH MTU発見を使用していない可能性があることを示します。"
    },
    {
      "indent": 3,
      "text": "Other than the special rules for handling fragments and path MTU discovery the actual translation of the packet header consists of a simple mapping as defined below. Note that ICMP packets require special handling in order to translate the content of ICMP error message and also to add the ICMP pseudo-header checksum.",
      "ja": "フラグメントとパスMTU発見の取り扱いの特別なルール以外に、パケットヘッダーの実際の翻訳は、以下に定義されている単純なマッピングで構成されています。ICMPエラーメッセージのコンテンツを翻訳し、ICMP擬似ヘッダーチェックサムを追加するには、ICMPパケットが特別な取り扱いが必要であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.1. Translating IPv4 Headers into IPv6 Headers",
      "section_title": true,
      "ja": "3.1. IPv4ヘッダーをIPv6ヘッダーに変換します"
    },
    {
      "indent": 3,
      "text": "If the DF flag is not set and the IPv4 packet will result in an IPv6 packet larger than 1280 bytes the IPv4 packet MUST be fragmented prior to translating it. Since IPv4 packets with DF not set will always result in a fragment header being added to the packet the IPv4 packets must be fragmented so that their length, excluding the IPv4 header, is at most 1232 bytes (1280 minus 40 for the IPv6 header and 8 for the Fragment header). The resulting fragments are then translated independently using the logic described below.",
      "ja": "DFフラグが設定されておらず、IPv4パケットが1280バイトを超えるIPv6パケットを作成する場合、翻訳する前にIPv4パケットを断片化する必要があります。DFが設定されていないIPv4パケットは、常にフラグメントヘッダーがパケットに追加されるため、IPv4ヘッダーを除く長さが最大1232バイト（IPv6ヘッダーと8つのマイナス40、8が断片化する必要があります。フラグメントヘッダーの場合）。結果の断片は、以下のロジックを使用して独立して翻訳されます。"
    },
    {
      "indent": 3,
      "text": "If the DF bit is set and the packet is not a fragment (i.e., the MF flag is not set and the Fragment Offset is zero) then there is no need to add a fragment header to the packet. The IPv6 header fields are set as follows:",
      "ja": "DFビットが設定され、パケットがフラグメントではない場合（つまり、MFフラグが設定されておらず、フラグメントオフセットがゼロです）、パケットにフラグメントヘッダーを追加する必要はありません。IPv6ヘッダーフィールドは次のように設定されています。"
    },
    {
      "indent": 9,
      "text": "Version: 6",
      "ja": "バージョン：6"
    },
    {
      "indent": 9,
      "text": "Traffic Class: By default, copied from IP Type Of Service and Precedence field (all 8 bits are copied). According to [DIFFSERV] the semantics of the bits are identical in IPv4 and IPv6. However, in some IPv4 environments these fields might be used with the old semantics of \"Type Of Service and Precedence\". An implementation of a translator SHOULD provide the ability to ignore the IPv4 \"TOS\" and always set the IPv6 traffic class to zero.",
      "ja": "トラフィッククラス：デフォルトでは、IPタイプのサービスと優先順位フィールドからコピーされました（8ビットすべてがコピーされます）。[diffserv]によると、ビットのセマンティクスはIPv4とIPv6で同一です。ただし、一部のIPv4環境では、これらのフィールドは「サービスの種類と優先順位」の古いセマンティクスとともに使用される場合があります。翻訳者の実装は、IPv4 \"TOS\"を無視し、常にIPv6トラフィッククラスをゼロに設定する機能を提供する必要があります。"
    },
    {
      "indent": 9,
      "text": "Flow Label: 0 (all zero bits)",
      "ja": "フローラベル：0（すべてゼロビット）"
    },
    {
      "indent": 9,
      "text": "Payload Length: Total length value from IPv4 header, minus the size of the IPv4 header and IPv4 options, if present.",
      "ja": "ペイロード長：IPv4ヘッダーからの合計長さの値は、存在する場合はIPv4ヘッダーとIPv4オプションのサイズを差し引いています。"
    },
    {
      "indent": 9,
      "text": "Next Header: Protocol field copied from IPv4 header",
      "ja": "次のヘッダー：IPv4ヘッダーからコピーされたプロトコルフィールド"
    },
    {
      "indent": 9,
      "text": "Hop Limit: TTL value copied from IPv4 header. Since the translator is a router, as part of forwarding the packet it needs to decrement either the IPv4 TTL (before the translation) or the IPv6 Hop Limit (after the translation). As part of decrementing the TTL or Hop Limit the translator (as any router) needs to check for zero and send the ICMPv4 or ICMPv6 \"ttl exceeded\" error.",
      "ja": "ホップ制限：IPv4ヘッダーからコピーされたTTL値。翻訳者はルーターであるため、パケットの転送の一環として、IPv4 TTL（翻訳前）またはIPv6ホップ制限（翻訳後）のいずれかを減らす必要があります。TTLまたはホップ制限の減少の一環として、翻訳者は（任意のルーターとして）ゼロをチェックし、ICMPV4またはICMPV6 \"TTLを超えた\"エラーを送信する必要があります。"
    },
    {
      "indent": 9,
      "text": "Source Address: The low-order 32 bits is the IPv4 source address. The high-order 96 bits is the IPv4-mapped prefix (::ffff:0:0/96)",
      "ja": "ソースアドレス：低次の32ビットはIPv4ソースアドレスです。高次の96ビットは、IPv4-Mappedプレフィックス（:: FFFF：0：0/96）です。"
    },
    {
      "indent": 9,
      "text": "Destination Address:\n        The low-order 32 bits is the IPv4 destination\n        address.  The high-order 96 bits is the IPv4-\n        translated prefix (0::ffff:0:0:0/96)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If IPv4 options are present in the IPv4 packet, they are ignored i.e., there is no attempt to translate them. However, if an unexpired source route option is present then the packet MUST instead be discarded, and an ICMPv4 \"destination unreachable/source route failed\" (Type 3/Code 5) error message SHOULD be returned to the sender.",
      "ja": "IPv4パケットにIPv4オプションが存在する場合、それらは無視されます。つまり、それらを翻訳する試みはありません。ただし、期限切れのないソースルートオプションが存在する場合、代わりにパケットを破棄し、ICMPV4 \"宛先到達可能/ソースルートが失敗しました\"（タイプ3/コード5）エラーメッセージを送信者に返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If there is need to add a fragment header (the DF bit is not set or the packet is a fragment) the header fields are set as above with the following exceptions:",
      "ja": "フラグメントヘッダーを追加する必要がある場合（DFビットが設定されていないか、パケットがフラグメントである）、ヘッダーフィールドは次の例外を除いて上記のように設定されています。"
    },
    {
      "indent": 6,
      "text": "IPv6 fields:",
      "ja": "IPv6フィールド："
    },
    {
      "indent": 10,
      "text": "Payload Length: Total length value from IPv4 header, plus 8 for the fragment header, minus the size of the IPv4 header and IPv4 options, if present.",
      "ja": "ペイロード長：IPv4ヘッダーからの合計長さの値、フラグメントヘッダーの8つ、IPv4ヘッダーのサイズとIPv4オプションのサイズを差し引いて、存在する場合。"
    },
    {
      "indent": 10,
      "text": "Next Header: Fragment Header (44).",
      "ja": "次のヘッダー：フラグメントヘッダー（44）。"
    },
    {
      "indent": 6,
      "text": "Fragment header fields:",
      "ja": "フラグメントヘッダーフィールド："
    },
    {
      "indent": 10,
      "text": "Next Header: Protocol field copied from IPv4 header.",
      "ja": "次のヘッダー：IPv4ヘッダーからコピーされたプロトコルフィールド。"
    },
    {
      "indent": 10,
      "text": "Fragment Offset: Fragment Offset copied from the IPv4 header.",
      "ja": "フラグメントオフセット：IPv4ヘッダーからコピーされたフラグメントオフセット。"
    },
    {
      "indent": 10,
      "text": "M flag: More Fragments bit copied from the IPv4 header.",
      "ja": "Mフラグ：IPv4ヘッダーからコピーされたより多くのフラグメントビット。"
    },
    {
      "indent": 10,
      "text": "Identification: The low-order 16 bits copied from the Identification field in the IPv4 header. The high-order 16 bits set to zero.",
      "ja": "識別：IPv4ヘッダーの識別フィールドからコピーされた低次の16ビット。高次の16ビットはゼロに設定されています。"
    },
    {
      "indent": 0,
      "text": "3.2. Translating UDP over IPv4",
      "section_title": true,
      "ja": "3.2. IPv4を介してUDPを翻訳します"
    },
    {
      "indent": 3,
      "text": "If a UDP packet has a zero UDP checksum then a valid checksum must be calculated in order to translate the packet. A stateless translator can not do this for fragmented packets but [MILLER] indicates that fragmented UDP packets with a zero checksum appear to only be used for malicious purposes. Thus this is not believed to be a noticeable limitation.",
      "ja": "UDPパケットにUDPチェックサムがゼロの場合、パケットを翻訳するために有効なチェックサムを計算する必要があります。ステートレスの翻訳者は、断片化されたパケットに対してこれを行うことはできませんが、[Miller]は、ゼロチェックサムを持つ断片化されたUDPパケットが悪意のある目的にのみ使用されるように見えることを示しています。したがって、これは顕著な制限であるとは考えられていません。"
    },
    {
      "indent": 3,
      "text": "When a translator receives the first fragment of a fragmented UDP IPv4 packet and the checksum field is zero the translator SHOULD drop the packet and generate a system management event specifying at least the IP addresses and port numbers in the packet. When it receives fragments other than the first it SHOULD silently drop the packet, since there is no port information to log.",
      "ja": "翻訳者が断片化されたUDP IPv4パケットの最初のフラグメントを受信し、チェックサムフィールドがゼロである場合、翻訳者はパケットをドロップし、少なくともパケット内のIPアドレスとポート番号を指定するシステム管理イベントを生成する必要があります。ログするポート情報がないため、最初のもの以外のフラグメントを受信すると、パケットを静かにドロップする必要があります。"
    },
    {
      "indent": 3,
      "text": "When a translator receives an unfragmented UDP IPv4 packet and the checksum field is zero the translator MUST compute the missing UDP checksum as part of translating the packet. Also, the translator SHOULD maintain a counter of how many UDP checksums are generated in this manner.",
      "ja": "翻訳者がフラージュされていないUDP IPv4パケットを受信し、チェックサムフィールドがゼロの場合、翻訳者はパケットの翻訳の一部として欠落しているUDPチェックサムを計算する必要があります。また、翻訳者は、この方法で生成されるUDPチェックサムの数のカウンターを維持する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3. Translating ICMPv4 Headers into ICMPv6 Headers",
      "section_title": true,
      "ja": "3.3. ICMPV4ヘッダーをICMPV6ヘッダーに変換します"
    },
    {
      "indent": 3,
      "text": "All ICMP messages that are to be translated require that the ICMP checksum field be updated as part of the translation since ICMPv6, unlike ICMPv4, has a pseudo-header checksum just like UDP and TCP.",
      "ja": "翻訳されるすべてのICMPメッセージは、ICMPv6とは異なり、ICMPv6がUDPやTCPのように擬似ヘッダーチェックサムを持っているため、翻訳の一部としてICMPチェックサムフィールドを更新する必要があります。"
    },
    {
      "indent": 3,
      "text": "In addition all ICMP packets need to have the Type value translated and for ICMP error messages the included IP header also needs translation.",
      "ja": "さらに、すべてのICMPパケットがタイプ値を翻訳する必要があり、ICMPエラーメッセージの場合、含まれたIPヘッダーにも翻訳が必要です。"
    },
    {
      "indent": 3,
      "text": "The actions needed to translate various ICMPv4 messages are:",
      "ja": "さまざまなICMPV4メッセージを翻訳するために必要なアクションは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "ICMPv4 query messages:",
      "ja": "ICMPV4クエリメッセージ："
    },
    {
      "indent": 8,
      "text": "Echo and Echo Reply (Type 8 and Type 0) Adjust the type to 128 and 129, respectively, and adjust the ICMP checksum both to take the type change into account and to include the ICMPv6 pseudo-header.",
      "ja": "エコーとエコーの応答（タイプ8とタイプ0）タイプをそれぞれ128と129に調整し、ICMPチェックサムを調整して、タイプの変更を考慮し、ICMPV6 pseudo-headerを含めます。"
    },
    {
      "indent": 8,
      "text": "Information Request/Reply (Type 15 and Type 16) Obsoleted in ICMPv4. Silently drop.",
      "ja": "ICMPV4で廃止された情報リクエスト/返信（タイプ15およびタイプ16）。静かに落ちます。"
    },
    {
      "indent": 8,
      "text": "Timestamp and Timestamp Reply (Type 13 and Type 14) Obsoleted in ICMPv6. Silently drop.",
      "ja": "ICMPv6で廃止されたタイムスタンプとタイムスタンプの返信（タイプ13およびタイプ14）。静かに落ちます。"
    },
    {
      "indent": 8,
      "text": "Address Mask Request/Reply (Type 17 and Type 18) Obsoleted in ICMPv6. Silently drop.",
      "ja": "アドレスマスクリクエスト/返信（タイプ17およびタイプ18）は、ICMPv6に廃止されました。静かに落ちます。"
    },
    {
      "indent": 8,
      "text": "ICMP Router Advertisement (Type 9) Single hop message. Silently drop.",
      "ja": "ICMPルーター広告（タイプ9）シングルホップメッセージ。静かに落ちます。"
    },
    {
      "indent": 8,
      "text": "ICMP Router Solicitation (Type 10) Single hop message. Silently drop.",
      "ja": "ICMPルーター勧誘（タイプ10）シングルホップメッセージ。静かに落ちます。"
    },
    {
      "indent": 8,
      "text": "Unknown ICMPv4 types Silently drop.",
      "ja": "不明なICMPV4タイプは静かにドロップします。"
    },
    {
      "indent": 6,
      "text": "IGMP messages:",
      "ja": "IGMPメッセージ："
    },
    {
      "indent": 11,
      "text": "While the MLD messages [MLD] are the logical IPv6 counterparts for the IPv4 IGMP messages all the \"normal\" IGMP messages are single-hop messages and should be silently dropped by the translator. Other IGMP messages might be used by multicast routing protocols and, since it would be a configuration error to try to have router adjacencies across IPv4/IPv6 translators those packets should also be silently dropped.",
      "ja": "MLDメッセージ[MLD]はIPv4 IGMPメッセージの論理IPv6対応物ですが、すべての「通常の」IGMPメッセージはシングルホップメッセージであり、翻訳者が静かにドロップする必要があります。他のIGMPメッセージは、マルチキャストルーティングプロトコルで使用される場合があり、IPv4/IPv6翻訳者全体のルーターの隣接を試みるための構成エラーになるため、これらのパケットも静かに削除する必要があります。"
    },
    {
      "indent": 6,
      "text": "ICMPv4 error messages:",
      "ja": "ICMPV4エラーメッセージ："
    },
    {
      "indent": 8,
      "text": "Destination Unreachable (Type 3) For all that are not explicitly listed below set the Type to 1.",
      "ja": "以下に明示的にリストされていないすべての宛先なし（タイプ3）タイプを1に設定します。"
    },
    {
      "indent": 11,
      "text": "Translate the code field as follows: Code 0, 1 (net, host unreachable): Set Code to 0 (no route to destination).",
      "ja": "コードフィールドを次のように翻訳します：コード0、1（ネット、ホストの到達不能）：コードを0に設定します（宛先へのルートなし）。"
    },
    {
      "indent": 14,
      "text": "Code 2 (protocol unreachable): Translate to an ICMPv6 Parameter Problem (Type 4, Code 1) and make the Pointer point to the IPv6 Next Header field.",
      "ja": "コード2（プロトコルは到達不能）：ICMPV6パラメーター問題（タイプ4、コード1）に変換し、IPv6次のヘッダーフィールドをポインターポイントにします。"
    },
    {
      "indent": 14,
      "text": "Code 3 (port unreachable): Set Code to 4 (port unreachable).",
      "ja": "コード3（到達不能）：コードを4（到達不能）に設定します。"
    },
    {
      "indent": 14,
      "text": "Code 4 (fragmentation needed and DF set): Translate to an ICMPv6 Packet Too Big message (Type 2) with code 0. The MTU field needs to be adjusted for the difference between the IPv4 and IPv6 header sizes. Note that if the IPv4 router did not set the MTU field i.e. the router does not implement [PMTUv4], then the translator must use the plateau values specified in [PMTUv4] to determine a likely path MTU and include that path MTU in the ICMPv6 packet. (Use the greatest plateau value that is less than the returned Total Length field.)",
      "ja": "コード4（断片化が必要とDFセット）：コード0を使用してICMPV6パケット（タイプ2）に変換されます。MTUフィールドは、IPv4ヘッダーサイズとIPv6ヘッダーサイズの違いに合わせて調整する必要があります。IPv4ルーターがMTUフィールドを設定しなかった場合、つまりルーターが[PMTUV4]を実装していない場合、翻訳者は[PMTUV4]で指定されたプラトー値を使用して、可能性の高いパスMTUを決定し、ICMPV6パケットにそのパスMTUを含める必要があることに注意してください。。（返された総長さフィールドよりも少ない最大のプラトー値を使用します。）"
    },
    {
      "indent": 14,
      "text": "Code 5 (source route failed): Set Code to 0 (no route to destination). Note that this error is unlikely since source routes are not translated.",
      "ja": "コード5（ソースルートに失敗しました）：コードを0に設定します（宛先へのルートなし）。ソースルートが翻訳されていないため、このエラーはありそうにないことに注意してください。"
    },
    {
      "indent": 14,
      "text": "Code 6,7: Set Code to 0 (no route to destination).",
      "ja": "コード6,7：コードを0に設定します（宛先へのルートなし）。"
    },
    {
      "indent": 14,
      "text": "Code 8: Set Code to 0 (no route to destination).",
      "ja": "コード8：コードを0に設定します（宛先へのルートなし）。"
    },
    {
      "indent": 14,
      "text": "Code 9, 10 (communication with destination host administratively prohibited): Set Code to 1 (communication with destination administratively prohibited)",
      "ja": "コード9、10（宛先ホストとの通信が管理上禁止）：コードを1に設定します（目的地との通信は管理上禁止されています）"
    },
    {
      "indent": 14,
      "text": "Code 11, 12: Set Code to 0 (no route to destination).",
      "ja": "コード11、12：コードを0に設定します（宛先へのルートなし）。"
    },
    {
      "indent": 8,
      "text": "Redirect (Type 5) Single hop message. Silently drop.",
      "ja": "リダイレクト（タイプ5）シングルホップメッセージ。静かに落ちます。"
    },
    {
      "indent": 8,
      "text": "Source Quench (Type 4) Obsoleted in ICMPv6. Silently drop.",
      "ja": "ソースクエンチ（タイプ4）は、ICMPv6で廃止されました。静かに落ちます。"
    },
    {
      "indent": 8,
      "text": "Time Exceeded (Type 11) Set the Type field to 3. The Code field is unchanged.",
      "ja": "時間を超えた（タイプ11）タイプフィールドを3に設定します。コードフィールドは変更されていません。"
    },
    {
      "indent": 8,
      "text": "Parameter Problem (Type 12) Set the Type field to 4. The Pointer needs to be updated to point to the corresponding field in the translated include IP header.",
      "ja": "パラメーター問題（タイプ12）は、タイプフィールドを4に設定します。ポインターを更新する必要があります。翻訳されたIPヘッダーの対応するフィールドを指す必要があります。"
    },
    {
      "indent": 0,
      "text": "3.4. Translating ICMPv4 Error Messages into ICMPv6",
      "section_title": true,
      "ja": "3.4. ICMPV4エラーメッセージをICMPv6に変換します"
    },
    {
      "indent": 3,
      "text": "There are some differences between the IPv4 and the IPv6 ICMP error message formats as detailed above. In addition, the ICMP error messages contain the IP header for the packet in error which needs to be translated just like a normal IP header. The translation of this \"packet in error\" is likely to change the length of the datagram thus the Payload Length field in the outer IPv6 header might need to be updated.",
      "ja": "上記のIPv4とIPv6 ICMPエラーメッセージフォーマットにはいくつかの違いがあります。さらに、ICMPエラーメッセージには、通常のIPヘッダーと同じように翻訳する必要があるエラーのパケットのIPヘッダーが含まれています。この「パケットのエラー」の変換は、データグラムの長さを変更する可能性が高いため、外側のIPv6ヘッダーのペイロード長フィールドを更新する必要がある場合があります。"
    },
    {
      "indent": 8,
      "text": "+-------------+                 +-------------+\n|    IPv4     |                 |    IPv6     |\n|   Header    |                 |   Header    |\n+-------------+                 +-------------+\n|   ICMPv4    |                 |   ICMPv6    |\n|   Header    |                 |   Header    |\n+-------------+                 +-------------+\n|    IPv4     |      ===>       |    IPv6     |\n|   Header    |                 |   Header    |\n+-------------+                 +-------------+\n|   Partial   |                 |   Partial   |\n|  Transport  |                 |  Transport  |\n|   Layer     |                 |   Layer     |\n|   Header    |                 |   Header    |\n+-------------+                 +-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "IPv4-to-IPv6 ICMP Error Translation",
      "ja": "IPv4-to-IPV6 ICMPエラー変換"
    },
    {
      "indent": 3,
      "text": "The translation of the inner IP header can be done by recursively invoking the function that translated the outer IP headers.",
      "ja": "内側のIPヘッダーの翻訳は、外側のIPヘッダーを変換する関数を再帰的に呼び出すことで実行できます。"
    },
    {
      "indent": 0,
      "text": "3.5. Knowing when to Translate",
      "section_title": true,
      "ja": "3.5. いつ翻訳するかを知っています"
    },
    {
      "indent": 3,
      "text": "The translator is assumed to know the pool(s) of IPv4 address that are used to represent the internal IPv6-only nodes. Thus if the IPv4 destination field contains an address that falls in these configured sets of prefixes the packet needs to be translated to IPv6.",
      "ja": "翻訳者は、内部IPv6のみのノードを表すために使用されるIPv4アドレスのプールを知っていると想定されています。したがって、IPv4宛先フィールドに、これらの構成されたプレフィックスセットに該当するアドレスが含まれている場合、パケットをIPv6に翻訳する必要があります。"
    },
    {
      "indent": 0,
      "text": "4. Translating from IPv6 to IPv4",
      "section_title": true,
      "ja": "4. IPv6からIPv4への翻訳"
    },
    {
      "indent": 3,
      "text": "When an IPv6-to-IPv4 translator receives an IPv6 datagram addressed to an IPv4-mapped IPv6 address, it translates the IPv6 header of that packet into an IPv4 header. It then forwards the packet based on the IPv4 destination address. The original IPv6 header on the packet is removed and replaced by an IPv4 header. Except for ICMP packets the transport layer header and data portion of the packet are left unchanged.",
      "ja": "IPv6-to-IPV4 TranslatorがIPv4-Mapped IPv6アドレスにアドレス指定されたIPv6データグラムを受信すると、そのパケットのIPv6ヘッダーをIPv4ヘッダーに変換します。次に、IPv4宛先アドレスに基づいてパケットを転送します。パケットの元のIPv6ヘッダーが削除され、IPv4ヘッダーに置き換えられます。ICMPパケットを除き、トランスポートレイヤーヘッダーとパケットのデータ部分は変更されません。"
    },
    {
      "indent": 8,
      "text": "+-------------+                 +-------------+\n|    IPv6     |                 |    IPv4     |\n|   Header    |                 |   Header    |\n+-------------+                 +-------------+\n|  Fragment   |                 |  Transport  |\n|   Header    |      ===>       |   Layer     |\n|(if present) |                 |   Header    |\n+-------------+                 +-------------+\n|  Transport  |                 |             |\n|   Layer     |                 ~    Data     ~\n|   Header    |                 |             |\n+-------------+                 +-------------+\n|             |\n~    Data     ~\n|             |\n+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "IPv6-to-IPv4 Translation",
      "ja": "IPv6-to-IPV4翻訳"
    },
    {
      "indent": 3,
      "text": "There are some differences between IPv6 and IPv4 in the area of fragmentation and the minimum link MTU that effect the translation. An IPv6 link has to have an MTU of 1280 bytes or greater. The corresponding limit for IPv4 is 68 bytes. Thus, unless there were special measures, it would not be possible to do end-to-end path MTU discovery when the path includes an IPv6-to-IPv4 translator since the IPv6 node might receive ICMP \"packet too big\" messages originated by an IPv4 router that report an MTU less than 1280. However, [IPv6] requires that IPv6 nodes handle such an ICMP \"packet too big\" message by reducing the path MTU to 1280 and including an IPv6 fragment header with each packet. This allows end-to-end path MTU discovery across the translator as long as the path MTU is 1280 bytes or greater. When the path MTU drops below the 1280 limit the IPv6 sender will originate 1280 byte packets that will be fragmented by IPv4 routers along the path after being translated to IPv4.",
      "ja": "断片化の領域では、IPv6とIPv4と翻訳に影響を与える最小リンクMTUの間にはいくつかの違いがあります。IPv6リンクには、1280バイト以上のMTUが必要です。IPv4の対応する制限は68バイトです。したがって、特別な手段がない限り、IPv6ノードがICMP「パケットが大きすぎる」メッセージを受信する可能性があるため、パスにIPv6-to-IPV4翻訳者が含まれている場合、エンドツーエンドのパスMTU発見を行うことはできません。1280未満のMTUを報告するIPv4ルーター。ただし、[IPv6]では、IPv6ノードがそのようなICMP「パケットが大きすぎる」メッセージを1280に減らし、各パケットにIPv6フラグメントヘッダーを含めることにより、そのようなICMP「パケットが大きすぎる」メッセージを処理する必要があります。これにより、パスMTUが1280バイト以上である限り、翻訳者を横切るエンドツーエンドパスMTU発見が可能になります。パスMTUが1280の制限を下回ると、IPv6送信者は、IPv4に翻訳された後、パスに沿ってIPv4ルーターによって断片化される1280バイトパケットを発生します。"
    },
    {
      "indent": 3,
      "text": "The only drawback with this scheme is that it is not possible to use PMTU to do optimal UDP fragmentation (as opposed to completely avoiding fragmentation) at sender since the presence of an IPv6 Fragment header is interpreted that is it OK to fragment the packet on the IPv4 side. Thus if a UDP application wants to send large packets independent of the PMTU, the sender will only be able to determine the path MTU on the IPv6 side of the translator. If the path MTU on the IPv4 side of the translator is smaller then the IPv6 sender will not receive any ICMP \"too big\" errors and can not adjust the size fragments it is sending.",
      "ja": "このスキームの唯一の欠点は、IPv6フラグメントヘッダーの存在が解釈されるため、PMTUを使用して最適なUDPフラグメンテーション（完全に断片化を回避するのではなく）を送信者に行うことができないことです。IPv4サイド。したがって、UDPアプリケーションがPMTUから独立した大きなパケットを送信したい場合、送信者は翻訳者のIPv6側のパスMTUのみを決定できます。翻訳者のIPv4側のPATH MTUが小さい場合、IPv6送信者はICMPの「大きすぎる」エラーを受け取らず、送信しているサイズフラグメントを調整できません。"
    },
    {
      "indent": 3,
      "text": "Other than the special rules for handling fragments and path MTU discovery the actual translation of the packet header consists of a simple mapping as defined below. Note that ICMP packets require special handling in order to translate the content of ICMP error message and also to add the ICMP pseudo-header checksum.",
      "ja": "フラグメントとパスMTU発見の取り扱いの特別なルール以外に、パケットヘッダーの実際の翻訳は、以下に定義されている単純なマッピングで構成されています。ICMPエラーメッセージのコンテンツを翻訳し、ICMP擬似ヘッダーチェックサムを追加するには、ICMPパケットが特別な取り扱いが必要であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.1. Translating IPv6 Headers into IPv4 Headers",
      "section_title": true,
      "ja": "4.1. IPv6ヘッダーをIPv4ヘッダーに変換します"
    },
    {
      "indent": 3,
      "text": "If there is no IPv6 Fragment header the IPv4 header fields are set as follows:",
      "ja": "IPv6フラグメントヘッダーがない場合、IPv4ヘッダーフィールドは次のように設定されています。"
    },
    {
      "indent": 9,
      "text": "Version: 4",
      "ja": "バージョン：4"
    },
    {
      "indent": 9,
      "text": "Internet Header Length: 5 (no IPv4 options)",
      "ja": "インターネットヘッダーの長さ：5（IPv4オプションなし）"
    },
    {
      "indent": 9,
      "text": "Type of Service and Precedence: By default, copied from the IPv6 Traffic Class (all 8 bits). According to [DIFFSERV] the semantics of the bits are identical in IPv4 and IPv6. However, in some IPv4 environments these bits might be used with the old semantics of \"Type Of Service and Precedence\". An implementation of a translator SHOULD provide the ability to ignore the IPv6 traffic class and always set the IPv4 \"TOS\" to zero.",
      "ja": "サービスのタイプと優先順位：デフォルトでは、IPv6トラフィッククラス（8ビットすべて）からコピーされました。[diffserv]によると、ビットのセマンティクスはIPv4とIPv6で同一です。ただし、一部のIPv4環境では、これらのビットは「サービスの種類と優先順位」の古いセマンティクスで使用される場合があります。翻訳者の実装は、IPv6トラフィッククラスを無視し、常にIPv4 \"TOS\"をゼロに設定する機能を提供する必要があります。"
    },
    {
      "indent": 9,
      "text": "Total Length: Payload length value from IPv6 header, plus the size of the IPv4 header.",
      "ja": "合計長さ：IPv6ヘッダーからのペイロード長の値に加えて、IPv4ヘッダーのサイズ。"
    },
    {
      "indent": 9,
      "text": "Identification: All zero.",
      "ja": "識別：すべてゼロ。"
    },
    {
      "indent": 9,
      "text": "Flags: The More Fragments flag is set to zero. The Don't Fragments flag is set to one.",
      "ja": "フラグ：より多くのフラグメントフラグがゼロに設定されています。DONTフラグメントフラグは1つに設定されています。"
    },
    {
      "indent": 9,
      "text": "Fragment Offset: All zero.",
      "ja": "フラグメントオフセット：すべてゼロ。"
    },
    {
      "indent": 9,
      "text": "Time to Live: Hop Limit value copied from IPv6 header. Since the translator is a router, as part of forwarding the packet it needs to decrement either the IPv6 Hop Limit (before the translation) or the IPv4 TTL (after the translation). As part of decrementing the TTL or Hop Limit the translator (as any router) needs to check for zero and send the ICMPv4 or ICMPv6 \"ttl exceeded\" error.",
      "ja": "ライブの時間：IPv6ヘッダーからコピーされたホップ制限値。翻訳者はルーターであるため、パケットの転送の一環として、IPv6ホップ制限（翻訳前）またはIPv4 TTL（翻訳後）のいずれかを減らす必要があります。TTLまたはホップ制限の減少の一環として、翻訳者は（任意のルーターとして）ゼロをチェックし、ICMPV4またはICMPV6 \"TTLを超えた\"エラーを送信する必要があります。"
    },
    {
      "indent": 9,
      "text": "Protocol: Next Header field copied from IPv6 header.",
      "ja": "プロトコル：IPv6ヘッダーからコピーされた次のヘッダーフィールド。"
    },
    {
      "indent": 9,
      "text": "Header Checksum: Computed once the IPv4 header has been created.",
      "ja": "ヘッダーチェックサム：IPv4ヘッダーが作成されたら計算されます。"
    },
    {
      "indent": 9,
      "text": "Source Address: If the IPv6 source address is an IPv4-translated address then the low-order 32 bits of the IPv6 source address is copied to the IPv4 source address. Otherwise, the source address is set to 0.0.0.0. The use of 0.0.0.0 is to avoid completely dropping e.g. ICMPv6 error messages sent by IPv6-only routers which makes e.g. traceroute present something for the IPv6-only hops.",
      "ja": "ソースアドレス：IPv6ソースアドレスがIPv4翻訳アドレスである場合、IPv6ソースアドレスの低次の32ビットがIPv4ソースアドレスにコピーされます。それ以外の場合、ソースアドレスは0.0.0.0に設定されています。0.0.0.0の使用は、完全に低下することを避けるためです。IPv6のみのルーターによって送信されたICMPV6エラーメッセージ。Tracerouteは、IPv6のみのホップに何かを提示します。"
    },
    {
      "indent": 9,
      "text": "Destination Address: IPv6 packets that are translated have an IPv4-mapped destination address. Thus the low-order 32 bits of the IPv6 destination address is copied to the IPv4 destination address.",
      "ja": "宛先アドレス：翻訳されたIPv6パケットには、IPv4マップの宛先アドレスがあります。したがって、IPv6宛先アドレスの低次の32ビットがIPv4宛先アドレスにコピーされます。"
    },
    {
      "indent": 3,
      "text": "If any of an IPv6 hop-by-hop options header, destination options header, or routing header with the Segments Left field equal to zero are present in the IPv6 packet, they are ignored i.e., there is no attempt to translate them. However, the Total Length field and the Protocol field would have to be adjusted to \"skip\" these extension headers.",
      "ja": "IPv6ホップバイホップオプションヘッダー、宛先オプションヘッダー、またはゼロに等しい左フィールドを持つセグメントヘッダーがIPv6パケットに存在する場合、それらは無視されます。ただし、これらの拡張ヘッダーを「スキップ」するために、総長さフィールドとプロトコルフィールドを調整する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a routing header with a non-zero Segments Left field is present then the packet MUST NOT be translated, and an ICMPv6 \"parameter problem/ erroneous header field encountered\" (Type 4/Code 0) error message, with the Pointer field indicating the first byte of the Segments Left field, SHOULD be returned to the sender.",
      "ja": "ゼロ以外のセグメントの左フィールドを備えたルーティングヘッダーが存在する場合、パケットを翻訳してはならず、ICMPV6「パラメーター問題/誤ったヘッダーフィールドが遭遇する」（タイプ4/コード0）エラーメッセージ、ポインターフィールドはセグメントの最初のバイト左フィールドは、送信者に返される必要があります。"
    },
    {
      "indent": 3,
      "text": "If the IPv6 packet contains a Fragment header the header fields are set as above with the following exceptions:",
      "ja": "IPv6パケットにフラグメントヘッダーが含まれている場合、次の例外を除いて、ヘッダーフィールドが上記のように設定されています。"
    },
    {
      "indent": 9,
      "text": "Total Length: Payload length value from IPv6 header, minus 8 for the Fragment header, plus the size of the IPv4 header.",
      "ja": "合計長さ：IPv6ヘッダーからのペイロード長い値、フラグメントヘッダーのマイナス8、およびIPv4ヘッダーのサイズ。"
    },
    {
      "indent": 9,
      "text": "Identification: Copied from the low-order 16-bits in the Identification field in the Fragment header.",
      "ja": "識別：フラグメントヘッダーの識別フィールドの低次の16ビットからコピーされました。"
    },
    {
      "indent": 9,
      "text": "Flags: The More Fragments flag is copied from the M flag in the Fragment header. The Don't Fragments flag is set to zero allowing this packet to be fragmented by IPv4 routers.",
      "ja": "フラグ：フラグメントヘッダーのMフラグから、より多くのフラグメントフラグがコピーされます。DONTフラグメントフラグはゼロに設定されているため、このパケットをIPv4ルーターで断片化できます。"
    },
    {
      "indent": 9,
      "text": "Fragment Offset: Copied from the Fragment Offset field in the Fragment Header.",
      "ja": "フラグメントオフセット：フラグメントヘッダーのフラグメントオフセットフィールドからコピーされました。"
    },
    {
      "indent": 9,
      "text": "Protocol: Next Header value copied from Fragment header.",
      "ja": "プロトコル：フラグメントヘッダーからコピーされた次のヘッダー値。"
    },
    {
      "indent": 0,
      "text": "4.2. Translating ICMPv6 Headers into ICMPv4 Headers",
      "section_title": true,
      "ja": "4.2. ICMPV6ヘッダーをICMPV4ヘッダーに変換します"
    },
    {
      "indent": 3,
      "text": "All ICMP messages that are to be translated require that the ICMP checksum field be updated as part of the translation since ICMPv6, unlike ICMPv4, has a pseudo-header checksum just like UDP and TCP.",
      "ja": "翻訳されるすべてのICMPメッセージは、ICMPv6とは異なり、ICMPv6がUDPやTCPのように擬似ヘッダーチェックサムを持っているため、翻訳の一部としてICMPチェックサムフィールドを更新する必要があります。"
    },
    {
      "indent": 3,
      "text": "In addition all ICMP packets need to have the Type value translated and for ICMP error messages the included IP header also needs translation.",
      "ja": "さらに、すべてのICMPパケットがタイプ値を翻訳する必要があり、ICMPエラーメッセージの場合、含まれたIPヘッダーにも翻訳が必要です。"
    },
    {
      "indent": 3,
      "text": "The actions needed to translate various ICMPv6 messages are:",
      "ja": "さまざまなICMPV6メッセージを翻訳するために必要なアクションは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "ICMPv6 informational messages:",
      "ja": "ICMPV6情報メッセージ："
    },
    {
      "indent": 8,
      "text": "Echo Request and Echo Reply (Type 128 and 129) Adjust the type to 0 and 8, respectively, and adjust the ICMP checksum both to take the type change into account and to exclude the ICMPv6 pseudo-header.",
      "ja": "エコーリクエストとエコーの応答（タイプ128および129）は、それぞれタイプを0と8に調整し、ICMPチェックサムを調整して、タイプの変更を考慮し、ICMPV6 pseudo-headerを除外します。"
    },
    {
      "indent": 8,
      "text": "MLD Multicast Listener Query/Report/Done (Type 130, 131, 132) Single hop message. Silently drop.",
      "ja": "MLDマルチキャストリスナークエリ/レポート/完了（タイプ130、131、132）シングルホップメッセージ。静かに落ちます。"
    },
    {
      "indent": 8,
      "text": "Neighbor Discover messages (Type 133 through 137) Single hop message. Silently drop.",
      "ja": "Neighborはメッセージ（タイプ133〜137）シングルホップメッセージを発見します。静かに落ちます。"
    },
    {
      "indent": 8,
      "text": "Unknown informational messages Silently drop.",
      "ja": "未知の情報メッセージは静かにドロップします。"
    },
    {
      "indent": 6,
      "text": "ICMPv6 error messages:",
      "ja": "ICMPV6エラーメッセージ："
    },
    {
      "indent": 8,
      "text": "Destination Unreachable (Type 1) Set the Type field to 3. Translate the code field as follows: Code 0 (no route to destination): Set Code to 1 (host unreachable).",
      "ja": "宛先の到達不能（タイプ1）タイプフィールドを3に設定します。コードフィールドを次のように変換します：コード0（宛先へのルートなし）：コードを1（ホストなしの到達不可）に設定します。"
    },
    {
      "indent": 14,
      "text": "Code 1 (communication with destination administratively prohibited): Set Code to 10 (communication with destination host administratively prohibited).",
      "ja": "コード1（管理的に禁止されている宛先との通信）：コードを10に設定します（宛先ホストとの通信は管理上禁止されています）。"
    },
    {
      "indent": 14,
      "text": "Code 2 (beyond scope of source address): Set Code to 1 (host unreachable). Note that this error is very unlikely since the IPv4-translatable source address is considered to have global scope.",
      "ja": "コード2（ソースアドレスの範囲を超えて）：コードを1に設定します（到達不可能なホスト）。IPv4翻訳可能なソースアドレスにはグローバルな範囲があると見なされるため、このエラーは非常にありそうもないことに注意してください。"
    },
    {
      "indent": 14,
      "text": "Code 3 (address unreachable): Set Code to 1 (host unreachable).",
      "ja": "コード3（到達不可能なアドレス）：コードを1に設定します（到達不可能なホスト）。"
    },
    {
      "indent": 14,
      "text": "Code 4 (port unreachable): Set Code to 3 (port unreachable).",
      "ja": "コード4（到達不能）：コードを3（到達不能）に設定します。"
    },
    {
      "indent": 8,
      "text": "Packet Too Big (Type 2) Translate to an ICMPv4 Destination Unreachable with code 4. The MTU field needs to be adjusted for the difference between the IPv4 and IPv6 header sizes taking into account whether or not the packet in error includes a Fragment header.",
      "ja": "パケットが大きすぎる（タイプ2）コード4を使用して到達不可能なICMPV4宛先に変換されます。MTUフィールドは、IPv4とIPv6ヘッダーサイズの違いを考慮して、誤差のあるパケットにフラグメントヘッダーを含むかどうかを考慮して調整する必要があります。"
    },
    {
      "indent": 8,
      "text": "Time Exceeded (Type 3) Set the Type to 11. The Code field is unchanged.",
      "ja": "時間を超えた（タイプ3）タイプを11に設定します。コードフィールドは変更されていません。"
    },
    {
      "indent": 8,
      "text": "Parameter Problem (Type 4) If the Code is 1 translate this to an ICMPv4 protocol unreachable (Type 3, Code 2). Otherwise set the Type to 12 and the Code to zero. The Pointer needs to be updated to point to the corresponding field in the translated include IP header.",
      "ja": "パラメーター問題（タイプ4）コードが1の場合、これをICMPV4プロトコルに翻訳できない場合（タイプ3、コード2）。それ以外の場合は、タイプを12に設定し、コードをゼロに設定します。ポインターを更新して、翻訳されたIPヘッダーの対応するフィールドを指す必要があります。"
    },
    {
      "indent": 8,
      "text": "Unknown error messages Silently drop.",
      "ja": "不明なエラーメッセージは静かにドロップします。"
    },
    {
      "indent": 0,
      "text": "4.3. Translating ICMPv6 Error Messages into ICMPv4",
      "section_title": true,
      "ja": "4.3. ICMPV6エラーメッセージをICMPv4に変換します"
    },
    {
      "indent": 3,
      "text": "There are some differences between the IPv4 and the IPv6 ICMP error message formats as detailed above. In addition, the ICMP error messages contain the IP header for the packet in error which needs to be translated just like a normal IP header. The translation of this \"packet in error\" is likely to change the length of the datagram thus the Total Length field in the outer IPv4 header might need to be updated.",
      "ja": "上記のIPv4とIPv6 ICMPエラーメッセージフォーマットにはいくつかの違いがあります。さらに、ICMPエラーメッセージには、通常のIPヘッダーと同じように翻訳する必要があるエラーのパケットのIPヘッダーが含まれています。この「パケットの誤差」の変換は、データグラムの長さを変更する可能性が高いため、外側のIPv4ヘッダーの総長さフィールドを更新する必要がある場合があります。"
    },
    {
      "indent": 8,
      "text": "+-------------+                 +-------------+\n|    IPv6     |                 |    IPv4     |\n|   Header    |                 |   Header    |\n+-------------+                 +-------------+\n|   ICMPv6    |                 |   ICMPv4    |\n|   Header    |                 |   Header    |\n+-------------+                 +-------------+\n|    IPv6     |      ===>       |    IPv4     |\n|   Header    |                 |   Header    |\n+-------------+                 +-------------+\n|   Partial   |                 |   Partial   |\n|  Transport  |                 |  Transport  |\n|   Layer     |                 |   Layer     |\n|   Header    |                 |   Header    |\n+-------------+                 +-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "IPv6-to-IPv4 ICMP Error Translation",
      "ja": "IPv6-to-IPV4 ICMPエラー変換"
    },
    {
      "indent": 3,
      "text": "The translation of the inner IP header can be done by recursively invoking the function that translated the outer IP headers.",
      "ja": "内側のIPヘッダーの翻訳は、外側のIPヘッダーを変換する関数を再帰的に呼び出すことで実行できます。"
    },
    {
      "indent": 0,
      "text": "4.4. Knowing when to Translate",
      "section_title": true,
      "ja": "4.4. いつ翻訳するかを知っています"
    },
    {
      "indent": 3,
      "text": "When the translator receives an IPv6 packet with an IPv4-mapped destination address the packet will be translated to IPv4.",
      "ja": "翻訳者がIPv4マップの宛先アドレスを持つIPv6パケットを受信すると、パケットはIPv4に翻訳されます。"
    },
    {
      "indent": 0,
      "text": "5. Implications for IPv6-Only Nodes",
      "section_title": true,
      "ja": "5. IPv6のみのノードへの影響"
    },
    {
      "indent": 3,
      "text": "An IPv6-only node which works through SIIT translators need some modifications beyond a normal IPv6-only node.",
      "ja": "SIIT翻訳者を介して動作するIPv6のみのノードは、通常のIPv6のみのノードを超えていくつかの変更が必要です。"
    },
    {
      "indent": 3,
      "text": "As specified in Section 1.3 the application protocols need to handle operation on a dual stack node. In addition the protocol stack needs to be able to: o Determine when an IPv4-translatable address needs to be allocated and the allocation needs to be refreshed/renewed. This can presumably be done without involving the applications by e.g. handling this under the socket API. For instance, when the connect or sendto socket calls are invoked they could check if the destination is an IPv4-mapped address and in that case allocate/refresh the IPv4-translatable address.",
      "ja": "セクション1.3で指定されているように、アプリケーションプロトコルはデュアルスタックノードの操作を処理する必要があります。さらに、プロトコルスタックは次のことができる必要があります。oIPv4翻訳可能なアドレスを割り当てる必要がある場合、および割り当てを更新/更新する必要があります。これは、おそらくアプリケーションを巻き込まずに実行できます。これをソケットAPIで処理します。たとえば、ConnectまたはSendto Socket Callが呼び出されると、宛先がIPv4マップのアドレスであるかどうかを確認できます。"
    },
    {
      "indent": 3,
      "text": "o Ensure, as part of the source address selection mechanism, that when the destination address is an IPv4-mapped address the source address MUST be an IPv4-translatable address. And an IPv4- translatable address MUST NOT be used with other forms of IPv6 destination addresses.",
      "ja": "o ソースアドレスの選択メカニズムの一部として、宛先アドレスがIPv4マップアドレスである場合、ソースアドレスがIPv4翻訳可能なアドレスでなければならないことを確認してください。IPv4-翻訳可能なアドレスは、他の形式のIPv6宛先アドレスで使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "o Should the peer have AAAA/A6 address records the application (or resolver) SHOULD never fall back to looking for A address records even if communication fails using the available AAAA/A6 records. The reason for this restriction is to prevent traffic between two IPv6 nodes (which AAAA/A6 records in the DNS) from accidentally going through SIIT translators twice; from IPv6 to IPv4 and to IPv6 again. It is considered preferable to instead signal a failure to communicate to the application.",
      "ja": "o ピアがAAAA/A6アドレスレコードを持っている場合、アプリケーション（またはリゾルバー）は、利用可能なAAAA/A6レコードを使用して通信が失敗した場合でも、アドレスレコードを探すことに決して頼らないでください。この制限の理由は、2つのIPv6ノード（DNSにAAAA/A6が記録）間のトラフィックを防ぐことが誤ってSIIT翻訳者を2回通過することです。IPv6からIPv4、およびIPv6に再び。代わりに、アプリケーションとの通信の失敗を通知することが望ましいと考えられています。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The use of stateless IP/ICMP translators does not introduce any new security issues beyond the security issues that are already present in the IPv4 and IPv6 protocols and in the routing protocols which are used to make the packets reach the translator.",
      "ja": "Stateless IP/ICMP翻訳者の使用は、IPv4およびIPv6プロトコル、およびパケットが翻訳者に届くために使用されるルーティングプロトコルに既に存在するセキュリティ問題を超えた新しいセキュリティ問題を導入しません。"
    },
    {
      "indent": 3,
      "text": "As the Authentication Header [IPv6-AUTH] is specified to include the IPv4 Identification field and the translating function not being able to always preserve the Identification field, it is not possible for an IPv6 endpoint to compute AH on received packets that have been translated from IPv4 packets. Thus AH does not work through a translator.",
      "ja": "認証ヘッダー[IPv6-Auth]は、IPv4識別フィールドと翻訳機能が常に識別フィールドを保持できないように指定されているため、IPv6エンドポイントは、IPv4パケット。したがって、AHは翻訳者を介して機能しません。"
    },
    {
      "indent": 3,
      "text": "Packets with ESP can be translated since ESP does not depend on header fields prior to the ESP header. Note that ESP transport mode is easier to handle than ESP tunnel mode; in order to use ESP tunnel mode the IPv6 node needs to be able to generate an inner IPv4 header when transmitting packets and remove such an IPv4 header when receiving packets.",
      "ja": "ESPは、ESPヘッダーの前にヘッダーフィールドに依存しないため、ESPのパケットを翻訳できます。ESPトランスポートモードは、ESPトンネルモードよりも処理しやすいことに注意してください。ESPトンネルモードを使用するために、IPv6ノードは、パケットを送信するときに内側のIPv4ヘッダーを生成し、パケットを受信するときにそのようなIPv4ヘッダーを削除できる必要があります。"
    },
    {
      "indent": 0,
      "text": "References",
      "ja": "参考文献"
    },
    {
      "indent": 3,
      "text": "[KEYWORDS] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[キーワード] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[IPv6] Deering, S. and R. Hinden, Editors, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[IPv6] Deering、S。およびR. Hinden、編集者、「インターネットプロトコル、バージョン6（IPv6）仕様」、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[IPv4] Postel, J., \"Internet Protocol\", STD 5, RFC 791, September 1981.",
      "ja": "[IPv4] Postel、J。、「インターネットプロトコル」、STD 5、RFC 791、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[ADDR-ARCH] Deering, S. and R. Hinden, Editors, \"IP Version 6 Addressing Architecture\", RFC 2373, July 1998.",
      "ja": "[Addr-Arch] Deering、S。and R. Hinden、編集者、「IPバージョン6アドレス指定アーキテクチャ」、RFC 2373、1998年7月。"
    },
    {
      "indent": 3,
      "text": "[TRANS-MECH] Gilligan, R. and E. Nordmark, \"Transition Mechanisms for IPv6 Hosts and Routers\", RFC 1933, April 1996.",
      "ja": "[Trans-Mech] Gilligan、R。およびE. Nordmark、「IPv6ホストとルーターの遷移メカニズム」、RFC 1933、1996年4月。"
    },
    {
      "indent": 3,
      "text": "[DISCOVERY] Narten, T., Nordmark, E. and W. Simpson, \"Neighbor Discovery for IP Version 6 (IPv6)\", RFC 2461, December 1998.",
      "ja": "[発見] Narten、T.、Nordmark、E。and W. Simpson、「IPバージョン6（IPv6）の近隣発見」、RFC 2461、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[IPv6-SA] Atkinson, R., \"Security Architecture for the Internet Protocol\", RFC 2401, November 1998.",
      "ja": "[IPv6-SA] Atkinson、R。、「インターネットプロトコルのセキュリティアーキテクチャ」、RFC 2401、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[IPv6-AUTH] Atkinson, R., \"IP Authentication Header\", RFC 2402, November 1998.",
      "ja": "[IPv6-Auth] Atkinson、R。、「IP認証ヘッダー」、RFC 2402、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[IPv6-ESP] Atkinson, R., \"IP Encapsulating Security Payload (ESP)\", RFC 2406, November 1998.",
      "ja": "[IPv6-ESP] Atkinson、R。、「IPカプセル化セキュリティペイロード（ESP）」、RFC 2406、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[ICMPv4] Postel, J., \"Internet Control Message Protocol\", STD 5, RFC 792, September 1981.",
      "ja": "[ICMPV4] Postel、J。、「インターネット制御メッセージプロトコル」、STD 5、RFC 792、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[ICMPv6] Conta, A. and S. Deering, \"Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6)\", RFC 2463, December 1998.",
      "ja": "[ICMPV6] Conta、A。およびS. Deering、「インターネットプロトコルバージョン6（IPv6）のインターネット制御メッセージプロトコル（ICMPV6）」、RFC 2463、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[IGMP] Deering, S., \"Host extensions for IP multicasting\", STD 5, RFC 1112, August 1989.",
      "ja": "[IGMP] Deering、S。、「IPマルチキャストのホスト拡張」、STD 5、RFC 1112、1989年8月。"
    },
    {
      "indent": 3,
      "text": "[PMTUv4] Mogul, J. and S. Deering, \"Path MTU Discovery\", RFC 1191, November 1990.",
      "ja": "[PMTUV4] Mogul、J。およびS. Deering、「Path MTU Discovery」、RFC 1191、1990年11月。"
    },
    {
      "indent": 3,
      "text": "[PMTUv6] McCann, J., Deering, S. and J. Mogul, \"Path MTU Discovery for IP version 6\", RFC 1981, August 1996.",
      "ja": "[PMTUV6] McCann、J.、Deering、S。、およびJ. Mogul、「IPバージョン6のPath MTU Discovery」、RFC 1981、1996年8月。"
    },
    {
      "indent": 3,
      "text": "[DIFFSERV] Nichols, K., Blake, S., Baker, F. and D. Black, \"Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers\", RFC 2474, December 1998.",
      "ja": "[Diffserv] Nichols、K.、Blake、S.、Baker、F。、およびD. Black、「IPv4およびIPv6ヘッダーの差別化されたサービスフィールド（DSフィールド）の定義」、RFC 2474、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[MLD] Deering, S., Fenner, W. and B. Haberman, \"Multicast Listener Discovery (MLD) for IPv6\", RFC 2710, October 1999.",
      "ja": "[MLD] Deering、S.、Fenner、W。and B. Haberman、「IPv6のマルチキャストリスナーディスカバリー（MLD）」、RFC 2710、1999年10月。"
    },
    {
      "indent": 3,
      "text": "[FTPEXT] Allman, M., Ostermann, S. and C. Metz, \"FTP Extensions for IPv6 and NATs.\", RFC 2428, September 1998.",
      "ja": "[ftpext] Allman、M.、Ostermann、S。and C. Metz、「IPv6およびNatsのFTP拡張機能」、RFC 2428、1998年9月。"
    },
    {
      "indent": 3,
      "text": "[MILLER] G. Miller, Email to the ngtrans mailing list on 26 March 1999.",
      "ja": "[ミラー] G.ミラー、1999年3月26日のNGTRANSメーリングリストにメール。"
    },
    {
      "indent": 3,
      "text": "[BSDAPI] Gilligan, R., Thomson, S., Bound, J. and W. Stevens, \"Basic Socket Interface Extensions for IPv6\", RFC 2553, March 1999.",
      "ja": "[BSDAPI] Gilligan、R.、Thomson、S.、Bound、J。and W. Stevens、「IPv6用の基本ソケットインターフェイス拡張」、RFC 2553、1999年3月。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者の連絡先"
    },
    {
      "indent": 3,
      "text": "Erik Nordmark Sun Microsystems, Inc. 901 San Antonio Road Palo Alto, CA 94303 USA",
      "ja": "Erik Nordmark Sun Microsystems、Inc。901 San Antonio Road Palo Alto、CA 94303 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 650 786 5166\nFax:   +1 650 786 5896\nEMail: nordmark@sun.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2000). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2000）。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書と本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}