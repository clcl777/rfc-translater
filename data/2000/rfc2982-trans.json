{
  "title": {
    "text": "RFC 2982 - Distributed Management Expression MIB",
    "ja": "RFC 2982 - 分散管理式MIB"
  },
  "number": 2982,
  "created_at": "2024-01-04 07:17:32.892812+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                       R. Kavasseri\nRequest for Comments: 2982                      (Editor of this version)\nCategory: Standards Track                                     B. Stewart\n                                            (Author of previous version)\n                                                     Cisco Systems, Inc.\n                                                            October 2000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Distributed Management Expression MIB",
      "ja": "分散管理式MIB"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2000). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2000）。無断転載を禁じます。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This memo defines a portion of the Management Information Base (MIB) for use with network management protocols in the Internet community. In particular, it describes managed objects used for managing expressions of MIB objects. The results of these expressions become MIB objects usable like any other MIB object, such as for the test condition for declaring an event.",
      "ja": "このメモは、インターネットコミュニティのネットワーク管理プロトコルで使用するための管理情報ベース（MIB）の一部を定義します。特に、MIBオブジェクトの表現の管理に使用される管理されたオブジェクトについて説明します。これらの式の結果は、イベントを宣言するテスト条件など、他のMIBオブジェクトと同様に使用可能なMIBオブジェクトになります。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.",
      "ja": "「必須」、「そうしない」、「必須」、「必要」、「「しない」、「そうでない」、「そうではない」、「そうでない」、「推奨」、「5月」、および「オプション」は、RFC 2119に記載されているとおりに解釈されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1 The SNMP Management Framework ...............................    2\n2 Overview ....................................................    3\n2.1 Usage .....................................................    4\n2.2 Persistence ...............................................    4\n2.3 Operation .................................................    4\n2.3.1 Sampling ................................................    5\n2.3.2 Wildcards ...............................................    5\n2.3.3 Evaluation ..............................................    5\n2.3.4 Value Identification ....................................    6\n2.4 Subsets ...................................................    6\n2.4.1 No Wildcards ............................................    6\n   2.4.2 No Deltas ...............................................    7\n2.5 Structure .................................................    7\n2.5.1 Resource ................................................    7\n2.5.2 Definition ..............................................    7\n2.5.3 Value ...................................................    8\n2.6 Examples ..................................................    8\n2.6.1 Wildcarding .............................................    8\n2.6.2 Calculation and Conditional .............................   10\n3 Definitions .................................................   12\n4 Intellectual Property .......................................   36\n5 Acknowledgements ............................................   37\n6 References ..................................................   37\n7 Security Considerations .....................................   38\n8 Author's Address ............................................   40\n9 Editor's Address ............................................   40\n10 Full Copyright Statement ...................................   41",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. The SNMP Management Framework",
      "section_title": true,
      "ja": "1. SNMP管理フレームワーク"
    },
    {
      "indent": 3,
      "text": "The SNMP Management Framework presently consists of five major components:",
      "ja": "SNMP管理フレームワークは現在、5つの主要なコンポーネントで構成されています。"
    },
    {
      "indent": 4,
      "text": "o An overall architecture, described in RFC 2571 [RFC2571].",
      "ja": "o RFC 2571 [RFC2571]に記載されている全体的なアーキテクチャ。"
    },
    {
      "indent": 4,
      "text": "o Mechanisms for describing and naming objects and events for the purpose of management. The first version of this Structure of Management Information (SMI) is called SMIv1 and described in STD 16, RFC 1155 [RFC1155], STD 16, RFC 1212 [RFC1212] and RFC 1215 [RFC1215]. The second version, called SMIv2, is described in STD 58, RFC 2578 [RFC2578], STD 58, RFC 2579 [RFC2579] and STD 58, RFC 2580 [RFC2580].",
      "ja": "o 管理を目的としたオブジェクトとイベントを説明および名前を付けるためのメカニズム。この管理情報の最初のバージョン（SMI）はSMIV1と呼ばれ、STD 16、RFC 1155 [RFC1155]、STD 16、RFC 1212 [RFC1212]およびRFC 1215 [RFC1215]で説明されています。SMIV2と呼ばれる2番目のバージョンは、STD 58、RFC 2578 [RFC2578]、STD 58、RFC 2579 [RFC2579]およびSTD 58、RFC 2580 [RFC2580]に記載されています。"
    },
    {
      "indent": 4,
      "text": "o Message protocols for transferring management information. The first version of the SNMP message protocol is called SNMPv1 and described in STD 15, RFC 1157 [RFC1157]. A second version of the SNMP message protocol, which is not an Internet standards track protocol, is called SNMPv2c and described in RFC 1901 [RFC1901] and RFC 1906 [RFC1906]. The third version of the message protocol is called SNMPv3 and described in RFC 1906 [RFC1906], RFC 2572 [RFC2572] and RFC 2574 [RFC2574].",
      "ja": "o 管理情報を転送するためのメッセージプロトコル。SNMPメッセージプロトコルの最初のバージョンはSNMPV1と呼ばれ、STD 15、RFC 1157 [RFC1157]で説明されています。インターネット標準トラックプロトコルではないSNMPメッセージプロトコルの2番目のバージョンは、SNMPV2Cと呼ばれ、RFC 1901 [RFC1901]およびRFC 1906 [RFC1906]で説明されています。メッセージプロトコルの3番目のバージョンはSNMPV3と呼ばれ、RFC 1906 [RFC1906]、RFC 2572 [RFC2572]およびRFC 2574 [RFC2574]で説明されています。"
    },
    {
      "indent": 4,
      "text": "o Protocol operations for accessing management information. The first set of protocol operations and associated PDU formats is described in STD 15, RFC 1157 [RFC1157]. A second set of protocol operations and associated PDU formats is described in RFC 1905 [RFC1905].",
      "ja": "o 管理情報にアクセスするためのプロトコル操作。プロトコル操作の最初のセットと関連するPDU形式は、STD 15、RFC 1157 [RFC1157]で説明されています。プロトコル操作の2番目のセットと関連するPDU形式は、RFC 1905 [RFC1905]で説明されています。"
    },
    {
      "indent": 4,
      "text": "o A set of fundamental applications described in RFC 2573 [RFC2573] and the view-based access control mechanism described in RFC 2575 [RFC2575].",
      "ja": "o RFC 2573 [RFC2573]に記載されている一連の基本的なアプリケーションと、RFC 2575 [RFC2575]で説明されているビューベースのアクセス制御メカニズム。"
    },
    {
      "indent": 3,
      "text": "A more detailed introduction to the current SNMP Management Framework can be found in RFC 2570 [RFC2570].",
      "ja": "現在のSNMP管理フレームワークのより詳細な紹介は、RFC 2570 [RFC2570]にあります。"
    },
    {
      "indent": 3,
      "text": "Managed objects are accessed via a virtual information store, termed the Management Information Base or MIB. Objects in the MIB are defined using the mechanisms defined in the SMI.",
      "ja": "管理されたオブジェクトは、管理情報ベースまたはMIBと呼ばれる仮想情報ストアからアクセスされます。MIBのオブジェクトは、SMIで定義されたメカニズムを使用して定義されます。"
    },
    {
      "indent": 3,
      "text": "This memo specifies a MIB module that is compliant to the SMIv2. A MIB conforming to the SMIv1 can be produced through the appropriate translations. The resulting translated MIB must be semantically equivalent, except where objects or events are omitted because no translation is possible (use of Counter64). Some machine readable information in SMIv2 will be converted into textual descriptions in SMIv1 during the translation process. However, this loss of machine readable information is not considered to change the semantics of the MIB.",
      "ja": "このメモは、SMIV2に準拠したMIBモジュールを指定します。SMIV1に準拠するMIBは、適切な翻訳を通じて生成できます。結果として生じる翻訳されたMIBは、翻訳が不可能であるためオブジェクトまたはイベントが省略されている場合を除き、意味的に同等でなければなりません（Counter64の使用）。SMIV2の一部の機械読み取り可能な情報は、翻訳プロセス中にSMIV1のテキスト説明に変換されます。ただし、この機械の読み取り可能な情報の損失は、MIBのセマンティクスを変更するとは見なされません。"
    },
    {
      "indent": 0,
      "text": "2. Overview",
      "section_title": true,
      "ja": "2. 概要"
    },
    {
      "indent": 3,
      "text": "Users of MIBs often desire MIB objects that MIB designers have not provided. Furthermore, such needs vary from one management philosophy to another. Rather than fill more and more MIBs with standardized objects, the Expression MIB supports externally defined expressions of existing MIB objects.",
      "ja": "MIBSのユーザーは、MIBデザイナーが提供していないMIBオブジェクトを望んでいます。さらに、そのようなニーズは、管理哲学によって別の管理哲学によって異なります。標準化されたオブジェクトでますます多くのMIBを埋めるのではなく、MIB式は、既存のMIBオブジェクトの外部から定義された式をサポートします。"
    },
    {
      "indent": 3,
      "text": "In the Expression MIB the results of an evaluated expression are MIB objects that may be used like any other MIB objects. These custom-defined objects are thus usable anywhere any other MIB object can be used. For example, they can be used by a management application directly or referenced from another MIB, such as the Event MIB [MIBEventMIB]. They can even be used by the Expression MIB itself, forming expressions of expressions.",
      "ja": "式MIBでは、評価された式の結果は、他のMIBオブジェクトと同様に使用できるMIBオブジェクトです。したがって、これらのカスタム定義のオブジェクトは、他のMIBオブジェクトを使用できる場所で使用できます。たとえば、それらは、イベントMIB [MibeventMib]など、管理アプリケーションで直接使用するか、別のMIBから参照することができます。それらは、MIB式自体によって使用さえ、表現の表現を形成することさえできます。"
    },
    {
      "indent": 3,
      "text": "The Expression MIB is instrumentation for a relatively powerful, complex, high-level application, considerably different from simple instrumentation for a communication driver or a protocol. The MIB is appropriate in a relatively powerful, resource-rich managed system and not necessarily in a severely limited environment.",
      "ja": "Expression MIBは、比較的強力で複雑な高レベルのアプリケーションのための計装であり、通信ドライバーやプロトコルの単純な計装とはかなり異なります。MIBは、比較的強力でリソースが豊富な管理システムで適切であり、必ずしも限られた環境ではそうではありません。"
    },
    {
      "indent": 3,
      "text": "Nevertheless, due to dependencies from the Event MIB [RFC2981] and the need to support as low-end a system as possible, the Expression MIB can be somewhat stripped down for lower-power, lower-resource implementations, as described in the Subsets section, below.",
      "ja": "それにもかかわらず、イベントMIB [RFC2981]からの依存関係と、可能な限りローエンドのシステムをサポートする必要性により、サブセットセクションで説明されているように、低出力の低いリソースの実装のためにMIBをある程度剥がすことができます。、 下に。"
    },
    {
      "indent": 3,
      "text": "Implementation of the Expression MIB in a managed system led to the addition of objects that may not have been necessary in an application environment with complete knowledge of compiled MIB definitions. This is appropriate since implementation must be possible within typical managed systems with some constraints on system resources.",
      "ja": "管理されたシステムでの式MIBの実装により、コンパイルされたMIB定義の完全な知識があるアプリケーション環境では必要ないオブジェクトが追加されました。これは、システムリソースに何らかの制約がある典型的な管理システム内で実装が可能でなければならないため、適切です。"
    },
    {
      "indent": 0,
      "text": "2.1. Usage",
      "section_title": true,
      "ja": "2.1. 使用法"
    },
    {
      "indent": 3,
      "text": "On managed systems that can afford the overhead, the Expression MIB is a way to create new, customized MIB objects for monitoring. Although these can save some network traffic and overhead on management systems, that is often not a good tradeoff for objects that are simply to be recorded or displayed.",
      "ja": "オーバーヘッドを提供できる管理されたシステムでは、式MIBは、監視用の新しいカスタマイズされたMIBオブジェクトを作成する方法です。これらは管理システム上のネットワークトラフィックとオーバーヘッドを節約できますが、それは多くの場合、単に記録または表示されるオブジェクトの良いトレードオフではありません。"
    },
    {
      "indent": 3,
      "text": "An example of a use of the Expression MIB would be to provide custom objects for the Event MIB [RFC2981]. A complex expression can evaluate to a rate of flow or a boolean and thus be subject to testing as an event trigger, resulting in an SNMP notification. Without these capabilities such monitoring would be limited to the objects in predefined MIBs. The Expression MIB thus supports powerful tools for the network manager faced with the monitoring of large, complex systems that can support a significant level of self management.",
      "ja": "MIB式の使用の例は、イベントMIB [RFC2981]にカスタムオブジェクトを提供することです。複雑な式は、流量またはブール値を評価することができ、イベントトリガーとしてテストを受けることができ、SNMP通知をもたらします。これらの機能がなければ、そのような監視は、事前定義されたMIBSのオブジェクトに限定されます。したがって、MIBという表現は、重要なレベルの自己管理をサポートできる、大規模で複雑なシステムの監視に直面したネットワークマネージャーの強力なツールをサポートしています。"
    },
    {
      "indent": 0,
      "text": "2.2. Persistence",
      "section_title": true,
      "ja": "2.2. 持続性"
    },
    {
      "indent": 3,
      "text": "Although like most MIBs this one has no explicit controls for the persistence of the values set in configuring an expression, a robust, polite implementation would certainly not force its managing applications to reconfigure it whenever it resets.",
      "ja": "ほとんどのMIBSと同様に、これには式の構成に設定された値の持続性の明示的な制御はありませんが、堅牢で丁寧な実装は、リセットされるたびにその管理アプリケーションに再構成を強制することはありません。"
    },
    {
      "indent": 3,
      "text": "Again, as with most MIBs, it is implementation specific how a system provides and manages such persistence. To speculate, one could imagine, for example, that persistence depended on the context in which the expression was configured, or perhaps system-specific characteristics of the expression's owner. Or perhaps everything in a MIB such as this one, which is clearly aimed at persistent configuration, is automatically part of a system's other persistent configuration.",
      "ja": "繰り返しますが、ほとんどのMIBSと同様に、システムがそのような持続性をどのように提供および管理するかは実装具体です。推測すると、たとえば、式が構成されたコンテキスト、またはおそらく式の所有者のシステム固有の特性に依存することを想像することができます。または、このようなMIBのすべてが、明らかに永続的な構成を目的としていることは、システムの他の永続的な構成の一部です。"
    },
    {
      "indent": 0,
      "text": "2.3. Operation",
      "section_title": true,
      "ja": "2.3. 手術"
    },
    {
      "indent": 3,
      "text": "Most of the operation of the MIB is described or implied in the object definitions but a few highlights bear mentioning here.",
      "ja": "MIBの操作のほとんどは、オブジェクト定義で説明または暗示されていますが、ここで言及されているハイライトにはいくつかのハイライトが付いています。"
    },
    {
      "indent": 0,
      "text": "2.3.1. Sampling",
      "section_title": true,
      "ja": "2.3.1. サンプリング"
    },
    {
      "indent": 3,
      "text": "The MIB supports three types of object sampling for the MIB objects that make up the expression: absolute, delta, and changed.",
      "ja": "MIBは、式を構成するMIBオブジェクトの3種類のオブジェクトサンプリングをサポートします：絶対、デルタ、および変更されました。"
    },
    {
      "indent": 3,
      "text": "Absolute samples are simply the value of the MIB object at the time it is sampled.",
      "ja": "絶対サンプルは、サンプリングされた時点でのMIBオブジェクトの値にすぎません。"
    },
    {
      "indent": 3,
      "text": "Absolute samples are not sufficient for expressions of counters, as counters have meaning only as a delta (difference) from one sample to the next. Thus objects may be sampled as deltas. Delta sampling requires the application to maintain state for the value at the last sample, and to do continuous sampling whether or not anyone is looking at the results. It thus creates constant overhead.",
      "ja": "カウンターは、サンプルから次のサンプルまでのデルタ（差）としてのみ意味があるため、カウンターの表現には絶対サンプルでは十分ではありません。したがって、オブジェクトはデルタとしてサンプリングされる場合があります。Deltaサンプリングでは、最後のサンプルで値に対して状態を維持し、結果を見ているかどうかにかかわらず、継続的なサンプリングを行うためにアプリケーションが必要です。したがって、一定のオーバーヘッドを作成します。"
    },
    {
      "indent": 3,
      "text": "Changed sampling is a simple fallout of delta sampling where rather than a difference the result is a boolean indicating whether or not the object changed value since the last sample.",
      "ja": "変更されたサンプリングは、デルタサンプリングの単純な放射性降下物であり、違いではなく、結果は最後のサンプル以降にオブジェクトが値を変更したかどうかを示すブール値です。"
    },
    {
      "indent": 0,
      "text": "2.3.2. Wildcards",
      "section_title": true,
      "ja": "2.3.2. ワイルドカード"
    },
    {
      "indent": 3,
      "text": "Wildcards allow the application of a single expression to multiple instances of the same MIB object. The definer of the expression indicates this choice and provides a partial object identifier, with some or all of the instance portion left off. The application then does the equivalent of GetNext to obtain the object values, thus discovering the instances.",
      "ja": "ワイルドカードにより、同じMIBオブジェクトの複数のインスタンスに単一の式を適用できます。式の定義者はこの選択を示し、部分的なオブジェクト識別子を提供し、いくつかまたはすべてのインスタンス部分が除外されています。アプリケーションは、GetNextに相当するものを行い、オブジェクト値を取得し、インスタンスを発見します。"
    },
    {
      "indent": 3,
      "text": "All wildcarded objects in an expression must have the same semantics for the missing portion of their object identifiers. Otherwise, any successful evaluation of the wildcarded expression would be the result of the accidental matching of the wildcarded portion of the object identifiers in the expression. Such an evaluation will likely produce results which are not meaningful.",
      "ja": "式のすべてのワイルドカードオブジェクトは、オブジェクト識別子の欠落部分に対して同じセマンティクスを持たなければなりません。それ以外の場合、ワイルドカードされた式の評価が成功したことは、式のオブジェクト識別子のワイルドカード部分の偶発的な一致の結果です。このような評価は、意味のない結果を生み出す可能性があります。"
    },
    {
      "indent": 3,
      "text": "The expression can be evaluated only for those instances where all the objects in the expression are available with the same value for the wildcarded portion of the instance.",
      "ja": "式は、式のすべてのオブジェクトがインスタンスのワイルドカード部分に対して同じ値で利用可能であるインスタンスについてのみ評価できます。"
    },
    {
      "indent": 0,
      "text": "2.3.3. Evaluation",
      "section_title": true,
      "ja": "2.3.3. 評価"
    },
    {
      "indent": 3,
      "text": "There are two important aspects of evaluation that may not be obvious: what objects and when.",
      "ja": "評価には、明らかではないかもしれない2つの重要な側面があります。"
    },
    {
      "indent": 3,
      "text": "What objects get used in the evaluation depends on the type of request and whether or not the expression contains wildcarded objects. If the request was a Get, that locks down the instances to be used. If the request was a GetNext or GetBulk, the application must work its way up to the next full set of objects for the expression.",
      "ja": "評価で使用されるオブジェクトは、リクエストのタイプと、式にワイルドカードされたオブジェクトが含まれているかどうかによって異なります。リクエストがGETの場合、使用するインスタンスをロックします。リクエストがgetNextまたはgetBulkである場合、アプリケーションは式の次のフルセットのオブジェクトまで動作する必要があります。"
    },
    {
      "indent": 3,
      "text": "Evaluation of expressions happens at two possible times, depending on the sampling method (delta or absolute) used to evaluate the expression.",
      "ja": "式の評価は、式の評価に使用されるサンプリング方法（デルタまたは絶対）に応じて、2回の可能な時間で発生します。"
    },
    {
      "indent": 3,
      "text": "If there are no delta or change values in an expression, the evaluation occurs on demand, i.e. when a requester attempts to read the value of the expression. In this case all requesters get a freshly calculated value.",
      "ja": "式にデルタまたは変更値がない場合、評価はオンデマンドで、つまり、リクエスターが式の値を読み取ろうとするときに発生します。この場合、すべての要求者は新たに計算された値を取得します。"
    },
    {
      "indent": 3,
      "text": "For expressions with delta or change values, evaluation goes on continuously, every sample period. In this case requesters get the value as of the last sample period. For any given sample period of a given expression, only those instances exist that provided a full set of object values. It may be possible that a delta expression which was evaluated successfully for one sample period may not be successfully evaluated in the next sample period. This may, for example, be due to missing instances for some or all of the objects in the expression. In such cases, the value from the previous sample period (with the successful evaluation) must not be carried forward to the next sample period (with the failed evaluation).",
      "ja": "デルタまたは変化の値を使用した表現の場合、評価は継続的に続き、すべてのサンプル期間が続きます。この場合、要求者は最後のサンプル期間時点で値を取得します。特定の式の任意のサンプル期間について、オブジェクト値の完全なセットを提供するインスタンスのみが存在します。1つのサンプル期間で正常に評価されたデルタ式が、次のサンプル期間で正常に評価されない可能性があります。たとえば、これは、式の一部またはすべてのオブジェクトのインスタンスが欠落しているためである可能性があります。そのような場合、前のサンプル期間（評価が成功した場合）の値を、次のサンプル期間（評価に失敗した場合）に繰り越すべきではありません。"
    },
    {
      "indent": 0,
      "text": "2.3.4. Value Identification",
      "section_title": true,
      "ja": "2.3.4. 値識別"
    },
    {
      "indent": 3,
      "text": "Values resulting from expression evaluation are identified with a combination of the object identifier (OID) for the data type from expValueTable (such as expValueCounter32Val), the expression owner, the expression name, and an OID fragment.",
      "ja": "式評価に起因する値は、ExpvalueTable（Expvaluecounter32Valなど）、式の所有者、式名、およびOIDフラグメントのデータ型のオブジェクト識別子（OID）の組み合わせで識別されます。"
    },
    {
      "indent": 3,
      "text": "The OID fragment is not an entire OID beginning with iso.dod.org (1.3.6). Rather it begins with 0.0. The remainder is either another 0 when there is no wildcarding or the instance that satisfied the wildcard if there is wildcarding.",
      "ja": "oidフラグメントは、iso.dod.org（1.3.6）で始まるoid全体ではありません。むしろ、0.0から始まります。残りは、ワイルドカードがない場合の別の0またはワイルドカードがある場合にワイルドカードを満たしたインスタンスのいずれかです。"
    },
    {
      "indent": 0,
      "text": "2.4. Subsets",
      "section_title": true,
      "ja": "2.4. サブセット"
    },
    {
      "indent": 3,
      "text": "To pare down the Expression MIBs complexity and use of resources an implementor can leave out various parts.",
      "ja": "MIBSの複雑さとリソースの使用を表現するために、実装者はさまざまな部分を除外できます。"
    },
    {
      "indent": 0,
      "text": "2.4.1. No Wildcards",
      "section_title": true,
      "ja": "2.4.1. ワイルドカードはありません"
    },
    {
      "indent": 3,
      "text": "Leaving out wildcarding significantly reduces the complexity of retrieving values to evaluate expressions and the processing required to do so. Such an implementation would allow expressions made up of individual MIB objects but would not be suitable for expressions applied across large tables as each instance in the table would require a separate expression definition.",
      "ja": "ワイルドカードを除外すると、値を取得するために値を取得する複雑さと、そうするために必要な処理が大幅に減少します。このような実装では、個々のMIBオブジェクトで構成される式が可能になりますが、テーブル内の各インスタンスには個別の式定義が必要になるため、大きなテーブルに適用される式には適していません。"
    },
    {
      "indent": 3,
      "text": "Furthermore it would not be suitable for tables with arbitrary, dynamic instances, as expressions definitions could not predict what instance values to use.",
      "ja": "さらに、式の定義では使用するインスタンス値を予測できなかったため、任意の動的インスタンスを持つテーブルには適していません。"
    },
    {
      "indent": 3,
      "text": "An implementation without wildcards might be useful for a self-managing system with small tables or few dynamic instances, or one that can do calculations only for a few key objects.",
      "ja": "ワイルドカードのない実装は、小さなテーブルまたは動的なインスタンスが少ない自己管理システム、またはいくつかの重要なオブジェクトでのみ計算を行うことができるものに役立つ場合があります。"
    },
    {
      "indent": 0,
      "text": "2.4.2. No Deltas",
      "section_title": true,
      "ja": "2.4.2. デルタはありません"
    },
    {
      "indent": 3,
      "text": "Leaving out delta processing significantly reduces state that must be kept and the burden of ongoing processing even when no one is looking at the results. Unfortunately it also makes expressions on counters unusable, as counters have meaning only as deltas.",
      "ja": "デルタ処理を除外すると、維持する必要がある状態と、誰も結果を見ていなくても、継続的な処理の負担が大幅に減少します。残念ながら、カウンターはデルタとしてのみ意味があるため、カウンターでの表現も使用できません。"
    },
    {
      "indent": 3,
      "text": "An implementation without deltas might be useful for a severely limited, self-managing system that has no need for expressions or events on counters. Although conceivable, such systems would be rare.",
      "ja": "デルタのない実装は、カウンターで表現やイベントを必要としない厳しく限られた自己管理システムに役立つかもしれません。考えられますが、そのようなシステムはまれです。"
    },
    {
      "indent": 0,
      "text": "2.5. Structure",
      "section_title": true,
      "ja": "2.5. 構造"
    },
    {
      "indent": 3,
      "text": "The MIB has the following sections:",
      "ja": "MIBには次のセクションがあります。"
    },
    {
      "indent": 7,
      "text": "o Resource -- management of the MIB's use of system resources.",
      "ja": "o リソース -  MIBのシステムリソースの使用の管理。"
    },
    {
      "indent": 7,
      "text": "o Definition -- definition of expressions.",
      "ja": "o 定義 - 式の定義。"
    },
    {
      "indent": 7,
      "text": "o Value -- values of evaluated expressions.",
      "ja": "o 値 - 評価された式の値。"
    },
    {
      "indent": 0,
      "text": "2.5.1. Resource",
      "section_title": true,
      "ja": "2.5.1. リソース"
    },
    {
      "indent": 3,
      "text": "The resource section has objects to manage resource usage by wildcarded delta expressions, a potential major consumer of CPU and memory.",
      "ja": "リソースセクションには、CPUとメモリの潜在的な主要な消費者であるWildCarded Delta Expressionsによるリソース使用量を管理するオブジェクトがあります。"
    },
    {
      "indent": 0,
      "text": "2.5.2. Definition",
      "section_title": true,
      "ja": "2.5.2. 意味"
    },
    {
      "indent": 3,
      "text": "The definition section contains the tables that define expressions.",
      "ja": "定義セクションには、式を定義する表が含まれています。"
    },
    {
      "indent": 3,
      "text": "The expression table, indexed by expression owner and expression name, contains those parameters that apply to the entire expression, such as the expression itself, the data type of the result, and the sampling interval if it contains delta or change values.",
      "ja": "式の所有者と式の名前で索引付けされた式テーブルには、式そのもの、結果のデータ型、デルタまたは変更値が含まれている場合のサンプリング間隔など、式全体に適用されるパラメーターが含まれています。"
    },
    {
      "indent": 3,
      "text": "The object table, indexed by expression owner, expression name and object index within each expression, contains the parameters that apply to the individual objects that go into the expression, including the object identifier, sample type, discontinuity indicator, and such.",
      "ja": "各式内の式の所有者、式の式名、およびオブジェクトインデックスによってインデックス付けされたオブジェクトテーブルには、オブジェクト識別子、サンプルタイプ、不連続インジケーターなど、式に入る個々のオブジェクトに適用されるパラメーターが含まれています。"
    },
    {
      "indent": 0,
      "text": "2.5.3. Value",
      "section_title": true,
      "ja": "2.5.3. 価値"
    },
    {
      "indent": 3,
      "text": "The value section contains the values of evaluated expressions.",
      "ja": "値セクションには、評価された式の値が含まれています。"
    },
    {
      "indent": 3,
      "text": "The value table, indexed by expression owner, expression name and instance fragment contains a \"discriminated union\" of evaluated expression results. For a given expression only one of the columns is instantiated, depending on the result data type for the expression. The instance fragment is a constant or the final section of the object identifier that filled in a wildcard.",
      "ja": "式の所有者によってインデックス付けされた値テーブル、式の名前、インスタンスフラグメントには、評価された式結果の「差別された組合」が含まれています。特定の式では、式の結果データ型に応じて、列の1つのみがインスタンス化されます。インスタンスフラグメントは、ワイルドカードで満たされたオブジェクト識別子の定数または最終セクションです。"
    },
    {
      "indent": 0,
      "text": "2.6. Examples",
      "section_title": true,
      "ja": "2.6. 例"
    },
    {
      "indent": 3,
      "text": "The examples refer to tables and objects defined below in the MIB itself. They may well make more sense after reading those definitions.",
      "ja": "例は、MIB自体で以下に定義されている表とオブジェクトを示しています。それらの定義を読んだ後、彼らはより理にかなっているかもしれません。"
    },
    {
      "indent": 0,
      "text": "2.6.1. Wildcarding",
      "section_title": true,
      "ja": "2.6.1. ワイルドカード"
    },
    {
      "indent": 3,
      "text": "An expression may use wildcarded MIB objects that result in multiple values for the expression. To specify a wildcarded MIB object a management application leaves off part or all of the instance portion of the object identifier, and sets expObjectWildcard to true(1) for that object. For our example we'll use a counter of total blessings from a table of people. Another table, indexed by town and person has blessings just from that town.",
      "ja": "式は、式の複数の値をもたらすワイルドカードMIBオブジェクトを使用する場合があります。ワイルドカードMIBオブジェクトを指定するには、管理アプリケーションがオブジェクト識別子の一部またはすべてのインスタンス部分を除外し、そのオブジェクトのexpobjectWildCardをtrue（1）に設定します。この例では、人々のテーブルからの完全な祝福のカウンターを使用します。町と人によって索引付けされた別のテーブルは、その町から祝福を持っています。"
    },
    {
      "indent": 3,
      "text": "So the index clauses are:",
      "ja": "したがって、インデックス条項は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "personEntry OBJECT-TYPE ... INDEX { personIndex }",
      "ja": "Personentry object-type ... index {personindex}"
    },
    {
      "indent": 3,
      "text": "And:",
      "ja": "そして："
    },
    {
      "indent": 7,
      "text": "townPersonEntry OBJECT-TYPE ... INDEX { townIndex, personIndex }",
      "ja": "TownPersonEntry Object-Type ... index {townindex、personindex}"
    },
    {
      "indent": 3,
      "text": "In our friendly application we may have entered our expression as:",
      "ja": "フレンドリーなアプリケーションでは、次のように表現を入力した可能性があります。"
    },
    {
      "indent": 7,
      "text": "100 * townPersonBlessings.976.* / personBlessings.*",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "What goes in expExpression is:",
      "ja": "expxpressionで起こるのは次のとおりです。"
    },
    {
      "indent": 7,
      "text": "100*$1/$2",
      "ja": "100*$ 1/$ 2"
    },
    {
      "indent": 3,
      "text": "For example purposes we'll use some slightly far-fetched OIDs. The People MIB is 1.3.6.1.99.7 and the Town MIB is 1.3.6.1.99.11, so for our two counters the OIDs are:",
      "ja": "たとえば、少し遠く離れたOIDを使用します。MIBの人々は1.3.6.1.99.7で、町のMIBは1.3.6.1.99.11なので、2つのカウンターについてはOIDは次のとおりです。"
    },
    {
      "indent": 7,
      "text": "personBlessings 1.3.6.1.99.7.1.3.1.4 townPersonBlessings 1.3.6.1.99.11.1.2.1.9",
      "ja": "PersonBlessings 1.3.6.1.99.7.1.3.1.4 TownPersonBlessings 1.3.6.1.99.11.1.2.1.9"
    },
    {
      "indent": 3,
      "text": "The rule for wildcards is that all the wildcarded parts have to match exactly. In this case that means we have to hardwire the town and only the personIndex can be wildcarded. So our values for expObjectID are:",
      "ja": "ワイルドカードのルールは、すべてのワイルドカード部品が正確に一致しなければならないことです。この場合、それは私たちが町を携帯しなければならないことを意味し、PersonIndexのみをワイルドカードにすることができます。したがって、expobjectIDの価値は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "1.3.6.1.99.7.1.3.1.4 1.3.6.1.99.11.1.2.1.9.976",
      "ja": "1.3.6.1.99.7.1.3.1.4 1.3.6.1.99.11.1.2.1.9.976"
    },
    {
      "indent": 3,
      "text": "We're hardwired to townIndex 976 and personIndex is allowed to vary.",
      "ja": "TownIndex 976に固執しており、PersonIndexはさまざまです。"
    },
    {
      "indent": 3,
      "text": "The value of expExpressionPrefix can be either of those two counter OIDs (including the instance fragment in the second case), since either of them takes you to a MIB definition where you can look at the INDEX clause and figure out what's been left off. What's been left off doesn't have to work out to be the same object, but it does have to work out to be the same values (semantics) for the result to make sense. Note that the managed system can not typically check such semantics and if given nonsense will return nonsense.",
      "ja": "ExpexpressionPrefixの値は、これらの2つのカウンターOID（2番目のケースのインスタンスフラグメントを含む）のいずれかである可能性があります。これらのいずれかが、インデックス句を見て、何が省略されているかを把握できるMIB定義に連れて行くからです。中断されたものは、同じオブジェクトになるために解決する必要はありませんが、結果を意味するために同じ値（セマンティクス）になるためには解決する必要があります。管理されたシステムは通常、そのようなセマンティクスをチェックすることはできず、ナンセンスが与えられた場合はナンセンスを返すことに注意してください。"
    },
    {
      "indent": 3,
      "text": "If we have people numbered 6, 19, and 42 in town number 976, the successive values of expValueInstance will be:",
      "ja": "976番の町で6、19、42人の人がいる場合、expvalueInstanceの連続した値は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "0.0.6 0.0.19 0.0.42",
      "ja": "0.0.6 0.0.19 0.0.42"
    },
    {
      "indent": 3,
      "text": "So there will be three values in expValueTable, with those OIDs as the expValueInstance part of their indexing.",
      "ja": "したがって、これらのOIDをインデックスの普及の一部として、ExpvalueTableに3つの値があります。"
    },
    {
      "indent": 0,
      "text": "2.6.2. Calculation and Conditional",
      "section_title": true,
      "ja": "2.6.2. 計算と条件"
    },
    {
      "indent": 3,
      "text": "The following formula for line utilization of a half-duplex link is adapted from [PracPersp].",
      "ja": "ハーフダプレックスリンクのライン利用に関する次の式は、[pracpersp]から採用されています。"
    },
    {
      "indent": 4,
      "text": "utilization = (ifInOctets + ifOutOctets) * 800 / seconds / ifSpeed",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The expression results in the percentage line utilization per second. The total octets are multiplied by 8 to get bits and 100 to scale up the percentage as an integer.",
      "ja": "式は、1秒あたりのライン利用率を発生させます。合計オクテットに8を掛けて、ビットと100を取得して整数としてパーセンテージをスケールアップします。"
    },
    {
      "indent": 3,
      "text": "The following Expression MIB object values implement this as an expression for all ifIndexes that directly represent actual hardware. Since the octet counters are Counter32 values, they must be delta sampled to be meaningful. The sample period is 6 seconds but for accuracy and independence is calculated as a delta of sysUpTime.",
      "ja": "次の式MIBオブジェクト値は、実際のハードウェアを直接表すすべてのifindexesの式としてこれを実装します。OctetカウンターはCounter32値であるため、意味のあるようにデルタをサンプリングする必要があります。サンプル期間は6秒ですが、精度と独立性のために、sysuptimeのデルタとして計算されます。"
    },
    {
      "indent": 3,
      "text": "The expObjectTable entry for ifInOctets has an expObjectConditional that checks for being a hardware interface. Only one object in the expression needs that check associated, since it applies to the whole expression. Since ifConnectorPresent is a TruthValue with values of 1 or 2 rather than 0 and non-zero, it must also be in an expression rather than used directly for the conditional.",
      "ja": "ifinoctetsのexpobjecttableエントリには、ハードウェアインターフェイスであることをチェックするexpobjectContionalがあります。式全体が式全体に適用されるため、式の1つのオブジェクトのみが関連する必要があります。IfConnectorPresentは、0および非ゼロではなく1または2の値を持つTruthValueであるため、条件に直接使用するのではなく、式にも含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "The interface-specific discontinuity indicator is supplied only for ifInOctets since invalidating that sample will invalidate an attempt at evaluation, effectively invalidating ifOutOctets as well (correctly, because it has the same indicator).",
      "ja": "インターフェイス固有の不連続性インジケーターは、サンプルを無効にすることで評価の試みを無効にし、ifoutoctetsを効果的に無効にするため、ifinoctetsにのみ提供されます（同じインジケーターがあるため）。"
    },
    {
      "indent": 3,
      "text": "For notational clarity, in the rest of this document, a string in quotes as part of the object instance indicates the value that would actually be one subidentifier per byte. The objects all belong to owner \"me\".",
      "ja": "表記の明確さのために、このドキュメントの残りの部分では、オブジェクトインスタンスの一部として引用符の文字列は、実際にバイトごとに1つのサブインデーティファイアになる値を示します。オブジェクトはすべて所有者「私」に属します。"
    },
    {
      "indent": 3,
      "text": "Also for clarity OIDs are expressed as the object descriptor and instance. In fact they must be supplied numerically, with all subidentifiers in place before the part for the particular object and instance.",
      "ja": "また、明確にするために、OIDはオブジェクト記述子およびインスタンスとして表されます。実際、特定のオブジェクトとインスタンスの部品の前にすべてのサブインデントファイヤーが所定の位置に配置され、数値的に供給する必要があります。"
    },
    {
      "indent": 3,
      "text": "What the user would set in expExpressionTable:",
      "ja": "ユーザーがExpexpressionTableで設定するもの："
    },
    {
      "indent": 3,
      "text": "expExpression.2.\"me\".4.\"hard\"      = \"$1==1\"\nexpExpressionValueType.2.\"me\".4.\"hard\"  = unsigned32\nexpExpressionRowStatus.2.\"me\"4.\"hard\"   = 'active'\n   expExpression.2.\"me\".4.\"util\"      = \"($1+$2)*800/$4/$3\"\nexpExpressionValueType.2.\"me\".4.\"util\"  = integer32\nexpExpressionDeltaInterval.2.\"me\".4.\"util\"   = 6\nexpExpressionRowStatus.2.\"me\"4.\"util\"   = 'active'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "What the user would set in expObjectTable:",
      "ja": "ユーザーがexpobjectTableで設定するもの："
    },
    {
      "indent": 3,
      "text": "expObjectID.2.\"me\".4.\"hard\".1 = ifConnectorPresent expObjectWildcard.2.\"me\".4.\"hard\".1 = 'true' expObjectSampleType.2.\"me\".4.\"hard\".1 = 'absoluteValue' expObjectRowStatus.2.\"me\".4.\"hard\".1 = 'active'",
      "ja": "expobjectid.2。 \"me\" .4。1 = 'AbsolutValue' expobjectRowStatus.2。 \"me\" .4。 \"hard\" .1 = 'Active'"
    },
    {
      "indent": 3,
      "text": "expObjectID.2.\"me\".4.\"util\".1 = ifInOctets expObjectWildcard.2.\"me\".4.\"util\".1 = 'true' expObjectSampleType.2.\"me\".4.\"util\".1 = 'deltaValue' expObjectConditional.2.\"me\".4.\"util\".1 = expValueUnsigned32Val.4.\"hard\".0.0 expObjectConditionalWildcard.2.\"me\".4.\"util\".1 = 'true' expObjectDiscontinuityID.2.\"me\".4.\"util\".1 = ifCounterDiscontinuityTime expObjectDiscontinuityIDWildcard.2.\"me\".4.\"util\".1 = 'true' expObjectRowStatus.2.\"me\".4.\"util\".1 = 'active'",
      "ja": "expobjectid.2。 \"me\" .4。1 = 'deltavalue' expobjectConditional.2。 \"Me\" .4。.2。 \"me\" .4。= 'Active'"
    },
    {
      "indent": 3,
      "text": "expObjectID.2.\"me\".4.\"util\".2 = ifOutOctets expObjectWildcard.2.\"me\".4.\"util\".2 = 'true' expObjectSampleType.2.\"me\".4.\"util\".2 = 'deltaValue' expObjectRowStatus.2.\"me\".4.\"util\".2 = 'active'",
      "ja": "expobjectid.2。 \"me\" .4。2 = 'deltavalue' expobjectrowstatus.2。 \"me\" .4。 \"util\" .2 = 'Active'"
    },
    {
      "indent": 3,
      "text": "expObjectID.2.\"me\".4.\"util\".3 = ifSpeed expObjectWildcard.2.\"me\".4.\"util\".3 = 'true' expObjectSampleType.2.\"me\".4.\"util\".3 = 'absoluteValue' expObjectRowStatus.2.\"me\".4.\"util\".3 = 'active'",
      "ja": "expobjectid.2。 \"me\" .4。3 = 'AbsolutValue' expobjectRowStatus.2。 \"me\" .4。 \"Util\" .3 = 'Active'"
    },
    {
      "indent": 3,
      "text": "expObjectID.2.\"me\".4.\"util\".4 = sysUpTime.0 expObjectWildcard.2.\"me\".4.\"util\".4 = 'false' expObjectSampleType.2.\"me\".4.\"util\".4 = 'deltaValue' expObjectRowStatus.2.\"me\".4.\"util\".4 = 'active'",
      "ja": "expobjectid.2。 \"me\" .4。\".4 = 'deltavalue' expobjectrowstatus.2。\" me \".4。\" util \".4 = 'Active'"
    },
    {
      "indent": 3,
      "text": "These settings will result in populating one column of expValueTable:",
      "ja": "これらの設定により、1つの列のExpvalueTableが入力されます。"
    },
    {
      "indent": 3,
      "text": "expValueInteger32Val.2.\"me\".4.\"util\".0.0.?",
      "ja": "expvalueInteger32Val.2。 \"me\" .4。 \"Util\" .0.0。？"
    },
    {
      "indent": 3,
      "text": "The subidentifier represented by \"?\" above represents one subidentifier that takes on a value of ifIndex and identifies a row for each ifIndex value where ifConnectorPresent is 'true' and the interface was present for two samples to provide a delta.",
      "ja": "「？」で表される小Identifier上記は、ifindexの値を引き受け、ifconnectorPresentが「true」であり、2つのサンプルがデルタを提供する2つのサンプルにインターフェイスが存在する各ifindex値の行を識別する1つのサブインデントファイアを表します。"
    },
    {
      "indent": 3,
      "text": "This value could in turn be used as an event threshold [RFC2981] to watch for overutilization of all hardware network connections.",
      "ja": "この値は、イベントのしきい値[RFC2981]として使用して、すべてのハードウェアネットワーク接続の過剰活用を監視できます。"
    },
    {
      "indent": 0,
      "text": "3. Definitions",
      "section_title": true,
      "ja": "3. 定義"
    },
    {
      "indent": 0,
      "text": "DISMAN-EXPRESSION-MIB DEFINITIONS ::= BEGIN",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "IMPORTS\n    MODULE-IDENTITY, OBJECT-TYPE,\n    Integer32, Gauge32, Unsigned32,\n    Counter32, Counter64, IpAddress,\n    TimeTicks, mib-2, zeroDotZero  FROM SNMPv2-SMI\n    RowStatus, TruthValue, TimeStamp    FROM SNMPv2-TC\n    sysUpTime                 FROM SNMPv2-MIB\n    SnmpAdminString           FROM SNMP-FRAMEWORK-MIB\n    MODULE-COMPLIANCE, OBJECT-GROUP     FROM SNMPv2-CONF;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "dismanExpressionMIB MODULE-IDENTITY LAST-UPDATED \"200010160000Z\" -- 16 October 2000 ORGANIZATION \"IETF Distributed Management Working Group\" CONTACT-INFO \"Ramanathan Kavasseri Cisco Systems, Inc. 170 West Tasman Drive, San Jose CA 95134-1706. Phone: +1 408 527 2446 Email: ramk@cisco.com\" DESCRIPTION \"The MIB module for defining expressions of MIB objects for management purposes.\" -- Revision History",
      "ja": "DismanExpressionMIBモジュールのIDINDITITY最終的な「200010160000Z」 -  2000年10月16日組織「IETF分散管理ワーキンググループ「コンタクトINFO」」Ramanathan Kavasseri Cisco Systems、Inc。170 West Tasman Drive、San Jose CA 95134-1706。527 2446メール：ramk@cisco.com「説明」管理目的でMIBオブジェクトの式を定義するためのMIBモジュール。」 - 改訂履歴"
    },
    {
      "indent": 4,
      "text": "   REVISION     \"200010160000Z\" -- 16 October 2000\n   DESCRIPTION  \"This is the initial version of this MIB.\n                Published as RFC 2982\"\n::= { mib-2 90 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "dismanExpressionMIBObjects OBJECT IDENTIFIER ::=\n                                            { dismanExpressionMIB 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expResource    OBJECT IDENTIFIER ::= { dismanExpressionMIBObjects 1 }\nexpDefine OBJECT IDENTIFIER ::= { dismanExpressionMIBObjects 2 }\nexpValue  OBJECT IDENTIFIER ::= { dismanExpressionMIBObjects 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- -- Resource Control --\u0007\u0007\u0007expResourceDeltaMinimum OBJECT-TYPE SYNTAX Integer32 (-1 | 1..600) UNITS \"seconds\" MAX-ACCESS read-write STATUS current DESCRIPTION \"The minimum expExpressionDeltaInterval this system will accept. A system may use the larger values of this minimum to lessen the impact of constantly computing deltas. For larger delta sampling intervals the system samples less often and suffers less overhead. This object provides a way to enforce such lower overhead for all expressions created after it is set.",
      "ja": "---リソースコントロール -  ExpResourcedEltaminimumオブジェクトタイプ構文integer32（-1 | 1..600）単位「秒」最大アクセス読み取りワイトステータス現在の説明 \"最小expexpressionDeltaintervalこのシステムは受け入れます。この最小値のより大きな値を使用して、絶えず計算デルタの影響を軽減することができます。より大きなデルタサンプリング間隔の場合、システムのサンプルが少なくなり、オーバーヘッドが少なくなります。。"
    },
    {
      "indent": 5,
      "text": "The value -1 indicates that expResourceDeltaMinimum is irrelevant as the system will not accept 'deltaValue' as a value for expObjectSampleType.",
      "ja": "値-1は、システムが「deltavalue」をexpobjectsampletypeの値として受け入れないため、expresourcededeltaminimumが無関係であることを示します。"
    },
    {
      "indent": 5,
      "text": "Unless explicitly resource limited, a system's value for this object should be 1, allowing as small as a 1 second interval for ongoing delta sampling.",
      "ja": "明示的にリソースが限られていない限り、このオブジェクトに対するシステムの値は1である必要があり、進行中のデルタサンプリングのために1秒の間隔を1秒ほど許可します。"
    },
    {
      "indent": 4,
      "text": " Changing this value will not invalidate an existing setting\n of expObjectSampleType.\"\n::= { expResource 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expResourceDeltaWildcardInstanceMaximum OBJECT-TYPE SYNTAX Unsigned32 UNITS \"instances\" MAX-ACCESS read-write STATUS current DESCRIPTION \"For every instance of a deltaValue object, one dynamic instance entry is needed for holding the instance value from the previous sample, i.e. to maintain state.",
      "ja": "ExpResourcedElTawildCardinStanceMaximumオブジェクトタイプの構文untisined32ユニット「インスタンス「Max-Access read-writeステータス現在の説明」deltavalueオブジェクトのすべてのインスタンスについて、1つの動的インスタンスエントリは、前のサンプルからのインスタンス値を保持するために必要です。"
    },
    {
      "indent": 5,
      "text": "This object limits maximum number of dynamic instance entries this system will support for wildcarded delta objects in expressions. For a given delta expression, the number of dynamic instances is the number of values that meet all criteria to exist times the number of delta values in the expression.",
      "ja": "このオブジェクトは、このシステムが式でワイルドカードされたデルタオブジェクトをサポートする動的インスタンスエントリの最大数を制限します。特定のデルタ式の場合、動的インスタンスの数は、存在するすべての基準を満たす値の数です。"
    },
    {
      "indent": 5,
      "text": "A value of 0 indicates no preset limit, that is, the limit is dynamic based on system operation and resources.",
      "ja": "値0はプリセット制限がないことを示します。つまり、制限はシステムの操作とリソースに基づいて動的です。"
    },
    {
      "indent": 5,
      "text": "Unless explicitly resource limited, a system's value for this object should be 0.",
      "ja": "明示的にリソースが限られていない限り、このオブジェクトに対するシステムの値は0でなければなりません。"
    },
    {
      "indent": 5,
      "text": "Changing this value will not eliminate or inhibit existing delta wildcard instance objects but will prevent the creation of more such objects.",
      "ja": "この値を変更しても、既存のデルタワイルドカードインスタンスオブジェクトは排除または阻害されませんが、そのようなオブジェクトの作成を防ぎます。"
    },
    {
      "indent": 4,
      "text": " An attempt to allocate beyond the limit results in expErrorCode\n being tooManyWildcardValues for that evaluation attempt.\"\n::= { expResource 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expResourceDeltaWildcardInstances OBJECT-TYPE\n    SYNTAX      Gauge32\n    UNITS       \"instances\"\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n     \"The number of currently active instance entries as\n     defined for expResourceDeltaWildcardInstanceMaximum.\"\n    ::= { expResource 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expResourceDeltaWildcardInstancesHigh OBJECT-TYPE\n    SYNTAX      Gauge32\n    UNITS       \"instances\"\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n     \"The highest value of expResourceDeltaWildcardInstances\n     that has occurred since initialization of the managed\n     system.\"\n    ::= { expResource 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expResourceDeltaWildcardInstanceResourceLacks OBJECT-TYPE\n    SYNTAX      Counter32\n    UNITS       \"instances\"\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n     \"The number of times this system could not evaluate an\n     expression because that would have created a value instance in\n     excess of expResourceDeltaWildcardInstanceMaximum.\"\n    ::= { expResource 5 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "--",
      "ja": " - "
    },
    {
      "indent": 0,
      "text": "-- Definition\n--\n-- Expression Definition Table\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expExpressionTable OBJECT-TYPE",
      "ja": "ExpexpressionTableオブジェクトタイプ"
    },
    {
      "indent": 4,
      "text": "SYNTAX      SEQUENCE OF ExpExpressionEntry\nMAX-ACCESS  not-accessible\nSTATUS      current\nDESCRIPTION\n \"A table of expression definitions.\"\n::= { expDefine 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expExpressionEntry OBJECT-TYPE SYNTAX ExpExpressionEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"Information about a single expression. New expressions can be created using expExpressionRowStatus.",
      "ja": "ExpexpressionEntryオブジェクトタイプ構文ExpexppressionEntry Max-Accessアクセス不可能なステータス現在の説明 \"単一の式に関する情報。ExpexpressionRowStatusを使用して新しい式を作成できます。"
    },
    {
      "indent": 5,
      "text": "To create an expression first create the named entry in this table. Then use expExpressionName to populate expObjectTable. For expression evaluation to succeed all related entries in expExpressionTable and expObjectTable must be 'active'. If these conditions are not met the corresponding values in expValue simply are not instantiated.",
      "ja": "式を作成するには、最初にこのテーブルに指名されたエントリを作成します。次に、ExpexpressionNameを使用してExpobjectTableを入力します。ExpexpressionTableおよびExpobjectTableの関連するすべてのエントリを成功させるための式評価は、「アクティブ」でなければなりません。これらの条件が満たされていない場合、エクスポバルの対応する値は単にインスタンス化されません。"
    },
    {
      "indent": 5,
      "text": "Deleting an entry deletes all related entries in expObjectTable and expErrorTable.",
      "ja": "エントリを削除すると、expobjecttableおよびExperrortableの関連するすべてのエントリが削除されます。"
    },
    {
      "indent": 5,
      "text": "Because of the relationships among the multiple tables for an expression (expExpressionTable, expObjectTable, and expValueTable) and the SNMP rules for independence in setting object values, it is necessary to do final error checking when an expression is evaluated, that is, when one of its instances in expValueTable is read or a delta interval expires. Earlier checking need not be done and an implementation may not impose any ordering on the creation of objects related to an expression.",
      "ja": "式の複数のテーブル間の関係（ExpexpressionTable、ExpobjectTable、およびExpvaluetable）と、オブジェクト値を設定する際の独立性のSNMPルールのために、式が評価されるとき、つまり、つまり、最終的なエラーチェックを行う必要があります。ExpvalueTableのそのインスタンスは読み取られるか、Delta間隔が期限切れになります。以前のチェックを行う必要はなく、実装が式に関連するオブジェクトの作成に順序付けを課さない場合があります。"
    },
    {
      "indent": 5,
      "text": "To maintain security of MIB information, when creating a new row in this table, the managed system must record the security credentials of the requester. These security credentials are the parameters necessary as inputs to isAccessAllowed from the Architecture for",
      "ja": "MIB情報のセキュリティを維持するために、このテーブルに新しい行を作成する場合、管理されたシステムは要求者のセキュリティ資格情報を記録する必要があります。これらのセキュリティ資格情報は、アーキテクチャからのISACCESSALLOWへの入力として必要なパラメーターです"
    },
    {
      "indent": 5,
      "text": "Describing SNMP Management Frameworks. When obtaining the objects that make up the expression, the system must (conceptually) use isAccessAllowed to ensure that it does not violate security.",
      "ja": "SNMP管理フレームワークの説明。式を構成するオブジェクトを取得する場合、システムは（概念的に）ISACCESSALLOWEDを使用して、セキュリティに違反しないことを確認する必要があります。"
    },
    {
      "indent": 5,
      "text": "The evaluation of the expression takes place under the security credentials of the creator of its expExpressionEntry.",
      "ja": "表現の評価は、そのexpexpressionentryの作成者のセキュリティ資格の下で行われます。"
    },
    {
      "indent": 4,
      "text": " Values of read-write objects in this table may be changed\n     at any time.\"\nINDEX       { expExpressionOwner, expExpressionName }\n::= { expExpressionTable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "ExpExpressionEntry ::= SEQUENCE {\n    expExpressionOwner           SnmpAdminString,\n    expExpressionName             SnmpAdminString,\n    expExpression                OCTET STRING,\n    expExpressionValueType       INTEGER,\n    expExpressionComment         SnmpAdminString,\n    expExpressionDeltaInterval   Integer32,\n    expExpressionPrefix           OBJECT IDENTIFIER,\n    expExpressionErrors          Counter32,\n    expExpressionEntryStatus     RowStatus\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expExpressionOwner OBJECT-TYPE\n   SYNTAX      SnmpAdminString (SIZE(0..32))\n   MAX-ACCESS  not-accessible\n   STATUS      current\n   DESCRIPTION\n     \"The owner of this entry. The exact semantics of this\n     string are subject to the security policy defined by the\n     security administrator.\"\n    ::= { expExpressionEntry 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expExpressionName OBJECT-TYPE\n    SYNTAX      SnmpAdminString (SIZE (1..32))\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n     \"The name of the expression.  This is locally unique, within\n     the scope of an expExpressionOwner.\"\n    ::= { expExpressionEntry 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expExpression OBJECT-TYPE SYNTAX OCTET STRING (SIZE (1..1024)) MAX-ACCESS read-create STATUS current DESCRIPTION \"The expression to be evaluated. This object is the same as a DisplayString (RFC 1903) except for its maximum length.",
      "ja": "Expexpression Object-Type Syntax Octet String（Size（1..1024））Max-Access Read-Createステータス現在の説明 \"評価対象の式。このオブジェクトは、最大長を除いてDisplayString（RFC 1903）と同じです。"
    },
    {
      "indent": 5,
      "text": "Except for the variable names the expression is in ANSI C syntax. Only the subset of ANSI C operators and functions listed here is allowed.",
      "ja": "変数名を除き、式はANSI C構文にあります。ここにリストされているANSI C演算子と機能のサブセットのみが許可されています。"
    },
    {
      "indent": 5,
      "text": "Variables are expressed as a dollar sign ('$') and an integer that corresponds to an expObjectIndex. An example of a valid expression is:",
      "ja": "変数は、ドル記号（ '$'）およびexpobjectIndexに対応する整数として表されます。有効な式の例は次のとおりです。"
    },
    {
      "indent": 10,
      "text": "($1-$5)*100",
      "ja": "（$ 1- $ 5）*100"
    },
    {
      "indent": 5,
      "text": "Expressions must not be recursive, that is although an expression may use the results of another expression, it must not contain any variable that is directly or indirectly a result of its own evaluation. The managed system must check for recursive expressions.",
      "ja": "式は再帰的であってはなりません。つまり、式は別の式の結果を使用する可能性がありますが、直接的または間接的に独自の評価の結果である変数を含めてはなりません。 管理されたシステムは、再帰的な表現をチェックする必要があります。"
    },
    {
      "indent": 5,
      "text": "The only allowed operators are:",
      "ja": "許可されている唯一のオペレーターは次のとおりです。"
    },
    {
      "indent": 10,
      "text": "( )\n- (unary)\n+ - * / %\n& | ^ << >> ~\n! && || == != > >= < <=",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Note the parentheses are included for parenthesizing the expression, not for casting data types.",
      "ja": "注意データ型ではなく、式を括弧で囲むために括弧が含まれています。"
    },
    {
      "indent": 5,
      "text": "The only constant types defined are:",
      "ja": "定義されている唯一の定数タイプは次のとおりです。"
    },
    {
      "indent": 10,
      "text": "int (32-bit signed) long (64-bit signed) unsigned int unsigned long hexadecimal character string oid",
      "ja": "int（32ビット署名）long（64ビット署名）unsigned int unsigned long hexadecimal文字列oid"
    },
    {
      "indent": 5,
      "text": "The default type for a positive integer is int unless it is too large in which case it is long.",
      "ja": "正の整数のデフォルトのタイプは、大きすぎない限り、intです。"
    },
    {
      "indent": 5,
      "text": "All but oid are as defined for ANSI C. Note that a hexadecimal constant may end up as a scalar or an array of 8-bit integers. A string constant is enclosed in double quotes and may contain back-slashed individual characters as in ANSI C.",
      "ja": "OIDを除くすべては、ANSI Cに対して定義されています。16進数定数は、8ビット整数のスカラーまたは配列として終わる可能性があることに注意してください。文字列定数は二重引用符で囲まれており、ANSI Cのようにバックスラッシュした個々の文字が含まれる場合があります。"
    },
    {
      "indent": 5,
      "text": "An oid constant comprises 32-bit, unsigned integers and at least one period, for example:",
      "ja": "OID定数は、32ビット、署名されていない整数と少なくとも1つの期間を含む。たとえば、："
    },
    {
      "indent": 10,
      "text": "0. .0 1.3.6.1",
      "ja": "0. .0 1.3.6.1"
    },
    {
      "indent": 5,
      "text": "No additional leading or trailing subidentifiers are automatically added to an OID constant. The constant is taken as expressed.",
      "ja": "追加のリーディングまたはトレーリングサブインデーディファーは、OID定数に自動的に追加されません。定数は表現どおりにとられます。"
    },
    {
      "indent": 5,
      "text": "Integer-typed objects are treated as 32- or 64-bit, signed or unsigned integers, as appropriate. The results of mixing them are as for ANSI C, including the type of the result. Note that a 32-bit value is thus promoted to 64 bits only in an operation with a 64-bit value. There is no provision for larger values to handle overflow.",
      "ja": "整数型オブジェクトは、必要に応じて、32ビットまたは64ビット、署名または署名されていない整数として扱われます。それらを混合した結果は、結果のタイプを含むANSI Cの結果です。したがって、32ビット値は、64ビット値の操作でのみ64ビットに宣伝されることに注意してください。オーバーフローを処理するためのより大きな値の規定はありません。"
    },
    {
      "indent": 5,
      "text": "Relative to SNMP data types, a resulting value becomes unsigned when calculating it uses any unsigned value, including a counter. To force the final value to be of data type counter the expression must explicitly use the counter32() or counter64() function (defined below).",
      "ja": "SNMPデータ型と比較して、結果の値は、カウンターを含む符号なしの値を計算すると署名されません。最終的な値をデータ型カウンターに強制するには、式はcounter32（）またはcounter64（）関数を明示的に使用する必要があります（以下に定義）。"
    },
    {
      "indent": 5,
      "text": "OCTET STRINGS and OBJECT IDENTIFIERs are treated as one-dimensioned arrays of unsigned 8-bit integers and unsigned 32-bit integers, respectively.",
      "ja": "オクテット文字列とオブジェクトの識別子は、それぞれ署名されていない8ビット整数と署名されていない32ビット整数の1次元アレイとして扱われます。"
    },
    {
      "indent": 5,
      "text": "IpAddresses are treated as 32-bit, unsigned integers in network byte order, that is, the hex version of 255.0.0.0 is 0xff000000.",
      "ja": "iPaddressesは、ネットワークバイトの順序で32ビットの符号なし整数として扱われます。つまり、255.0.0.0の16進バージョンは0xff00000000です。"
    },
    {
      "indent": 5,
      "text": "Conditional expressions result in a 32-bit, unsigned integer of value 0 for false or 1 for true. When an arbitrary value is used as a boolean 0 is false and non-zero is true.",
      "ja": "条件付き式は、32ビット、false 0の値0またはtrueで1の符号なし整数をもたらします。任意の値がブール値として使用される場合、0は偽で、非ゼロは真です。"
    },
    {
      "indent": 5,
      "text": "Rules for the resulting data type from an operation, based on the operator:",
      "ja": "オペレーターに基づいて、操作から得られたデータ型のルール："
    },
    {
      "indent": 5,
      "text": "For << and >> the result is the same as the left hand operand.",
      "ja": "<<および>>の場合、結果は左手オペランドと同じです。"
    },
    {
      "indent": 5,
      "text": "For &&, ||, ==, !=, <, <=, >, and >= the result is always Unsigned32.",
      "ja": "&&、||、==、！=、<、<=、>、および> = forは常にsigned32です。"
    },
    {
      "indent": 5,
      "text": "For unary - the result is always Integer32.",
      "ja": "単位の場合 - 結果は常に整数です32です。"
    },
    {
      "indent": 5,
      "text": "For +, -, *, /, %, &, |, and ^ the result is promoted according to the following rules, in order from most to least preferred:",
      "ja": "for、 *、 /、％、＆、、|、 ^、および ^結果は、以下のルールに従って宣伝されます。"
    },
    {
      "indent": 10,
      "text": "If left hand and right hand operands are the same type, use that.",
      "ja": "左手と右手のオペランドが同じタイプの場合は、それを使用してください。"
    },
    {
      "indent": 10,
      "text": "If either side is Counter64, use that.",
      "ja": "どちらの側がカウンター64の場合は、それを使用してください。"
    },
    {
      "indent": 10,
      "text": "If either side is IpAddress, use that.",
      "ja": "どちらの側がiPaddressの場合は、それを使用してください。"
    },
    {
      "indent": 10,
      "text": "If either side is TimeTicks, use that.",
      "ja": "どちらかの側が時刻表の場合は、それを使用してください。"
    },
    {
      "indent": 10,
      "text": "If either side is Counter32, use that.",
      "ja": "どちらの側がカウンター32の場合は、それを使用してください。"
    },
    {
      "indent": 10,
      "text": "Otherwise use Unsigned32.",
      "ja": "それ以外の場合は、unsigned32を使用します。"
    },
    {
      "indent": 5,
      "text": "The following rules say what operators apply with what data types. Any combination not explicitly defined does not work.",
      "ja": "次のルールでは、どのデータ型でどのオペレーターが適用されるかを示しています。明示的に定義されていない組み合わせは機能しません。"
    },
    {
      "indent": 5,
      "text": "For all operators any of the following can be the left hand or right hand operand: Integer32, Counter32, Unsigned32, Counter64.",
      "ja": "すべての演算子の場合、次のいずれかが左手または右手のオペランドになります：integer32、counter32、unsigned32、counter64。"
    },
    {
      "indent": 5,
      "text": "The operators +, -, *, /, %, <, <=, >, and >= work with TimeTicks.",
      "ja": "演算子、 - 、 *、 /、％、<、<=、>、および> =タイムテックを使用します。"
    },
    {
      "indent": 5,
      "text": "The operators &, |, and ^ work with IpAddress.",
      "ja": "オペレーター＆、|、および ^はiPaddressを使用します。"
    },
    {
      "indent": 5,
      "text": "The operators << and >> work with IpAddress but only as the left hand operand.",
      "ja": "オペレーター<<および>>はiPaddressで動作しますが、左手オペランドとしてのみ動作します。"
    },
    {
      "indent": 5,
      "text": "The + operator performs a concatenation of two OCTET STRINGs or two OBJECT IDENTIFIERs.",
      "ja": "オペレーターは、2つのオクテット文字列または2つのオブジェクト識別子の連結を実行します。"
    },
    {
      "indent": 5,
      "text": "The operators &, | perform bitwise operations on OCTET STRINGs. If the OCTET STRING happens to be a DisplayString the results may be meaningless, but the agent system does not check this as some such systems do not have this information.",
      "ja": "オペレーター＆、|Octet文字列でビットワイズ操作を実行します。Octet文字列がたまたまディスプレイストリングである場合、結果は無意味である可能性がありますが、エージェントシステムはこれをチェックしません。そのようなシステムにはこの情報がないためです。"
    },
    {
      "indent": 5,
      "text": "The operators << and >> perform bitwise operations on OCTET STRINGs appearing as the left hand operand.",
      "ja": "オペレーター<<および>>は、左手オペランドとして表示されるオクテット文字列でビットワイズ操作を実行します。"
    },
    {
      "indent": 5,
      "text": "The only functions defined are:",
      "ja": "定義されている唯一の関数は次のとおりです。"
    },
    {
      "indent": 10,
      "text": "counter32 counter64 arraySection stringBegins stringEnds stringContains oidBegins oidEnds oidContains average maximum minimum sum exists",
      "ja": "Counter32 Counter64 Arraysection StringBegins StringEnds StringContains oidbegins oidends oidcontaines平均最小最小額が存在する"
    },
    {
      "indent": 5,
      "text": "The following function definitions indicate their parameters by naming the data type of the parameter in the parameter's position in the parameter list. The parameter must be of the type indicated and generally may be a constant, a MIB object, a function, or an expression.",
      "ja": "次の関数定義は、パラメーターリストのパラメーターの位置のパラメーターのデータ型に名前を付けることにより、パラメーターを示します。パラメーターは示されているタイプである必要があり、一般に一定のオブジェクト、関数、または式である場合があります。"
    },
    {
      "indent": 5,
      "text": "counter32(integer) - wrapped around an integer value counter32 forces Counter32 as a data type.",
      "ja": "Counter32（整数） - 整数値Counter32 Forces counter32をデータ型として包みます。"
    },
    {
      "indent": 5,
      "text": "counter64(integer) - similar to counter32 except that the resulting data type is 'counter64'.",
      "ja": "Counter64（整数） - 結果のデータ型が「Counter64」であることを除いて、Counter32に似ています。"
    },
    {
      "indent": 5,
      "text": "arraySection(array, integer, integer) - selects a piece of an array (i.e. part of an OCTET STRING or OBJECT IDENTIFIER). The integer arguments are in the range 0 to 4,294,967,295. The first is an initial array index (one-dimensioned) and the second is an ending array index. A value of 0 indicates first or last element, respectively. If the first element is larger than the array length the result is 0 length. If the second integer is less than or equal to the first, the result is 0 length. If the second is larger than the array length it indicates last element.",
      "ja": "Arraysection（配列、整数、整数） - 配列の一部（つまり、オクテット文字列またはオブジェクト識別子の一部）を選択します。整数引数は、0〜4,294,967,295の範囲にあります。1つ目は初期配列インデックス（1次元）で、2番目はエンディングアレイインデックスです。0の値は、それぞれ最初または最後の要素を示します。最初の要素が配列の長さよりも大きい場合、結果は0の長さです。2番目の整数が最初の整数以下の場合、結果は0の長さです。2番目が配列の長さよりも大きい場合、最後の要素を示します。"
    },
    {
      "indent": 5,
      "text": "stringBegins/Ends/Contains(octetString, octetString) - looks for the second string (which can be a string constant) in the first and returns the one-dimensioned arrayindex where the match began. A return value of 0 indicates no match (i.e. boolean false).",
      "ja": "stringbegins/end/contains（octetString、octetString） - 最初の文字列（文字列定数になる可能性があります）を探し、一致が始まった1次元のarrayindexを返します。0の返品値は、一致しないことを示します（つまり、boolean false）。"
    },
    {
      "indent": 5,
      "text": "oidBegins/Ends/Contains(oid, oid) - looks for the second OID (which can be an OID constant) in the first and returns the the one-dimensioned index where the match began. A return value of 0 indicates no match (i.e. boolean false).",
      "ja": "oidbegins/ends/contains（oid、oid） - 最初の2番目のoid（oid定数になる可能性がある）を探し、一致が始まった1次元インデックスを返します。0の返品値は、一致しないことを示します（つまり、boolean false）。"
    },
    {
      "indent": 5,
      "text": "average/maximum/minimum(integer) - calculates the average, minimum, or maximum value of the integer valued object over multiple sample times. If the object disappears for any sample period, the accumulation and the resulting value object cease to exist until the object reappears at which point the calculation starts over.",
      "ja": "平均/最大/最小（整数） - 複数のサンプル時間にわたって整数値オブジェクトの平均、最小、または最大値を計算します。サンプル期間のオブジェクトが消えると、オブジェクトが再び現れるまで蓄積と結果の値オブジェクトが存在しなくなります。"
    },
    {
      "indent": 5,
      "text": "sum(integerObject*) - sums all available values of the wildcarded integer object, resulting in an integer scalar. Must be used with caution as it wraps on overflow with no notification.",
      "ja": "sum（integerobject*） - ワイルドカードされた整数オブジェクトの利用可能なすべての値を合計して、整数スカラーになります。通知なしでオーバーフローをラップするため、注意して使用する必要があります。"
    },
    {
      "indent": 5,
      "text": "exists(anyTypeObject) - verifies the object instance exists. A return value of 0 indicates NoSuchInstance (i.e. boolean false).\"",
      "ja": "存在する（AnyTypeObject） - オブジェクトインスタンスの存在を検証します。0の戻り値は、Nosuchinstance（つまり、Boolean False）を示します。」"
    },
    {
      "indent": 4,
      "text": "::= { expExpressionEntry 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expExpressionValueType OBJECT-TYPE SYNTAX INTEGER { counter32(1), unsigned32(2), timeTicks(3), integer32(4), ipAddress(5), octetString(6), objectId(7), counter64(8) } MAX-ACCESS read-create STATUS current DESCRIPTION \"The type of the expression value. One and only one of the value objects in expValueTable will be instantiated to match this type.",
      "ja": "ExpexpressionValueetype Object-Type Syntax Integer {Counter32（1）、Unsigned32（2）、Timeticks（3）、Integer32（4）、iPaddress（5）、Objectid（7）、Counter64（8）}読み取りステータス現在の説明 \"式値のタイプ。ExpalueTableの値の1つだけが、このタイプと一致するようにインスタンス化されます。"
    },
    {
      "indent": 4,
      "text": " If the result of the expression can not be made into this type,\n an invalidOperandType error will occur.\"\nDEFVAL      { counter32 }\n::= { expExpressionEntry 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expExpressionComment OBJECT-TYPE\n    SYNTAX      SnmpAdminString\n    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n     \"A comment to explain the use or meaning of the expression.\"\n    DEFVAL      { ''H }\n    ::= { expExpressionEntry 5 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expExpressionDeltaInterval OBJECT-TYPE SYNTAX Integer32 (0..86400) UNITS \"seconds\" MAX-ACCESS read-create STATUS current DESCRIPTION \"Sampling interval for objects in this expression with expObjectSampleType 'deltaValue'.",
      "ja": "expexpressionDeltainterValオブジェクトタイプ構文integer32（0..86400）単位「秒」最大アクセス読み取りステータス現在の説明 \"この式のオブジェクトのサンプリング間隔expobjectsampletype 'deltavalue'。"
    },
    {
      "indent": 5,
      "text": "This object has no effect if the the expression has no deltaValue objects.",
      "ja": "このオブジェクトには、式にdeltavalueオブジェクトがない場合、効果はありません。"
    },
    {
      "indent": 5,
      "text": "A value of 0 indicates no automated sampling. In this case the delta is the difference from the last time the expression was evaluated. Note that this is subject to unpredictable delta times in the face of retries or multiple managers.",
      "ja": "0の値は、自動サンプリングがないことを示します。この場合、デルタは、式が最後に評価されたときとの違いです。これは、レトリまたは複数のマネージャーに直面して予測不可能なデルタ時間の対象となることに注意してください。"
    },
    {
      "indent": 5,
      "text": "A value greater than zero is the number of seconds between automated samples.",
      "ja": "ゼロを超える値は、自動化されたサンプル間の秒数です。"
    },
    {
      "indent": 5,
      "text": "Until the delta interval has expired once the delta for the object is effectively not instantiated and evaluating the expression has results as if the object itself were not instantiated.",
      "ja": "オブジェクトのデルタが事実上インスタンス化されず、式を評価すると、オブジェクト自体がインスタンス化されていないかのように結果が得られます。"
    },
    {
      "indent": 5,
      "text": "Note that delta values potentially consume large amounts of system CPU and memory. Delta state and processing must continue constantly even if the expression is not being used. That is, the expression is being evaluated every delta interval, even if no application is reading those values. For wildcarded objects this can be substantial overhead.",
      "ja": "デルタ値は、潜在的に大量のシステムCPUとメモリを消費することに注意してください。式が使用されていなくても、デルタ状態と処理は常に継続する必要があります。つまり、これらの値を読み取っていなくても、式はすべてのデルタ間隔を評価されています。ワイルドカードされたオブジェクトの場合、これはかなりのオーバーヘッドになる可能性があります。"
    },
    {
      "indent": 4,
      "text": " Note that delta intervals, external expression value sampling\n intervals and delta intervals for expressions within other\n expressions can have unusual interactions as they are impossible\n to synchronize accurately.  In general one interval embedded\n below another must be enough shorter that the higher sample\n sees relatively smooth, predictable behavior.  So, for example,\n to avoid the higher level getting the same sample twice, the\n lower level should sample at least twice as fast as the higher\n level does.\"\nDEFVAL      { 0 }\n::= { expExpressionEntry 6 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expExpressionPrefix OBJECT-TYPE SYNTAX OBJECT IDENTIFIER MAX-ACCESS read-only STATUS current DESCRIPTION \"An object prefix to assist an application in determining the instance indexing to use in expValueTable, relieving the application of the need to scan the expObjectTable to determine such a prefix.",
      "ja": "expexpressionPrefixオブジェクトタイプ構文識別子識別子最大アクセス読み取り専用ステータス現在"
    },
    {
      "indent": 5,
      "text": "See expObjectTable for information on wildcarded objects.",
      "ja": "WildCardedオブジェクトの情報については、expobjectTableを参照してください。"
    },
    {
      "indent": 5,
      "text": "If the expValueInstance portion of the value OID may be treated as a scalar (that is, normally, 0) the value of expExpressionPrefix is zero length, that is, no OID at all. Note that zero length implies a null OID, not the OID 0.0.",
      "ja": "値OIDのexpvalueInstance部分がスカラーとして扱われる可能性がある場合（つまり、通常0）、ExpxpressionPrefixの値は長さゼロです。つまり、OIDはまったくありません。ゼロの長さは、oid 0.0ではなく、null oidを意味することに注意してください。"
    },
    {
      "indent": 4,
      "text": " Otherwise, the value of expExpressionPrefix is the expObjectID\n value of any one of the wildcarded objects for the expression.\n This is sufficient, as the remainder, that is, the instance\n fragment relevant to instancing the values, must be the same for\n all wildcarded objects in the expression.\"\n::= { expExpressionEntry 7 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expExpressionErrors OBJECT-TYPE",
      "ja": "ExpexpressionErrorsオブジェクトタイプ"
    },
    {
      "indent": 4,
      "text": "SYNTAX Counter32 MAX-ACCESS read-only STATUS current DESCRIPTION \"The number of errors encountered while evaluating this expression.",
      "ja": "構文Counter32 Max-Access読み取り専用ステータス現在の説明 \"この式を評価する際に遭遇したエラーの数。"
    },
    {
      "indent": 4,
      "text": " Note that an object in the expression not being accessible,\n is not considered an error. An example of an inaccessible\n object is when the object is excluded from the view of the\n user whose security credentials are used in the expression\n evaluation. In such cases, it is a legitimate condition\n that causes the corresponding expression value not to be\n instantiated.\"\n::= { expExpressionEntry 8 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expExpressionEntryStatus OBJECT-TYPE\n    SYNTAX      RowStatus\n    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n     \"The control that allows creation and deletion of entries.\"\n    ::= { expExpressionEntry 9 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- -- Expression Error Table --",
      "ja": "---発現エラーテーブル - "
    },
    {
      "indent": 0,
      "text": "expErrorTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF ExpErrorEntry\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n     \"A table of expression errors.\"\n    ::= { expDefine 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expErrorEntry OBJECT-TYPE SYNTAX ExpErrorEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"Information about errors in processing an expression.",
      "ja": "ExperRerentryオブジェクトタイプの構文ExperrorEntry Max-Accessアクセス不可能なステータス現在の説明 \"式の処理におけるエラーに関する情報。"
    },
    {
      "indent": 4,
      "text": " Entries appear in this table only when there is a matching expExpressionEntry and then only when there has been an error for that expression as reflected by the error codes defined for expErrorCode.\" INDEX { expExpressionOwner, expExpressionName }",
      "ja": "このテーブルには、一致するexpexppressionentryがある場合にのみエントリが表示され、その後、Experrorcodeで定義されたエラーコードによって反映されているように、その式にエラーが発生した場合にのみ表示されます。"
    },
    {
      "indent": 4,
      "text": "::= { expErrorTable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "ExpErrorEntry ::= SEQUENCE {\n    expErrorTime       TimeStamp,\n    expErrorIndex      Integer32,\n    expErrorCode       INTEGER,\n    expErrorInstance   OBJECT IDENTIFIER\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expErrorTime OBJECT-TYPE\n    SYNTAX      TimeStamp\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n     \"The value of sysUpTime the last time an error caused a\n     failure to evaluate this expression.\"\n    ::= { expErrorEntry 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expErrorIndex OBJECT-TYPE\n    SYNTAX      Integer32\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n     \"The one-dimensioned character array index into\n     expExpression for where the error occurred.  The value\n     zero indicates irrelevance.\"\n    ::= { expErrorEntry 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expErrorCode OBJECT-TYPE\n    SYNTAX      INTEGER {\n          invalidSyntax(1),\n          undefinedObjectIndex(2),\n          unrecognizedOperator(3),\n          unrecognizedFunction(4),\n          invalidOperandType(5),\n          unmatchedParenthesis(6),\n          tooManyWildcardValues(7),\n          recursion(8),\n          deltaTooShort(9),\n          resourceUnavailable(10),\n          divideByZero(11)\n          }\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n     \"The error that occurred.  In the following explanations the\n     expected timing of the error is in parentheses.  'S' means\n     the error occurs on a Set request.  'E' means the error\n     occurs on the attempt to evaluate the expression either due to\n     Get from expValueTable or in ongoing delta processing.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "invalidSyntax the value sent for expExpression is not valid Expression MIB expression syntax (S) undefinedObjectIndex an object reference ($n) in expExpression does not have a matching instance in expObjectTable (E) unrecognizedOperator the value sent for expExpression held an unrecognized operator (S) unrecognizedFunction the value sent for expExpression held an unrecognized function name (S) invalidOperandType an operand in expExpression is not the right type for the associated operator or result (SE) unmatchedParenthesis the value sent for expExpression is not correctly parenthesized (S) tooManyWildcardValues evaluating the expression exceeded the limit set by expResourceDeltaWildcardInstanceMaximum (E) recursion through some chain of embedded expressions the expression invokes itself (E) deltaTooShort the delta for the next evaluation passed before the system could evaluate the present sample (E) resourceUnavailable some resource, typically dynamic memory, was unavailable (SE) divideByZero an attempt to divide by zero occurred (E)",
      "ja": "invalidsyntax expexpressionのために送信された値は有効ではありませんmib式の式の構文undefinedobjectindex expexpressionのオブジェクト参照（$ n）は、expobjectable（e）未知の操作者に送られたexpxpressionのために送信される値を認識していないオペレーター（s）に一致するインスタンスを持っていません（s）認識されていない機能expxpressionのために送信された値は、認識されていない関数名を保持していませんexpexpressionのオペランドは、関連する演算子または結果のための正しいタイプではありません。ExpresourcededeltawildCardinstancemaximum（e）埋め込み式のいくつかのチェーンを介した再帰によって設定された制限を超えました。式は、式が呼び出されます（e）デルタは、システムが渡される次の評価のためにデルタを、現在のサンプル（e）リソースのリソースを評価することができます。利用できませんでした（SE）分割するゼロで分割する試みが発生しました（e）"
    },
    {
      "indent": 5,
      "text": "For the errors that occur when the attempt is made to set expExpression Set request fails with the SNMP error code 'wrongValue'. Such failures refer to the most recent failure to Set expExpression, not to the present value of expExpression which must be either unset or syntactically correct.",
      "ja": "Expexpressionセットリクエストを設定する試みが行われたときに発生するエラーの場合、SNMPエラーコード「誤解」で失敗します。このような障害は、非表示または構文的に正しいものでなければならない現在のexpxpressionの価値ではなく、Expxpressionを設定する最新の障害を指します。"
    },
    {
      "indent": 4,
      "text": " Errors that occur during evaluation for a Get* operation return\n the SNMP error code 'genErr' except for 'tooManyWildcardValues'\n and 'resourceUnavailable' which return the SNMP error code\n 'resourceUnavailable'.\"\n::= { expErrorEntry 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expErrorInstance OBJECT-TYPE\n    SYNTAX      OBJECT IDENTIFIER\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n     \"The expValueInstance being evaluated when the error\n     occurred.  A zero-length indicates irrelevance.\"\n    ::= { expErrorEntry 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- -- Object Table --",
      "ja": "---オブジェクトテーブル - "
    },
    {
      "indent": 0,
      "text": "expObjectTable OBJECT-TYPE SYNTAX SEQUENCE OF ExpObjectEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"A table of object definitions for each expExpression.",
      "ja": "ExpobjectTable Object-Type ExpobjectEntry Max-Access of-accessable not-accessable current current securty \"各expxpressionのオブジェクト定義の表。"
    },
    {
      "indent": 5,
      "text": "Wildcarding instance IDs:",
      "ja": "ワイルドカードインスタンスID："
    },
    {
      "indent": 4,
      "text": " It is legal to omit all or part of the instance portion for\n some or all of the objects in an expression. (See the\n DESCRIPTION of expObjectID for details.  However, note that\n if more than one object in the same expression is wildcarded\n in this way, they all must be objects where that portion of\n the instance is the same.  In other words, all objects may be\n in the same SEQUENCE or in different SEQUENCEs but with the\n same semantic index value (e.g., a value of ifIndex)\n for the wildcarded portion.\"\n::= { expDefine 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expObjectEntry OBJECT-TYPE SYNTAX ExpObjectEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"Information about an object. An application uses expObjectEntryStatus to create entries in this table while in the process of defining an expression.",
      "ja": "expobjectentryオブジェクトタイプ構文expobjectentry max-accessアクセス不可能なステータス現在の説明 \"オブジェクトに関する情報。アプリケーションはexpobjectentrystatusを使用して、式を定義している間にこのテーブルにエントリを作成します。"
    },
    {
      "indent": 4,
      "text": " Values of read-create objects in this table may be\n changed at any time.\"\nINDEX       { expExpressionOwner, expExpressionName, expObjectIndex }\n::= { expObjectTable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "ExpObjectEntry ::= SEQUENCE {\n    expObjectIndex                     Unsigned32,\n    expObjectID                        OBJECT IDENTIFIER,\n    expObjectIDWildcard                TruthValue,\n    expObjectSampleType                INTEGER,\n    expObjectDeltaDiscontinuityID      OBJECT IDENTIFIER,\n    expObjectDiscontinuityIDWildcard   TruthValue,\n    expObjectDiscontinuityIDType       INTEGER,\n    expObjectConditional               OBJECT IDENTIFIER,\n    expObjectConditionalWildcard       TruthValue,\n    expObjectEntryStatus               RowStatus\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expObjectIndex OBJECT-TYPE\n    SYNTAX      Unsigned32 (1..4294967295)\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n     \"Within an expression, a unique, numeric identification for an\n     object.  Prefixed with a dollar sign ('$') this is used to\n     reference the object in the corresponding expExpression.\"\n    ::= { expObjectEntry 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expObjectID OBJECT-TYPE SYNTAX OBJECT IDENTIFIER MAX-ACCESS read-create STATUS current DESCRIPTION \"The OBJECT IDENTIFIER (OID) of this object. The OID may be fully qualified, meaning it includes a complete instance identifier part (e.g., ifInOctets.1 or sysUpTime.0), or it may not be fully qualified, meaning it may lack all or part of the instance identifier. If the expObjectID is not fully qualified, then expObjectWildcard must be set to true(1). The value of the expression will be multiple values, as if done for a GetNext sweep of the object.",
      "ja": "expobjectidオブジェクトタイプの構文識別子識別子最大アクセス読み取り - 作成ステータス現在の説明 \"このオブジェクトのオブジェクト識別子（OID）。OIDは完全に適格である場合があります。.0）、またはそれは完全に適格でない場合があります。つまり、インスタンス識別子のすべてまたは一部を欠いている可能性があります。ExpobjectIDが完全に適格でない場合、expobjectWildCardをtrue（1）に設定する必要があります。オブジェクトのgetNextスイープに対して行われたように、複数の値。"
    },
    {
      "indent": 5,
      "text": "An object here may itself be the result of an expression but recursion is not allowed.",
      "ja": "ここのオブジェクト自体は表現の結果である可能性がありますが、再帰は許可されていません。"
    },
    {
      "indent": 4,
      "text": " NOTE:  The simplest implementations of this MIB may not allow\n wildcards.\"\n::= { expObjectEntry 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expObjectIDWildcard OBJECT-TYPE SYNTAX TruthValue MAX-ACCESS read-create STATUS current DESCRIPTION \"A true value indicates the expObjecID of this row is a wildcard object. False indicates that expObjectID is fully instanced. If all expObjectWildcard values for a given expression are FALSE, expExpressionPrefix will reflect a scalar object (i.e. will be 0.0).",
      "ja": "expobjectidWildCardオブジェクトタイプの構文ruthvalue max-access read-createステータス現在の説明 \"真の値は、この行のexpobjecidがワイルドカードオブジェクトであることを示します。falseはexpobjectidが完全にインスタンスされていることを示します。スカラーオブジェクトを反映します（つまり、0.0になります）。"
    },
    {
      "indent": 4,
      "text": "    NOTE:  The simplest implementations of this MIB may not allow\n    wildcards.\"\nDEFVAL      { false }\n::= { expObjectEntry 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expObjectSampleType OBJECT-TYPE SYNTAX INTEGER { absoluteValue(1), deltaValue(2), changedValue(3) } MAX-ACCESS read-create STATUS current DESCRIPTION \"The method of sampling the selected variable.",
      "ja": "expobjectsampletype object-type syntax integer {absolutevalue（1）、deltavalue（2）、chandervalue（3）} max-access read-createステータス現在の説明 \"選択した変数をサンプリングする方法。"
    },
    {
      "indent": 5,
      "text": "An 'absoluteValue' is simply the present value of the object.",
      "ja": "「絶対的な」は、単にオブジェクトの現在の値です。"
    },
    {
      "indent": 5,
      "text": "A 'deltaValue' is the present value minus the previous value, which was sampled expExpressionDeltaInterval seconds ago. This is intended primarily for use with SNMP counters, which are meaningless as an 'absoluteValue', but may be used with any integer-based value.",
      "ja": "「deltavalue」は、現在の値から以前の値を差し引いたものであり、数秒前にexpexpressiondeltaintervalがサンプリングされました。これは、主にSNMPカウンターで使用するためのものであり、「絶対的な」とは意味がありませんが、整数ベースの値で使用される場合があります。"
    },
    {
      "indent": 5,
      "text": "A 'changedValue' is a boolean for whether the present value is different from the previous value. It is applicable to any data type and results in an Unsigned32 with value 1 if the object's value is changed and 0 if not. In all other respects it is as a 'deltaValue' and all statements and operation regarding delta values apply to changed values.",
      "ja": "「変更値」は、現在の値が以前の値と異なるかどうかのブール値です。これは任意のデータ型に適用でき、オブジェクトの値が変更された場合は値1のunsigned32になり、そうでない場合は0になります。他のすべての点で、それは「デルタバルー」としてであり、デルタ値に関するすべてのステートメントと操作が変更された値に適用されます。"
    },
    {
      "indent": 4,
      "text": " When an expression contains both delta and absolute values\n the absolute values are obtained at the end of the delta\n period.\"\nDEFVAL      { absoluteValue }\n::= { expObjectEntry 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "sysUpTimeInstance OBJECT IDENTIFIER ::= { sysUpTime 0 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expObjectDeltaDiscontinuityID OBJECT-TYPE SYNTAX OBJECT IDENTIFIER MAX-ACCESS read-create STATUS current DESCRIPTION \"The OBJECT IDENTIFIER (OID) of a TimeTicks, TimeStamp, or DateAndTime object that indicates a discontinuity in the value at expObjectID.",
      "ja": "expobjectdeltadiscontinuityid object-type syntax object識別子max-access read-createステータス現在の説明 \"expobjectidの値の不連続性を示すタイムティック、タイムスタンプ、またはデータアンドタイムオブジェクトのオブジェクト識別子（OID）。"
    },
    {
      "indent": 5,
      "text": "This object is instantiated only if expObjectSampleType is 'deltaValue' or 'changedValue'.",
      "ja": "このオブジェクトは、expobjectsampletypeが「deltavalue」または「chandervalue」である場合にのみインスタンス化されます。"
    },
    {
      "indent": 5,
      "text": "The OID may be for a leaf object (e.g. sysUpTime.0) or may be wildcarded to match expObjectID.",
      "ja": "oidは、葉のオブジェクト（sysuptime.0など）用であるか、expobjectidに一致するようにワイルドカードされている場合があります。"
    },
    {
      "indent": 5,
      "text": "This object supports normal checking for a discontinuity in a counter. Note that if this object does not point to sysUpTime discontinuity checking must still check sysUpTime for an overall discontinuity.",
      "ja": "このオブジェクトは、カウンターの不連続性の通常のチェックをサポートします。このオブジェクトがsysuptimeの不連続性チェックを指していない場合、全体的な不連続性がsysuptimeを確認する必要があることに注意してください。"
    },
    {
      "indent": 4,
      "text": " If the object identified is not accessible no discontinuity\n check will be made.\"\nDEFVAL      { sysUpTimeInstance }\n::= { expObjectEntry 5 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expObjectDiscontinuityIDWildcard OBJECT-TYPE SYNTAX TruthValue MAX-ACCESS read-create STATUS current DESCRIPTION \"A true value indicates the expObjectDeltaDiscontinuityID of this row is a wildcard object. False indicates that expObjectDeltaDiscontinuityID is fully instanced.",
      "ja": "expobjectdiscontinuityidwildcard object-type struthvalue max-access read-createステータス現在の説明 \"真の値は、この行のexpobjectdeltadiscontinuityidがワイルドカードオブジェクトであることを示します。falseは、expobjectdeltadiscontinuityidが完全にインストールされていることを示します。"
    },
    {
      "indent": 5,
      "text": "This object is instantiated only if expObjectSampleType is 'deltaValue' or 'changedValue'.",
      "ja": "このオブジェクトは、expobjectsampletypeが「deltavalue」または「chandervalue」である場合にのみインスタンス化されます。"
    },
    {
      "indent": 4,
      "text": " NOTE:  The simplest implementations of this MIB may not allow\n wildcards.\"\nDEFVAL      { false }\n ::= { expObjectEntry 6 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expObjectDiscontinuityIDType OBJECT-TYPE SYNTAX INTEGER { timeTicks(1), timeStamp(2), dateAndTime(3) } MAX-ACCESS read-create STATUS current DESCRIPTION \"The value 'timeTicks' indicates the expObjectDeltaDiscontinuityID of this row is of syntax TimeTicks. The value 'timeStamp' indicates syntax TimeStamp. The value 'dateAndTime indicates syntax DateAndTime.",
      "ja": "expobjectDiscontinuityIdType Object-Type Syntax Integer {Timeticks（1）、Timestamp（2）、Dateandtime（3）}最大読み取りステータス現在の説明「値「タイムテック」は、この列のexpobjectdeltadiscontinuitididを示します。「タイムスタンプ」は、構文のタイムスタンプを示します。値 'dateandtimeは、構文のデータアンドタイムを示します。"
    },
    {
      "indent": 4,
      "text": " This object is instantiated only if expObjectSampleType is\n 'deltaValue' or 'changedValue'.\"\nDEFVAL      { timeTicks }\n ::= { expObjectEntry 7 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expObjectConditional OBJECT-TYPE SYNTAX OBJECT IDENTIFIER MAX-ACCESS read-create STATUS current DESCRIPTION \"The OBJECT IDENTIFIER (OID) of an object that overrides whether the instance of expObjectID is to be considered usable. If the value of the object at expObjectConditional is 0 or not instantiated, the object at expObjectID is treated as if it is not instantiated. In other words, expObjectConditional is a filter that controls whether or not to use the value at expObjectID.",
      "ja": "expobjectConditionalオブジェクトタイプ構文識別子識別子最大アクセス読み取り -  createステータス現在の説明インスタンス化されていないため、expobjectIDのオブジェクトはインスタンス化されていないかのように扱われます。つまり、expobjectContionalは、expobjectIDで値を使用するかどうかを制御するフィルターです。"
    },
    {
      "indent": 5,
      "text": "The OID may be for a leaf object (e.g. sysObjectID.0) or may be wildcarded to match expObjectID. If expObject is wildcarded and expObjectID in the same row is not, the wild portion of expObjectConditional must match the wildcarding of the rest of the expression. If no object in the expression is wildcarded but expObjectConditional is, use the lexically first instance (if any) of expObjectConditional.",
      "ja": "oidは、葉のオブジェクト（sysobjectid.0など）用であるか、expobjectidに一致するようにワイルドカードされている場合があります。expobjectがワイルドカードであり、同じ行のexpobjectidがそうでない場合、expobjectConditionalの野生部分は、式の残りの部分の野生カードと一致する必要があります。式のオブジェクトがワイルドカードされていないが、expobjectConditionalがexpobjectContionalの語彙的に最初のインスタンス（もしあれば）を使用します。"
    },
    {
      "indent": 5,
      "text": "If the value of expObjectConditional is 0.0 operation is as if the value pointed to by expObjectConditional is a non-zero (true) value.",
      "ja": "expobjectContionalの値が0.0の場合の場合、expobjectContionalによって指される値が非ゼロ（真）値であるかのようです。"
    },
    {
      "indent": 4,
      "text": " Note that expObjectConditional can not trivially use an object\n of syntax TruthValue, since the underlying value is not 0 or 1.\"\nDEFVAL      { zeroDotZero }\n::= { expObjectEntry 8 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "expObjectConditionalWildcard OBJECT-TYPE SYNTAX TruthValue MAX-ACCESS read-create STATUS current DESCRIPTION",
      "ja": "expobjectConditionalWildcard Object-Type Syntax TruthValue Max-Access Read-Createステータス現在の説明"
    },
    {
      "indent": 5,
      "text": "\"A true value indicates the expObjectConditional of this row is a wildcard object. False indicates that expObjectConditional is fully instanced.",
      "ja": "「真の値は、この行のexpobjectContionalがワイルドカードオブジェクトであることを示します。Falseは、expobjectContionalが完全にインスタンスされていることを示します。"
    },
    {
      "indent": 4,
      "text": " NOTE: The simplest implementations of this MIB may not allow\n wildcards.\"\nDEFVAL      { false }\n ::= { expObjectEntry 9 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expObjectEntryStatus OBJECT-TYPE SYNTAX RowStatus MAX-ACCESS read-create STATUS current DESCRIPTION \"The control that allows creation/deletion of entries.",
      "ja": "expobjectentrystatusオブジェクトタイプ構文rowStatus max-access read-createステータス現在の説明 \"エントリの作成/削除を可能にするコントロール。"
    },
    {
      "indent": 4,
      "text": " Objects in this table may be changed while\n expObjectEntryStatus is in any state.\"\n::= { expObjectEntry 10 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- -- Expression Value Table --",
      "ja": "---式値表 - "
    },
    {
      "indent": 0,
      "text": "expValueTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF ExpValueEntry\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n     \"A table of values from evaluated expressions.\"\n    ::= { expValue 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expValueEntry OBJECT-TYPE SYNTAX ExpValueEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"A single value from an evaluated expression. For a given instance, only one 'Val' object in the conceptual row will be instantiated, that is, the one with the appropriate type for the value. For values that contain no objects of expObjectSampleType 'deltaValue' or 'changedValue', reading a value from the table causes the evaluation of the expression for that value. For those that contain a 'deltaValue' or 'changedValue' the value read is as of the last sampling interval.",
      "ja": "expvalueEntryオブジェクトタイプの構文expvalueEntry max-accessアクセス不可能なステータス現在の説明 \"評価された式からの単一の値。特定のインスタンスでは、概念行の1つの「val」オブジェクトのみがインスタンス化されます。値の適切なタイプ。Expobjectsampletype「deltavalue」または「changedValue」のオブジェクトを含む値の場合、テーブルから値を読み取ると、その値の式の評価が生じます。読み取り値は、最後のサンプリング間隔の時点です。"
    },
    {
      "indent": 5,
      "text": "If in the attempt to evaluate the expression one or more of the necessary objects is not available, the corresponding entry in this table is effectively not instantiated.",
      "ja": "式を評価しようとすると、必要なオブジェクトの1つ以上が使用できない場合、この表の対応するエントリは事実上インスタンス化されていません。"
    },
    {
      "indent": 5,
      "text": "To maintain security of MIB information, when creating a new row in this table, the managed system must record the security credentials of the requester. These security credentials are the parameters necessary as inputs to isAccessAllowed from [RFC2571]. When obtaining the objects that make up the expression, the system must (conceptually) use isAccessAllowed to ensure that it does not violate security.",
      "ja": "MIB情報のセキュリティを維持するために、このテーブルに新しい行を作成する場合、管理されたシステムは要求者のセキュリティ資格情報を記録する必要があります。これらのセキュリティ資格情報は、[RFC2571]からISACCESSALLOWに入力するために必要なパラメーターです。式を構成するオブジェクトを取得する場合、システムは（概念的に）ISACCESSALLOWEDを使用して、セキュリティに違反しないことを確認する必要があります。"
    },
    {
      "indent": 5,
      "text": "The evaluation of that expression takes place under the security credentials of the creator of its expExpressionEntry.",
      "ja": "その表現の評価は、そのexpexpressionentryの作成者のセキュリティ資格の下で行われます。"
    },
    {
      "indent": 4,
      "text": " To maintain security of MIB information, expression evaluation must\n take place using security credentials for the implied Gets of the\n objects in the expression as inputs (conceptually) to\n isAccessAllowed from the Architecture for Describing SNMP\n Management Frameworks.  These are the security credentials of the\n creator of the corresponding expExpressionEntry.\"\nINDEX       { expExpressionOwner, expExpressionName,\n              IMPLIED expValueInstance }\n::= { expValueTable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "ExpValueEntry ::= SEQUENCE {\n    expValueInstance          OBJECT IDENTIFIER,\n    expValueCounter32Val      Counter32,\n    expValueUnsigned32Val     Unsigned32,\n    expValueTimeTicksVal      TimeTicks,\n    expValueInteger32Val      Integer32,\n    expValueIpAddressVal      IpAddress,\n    expValueOctetStringVal    OCTET STRING,\n    expValueOidVal            OBJECT IDENTIFIER,\n    expValueCounter64Val      Counter64\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expValueInstance OBJECT-TYPE SYNTAX OBJECT IDENTIFIER MAX-ACCESS not-accessible STATUS current DESCRIPTION \"The final instance portion of a value's OID according to the wildcarding in instances of expObjectID for the expression. The prefix of this OID fragment is 0.0, leading to the following behavior.",
      "ja": "expvalueInstanceオブジェクトタイプ構文識別識別子最大アクセスアクセス不可能なステータス現在の説明行動。"
    },
    {
      "indent": 5,
      "text": "If there is no wildcarding, the value is 0.0.0. In other words, there is one value which standing alone would have been a scalar with a 0 at the end of its OID.",
      "ja": "ワイルドカードがない場合、値は0.0.0です。言い換えれば、OIDの終わりに0が0のスカラーであったであろう1つの値があります。"
    },
    {
      "indent": 4,
      "text": " If there is wildcarding, the value is 0.0 followed by\n a value that the wildcard can take, thus defining one value\n instance for each real, possible value of the wildcard.\n So, for example, if the wildcard worked out to be an ifIndex,\n there is an expValueInstance for each applicable ifIndex.\"\n::= { expValueEntry 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expValueCounter32Val OBJECT-TYPE\n    SYNTAX      Counter32\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n     \"The value when expExpressionValueType is 'counter32'.\"\n    ::= { expValueEntry 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expValueUnsigned32Val OBJECT-TYPE\n    SYNTAX      Unsigned32\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n     \"The value when expExpressionValueType is 'unsigned32'.\"\n    ::= { expValueEntry 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expValueTimeTicksVal OBJECT-TYPE\n    SYNTAX      TimeTicks\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n     \"The value when expExpressionValueType is 'timeTicks'.\"\n    ::= { expValueEntry 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expValueInteger32Val OBJECT-TYPE\n    SYNTAX      Integer32\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n     \"The value when expExpressionValueType is 'integer32'.\"\n    ::= { expValueEntry 5 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expValueIpAddressVal OBJECT-TYPE\n    SYNTAX      IpAddress\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n     \"The value when expExpressionValueType is 'ipAddress'.\"\n    ::= { expValueEntry 6 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expValueOctetStringVal OBJECT-TYPE\n    SYNTAX      OCTET STRING (SIZE (0..65536))\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n     \"The value when expExpressionValueType is 'octetString'.\"\n    ::= { expValueEntry 7 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expValueOidVal OBJECT-TYPE\n    SYNTAX      OBJECT IDENTIFIER\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n     \"The value when expExpressionValueType is 'objectId'.\"\n    ::= { expValueEntry 8 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "expValueCounter64Val OBJECT-TYPE\n    SYNTAX      Counter64\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n     \"The value when expExpressionValueType is 'counter64'.\"\n    ::= { expValueEntry 9 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- -- Conformance --",
      "ja": "---適合 - "
    },
    {
      "indent": 0,
      "text": "dismanExpressionMIBConformance OBJECT IDENTIFIER ::=\n    { dismanExpressionMIB 3 }\ndismanExpressionMIBCompliances OBJECT IDENTIFIER ::=\n    { dismanExpressionMIBConformance 1 }\ndismanExpressionMIBGroups      OBJECT IDENTIFIER ::=\n    { dismanExpressionMIBConformance 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Compliance",
      "ja": " - コンプライアンス"
    },
    {
      "indent": 0,
      "text": "dismanExpressionMIBCompliance MODULE-COMPLIANCE\n     STATUS current\n     DESCRIPTION\n          \"The compliance statement for entities which implement\n          the Expression MIB.\"\n     MODULE    -- this module\n          MANDATORY-GROUPS {\n               dismanExpressionResourceGroup,\n               dismanExpressionDefinitionGroup,\n               dismanExpressionValueGroup\n          }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "OBJECT expResourceDeltaMinimum SYNTAX Integer32 (-1 | 60..600) DESCRIPTION \"Implementation need not allow deltas or it may implement them and restrict them to higher values.\"",
      "ja": "オブジェクトExpResourcedeltaminimum Syntax Integer32（-1 | 60..600）説明「実装はDeltasを許可する必要はないか、それらを実装してより高い値に制限することができます。」"
    },
    {
      "indent": 5,
      "text": "OBJECT expObjectSampleType WRITE-SYNTAX INTEGER { absoluteValue(1) } DESCRIPTION \"Implementation may disallow deltas calculation or change detection.\"",
      "ja": "オブジェクトexpobjectsampletype write-syntax integer {absolutevalue（1）}説明「実装は、デルタの計算または変更の検出を許可する可能性があります。」"
    },
    {
      "indent": 5,
      "text": "OBJECT expObjectIDWildcard WRITE-SYNTAX INTEGER { false(2) } DESCRIPTION \"Implementation may allow wildcards.\"",
      "ja": "Object expobjectIdWildCard write-syntax integer {false（2）}説明「実装はワイルドカードを許可する場合があります。」"
    },
    {
      "indent": 5,
      "text": "OBJECT expObjectDiscontinuityIDWildcard WRITE-SYNTAX INTEGER { false(2) } DESCRIPTION \"Implementation need not allow wildcards.\"",
      "ja": "オブジェクトexpobjectDiscontinuityIdWildCard write-syntax integer {false（2）}説明「実装はワイルドカードを許可する必要はありません。」"
    },
    {
      "indent": 5,
      "text": "OBJECT expObjectConditionalWildcard WRITE-SYNTAX INTEGER { false(2) } DESCRIPTION \"Implementation need not allow deltas wildcards.\"",
      "ja": "オブジェクトexpobjectConditionalWildcard write-syntax integer {false（2）}説明「実装はDeltas Wildcardsを許可する必要はありません。」"
    },
    {
      "indent": 5,
      "text": "::= { dismanExpressionMIBCompliances 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Units of Conformance",
      "ja": " - 適合ユニット"
    },
    {
      "indent": 0,
      "text": "dismanExpressionResourceGroup OBJECT-GROUP\n     OBJECTS {\n          expResourceDeltaMinimum,\n          expResourceDeltaWildcardInstanceMaximum,\n          expResourceDeltaWildcardInstances,\n          expResourceDeltaWildcardInstancesHigh,\n          expResourceDeltaWildcardInstanceResourceLacks\n     }\n     STATUS current\n     DESCRIPTION\n          \"Expression definition resource management.\"\n     ::= { dismanExpressionMIBGroups 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "dismanExpressionDefinitionGroup OBJECT-GROUP OBJECTS { expExpression, expExpressionValueType, expExpressionComment, expExpressionDeltaInterval, expExpressionPrefix, expExpressionErrors, expExpressionEntryStatus,",
      "ja": "DismanExpressionDefinitionGroup Object Group Objects {Expexpression、ExpexpressionValueType、expexppressionComment、ExpexpressionDeltainterval、ExpexpressionPrefix、ExpexpressionErrors、ExpexpressionEntrystatus、"
    },
    {
      "indent": 5,
      "text": "     expErrorTime,\n     expErrorIndex,\n     expErrorCode,\n     expErrorInstance,\n          expObjectID,\n     expObjectIDWildcard,\n     expObjectSampleType,\n     expObjectDeltaDiscontinuityID,\n     expObjectDiscontinuityIDWildcard,\n     expObjectDiscontinuityIDType,\n     expObjectConditional,\n     expObjectConditionalWildcard,\n     expObjectEntryStatus\n}\nSTATUS current\nDESCRIPTION\n     \"Expression definition.\"\n::= { dismanExpressionMIBGroups 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "dismanExpressionValueGroup OBJECT-GROUP\n     OBJECTS {\n          expValueCounter32Val,\n          expValueUnsigned32Val,\n          expValueTimeTicksVal,\n          expValueInteger32Val,\n          expValueIpAddressVal,\n          expValueOctetStringVal,\n          expValueOidVal,\n          expValueCounter64Val\n     }\n     STATUS current\n     DESCRIPTION\n          \"Expression value.\"\n     ::= { dismanExpressionMIBGroups 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "END",
      "ja": "終わり"
    },
    {
      "indent": 0,
      "text": "4. Intellectual Property",
      "section_title": true,
      "ja": "4. 知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any effort to identify any such rights. Information on the IETF's procedures with respect to rights in standards-track and standards- related documentation can be found in BCP-11. Copies of claims of rights made available for publication and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementors or users of this specification can be obtained from the IETF Secretariat.",
      "ja": "IETFは、知的財産またはその他の権利の有効性または範囲に関して、この文書に記載されているテクノロジーの実装または使用に関連すると主張される可能性のある他の権利、またはそのような権利に基づくライセンスがどの程度であるかについての程度に関連する可能性があるという立場はありません。利用可能;また、そのような権利を特定するために努力したことも表明していません。標準トラックおよび標準関連の文書における権利に関するIETFの手順に関する情報は、BCP-11に記載されています。出版のために利用可能にされた権利の請求のコピーと、利用可能になるライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような独自の権利の使用のための一般的なライセンスまたは許可を取得しようとする試みの結果を得ることができますIETF事務局から。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights which may cover technology that may be required to practice this standard. Please address the information to the IETF Executive Director.",
      "ja": "IETFは、関心のある当事者に、この基準を実践するために必要な技術をカバーする可能性のある著作権、特許、または特許出願、またはその他の独自の権利を注意深く招待するよう招待しています。情報をIETFエグゼクティブディレクターに宛ててください。"
    },
    {
      "indent": 0,
      "text": "5. Acknowledgements",
      "section_title": true,
      "ja": "5. 謝辞"
    },
    {
      "indent": 3,
      "text": "This MIB contains considerable contributions from the Distributed Management Design Team (Andy Bierman, Maria Greene, Bob Stewart, and Steve Waldbusser), and colleagues at Cisco who did the first implementation.",
      "ja": "このMIBには、分散型管理デザインチーム（Andy Bierman、Maria Greene、Bob Stewart、Steve Waldbusser）と、最初の実装を行ったCiscoの同僚からのかなりの貢献が含まれています。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6. 参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC2571] Harrington, D., Presuhn, R. and B. Wijnen, \"An Architecture Describing SNMP Management Frameworks\", RFC 2571, April 1999.",
      "ja": "[RFC2571] Harrington、D.、Presuhn、R。、およびB. Wijnen、「SNMP管理フレームワークを説明するアーキテクチャ」、RFC 2571、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC1155] Rose, M. and K. McCloghrie, \"Structure and Identification of Management Information for TCP/IP-based Internets\", STD 16, RFC 1155, May 1990.",
      "ja": "[RFC1155] Rose、M。およびK. McCloghrie、「TCP/IPベースのインターネットの管理情報の構造と識別」、STD 16、RFC 1155、1990年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC1212] Rose, M. and K. McCloghrie, \"Concise MIB Definitions\", STD 16, RFC 1212, March 1991.",
      "ja": "[RFC1212] Rose、M。およびK. McCloghrie、「Concise MIB Definitions」、STD 16、RFC 1212、1991年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC1215] Rose, M., \"A Convention for Defining Traps for use with the SNMP\", RFC 1215, March 1991.",
      "ja": "[RFC1215] Rose、M。、「SNMPで使用するためのトラップを定義するための条約」、RFC 1215、1991年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2578] McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M. and S. Waldbusser, \"Structure of Management Information Version 2 (SMIv2)\", STD 58, RFC 2578, April 1999.",
      "ja": "[RFC2578] McCloghrie、K.、Perkins、D.、Schoenwaelder、J.、Case、J.、Rose、M。、およびS. Waldbusser、「管理情報の構造バージョン2（SMIV2）、STD 58、RFC 2578、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2579] McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M. and S. Waldbusser, \"Textual Conventions for SMIv2\", STD 58, RFC 2579, April 1999.",
      "ja": "[RFC2579] McCloghrie、K.、Perkins、D.、Schoenwaelder、J.、Case、J.、Rose、M。、およびS. Waldbusser、「SMIV2のテキストコンベンション」、STD 58、RFC 2579、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2580] McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M. and S. Waldbusser, \"Conformance Statements for SMIv2\", STD 58, RFC 2580, April 1999.",
      "ja": "[RFC2580] McCloghrie、K.、Perkins、D.、Schoenwaelder、J.、Case、J.、Rose、M。、およびS. Waldbusser、「Smiv2の適合ステートメント」、STD 58、RFC 2580、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC1157] Case, J., Fedor, M., Schoffstall, M. and J. Davin, \"Simple Network Management Protocol\", STD 15, RFC 1157, May 1990.",
      "ja": "[RFC1157] Case、J.、Fedor、M.、Schoffstall、M。、およびJ. Davin、「Simple Network Management Protocol」、STD 15、RFC 1157、1990年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC1901] Case, J., McCloghrie, K., Rose, M. and S. Waldbusser, \"Introduction to Community-based SNMPv2\", RFC 1901, January 1996.",
      "ja": "[RFC1901] Case、J.、McCloghrie、K.、Rose、M。、およびS. Waldbusser、「コミュニティベースのSNMPV2の紹介」、RFC 1901、1996年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC1906] Case, J., McCloghrie, K., Rose, M. and S. Waldbusser, \"Transport Mappings for Version 2 of the Simple Network Management Protocol (SNMPv2)\", RFC 1906, January 1996.",
      "ja": "[RFC1906] Case、J.、McCloghrie、K.、Rose、M。、およびS. Waldbusser、「Simple Network Management Protocol（SNMPV2）のバージョン2の輸送マッピング」、RFC 1906、1996年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC2572] Case, J., Harrington D., Presuhn R. and B. Wijnen, \"Message Processing and Dispatching for the Simple Network Management Protocol (SNMP)\", RFC 2572, April 1999.",
      "ja": "[RFC2572] Case、J.、Harrington D.、Presuhn R.およびB. Wijnen、「Simple Network Management Protocol（SNMP）のメッセージ処理とディスパッチ」、RFC 2572、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2574] Blumenthal, U. and B. Wijnen, \"User-based Security Model (USM) for version 3 of the Simple Network Management Protocol (SNMPv3)\", RFC 2574, April 1999.",
      "ja": "[RFC2574] Blumenthal、U.およびB. Wijnen、「シンプルネットワーク管理プロトコル（SNMPV3）のバージョン3のユーザーベースのセキュリティモデル（USM）」、RFC 2574、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC1905] Case, J., McCloghrie, K., Rose, M. and S. Waldbusser, \"Protocol Operations for Version 2 of the Simple Network Management Protocol (SNMPv2)\", RFC 1905, January 1996.",
      "ja": "[RFC1905] Case、J.、McCloghrie、K.、Rose、M。、およびS. Waldbusser、「Simple Network Management Protocol（SNMPV2）のバージョン2のプロトコル操作」、RFC 1905、1996年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC2573] Levi, D., Meyer, P. and B. Stewart, \"SNMPv3 Applications\", RFC 2573, April 1999.",
      "ja": "[RFC2573] Levi、D.、Meyer、P。and B. Stewart、「SNMPV3 Applications」、RFC 2573、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2575] Wijnen, B., Presuhn, R. and K. McCloghrie, \"View-based Access Control Model (VACM) for the Simple Network Management Protocol (SNMP)\", RFC 2575, April 1999.",
      "ja": "[RFC2575] Wijnen、B.、Presuhn、R。、およびK. McCloghrie、「シンプルネットワーク管理プロトコル（SNMP）のビューベースのアクセス制御モデル（VACM）」、1999年4月、RFC 2575。"
    },
    {
      "indent": 3,
      "text": "[RFC2570] Case, J., Mundy, R., Partain, D. and B. Stewart, \"Introduction to Version 3 of the Internet-standard Network Management Framework\", RFC 2570, April 1999.",
      "ja": "[RFC2570] Case、J.、Mundy、R.、Partain、D。およびB. Stewart、「インターネット標準ネットワーク管理フレームワークのバージョン3の紹介」、RFC 2570、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC1903] Case, J., McCloghrie, K., Rose, M. and S. Waldbusser, \"Coexistence between Version 1 and version 2 of the Internet-standard Network Management Framework\", RFC 1903, January 1996.",
      "ja": "[RFC1903] Case、J.、McCloghrie、K.、Rose、M。、およびS. Waldbusser、「インターネット標準ネットワーク管理フレームワークのバージョン1とバージョン2の共存」、RFC 1903、1996年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC2981] Stewart, B., \"Event MIB\", RFC 2981, October 2000.",
      "ja": "[RFC2981]スチュワート、B。、「イベントMIB」、RFC 2981、2000年10月。"
    },
    {
      "indent": 3,
      "text": "[PracPersp] Leinwand, A. and K. Fang, \"Network Management: A Practical Perspective\", Addison-Wesley Publishing Company, Inc., 1993.",
      "ja": "[Pracpersp] Leinwand、A。and K. Fang、「ネットワーク管理：実用的な視点」、Addison-Wesley Publishing Company、Inc.、1993。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Expression MIB security involves two perspectives: protection of expressions from tampering or unauthorized use of resources, and protection of the objects used to calculate the expressions.",
      "ja": "Expression MIBセキュリティには、2つの視点が含まれます。リソースの改ざんまたは不正使用からの表現の保護と、式の計算に使用されるオブジェクトの保護です。"
    },
    {
      "indent": 3,
      "text": "Security of expression definitions and results depends on the expression owner (expExpressionOwner). With view-based access control [RFC2575] a network manager can control who has what level of access to what expressions.",
      "ja": "式の定義と結果のセキュリティは、式の所有者（Expxpressionowner）に依存します。ビューベースのアクセス制御[RFC2575]を使用すると、ネットワークマネージャーは、どの式へのアクセスレベルを誰が持っているかを制御できます。"
    },
    {
      "indent": 3,
      "text": "Access control for the objects within the expression depends on the security credentials of the expression creator. These are the security credentials used to get the objects necessary to evaluate the expression. They are the security credentials that were used to set the expExpressionRowStatus object for that expression to 'active', as recorded by the managed system.",
      "ja": "式内のオブジェクトのアクセス制御は、式作成者のセキュリティ資格情報に依存します。これらは、式の評価に必要なオブジェクトを取得するために使用されるセキュリティ資格情報です。これらは、管理されたシステムによって記録されているように、その式のexpexpressionRowStatusオブジェクトを「アクティブ」に設定するために使用されたセキュリティ資格情報です。"
    },
    {
      "indent": 3,
      "text": "This means that the results of an expression could potentially be made available to someone who does not have access to the raw data that went into them. This could be either legitimate or a security violation, depending on the specific situation and security policy.",
      "ja": "これは、表現の結果が、それらに入った生データにアクセスできない人が利用できる可能性があることを意味します。これは、特定の状況とセキュリティポリシーに応じて、正当な違反またはセキュリティ違反のいずれかです。"
    },
    {
      "indent": 3,
      "text": "To facilitate the provisioning of access control by a security administrator for this MIB itself using the View-Based Access Control Model (VACM) defined in RFC 2575 [RFC2575] for tables in which multiple users may need to independently create or modify entries, the initial index is used as an \"owner index\". Such an initial index has a syntax of SnmpAdminString, and can thus be trivially mapped to a securityName or groupName as defined in VACM, in accordance with a security policy.",
      "ja": "このMIB自体のセキュリティ管理者によるアクセス制御のプロビジョニングを容易にするために、複数のユーザーが独立してエントリを作成または変更する必要があるテーブルについて、RFC 2575 [RFC2575]で定義されたビューベースのアクセス制御モデル（VACM）を使用して、初期インデックスは「所有者インデックス」として使用されます。このような初期インデックスには、snmpadminstringの構文があり、したがって、セキュリティポリシーに従って、vacmで定義されているように、SecurityNameまたはGroupNameに簡単にマッピングできます。"
    },
    {
      "indent": 3,
      "text": "All entries in related tables belonging to a particular user will have the same value for this initial index. For a given user's entries in a particular table, the object identifiers for the information in these entries will have the same subidentifiers (except for the \"column\" subidentifier) up to the end of the encoded owner index. To configure VACM to permit access to this portion of the table, one would create vacmViewTreeFamilyTable entries with the value of vacmViewTreeFamilySubtree including the owner index portion, and vacmViewTreeFamilyMask \"wildcarding\" the column subidentifier. More elaborate configurations are possible.",
      "ja": "特定のユーザーに属する関連テーブルのすべてのエントリは、この初期インデックスに対して同じ値を持ちます。特定のテーブルにある特定のユーザーのエントリの場合、これらのエントリの情報のオブジェクト識別子は、エンコードされた所有者インデックスの最後まで同じサブ条約者（「列」のサブアイデンティファイアを除く）を持っています。テーブルのこの部分へのアクセスを許可するためにVacmを構成するために、所有者インデックス部分を含むvacmviewTreefamilySubtreeの値とvacmviewTreefamilymaskのcolumn subidentifierを含むvacmviewtreefamilysubtreeのvacmviewtreefamilytableエントリを作成します。より精巧な構成が可能です。"
    },
    {
      "indent": 0,
      "text": "8. Author's Address",
      "section_title": true,
      "ja": "8. 著者の連絡先"
    },
    {
      "indent": 3,
      "text": "Bob Stewart Cisco Systems, Inc. 170 West Tasman Drive San Jose, CA 95134-1706 U.S.A.",
      "ja": "Bob Stewart Cisco Systems、Inc。170 West Tasman Drive San Jose、CA 95134-1706 U.S.A."
    },
    {
      "indent": 0,
      "text": "9. Editor's Address",
      "section_title": true,
      "ja": "9. 編集者のアドレス"
    },
    {
      "indent": 3,
      "text": "Ramanathan Kavasseri Cisco Systems, Inc. 170 West Tasman Drive San Jose, CA 95134-1706 U.S.A.",
      "ja": "Ramanathan Kavasseri Cisco Systems、Inc。170 West Tasman Drive San Jose、CA 95134-1706 U.S.A."
    },
    {
      "indent": 3,
      "text": "Phone: +1 408 527 2446\nEMail: ramk@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "10. Full Copyright Statement",
      "section_title": true,
      "ja": "10. 完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2000). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2000）。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントと本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}