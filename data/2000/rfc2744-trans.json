{
  "title": {
    "text": "RFC 2744 - Generic Security Service API Version 2 : C-bindings",
    "ja": "RFC 2744 - ジェネリックセキュリティサービスAPIバージョン2：Cバインディング"
  },
  "number": 2744,
  "created_at": "2024-02-03 05:17:43.283987+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                             J. Wray\nRequest for Comments: 2744                                Iris Associates\nObsoletes: 1509                                              January 2000\nCategory: Standards Track",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Generic Security Service API Version 2 : C-bindings",
      "ja": "ジェネリックセキュリティサービスAPIバージョン2：Cバインディング"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2000). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2000）。無断転載を禁じます。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document specifies C language bindings for Version 2, Update 1 of the Generic Security Service Application Program Interface (GSS-API), which is described at a language-independent conceptual level in RFC-2743 [GSSAPI]. It obsoletes RFC-1509, making specific incremental changes in response to implementation experience and liaison requests. It is intended, therefore, that this memo or a successor version thereof will become the basis for subsequent progression of the GSS-API specification on the standards track.",
      "ja": "このドキュメントは、RFC-2743 [GSSAPI]の言語に依存しない概念レベルで説明されているジェネリックセキュリティサービスアプリケーションプログラムインターフェイス（GSS-API）のバージョン2、更新1のC言語バインディングを指定します。RFC-1509が廃止され、実装の経験とリエゾンリクエストに応じて特定の増分変化をもたらします。したがって、このメモまたはその後継バージョンは、標準トラックでのGSS-API仕様のその後の進行の基礎となることを意図しています。"
    },
    {
      "indent": 3,
      "text": "The Generic Security Service Application Programming Interface provides security services to its callers, and is intended for implementation atop a variety of underlying cryptographic mechanisms. Typically, GSS-API callers will be application protocols into which security enhancements are integrated through invocation of services provided by the GSS-API. The GSS-API allows a caller application to authenticate a principal identity associated with a peer application, to delegate rights to a peer, and to apply security services such as confidentiality and integrity on a per-message basis.",
      "ja": "Generic Security Service Applicationプログラミングインターフェイスは、発信者にセキュリティサービスを提供し、さまざまな基礎となる暗号化メカニズムの上で実装を目的としています。通常、GSS-API発信者は、GSS-APIが提供するサービスの呼び出しを通じてセキュリティ強化が統合されるアプリケーションプロトコルとなります。GSS-APIを使用すると、発信者アプリケーションは、ピアアプリケーションに関連する主要なアイデンティティを認証し、ピアに権利を委任し、守秘義務や整合性などのセキュリティサービスを1人あたりベースで適用できます。"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The Generic Security Service Application Programming Interface [GSSAPI] provides security services to calling applications. It allows a communicating application to authenticate the user associated with another application, to delegate rights to another application, and to apply security services such as confidentiality and integrity on a per-message basis.",
      "ja": "ジェネリックセキュリティサービスアプリケーションプログラミングインターフェイス[GSSAPI]は、呼び出しアプリケーションにセキュリティサービスを提供します。これにより、通信アプリケーションが別のアプリケーションに関連付けられているユーザーを認証し、別のアプリケーションに権利を委任し、守秘義務や整合性などのセキュリティサービスを適用することができます。"
    },
    {
      "indent": 3,
      "text": "There are four stages to using the GSS-API:",
      "ja": "GSS-APIの使用には4つの段階があります。"
    },
    {
      "indent": 3,
      "text": "a) The application acquires a set of credentials with which it may prove its identity to other processes. The application's credentials vouch for its global identity, which may or may not be related to any local username under which it may be running.",
      "ja": "a) アプリケーションは、他のプロセスに対するアイデンティティを証明する可能性のある資格情報のセットを取得します。アプリケーションの資格情報は、そのグローバルアイデンティティを保証します。これは、実行中のローカルユーザー名に関連している場合と関連している場合があります。"
    },
    {
      "indent": 3,
      "text": "b) A pair of communicating applications establish a joint security context using their credentials. The security context is a pair of GSS-API data structures that contain shared state information, which is required in order that per-message security services may be provided. Examples of state that might be shared between applications as part of a security context are cryptographic keys, and message sequence numbers. As part of the establishment of a security context, the context initiator is authenticated to the responder, and may require that the responder is authenticated in turn. The initiator may optionally give the responder the right to initiate further security contexts, acting as an agent or delegate of the initiator. This transfer of rights is termed delegation, and is achieved by creating a set of credentials, similar to those used by the initiating application, but which may be used by the responder.",
      "ja": "b) 通信アプリケーションのペアは、資格情報を使用して共同セキュリティコンテキストを確立します。セキュリティコンテキストは、共有された状態情報を含むGSS-APIデータ構造のペアです。これは、セキュリティごとのセキュリティサービスを提供できるために必要です。セキュリティコンテキストの一部としてアプリケーション間で共有される可能性のある状態の例は、暗号化キーとメッセージシーケンス番号です。セキュリティコンテキストの確立の一環として、コンテキストイニシエーターはレスポンダーに認証され、レスポンダーが順番に認証されることを要求する場合があります。イニシエーターは、オプションで、イニシエーターのエージェントまたは代表として機能し、さらなるセキュリティコンテキストを開始する権利を応答者に与えることができます。この権利の移転は委任と呼ばれ、開始アプリケーションで使用されるものと同様に、資格情報のセットを作成することで達成されますが、レスポンダーでは使用できます。"
    },
    {
      "indent": 6,
      "text": "To establish and maintain the shared information that makes up the security context, certain GSS-API calls will return a token data structure, which is an opaque data type that may contain cryptographically protected data. The caller of such a GSS-API routine is responsible for transferring the token to the peer application, encapsulated if necessary in an application-application protocol. On receipt of such a token, the peer application should pass it to a corresponding GSS-API routine which will decode the token and extract the information, updating the security context state information accordingly.",
      "ja": "セキュリティコンテキストを構成する共有情報を確立および維持するために、特定のGSS-API呼び出しは、暗号化されたデータ構造を含む不透明なデータ型であるトークンデータ構造を返します。このようなGSS-APIルーチンの発信者は、トークンをピアアプリケーションに転送する責任があります。これは、アプリケーションアプリケーションプロトコルで必要に応じてカプセル化されています。このようなトークンを受け取ると、ピアアプリケーションは、トークンをデコードして抽出し、セキュリティコンテキスト状態情報をそれに応じて更新する対応するGSS-APIルーチンに渡す必要があります。"
    },
    {
      "indent": 3,
      "text": "c) Per-message services are invoked to apply either:",
      "ja": "c) どちらかを適用するために、メッセージごとのサービスが呼び出されます。"
    },
    {
      "indent": 6,
      "text": "integrity and data origin authentication, or confidentiality, integrity and data origin authentication to application data, which are treated by GSS-API as arbitrary octet-strings. An application transmitting a message that it wishes to protect will call the appropriate GSS-API routine (gss_get_mic or gss_wrap) to apply protection, specifying the appropriate security context, and send the resulting token to the receiving application. The receiver will pass the received token (and, in the case of data protected by gss_get_mic, the accompanying message-data) to the corresponding decoding routine (gss_verify_mic or gss_unwrap) to remove the protection and validate the data.",
      "ja": "整合性とデータ起源の認証、または機密性、整合性、データ起源の認証は、GSS-APIによって任意のオクテットストリングとして扱われます。保護したいメッセージを送信するアプリケーションは、適切なGSS-APIルーチン（GSS_GET_MICまたはGSS_WRAP）を呼び出して保護を適用し、適切なセキュリティコンテキストを指定し、結果のトークンを受信アプリケーションに送信します。受信者は、受信したトークン（および、GSS_GET_MIC、付随するメッセージ-DATAによって保護されているデータの場合）を対応するデコードルーチン（gss_verify_micまたはgss_unwrap）に渡して保護を削除し、データを検証します。"
    },
    {
      "indent": 3,
      "text": "d) At the completion of a communications session (which may extend across several transport connections), each application calls a GSS-API routine to delete the security context. Multiple contexts may also be used (either successively or simultaneously) within a single communications association, at the option of the applications.",
      "ja": "d) 通信セッション（複数の輸送接続全体に拡張される可能性がある）が完了すると、各アプリケーションはGSS-APIルーチンを呼び出してセキュリティコンテキストを削除します。アプリケーションのオプションで、単一の通信協会内で、複数のコンテキストを（連続または同時に）使用することもできます。"
    },
    {
      "indent": 0,
      "text": "2. GSS-API Routines",
      "section_title": true,
      "ja": "2. GSS-APIルーチン"
    },
    {
      "indent": 6,
      "text": "This section lists the routines that make up the GSS-API, and offers a brief description of the purpose of each routine. Detailed descriptions of each routine are listed in alphabetical order in section 5.",
      "ja": "このセクションには、GSS-APIを構成するルーチンをリストし、各ルーチンの目的の簡単な説明を提供します。各ルーチンの詳細な説明は、セクション5のアルファベット順にリストされています。"
    },
    {
      "indent": 3,
      "text": "Table 2-1 GSS-API Credential-management Routines",
      "ja": "表2-1 GSS-API資格管理ルーチン"
    },
    {
      "indent": 3,
      "text": "Routine                Section              Function\n-------                -------              --------\ngss_acquire_cred           5.2  Assume a global identity; Obtain\n                                a GSS-API credential handle for\n                                pre-existing credentials.\ngss_add_cred               5.3  Construct credentials\n                                incrementally\ngss_inquire_cred           5.21 Obtain information about a\n                                credential\ngss_inquire_cred_by_mech   5.22 Obtain per-mechanism information\n                                about a credential.\ngss_release_cred           5.27 Discard a credential handle.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Table 2-2 GSS-API Context-Level Routines",
      "ja": "表2-2 GSS-APIコンテキストレベルのルーチン"
    },
    {
      "indent": 3,
      "text": "Routine                 Section              Function\n-------                 -------              --------\ngss_init_sec_context       5.19 Initiate a security context with\n                                a peer application\ngss_accept_sec_context     5.1  Accept a security context\n                                initiated by a\n                                peer application\ngss_delete_sec_context     5.9  Discard a security context\ngss_process_context_token  5.25 Process a token on a security\n                                context from a peer application\ngss_context_time           5.7  Determine for how long a context\n                                will remain valid\ngss_inquire_context        5.20 Obtain information about a\n                                security context\ngss_wrap_size_limit        5.34 Determine token-size limit for\n                                gss_wrap on a context\ngss_export_sec_context     5.14 Transfer a security context to\n                                another process\ngss_import_sec_context     5.17 Import a transferred context",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Table 2-3 GSS-API Per-message Routines",
      "ja": "表2-3 gss-apiメッセージあたりのルーチン"
    },
    {
      "indent": 3,
      "text": "Routine                 Section              Function\n-------                 -------              --------\ngss_get_mic                5.15 Calculate a cryptographic message\n                                integrity code (MIC) for a\n                                message; integrity service\ngss_verify_mic             5.32 Check a MIC against a message;\n                                verify integrity of a received\n                                message\ngss_wrap                   5.33 Attach a MIC to a message, and\n                                optionally encrypt the message\n                                content;\n                                confidentiality service\ngss_unwrap                 5.31 Verify a message with attached\n                                MIC, and decrypt message content\n                                if necessary.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Table 2-4 GSS-API Name manipulation Routines",
      "ja": "表2-4 GSS-API名操作ルーチン"
    },
    {
      "indent": 3,
      "text": "Routine                 Section              Function\n-------                 -------              --------\ngss_import_name            5.16 Convert a contiguous string name\n                                to internal-form\ngss_display_name           5.10 Convert internal-form name to\n                                text\ngss_compare_name           5.6  Compare two internal-form names",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "gss_release_name           5.28 Discard an internal-form name\ngss_inquire_names_for_mech 5.24 List the name-types supported by\n                                the specified mechanism\ngss_inquire_mechs_for_name 5.23 List mechanisms that support the\n                                specified name-type\ngss_canonicalize_name      5.5  Convert an internal name to an MN\ngss_export_name            5.13 Convert an MN to export form\ngss_duplicate_name         5.12 Create a copy of an internal name",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Table 2-5 GSS-API Miscellaneous Routines",
      "ja": "表2-5 GSS-APIその他のルーチン"
    },
    {
      "indent": 3,
      "text": "Routine                Section              Function\n-------                -------              --------\ngss_add_oid_set_member    5.4  Add an object identifier to\n                               a set\ngss_display_status        5.11 Convert a GSS-API status code\n                               to text\ngss_indicate_mechs        5.18 Determine available underlying\n                               authentication mechanisms\ngss_release_buffer        5.26 Discard a buffer\ngss_release_oid_set       5.29 Discard a set of object\n                               identifiers\ngss_create_empty_oid_set  5.8  Create a set containing no\n                               object identifiers\ngss_test_oid_set_member   5.30 Determines whether an object\n                                    identifier is a member of a set.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Individual GSS-API implementations may augment these routines by providing additional mechanism-specific routines if required functionality is not available from the generic forms. Applications are encouraged to use the generic routines wherever possible on portability grounds.",
      "ja": "個々のGSS-API実装は、必要な機能が一般的なフォームから使用できない場合、追加のメカニズム固有のルーチンを提供することにより、これらのルーチンを強化する場合があります。アプリケーションは、移植性の根拠で可能な限り一般的なルーチンを使用することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "3. Data Types and Calling Conventions",
      "section_title": true,
      "ja": "3. データ型と呼び出し規則"
    },
    {
      "indent": 3,
      "text": "The following conventions are used by the GSS-API C-language bindings:",
      "ja": "次の規則は、GSS-API C言語のバインディングによって使用されます。"
    },
    {
      "indent": 0,
      "text": "3.1. Integer types",
      "section_title": true,
      "ja": "3.1. 整数タイプ"
    },
    {
      "indent": 3,
      "text": "GSS-API uses the following integer data type:",
      "ja": "GSS-APIは、次の整数データ型を使用します。"
    },
    {
      "indent": 3,
      "text": "OM_uint32 32-bit unsigned integer",
      "ja": "OM_UINT32 32ビット符号なし整数"
    },
    {
      "indent": 3,
      "text": "Where guaranteed minimum bit-count is important, this portable data type is used by the GSS-API routine definitions. Individual GSS-API implementations will include appropriate typedef definitions to map this type onto a built-in data type. If the platform supports the X/Open xom.h header file, the OM_uint32 definition contained therein should be used; the GSS-API header file in Appendix A contains logic that will detect the prior inclusion of xom.h, and will not attempt to re-declare OM_uint32. If the X/Open header file is not available on the platform, the GSS-API implementation should use the smallest natural unsigned integer type that provides at least 32 bits of precision.",
      "ja": "保証された最小ビットカウントが重要な場合、このポータブルデータタイプはGSS-APIルーチン定義で使用されます。個々のGSS-API実装には、このタイプを組み込みデータ型にマッピングするための適切なtypedef定義が含まれます。プラットフォームがx/open xom.hヘッダーファイルをサポートする場合、そこに含まれるOM_UINT32定義を使用する必要があります。付録AのGSS-APIヘッダーファイルには、XOM.Hの以前の包含が検出され、OM_UINT32を再廃止しようとしないロジックが含まれています。X/Open Headerファイルがプラットフォームで使用できない場合、GSS-API実装は、少なくとも32ビットの精度を提供する最小の自然な非署名整数型を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2. String and similar data",
      "section_title": true,
      "ja": "3.2. 文字列および同様のデータ"
    },
    {
      "indent": 3,
      "text": "Many of the GSS-API routines take arguments and return values that describe contiguous octet-strings. All such data is passed between the GSS-API and the caller using the gss_buffer_t data type. This data type is a pointer to a buffer descriptor, which consists of a length field that contains the total number of bytes in the datum, and a value field which contains a pointer to the actual datum:",
      "ja": "GSS-APIルーチンの多くは、引数を取り、隣接するオクテットストリングを説明する値を返します。このようなデータはすべて、GSS_BUFFER_Tデータ型を使用してGSS-APIと発信者の間で渡されます。このデータ型は、バッファ記述子へのポインターであり、データム内のバイトの総数を含む長さフィールドと、実際のデータムへのポインターを含む値フィールドで構成されています。"
    },
    {
      "indent": 3,
      "text": "typedef struct gss_buffer_desc_struct {\n   size_t    length;\n   void      *value;\n} gss_buffer_desc, *gss_buffer_t;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Storage for data returned to the application by a GSS-API routine using the gss_buffer_t conventions is allocated by the GSS-API routine. The application may free this storage by invoking the gss_release_buffer routine. Allocation of the gss_buffer_desc object is always the responsibility of the application; unused gss_buffer_desc objects may be initialized to the value GSS_C_EMPTY_BUFFER.",
      "ja": "GSS_BUFFER_Tコンベンションを使用してGSS-APIルーチンによってアプリケーションに返されたデータのストレージは、GSS-APIルーチンによって割り当てられます。アプリケーションは、GSS_RELEASE_BUFFERルーチンを呼び出すことにより、このストレージを解放できます。GSS_BUFFER_DESCオブジェクトの割り当ては、常にアプリケーションの責任です。未使用のGSS_BUFFER_DESCオブジェクトは、値GSS_C_EMPTY_BUFFERに初期化される場合があります。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Opaque data types",
      "section_title": true,
      "ja": "3.2.1. 不透明なデータ型"
    },
    {
      "indent": 3,
      "text": "Certain multiple-word data items are considered opaque data types at the GSS-API, because their internal structure has no significance either to the GSS-API or to the caller. Examples of such opaque data types are the input_token parameter to gss_init_sec_context (which is opaque to the caller), and the input_message parameter to gss_wrap (which is opaque to the GSS-API). Opaque data is passed between the GSS-API and the application using the gss_buffer_t datatype.",
      "ja": "特定の複数語データ項目は、GSS-APIの内部構造がGSS-APIまたは発信者にとって重要ではないため、GSS-APIで不透明なデータ型と見なされます。このような不透明なデータ型の例は、gss_init_sec_context（発信者に不透明です）へのinput_tokenパラメーターと、gss_wrap（gss-apiに不透明です）へのinput_messageパラメーターです。gss_buffer_t datatypeを使用して、GSS-APIとアプリケーションの間で不透明なデータが渡されます。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Character strings",
      "section_title": true,
      "ja": "3.2.2. キャラクター文字列"
    },
    {
      "indent": 3,
      "text": "Certain multiple-word data items may be regarded as simple ISO Latin-1 character strings. Examples are the printable strings passed to gss_import_name via the input_name_buffer parameter. Some GSS-API routines also return character strings. All such character strings are passed between the application and the GSS-API implementation using the gss_buffer_t datatype, which is a pointer to a gss_buffer_desc object.",
      "ja": "特定の複数語データ項目は、単純なISO LATIN-1文字列と見なされる場合があります。例は、input_name_bufferパラメーターを介してgss_import_nameに渡された印刷可能な文字列です。一部のGSS-APIルーチンは、文字文字列も返します。このようなキャラクター文字列はすべて、GSS_Buffer_DESCオブジェクトへのポインターであるGSS_Buffer_t Datatypeを使用して、アプリケーションとGSS-API実装の間に渡されます。"
    },
    {
      "indent": 3,
      "text": "When a gss_buffer_desc object describes a printable string, the length field of the gss_buffer_desc should only count printable characters within the string. In particular, a trailing NUL character should NOT be included in the length count, nor should either the GSS-API implementation or the application assume the presence of an uncounted trailing NUL.",
      "ja": "GSS_BUFFER_DESCオブジェクトが印刷可能な文字列を記述する場合、GSS_BUFFER_DESCの長さフィールドは、文字列内の印刷可能な文字のみをカウントする必要があります。特に、後続のnul文字を長さのカウントに含めるべきではなく、GSS-API実装またはアプリケーションが、数え切れないほどの後続のnulの存在を想定するべきではありません。"
    },
    {
      "indent": 0,
      "text": "3.3. Object Identifiers",
      "section_title": true,
      "ja": "3.3. オブジェクト識別子"
    },
    {
      "indent": 3,
      "text": "Certain GSS-API procedures take parameters of the type gss_OID, or Object identifier. This is a type containing ISO-defined tree-structured values, and is used by the GSS-API caller to select an underlying security mechanism and to specify namespaces. A value of type gss_OID has the following structure:",
      "ja": "特定のGSS-API手順タイプGSS_OIDまたはオブジェクト識別子のパラメーターを採用します。これは、ISO定義のツリー構造値を含むタイプであり、GSS-API発信者が基礎となるセキュリティメカニズムを選択し、名前空間を指定するために使用されます。タイプGSS_OIDの値には、次の構造があります。"
    },
    {
      "indent": 3,
      "text": "typedef struct gss_OID_desc_struct {\n   OM_uint32   length;\n   void        *elements;\n} gss_OID_desc, *gss_OID;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The elements field of this structure points to the first byte of an octet string containing the ASN.1 BER encoding of the value portion of the normal BER TLV encoding of the gss_OID. The length field contains the number of bytes in this value. For example, the gss_OID value corresponding to {iso(1) identified-organization(3) icd-ecma(12) member-company(2) dec(1011) cryptoAlgorithms(7) DASS(5)}, meaning the DASS X.509 authentication mechanism, has a length field of 7 and an elements field pointing to seven octets containing the following octal values: 53,14,2,207,163,7,5. GSS-API implementations should provide constant gss_OID values to allow applications to request any supported mechanism, although applications are encouraged on portability grounds to accept the default mechanism. gss_OID values should also be provided to allow applications to specify particular name types (see section 3.10). Applications should treat gss_OID_desc values returned by GSS-API routines as read-only. In particular, the application should not attempt to deallocate them with free(). The gss_OID_desc datatype is equivalent to the X/Open OM_object_identifier datatype[XOM].",
      "ja": "この構造の要素フィールドは、asn.1 berを含むオクテット文字列の最初のバイトを指します。長さフィールドには、この値のバイト数が含まれています。たとえば、{ISO（1）識別された組織（3）ICD-ECMA（12）メンバー - コンパニー（2）DEC（1011）CryptoAlgorithms（7）Dass（5）}に対応するGSS_OID値。509認証メカニズムには、7の長さフィールドがあり、次のオクタル値を含む7つのオクテットを指す要素フィールドがあります：53,14,2,207,163,7,5。GSS-APIの実装は、デフォルトのメカニズムを受け入れるための移植性の根拠でアプリケーションが奨励されていますが、アプリケーションがサポートされているメカニズムを要求できるように、一定のGSS_OID値を提供する必要があります。GSS_OID値も、アプリケーションが特定の名前タイプを指定できるようにするために提供する必要があります（セクション3.10を参照）。アプリケーションは、GSS-APIルーチンによって返されるGSS_OID_DESC値を読み取り専用として扱う必要があります。特に、アプリケーションはそれらをfree（）でそれらを扱うことを試みるべきではありません。GSS_OID_DESC DatAtypeは、X/Open OM_OBJECT_IDENTIFIER DATATYPE [XOM]と同等です。"
    },
    {
      "indent": 0,
      "text": "3.4. Object Identifier Sets",
      "section_title": true,
      "ja": "3.4. オブジェクト識別子セット"
    },
    {
      "indent": 3,
      "text": "Certain GSS-API procedures take parameters of the type gss_OID_set. This type represents one or more object identifiers (section 2.3). A gss_OID_set object has the following structure:",
      "ja": "特定のGSS-APIプロシージャは、型GSS_OID_SETのパラメーターを採用します。このタイプは、1つ以上のオブジェクト識別子を表します（セクション2.3）。gss_oid_setオブジェクトには次の構造があります。"
    },
    {
      "indent": 3,
      "text": "typedef struct gss_OID_set_desc_struct {\n   size_t    count;\n   gss_OID   elements;\n} gss_OID_set_desc, *gss_OID_set;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The count field contains the number of OIDs within the set. The elements field is a pointer to an array of gss_OID_desc objects, each of which describes a single OID. gss_OID_set values are used to name the available mechanisms supported by the GSS-API, to request the use of specific mechanisms, and to indicate which mechanisms a given credential supports.",
      "ja": "カウントフィールドには、セット内のOIDの数が含まれています。Elementsフィールドは、GSS_OID_DESCオブジェクトの配列へのポインターであり、それぞれが単一のOIDを記述しています。GSS_OID_SET値は、GSS-APIによってサポートされる利用可能なメカニズムに名前を付けて、特定のメカニズムの使用を要求し、特定の資格情報がどのメカニズムがサポートするかを示すために使用されます。"
    },
    {
      "indent": 3,
      "text": "All OID sets returned to the application by GSS-API are dynamic objects (the gss_OID_set_desc, the \"elements\" array of the set, and the \"elements\" array of each member OID are all dynamically allocated), and this storage must be deallocated by the application using the gss_release_oid_set() routine.",
      "ja": "GSS-APIによってアプリケーションに返されるすべてのOIDセットは動的なオブジェクト（GSS_OID_SET_DESC、セットの「要素」配列、および各メンバーの「要素」配列がすべて動的に割り当てられます）であり、このストレージはすべて動的に割り当てられています）。gss_release_oid_set（）ルーチンを使用したアプリケーション。"
    },
    {
      "indent": 0,
      "text": "3.5. Credentials",
      "section_title": true,
      "ja": "3.5. 資格"
    },
    {
      "indent": 3,
      "text": "A credential handle is a caller-opaque atomic datum that identifies a GSS-API credential data structure. It is represented by the caller-opaque type gss_cred_id_t, which should be implemented as a pointer or arithmetic type. If a pointer implementation is chosen, care must be taken to ensure that two gss_cred_id_t values may be compared with the == operator.",
      "ja": "資格認定ハンドルは、GSS-API資格情報構造を識別する発信者と麻痺の原子データムです。これは、ポインターまたは算術タイプとして実装する必要がある発信者 - 透明タイプGSS_CRED_ID_Tで表されます。ポインターの実装が選択されている場合、2つのGSS_CRED_ID_T値を==演算子と比較できるように注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "GSS-API credentials can contain mechanism-specific principal authentication data for multiple mechanisms. A GSS-API credential is composed of a set of credential-elements, each of which is applicable to a single mechanism. A credential may contain at most one credential-element for each supported mechanism. A credential-element identifies the data needed by a single mechanism to authenticate a single principal, and conceptually contains two credential-references that describe the actual mechanism-specific authentication data, one to be used by GSS-API for initiating contexts, and one to be used for accepting contexts. For mechanisms that do not distinguish between acceptor and initiator credentials, both references would point to the same underlying mechanism-specific authentication data.",
      "ja": "GSS-API資格情報には、複数のメカニズムのメカニズム固有のプリンシパル認証データを含めることができます。GSS-API資格情報は、資格情報のセットで構成されており、それぞれが単一のメカニズムに適用できます。資格情報には、サポートされているメカニズムごとに最大1つの資格要素が含まれる場合があります。資格認定は、単一のメカニズムに必要なデータを単一のプリンシパルを認証するために識別し、実際のメカニズム固有の認証データを記述する2つの資格情報参照を概念的に含みます。コンテキストを受け入れるために使用されます。アクセプターとイニシエーターの資格情報を区別しないメカニズムの場合、両方の参照は同じ基礎となるメカニズム固有の認証データを指します。"
    },
    {
      "indent": 3,
      "text": "Credentials describe a set of mechanism-specific principals, and give their holder the ability to act as any of those principals. All principal identities asserted by a single GSS-API credential should belong to the same entity, although enforcement of this property is an implementation-specific matter. The GSS-API does not make the actual credentials available to applications; instead a credential handle is used to identify a particular credential, held internally by GSS-API. The combination of GSS-API credential handle and mechanism identifies the principal whose identity will be asserted by the credential when used with that mechanism.",
      "ja": "資格情報は、メカニズム固有のプリンシパルのセットを説明し、その所有者にそれらのプリンシパルのいずれかとして行動する能力を提供します。単一のGSS-API資格によって主張されたすべての主要なアイデンティティは、同じエンティティに属する必要がありますが、このプロパティの施行は実装固有の問題です。GSS-APIは、実際の資格情報をアプリケーションで利用できるようにしません。代わりに、GSS-APIによって内部的に保持されている特定の資格情報を識別するために資格情報を使用しています。GSS-APIクレデンシャルハンドルとメカニズムの組み合わせは、そのメカニズムで使用された場合、資格によってアイデンティティが主張されるプリンシパルを識別します。"
    },
    {
      "indent": 3,
      "text": "The gss_init_sec_context and gss_accept_sec_context routines allow the value GSS_C_NO_CREDENTIAL to be specified as their credential handle parameter. This special credential-handle indicates a desire by the application to act as a default principal. While individual GSS-API implementations are free to determine such default behavior as appropriate to the mechanism, the following default behavior by these routines is recommended for portability:",
      "ja": "GSS_INIT_SEC_CONTEXTおよびGSS_ACCEPT_SEC_CONTEXTルーチンにより、値GSS_C_NO_CREDENTIALを資格情報ハンドルパラメーターとして指定することができます。この特別な資格情報は、デフォルトのプリンシパルとして機能するというアプリケーションによる欲求を示しています。個々のGSS-API実装は、メカニズムに適したようなデフォルトの動作を自由に決定できますが、これらのルーチンによる次のデフォルト動作は、移植性に推奨されます。"
    },
    {
      "indent": 3,
      "text": "gss_init_sec_context",
      "ja": "gss_init_sec_context"
    },
    {
      "indent": 6,
      "text": "1) If there is only a single principal capable of initiating security contexts for the chosen mechanism that the application is authorized to act on behalf of, then that principal shall be used, otherwise",
      "ja": "1) 選択されたメカニズムのセキュリティコンテキストを開始できる単一のプリンシパルがある場合、アプリケーションが代表することを許可されている場合、そのプリンシパルは使用されます。"
    },
    {
      "indent": 6,
      "text": "2) If the platform maintains a concept of a default network-identity for the chosen mechanism, and if the application is authorized to act on behalf of that identity for the purpose of initiating security contexts, then the principal corresponding to that identity shall be used, otherwise",
      "ja": "2) プラットフォームが選択したメカニズムのデフォルトネットワークアイデンティティの概念を維持し、セキュリティコンテキストを開始する目的でそのアイデンティティに代わって行動することをアプリケーションが許可されている場合、そのアイデンティティに対応するプリンシパルが使用されます。"
    },
    {
      "indent": 6,
      "text": "3) If the platform maintains a concept of a default local identity, and provides a means to map local identities into network-identities for the chosen mechanism, and if the application is authorized to act on behalf of the network-identity image of the default local identity for the purpose of initiating security contexts using the chosen mechanism, then the principal corresponding to that identity shall be used, otherwise",
      "ja": "3) プラットフォームがデフォルトのローカルアイデンティティの概念を維持し、選択したメカニズムのネットワークアイデンティティにローカルアイデンティティをマッピングする手段を提供し、デフォルトのローカルIDのネットワークアイデンティティイメージに代わって行動することが許可されている場合選択したメカニズムを使用してセキュリティコンテキストを開始する目的で、そのアイデンティティに対応するプリンシパルが使用されます。"
    },
    {
      "indent": 6,
      "text": "4) A user-configurable default identity should be used.",
      "ja": "4) ユーザー構成可能なデフォルトのIDを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "gss_accept_sec_context",
      "ja": "gss_accept_sec_context"
    },
    {
      "indent": 6,
      "text": "1) If there is only a single authorized principal identity capable of accepting security contexts for the chosen mechanism, then that principal shall be used, otherwise",
      "ja": "1) 選択したメカニズムのセキュリティコンテキストを受け入れることができる単一の承認された元本IDのみがある場合、その校長は使用されます。"
    },
    {
      "indent": 6,
      "text": "2) If the mechanism can determine the identity of the target principal by examining the context-establishment token, and if the accepting application is authorized to act as that principal for the purpose of accepting security contexts using the chosen mechanism, then that principal identity shall be used, otherwise",
      "ja": "2) メカニズムがコンテキスト確立トークンを調べてターゲットプリンシパルのアイデンティティを決定できる場合、および選択されたメカニズムを使用してセキュリティコンテキストを受け入れる目的でそのプリンシパルとして行動することを許可されている場合、そのプリンシパルアイデンティティを使用するものとします。、 さもないと"
    },
    {
      "indent": 6,
      "text": "3) If the mechanism supports context acceptance by any principal, and if mutual authentication was not requested, any principal that the application is authorized to accept security contexts under using the chosen mechanism may be used, otherwise",
      "ja": "3) メカニズムが任意のプリンシパルによるコンテキストの受け入れをサポートし、相互認証が要求されなかった場合、選択したメカニズムを使用してセキュリティコンテキストを受け入れることが許可されているプリンシパルが使用される場合があります。"
    },
    {
      "indent": 6,
      "text": "4)A user-configurable default identity shall be used.",
      "ja": "4）ユーザー構成可能なデフォルトのIDを使用するものとします。"
    },
    {
      "indent": 3,
      "text": "The purpose of the above rules is to allow security contexts to be established by both initiator and acceptor using the default behavior wherever possible. Applications requesting default behavior are likely to be more portable across mechanisms and platforms than ones that use gss_acquire_cred to request a specific identity.",
      "ja": "上記のルールの目的は、可能な限りデフォルトの動作を使用して、イニシエーターとアクセプターの両方によってセキュリティコンテキストを確立できるようにすることです。デフォルトの動作を要求するアプリケーションは、特定のIDを要求するためにGSS_ACQUIRE_CREDを使用したものよりも、メカニズムやプラットフォーム間でよりポータブルである可能性があります。"
    },
    {
      "indent": 0,
      "text": "3.6. Contexts",
      "section_title": true,
      "ja": "3.6. コンテキスト"
    },
    {
      "indent": 3,
      "text": "The gss_ctx_id_t data type contains a caller-opaque atomic value that identifies one end of a GSS-API security context. It should be implemented as a pointer or arithmetic type. If a pointer type is chosen, care should be taken to ensure that two gss_ctx_id_t values may be compared with the == operator.",
      "ja": "GSS_CTX_ID_Tデータ型には、GSS-APIセキュリティコンテキストの一方の端を識別する発信者と障害の原子値が含まれています。ポインターまたは算術型として実装する必要があります。ポインタータイプが選択されている場合、2つのGSS_CTX_ID_T値を==演算子と比較できるように注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "The security context holds state information about each end of a peer communication, including cryptographic state information.",
      "ja": "セキュリティコンテキストは、暗号化状態情報を含む、ピアコミュニケーションの各端に関する状態情報を保持しています。"
    },
    {
      "indent": 0,
      "text": "3.7. Authentication tokens",
      "section_title": true,
      "ja": "3.7. 認証トークン"
    },
    {
      "indent": 3,
      "text": "A token is a caller-opaque type that GSS-API uses to maintain synchronization between the context data structures at each end of a GSS-API security context. The token is a cryptographically protected octet-string, generated by the underlying mechanism at one end of a GSS-API security context for use by the peer mechanism at the other end. Encapsulation (if required) and transfer of the token are the responsibility of the peer applications. A token is passed between the GSS-API and the application using the gss_buffer_t conventions.",
      "ja": "トークンは、GSS-APIがGSS-APIセキュリティコンテキストの両端でコンテキストデータ構造間の同期を維持するために使用する発信者オパクタイプです。トークンは暗号化されたオクテット弦であり、GSS-APIセキュリティコンテキストの一方の端で基礎となるメカニズムによって生成され、他方の端でピアメカニズムによって使用されます。カプセル化（必要な場合）とトークンの転送は、ピアアプリケーションの責任です。GSS-APIとGSS_BUFFER_Tコンベンションを使用して、GSS-APIとアプリケーションの間にトークンが渡されます。"
    },
    {
      "indent": 0,
      "text": "3.8. Interprocess tokens",
      "section_title": true,
      "ja": "3.8. インタープロセストークン"
    },
    {
      "indent": 3,
      "text": "Certain GSS-API routines are intended to transfer data between processes in multi-process programs. These routines use a caller-opaque octet-string, generated by the GSS-API in one process for use by the GSS-API in another process. The calling application is responsible for transferring such tokens between processes in an OS-specific manner. Note that, while GSS-API implementors are encouraged to avoid placing sensitive information within interprocess tokens, or to cryptographically protect them, many implementations will be unable to avoid placing key material or other sensitive data within them. It is the application's responsibility to ensure that interprocess tokens are protected in transit, and transferred only to processes that are trustworthy. An interprocess token is passed between the GSS-API and the application using the gss_buffer_t conventions.",
      "ja": "特定のGSS-APIルーチンは、マルチプロセスプログラムのプロセス間でデータを転送することを目的としています。これらのルーチンは、GSS-APIによってGSS-APIが別のプロセスで使用するためにGSS-APIによって生成された発信者と麻痺のオクテットストリングを使用します。呼び出しアプリケーションは、OS固有の方法でプロセス間でこのようなトークンを転送する責任があります。GSS-APIの実装者は、インタープロセストークン内に機密情報の配置を避けたり、暗号化的に保護するように奨励されていますが、多くの実装では、重要な素材やその他の機密データの配置を避けることができないことに注意してください。インタープロセストークンが輸送中に保護され、信頼できるプロセスにのみ転送されることを保証することは、アプリケーションの責任です。GSS_BUFFER_Tコンベンションを使用して、GSS-APIとアプリケーションの間にインタープロセストークンが渡されます。"
    },
    {
      "indent": 0,
      "text": "3.9. Status values",
      "section_title": true,
      "ja": "3.9. ステータス値"
    },
    {
      "indent": 3,
      "text": "Every GSS-API routine returns two distinct values to report status information to the caller: GSS status codes and Mechanism status codes.",
      "ja": "すべてのGSS-APIルーチンは、2つの異なる値を返して、ステータス情報を発信者に報告します。GSSステータスコードとメカニズムステータスコード。"
    },
    {
      "indent": 0,
      "text": "3.9.1. GSS status codes",
      "section_title": true,
      "ja": "3.9.1. GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS-API routines return GSS status codes as their OM_uint32 function value. These codes indicate errors that are independent of the underlying mechanism(s) used to provide the security service. The errors that can be indicated via a GSS status code are either generic API routine errors (errors that are defined in the GSS-API specification) or calling errors (errors that are specific to these language bindings).",
      "ja": "GSS-APIルーチンは、GSSステータスコードをOM_UINT32関数値として返します。これらのコードは、セキュリティサービスを提供するために使用される基礎となるメカニズムに依存しないエラーを示します。GSSステータスコードで示されるエラーは、一般的なAPIルーチンエラー（GSS-API仕様で定義されているエラー）または呼び出しエラー（これらの言語バインディングに固有のエラー）のいずれかです。"
    },
    {
      "indent": 3,
      "text": "A GSS status code can indicate a single fatal generic API error from the routine and a single calling error. In addition, supplementary status information may be indicated via the setting of bits in the supplementary info field of a GSS status code.",
      "ja": "GSSステータスコードは、ルーチンからの単一の致命的な一般的なAPIエラーと単一の呼び出しエラーを示すことができます。さらに、補足ステータス情報は、GSSステータスコードの補足情報フィールドのビットの設定を介して示される場合があります。"
    },
    {
      "indent": 3,
      "text": "These errors are encoded into the 32-bit GSS status code as follows:",
      "ja": "これらのエラーは、次のように32ビットGSSステータスコードにエンコードされます。"
    },
    {
      "indent": 3,
      "text": "   MSB                                                        LSB\n   |------------------------------------------------------------|\n   |  Calling Error | Routine Error  |    Supplementary Info    |\n   |------------------------------------------------------------|\nBit 31            24 23            16 15                       0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hence if a GSS-API routine returns a GSS status code whose upper 16 bits contain a non-zero value, the call failed. If the calling error field is non-zero, the invoking application's call of the routine was erroneous. Calling errors are defined in table 5-1. If the routine error field is non-zero, the routine failed for one of the routine-specific reasons listed below in table 5-2. Whether or not the upper 16 bits indicate a failure or a success, the routine may indicate additional information by setting bits in the supplementary info field of the status code. The meaning of individual bits is listed below in table 5-3.",
      "ja": "したがって、GSS-APIルーチンが16ビットがゼロ以外の値を含むGSSステータスコードを返した場合、コールは失敗しました。呼び出しエラーフィールドがゼロではない場合、呼び出しアプリケーションのルーチンの呼び出しは誤っていました。呼び出しエラーは、表5-1に定義されています。ルーチンエラーフィールドがゼロでない場合、表5-2に以下にリストされているルーチン固有の理由の1つで、ルーチンが失敗しました。上部16ビットが失敗または成功を示すかどうかにかかわらず、ルーチンはステータスコードの補足情報フィールドにビットを設定することにより追加情報を示す場合があります。個々のビットの意味を表5-3に示します。"
    },
    {
      "indent": 3,
      "text": "Table 3-1 Calling Errors",
      "ja": "表3-1呼び出しエラー"
    },
    {
      "indent": 3,
      "text": "Name                   Value in field           Meaning\n----                   --------------           -------\nGSS_S_CALL_INACCESSIBLE_READ  1       A required input parameter\n                                      could not be read\nGSS_S_CALL_INACCESSIBLE_WRITE 2       A required output parameter\n                                       could not be written.\nGSS_S_CALL_BAD_STRUCTURE      3       A parameter was malformed\n   Table 3-2  Routine Errors",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Name                   Value in field           Meaning\n----                   --------------           -------\nGSS_S_BAD_MECH                1       An unsupported mechanism\n                                      was requested\nGSS_S_BAD_NAME                2       An invalid name was\n                                      supplied\nGSS_S_BAD_NAMETYPE            3       A supplied name was of an\n                                      unsupported type\nGSS_S_BAD_BINDINGS            4       Incorrect channel bindings\n                                      were supplied\nGSS_S_BAD_STATUS              5       An invalid status code was\n                                      supplied\nGSS_S_BAD_MIC GSS_S_BAD_SIG   6       A token had an invalid MIC\nGSS_S_NO_CRED                 7       No credentials were\n                                      supplied, or the\n                                      credentials were\n                                      unavailable or\n                                      inaccessible.\nGSS_S_NO_CONTEXT              8       No context has been\n                                      established\nGSS_S_DEFECTIVE_TOKEN         9       A token was invalid\nGSS_S_DEFECTIVE_CREDENTIAL   10       A credential was invalid\nGSS_S_CREDENTIALS_EXPIRED    11       The referenced credentials\n                                      have expired\nGSS_S_CONTEXT_EXPIRED        12       The context has expired\nGSS_S_FAILURE                13       Miscellaneous failure (see\n                                      text)\nGSS_S_BAD_QOP                14       The quality-of-protection\n                                      requested could not be\n                                      provided\nGSS_S_UNAUTHORIZED           15       The operation is forbidden\n                                      by local security policy\nGSS_S_UNAVAILABLE            16       The operation or option is\n                                      unavailable\nGSS_S_DUPLICATE_ELEMENT      17       The requested credential\n                                      element already exists\nGSS_S_NAME_NOT_MN            18       The provided name was not a\n                                      mechanism name",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Table 3-3 Supplementary Status Bits",
      "ja": "表3-3補足ステータスビット"
    },
    {
      "indent": 3,
      "text": "Name                   Bit Number           Meaning\n----                   ----------           -------\nGSS_S_CONTINUE_NEEDED   0 (LSB)   Returned only by\n                                  gss_init_sec_context or\n                                  gss_accept_sec_context. The\n                                  routine must be called again\n                                  to complete its function.\n                                  See routine documentation for\n                                  detailed description\nGSS_S_DUPLICATE_TOKEN   1         The token was a duplicate of\n                                  an earlier token\nGSS_S_OLD_TOKEN         2         The token's validity period\n                                  has expired\nGSS_S_UNSEQ_TOKEN       3         A later token has already been\n                                  processed\nGSS_S_GAP_TOKEN         4         An expected per-message token\n                                  was not received",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The routine documentation also uses the name GSS_S_COMPLETE, which is a zero value, to indicate an absence of any API errors or supplementary information bits.",
      "ja": "ルーチンのドキュメントでは、gss_s_completeという名前を使用して、ゼロ値であるため、APIエラーまたは補足情報ビットがないことを示します。"
    },
    {
      "indent": 3,
      "text": "All GSS_S_xxx symbols equate to complete OM_uint32 status codes, rather than to bitfield values. For example, the actual value of the symbol GSS_S_BAD_NAMETYPE (value 3 in the routine error field) is 3<<16. The macros GSS_CALLING_ERROR(), GSS_ROUTINE_ERROR() and GSS_SUPPLEMENTARY_INFO() are provided, each of which takes a GSS status code and removes all but the relevant field. For example, the value obtained by applying GSS_ROUTINE_ERROR to a status code removes the calling errors and supplementary info fields, leaving only the routine errors field. The values delivered by these macros may be directly compared with a GSS_S_xxx symbol of the appropriate type. The macro GSS_ERROR() is also provided, which when applied to a GSS status code returns a non-zero value if the status code indicated a calling or routine error, and a zero value otherwise. All macros defined by GSS-API evaluate their argument(s) exactly once.",
      "ja": "すべてのGSS_S_XXXシンボルは、ビットフィールドの値ではなく、OM_UINT32ステータスコードを完了することに相当します。たとえば、シンボルGSS_S_S_BAD_NAMETYPE（ルーチンエラーフィールドの値3）の実際の値は3 << 16です。Macros gss_calling_error（）、gss_routine_error（）、およびgss_supplementary_info（）が提供されます。それぞれがGSSステータスコードを取得し、関連フィールドを除くすべてを削除します。たとえば、GSS_Routine_Errorをステータスコードに適用することによって得られた値は、呼び出しエラーと補足情報フィールドを削除し、ルーチンエラーフィールドのみを残します。これらのマクロによって提供される値は、適切なタイプのGSS_S_XXXシンボルと直接比較できます。Macro GSS_ERROR（）も提供されます。これは、GSSステータスコードに適用すると、ステータスコードが呼び出しエラーまたはルーチンエラーを示し、それ以外の場合はゼロ値を示した場合、ゼロ以外の値を返します。GSS-APIによって定義されたすべてのマクロは、彼らの引数を1回正確に評価します。"
    },
    {
      "indent": 3,
      "text": "A GSS-API implementation may choose to signal calling errors in a platform-specific manner instead of, or in addition to the routine value; routine errors and supplementary info should be returned via major status values only.",
      "ja": "GSS-APIの実装は、ルーチン値ではなく、またはルーチン値に加えて、プラットフォーム固有の方法で呼び出しエラーを信号することを選択できます。定期的なエラーと補足情報は、主要なステータス値のみで返品する必要があります。"
    },
    {
      "indent": 3,
      "text": "The GSS major status code GSS_S_FAILURE is used to indicate that the underlying mechanism detected an error for which no specific GSS status code is defined. The mechanism-specific status code will provide more details about the error.",
      "ja": "GSSの主要なステータスコードGSS_S_FAILUREは、基礎となるメカニズムが特定のGSSステータスコードが定義されていないエラーを検出したことを示すために使用されます。メカニズム固有のステータスコードは、エラーの詳細を提供します。"
    },
    {
      "indent": 0,
      "text": "3.9.2. Mechanism-specific status codes",
      "section_title": true,
      "ja": "3.9.2. メカニズム固有のステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS-API routines return a minor_status parameter, which is used to indicate specialized errors from the underlying security mechanism. This parameter may contain a single mechanism-specific error, indicated by a OM_uint32 value.",
      "ja": "GSS-APIルーチンは、Minor_Statusパラメーターを返します。これは、基礎となるセキュリティメカニズムからの特殊なエラーを示すために使用されます。このパラメーターには、OM_UINT32値で示される単一のメカニズム固有のエラーが含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "The minor_status parameter will always be set by a GSS-API routine, even if it returns a calling error or one of the generic API errors indicated above as fatal, although most other output parameters may remain unset in such cases. However, output parameters that are expected to return pointers to storage allocated by a routine must always be set by the routine, even in the event of an error, although in such cases the GSS-API routine may elect to set the returned parameter value to NULL to indicate that no storage was actually allocated. Any length field associated with such pointers (as in a gss_buffer_desc structure) should also be set to zero in such cases.",
      "ja": "minor_statusパラメーターは、コールエラーまたは上記の一般的なAPIエラーの1つを致命的であると返す場合でも、GSS-APIルーチンによって常に設定されますが、他のほとんどの出力パラメーターはそのような場合には設定されたままです。ただし、ルーチンによって割り当てられたストレージにポインターを返すと予想される出力パラメーターは、エラーが発生した場合でも、常にルーチンによって設定する必要がありますが、そのような場合はGSS-APIルーチンが返されたパラメーター値をに設定することを選択する場合があります。ストレージが実際に割り当てられていないことを示すためにnull。このようなポインター（GSS_BUFFER_DESC構造など）に関連付けられた任意の長さフィールドも、そのような場合にはゼロに設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.10. Names",
      "section_title": true,
      "ja": "3.10. 名前"
    },
    {
      "indent": 3,
      "text": "A name is used to identify a person or entity. GSS-API authenticates the relationship between a name and the entity claiming the name.",
      "ja": "名前は、個人またはエンティティを識別するために使用されます。GSS-APIは、名前と名前を主張するエンティティとの関係を認証します。"
    },
    {
      "indent": 3,
      "text": "Since different authentication mechanisms may employ different namespaces for identifying their principals, GSSAPI's naming support is necessarily complex in multi-mechanism environments (or even in some single-mechanism environments where the underlying mechanism supports multiple namespaces).",
      "ja": "異なる認証メカニズムは、プリンシパルを識別するために異なる名前空間を使用する可能性があるため、GSSAPIの命名サポートは、マルチメカニズム環境（または基礎となるメカニズムが複数の名前空間をサポートするいくつかの単一メカニズム環境）で必然的に複雑です。"
    },
    {
      "indent": 3,
      "text": "Two distinct representations are defined for names:",
      "ja": "名前については、2つの異なる表現が定義されています。"
    },
    {
      "indent": 3,
      "text": "An internal form. This is the GSS-API \"native\" format for names, represented by the implementation-specific gss_name_t type. It is opaque to GSS-API callers. A single gss_name_t object may contain multiple names from different namespaces, but all names should refer to the same entity. An example of such an internal name would be the name returned from a call to the gss_inquire_cred routine, when applied to a credential containing credential elements for multiple authentication mechanisms employing different namespaces. This gss_name_t object will contain a distinct name for the entity for each authentication mechanism.",
      "ja": "内部フォーム。これは、実装固有のGSS_NAME_Tタイプで表される名前のGSS-API「ネイティブ」形式です。GSS-API発信者にとって不透明です。単一のGSS_NAME_Tオブジェクトには、異なる名前空間から複数の名前が含まれる場合がありますが、すべての名前は同じエンティティを参照する必要があります。このような内部名の例は、異なる名前空間を採用する複数の認証メカニズムの資格情報を含む資格情報に適用される場合、gss_inquire_credルーチンへの呼び出しから返される名前です。このGSS_NAME_Tオブジェクトには、認証メカニズムごとにエンティティの明確な名前が含まれています。"
    },
    {
      "indent": 6,
      "text": "For GSS-API implementations supporting multiple namespaces, objects of type gss_name_t must contain sufficient information to determine the namespace to which each primitive name belongs.",
      "ja": "複数の名前空間をサポートするGSS-API実装の場合、型GSS_NAME_Tのオブジェクトには、各プリミティブ名が属する名前空間を決定するのに十分な情報を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Mechanism-specific contiguous octet-string forms. A format capable of containing a single name (from a single namespace). Contiguous string names are always accompanied by an object identifier specifying the namespace to which the name belongs, and their format is dependent on the authentication mechanism that employs the name. Many, but not all, contiguous string names will be printable, and may therefore be used by GSS-API applications for communication with their users.",
      "ja": "メカニズム固有の隣接するオクテットストリングフォーム。単一の名前（単一の名前空間から）を含めることができる形式。隣接する文字列名には、常に名前が属する名前空間を指定するオブジェクト識別子が常に伴い、その形式は名前を使用する認証メカニズムに依存します。すべてではありませんが、隣接する文字列名は印刷可能であるため、ユーザーとの通信のためにGSS-APIアプリケーションで使用される場合があります。"
    },
    {
      "indent": 3,
      "text": "Routines (gss_import_name and gss_display_name) are provided to convert names between contiguous string representations and the internal gss_name_t type. gss_import_name may support multiple syntaxes for each supported namespace, allowing users the freedom to choose a preferred name representation. gss_display_name should use an implementation-chosen printable syntax for each supported name-type.",
      "ja": "ルーチン（gss_import_nameおよびgss_display_name）が提供され、隣接する文字列表現と内部gss_name_tタイプの間で名前を変換します。GSS_IMPORT_NAMEは、サポートされている各ネームスペースの複数の構文をサポートする場合があり、ユーザーが優先名の表現を自由に選択できるようにします。GSS_DISPLAY_NAMEサポートされているNAME-TYPEごとに、実装選択の印刷可能な構文を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "If an application calls gss_display_name(), passing the internal name resulting from a call to gss_import_name(), there is no guarantee the the resulting contiguous string name will be the same as the original imported string name. Nor do name-space identifiers necessarily survive unchanged after a journey through the internal name-form. An example of this might be a mechanism that authenticates X.500 names, but provides an algorithmic mapping of Internet DNS names into X.500. That mechanism's implementation of gss_import_name() might, when presented with a DNS name, generate an internal name that contained both the original DNS name and the equivalent X.500 name. Alternatively, it might only store the X.500 name. In the latter case, gss_display_name() would most likely generate a printable X.500 name, rather than the original DNS name.",
      "ja": "アプリケーションがgss_display_name（）を呼び出し、gss_import_name（）への呼び出しから生じる内部名を渡す場合、結果の連続した文字列名は元のインポートされた文字列名と同じであるという保証はありません。また、内部のネームフォームを旅した後、名前空間識別子は必ずしも変わらずに生き残りません。この例は、X.500名を認証するメカニズムかもしれませんが、インターネットDNS名のアルゴリズムマッピングをX.500に提供します。GSS_IMPORT_NAME（）のメカニズムの実装は、DNS名で提示された場合、元のDNS名と同等のX.500名の両方を含む内部名を生成する可能性があります。または、X.500名のみを保存する場合があります。後者の場合、GSS_DISPLAY_NAME（）は、元のDNS名ではなく、印刷可能なX.500名を生成する可能性が高いでしょう。"
    },
    {
      "indent": 3,
      "text": "The process of authentication delivers to the context acceptor an internal name. Since this name has been authenticated by a single mechanism, it contains only a single name (even if the internal name presented by the context initiator to gss_init_sec_context had multiple components). Such names are termed internal mechanism names, or \"MN\"s and the names emitted by gss_accept_sec_context() are always of this type. Since some applications may require MNs without wanting to incur the overhead of an authentication operation, a second function, gss_canonicalize_name(), is provided to convert a general internal name into an MN.",
      "ja": "認証のプロセスは、コンテキストアクセプターに内部名を提供します。この名前は単一のメカニズムによって認証されているため、単一の名前のみが含まれています（gss_init_sec_contextのコンテキストイニシエーターによって提示された内部名が複数のコンポーネントを持っていたとしても）。このような名前は、内部メカニズム名、または「Mn」と呼ばれ、GSS_ACCEPT_SEC_CONTEXT（）によって放出される名前は常にこのタイプです。一部のアプリケーションでは、認証操作のオーバーヘッドを発生させたくない場合はMNSを必要とする場合があるため、一般的な内部名をMNに変換するために2番目の関数GSS_CANONICALIZE_NAME（）が提供されます。"
    },
    {
      "indent": 3,
      "text": "Comparison of internal-form names may be accomplished via the gss_compare_name() routine, which returns true if the two names being compared refer to the same entity. This removes the need for the application program to understand the syntaxes of the various printable names that a given GSS-API implementation may support. Since GSS-API assumes that all primitive names contained within a given internal name refer to the same entity, gss_compare_name() can return true if the two names have at least one primitive name in common. If the implementation embodies knowledge of equivalence relationships between names taken from different namespaces, this knowledge may also allow successful comparison of internal names containing no overlapping primitive elements.",
      "ja": "内部形式名の比較は、gss_compare_name（）ルーチンを介して達成できます。これは、比較される2つの名前が同じエンティティを参照する場合にtrueを返します。これにより、特定のGSS-API実装がサポートする可能性のあるさまざまな印刷可能な名前の構文を理解するアプリケーションプログラムの必要性が削除されます。GSS-APIは、特定の内部名に含まれるすべてのプリミティブ名が同じエンティティを参照すると想定しているため、2つの名前に少なくとも1つの原始名が共通している場合、gss_compare_name（）はtrueを返すことができます。実装が異なる名前空間から取得した名前間の同等の関係の知識を具体化する場合、この知識は、重複する原始要素を含む内部名の比較を成功させることもできます。"
    },
    {
      "indent": 3,
      "text": "When used in large access control lists, the overhead of invoking gss_import_name() and gss_compare_name() on each name from the ACL may be prohibitive. As an alternative way of supporting this case, GSS-API defines a special form of the contiguous string name which may be compared directly (e.g. with memcmp()). Contiguous names suitable for comparison are generated by the gss_export_name() routine, which requires an MN as input. Exported names may be re-imported by the gss_import_name() routine, and the resulting internal name will also be an MN. The gss_OID constant GSS_C_NT_EXPORT_NAME indentifies the \"export name\" type, and the value of this constant is given in Appendix A. Structurally, an exported name object consists of a header containing an OID identifying the mechanism that authenticated the name, and a trailer containing the name itself, where the syntax of the trailer is defined by the individual mechanism specification. The precise format of an export name is defined in the language-independent GSS-API specification [GSSAPI].",
      "ja": "大規模なアクセス制御リストで使用する場合、ACLの各名前でGSS_IMPORT_NAME（）およびGSS_Compare_Name（）を呼び出すオーバーヘッドは法外な場合があります。このケースをサポートする別の方法として、GSS-APIは、直接比較できる隣接する文字列名の特別な形式を定義します（例：memcmp（））。比較に適した隣接する名前は、gss_export_name（）ルーチンによって生成されます。これには、入力としてMNが必要です。エクスポートされた名前はGSS_IMPORT_NAME（）ルーチンによって再インポートされる場合があり、結果の内部名もMNになります。gss_oid constant gss_c_nt_export_nameは「エクスポート名」タイプを示し、この定数の値は付録Aに記載されています。構造的に、エクスポートされた名前オブジェクトは、名前を認証するメカニズムを識別するヘッダーと、ヘッダーと、次のものとトレーラーを含むトレーラーで構成されています。名前自体、トレーラーの構文は個々のメカニズム仕様によって定義されます。エクスポート名の正確な形式は、言語に依存しないGSS-API仕様[GSSAPI]で定義されています。"
    },
    {
      "indent": 3,
      "text": "Note that the results obtained by using gss_compare_name() will in general be different from those obtained by invoking gss_canonicalize_name() and gss_export_name(), and then comparing the exported names. The first series of operation determines whether two (unauthenticated) names identify the same principal; the second whether a particular mechanism would authenticate them as the same principal. These two operations will in general give the same results only for MNs.",
      "ja": "gss_compare_name（）を使用して得られた結果は、一般にgss_canonicalize_name（）およびgss_export_name（）を呼び出して取得した結果とは異なることに注意してください。最初の一連の操作は、2つの（認証されていない）名前が同じプリンシパルを識別するかどうかを決定します。2番目は、特定のメカニズムがそれらを同じプリンシパルとして認証するかどうか。これらの2つの操作は、一般にMNSでのみ同じ結果をもたらします。"
    },
    {
      "indent": 3,
      "text": "The gss_name_t datatype should be implemented as a pointer type. To allow the compiler to aid the application programmer by performing type-checking, the use of (void *) is discouraged. A pointer to an implementation-defined type is the preferred choice.",
      "ja": "GSS_NAME_T DATATYPEは、ポインタータイプとして実装する必要があります。タイプチェックを実行してコンパイラがアプリケーションプログラマーを支援できるようにするために、（void *）の使用が阻止されます。実装定義のタイプへのポインターが推奨される選択です。"
    },
    {
      "indent": 3,
      "text": "Storage is allocated by routines that return gss_name_t values. A procedure, gss_release_name, is provided to free storage associated with an internal-form name.",
      "ja": "ストレージは、GSS_NAME_T値を返すルーチンによって割り当てられます。手順、GSS_RELEASE_NAMEは、内部形式名に関連付けられた無料ストレージに提供されます。"
    },
    {
      "indent": 0,
      "text": "3.11. Channel Bindings",
      "section_title": true,
      "ja": "3.11. チャネルバインディング"
    },
    {
      "indent": 3,
      "text": "GSS-API supports the use of user-specified tags to identify a given context to the peer application. These tags are intended to be used to identify the particular communications channel that carries the context. Channel bindings are communicated to the GSS-API using the following structure:",
      "ja": "GSS-APIは、ユーザー指定のタグの使用をサポートして、特定のコンテキストをピアアプリケーションに識別します。これらのタグは、コンテキストを運ぶ特定の通信チャネルを識別するために使用することを目的としています。チャネルバインディングは、次の構造を使用してGSS-APIに通知されます。"
    },
    {
      "indent": 3,
      "text": "typedef struct gss_channel_bindings_struct {\n   OM_uint32       initiator_addrtype;\n   gss_buffer_desc initiator_address;\n   OM_uint32       acceptor_addrtype;\n   gss_buffer_desc acceptor_address;\n   gss_buffer_desc application_data;\n} *gss_channel_bindings_t;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The initiator_addrtype and acceptor_addrtype fields denote the type of addresses contained in the initiator_address and acceptor_address buffers. The address type should be one of the following:",
      "ja": "initiator_addrtypeおよびaccedor_addrtypeフィールドは、initiator_addressおよびaccedor_addressバッファに含まれるアドレスのタイプを示します。アドレスタイプは次のいずれかである必要があります。"
    },
    {
      "indent": 3,
      "text": "GSS_C_AF_UNSPEC Unspecified address type GSS_C_AF_LOCAL Host-local address type GSS_C_AF_INET Internet address type (e.g. IP) GSS_C_AF_IMPLINK ARPAnet IMP address type GSS_C_AF_PUP pup protocols (eg BSP) address type GSS_C_AF_CHAOS MIT CHAOS protocol address type GSS_C_AF_NS XEROX NS address type GSS_C_AF_NBS nbs address type GSS_C_AF_ECMA ECMA address type GSS_C_AF_DATAKIT datakit protocols address type GSS_C_AF_CCITT CCITT protocols GSS_C_AF_SNA IBM SNA address type GSS_C_AF_DECnet DECnet address type GSS_C_AF_DLI Direct data link interface address type GSS_C_AF_LAT LAT address type GSS_C_AF_HYLINK NSC Hyperchannel address type GSS_C_AF_APPLETALK AppleTalk address type GSS_C_AF_BSC BISYNC 2780/3780 address type GSS_C_AF_DSS Distributed system services address type GSS_C_AF_OSI OSI TP4 address type GSS_C_AF_X25 X.25 GSS_C_AF_NULLADDR No address specified",
      "ja": "gss_c_unspec unspecifiedアドレスタイプタイプタイプgss_c_af_localホストローカルアドレスタイプGSS_C_AF_INETインターネットアドレスタイプ（例えばIP） NSアドレスタイプGSS_C_AF_NBS NBSアドレスタイプGSS_C_AF_ECMA ECMAアドレスタイプGSS_C_AF_DATAKIT DATAKITプロトコルのアドレスタイプGSS_C_AF_CCITT CCITTプロトコルGSS_C_AF_SNA IBM SNAアドレスタイプGSS_C_AF_DECNET DECNET DECNETタイプGSS_C_AF_DLI DIRAPRING LINK INTEPING INTEPINCEPAND _HILINK TPPICE gss_c_lat gnat gsppync_pperink nat perppers S_C_AF_APPLETALK APPLETALKアドレスタイプGSS_C_AF_BSC BISYNC 2780/3780アドレスタイプGSS_C_AF_DSS分散システムサービスアドレスタイプGSS_C_AF_OSI OSI TP4アドレスタイプGSS_C_AF_X25 X.25 GSS_C_AF_NULLADDRアドレスなし指定"
    },
    {
      "indent": 3,
      "text": "Note that these symbols name address families rather than specific addressing formats. For address families that contain several alternative address forms, the initiator_address and acceptor_address fields must contain sufficient information to determine which address form is used. When not otherwise specified, addresses should be specified in network byte-order (that is, native byte-ordering for the address family).",
      "ja": "これらのシンボルは、特定のアドレス指定形式ではなく、アドレスファミリーに名前を付けていることに注意してください。いくつかの代替アドレスフォームを含むアドレスファミリの場合、initiator_addressおよびaccedor_addressフィールドには、どのアドレスフォームが使用されているかを決定するのに十分な情報を含める必要があります。それ以外の指定がない場合は、アドレスをネットワークバイトオーダー（つまり、住所ファミリーのネイティブバイト順序）で指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Conceptually, the GSS-API concatenates the initiator_addrtype, initiator_address, acceptor_addrtype, acceptor_address and application_data to form an octet string. The mechanism calculates a MIC over this octet string, and binds the MIC to the context establishment token emitted by gss_init_sec_context. The same bindings are presented by the context acceptor to gss_accept_sec_context, and a MIC is calculated in the same way. The calculated MIC is compared with that found in the token, and if the MICs differ, gss_accept_sec_context will return a GSS_S_BAD_BINDINGS error, and the context will not be established. Some mechanisms may include the actual channel binding data in the token (rather than just a MIC); applications should therefore not use confidential data as channel-binding components.",
      "ja": "概念的には、GSS-APIは、initiator_addrtype、initiator_address、accedor_addrtype、accedor_address、application_dataを連結してオクター文字列を形成します。メカニズムは、このオクテット文字列のマイクを計算し、gss_init_sec_contextによって放出されるコンテキスト確立トークンにマイクをバインドします。同じバインディングは、Context AcceptorからGSS_ACCEPT_SEC_CONTEXTに提示され、MICは同じ方法で計算されます。計算されたマイクは、トークンに見られるマイクと比較され、MICSが異なる場合、GSS_ACCEPT_SEC_CONTEXTはGSS_S_BAD_BINDINGSエラーを返し、コンテキストは確立されません。いくつかのメカニズムには、トークンの実際のチャネル結合データが含まれる場合があります（単なるマイクではなく）。したがって、アプリケーションは、チャネル結合コンポーネントとして機密データを使用しないでください。"
    },
    {
      "indent": 3,
      "text": "Individual mechanisms may impose additional constraints on addresses and address types that may appear in channel bindings. For example, a mechanism may verify that the initiator_address field of the channel bindings presented to gss_init_sec_context contains the correct network address of the host system. Portable applications should therefore ensure that they either provide correct information for the address fields, or omit addressing information, specifying GSS_C_AF_NULLADDR as the address-types.",
      "ja": "個々のメカニズムは、チャネルバインディングに表示される可能性のあるアドレスとアドレスタイプに追加の制約を課す場合があります。たとえば、メカニズムは、GSS_INIT_SEC_CONTEXTに提示されたチャネルバインディングのinitiator_addressフィールドに、ホストシステムの正しいネットワークアドレスが含まれていることを確認する場合があります。したがって、ポータブルアプリケーションは、アドレスフィールドに正しい情報を提供するか、アドレス指定情報を省略して、GSS_C_AF_NULLADDRをアドレスタイプとして指定することを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.12. Optional parameters",
      "section_title": true,
      "ja": "3.12. オプションのパラメーター"
    },
    {
      "indent": 3,
      "text": "Various parameters are described as optional. This means that they follow a convention whereby a default value may be requested. The following conventions are used for omitted parameters. These conventions apply only to those parameters that are explicitly documented as optional.",
      "ja": "さまざまなパラメーターがオプションとして説明されています。これは、デフォルト値が要求される可能性があるコンベンションに従うことを意味します。省略されたパラメーターには、次の規則が使用されます。これらの規則は、オプションとして明示的に文書化されたパラメーターにのみ適用されます。"
    },
    {
      "indent": 0,
      "text": "3.12.1. gss_buffer_t types",
      "section_title": true,
      "ja": "3.12.1. GSS_BUFFER_Tタイプ"
    },
    {
      "indent": 3,
      "text": "Specify GSS_C_NO_BUFFER as a value. For an input parameter this signifies that default behavior is requested, while for an output parameter it indicates that the information that would be returned via the parameter is not required by the application.",
      "ja": "GSS_C_NO_BUFFERを値として指定します。入力パラメーターの場合、これはデフォルトの動作が要求されることを意味しますが、出力パラメーターの場合、パラメーターを介して返される情報がアプリケーションでは必要ないことを示します。"
    },
    {
      "indent": 0,
      "text": "3.12.2. Integer types (input)",
      "section_title": true,
      "ja": "3.12.2. 整数型（入力）"
    },
    {
      "indent": 3,
      "text": "Individual parameter documentation lists values to be used to indicate default actions.",
      "ja": "個々のパラメータードキュメントには、デフォルトのアクションを示すために使用される値がリストされています。"
    },
    {
      "indent": 0,
      "text": "3.12.3. Integer types (output)",
      "section_title": true,
      "ja": "3.12.3. 整数タイプ（出力）"
    },
    {
      "indent": 3,
      "text": "Specify NULL as the value for the pointer.",
      "ja": "ポインターの値としてnullを指定します。"
    },
    {
      "indent": 0,
      "text": "3.12.4. Pointer types",
      "section_title": true,
      "ja": "3.12.4. ポインタータイプ"
    },
    {
      "indent": 3,
      "text": "Specify NULL as the value.",
      "ja": "値としてnullを指定します。"
    },
    {
      "indent": 0,
      "text": "3.12.5. Object IDs",
      "section_title": true,
      "ja": "3.12.5. オブジェクトID"
    },
    {
      "indent": 3,
      "text": "Specify GSS_C_NO_OID as the value.",
      "ja": "gss_c_no_oidを値として指定します。"
    },
    {
      "indent": 0,
      "text": "3.12.6. Object ID Sets",
      "section_title": true,
      "ja": "3.12.6. オブジェクトIDセット"
    },
    {
      "indent": 3,
      "text": "Specify GSS_C_NO_OID_SET as the value.",
      "ja": "gss_c_no_oid_setを値として指定します。"
    },
    {
      "indent": 0,
      "text": "3.12.7. Channel Bindings",
      "section_title": true,
      "ja": "3.12.7. チャネルバインディング"
    },
    {
      "indent": 3,
      "text": "Specify GSS_C_NO_CHANNEL_BINDINGS to indicate that channel bindings are not to be used.",
      "ja": "GSS_C_NO_CHANNEL_BINDINGSを指定して、チャネルバインディングを使用しないことを示します。"
    },
    {
      "indent": 0,
      "text": "4. Additional Controls",
      "section_title": true,
      "ja": "4. 追加のコントロール"
    },
    {
      "indent": 3,
      "text": "This section discusses the optional services that a context initiator may request of the GSS-API at context establishment. Each of these services is requested by setting a flag in the req_flags input parameter to gss_init_sec_context.",
      "ja": "このセクションでは、コンテキストイニシエーターがコンテキスト確立でGSS-APIの要求が可能なオプションのサービスについて説明します。これらの各サービスは、REQ_FLAGS入力パラメーターのフラグをGSS_INIT_SEC_CONTEXTに設定することにより要求されます。"
    },
    {
      "indent": 3,
      "text": "The optional services currently defined are:",
      "ja": "現在定義されているオプションのサービスは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Delegation - The (usually temporary) transfer of rights from initiator to acceptor, enabling the acceptor to authenticate itself as an agent of the initiator.",
      "ja": "委任 - （通常は一時的な）イニシエーターからアクセプターへの権利の移転により、アクセプターがイニシエーターのエージェントとして認証できるようにします。"
    },
    {
      "indent": 3,
      "text": "Mutual Authentication - In addition to the initiator authenticating its identity to the context acceptor, the context acceptor should also authenticate itself to the initiator.",
      "ja": "相互認証 - そのアイデンティティをコンテキストアクセプターに認証するイニシエーターに加えて、コンテキストアクセプターはイニシエーターにも認証する必要があります。"
    },
    {
      "indent": 3,
      "text": "Replay detection - In addition to providing message integrity services, gss_get_mic and gss_wrap should include message numbering information to enable gss_verify_mic and gss_unwrap to detect if a message has been duplicated.",
      "ja": "リプレイ検出 - メッセージ整合性サービスの提供に加えて、GSS_GET_MICとGSS_WRAPには、メッセージが複製されているかどうかを検出できるように、gss_verify_micおよびgss_unwrapを有効にするためのメッセージ番号情報を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Out-of-sequence detection - In addition to providing message integrity services, gss_get_mic and gss_wrap should include message sequencing information to enable gss_verify_mic and gss_unwrap to detect if a message has been received out of sequence.",
      "ja": "アウトシーケンス検出 - メッセージ整合性サービスの提供に加えて、GSS_GET_MICとGSS_WRAPには、GSS_VERIFY_MICおよびGSS_UNWRAPを有効にするためのメッセージシーケンス情報を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Anonymous authentication - The establishment of the security context should not reveal the initiator's identity to the context acceptor.",
      "ja": "匿名認証 - セキュリティコンテキストの確立は、Context Acceptorにイニシエーターの身元を明らかにするべきではありません。"
    },
    {
      "indent": 3,
      "text": "Any currently undefined bits within such flag arguments should be ignored by GSS-API implementations when presented by an application, and should be set to zero when returned to the application by the GSS-API implementation.",
      "ja": "このようなフラグの引数内の未定義のビットは、アプリケーションによって提示された場合、GSS-API実装によって無視される必要があり、GSS-API実装によってアプリケーションに返されるとゼロに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Some mechanisms may not support all optional services, and some mechanisms may only support some services in conjunction with others. Both gss_init_sec_context and gss_accept_sec_context inform the applications which services will be available from the context when the establishment phase is complete, via the ret_flags output parameter. In general, if the security mechanism is capable of providing a requested service, it should do so, even if additional services must be enabled in order to provide the requested service. If the mechanism is incapable of providing a requested service, it should proceed without the service, leaving the application to abort the context establishment process if it considers the requested service to be mandatory.",
      "ja": "一部のメカニズムはすべてのオプションのサービスをサポートしない場合があり、一部のメカニズムは他のサービスと併せて一部のサービスのみをサポートする場合があります。GSS_INIT_SEC_CONTEXTとGSS_ACCEPT_SEC_CONTEXTの両方の両方が、RET_FLAGS出力パラメーターを介して、確立フェーズが完了したときにコンテキストから利用可能なサービスをアプリケーションに通知します。一般に、セキュリティメカニズムが要求されたサービスを提供できる場合、要求されたサービスを提供するために追加のサービスを有効にする必要がある場合でも、そうする必要があります。メカニズムが要求されたサービスを提供できない場合は、サービスなしで進行する必要があり、要求されたサービスが必須であると考える場合、コンテキスト確立プロセスを中止するためにアプリケーションを残します。"
    },
    {
      "indent": 3,
      "text": "Some mechanisms may specify that support for some services is optional, and that implementors of the mechanism need not provide it. This is most commonly true of the confidentiality service, often because of legal restrictions on the use of data-encryption, but may apply to any of the services. Such mechanisms are required to send at least one token from acceptor to initiator during context establishment when the initiator indicates a desire to use such a service, so that the initiating GSS-API can correctly indicate whether the service is supported by the acceptor's GSS-API.",
      "ja": "一部のメカニズムは、一部のサービスのサポートがオプションであり、メカニズムの実装者がそれを提供する必要はないことを指定する場合があります。これは、多くの場合、データ暗号化の使用に関する法的制限があるため、機密性サービスに最も一般的ですが、どのサービスにも適用される場合があります。このようなメカニズムは、イニシエーターがそのようなサービスを使用したいという欲求を示している場合、コンテキスト確立中にアクセプターから開始者に少なくとも1つのトークンを送信するために必要です。。"
    },
    {
      "indent": 0,
      "text": "4.1. Delegation",
      "section_title": true,
      "ja": "4.1. 代表団"
    },
    {
      "indent": 3,
      "text": "The GSS-API allows delegation to be controlled by the initiating application via a boolean parameter to gss_init_sec_context(), the routine that establishes a security context. Some mechanisms do not support delegation, and for such mechanisms attempts by an application to enable delegation are ignored.",
      "ja": "GSS-APIにより、セキュリティコンテキストを確立するルーチンであるGSS_INIT_SEC_CONTEXT（）へのブールパラメーターを介して、開始アプリケーションによって委任を制御できます。一部のメカニズムは委任をサポートしておらず、そのようなメカニズムについては、委任を有効にするためのアプリケーションによる試みは無視されます。"
    },
    {
      "indent": 3,
      "text": "The acceptor of a security context for which the initiator enabled delegation will receive (via the delegated_cred_handle parameter of gss_accept_sec_context) a credential handle that contains the delegated identity, and this credential handle may be used to initiate subsequent GSS-API security contexts as an agent or delegate of the initiator. If the original initiator's identity is \"A\" and the delegate's identity is \"B\", then, depending on the underlying mechanism, the identity embodied by the delegated credential may be either \"A\" or \"B acting for A\".",
      "ja": "イニシエーターが代表団を有効にしたセキュリティコンテキストのアクセプターは、（GSS_ACCEPT_SEC_CONTEXTのDELEGATED_CRED_HANDLEパラメーターを介して）委任されたアイデンティティを含む資格的ハンドルを受け取ります。イニシエーターの代表者。元のイニシエーターのアイデンティティが「A」であり、代表者のアイデンティティが「B」である場合、基礎となるメカニズムに応じて、委任された資格情報によって具体化されるアイデンティティは「A」または「Aのために作用する」のいずれかである場合があります。"
    },
    {
      "indent": 3,
      "text": "For many mechanisms that support delegation, a simple boolean does not provide enough control. Examples of additional aspects of delegation control that a mechanism might provide to an application are duration of delegation, network addresses from which delegation is valid, and constraints on the tasks that may be performed by a delegate. Such controls are presently outside the scope of the GSS-API. GSS-API implementations supporting mechanisms offering additional controls should provide extension routines that allow these controls to be exercised (perhaps by modifying the initiator's GSS-API credential prior to its use in establishing a context). However, the simple delegation control provided by GSS-API should always be able to over-ride other mechanism-specific delegation controls - If the application instructs gss_init_sec_context() that delegation is not desired, then the implementation must not permit delegation to occur. This is an exception to the general rule that a mechanism may enable services even if they are not requested - delegation may only be provided at the explicit request of the application.",
      "ja": "代表団をサポートする多くのメカニズムでは、単純なブール値は十分な制御を提供しません。アプリケーションにメカニズムが提供する可能性のある委任制御の追加の側面の例は、委任の期間、委任が有効なネットワークアドレス、および代表者が実行できるタスクの制約です。このようなコントロールは現在、GSS-APIの範囲外です。追加のコントロールを提供するメカニズムをサポートするGSS-API実装は、これらのコントロールを行使できるようにする拡張ルーチンを提供する必要があります（おそらく、コンテキストの確立に使用する前にイニシエーターのGSS-API資格情報を変更することにより）。ただし、GSS-APIによって提供される単純な委任制御は、常に他のメカニズム固有の委任コントロールをオーバーライドできる必要があります - アプリケーションがGSS_INIT_SEC_CONTEXT（）に指示する場合、委任が望ましくないと、実装は委任を許可してはなりません。これは、メカニズムが要求されていなくてもサービスを有効にする可能性があるという一般的なルールの例外です。委任は、アプリケーションの明示的な要求でのみ提供される場合があります。"
    },
    {
      "indent": 0,
      "text": "4.2. Mutual authentication",
      "section_title": true,
      "ja": "4.2. 相互認証"
    },
    {
      "indent": 3,
      "text": "Usually, a context acceptor will require that a context initiator authenticate itself so that the acceptor may make an access-control decision prior to performing a service for the initiator. In some cases, the initiator may also request that the acceptor authenticate itself. GSS-API allows the initiating application to request this mutual authentication service by setting a flag when calling gss_init_sec_context.",
      "ja": "通常、コンテキストアクセプターは、コンテキストイニシエーターが自体を認証することを要求して、アクセプターがイニシエーターのサービスを実行する前にアクセス制御決定を下すことができます。場合によっては、イニシエーターは、アクセプターが認証することを要求することもあります。GSS-APIを使用すると、GSS_INIT_SEC_CONTEXTを呼び出すときにフラグを設定することにより、開始アプリケーションがこの相互認証サービスを要求できます。"
    },
    {
      "indent": 3,
      "text": "The initiating application is informed as to whether or not the context acceptor has authenticated itself. Note that some mechanisms may not support mutual authentication, and other mechanisms may always perform mutual authentication, whether or not the initiating application requests it. In particular, mutual authentication my be required by some mechanisms in order to support replay or out-of-sequence message detection, and for such mechanisms a request for either of these services will automatically enable mutual authentication.",
      "ja": "開始アプリケーションは、コンテキストアクセプターが自らを認証したかどうかについて通知されます。一部のメカニズムは相互認証をサポートしない場合があり、他のメカニズムは、開始アプリケーションが要求するかどうかにかかわらず、相互認証を常に実行する場合があることに注意してください。特に、相互認証のリプレイまたはシーケンスメッセージの検出をサポートするために、いくつかのメカニズムで必要とされます。そのようなメカニズムのために、これらのサービスのいずれかの要求は相互認証を自動的に有効にします。"
    },
    {
      "indent": 0,
      "text": "4.3. Replay and out-of-sequence detection",
      "section_title": true,
      "ja": "4.3. リプレイとシーケンスの検出"
    },
    {
      "indent": 3,
      "text": "The GSS-API may provide detection of mis-ordered message once a security context has been established. Protection may be applied to messages by either application, by calling either gss_get_mic or gss_wrap, and verified by the peer application by calling gss_verify_mic or gss_unwrap.",
      "ja": "GSS-APIは、セキュリティコンテキストが確立されると、誤った順序のメッセージの検出を提供する場合があります。保護は、GSS_GET_MICまたはGSS_WRAPを呼び出すことにより、いずれかのアプリケーションによってメッセージに適用され、GSS_Verify_MicまたはGSS_UNWRAPを呼び出すことにより、ピアアプリケーションによって検証できます。"
    },
    {
      "indent": 3,
      "text": "gss_get_mic calculates a cryptographic MIC over an application message, and returns that MIC in a token. The application should pass both the token and the message to the peer application, which presents them to gss_verify_mic.",
      "ja": "GSS_GET_MICアプリケーションメッセージで暗号化マイクを計算し、トークンでそのマイクを返します。アプリケーションは、トークンとメッセージの両方をピアアプリケーションに渡す必要があります。これにより、GSS_verify_micに表示されます。"
    },
    {
      "indent": 3,
      "text": "gss_wrap calculates a cryptographic MIC of an application message, and places both the MIC and the message inside a single token. The Application should pass the token to the peer application, which presents it to gss_unwrap to extract the message and verify the MIC.",
      "ja": "GSS_WRAPは、アプリケーションメッセージの暗号化マイクを計算し、マイクとメッセージの両方を単一のトークン内に配置します。 アプリケーションはトークンをピアアプリケーションに渡す必要があります。これにより、GSS_UNWRAPに提示してメッセージを抽出し、MICを確認します。"
    },
    {
      "indent": 3,
      "text": "Either pair of routines may be capable of detecting out-of-sequence message delivery, or duplication of messages. Details of such mis-ordered messages are indicated through supplementary status bits in the major status code returned by gss_verify_mic or gss_unwrap. The relevant supplementary bits are:",
      "ja": "どちらのペアのルーチンも、順番外のメッセージ配信を検出したり、メッセージの複製を検出できる場合があります。このような誤ったメッセージの詳細は、gss_verify_micまたはgss_unwrapによって返された主要なステータスコードの補足ステータスビットによって示されます。関連する補足ビットは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "GSS_S_DUPLICATE_TOKEN - The token is a duplicate of one that has already been received and processed. Only contexts that claim to provide replay detection may set this bit. GSS_S_OLD_TOKEN - The token is too old to determine whether or not it is a duplicate. Contexts supporting out-of-sequence detection but not replay detection should always set this bit if GSS_S_UNSEQ_TOKEN is set; contexts that support replay detection should only set this bit if the token is so old that it cannot be checked for duplication. GSS_S_UNSEQ_TOKEN - A later token has already been processed. GSS_S_GAP_TOKEN - An earlier token has not yet been received.",
      "ja": "GSS_S_DUPLICATION_TOKEN-トークンは、すでに受信および処理されたものの複製です。リプレイ検出を提供すると主張するコンテキストのみが、このビットを設定することができます。GSS_S_OLD_TOKEN-トークンは古すぎて複製かどうかを判断できません。GSS_S_UNSEQ_TOKENが設定されている場合、リプレイの検出ではなく、順調な検出をサポートするコンテキストは、常にこのビットを設定する必要があります。リプレイ検出をサポートするコンテキストは、トークンが非常に古いため、重複をチェックできない場合にのみ、このビットを設定する必要があります。GSS_S_UNSEQ_TOKEN-後のトークンはすでに処理されています。GSS_S_GAP_TOKEN-以前のトークンはまだ受信されていません。"
    },
    {
      "indent": 3,
      "text": "A mechanism need not maintain a list of all tokens that have been processed in order to support these status codes. A typical mechanism might retain information about only the most recent \"N\" tokens processed, allowing it to distinguish duplicates and missing tokens within the most recent \"N\" messages; the receipt of a token older than the most recent \"N\" would result in a GSS_S_OLD_TOKEN status.",
      "ja": "メカニズムは、これらのステータスコードをサポートするために処理されたすべてのトークンのリストを維持する必要はありません。典型的なメカニズムは、最新の「n」トークンのみに関する情報を保持し、最新の「n」メッセージ内の重複と欠落しているトークンを区別できるようにします。最新の「n」よりも古いトークンの受領は、GSS_S_OLD_TOKENステータスになります。"
    },
    {
      "indent": 0,
      "text": "4.4. Anonymous Authentication",
      "section_title": true,
      "ja": "4.4. 匿名認証"
    },
    {
      "indent": 3,
      "text": "In certain situations, an application may wish to initiate the authentication process to authenticate a peer, without revealing its own identity. As an example, consider an application providing access to a database containing medical information, and offering unrestricted access to the service. A client of such a service might wish to authenticate the service (in order to establish trust in any information retrieved from it), but might not wish the service to be able to obtain the client's identity (perhaps due to privacy concerns about the specific inquiries, or perhaps simply to avoid being placed on mailing-lists).",
      "ja": "特定の状況では、アプリケーションは、独自のアイデンティティを明らかにすることなく、ピアを認証するための認証プロセスを開始することをお勧めします。例として、医療情報を含むデータベースへのアクセスを提供し、サービスへの無制限のアクセスを提供するアプリケーションを検討してください。そのようなサービスのクライアントは（それから取得された情報に対する信頼を確立するためにサービスを認証することを希望するかもしれませんが、サービスがクライアントの身元を取得できることを望んでいないかもしれません（おそらく特定の問い合わせに関するプライバシーの懸念のために、または単に郵送リストに置かれないようにするために）。"
    },
    {
      "indent": 3,
      "text": "In normal use of the GSS-API, the initiator's identity is made available to the acceptor as a result of the context establishment process. However, context initiators may request that their identity not be revealed to the context acceptor. Many mechanisms do not support anonymous authentication, and for such mechanisms the request will not be honored. An authentication token will be still be generated, but the application is always informed if a requested service is unavailable, and has the option to abort context establishment if anonymity is valued above the other security services that would require a context to be established.",
      "ja": "GSS-APIの通常の使用では、コンテキスト確立プロセスの結果として、イニシエーターのアイデンティティがアクセプターに利用可能になります。ただし、コンテキストイニシエーターは、自分の身元がコンテキストアクセプターに明らかにされないように要求する場合があります。多くのメカニズムは匿名認証をサポートしておらず、そのようなメカニズムについては、リクエストは尊重されません。認証トークンは引き続き生成されますが、要求されたサービスが利用できない場合は常にアプリケーションに通知され、匿名性が確立される必要がある他のセキュリティサービスよりも評価されている場合、コンテキスト確立を中止するオプションがあります。"
    },
    {
      "indent": 3,
      "text": "In addition to informing the application that a context is established anonymously (via the ret_flags outputs from gss_init_sec_context and gss_accept_sec_context), the optional src_name output from gss_accept_sec_context and gss_inquire_context will, for such contexts, return a reserved internal-form name, defined by the implementation.",
      "ja": "コンテキストが匿名で確立されていることをアプリケーションに通知することに加えて（gss_init_sec_contextおよびgss_accept_sec_contextからのret_flags出力を介して）、gss_accept_sec_contextおよびgsss_inquire_contextからのgss_accept_sec_contextおよびgsquire_contextからのオプションのsrc_name出力は、そのようなコンテキストを返します。"
    },
    {
      "indent": 3,
      "text": "When presented to gss_display_name, this reserved internal-form name will result in a printable name that is syntactically distinguishable from any valid principal name supported by the implementation, associated with a name-type object identifier with the value GSS_C_NT_ANONYMOUS, whose value us given in Appendix A. The printable form of an anonymous name should be chosen such that it implies anonymity, since this name may appear in, for example, audit logs. For example, the string \"<anonymous>\" might be a good choice, if no valid printable names supported by the implementation can begin with \"<\" and end with \">\".",
      "ja": "gss_display_nameに提示されると、この予約された内部形式名は、value gss_c_nt_anonymousを持つ名前型オブジェクト識別子に関連付けられた実装によってサポートされている有効な主名と構文的に区別できる印刷可能な名前になります。A.この名前が監査ログに表示される可能性があるため、匿名の名前の印刷可能な形式は匿名性を意味するように選択する必要があります。たとえば、文字列「<anonymous>」は、実装でサポートされている有効な印刷可能な名前が「<」から始まり、「>」で終わることができない場合、良い選択かもしれません。"
    },
    {
      "indent": 0,
      "text": "4.5. Confidentiality",
      "section_title": true,
      "ja": "4.5. 機密性"
    },
    {
      "indent": 3,
      "text": "If a context supports the confidentiality service, gss_wrap may be used to encrypt application messages. Messages are selectively encrypted, under the control of the conf_req_flag input parameter to gss_wrap.",
      "ja": "コンテキストが機密保持サービスをサポートする場合、GSS_WRAPを使用してアプリケーションメッセージを暗号化できます。メッセージは、conf_req_flag入力パラメーターをgss_wrapに制御する下で、選択的に暗号化されます。"
    },
    {
      "indent": 0,
      "text": "4.6. Inter-process context transfer",
      "section_title": true,
      "ja": "4.6. インタープロセスコンテキスト転送"
    },
    {
      "indent": 3,
      "text": "GSS-API V2 provides routines (gss_export_sec_context and gss_import_sec_context) which allow a security context to be transferred between processes on a single machine. The most common use for such a feature is a client-server design where the server is implemented as a single process that accepts incoming security contexts, which then launches child processes to deal with the data on these contexts. In such a design, the child processes must have access to the security context data structure created within the parent by its call to gss_accept_sec_context so that they can use per-message protection services and delete the security context when the communication session ends.",
      "ja": "GSS-API V2は、単一のマシンのプロセス間でセキュリティコンテキストを転送できるルーチン（GSS_EXPORT_SEC_CONTEXTおよびGSS_IMPORT_SEC_CONTEXT）を提供します。このような機能の最も一般的な用途は、サーバーが着信セキュリティコンテキストを受け入れる単一のプロセスとして実装され、これらのコンテキストに関するデータに対処するための子プロセスを起動するクライアントサーバー設計です。このような設計では、子どものプロセスは、gss_accept_sec_contextへの呼び出しによって親内に作成されたセキュリティコンテキストデータ構造にアクセスする必要があります。"
    },
    {
      "indent": 3,
      "text": "Since the security context data structure is expected to contain sequencing information, it is impractical in general to share a context between processes. Thus GSS-API provides a call (gss_export_sec_context) that the process which currently owns the context can call to declare that it has no intention to use the context subsequently, and to create an inter-process token containing information needed by the adopting process to successfully import the context. After successful completion of gss_export_sec_context, the original security context is made inaccessible to the calling process by GSS-API, and any context handles referring to this context are no longer valid. The originating process transfers the inter-process token to the adopting process, which passes it to gss_import_sec_context, and a fresh gss_ctx_id_t is created such that it is functionally identical to the original context.",
      "ja": "セキュリティコンテキストデータ構造にはシーケンス情報が含まれると予想されるため、プロセス間でコンテキストを共有することは一般に非現実的です。したがって、GSS-APIは、現在コンテキストを所有しているプロセスが、その後のコンテキストを使用する意図がないことを宣言し、採用プロセスが正常に成功させるために必要な情報を含むプロセス間トークンを作成することを宣言することができるという呼び出し（gss_export_sec_context）を提供します。コンテキストをインポートします。gss_export_sec_contextが正常に完了した後、元のセキュリティコンテキストはGSS-APIによる呼び出しプロセスにアクセスできなくなり、このコンテキストを参照するコンテキストハンドルはもはや有効ではありません。発信元のプロセスは、インタープロセストークンを採用プロセスに転送し、GSS_IMPORT_SEC_CONTEXTに渡し、新鮮なGSS_CTX_ID_Tが作成され、元のコンテキストと機能的に同一になります。"
    },
    {
      "indent": 3,
      "text": "The inter-process token may contain sensitive data from the original security context (including cryptographic keys). Applications using inter-process tokens to transfer security contexts must take appropriate steps to protect these tokens in transit.",
      "ja": "プロセス間トークンには、元のセキュリティコンテキスト（暗号化キーを含む）からの機密データが含まれている場合があります。プロセス間トークンを使用してセキュリティコンテキストを転送するアプリケーションは、これらのトークンを輸送中に保護するために適切な措置を講じる必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementations are not required to support the inter-process transfer of security contexts. The ability to transfer a security context is indicated when the context is created, by gss_init_sec_context or gss_accept_sec_context setting the GSS_C_TRANS_FLAG bit in their ret_flags parameter.",
      "ja": "セキュリティコンテキストのプロセス間転送をサポートするために実装は必要ありません。gss_init_sec_contextまたはgss_accept_sec_contextにより、コンテキストが作成されると、セキュリティコンテキストを転送する機能が示されます。ret_flagsパラメーターのgss_c_trans_flagビットを設定します。"
    },
    {
      "indent": 0,
      "text": "4.7. The use of incomplete contexts",
      "section_title": true,
      "ja": "4.7. 不完全なコンテキストの使用"
    },
    {
      "indent": 3,
      "text": "Some mechanisms may allow the per-message services to be used before the context establishment process is complete. For example, a mechanism may include sufficient information in its initial context-level token for the context acceptor to immediately decode messages protected with gss_wrap or gss_get_mic. For such a mechanism, the initiating application need not wait until subsequent context-level tokens have been sent and received before invoking the per-message protection services.",
      "ja": "いくつかのメカニズムにより、コンテキスト確立プロセスが完了する前に、メッセージごとのサービスを使用することができます。たとえば、メカニズムには、Context AcceptorがGSS_WRAPまたはGSS_GET_MICで保護されたメッセージをすぐにデコードするための最初のコンテキストレベルトークンに十分な情報を含めることができます。このようなメカニズムのために、開始アプリケーションは、それに続くコンテキストレベルのトークンが送信および受信されるまで待つ必要はありません。"
    },
    {
      "indent": 3,
      "text": "The ability of a context to provide per-message services in advance of complete context establishment is indicated by the setting of the GSS_C_PROT_READY_FLAG bit in the ret_flags parameter from gss_init_sec_context and gss_accept_sec_context. Applications wishing to use per-message protection services on partially-established contexts should check this flag before attempting to invoke gss_wrap or gss_get_mic.",
      "ja": "完全なコンテキスト確立に先立って男性ごとのサービスを提供するコンテキストの能力は、gss_init_sec_contextおよびgss_accept_sec_contextのret_flagsパラメーターのgss_c_prot_ready_flagビットの設定によって示されます。部分的に確立されたコンテキストでメッセージごとの保護サービスを使用したいアプリケーションは、GSS_WRAPまたはGSS_GET_MICを呼び出す前にこのフラグを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "5. GSS-API Routine Descriptions",
      "section_title": true,
      "ja": "5. GSS-APIルーチン説明"
    },
    {
      "indent": 3,
      "text": "In addition to the explicit major status codes documented here, the code GSS_S_FAILURE may be returned by any routine, indicating an implementation-specific or mechanism-specific error condition, further details of which are reported via the minor_status parameter.",
      "ja": "ここに文書化された明示的な主要なステータスコードに加えて、コードGSS_S_FAILUREは任意のルーチンによって返される場合があり、実装固有またはメカニズム固有のエラー条件を示します。"
    },
    {
      "indent": 0,
      "text": "5.1. gss_accept_sec_context",
      "section_title": true,
      "ja": "5.1. gss_accept_sec_context"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_accept_sec_context ( OM_uint32 *minor_status, gss_ctx_id_t *context_handle, const gss_cred_id_t acceptor_cred_handle, const gss_buffer_t input_token_buffer, const gss_channel_bindings_t input_chan_bindings, const gss_name_t *src_name, gss_OID *mech_type, gss_buffer_t output_token, OM_uint32 *ret_flags, OM_uint32 *time_rec, gss_cred_id_t *delegated_cred_handle)",
      "ja": "OM_UINT32 GSS_ACCEPT_SEC_CONTEXT（OM_UINT32 *minor_status、gss_ctx_id_t *context_handle、const gss_cred_id_t accedor_cred_handle、const gss_buffer_t input_token_buffer名前、gss_oid *mech_type、gss_buffer_t output_token、om_uint32 *ret_flags、om_uint32 *time_rec、gss_cred_id_t *delegated_cred_handle）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Allows a remotely initiated security context between the application and a remote peer to be established. The routine may return a output_token which should be transferred to the peer application, where the peer application will present it to gss_init_sec_context. If no token need be sent, gss_accept_sec_context will indicate this by setting the length field of the output_token argument to zero. To complete the context establishment, one or more reply tokens may be required from the peer application; if so, gss_accept_sec_context will return a status flag of GSS_S_CONTINUE_NEEDED, in which case it should be called again when the reply token is received from the peer application, passing the token to gss_accept_sec_context via the input_token parameters.",
      "ja": "アプリケーションとリモートピアの間のリモートで開始されたセキュリティコンテキストを確立することができます。ルーチンは、ピアアプリケーションに転送する必要があるoutput_tokenを返す場合があり、ピアアプリケーションはそれをgss_init_sec_contextに提示します。トークンを送信する必要がない場合、gss_accept_sec_contextは、output_token引数の長さフィールドをゼロに設定することによりこれを示します。コンテキストの確立を完了するには、ピアアプリケーションから1つ以上の返信トークンが必要になる場合があります。その場合、gss_accept_sec_contextはgss_s_s_continue_neededのステータスフラグを返します。この場合、回答トークンがピアアプリケーションから受信されたときに再度呼び出され、入力_tokenパラメーターを介してgscecte_sec_contextにトークンを渡します。"
    },
    {
      "indent": 3,
      "text": "Portable applications should be constructed to use the token length and return status to determine whether a token needs to be sent or waited for. Thus a typical portable caller should always invoke gss_accept_sec_context within a loop:",
      "ja": "ポータブルアプリケーションは、トークンの長さと戻りステータスを使用して、トークンを送信または待機する必要があるかどうかを判断するために構築する必要があります。したがって、典型的なポータブル発信者は、常にループ内でgss_accept_sec_contextを呼び出す必要があります。"
    },
    {
      "indent": 3,
      "text": "gss_ctx_id_t context_hdl = GSS_C_NO_CONTEXT;",
      "ja": "gss_ctx_id_t context_hdl = gss_c_no_context;"
    },
    {
      "indent": 3,
      "text": "do {\n  receive_token_from_peer(input_token);\n  maj_stat = gss_accept_sec_context(&min_stat,\n                                    &context_hdl,\n                                    cred_hdl,\n                                    input_token,\n                                    input_bindings,\n                                    &client_name,\n                                    &mech_type,\n                                    output_token,\n                                    &ret_flags,\n                                    &time_rec,\n                                    &deleg_cred);\n  if (GSS_ERROR(maj_stat)) {\n    report_error(maj_stat, min_stat);\n  };\n  if (output_token->length != 0) {\n    send_token_to_peer(output_token);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    gss_release_buffer(&min_stat, output_token);\n  };\n  if (GSS_ERROR(maj_stat)) {\n    if (context_hdl != GSS_C_NO_CONTEXT)\n      gss_delete_sec_context(&min_stat,\n                             &context_hdl,\n                             GSS_C_NO_BUFFER);\n    break;\n  };\n} while (maj_stat & GSS_S_CONTINUE_NEEDED);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Whenever the routine returns a major status that includes the value GSS_S_CONTINUE_NEEDED, the context is not fully established and the following restrictions apply to the output parameters:",
      "ja": "ルーチンが値GSS_S_S_CONTINUE_NEEDEDを含む主要なステータスを返すときはいつでも、コンテキストは完全に確立されておらず、次の制限が出力パラメーターに適用されます。"
    },
    {
      "indent": 3,
      "text": "The value returned via the time_rec parameter is undefined Unless the accompanying ret_flags parameter contains the bit GSS_C_PROT_READY_FLAG, indicating that per-message services may be applied in advance of a successful completion status, the value returned via the mech_type parameter may be undefined until the routine returns a major status value of GSS_S_COMPLETE.",
      "ja": "添付されたRET_FLAGSパラメーターにビットGSS_C_PROT_READY_FLAGが含まれている場合を除き、Time_Recパラメーターを介して返される値は未定義です。GSS_S_Completeの主要なステータス値。"
    },
    {
      "indent": 3,
      "text": "The values of the GSS_C_DELEG_FLAG, GSS_C_MUTUAL_FLAG,GSS_C_REPLAY_FLAG, GSS_C_SEQUENCE_FLAG, GSS_C_CONF_FLAG,GSS_C_INTEG_FLAG and GSS_C_ANON_FLAG bits returned via the ret_flags parameter should contain the values that the implementation expects would be valid if context establishment were to succeed.",
      "ja": "GSS_C_DELEG_FLAG、GSS_C_MUTUAL_FLAG、GSS_C_REPLAY_FLAG、GSS_C_FLAG_FLAG、GSS_C_CONF_FLAG、GSS_C_INTEG_FLAG、GSS_C_ANON_ANON_FLAGの継続的に依頼されました。 。"
    },
    {
      "indent": 3,
      "text": "The values of the GSS_C_PROT_READY_FLAG and GSS_C_TRANS_FLAG bits within ret_flags should indicate the actual state at the time gss_accept_sec_context returns, whether or not the context is fully established.",
      "ja": "GSS_C_PROT_READY_FLAGおよびGSS_C_TRANS_FLAG BITS内のGSS_C_TRANS_FLAGは、コンテキストが完全に確立されているかどうかにかかわらず、GSS_ACCEPT_SEC_CONTEXT RETURENの実際の状態を示す必要があります。"
    },
    {
      "indent": 3,
      "text": "Although this requires that GSS-API implementations set the GSS_C_PROT_READY_FLAG in the final ret_flags returned to a caller (i.e. when accompanied by a GSS_S_COMPLETE status code), applications should not rely on this behavior as the flag was not defined in Version 1 of the GSS-API. Instead, applications should be prepared to use per-message services after a successful context establishment, according to the GSS_C_INTEG_FLAG and GSS_C_CONF_FLAG values.",
      "ja": "これには、GSS-API実装が発信者に返される最終RET_FLAGSのGSS_C_PROT_READY_FLAGを設定する必要がありますが（つまり、GSS_S_Completeステータスコードを伴う場合）、アプリケーションはGSS-のバージョン1ではフラグが定義されていないため、この動作に依存してはいけません。API。代わりに、GSS_C_INTEG_FLAGおよびGSS_C_CONF_FLAG値に従って、コンテキストの確立を成功させた後、出気ごとのサービスを使用する準備をする必要があります。"
    },
    {
      "indent": 3,
      "text": "All other bits within the ret_flags argument should be set to zero. While the routine returns GSS_S_CONTINUE_NEEDED, the values returned via the ret_flags argument indicate the services that the implementation expects to be available from the established context.",
      "ja": "RET_FLAGS引数内の他のすべてのビットは、ゼロに設定する必要があります。ルーチンはGSS_S_S_CONTINUE_NEEDEDを返しますが、RET_FLAGS引数で返される値は、実装が確立されたコンテキストから利用可能になると予想されるサービスを示しています。"
    },
    {
      "indent": 3,
      "text": "If the initial call of gss_accept_sec_context() fails, the implementation should not create a context object, and should leave the value of the context_handle parameter set to GSS_C_NO_CONTEXT to indicate this. In the event of a failure on a subsequent call, the implementation is permitted to delete the \"half-built\" security context (in which case it should set the context_handle parameter to GSS_C_NO_CONTEXT), but the preferred behavior is to leave the security context (and the context_handle parameter) untouched for the application to delete (using gss_delete_sec_context).",
      "ja": "gss_accept_sec_context（）の最初の呼び出しが失敗した場合、実装はコンテキストオブジェクトを作成しないでください。コンテキスト_handleパラメーターの値をGSS_C_NO_CONTEXTに設定して、これを示す必要があります。後続の呼び出しが失敗した場合、実装は「ハーフ構築」セキュリティコンテキストを削除することが許可されています（この場合、Context_HandleパラメーターをGSS_C_NO_CONTEXTに設定する必要があります）が、好ましい動作はセキュリティコンテキストを離れることです（およびcontext_handleパラメーター）は、アプリケーションが削除するために（gss_delete_sec_contextを使用）削除するために触れられません。"
    },
    {
      "indent": 3,
      "text": "During context establishment, the informational status bits GSS_S_OLD_TOKEN and GSS_S_DUPLICATE_TOKEN indicate fatal errors, and GSS-API mechanisms should always return them in association with a routine error of GSS_S_FAILURE. This requirement for pairing did not exist in version 1 of the GSS-API specification, so applications that wish to run over version 1 implementations must special-case these codes.",
      "ja": "コンテキストの確立中に、情報ステータスビットGSS_OLD_TOKENおよびGSS_S_DUPLICATION_TOKENは致命的なエラーを示し、GSS-APIメカニズムは常にGSS_S_FAILUREの日常的なエラーに関連してそれらを返す必要があります。このペアリングの要件は、GSS-API仕様のバージョン1には存在していなかったため、バージョン1の実装を実行するアプリケーションは、これらのコードを特別なケースにする必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "context_handle gss_ctx_id_t, read/modify context handle for new context. Supply GSS_C_NO_CONTEXT for first call; use value returned in subsequent calls. Once gss_accept_sec_context() has returned a value via this parameter, resources have been assigned to the corresponding context, and must be freed by the application after use with a call to gss_delete_sec_context().",
      "ja": "context_handle gss_ctx_id_t、新しいコンテキストのコンテキストハンドルを読み取り/変更します。最初の呼び出しにGSS_C_NO_CONTEXTを提供します。後続の呼び出しで返された値を使用します。GSS_ACCEPT_SEC_CONTEXT（）がこのパラメーターを介して値を返すと、リソースが対応するコンテキストに割り当てられ、GSS_DELETE_SEC_CONTEXT（）への呼び出しでアプリケーションによって解放される必要があります。"
    },
    {
      "indent": 3,
      "text": "acceptor_cred_handle gss_cred_id_t, read Credential handle claimed by context acceptor. Specify GSS_C_NO_CREDENTIAL to accept the context as a default principal. If GSS_C_NO_CREDENTIAL is specified, but no default acceptor principal is defined, GSS_S_NO_CRED will be returned.",
      "ja": "Acceptor_cred_handle GSS_CRED_ID_T、Context Acceptorが請求されたクレデンシャルハンドルを読み取ります。GSS_C_NO_CREDENTIALを指定して、デフォルトのプリンシパルとしてコンテキストを受け入れます。GSS_C_NO_CREDENTIALが指定されているが、デフォルトのアクセプタープリンシパルが定義されていない場合、GSS_S_NO_CREDが返されます。"
    },
    {
      "indent": 3,
      "text": "input_token_buffer buffer, opaque, read token obtained from remote application.",
      "ja": "input_token_bufferバッファ、不透明、リモートアプリケーションから取得したトークンを読み取ります。"
    },
    {
      "indent": 3,
      "text": "input_chan_bindings channel bindings, read, optional Application-specified bindings. Allows application to securely bind channel identification information to the security context. If channel bindings are not used, specify GSS_C_NO_CHANNEL_BINDINGS.",
      "ja": "input_chan_bindingsチャネルバインディング、読み取り、オプションのアプリケーション指定バインディング。アプリケーションは、セキュリティコンテキストにチャネル識別情報を安全にバインドできるようにします。チャネルバインディングが使用されていない場合は、GSS_C_NO_CHANNEL_BINDINGSを指定します。"
    },
    {
      "indent": 3,
      "text": "src_name gss_name_t, modify, optional Authenticated name of context initiator. After use, this name should be deallocated by passing it to gss_release_name(). If not required, specify NULL.",
      "ja": "src_name gss_name_t、modify、オプションの認証されたコンテキストイニシエーターの名前。使用後、この名前はGSS_RELEASE_NAME（）に渡すことにより、扱う必要があります。不要な場合は、nullを指定します。"
    },
    {
      "indent": 3,
      "text": "mech_type Object ID, modify, optional Security mechanism used. The returned OID value will be a pointer into static storage, and should be treated as read-only by the caller (in particular, it does not need to be freed). If not required, specify NULL.",
      "ja": "mech_typeオブジェクトID、変更、オプションのセキュリティメカニズムが使用されます。返されたOID値は、静的ストレージへのポインターであり、発信者が読み取り専用として扱う必要があります（特に、解放する必要はありません）。不要な場合は、nullを指定します。"
    },
    {
      "indent": 3,
      "text": "output_token buffer, opaque, modify Token to be passed to peer application. If the length field of the returned token buffer is 0, then no token need be passed to the peer application. If a non-zero length field is returned, the associated storage must be freed after use by the application with a call to gss_release_buffer().",
      "ja": "output_tokenバッファー、不透明、トークンを変更するように、ピアアプリケーションに渡されます。返されたトークンバッファーの長さフィールドが0の場合、トークンをピアアプリケーションに渡す必要はありません。ゼロ以外の長さフィールドが返される場合、gss_release_buffer（）への呼び出しで、アプリケーションで使用後に関連するストレージを解放する必要があります。"
    },
    {
      "indent": 3,
      "text": "ret_flags bit-mask, modify, optional Contains various independent flags, each of which indicates that the context supports a specific service option. If not needed, specify NULL. Symbolic names are provided for each flag, and the symbolic names corresponding to the required flags should be logically-ANDed with the ret_flags value to test whether a given option is supported by the context. The flags are: GSS_C_DELEG_FLAG True - Delegated credentials are available via the delegated_cred_handle parameter False - No credentials were delegated GSS_C_MUTUAL_FLAG True - Remote peer asked for mutual authentication False - Remote peer did not ask for mutual authentication GSS_C_REPLAY_FLAG True - replay of protected messages will be detected False - replayed messages will not be detected GSS_C_SEQUENCE_FLAG True - out-of-sequence protected messages will be detected False - out-of-sequence messages will not be detected GSS_C_CONF_FLAG True - Confidentiality service may be invoked by calling the gss_wrap routine False - No confidentiality service (via gss_wrap) available. gss_wrap will provide message encapsulation, data-origin authentication and integrity services only. GSS_C_INTEG_FLAG True - Integrity service may be invoked by calling either gss_get_mic or gss_wrap routines. False - Per-message integrity service unavailable. GSS_C_ANON_FLAG True - The initiator does not wish to be authenticated; the src_name parameter (if requested) contains an anonymous internal name. False - The initiator has been authenticated normally. GSS_C_PROT_READY_FLAG True - Protection services (as specified by the states of the GSS_C_CONF_FLAG and GSS_C_INTEG_FLAG) are available if the accompanying major status return value is either GSS_S_COMPLETE or GSS_S_CONTINUE_NEEDED. False - Protection services (as specified by the states of the GSS_C_CONF_FLAG and GSS_C_INTEG_FLAG) are available only if the accompanying major status return value is GSS_S_COMPLETE. GSS_C_TRANS_FLAG True - The resultant security context may be transferred to other processes via a call to gss_export_sec_context(). False - The security context is not transferable. All other bits should be set to zero.",
      "ja": "ret_flagsビットマスク、変更、オプションには、さまざまな独立したフラグが含まれています。それぞれが、コンテキストが特定のサービスオプションをサポートしていることを示します。必要ない場合は、nullを指定します。各フラグに対してシンボリック名が提供され、必要なフラグに対応するシンボリック名は、ret_flags値を論理的に配信する必要があります。フラグは次のとおりです。GSS_C_DELEG_FLAGTRUE -DELEGATED_CRED_HANDLEパラメーターfalseを介して委任された資格情報はfalse-委任された資格情報はありません。false-リプレイされたメッセージは検出されませんGSS_C_SEQUENCE_FLAG TRUE -OUP -OFSE -OF -SEAVEENCE PROTECTEDメッセージは誤って検出されます -  false -Out -sequenceメッセージは検出されませんGSS_C_CONF_FLAG True-秘密保持サービスは、GSS_WRAPルーチンを呼び出すことによって呼び出される場合があります - 秘密なしサービス（GSS_WRAP経由）利用可能。GSS_WRAPは、メッセージのカプセル化、データオリジン認証、および整合性サービスのみを提供します。GSS_C_INTEG_FLAG True -Integrity Serviceは、GSS_GET_MICまたはGSS_WRAPルーチンのいずれかを呼び出すことで呼び出される場合があります。false -Message Integrity Serviceは利用できません。gss_c_anon_flag true-イニシエーターは認証されることを望んでいません。SRC_NAMEパラメーター（要求された場合）には、匿名の内部名が含まれています。false-イニシエーターは正常に認証されています。GSS_C_PROT_READY_FLAG TRUA-保護サービス（GSS_C_CONF_FLAGおよびGSS_C_INTEG_FLAGの状態によって指定されているとおり）が利用可能です。false-保護サービス（GSS_C_CONF_FLAGおよびGSS_C_INTEG_FLAGの状態によって指定）は、付随する主要なステータスリターン値がGSS_S_COMPLETEである場合にのみ利用可能です。gss_c_trans_flag true-結果のセキュリティコンテキストは、gss_export_sec_context（）を呼び出すことにより、他のプロセスに転送される場合があります。false-セキュリティコンテキストは転送できません。他のすべてのビットはゼロに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "time_rec Integer, modify, optional number of seconds for which the context will remain valid. Specify NULL if not required.",
      "ja": "time_rec integer、変更、オプションの秒数のコンテキストが有効なままです。必要でない場合はnullを指定します。"
    },
    {
      "indent": 3,
      "text": "delegated_cred_handle gss_cred_id_t, modify, optional credential handle for credentials received from context initiator. Only valid if deleg_flag in ret_flags is true, in which case an explicit credential handle (i.e. not GSS_C_NO_CREDENTIAL) will be returned; if deleg_flag is false, gss_accept_context() will set this parameter to GSS_C_NO_CREDENTIAL. If a credential handle is returned, the associated resources must be released by the application after use with a call to gss_release_cred(). Specify NULL if not required.",
      "ja": "delegated_cred_handle gss_cred_id_t、修正、コンテキストイニシエーターから受信した資格情報のオプションの資格情報ハンドル。ret_flagsのdeleg_flagが真である場合にのみ有効です。この場合、明示的な資格的ハンドル（つまり、GSS_C_NO_CREDENTIALではありません）が返されます。DELEG_FLAGがfalseの場合、gss_accept_context（）はこのパラメーターをgss_c_no_credentialに設定します。資格情報が返された場合、GSS_RELEASE_CRED（）への呼び出しで使用後、関連するリソースをアプリケーションによってリリースする必要があります。必要でない場合はnullを指定します。"
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code.",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します。"
    },
    {
      "indent": 3,
      "text": "GSS_S_CONTINUE_NEEDED Indicates that a token from the peer application is required to complete the context, and that gss_accept_sec_context must be called again with that token.",
      "ja": "gss_s_continue_neededは、コンテキストを完了するためにピアアプリケーションからのトークンが必要であり、gss_accept_sec_contextをそのトークンで再度呼び出す必要があることを示します。"
    },
    {
      "indent": 3,
      "text": "GSS_S_DEFECTIVE_TOKEN Indicates that consistency checks performed on the input_token failed.",
      "ja": "gss_s_defective_tokenは、input_tokenで実行された一貫性チェックが失敗したことを示します。"
    },
    {
      "indent": 3,
      "text": "GSS_S_DEFECTIVE_CREDENTIAL Indicates that consistency checks performed on the credential failed.",
      "ja": "GSS_S_DEFECTIVE_CREDENTIALは、資格認定で実行された一貫性チェックが失敗したことを示します。"
    },
    {
      "indent": 3,
      "text": "GSS_S_NO_CRED The supplied credentials were not valid for context acceptance, or the credential handle did not reference any credentials.",
      "ja": "GSS_S_NO_CRED付属の資格情報は、コンテキストの受け入れに対して有効ではないか、資格情報が資格情報を参照しませんでした。"
    },
    {
      "indent": 3,
      "text": "GSS_S_CREDENTIALS_EXPIRED The referenced credentials have expired.",
      "ja": "GSS_S_CREDENTIALS_EXPIRED参照資格情報の有効期限が切れました。"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_BINDINGS The input_token contains different channel bindings to those specified via the input_chan_bindings parameter.",
      "ja": "gss_s_bad_bindings input_tokenには、input_chan_bindingsパラメーターを介して指定されたものに異なるチャネルバインディングが含まれています。"
    },
    {
      "indent": 3,
      "text": "GSS_S_NO_CONTEXT Indicates that the supplied context handle did not refer to a valid context.",
      "ja": "GSS_S_NO_CONTEXTは、付属のコンテキストハンドルが有効なコンテキストを参照していないことを示します。"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_SIG The input_token contains an invalid MIC.",
      "ja": "gss_s_bad_sig input_tokenには無効なマイクが含まれています。"
    },
    {
      "indent": 3,
      "text": "GSS_S_OLD_TOKEN The input_token was too old. This is a fatal error during context establishment.",
      "ja": "gss_s_old_token input_tokenは古すぎました。これは、コンテキスト確立中の致命的なエラーです。"
    },
    {
      "indent": 3,
      "text": "GSS_S_DUPLICATE_TOKEN The input_token is valid, but is a duplicate of a token already processed. This is a fatal error during context establishment.",
      "ja": "gss_s_duplicate_token input_tokenは有効ですが、すでに処理されているトークンの複製です。これは、コンテキスト確立中の致命的なエラーです。"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_MECH The received token specified a mechanism that is not supported by the implementation or the provided credential.",
      "ja": "GSS_S_BAD_MECH受信トークンは、実装または提供された資格によってサポートされていないメカニズムを指定しました。"
    },
    {
      "indent": 0,
      "text": "5.2. gss_acquire_cred",
      "section_title": true,
      "ja": "5.2. GSS_ACQUIRE_CRED"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_acquire_cred ( OM_uint32 *minor_status, const gss_name_t desired_name, OM_uint32 time_req, const gss_OID_set desired_mechs, gss_cred_usage_t cred_usage, gss_cred_id_t *output_cred_handle, gss_OID_set *actual_mechs, OM_uint32 *time_rec)",
      "ja": "OM_UINT32 GSS_ACQUIRE_CRED（OM_UINT32 *MINTER_STATUS、const GSS_NAME_T DESTERIED_NAME、OM_UINT32 TIME_REQ、const gss_oid_set desired_mechs、GSS_CRED_USAGE_T CRED_USAGE、GSS_CRED_ID_T * 32 *time_rec）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Allows an application to acquire a handle for a pre-existing credential by name. GSS-API implementations must impose a local access-control policy on callers of this routine to prevent unauthorized callers from acquiring credentials to which they are not entitled. This routine is not intended to provide a \"login to the network\" function, as such a function would involve the creation of new credentials rather than merely acquiring a handle to existing credentials. Such functions, if required, should be defined in implementation-specific extensions to the API.",
      "ja": "アプリケーションは、名前で既存の資格情報のハンドルを取得できます。GSS-APIの実装は、このルーチンの発信者にローカルアクセス制御ポリシーを課して、許可されていない発信者が資格のない資格情報を取得できないようにする必要があります。このルーチンは、「ネットワークへのログイン」関数を提供することを意図したものではありません。そのような関数には、既存の資格情報のハンドルを取得するだけでなく、新しい資格情報の作成が含まれるためです。このような関数は、必要に応じて、APIの実装固有の拡張機能で定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "If desired_name is GSS_C_NO_NAME, the call is interpreted as a request for a credential handle that will invoke default behavior when passed to gss_init_sec_context() (if cred_usage is GSS_C_INITIATE or GSS_C_BOTH) or gss_accept_sec_context() (if cred_usage is GSS_C_ACCEPT or GSS_C_BOTH).",
      "ja": "If desired_name is GSS_C_NO_NAME, the call is interpreted as a request for a credential handle that will invoke default behavior when passed to gss_init_sec_context() (if cred_usage is GSS_C_INITIATE or GSS_C_BOTH) or gss_accept_sec_context() (if cred_usage is GSS_C_ACCEPT or GSS_C_BOTH)."
    },
    {
      "indent": 3,
      "text": "Mechanisms should honor the desired_mechs parameter, and return a credential that is suitable to use only with the requested mechanisms. An exception to this is the case where one underlying credential element can be shared by multiple mechanisms; in this case it is permissible for an implementation to indicate all mechanisms with which the credential element may be used. If desired_mechs is an empty set, behavior is undefined.",
      "ja": "メカニズムは、希望の_mechsパラメーターを尊重し、要求されたメカニズムでのみ使用するのに適した資格情報を返す必要があります。これの例外は、1つの基礎となる資格要素を複数のメカニズムによって共有できる場合です。この場合、実装は、資格情報要素を使用できるすべてのメカニズムを示すことが許されます。希望する_mechsが空のセットである場合、動作は未定義です。"
    },
    {
      "indent": 3,
      "text": "This routine is expected to be used primarily by context acceptors, since implementations are likely to provide mechanism-specific ways of obtaining GSS-API initiator credentials from the system login process. Some implementations may therefore not support the acquisition of GSS_C_INITIATE or GSS_C_BOTH credentials via gss_acquire_cred for any name other than GSS_C_NO_NAME, or a name produced by applying either gss_inquire_cred to a valid credential, or gss_inquire_context to an active context.",
      "ja": "このルーチンは、システムログインプロセスからGSS-APIイニシエーター資格情報を取得するメカニズム固有の方法を提供する可能性が高いため、主にコンテキストアクセプターによって使用されることが期待されています。したがって、一部の実装は、GSS_C_NO_NAME以外の名前のGSS_ACQUIRE_CREDを介してGSS_C_INITIATEまたはGSS_C_BOTH資格情報の取得をサポートしていない場合があります。"
    },
    {
      "indent": 3,
      "text": "If credential acquisition is time-consuming for a mechanism, the mechanism may choose to delay the actual acquisition until the credential is required (e.g. by gss_init_sec_context or gss_accept_sec_context). Such mechanism-specific implementation decisions should be invisible to the calling application; thus a call of gss_inquire_cred immediately following the call of gss_acquire_cred must return valid credential data, and may therefore incur the overhead of a deferred credential acquisition.",
      "ja": "資格取得がメカニズムに時間がかかる場合、メカニズムは、資格情報が必要になるまで実際の取得を遅らせることを選択する場合があります（例：GSS_INIT_SEC_CONTEXTまたはGSS_ACCEPT_SEC_CONTEXT）。このようなメカニズム固有の実装決定は、呼び出しアプリケーションには見えない必要があります。したがって、GSS_ACQUIRE_CREDの呼び出しの直後にgss_inquire_credの呼び出しは、有効な資格情報データを返す必要があるため、繰延資格情報の取得のオーバーヘッドが発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "desired_name gss_name_t, read Name of principal whose credential should be acquired",
      "ja": "sepired_name gss_name_t、資格情報を取得すべきプリンシパルの名前を読む"
    },
    {
      "indent": 3,
      "text": "time_req Integer, read, optional number of seconds that credentials should remain valid. Specify GSS_C_INDEFINITE to request that the credentials have the maximum permitted lifetime.",
      "ja": "Time_req integer、読み取り、資格情報が有効なままである必要がある秒数。GSS_C_INDEFINITEを指定して、資格情報に最大許可された寿命があることを要求します。"
    },
    {
      "indent": 3,
      "text": "desired_mechs Set of Object IDs, read, optional set of underlying security mechanisms that may be used. GSS_C_NO_OID_SET may be used to obtain an implementation-specific default.",
      "ja": "使用される可能性のある根本的なセキュリティメカニズムのオブジェクトIDのセット、読み取り、オプションのセットのセット。GSS_C_NO_OID_SETを使用して、実装固有のデフォルトを取得できます。"
    },
    {
      "indent": 3,
      "text": "cred_usage gss_cred_usage_t, read GSS_C_BOTH - Credentials may be used either to initiate or accept security contexts. GSS_C_INITIATE - Credentials will only be used to initiate security contexts. GSS_C_ACCEPT - Credentials will only be used to accept security contexts.",
      "ja": "CRED_USAGE GSS_CRED_USAGE_T、読み取りGSS_C_BOTH-資格情報を使用して、セキュリティコンテキストを開始または受け入れることができます。GSS_C_INITIATE-資格情報は、セキュリティコンテキストの開始にのみ使用されます。GSS_C_ACCEPT-資格情報は、セキュリティコンテキストを受け入れるためにのみ使用されます。"
    },
    {
      "indent": 3,
      "text": "output_cred_handle gss_cred_id_t, modify The returned credential handle. Resources associated with this credential handle must be released by the application after use with a call to gss_release_cred().",
      "ja": "output_cred_handle gss_cred_id_t、返された資格情報を変更します。この資格情報に関連付けられたリソースは、GSS_RELEASE_CRED（）を呼び出して使用した後、アプリケーションによってリリースされる必要があります。"
    },
    {
      "indent": 3,
      "text": "actual_mechs Set of Object IDs, modify, optional The set of mechanisms for which the credential is valid. Storage associated with the returned OID-set must be released by the application after use with a call to gss_release_oid_set(). Specify NULL if not required.",
      "ja": "実際の_mechsオブジェクトIDのセット、変更、オプションのクレデンシャルが有効なメカニズムのセット。返されたOID-SETに関連付けられたストレージは、GSS_RELEASE_OID_SET（）への呼び出しで使用後にアプリケーションによってリリースされる必要があります。必要でない場合はnullを指定します。"
    },
    {
      "indent": 3,
      "text": "time_rec Integer, modify, optional Actual number of seconds for which the returned credentials will remain valid. If the implementation does not support expiration of credentials, the value GSS_C_INDEFINITE will be returned. Specify NULL if not required",
      "ja": "time_rec integer、変更、返された資格情報が有効なままであるオプションの実際の秒数。実装が資格情報の有効期限をサポートしていない場合、値GSS_C_INDEFINITEが返されます。必要でない場合はnullを指定します"
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code.",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_MECH Unavailable mechanism requested",
      "ja": "GSS_S_BAD_MECH利用可能なメカニズムが要求されました"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_NAMETYPE Type contained within desired_name parameter is not supported",
      "ja": "希望_nameパラメーターに含まれるGSS_S_BAD_NAMETYPEタイプはサポートされていません"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_NAME Value supplied for desired_name parameter is ill formed.",
      "ja": "希望のパラメーターに供給されるGSS_S_BAD_NAME値は不正に形成されています。"
    },
    {
      "indent": 3,
      "text": "GSS_S_CREDENTIALS_EXPIRED The credentials could not be acquired Because they have expired.",
      "ja": "GSS_S_CREDENTIALS_EXPIREDは、有効期限が切れているため、取得できませんでした。"
    },
    {
      "indent": 3,
      "text": "GSS_S_NO_CRED No credentials were found for the specified name.",
      "ja": "GSS_S_NO_CRED指定された名前の資格情報は見つかりませんでした。"
    },
    {
      "indent": 0,
      "text": "5.3. gss_add_cred",
      "section_title": true,
      "ja": "5.3. GSS_ADD_CRED"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_add_cred (\n  OM_uint32           *minor_status,\n  const gss_cred_id_t input_cred_handle,\n  const gss_name_t    desired_name,\n  const gss_OID       desired_mech,\n  gss_cred_usage_t    cred_usage,\n  OM_uint32           initiator_time_req,\n  OM_uint32           acceptor_time_req,\n  gss_cred_id_t       *output_cred_handle,\n  gss_OID_set         *actual_mechs,\n  OM_uint32           *initiator_time_rec,\n  OM_uint32           *acceptor_time_rec)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Adds a credential-element to a credential. The credential-element is identified by the name of the principal to which it refers. GSS-API implementations must impose a local access-control policy on callers of this routine to prevent unauthorized callers from acquiring credential-elements to which they are not entitled. This routine is not intended to provide a \"login to the network\" function, as such a function would involve the creation of new mechanism-specific authentication data, rather than merely acquiring a GSS-API handle to existing data. Such functions, if required, should be defined in implementation-specific extensions to the API.",
      "ja": "資格情報を資格情報に追加します。資格認定は、それが言及するプリンシパルの名前によって識別されます。GSS-APIの実装は、このルーチンの発信者にローカルアクセス制御ポリシーを課して、許可されていない発信者が資格のない資格情報を取得できないようにする必要があります。このルーチンは、既存のデータにGSS-APIハンドルを取得するのではなく、そのような関数には新しいメカニズム固有の認証データの作成が含まれるため、「ネットワークへのログイン」機能を提供することを意図したものではありません。このような関数は、必要に応じて、APIの実装固有の拡張機能で定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "If desired_name is GSS_C_NO_NAME, the call is interpreted as a request to add a credential element that will invoke default behavior when passed to gss_init_sec_context() (if cred_usage is GSS_C_INITIATE or GSS_C_BOTH) or gss_accept_sec_context() (if cred_usage is GSS_C_ACCEPT or GSS_C_BOTH).",
      "ja": "希望_nameがgss_c_no_nameの場合、呼び出しは、gss_init_sec_context（）に渡されたときにデフォルトの動作を呼び出す資格情報要素を追加するリクエストとして解釈されます（cred_c_usageがgss_c_initiateまたはgss_c_both）またはgsscectecticcectecticcecticcecteccecteccectectectectectectectectecteccectectectectectectectectectectectectectectectectectectectectectectectectectect_ced_c 。"
    },
    {
      "indent": 3,
      "text": "This routine is expected to be used primarily by context acceptors, since implementations are likely to provide mechanism-specific ways of obtaining GSS-API initiator credentials from the system login process. Some implementations may therefore not support the acquisition of GSS_C_INITIATE or GSS_C_BOTH credentials via gss_acquire_cred for any name other than GSS_C_NO_NAME, or a name produced by applying either gss_inquire_cred to a valid credential, or gss_inquire_context to an active context.",
      "ja": "このルーチンは、システムログインプロセスからGSS-APIイニシエーター資格情報を取得するメカニズム固有の方法を提供する可能性が高いため、主にコンテキストアクセプターによって使用されることが期待されています。したがって、一部の実装は、GSS_C_NO_NAME以外の名前のGSS_ACQUIRE_CREDを介してGSS_C_INITIATEまたはGSS_C_BOTH資格情報の取得をサポートしていない場合があります。"
    },
    {
      "indent": 3,
      "text": "If credential acquisition is time-consuming for a mechanism, the mechanism may choose to delay the actual acquisition until the credential is required (e.g. by gss_init_sec_context or gss_accept_sec_context). Such mechanism-specific implementation decisions should be invisible to the calling application; thus a call of gss_inquire_cred immediately following the call of gss_add_cred must return valid credential data, and may therefore incur the overhead of a deferred credential acquisition.",
      "ja": "資格取得がメカニズムに時間がかかる場合、メカニズムは、資格情報が必要になるまで実際の取得を遅らせることを選択する場合があります（例：GSS_INIT_SEC_CONTEXTまたはGSS_ACCEPT_SEC_CONTEXT）。このようなメカニズム固有の実装決定は、呼び出しアプリケーションには見えない必要があります。したがって、gss_add_credの呼び出し直後にgss_inquire_credの呼び出しは、有効な資格情報データを返す必要があるため、繰延資格情報の取得のオーバーヘッドが発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "This routine can be used to either compose a new credential containing all credential-elements of the original in addition to the newly-acquire credential-element, or to add the new credential-element to an existing credential. If NULL is specified for the output_cred_handle parameter argument, the new credential-element will be added to the credential identified by input_cred_handle; if a valid pointer is specified for the output_cred_handle parameter, a new credential handle will be created.",
      "ja": "このルーチンを使用して、新たに取得する資格認定に加えて、オリジナルのすべての資格認定を含む新しい資格情報を作成するか、既存の資格情報に新しい資格認定を追加することができます。nullがoutput_cred_handleパラメーター引数に指定されている場合、新しい資格情報エレメントがinput_cred_handleによって識別された資格情報に追加されます。output_cred_handleパラメーターに有効なポインターが指定されている場合、新しい資格情報ハンドルが作成されます。"
    },
    {
      "indent": 3,
      "text": "If GSS_C_NO_CREDENTIAL is specified as the input_cred_handle, gss_add_cred will compose a credential (and set the output_cred_handle parameter accordingly) based on default behavior. That is, the call will have the same effect as if the application had first made a call to gss_acquire_cred(), specifying the same usage and passing GSS_C_NO_NAME as the desired_name parameter to obtain an explicit credential handle embodying default behavior, passed this credential handle to gss_add_cred(), and finally called gss_release_cred() on the first credential handle.",
      "ja": "GSS_C_NO_CREDENTIALがinput_CRED_HANDLEとして指定されている場合、GSS_ADD_CREDはデフォルトの動作に基づいて資格情報を作成します（およびそれに応じてoutput_cred_handleパラメーターを設定します）。つまり、コールは、アプリケーションが最初にGSS_ACQUIRE_CRED（）に呼び出しを行った場合と同じ効果を持ち、同じ使用法を指定し、GSS_C_NO_NAMEを希望_NAMEパラメーターとして渡して、デフォルトの動作をエンディングする明示的な資格的ハンドルを取得し、この資格認定ハンドルを渡しました。GSS_ADD_CRED（）、そして最終的に最初の資格情報ハンドルでGSS_RELEASE_CRED（）と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "If GSS_C_NO_CREDENTIAL is specified as the input_cred_handle parameter, a non-NULL output_cred_handle must be supplied.",
      "ja": "GSS_C_NO_CREDENTIALがinput_CRED_HANDLEパラメーターとして指定されている場合、NON-NULL OUTPUT_CRED_HANDLEを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code.",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します。"
    },
    {
      "indent": 3,
      "text": "input_cred_handle gss_cred_id_t, read, optional The credential to which a credential-element will be added. If GSS_C_NO_CREDENTIAL is specified, the routine will compose the new credential based on default behavior (see description above). Note that, while the credential-handle is not modified by gss_add_cred(), the underlying credential will be modified if output_credential_handle is NULL.",
      "ja": "input_cred_handle gss_cred_id_t、読み取り、オプションの資格情報が追加される資格情報。GSS_C_NO_CREDENTIALが指定されている場合、ルーチンはデフォルトの動作に基づいて新しい資格情報を作成します（上記の説明を参照）。資格情報はgss_add_cred（）によって変更されていませんが、output_credential_handleがnullの場合、基礎となる資格情報は変更されます。"
    },
    {
      "indent": 3,
      "text": "desired_name gss_name_t, read. Name of principal whose credential should be acquired.",
      "ja": "desireled_name gss_name_t、read。資格情報を取得すべき校長の名前。"
    },
    {
      "indent": 3,
      "text": "desired_mech Object ID, read Underlying security mechanism with which the credential may be used.",
      "ja": "希望_mechオブジェクトIDは、資格情報を使用できる基礎となるセキュリティメカニズムを読み取ります。"
    },
    {
      "indent": 3,
      "text": "cred_usage gss_cred_usage_t, read GSS_C_BOTH - Credential may be used either to initiate or accept security contexts. GSS_C_INITIATE - Credential will only be used to initiate security contexts. GSS_C_ACCEPT - Credential will only be used to accept security contexts.",
      "ja": "CRED_USAGE GSS_CRED_USAGE_T、読み取りGSS_C_BOTH-資格情報を使用して、セキュリティコンテキストを開始または受け入れることができます。GSS_C_INITIATE-資格情報は、セキュリティコンテキストの開始にのみ使用されます。GSS_C_ACCEPT-資格情報は、セキュリティコンテキストを受け入れるためにのみ使用されます。"
    },
    {
      "indent": 3,
      "text": "initiator_time_req Integer, read, optional number of seconds that the credential should remain valid for initiating security contexts. This argument is ignored if the composed credentials are of type GSS_C_ACCEPT. Specify GSS_C_INDEFINITE to request that the credentials have the maximum permitted initiator lifetime.",
      "ja": "Initiatator_time_req integer、読み取り、セキュリティコンテキストの開始には資格情報が有効なままである秒数。構成された資格情報がタイプGSS_C_ACCEPTである場合、この引数は無視されます。GSS_C_INDEFINITEを指定して、資格情報に最大許可イニシエーターの寿命があることを要求します。"
    },
    {
      "indent": 3,
      "text": "acceptor_time_req Integer, read, optional number of seconds that the credential should remain valid for accepting security contexts. This argument is ignored if the composed credentials are of type GSS_C_INITIATE.",
      "ja": "Acceptor_time_req integer、読み取り、セキュリティコンテキストを受け入れるために資格情報が有効である必要があるオプション数秒数。構成された資格情報がタイプGSS_C_INITIATEである場合、この引数は無視されます。"
    },
    {
      "indent": 21,
      "text": "Specify GSS_C_INDEFINITE to request that the credentials have the maximum permitted initiator lifetime.",
      "ja": "GSS_C_INDEFINITEを指定して、資格情報に最大許可イニシエーターの寿命があることを要求します。"
    },
    {
      "indent": 3,
      "text": "output_cred_handle gss_cred_id_t, modify, optional The returned credential handle, containing the new credential-element and all the credential-elements from input_cred_handle. If a valid pointer to a gss_cred_id_t is supplied for this parameter, gss_add_cred creates a new credential handle containing all credential-elements from the input_cred_handle and the newly acquired credential-element; if NULL is specified for this parameter, the newly acquired credential-element will be added to the credential identified by input_cred_handle.",
      "ja": "output_cred_handle gss_cred_id_t、modify、optional returned elementとinput_cred_handleからのすべての資格認定を含む返された資格情報ハンドルをオプション。このパラメーターにGSS_CRED_ID_Tへの有効なポインターが提供されている場合、GSS_ADD_CREDは、入力_CRED_HANDLEおよび新しく獲得した資格認定からすべての資格情報を含む新しい資格情報を作成します。このパラメーターにnullが指定されている場合、新しく取得された資格認定がinput_cred_handleによって識別された資格情報に追加されます。"
    },
    {
      "indent": 22,
      "text": "The resources associated with any credential handle returned via this parameter must be released by the application after use with a call to gss_release_cred().",
      "ja": "このパラメーターを介して返される資格情報ハンドルに関連付けられたリソースは、gss_release_cred（）への呼び出しで使用後にアプリケーションによってリリースされる必要があります。"
    },
    {
      "indent": 3,
      "text": "actual_mechs Set of Object IDs, modify, optional The complete set of mechanisms for which the new credential is valid. Storage for the returned OID-set must be freed by the application after use with a call to gss_release_oid_set(). Specify NULL if not required.",
      "ja": "altual_mechsオブジェクトIDのセット、変更、オプション新しい資格情報が有効なメカニズムの完全なセット。返されたOID-SETのストレージは、GSS_RELEASE_OID_SET（）を呼び出して使用した後、アプリケーションによって解放する必要があります。必要でない場合はnullを指定します。"
    },
    {
      "indent": 3,
      "text": "initiator_time_rec Integer, modify, optional Actual number of seconds for which the returned credentials will remain valid for initiating contexts using the specified mechanism. If the implementation or mechanism does not support expiration of credentials, the value GSS_C_INDEFINITE will be returned. Specify NULL if not required",
      "ja": "Initiator_time_rec integer、変更、オプションの実際の実際の秒数は、指定されたメカニズムを使用してコンテキストを開始するために有効なままです。実装またはメカニズムが資格情報の有効期限をサポートしていない場合、値GSS_C_INDEFINITEが返されます。必要でない場合はnullを指定します"
    },
    {
      "indent": 3,
      "text": "acceptor_time_rec Integer, modify, optional Actual number of seconds for which the returned credentials will remain valid for accepting security contexts using the specified mechanism. If the implementation or mechanism does not support expiration of credentials, the value GSS_C_INDEFINITE will be returned. Specify NULL if not required",
      "ja": "Acceptor_time_rec integer、変更、オプションの実際の秒数は、指定されたメカニズムを使用してセキュリティコンテキストを受け入れるために返された資格情報が有効なままです。実装またはメカニズムが資格情報の有効期限をサポートしていない場合、値GSS_C_INDEFINITEが返されます。必要でない場合はnullを指定します"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_MECH Unavailable mechanism requested",
      "ja": "GSS_S_BAD_MECH利用可能なメカニズムが要求されました"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_NAMETYPE Type contained within desired_name parameter is not supported",
      "ja": "希望_nameパラメーターに含まれるGSS_S_BAD_NAMETYPEタイプはサポートされていません"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_NAME Value supplied for desired_name parameter is ill-formed.",
      "ja": "希望の_nameパラメーターに供給されるGSS_S_BAD_NAME値は不正です。"
    },
    {
      "indent": 3,
      "text": "GSS_S_DUPLICATE_ELEMENT The credential already contains an element for the requested mechanism with overlapping usage and validity period.",
      "ja": "GSS_S_DUPLICATION_ELEMENT資格情報には、使用された使用と有効期間が重複する要求されたメカニズムの要素が既に含まれています。"
    },
    {
      "indent": 3,
      "text": "GSS_S_CREDENTIALS_EXPIRED The required credentials could not be added because they have expired.",
      "ja": "GSS_S_CREDENTIALS_EXPIRED必要な資格情報は、有効期限が切れているため追加できませんでした。"
    },
    {
      "indent": 3,
      "text": "GSS_S_NO_CRED No credentials were found for the specified name.",
      "ja": "GSS_S_NO_CRED指定された名前の資格情報は見つかりませんでした。"
    },
    {
      "indent": 0,
      "text": "5.4. gss_add_oid_set_member",
      "section_title": true,
      "ja": "5.4. gss_add_oid_set_member"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_add_oid_set_member ( OM_uint32 *minor_status, const gss_OID member_oid, gss_OID_set *oid_set)",
      "ja": "OM_UINT32 GSS_ADD_OID_SET_MEMBER（OM_UINT32 *minor_status、const gss_oid member_oid、gss_oid_set *oid_set）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Add an Object Identifier to an Object Identifier set. This routine is intended for use in conjunction with gss_create_empty_oid_set when constructing a set of mechanism OIDs for input to gss_acquire_cred. The oid_set parameter must refer to an OID-set that was created by GSS-API (e.g. a set returned by gss_create_empty_oid_set()). GSS-API creates a copy of the member_oid and inserts this copy into the set, expanding the storage allocated to the OID-set's elements array if necessary. The routine may add the new member OID anywhere within the elements array, and implementations should verify that the new member_oid is not already contained within the elements array; if the member_oid is already present, the oid_set should remain unchanged.",
      "ja": "オブジェクト識別子セットにオブジェクト識別子を追加します。このルーチンは、GSS_ACQUIRE_CREDに入力するために一連のメカニズムOIDを構築するときに、GSS_CREATE_EMPTY_OID_SETと組み合わせて使用することを目的としています。OID_SETパラメーターは、GSS-APIによって作成されたOID-SET（たとえば、GSS_CREATE_EMPTY_OID_SET（）によって返されたセットを参照する必要があります。GSS-APIは、member_oidのコピーを作成し、このコピーをセットに挿入し、必要に応じてOID-Setの要素アレイに割り当てられたストレージを拡張します。ルーチンは、新しいメンバーOIDを要素配列内のどこにでも追加する場合があり、実装では、新しいMember_oidが要素配列内にまだ含まれていないことを確認する必要があります。Member_oidがすでに存在している場合、oid_setは変更されていないままでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "minor_status Integer, modify Mechanism specific status code",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します"
    },
    {
      "indent": 6,
      "text": "member_oid Object ID, read The object identifier to copied into the set.",
      "ja": "member_oidオブジェクトID、オブジェクト識別子を読み取り、セットにコピーします。"
    },
    {
      "indent": 6,
      "text": "oid_set Set of Object ID, modify The set in which the object identifier should be inserted.",
      "ja": "oid_setオブジェクトIDのセット、オブジェクト識別子を挿入するセットを変更します。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 6,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 0,
      "text": "5.5. gss_canonicalize_name",
      "section_title": true,
      "ja": "5.5. gss_canonicalize_name"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_canonicalize_name ( OM_uint32 *minor_status, const gss_name_t input_name, const gss_OID mech_type, gss_name_t *output_name)",
      "ja": "OM_UINT32 GSS_CANONICALIZE_NAME（OM_UINT32 *minor_status、const gss_name_t input_name、const gss_oid mech_type、gss_name_t *output_name）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Generate a canonical mechanism name (MN) from an arbitrary internal name. The mechanism name is the name that would be returned to a context acceptor on successful authentication of a context where the initiator used the input_name in a successful call to gss_acquire_cred, specifying an OID set containing <mech_type> as its only member, followed by a call to gss_init_sec_context, specifying <mech_type> as the authentication mechanism.",
      "ja": "任意の内部名から標準メカニズム名（MN）を生成します。メカニズム名は、gss_acquire_credへの成功したコールでinitiatorがinput_nameを使用したコンテキストの成功した認証でコンテキストアクセプターに返される名前です。GSS_INIT_SEC_CONTEXTに、<mech_type>を認証メカニズムとして指定します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します"
    },
    {
      "indent": 3,
      "text": "input_name gss_name_t, read The name for which a canonical form is desired",
      "ja": "input_name gss_name_t、標準形式が望まれる名前を読む"
    },
    {
      "indent": 3,
      "text": "mech_type Object ID, read The authentication mechanism for which the canonical form of the name is desired. The desired mechanism must be specified explicitly; no default is provided.",
      "ja": "mech_typeオブジェクトIDは、名前の標準形式が必要な認証メカニズムを読み取ります。目的のメカニズムを明示的に指定する必要があります。デフォルトは提供されていません。"
    },
    {
      "indent": 3,
      "text": "output_name gss_name_t, modify The resultant canonical name. Storage associated with this name must be freed by the application after use with a call to gss_release_name().",
      "ja": "output_name gss_name_t、結果の標準名を変更します。この名前に関連付けられたストレージは、GSS_RELEASE_NAME（）を呼び出して使用した後、アプリケーションによって解放する必要があります。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion.",
      "ja": "gss_s_complete正常に完了しました。"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_MECH The identified mechanism is not supported.",
      "ja": "GSS_S_BAD_MECH識別されたメカニズムはサポートされていません。"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_NAMETYPE The provided internal name contains no elements that could be processed by the specified mechanism.",
      "ja": "GSS_S_BAD_NAMETYPE提供された内部名には、指定されたメカニズムによって処理できる要素は含まれていません。"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_NAME The provided internal name was ill-formed.",
      "ja": "GSS_S_BAD_NAME提供された内部名は不調でした。"
    },
    {
      "indent": 0,
      "text": "5.6. gss_compare_name",
      "section_title": true,
      "ja": "5.6. gss_compare_name"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_compare_name ( OM_uint32 *minor_status, const gss_name_t name1, const gss_name_t name2, int *name_equal)",
      "ja": "om_uint32 gss_compare_name（om_uint32 *minor_status、const gss_name_t name1、const gss_name_t name2、int *name_equal）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Allows an application to compare two internal-form names to determine whether they refer to the same entity.",
      "ja": "アプリケーションが2つの内部形式名を比較して、同じエンティティを参照するかどうかを判断できます。"
    },
    {
      "indent": 3,
      "text": "If either name presented to gss_compare_name denotes an anonymous principal, the routines should indicate that the two names do not refer to the same identity.",
      "ja": "gss_compare_nameに提示されたいずれかの名前が匿名のプリンシパルを示している場合、ルーチンは2つの名前が同じIDを参照していないことを示す必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code.",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します。"
    },
    {
      "indent": 3,
      "text": "name1 gss_name_t, read internal-form name",
      "ja": "name1 gss_name_t、内部形式名を読んでください"
    },
    {
      "indent": 3,
      "text": "name2 gss_name_t, read internal-form name",
      "ja": "name2 gss_name_t、内部形式名を読んでください"
    },
    {
      "indent": 3,
      "text": "name_equal boolean, modify non-zero - names refer to same entity zero - names refer to different entities (strictly, the names are not known to refer to the same identity).",
      "ja": "name_equal boolean、非ゼロの変更 - 名前は同じエンティティゼロを参照します - 名前は異なるエンティティを指します（厳密には、名前は同じアイデンティティを参照することは知られていません）。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_NAMETYPE The two names were of incomparable types.",
      "ja": "GSS_S_BAD_NAMETYPE 2つの名前は比類のないタイプでした。"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_NAME One or both of name1 or name2 was ill-formed.",
      "ja": "gss_s_bad_name name1またはname2の1つまたは両方が不正に形成されました。"
    },
    {
      "indent": 0,
      "text": "5.7. gss_context_time",
      "section_title": true,
      "ja": "5.7. gss_context_time"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_context_time ( OM_uint32 *minor_status, const gss_ctx_id_t context_handle, OM_uint32 *time_rec)",
      "ja": "OM_UINT32 GSS_CONTEXT_TIME（OM_UINT32 *minor_status、const gss_ctx_id_t context_handle、om_uint32 *time_rec）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Determines the number of seconds for which the specified context will remain valid.",
      "ja": "指定されたコンテキストが有効なままである秒数を決定します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Implementation specific status code.",
      "ja": "minor_status integer、実装固有のステータスコードを変更します。"
    },
    {
      "indent": 3,
      "text": "context_handle gss_ctx_id_t, read Identifies the context to be interrogated.",
      "ja": "context_handle gss_ctx_id_t、読み取り尋問するコンテキストを識別します。"
    },
    {
      "indent": 3,
      "text": "time_rec Integer, modify Number of seconds that the context will remain valid. If the context has already expired, zero will be returned.",
      "ja": "time_rec integer、コンテキストが有効なままである秒数を変更します。コンテキストが既に有効期限が切れている場合、ゼロは返されます。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_CONTEXT_EXPIRED The context has already expired",
      "ja": "GSS_S_CONTEXT_EXPIREDコンテキストはすでに期限切れになっています"
    },
    {
      "indent": 3,
      "text": "GSS_S_NO_CONTEXT The context_handle parameter did not identify a valid context",
      "ja": "gss_s_no_context context_handleパラメーターは有効なコンテキストを識別しませんでした"
    },
    {
      "indent": 0,
      "text": "5.8. gss_create_empty_oid_set",
      "section_title": true,
      "ja": "5.8. gss_create_empty_oid_set"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_create_empty_oid_set ( OM_uint32 *minor_status, gss_OID_set *oid_set)",
      "ja": "om_uint32 gss_create_empty_oid_set（om_uint32 *minor_status、gss_oid_set *oid_set）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Create an object-identifier set containing no object identifiers, to which members may be subsequently added using the gss_add_oid_set_member() routine. These routines are intended to be used to construct sets of mechanism object identifiers, for input to gss_acquire_cred.",
      "ja": "Object-Identifierセットを作成して、オブジェクト識別子を含みません。その後、メンバーはGSS_ADD_OID_SET_MEMBER（）ルーチンを使用して追加できます。これらのルーチンは、GSS_ACQUIRE_CREDへの入力のために、メカニズムオブジェクト識別子のセットを構築するために使用することを目的としています。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します"
    },
    {
      "indent": 3,
      "text": "oid_set Set of Object IDs, modify The empty object identifier set. The routine will allocate the gss_OID_set_desc object, which the application must free after use with a call to gss_release_oid_set().",
      "ja": "OID_SETオブジェクトIDのセット、空のオブジェクト識別子セットを変更します。ルーチンはGSS_OID_SET_DESCオブジェクトを割り当てます。これは、GSS_RELEASE_OID_SET（）に電話をかけて使用した後にアプリケーションを解放する必要があります。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 0,
      "text": "5.9. gss_delete_sec_context",
      "section_title": true,
      "ja": "5.9. gss_delete_sec_context"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_delete_sec_context ( OM_uint32 *minor_status, gss_ctx_id_t *context_handle, gss_buffer_t output_token)",
      "ja": "OM_UINT32 GSS_DELETE_SEC_CONTEXT（OM_UINT32 *MINTER_STATUS、GSS_CTX_ID_T *Context_Handle、GSS_BUFFER_T OUTPUT_TOKEN）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Delete a security context. gss_delete_sec_context will delete the local data structures associated with the specified security context, and may generate an output_token, which when passed to the peer gss_process_context_token will instruct it to do likewise. If no token is required by the mechanism, the GSS-API should set the length field of the output_token (if provided) to zero. No further security services may be obtained using the context specified by context_handle.",
      "ja": "セキュリティコンテキストを削除します。GSS_DELETE_SEC_CONTEXTは、指定されたセキュリティコンテキストに関連付けられたローカルデータ構造を削除し、output_Tokenを生成する場合があります。メカニズムによってトークンが必要ない場合、GSS-APIはoutput_token（提供されている場合）の長さフィールドをゼロに設定する必要があります。Context_handleで指定されたコンテキストを使用して、さらなるセキュリティサービスを取得することはできません。"
    },
    {
      "indent": 3,
      "text": "In addition to deleting established security contexts, gss_delete_sec_context must also be able to delete \"half-built\" security contexts resulting from an incomplete sequence of gss_init_sec_context()/gss_accept_sec_context() calls.",
      "ja": "確立されたセキュリティコンテキストの削除に加えて、GSS_DELETE_SEC_CONTEXTは、GSS_INIT_SEC_CONTEXT（）/GSS_ACCEPT_SEC_CONTEXT（）コールの不完全なシーケンスから生じる「ハーフビルド」セキュリティコンテキストを削除できる必要があります。"
    },
    {
      "indent": 3,
      "text": "The output_token parameter is retained for compatibility with version 1 of the GSS-API. It is recommended that both peer applications invoke gss_delete_sec_context passing the value GSS_C_NO_BUFFER for the output_token parameter, indicating that no token is required, and that gss_delete_sec_context should simply delete local context data structures. If the application does pass a valid buffer to gss_delete_sec_context, mechanisms are encouraged to return a zero-length token, indicating that no peer action is necessary, and that no token should be transferred by the application.",
      "ja": "output_tokenパラメーターは、GSS-APIのバージョン1との互換性のために保持されます。両方のピアアプリケーションがGSS_DELETE_SEC_CONTEXTを呼び出すことをお勧めします。GSS_DELETE_CONTEXTOUTPUT_TOKENパラメーターの値GSS_C_NO_BUFFERは、トークンが不要であり、GSS_DELETE_SEC_CONTEXTは単にローカルコンテキストデータ構造を削除する必要があります。アプリケーションが有効なバッファーをGSS_DELETE_SEC_CONTEXTに渡す場合、メカニズムはゼロの長さのトークンを返すように奨励されており、ピアアクションは不要であり、アプリケーションによってトークンを転送しないことを示します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code.",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します。"
    },
    {
      "indent": 3,
      "text": "context_handle gss_ctx_id_t, modify context handle identifying context to delete. After deleting the context, the GSS-API will set this context handle to GSS_C_NO_CONTEXT.",
      "ja": "context_handle gss_ctx_id_t、削除するコンテキストの識別コンテキストを処理するコンテキストを変更します。コンテキストを削除した後、GSS-APIはこのコンテキストハンドルをGSS_C_NO_CONTEXTに設定します。"
    },
    {
      "indent": 3,
      "text": "output_token buffer, opaque, modify, optional token to be sent to remote application to instruct it to also delete the context. It is recommended that applications specify GSS_C_NO_BUFFER for this parameter, requesting local deletion only. If a buffer parameter is provided by the application, the mechanism may return a token in it; mechanisms that implement only local deletion should set the length field of this token to zero to indicate to the application that no token is to be sent to the peer.",
      "ja": "output_tokenバッファ、不透明、変更、オプションのトークンをリモートアプリケーションに送信して、コンテキストも削除するように指示します。アプリケーションは、このパラメーターにGSS_C_NO_BUFFERを指定し、ローカル削除のみを要求することをお勧めします。バッファパラメーターがアプリケーションによって提供されている場合、メカニズムはトークンを返す場合があります。ローカル削除のみを実装するメカニズムは、このトークンの長さフィールドをゼロに設定して、トークンがピアに送信されないことをアプリケーションに示す必要があります。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_NO_CONTEXT No valid context was supplied",
      "ja": "gss_s_no_context有効なコンテキストは提供されていません"
    },
    {
      "indent": 0,
      "text": "5.10.gss_display_name",
      "ja": "5.10.GSS_DISPLAY_NAME"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_display_name ( OM_uint32 *minor_status, const gss_name_t input_name, gss_buffer_t output_name_buffer, gss_OID *output_name_type)",
      "ja": "OM_UINT32 GSS_DISPLAY_NAME（OM_UINT32 *minor_status、const gss_name_t input_name、gss_buffer_t output_name_buffer、gss_oid *output_name_type）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Allows an application to obtain a textual representation of an opaque internal-form name for display purposes. The syntax of a printable name is defined by the GSS-API implementation.",
      "ja": "アプリケーションは、表示目的で不透明な内部形式名のテキスト表現を取得できます。印刷可能な名前の構文は、GSS-API実装によって定義されます。"
    },
    {
      "indent": 3,
      "text": "If input_name denotes an anonymous principal, the implementation should return the gss_OID value GSS_C_NT_ANONYMOUS as the output_name_type, and a textual name that is syntactically distinct from all valid supported printable names in output_name_buffer.",
      "ja": "input_nameが匿名のプリンシパルを示している場合、実装はgss_oid値gss_c_nt_annymousをoutput_name_typeとして返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If input_name was created by a call to gss_import_name, specifying GSS_C_NO_OID as the name-type, implementations that employ lazy conversion between name types may return GSS_C_NO_OID via the output_name_type parameter.",
      "ja": "input_nameがgss_import_nameの呼び出しによって作成された場合、gss_c_no_oidを名前タイプとして指定すると、名前タイプ間で怠zyな変換を使用する実装は、output_name_typeパラメーターを介してgss_c_no_oioを返す場合があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code.",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します。"
    },
    {
      "indent": 3,
      "text": "input_name gss_name_t, read name to be displayed",
      "ja": "input_name gss_name_t、表示する名前を読み取ります"
    },
    {
      "indent": 3,
      "text": "output_name_buffer buffer, character-string, modify buffer to receive textual name string. The application must free storage associated with this name after use with a call to gss_release_buffer().",
      "ja": "output_name_bufferバッファ、文字弦、バッファを変更してテキスト名文字列を受信します。アプリケーションは、gss_release_buffer（）への呼び出しで使用した後、この名前に関連付けられた無料ストレージを無料で保存する必要があります。"
    },
    {
      "indent": 3,
      "text": "output_name_type Object ID, modify, optional The type of the returned name. The returned gss_OID will be a pointer into static storage, and should be treated as read-only by the caller (in particular, the application should not attempt to free it). Specify NULL if not required.",
      "ja": "output_name_type object id、modify、optional returned nameのタイプ。返されたGSS_OIDは静的ストレージへのポインターであり、発信者が読み取り専用として扱う必要があります（特に、アプリケーションはそれを解放しようとしないでください）。必要でない場合はnullを指定します。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_NAME input_name was ill-formed",
      "ja": "gss_s_bad_name input_nameは不整合されていませんでした"
    },
    {
      "indent": 0,
      "text": "5.11.gss_display_status",
      "ja": "5.11.gss_display_status"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_display_status ( OM_uint32 *minor_status, OM_uint32 status_value, int status_type, const gss_OID mech_type, OM_uint32 *message_context, gss_buffer_t status_string)",
      "ja": "OM_UINT32 GSS_DISPLAY_STATUS（OM_UINT32 *MINTER_STATUS、OM_UINT32 STATUS_VALUE、INT STATUS_TYPE、const GSS_OID MECH_TYPE、OM_UINT32 *MESSAGE_CONTEXT、GSS_BUFFER_T STATUS_STRING）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Allows an application to obtain a textual representation of a GSS-API status code, for display to the user or for logging purposes. Since some status values may indicate multiple conditions, applications may need to call gss_display_status multiple times, each call generating a single text string. The message_context parameter is used by gss_display_status to store state information about which error messages have already been extracted from a given status_value; message_context must be initialized to 0 by the application prior to the first call, and gss_display_status will return a non-zero value in this parameter if there are further messages to extract.",
      "ja": "アプリケーションがGSS-APIステータスコードのテキスト表現を取得し、ユーザーへの表示またはロギング目的で取得できます。一部のステータス値は複数の条件を示す場合があるため、アプリケーションはgss_display_statusを複数回呼び出す必要がある場合があり、各呼び出しで単一のテキスト文字列を生成します。message_contextパラメーターは、gss_display_statusによって使用され、特定のstatus_valueから既に抽出されているエラーメッセージに関する状態情報を保存します。Message_Contextは、最初の呼び出しの前にアプリケーションで0に初期化する必要があり、GSS_DISPLAY_STATUSは、抽出するメッセージがさらにある場合、このパラメーターのゼロ以外の値を返します。"
    },
    {
      "indent": 3,
      "text": "The message_context parameter contains all state information required by gss_display_status in order to extract further messages from the status_value; even when a non-zero value is returned in this parameter, the application is not required to call gss_display_status again unless subsequent messages are desired. The following code extracts all messages from a given status code and prints them to stderr:",
      "ja": "message_contextパラメーターには、gss_display_statusが必要とするすべての状態情報が含まれています。このパラメーターでゼロ以外の値が返された場合でも、後続のメッセージが望まない限り、GSS_DISPLAY_STATUSを再度呼び出す必要はありません。次のコードは、特定のステータスコードからすべてのメッセージを抽出し、それらをstderrに印刷します。"
    },
    {
      "indent": 3,
      "text": "OM_uint32 message_context;\nOM_uint32 status_code;\nOM_uint32 maj_status;\nOM_uint32 min_status;\ngss_buffer_desc status_string;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "...",
      "ja": "..."
    },
    {
      "indent": 3,
      "text": "message_context = 0;",
      "ja": "message_context = 0;"
    },
    {
      "indent": 3,
      "text": "do {",
      "ja": "する {"
    },
    {
      "indent": 5,
      "text": "maj_status = gss_display_status ( &min_status, status_code, GSS_C_GSS_CODE, GSS_C_NO_OID, &message_context, &status_string)",
      "ja": "maj_status = gss_display_status（＆min_status、status_code、gss_c_gss_code、gss_c_no_oio、＆message_context、＆status_string）"
    },
    {
      "indent": 5,
      "text": "fprintf(stderr, \"%.*s\\n\", (int)status_string.length,",
      "ja": "fprintf（stderr、 \"％。*s \\ n\"、（int）status_string.length、"
    },
    {
      "indent": 12,
      "text": "(char *)status_string.value);",
      "ja": "（char *）status_string.value）;"
    },
    {
      "indent": 5,
      "text": "gss_release_buffer(&min_status, &status_string);",
      "ja": "GSS_RELEASE_BUFFER（＆MIN_STATUS、＆STATUS_STRING）;"
    },
    {
      "indent": 3,
      "text": "} while (message_context != 0);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code.",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します。"
    },
    {
      "indent": 3,
      "text": "status_value Integer, read Status value to be converted",
      "ja": "status_value integer、変換するステータス値を読み取ります"
    },
    {
      "indent": 3,
      "text": "status_type Integer, read GSS_C_GSS_CODE - status_value is a GSS status code",
      "ja": "status_type integer、gss_c_gss_code -status_valueはGSSステータスコードです"
    },
    {
      "indent": 3,
      "text": "GSS_C_MECH_CODE - status_value is a mechanism status code",
      "ja": "gss_c_mech_code -status_valueはメカニズムステータスコードです"
    },
    {
      "indent": 3,
      "text": "mech_type Object ID, read, optional Underlying mechanism (used to interpret a minor status value) Supply GSS_C_NO_OID to obtain the system default.",
      "ja": "mech_typeオブジェクトID、読み取り、オプションの基礎メカニズム（マイナーステータス値を解釈するために使用）は、システムのデフォルトを取得するためにGSS_C_NO_OIDを提供します。"
    },
    {
      "indent": 3,
      "text": "message_context Integer, read/modify Should be initialized to zero by the application prior to the first call. On return from gss_display_status(), a non-zero status_value parameter indicates that additional messages may be extracted from the status code via subsequent calls to gss_display_status(), passing the same status_value, status_type, mech_type, and message_context parameters.",
      "ja": "message_context integer、読み取り/変更は、最初の呼び出し前にアプリケーションによってゼロに初期化する必要があります。GSS_DISPLAY_STATUS（）から戻ると、非ゼロSTATUS_VALUEパラメーターは、GSS_DISPLAY_STATUS（）に後続の呼び出しを介してステータスコードから追加のメッセージが抽出され、同じSTATUS_VALUE、STATUS_TYPE、MECH_TYPE、およびMessage_Contextパラメーターを渡すことができることを示します。"
    },
    {
      "indent": 3,
      "text": "status_string buffer, character string, modify textual interpretation of the status_value. Storage associated with this parameter must be freed by the application after use with a call to gss_release_buffer().",
      "ja": "Status_Stringバッファ、文字文字列、Status_Valueのテキスト解釈を変更します。このパラメーターに関連付けられたストレージは、gss_release_buffer（）への呼び出しで使用後にアプリケーションによって解放される必要があります。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_MECH Indicates that translation in accordance with an unsupported mechanism type was requested",
      "ja": "GSS_S_BAD_MECHは、サポートされていないメカニズムの種類に従って翻訳が要求されたことを示しています"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_STATUS The status value was not recognized, or the status type was neither GSS_C_GSS_CODE nor GSS_C_MECH_CODE.",
      "ja": "GSS_S_BAD_STATUSステータス値は認識されていませんでした。または、ステータスタイプはGSS_C_GSS_CODEもGSS_C_MECH_CODEも認識されませんでした。"
    },
    {
      "indent": 0,
      "text": "5.12. gss_duplicate_name",
      "section_title": true,
      "ja": "5.12. gss_duplicate_name"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_duplicate_name ( OM_uint32 *minor_status, const gss_name_t src_name, gss_name_t *dest_name)",
      "ja": "om_uint32 gss_duplicate_name（om_uint32 *minor_status、const gss_name_t src_name、gss_name_t *dest_name）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Create an exact duplicate of the existing internal name src_name. The new dest_name will be independent of src_name (i.e. src_name and dest_name must both be released, and the release of one shall not affect the validity of the other).",
      "ja": "既存の内部名src_nameの正確な複製を作成します。新しいDEST_NAMEはSRC_NAME（つまり、SRC_NAMEとDEST_NAMEの両方をリリースする必要があり、1つのリリースは他のものの有効性に影響しないものとします）。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code.",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します。"
    },
    {
      "indent": 3,
      "text": "src_name gss_name_t, read internal name to be duplicated.",
      "ja": "src_name gss_name_t、内部名を読んで複製する。"
    },
    {
      "indent": 3,
      "text": "dest_name gss_name_t, modify The resultant copy of <src_name>. Storage associated with this name must be freed by the application after use with a call to gss_release_name().",
      "ja": "dest_name gss_name_t、<src_name>の結果のコピーを変更します。この名前に関連付けられたストレージは、GSS_RELEASE_NAME（）を呼び出して使用した後、アプリケーションによって解放する必要があります。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_NAME The src_name parameter was ill-formed.",
      "ja": "gss_s_bad_name src_nameパラメーターは不正に形成されていました。"
    },
    {
      "indent": 0,
      "text": "5.13. gss_export_name",
      "section_title": true,
      "ja": "5.13. gss_export_name"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_export_name ( OM_uint32 *minor_status, const gss_name_t input_name, gss_buffer_t exported_name)",
      "ja": "OM_UINT32 GSS_EXPORT_NAME（OM_UINT32 *minor_status、const gss_name_t input_name、gss_buffer_t exported_name）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "To produce a canonical contiguous string representation of a mechanism name (MN), suitable for direct comparison (e.g. with memcmp) for use in authorization functions (e.g. matching entries in an access-control list). The <input_name> parameter must specify a valid MN (i.e. an internal name generated by gss_accept_sec_context or by gss_canonicalize_name).",
      "ja": "認証関数で使用するための直接比較（MEMCMPなど）に適したメカニズム名（MN）の標準的な連続文字列表現を生成するには（例：アクセス制御リストのエントリの一致）。<inupt_name>パラメーターは、有効なmn（つまり、gss_accept_sec_contextまたはgss_canonicalize_nameによって生成された内部名）を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します"
    },
    {
      "indent": 3,
      "text": "input_name gss_name_t, read The MN to be exported",
      "ja": "input_name gss_name_t、エクスポートするMNを読み取ります"
    },
    {
      "indent": 3,
      "text": "exported_name gss_buffer_t, octet-string, modify The canonical contiguous string form of <input_name>. Storage associated with this string must freed by the application after use with gss_release_buffer().",
      "ja": "exported_name gss_buffer_t、octet-string、<inupt_name>の標準的な連続文字列形式を変更します。この文字列に関連付けられたストレージは、GSS_RELEASE_BUFFER（）で使用した後、アプリケーションによって解放する必要があります。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_NAME_NOT_MN The provided internal name was not a mechanism name.",
      "ja": "GSS_S_NAME_NOT_MN提供された内部名はメカニズム名ではありませんでした。"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_NAME The provided internal name was ill-formed.",
      "ja": "GSS_S_BAD_NAME提供された内部名は不調でした。"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_NAMETYPE The internal name was of a type not supported by the GSS-API implementation.",
      "ja": "GSS_S_BAD_NAMETYPE内部名は、GSS-API実装ではサポートされていないタイプでした。"
    },
    {
      "indent": 0,
      "text": "5.14. gss_export_sec_context",
      "section_title": true,
      "ja": "5.14. gss_export_sec_context"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_export_sec_context ( OM_uint32 *minor_status, gss_ctx_id_t *context_handle, gss_buffer_t interprocess_token)",
      "ja": "OM_UINT32 GSS_EXPORT_SEC_CONTEXT（OM_UINT32 *minor_status、gss_ctx_id_t *context_handle、gss_buffer_t interprocess_token）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Provided to support the sharing of work between multiple processes. This routine will typically be used by the context-acceptor, in an application where a single process receives incoming connection requests and accepts security contexts over them, then passes the established context to one or more other processes for message exchange. gss_export_sec_context() deactivates the security context for the calling process and creates an interprocess token which, when passed to gss_import_sec_context in another process, will re-activate the context in the second process. Only a single instantiation of a given context may be active at any one time; a subsequent attempt by a context exporter to access the exported security context will fail.",
      "ja": "複数のプロセス間で作業の共有をサポートするために提供されます。このルーチンは、通常、コンテキストアセプターによって使用されます。単一のプロセスが着信接続要求を受信してセキュリティコンテキストを受け入れるアプリケーションで使用され、メッセージ交換のために確立されたコンテキストを1つ以上の他のプロセスに渡します。gss_export_sec_context（）呼び出しプロセスのセキュリティコンテキストを非アクティブ化し、別のプロセスでgss_import_sec_contextに渡された場合、2番目のプロセスでコンテキストを再アクティブ化するインタープロセストークンを作成します。特定のコンテキストの単一のインスタンス化のみが一度にアクティブになる場合があります。エクスポートされたセキュリティコンテキストにアクセスしようとするコンテキスト輸出国によるその後の試みは失敗します。"
    },
    {
      "indent": 3,
      "text": "The implementation may constrain the set of processes by which the interprocess token may be imported, either as a function of local security policy, or as a result of implementation decisions. For example, some implementations may constrain contexts to be passed only between processes that run under the same account, or which are part of the same process group.",
      "ja": "実装は、ローカルセキュリティポリシーの関数として、または実装の決定の結果として、インタープロセストークンがインポートされるプロセスのセットを制約する場合があります。たとえば、一部の実装では、同じアカウントの下で実行されるプロセス、または同じプロセスグループの一部であるプロセス間でのみコンテキストを制限する場合があります。"
    },
    {
      "indent": 3,
      "text": "The interprocess token may contain security-sensitive information (for example cryptographic keys). While mechanisms are encouraged to either avoid placing such sensitive information within interprocess tokens, or to encrypt the token before returning it to the application, in a typical object-library GSS-API implementation this may not be possible. Thus the application must take care to protect the interprocess token, and ensure that any process to which the token is transferred is trustworthy.",
      "ja": "インタープロセストークンには、セキュリティに敏感な情報（たとえば暗号化キー）が含まれる場合があります。メカニズムは、このような機密情報をインタープロセストークン内に配置することを避けるか、典型的なオブジェクトライブラリGSS-API実装でアプリケーションに戻す前にトークンを暗号化することを奨励されていますが、これは不可能です。したがって、アプリケーションはインタープロセストークンを保護するように注意し、トークンが転送されるプロセスが信頼できることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "If creation of the interprocess token is successful, the implementation shall deallocate all process-wide resources associated with the security context, and set the context_handle to GSS_C_NO_CONTEXT. In the event of an error that makes it impossible to complete the export of the security context, the implementation must not return an interprocess token, and should strive to leave the security context referenced by the context_handle parameter untouched. If this is impossible, it is permissible for the implementation to delete the security context, providing it also sets the context_handle parameter to GSS_C_NO_CONTEXT.",
      "ja": "インタープロセストークンの作成が成功した場合、実装はセキュリティコンテキストに関連するすべてのプロセス全体のリソースを扱い、Context_HandleをGSS_C_NO_CONTEXTに設定するものとします。セキュリティコンテキストのエクスポートを完了することを不可能にするエラーが発生した場合、実装はインタープロセストークンを返してはなりません。また、Context_handleパラメーターによって参照されるセキュリティコンテキストのままにするよう努力する必要があります。これが不可能な場合は、実装がセキュリティコンテキストを削除することが許可されており、Context_Content_HandleパラメーターをGSS_C_NO_CONTEXTに設定することもできます。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します"
    },
    {
      "indent": 3,
      "text": "context_handle gss_ctx_id_t, modify context handle identifying the context to transfer.",
      "ja": "context_handle gss_ctx_id_t、コンテキストを変更して、転送するコンテキストを識別します。"
    },
    {
      "indent": 3,
      "text": "interprocess_token buffer, opaque, modify token to be transferred to target process. Storage associated with this token must be freed by the application after use with a call to gss_release_buffer().",
      "ja": "interprocess_tokenバッファ、不透明、トークンを変更してターゲットプロセスに転送します。このトークンに関連付けられたストレージは、GSS_RELEASE_BUFFER（）への呼び出しで使用後にアプリケーションによって解放される必要があります。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_CONTEXT_EXPIRED The context has expired",
      "ja": "GSS_S_CONTEXT_EXPIREDコンテキストの有効期限が切れています"
    },
    {
      "indent": 3,
      "text": "GSS_S_NO_CONTEXT The context was invalid",
      "ja": "GSS_S_NO_CONTEXTコンテキストは無効でした"
    },
    {
      "indent": 3,
      "text": "GSS_S_UNAVAILABLE The operation is not supported.",
      "ja": "gss_s_unavailable操作はサポートされていません。"
    },
    {
      "indent": 0,
      "text": "5.15. gss_get_mic",
      "section_title": true,
      "ja": "5.15. gss_get_mic"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_get_mic ( OM_uint32 *minor_status, const gss_ctx_id_t context_handle, gss_qop_t qop_req, const gss_buffer_t message_buffer, gss_buffer_t msg_token)",
      "ja": "OM_UINT32 GSS_GET_MIC（OM_UINT32 *MINTER_STATUS、const GSS_CTX_ID_T Context_Handle、GSS_QOP_T QOP_REQ、const GSS_Buffer_t Message_Buffer、GSS_BUFFER_T MSG_TOKEN）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Generates a cryptographic MIC for the supplied message, and places the MIC in a token for transfer to the peer application. The qop_req parameter allows a choice between several cryptographic algorithms, if supported by the chosen mechanism.",
      "ja": "提供されたメッセージの暗号化マイクを生成し、ピアアプリケーションに転送するためにマイクをトークンに入れます。QOP_REQパラメーターは、選択したメカニズムでサポートされている場合、いくつかの暗号化アルゴリズムから選択できます。"
    },
    {
      "indent": 3,
      "text": "Since some application-level protocols may wish to use tokens emitted by gss_wrap() to provide \"secure framing\", implementations must support derivation of MICs from zero-length messages.",
      "ja": "一部のアプリケーションレベルのプロトコルは、gss_wrap（）によって放出されたトークンを使用して「セキュアフレーミング」を提供する場合があるため、実装はゼロ長のメッセージからのMICの導出をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Implementation specific status code.",
      "ja": "minor_status integer、実装固有のステータスコードを変更します。"
    },
    {
      "indent": 3,
      "text": "context_handle gss_ctx_id_t, read identifies the context on which the message will be sent",
      "ja": "Context_handle gss_ctx_id_t、読み取りメッセージが送信されるコンテキストを識別します"
    },
    {
      "indent": 3,
      "text": "qop_req gss_qop_t, read, optional Specifies requested quality of protection. Callers are encouraged, on portability grounds, to accept the default quality of protection offered by the chosen mechanism, which may be requested by specifying GSS_C_QOP_DEFAULT for this parameter. If an unsupported protection strength is requested, gss_get_mic will return a major_status of GSS_S_BAD_QOP.",
      "ja": "QOP_REQ GSS_QOP_T、読み取り、オプションの保護品質のリクエストされた品質を指定します。発信者は、移植性の根拠で、選択したメカニズムによって提供されるデフォルトの保護品質を受け入れるよう奨励されています。サポートされていない保護強度が要求された場合、GSS_GET_MICはGSS_S_BAD_QOPのMajor_Statusを返します。"
    },
    {
      "indent": 3,
      "text": "message_buffer buffer, opaque, read message to be protected",
      "ja": "message_bufferバッファー、不透明、保護されるメッセージを読む"
    },
    {
      "indent": 3,
      "text": "msg_token buffer, opaque, modify buffer to receive token. The application must free storage associated with this buffer after use with a call to gss_release_buffer().",
      "ja": "MSG_TOKENバッファー、不透明、バッファを変更してトークンを受信します。アプリケーションは、GSS_RELEASE_BUFFER（）を呼び出して使用した後、このバッファに関連付けられたストレージを解放する必要があります。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_CONTEXT_EXPIRED The context has already expired",
      "ja": "GSS_S_CONTEXT_EXPIREDコンテキストはすでに期限切れになっています"
    },
    {
      "indent": 3,
      "text": "GSS_S_NO_CONTEXT The context_handle parameter did not identify a valid context",
      "ja": "gss_s_no_context context_handleパラメーターは有効なコンテキストを識別しませんでした"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_QOP The specified QOP is not supported by the mechanism.",
      "ja": "GSS_S_BAD_QOP指定されたQOPは、メカニズムによってサポートされていません。"
    },
    {
      "indent": 0,
      "text": "5.16. gss_import_name",
      "section_title": true,
      "ja": "5.16. gss_import_name"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_import_name ( OM_uint32 *minor_status, const gss_buffer_t input_name_buffer, const gss_OID input_name_type, gss_name_t *output_name)",
      "ja": "OM_UINT32 GSS_IMPORT_NAME（OM_UINT32 *minor_status、const gss_buffer_t input_name_buffer、const gss_oid input_name_type、gss_name_t *output_name）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Convert a contiguous string name to internal form. In general, the internal name returned (via the <output_name> parameter) will not be an MN; the exception to this is if the <input_name_type> indicates that the contiguous string provided via the <input_name_buffer> parameter is of type GSS_C_NT_EXPORT_NAME, in which case the returned internal name will be an MN for the mechanism that exported the name.",
      "ja": "連続した文字列名を内部フォームに変換します。一般に、（<OUTPUT_NAME>パラメーターを介して）返された内部名はMNではありません。これの例外は、<inupt_name_type>が<inupt_name_buffer>パラメーターを介して提供される連続文字列がタイプGSS_C_NT_EXPORT_NAMEであることを示している場合です。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します"
    },
    {
      "indent": 3,
      "text": "input_name_buffer buffer, octet-string, read buffer containing contiguous string name to convert",
      "ja": "input_name_bufferバッファー、オクテットストリング、隣接する文字列名を含むバッファーを読み取り、変換する"
    },
    {
      "indent": 3,
      "text": "input_name_type Object ID, read, optional Object ID specifying type of printable name. Applications may specify either GSS_C_NO_OID to use a mechanism-specific default printable syntax, or an OID recognized by the GSS-API implementation to name a specific namespace.",
      "ja": "input_name_typeオブジェクトID、読み取り、オプションのオブジェクトIDは、印刷可能な名前のタイプを指定します。アプリケーションは、GSS_C_NO_OIDを指定して、メカニズム固有のデフォルトの印刷可能な構文を使用するか、特定の名前空間に名前を付けるためにGSS-API実装によって認識されるOIDを使用できます。"
    },
    {
      "indent": 3,
      "text": "output_name gss_name_t, modify returned name in internal form. Storage associated with this name must be freed by the application after use with a call to gss_release_name().",
      "ja": "output_name gss_name_t、内部形式の返された名前を変更します。この名前に関連付けられたストレージは、GSS_RELEASE_NAME（）を呼び出して使用した後、アプリケーションによって解放する必要があります。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_NAMETYPE The input_name_type was unrecognized",
      "ja": "gss_s_bad_nameType input_name_typeは認識されていませんでした"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_NAME The input_name parameter could not be interpreted as a name of the specified type",
      "ja": "gss_s_bad_name input_nameパラメーターは、指定された型の名前として解釈できませんでした"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_MECH The input name-type was GSS_C_NT_EXPORT_NAME, but the mechanism contained within the input-name is not supported",
      "ja": "GSS_S_BAD_MECH入力名タイプはGSS_C_NT_EXPORT_NAMEでしたが、入力名に含まれるメカニズムはサポートされていません"
    },
    {
      "indent": 0,
      "text": "5.17. gss_import_sec_context",
      "section_title": true,
      "ja": "5.17. gss_import_sec_context"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_import_sec_context ( OM_uint32 *minor_status, const gss_buffer_t interprocess_token, gss_ctx_id_t *context_handle)",
      "ja": "OM_UINT32 GSS_IMPORT_SEC_CONTEXT（OM_UINT32 *minor_status、const gss_buffer_t interprocess_token、gss_ctx_id_t *context_handle）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Allows a process to import a security context established by another process. A given interprocess token may be imported only once. See gss_export_sec_context.",
      "ja": "プロセスが別のプロセスによって確立されたセキュリティコンテキストをインポートできるようにします。所定のプロセストークンは、1回だけインポートされる場合があります。gss_export_sec_contextを参照してください。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します"
    },
    {
      "indent": 3,
      "text": "interprocess_token buffer, opaque, modify token received from exporting process",
      "ja": "interprocess_tokenバッファ、不透明、エクスポートプロセスから受信したトークンを変更する"
    },
    {
      "indent": 3,
      "text": "context_handle gss_ctx_id_t, modify context handle of newly reactivated context. Resources associated with this context handle must be released by the application after use with a call to gss_delete_sec_context().",
      "ja": "context_handle gss_ctx_id_t、新たに再アクティブ化されたコンテキストのコンテキストハンドルを変更します。このコンテキストハンドルに関連付けられたリソースは、gss_delete_sec_context（）を呼び出して使用した後、アプリケーションによってリリースされる必要があります。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion.",
      "ja": "gss_s_complete正常に完了しました。"
    },
    {
      "indent": 3,
      "text": "GSS_S_NO_CONTEXT The token did not contain a valid context reference.",
      "ja": "GSS_S_NO_CONTEXTトークンには、有効なコンテキストリファレンスが含まれていませんでした。"
    },
    {
      "indent": 3,
      "text": "GSS_S_DEFECTIVE_TOKEN The token was invalid.",
      "ja": "gss_s_defective_tokenトークンは無効でした。"
    },
    {
      "indent": 3,
      "text": "GSS_S_UNAVAILABLE The operation is unavailable.",
      "ja": "gss_s_unavailable操作は利用できません。"
    },
    {
      "indent": 3,
      "text": "GSS_S_UNAUTHORIZED Local policy prevents the import of this context by the current process.",
      "ja": "GSS_S_UNAOTORIZEDローカルポリシーは、現在のプロセスによるこのコンテキストのインポートを防ぎます。"
    },
    {
      "indent": 0,
      "text": "5.18. gss_indicate_mechs",
      "section_title": true,
      "ja": "5.18. gss_indicate_mechs"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_indicate_mechs ( OM_uint32 *minor_status, gss_OID_set *mech_set)",
      "ja": "om_uint32 gss_indicate_mechs（om_uint32 *minor_status、gss_oid_set *mech_set）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Allows an application to determine which underlying security mechanisms are available.",
      "ja": "アプリケーションが利用可能な基礎となるセキュリティメカニズムを決定できるようにします。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code.",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します。"
    },
    {
      "indent": 3,
      "text": "mech_set set of Object IDs, modify set of implementation-supported mechanisms. The returned gss_OID_set value will be a dynamically-allocated OID set, that should be released by the caller after use with a call to gss_release_oid_set().",
      "ja": "MECH_SETオブジェクトIDのセット、実装サポートされたメカニズムのセットを変更します。返されたgss_oid_set値は、動的に割り当てられたoidセットになります。これは、gss_release_oid_set（）への呼び出しで使用した後に発信者がリリースする必要があります。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 0,
      "text": "5.19. gss_init_sec_context",
      "section_title": true,
      "ja": "5.19. gss_init_sec_context"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_init_sec_context (\n  OM_uint32                    *minor_status,\n  const gss_cred_id_t          initiator_cred_handle,\n  gss_ctx_id_t                 *context_handle,\\\n  const gss_name_t             target_name,\n  const gss_OID                mech_type,\n  OM_uint32                    req_flags,\n  OM_uint32                    time_req,\n  const gss_channel_bindings_t input_chan_bindings,\n  const gss_buffer_t           input_token\n  gss_OID                      *actual_mech_type,\n  gss_buffer_t                 output_token,\n  OM_uint32                    *ret_flags,\n  OM_uint32                    *time_rec )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Initiates the establishment of a security context between the application and a remote peer. Initially, the input_token parameter should be specified either as GSS_C_NO_BUFFER, or as a pointer to a gss_buffer_desc object whose length field contains the value zero. The routine may return a output_token which should be transferred to the peer application, where the peer application will present it to gss_accept_sec_context. If no token need be sent, gss_init_sec_context will indicate this by setting the length field of the output_token argument to zero. To complete the context establishment, one or more reply tokens may be required from the peer application; if so, gss_init_sec_context will return a status containing the supplementary information bit GSS_S_CONTINUE_NEEDED. In this case, gss_init_sec_context should be called again when the reply token is received from the peer application, passing the reply token to gss_init_sec_context via the input_token parameters.",
      "ja": "アプリケーションとリモートピアの間にセキュリティコンテキストの確立を開始します。最初に、input_tokenパラメーターは、gss_c_no_bufferとして、または長さのフィールドに値が含まれているGSS_buffer_descオブジェクトへのポインターとして指定する必要があります。ルーチンは、ピアアプリケーションに転送する必要があるoutput_tokenを返す場合があります。ピアアプリケーションでは、ピアアプリケーションがGSS_ACCEPT_SEC_CONTEXTに表示されます。トークンを送信する必要がない場合、gss_init_sec_contextは、output_token引数の長さフィールドをゼロに設定することによりこれを示します。コンテキストの確立を完了するには、ピアアプリケーションから1つ以上の返信トークンが必要になる場合があります。その場合、GSS_INIT_SEC_CONTEXTは、補足情報BIT GSS_S_CONTINUE_NEEDEDを含むステータスを返します。この場合、gss_init_sec_contextは、回答トークンがピアアプリケーションから受信されたときに再度呼び出され、input_tokenパラメーターを介してgss_init_sec_contextに返信トークンを渡します。"
    },
    {
      "indent": 3,
      "text": "Portable applications should be constructed to use the token length and return status to determine whether a token needs to be sent or waited for. Thus a typical portable caller should always invoke gss_init_sec_context within a loop:",
      "ja": "ポータブルアプリケーションは、トークンの長さと戻りステータスを使用して、トークンを送信または待機する必要があるかどうかを判断するために構築する必要があります。したがって、典型的なポータブル発信者は、常にループ内でgss_init_sec_contextを呼び出す必要があります。"
    },
    {
      "indent": 3,
      "text": "int context_established = 0;\ngss_ctx_id_t context_hdl = GSS_C_NO_CONTEXT;\n       ...\ninput_token->length = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "while (!context_established) {\n  maj_stat = gss_init_sec_context(&min_stat,\n                                  cred_hdl,\n                                  &context_hdl,\n                                  target_name,\n                                  desired_mech,\n                                  desired_services,\n                                  desired_time,\n                                  input_bindings,\n                                  input_token,\n                                  &actual_mech,\n                                  output_token,\n                                  &actual_services,\n                                  &actual_time);\n  if (GSS_ERROR(maj_stat)) {\n    report_error(maj_stat, min_stat);\n  };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "if (output_token->length != 0) {\n  send_token_to_peer(output_token);\n  gss_release_buffer(&min_stat, output_token)\n};\nif (GSS_ERROR(maj_stat)) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  if (context_hdl != GSS_C_NO_CONTEXT)\n    gss_delete_sec_context(&min_stat,\n                           &context_hdl,\n                           GSS_C_NO_BUFFER);\n  break;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  if (maj_stat & GSS_S_CONTINUE_NEEDED) {\n    receive_token_from_peer(input_token);\n  } else {\n    context_established = 1;\n  };\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Whenever the routine returns a major status that includes the value GSS_S_CONTINUE_NEEDED, the context is not fully established and the following restrictions apply to the output parameters:",
      "ja": "ルーチンが値GSS_S_S_CONTINUE_NEEDEDを含む主要なステータスを返すときはいつでも、コンテキストは完全に確立されておらず、次の制限が出力パラメーターに適用されます。"
    },
    {
      "indent": 6,
      "text": "The value returned via the time_rec parameter is undefined Unless the accompanying ret_flags parameter contains the bit GSS_C_PROT_READY_FLAG, indicating that per-message services may be applied in advance of a successful completion status, the value returned via the actual_mech_type parameter is undefined until the routine returns a major status value of GSS_S_COMPLETE.",
      "ja": "添付のRET_FLAGSパラメーターにビットGSS_C_PROT_READY_FLAGが含まれていない限り、Time_Recパラメーターを介して返される値は未定義です。GSS_S_Completeの主要なステータス値。"
    },
    {
      "indent": 6,
      "text": "The values of the GSS_C_DELEG_FLAG, GSS_C_MUTUAL_FLAG, GSS_C_REPLAY_FLAG, GSS_C_SEQUENCE_FLAG, GSS_C_CONF_FLAG, GSS_C_INTEG_FLAG and GSS_C_ANON_FLAG bits returned via the ret_flags parameter should contain the values that the implementation expects would be valid if context establishment were to succeed. In particular, if the application has requested a service such as delegation or anonymous authentication via the req_flags argument, and such a service is unavailable from the underlying mechanism, gss_init_sec_context should generate a token that will not provide the service, and indicate via the ret_flags argument that the service will not be supported. The application may choose to abort the context establishment by calling gss_delete_sec_context (if it cannot continue in the absence of the service), or it may choose to transmit the token and continue context establishment (if the service was merely desired but not mandatory).",
      "ja": "GSS_C_DELEG_FLAG、GSS_C_MUTUAL_FLAG、GSS_C_REPLAY_FLAG、GSS_C_FLAG_FLAG、GSS_C_CONF_FLAG、GSS_C_INTEG_FLAG、GSS_C_ANON_ANON_FLAGの継続的に依頼されました。 。特に、アプリケーションがREQ_FLAGS引数を介して委任や匿名認証などのサービスを要求している場合、そのようなサービスは基礎となるメカニズムから利用できない場合、GSS_INIT_SEC_CONTEXTはサービスを提供しないトークンを生成し、RET_FLAGS引数を介して示す必要はありません。サービスがサポートされないこと。アプリケーションは、GSS_DELETE_SEC_CONTEXTを呼び出すことでコンテキスト確立を中止することを選択できます（サービスの存在下で継続できない場合）、またはトークンを送信してコンテキスト確立を継続することを選択できます（サービスが単に望ましいが必須ではない場合）。"
    },
    {
      "indent": 6,
      "text": "The values of the GSS_C_PROT_READY_FLAG and GSS_C_TRANS_FLAG bits within ret_flags should indicate the actual state at the time gss_init_sec_context returns, whether or not the context is fully established.",
      "ja": "gss_c_prot_ready_flagおよびgss_c_trans_flagの値は、ret_flags内のgss_c_trans_flagは、コンテキストが完全に確立されているかどうかにかかわらず、gss_init_sec_contextが返される時点で実際の状態を示す必要があります。"
    },
    {
      "indent": 6,
      "text": "GSS-API implementations that support per-message protection are encouraged to set the GSS_C_PROT_READY_FLAG in the final ret_flags returned to a caller (i.e. when accompanied by a GSS_S_COMPLETE status code). However, applications should not rely on this behavior as the flag was not defined in Version 1 of the GSS-API. Instead, applications should determine what per-message services are available after a successful context establishment according to the GSS_C_INTEG_FLAG and GSS_C_CONF_FLAG values.",
      "ja": "メッセージごとの保護をサポートするGSS-APIの実装は、最終的なRET_FLAGSでGSS_C_PROT_READY_FLAGを発信者に返すように設定することをお勧めします（つまり、GSS_S_COMPLETEステータスコードを伴う場合）。ただし、GSS-APIのバージョン1ではフラグが定義されていないため、アプリケーションはこの動作に依存してはなりません。代わりに、アプリケーションは、GSS_C_INTEG_FLAGおよびGSS_C_CONF_FLAG値に従って、コンテキスト確立を成功させた後に利用可能なサービスごとのサービスを決定する必要があります。"
    },
    {
      "indent": 6,
      "text": "All other bits within the ret_flags argument should be set to zero.",
      "ja": "RET_FLAGS引数内の他のすべてのビットは、ゼロに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the initial call of gss_init_sec_context() fails, the implementation should not create a context object, and should leave the value of the context_handle parameter set to GSS_C_NO_CONTEXT to indicate this. In the event of a failure on a subsequent call, the implementation is permitted to delete the \"half-built\" security context (in which case it should set the context_handle parameter to GSS_C_NO_CONTEXT), but the preferred behavior is to leave the security context untouched for the application to delete (using gss_delete_sec_context).",
      "ja": "GSS_INIT_SEC_CONTEXT（）の最初の呼び出しが失敗した場合、実装はコンテキストオブジェクトを作成しないでください。コンテキスト_HANDLEパラメーターの値をGSS_C_NO_CONTEXTに設定して、これを示す必要があります。後続の呼び出しが失敗した場合、実装は「ハーフ構築」セキュリティコンテキストを削除することが許可されています（この場合、Context_C_NO_Contextにcontext_handleパラメーターを設定する必要があります）が、好みの動作はセキュリティコンテキストを触れずに残すことです。アプリケーションが削除するために（gss_delete_sec_contextを使用）。"
    },
    {
      "indent": 3,
      "text": "During context establishment, the informational status bits GSS_S_OLD_TOKEN and GSS_S_DUPLICATE_TOKEN indicate fatal errors, and GSS-API mechanisms should always return them in association with a routine error of GSS_S_FAILURE. This requirement for pairing did not exist in version 1 of the GSS-API specification, so applications that wish to run over version 1 implementations must special-case these codes.",
      "ja": "コンテキストの確立中に、情報ステータスビットGSS_OLD_TOKENおよびGSS_S_DUPLICATION_TOKENは致命的なエラーを示し、GSS-APIメカニズムは常にGSS_S_FAILUREの日常的なエラーに関連してそれらを返す必要があります。このペアリングの要件は、GSS-API仕様のバージョン1には存在していなかったため、バージョン1の実装を実行するアプリケーションは、これらのコードを特別なケースにする必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code.",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します。"
    },
    {
      "indent": 3,
      "text": "initiator_cred_handle gss_cred_id_t, read, optional handle for credentials claimed. Supply GSS_C_NO_CREDENTIAL to act as a default initiator principal. If no default initiator is defined, the function will return GSS_S_NO_CRED.",
      "ja": "initiator_cred_handle gss_cred_id_t、読み取り、資格情報のオプションのハンドルが主張されています。GSS_C_NO_CREDENTIALを提供して、デフォルトの開始校長として機能します。デフォルトのイニシエーターが定義されていない場合、関数はGSS_S_NO_CREDを返します。"
    },
    {
      "indent": 3,
      "text": "context_handle gss_ctx_id_t, read/modify context handle for new context. Supply GSS_C_NO_CONTEXT for first call; use value returned by first call in continuation calls. Resources associated with this context-handle must be released by the application after use with a call to gss_delete_sec_context().",
      "ja": "context_handle gss_ctx_id_t、新しいコンテキストのコンテキストハンドルを読み取り/変更します。最初の呼び出しにGSS_C_NO_CONTEXTを提供します。継続コールの最初のコールによって返される値を使用します。このコンテキストハンドルに関連するリソースは、gss_delete_sec_context（）への呼び出しで使用後にアプリケーションによってリリースされる必要があります。"
    },
    {
      "indent": 3,
      "text": "target_name gss_name_t, read Name of target",
      "ja": "Target_name gss_name_t、ターゲットの名前を読み取ります"
    },
    {
      "indent": 3,
      "text": "mech_type OID, read, optional Object ID of desired mechanism. Supply GSS_C_NO_OID to obtain an implementation specific default",
      "ja": "mech_type oid、読み取り、目的のメカニズムのオプションオブジェクトID。GSS_C_NO_OIDを提供して、実装固有のデフォルトを取得します"
    },
    {
      "indent": 3,
      "text": "req_flags bit-mask, read Contains various independent flags, each of which requests that the context support a specific service option. Symbolic names are provided for each flag, and the symbolic names corresponding to the required flags should be logically-ORed together to form the bit-mask value. The flags are:",
      "ja": "req_flagsビットマスク、読み取りにはさまざまな独立したフラグが含まれており、それぞれにコンテキストが特定のサービスオプションをサポートすることを要求します。各フラグに対してシンボリック名が提供され、必要なフラグに対応するシンボリック名は、ビットマスク値を形成するために論理的に並べる必要があります。フラグは次のとおりです。"
    },
    {
      "indent": 21,
      "text": "GSS_C_DELEG_FLAG True - Delegate credentials to remote peer False - Don't delegate",
      "ja": "GSS_C_DELEG_FLAG True-リモートピアFalseへの代表資格情報 - 委任しないでください"
    },
    {
      "indent": 21,
      "text": "GSS_C_MUTUAL_FLAG True - Request that remote peer authenticate itself False - Authenticate self to remote peer only",
      "ja": "gss_c_mutual_flag true-リクエストリモートピア自体認証虚偽 - リモートピアに自己認証のみ"
    },
    {
      "indent": 21,
      "text": "GSS_C_REPLAY_FLAG True - Enable replay detection for messages protected with gss_wrap or gss_get_mic False - Don't attempt to detect replayed messages",
      "ja": "gss_c_replay_flag true- gss_wrapまたはgss_get_mic falseで保護されているメッセージのリプレイ検出を有効にする - 再生メッセージを検出しようとしない"
    },
    {
      "indent": 21,
      "text": "GSS_C_SEQUENCE_FLAG True - Enable detection of out-of-sequence protected messages False - Don't attempt to detect out-of-sequence messages",
      "ja": "gss_c_sequence_flag true-シーケンス外で保護されたメッセージの検出を有効にするfalse-シーケンス外のメッセージを検出しようとしない"
    },
    {
      "indent": 21,
      "text": "GSS_C_CONF_FLAG True - Request that confidentiality service be made available (via gss_wrap) False - No per-message confidentiality service is required.",
      "ja": "GSS_C_CONF_FLAG TRUE -（GSS_WRAP経由で）falseを利用可能にするための機密サービスを要求します-MESSAGEごとの機密性サービスは必要ありません。"
    },
    {
      "indent": 21,
      "text": "GSS_C_INTEG_FLAG True - Request that integrity service be made available (via gss_wrap or gss_get_mic) False - No per-message integrity service is required.",
      "ja": "GSS_C_INTEG_FLAG TRUE -Integrity Serviceを利用可能にすることを要求します（gss_wrapまたはgss_get_mic経由）false -message Persisage Integrity Serviceは不要です。"
    },
    {
      "indent": 21,
      "text": "GSS_C_ANON_FLAG True - Do not reveal the initiator's identity to the acceptor. False - Authenticate normally.",
      "ja": "gss_c_anon_flag true-アクセプターにイニシエーターの身元を明らかにしないでください。false-正常に認証します。"
    },
    {
      "indent": 3,
      "text": "time_req Integer, read, optional Desired number of seconds for which context should remain valid. Supply 0 to request a default validity period.",
      "ja": "time_req integer、読み取り、コンテキストが有効なままである必要があるオプションの希望の秒数。デフォルトの有効期間を要求するために0を供給します。"
    },
    {
      "indent": 3,
      "text": "input_chan_bindings channel bindings, read, optional Application-specified bindings. Allows application to securely bind channel identification information to the security context. Specify GSS_C_NO_CHANNEL_BINDINGS if channel bindings are not used.",
      "ja": "input_chan_bindingsチャネルバインディング、読み取り、オプションのアプリケーション指定バインディング。アプリケーションは、セキュリティコンテキストにチャネル識別情報を安全にバインドできるようにします。チャネルバインディングが使用されていない場合は、GSS_C_NO_CHANNEL_BINDINGSを指定します。"
    },
    {
      "indent": 3,
      "text": "input_token buffer, opaque, read, optional (see text) Token received from peer application. Supply GSS_C_NO_BUFFER, or a pointer to a buffer containing the value GSS_C_EMPTY_BUFFER on initial call.",
      "ja": "input_tokenバッファー、不透明、読み取り、オプション（テキストを参照）トークンはピアアプリケーションから受信します。GSS_C_NO_BUFFER、または最初の呼び出しで値GSS_C_EMPTY_BUFFERを含むバッファーへのポインターを提供します。"
    },
    {
      "indent": 3,
      "text": "actual_mech_type OID, modify, optional Actual mechanism used. The OID returned via this parameter will be a pointer to static storage that should be treated as read-only; In particular the application should not attempt to free it. Specify NULL if not required.",
      "ja": "everity_mech_type oid、変更、使用されるオプションの実際のメカニズム。このパラメーターを介して返されるOIDは、読み取り専用として扱う必要がある静的ストレージへのポインターになります。特に、アプリケーションはそれを解放しようとしてはなりません。必要でない場合はnullを指定します。"
    },
    {
      "indent": 3,
      "text": "output_token buffer, opaque, modify token to be sent to peer application. If the length field of the returned buffer is zero, no token need be sent to the peer application. Storage associated with this buffer must be freed by the application after use with a call to gss_release_buffer().",
      "ja": "output_tokenバッファー、不透明、トークンを変更してピアアプリケーションに送信します。返されたバッファーの長さフィールドがゼロの場合、トークンをピアアプリケーションに送信する必要はありません。このバッファに関連付けられたストレージは、GSS_RELEASE_BUFFER（）を呼び出して使用した後、アプリケーションによって解放する必要があります。"
    },
    {
      "indent": 3,
      "text": "ret_flags bit-mask, modify, optional Contains various independent flags, each of which indicates that the context supports a specific service option. Specify NULL if not required. Symbolic names are provided for each flag, and the symbolic names corresponding to the required flags should be logically-ANDed with the ret_flags value to test whether a given option is supported by the context. The flags are: GSS_C_DELEG_FLAG True - Credentials were delegated to the remote peer False - No credentials were delegated",
      "ja": "ret_flagsビットマスク、変更、オプションには、さまざまな独立したフラグが含まれています。それぞれが、コンテキストが特定のサービスオプションをサポートしていることを示します。必要でない場合はnullを指定します。各フラグに対してシンボリック名が提供され、必要なフラグに対応するシンボリック名は、ret_flags値を論理的に配信する必要があります。フラグは次のとおりです。GSS_C_DELEG_FLAGTRUE-資格情報はリモートピアFALSEに委任されました - 資格情報は委任されませんでした"
    },
    {
      "indent": 21,
      "text": "GSS_C_MUTUAL_FLAG True - The remote peer has authenticated itself. False - Remote peer has not authenticated itself.",
      "ja": "gss_c_mutual_flag true-リモートピアはそれ自体を認証しました。false-リモートピアはそれ自体を認証していません。"
    },
    {
      "indent": 21,
      "text": "GSS_C_REPLAY_FLAG True - replay of protected messages will be detected False - replayed messages will not be detected",
      "ja": "gss_c_replay_flag true-保護されたメッセージのリプレイが誤って検出されます - リプレイされたメッセージは検出されません"
    },
    {
      "indent": 21,
      "text": "GSS_C_SEQUENCE_FLAG True - out-of-sequence protected messages will be detected False - out-of-sequence messages will not be detected",
      "ja": "gss_c_sequence_flag true-アウトシーケンス保護されたメッセージが検出されます虚偽 - アウトシーケンスメッセージは検出されません"
    },
    {
      "indent": 21,
      "text": "GSS_C_CONF_FLAG True - Confidentiality service may be invoked by calling gss_wrap routine False - No confidentiality service (via gss_wrap) available. gss_wrap will provide message encapsulation, data-origin authentication and integrity services only.",
      "ja": "GSS_C_CONF_FLAG True -GSS_WRAPルーチンFalse -No Confidentlisity Service（GSS_WRAP経由）を利用できるように、COALD GSS_WRAPルーチン-No Calling Cally Callingが呼び出すことができます。GSS_WRAPは、メッセージのカプセル化、データオリジン認証、および整合性サービスのみを提供します。"
    },
    {
      "indent": 21,
      "text": "GSS_C_INTEG_FLAG True - Integrity service may be invoked by calling either gss_get_mic or gss_wrap routines. False - Per-message integrity service unavailable.",
      "ja": "GSS_C_INTEG_FLAG True -Integrity Serviceは、GSS_GET_MICまたはGSS_WRAPルーチンのいずれかを呼び出すことで呼び出される場合があります。false -Message Integrity Serviceは利用できません。"
    },
    {
      "indent": 21,
      "text": "GSS_C_ANON_FLAG True - The initiator's identity has not been revealed, and will not be revealed if any emitted token is passed to the acceptor. False - The initiator's identity has been or will be authenticated normally.",
      "ja": "GSS_C_ANON_FLAG True-イニシエーターの身元は明らかにされておらず、放出されたトークンがアクセプターに渡された場合、明らかにされません。false-イニシエーターのアイデンティティは、正常に認証されているか、または認証されます。"
    },
    {
      "indent": 21,
      "text": "GSS_C_PROT_READY_FLAG",
      "ja": "gss_c_prot_ready_flag"
    },
    {
      "indent": 23,
      "text": "True - Protection services (as specified by the states of the GSS_C_CONF_FLAG and GSS_C_INTEG_FLAG) are available for use if the accompanying major status return value is either GSS_S_COMPLETE or GSS_S_CONTINUE_NEEDED. False - Protection services (as specified by the states of the GSS_C_CONF_FLAG and GSS_C_INTEG_FLAG) are available only if the accompanying major status return value is GSS_S_COMPLETE.",
      "ja": "true-保護サービス（GSS_C_CONF_FLAGおよびGSS_C_INTEG_FLAGの状態によって指定されているように）は、付随する主要なステータスリターン値がGSS_S_COMPLETEまたはGSS_S_CONTINUE_NEEDEDのいずれかである場合に使用できます。false-保護サービス（GSS_C_CONF_FLAGおよびGSS_C_INTEG_FLAGの状態によって指定）は、付随する主要なステータスリターン値がGSS_S_COMPLETEである場合にのみ利用可能です。"
    },
    {
      "indent": 21,
      "text": "GSS_C_TRANS_FLAG True - The resultant security context may be transferred to other processes via a call to gss_export_sec_context(). False - The security context is not transferable.",
      "ja": "gss_c_trans_flag true-結果のセキュリティコンテキストは、gss_export_sec_context（）を呼び出すことにより、他のプロセスに転送される場合があります。false-セキュリティコンテキストは転送できません。"
    },
    {
      "indent": 21,
      "text": "All other bits should be set to zero.",
      "ja": "他のすべてのビットはゼロに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "time_rec Integer, modify, optional number of seconds for which the context will remain valid. If the implementation does not support context expiration, the value GSS_C_INDEFINITE will be returned. Specify NULL if not required.",
      "ja": "time_rec integer、変更、オプションの秒数のコンテキストが有効なままです。実装がコンテキストの有効期限をサポートしない場合、値GSS_C_INDEFINITEが返されます。必要でない場合はnullを指定します。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_CONTINUE_NEEDED Indicates that a token from the peer application is required to complete the context, and that gss_init_sec_context must be called again with that token.",
      "ja": "gss_s_continue_neededは、コンテキストを完了するためにピアアプリケーションからのトークンが必要であり、gss_init_sec_contextをそのトークンで再度呼び出す必要があることを示します。"
    },
    {
      "indent": 3,
      "text": "GSS_S_DEFECTIVE_TOKEN Indicates that consistency checks performed on the input_token failed",
      "ja": "gss_s_defective_tokenは、input_tokenで実行された一貫性チェックが失敗したことを示します"
    },
    {
      "indent": 3,
      "text": "GSS_S_DEFECTIVE_CREDENTIAL Indicates that consistency checks performed on the credential failed.",
      "ja": "GSS_S_DEFECTIVE_CREDENTIALは、資格認定で実行された一貫性チェックが失敗したことを示します。"
    },
    {
      "indent": 3,
      "text": "GSS_S_NO_CRED The supplied credentials were not valid for context initiation, or the credential handle did not reference any credentials.",
      "ja": "GSS_S_NO_CRED付属の資格情報は、コンテキストの開始に対して有効ではないか、資格情報が資格情報を参照しませんでした。"
    },
    {
      "indent": 3,
      "text": "GSS_S_CREDENTIALS_EXPIRED The referenced credentials have expired GSS_S_BAD_BINDINGS The input_token contains different channel bindings to those specified via the input_chan_bindings parameter",
      "ja": "GSS_S_CREDENTIALS_EXPIRED参照資格情報が有効期限が切れているGSS_S_BAD_BINDINGS input_tokenには、input_chan_bindingsパラメーターを介して指定されたものに異なるチャネルバインディングが含まれています"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_SIG The input_token contains an invalid MIC, or a MIC that could not be verified",
      "ja": "gss_s_bad_sig input_tokenには無効なマイク、または検証できないマイクが含まれています"
    },
    {
      "indent": 3,
      "text": "GSS_S_OLD_TOKEN The input_token was too old. This is a fatal error during context establishment",
      "ja": "gss_s_old_token input_tokenは古すぎました。これは、コンテキスト確立中の致命的なエラーです"
    },
    {
      "indent": 3,
      "text": "GSS_S_DUPLICATE_TOKEN The input_token is valid, but is a duplicate of a token already processed. This is a fatal error during context establishment.",
      "ja": "gss_s_duplicate_token input_tokenは有効ですが、すでに処理されているトークンの複製です。これは、コンテキスト確立中の致命的なエラーです。"
    },
    {
      "indent": 3,
      "text": "GSS_S_NO_CONTEXT Indicates that the supplied context handle did not refer to a valid context",
      "ja": "GSS_S_NO_CONTEXTは、提供されたコンテキストハンドルが有効なコンテキストを参照しなかったことを示します"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_NAMETYPE The provided target_name parameter contained an invalid or unsupported type of name",
      "ja": "GSS_S_BAD_NAMETYPE提供されたターゲット_NAMEパラメーターには、無効またはサポートされていないタイプの名前が含まれていました"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_NAME The provided target_name parameter was ill-formed.",
      "ja": "GSS_S_BAD_NAME提供されたターゲット_NAMEパラメーターは不正に形成されました。"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_MECH The specified mechanism is not supported by the provided credential, or is unrecognized by the implementation.",
      "ja": "GSS_S_BAD_MECH指定されたメカニズムは、提供された資格によってサポートされていないか、実装によって認識されません。"
    },
    {
      "indent": 0,
      "text": "5.20. gss_inquire_context",
      "section_title": true,
      "ja": "5.20. gss_inquire_context"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_inquire_context ( OM_uint32 *minor_status, const gss_ctx_id_t context_handle, gss_name_t *src_name, gss_name_t *targ_name, OM_uint32 *lifetime_rec, gss_OID *mech_type, OM_uint32 *ctx_flags, int *locally_initiated, int *open )",
      "ja": "om_uint32 gss_inquire_context（om_uint32 *minor_status、const gss_ctx_id_t context_handle、gss_name_t *src_name、gss_name_t *targ_name、om_uint32 *ctip32 *ctpfe extimex itiated、int *open）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Obtains information about a security context. The caller must already have obtained a handle that refers to the context, although the context need not be fully established.",
      "ja": "セキュリティコンテキストに関する情報を取得します。コンテキストを完全に確立する必要はありませんが、発信者は既にコンテキストを参照するハンドルを取得している必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します"
    },
    {
      "indent": 3,
      "text": "context_handle gss_ctx_id_t, read A handle that refers to the security context.",
      "ja": "Context_handle gss_ctx_id_t、セキュリティコンテキストを指すハンドルを読んでください。"
    },
    {
      "indent": 3,
      "text": "src_name gss_name_t, modify, optional The name of the context initiator. If the context was established using anonymous authentication, and if the application invoking gss_inquire_context is the context acceptor, an anonymous name will be returned. Storage associated with this name must be freed by the application after use with a call to gss_release_name(). Specify NULL if not required.",
      "ja": "src_name gss_name_t、modify、オプションのコンテキストイニシエーターの名前。匿名認証を使用してコンテキストが確立され、gss_inquire_contextを呼び出すアプリケーションがコンテキストアクセプターである場合、匿名名が返されます。この名前に関連付けられたストレージは、GSS_RELEASE_NAME（）を呼び出して使用した後、アプリケーションによって解放する必要があります。必要でない場合はnullを指定します。"
    },
    {
      "indent": 3,
      "text": "targ_name gss_name_t, modify, optional The name of the context acceptor. Storage associated with this name must be freed by the application after use with a call to gss_release_name(). If the context acceptor did not authenticate itself, and if the initiator did not specify a target name in its call to gss_init_sec_context(), the value GSS_C_NO_NAME will be returned. Specify NULL if not required.",
      "ja": "targ_name gss_name_t、modify、オプションのコンテキストアクセプターの名前。この名前に関連付けられたストレージは、GSS_RELEASE_NAME（）を呼び出して使用した後、アプリケーションによって解放する必要があります。Context Acceptorがそれ自体を認証しなかった場合、およびイニシエーターがGSS_INIT_SEC_CONTEXT（）への呼び出しでターゲット名を指定しなかった場合、値GSS_C_NO_NAMEが返されます。必要でない場合はnullを指定します。"
    },
    {
      "indent": 3,
      "text": "lifetime_rec Integer, modify, optional The number of seconds for which the context will remain valid. If the context has expired, this parameter will be set to zero. If the implementation does not support context expiration, the value GSS_C_INDEFINITE will be returned. Specify NULL if not required.",
      "ja": "lifetime_rec integer、modify、オプションコンテキストが有効なままである秒数。コンテキストの有効期限が切れた場合、このパラメーターはゼロに設定されます。実装がコンテキストの有効期限をサポートしない場合、値GSS_C_INDEFINITEが返されます。必要でない場合はnullを指定します。"
    },
    {
      "indent": 3,
      "text": "mech_type gss_OID, modify, optional The security mechanism providing the context. The returned OID will be a pointer to static storage that should be treated as read-only by the application; in particular the application should not attempt to free it. Specify NULL if not required.",
      "ja": "mech_type gss_oid、modify、オプションのコンテキストを提供するセキュリティメカニズム。返されたOIDは、アプリケーションによって読み取り専用として扱う必要がある静的ストレージへのポインターとなります。特に、アプリケーションはそれを解放しようとしてはなりません。必要でない場合はnullを指定します。"
    },
    {
      "indent": 3,
      "text": "ctx_flags bit-mask, modify, optional Contains various independent flags, each of which indicates that the context supports (or is expected to support, if ctx_open is false) a specific service option. If not needed, specify NULL. Symbolic names are provided for each flag, and the symbolic names corresponding to the required flags should be logically-ANDed with the ret_flags value to test whether a given option is supported by the context. The flags are:",
      "ja": "ctx_flagsビットマスク、変更、オプションには、さまざまな独立したフラグが含まれています。それぞれが、コンテキストが特定のサービスオプションであることをサポートしている（またはctx_openがfalseの場合はサポートされると予想されることを示しています）。必要ない場合は、nullを指定します。各フラグに対してシンボリック名が提供され、必要なフラグに対応するシンボリック名は、ret_flags値を論理的に配信する必要があります。フラグは次のとおりです。"
    },
    {
      "indent": 21,
      "text": "GSS_C_DELEG_FLAG True - Credentials were delegated from the initiator to the acceptor. False - No credentials were delegated",
      "ja": "GSS_C_DELEG_FLAG True-資格情報はイニシエーターからアクセプターに委任されました。false-資格情報は委任されませんでした"
    },
    {
      "indent": 21,
      "text": "GSS_C_MUTUAL_FLAG True - The acceptor was authenticated to the initiator False - The acceptor did not authenticate itself.",
      "ja": "gss_c_mutual_flag true-アクセプターはイニシエーターのfalseに認証されました - アクセプターはそれ自体を認証しませんでした。"
    },
    {
      "indent": 21,
      "text": "GSS_C_REPLAY_FLAG True - replay of protected messages will be detected False - replayed messages will not be detected",
      "ja": "gss_c_replay_flag true-保護されたメッセージのリプレイが誤って検出されます - リプレイされたメッセージは検出されません"
    },
    {
      "indent": 21,
      "text": "GSS_C_SEQUENCE_FLAG True - out-of-sequence protected messages will be detected False - out-of-sequence messages will not be detected",
      "ja": "gss_c_sequence_flag true-アウトシーケンス保護されたメッセージが検出されます虚偽 - アウトシーケンスメッセージは検出されません"
    },
    {
      "indent": 21,
      "text": "GSS_C_CONF_FLAG True - Confidentiality service may be invoked by calling gss_wrap routine False - No confidentiality service (via gss_wrap) available. gss_wrap will provide message encapsulation, data-origin authentication and integrity services only.",
      "ja": "GSS_C_CONF_FLAG True -GSS_WRAPルーチンFalse -No Confidentlisity Service（GSS_WRAP経由）を利用できるように、COALD GSS_WRAPルーチン-No Calling Cally Callingが呼び出すことができます。GSS_WRAPは、メッセージのカプセル化、データオリジン認証、および整合性サービスのみを提供します。"
    },
    {
      "indent": 21,
      "text": "GSS_C_INTEG_FLAG True - Integrity service may be invoked by calling either gss_get_mic or gss_wrap routines.",
      "ja": "GSS_C_INTEG_FLAG True -Integrity Serviceは、GSS_GET_MICまたはGSS_WRAPルーチンのいずれかを呼び出すことで呼び出される場合があります。"
    },
    {
      "indent": 23,
      "text": "False - Per-message integrity service unavailable.",
      "ja": "false -Message Integrity Serviceは利用できません。"
    },
    {
      "indent": 21,
      "text": "GSS_C_ANON_FLAG True - The initiator's identity will not be revealed to the acceptor. The src_name parameter (if requested) contains an anonymous internal name. False - The initiator has been authenticated normally.",
      "ja": "GSS_C_ANON_FLAG True-イニシエーターの身元はアクセプターには明らかにされません。SRC_NAMEパラメーター（要求された場合）には、匿名の内部名が含まれています。false-イニシエーターは正常に認証されています。"
    },
    {
      "indent": 21,
      "text": "GSS_C_PROT_READY_FLAG True - Protection services (as specified by the states of the GSS_C_CONF_FLAG and GSS_C_INTEG_FLAG) are available for use. False - Protection services (as specified by the states of the GSS_C_CONF_FLAG and GSS_C_INTEG_FLAG) are available only if the context is fully established (i.e. if the open parameter is non-zero).",
      "ja": "gss_c_prot_ready_flag true-保護サービス（GSS_C_CONF_FLAGおよびGSS_C_INTEG_FLAGの状態によって指定されています）が使用できます。false-保護サービス（GSS_C_CONF_FLAGおよびGSS_C_INTEG_FLAGの状態によって指定されているように）は、コンテキストが完全に確立されている場合にのみ使用できます（つまり、オープンパラメーターが非ゼロの場合）。"
    },
    {
      "indent": 21,
      "text": "GSS_C_TRANS_FLAG True - The resultant security context may be transferred to other processes via a call to gss_export_sec_context(). False - The security context is not transferable.",
      "ja": "gss_c_trans_flag true-結果のセキュリティコンテキストは、gss_export_sec_context（）を呼び出すことにより、他のプロセスに転送される場合があります。false-セキュリティコンテキストは転送できません。"
    },
    {
      "indent": 3,
      "text": "locally_initiated Boolean, modify Non-zero if the invoking application is the context initiator. Specify NULL if not required.",
      "ja": "locally_initiated boolean、呼び出しアプリケーションがコンテキストイニシエーターである場合、非ゼロを変更します。必要でない場合はnullを指定します。"
    },
    {
      "indent": 3,
      "text": "open Boolean, modify Non-zero if the context is fully established; Zero if a context-establishment token is expected from the peer application. Specify NULL if not required.",
      "ja": "ブールを開いて、コンテキストが完全に確立されている場合はゼロ以外を変更します。ゼロピアアプリケーションからコンテキスト確立トークンが予想される場合。必要でない場合はnullを指定します。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_NO_CONTEXT The referenced context could not be accessed.",
      "ja": "GSS_S_NO_CONTEXT参照されるコンテキストにアクセスできませんでした。"
    },
    {
      "indent": 0,
      "text": "5.21. gss_inquire_cred",
      "section_title": true,
      "ja": "5.21. GSS_ACQUIRE_CRED"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_inquire_cred ( OM_uint32 *minor_status, const gss_cred_id_t cred_handle, gss_name_t *name, OM_uint32 *lifetime, gss_cred_usage_t *cred_usage, gss_OID_set *mechanisms )",
      "ja": "OM_UINT32 GSS_INQUIRE_CRED（OM_UINT32 *MINTER_STATUS、const GSS_CRED_ID_T CRED_HANDLE、GSS_NAME_T *name、om_uint32 *lifetime、gss_cred_usage_t *cred_usage、gss_set *set *mechisms）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Obtains information about a credential.",
      "ja": "資格情報に関する情報を取得します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します"
    },
    {
      "indent": 3,
      "text": "cred_handle gss_cred_id_t, read A handle that refers to the target credential. Specify GSS_C_NO_CREDENTIAL to inquire about the default initiator principal.",
      "ja": "cred_handle gss_cred_id_t、ターゲット資格情報を指すハンドルを読んでください。GSS_C_NO_CREDENTIALを指定して、デフォルトの開始校長について問い合わせます。"
    },
    {
      "indent": 3,
      "text": "name gss_name_t, modify, optional The name whose identity the credential asserts. Storage associated with this name should be freed by the application after use with a call to gss_release_name(). Specify NULL if not required.",
      "ja": "名前gss_name_t、modify、optionalアイデンティティが認定を主張する名前。この名前に関連付けられたストレージは、GSS_RELEASE_NAME（）への呼び出しで使用後にアプリケーションによって解放される必要があります。必要でない場合はnullを指定します。"
    },
    {
      "indent": 3,
      "text": "lifetime Integer, modify, optional The number of seconds for which the credential will remain valid. If the credential has expired, this parameter will be set to zero. If the implementation does not support credential expiration, the value GSS_C_INDEFINITE will be returned. Specify NULL if not required.",
      "ja": "Lifetime Integer、Modify、Optional資格情報が有効なままである秒数。資格情報の有効期限が切れた場合、このパラメーターはゼロに設定されます。実装が資格情報の有効期限をサポートしていない場合、値GSS_C_INDEFINITEが返されます。必要でない場合はnullを指定します。"
    },
    {
      "indent": 3,
      "text": "cred_usage gss_cred_usage_t, modify, optional How the credential may be used. One of the following: GSS_C_INITIATE GSS_C_ACCEPT GSS_C_BOTH Specify NULL if not required.",
      "ja": "CRED_USAGE GSS_CRED_USAGE_T、変更、オプションの資格情報の使用方法。以下のいずれか：GSS_C_INITIATE GSS_C_ACCEPT GSS_C_OTHが必要ない場合はnullを指定します。"
    },
    {
      "indent": 3,
      "text": "mechanisms gss_OID_set, modify, optional Set of mechanisms supported by the credential. Storage associated with this OID set must be freed by the application after use with a call to gss_release_oid_set(). Specify NULL if not required.",
      "ja": "メカニズムGSS_OID_SET、修正、資格情報によってサポートされるオプションのメカニズムセット。このOIDセットに関連付けられたストレージは、gss_release_oid_set（）を呼び出して使用した後、アプリケーションによって解放される必要があります。必要でない場合はnullを指定します。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_NO_CRED The referenced credentials could not be accessed.",
      "ja": "GSS_S_NO_CRED参照されている資格情報にアクセスできませんでした。"
    },
    {
      "indent": 3,
      "text": "GSS_S_DEFECTIVE_CREDENTIAL The referenced credentials were invalid.",
      "ja": "GSS_S_DEFECTIVE_CREDENITIAL参照資格情報は無効でした。"
    },
    {
      "indent": 3,
      "text": "GSS_S_CREDENTIALS_EXPIRED The referenced credentials have expired. If the lifetime parameter was not passed as NULL, it will be set to 0.",
      "ja": "GSS_S_CREDENTIALS_EXPIRED参照資格情報の有効期限が切れました。寿命パラメーターがnullとして渡されなかった場合、0に設定されます。"
    },
    {
      "indent": 0,
      "text": "5.22. gss_inquire_cred_by_mech",
      "section_title": true,
      "ja": "5.22. gss_inquire_cred_by_mech"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_inquire_cred_by_mech ( OM_uint32 *minor_status, const gss_cred_id_t cred_handle, const gss_OID mech_type, gss_name_t *name, OM_uint32 *initiator_lifetime, OM_uint32 *acceptor_lifetime, gss_cred_usage_t *cred_usage )",
      "ja": "OM_UINT32 GSS_INQUIRE_CRED_BY_MECH（OM_UINT32 *MINTER_STATUS、const GSS_CRED_ID_T CRED_HHANDLE、const gss_oid mech_type、gss_name_t *name、om_uint32 *initiator_lifetime、om_uint32 *acceptor_lifetime"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Obtains per-mechanism information about a credential.",
      "ja": "資格情報に関するメカニズムごとの情報を取得します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します"
    },
    {
      "indent": 3,
      "text": "cred_handle gss_cred_id_t, read A handle that refers to the target credential. Specify GSS_C_NO_CREDENTIAL to inquire about the default initiator principal.",
      "ja": "cred_handle gss_cred_id_t、ターゲット資格情報を指すハンドルを読んでください。GSS_C_NO_CREDENTIALを指定して、デフォルトの開始校長について問い合わせます。"
    },
    {
      "indent": 3,
      "text": "mech_type gss_OID, read The mechanism for which information should be returned.",
      "ja": "mech_type gss_oid、情報を返すべきメカニズムを読んでください。"
    },
    {
      "indent": 3,
      "text": "name gss_name_t, modify, optional The name whose identity the credential asserts. Storage associated with this name must be freed by the application after use with a call to gss_release_name(). Specify NULL if not required.",
      "ja": "名前gss_name_t、modify、optionalアイデンティティが認定を主張する名前。この名前に関連付けられたストレージは、GSS_RELEASE_NAME（）を呼び出して使用した後、アプリケーションによって解放する必要があります。必要でない場合はnullを指定します。"
    },
    {
      "indent": 3,
      "text": "initiator_lifetime Integer, modify, optional The number of seconds for which the credential will remain capable of initiating security contexts under the specified mechanism. If the credential can no longer be used to initiate contexts, or if the credential usage for this mechanism is GSS_C_ACCEPT, this parameter will be set to zero. If the implementation does not support expiration of initiator credentials, the value GSS_C_INDEFINITE will be returned. Specify NULL if not required.",
      "ja": "Initiatator_lifetime Integer、Modify、オプションは、指定されたメカニズムの下でセキュリティコンテキストを開始できる範囲の秒数をオプションします。資格情報を使用してコンテキストを開始することができなくなった場合、またはこのメカニズムの資格情報がGSS_C_ACCEPTである場合、このパラメーターはゼロに設定されます。実装がイニシエーター資格情報の有効期限をサポートしていない場合、値GSS_C_INDEFINITEが返されます。必要でない場合はnullを指定します。"
    },
    {
      "indent": 3,
      "text": "acceptor_lifetime Integer, modify, optional The number of seconds for which the credential will remain capable of accepting security contexts under the specified mechanism. If the credential can no longer be used to accept contexts, or if the credential usage for this mechanism is GSS_C_INITIATE, this parameter will be set to zero.",
      "ja": "Acceptor_lifetime Integer、Modify、オプションは、指定されたメカニズムの下でセキュリティコンテキストを受け入れることができる範囲の秒数をオプションします。資格情報を使用してコンテキストを受け入れることができなくなった場合、またはこのメカニズムの資格情報がGSS_C_INITIATEである場合、このパラメーターはゼロに設定されます。"
    },
    {
      "indent": 21,
      "text": "If the implementation does not support expiration of acceptor credentials, the value GSS_C_INDEFINITE will be returned. Specify NULL if not required.",
      "ja": "実装がアクセプター資格情報の有効期限をサポートしていない場合、値GSS_C_INDEFINITEが返されます。必要でない場合はnullを指定します。"
    },
    {
      "indent": 3,
      "text": "cred_usage gss_cred_usage_t, modify, optional How the credential may be used with the specified mechanism. One of the following: GSS_C_INITIATE GSS_C_ACCEPT GSS_C_BOTH Specify NULL if not required.",
      "ja": "CRED_USAGE GSS_CRED_USAGE_T、修正、オプションのオプション指定されたメカニズムで資格情報を使用する方法。以下のいずれか：GSS_C_INITIATE GSS_C_ACCEPT GSS_C_OTHが必要ない場合はnullを指定します。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_NO_CRED The referenced credentials could not be accessed.",
      "ja": "GSS_S_NO_CRED参照されている資格情報にアクセスできませんでした。"
    },
    {
      "indent": 3,
      "text": "GSS_S_DEFECTIVE_CREDENTIAL The referenced credentials were invalid.",
      "ja": "GSS_S_DEFECTIVE_CREDENITIAL参照資格情報は無効でした。"
    },
    {
      "indent": 3,
      "text": "GSS_S_CREDENTIALS_EXPIRED The referenced credentials have expired. If the lifetime parameter was not passed as NULL, it will be set to 0.",
      "ja": "GSS_S_CREDENTIALS_EXPIRED参照資格情報の有効期限が切れました。寿命パラメーターがnullとして渡されなかった場合、0に設定されます。"
    },
    {
      "indent": 0,
      "text": "5.23. gss_inquire_mechs_for_name",
      "section_title": true,
      "ja": "5.23. gss_inquire_mechs_for_name"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_inquire_mechs_for_name ( OM_uint32 *minor_status, const gss_name_t input_name, gss_OID_set *mech_types )",
      "ja": "OM_UINT32 GSS_INQUIRE_MECHS_FOR_NAME（OM_UINT32 *MINTER_STATUS、const gss_name_t input_name、gss_oid_set *mech_types）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Returns the set of mechanisms supported by the GSS-API implementation that may be able to process the specified name.",
      "ja": "指定された名前を処理できる可能性のあるGSS-API実装によってサポートされるメカニズムのセットを返します。"
    },
    {
      "indent": 3,
      "text": "Each mechanism returned will recognize at least one element within the name. It is permissible for this routine to be implemented within a mechanism-independent GSS-API layer, using the type information contained within the presented name, and based on registration information provided by individual mechanism implementations. This means that the returned mech_types set may indicate that a particular mechanism will understand the name when in fact it would refuse to accept the name as input to gss_canonicalize_name, gss_init_sec_context, gss_acquire_cred or gss_add_cred (due to some property of the specific name, as opposed to the name type). Thus this routine should be used only as a pre-filter for a call to a subsequent mechanism-specific routine.",
      "ja": "返される各メカニズムは、名前内の少なくとも1つの要素を認識します。このルーチンは、提示された名前に含まれるタイプ情報を使用し、個々のメカニズムの実装によって提供される登録情報に基づいて、メカニズムに依存しないGSS-APIレイヤー内で実装されることが許されます。これは、返されたmech_typesセットが、特定のメカニズムが名前を理解することを示す可能性があることを意味することを意味します。実際には、gss_canonicalize_name、gss_init_sec_context、gss_acquire_credまたはgss_add_credの入力として名前を受け入れることを拒否することを拒否することを意味します（特定の名前のある財産のため、特定の名前のために、ある程度、ある程度、特定の名前の財産のためです。名前タイプ）。したがって、このルーチンは、その後のメカニズム固有のルーチンを呼び出すための事前フィルターとしてのみ使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Implementation specific status code.",
      "ja": "minor_status integer、実装固有のステータスコードを変更します。"
    },
    {
      "indent": 3,
      "text": "input_name gss_name_t, read The name to which the inquiry relates.",
      "ja": "input_name gss_name_t、問い合わせが関連する名前を読んでください。"
    },
    {
      "indent": 3,
      "text": "mech_types gss_OID_set, modify Set of mechanisms that may support the specified name. The returned OID set must be freed by the caller after use with a call to gss_release_oid_set().",
      "ja": "mech_types gss_oid_set、指定された名前をサポートする可能性のあるメカニズムのセットを変更します。返されたOIDセットは、gss_release_oid_set（）を呼び出して使用した後、発信者によって解放されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_NAME The input_name parameter was ill-formed.",
      "ja": "gss_s_bad_name input_nameパラメーターは不正に形成されました。"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_NAMETYPE The input_name parameter contained an invalid or unsupported type of name",
      "ja": "gss_s_bad_nameType input_nameパラメーターには無効またはサポートされていないタイプの名前が含まれていました"
    },
    {
      "indent": 0,
      "text": "5.24. gss_inquire_names_for_mech",
      "section_title": true,
      "ja": "5.24. gss_inquire_names_for_mech"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_inquire_names_for_mech ( OM_uint32 *minor_status, const gss_OID mechanism, gss_OID_set *name_types)",
      "ja": "OM_UINT32 GSS_INQUIRE_NAMES_FOR_MECH（OM_UINT32 *MINTER_STATUS、const GSS_OIDメカニズム、GSS_OID_SET *name_types）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Returns the set of nametypes supported by the specified mechanism.",
      "ja": "指定されたメカニズムによってサポートされているネームタイプのセットを返します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Implementation specific status code.",
      "ja": "minor_status integer、実装固有のステータスコードを変更します。"
    },
    {
      "indent": 3,
      "text": "mechanism gss_OID, read The mechanism to be interrogated.",
      "ja": "メカニズムgss_oid、尋問するメカニズムを読みます。"
    },
    {
      "indent": 3,
      "text": "name_types gss_OID_set, modify Set of name-types supported by the specified mechanism. The returned OID set must be freed by the application after use with a call to gss_release_oid_set().",
      "ja": "name_types gss_oid_set、指定されたメカニズムでサポートされている名前タイプのセットを変更します。返されたOIDセットは、gss_release_oid_set（）を呼び出して使用した後、アプリケーションによって解放されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 0,
      "text": "5.25. gss_process_context_token",
      "section_title": true,
      "ja": "5.25. gss_process_context_token"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_process_context_token ( OM_uint32 *minor_status, const gss_ctx_id_t context_handle, const gss_buffer_t token_buffer)",
      "ja": "OM_UINT32 GSS_PROCESS_CONTEXT_TOKEN（OM_UINT32 *minor_status、const gss_ctx_id_t context_handle、const gss_buffer_t token_buffer）"
    },
    {
      "indent": 8,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Provides a way to pass an asynchronous token to the security service. Most context-level tokens are emitted and processed synchronously by gss_init_sec_context and gss_accept_sec_context, and the application is informed as to whether further tokens are expected by the GSS_C_CONTINUE_NEEDED major status bit. Occasionally, a mechanism may need to emit a context-level token at a point when the peer entity is not expecting a token. For example, the initiator's final call to gss_init_sec_context may emit a token and return a status of GSS_S_COMPLETE, but the acceptor's call to gss_accept_sec_context may fail. The acceptor's mechanism may wish to send a token containing an error indication to the initiator, but the initiator is not expecting a token at this point, believing that the context is fully established. Gss_process_context_token provides a way to pass such a token to the mechanism at any time.",
      "ja": "非同期トークンをセキュリティサービスに渡す方法を提供します。ほとんどのコンテキストレベルのトークンは、GSS_INIT_SEC_CONTEXTとGSS_ACCEPT_SEC_CONTEXTによって放出および処理され、GSS_C_CONTINUE_NEEDED主要なステータスビットによってさらにトークンが予想されるかどうかについてアプリケーションに通知されます。時折、ピアエンティティがトークンを期待していない時点で、メカニズムがコンテキストレベルのトークンを放出する必要がある場合があります。たとえば、GSS_INIT_SEC_CONTEXTへのイニシエーターの最終呼び出しは、トークンを発射し、GSS_S_Completeのステータスを返す場合がありますが、GSS_ACCEPT_SEC_CONTEXTへのアクセプターの呼び出しは失敗する場合があります。アクセプターのメカニズムは、エラー表示を含むトークンをイニシエーターに送信したい場合がありますが、イニシエーターは、コンテキストが完全に確立されていると信じて、この時点でトークンを期待していません。GSS_PROCESS_CONTEXT_TOKENは、そのようなトークンをいつでもメカニズムに渡す方法を提供します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Implementation specific status code.",
      "ja": "minor_status integer、実装固有のステータスコードを変更します。"
    },
    {
      "indent": 3,
      "text": "context_handle gss_ctx_id_t, read context handle of context on which token is to be processed",
      "ja": "Context_handle gss_ctx_id_t、トークンが処理されるコンテキストのコンテキストハンドルを読む"
    },
    {
      "indent": 3,
      "text": "token_buffer buffer, opaque, read token to process",
      "ja": "token_bufferバッファー、不透明は、トークンを読んで処理します"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_DEFECTIVE_TOKEN Indicates that consistency checks performed on the token failed",
      "ja": "gss_s_defective_tokenは、トークンで実行された一貫性チェックが失敗したことを示します"
    },
    {
      "indent": 3,
      "text": "GSS_S_NO_CONTEXT The context_handle did not refer to a valid context",
      "ja": "gss_s_no_context context_handleは有効なコンテキストを参照しませんでした"
    },
    {
      "indent": 0,
      "text": "5.26. gss_release_buffer",
      "section_title": true,
      "ja": "5.26. GSS_RELEASE_BUFFER"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_release_buffer ( OM_uint32 *minor_status, gss_buffer_t buffer)",
      "ja": "OM_UINT32 GSS_RELEASE_BUFFER（OM_UINT32 *MINTER_STATUS、GSS_BUFFER_Tバッファー）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Free storage associated with a buffer. The storage must have been allocated by a GSS-API routine. In addition to freeing the associated storage, the routine will zero the length field in the descriptor to which the buffer parameter refers, and implementations are encouraged to additionally set the pointer field in the descriptor to NULL. Any buffer object returned by a GSS-API routine may be passed to gss_release_buffer (even if there is no storage associated with the buffer).",
      "ja": "バッファに関連付けられた無料ストレージ。ストレージは、GSS-APIルーチンによって割り当てられている必要があります。関連するストレージを解放することに加えて、ルーチンはバッファーパラメーターが参照する記述子の長さフィールドをゼロにし、記述子のポインターフィールドをさらにnullに設定することを実装することが奨励されます。GSS-APIルーチンによって返されるバッファオブジェクトは、GSS_RELEASE_BUFFERに渡される場合があります（バッファに関連付けられたストレージがない場合でも）。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します"
    },
    {
      "indent": 3,
      "text": "buffer buffer, modify The storage associated with the buffer will be deleted. The gss_buffer_desc object will not be freed, but its length field will be zeroed.",
      "ja": "バッファバッファー、バッファに関連付けられたストレージを変更すると削除されます。GSS_BUFFER_DESCオブジェクトは解放されませんが、その長さフィールドはゼロになります。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 0,
      "text": "5.27. gss_release_cred",
      "section_title": true,
      "ja": "5.27. GSS_RELEASE_CRED"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_release_cred ( OM_uint32 *minor_status, gss_cred_id_t *cred_handle)",
      "ja": "OM_UINT32 GSS_RELEASE_CRED（OM_UINT32 *MINTER_STATUS、GSS_CRED_ID_T *CRED_HANDLE）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Informs GSS-API that the specified credential handle is no longer required by the application, and frees associated resources. Implementations are encouraged to set the cred_handle to GSS_C_NO_CREDENTIAL on successful completion of this call.",
      "ja": "GSS-APIに、指定された資格情報がアプリケーションで不要になったことを通知し、関連するリソースを解放します。実装は、この呼び出しが正常に完了したときにCRED_HANDLEをGSS_C_NO_CREDENTIALに設定することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "cred_handle gss_cred_id_t, modify, optional Opaque handle identifying credential to be released. If GSS_C_NO_CREDENTIAL is supplied, the routine will complete successfully, but will do nothing.",
      "ja": "CRED_HANDLE GSS_CRED_ID_T、変更、オプションの不透明なハンドルは、リリースされる資格情報を識別します。GSS_C_NO_CREDENTIALが提供された場合、ルーチンは正常に完了しますが、何もしません。"
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code.",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_NO_CRED Credentials could not be accessed.",
      "ja": "GSS_S_NO_CRED資格情報にアクセスできませんでした。"
    },
    {
      "indent": 0,
      "text": "5.28. gss_release_name",
      "section_title": true,
      "ja": "5.28. GSS_RELEASE_NAME"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_release_name ( OM_uint32 *minor_status, gss_name_t *name)",
      "ja": "om_uint32 gss_release_name（om_uint32 *minor_status、gss_name_t *name）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Free GSSAPI-allocated storage associated with an internal-form name. Implementations are encouraged to set the name to GSS_C_NO_NAME on successful completion of this call.",
      "ja": "内部形式名に関連付けられた無料のgssapi-allocatedストレージ。実装は、この呼び出しが正常に完了したときにGSS_C_NO_NAMEに名前を設定することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します"
    },
    {
      "indent": 3,
      "text": "name gss_name_t, modify The name to be deleted",
      "ja": "名前gss_name_t、削除する名前を変更します"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_NAME The name parameter did not contain a valid name",
      "ja": "gss_s_bad_name nameパラメーターには有効な名前が含まれていませんでした"
    },
    {
      "indent": 0,
      "text": "5.29. gss_release_oid_set",
      "section_title": true,
      "ja": "5.29. gss_release_oid_set"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_release_oid_set ( OM_uint32 *minor_status, gss_OID_set *set)",
      "ja": "OM_UINT32 GSS_RELEASE_OID_SET（OM_UINT32 *minor_status、gss_oid_set *set）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Free storage associated with a GSSAPI-generated gss_OID_set object. The set parameter must refer to an OID-set that was returned from a GSS-API routine. gss_release_oid_set() will free the storage associated with each individual member OID, the OID set's elements array, and the gss_OID_set_desc.",
      "ja": "GSSAPIに生成されたGSS_OID_SETオブジェクトに関連付けられた無料ストレージ。SETパラメーターは、GSS-APIルーチンから返されたOIDセットを参照する必要があります。GSS_RELEASE_OID_SET（）は、個々のメンバーのOID、OIDセットの要素アレイ、およびGSS_OID_SET_DESCに関連付けられたストレージを解放します。"
    },
    {
      "indent": 3,
      "text": "Implementations are encouraged to set the gss_OID_set parameter to GSS_C_NO_OID_SET on successful completion of this routine.",
      "ja": "実装は、このルーチンの正常に完了したときにGSS_OID_SETパラメーターをGSS_C_NO_OID_SETに設定することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します"
    },
    {
      "indent": 3,
      "text": "set Set of Object IDs, modify The storage associated with the gss_OID_set will be deleted.",
      "ja": "オブジェクトIDのセット、GSS_OID_SETに関連付けられたストレージを変更すると削除されます。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 0,
      "text": "5.30. gss_test_oid_set_member",
      "section_title": true,
      "ja": "5.30. gss_test_oid_set_member"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_test_oid_set_member ( OM_uint32 *minor_status, const gss_OID member, const gss_OID_set set, int *present)",
      "ja": "OM_UINT32 GSS_TEST_OID_SET_MEMBER（OM_UINT32 *MINTER_STATUS、const GSS_OIDメンバー、const gss_oid_set set、int *estrent）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Interrogate an Object Identifier set to determine whether a specified Object Identifier is a member. This routine is intended to be used with OID sets returned by gss_indicate_mechs(), gss_acquire_cred(), and gss_inquire_cred(), but will also work with user-generated sets.",
      "ja": "指定されたオブジェクト識別子がメンバーであるかどうかを判断するために、オブジェクト識別子セットを尋問します。このルーチンは、gss_indicate_mechs（）、gss_acquire_cred（）、およびgss_inquire_cred（）によって返されるoidセットで使用することを目的としていますが、ユーザー生成セットでも動作します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します"
    },
    {
      "indent": 3,
      "text": "member Object ID, read The object identifier whose presence is to be tested.",
      "ja": "メンバーオブジェクトID、存在をテストするオブジェクト識別子を読み取ります。"
    },
    {
      "indent": 3,
      "text": "set Set of Object ID, read The Object Identifier set.",
      "ja": "オブジェクトIDのセットセット、オブジェクト識別子セットを読み取ります。"
    },
    {
      "indent": 3,
      "text": "present Boolean, modify non-zero if the specified OID is a member of the set, zero if not.",
      "ja": "現在のブール、指定されたOIDがセットのメンバーである場合はゼロ以外を変更します。そうでない場合はゼロです。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 0,
      "text": "5.31. gss_unwrap",
      "section_title": true,
      "ja": "5.31. gss_unwrap"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_unwrap ( OM_uint32 *minor_status, const gss_ctx_id_t context_handle, const gss_buffer_t input_message_buffer, gss_buffer_t output_message_buffer, int *conf_state, gss_qop_t *qop_state)",
      "ja": "OM_UINT32 GSS_UNWRAP（OM_UINT32 *MINTER_STATUS、const GSS_CTX_ID_T Context_handle、const GSS_Buffer_t input_message_buffer、gss_buffer_t output_message_buffer、int *"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Converts a message previously protected by gss_wrap back to a usable form, verifying the embedded MIC. The conf_state parameter indicates whether the message was encrypted; the qop_state parameter indicates the strength of protection that was used to provide the confidentiality and integrity services.",
      "ja": "GSS_WRAPによって以前に保護されていたメッセージを使用可能なフォームに変換し、埋め込みマイクを確認します。conf_stateパラメーターは、メッセージが暗号化されたかどうかを示します。QOP_STATEパラメーターは、機密性と整合性サービスを提供するために使用された保護の強度を示します。"
    },
    {
      "indent": 3,
      "text": "Since some application-level protocols may wish to use tokens emitted by gss_wrap() to provide \"secure framing\", implementations must support the wrapping and unwrapping of zero-length messages.",
      "ja": "一部のアプリケーションレベルのプロトコルは、gss_wrap（）によって放出されたトークンを使用して「セキュアフレーミング」を提供する場合があるため、実装はゼロ長さのメッセージのラッピングとアンラッピングをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code.",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します。"
    },
    {
      "indent": 3,
      "text": "context_handle gss_ctx_id_t, read Identifies the context on which the message arrived",
      "ja": "Context_handle gss_ctx_id_t、読み取りメッセージが届いたコンテキストを識別します"
    },
    {
      "indent": 3,
      "text": "input_message_buffer buffer, opaque, read protected message",
      "ja": "input_message_bufferバッファ、不透明、保護されたメッセージを読み取ります"
    },
    {
      "indent": 3,
      "text": "output_message_buffer buffer, opaque, modify Buffer to receive unwrapped message. Storage associated with this buffer must be freed by the application after use use with a call to gss_release_buffer().",
      "ja": "output_message_bufferバッファー、不透明、バッファを変更して、包まれていないメッセージを受信します。このバッファに関連付けられたストレージは、gss_release_buffer（）への呼び出しで使用した後、アプリケーションによって解放される必要があります。"
    },
    {
      "indent": 3,
      "text": "conf_state boolean, modify, optional Non-zero - Confidentiality and integrity protection were used Zero - Integrity service only was used Specify NULL if not required",
      "ja": "conf_state boolean、modify、オプションの非ゼロ - 機密性と整合性保護が使用されましたゼロ - 整合性サービスのみが使用され、必要でない場合はnullを指定しました"
    },
    {
      "indent": 3,
      "text": "qop_state gss_qop_t, modify, optional Quality of protection provided. Specify NULL if not required",
      "ja": "QOP_STATE GSS_QOP_T、変更、オプションの保護品質が提供されます。必要でない場合はnullを指定します"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_DEFECTIVE_TOKEN The token failed consistency checks",
      "ja": "gss_s_defective_tokenトークンの失敗した一貫性チェック"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_SIG The MIC was incorrect",
      "ja": "GSS_S_BAD_SIGマイクは間違っていました"
    },
    {
      "indent": 3,
      "text": "GSS_S_DUPLICATE_TOKEN The token was valid, and contained a correct MIC for the message, but it had already been processed",
      "ja": "gss_s_duplicate_tokenトークンは有効で、メッセージの正しいマイクが含まれていましたが、すでに処理されていました"
    },
    {
      "indent": 3,
      "text": "GSS_S_OLD_TOKEN The token was valid, and contained a correct MIC for the message, but it is too old to check for duplication.",
      "ja": "gss_s_old_tokenトークンは有効で、メッセージに正しいマイクが含まれていましたが、重複をチェックするには古すぎます。"
    },
    {
      "indent": 3,
      "text": "GSS_S_UNSEQ_TOKEN The token was valid, and contained a correct MIC for the message, but has been verified out of sequence; a later token has already been received.",
      "ja": "GSS_S_UNSEQ_TOKEN TOKENは有効であり、メッセージの正しいマイクが含まれていましたが、シーケンスから検証されています。後のトークンはすでに受信されています。"
    },
    {
      "indent": 3,
      "text": "GSS_S_GAP_TOKEN The token was valid, and contained a correct MIC for the message, but has been verified out of sequence; an earlier expected token has not yet been received.",
      "ja": "gss_s_gap_tokenトークンは有効であり、メッセージの正しいマイクが含まれていましたが、シーケンスから検証されています。以前の予想されるトークンはまだ受け取られていません。"
    },
    {
      "indent": 3,
      "text": "GSS_S_CONTEXT_EXPIRED The context has already expired",
      "ja": "GSS_S_CONTEXT_EXPIREDコンテキストはすでに期限切れになっています"
    },
    {
      "indent": 3,
      "text": "GSS_S_NO_CONTEXT The context_handle parameter did not identify a valid context",
      "ja": "gss_s_no_context context_handleパラメーターは有効なコンテキストを識別しませんでした"
    },
    {
      "indent": 0,
      "text": "5.32. gss_verify_mic",
      "section_title": true,
      "ja": "5.32. gss_verify_mic"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_verify_mic ( OM_uint32 *minor_status, const gss_ctx_id_t context_handle, const gss_buffer_t message_buffer, const gss_buffer_t token_buffer, gss_qop_t *qop_state)",
      "ja": "om_uint32 gss_verify_mic（om_uint32 *minor_status、const gss_ctx_id_t context_handle、const gss_buffer_t message_buffer_t token_buffer、gss_qop_t *qop_state）"
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Verifies that a cryptographic MIC, contained in the token parameter, fits the supplied message. The qop_state parameter allows a message recipient to determine the strength of protection that was applied to the message.",
      "ja": "トークンパラメーターに含まれる暗号化マイクが提供されたメッセージに適合することを確認します。QOP_STATEパラメーターにより、メッセージ受信者はメッセージに適用された保護の強度を決定できます。"
    },
    {
      "indent": 3,
      "text": "Since some application-level protocols may wish to use tokens emitted by gss_wrap() to provide \"secure framing\", implementations must support the calculation and verification of MICs over zero-length messages.",
      "ja": "一部のアプリケーションレベルのプロトコルは、gss_wrap（）によって放出されたトークンを使用して「セキュアフレーミング」を提供する場合があるため、実装はゼロ長さのメッセージを超えるMICの計算と検証をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code.",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します。"
    },
    {
      "indent": 3,
      "text": "context_handle gss_ctx_id_t, read Identifies the context on which the message arrived",
      "ja": "Context_handle gss_ctx_id_t、読み取りメッセージが届いたコンテキストを識別します"
    },
    {
      "indent": 3,
      "text": "message_buffer buffer, opaque, read Message to be verified",
      "ja": "message_bufferバッファ、不透明、メッセージを読む"
    },
    {
      "indent": 3,
      "text": "token_buffer buffer, opaque, read Token associated with message",
      "ja": "token_bufferバッファ、不透明、メッセージに関連付けられたトークンを読む"
    },
    {
      "indent": 3,
      "text": "qop_state gss_qop_t, modify, optional quality of protection gained from MIC Specify NULL if not required",
      "ja": "QOP_STATE GSS_QOP_T、変更、オプションの保護品質MICから得られた品質は、必要でない場合にヌルを指定します"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_DEFECTIVE_TOKEN The token failed consistency checks",
      "ja": "gss_s_defective_tokenトークンの失敗した一貫性チェック"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_SIG The MIC was incorrect",
      "ja": "GSS_S_BAD_SIGマイクは間違っていました"
    },
    {
      "indent": 3,
      "text": "GSS_S_DUPLICATE_TOKEN The token was valid, and contained a correct MIC for the message, but it had already been processed",
      "ja": "gss_s_duplicate_tokenトークンは有効で、メッセージの正しいマイクが含まれていましたが、すでに処理されていました"
    },
    {
      "indent": 3,
      "text": "GSS_S_OLD_TOKEN The token was valid, and contained a correct MIC for the message, but it is too old to check for duplication.",
      "ja": "gss_s_old_tokenトークンは有効で、メッセージに正しいマイクが含まれていましたが、重複をチェックするには古すぎます。"
    },
    {
      "indent": 3,
      "text": "GSS_S_UNSEQ_TOKEN The token was valid, and contained a correct MIC for the message, but has been verified out of sequence; a later token has already been received.",
      "ja": "GSS_S_UNSEQ_TOKEN TOKENは有効であり、メッセージの正しいマイクが含まれていましたが、シーケンスから検証されています。後のトークンはすでに受信されています。"
    },
    {
      "indent": 3,
      "text": "GSS_S_GAP_TOKEN The token was valid, and contained a correct MIC for the message, but has been verified out of sequence; an earlier expected token has not yet been received.",
      "ja": "gss_s_gap_tokenトークンは有効であり、メッセージの正しいマイクが含まれていましたが、シーケンスから検証されています。以前の予想されるトークンはまだ受け取られていません。"
    },
    {
      "indent": 3,
      "text": "GSS_S_CONTEXT_EXPIRED The context has already expired",
      "ja": "GSS_S_CONTEXT_EXPIREDコンテキストはすでに期限切れになっています"
    },
    {
      "indent": 3,
      "text": "GSS_S_NO_CONTEXT The context_handle parameter did not identify a valid context",
      "ja": "gss_s_no_context context_handleパラメーターは有効なコンテキストを識別しませんでした"
    },
    {
      "indent": 0,
      "text": "5.33. gss_wrap",
      "section_title": true,
      "ja": "5.33. gss_wrap"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_wrap (\n  OM_uint32          *minor_status,\n  const gss_ctx_id_t context_handle,\n  int               conf_req_flag,\n  gss_qop_t          qop_req\n  const gss_buffer_t input_message_buffer,\n  int                *conf_state,\n  gss_buffer_t       output_message_buffer )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Attaches a cryptographic MIC and optionally encrypts the specified input_message. The output_message contains both the MIC and the message. The qop_req parameter allows a choice between several cryptographic algorithms, if supported by the chosen mechanism.",
      "ja": "暗号化マイクを取り付け、オプションで指定されたinput_messageを暗号化します。output_messageには、マイクとメッセージの両方が含まれています。QOP_REQパラメーターは、選択したメカニズムでサポートされている場合、いくつかの暗号化アルゴリズムから選択できます。"
    },
    {
      "indent": 3,
      "text": "Since some application-level protocols may wish to use tokens emitted by gss_wrap() to provide \"secure framing\", implementations must support the wrapping of zero-length messages.",
      "ja": "一部のアプリケーションレベルのプロトコルは、gss_wrap（）によって放出されたトークンを使用して「セキュアフレーミング」を提供する場合があるため、実装はゼロ長のメッセージのラッピングをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code.",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します。"
    },
    {
      "indent": 3,
      "text": "context_handle gss_ctx_id_t, read Identifies the context on which the message will be sent",
      "ja": "Context_handle gss_ctx_id_t、読み取りメッセージが送信されるコンテキストを識別します"
    },
    {
      "indent": 3,
      "text": "conf_req_flag boolean, read Non-zero - Both confidentiality and integrity services are requested Zero - Only integrity service is requested",
      "ja": "conf_req_flag boolean、nonゼロを読む - 機密性と整合性サービスの両方がゼロに要求されます - 整合性サービスのみが要求されます"
    },
    {
      "indent": 3,
      "text": "qop_req gss_qop_t, read, optional Specifies required quality of protection. A mechanism-specific default may be requested by setting qop_req to GSS_C_QOP_DEFAULT. If an unsupported protection strength is requested, gss_wrap will return a major_status of GSS_S_BAD_QOP.",
      "ja": "QOP_REQ GSS_QOP_T、読み取り、オプションは、必要な保護品質を指定します。QOP_REQをGSS_C_QOP_DEFAULTに設定することにより、メカニズム固有のデフォルトが要求される場合があります。サポートされていない保護強度が要求された場合、GSS_WRAPはGSS_S_BAD_QOPのMajor_Statusを返します。"
    },
    {
      "indent": 3,
      "text": "input_message_buffer buffer, opaque, read Message to be protected",
      "ja": "input_message_bufferバッファー、不透明、メッセージを読む"
    },
    {
      "indent": 3,
      "text": "conf_state boolean, modify, optional Non-zero - Confidentiality, data origin authentication and integrity services have been applied Zero - Integrity and data origin services only has been applied. Specify NULL if not required",
      "ja": "conf_state boolean、modify、オプションの非ゼロ - 機密性、データオリジン認証、整合性サービスがゼロに適用されています - 整合性とデータオリジンサービスは適用されています。必要でない場合はnullを指定します"
    },
    {
      "indent": 3,
      "text": "output_message_buffer buffer, opaque, modify Buffer to receive protected message. Storage associated with this message must be freed by the application after use with a call to gss_release_buffer().",
      "ja": "output_message_bufferバッファ、不透明、バッファを変更して保護されたメッセージを受信します。このメッセージに関連付けられたストレージは、gss_release_buffer（）への呼び出しで使用後にアプリケーションによって解放される必要があります。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_CONTEXT_EXPIRED The context has already expired",
      "ja": "GSS_S_CONTEXT_EXPIREDコンテキストはすでに期限切れになっています"
    },
    {
      "indent": 3,
      "text": "GSS_S_NO_CONTEXT The context_handle parameter did not identify a valid context",
      "ja": "gss_s_no_context context_handleパラメーターは有効なコンテキストを識別しませんでした"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_QOP The specified QOP is not supported by the mechanism.",
      "ja": "GSS_S_BAD_QOP指定されたQOPは、メカニズムによってサポートされていません。"
    },
    {
      "indent": 0,
      "text": "5.34. gss_wrap_size_limit",
      "section_title": true,
      "ja": "5.34. gss_wrap_size_limit"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_wrap_size_limit (\n  OM_uint32          *minor_status,\n  const gss_ctx_id_t context_handle,\n  int                conf_req_flag,\n  gss_qop_t          qop_req,\n  OM_uint32          req_output_size,\n  OM_uint32          *max_input_size)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Purpose:",
      "ja": "目的："
    },
    {
      "indent": 3,
      "text": "Allows an application to determine the maximum message size that, if presented to gss_wrap with the same conf_req_flag and qop_req parameters, will result in an output token containing no more than req_output_size bytes.",
      "ja": "アプリケーションは、同じconf_req_flagおよびqop_reqパラメーターを使用してgss_wrapに提示された場合、req_output_sizeバイト以外の出力トークンをもたらす最大メッセージサイズを決定できます。"
    },
    {
      "indent": 3,
      "text": "This call is intended for use by applications that communicate over protocols that impose a maximum message size. It enables the application to fragment messages prior to applying protection.",
      "ja": "この呼び出しは、最大メッセージサイズを課すプロトコルを介して通信するアプリケーションで使用することを目的としています。保護を適用する前に、アプリケーションがメッセージをフラグメントすることができます。"
    },
    {
      "indent": 3,
      "text": "GSS-API implementations are recommended but not required to detect invalid QOP values when gss_wrap_size_limit() is called. This routine guarantees only a maximum message size, not the availability of specific QOP values for message protection.",
      "ja": "GSS_WRAP_SIZE_LIMIT（）が呼び出された場合、GSS-APIの実装が推奨されますが、無効なQOP値を検出するためには必要ありません。このルーチンは、メッセージ保護のための特定のQOP値の可用性ではなく、最大メッセージサイズのみを保証します。"
    },
    {
      "indent": 3,
      "text": "Successful completion of this call does not guarantee that gss_wrap will be able to protect a message of length max_input_size bytes, since this ability may depend on the availability of system resources at the time that gss_wrap is called. However, if the implementation itself imposes an upper limit on the length of messages that may be processed by gss_wrap, the implementation should not return a value via max_input_bytes that is greater than this length.",
      "ja": "この呼び出しを正常に完了しても、GSS_WRAPがGSS_WRAPと呼ばれる時点でのシステムリソースの可用性に依存する可能性があるため、GSS_WRAPが長さのmax_input_sizeバイトのメッセージを保護できることを保証しません。ただし、実装自体がGSS_WRAPによって処理される可能性のあるメッセージの長さに上限を課す場合、実装はこの長さよりも大きいMAX_INPUT_BYTESを介して値を返すべきではありません。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 3,
      "text": "minor_status Integer, modify Mechanism specific status code",
      "ja": "minor_status Integer、メカニズム固有のステータスコードを変更します"
    },
    {
      "indent": 3,
      "text": "context_handle gss_ctx_id_t, read A handle that refers to the security over which the messages will be sent.",
      "ja": "Context_handle gss_ctx_id_t、メッセージが送信されるセキュリティを指すハンドルを読んでください。"
    },
    {
      "indent": 3,
      "text": "conf_req_flag Boolean, read Indicates whether gss_wrap will be asked to apply confidentiality protection in addition to integrity protection. See the routine description for gss_wrap for more details.",
      "ja": "conf_req_flag boolean、readは、GSS_WRAPが整合性保護に加えて機密保護を適用するように求められるかどうかを示します。詳細については、gss_wrapの定期的な説明を参照してください。"
    },
    {
      "indent": 3,
      "text": "qop_req gss_qop_t, read Indicates the level of protection that gss_wrap will be asked to provide. See the routine description for gss_wrap for more details.",
      "ja": "QOP_REQ GSS_QOP_T、読み取りは、GSS_WRAPが提供するように求められる保護レベルを示します。詳細については、gss_wrapの定期的な説明を参照してください。"
    },
    {
      "indent": 3,
      "text": "req_output_size Integer, read The desired maximum size for tokens emitted by gss_wrap.",
      "ja": "req_output_size integer、gss_wrapによって放出されたトークンの目的の最大サイズを読み取ります。"
    },
    {
      "indent": 3,
      "text": "max_input_size Integer, modify The maximum input message size that may be presented to gss_wrap in order to guarantee that the emitted token shall be no larger than req_output_size bytes.",
      "ja": "MAX_INPUT_SIZE INTEGERは、EMITEDトークンがREQ_OUTPUT_SIZEバイトよりも大きくないことを保証するために、GSS_WRAPに提示される可能性のある最大入力メッセージサイズを変更します。"
    },
    {
      "indent": 3,
      "text": "Function value: GSS status code",
      "ja": "関数値：GSSステータスコード"
    },
    {
      "indent": 3,
      "text": "GSS_S_COMPLETE Successful completion",
      "ja": "gss_s_complete正常に完了しました"
    },
    {
      "indent": 3,
      "text": "GSS_S_NO_CONTEXT The referenced context could not be accessed.",
      "ja": "GSS_S_NO_CONTEXT参照されるコンテキストにアクセスできませんでした。"
    },
    {
      "indent": 3,
      "text": "GSS_S_CONTEXT_EXPIRED The context has expired.",
      "ja": "GSS_S_CONTEXT_EXPIREDコンテキストの有効期限が切れています。"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_QOP The specified QOP is not supported by the mechanism.",
      "ja": "GSS_S_BAD_QOP指定されたQOPは、メカニズムによってサポートされていません。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document specifies a service interface for security facilities and services; as such, security considerations appear throughout the specification. Nonetheless, it is appropriate to summarize certain specific points relevant to GSS-API implementors and calling applications. Usage of the GSS-API interface does not in itself provide security services or assurance; instead, these attributes are dependent on the underlying mechanism(s) which support a GSS-API implementation. Callers must be attentive to the requests made to GSS-API calls and to the status indicators returned by GSS-API, as these specify the security service characteristics which GSS-API will provide. When the interprocess context transfer facility is used, appropriate local controls should be applied to constrain access to interprocess tokens and to the sensitive data which they contain.",
      "ja": "このドキュメントは、セキュリティ機能とサービスのサービスインターフェイスを指定します。そのため、セキュリティの考慮事項は仕様全体に表示されます。それにもかかわらず、GSS-APIの実装者と呼び出しアプリケーションに関連する特定の特定のポイントを要約することが適切です。GSS-APIインターフェイスの使用自体は、セキュリティサービスまたは保証を提供しません。代わりに、これらの属性は、GSS-APIの実装をサポートする基礎となるメカニズムに依存します。発信者は、GSS-APIによって返されるGSS-APIコールとGSS-APIによって返されるステータスインジケーターに行われたリクエストに注意を払う必要があります。インタープロセスコンテキスト転送施設を使用する場合、適切なローカルコントロールを適用して、インタープロセストークンとそれらに含まれる機密データへのアクセスを制約する必要があります。"
    },
    {
      "indent": 3,
      "text": "Appendix A. GSS-API C header file gssapi.h",
      "ja": "付録A. GSS-API CヘッダーファイルGSSAPI.H"
    },
    {
      "indent": 3,
      "text": "C-language GSS-API implementations should include a copy of the following header-file.",
      "ja": "CランゲージGSS-API実装には、次のヘッダーファイルのコピーを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "#ifndef GSSAPI_H_ #define GSSAPI_H_",
      "ja": "#ifndef gssapi_h_ #define gssapi_h_"
    },
    {
      "indent": 3,
      "text": "/*\n * First, include stddef.h to get size_t defined.\n */\n#include <stddef.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * If the platform supports the xom.h header file, it should be\n * included here.\n */\n#include <xom.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Now define the three implementation-dependent types.\n */\ntypedef <platform-specific> gss_ctx_id_t;\ntypedef <platform-specific> gss_cred_id_t;\ntypedef <platform-specific> gss_name_t;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * The following type must be defined as the smallest natural\n * unsigned integer supported by the platform that has at least\n * 32 bits of precision.\n */\ntypedef <platform-specific> gss_uint32;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifdef OM_STRING\n/*\n * We have included the xom.h header file.  Verify that OM_uint32\n * is defined correctly.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#if sizeof(gss_uint32) != sizeof(OM_uint32)\n#error Incompatible definition of OM_uint32 from xom.h\n#endif",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef OM_object_identifier gss_OID_desc, *gss_OID;",
      "ja": "typedef om_object_identifier gss_oid_desc、 *gss_oid;"
    },
    {
      "indent": 3,
      "text": "#else",
      "ja": "＃それ以外"
    },
    {
      "indent": 3,
      "text": "/*\n * We can't use X/Open definitions, so roll our own.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef gss_uint32 OM_uint32;",
      "ja": "typedef gss_uint32 om_uint32;"
    },
    {
      "indent": 3,
      "text": "typedef struct gss_OID_desc_struct {\n  OM_uint32 length;\n  void      *elements;\n} gss_OID_desc, *gss_OID;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 3,
      "text": "typedef struct gss_OID_set_desc_struct  {\n  size_t     count;\n  gss_OID    elements;\n} gss_OID_set_desc, *gss_OID_set;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef struct gss_buffer_desc_struct {\n  size_t length;\n  void *value;\n} gss_buffer_desc, *gss_buffer_t;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef struct gss_channel_bindings_struct {\n  OM_uint32 initiator_addrtype;\n  gss_buffer_desc initiator_address;\n  OM_uint32 acceptor_addrtype;\n  gss_buffer_desc acceptor_address;\n  gss_buffer_desc application_data;\n} *gss_channel_bindings_t;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * For now, define a QOP-type as an OM_uint32\n */\ntypedef OM_uint32 gss_qop_t;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef int gss_cred_usage_t;",
      "ja": "typedef int gss_cred_usage_t;"
    },
    {
      "indent": 3,
      "text": "/*\n * Flag bits for context-level services.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define GSS_C_DELEG_FLAG 1 #define GSS_C_MUTUAL_FLAG 2 #define GSS_C_REPLAY_FLAG 4 #define GSS_C_SEQUENCE_FLAG 8 #define GSS_C_CONF_FLAG 16 #define GSS_C_INTEG_FLAG 32 #define GSS_C_ANON_FLAG 64 #define GSS_C_PROT_READY_FLAG 128 #define GSS_C_TRANS_FLAG 256",
      "ja": "#define gss_c_deleg_flag 1 #define gss_c_mutual_flag 2 #define gss_c_replay_flag 4 #define gss_c_sequence_flag 8 _c_prot_ready_flag 128 #define gss_c_trans_flag 256"
    },
    {
      "indent": 3,
      "text": "/*\n * Credential usage options\n */\n#define GSS_C_BOTH     0\n#define GSS_C_INITIATE 1\n#define GSS_C_ACCEPT   2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Status code types for gss_display_status\n */\n#define GSS_C_GSS_CODE  1\n#define GSS_C_MECH_CODE 2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * The constant definitions for channel-bindings address families\n */\n#define GSS_C_AF_UNSPEC     0\n#define GSS_C_AF_LOCAL      1\n#define GSS_C_AF_INET       2\n#define GSS_C_AF_IMPLINK    3\n#define GSS_C_AF_PUP        4\n#define GSS_C_AF_CHAOS      5\n#define GSS_C_AF_NS         6\n#define GSS_C_AF_NBS        7\n#define GSS_C_AF_ECMA       8\n#define GSS_C_AF_DATAKIT    9\n#define GSS_C_AF_CCITT      10\n#define GSS_C_AF_SNA        11\n#define GSS_C_AF_DECnet     12\n#define GSS_C_AF_DLI        13\n#define GSS_C_AF_LAT        14\n#define GSS_C_AF_HYLINK     15\n#define GSS_C_AF_APPLETALK  16\n#define GSS_C_AF_BSC        17\n#define GSS_C_AF_DSS        18\n#define GSS_C_AF_OSI        19\n#define GSS_C_AF_X25        21",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define GSS_C_AF_NULLADDR 255",
      "ja": "#define gss_c_af_nulladdr 255"
    },
    {
      "indent": 3,
      "text": "/*\n * Various Null values\n */\n#define GSS_C_NO_NAME ((gss_name_t) 0)\n#define GSS_C_NO_BUFFER ((gss_buffer_t) 0)\n#define GSS_C_NO_OID ((gss_OID) 0)\n#define GSS_C_NO_OID_SET ((gss_OID_set) 0)\n#define GSS_C_NO_CONTEXT ((gss_ctx_id_t) 0)\n#define GSS_C_NO_CREDENTIAL ((gss_cred_id_t) 0)\n#define GSS_C_NO_CHANNEL_BINDINGS ((gss_channel_bindings_t) 0)\n#define GSS_C_EMPTY_BUFFER {0, NULL}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Some alternate names for a couple of the above\n * values.  These are defined for V1 compatibility.\n */\n#define GSS_C_NULL_OID GSS_C_NO_OID\n#define GSS_C_NULL_OID_SET GSS_C_NO_OID_SET",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Define the default Quality of Protection for per-message\n * services.  Note that an implementation that offers multiple\n * levels of QOP may define GSS_C_QOP_DEFAULT to be either zero\n * (as done here) to mean \"default protection\", or to a specific\n * explicit QOP value.  However, a value of 0 should always be\n * interpreted by a GSS-API implementation as a request for the\n * default protection level.\n */\n#define GSS_C_QOP_DEFAULT 0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Expiration time of 2^32-1 seconds means infinite lifetime for a\n * credential or security context\n */\n#define GSS_C_INDEFINITE 0xfffffffful",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * The implementation must reserve static storage for a\n * gss_OID_desc object containing the value\n * {10, (void *)\"\\x2a\\x86\\x48\\x86\\xf7\\x12\"\n * \"\\x01\\x02\\x01\\x01\"},\n * corresponding to an object-identifier value of\n * {iso(1) member-body(2) United States(840) mit(113554)\n * infosys(1) gssapi(2) generic(1) user_name(1)}.  The constant\n * GSS_C_NT_USER_NAME should be initialized to point\n * to that gss_OID_desc.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " */ extern gss_OID GSS_C_NT_USER_NAME;",
      "ja": "*/ extern gss_oid gss_c_nt_user_name;"
    },
    {
      "indent": 3,
      "text": "/*\n * The implementation must reserve static storage for a\n * gss_OID_desc object containing the value\n * {10, (void *)\"\\x2a\\x86\\x48\\x86\\xf7\\x12\"\n *              \"\\x01\\x02\\x01\\x02\"},\n * corresponding to an object-identifier value of\n * {iso(1) member-body(2) United States(840) mit(113554)\n * infosys(1) gssapi(2) generic(1) machine_uid_name(2)}.\n * The constant GSS_C_NT_MACHINE_UID_NAME should be\n * initialized to point to that gss_OID_desc.\n */\nextern gss_OID GSS_C_NT_MACHINE_UID_NAME;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * The implementation must reserve static storage for a\n * gss_OID_desc object containing the value\n * {10, (void *)\"\\x2a\\x86\\x48\\x86\\xf7\\x12\"\n *              \"\\x01\\x02\\x01\\x03\"},\n * corresponding to an object-identifier value of\n * {iso(1) member-body(2) United States(840) mit(113554)\n * infosys(1) gssapi(2) generic(1) string_uid_name(3)}.\n * The constant GSS_C_NT_STRING_UID_NAME should be\n * initialized to point to that gss_OID_desc.\n */\nextern gss_OID GSS_C_NT_STRING_UID_NAME;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * The implementation must reserve static storage for a\n * gss_OID_desc object containing the value\n * {6, (void *)\"\\x2b\\x06\\x01\\x05\\x06\\x02\"},\n * corresponding to an object-identifier value of\n * {iso(1) org(3) dod(6) internet(1) security(5)\n * nametypes(6) gss-host-based-services(2)).  The constant\n * GSS_C_NT_HOSTBASED_SERVICE_X should be initialized to point\n * to that gss_OID_desc.  This is a deprecated OID value, and\n * implementations wishing to support hostbased-service names\n * should instead use the GSS_C_NT_HOSTBASED_SERVICE OID,\n * defined below, to identify such names;\n * GSS_C_NT_HOSTBASED_SERVICE_X should be accepted a synonym\n * for GSS_C_NT_HOSTBASED_SERVICE when presented as an input\n * parameter, but should not be emitted by GSS-API\n * implementations\n */\nextern gss_OID GSS_C_NT_HOSTBASED_SERVICE_X;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * The implementation must reserve static storage for a\n * gss_OID_desc object containing the value\n * {10, (void *)\"\\x2a\\x86\\x48\\x86\\xf7\\x12\"\n *              \"\\x01\\x02\\x01\\x04\"}, corresponding to an\n * object-identifier value of {iso(1) member-body(2)\n * Unites States(840) mit(113554) infosys(1) gssapi(2)\n * generic(1) service_name(4)}.  The constant\n * GSS_C_NT_HOSTBASED_SERVICE should be initialized\n * to point to that gss_OID_desc.\n */\nextern gss_OID GSS_C_NT_HOSTBASED_SERVICE;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * The implementation must reserve static storage for a\n * gss_OID_desc object containing the value\n * {6, (void *)\"\\x2b\\x06\\01\\x05\\x06\\x03\"},\n * corresponding to an object identifier value of\n * {1(iso), 3(org), 6(dod), 1(internet), 5(security),\n * 6(nametypes), 3(gss-anonymous-name)}.  The constant\n * and GSS_C_NT_ANONYMOUS should be initialized to point\n * to that gss_OID_desc.\n */\nextern gss_OID GSS_C_NT_ANONYMOUS;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * The implementation must reserve static storage for a\n * gss_OID_desc object containing the value\n * {6, (void *)\"\\x2b\\x06\\x01\\x05\\x06\\x04\"},\n * corresponding to an object-identifier value of\n * {1(iso), 3(org), 6(dod), 1(internet), 5(security),\n * 6(nametypes), 4(gss-api-exported-name)}.  The constant\n * GSS_C_NT_EXPORT_NAME should be initialized to point\n * to that gss_OID_desc.\n */\nextern gss_OID GSS_C_NT_EXPORT_NAME;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Major status codes */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define GSS_S_COMPLETE 0",
      "ja": "#define gss_s_complete 0"
    },
    {
      "indent": 3,
      "text": "/*\n * Some \"helper\" definitions to make the status code macros obvious.\n */\n#define GSS_C_CALLING_ERROR_OFFSET 24\n#define GSS_C_ROUTINE_ERROR_OFFSET 16",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define GSS_C_SUPPLEMENTARY_OFFSET 0 #define GSS_C_CALLING_ERROR_MASK 0377ul #define GSS_C_ROUTINE_ERROR_MASK 0377ul #define GSS_C_SUPPLEMENTARY_MASK 0177777ul",
      "ja": "#define gss_c_supplementary_offset 0 #define gss_c_calling_error_mask 0377ul #define gss_c_routine_error_mask 0377ul"
    },
    {
      "indent": 3,
      "text": "/*\n * The macros that test status codes for error conditions.\n * Note that the GSS_ERROR() macro has changed slightly from\n * the V1 GSS-API so that it now evaluates its argument\n * only once.\n */\n#define GSS_CALLING_ERROR(x) \\\n (x & (GSS_C_CALLING_ERROR_MASK << GSS_C_CALLING_ERROR_OFFSET))\n#define GSS_ROUTINE_ERROR(x) \\\n (x & (GSS_C_ROUTINE_ERROR_MASK << GSS_C_ROUTINE_ERROR_OFFSET))\n#define GSS_SUPPLEMENTARY_INFO(x) \\\n (x & (GSS_C_SUPPLEMENTARY_MASK << GSS_C_SUPPLEMENTARY_OFFSET))\n#define GSS_ERROR(x) \\\n (x & ((GSS_C_CALLING_ERROR_MASK << GSS_C_CALLING_ERROR_OFFSET) | \\\n       (GSS_C_ROUTINE_ERROR_MASK << GSS_C_ROUTINE_ERROR_OFFSET)))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Now the actual status code definitions\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Calling errors:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " */\n#define GSS_S_CALL_INACCESSIBLE_READ \\\n(1ul << GSS_C_CALLING_ERROR_OFFSET)\n#define GSS_S_CALL_INACCESSIBLE_WRITE \\\n(2ul << GSS_C_CALLING_ERROR_OFFSET)\n#define GSS_S_CALL_BAD_STRUCTURE \\\n(3ul << GSS_C_CALLING_ERROR_OFFSET)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Routine errors:\n */\n#define GSS_S_BAD_MECH             (1ul <<\nGSS_C_ROUTINE_ERROR_OFFSET)\n#define GSS_S_BAD_NAME             (2ul <<\nGSS_C_ROUTINE_ERROR_OFFSET)\n#define GSS_S_BAD_NAMETYPE         (3ul <<\nGSS_C_ROUTINE_ERROR_OFFSET)\n#define GSS_S_BAD_BINDINGS         (4ul <<\nGSS_C_ROUTINE_ERROR_OFFSET)\n#define GSS_S_BAD_STATUS           (5ul <<\n   GSS_C_ROUTINE_ERROR_OFFSET)\n#define GSS_S_BAD_SIG              (6ul <<\nGSS_C_ROUTINE_ERROR_OFFSET)\n#define GSS_S_BAD_MIC GSS_S_BAD_SIG\n#define GSS_S_NO_CRED              (7ul <<\nGSS_C_ROUTINE_ERROR_OFFSET)\n#define GSS_S_NO_CONTEXT           (8ul <<\nGSS_C_ROUTINE_ERROR_OFFSET)\n#define GSS_S_DEFECTIVE_TOKEN      (9ul <<\nGSS_C_ROUTINE_ERROR_OFFSET)\n#define GSS_S_DEFECTIVE_CREDENTIAL (10ul <<\nGSS_C_ROUTINE_ERROR_OFFSET)\n#define GSS_S_CREDENTIALS_EXPIRED  (11ul <<\nGSS_C_ROUTINE_ERROR_OFFSET)\n#define GSS_S_CONTEXT_EXPIRED      (12ul <<\nGSS_C_ROUTINE_ERROR_OFFSET)\n#define GSS_S_FAILURE              (13ul <<\nGSS_C_ROUTINE_ERROR_OFFSET)\n#define GSS_S_BAD_QOP              (14ul <<\nGSS_C_ROUTINE_ERROR_OFFSET)\n#define GSS_S_UNAUTHORIZED         (15ul <<\nGSS_C_ROUTINE_ERROR_OFFSET)\n#define GSS_S_UNAVAILABLE          (16ul <<\nGSS_C_ROUTINE_ERROR_OFFSET)\n#define GSS_S_DUPLICATE_ELEMENT    (17ul <<\nGSS_C_ROUTINE_ERROR_OFFSET)\n#define GSS_S_NAME_NOT_MN          (18ul <<\nGSS_C_ROUTINE_ERROR_OFFSET)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Supplementary info bits:\n */\n#define GSS_S_CONTINUE_NEEDED \\\n         (1ul << (GSS_C_SUPPLEMENTARY_OFFSET + 0))\n#define GSS_S_DUPLICATE_TOKEN \\\n         (1ul << (GSS_C_SUPPLEMENTARY_OFFSET + 1))\n#define GSS_S_OLD_TOKEN \\\n         (1ul << (GSS_C_SUPPLEMENTARY_OFFSET + 2))\n#define GSS_S_UNSEQ_TOKEN \\\n         (1ul << (GSS_C_SUPPLEMENTARY_OFFSET + 3))\n#define GSS_S_GAP_TOKEN \\\n         (1ul << (GSS_C_SUPPLEMENTARY_OFFSET + 4))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Finally, function prototypes for the GSS-API routines.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_acquire_cred\n              (OM_uint32 ,             /*  minor_status */\n               const gss_name_t,       /* desired_name */\n               OM_uint32,              /* time_req */\n               const gss_OID_set,      /* desired_mechs */\n               gss_cred_usage_t,       /* cred_usage */\n               gss_cred_id_t ,         /* output_cred_handle */\n               gss_OID_set ,           /* actual_mechs */\n               OM_uint32 *             /* time_rec */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_release_cred\n              (OM_uint32 ,             /* minor_status */\n               gss_cred_id_t *         /* cred_handle */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_init_sec_context\n              (OM_uint32 ,             /* minor_status */\n               const gss_cred_id_t,    /* initiator_cred_handle */\n               gss_ctx_id_t ,          /* context_handle */\n               const gss_name_t,       /* target_name */\n               const gss_OID,          /* mech_type */\n               OM_uint32,              /* req_flags */\n               OM_uint32,              /* time_req */\n               const gss_channel_bindings_t,\n                                       /* input_chan_bindings */\n               const gss_buffer_t,     /* input_token */\n               gss_OID ,               /* actual_mech_type */\n               gss_buffer_t,           /* output_token */\n               OM_uint32 ,             /* ret_flags */\n               OM_uint32 *             /* time_rec */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_accept_sec_context\n              (OM_uint32 ,             /* minor_status */\n               gss_ctx_id_t ,          /* context_handle */\n               const gss_cred_id_t,    /* acceptor_cred_handle */\n               const gss_buffer_t,     /* input_token_buffer */\n               const gss_channel_bindings_t,\n                                       /* input_chan_bindings */\n               gss_name_t ,            /* src_name */\n               gss_OID ,               /* mech_type */\n               gss_buffer_t,           /* output_token */\n               OM_uint32 ,             /* ret_flags */\n               OM_uint32 ,             /* time_rec */\n               gss_cred_id_t *         /* delegated_cred_handle */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_process_context_token\n              (OM_uint32 ,             /* minor_status */\n               const gss_ctx_id_t,     /* context_handle */\n               const gss_buffer_t      /* token_buffer */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_delete_sec_context\n              (OM_uint32 ,             /* minor_status */\n               gss_ctx_id_t ,          /* context_handle */\n               gss_buffer_t            /* output_token */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_context_time\n              (OM_uint32 ,             /* minor_status */\n               const gss_ctx_id_t,     /* context_handle */\n               OM_uint32 *             /* time_rec */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_get_mic\n              (OM_uint32 ,             /* minor_status */\n               const gss_ctx_id_t,     /* context_handle */\n               gss_qop_t,              /* qop_req */\n               const gss_buffer_t,     /* message_buffer */\n               gss_buffer_t            /* message_token */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_verify_mic\n              (OM_uint32 ,             /* minor_status */\n               const gss_ctx_id_t,     /* context_handle */\n               const gss_buffer_t,     /* message_buffer */\n               const gss_buffer_t,     /* token_buffer */\n               gss_qop_t *             /* qop_state */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_wrap\n              (OM_uint32 ,             /* minor_status */\n               const gss_ctx_id_t,     /* context_handle */\n               int,                    /* conf_req_flag */\n               gss_qop_t,              /* qop_req */\n               const gss_buffer_t,     /* input_message_buffer */\n               int ,                   /* conf_state */\n               gss_buffer_t            /* output_message_buffer */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_unwrap\n              (OM_uint32 ,             /* minor_status */\n               const gss_ctx_id_t,     /* context_handle */\n               const gss_buffer_t,     /* input_message_buffer */\n               gss_buffer_t,           /* output_message_buffer */\n               int ,                   /* conf_state */\n               gss_qop_t *             /* qop_state */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_display_status\n              (OM_uint32 ,             /* minor_status */\n               OM_uint32,              /* status_value */\n               int,                    /* status_type */\n               const gss_OID,          /* mech_type */\n               OM_uint32 ,             /* message_context */\n               gss_buffer_t            /* status_string */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_indicate_mechs\n              (OM_uint32 ,             /* minor_status */\n               gss_OID_set *           /* mech_set */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_compare_name\n              (OM_uint32 ,             /* minor_status */\n               const gss_name_t,       /* name1 */\n               const gss_name_t,       /* name2 */\n               int *                   /* name_equal */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_display_name\n              (OM_uint32 ,             /* minor_status */\n               const gss_name_t,       /* input_name */\n               gss_buffer_t,           /* output_name_buffer */\n               gss_OID *               /* output_name_type */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_import_name\n              (OM_uint32 ,             /* minor_status */\n               const gss_buffer_t,     /* input_name_buffer */\n               const gss_OID,          /* input_name_type */\n               gss_name_t *            /* output_name */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_export_name\n              (OM_uint32,              /* minor_status */\n               const gss_name_t,       /* input_name */\n               gss_buffer_t            /* exported_name */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_release_name\n              (OM_uint32 *,            /* minor_status */\n               gss_name_t *            /* input_name */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_release_buffer\n              (OM_uint32 ,             /* minor_status */\n               gss_buffer_t            /* buffer */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_release_oid_set\n              (OM_uint32 ,             /* minor_status */\n               gss_OID_set *           /* set */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_inquire_cred\n              (OM_uint32 ,             /* minor_status */\n               const gss_cred_id_t,    /* cred_handle */\n               gss_name_t ,            /* name */\n               OM_uint32 ,             /* lifetime */\n               gss_cred_usage_t ,      /* cred_usage */\n               gss_OID_set *           /* mechanisms */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_inquire_context (\n               OM_uint32 ,             /* minor_status */\n               const gss_ctx_id_t,     /* context_handle */\n               gss_name_t ,            /* src_name */\n               gss_name_t ,            /* targ_name */\n               OM_uint32 ,             /* lifetime_rec */\n               gss_OID ,               /* mech_type */\n               OM_uint32 ,             /* ctx_flags */\n               int ,                   /* locally_initiated */\n               int *                   /* open */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_wrap_size_limit (\n               OM_uint32 ,             /* minor_status */\n               const gss_ctx_id_t,     /* context_handle */\n               int,                    /* conf_req_flag */\n               gss_qop_t,              /* qop_req */\n               OM_uint32,              /* req_output_size */\n               OM_uint32 *             /* max_input_size */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_add_cred (\n               OM_uint32 ,             /* minor_status */\n               const gss_cred_id_t,    /* input_cred_handle */\n               const gss_name_t,       /* desired_name */\n               const gss_OID,          /* desired_mech */\n               gss_cred_usage_t,       /* cred_usage */\n               OM_uint32,              /* initiator_time_req */\n               OM_uint32,              /* acceptor_time_req */\n               gss_cred_id_t ,         /* output_cred_handle */\n               gss_OID_set ,           /* actual_mechs */\n               OM_uint32 ,             /* initiator_time_rec */\n               OM_uint32 *             /* acceptor_time_rec */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_inquire_cred_by_mech (\n               OM_uint32 ,             /* minor_status */\n               const gss_cred_id_t,    /* cred_handle */\n               const gss_OID,          /* mech_type */\n               gss_name_t ,            /* name */\n               OM_uint32 ,             /* initiator_lifetime */\n               OM_uint32 ,             /* acceptor_lifetime */\n               gss_cred_usage_t *      /* cred_usage */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_export_sec_context (\n               OM_uint32 ,             /* minor_status */\n               gss_ctx_id_t ,          /* context_handle */\n               gss_buffer_t            /* interprocess_token */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_import_sec_context (\n               OM_uint32 ,             /* minor_status */\n               const gss_buffer_t,     /* interprocess_token */\n               gss_ctx_id_t *          /* context_handle */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_create_empty_oid_set (\n               OM_uint32 ,             /* minor_status */\n               gss_OID_set *           /* oid_set */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_add_oid_set_member (\n               OM_uint32 ,             /* minor_status */\n               const gss_OID,          /* member_oid */\n               gss_OID_set *           /* oid_set */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_test_oid_set_member (\n               OM_uint32 ,             /* minor_status */\n               const gss_OID,          /* member */\n               const gss_OID_set,      /* set */\n               int *                   /* present */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_inquire_names_for_mech (\n               OM_uint32 ,             /* minor_status */\n               const gss_OID,          /* mechanism */\n               gss_OID_set *           /* name_types */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_inquire_mechs_for_name (\n               OM_uint32 ,             /* minor_status */\n               const gss_name_t,       /* input_name */\n               gss_OID_set *           /* mech_types */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_canonicalize_name (\n               OM_uint32 ,             /* minor_status */\n               const gss_name_t,       /* input_name */\n               const gss_OID,          /* mech_type */\n               gss_name_t *            /* output_name */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_duplicate_name (\n               OM_uint32 ,             /* minor_status */\n               const gss_name_t,       /* src_name */\n               gss_name_t *            /* dest_name */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * The following routines are obsolete variants of gss_get_mic,\n * gss_verify_mic, gss_wrap and gss_unwrap.  They should be\n * provided by GSS-API V2 implementations for backwards\n * compatibility with V1 applications.  Distinct entrypoints",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "* (as opposed to #defines) should be provided, both to allow * GSS-API V1 applications to link against GSS-API V2 implementations, * and to retain the slight parameter type differences between the * obsolete versions of these routines and their current forms. */",
      "ja": "* （#definesとは対照的に）は、 * GSS-API V1アプリケーションがGSS-API V2実装に対してリンクできるようにし、これらのルーチンの *時代遅れのバージョンと現在のフォームの間のわずかなパラメータータイプの違いを保持するために提供する必要があります。。*/"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_sign\n              (OM_uint32 ,        /* minor_status */\n               gss_ctx_id_t,      /* context_handle */\n               int,               /* qop_req */\n               gss_buffer_t,      /* message_buffer */\n               gss_buffer_t       /* message_token */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_verify\n              (OM_uint32 ,        /* minor_status */\n               gss_ctx_id_t,      /* context_handle */\n               gss_buffer_t,      /* message_buffer */\n               gss_buffer_t,      /* token_buffer */\n               int *              /* qop_state */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_seal\n              (OM_uint32 ,        /* minor_status */\n               gss_ctx_id_t,      /* context_handle */\n               int,               /* conf_req_flag */\n               int,               /* qop_req */\n               gss_buffer_t,      /* input_message_buffer */\n               int ,              /* conf_state */\n               gss_buffer_t       /* output_message_buffer */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_unseal\n              (OM_uint32 ,        /* minor_status */\n               gss_ctx_id_t,      /* context_handle */\n               gss_buffer_t,      /* input_message_buffer */\n               gss_buffer_t,      /* output_message_buffer */\n               int ,              /* conf_state */\n               int *              /* qop_state */\n              );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif /* GSSAPI_H_ */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix B. Additional constraints for application binary portability",
      "section_title": true,
      "ja": "付録B. アプリケーションバイナリポータビリティの追加の制約"
    },
    {
      "indent": 3,
      "text": "The purpose of this C-bindings document is to encourage source-level portability of applications across GSS-API implementations on different platforms and atop different mechanisms. Additional goals that have not been explicitly addressed by this document are link-time and run-time portability.",
      "ja": "このC-Bindingsドキュメントの目的は、さまざまなプラットフォームおよびさまざまなメカニズムのGSS-API実装全体のアプリケーションのソースレベルの移植性を促進することです。このドキュメントで明示的に対処されていない追加の目標は、リンク時間とランタイムポータビリティです。"
    },
    {
      "indent": 3,
      "text": "Link-time portability provides the ability to compile an application against one implementation of GSS-API, and then link it against a different implementation on the same platform. It is a stricter requirement than source-level portability.",
      "ja": "Link-Time Porteabilityは、GSS-APIの1つの実装に対してアプリケーションをコンパイルし、同じプラットフォーム上の異なる実装に対してリンクする機能を提供します。ソースレベルの移植性よりも厳しい要件です。"
    },
    {
      "indent": 3,
      "text": "Run-time portability differs from link-time portability only on those platforms that implement dynamically loadable GSS-API implementations, but do not offer load-time symbol resolution. On such platforms, run-time portability is a stricter requirement than link-time portability, and will typically include the precise placement of the various GSS-API routines within library entrypoint vectors.",
      "ja": "ランタイムポータビリティは、動的にロード可能なGSS-API実装を実装するプラットフォームでのみリンク時間の移植性とは異なりますが、ロードタイムシンボル解像度を提供しません。このようなプラットフォームでは、ランタイムポータビリティはリンク時間の移植性よりも厳しい要件であり、通常、ライブラリエントリポイントベクター内のさまざまなGSS-APIルーチンの正確な配置が含まれます。"
    },
    {
      "indent": 3,
      "text": "Individual platforms will impose their own rules that must be followed to achieve link-time (and run-time, if different) portability. In order to ensure either form of binary portability, an ABI specification must be written for GSS-API implementations on that platform. However, it is recognized that there are some issues that are likely to be common to all such ABI specifications. This appendix is intended to be a repository for such common issues, and contains some suggestions that individual ABI specifications may choose to reference. Since machine architectures vary greatly, it may not be possible or desirable to follow these suggestions on all platforms.",
      "ja": "個々のプラットフォームは、リンク時間（および実行時間、異なる場合）の移植性を達成するために従わなければならない独自のルールを課します。いずれかの形式のバイナリポータビリティを確保するには、そのプラットフォーム上のGSS-API実装用にABI仕様を作成する必要があります。ただし、そのようなすべてのABI仕様に共通する可能性が高いいくつかの問題があることが認識されています。この付録は、そのような一般的な問題のリポジトリであることを目的としており、個々のABI仕様が参照することを選択できるといういくつかの提案が含まれています。マシンアーキテクチャは大きく異なるため、すべてのプラットフォームでこれらの提案に従うことは不可能または望ましくない場合があります。"
    },
    {
      "indent": 0,
      "text": "B.1. Pointers",
      "section_title": true,
      "ja": "B.1. ポインター"
    },
    {
      "indent": 3,
      "text": "While ANSI-C provides a single pointer type for each declared type, plus a single (void *) type, some platforms (notably those using segmented memory architectures) augment this with various modified pointer types (e.g. far pointers, near pointers). These language bindings assume ANSI-C, and thus do not address such non-standard implementations. GSS-API implementations for such platforms must choose an appropriate memory model, and should use it consistently throughout. For example, if a memory model is chosen that requires the use of far pointers when passing routine parameters, then far pointers should also be used within the structures defined by GSS-API.",
      "ja": "ANSI-Cは、宣言されたタイプごとに単一のポインタータイプを提供し、さらに1つの（void *）タイプを提供しますが、一部のプラットフォーム（特にセグメント化されたメモリアーキテクチャを使用するもの）は、さまざまな修正ポインタータイプ（たとえば、ポインターの近くの遠いポインター）でこれを増強します。これらの言語のバインディングはANSI-Cを想定しているため、そのような非標準の実装に対処しません。このようなプラットフォームのGSS-API実装は、適切なメモリモデルを選択する必要があり、一貫して使用する必要があります。たとえば、ルーチンパラメーターを渡すときに遠いポインターを使用する必要があるメモリモデルが選択されている場合、GSS-APIで定義された構造内では、遠いポインターも使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "B.2. Internal structure alignment",
      "section_title": true,
      "ja": "B.2. 内部構造アライメント"
    },
    {
      "indent": 3,
      "text": "GSS-API defines several data-structures containing differently-sized fields. An ABI specification should include a detailed description of how the fields of such structures are aligned, and if there is any internal padding in these data structures. The use of compiler defaults for the platform is recommended.",
      "ja": "GSS-APIは、異なるサイズのフィールドを含むいくつかのデータ構造を定義します。ABI仕様には、そのような構造のフィールドがどのように整合されているか、およびこれらのデータ構造に内部パディングがある場合の詳細な説明を含める必要があります。プラットフォームにコンパイラのデフォルトを使用することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "B.3. Handle types",
      "section_title": true,
      "ja": "B.3. ハンドルタイプ"
    },
    {
      "indent": 3,
      "text": "The C bindings specify that the gss_cred_id_t and gss_ctx_id_t types should be implemented as either pointer or arithmetic types, and that if pointer types are used, care should be taken to ensure that two handles may be compared with the == operator. Note that ANSI-C does not guarantee that two pointer values may be compared with the == operator unless either the two pointers point to members of a single array, or at least one of the pointers contains a NULL value.",
      "ja": "Cバインディングは、GSS_CRED_ID_TおよびGSS_CTX_ID_Tタイプをポインターまたは算術タイプとして実装する必要があり、ポインタータイプを使用する場合は、2つのハンドルを==演算子と比較できるように注意する必要があることを指定します。ANSI-Cは、2つのポインターが単一の配列のメンバーを指しているか、少なくとも1つのポインターにヌル値を含む場合を除き、2つのポインター値を==演算子と比較できることを保証しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "For binary portability, additional constraints are required. The following is an attempt at defining platform-independent constraints.",
      "ja": "バイナリの移植性には、追加の制約が必要です。以下は、プラットフォームに依存しない制約を定義する試みです。"
    },
    {
      "indent": 3,
      "text": "The size of the handle type must be the same as sizeof(void *), using the appropriate memory model.",
      "ja": "ハンドルタイプのサイズは、適切なメモリモデルを使用して、sizeof（void *）と同じでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The == operator for the chosen type must be a simple bit-wise comparison. That is, for two in-memory handle objects h1 and h2, the boolean value of the expression",
      "ja": "選択したタイプの==演算子は、単純な少しの比較でなければなりません。つまり、2つのインメモリーハンドルオブジェクトH1とH2の場合、式のブール値"
    },
    {
      "indent": 6,
      "text": "(h1 == h2)",
      "ja": "（H1 == H2）"
    },
    {
      "indent": 3,
      "text": "should always be the same as the boolean value of the expression",
      "ja": "式のブール値と常に同じでなければなりません"
    },
    {
      "indent": 6,
      "text": "(memcmp(&h1, &h2, sizeof(h1)) == 0)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The actual use of the type (void *) for handle types is discouraged, not for binary portability reasons, but since it effectively disables much of the compile-time type-checking that the compiler can otherwise perform, and is therefore not \"programmer-friendly\". If a pointer implementation is desired, and if the platform's implementation of pointers permits, the handles should be implemented as pointers to distinct implementation-defined types.",
      "ja": "ハンドルタイプのタイプ（void *）の実際の使用は、バイナリの移植性の理由ではなく、コンパイラーが実行できるため、「プログラマー - ではない」というコンパイル時間タイプチェックの多くを効果的に無効にするため、落胆しています。フレンドリー\"。ポインターの実装が必要な場合、およびプラットフォームのポインターの実装が許可されている場合、ハンドルは明確な実装定義型のポインターとして実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "B.4. The gss_name_t type",
      "section_title": true,
      "ja": "B.4. GSS_NAME_Tタイプ"
    },
    {
      "indent": 3,
      "text": "The gss_name_t type, representing the internal name object, should be implemented as a pointer type. The use of the (void *) type is discouraged as it does not allow the compiler to perform strong type-checking. However, the pointer type chosen should be of the same size as the (void *) type. Provided this rule is obeyed, ABI specifications need not further constrain the implementation of gss_name_t objects.",
      "ja": "内部名オブジェクトを表すGSS_NAME_Tタイプは、ポインタータイプとして実装する必要があります。コンパイラが強力なタイプチェックを実行できないため、（void *）タイプの使用は落胆します。ただし、選択したポインタータイプは、（void *）タイプと同じサイズでなければなりません。このルールが従っていれば、ABI仕様はGSS_NAME_Tオブジェクトの実装をさらに制限する必要はありません。"
    },
    {
      "indent": 0,
      "text": "B.5. The int and size_t types",
      "section_title": true,
      "ja": "B.5. intおよびsize_tタイプ"
    },
    {
      "indent": 3,
      "text": "Some platforms may support differently sized implementations of the \"int\" and \"size_t\" types, perhaps chosen through compiler switches, and perhaps dependent on memory model. An ABI specification for such a platform should include required implementations for these types. It is recommended that the default implementation (for the chosen memory model, if appropriate) is chosen.",
      "ja": "一部のプラットフォームは、おそらくコンパイラスイッチを介して選択され、おそらくメモリモデルに依存する「int」および「size_t」タイプの異なるサイズの実装をサポートする場合があります。このようなプラットフォームのABI仕様には、これらのタイプに必要な実装を含める必要があります。デフォルトの実装（必要に応じて選択されたメモリモデルの場合）を選択することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "B.6. Procedure-calling conventions",
      "section_title": true,
      "ja": "B.6. 手順をコールする規則"
    },
    {
      "indent": 3,
      "text": "Some platforms support a variety of different binary conventions for calling procedures. Such conventions cover things like the format of the stack frame, the order in which the routine parameters are pushed onto the stack, whether or not a parameter count is pushed onto the stack, whether some argument(s) or return values are to be passed in registers, and whether the called routine or the caller is responsible for removing the stack frame on return. For such platforms, an ABI specification should specify which calling convention is to be used for GSS-API implementations.",
      "ja": "一部のプラットフォームは、呼び出し手順のためのさまざまなバイナリ規則をサポートしています。このようなコンベンションは、スタックフレームの形式、ルーチンパラメーターがスタックにプッシュされる順序、パラメーターカウントがスタックにプッシュされるかどうか、何らかの引数または返信値を渡すかどうかにかかわらず、スタックにプッシュされる順序などをカバーしています。レジスタでは、呼び出されたルーチンまたは発信者が、返品時にスタックフレームを削除する責任があるかどうか。このようなプラットフォームの場合、ABI仕様は、GSS-API実装に使用する呼び出し規則を指定する必要があります。"
    },
    {
      "indent": 0,
      "text": "References",
      "ja": "参考文献"
    },
    {
      "indent": 3,
      "text": "[GSSAPI] Linn, J., \"Generic Security Service Application Program Interface Version 2, Update 1\", RFC 2743, January 2000.",
      "ja": "[GSSAPI] Linn、J。、「Generic Security Service Application Program Interfaceバージョン2、Update 1」、RFC 2743、2000年1月。"
    },
    {
      "indent": 3,
      "text": "[XOM] OSI Object Management API Specification, Version 2.0 t\", X.400 API Association & X/Open Company Limited, August 24, 1990 Specification of datatypes and routines for manipulating information objects.",
      "ja": "[XOM] OSIオブジェクト管理API仕様、バージョン2.0 T \"、X.400 API Association＆X/Open Company Limited、1990年8月24日、情報オブジェクトを操作するためのデータ型およびルーチンの仕様。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者の連絡先"
    },
    {
      "indent": 3,
      "text": "John Wray Iris Associates 5 Technology Park Drive, Westford, MA 01886 USA",
      "ja": "ジョンレイアイリスアソシエイツ5テクノロジーパークドライブ、ウェストフォード、マサチューセッツ州01886 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1-978-392-6689\nEMail: John_Wray@Iris.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2000). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2000）。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントと本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}