{
  "title": {
    "text": "RFC 2961 - RSVP Refresh Overhead Reduction Extensions",
    "ja": "RFC 2961 - RSVPオーバーヘッド削減延長を更新します"
  },
  "number": 2961,
  "created_at": "2024-01-07 07:17:47.827163+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                         L. Berger\nRequest for Comments: 2961                         LabN Consulting, LLC\nCategory: Standards Track                                        D. Gan\n                                                 Juniper Networks, Inc.\n                                                             G. Swallow\n                                                    Cisco Systems, Inc.\n                                                                 P. Pan\n                                                 Juniper Networks, Inc.\n                                                             F. Tommasi\n                                                           S. Molendini\n                                                    University of Lecce\n                                                             April 2001",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "RSVP Refresh Overhead Reduction Extensions",
      "ja": "RSVPオーバーヘッド削減延長を更新します"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2001）。無断転載を禁じます。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes a number of mechanisms that can be used to reduce processing overhead requirements of refresh messages, eliminate the state synchronization latency incurred when an RSVP (Resource ReserVation Protocol) message is lost and, when desired, refreshing state without the transmission of whole refresh messages. The same extensions also support reliable RSVP message delivery on a per hop basis. These extension present no backwards compatibility issues.",
      "ja": "このドキュメントでは、更新メッセージの処理オーバーヘッド要件を削減するために使用できる多くのメカニズムについて説明し、RSVP（リソース予約プロトコル）メッセージが失われ、必要に応じて更新されない状態を更新せずに状態を排除します。メッセージ。同じ拡張機能は、信頼性の高いRSVPメッセージ配信も1ホップごとにサポートしています。これらの拡張機能には、後方互換性の問題はありません。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1      Introduction and Background ................................2\n1.1    Trigger and Refresh Messages ...............................4\n2      Refresh-Reduction-Capable Bit ..............................4\n3      RSVP Bundle Message ........................................5\n3.1    Bundle Header ..............................................5\n3.2    Message Formats ............................................6\n3.3    Sending RSVP Bundle Messages ...............................7\n3.4    Receiving RSVP Bundle Messages .............................8\n4      MESSAGE_ID Extension .......................................8\n4.1    Modification of Standard Message Formats ...................9\n4.2    MESSAGE_ID Objects ........................................10\n4.3    MESSAGE_ID_ACK and MESSAGE_ID_NACK Objects ................11\n4.4    Ack Message Format ........................................11\n4.5    MESSAGE_ID Object Usage ...................................12\n4.6    MESSAGE_ID_ACK Object and MESSAGE_ID_NACK Object Usage ....14\n4.7    Multicast Considerations ..................................15\n4.7.1  Reference RSVP/Routing Interface ..........................16\n4.8    Compatibility .............................................16\n5      Summary Refresh Extension .................................17\n5.1    MESSAGE_ID LIST, SRC_LIST and MCAST_LIST Objects ..........18\n5.2    Srefresh Message Format ...................................24\n5.3    Srefresh Message Usage ....................................25\n5.4    Srefresh NACK .............................................28\n5.5    Preserving RSVP Soft State ................................28\n5.6    Compatibility .............................................29\n6      Exponential Back-Off Procedures ...........................29\n6.1    Outline of Operation ......................................30\n6.2    Time Parameters ...........................................30\n6.3    Retransmission Algorithm ..................................31\n6.4    Performance Considerations ................................31\n7      Acknowledgments ...........................................31\n8      Security Considerations ...................................32\n9      References ................................................32\n10     Authors' Addresses ........................................33\n11     Full Copyright Statement...................................34",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction and Background",
      "section_title": true,
      "ja": "1. はじめに。背景"
    },
    {
      "indent": 3,
      "text": "Standard RSVP [RFC2205] maintains state via the generation of RSVP refresh messages. Refresh messages are used to both synchronize state between RSVP neighbors and to recover from lost RSVP messages. The use of Refresh messages to cover many possible failures has resulted in a number of operational problems. One problem relates to scaling, another relates to the reliability and latency of RSVP Signaling.",
      "ja": "Standard RSVP [RFC2205]は、RSVP更新メッセージの生成を介して状態を維持します。更新メッセージは、RSVP近隣の間の状態を同期させ、失われたRSVPメッセージから回復するために使用されます。多くの可能な障害をカバーするために更新メッセージを使用すると、多くの運用上の問題が発生しました。1つの問題はスケーリングに関連し、もう1つはRSVPシグナル伝達の信頼性と潜伏期に関連しています。"
    },
    {
      "indent": 3,
      "text": "The scaling problems are linked to the resource requirements (in terms of processing and memory) of running RSVP. The resource requirements increase proportionally with the number of sessions. Each session requires the generation, transmission, reception and processing of RSVP Path and Resv messages per refresh period. Supporting a large number of sessions, and the corresponding volume of refresh messages, presents a scaling problem.",
      "ja": "スケーリングの問題は、RSVPの実行のリソース要件（処理とメモリの観点から）にリンクされています。リソースの要件は、セッションの数に比例して増加します。各セッションでは、更新期間ごとにRSVPパスとRESVメッセージの生成、送信、受信、および処理が必要です。多数のセッションと、対応するリフレッシュメッセージのボリュームをサポートすると、スケーリングの問題が発生します。"
    },
    {
      "indent": 3,
      "text": "The reliability and latency problem occurs when a non-refresh RSVP message is lost in transmission. Standard RSVP [RFC2205] recovers from a lost message via RSVP refresh messages. In the face of transmission loss of RSVP messages, the end-to-end latency of RSVP signaling is tied to the refresh interval of the node(s) experiencing the loss. When end-to-end signaling is limited by the refresh interval, the delay incurred in the establishment or the change of a reservation may be beyond the range of what is acceptable for some applications.",
      "ja": "信頼性とレイテンシーの問題は、伝送で非再販RSVPメッセージが失われたときに発生します。標準のRSVP [RFC2205]は、RSVP更新メッセージを介して失われたメッセージから回復します。RSVPメッセージの送信損失に直面して、RSVPシグナル伝達のエンドツーエンドのレイテンシは、損失を経験するノードの更新間隔に結び付けられています。エンドツーエンドの信号が更新間隔によって制限される場合、施設で発生した遅延または予約の変更は、一部のアプリケーションで許容できる範囲を超えている可能性があります。"
    },
    {
      "indent": 3,
      "text": "One way to address the refresh volume problem is to increase the refresh period, \"R\" as defined in Section 3.7 of [RFC2205]. Increasing the value of R provides linear improvement on transmission overhead, but at the cost of increasing the time it takes to synchronize state.",
      "ja": "リフレッシュボリュームの問題に対処する1つの方法は、[RFC2205]のセクション3.7で定義されている「R」を更新期間を増やすことです。Rの値を増やすと、トランスミッションオーバーヘッドが線形改善を提供しますが、状態を同期するのにかかる時間を増やします。"
    },
    {
      "indent": 3,
      "text": "One way to address the reliability and latency of RSVP Signaling is to decrease the refresh period R. Decreasing the value of R increases the probability that state will be installed in the face of message loss, but at the cost of increasing refresh message rate and associated processing requirements.",
      "ja": "RSVPシグナル伝達の信頼性と遅延に対処する1つの方法は、リフレッシュ期間Rを減らすことです。Rの値を減らすことで、メッセージの損失に直面して状態がインストールされる可能性が高くなりますが、更新メッセージレートと関連するコストがかかります。処理要件。"
    },
    {
      "indent": 3,
      "text": "An additional issue is the time to deallocate resources after a tear message is lost. RSVP does not retransmit ResvTear or PathTear messages. If the sole tear message transmitted is lost, then resources will only be deallocated once the \"cleanup timer\" interval has passed. This may result in resources being allocated for an unnecessary period of time. Note that even when the refresh period is adjusted, the \"cleanup timer\" must still expire since tear messages are not retransmitted.",
      "ja": "追加の問題は、涙メッセージが失われた後にリソースを扱う時です。RSVPは、resvtearまたはpathtearメッセージを再送信しません。送信された唯一の涙メッセージが失われた場合、リソースは「クリーンアップタイマー」間隔が通過した場合にのみ扱います。これにより、リソースが不必要な期間に割り当てられる可能性があります。更新期間が調整されている場合でも、ティアメッセージが再送信されないため、「クリーンアップタイマー」はまだ期限切れになる必要があります。"
    },
    {
      "indent": 3,
      "text": "The extensions defined in this document address both the refresh volume and the reliability issues with mechanisms other than adjusting refresh rate. The extensions are collectively referred to as the \"Refresh Overhead Reduction\" or the \"Refresh Reduction\" extensions. A Bundle message is defined to reduce overall message handling load. A MESSAGE_ID object is defined to reduce refresh message processing by allowing the receiver to more readily identify an unchanged message. A MESSAGE_ACK object is defined which can be used to detect message loss and support reliable RSVP message delivery on a per hop basis. A summary refresh message is defined to enable refreshing state without the transmission of whole refresh messages, while maintaining RSVP's ability to indicate when state is lost and to adjust to changes in routing.",
      "ja": "このドキュメントで定義されている拡張機能は、リフレッシュレートを調整する以外のメカニズムに関するリフレッシュボリュームと信頼性の問題の両方に対応しています。拡張機能は、集合的に「更新オーバーヘッド削減」または「更新削減」拡張機能と呼ばれます。バンドルメッセージは、全体的なメッセージ処理負荷を減らすために定義されています。Message_idオブジェクトは、受信者が変更されていないメッセージをより簡単に識別できるようにすることにより、メッセージ処理を更新するために定義されます。メッセージの損失を検出し、信頼できるRSVPメッセージ配信を1ホップごとにサポートするために使用できるMessage_ackオブジェクトが定義されています。RSVPのリフレッシュメッセージを送信せずにリフレッシュ状態を有効にすると、RSVPの状態が失われ、ルーティングの変更に適応する能力を維持しながら、概要更新メッセージが定義されます。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "「必須」、「そうしない」、「必須」、「shall」、「shall \"、\" ingle \"、\" should \"、\" not \"、\" becommended \"、\" bay \"、および「optional」は、[RFC2119]に記載されているように解釈される。"
    },
    {
      "indent": 0,
      "text": "1.1. Trigger and Refresh Messages",
      "section_title": true,
      "ja": "1.1. メッセージをトリガーして更新します"
    },
    {
      "indent": 3,
      "text": "This document categorizes RSVP messages into two types: trigger and refresh messages. Trigger messages are those RSVP messages that advertise state or any other information not previously transmitted. Trigger messages include messages advertising new state, a route change that alters a reservation path, or a modification to an existing RSVP session or reservation. Trigger messages also include those messages that include changes in non-RSVP processed objects, such as changes in the Policy or ADSPEC objects.",
      "ja": "このドキュメントは、RSVPメッセージをトリガーと更新メッセージの2つのタイプに分類します。トリガーメッセージは、状態または以前に送信されていない他の情報を宣伝するRSVPメッセージです。トリガーメッセージには、新しい状態を宣伝するメッセージ、予約パスを変更するルート変更、または既存のRSVPセッションまたは予約の変更が含まれます。トリガーメッセージには、ポリシーやADSPECオブジェクトの変更など、非RSVP処理オブジェクトの変更を含むメッセージも含まれます。"
    },
    {
      "indent": 3,
      "text": "Refresh messages represent previously advertised state and contain exactly the same objects and same information as a previously transmitted message, and are sent over the same path. Only Path and Resv messages can be refresh messages. Refresh messages are identical to the corresponding previously transmitted message, with some possible exceptions. Specifically, the checksum field, the flags field and the INTEGRITY object may differ in refresh messages.",
      "ja": "更新メッセージは、以前に宣伝されていた状態を表し、以前に送信されたメッセージとまったく同じオブジェクトと同じ情報を含み、同じパスで送信されます。PATHとRESVメッセージのみがメッセージを更新できます。更新メッセージは、いくつかの可能な例外を除いて、対応する以前に送信されたメッセージと同じです。具体的には、チェックサムフィールド、フラグフィールド、および整合性オブジェクトは、更新メッセージで異なる場合があります。"
    },
    {
      "indent": 0,
      "text": "2. Refresh-Reduction-Capable Bit",
      "section_title": true,
      "ja": "2. リフレッシュ削減対応ビット"
    },
    {
      "indent": 3,
      "text": "To indicate support for the refresh overhead reduction extensions, an additional capability bit is added to the common RSVP header, which is defined in [RFC2205].",
      "ja": "更新オーバーヘッド削減拡張のサポートを示すために、[RFC2205]で定義されている一般的なRSVPヘッダーに追加の機能ビットが追加されます。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Vers | Flags |   Msg Type    |         RSVP Checksum         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Send_TTL    |  (Reserved)   |         RSVP Length           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Flags: 4 bits",
      "ja": "フラグ：4ビット"
    },
    {
      "indent": 9,
      "text": "0x01: Refresh (overhead) reduction capable",
      "ja": "0x01：更新（オーバーヘッド）削減可能"
    },
    {
      "indent": 11,
      "text": "When set, indicates that this node is willing and capable of receiving all the messages and objects described in this document. This includes the Bundle message described in Section 3, the MESSAGE_ID objects and Ack messages described in Section 4, and the MESSAGE_ID LIST objects and Srefresh message described in Section 5. This bit is meaningful only between RSVP neighbors.",
      "ja": "設定すると、このノードがこのドキュメントに記載されているすべてのメッセージとオブジェクトを受信できることを示しています。これには、セクション3で説明されているバンドルメッセージ、セクション4で説明されているMessage_IDオブジェクト、ACKメッセージ、およびメッセージ_IDリストオブジェクトとセクション5で説明されているSrefreshメッセージが含まれます。このビットは、RSVPネイバー間でのみ意味があります。"
    },
    {
      "indent": 3,
      "text": "Nodes supporting the refresh overhead reduction extensions must also take care to recognize when a next hop stops sending RSVP messages with the Refresh-Reduction-Capable bit set. To cover this case, nodes supporting the refresh overhead reduction extensions MUST examine the flags field of each received RSVP message. If the flag changes from indicating support to indicating non-support then, unless configured otherwise, Srefresh messages (described in Section 5) MUST NOT be used for subsequent state refreshes to that neighbor and Bundle messages (Section 3) MUST NOT be sent to that neighbor. Note, a node that supports reliable RSVP message delivery (Section 4) but not Bundle and Srefresh messages, will not set the Refresh-Reduction-Capable bit.",
      "ja": "リフレッシュオーバーヘッド削減拡張をサポートするノードは、次のホップがリフレッシュ削減対応ビットセットでRSVPメッセージの送信を停止したときに認識するように注意する必要があります。このケースをカバーするには、更新オーバーヘッド削減延長をサポートするノードは、受信した各RSVPメッセージのフラグフィールドを調べる必要があります。サポートを示すことから非サポートを示すことにフラグが変更された場合、特に構成されていない限り、srefreshメッセージ（セクション5で説明）をその後の状態rfeshesに使用してはいけません。近所の人。注意してください。信頼性の高いRSVPメッセージ配信（セクション4）をサポートするノードではなく、バンドルやSrefreshメッセージではなく、リフレッシュ削減に対応するビットを設定しません。"
    },
    {
      "indent": 0,
      "text": "3. RSVP Bundle Message",
      "section_title": true,
      "ja": "3. RSVPバンドルメッセージ"
    },
    {
      "indent": 3,
      "text": "An RSVP Bundle message consists of a bundle header followed by a body consisting of a variable number of standard RSVP messages. A Bundle message is used to aggregate multiple RSVP messages within a single PDU. The term \"bundling\" is used to avoid confusion with RSVP reservation aggregation. The following subsections define the formats of the bundle header and the rules for including standard RSVP messages as part of the message.",
      "ja": "RSVPバンドルメッセージは、バンドルヘッダーに続いて、可変数の標準RSVPメッセージで構成されるボディで構成されています。バンドルメッセージは、単一のPDU内で複数のRSVPメッセージを集約するために使用されます。「バンドリング」という用語は、RSVP予約集約との混乱を避けるために使用されます。次のサブセクションでは、バンドルヘッダーの形式と、メッセージの一部として標準のRSVPメッセージを含めるためのルールを定義します。"
    },
    {
      "indent": 0,
      "text": "3.1. Bundle Header",
      "section_title": true,
      "ja": "3.1. バンドルヘッダー"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Vers  | Flags |   Msg type    |         RSVP checksum         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Send_TTL    |  (Reserved)   |         RSVP length           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "The format of the bundle header is identical to the format of the RSVP common header [RFC2205]. The fields in the header are as follows:",
      "ja": "バンドルヘッダーの形式は、RSVP共通ヘッダー[RFC2205]の形式と同じです。ヘッダーのフィールドは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Vers: 4 bits",
      "ja": "バージョン：4ビット"
    },
    {
      "indent": 9,
      "text": "Protocol version number. This is version 1.",
      "ja": "プロトコルバージョン番号。これはバージョン1です。"
    },
    {
      "indent": 6,
      "text": "Flags: 4 bits",
      "ja": "フラグ：4ビット"
    },
    {
      "indent": 9,
      "text": "0x01: Refresh (overhead) reduction capable",
      "ja": "0x01：更新（オーバーヘッド）削減可能"
    },
    {
      "indent": 11,
      "text": "See Section 2.",
      "ja": "セクション2を参照してください。"
    },
    {
      "indent": 9,
      "text": "0x02-0x08: Reserved",
      "ja": "0x02-0x08：予約"
    },
    {
      "indent": 6,
      "text": "Msg type: 8 bits",
      "ja": "MSGタイプ：8ビット"
    },
    {
      "indent": 9,
      "text": "12 = Bundle",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "RSVP checksum: 16 bits",
      "ja": "RSVPチェックサム：16ビット"
    },
    {
      "indent": 9,
      "text": "The one's complement of the one's complement sum of the entire message, with the checksum field replaced by zero for the purpose of computing the checksum. An all-zero value means that no checksum was transmitted. Because individual sub-messages may carry their own checksum as well as the INTEGRITY object for authentication, this field MAY be set to zero. Note that when the checksum is not computed, the header of the bundle message will not be covered by any checksum. If the checksum is computed, individual sub-messages MAY set their own checksum to zero.",
      "ja": "メッセージ全体の補完合計の補完は、チェックサムを計算する目的でチェックサムフィールドをゼロに置き換えます。全ゼロ値は、チェックサムが送信されなかったことを意味します。個々のサブメッセージは、認証用の整合性オブジェクトと同様に独自のチェックサムを搭載する可能性があるため、このフィールドはゼロに設定される場合があります。チェックサムが計算されていない場合、バンドルメッセージのヘッダーはチェックサムでカバーされないことに注意してください。チェックサムが計算されると、個々のサブメッセージが独自のチェックサムをゼロに設定する場合があります。"
    },
    {
      "indent": 6,
      "text": "Send_TTL: 8 bits",
      "ja": "send_ttl：8ビット"
    },
    {
      "indent": 9,
      "text": "The IP TTL value with which the message was sent. This is used by RSVP to detect a non-RSVP hop by comparing the Send_TTL with the IP TTL in a received message.",
      "ja": "メッセージが送信されたIP TTL値。これは、RSVPが受信したメッセージでsend_ttlとIP TTLを比較することにより、非RSVPホップを検出するために使用されます。"
    },
    {
      "indent": 6,
      "text": "RSVP length: 16 bits",
      "ja": "RSVPの長さ：16ビット"
    },
    {
      "indent": 9,
      "text": "The total length of this RSVP Bundle message in bytes, including the bundle header and the sub-messages that follow.",
      "ja": "バンドルヘッダーとその後のサブメッセージを含む、このRSVPバンドルメッセージの合計長さはバイトでのバイトで。"
    },
    {
      "indent": 0,
      "text": "3.2. Message Formats",
      "section_title": true,
      "ja": "3.2. メッセージ形式"
    },
    {
      "indent": 3,
      "text": "An RSVP Bundle message must contain at least one sub-message. A sub-message MAY be any message type except for another Bundle message.",
      "ja": "RSVPバンドルメッセージには、少なくとも1つのサブメッセージが含まれている必要があります。サブメッセージは、別のバンドルメッセージを除く任意のメッセージタイプになる場合があります。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Vers  | Flags |      12       |         RSVP checksum         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Send_TTL    |  (Reserved)   |         RSVP length           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n//                   First sub-message                         //\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n//                   More sub-messages..                       //\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3. Sending RSVP Bundle Messages",
      "section_title": true,
      "ja": "3.3. RSVPバンドルメッセージの送信"
    },
    {
      "indent": 3,
      "text": "Support for RSVP Bundle messages is optional. While message bundling helps in scaling RSVP, by reducing processing overhead and bandwidth consumption, a node is not required to transmit every standard RSVP message in a Bundle message. A node MUST always be ready to receive standard RSVP messages.",
      "ja": "RSVPバンドルメッセージのサポートはオプションです。メッセージバンドリングはRSVPのスケーリングに役立ちますが、処理オーバーヘッドと帯域幅の消費を削減することにより、すべての標準RSVPメッセージをバンドルメッセージに送信するためにノードは必要ありません。ノードは、常に標準のRSVPメッセージを受信する準備ができている必要があります。"
    },
    {
      "indent": 3,
      "text": "RSVP Bundle messages can only be sent to RSVP neighbors that support bundling. Methods for discovering such information include: (1) manual configuration and (2) observing the Refresh-Reduction-Capable bit (see Section 2) in the received RSVP messages. RSVP Bundle messages MUST NOT be used if the RSVP neighbor does not support RSVP Bundle messages.",
      "ja": "RSVPバンドルメッセージは、バンドルをサポートするRSVPネイバーにのみ送信できます。そのような情報を発見する方法には、（1）手動構成と（2）受信したRSVPメッセージのリフレッシュ削減対応ビット（セクション2を参照）の観察が含まれます。RSVP隣人がRSVPバンドルメッセージをサポートしていない場合、RSVPバンドルメッセージは使用しないでください。"
    },
    {
      "indent": 3,
      "text": "RSVP Bundle messages are sent hop by hop between RSVP-capable nodes as \"raw\" IP datagrams with protocol number 46. The IP source address is an address local to the system that originated the Bundle message. The IP destination address is the RSVP neighbor for which the sub-messages are intended.",
      "ja": "RSVPバンドルメッセージは、RSVP対応ノード間のホップでホップで送信されます。プロトコル番号46の「RAW」IPデータグラムとして。IPソースアドレスは、バンドルメッセージを発信するシステムにローカルなアドレスです。IP宛先アドレスは、サブメッセージが意図されているRSVPネイバーです。"
    },
    {
      "indent": 3,
      "text": "RSVP Bundle messages SHOULD NOT be sent with the Router Alert IP option in their IP headers. This is because Bundle messages are addressed directly to RSVP neighbors.",
      "ja": "RSVPバンドルメッセージは、IPヘッダーにルーターアラートIPオプションを使用して送信しないでください。これは、バンドルメッセージがRSVP近隣に直接宛てられているためです。"
    },
    {
      "indent": 3,
      "text": "Each RSVP Bundle message MUST occupy exactly one IP datagram, which is approximately 64K bytes. If it exceeds the MTU, the datagram is fragmented by IP and reassembled at the recipient node. Implementations may choose to limit each RSVP Bundle message to the MTU size of the outgoing link, e.g., 1500 bytes. Implementations SHOULD also limit the amount of time that a message is delayed in order to be bundled. Different limits may be used for trigger and standard refresh messages. Trigger messages SHOULD be delayed a minimal amount of time. Refresh messages may be delayed up to their refresh interval. Note that messages related to the same Resv or Path state should not be delayed at different intervals in order to preserve ordering.",
      "ja": "各RSVPバンドルメッセージは、約64Kバイトである1つのIPデータグラムを1つだけ占有する必要があります。MTUを超えると、データグラムはIPによって断片化され、受信者ノードで再組み立てされます。実装は、各RSVPバンドルメッセージを発信リンクのMTUサイズ、たとえば1500バイトに制限することを選択できます。また、実装は、バンドルされるためにメッセージが遅延する時間を制限する必要があります。トリガーおよび標準の更新メッセージには、さまざまな制限を使用できます。トリガーメッセージは最小限の時間を遅らせる必要があります。更新メッセージは、更新間隔まで遅れている場合があります。同じRESVまたはパス状態に関連するメッセージは、注文を維持するために異なる間隔で遅延しないでください。"
    },
    {
      "indent": 3,
      "text": "If the RSVP neighbor is not known or changes in next hops cannot be identified via routing, Bundle messages MUST NOT be used. Note that when the routing next hop is not RSVP capable it will typically not be possible to identify changes in next hop.",
      "ja": "RSVPネイバーが不明または次のホップの変更をルーティングで識別できない場合、バンドルメッセージを使用してはなりません。ルーティングの次のホップがrsvp能力がない場合、通常、次のホップの変更を識別することはできないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Any message that will be handled by the RSVP neighbor indicated in a Bundle Message's destination address may be included in the same message. This includes all RSVP messages that would be sent out a point-to-point link. It includes any message, such as a Resv, addressed to the same destination address. It also includes Path and PathTear messages when the next hop is known to be the destination and changes in next hops can be detected. Path and PathTear messages for multicast sessions MUST NOT be sent in Bundle messages when the outgoing link is not a point-to-point link or when the next hop does not support the refresh overhead reduction extensions.",
      "ja": "バンドルメッセージの宛先アドレスに示されているRSVPネイバーによって処理されるメッセージは、同じメッセージに含まれる場合があります。これには、ポイントツーポイントリンクが送信されるすべてのRSVPメッセージが含まれます。同じ宛先アドレスにアドレス指定されたRESVなどのメッセージが含まれます。また、次のホップが目的地であることが知られている場合、パスとパスのメッセージが含まれ、次のホップの変更を検出できます。マルチキャストセッションのPATHとPATHTEARメッセージは、発信リンクがポイントツーポイントリンクではない場合、または次のホップが更新オーバーヘッド削減延長をサポートしていない場合、バンドルメッセージで送信しないでください。"
    },
    {
      "indent": 0,
      "text": "3.4. Receiving RSVP Bundle Messages",
      "section_title": true,
      "ja": "3.4. RSVPバンドルメッセージの受信"
    },
    {
      "indent": 3,
      "text": "If the local system does not recognize or does not wish to accept a Bundle message, the received messages shall be discarded without further analysis.",
      "ja": "ローカルシステムがバンドルメッセージを認識していない、または受け入れたくない場合、受信したメッセージは、さらなる分析なしに破棄されるものとします。"
    },
    {
      "indent": 3,
      "text": "The receiver next compares the Send_TTL with which a Bundle message is sent to the IP TTL with which it is received. If a non-RSVP hop is detected, the number of non-RSVP hops is recorded. It is used later in processing of sub-messages.",
      "ja": "レシーバーは、次に、バンドルメッセージが受信されたIP TTLに送信されるsend_ttlを比較します。非RSVPホップが検出された場合、非RSVPホップの数が記録されます。後でサブメッセージの処理で使用されます。"
    },
    {
      "indent": 3,
      "text": "Next, the receiver verifies the version number and checksum of the RSVP Bundle message and discards the message if any mismatch is found.",
      "ja": "次に、RSVPバンドルメッセージのバージョン番号とチェックサムを確認し、不一致が見つかった場合にメッセージを破棄します。"
    },
    {
      "indent": 3,
      "text": "The receiver then starts decapsulating individual sub-messages. Each sub-message has its own complete message length and authentication information. With the exception of using the Send_TTL from the header of the Bundle message, each sub-message is processed as if it was received individually.",
      "ja": "その後、レシーバーは個々のサブメッセージの脱カプセルを開始します。各サブメッセージには、独自の完全なメッセージの長さと認証情報があります。バンドルメッセージのヘッダーからsend_ttlを使用することを除いて、各サブメッセージは、それが個別に受信されたかのように処理されます。"
    },
    {
      "indent": 0,
      "text": "4. MESSAGE_ID Extension",
      "section_title": true,
      "ja": "4. message_id拡張機能"
    },
    {
      "indent": 3,
      "text": "Three new objects are defined as part of the MESSAGE_ID extension. The objects are the MESSAGE_ID object, the MESSAGE_ID_ACK object, and the MESSAGE_ID_NACK objects. The first two objects are used to support acknowledgments and reliable RSVP message delivery. The last object is used to support the summary refresh extension described in Section 5. The MESSAGE_ID object can also be used to simply provide a shorthand indication of when the message carrying the object is a refresh message. Such information can be used by the receiving node to reduce refresh processing requirements.",
      "ja": "3つの新しいオブジェクトは、message_id拡張子の一部として定義されます。オブジェクトは、Message_IDオブジェクト、message_id_ackオブジェクト、およびmessage_id_nackオブジェクトです。最初の2つのオブジェクトは、謝辞と信頼できるRSVPメッセージ配信をサポートするために使用されます。最後のオブジェクトは、セクション5で説明されている概要の更新拡張機能をサポートするために使用されます。メッセージ_IDオブジェクトは、オブジェクトを運ぶメッセージが更新メッセージであるときの速記を示すために単純に提供することもできます。このような情報は、更新処理要件を削減するために、受信ノードで使用できます。"
    },
    {
      "indent": 3,
      "text": "Message identification and acknowledgment is done on a per hop basis. All types of MESSAGE_ID objects contain a message identifier. The identifier MUST be unique on a per object generator's IP address basis. No more than one MESSAGE_ID object may be included in an RSVP message. Each message containing a MESSAGE_ID object may be acknowledged via a MESSAGE_ID_ACK object, when so indicated. MESSAGE_ID_ACK and MESSAGE_ID_NACK objects may be sent piggy-backed in unrelated RSVP messages or in RSVP Ack messages. RSVP messages carrying any of the three object types may be included in a bundle message. When included, each object is treated as if it were contained in a standard, non-bundled, RSVP message.",
      "ja": "メッセージの識別と承認は、ホップごとに行われます。すべてのタイプのmessage_idオブジェクトには、メッセージ識別子が含まれています。識別子は、Object GeneratorのIPアドレスごとに一意でなければなりません。RSVPメッセージに含まれることはできません。Message_IDオブジェクトを含む各メッセージは、そのように示されている場合、message_id_ackオブジェクトを介して確認される場合があります。message_id_ackおよびmessage_id_nackオブジェクトは、無関係なRSVPメッセージまたはRSVP ACKメッセージでピギーバックされて送信される場合があります。3つのオブジェクトタイプのいずれかを運ぶRSVPメッセージは、バンドルメッセージに含まれる場合があります。含まれる場合、各オブジェクトは、標準のバンドルされていないRSVPメッセージに含まれているかのように扱われます。"
    },
    {
      "indent": 0,
      "text": "4.1. Modification of Standard Message Formats",
      "section_title": true,
      "ja": "4.1. 標準メッセージ形式の変更"
    },
    {
      "indent": 3,
      "text": "The MESSAGE_ID, MESSAGE_ID_ACK and MESSAGE_ID_NACK objects may be included in the standard RSVP messages, as defined in [RFC2205]. When included, one or more MESSAGE_ID_ACK or MESSAGE_ID_NACK objects MUST immediately follow the INTEGRITY object. When no INTEGRITY object is present, the MESSAGE_ID_ACK or MESSAGE_ID_NACK objects MUST immediately follow the message or sub-message header. Only one MESSAGE_ID object MAY be included in a message or sub-message and it MUST follow any present MESSAGE_ID_ACK or MESSAGE_ID_NACK objects. When no MESSAGE_ID_ACK or MESSAGE_ID_NACK objects are present, the MESSAGE_ID object MUST immediately follow the INTEGRITY object. When no INTEGRITY object is present, the MESSAGE_ID object MUST immediately follow the message or sub-message header.",
      "ja": "message_id、message_id_ack、message_id_nackオブジェクトは、[rfc2205]で定義されているように、標準のRSVPメッセージに含まれる場合があります。含まれている場合、1つ以上のmessage_id_ackまたはmessage_id_nackオブジェクトは、整合性オブジェクトに直接従う必要があります。整合性オブジェクトが存在しない場合、message_id_ackまたはmessage_id_nackオブジェクトは、メッセージまたはサブメッセージヘッダーにすぐに続く必要があります。メッセージまたはサブメッセージに含めることができ、現在のmessage_id_ackまたはmessage_id_nackオブジェクトに従う必要があります。message_id_ackまたはmessage_id_nackオブジェクトが存在しない場合、message_idオブジェクトは整合性オブジェクトにすぐに従う必要があります。整合性オブジェクトが存在しない場合、message_idオブジェクトは、メッセージまたはサブメッセージヘッダーにすぐに従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The ordering of the ACK objects for all standard RSVP messages is:\n<Common Header>  [ <INTEGRITY> ]\n                 [ [<MESSAGE_ID_ACK> | <MESSAGE_ID_NACK>] ... ]\n                 [ <MESSAGE_ID> ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.2. MESSAGE_ID Objects",
      "section_title": true,
      "ja": "4.2. message_idオブジェクト"
    },
    {
      "indent": 3,
      "text": "MESSAGE_ID Class = 23",
      "ja": "message_id class = 23"
    },
    {
      "indent": 3,
      "text": "MESSAGE_ID object",
      "ja": "message_idオブジェクト"
    },
    {
      "indent": 6,
      "text": "Class = MESSAGE_ID Class, C_Type = 1",
      "ja": "class = message_id class、c_type = 1"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Flags     |                      Epoch                    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Message_Identifier                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Flags: 8 bits",
      "ja": "フラグ：8ビット"
    },
    {
      "indent": 9,
      "text": "0x01 = ACK_Desired flag",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Indicates that the sender requests the receiver to send an acknowledgment for the message.",
      "ja": "送信者がレシーバーにメッセージの謝辞を送信するよう要求することを示します。"
    },
    {
      "indent": 6,
      "text": "Epoch: 24 bits",
      "ja": "エポック：24ビット"
    },
    {
      "indent": 9,
      "text": "A value that indicates when the Message_Identifier sequence has reset. SHOULD be randomly generated each time a node reboots or the RSVP agent is restarted. The value SHOULD NOT be the same as was used when the node was last operational. This value MUST NOT be changed during normal operation.",
      "ja": "message_identifierシーケンスがリセットされたときを示す値。ノードの再起動またはRSVPエージェントが再起動されるたびにランダムに生成する必要があります。値は、ノードが最後に動作したときに使用されたものと同じであるべきではありません。この値は、通常の操作中に変更してはなりません。"
    },
    {
      "indent": 6,
      "text": "Message_Identifier: 32 bits",
      "ja": "message_identifier：32ビット"
    },
    {
      "indent": 9,
      "text": "When combined with the message generator's IP address, the Message_Identifier field uniquely identifies a message. The values placed in this field change incrementally and only decrease when the Epoch changes or when the value wraps.",
      "ja": "メッセージジェネレーターのIPアドレスと組み合わせると、Message_Identifierフィールドはメッセージを一意に識別します。このフィールドに配置された値は、段階的に変化し、エポックが変化したとき、または値がラップされたときにのみ減少します。"
    },
    {
      "indent": 0,
      "text": "4.3. MESSAGE_ID_ACK and MESSAGE_ID_NACK Objects",
      "section_title": true,
      "ja": "4.3. message_id_ackおよびmessage_id_nackオブジェクト"
    },
    {
      "indent": 3,
      "text": "MESSAGE_ID_ACK Class = 24",
      "ja": "message_id_ack class = 24"
    },
    {
      "indent": 3,
      "text": "MESSAGE_ID_ACK object",
      "ja": "message_id_ackオブジェクト"
    },
    {
      "indent": 6,
      "text": "Class = MESSAGE_ID_ACK Class, C_Type = 1",
      "ja": "class = message_id_ack class、c_type = 1"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Flags     |                      Epoch                    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Message_Identifier                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Flags: 8 bits",
      "ja": "フラグ：8ビット"
    },
    {
      "indent": 9,
      "text": "No flags are currently defined. This field MUST be zero on transmission and ignored on receipt.",
      "ja": "現在、フラグは定義されていません。このフィールドは、送信時にゼロであり、受領時に無視する必要があります。"
    },
    {
      "indent": 6,
      "text": "Epoch: 24 bits",
      "ja": "エポック：24ビット"
    },
    {
      "indent": 9,
      "text": "The Epoch field copied from the message being acknowledged.",
      "ja": "承認されているメッセージからコピーされたエポックフィールド。"
    },
    {
      "indent": 6,
      "text": "Message_Identifier: 32 bits",
      "ja": "message_identifier：32ビット"
    },
    {
      "indent": 9,
      "text": "The Message_Identifier field copied from the message being acknowledged.",
      "ja": "Message_identifierフィールドは、メッセージからコピーされました。"
    },
    {
      "indent": 3,
      "text": "MESSAGE_ID_NACK object",
      "ja": "message_id_nackオブジェクト"
    },
    {
      "indent": 6,
      "text": "Class = MESSAGE_ID_ACK Class, C_Type = 2",
      "ja": "class = message_id_ack class、c_type = 2"
    },
    {
      "indent": 9,
      "text": "Definition is the same as the MESSAGE_ID_ACK object.",
      "ja": "定義はmessage_id_ackオブジェクトと同じです。"
    },
    {
      "indent": 0,
      "text": "4.4. Ack Message Format",
      "section_title": true,
      "ja": "4.4. ACKメッセージ形式"
    },
    {
      "indent": 3,
      "text": "Ack messages carry one or more MESSAGE_ID_ACK or MESSAGE_ID_NACK objects. They MUST NOT contain any MESSAGE_ID objects. Ack messages are sent between neighboring RSVP nodes. The IP destination address of an Ack message is the unicast address of the node that generated the message(s) being acknowledged. For messages with RSVP_HOP objects, such as Path and Resv messages, the address is found in the RSVP_HOP object. For other messages, such as ResvConf, the associated IP address is the source address in the IP header. The IP source address is an address of the node that sends the Ack message.",
      "ja": "ACKメッセージは、1つ以上のmessage_id_ackまたはmessage_id_nackオブジェクトを運びます。メッセージ_idオブジェクトを含めてはなりません。ACKメッセージは、隣接するRSVPノード間で送信されます。ACKメッセージのIP宛先アドレスは、メッセージを生成したノードのユニキャストアドレスです。PATHやRESVメッセージなどのRSVP_HOPオブジェクトを使用したメッセージの場合、アドレスはRSVP_HOPオブジェクトにあります。RESVCONFなどの他のメッセージの場合、関連するIPアドレスはIPヘッダーのソースアドレスです。IPソースアドレスは、ACKメッセージを送信するノードのアドレスです。"
    },
    {
      "indent": 3,
      "text": "The Ack message format is as follows:",
      "ja": "ACKメッセージ形式は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "<ACK Message> ::= <Common Header> [ <INTEGRITY> ]\n                  <MESSAGE_ID_ACK> | <MESSAGE_ID_NACK>\n                  [ [<MESSAGE_ID_ACK> | <MESSAGE_ID_NACK>] ... ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "For Ack messages, the Msg Type field of the Common Header MUST be set to 13.",
      "ja": "ACKメッセージの場合、共通ヘッダーのMSGタイプフィールドを13に設定する必要があります。"
    },
    {
      "indent": 5,
      "text": "Section 4.6 provides guidance on when an Ack message should be used and when MESSAGE_ID objects should be sent piggy-backed in other RSVP messages.",
      "ja": "セクション4.6は、ACKメッセージを使用する時期と、メッセージ_IDオブジェクトを他のRSVPメッセージでピギー支援を送信する時期に関するガイダンスを提供します。"
    },
    {
      "indent": 0,
      "text": "4.5. MESSAGE_ID Object Usage",
      "section_title": true,
      "ja": "4.5. message_idオブジェクトの使用法"
    },
    {
      "indent": 3,
      "text": "The MESSAGE_ID object may be included in any RSVP message other than the Ack and Bundle messages. The MESSAGE_ID object is always generated and processed over a single hop between RSVP neighbors. The IP address of the object generator, i.e., the node that creates the object, is represented in a per RSVP message type specific fashion. For messages with RSVP_HOP objects, such as Path and Resv messages, the generator's IP address is found in the RSVP_HOP object. For other messages, such as ResvConf message, the generator's IP address is the source address in the IP header. Note that MESSAGE_ID objects can only be used in a Bundle sub-messages, but not in a Bundle message. As is always the case with the Bundle message, each sub-message is processed as if it was received individually. This includes processing of MESSAGE_ID objects.",
      "ja": "Message_IDオブジェクトは、ACKおよびバンドルメッセージ以外のRSVPメッセージに含まれる場合があります。Message_idオブジェクトは、常にRSVPネイバーの間の1つのホップで生成および処理されます。オブジェクトジェネレーターのIPアドレス、つまりオブジェクトを作成するノードは、RSVPメッセージタイプの特定のファッションで表されます。PATHやRESVメッセージなどのRSVP_HOPオブジェクトを使用したメッセージの場合、ジェネレーターのIPアドレスはRSVP_HOPオブジェクトにあります。ResvConfメッセージなどの他のメッセージの場合、ジェネレーターのIPアドレスはIPヘッダーのソースアドレスです。message_idオブジェクトは、バンドルサブメッセージでのみ使用できますが、バンドルメッセージでは使用できません。バンドルメッセージの場合は常にそうであるように、各サブメッセージは、個別に受信されたかのように処理されます。これには、message_idオブジェクトの処理が含まれます。"
    },
    {
      "indent": 3,
      "text": "The Epoch field contains a generator selected value. The value is used to indicate when the sender resets the values used in the Message_Identifier field. On startup, a node SHOULD randomly select a value to be used in the Epoch field. The node SHOULD ensure that the selected value is not the same as was used when the node was last operational. The value MUST NOT be changed unless the node or the RSVP agent is restarted.",
      "ja": "エポックフィールドには、ジェネレーターの選択された値が含まれています。この値は、送信者がメッセージ_IDIDIDIERフィールドで使用される値をリセットするときを示すために使用されます。起動時には、ノードはエポックフィールドで使用する値をランダムに選択する必要があります。ノードは、選択した値が、ノードが最後に動作したときに使用されたものと同じではないことを確認する必要があります。ノードまたはRSVPエージェントが再起動されない限り、値を変更してはなりません。"
    },
    {
      "indent": 3,
      "text": "The Message_Identifier field contains a generator selected value. This value, when combined with the generator's IP address, identifies a particular RSVP message and the specific state information it represents. The combination of Message_Identifier and Epoch can also be used to detect out of order messages. When a node is sending a refresh message with a MESSAGE_ID object, it SHOULD use the same Message_Identifier value that was used in the RSVP message that first advertised the state being refreshed. When a node is sending a trigger message, the Message_Identifier value MUST have a value that is greater than any other value previously used with the same Epoch field value. A value is considered to have been used when it has been sent in any message using the associated IP address with the same Epoch field value.",
      "ja": "message_identifierフィールドには、ジェネレーターの選択された値が含まれています。この値は、ジェネレーターのIPアドレスと組み合わせると、特定のRSVPメッセージとそれが表す特定の状態情報を識別します。message_identifierとエポックの組み合わせを使用して、順序のメッセージを検出することもできます。ノードがmessage_idオブジェクトを使用して更新メッセージを送信している場合、RSVPメッセージで使用された同じmessage_identifier値を使用する必要があります。ノードがトリガーメッセージを送信している場合、message_identifier値には、同じエポックフィールド値で以前に使用されていた他の値よりも大きい値が必要です。値は、同じエポックフィールド値を持つ関連するIPアドレスを使用してメッセージで送信されたときに使用されたと見なされます。"
    },
    {
      "indent": 3,
      "text": "The ACK_Desired flag is set when the MESSAGE_ID object generator wants a MESSAGE_ID_ACK object sent in response to the message. Such information can be used to ensure reliable delivery of RSVP messages in the face of network loss. Nodes setting the ACK_Desired flag SHOULD retransmit unacknowledged messages at a more rapid interval than the standard refresh period until the message is acknowledged or until a \"rapid\" retry limit is reached. Rapid retransmission rate MUST be based on the exponential exponential back-off procedures defined in section 6. The ACK_Desired flag will typically be set only in trigger messages. The ACK_Desired flag MAY be set in refresh messages. Issues relate to multicast sessions are covered in a later section.",
      "ja": "ACK_DESIREDフラグは、メッセージに応答して送信されたmessage_idオブジェクトジェネレーターがmessage_id_ackオブジェクトを必要とするときに設定されます。このような情報は、ネットワーク損失に直面してRSVPメッセージの信頼できる配信を確保するために使用できます。ノードACK_DESIREDフラグを設定すると、メッセージが認められるまで、または「迅速な」再試行制限に達するまで、標準の更新期間よりも迅速な間隔で未装填メッセージを再送信する必要があります。迅速な再送信率は、セクション6で定義されている指数指数バックオフ手順に基づいている必要があります。ACK_DESIREDフラグは、通常、トリガーメッセージでのみ設定されます。ACK_Desiredフラグは、更新メッセージで設定できます。マルチキャストセッションに関連する問題については、後のセクションで説明します。"
    },
    {
      "indent": 3,
      "text": "Nodes processing incoming MESSAGE_ID objects SHOULD check to see if a newly received message is out of order and can be ignored. Out of order messages SHOULD be ignored, i.e., silently dropped. Out of order messages can be identified by examining the values in the Epoch and Message_Identifier fields. To determine ordering, the received Epoch value must match the value previously received from the message sender. If the values differ then the receiver MUST NOT treat the message as out of order. When the Epoch values match and the Message_Identifier value is less than the largest value previously received from the sender, then the receiver SHOULD check the value previously received for the state associated with the message. This check should be performed for any message that installs or changes state. (Includes at least: Path, Resv, PathTear, ResvTear, PathErr and ResvErr.) If no local state information can be associated with the message, the receiver MUST NOT treat the message as out of order. If local state can be associated with the message and the received Message_Identifier value is less than the most recently received value associated with the state, the message SHOULD be treated as being out of order.",
      "ja": "ノードの処理受信message_idオブジェクトは、新しく受信したメッセージが故障していて無視できるかどうかを確認する必要があります。順序外のメッセージは無視する必要があります。つまり、静かにドロップされます。Out Aut Orderメッセージは、EpochおよびMessage_Identifierフィールドの値を調べることで識別できます。順序付けを決定するには、受信したエポック値は、メッセージ送信者から以前に受信した値と一致する必要があります。値が異なる場合、受信者はメッセージを故障として扱ってはなりません。エポック値が一致し、Message_Identifier値が送信者から以前に受信した最大値よりも少ない場合、受信者はメッセージに関連付けられた状態に対して以前に受信された値を確認する必要があります。このチェックは、状態をインストールまたは変更するメッセージに対して実行する必要があります。（少なくとも含む：PATH、RESV、PATHTEAR、RESVTEAR、PATHERR、RESVERR。）ローカル状態情報をメッセージに関連付けることができない場合、レシーバーはメッセージを故障として扱ってはなりません。現地の状態がメッセージに関連付けられ、受信したmessage_identifier値が州に関連付けられた最近の受信価値よりも少ない場合、メッセージは故障していると扱われるべきです。"
    },
    {
      "indent": 3,
      "text": "Note that the 32-bit Message_Identifier value MAY wrap. To cover the wrap case, the following expression may be used to test if a newly received Message_Identifier value is less than a previously received value:",
      "ja": "32ビットmessage_identifier値がラップする場合があることに注意してください。ラップケースをカバーするために、次の式を使用して、新しく受信したmessage_identifier値が以前に受信した値よりも少ないかどうかをテストできます。"
    },
    {
      "indent": 7,
      "text": "if ((int) old_id - (int) new_id > 0) {\n   new value is less than old value;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "MESSAGE_ID objects of messages that are not out of order SHOULD be used to aid in determining if the message represents new state or a state refresh. Note that state is only refreshed in Path and Resv messages. If the received Epoch values differs from the value previously received from the message sender, the message is a trigger message and the receiver MUST fully process the message. If a Path or Resv message contains the same Message_Identifier value that was used in the most recently received message for the same session and, for Path messages, SENDER_TEMPLATE then the receiver SHOULD treat the message as a state refresh. If the Message_Identifier value is greater than the most recently received value, the receiver MUST fully processes the message. When fully processing a Path or Resv message, the receiver MUST store the received Message_Identifier value as part of the local Path or Resv state for future reference.",
      "ja": "メッセージが順調でないメッセージのMessage_idオブジェクトは、メッセージが新しい状態または状態の更新を表すかどうかを判断するのに役立つために使用する必要があります。状態はPATHおよびRESVメッセージでのみ更新されていることに注意してください。受信したエポック値がメッセージ送信者から以前に受信された値と異なる場合、メッセージはトリガーメッセージであり、受信者はメッセージを完全に処理する必要があります。パスまたはRESVメッセージに、同じセッションの最近受信したメッセージで使用された同じメッセージ_Identifier値が含まれている場合、パスメッセージの場合、sender_templateの場合、受信者はメッセージを状態の更新として扱う必要があります。message_identifier値が最近受信した値よりも大きい場合、受信者はメッセージを完全に処理する必要があります。パスまたはRESVメッセージを完全に処理する場合、受信者は将来の参照のためにローカルパスまたはRESV状態の一部として受信したmessage_identifier値を保存する必要があります。"
    },
    {
      "indent": 3,
      "text": "Nodes receiving a non-out of order message containing a MESSAGE_ID object with the ACK_Desired flag set, SHOULD respond with a MESSAGE_ID_ACK object. Note that MESSAGE_ID objects received in messages containing errors, i.e., are not syntactically valid, MUST NOT be acknowledged. PathErr and ResvErr messages SHOULD be treated as implicit acknowledgments.",
      "ja": "ACK_DESIREDフラグセットを使用してMessage_IDオブジェクトを含む注文メッセージの非アウトを受信するノードは、message_id_ackオブジェクトで応答する必要があります。エラー、つまり構文的に有効ではないメッセージで受信されたMessage_idオブジェクトは、確認してはならないことに注意してください。PatherrおよびResverrメッセージは、暗黙の謝辞として扱う必要があります。"
    },
    {
      "indent": 0,
      "text": "4.6. MESSAGE_ID_ACK Object and MESSAGE_ID_NACK Object Usage",
      "section_title": true,
      "ja": "4.6. message_id_ackオブジェクトとmessage_id_nackオブジェクトの使用法"
    },
    {
      "indent": 3,
      "text": "The MESSAGE_ID_ACK object is used to acknowledge receipt of messages containing MESSAGE_ID objects that were sent with the ACK_Desired flag set. A MESSAGE_ID_ACK object MUST NOT be generated in response to a received MESSAGE_ID object when the ACK_Desired flag is not set.",
      "ja": "Message_id_ackオブジェクトは、ACK_Desiredフラグセットで送信されたMessage_IDオブジェクトを含むメッセージの受信を確認するために使用されます。ack_desiredフラグが設定されていない場合、message_id_ackオブジェクトは、受信したmessage_idオブジェクトに応じて生成してはなりません。"
    },
    {
      "indent": 3,
      "text": "The MESSAGE_ID_NACK object is used as part of the summary refresh extension. The generation and processing of MESSAGE_ID_NACK objects is described in further detail in Section 5.4.",
      "ja": "message_id_nackオブジェクトは、概要更新拡張機能の一部として使用されます。message_id_nackオブジェクトの生成と処理については、セクション5.4で詳細に説明します。"
    },
    {
      "indent": 3,
      "text": "MESSAGE_ID_ACK and MESSAGE_ID_NACK objects MAY be sent in any RSVP message that has an IP destination address matching the generator of the associated MESSAGE_ID object. This means that the objects will not typically be included in the non hop-by-hop Path, PathTear and ResvConf messages. When no appropriate message is available, one or more objects SHOULD be sent in an Ack message. Implementations SHOULD include MESSAGE_ID_ACK and MESSAGE_ID_NACK objects in standard RSVP messages when possible.",
      "ja": "message_id_ackおよびmessage_id_nackオブジェクトは、関連するmessage_idオブジェクトのジェネレーターに一致するIP宛先アドレスを持つRSVPメッセージで送信される場合があります。これは、オブジェクトが通常、非ホップバイホップパス、PATHTEAR、およびRESVCONFメッセージに含まれないことを意味します。適切なメッセージが利用できない場合は、1つ以上のオブジェクトをACKメッセージに送信する必要があります。実装には、可能な場合は標準のRSVPメッセージにmessage_id_ackおよびmessage_id_nackオブジェクトを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD limit the amount of time that an object is delayed in order to be piggy-backed or sent in an Ack message. Different limits may be used for MESSAGE_ID_ACK and MESSAGE_ID_NACK objects. MESSAGE_ID_ACK objects are used to detect link transmission losses. If an ACK object is delayed too long, the corresponding message will be retransmitted. To avoid such retransmission, ACK objects SHOULD be delayed a minimal amount of time. A delay time equal to the link transit time MAY be used. MESSAGE_ID_NACK objects may be delayed an independent and longer time, although additional delay increases the amount of time a desired reservation is not installed.",
      "ja": "実装では、オブジェクトが遅延する時間を制限して、ACKメッセージで貯金張りまたは送信するために制限する必要があります。message_id_ackおよびmessage_id_nackオブジェクトには、さまざまな制限を使用できます。message_id_ackオブジェクトは、リンク送信の損失を検出するために使用されます。ACKオブジェクトが長すぎると、対応するメッセージが再送信されます。このような再送信を避けるために、ACKオブジェクトは最小限の時間を遅らせる必要があります。リンクトランジット時間に等しい遅延時間を使用できます。message_id_nackオブジェクトは、独立した時間が長く遅れている場合がありますが、追加の遅延により、希望する予約がインストールされていない時間が増加します。"
    },
    {
      "indent": 0,
      "text": "4.7. Multicast Considerations",
      "section_title": true,
      "ja": "4.7. マルチキャストの考慮事項"
    },
    {
      "indent": 3,
      "text": "Path and PathTear messages may be sent to IP multicast destination addresses. When the destination is a multicast address, it is possible that a single message containing a single MESSAGE_ID object will be received by multiple RSVP next hops. When the ACK_Desired flag is set in this case, acknowledgment processing is more complex.",
      "ja": "PATHおよびPATHTEARメッセージは、IPマルチキャスト宛先アドレスに送信される場合があります。宛先がマルチキャストアドレスである場合、単一のメッセージ_IDオブジェクトを含む単一のメッセージが複数のRSVP次のホップによって受信される可能性があります。この場合、ACK_DESIREDフラグが設定されると、確認処理がより複雑になります。"
    },
    {
      "indent": 3,
      "text": "There are a number of issues to be addressed including ACK implosion, number of acknowledgments to be expected and handling of new receivers.",
      "ja": "ACK爆発、予想される謝辞の数、新しい受信機の処理など、対処すべき多くの問題があります。"
    },
    {
      "indent": 3,
      "text": "ACK implosion occurs when each receiver responds to the MESSAGE_ID object at approximately the same time. This can lead to a potentially large number of MESSAGE_ID_ACK objects being simultaneously delivered to the message generator. To address this case, the receiver MUST wait a random interval prior to acknowledging a MESSAGE_ID object received in a message destined to a multicast address. The random interval SHOULD be between zero (0) and a configured maximum time. The configured maximum SHOULD be set in proportion to the refresh and \"rapid\" retransmission interval, i.e, such that the maximum time before sending an acknowledgment does not result in retransmission. It should be noted that ACK implosion is being addressed by spreading acknowledgments out in time, not by ACK suppression.",
      "ja": "ACK爆発は、各レシーバーがほぼ同時にmessage_idオブジェクトに応答すると発生します。これにより、潜在的に多数のMessage_id_ackオブジェクトが同時にメッセージジェネレーターに配信される可能性があります。このケースに対処するには、レシーバーは、マルチキャストアドレスに導かれたメッセージで受信されたメッセージ_IDオブジェクトを確認する前に、ランダム間隔を待つ必要があります。ランダム間隔は、ゼロ（0）と構成された最大時間の間である必要があります。構成された最大値は、更新および「迅速な」再送信間隔に比例して設定する必要があります。つまり、確認を送信する前の最大時間が再送信されないようにします。ACK抑制は、ACK抑制ではなく、時間内に謝辞を広めることにより、ACK爆発が対処されていることに注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "A more fundamental issue is the number of acknowledgments that the upstream node, i.e., the message generator, should expect. The number of acknowledgments that should be expected is the same as the number of RSVP next hops. In the router-to-router case, the number of next hops can often be obtained from routing. When hosts are either the upstream node or the next hops, the number of next hops will typically not be readily available. Another case where the number of RSVP next hops will typically not be known is when there are non-RSVP routers between the message generator and the RSVP next hops.",
      "ja": "より基本的な問題は、上流ノード、つまりメッセージジェネレーターが期待すべき謝辞の数です。予想すべき謝辞の数は、次のホップのRSVPの数と同じです。ルーターからルーター間のケースでは、次のホップの数をルーティングから取得できることがよくあります。ホストがアップストリームノードまたは次のホップのいずれかである場合、次のホップの数は通常、容易に利用できません。次のRSVPの次のホップの数が通常知られていない別のケースは、メッセージジェネレーターとRSVPの次のホップの間に非RSVPルーターがある場合です。"
    },
    {
      "indent": 3,
      "text": "When the number of next hops is not known, the message generator SHOULD only expect a single response. The result of this behavior will be special retransmission handling until the message is delivered to at least one next hop, then followed by standard RSVP refreshes. Refresh messages will synchronize state with any next hops that don't receive the original message.",
      "ja": "次のホップの数が不明な場合、メッセージジェネレーターは単一の応答のみを期待する必要があります。この動作の結果は、メッセージが少なくとも1つの次のホップに配信され、その後標準のRSVPリフレッシュが続くまで、特別な再送信処理となります。メッセージを更新すると、元のメッセージが表示されない次のホップと状態を同期します。"
    },
    {
      "indent": 0,
      "text": "4.7.1. Reference RSVP/Routing Interface",
      "section_title": true,
      "ja": "4.7.1. RSVP/ルーティングインターフェイスを参照します"
    },
    {
      "indent": 3,
      "text": "When using the MESSAGE_ID extension with multicast sessions it is preferable for RSVP to obtain the number of next hops from routing and to be notified when that number changes. The interface between routing and RSVP is purely an implementation issue. Since RSVP [RFC2205] describes a reference routing interface, a version of the RSVP/routing interface updated to provide number of next hop information is presented. See [RFC2205] for previously defined parameters and function description.",
      "ja": "マルチキャストセッションでmessage_id拡張子を使用する場合、RSVPがルーティングから次のホップの数を取得し、その数が変更されたときに通知されることが望ましいです。ルーティングとRSVPの間のインターフェイスは、純粋に実装の問題です。RSVP [RFC2205]は参照ルーティングインターフェイスを記述しているため、次のホップ情報を提供するために更新されたRSVP/ルーティングインターフェイスのバージョンが表示されます。以前に定義されたパラメーターと関数の説明については、[RFC2205]を参照してください。"
    },
    {
      "indent": 6,
      "text": "o Route Query Mcast_Route_Query( [ SrcAddress, ] DestAddress, Notify_flag ) -> [ IncInterface, ] OutInterface_list, NHops_list",
      "ja": "o ルートクエリmcast_route_query（[srcaddress、] destaddress、notify_flag） - > [incinterface、] outinterface_list、nhops_list"
    },
    {
      "indent": 6,
      "text": "o Route Change Notification Mcast_Route_Change( ) -> [ SrcAddress, ] DestAddress, [ IncInterface, ] OutInterface_list, NHops_list",
      "ja": "o ルート変更通知mcast_route_change（） - > [srcaddress、] destaddress、[incinterface、] outinterface_list、nhops_list"
    },
    {
      "indent": 6,
      "text": "NHops_list provides the number of multicast group members reachable via each OutInterface_list entry.",
      "ja": "NHOPS_LISTは、各OutInterface_Listエントリを介して到達可能なマルチキャストグループメンバーの数を提供します。"
    },
    {
      "indent": 0,
      "text": "4.8. Compatibility",
      "section_title": true,
      "ja": "4.8. 互換性"
    },
    {
      "indent": 3,
      "text": "All nodes sending messages with the Refresh-Reduction-Capable bit set will support the MESSAGE_ID Extension. There are no backward compatibility issues raised by the MESSAGE_ID Class with nodes that do not set the Refresh-Reduction-Capable bit. The MESSAGE_ID Class has an assigned value whose form is 0bbbbbbb. Per RSVP [RFC2205], classes with values of this form must be rejected with an \"Unknown Object Class\" error by nodes not supporting the class. When the receiver of a MESSAGE_ID object does not support the class, a corresponding error message will be generated. The generator of the MESSAGE_ID object will see the error and then MUST re-send the original message without the MESSAGE_ID object. In this case, the message generator MAY still choose to retransmit messages at the \"rapid\" retransmission interval. Lastly, since the MESSAGE_ID_ACK class can only be issued in response to the MESSAGE_ID object, there are no possible issues with this class or Ack messages. A node MAY support the MESSAGE_ID Extension without supporting the other refresh overhead reduction extensions.",
      "ja": "リフレッシュ削減対応ビットセットでメッセージを送信するすべてのノードは、メッセージ_ID拡張機能をサポートします。message_idクラスによって提起された逆方向の互換性の問題はありません。ノードは、リフレッシュ削減対応ビットを設定していません。message_idクラスには、フォームが0bbbbbbbbの割り当てされた値があります。RSVP [RFC2205]ごとに、このフォームの値を持つクラスは、クラスをサポートしないノードによる「不明なオブジェクトクラス」エラーで拒否する必要があります。message_idオブジェクトの受信者がクラスをサポートしていない場合、対応するエラーメッセージが生成されます。message_idオブジェクトのジェネレーターはエラーが表示され、message_idオブジェクトなしで元のメッセージを再送信する必要があります。この場合、メッセージジェネレーターは引き続き「迅速な」再送信間隔でメッセージを再送信することを選択できます。最後に、message_id_ackクラスはmessage_idオブジェクトに応じてのみ発行できるため、このクラスまたはACKメッセージには可能な問題はありません。ノードは、他の更新オーバーヘッド削減拡張機能をサポートせずにメッセージ_ID拡張機能をサポートできます。"
    },
    {
      "indent": 0,
      "text": "5. Summary Refresh Extension",
      "section_title": true,
      "ja": "5. 概要更新拡張機能"
    },
    {
      "indent": 3,
      "text": "The summary refresh extension enables the refreshing of RSVP state without the transmission of standard Path or Resv messages. The benefits of the described extension are that it reduces the amount of information that must be transmitted and processed in order to maintain RSVP state synchronization. Importantly, the described extension preserves RSVP's ability to handle non-RSVP next hops and to adjust to changes in routing. This extension cannot be used with Path or Resv messages that contain any change from previously transmitted messages, i.e., are trigger messages.",
      "ja": "概要の更新拡張機能により、標準のパスまたはRESVメッセージを送信せずにRSVP状態をリフレッシュできます。記載されている拡張の利点は、RSVP状態の同期を維持するために送信および処理する必要がある情報の量を減らすことです。重要なことに、記載されている拡張機能は、RSVPの次のホップを処理し、ルーティングの変更に合わせて調整する能力を保持します。この拡張子は、以前に送信されたメッセージからの変更、つまりトリガーメッセージを含むPATHまたはRESVメッセージで使用することはできません。"
    },
    {
      "indent": 3,
      "text": "The summary refresh extension builds on the previously defined MESSAGE_ID extension. Only state that was previously advertised in Path and Resv messages containing MESSAGE_ID objects can be refreshed via the summary refresh extension.",
      "ja": "概要更新拡張機能は、以前に定義されたmessage_id拡張機能に基づいています。Message_idオブジェクトを含むPATHおよびRESVメッセージで以前に宣伝されていた状態のみは、概要更新拡張機能を介して更新できます。"
    },
    {
      "indent": 3,
      "text": "The summary refresh extension uses the objects and the ACK message previously defined as part of the MESSAGE_ID extension, and a new Srefresh message. The new message carries a list of Message_Identifier fields corresponding to the Path and Resv trigger messages that established the state. The Message_Identifier fields are carried in one of three Srefresh related objects. The three objects are the MESSAGE_ID LIST object, the MESSAGE_ID SRC_LIST object, and the MESSAGE_ID MCAST_LIST object.",
      "ja": "概要更新拡張機能は、Message_ID拡張子の一部として以前に定義されていたオブジェクトとACKメッセージを使用し、新しいsrefreshメッセージを使用します。新しいメッセージには、PATHに対応するMessage_Identifierフィールドのリストと、状態を確立したメッセージをトリガーします。message_identifierフィールドは、3つのSrefresh関連オブジェクトのいずれかに配置されます。3つのオブジェクトは、message_idリストオブジェクト、message_id src_listオブジェクト、およびmessage_id mcast_listオブジェクトです。"
    },
    {
      "indent": 3,
      "text": "The MESSAGE_ID LIST object is used to refresh all Resv state, and Path state of unicast sessions. It is made up of a list of Message_Identifier fields that were originally advertised in MESSAGE_ID objects. The other two objects are used to refresh Path state of multicast sessions. A node receiving a summary refresh for multicast path state will at times need source and group information. These two objects provide this information. The objects differ in the information they contain and how they are sent. Both carry Message_Identifier fields and corresponding source IP addresses. The MESSAGE_ID SRC_LIST is sent in messages addressed to the session's multicast IP address. The MESSAGE_ID MCAST_LIST object adds the group address and is sent in messages addressed to the RSVP next hop. The MESSAGE_ID MCAST_LIST is normally used on point-to-point links.",
      "ja": "Message_idリストオブジェクトは、すべてのRESV状態とユニキャストセッションのパス状態を更新するために使用されます。これは、Message_idオブジェクトで最初に宣伝されていたmessage_identifierフィールドのリストで構成されています。他の2つのオブジェクトは、マルチキャストセッションのパス状態を更新するために使用されます。マルチキャストパス状態の概要更新を受信するノードには、ソースとグループ情報が必要になる場合があります。これらの2つのオブジェクトはこの情報を提供します。オブジェクトは、含まれている情報と送信方法が異なります。どちらも、message_identifierフィールドと対応するソースIPアドレスを運びます。Message_ID SRC_LISTは、セッションのマルチキャストIPアドレスにアドレス指定されたメッセージで送信されます。message_id mcast_listオブジェクトはグループアドレスを追加し、RSVP Next Hopにアドレス指定されたメッセージで送信されます。Message_id mcast_listは通常、ポイントツーポイントリンクで使用されます。"
    },
    {
      "indent": 3,
      "text": "An RSVP node receiving an Srefresh message, matches each listed Message_Identifier field with installed Path or Resv state. All matching state is updated as if a normal RSVP refresh message has been received. If matching state cannot be found, then the Srefresh message sender is notified via a refresh NACK.",
      "ja": "srefreshメッセージを受信するRSVPノードは、リストされている各メッセージ_IdentifierフィールドとインストールされたパスまたはRESV状態を一致させます。すべてのマッチング状態は、通常のRSVP更新メッセージが受信されているかのように更新されます。一致する状態が見つからない場合、srefreshメッセージ送信者は更新されたナックで通知されます。"
    },
    {
      "indent": 3,
      "text": "A refresh NACK is sent via the MESSAGE_ID_NACK object. As described in the previous section, the rules for sending a MESSAGE_ID_NACK object are the same as for sending a MESSAGE_ID_ACK object. This includes sending MESSAGE_ID_NACK object both piggy-backed in unrelated RSVP messages or in RSVP ACK messages.",
      "ja": "更新されたnackは、message_id_nackオブジェクトから送信されます。前のセクションで説明したように、message_id_nackオブジェクトを送信するためのルールは、message_id_ackオブジェクトを送信する場合と同じです。これには、無関係なRSVPメッセージまたはRSVP ACKメッセージでPiggyバックされたMessage_id_nackオブジェクトの送信が含まれます。"
    },
    {
      "indent": 0,
      "text": "5.1. MESSAGE_ID LIST, SRC_LIST and MCAST_LIST Objects",
      "section_title": true,
      "ja": "5.1. message_idリスト、src_list、mcast_listオブジェクト"
    },
    {
      "indent": 3,
      "text": "MESSAGE_ID LIST object",
      "ja": "Message_idリストオブジェクト"
    },
    {
      "indent": 3,
      "text": "MESSAGE_ID_LIST Class = 25",
      "ja": "message_id_list class = 25"
    },
    {
      "indent": 6,
      "text": "Class = MESSAGE_ID_LIST Class, C_Type = 1",
      "ja": "class = message_id_list class、c_type = 1"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Flags     |                      Epoch                    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Message_Identifier                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                 :                             |\n//                                :                            //\n|                                 :                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Message_Identifier                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Flags: 8 bits",
      "ja": "フラグ：8ビット"
    },
    {
      "indent": 9,
      "text": "No flags are currently defined. This field MUST be zero on transmission and ignored on receipt.",
      "ja": "現在、フラグは定義されていません。このフィールドは、送信時にゼロであり、受領時に無視する必要があります。"
    },
    {
      "indent": 6,
      "text": "Epoch: 24 bits",
      "ja": "エポック：24ビット"
    },
    {
      "indent": 9,
      "text": "The Epoch field from the MESSAGE_ID object corresponding to the trigger message that advertised the state being refreshed.",
      "ja": "更新されている状態を宣伝したトリガーメッセージに対応するMessage_idオブジェクトからのエポックフィールド。"
    },
    {
      "indent": 6,
      "text": "Message_Identifier: 32 bits",
      "ja": "message_identifier：32ビット"
    },
    {
      "indent": 9,
      "text": "The Message_Identifier field from the MESSAGE_ID object corresponding to the trigger message that advertised the state being refreshed. One or more Message_Identifiers may be included.",
      "ja": "更新されている状態を宣伝したトリガーメッセージに対応するMessage_idオブジェクトからのmessage_identifierフィールド。1つ以上のmessage_identifiersを含めることができます。"
    },
    {
      "indent": 3,
      "text": "IPv4/MESSAGE_ID SRC_LIST object",
      "ja": "ipv4/message_id src_listオブジェクト"
    },
    {
      "indent": 6,
      "text": "Class = MESSAGE_ID_LIST Class, C_Type = 2",
      "ja": "class = message_id_list class、c_type = 2"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Flags     |                      Epoch                    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                              Source_                          |\n|                      Message_Identifier_Tuple                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                 :                             |\n//                                :                            //\n|                                 :                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                              Source_                          |\n|                      Message_Identifier_Tuple                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where a Source_Message_Identifier_Tuple consists of:",
      "ja": "source_message_identifier_tupleが構成されている場合："
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Message_Identifier                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Source_IP_Address (4 bytes)                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "IPv6/MESSAGE_ID SRC_LIST object",
      "ja": "IPv6/message_id src_listオブジェクト"
    },
    {
      "indent": 6,
      "text": "Class = MESSAGE_ID_LIST Class, C_Type = 3",
      "ja": "class = message_id_list class、c_type = 3"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Flags     |                      Epoch                    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                            IPv6_Source_                       |\n|                      Message_Identifier_Tuple                 |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                 :                             |\n//                                :                            //\n|                                 :                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                            IPv6_Source_                       |\n|                      Message_Identifier_Tuple                 |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where a IPv6 Source_Message_Identifier_Tuple consists of:",
      "ja": "ipv6 source_message_identifier_tupleが次のことを構成する場合："
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Message_Identifier                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                      IPv6 Source_IP_Address                   |\n|                            (16 Bytes)                         |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Flags: 8 bits",
      "ja": "フラグ：8ビット"
    },
    {
      "indent": 9,
      "text": "No flags are currently defined. This field MUST be zero on transmission and ignored on receipt.",
      "ja": "現在、フラグは定義されていません。このフィールドは、送信時にゼロであり、受領時に無視する必要があります。"
    },
    {
      "indent": 6,
      "text": "Epoch: 24 bits",
      "ja": "エポック：24ビット"
    },
    {
      "indent": 9,
      "text": "The Epoch field from the MESSAGE_ID object corresponding to the trigger message that advertised the state being refreshed.",
      "ja": "更新されている状態を宣伝したトリガーメッセージに対応するMessage_idオブジェクトからのエポックフィールド。"
    },
    {
      "indent": 6,
      "text": "Message_Identifier",
      "ja": "message_identifier"
    },
    {
      "indent": 9,
      "text": "The Message_Identifier field from the MESSAGE_ID object corresponding to the trigger message that advertised the Path state being refreshed. One or more Message_Identifiers may be included. Each Message_Identifier MUST be followed by the source IP address corresponding to the sender described in the Path state being refreshed.",
      "ja": "PATH状態が更新されているトリガーメッセージに対応するMessage_IDオブジェクトからのmessage_identifierフィールド。1つ以上のmessage_identifiersを含めることができます。各message_identifierの後に、リフレッシュするパス状態で説明されている送信者に対応するソースIPアドレスが続く必要があります。"
    },
    {
      "indent": 6,
      "text": "Source_IP_Address",
      "ja": "source_ip_address"
    },
    {
      "indent": 9,
      "text": "The IP address corresponding to the sender of the Path state being refreshed.",
      "ja": "パス状態の送信者に対応するIPアドレスは更新されています。"
    },
    {
      "indent": 6,
      "text": "IPv4/MESSAGE_ID MCAST_LIST object",
      "ja": "ipv4/message_id mcast_listオブジェクト"
    },
    {
      "indent": 6,
      "text": "Class = MESSAGE_ID_LIST Class, C_Type = 4",
      "ja": "class = message_id_list class、c_type = 4"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Flags     |                      Epoch                    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             Multicast_                        |\n|                        Message_Identifier_                    |\n|                               Tuple                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                 :                             |\n//                                :                            //\n|                                 :                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             Multicast_                        |\n|                        Message_Identifier_                    |\n|                               Tuple                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where a Multicast_Message_Identifier_Tuple consists of:",
      "ja": "multicast_message_identifier_tupleが構成されている場合："
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Message_Identifier                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Source_IP_Address (4 bytes)                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Destination_IP_Address (4 bytes)              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "IPv6/MESSAGE_ID MCAST_LIST object",
      "ja": "ipv6/message_id mcast_listオブジェクト"
    },
    {
      "indent": 6,
      "text": "Class = MESSAGE_ID_LIST Class, C_Type = 5",
      "ja": "class = message_id_list class、c_type = 5"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Flags     |                      Epoch                    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                                                               |\n|                                                               |\n|                           IPv6 Multicast_                     |\n|                        Message_Identifier_                    |\n|                               Tuple                           |\n|                                                               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                 :                             |\n//                                :                            //\n|                                 :                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                                                               |\n|                                                               |\n|                           IPv6 Multicast_                     |\n|                        Message_Identifier_                    |\n|                               Tuple                           |\n|                                                               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where a IPv6 Multicast_Message_Identifier_Tuple consists of:",
      "ja": "IPv6 multicast_message_identifier_tupleが構成されている場合："
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Message_Identifier                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                      IPv6 Source_IP_Address                   |\n|                            (16 Bytes)                         |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                     IPv6 Destination_IP_Address               |\n|                            (16 Bytes)                         |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Flags: 8 bits",
      "ja": "フラグ：8ビット"
    },
    {
      "indent": 9,
      "text": "No flags are currently defined. This field MUST be zero on transmission and ignored on receipt.",
      "ja": "現在、フラグは定義されていません。このフィールドは、送信時にゼロであり、受領時に無視する必要があります。"
    },
    {
      "indent": 6,
      "text": "Epoch: 24 bits",
      "ja": "エポック：24ビット"
    },
    {
      "indent": 9,
      "text": "The Epoch field from the MESSAGE_ID object corresponding to the trigger message that advertised the state being refreshed.",
      "ja": "更新されている状態を宣伝したトリガーメッセージに対応するMessage_idオブジェクトからのエポックフィールド。"
    },
    {
      "indent": 6,
      "text": "Message_Identifier: 32 bits",
      "ja": "message_identifier：32ビット"
    },
    {
      "indent": 9,
      "text": "The Message_Identifier field from the MESSAGE_ID object corresponding to the trigger message that advertised the Path state being refreshed. One or more Message_Identifiers may be included. Each Message_Identifier MUST be followed by the source IP address corresponding to the sender of the Path state being refreshed, and the destination IP address of the session.",
      "ja": "PATH状態が更新されているトリガーメッセージに対応するMessage_IDオブジェクトからのmessage_identifierフィールド。1つ以上のmessage_identifiersを含めることができます。各message_identifierの後に、パス状態の送信者に対応するソースIPアドレスが更新され、セッションの宛先IPアドレスが続く必要があります。"
    },
    {
      "indent": 6,
      "text": "Source_IP_Address",
      "ja": "source_ip_address"
    },
    {
      "indent": 9,
      "text": "The IP address corresponding to the sender of the Path state being refreshed.",
      "ja": "パス状態の送信者に対応するIPアドレスは更新されています。"
    },
    {
      "indent": 6,
      "text": "Destination_IP_Address",
      "ja": "destination_ip_address"
    },
    {
      "indent": 9,
      "text": "The destination IP address corresponding to the session of the Path state being refreshed.",
      "ja": "パス状態のセッションに対応する宛先IPアドレスは更新されます。"
    },
    {
      "indent": 0,
      "text": "5.2. Srefresh Message Format",
      "section_title": true,
      "ja": "5.2. srefreshメッセージ形式"
    },
    {
      "indent": 3,
      "text": "Srefresh messages carry one or more MESSAGE_ID LIST, MESSAGE_ID SRC_LIST, and MESSAGE_ID MCAST_LIST objects. MESSAGE_ID LIST and MESSAGE_ID MCAST_LIST objects MAY be carried in the same Srefresh message. MESSAGE_ID SRC_LIST can not be combined in Srefresh messages with the other objects. A single Srefresh message MAY refresh both Path and Resv state.",
      "ja": "srefreshメッセージは、1つ以上のmessage_idリスト、message_id src_list、message_id mcast_listオブジェクトを伝えます。message_idリストとmessage_id mcast_listオブジェクトは、同じsrefreshメッセージに掲載される場合があります。message_id src_listは、他のオブジェクトとSrefreshメッセージで結合することはできません。単一のsrefreshメッセージは、パスとRESVの両方の状態を更新する場合があります。"
    },
    {
      "indent": 3,
      "text": "Srefresh messages carrying Message_Identifier fields corresponding to Path state are normally sent with a destination IP address equal to the address carried in the corresponding SESSION objects. The destination IP address MAY be set to the RSVP next hop when the next hop is known to be RSVP capable and either (a) the session is unicast or (b) the outgoing interface is a point-to-point link. Srefresh messages carrying Message_Identifier fields corresponding to Resv state MUST be sent with a destination IP address set to the Resv state's previous hop.",
      "ja": "PATH状態に対応するmessage_identifierフィールドを運ぶsrefreshメッセージは、通常、対応するセッションオブジェクトに掲載されたアドレスに等しい宛先IPアドレスで送信されます。宛先IPアドレスは、次のホップがRSVPが有能であることが知られている場合、（a）セッションがユニキャストまたは（b）発信インターフェイスがポイントツーポイントリンクであることが知られている場合、RSVP次のホップに設定できます。RESV状態に対応するmessage_identifierフィールドを運ぶsrefreshメッセージは、RESV状態の前のホップに設定されている宛先IPアドレスで送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Srefresh messages sent to a multicast session's destination IP address, MUST contain MESSAGE_ID SRC_LIST objects and MUST NOT include any MESSAGE_ID LIST or MESSAGE_ID MCAST_LIST objects. Srefresh messages sent to the RSVP next hop MAY contain either or both MESSAGE_ID LIST and MESSAGE_ID MCAST_LIST objects, but MUST NOT include any MESSAGE_ID SRC_LIST objects.",
      "ja": "マルチキャストセッションの宛先IPアドレスに送信されたsrefreshメッセージは、message_id src_listオブジェクトを含める必要があり、message_idリストまたはmessage_id mcast_listオブジェクトを含めてはなりません。RSVPに送信されたsrefreshメッセージ次のホップには、メッセージ_idリストとmessage_id mcast_listオブジェクトのいずれかまたは両方が含まれる場合がありますが、message_id src_listオブジェクトを含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "The source IP address of an Srefresh message is an address of the node that generates the message. The source IP address MUST match the address associate with the MESSAGE_ID objects when they were included in a standard RSVP message. As previously mentioned, the source address associated with a MESSAGE_ID object is represented in a per RSVP message type specific fashion. For messages with RSVP_HOP objects, such as Path and Resv messages, the address is found in the RSVP_HOP object. For other messages, such as ResvConf message, the associated IP address is the source address in the IP header.",
      "ja": "SrefreshメッセージのソースIPアドレスは、メッセージを生成するノードのアドレスです。ソースIPアドレスは、標準のRSVPメッセージに含まれているときに、アドレスアソシエイトをmessage_idオブジェクトと一致させる必要があります。前述のように、message_idオブジェクトに関連付けられたソースアドレスは、RSVPメッセージタイプの特定のファッションで表されます。PATHやRESVメッセージなどのRSVP_HOPオブジェクトを使用したメッセージの場合、アドレスはRSVP_HOPオブジェクトにあります。RESVCONFメッセージなどの他のメッセージの場合、関連するIPアドレスはIPヘッダーのソースアドレスです。"
    },
    {
      "indent": 3,
      "text": "Srefresh messages that are addressed to a session's destination IP address MUST be sent with the Router Alert IP option in their IP headers. Srefresh messages addressed directly to RSVP neighbors SHOULD NOT be sent with the Router Alert IP option in their IP headers.",
      "ja": "セッションの宛先IPアドレスにアドレス指定されたSREFRESHメッセージは、IPヘッダーのルーターアラートIPオプションで送信する必要があります。RSVP Neighborsに直接アドレス指定されたSrefreshメッセージは、IPヘッダーのRouter Alert IPオプションを使用して送信しないでください。"
    },
    {
      "indent": 3,
      "text": "Each Srefresh message MUST occupy exactly one IP datagram. If it exceeds the MTU, the datagram is fragmented by IP and reassembled at the recipient node. Srefresh messages MAY be sent within an RSVP Bundle messages. Although this is not expected since Srefresh messages can carry a list of Message_Identifier fields within a single object. Implementations may choose to limit each Srefresh message to the MTU size of the outgoing link, e.g., 1500 bytes.",
      "ja": "各SREFRESHメッセージは、正確に1つのIPデータグラムを占有する必要があります。MTUを超えると、データグラムはIPによって断片化され、受信者ノードで再組み立てされます。srefreshメッセージは、RSVPバンドルメッセージ内で送信される場合があります。ただし、Srefreshメッセージは単一のオブジェクト内のmessage_identifierフィールドのリストを掲載できるため、これは予想されていません。実装は、各SREFRESHメッセージを発信リンクのMTUサイズ、たとえば1500バイトに制限することを選択できます。"
    },
    {
      "indent": 3,
      "text": "The Srefresh message format is:",
      "ja": "srefreshメッセージ形式は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "<Srefresh Message> ::= <Common Header> [ <INTEGRITY> ]\n                      [ [<MESSAGE_ID_ACK> | <MESSAGE_ID_NACK>] ... ]\n                      [ <MESSAGE_ID> ]\n                      <srefresh list> | <source srefresh list>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<srefresh list> ::= <MESSAGE_ID LIST> | <MESSAGE_ID MCAST_LIST>\n                      [ <srefresh list> ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<source srefresh list> ::= <MESSAGE_ID SRC_LIST>\n                             [ <source srefresh list> ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For Srefresh messages, the Msg Type field of the Common Header MUST be set to 15.",
      "ja": "更新メッセージの場合、共通ヘッダーのメッセージタイプフィールドは15に設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3. Srefresh Message Usage",
      "section_title": true,
      "ja": "5.3. srefreshメッセージの使用"
    },
    {
      "indent": 3,
      "text": "An Srefresh message may be generated to refresh Resv and Path state. If an Srefresh message is used to refresh some particular state, then the generation of a standard refresh message for that particular state SHOULD be suppressed. A state's refresh interval is not affected by the use of Srefresh message based refreshes.",
      "ja": "srefreshメッセージを生成して、RESVとPATH状態を更新できます。特定の状態を更新するためにsrefreshメッセージを使用している場合、その特定の状態の標準更新メッセージの生成を抑制する必要があります。状態の更新間隔は、Srefreshメッセージベースのリフレッシュの使用による影響を受けません。"
    },
    {
      "indent": 3,
      "text": "When generating an Srefresh message, a node SHOULD refresh as much Path and Resv state as is possible by including the information from as many MESSAGE_ID objects in the same Srefresh message. Only the information from MESSAGE_ID objects that meet the source and destination IP address restrictions, as described in Sections 5.2, may be included in the same Srefresh message. Identifying Resv state that can be refreshed using the same Srefresh message is fairly straightforward. Identifying which Path state may be included is a little more complex.",
      "ja": "srefreshメッセージを生成する場合、ノードは、同じsrefreshメッセージに多くのmessage_idオブジェクトからの情報を含めることにより、可能な限りパスとRESV状態を更新する必要があります。セクション5.2で説明されているように、ソースおよび宛先IPアドレスの制限を満たすMessage_IDオブジェクトからの情報のみが、同じsrefreshメッセージに含まれる場合があります。同じsrefreshメッセージを使用して更新できるRESV状態を識別することは、かなり簡単です。どのパス状態が含まれているかを特定することは、もう少し複雑です。"
    },
    {
      "indent": 3,
      "text": "Only state that was previously advertised in Path and Resv messages containing MESSAGE_ID objects can be refreshed via an Srefresh message. Srefresh message based refreshes must preserve the state synchronization properties of Path or Resv message based refreshes. Specifically, the use of Srefresh messages MUST NOT result in state being timed-out at the RSVP next hop. The period at which state is refreshed when using Srefresh messages MAY be shorter than the period that would be used when using Path or Resv message based refreshes, but it MUST NOT be longer.",
      "ja": "Message_idオブジェクトを含むPATHおよびRESVメッセージで以前に宣伝されていた状態のみは、srefreshメッセージを介して更新できます。SREFRESHメッセージベースのリフレッシュは、パスまたはRESVメッセージベースのリフレッシュの状態同期プロパティを保存する必要があります。具体的には、Srefreshメッセージの使用は、RSVP Next Hopで状態がタイムアウトすることをもたらさないはずです。Srefreshメッセージを使用するときに状態が更新される期間は、PATHまたはRESVメッセージベースのリフレッシュを使用するときに使用される期間よりも短くなる可能性がありますが、長くはかかりません。"
    },
    {
      "indent": 3,
      "text": "The particular approach used to trigger Srefresh message based refreshes is implementation specific. Some possibilities are triggering Srefresh message generation based on each state's refresh period or, on a per interface basis, periodically generating Srefresh messages to refresh all state that has not been refreshed within the state's refresh interval. Other approaches are also possible. A default Srefresh message generation interval of 30 seconds is suggested for nodes that do not dynamically calculate a generation interval.",
      "ja": "Srefreshメッセージベースのリフレッシュをトリガーするために使用される特定のアプローチは、実装固有です。いくつかの可能性は、各州の更新期間に基づいて、またはインターフェイスごとにSREFRESHメッセージを定期的に生成して、州の更新間隔内で更新されていないすべての状態を更新するために定期的に生成することをトリガーしています。他のアプローチも可能です。生成間隔を動的に計算しないノードについては、30秒のデフォルトのsrefreshメッセージ生成間隔を提案します。"
    },
    {
      "indent": 3,
      "text": "When generating an Srefresh message, there are two methods for identifying which Path state may be refreshed in a specific message. In both cases, the previously mentioned refresh interval and source IP address restrictions must be followed. The primary method is to include only those sessions that share the same destination IP address in the same Srefresh message.",
      "ja": "srefreshメッセージを生成するとき、特定のメッセージでどのパス状態を更新する可能性があるかを識別する2つの方法があります。どちらの場合も、前述の更新間隔とソースIPアドレスの制限に従う必要があります。主な方法は、同じsrefreshメッセージに同じ宛先IPアドレスを共有するセッションのみを含めることです。"
    },
    {
      "indent": 3,
      "text": "The secondary method for identifying which Path state may be refreshed within a single Srefresh message is an optimization. This method MAY be used when the next hop is known to support RSVP and when either (a) the session is unicast or (b) the outgoing interface is a point-to-point link. This method MUST NOT be used when the next hop is not known to support RSVP or when the outgoing interface is to a multi-access network and the session is to a multicast address. The use of this method MAY be administratively configured. When using this method, the destination address in the IP header of the Srefresh message is usually the next hop's address. When the use of this method is administratively configured, the destination address should be the well known group address 224.0.0.14. When the outgoing interface is a point-to-point link, all Path state associated with sessions advertised out the interface SHOULD be included in the same Srefresh message. When the outgoing interface is not a point-to-point link, all unicast session Path state SHOULD be included in the same Srefresh message.",
      "ja": "単一のsrefreshメッセージ内でどの経路状態を更新するかを識別する二次方法は最適化です。この方法は、次のホップがRSVPをサポートするように知られている場合、および（a）セッションがユニキャストまたは（b）発信インターフェイスがポイントツーポイントリンクである場合に使用できます。この方法は、次のホップがRSVPをサポートすることがわからない場合、または発信インターフェイスがマルチアクセスネットワークに合っていて、セッションがマルチキャストアドレスにある場合は使用しないでください。この方法の使用は、管理上構成されている場合があります。この方法を使用する場合、srefreshメッセージのIPヘッダーの宛先アドレスは通常、次のホップのアドレスです。この方法の使用が管理上構成されている場合、宛先アドレスはよく知られているグループアドレス224.0.0.14である必要があります。発信インターフェイスがポイントツーポイントリンクである場合、インターフェイスを宣伝されているセッションに関連付けられたすべてのパス状態は、同じsrefreshメッセージに含める必要があります。発信インターフェイスがポイントツーポイントリンクではない場合、すべてのユニキャストセッションパス状態を同じsrefreshメッセージに含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Identifying which Resv state may be refreshed within a single Srefresh message is based simply on the source and destination IP addresses. Any state that was previously advertised in Resv messages with the same IP addresses as an Srefresh message MAY be included.",
      "ja": "単一のsrefreshメッセージ内でどのresv状態が更新される可能性があるかを識別することは、単にソースと宛先のIPアドレスに基づいています。以前にSREFRESHメッセージと同じIPアドレスを持つRESVメッセージに宣伝されていた状態が含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "After identifying the Path and Resv state that can be included in a particular Srefresh message, the message generator adds to the message MESSAGE_ID information matching each identified state's previously used object. For all Resv state and for Path state of unicast sessions, the information is added to the message in a MESSAGE_ID LIST object that has a matching Epoch value. (Note only one Epoch value will be in use during normal operation.) If no matching object exists, then a new MESSAGE_ID LIST object is created.",
      "ja": "特定のsrefreshメッセージに含めることができるパスとRESV状態を識別した後、メッセージジェネレーターは、識別された各状態が以前に使用したオブジェクトに一致するメッセージ_ID情報に追加されます。すべてのRESV状態とユニキャストセッションのパス状態について、情報は、一致するエポック値を持つメッセージ_IDリストオブジェクトのメッセージに追加されます。（通常の操作中に1つのエポック値のみが使用されることに注意してください。）一致するオブジェクトが存在しない場合、新しいmessage_idリストオブジェクトが作成されます。"
    },
    {
      "indent": 3,
      "text": "Path state of multicast sessions may be added to the same message when the destination address of the Srefresh message is the RSVP next hop and the outgoing interface is a point-to-point link. In this case the information is added to the message in a MESSAGE_ID MCAST_LIST object that has a matching Epoch value. If no matching object exists, then a new MESSAGE_ID MCAST_LIST object is created. When the destination address of the message is a multicast address, then identified information is added to the message in a MESSAGE_ID SRC_LIST object that has a matching Epoch value. If no matching object exists, then a new MESSAGE_ID SRC_LIST object is created. Once the Srefresh message is composed, the message generator transmits the message out the proper interface.",
      "ja": "マルチキャストセッションのPATH状態は、SREFRESHメッセージの宛先アドレスがRSVP Next Hopであり、発信インターフェイスがポイントツーポイントリンクである場合、同じメッセージに追加される場合があります。この場合、情報は、一致するエポック値を持つmessage_id mcast_listオブジェクトのメッセージに追加されます。一致するオブジェクトが存在しない場合、新しいmessage_id mcast_listオブジェクトが作成されます。メッセージの宛先アドレスがマルチキャストアドレスである場合、識別された情報が、一致するエポック値を持つメッセージ_id src_listオブジェクトのメッセージに追加されます。一致するオブジェクトが存在しない場合、新しいmessage_id src_listオブジェクトが作成されます。Srefreshメッセージが作成されると、メッセージジェネレーターはメッセージを適切なインターフェイスから送信します。"
    },
    {
      "indent": 3,
      "text": "Upon receiving an Srefresh message, the node MUST attempt to identify matching installed Path or Resv state. Matching is done based on the source address in the IP header of the Srefresh message, the object type and each Message_Identifier field. If matching state can be found, then the receiving node MUST update the matching state information as if a standard refresh message had been received. If matching state cannot be identified, then an Srefresh NACK MUST be generated corresponding to the unmatched Message_Identifier field. Message_Identifier fields received in MESSAGE_ID LIST objects may correspond to any Resv state or to Path state of unicast sessions. Message_Identifier fields received in MESSAGE_ID SRC_LIST or MCAST_LIST objects correspond to Path state of multicast sessions.",
      "ja": "srefreshメッセージを受信すると、ノードは一致するインストールされたパスまたはRESV状態を識別しようとする必要があります。 マッチングは、SREFRESHメッセージのIPヘッダー、オブジェクトタイプ、および各Message_Identifierフィールドのソースアドレスに基づいて行われます。 一致する状態を見つけることができる場合、受信ノードは、標準の更新メッセージが受信されたかのように一致する状態情報を更新する必要があります。 一致する状態を識別できない場合、比類のないmessage_identifierフィールドに対応するsrefresh nackを生成する必要があります。 message_idリストで受信されたmessage_identifierフィールドは、任意のresv状態またはユニキャストセッションのパス状態に対応する場合があります。 message_id src_listまたはmcast_listオブジェクトで受信したmessage_identifierフィールドは、マルチキャストセッションのパス状態に対応しています。"
    },
    {
      "indent": 3,
      "text": "An additional check must be performed to determine if a NACK should be generated for unmatched Message_Identifier fields associated with Path state of multicast sessions, i.e., fields that were carried in MESSAGE_ID SRC_LIST or MCAST_LIST objects. The receiving node must check to see if the node would forward data packets originated from the source corresponding to the unmatched field. This check, commonly known as an RPF check, is performed based on the source and group information carried in the MESSAGE_ID SRC_LIST and MCAST_LIST objects. In both objects the IP address of the source is listed immediately after the corresponding Message_Identifier field. The group address is listed immediately after the source IP address in MESSAGE_ID MCAST_LIST objects. The group address is the message's destination IP address when MESSAGE_ID SRC_LIST objects are used. The receiving node only generates an Srefresh NACK when the node would forward packets to the identified group from the listed sender. If the node would forward multicast data packets from a listed sender and there is a corresponding unmatched Message_Identifier field, then an appropriate Srefresh NACK MUST be generated. If the node would not forward packets to the identified group from a listed sender, a corresponding unmatched Message_Identifier field is silently ignored.",
      "ja": "追加のチェックを実行して、マルチキャストセッションのパス状態に関連付けられている比類のないmessage_identifierフィールド、つまりmessage_id src_listまたはmcast_listオブジェクトで運ばれたフィールドにNACKを生成する必要があるかどうかを判断する必要があります。受信ノードは、ノードが比類のないフィールドに対応するソースから発信されるデータパケットを転送するかどうかを確認する必要があります。このチェックは、一般にRPFチェックと呼ばれ、Message_id src_listおよびmcast_listオブジェクトに掲載されたソースとグループ情報に基づいて実行されます。両方のオブジェクトで、ソースのIPアドレスは、対応するmessage_identifierフィールドの直後にリストされます。グループアドレスは、message_id mcast_listオブジェクトのソースIPアドレスの直後にリストされます。グループアドレスは、Message_ID SRC_LISTオブジェクトが使用されるときのメッセージの宛先IPアドレスです。受信ノードは、ノードがリストされた送信者から識別されたグループに転送される場合にのみSrefresh Nackを生成します。ノードがリストされている送信者からマルチキャストデータパケットを転送し、対応するマッチングされていないmessage_identifierフィールドがある場合、適切なsrefresh nackを生成する必要があります。ノードがリストされた送信者から識別されたグループに転送されない場合、対応する比類のないmessage_identifierフィールドは静かに無視されます。"
    },
    {
      "indent": 0,
      "text": "5.4. Srefresh NACK",
      "section_title": true,
      "ja": "5.4. srefresh nack"
    },
    {
      "indent": 3,
      "text": "Srefresh NACKs are used to indicate that a received Message_Identifier field carried in MESSAGE_ID LIST, SRC_LIST, or MCAST_LIST object does not match any installed state. This may occur for a number of reasons including, for example, a route change. An Srefresh NACK is encoded in a MESSAGE_ID_NACK object. When generating an Srefresh NACK, the epoch and Message_Identifier fields of the MESSAGE_ID_NACK object MUST have the same value as was received. MESSAGE_ID_NACK objects are transmitted as described in Section 4.6.",
      "ja": "srefresh nacksは、message_idリスト、src_list、またはmcast_listオブジェクトに掲載された受信したmessage_identifierフィールドが、インストールされた状態と一致しないことを示すために使用されます。これは、たとえばルートの変更など、さまざまな理由で発生する場合があります。srefresh nackはmessage_id_nackオブジェクトにエンコードされています。srefresh nackを生成する場合、message_id_nackオブジェクトのエポックとmessage_identifierフィールドは、受信した値と同じ値を持つ必要があります。message_id_nackオブジェクトは、セクション4.6で説明されているように送信されます。"
    },
    {
      "indent": 3,
      "text": "Received MESSAGE_ID_NACK objects indicate that the object generator does not have any installed state matching the object. Upon receiving a MESSAGE_ID_NACK object, the receiver performs an installed Path or Resv state lookup based on the Epoch and Message_Identifier values contained in the object. If matching state is found, then the receiver MUST transmit the matching state via a standard Path or Resv message. If the receiver cannot identify any installed state, then no action is required.",
      "ja": "受信したmessage_id_nackオブジェクトは、オブジェクトジェネレーターにオブジェクトに一致するインストールされた状態がないことを示します。Message_id_nackオブジェクトを受信すると、受信者は、オブジェクトに含まれるエポックとmessage_identifier値に基づいて、インストールされたパスまたはRESV状態検索を実行します。一致する状態が見つかった場合、レシーバーは標準のパスまたはRESVメッセージを介して一致する状態を送信する必要があります。受信者がインストールされた状態を識別できない場合、アクションは必要ありません。"
    },
    {
      "indent": 0,
      "text": "5.5. Preserving RSVP Soft State",
      "section_title": true,
      "ja": "5.5. RSVPソフト状態の保存"
    },
    {
      "indent": 3,
      "text": "As discussed in [RFC2205], RSVP uses soft state to address a large class of potential errors. RSVP does this by periodically sending a full representation of installed state in Resv and Path messages. Srefresh messages are used in place of the periodic sending of standard Path and Resv refresh messages. While this provides scaling benefits and protects against common network events such as packet loss or routing change, it does not provide exactly the same error recovery properties. An example error that could potentially be recovered from via standard messages but not with Srefresh messages is internal corruption of state. This section recommends two methods that can be used to better preserve RSVP's soft state error recovery mechanism. Both mechanisms are supported using existing protocol messages.",
      "ja": "[RFC2205]で説明したように、RSVPはソフト状態を使用して、潜在的なエラーの大規模なクラスに対処します。RSVPは、RESVおよびPATHメッセージにインストールされた状態の完全な表現を定期的に送信することにより、これを行います。srefreshメッセージは、標準のパスとRESV更新メッセージの定期的な送信の代わりに使用されます。これにより、スケーリングの利点が提供され、パケットの損失やルーティングの変更などの一般的なネットワークイベントから保護されますが、まったく同じエラー回復プロパティを提供しません。標準メッセージから潜在的に回復する可能性のあるエラーの例は、srefreshメッセージではないことではなく、状態の内部破損です。このセクションでは、RSVPのソフト状態エラー回復メカニズムをよりよく維持するために使用できる2つの方法を推奨します。両方のメカニズムは、既存のプロトコルメッセージを使用してサポートされています。"
    },
    {
      "indent": 3,
      "text": "The first mechanism uses a checksum or other algorithm to detect a previously unnoticed change in internal state. This mechanism does not protect against internal state corruption. It just covers the case where a trigger message should have been sent, but was not. When sending a Path or Resv trigger message, a node should run a checksum or other algorithm, such as [MD5], over the internal state and store the result. The choice of algorithm is an administrative decision. Periodically the node should rerun the algorithm and compare the new result with the stored result. If the values differ, then a corresponding standard Path or Resv refresh message should be sent and the new value should be stored. The recomputation period should be set based on the computation resources of the node and the reliability requirements of the network.",
      "ja": "最初のメカニズムは、チェックサムまたはその他のアルゴリズムを使用して、以前に見られなかった内部状態の変化を検出します。このメカニズムは、内部の状態の腐敗から保護しません。トリガーメッセージが送信されるべきである場合は、そうではなかった場合だけです。パスまたはRESVトリガーメッセージを送信する場合、ノードは内部状態を介して[MD5]などのチェックサムまたは他のアルゴリズムを実行し、結果を保存する必要があります。アルゴリズムの選択は管理上の決定です。定期的にノードはアルゴリズムを再実行し、新しい結果を保存された結果と比較する必要があります。値が異なる場合、対応する標準パスまたはRESV更新メッセージを送信し、新しい値を保存する必要があります。再計算期間は、ノードの計算リソースとネットワークの信頼性要件に基づいて設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The second mechanism is simply to periodically send standard Path and Resv refresh messages. Since this mechanism uses standard refresh messages, it can recover from the same set of errors as standard RSVP. When using this mechanism, the period that standard refresh messages are sent must be longer than the interval that Srefresh messages are generated in order to gain the benefits of using the summary refresh extension. When a standard refresh message is sent, a corresponding summary refresh SHOULD NOT be sent during the same refresh period. When a node supports the periodic generation of standard refresh messages while Srefreshes are being used, the frequency of generation of standard refresh messages relative to the generation of summary refreshes SHOULD be configurable by the network administrator.",
      "ja": "2番目のメカニズムは、単に標準のパスとRESVの更新メッセージを定期的に送信することです。このメカニズムは標準の更新メッセージを使用するため、標準のRSVPと同じエラーセットから回復できます。このメカニズムを使用する場合、標準の更新メッセージが送信される期間は、要約リフレッシュ拡張機能を使用することの利点を得るために、srefreshメッセージが生成される間隔よりも長くなければなりません。標準の更新メッセージが送信された場合、同じ更新期間中に対応する要約リフレッシュを送信しないでください。ノードが使用されている間にノードが標準の更新メッセージの周期生成をサポートする場合、サマリーリフレッシュの生成に対する標準更新メッセージの生成の頻度は、ネットワーク管理者が構成できる必要があります。"
    },
    {
      "indent": 0,
      "text": "5.6. Compatibility",
      "section_title": true,
      "ja": "5.6. 互換性"
    },
    {
      "indent": 3,
      "text": "Nodes supporting the summary refresh extension advertise their support via the Refresh-Reduction-Capable bit in the RSVP message header. This enables nodes supporting the extension to detect each other. When it is not known if a next hop supports the extension, standard Path and Resv message based refreshes MUST be used. Note that when the routing next hop does not support RSVP, it will not always be possible to detect if the RSVP next hop supports the summary refresh extension. Therefore, when the routing next hop is not RSVP capable the Srefresh message based refresh SHOULD NOT be used. A node MAY be administratively configured to use Srefresh messages in all cases when all RSVP nodes in a network are known to support the summary refresh extension. This is useful since when operating in this mode, the extension properly adjusts to the case of non-RSVP next hops and changes in routing.",
      "ja": "サマリーリフレッシュエクステンションをサポートするノードは、RSVPメッセージヘッダーのリフレッシュ削減対応ビットを介してサポートを宣伝します。これにより、拡張機能をサポートするノードが互いに検出されます。次のホップが拡張機能をサポートするかどうかがわからない場合、標準パスとRESVのメッセージベースのリフレッシュを使用する必要があります。ルーティングNext HopがRSVPをサポートしていない場合、RSVP Next Hopがサマリーリフレッシュ拡張機能をサポートしているかどうかを常に検出できるとは限りません。したがって、ルーティングの次のホップがRSVPに能力がない場合、srefreshメッセージベースの更新は使用しないでください。ネットワーク内のすべてのRSVPノードがサマリーリフレッシュ拡張機能をサポートするように既知の場合、すべての場合にSREFRESHメッセージを使用するようにノードを管理する場合があります。これは、このモードで動作する場合、拡張機能がRSVP以外の次のホップとルーティングの変更の場合に適切に調整されるためです。"
    },
    {
      "indent": 3,
      "text": "Per section 2, nodes supporting the summary refresh extension must also take care to recognize when a next hop stops sending RSVP messages with the Refresh-Reduction-Capable bit set.",
      "ja": "セクション2ごとに、サマリーリフレッシュ拡張機能をサポートするノードは、次のホップがRSVPメッセージの送信を停止したときに、リフレッシュ削減対応ビットセットでRSVPメッセージの送信を停止することに注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "6. Exponential Back-Off Procedures",
      "section_title": true,
      "ja": "6. 指数バックオフ手順"
    },
    {
      "indent": 3,
      "text": "This section is based on [Pan] and provides procedures to implement exponential back-off for retransmission of messages awaiting acknowledgment, see Section 4.5. Implementations MUST use the described procedures or their equivalent.",
      "ja": "このセクションは[PAN]に基づいており、承認を待っているメッセージの再送信のために指数関数的なバックオフを実装する手順を提供します。セクション4.5を参照してください。実装は、説明されている手順または同等の手順を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1. Outline of Operation",
      "section_title": true,
      "ja": "6.1. 操作の概要"
    },
    {
      "indent": 3,
      "text": "The following is one possible mechanism for exponential back-off retransmission of an unacknowledged RSVP message: When sending such a message, a node inserts a MESSAGE_ID object with the ACK_Desired flag set. The sending node will retransmit the message until a message acknowledgment is received or the message has been transmitted a maximum number of times. Upon reception, a receiving node acknowledges the arrival of the message by sending back a message acknowledgment (that is, a corresponding MESSAGE_ID_ACK object.) When the sending node receives the acknowledgment retransmission of the message is stopped. The interval between retransmissions is governed by a rapid retransmission timer. The rapid retransmission timer starts at a small interval and increases exponentially until it reaches a threshold.",
      "ja": "以下は、未承認のRSVPメッセージの指数バックオフ再送信のための1つの可能なメカニズムです。そのようなメッセージを送信するとき、ノードはACK_Desiredフラグセットにメッセージ_IDオブジェクトを挿入します。送信ノードは、メッセージの確認が受信されるか、メッセージが最大回数送信されるまでメッセージを再送信します。受信時に、受信ノードは、メッセージの確認（つまり、対応するmessage_id_ackオブジェクト）を送信することにより、メッセージの到着を認めます。送信ノードがメッセージの確認の再送信を受信したときに停止します。再送信間の間隔は、迅速な再送信タイマーによって支配されます。迅速な再送信タイマーは小さな間隔から始まり、しきい値に達するまで指数関数的に増加します。"
    },
    {
      "indent": 0,
      "text": "6.2. Time Parameters",
      "section_title": true,
      "ja": "6.2. 時間パラメーター"
    },
    {
      "indent": 3,
      "text": "The described procedures make use of the following time parameters. All parameters are per interface.",
      "ja": "説明されている手順では、次の時間パラメーターを使用します。すべてのパラメーターはインターフェイスごとです。"
    },
    {
      "indent": 6,
      "text": "Rapid retransmission interval Rf:",
      "ja": "迅速な再送信間隔RF："
    },
    {
      "indent": 11,
      "text": "Rf is the initial retransmission interval for unacknowledged messages. After sending the message for the first time, the sending node will schedule a retransmission after Rf seconds. The value of Rf could be as small as the round trip time (RTT) between a sending and a receiving node, if known.",
      "ja": "RFは、未承認のメッセージの最初の再送信間隔です。メッセージを初めて送信した後、送信ノードはRF秒後に再送信をスケジュールします。RFの値は、既知の場合、送信と受信ノードの間の往復時間（RTT）と同じくらい小さくなる可能性があります。"
    },
    {
      "indent": 6,
      "text": "Rapid retry limit Rl:",
      "ja": "Rapid Retry Limit RL："
    },
    {
      "indent": 11,
      "text": "Rl is the maximum number of times a message will be transmitted without being acknowledged.",
      "ja": "RLは、メッセージが認められずに送信される最大回数です。"
    },
    {
      "indent": 6,
      "text": "Increment value Delta:",
      "ja": "増分値Delta："
    },
    {
      "indent": 11,
      "text": "Delta governs the speed with which the sender increases the retransmission interval. The ratio of two successive retransmission intervals is (1 + Delta).",
      "ja": "デルタは、送信者が再送信間隔を増加させる速度を支配します。2つの連続した再送信間隔の比率は（1 Delta）です。"
    },
    {
      "indent": 3,
      "text": "Suggested default values are an initial retransmission timeout (Rf) of 500ms, a power of 2 exponential back-off (Delta = 1) and a retry limit (Rl) of 3.",
      "ja": "推奨されるデフォルト値は、500msの初期再送信タイムアウト（RF）、2指数バックオフ（Delta = 1）の電力、3の再試行制限（RL）です。"
    },
    {
      "indent": 0,
      "text": "6.3. Retransmission Algorithm",
      "section_title": true,
      "ja": "6.3. 再送信アルゴリズム"
    },
    {
      "indent": 3,
      "text": "After a sending node transmits a message containing a MESSAGE_ID object with the ACK_Desired flag set, it should immediately schedule a retransmission after Rf seconds. If a corresponding MESSAGE_ID_ACK object is received earlier than Rf seconds, then retransmission SHOULD be canceled. Otherwise, it will retransmit the message after (1 + Delta)*Rf seconds. The staged retransmission will continue until either an appropriate MESSAGE_ID_ACK object is received, or the rapid retry limit, Rl, has been reached.",
      "ja": "送信ノードがACK_IDオブジェクトを含むメッセージをACK_DESIREDフラグセットに送信した後、RF秒後にすぐに再送信をスケジュールする必要があります。対応するmessage_id_ackオブジェクトがrf秒より早く受信される場合、再送信をキャンセルする必要があります。それ以外の場合は、（1 delta）*rf秒後にメッセージを再送信します。段階的な再送信は、適切なmessage_id_ackオブジェクトが受信されるか、迅速な再試行制限rlに到達するまで続きます。"
    },
    {
      "indent": 3,
      "text": "A sending node can use the following algorithm when transmitting a message containing a MESSAGE_ID object with the ACK_Desired flag set:",
      "ja": "送信ノードは、ack_desiredフラグセットを使用してmessage_idオブジェクトを含むメッセージを送信するときに、次のアルゴリズムを使用できます。"
    },
    {
      "indent": 7,
      "text": "Prior to initial transmission initialize: Rk = Rf and Rn = 0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "while (Rn++ < Rl)  {\n    transmit the message;\n    wake up after Rk seconds;\n    Rk = Rk * (1 + Delta);\n}\n/* acknowledged or no reply from receiver for too long: */ do any\nneeded clean up; exit;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Asynchronously, when a sending node receives a corresponding MESSAGE_ID_ACK object, it will change the retry count, Rn, to Rl.",
      "ja": "非同期に、送信ノードが対応するmessage_id_ackオブジェクトを受信すると、retry count rnをRLに変更します。"
    },
    {
      "indent": 3,
      "text": "Note that the transmitting node does not advertise the use of the described exponential back-off procedures via the TIME_VALUE object.",
      "ja": "送信ノードは、Time_Valueオブジェクトを介して説明されている指数バックオフ手順の使用を宣伝していないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "6.4. Performance Considerations",
      "section_title": true,
      "ja": "6.4. パフォーマンスに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The use of exponential back-off retransmission is a new and significant addition to RSVP. It will be important to review related operations and performance experience before this document advances to Draft Standard. It will be particularly important to review experience with multicast, and any ACK implosion problems actually encountered.",
      "ja": "指数関数的なバックオフ再送信の使用は、RSVPへの新しく重要な追加です。このドキュメントが標準のドラフトに進む前に、関連する運用とパフォーマンスの経験をレビューすることが重要です。マルチキャストの経験や、実際に遭遇したACK爆発の問題をレビューすることが特に重要です。"
    },
    {
      "indent": 0,
      "text": "7. Acknowledgments",
      "section_title": true,
      "ja": "7. 謝辞"
    },
    {
      "indent": 3,
      "text": "This document represents ideas and comments from the MPLS-TE design team and participants in the RSVP Working Group's interim meeting. Thanks to Bob Braden, Lixia Zhang, Fred Baker, Adrian Farrel, Roch Guerin, Kireeti Kompella, David Mankins, Henning Schulzrinne, Andreas Terzis, Lan Wang and Masanobu Yuhara for specific feedback on the various versions of the document.",
      "ja": "このドキュメントは、MPLS-TEデザインチームとRSVPワーキンググループの暫定会議の参加者からのアイデアとコメントを表しています。ボブ・ブレイデン、リクシア・チャン、フレッド・ベイカー、エイドリアン・ファレル、ロック・ゲリン、キリエト・コンペラ、デビッド・マンキンズ、ヘニング・シュルツリン、アンドレアス・テルジス、ラン・ワン、マサノブ・ユハラに感謝します。"
    },
    {
      "indent": 3,
      "text": "Portions of this work are based on work done by Masanobu Yuhara and Mayumi Tomikawa [Yuhara].",
      "ja": "この作品の一部は、YuharaとMayumi tomikawa [Yuhara]によって行われた作業に基づいています。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "No new security issues are raised in this document. See [RFC2205] for a general discussion on RSVP security issues.",
      "ja": "このドキュメントでは、新しいセキュリティの問題は発生していません。RSVPセキュリティの問題に関する一般的な議論については、[RFC2205]を参照してください。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9. 参考文献"
    },
    {
      "indent": 3,
      "text": "[Pan] Pan, P., Schulzrinne, H., \"Staged Refresh Timers for RSVP,\" Global Internet'97, Phoenix, AZ, November 1997. http://www.cs.columbia.edu/~pingpan/papers/timergi.pdf",
      "ja": "[Pan、Pan、P.、Schulzrinne、H。、「RSVPの段階的なリフレッシュタイマー」、グローバルインターネット'97、アリゾナ州フェニックス、1997年11月。http：//www.cs.columbia.edu/~pingpan/papers/Timergi.pdf"
    },
    {
      "indent": 3,
      "text": "[MD5] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321, April 1992.",
      "ja": "[MD5] Rivest、R。、「The MD5 Message-Digest Algorithm」、RFC 1321、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2205] Braden, R., Ed., Zhang, L., Berson, S., Herzog, S. and S. Jamin , \"Resource ReserVation Protocol -- Version 1 Functional Specification\", RFC 2205, September 1997.",
      "ja": "[RFC2205] Braden、R.、ed。、Zhang、L.、Berson、S.、Herzog、S。、およびS. Jamin、「リソース予約プロトコル - バージョン1機能仕様」、RFC 2205、1997年9月。"
    },
    {
      "indent": 3,
      "text": "[Yuhara] Yuhara, M., and M Tomikawa, \"RSVP Extensions for ID-based Refreshes\", Work in Progress.",
      "ja": "[Yuhara] Yuhara、M。、およびM Tomikawa、「IDベースのリフレッシュのRSVP拡張機能」、進行中の作業。"
    },
    {
      "indent": 0,
      "text": "10. Authors' Addresses",
      "section_title": true,
      "ja": "10. 著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Lou Berger LabN Consulting, LLC",
      "ja": "Lou Berger Labn Consulting、LLC"
    },
    {
      "indent": 3,
      "text": "Phone:  +1 301 468 9228\nEMail:  lberger@labn.net",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Der-Hwa Gan Juniper Networks, Inc. 1194 N. Mathilda Avenue, Sunnyvale, CA 94089",
      "ja": "Der-Hwa Gan Juniper Networks、Inc。1194 N. Mathilda Avenue、Sunnyvale、CA 94089"
    },
    {
      "indent": 3,
      "text": "Voice: +1 408 745 2074\nEmail:  dhg@juniper.net",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "George Swallow Cisco Systems, Inc. 250 Apollo Drive Chelmsford, MA 01824",
      "ja": "George Swallow Cisco Systems、Inc。250 Apollo Drive Chelmsford、MA 01824"
    },
    {
      "indent": 3,
      "text": "Phone:  +1 978 244 8143\nEMail:  swallow@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Ping Pan Juniper Networks, Inc. 1194 N. Mathilda Avenue, Sunnyvale, CA 94089",
      "ja": "Ping Pan Juniper Networks、Inc。1194 N. Mathilda Avenue、Sunnyvale、CA 94089"
    },
    {
      "indent": 3,
      "text": "Voice: +1 408 745 3704\nEmail:  pingpan@juniper.net",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Franco Tommasi University of Lecce, Fac. Ingegneria Via Monteroni 73100 Lecce, ITALY",
      "ja": "フランコ・トンマーシ・レクセ大学、FAC。イタリアのモンテーニ73100レッケ経由のインゲグネリア"
    },
    {
      "indent": 3,
      "text": "EMail:  franco.tommasi@unile.it",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Simone Molendini University of Lecce, Fac. Ingegneria Via Monteroni 73100 Lecce, ITALY",
      "ja": "シモーヌ・モレンディニ大学レッケ大学、FAC。イタリアのモンテーニ73100レッケ経由のインゲグネリア"
    },
    {
      "indent": 3,
      "text": "EMail:  molendini@ultra5.unile.it",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "11. Full Copyright Statement",
      "section_title": true,
      "ja": "11. 完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2001）。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書と本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}