{
  "title": {
    "text": "RFC 4086 - Randomness Requirements for Security",
    "ja": "RFC 4086 - セキュリティのためのランダム性要件"
  },
  "number": 4086,
  "created_at": "2021-04-02 20:50:25.944755+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                   D. Eastlake, 3rd\nRequest for Comments: 4086                         Motorola Laboratories\nBCP: 106                                                     J. Schiller\nObsoletes: 1750                                                      MIT\nCategory: Best Current Practice                               S. Crocker\n                                                               June 2005",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Randomness Requirements for Security",
      "ja": "セキュリティのためのランダム性要件"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのためのインターネットの最良の現在の慣行を指定し、改善のための議論と提案を要求します。このメモの分布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "著作権（C）インターネット社会（2005）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "Security systems are built on strong cryptographic algorithms that foil pattern analysis attempts. However, the security of these systems is dependent on generating secret quantities for passwords, cryptographic keys, and similar quantities. The use of pseudo-random processes to generate secret quantities can result in pseudo-security. A sophisticated attacker may find it easier to reproduce the environment that produced the secret quantities and to search the resulting small set of possibilities than to locate the quantities in the whole of the potential number space.",
      "ja": "セキュリティシステムは、パターン分析の試みへの耐性が強い暗号化アルゴリズム上に構築されています。ただし、これらのシステムのセキュリティは、パスワード、暗号鍵、および同様の量の秘密の数の生成に依存しています。秘密の数を生成するための疑似ランダムプロセスの使用は疑似セキュリティをもたらす可能性があります。洗練された攻撃者は、秘密数量を生み出した環境を再現し、潜在的な数の空間全体の数量を見つけることよりも結果として生じる小さな可能性を検索することがより容易になるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Choosing random quantities to foil a resourceful and motivated adversary is surprisingly difficult. This document points out many pitfalls in using poor entropy sources or traditional pseudo-random number generation techniques for generating such quantities. It recommends the use of truly random hardware techniques and shows that the existing hardware on many systems can be used for this purpose. It provides suggestions to ameliorate the problem when a hardware solution is not available, and it gives examples of how large such quantities need to be for some applications.",
      "ja": "機密性でやる気のある敵対者を箔にするためのランダムな量を選択することは驚くほど困難です。この文書は、エントロピー源やそのような量を生成するための伝統的な疑似乱数生成技術を使用する際の多くの落とし穴を指摘しています。それは真にランダムなハードウェア技術の使用を推奨し、多くのシステム上の既存のハードウェアをこの目的のために使用できることを示しています。ハードウェアソリューションが利用できない場合に問題を改善するための提案を提供し、そのような量の多くのアプリケーションに対してどのような数の量である必要があるかの例を示します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 2,
      "text": " 1. Introduction and Overview .......................................3\n 2. General Requirements ............................................4\n 3. Entropy Sources .................................................7\n    3.1. Volume Required ............................................7\n    3.2. Existing Hardware Can Be Used For Randomness ...............8\n         3.2.1. Using Existing Sound/Video Input ....................8\n         3.2.2. Using Existing Disk Drives ..........................8\n    3.3. Ring Oscillator Sources ....................................9\n    3.4. Problems with Clocks and Serial Numbers ...................10\n    3.5. Timing and Value of External Events .......................11\n    3.6. Non-hardware Sources of Randomness ........................12\n 4. De-skewing .....................................................12\n    4.1. Using Stream Parity to De-Skew ............................13\n    4.2. Using Transition Mappings to De-Skew ......................14\n    4.3. Using FFT to De-Skew ......................................15\n    4.4. Using Compression to De-Skew ..............................15\n 5. Mixing .........................................................16\n    5.1. A Trivial Mixing Function .................................17\n    5.2. Stronger Mixing Functions .................................18\n    5.3. Using S-Boxes for Mixing ..................................19\n    5.4. Diffie-Hellman as a Mixing Function .......................19\n    5.5. Using a Mixing Function to Stretch Random Bits ............20\n    5.6. Other Factors in Choosing a Mixing Function ...............20\n 6. Pseudo-random Number Generators ................................21\n    6.1. Some Bad Ideas ............................................21\n         6.1.1. The Fallacy of Complex Manipulation ................21\n         6.1.2. The Fallacy of Selection from a Large Database .....22\n         6.1.3. Traditional Pseudo-random Sequences ................23\n    6.2. Cryptographically Strong Sequences ........................24\n         6.2.1. OFB and CTR Sequences ..............................25\n         6.2.2. The Blum Blum Shub Sequence Generator ..............26\n    6.3. Entropy Pool Techniques ...................................27\n 7. Randomness Generation Examples and Standards ...................28\n    7.1. Complete Randomness Generators ............................28\n         7.1.1. US DoD Recommendations for Password Generation .....28\n         7.1.2. The /dev/random Device .............................29\n         7.1.3. Windows CryptGenRandom .............................30\n    7.2. Generators Assuming a Source of Entropy ...................31\n         7.2.1. X9.82 Pseudo-Random Number Generation ..............31\n         7.2.2. X9.17 Key Generation ...............................33\n         7.2.3. DSS Pseudo-random Number Generation ................34\n 8. Examples of Randomness Required ................................34\n    8.1. Password Generation .......................................35\n    8.2. A Very High Security Cryptographic Key ....................36\n 9. Conclusion .....................................................38\n10. Security Considerations ........................................38",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "11. Acknowledgments ................................................39\nAppendix A: Changes from RFC 1750 ..................................40\nInformative References .............................................41",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction and Overview",
      "section_title": true,
      "ja": "1. 導入と概要"
    },
    {
      "indent": 3,
      "text": "Software cryptography is coming into wider use, although there is a long way to go until it becomes pervasive. Systems such as SSH, IPSEC, TLS, S/MIME, PGP, DNSSEC, and Kerberos are maturing and becoming a part of the network landscape [SSH] [IPSEC] [TLS] [S/MIME] [MAIL_PGP*] [DNSSEC*]. For comparison, when the previous version of this document [RFC1750] was issued in 1994, the only Internet cryptographic security specification in the IETF was the Privacy Enhanced Mail protocol [MAIL_PEM*].",
      "ja": "ソフトウェア暗号化はより広い使用になりますが、それが蔓延するまで行くのは長い道のりがあります。SSH、IPSec、TLS、S / MIME、PGP、DNSSEC、およびKerberosなどのシステムは、ネットワークランドスケープ[SSH] [IPsec] [S / MIME] [Mail_PGP *] [DNSSEC *]]。比較のために、1994年にこの文書の以前のバージョンが発行された場合、IETFの唯一のインターネット暗号化セキュリティ仕様はプライバシー強化メールプロトコル[Mail_Pem *]でした。"
    },
    {
      "indent": 3,
      "text": "These systems provide substantial protection against snooping and spoofing. However, there is a potential flaw. At the heart of all cryptographic systems is the generation of secret, unguessable (i.e., random) numbers.",
      "ja": "これらのシステムは、スヌーピングとなりすましに対する実質的な保護を提供します。しかし、潜在的な欠陥があります。すべての暗号化システムの中心にあるのは、秘密、不正な（すなわち、ランダム）番号の生成です。"
    },
    {
      "indent": 3,
      "text": "The lack of generally available facilities for generating such random numbers (that is, the lack of general availability of truly unpredictable sources) forms an open wound in the design of cryptographic software. For the software developer who wants to build a key or password generation procedure that runs on a wide range of hardware, this is a very real problem.",
      "ja": "そのような乱数を生成するための一般的に利用可能な施設の欠如（すなわち、本当に予測不可能な情報源の一般的な利用可能性の欠如）は、暗号化ソフトウェアの設計において開いた傷を形成する。幅広いハードウェア上で実行されるキーまたはパスワード生成手順を構築したいソフトウェア開発者は、これが非常に本当の問題です。"
    },
    {
      "indent": 3,
      "text": "Note that the requirement is for data that an adversary has a very low probability of guessing or determining. This can easily fail if pseudo-random data is used that meets only traditional statistical tests for randomness, or that is based on limited-range sources such as clocks. Sometimes such pseudo-random quantities can be guessed by an adversary searching through an embarrassingly small space of possibilities.",
      "ja": "要件は、敵対者が推測または決定の確率が非常に低いデータに対するデータに対するものであることに注意してください。擬似ランダムデータを使用すると、ランダム性のための従来の統計テストのみを満たす、またはクロックなどの限られた範囲のソースに基づく疑似ランダムデータが使用される場合、これは簡単に失敗できます。時々このような疑似ランダムな量は、恥ずかしいほど小さいスペースを介して敵対的な検索によって推測され得る。"
    },
    {
      "indent": 3,
      "text": "This Best Current Practice document describes techniques for producing random quantities that will be resistant to attack. It recommends that future systems include hardware random number generation or provide access to existing hardware that can be used for this purpose. It suggests methods for use if such hardware is not available, and it gives some estimates of the number of random bits required for sample applications.",
      "ja": "この最良の現在の練習文書は、攻撃に対して耐性があるだろうランダムな量を生産するための技術を説明しています。将来のシステムには、ハードウェア乱数の世代が含まれているか、この目的のために使用できる既存のハードウェアへのアクセスを提供することをお勧めします。そのようなハードウェアが利用できない場合に使用する方法は、サンプルアプリケーションに必要なランダムビット数のいくつかの推定値を示しています。"
    },
    {
      "indent": 0,
      "text": "2. General Requirements",
      "section_title": true,
      "ja": "2. 一般的な要件"
    },
    {
      "indent": 3,
      "text": "Today, a commonly encountered randomness requirement is to pick a user password, usually a simple character string. Obviously, a password that can be guessed does not provide security. For re-usable passwords, it is desirable that users be able to remember the password. This may make it advisable to use pronounceable character strings or phrases composed of ordinary words. But this affects only the format of the password information, not the requirement that the password be very hard to guess.",
      "ja": "今日、一般的に遭遇したランダム性要件は、ユーザーパスワード、通常は単純な文字列を選択することです。明らかに、推測できるパスワードはセキュリティを提供しません。再使用可能なパスワードの場合、ユーザーはパスワードを覚えていることが望ましいです。これは、通常の単語で構成された発音可能な文字列やフレーズを使用することをお勧めします。しかし、これはパスワード情報の形式のみに影響を与えます。パスワードが推測するのが非常に難しいという要件ではありません。"
    },
    {
      "indent": 3,
      "text": "Many other requirements come from the cryptographic arena. Cryptographic techniques can be used to provide a variety of services, including confidentiality and authentication. Such services are based on quantities, traditionally called \"keys\", that are unknown to and unguessable by an adversary.",
      "ja": "他の多くの要件が暗号化アリーナから来る。暗号化技術は、機密性と認証を含むさまざまなサービスを提供するために使用できます。そのようなサービスは、伝統的に「鍵」と呼ばれる数量に基づいています、それは敵対者には不明であり、不燃性ではありません。"
    },
    {
      "indent": 3,
      "text": "There are even TCP/IP protocol uses for randomness in picking initial sequence numbers [RFC1948].",
      "ja": "初期シーケンス番号を選ぶのにTCP / IPプロトコルが使用されている場合は、[RFC1948]。"
    },
    {
      "indent": 3,
      "text": "Generally speaking, the above examples also illustrate two different types of random quantities that may be wanted. In the case of human-usable passwords, the only important characteristic is that they be unguessable. It is not important that they may be composed of ASCII characters, so the top bit of every byte is zero, for example. On the other hand, for fixed length keys and the like, one normally wants quantities that appear to be truly random, that is, quantities whose bits will pass statistical randomness tests.",
      "ja": "一般的に言って、上記の例は、望んでいてもよい2つの異なるタイプのランダムな量を説明する。人間の使いやすいパスワードの場合、唯一の重要な特徴は彼らが不正なことであるということです。それらがASCII文字で構成されている可能性が重要ではないので、たとえばバイトごとの上位ビットはゼロです。一方、固定長キー等の場合、通常はランダムであるように見える量、すなわちビットが統計的ランダム性試験に合格する量を望んでいる。"
    },
    {
      "indent": 3,
      "text": "In some cases, such as the use of symmetric encryption with the one-time pads or an algorithm like the US Advanced Encryption Standard [AES], the parties who wish to communicate confidentially and/or with authentication must all know the same secret key. In other cases, where asymmetric or \"public key\" cryptographic techniques are used, keys come in pairs. One key of the pair is private and must be kept secret by one party; the other is public and can be published to the world. It is computationally infeasible to determine the private key from the public key, and knowledge of the public key is of no help to an adversary [ASYMMETRIC]. See general references [SCHNEIER, FERGUSON, KAUFMAN].",
      "ja": "ある場合には、1回限りのパッドまたは米国の高度な暗号化規格[AES]のような対称暗号化の使用など、認証を確信や認証と通信したい当事者は、すべて同じ秘密鍵を知っている必要があります。他の場合では、非対称または「公開鍵」暗号化技術が使用される場合、キーはペアで来る。ペアの1つの鍵はプライベートで、一人のパーティーによって秘密にされなければなりません。もう一つは一般に、世界に公開することができます。公開鍵からの秘密鍵を決定することができ、公開鍵の知識は敵の[非対称]に役立ちません。一般参照[シュナエル、ファーガソン、Kaufman]を参照してください。"
    },
    {
      "indent": 3,
      "text": "The frequency and volume of the requirement for random quantities differs greatly for different cryptographic systems. With pure RSA, random quantities are required only when a new key pair is generated; thereafter, any number of messages can be signed without a further need for randomness. The public key Digital Signature Algorithm devised by the US National Institute of Standards and Technology (NIST) requires good random numbers for each signature [DSS]. And",
      "ja": "ランダムな量の要求の周波数と体積は、異なる暗号システムに対して大きく異なります。純粋なRSAを使用すると、新しいキーペアが生成されたときにのみランダムな量が必要です。その後、ランダム性をさらに必要とせずに任意の数のメッセージを署名することができる。米国国立標準技術研究所（NIST）によって考案された公開鍵デジタル署名アルゴリズムは、各シグネチャ[DSS]に対して良い乱数を必要とします。そして"
    },
    {
      "indent": 3,
      "text": "encrypting with a one-time pad (in principle the strongest possible encryption technique) requires randomness of equal volume to all the messages to be processed. See general references [SCHNEIER, FERGUSON, KAUFMAN].",
      "ja": "ワンタイムパッドで暗号化する（原則として、可能な限り最強の暗号化技術で）処理されるすべてのメッセージに対して等しいボリュームのランダム性を必要とします。一般参照[シュナエル、ファーガソン、Kaufman]を参照してください。"
    },
    {
      "indent": 3,
      "text": "In most of these cases, an adversary can try to determine the \"secret\" key by trial and error. This is possible as long as the key is enough smaller than the message that the correct key can be uniquely identified. The probability of an adversary succeeding at this must be made acceptably low, depending on the particular application. The size of the space the adversary must search is related to the amount of key \"information\" present, in an information-theoretic sense [SHANNON]. This depends on the number of different secret values possible and the probability of each value, as follows:",
      "ja": "これらのケースのほとんどで、敵対者は試行錯誤によって「秘密」キーを決定しようとすることができます。これは、キーが正しいキーを一意に識別できるというメッセージより十分に小さい限り可能である。これに成功した敵対者の確率は、特定の用途に応じて、許容可能に低くされなければならない。敵対者のサイズは、検索する必要があります。これは、次のように可能な異なる秘密値の数と各値の確率に依存します。"
    },
    {
      "indent": 8,
      "text": "                      -----\n                      \\\nBits of information =  \\     - p   * log  ( p  )\n                       /        i       2    i\n                      /\n                      -----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where i counts from 1 to the number of possible secret values and p sub i is the probability of the value numbered i. (Because p sub i is less than one, the log will be negative, so each term in the sum will be non-negative.)",
      "ja": "ここで、1から可能な秘密値の数、およびPサブiの数は、値の番号が付けられた確率です。（P SUB iが1未満のため、ログは負になりますので、合計内の各項目は負ではないでしょう。）"
    },
    {
      "indent": 3,
      "text": "If there are 2^n different values of equal probability, then n bits of information are present and an adversary would have to try, on the average, half of the values, or 2^(n-1), before guessing the secret quantity. If the probability of different values is unequal, then there is less information present, and fewer guesses will, on average, be required by an adversary. In particular, any values that an adversary can know to be impossible or of low probability can be initially ignored by the adversary, who will search through the more probable values first.",
      "ja": "同じ確率の2つの異なる値がある場合、Nビットの情報が存在し、承認の数量を推測する前に、平均、値の半分、または2 ^（n-1）を試してみる必要があります。。異なる値の確率が等しくない場合は、情報が少なくなり、推測が少なくなり、平均して敵対者に必要とされます。特に、敵対者が不可能であることを知ることができる任意の値は、最初により確実な値を検索する敵対者によって最初に無視されることができる任意の値を最初に無視することができます。"
    },
    {
      "indent": 3,
      "text": "For example, consider a cryptographic system that uses 128-bit keys. If these keys are derived using a fixed pseudo-random number generator that is seeded with an 8-bit seed, then an adversary needs to search through only 256 keys (by running the pseudo-random number generator with every possible seed), not 2^128 keys as may at first appear to be the case. Only 8 bits of \"information\" are in these 128-bit keys.",
      "ja": "たとえば、128ビットキーを使用する暗号化システムを考えてみましょう。これらのキーが8ビットシードを播種された固定擬似乱数発生器を使用して導出された場合、敵対者は256のキーを通して（すべての可能なシードで疑似乱数ジェネレータを実行することによって）256のキーを検索する必要があります。^ 128キーは、まずケースのように見えます。これらの128ビットキーには8ビットの「情報」があります。"
    },
    {
      "indent": 3,
      "text": "While the above analysis is correct on average, it can be misleading in some cases for cryptographic analysis where what is really important is the work factor for an adversary. For example, assume that there is a pseudo-random number generator generating 128-bit keys, as in the previous paragraph, but that it generates zero half of the time and a random selection from the remaining 2^128 - 1 values the rest of the time. The Shannon equation above says that there are 64 bits of information in one of these key values, but an adversary, simply by trying the value zero, can break the security of half of the uses, albeit a random half. Thus, for cryptographic purposes, it is also useful to look at other measures, such as min-entropy, defined as",
      "ja": "上記の分析は平均的に正しいですが、本当に重要なものが敵対者の仕事要因である暗号分析のために誤解を招く可能性があります。たとえば、前の段落のように128ビットキーを生成する疑似乱数発生器があると仮定しますが、残りの2 ^ 128  -  1の残りの2 ^ 128  -  1の値から半分の半分半分を生成するとします。時間。上記のシャノン式は、これらの重要な値の1つに64ビットの情報があると言いますが、単に値ゼロを試すことによって、敵対者は、ランダムな半分になることを示しています。したがって、暗号化の目的のために、そのまま定義されたMin-Entropyなどの他の措置を調べることも有用です。"
    },
    {
      "indent": 8,
      "text": "Min-entropy = - log ( maximum ( p ) ) i",
      "ja": "Min-entropy = - log ( maximum ( p ) ) i"
    },
    {
      "indent": 3,
      "text": "where i is as above. Using this equation, we get 1 bit of min-entropy for our new hypothetical distribution, as opposed to 64 bits of classical Shannon entropy.",
      "ja": "私は上記の通りです。この方程式を使用して、64ビットの古典的なシャノンエントロピーとは対照的に、私たちの新しい仮説分布のための1ビットの最小エントロピーを得ます。"
    },
    {
      "indent": 3,
      "text": "A continuous spectrum of entropies, sometimes called Renyi entropy, has been defined, specified by the parameter r. Here r = 1 is Shannon entropy and r = infinity is min-entropy. When r = zero, it is just log (n), where n is the number of non-zero probabilities. Renyi entropy is a non-increasing function of r, so min-entropy is always the most conservative measure of entropy and usually the best to use for cryptographic evaluation [LUBY].",
      "ja": "Renyi Entropyと呼ばれるエントロピーの連続スペクトルは、パラメータRによって指定されています。ここで、R = 1はシャノンエントロピーであり、R =無限大は最小エントロピーである。R =ゼロのとき、それはただログ（n）です。ここで、nはゼロ以外の確率の数です。Renyi EntropyはRの非増加機能です。そのため、最小エントロピーは常にエントロピーの最も控えめな尺度です。"
    },
    {
      "indent": 3,
      "text": "Statistically tested randomness in the traditional sense is NOT the same as the unpredictability required for security use.",
      "ja": "伝統的な意味で統計的にテストされたランダム性は、セキュリティの使用に必要な予測不可能性と同じではありません。"
    },
    {
      "indent": 3,
      "text": "For example, the use of a widely available constant sequence, such as the random table from the CRC Standard Mathematical Tables, is very weak against an adversary. An adversary who learns of or guesses it can easily break all security, future and past, based on the sequence [CRC]. As another example, using AES with a constant key to encrypt successive integers such as 1, 2, 3, ... will produce output that also has excellent statistical randomness properties but is predictable. On the other hand, taking successive rolls of a six-sided die and encoding the resulting values in ASCII would produce statistically poor output with a substantial unpredictable component. So note that passing or failing statistical tests doesn't reveal whether something is unpredictable or predictable.",
      "ja": "例えば、CRC標準数学テーブルからのランダムテーブルなどの広く利用可能な定数シーケンスを使用することは、敵対者に対して非常に弱い。それを学ぶか推測する敵対者は、シーケンス[CRC]に基づいて、すべてのセキュリティ、将来、過去を壊すことができます。別の例として、1,2,3のような連続した整数を暗号化するために定数キーを有するAESを使用することは、優れた統計的ランダム性特性を有するが予測可能である出力を生成する。一方、6面ダイの連続したロールをとり、ASCIIの結果として生じる値を符号化すると、実質的な予測不可能な構成要素を用いて統計的に不十分な出力が生じるであろう。だから、統計的テストの通過または失敗した統計的テストは、何かが予測不可能であるか予測可能であるかどうかを明らかにしません。"
    },
    {
      "indent": 0,
      "text": "3. Entropy Sources",
      "section_title": true,
      "ja": "3. エントロピー源"
    },
    {
      "indent": 3,
      "text": "Entropy sources tend to be very implementation dependent. Once one has gathered sufficient entropy, it can be used as the seed to produce the required amount of cryptographically strong pseudo-randomness, as described in Sections 6 and 7, after being de-skewed or mixed as necessary, as described in Sections 4 and 5.",
      "ja": "エントロピー源は非常に実装に依存する傾向があります。十分なエントロピーが集まったら、セクション4および5に記載されているように、セクション6および7に記載されているように、必要に応じて、必要に応じて歪んだり混合した後に必要な量の暗号的に強い疑似ランダム性を生成するためのシードとして使用できます。"
    },
    {
      "indent": 3,
      "text": "Is there any hope for true, strong, portable randomness in the future? There might be. All that's needed is a physical source of unpredictable numbers.",
      "ja": "将来的には、真性な、強い、ポータブルなランダム性は期待できるでしょうか？おそらく期待できるかもしれません。必要なのは予測不可能な数の物理的な源泉です。"
    },
    {
      "indent": 3,
      "text": "Thermal noise (sometimes called Johnson noise in integrated circuits) or a radioactive decay source and a fast, free-running oscillator would do the trick directly [GIFFORD]. This is a trivial amount of hardware, and it could easily be included as a standard part of a computer system's architecture. Most audio (or video) input devices are usable [TURBID]. Furthermore, any system with a spinning disk or ring oscillator and a stable (crystal) time source or the like has an adequate source of randomness ([DAVIS] and Section 3.3). All that's needed is the common perception among computer vendors that this small additional hardware and the software to access it is necessary and useful.",
      "ja": "熱雑音（集積回路のジョンソンノイズとも呼ばれる）または放射性減衰源と高速でフリーランニングオシレータが直接トリックをすることができます。これは些細なハードウェアであり、コンピュータシステムのアーキテクチャの標準部分として簡単に含めることができます。ほとんどのオーディオ（またはビデオ）入力デバイスは使用可能な[Turbid]です。さらに、紡績ディスクまたはリングオシレータおよび安定（水晶）タイム源などの任意のシステムは、適切なランダム性源（[DAVIS]および3.3）を有する。必要なのは、この小さな追加のハードウェアとそれにアクセスするためのソフトウェアが必要かつ有用であることをコンピュータベンダーの共通認識です。"
    },
    {
      "indent": 3,
      "text": "ANSI X9 is currently developing a standard that includes a part devoted to entropy sources. See Part 2 of [X9.82].",
      "ja": "ANSI X9は現在、エントロピーソースに費やされた部分を含む標準を開発しています。[X9.82]のパート2を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.1. Volume Required",
      "section_title": true,
      "ja": "3.1. 要求される量"
    },
    {
      "indent": 3,
      "text": "How much unpredictability is needed? Is it possible to quantify the requirement in terms of, say, number of random bits per second?",
      "ja": "必要な不安定性が必要ですか？毎秒のランダムビット数の観点から、要件を定量化することは可能ですか？"
    },
    {
      "indent": 3,
      "text": "The answer is that not very much is needed. For AES, the key can be 128 bits, and, as we show in an example in Section 8, even the highest security system is unlikely to require strong keying material of much over 200 bits. If a series of keys is needed, they can be generated from a strong random seed (starting value) using a cryptographically strong sequence, as explained in Section 6.2. A few hundred random bits generated at start-up or once a day is enough if such techniques are used. Even if the random bits are generated as slowly as one per second and it is not possible to overlap the generation process, it should be tolerable in most high-security applications to wait 200 seconds occasionally.",
      "ja": "答えはあまり必要とされていないということです。AESの場合、鍵は128ビットになる可能性がありますが、セクション8の例で示すように、最高のセキュリティシステムでさえも、200ビット以上の強力なキーイング材料を必要とする可能性は低いです。一連のキーが必要な場合は、セクション6.2で説明したように、暗号的に強いシーケンスを使用して強いランダムシード（開始値）から生成できます。そのような技術が使用される場合、起動時または1日に1回生成された数百のランダムビットが十分である。ランダムビットが1秒あたりの1つと同じくらいゆっくりと生成されたとしても、生成プロセスと重なっても不可能であっても、時々200秒待ちます。"
    },
    {
      "indent": 3,
      "text": "These numbers are trivial to achieve. It could be achieved by a person repeatedly tossing a coin, and almost any hardware based process is likely to be much faster.",
      "ja": "これらの数字は達成するのに些細です。それは硬貨を繰り返し投げ、そしてほとんどすべてのハードウェアベースのプロセスがはるかに速くなる可能性が高いことによって達成され得る。"
    },
    {
      "indent": 0,
      "text": "3.2. Existing Hardware Can Be Used For Randomness",
      "section_title": true,
      "ja": "3.2. 既存のハードウェアはランダム性に使用できます"
    },
    {
      "indent": 3,
      "text": "As described below, many computers come with hardware that can, with care, be used to generate truly random quantities.",
      "ja": "後述するように、多くのコンピュータには、注意して、真にランダムな量を生成するために使用できるハードウェアが付属しています。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Using Existing Sound/Video Input",
      "section_title": true,
      "ja": "3.2.1. 既存のサウンド/ビデオ入力を使用する"
    },
    {
      "indent": 3,
      "text": "Many computers are built with inputs that digitize some real-world analog source, such as sound from a microphone or video input from a camera. The \"input\" from a sound digitizer with no source plugged in or from a camera with the lens cap on is essentially thermal noise. If the system has enough gain to detect anything, such input can provide reasonably high quality random bits. This method is extremely dependent on the hardware implementation.",
      "ja": "多くのコンピュータは、マイクロフォンやカメラからのビデオ入力の音など、いくつかの実世界のアナログソースをデジタル化する入力で構築されています。レンズキャップオンのカメラからの電源が入っていない音声デジタイザからの「入力」は、本質的に熱雑音です。システムが何も検出するのに十分な利得がある場合、そのような入力はかなり高品質のランダムビットを提供できます。このメソッドはハードウェア実装に非常に依存しています。"
    },
    {
      "indent": 3,
      "text": "For example, on some UNIX-based systems, one can read from the /dev/audio device with nothing plugged into the microphone jack or with the microphone receiving only low level background noise. Such data is essentially random noise, although it should not be trusted without some checking, in case of hardware failure, and it will have to be de-skewed.",
      "ja": "たとえば、一部のUNIXベースのシステムでは、マイクロフォンジャックに接続されていない、または低レベルのバックグラウンドノイズのみを受けるマイクを使用して、/ DEV /オーディオデバイスから読み取ることができます。そのようなデータは本質的にランダムなノイズですが、ハードウェアの障害の場合には何度もチェックすることなく信頼されるべきではなく、歪んでいなければならないでしょう。"
    },
    {
      "indent": 3,
      "text": "Combining this approach with compression to de-skew (see Section 4), one can generate a huge amount of medium-quality random data with the UNIX-style command line:",
      "ja": "このアプローチを圧縮に組み合わせる（セクション4を参照）、UNIX形式のコマンドラインで膨大な量の中質ランダムデータを生成できます。"
    },
    {
      "indent": 8,
      "text": "cat /dev/audio | compress - >random-bits-file",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A detailed examination of this type of randomness source appears in [TURBID].",
      "ja": "この種のランダム性源の詳細な検討は、[濁っている]に現れる。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Using Existing Disk Drives",
      "section_title": true,
      "ja": "3.2.2. 既存のディスクドライブを使用する"
    },
    {
      "indent": 3,
      "text": "Disk drives have small random fluctuations in their rotational speed due to chaotic air turbulence [DAVIS, Jakobsson]. The addition of low-level disk seek-time instrumentation produces a series of measurements that contain this randomness. Such data is usually highly correlated, so significant processing is needed, as described in Section 5.2 below. Nevertheless, experimentation a decade ago showed that, with such processing, even slow disk drives on the slower computers of that day could easily produce 100 bits a minute or more of excellent random data.",
      "ja": "ディスクドライブは、カオス空気乱流のための回転速度に小さなランダムな変動を持ちます[Davis、Jakobsson]。低レベルのディスクシークタイム計装の追加は、このランダム性を含む一連の測定値を生成します。そのようなデータは通常非常に相関があり、以下のセクション5.2で説明されているように、非常に大きな処理が必要である。それにもかかわらず、10年前に、その日の遅いコンピュータ上の遅いディスクドライブでさえも、1分以上のランダムデータを容易に生成することができることを理解した。"
    },
    {
      "indent": 0,
      "text": " Every increase in processor speed, which increases the resolution with which disk motion can be timed or increases the rate of disk seeks, increases the rate of random bit generation possible with this technique. At the time of this paper and with modern hardware, a more typical rate of random bit production would be in excess of 10,000 bits a second. This technique is used in random number generators included in many operating system libraries.",
      "ja": "ディスクの動きをタイミングまたは増加させることができる解像度を高めるプロセッサ速度の増加は、この技術で可能なランダムビット生成の速度を増加させます。この紙の時代と現代のハードウェアでは、ランダムビット生産のより典型的なレートは10,000ビットを超えています。この手法は、多くのオペレーティングシステムライブラリに含まれる乱数発生器で使用されています。"
    },
    {
      "indent": 3,
      "text": "Note: the inclusion of cache memories in disk controllers has little effect on this technique if very short seek times, which represent cache hits, are simply ignored.",
      "ja": "注：キャッシュ・ヒットを表す非常に短いシーク回数が単に無視される場合、ディスク・コントローラー内のキャッシュ・メモリーを含めることはこの技術にほとんど影響を与えません。"
    },
    {
      "indent": 0,
      "text": "3.3. Ring Oscillator Sources",
      "section_title": true,
      "ja": "3.3. リングオシレータソース"
    },
    {
      "indent": 3,
      "text": "If an integrated circuit is being designed or field-programmed, an odd number of gates can be connected in series to produce a free-running ring oscillator. By sampling a point in the ring at a fixed frequency (for example, one determined by a stable crystal oscillator), some amount of entropy can be extracted due to variations in the free-running oscillator timing. It is possible to increase the rate of entropy by XOR'ing sampled values from a few ring oscillators with relatively prime lengths. It is sometimes recommended that an odd number of rings be used so that, even if the rings somehow become synchronously locked to each other, there will still be sampled bit transitions. Another possible source to sample is the output of a noisy diode.",
      "ja": "集積回路が設計されているかフィールドプログラムされている場合、奇数個のゲートを直列に接続してフリーランニングリングオシレータを生成することができる。固定周波数（例えば安定した水晶発振器によって決定されるもの）でリング内の点をサンプリングすることによって、自走発振器のタイミングのばらつきによりエントロピーのある程度のエントロピーを抽出することができる。比較的素数の長さを有するいくつかのリングオシレータからのサンプリングされた値をXOR 'のXOR'ER'を増やすことが可能である。時には奇数のリングを使用することをお勧めします。サンプルのもう1つの可能なソースは、ノイズの多いダイオードの出力です。"
    },
    {
      "indent": 3,
      "text": "Sampled bits from such sources will have to be heavily de-skewed, as disk rotation timings must be (see Section 4). An engineering study would be needed to determine the amount of entropy being produced depending on the particular design. In any case, these can be good sources whose cost is a trivial amount of hardware by modern standards.",
      "ja": "このような情報源からのサンプリングされたビットは、ディスクの回転タイミングがなければならないので、大きく歪む必要があります（セクション4を参照）。特定の設計に応じて生産されているエントロピーの量を決定するためには、エンジニアリング研究が必要になります。いずれにせよ、これらは現代の標準による些細な量のハードウェアである良いソースであり得る。"
    },
    {
      "indent": 3,
      "text": "As an example, IEEE 802.11i suggests the circuit below, with due attention in the design to isolation of the rings from each other and from clocked circuits to avoid undesired synchronization, etc., and with extensive post processing [IEEE_802.11i].",
      "ja": "一例として、IEEE802.11iは、望ましくない同期などを回避するために、互いからのリングを互いに絶縁するために設計に、そしてクロックされた回路からの設計に注意を払って、および豊富な後処理を避けるための回路を示唆している。"
    },
    {
      "indent": 9,
      "text": "    |\\     |\\                |\\\n+-->| >0-->| >0-- 19 total --| >0--+-------+\n|   |/     |/                |/    |       |\n|                                  |       |\n+----------------------------------+       V\n                                        +-----+\n    |\\     |\\                |\\         |     | output\n+-->| >0-->| >0-- 23 total --| >0--+--->| XOR |------>\n|   |/     |/                |/    |    |     |\n|                                  |    +-----+\n+----------------------------------+      ^ ^\n                                          | |\n    |\\     |\\                |\\           | |\n+-->| >0-->| >0-- 29 total --| >0--+------+ |\n|   |/     |/                |/    |        |\n|                                  |        |\n+----------------------------------+        |\n                                            |\n    Other randomness, if available ---------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.4. Problems with Clocks and Serial Numbers",
      "section_title": true,
      "ja": "3.4. 時計とシリアル番号に関する問題"
    },
    {
      "indent": 3,
      "text": "Computer clocks and similar operating system or hardware values, provide significantly fewer real bits of unpredictability than might appear from their specifications.",
      "ja": "コンピュータの時計と同様のオペレーティングシステムまたはハードウェア値は、それらの仕様から現れるよりも、予測不可能な不可能なビットを大幅に少なくします。"
    },
    {
      "indent": 3,
      "text": "Tests have been done on clocks on numerous systems, and it was found that their behavior can vary widely and in unexpected ways. One version of an operating system running on one set of hardware may actually provide, say, microsecond resolution in a clock, while a different configuration of the \"same\" system may always provide the same lower bits and only count in the upper bits at much lower resolution. This means that successive reads of the clock may produce identical values even if enough time has passed that the value \"should\" change based on the nominal clock resolution. There are also cases where frequently reading a clock can produce artificial sequential values, because of extra code that checks for the clock being unchanged between two reads and increases it by one! Designing portable application code to generate unpredictable numbers based on such system clocks is particularly challenging because the system designer does not always know the properties of the system clock.",
      "ja": "テストは多数のシステムの時計で行われており、それらの行動は広くそして予期せぬ方法でさまざまに異なることがわかった。1組のハードウェア上で実行されるオペレーティングシステムの1つのバージョンは、実際にはクロックでマイクロ秒の分解能を提供することができ、「同じ」システムの異なる構成は常に同じ下位ビットを提供し、上位ビットのみのカウントだけであることができる。低解像度。これは、公称クロック解像度に基づいて値が変化するのに十分な時間が経過したとしても、クロックの連続する読み取りが同一の値を生成する可能性があることを意味します。2つの読み取りの間で変更されずにそれを1つ増加させるために、クロックを読み取ることができる頻繁に、時計を読み取ることができるケースも人工的な順次値を生み出すことができる。このようなシステムクロックに基づいて予測できない数字を生成するためのポータブルアプリケーションコードの設計システム設計者は必ずしもシステムクロックのプロパティを知らないため、特に困難です。"
    },
    {
      "indent": 3,
      "text": "Use of a hardware serial number (such as an Ethernet MAC address) may also provide fewer bits of uniqueness than one would guess. Such quantities are usually heavily structured, and subfields may have only a limited range of possible values, or values may be easily guessable based on approximate date of manufacture or other data.",
      "ja": "ハードウェアシリアル番号（イーサネットMACアドレスなど）の使用は、推測するよりも一意の一意性が少なくてもよい。そのような量は通常高度に構造化され、サブフィールドは限られた範囲の可能な値のみを有してもよく、または値は、製造の近似日または他のデータに基づいて容易に推測できる可能性がある。"
    },
    {
      "indent": 3,
      "text": "For example, it is likely that a company that manufactures both computers and Ethernet adapters will, at least internally, use its own adapters, which significantly limits the range of built-in addresses.",
      "ja": "たとえば、コンピュータとイーサネットアダプタの両方を製造する会社は、少なくとも内部的に独自のアダプタを使用しているため、内蔵アドレスの範囲を大幅に制限します。"
    },
    {
      "indent": 3,
      "text": "Problems such as those described above make the production of code to generate unpredictable quantities difficult if the code is to be ported across a variety of computer platforms and systems.",
      "ja": "上記のような問題は、コードがさまざまなコンピュータプラットフォームやシステムに移植されることになっている場合、予期しない数量を生成するためのコードの作成を行うことができます。"
    },
    {
      "indent": 0,
      "text": "3.5. Timing and Value of External Events",
      "section_title": true,
      "ja": "3.5. 外部イベントのタイミングと値"
    },
    {
      "indent": 3,
      "text": "It is possible to measure the timing and content of mouse movement, key strokes, and similar user events. This is a reasonable source of unguessable data, with some qualifications. On some machines, input such as key strokes is buffered. Even though the user's inter-keystroke timing may have sufficient variation and unpredictability, there might not be an easy way to access that variation. Another problem is that no standard method exists for sampling timing details. This makes it hard to use this technique to build standard software intended for distribution to a large range of machines.",
      "ja": "マウスの移動、キーストローク、および同様のユーザーイベントのタイミングと内容を測定することができます。これはいくつかの資格を持つ、クエステーション不可能なデータの合理的な源です。いくつかのマシンでは、キーストロークなどの入力がバッファされています。ユーザのキーストロークタイミングで十分な変動性と予測不可能性がある場合でも、そのバリエーションにアクセスする簡単な方法がない可能性があります。もう1つの問題は、タイミングの詳細をサンプリングするための標準的な方法が存在しないことです。これはこの技術を使用して、広範囲のマシンへの配布を目的とした標準ソフトウェアを構築することを困難にします。"
    },
    {
      "indent": 3,
      "text": "The amount of mouse movement and the actual key strokes are usually easier to access than timings, but they may yield less unpredictability because the user may provide highly repetitive input.",
      "ja": "マウスの動きと実際のキーストロークの量は、通常、タイミングよりもアクセスが簡単ですが、ユーザーは反復的な入力を提供する可能性があるため、予測不可能性が低くなる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Other external events, such as network packet arrival times and lengths, can also be used, but only with great care. In particular, the possibility of manipulation of such network traffic measurements by an adversary and the lack of history at system start-up must be carefully considered. If this input is subject to manipulation, it must not be trusted as a source of entropy.",
      "ja": "ネットワークパケットの到着時間や長さなどの他の外部イベントも使用できますが、細心の注意を払うだけです。特に、システム起動時の敵対的および歴史の欠如によるそのようなネットワーク交通測定の操作の可能性は慎重に検討されなければならない。この入力が操作の対象となる場合は、エントロピーの源として信頼されてはいけません。"
    },
    {
      "indent": 3,
      "text": "In principle, almost any external sensor, such as raw radio reception or temperature sensing in appropriately equipped computers, can be used. But in each case, careful consideration must be given to how much this data is subject to adversarial manipulation and to how much entropy it can actually provide.",
      "ja": "原則として、RAW無線受信または適切な搭載されたコンピュータにおける温度検知などのほとんどすべての外部センサを使用することができる。しかし、それぞれの場合では、このデータが敵対的な操作の対象となる量とそれが実際にどのくらいのエントロピーを提供できるかには慎重に検討されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The above techniques are quite powerful against attackers that have no access to the quantities being measured. For example, these techniques would be powerful against offline attackers who had no access to one's environment and who were trying to crack one's random seed after the fact. In all cases, the more accurately one can measure the timing or value of an external sensor, the more rapidly one can generate bits.",
      "ja": "上記の技術は、測定されている量にアクセスできない攻撃者に対して非常に強力です。例えば、これらの技術は、自分の環境にアクセスできないオフライン攻撃者に対して強力であり、その事実後に自分のランダムな種を亀裂しようとしていた人は。全ての場合において、より正確に外部センサのタイミングまたは値を測定することができるが、より急速にビットを生成することができる。"
    },
    {
      "indent": 0,
      "text": "3.6. Non-hardware Sources of Randomness",
      "section_title": true,
      "ja": "3.6. ランダム性の非ハードウェア源"
    },
    {
      "indent": 3,
      "text": "The best source of input entropy would be a hardware-based random source such as ring oscillators, disk drive timing, thermal noise, or radioactive decay. However, if none of these is available, there are other possibilities. These include system clocks, system or input/output buffers, user/system/hardware/network serial numbers or addresses and timing, and user input. Unfortunately, each of these sources can produce very limited or predictable values under some circumstances.",
      "ja": "入力エントロピーの最良の情報源は、リングオシレータ、ディスクドライブのタイミング、熱ノイズ、または放射性崩壊などのハードウェアベースのランダムソースです。ただし、これらのどれも利用可能な場合は他の可能性があります。これらには、システムクロック、システム、または入出力バッファ、ユーザー/システム/ハードウェア/ネットワークのシリアル番号、またはアドレスとタイミング、およびユーザー入力が含まれます。残念ながら、これらの各情報源は状況によっては非常に限られたまたは予測可能な値を生み出すことができます。"
    },
    {
      "indent": 3,
      "text": "Some of the sources listed above would be quite strong on multi-user systems, where each user of the system is in essence a source of randomness. However, on a small single-user or embedded system, especially at start-up, it might be possible for an adversary to assemble a similar configuration. This could give the adversary inputs to the mixing process that were well-enough correlated to those used originally to make exhaustive search practical.",
      "ja": "上記のいくつかの情報源は、システムの各ユーザがエッセンスであるマルチユーザシステムでは非常に強いであろう。ただし、特に起動時には、小型のシングルユーザーまたは組み込みシステムでは、敵対的な構成を組み立てることが可能かもしれません。これにより、徹底的な検索を実用化するためにもともとに使用されるものとよく相関している混合プロセスへの敵対的な入力が与える可能性があります。"
    },
    {
      "indent": 3,
      "text": "The use of multiple random inputs with a strong mixing function is recommended and can overcome weakness in any particular input. The timing and content of requested \"random\" user keystrokes can yield hundreds of random bits, but conservative assumptions need to be made. For example, one reasonably conservative assumption would be that an inter-keystroke interval provides at most a few bits of randomness, but only when the interval is unique in the sequence of intervals up to that point. A similar assumption would be that a key code provides a few bits of randomness, but only when the code is unique in the sequence. Thus, an interval or key code that duplicated a previous value would be assumed to provide no additional randomness. The results of mixing these timings with typed characters could be further combined with clock values and other inputs.",
      "ja": "強力な混合関数を持つ複数のランダム入力を使用することをお勧めし、特定の入力の脆弱性を克服することができます。要求された「ランダム」ユーザキーストロークのタイミングと内容は数百のランダムビットを生成することができるが、保守的な仮定をなす必要がある。例えば、1つの合理的に保守的な仮定は、キー間停止間隔が最大数ビットのランダム性を提供することであるということであるが、間隔がその時点までの間隔で一意であるときだけである。同様の仮定は、キーコードが数ビットのランダム性を提供するが、コードがシーケンス内で一意である場合に限り、あるであろう。したがって、前の値を複製した間隔またはキーコードは、追加のランダム性を提供しないと仮定されます。これらのタイミングを型付き文字で混合した結果を、クロック値や他の入力とさらに組み合わせることができます。"
    },
    {
      "indent": 3,
      "text": "This strategy may make practical portable code for producing good random numbers for security, even if some of the inputs are very weak on some of the target systems. However, it may still fail against a high-grade attack on small, single-user, or embedded systems, especially if the adversary has ever been able to observe the generation process in the past. A hardware-based random source is still preferable.",
      "ja": "この戦略は、いくつかのターゲットシステムでいくつかの入力が非常に弱い場合でも、セキュリティのために良い乱数を生成するための実用的な携帯コードを作ることができます。ただし、特に敵対者が過去の生成プロセスを観察できたことがある場合は、まだ小型、シングルユーザー、または組み込みシステムでの高級攻撃に対して失敗する可能性があります。ハードウェアベースのランダムソースが依然として好ましい。"
    },
    {
      "indent": 0,
      "text": "4. De-skewing",
      "section_title": true,
      "ja": "4. 平滑化"
    },
    {
      "indent": 0,
      "text": " Is there any specific requirement on the shape of the distribution of quantities gathered for the entropy to produce the random numbers? The good news is that the distribution need not be uniform. All that is needed to bound performance is a conservative estimate of how non-uniform it is. Simple techniques to de-skew a bit stream are given below, and stronger cryptographic techniques are described in Section 5.2.",
      "ja": "乱数を生成するためにエントロピーのために集められた量の分布の形状に対する特定の要件はありますか？良いニュースは、分布が均一である必要はないということです。パフォーマンスを束縛するために必要なすべてのものはすべて不均一なものの控えめな推定値です。ビットストリームを逆スキュー解除するための簡単な技術を以下に示し、より強い暗号化技術がセクション5.2に記載されている。"
    },
    {
      "indent": 0,
      "text": "4.1. Using Stream Parity to De-Skew",
      "section_title": true,
      "ja": "4.1. ストリームパリティを使った平滑化"
    },
    {
      "indent": 3,
      "text": "As a simple but not particularly practical example, consider taking a sufficiently long string of bits and mapping the string to \"zero\" or \"one\". The mapping will not yield a perfectly uniform distribution, but it can be as close as desired. One mapping that serves the purpose is to take the parity of the string. This has the advantages that it is robust across all degrees of skew up to the estimated maximum skew and that it is trivial to implement in hardware.",
      "ja": "単純だが特に実用的な例としては、十分に長いビットの一列のビットを取り、文字列を「ゼロ」または「1」にマッピングすることを検討してください。マッピングは完全に均一な分布をもたらさないが、それは望み通りに近いことができる。目的を果たす1つのマッピングは、文字列のパリティを取ることです。これは、推定最大スキューまでのすべての歪みの程度にわたって頑強であり、ハードウェアで実装するのが簡単であるという利点を有する。"
    },
    {
      "indent": 3,
      "text": "The following analysis gives the number of bits that must be sampled:",
      "ja": "次の分析では、サンプリングする必要があるビット数を示します。"
    },
    {
      "indent": 3,
      "text": "Suppose that the ratio of ones to zeros is ( 0.5 + E ) to ( 0.5 - E ), where E is between 0 and 0.5 and is a measure of the \"eccentricity\" of the distribution. Consider the distribution of the parity function of N bit samples. The respective probabilities that the parity will be one or zero will be the sum of the odd or even terms in the binomial expansion of (p + q)^N, where p = 0.5 + E, the probability of a one, and q = 0.5 - E, the probability of a zero.",
      "ja": "ゼロ対ゼロの比率が（0.5 e）〜（0.5°E）であると仮定すると、Eは0から0.5の間であり、分布の「偏心」の尺度であるとします。Nビットサンプルのパリティ関数の分布を考慮してください。パリティが1またはゼロになることのそれぞれの確率は、（PQ）^ nの二項展開における奇数または偶数の用語の合計であり、ここで、p = 0.5e、1、Q = 0.5  -  e、ゼロの確率。"
    },
    {
      "indent": 3,
      "text": "These sums can be computed easily as",
      "ja": "これらの合計は簡単に計算できます"
    },
    {
      "indent": 8,
      "text": "                 N            N\n1/2 * ( ( p + q )  + ( p - q )  )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "and N N 1/2 * ( ( p + q ) - ( p - q ) ).",
      "ja": "and N N 1/2 * ( ( p + q ) - ( p - q ) )."
    },
    {
      "indent": 3,
      "text": "(Which formula corresponds to the probability that the parity will be 1 depends on whether N is odd or even.)",
      "ja": "（どの式は、nが奇数か偶数になる確率に対応します。"
    },
    {
      "indent": 3,
      "text": "Since p + q = 1 and p - q = 2E, these expressions reduce to",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": " N 1/2 * [1 + (2E) ]",
      "ja": " N 1/2 * [1 + (2E) ]"
    },
    {
      "indent": 3,
      "text": "and N 1/2 * [1 - (2E) ].",
      "ja": "and N 1/2 * [1 - (2E) ]"
    },
    {
      "indent": 3,
      "text": "Neither of these will ever be exactly 0.5 unless E is zero, but we can bring them arbitrarily close to 0.5. If we want the probabilities to be within some delta d of 0.5, e.g., then",
      "ja": "Eがゼロでない限り、これらのどちらも0.5ではありませんが、それらを任意に0.5に近づけることができます。確率が0.5のいくつかのデルタD内にあることを望んでいる場合、"
    },
    {
      "indent": 8,
      "text": " N ( 0.5 + ( 0.5 * (2E) ) ) < 0.5 + d.",
      "ja": " N ( 0.5 + ( 0.5 * (2E) ) ) < 0.5 + d."
    },
    {
      "indent": 3,
      "text": "Solving for N yields N > log(2d)/log(2E). (Note that 2E is less than 1, so its log is negative. Division by a negative number reverses the sense of an inequality.)",
      "ja": "nを解くn> log（2d）/ log（2e）を降伏します。（2Eは1未満であるため、ログは負です。負数の除算は不等式の意味を反転します。）"
    },
    {
      "indent": 3,
      "text": "The following table gives the length N of the string that must be sampled for various degrees of skew in order to come within 0.001 of a 50/50 distribution.",
      "ja": "次の表は、50/50分布の0.001以内に来るために、さまざまな程度のスキューに対してサンプリングされなければならない文字列の長さNを示しています。"
    },
    {
      "indent": 16,
      "text": "+---------+--------+-------+\n| Prob(1) |    E   |    N  |\n+---------+--------+-------+\n|   0.5   |  0.00  |    1  |\n|   0.6   |  0.10  |    4  |\n|   0.7   |  0.20  |    7  |\n|   0.8   |  0.30  |   13  |\n|   0.9   |  0.40  |   28  |\n|   0.95  |  0.45  |   59  |\n|   0.99  |  0.49  |  308  |\n+---------+--------+-------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The last entry shows that even if the distribution is skewed 99% in favor of ones, the parity of a string of 308 samples will be within 0.001 of a 50/50 distribution. But, as we shall see in section 5.2, there are much stronger techniques that extract more of the available entropy.",
      "ja": "最後のエントリでは、配布が99％に歪んでいても99％が99％に歪んでいても、308サンプルのストリングのパリティは50/50分布の0.001以内になります。しかし、セクション5.2に見えるように、利用可能なエントロピーのより多くを抽出するより強い技術がはるかに高いです。"
    },
    {
      "indent": 0,
      "text": "4.2. Using Transition Mappings to De-Skew",
      "section_title": true,
      "ja": "4.2. 遷移マッピングを使った平滑化"
    },
    {
      "indent": 3,
      "text": "Another technique, originally due to von Neumann [VON_NEUMANN], is to examine a bit stream as a sequence of non-overlapping pairs. One could then discard any 00 or 11 pairs found, interpret 01 as a 0 and 10 as a 1. Assume that the probability of a 1 is 0.5+E and that the probability of a 0 is 0.5-E, where E is the eccentricity of the source as described in the previous section. Then the probability of each pair is shown in the following table:",
      "ja": "もともと、Von Neumann [Von_neumann]による他の技術は、重ならないペアのシーケンスとしてビットストリームを調べることである。次いで、0または11対を廃棄し、0を0および10と解釈することができ、0.5 eの確率は0.5 eであり、0の確率は0.5°であると仮定します。ここで、Eはの偏心です。前のセクションで説明したソース。次に、各ペアの確率を次の表に示します。"
    },
    {
      "indent": 12,
      "text": "+------+-----------------------------------------+\n| pair |            probability                  |\n+------+-----------------------------------------+\n|  00  | (0.5 - E)^2          =  0.25 - E + E^2  |\n|  01  | (0.5 - E)*(0.5 + E)  =  0.25     - E^2  |\n|  10  | (0.5 + E)*(0.5 - E)  =  0.25     - E^2  |\n|  11  | (0.5 + E)^2          =  0.25 + E + E^2  |\n+------+-----------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This technique will completely eliminate any bias but requires an indeterminate number of input bits for any particular desired number of output bits. The probability of any particular pair being discarded is 0.5 + 2E^2, so the expected number of input bits to produce X output bits is X/(0.25 - E^2).",
      "ja": "この手法はどのバイアスを完全に排除するが、特定の所望の数の出力ビットに対して不確定数の入力ビットを必要とする。廃棄されている特定のペアの確率は0.5 2e ^ 2であるため、X出力ビットを生成するための入力ビット数の数はX /（0.25  -  E ^ 2）です。"
    },
    {
      "indent": 3,
      "text": "This technique assumes that the bits are from a stream where each bit has the same probability of being a 0 or 1 as any other bit in the stream and that bits are uncorrelated, i.e., that the bits come from identical independent distributions. If alternate bits are from two correlated sources, for example, the above analysis breaks down.",
      "ja": "この技術は、ビットが、ストリーム内の他のどのビットとして0または1と同じ確率があるストリームから、そのビットは無相関、すなわちビットが同一の独立した分布から来ることを仮定する。たとえば、代替ビットが2つの相関ソースからのものである場合は、上記の分析が切断されます。"
    },
    {
      "indent": 3,
      "text": "The above technique also provides another illustration of how a simple statistical analysis can mislead if one is not always on the lookout for patterns that could be exploited by an adversary. If the algorithm were misread slightly so that overlapping successive bits pairs were used instead of non-overlapping pairs, the statistical analysis given would be the same. However, instead of providing an unbiased, uncorrelated series of random 1s and 0s, it would produce a totally predictable sequence of exactly alternating 1s and 0s.",
      "ja": "上記の技術はまた、敵対者によって悪用される可能性があるパターンの展望台ではない場合、単純な統計分析がどのように誤解されるかの別の例を提供する。アルゴリズムがわずかに誤解された場合、重ならないペアの代わりに重なっているビット対を使用したように、与えられた統計分析は同じであろう。ただし、不適切な、無相関の一連のランダム1Sと0Sを提供するのではなく、正確に交互に交互に交互に交互に交互になるシーケンスを生成します。"
    },
    {
      "indent": 0,
      "text": "4.3. Using FFT to De-Skew",
      "section_title": true,
      "ja": "4.3. FFTを使った平滑化"
    },
    {
      "indent": 3,
      "text": "When real-world data consists of strongly correlated bits, it may still contain useful amounts of entropy. This entropy can be extracted through various transforms, the most powerful of which are described in section 5.2 below.",
      "ja": "実世界のデータが強く相関のあるビットで構成されている場合、それでも有用なエントロピーが含まれている可能性があります。このエントロピーはさまざまな変換を通して抽出できますが、最も強力なものは以下のセクション5.2で説明されています。"
    },
    {
      "indent": 3,
      "text": "Using the Fourier transform of the data or its optimized variant, the FFT, is interesting primarily for theoretical reasons. It can be shown that this technique will discard strong correlations. If adequate data is processed and if remaining correlations decay, spectral lines that approach statistical independence and normally distributed randomness can be produced [BRILLINGER].",
      "ja": "データのフーリエ変換またはその最適化されたバリエーションを使用して、FFTは主に理論的な理由から興味深いものです。この技術は強い相関を捨てることを示すことができます。適切なデータが処理され、残りの相関が崩壊した場合、統計的独立および通常分布したランダム性に近づくスペクトル線を生成することができる。"
    },
    {
      "indent": 0,
      "text": "4.4. Using Compression to De-Skew",
      "section_title": true,
      "ja": "4.4. 圧縮を使った平滑化"
    },
    {
      "indent": 3,
      "text": "Reversible compression techniques also provide a crude method of de-skewing a skewed bit stream. This follows directly from the definition of reversible compression and the formula in Section 2 for the amount of information in a sequence. Since the compression is reversible, the same amount of information must be present in the shorter output as was present in the longer input. By the Shannon information equation, this is only possible if, on average, the probabilities of the different shorter sequences are more uniformly distributed than were the probabilities of the longer sequences. Therefore, the shorter sequences must be de-skewed relative to the input.",
      "ja": "可逆的な圧縮技術はまた、斜めのビットストリームを逆スキューするための粗い方法を提供する。これは、シーケンス内の情報量については、リバーシブル圧縮の定義と式2の式の定義から直接次のとおりです。圧縮は可逆的であるため、長い入力に存在していたのと同じ出力に同じ量の情報が存在しなければなりません。シャノン情報方程式によって、平均して、異なる短シーケンスの確率がより長いシーケンスの確率よりも均一に分布している場合にのみ可能です。したがって、より短いシーケンスは入力に対して逆スキューされなければなりません。"
    },
    {
      "indent": 3,
      "text": "However, many compression techniques add a somewhat predictable preface to their output stream and may insert a similar sequence periodically in their output or otherwise introduce subtle patterns of their own. They should be considered only rough techniques compared to those described in Section 5.2. At a minimum, the beginning of the compressed sequence should be skipped and only later bits should used for applications requiring roughly-random bits.",
      "ja": "しかしながら、多くの圧縮技術はそれらの出力ストリームに対して幾分予測可能な序文を追加し、それらの出力において周期的に同様のシーケンスを挿入することができ、あるいはそれら自身の微妙なパターンを導入することができる。それらは、セクション5.2で説明されているものと比較して、大まかな技術のみを考慮する必要があります。最低では、圧縮シーケンスの始まりはスキップされるべきであり、後のビットだけが粗大なランダムなビットを必要とするアプリケーションに使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "5. Mixing",
      "section_title": true,
      "ja": "5. 攪拌"
    },
    {
      "indent": 3,
      "text": "What is the best overall strategy for obtaining unguessable random numbers in the absence of a strong, reliable hardware entropy source? It is to obtain input from a number of uncorrelated sources and to mix them with a strong mixing function. Such a function will preserve the entropy present in any of the sources, even if other quantities being combined happen to be fixed or easily guessable (low entropy). This approach may be advisable even with a good hardware source, as hardware can also fail. However, this should be weighed against a possible increase in the chance of overall failure due to added software complexity.",
      "ja": "強く信頼性の高いハードウェアエントロピー源がない場合に、不燃性の乱数を得るための最高の全体的な戦略は何ですか？それはいくつかの無相関化されたソースからの入力を取得し、それらを強力な混合関数と混合することです。そのような関数は、組み合わされている他の量が固定されているかまたは容易に推測できるようになっていても、いずれのソースに存在するエントロピーを保持します（低エントロピー）。ハードウェアも故障する可能性があるので、このアプローチは、良好なハードウェアソースを使用しても推奨される可能性があります。ただし、ソフトウェアの複雑さが追加されたため、全体的な失敗の可能性が高くなる可能性があるため、これを秤量する必要があります。"
    },
    {
      "indent": 3,
      "text": "Once one has used good sources, such as some of those listed in Section 3, and mixed them as described in this section, one has a strong seed. This can then be used to produce large quantities of cryptographically strong material as described in Sections 6 and 7.",
      "ja": "セクション3に列挙されているものの一部のような良好な情報源を使用し、このセクションで説明されているように混合したのは、強い種を持っています。次いで、セクション6および7に記載されているように、大量の暗号的強い材料を製造するために使用することができる。"
    },
    {
      "indent": 3,
      "text": "A strong mixing function is one that combines inputs and produces an output in which each output bit is a different complex non-linear function of all the input bits. On average, changing any input bit will change about half the output bits. But because the relationship is complex and non-linear, no particular output bit is guaranteed to change when any particular input bit is changed.",
      "ja": "強力な混合関数は、入力を組み合わせて、各出力ビットがすべての入力ビットの異なる複素非線形関数である出力を生成するものです。平均して、入力ビットを変更すると、出力ビットの約半分が変わります。しかし、関係は複雑で非線形であるため、特定の入力ビットが変更されたときに特定の出力ビットは変更されません。"
    },
    {
      "indent": 3,
      "text": "Consider the problem of converting a stream of bits that is skewed towards 0 or 1 or which has a somewhat predictable pattern to a shorter stream which is more random, as discussed in Section 4. This is simply another case where a strong mixing function is desired, to mix the input bits and produce a smaller number of output bits. The technique given in Section 4.1, using the parity of a number of bits, is simply the result of successively XORing them. This is examined as a trivial mixing function, immediately below. Use of stronger mixing functions to extract more of the randomness in a stream of skewed bits is examined in Section 5.2. See also [NASLUND].",
      "ja": "0または1に向かってスキューされているビットのストリームを変換するか、またはセクション4で説明したように、よりランダムなストリームにやや予測可能なパターンを有する問題を考慮してください。、入力ビットを混合し、より少ない数の出力ビットを生成します。セクション4.1で与えられた技術は、ビット数のパリティを使用して、単にそれらを順次XORingの結果である。これは、直下の些細な混合機能として検討されています。スキューされたビットの流れでより多くのランダムさを抽出するためのより強い混合関数の使用をセクション5.2で調べる。[Naslund]も参照してください。"
    },
    {
      "indent": 0,
      "text": "5.1. A Trivial Mixing Function",
      "section_title": true,
      "ja": "5.1. よくある攪拌関数"
    },
    {
      "indent": 3,
      "text": "For expository purposes we describe a trivial example for single bit inputs using the Exclusive Or (XOR) function. This function is equivalent to addition without carry, as show in the table below. This is a degenerate case in which the one output bit always changes for a change in either input bit. But, despite its simplicity, it provides a useful illustration.",
      "ja": "説明のために、排他的論理和（XOR）関数を使用した単一ビット入力のための簡単な例を説明します。この関数は、下の表に示すようにキャリーなしの追加と同等です。これは、1つの出力ビットがどちらの入力ビットの変化に対して常に変更される縮退ケースです。しかし、その単純さにもかかわらず、それは便利なイラストを提供します。"
    },
    {
      "indent": 16,
      "text": "+-----------+-----------+----------+\n|  input 1  |  input 2  |  output  |\n+-----------+-----------+----------+\n|     0     |     0     |     0    |\n|     0     |     1     |     1    |\n|     1     |     0     |     1    |\n|     1     |     1     |     0    |\n+-----------+-----------+----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If inputs 1 and 2 are uncorrelated and combined in this fashion, then the output will be an even better (less skewed) random bit than the inputs are. If we assume an \"eccentricity\" E as defined in Section 4.1 above, then the output eccentricity relates to the input eccentricity as follows:",
      "ja": "入力1と2が無相関でこのように組み合わされている場合、出力は入力よりもさらに優れた（スキューされていない）ランダムビットになります。上記のセクション4.1で定義されているように「偏心」Eを仮定した場合、出力偏心は次のように入力偏心に関係します。"
    },
    {
      "indent": 8,
      "text": "E = 2 * E * E output input 1 input 2",
      "ja": "E = 2 * E * E output input 1 input "
    },
    {
      "indent": 3,
      "text": "Since E is never greater than 1/2, the eccentricity is always improved, except in the case in which at least one input is a totally skewed constant. This is illustrated in the following table, where the top and left side values are the two input eccentricities and the entries are the output eccentricity:",
      "ja": "Eは1/2以上ではないので、少なくとも1つの入力が全く歪んだ一定である場合を除いて、偏心は常に改善されます。これは次の表に示されています。ここで、上面と左側の値は2つの入力偏心率であり、エントリは出力偏心です。"
    },
    {
      "indent": 5,
      "text": "+--------+--------+--------+--------+--------+--------+--------+\n|    E   |  0.00  |  0.10  |  0.20  |  0.30  |  0.40  |  0.50  |\n+--------+--------+--------+--------+--------+--------+--------+\n|  0.00  |  0.00  |  0.00  |  0.00  |  0.00  |  0.00  |  0.00  |\n|  0.10  |  0.00  |  0.02  |  0.04  |  0.06  |  0.08  |  0.10  |\n|  0.20  |  0.00  |  0.04  |  0.08  |  0.12  |  0.16  |  0.20  |\n|  0.30  |  0.00  |  0.06  |  0.12  |  0.18  |  0.24  |  0.30  |\n|  0.40  |  0.00  |  0.08  |  0.16  |  0.24  |  0.32  |  0.40  |\n|  0.50  |  0.00  |  0.10  |  0.20  |  0.30  |  0.40  |  0.50  |\n+--------+--------+--------+--------+--------+--------+--------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " However, note that the above calculations assume that the inputs are not correlated. If the inputs were, say, the parity of the number of minutes from midnight on two clocks accurate to a few seconds, then each might appear random if sampled at random intervals much longer than a minute. Yet if they were both sampled and combined with XOR, the result would be zero most of the time.",
      "ja": "ただし、上記の計算は入力が相関していないと仮定していることに注意してください。入力が数秒から数秒までの2クロックでの午前中の分数のパリティが、1分以上のランダムな間隔でサンプリングされた場合、それぞれがランダムに表示されることがあります。それでも、それらがサンプリングされてXORと組み合わされた場合、その結果はほとんどの場合ゼロになります。"
    },
    {
      "indent": 0,
      "text": "5.2. Stronger Mixing Functions",
      "section_title": true,
      "ja": "5.2. より強い攪拌関数"
    },
    {
      "indent": 3,
      "text": "The US Government Advanced Encryption Standard [AES] is an example of a strong mixing function for multiple bit quantities. It takes up to 384 bits of input (128 bits of \"data\" and 256 bits of \"key\") and produces 128 bits of output, each of which is dependent on a complex non-linear function of all input bits. Other encryption functions with this characteristic, such as [DES], can also be used by considering them to mix all of their key and data input bits.",
      "ja": "米国政府高度な暗号化標準[AES]は、複数のビット数量に対する強力な混合関数の一例です。それは最大384ビットの入力（128ビットの \"データ\"および256ビットの \"キー\"）を必要とし、それぞれ128ビットの出力を生成し、それぞれがすべての入力ビットの複素非線形関数に依存します。[DES]などのこの特性を持つ他の暗号化関数も、それらのすべてのキーとデータ入力ビットを混在させることを考慮して使用することもできます。"
    },
    {
      "indent": 3,
      "text": "Another good family of mixing functions is the \"message digest\" or hashing functions such as the US Government Secure Hash Standards [SHA*] and the MD4, MD5 [MD4, MD5] series. These functions all take a practically unlimited amount of input and produce a relatively short fixed-length output mixing all the input bits. The MD* series produces 128 bits of output, SHA-1 produces 160 bits, and other SHA functions produce up to 512 bits.",
      "ja": "混合関数のもう1つの良いファミリーは、米国政府の安全なハッシュ標準[SHA *]、MD4、MD5 [MD5]シリーズなどの「メッセージダイジェスト」またはハッシュ機能です。これらの関数はすべて実質的に無制限の量の入力を取り、すべての入力ビットを混在させる比較的短い固定長出力を生成します。MD *シリーズは128ビットの出力を生成し、SHA-1は160ビットを生成し、他のSHA関数は最大512ビットを生成します。"
    },
    {
      "indent": 3,
      "text": "Although the message digest functions are designed for variable amounts of input, AES and other encryption functions can also be used to combine any number of inputs. If 128 bits of output is adequate, the inputs can be packed into a 128-bit data quantity and successive AES \"keys\", padding with zeros if needed; the quantity is then successively encrypted by the \"keys\" using AES in Electronic Codebook Mode. Alternatively, the input could be packed into one 128-bit key and multiple data blocks and a CBC-MAC could be calculated [MODES].",
      "ja": "メッセージダイジェスト関数は可変量の入力用に設計されていますが、AESやその他の暗号化機能を使用して任意の数の入力を組み合わせることもできます。128ビットの出力が適切であれば、入力を128ビットのデータ量と連続するAES \"キー\"に詰め込むことができ、必要に応じてゼロを搭載することができます。その後、電子コードブックモードでAESを使用して数量を「キー」で順次暗号化されます。あるいは、入力を1つの128ビットキーにパックすることができ、複数のデータブロックおよびCBC-MACを計算することができます[モード]。"
    },
    {
      "indent": 3,
      "text": "More complex mixing should be used if more than 128 bits of output are needed and one wants to employ AES (but note that it is absolutely impossible to get more bits of \"randomness\" out than are put in). For example, suppose that inputs are packed into three quantities, A, B, and C. One may use AES to encrypt A with B and then with C as keys to produce the first part of the output, then encrypt B with C and then A for more output and, if necessary, encrypt C with A and then B for yet more output. Still more output can be produced by reversing the order of the keys given above. The same can be done with the hash functions, hashing various subsets of the input data or different copies of the input data with different prefixes and/or suffixes to produce multiple outputs.",
      "ja": "128ビット以上の出力が必要な場合は、より複雑なミキシングを使用する必要があります。たとえば、入力が3つの量、A、B、およびCにパックされているとすると、AESを使用してBを使用し、次いでCをキーとして暗号化して出力の最初の部分を生成し、次にCをCで暗号化してAを出力し、必要に応じて、さらにBでCを暗号化するためにCを暗号化します。上記のキーの順序を反転させることによって、さらに出力を作成することができる。ハッシュ関数を用いても同じことができ、入力データの様々なサブセットまたは入力データの異なるコピーを異なる接頭辞および/または接尾辞を用いて複数の出力を形成することができる。"
    },
    {
      "indent": 3,
      "text": "For an example of using a strong mixing function, reconsider the case of a string of 308 bits, each of which is biased 99% toward zero. The parity technique given in Section 4.1 reduces this to one bit, with only a 1/1000 deviance from being equally likely a zero or one. But, applying the equation for information given in Section 2, this",
      "ja": "強力な混合関数を使用する例については、308ビットのストリングの場合を再検討し、その各々はゼロに向かって99％バイアスされています。セクション4.1に示されているパリティ技法は、これを1ビットに減らし、1/1000の逸脱はゼロまたは1の偏差だけであります。しかし、セクション2で与えられた情報のための方程式を適用します。"
    },
    {
      "indent": 3,
      "text": "308-bit skewed sequence contains over 5 bits of information. Thus, hashing it with SHA-1 and taking the bottom 5 bits of the result would yield 5 unbiased random bits and not the single bit given by calculating the parity of the string. Alternatively, for some applications, you could use the entire hash output to retain almost all of the 5+ bits of entropy in a 160-bit quantity.",
      "ja": "308ビットスキューシーケンスには5ビット以上の情報が含まれています。したがって、SHA-1とそれをハッシュし、結果の底部5ビットを取得すると、5ビットが5つの不偏ランダムビットが得られ、文字列のパリティを計算することによって与えられた単一ビットではありません。あるいは、いくつかのアプリケーションでは、ハッシュ出力全体を使用して、160ビットのエントロピーの5ビットのエントロピーのほぼ全部を保持することができます。"
    },
    {
      "indent": 0,
      "text": "5.3. Using S-Boxes for Mixing",
      "section_title": true,
      "ja": "5.3. 攪拌のためにSボックスを使用する"
    },
    {
      "indent": 3,
      "text": "Many modern block encryption functions, including DES and AES, incorporate modules known as S-Boxes (substitution boxes). These produce a smaller number of outputs from a larger number of inputs through a complex non-linear mixing function that has the effect of concentrating limited entropy from the inputs into the output.",
      "ja": "DESとAESを含む多くの最新のブロック暗号化機能、Sボックス（置換ボックス）として知られるモジュールを組み込んでいます。これらは、制限されたエントロピーを入力から出力に集中させる効果を有する複雑な非線形混合関数を介して、より少ない数の出力から小数の出力を生成します。"
    },
    {
      "indent": 3,
      "text": "S-Boxes sometimes incorporate bent Boolean functions (functions of an even number of bits producing one output bit with maximum non-linearity). Looking at the output for all input pairs differing in any particular bit position, exactly half the outputs are different. An S-Box in which each output bit is produced by a bent function such that any linear combination of these functions is also a bent function is called a \"perfect S-Box\".",
      "ja": "Sボックスには、BENBENブール関数を組み込んだ（偶数ビット数の関数を最大限の非線形性を持つ1つの出力ビットを生成）。特定のビット位置が異なるすべての入力ペアの出力を見て、出力の半分半分は異なります。これらの機能の線形組み合わせも曲がった機能であるように、各出力ビットが曲がった機能によって生成されるSボックスは、「完璧なSボックス」と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "S-boxes and various repeated applications or cascades of such boxes can be used for mixing [SBOX1, SBOX2].",
      "ja": "このような箱のSボックスや様々な繰り返しのアプリケーションやカスケードを使用して[SBOX1、SBOX2]を混合することができます。"
    },
    {
      "indent": 0,
      "text": "5.4. Diffie-Hellman as a Mixing Function",
      "section_title": true,
      "ja": "5.4. 攪拌関数としてのDiffie-Hellman"
    },
    {
      "indent": 3,
      "text": "Diffie-Hellman exponential key exchange is a technique that yields a shared secret between two parties. It can be computationally infeasible for a third party to determine this secret even if they can observe all the messages between the two communicating parties. This shared secret is a mixture of initial quantities generated by each of the parties [D-H].",
      "ja": "Diffie-Hellman指数関数交換は、2人の締約国間の共有秘密を生じる技術です。2つの通信当事者間のすべてのメッセージを観察できる場合でも、この秘密を判断することは、この秘密を判断できるようにすることができます。この共有秘密は、各締約国によって生成された初期量の混合物[D-H]です。"
    },
    {
      "indent": 3,
      "text": "If these initial quantities are random and uncorrelated, then the shared secret combines their entropy but, of course, can not produce more randomness than the size of the shared secret generated.",
      "ja": "これらの初期量がランダムで無相関である場合、共有秘密はエントロピーを組み合わせるが、もちろん、生成された共有秘密のサイズよりもランダム性を生じさせることはできません。"
    },
    {
      "indent": 3,
      "text": "Although this is true if the Diffie-Hellman computation is performed privately, an adversary who can observe either of the public keys and knows the modulus being used need only search through the space of the other secret key in order to be able to calculate the shared secret [D-H]. So, conservatively, it would be best to consider public Diffie-Hellman to produce a quantity whose guessability corresponds to the worse of the two inputs. Because of this and the fact that Diffie-Hellman is computationally intensive, its use as a mixing function is not recommended.",
      "ja": "Diffie-Hellmanの計算が個人的に行われた場合、公開鍵のいずれかを観察し、使用されているモジュラスを知っている敵対者は、共有を計算できるようにするために他の秘密鍵のスペースを検索するだけである。秘密[DH]。それで、保守的には、推測性が2つの入力の悪化に対応する量を生み出すために、公的なDiffie-Hellmanを考慮することが最善でしょう。このため、Diffie-Hellmanが計算的に集約されているという事実は、ミキシング機能としての使用はお勧めできません。"
    },
    {
      "indent": 0,
      "text": "5.5. Using a Mixing Function to Stretch Random Bits",
      "section_title": true,
      "ja": "5.5. ランダムビットを伸長するために攪拌関数を使用する"
    },
    {
      "indent": 3,
      "text": "Although it is not necessary for a mixing function to produce the same or fewer output bits than its inputs, mixing bits cannot \"stretch\" the amount of random unpredictability present in the inputs. Thus, four inputs of 32 bits each, in which there are 12 bits worth of unpredictability (such as 4,096 equally probable values) in each input, cannot produce more than 48 bits worth of unpredictable output. The output can be expanded to hundreds or thousands of bits by, for example, mixing with successive integers, but the clever adversary's search space is still 2^48 possibilities. Furthermore, mixing to fewer bits than are input will tend to strengthen the randomness of the output.",
      "ja": "混合関数がその入力よりも同じまたは少ない出力ビットを生成する必要はないが、ミキシングビットは入力に存在するランダムな予測不能性の量を「ストレッチ」することはできない。したがって、それぞれ4つの入力には4つの入力（4,096等が等しく考えられる値など）が各入力で、48ビット以上の予測不可能な出力を生成することはできません。出力は、例えば、連続した整数との混合によって、数百または数千のビットに拡張することができますが、賢い敵の検索スペースはまだ2 ^ 48の可能性です。さらに、入力よりも少ないビットとの混合は、出力のランダム性を強化する傾向があります。"
    },
    {
      "indent": 3,
      "text": "The last table in Section 5.1 shows that mixing a random bit with a constant bit with Exclusive Or will produce a random bit. While this is true, it does not provide a way to \"stretch\" one random bit into more than one. If, for example, a random bit is mixed with a 0 and then with a 1, this produces a two bit sequence but it will always be either 01 or 10. Since there are only two possible values, there is still only the one bit of original randomness.",
      "ja": "セクション5.1の最後の表は、ランダムビットを排他的またはランダムビットを生成することでランダムビットを混合することを示しています。これは当てはまりますが、1つのランダムビットを複数に \"String\"する方法はありません。たとえば、ランダムビットが0と0で混合されている場合、これは2ビットのシーケンスを生成しますが、01または10のいずれかになります。オリジナルのランダム性の。"
    },
    {
      "indent": 0,
      "text": "5.6. Other Factors in Choosing a Mixing Function",
      "section_title": true,
      "ja": "5.6. 攪拌関数を選択する際のその他の要素"
    },
    {
      "indent": 3,
      "text": "For local use, AES has the advantages that it has been widely tested for flaws, is reasonably efficient in software, and is widely documented and implemented with hardware and software implementations available all over the world including open source code. The SHA* family have had a little less study and tend to require more CPU cycles than AES but there is no reason to believe they are flawed. Both SHA* and MD5 were derived from the earlier MD4 algorithm. They all have source code available [SHA*, MD4, MD5]. Some signs of weakness have been found in MD4 and MD5. In particular, MD4 has only three rounds and there are several independent breaks of the first two or last two rounds. And some collisions have been found in MD5 output.",
      "ja": "地元の使用のために、AESは、それが欠陥について広くテストされてきたという利点を持ち、オープンソースコードを含む世界中のハードウェアおよびソフトウェアの実装で広く文書化され実装されています。SHA *家族は少し少ない研究を受けており、AESよりも多くのCPUサイクルを必要とする傾向がありますが、それらが欠陥があると信じる理由はありません。SHA *とMD5の両方が以前のMD4アルゴリズムから導き出された。それらはすべて、利用可能なソースコードがあります[SHA *、MD4、MD5]。弱さの兆候はMD4とMD5に見られました。特に、MD4は3ラウンドしかありません、最初の2つまたは最後の2ラウンドのいくつかの独立した休憩があります。また、MD5出力には衝突が見つかりました。"
    },
    {
      "indent": 3,
      "text": "AES was selected by a robust, public, and international process. It and SHA* have been vouched for by the US National Security Agency (NSA) on the basis of criteria that mostly remain secret, as was DES. While this has been the cause of much speculation and doubt, investigation of DES over the years has indicated that NSA involvement in modifications to its design, which originated with IBM, was primarily to strengthen it. There has been no announcement of a concealed or special weakness being found in DES. It is likely that the NSA modifications to MD4 to produce the SHA algorithms similarly strengthened these algorithms, possibly against threats not yet known in the public cryptographic community.",
      "ja": "AESは、堅牢で一般、そして国際的なプロセスによって選択されました。それとSha *は、ほとんど秘密のままである基準に基づいて、米国国家安全保障庁（NSA）が救済されています。これは多くの投機と疑いの原因であるが、何年も経過すると、IBMに由来するその設計への修正へのNSAの関与は主にそれを強化することを示した。DESで見つかる隠されたまたは特別な弱さの発表はありませんでした。SHAアルゴリズムを生成するためのMD4へのNSA修正は、おそらく公衆暗号化コミュニティにおいてまだ知られていない脅威に対しても同様に強化する可能性が高い。"
    },
    {
      "indent": 3,
      "text": "Where input lengths are unpredictable, hash algorithms are more convenient to use than block encryption algorithms since they are generally designed to accept variable length inputs. Block encryption algorithms generally require an additional padding algorithm to accommodate inputs that are not an even multiple of the block size.",
      "ja": "入力長が予測不可能である場合、ハッシュアルゴリズムは、一般に可変長入力を受け入れるように設計されているため、ブロック暗号化アルゴリズムよりも使用が便利です。ブロック暗号化アルゴリズムでは、一般に、ブロックサイズの偶数倍ではない入力に対応するための追加のパディングアルゴリズムが必要です。"
    },
    {
      "indent": 3,
      "text": "As of the time of this document, the authors know of no patent claims to the basic AES, DES, SHA*, MD4, and MD5 algorithms other than patents for which an irrevocable royalty free license has been granted to the world. There may, of course, be essential patents of which the authors are unaware or patents on implementations or uses or other relevant patents issued or to be issued.",
      "ja": "この文書の時点の時点で、著者は、取消不能なロイヤリティフリーライセンスが世界に付与されている特許以外の基本的なAES、DES、SHA *、MD4、およびMD5アルゴリズムを認識していません。もちろん、著者らは、実装または使用または発行された他の関連特許に関する認識または特許であるか、または特許の本質的な特許であるかもしれません。"
    },
    {
      "indent": 0,
      "text": "6. Pseudo-random Number Generators",
      "section_title": true,
      "ja": "6. 擬似乱数生成器"
    },
    {
      "indent": 3,
      "text": "When a seed has sufficient entropy, from input as described in Section 3 and possibly de-skewed and mixed as described in Sections 4 and 5, one can algorithmically extend that seed to produce a large number of cryptographically-strong random quantities. Such algorithms are platform independent and can operate in the same fashion on any computer. For the algorithms to be secure, their input and internal workings must be protected from adversarial observation.",
      "ja": "セクション3および5に記載されているように、シードが十分なエントロピーを、セクション4および5に記載されているように歪んで混合された場合、そのシードをアルゴリズム的に拡張して、多数の暗号的に強いランダムな量を生成することができる。そのようなアルゴリズムはプラットフォームに依存しないため、どのコンピュータでも同じ方法で動作できます。アルゴリズムが安全であるためには、それらの入力と内部の作業は敵対的な観察から保護されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The design of such pseudo-random number generation algorithms, like the design of symmetric encryption algorithms, is not a task for amateurs. Section 6.1 below lists a number of bad ideas that failed algorithms have used. To learn what works, skip Section 6.1 and just read the remainder of this section and Section 7, which describes and references some standard pseudo random number generation algorithms. See Section 7 and Part 3 of [X9.82].",
      "ja": "対称暗号化アルゴリズムの設計と同様に、そのような疑似乱数生成アルゴリズムの設計は、アマチュアのタスクではありません。以下のセクション6.1に、障害が発生したアルゴリズムが使用された数の不正なアイデアを示します。どのような機能を学び、セクション6.1をスキップし、このセクションの残りの部分とセクション7を読んでください。[x9.82]のセクション7とパート3を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.1. Some Bad Ideas",
      "section_title": true,
      "ja": "6.1. 悪いアイデア"
    },
    {
      "indent": 3,
      "text": "The subsections below describe a number of ideas that might seem reasonable but that lead to insecure pseudo-random number generation.",
      "ja": "以降の節では、一見合理的に見えるかもしれないが、それが不安な擬似乱数生成につながるかもしれない多くのアイデアを説明しています。"
    },
    {
      "indent": 0,
      "text": "6.1.1. The Fallacy of Complex Manipulation",
      "section_title": true,
      "ja": "6.1.1. 複雑な操作の誤り"
    },
    {
      "indent": 0,
      "text": " One approach that may give a misleading appearance of unpredictability is to take a very complex algorithm (or an excellent traditional pseudo-random number generator with good statistical properties) and to calculate a cryptographic key by starting with limited data such as the computer system clock value as the seed. Adversaries who knew roughly when the generator was started would have a relatively small number of seed values to test, as they would know likely values of the system clock. Large numbers of pseudo- random bits could be generated, but the search space that an adversary would need to check could be quite small.",
      "ja": "予測不可能性の誤解を招く可能性のある外観を与える可能性がある1つのアプローチは、非常に複雑なアルゴリズム（または優れた統計的プロパティを持つ優れた従来の疑似乱数発生器）を取り、コンピュータシステムクロック値などの制限されたデータを開始することによって暗号鍵を計算することです。種として。生成器が開始されたときにおおよそ知っていた敵対者は、システムクロックの値の可能性が高いことを知っているので、テストするシード値の数が比較的少数であろう。多数の擬似ランダムビットを生成することができますが、敵対者がチェックする必要がある検索スペースはかなり小さいかもしれません。"
    },
    {
      "indent": 3,
      "text": "Thus, very strong or complex manipulation of data will not help if the adversary can learn what the manipulation is and if there is not enough entropy in the starting seed value. They can usually use the limited number of results stemming from a limited number of seed values to defeat security.",
      "ja": "したがって、敵対者が操作が何であるか、および開始シード値に十分なエントロピーがない場合には、データの非常に強いまたは複雑な操作が役立ちません。それらは通常、限られた数のシード値からの限られた数の結果を使用してセキュリティを軽減することができます。"
    },
    {
      "indent": 3,
      "text": "Another serious strategic error is to assume that a very complex pseudo-random number generation algorithm will produce strong random numbers, when there has been no theory behind or analysis of the algorithm. There is a excellent example of this fallacy near the beginning of Chapter 3 in [KNUTH], where the author describes a complex algorithm. It was intended that the machine language program corresponding to the algorithm would be so complicated that a person trying to read the code without comments wouldn't know what the program was doing. Unfortunately, actual use of this algorithm showed that it almost immediately converged to a single repeated value in one case and a small cycle of values in another case.",
      "ja": "もう1つの重大な戦略的エラーは、アルゴリズムの背後にある理論や分析がない場合、非常に複雑な擬似乱数生成アルゴリズムが強い乱数を生成すると仮定することです。この誤謬の優れた例が、「Knuth」の最初の初めに近い例があります。ここで、著者は複雑なアルゴリズムを説明しています。このアルゴリズムに対応する機械語プログラムは、コメントなしでコードを読みようとしている人がプログラムが何をしていたのかわからないことを理解することが意図されていました。残念ながら、このアルゴリズムの実際の使用は、1つのケースで1つの繰り返し値と別の場合には小さいサイクルの値にほぼ直ちに収束することを示しました。"
    },
    {
      "indent": 3,
      "text": "Not only does complex manipulation not help you if you have a limited range of seeds, but blindly-chosen complex manipulation can destroy the entropy in a good seed!",
      "ja": "あなたが限られた範囲の種を持っているが、盲目的に選択された複雑な操作は、良い種子でエントロピーを破壊することができるならば、複雑な操作はあなたを助けるだけではないだけではない。"
    },
    {
      "indent": 0,
      "text": "6.1.2. The Fallacy of Selection from a Large Database",
      "section_title": true,
      "ja": "6.1.2. 大規模データベースからの選択の誤り"
    },
    {
      "indent": 3,
      "text": "Another approach that can give a misleading appearance of unpredictability is to randomly select a quantity from a database and to assume that its strength is related to the total number of bits in the database. For example, typical USENET servers process many megabytes of information per day [USENET_1, USENET_2]. Assume that a random quantity was selected by fetching 32 bytes of data from a random starting point in this data. This does not yield 32*8 = 256 bits worth of unguessability. Even if much of the data is human language that contains no more than 2 or 3 bits of information per byte, it doesn't yield 32*2 = 64 bits of unguessability. For an adversary with access to the same Usenet database, the unguessability rests only on the starting point of the selection. That is perhaps a little over a couple of dozen bits of unguessability.",
      "ja": "予測不可能性の誤解を招く可能性を与えることができるもう1つの方法は、データベースから数量をランダムに選択し、その強さがデータベース内のビットの総数に関連していると仮定することです。たとえば、典型的なUSENETサーバーは、1日あたりの多くのメガバイトの情報をプロセスします[USENET_1、USENET_2]。このデータのランダムな開始点から32バイトのデータを取得することによってランダムな数量が選択されたとする。これは、32 * 8 = 256ビット価値のない不履行性をもたらさない。データの大部分が1バイト当たり2または3ビット以下の情報を含む人類言語であっても、不合格性の32 * 2 = 64ビットではありません。同じUSENETデータベースへのアクセスを持つ敵対者の場合、不正な性別は選択の開始点でのみ依頼します。それはおそらく数十二十分の不気味なビットにわたって少しずつです。"
    },
    {
      "indent": 3,
      "text": "The same argument applies to selecting sequences from the data on a publicly available CD/DVD recording or any other large public database. If the adversary has access to the same database, this \"selection from a large volume of data\" step buys little. However, if a selection can be made from data to which the adversary has no access, such as system buffers on an active multi-user system, it may be of help.",
      "ja": "同じ引数は、公的に利用可能なCD / DVD記録またはその他の大規模な公開データベース上のデータからのシーケンスの選択に適用されます。敵対者が同じデータベースにアクセスできる場合は、この「大量のデータからの選択」ステップが少し購入します。しかしながら、敵対的マルチユーザシステム上のシステムバッファのような逆境がないデータから選択が行われた場合、それは助けのものであり得る。"
    },
    {
      "indent": 0,
      "text": "6.1.3. Traditional Pseudo-random Sequences",
      "section_title": true,
      "ja": "6.1.3. 伝統的な疑似乱数列"
    },
    {
      "indent": 3,
      "text": "This section talks about traditional sources of deterministic or \"pseudo-random\" numbers. These typically start with a \"seed\" quantity and use simple numeric or logical operations to produce a sequence of values. Note that none of the techniques discussed in this section is suitable for cryptographic use. They are presented for general information.",
      "ja": "このセクションでは、伝統的な決定論的または「疑似ランダム」数の源について説明します。これらは通常、「シード」の量で始まり、単純な数値または論理演算を使用して一連の値を生成します。このセクションで説明されているテクニックのどれも暗号化の使用に適していません。それらは一般的な情報のために提示されています。"
    },
    {
      "indent": 3,
      "text": "[KNUTH] has a classic exposition on pseudo-random numbers. Applications he mentions are simulations of natural phenomena, sampling, numerical analysis, testing computer programs, decision making, and games. None of these have the same characteristics as the sorts of security uses we are talking about. Only in the last two could there be an adversary trying to find the random quantity. However, in these cases, the adversary normally has only a single chance to use a guessed value. In guessing passwords or attempting to break an encryption scheme, the adversary normally has many, perhaps unlimited, chances at guessing the correct value. Sometimes the adversary can store the message to be broken and repeatedly attack it. Adversaries are also be assumed to be aided by a computer.",
      "ja": "[Knuth]は擬似乱数に古典的な博覧会を持っています。適用彼は、自然現象、サンプリング、数値解析、テストコンピュータプログラム、意思決定、およびゲームのシミュレーションです。これらのどれも、私たちが話しているセキュリティの種類と同じ特性を持っていません。最後の2つだけでは、ランダムな量を見つけようとしている敵対的なものがある可能性があります。しかし、これらの場合、敵対者は通常、推測値を使用する機会が1つだけです。パスワードを推測するか暗号化方式を破ることを試みると、敵対者は正しい値を推測することで、通常、多くの人、おそらく無制限です。時々敵対者は壊れて繰り返し攻撃するようにメッセージを保存することができます。敵対者はまた、コンピュータによって支援されると仮定されています。"
    },
    {
      "indent": 3,
      "text": "For testing the \"randomness\" of numbers, Knuth suggests a variety of measures, including statistical and spectral. These tests check things like autocorrelation between different parts of a \"random\" sequence or distribution of its values. But these tests could be met by a constant stored random sequence, such as the \"random\" sequence printed in the CRC Standard Mathematical Tables [CRC]. Despite meeting all the tests suggested by Knuth, that sequence is unsuitable for cryptographic us, as adversaries must be assumed to have copies of all commonly published \"random\" sequences and to be able to spot the source and predict future values.",
      "ja": "数字の「ランダム性」をテストするために、ノードは統計的およびスペクトルを含むさまざまな尺度を示唆しています。これらのテストは、「ランダムな」シーケンスの異なる部分またはその値の分布の間の自己相関のようなものをチェックします。しかし、これらのテストは、CRC標準の数学表[CRC]で印刷された「ランダム」シーケンスのような一定の格納されたランダムシーケンスによって満たすことができます。ノースで提案されたすべてのテストを満たすにもかかわらず、そのシーケンスは暗号化米国には不適切であるため、敵対者は一般に公開されたすべての「ランダムな「ランダムな」シーケンスのコピーを持ち、将来の値を予測できるようにする必要があるためです。"
    },
    {
      "indent": 3,
      "text": "A typical pseudo-random number generation technique is the linear congruence pseudo-random number generator. This technique uses modular arithmetic, where the value numbered N+1 is calculated from the value numbered N by",
      "ja": "典型的な擬似乱数生成技術は線形合同擬似乱数発生器である。この技術はモジュール式算術演算を使用しています。ここで、n 1が番号が付けられた値から数字が付けられた値から計算されます。"
    },
    {
      "indent": 8,
      "text": "V    = ( V  * a + b )(Mod c)\n N+1      N",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The above technique has a strong relationship to linear shift register pseudo-random number generators, which are well understood cryptographically [SHIFT*]. In such generators, bits are introduced at one end of a shift register as the Exclusive Or (binary sum without carry) of bits from selected fixed taps into the register. For example, consider the following:",
      "ja": "上記の技術は線形シフトレジスタ擬似乱数発生器との強い関係を有し、これは暗号的に理解されている[Shift *]。そのような生成器では、選択された固定タップからレジスタへのビットの排他的論理和または（キャリーなし）ビットの一端にビットが導入される。たとえば、次の点を考慮してください。"
    },
    {
      "indent": 6,
      "text": "+----+     +----+     +----+                      +----+\n| B  | <-- | B  | <-- | B  | <--  . . . . . . <-- | B  | <-+\n|  0 |     |  1 |     |  2 |                      |  n |   |\n+----+     +----+     +----+                      +----+   |\n  |                     |            |                     |\n  |                     |            V                  +-----+\n  |                     V            +----------------> |     |\n  V                     +-----------------------------> | XOR |\n  +---------------------------------------------------> |     |\n                                                        +-----+",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "V    = ( ( V  * 2 ) + B  XOR  B ... )(Mod 2^n)\n N+1         N         0       2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The quality of traditional pseudo-random number generator algorithms is measured by statistical tests on such sequences. Carefully-chosen values a, b, c, and initial V or carefully-chosen placement of the shift register tap in the above simple process can produce excellent statistics.",
      "ja": "従来の擬似乱数発生器アルゴリズムの品質は、そのようなシーケンス上の統計的検定によって測定されます。上記の簡単なプロセスにおけるシフトレジスタタップの慎重に選択された値A、B、C、および初期vまたは慎重に選択された配置は、優れた統計を生み出すことができる。"
    },
    {
      "indent": 3,
      "text": "These sequences may be adequate in simulations (Monte Carlo experiments) as long as the sequence is orthogonal to the structure of the space being explored. Even there, subtle patterns may cause problems. However, such sequences are clearly bad for use in security applications. They are fully predictable if the initial state is known. Depending on the form of the pseudo-random number generator, the sequence may be determinable from observation of a short portion of the sequence [SCHNEIER, STERN]. For example, with the generators above, one can determine V(n+1) given knowledge of V(n). In fact, it has been shown that with these techniques, even if only one bit of the pseudo-random values are released, the seed can be determined from short sequences.",
      "ja": "これらの配列は、シーケンスが調べられている空間の構造と直交している限り、シミュレーション（モンテカルロ実験）において適切であり得る。そこでも、微妙なパターンが問題を引き起こす可能性があります。しかしながら、そのようなシーケンスは、セキュリティアプリケーションでの使用には明らかに悪い。初期状態がわかっている場合、それらは完全に予測可能です。擬似乱数発生器の形態に応じて、シーケンスの短い部分[シュナエ、シュンテル]の観察から決定可能であり得る。例えば、上記の生成器では、V（n）の知識が与えられたV（n 1）を決定することができる。実際、これらの技術では、1ビットの疑似ランダム値のみが解放されていても、シードを短いシーケンスから決定することができることが示されている。"
    },
    {
      "indent": 3,
      "text": "Not only have linear congruent generators been broken, but techniques are now known for breaking all polynomial congruent generators [KRAWCZYK].",
      "ja": "線形一致生成器が壊れているだけでなく、すべての多項式合同生成器[Krawczyk]を破るために技術が知られています。"
    },
    {
      "indent": 0,
      "text": "6.2. Cryptographically Strong Sequences",
      "section_title": true,
      "ja": "6.2. 暗号的に強いシーケンス"
    },
    {
      "indent": 3,
      "text": "In cases where a series of random quantities must be generated, an adversary may learn some values in the sequence. In general, adversaries should not be able to predict other values from the ones that they know.",
      "ja": "一連のランダムな量を生成しなければならない場合、敵対者はシーケンス内のいくつかの値を学ぶことができます。一般に、敵対者は彼らが知っているものから他の値を予測することができないはずです。"
    },
    {
      "indent": 0,
      "text": " The correct technique is to start with a strong random seed, to take cryptographically strong steps from that seed [FERGUSON, SCHNEIER], and not to reveal the complete state of the generator in the sequence elements. If each value in the sequence can be calculated in a fixed way from the previous value, then when any value is compromised, all future values can be determined. This would be the case, for example, if each value were a constant function of the previously used values, even if the function were a very strong, non-invertible message digest function.",
      "ja": "正しいテクニックは、その種のシード[ファーガソン、シュナリエ]から暗号的に強いステップをとるために、強いランダムなシードから始めることであり、シーケンス要素内の生成器の完全な状態を明らかにすることではありません。シーケンス内の各値を前の値から固定された方法で計算できる場合は、任意の値が損なわれると、すべての将来の値を決定できます。これは、例えば、関数が非常に強い非可逆的なメッセージダイジェスト関数であっても、各値が以前に使用された値の一定関数である場合であろう。"
    },
    {
      "indent": 3,
      "text": "(Note that if a technique for generating a sequence of key values is fast enough, it can trivially be used as the basis for a confidentiality system. If two parties use the same sequence generation technique and start with the same seed material, they will generate identical sequences. These could, for example, be XOR'ed at one end with data being sent to encrypt it, and XOR'ed with this data as received to decrypt it, due to the reversible properties of the XOR operation. This is commonly referred to as a simple stream cipher.)",
      "ja": "（一連のキー値を生成するための技術が十分に速い場合、機密性システムの基礎として緊密に使用することができる。2人の締約国が同じシーケンス生成技術を使用して同じシード素材で始まる場合、それらは生成されます同一のシーケンス。これらは、例えば、データを暗号化するために送信されているデータを一端でXor処理し、XOR操作の可逆的なプロパティのために復号化されたようにこのデータを復号することができる。これは一般的に単純なストリーム暗号と呼ばれます。）"
    },
    {
      "indent": 0,
      "text": "6.2.1. OFB and CTR Sequences",
      "section_title": true,
      "ja": "6.2.1. OFBおよびCTRのシーケンス"
    },
    {
      "indent": 3,
      "text": "One way to produce a strong sequence is to take a seed value and hash the quantities produced by concatenating the seed with successive integers, or the like, and then to mask the values obtained so as to limit the amount of generator state available to the adversary.",
      "ja": "強いシーケンスを生成する1つの方法は、シード値をとり、シードを連続した整数または整数を含む量を連結してから生成された量をハッシュし、次いで敵対者に利用可能な発生器状態の量を制限するために得られた値をマスクすることである。。"
    },
    {
      "indent": 3,
      "text": "It may also be possible to use an \"encryption\" algorithm with a random key and seed value to encrypt successive integers, as in counter (CTR) mode encryption. Alternatively, one can feedback all of the output value from encryption into the value to be encrypted for the next iteration. This is a particular example of output feedback mode (OFB) [MODES].",
      "ja": "カウンタ（CTR）モード暗号化のように、連続する整数を暗号化するために、ランダムキーとシード値を使用して「暗号化」アルゴリズムを使用することも可能であり得る。あるいは、暗号化からのすべての出力値を次の反復のために暗号化される値にフィードバックすることができます。これは出力フィードバックモード（OFB）[モード]の特定の例です。"
    },
    {
      "indent": 3,
      "text": "An example is shown below in which shifting and masking are used to combine part of the output feedback with part of the old input. This type of partial feedback should be avoided for reasons described below.",
      "ja": "次に、出力フィードバックの一部を古い入力の一部と組み合わせるためにシフトとマスキングを使用する例を示します。以下に説明する理由で、このタイプの部分フィードバックを回避する必要があります。"
    },
    {
      "indent": 12,
      "text": "+---------------+\n|       V       |\n|  |     n      |--+\n+--+------------+  |\n      |            |     +---------+\n shift|            +---> |         |      +-----+\n   +--+                  | Encrypt | <--- | Key |\n   |           +-------- |         |      +-----+\n   |           |         +---------+\n   V           V\n+------------+--+\n|      V     |  |\n|       n+1     |\n+---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that if a shift of one is used, this is the same as the shift register technique described in Section 6.1.3, but with the all-important difference that the feedback is determined by a complex non-linear function of all bits rather than by a simple linear or polynomial combination of output from a few bit position taps.",
      "ja": "1つのシフトが使用されている場合、これはセクション6.1.3で説明されているシフトレジスタの技法と同じですが、フィードバックはすべてのビットの複雑な非線形関数によって決まることをすべての重要な差ではありません。数ビット位置タップからの出力の単純な線形または多項式の組み合わせによって。"
    },
    {
      "indent": 3,
      "text": "Donald W. Davies showed that this sort of shifted partial output feedback significantly weakens an algorithm, compared to feeding all the output bits back as input. In particular, for DES, repeatedly encrypting a full 64-bit quantity will give an expected repeat in about 2^63 iterations. Feeding back anything less than 64 (and more than 0) bits will give an expected repeat in between 2^31 and 2^32 iterations!",
      "ja": "Donald W. Daviesは、このようなシフトされた部分出力フィードバックは、すべての出力ビットを入力として送ることと比較して、アルゴリズムを大幅に弱くすることを示しました。特に、DESの場合、完全な64ビット数量を繰り返し暗号化すると、約2 ^ 63反復で予想される繰り返しが得られます。フィードバック64（および0以上のビット）よりも小さいものは、2 ^ 31と2 ^ 32反復の間で予想される繰り返しを与えます！"
    },
    {
      "indent": 3,
      "text": "To predict values of a sequence from others when the sequence was generated by these techniques is equivalent to breaking the cryptosystem or to inverting the \"non-invertible\" hashing with only partial information available. The less information revealed in each iteration, the harder it will be for an adversary to predict the sequence. Thus it is best to use only one bit from each value. It has been shown that in some cases this makes it impossible to break a system even when the cryptographic system is invertible and could be broken if all of each generated value were revealed.",
      "ja": "これらの技術によってシーケンスが生成されたときに他のものからの順序の値を予測することは、暗号システムを破ること、または利用可能な部分情報のみを用いて「非可逆的」ハッシュを反転することと等価である。各反復で明らかにされた情報が少ないほど、それが順序を予測することが困難になるでしょう。したがって、各値から1ビットしか使用できません。場合によっては、暗号システムが可逆的であってもシステムを破ることが不可能であり、それぞれの生成された値の全てが明らかにされた場合に壊れる可能性があることがあることが示されている。"
    },
    {
      "indent": 0,
      "text": "6.2.2. The Blum Blum Shub Sequence Generator",
      "section_title": true,
      "ja": "6.2.2. Blum Blum Shubシーケンス生成器"
    },
    {
      "indent": 3,
      "text": "Currently the generator which has the strongest public proof of strength is called the Blum Blum Shub generator, named after its inventors [BBS]. It is also very simple and is based on quadratic residues. Its only disadvantage is that it is computationally intensive compared to the traditional techniques given in Section 6.1.3. This is not a major drawback if it is used for moderately-infrequent purposes, such as generating session keys.",
      "ja": "現在、最も強力な強さの証明を持つ生成器は、その発明者らのINSTROVERS [BBS]に命名されたBlum Blum Shub Generatorと呼ばれています。それはまた非常に単純でありそして二次残基に基づいている。その唯一の欠点は、6.1.3項に記載されている従来の技術と比較して計算的に集中的であることです。セッションキーの生成など、中程度のまれな目的に使用されている場合、これは大きな欠点ではありません。"
    },
    {
      "indent": 3,
      "text": "Simply choose two large prime numbers (say, p and q) that each gives a remainder of 3 when divided by 4. Let n = p * q. Then choose a random number, x, that is relatively prime to n. The initial seed for the generator and the method for calculating subsequent values are then:",
      "ja": "それぞれが4で割ったときに3つの残りの部分を与える2つの大きな素数（PとQ）を選択してください。次に、乱数x、つまりnを選択します。ジェネレータの初期シードと後続の値を計算するためのメソッドは次のとおりです。"
    },
    {
      "indent": 9,
      "text": "           2\ns    =  ( x  )(Mod n)\n 0\n           2\ns    = ( s   )(Mod n)\n i+1      i",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Be careful to use only a few bits from the bottom of each s. It is always safe to use only the lowest-order bit. If one uses no more than the:",
      "ja": "各Sの下から数ビットしか使用できません。最下位のビットのみを使用するのは常に安全です。次のもの以下が使用されていない場合"
    },
    {
      "indent": 9,
      "text": "log_2(log_2(s_i))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "low-order bits, then predicting any additional bits from a sequence generated in this manner is provably as hard as factoring n. As long as the initial x is secret, n can be made public if desired.",
      "ja": "このようにして生成されたシーケンスからの下位ビットを予測し、このようにして生成された順序からの任意の追加ビットを予測することは、実効的にはNと同じくらい困難である。最初のXが秘密である限り、必要に応じてNを公開することができます。"
    },
    {
      "indent": 3,
      "text": "An interesting characteristic of this generator is that any of the s values can be directly calculated. In particular,",
      "ja": "この生成器の興味深い特徴は、S値のいずれかを直接計算できることです。特に、"
    },
    {
      "indent": 6,
      "text": "         ( (2^i) (Mod ((p-1)*(q-1)) ) )\ns  = ( s                                )(Mod n)\n i      0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This means that in applications where many keys are generated in this fashion, it is not necessary to save them all. Each key can be effectively indexed and recovered from that small index and the initial s and n.",
      "ja": "つまり、多くのキーがこのように生成されるアプリケーションでは、それらをすべて保存する必要はありません。各キーは、その小さなインデックスと最初のSとNから効果的に索引付けされ、回復することができます。"
    },
    {
      "indent": 0,
      "text": "6.3. Entropy Pool Techniques",
      "section_title": true,
      "ja": "6.3. エントロピープールを使ったテクニック"
    },
    {
      "indent": 3,
      "text": "Many modern pseudo-random number sources, such as those described in Sections 7.1.2 and 7.1.3 utilize the technique of maintaining a \"pool\" of bits and providing operations for strongly mixing input with some randomness into the pool and extracting pseudo-random bits from the pool. This is illustrated in the figure below.",
      "ja": "セクション7.1.2および7.1.3に記載されているもののような多くの最新の疑似乱数ソースは、ビットの「プール」を維持し、いくつかのランダム性をプールに強く混合し、疑似ランダムを抽出するための操作を提供する技術を利用する。プールからのビット。これを下図に示します。"
    },
    {
      "indent": 9,
      "text": "    +--------+    +------+    +---------+\n--->| Mix In |--->| POOL |--->| Extract |--->\n    |  Bits  |    |      |    |   Bits  |\n    +--------+    +------+    +---------+\n                      ^           V\n                      |           |\n                      +-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Bits to be fed into the pool can come from any of the various hardware, environmental, or user input sources discussed above. It is also common to save the state of the pool on system shutdown and to restore it on re-starting, when stable storage is available.",
      "ja": "プールに供給されるビットは、上述したさまざまなハードウェア、環境、またはユーザーの入力ソースのいずれかから来ることができます。システムシャットダウン時にプールの状態を保存し、安定したストレージが使用可能な場合は再起動時に復元することも一般的です。"
    },
    {
      "indent": 3,
      "text": "Care must be taken that enough entropy has been added to the pool to support particular output uses desired. See [RSA_BULL1] for similar suggestions.",
      "ja": "特定の出力使用をサポートするのに十分なエントロピーがプールに追加されたことを注意する必要があります。類似の提案については[RSA_BULL1]を参照してください。"
    },
    {
      "indent": 0,
      "text": "7. Randomness Generation Examples and Standards",
      "section_title": true,
      "ja": "7. ランダム性生成の例と標準"
    },
    {
      "indent": 3,
      "text": "Several public standards and widely deployed examples are now in place for the generation of keys or other cryptographically random quantities. Some, in section 7.1, include an entropy source. Others, described in section 7.2, provide the pseudo-random number strong-sequence generator but assume the input of a random seed or input from a source of entropy.",
      "ja": "いくつかの公共標準および広く展開された例が、鍵の生成または他の暗号的にランダムな量のために任されています。セクション7.1では、エントロピーソースを含めます。セクション7.2で説明されている他のものは、疑似乱数強シーケンス発生器を提供しますが、ランダムなシードの入力またはエントロピー源からの入力を想定します。"
    },
    {
      "indent": 0,
      "text": "7.1. Complete Randomness Generators",
      "section_title": true,
      "ja": "7.1. 完全なランダム性生成機"
    },
    {
      "indent": 3,
      "text": "Three standards are described below. The two older standards use DES, with its 64-bit block and key size limit, but any equally strong or stronger mixing function could be substituted [DES]. The third is a more modern and stronger standard based on SHA-1 [SHA*]. Lastly, the widely deployed modern UNIX and Windows random number generators are described.",
      "ja": "3つの規格を以下に説明します。2つの古い標準は、その64ビットブロックとキーサイズの制限でDESを使用しますが、同様に強いまたは強い混合関数を代入することができます。3つ目は、SHA-1 [SHA *]に基づくより近代的で強力な標準です。最後に、広く展開された最新のUNIXおよびWindows乱数ジェネレータが記述されています。"
    },
    {
      "indent": 0,
      "text": "7.1.1. US DoD Recommendations for Password Generation",
      "section_title": true,
      "ja": "7.1.1. パスワード生成に関する米国国防総省の推奨事項"
    },
    {
      "indent": 3,
      "text": "The United States Department of Defense has specific recommendations for password generation [DoD]. It suggests using the US Data Encryption Standard [DES] in Output Feedback Mode [MODES] as follows:",
      "ja": "米国国防総省は、パスワード生成に関する具体的な推奨事項を持っています[DOD]。次のように、出力フィードバックモード[MODES]のUSデータ暗号化標準[DES]を使用することをお勧めします。"
    },
    {
      "indent": 9,
      "text": "Use an initialization vector determined from the system clock, system ID, user ID, and date and time; use a key determined from system interrupt registers, system status registers, and system counters; and, as plain text, use an external randomly generated 64-bit quantity such as the ASCII bytes for 8 characters typed in by a system administrator.",
      "ja": "システムクロック、システムID、ユーザーID、および日時から決定された初期化ベクトルを使用してください。システム割り込みレジスタ、システムステータスレジスタ、およびシステムカウンタから決定されたキーを使用してください。また、プレーンテキストとして、システム管理者が入力した8文字のASCIIバイトなど、外部ランダムに生成された64ビット数量を使用します。"
    },
    {
      "indent": 3,
      "text": "The password can then be calculated from the 64 bit \"cipher text\" generated by DES in 64-bit Output Feedback Mode. As many bits as are needed can be taken from these 64 bits and expanded into a pronounceable word, phrase, or other format if a human being needs to remember the password.",
      "ja": "パスワードは、64ビット出力フィードバックモードで生成された64ビットの「暗号テキスト」から計算できます。必要なのと同じくらい多くのビットをこれらの64ビットから取得することができ、人間がパスワードを覚えている必要がある場合は、発音不可の単語、フレーズ、またはその他のフォーマットに拡張されます。"
    },
    {
      "indent": 0,
      "text": "7.1.2. The /dev/random Device",
      "section_title": true,
      "ja": "7.1.2. /dev/random デバイス"
    },
    {
      "indent": 3,
      "text": "Several versions of the UNIX operating system provide a kernel-resident random number generator. Some of these generators use events captured by the Kernel during normal system operation.",
      "ja": "UNIXオペレーティングシステムのいくつかのバージョンがカーネル - 常駐乱数発生器を提供します。これらのジェネレータの中には、通常のシステム操作中にカーネルによってキャプチャされたイベントを使用します。"
    },
    {
      "indent": 3,
      "text": "For example, on some versions of Linux, the generator consists of a random pool of 512 bytes represented as 128 words of 4 bytes each. When an event occurs, such as a disk drive interrupt, the time of the event is XOR'ed into the pool, and the pool is stirred via a primitive polynomial of degree 128. The pool itself is treated as a ring buffer, with new data being XOR'ed (after stirring with the polynomial) across the entire pool.",
      "ja": "たとえば、いくつかのバージョンのLinuxでは、ジェネレータは4バイトの4バイトの128ワードとして表される512バイトのランダムプールで構成されています。ディスクドライブ割り込みなどのイベントが発生した場合、イベントの時刻はプールにXORされ、プールは次数128の原始多項式を介して攪拌されます。プール自体はリングバッファとして扱われます。プール全体にわたって（多項式で撹拌した後）データがXor 'されています。"
    },
    {
      "indent": 3,
      "text": "Each call that adds entropy to the pool estimates the amount of likely true entropy the input contains. The pool itself contains a accumulator that estimates the total over all entropy of the pool.",
      "ja": "プールにエントロピーを追加する各呼び出しは、入力に含まれる本当のエントロピーの可能性の高い量を推定します。プール自体には、プールのすべてのエントロピーを越えて合計を推定するアキュムレータが含まれています。"
    },
    {
      "indent": 3,
      "text": "Input events come from several sources, as listed below. Unfortunately, for server machines without human operators, the first and third are not available, and entropy may be added slowly in that case.",
      "ja": "入力イベントは以下のようにいくつかのソースから来ています。残念ながら、人間の演算子がないサーバーマシンの場合、最初と3番目は利用できず、その場合はエントロピーをゆっくり追加することができます。"
    },
    {
      "indent": 3,
      "text": "1. Keyboard interrupts. The time of the interrupt and the scan code are added to the pool. This in effect adds entropy from the human operator by measuring inter-keystroke arrival times.",
      "ja": "1. キーボード割り込み割り込みの時間とスキャンコードがプールに追加されます。これは、キー間到着時間を測定することによって、人間のオペレータからエントロピーを追加します。"
    },
    {
      "indent": 0,
      "text": " 2. Disk completion and other interrupts. A system being used by a person will likely have a hard-to-predict pattern of disk accesses. (But not all disk drivers support capturing this timing information with sufficient accuracy to be useful.)",
      "ja": "2.ディスクの完了とその他の割り込み。人が使用しているシステムは、予測困難なディスクアクセスのパターンを持つ可能性があります。（ただし、すべてのディスクドライバがこのタイミング情報をキャプチャするのではありません。"
    },
    {
      "indent": 3,
      "text": "3. Mouse motion. The timing and mouse position are added in.",
      "ja": "3. マウスの動きタイミングとマウスの位置が追加されます。"
    },
    {
      "indent": 3,
      "text": "When random bytes are required, the pool is hashed with SHA-1 [SHA*] to yield the returned bytes of randomness. If more bytes are required than the output of SHA-1 (20 bytes), then the hashed output is stirred back into the pool and a new hash is performed to obtain the next 20 bytes. As bytes are removed from the pool, the estimate of entropy is correspondingly decremented.",
      "ja": "ランダムバイトが必要な場合は、プールをSHA-1 [SHA *]でハッシュして、返されたランダム性のバイトを生成します。SHA-1（20バイト）の出力よりも多くのバイトが必要な場合は、ハッシュ出力をプール内に戻し、次の20バイトを取得するために新しいハッシュが実行されます。バイトがプールから取り外されると、エントロピーの推定値はそれに対応して減分されます。"
    },
    {
      "indent": 3,
      "text": "To ensure a reasonably random pool upon system startup, the standard startup and shutdown scripts save the pool to a disk file at shutdown and read this file at system startup.",
      "ja": "システムの起動時に合理的にランダムなプールを確保するために、標準の起動とシャットダウンスクリプトは、シャットダウン時にプールをディスクファイルに保存し、システム起動時にこのファイルを読み込みます。"
    },
    {
      "indent": 3,
      "text": "There are two user-exported interfaces. /dev/random returns bytes from the pool but blocks when the estimated entropy drops to zero. As entropy is added to the pool from events, more data becomes available via /dev/random. Random data obtained from such a /dev/random device is suitable for key generation for long term keys, if enough random bits are in the pool or are added in a reasonable amount of time.",
      "ja": "ユーザーエクスポートされたインターフェイスが2つあります。/dev/random プールからバイトを返しますが、推定エントロピーがゼロになるとブロックします。エントロピーがイベントからプールに追加されると、/dev/random を介してデータが多くなる。そのような /dev/random デバイスから得られたランダムデータは、十分なランダムビットがプール内にあるか、または妥当な時間で追加されている場合、長期キーの鍵生成に適しています。"
    },
    {
      "indent": 3,
      "text": "/dev/urandom works like /dev/random; however, it provides data even when the entropy estimate for the random pool drops to zero. This may be adequate for session keys or for other key generation tasks for which blocking to await more random bits is not acceptable. The risk of continuing to take data even when the pool's entropy estimate is small in that past output may be computable from current output, provided that an attacker can reverse SHA-1. Given that SHA-1 is designed to be non-invertible, this is a reasonable risk.",
      "ja": "/dev/urandomは /dev/random のように機能します。ただし、ランダムプールのエントロピー推定値がゼロになるとデータを提供します。これは、セッションキーまたはより多くのランダムビットを待つブロッキングが許容できない他のキー生成タスクに適していてもよい。攻撃者がSHA-1を逆転させることができるという条件で、プールのエントロピー推定値が小さい場合でもデータを継続する危険性は、過去の出力が電流出力から計算可能である可能性があります。SHA-1が非可逆的になるように設計されていることを考えると、これは合理的なリスクです。"
    },
    {
      "indent": 3,
      "text": "To obtain random numbers under Linux, Solaris, or other UNIX systems equipped with code as described above, all an application has to do is open either /dev/random or /dev/urandom and read the desired number of bytes.",
      "ja": "上記のようなコードを搭載したLinux、Solaris、または他のUNIXシステムの下で乱数を取得するには、すべてのアプリケーションが /dev/random または /dev/urandom のいずれかを開く必要があり、必要なバイト数を読み取る必要があります。"
    },
    {
      "indent": 3,
      "text": "(The Linux Random device was written by Theodore Ts'o. It was based loosely on the random number generator in PGP 2.X and PGP 3.0 (aka PGP 5.0).)",
      "ja": "（LinuxランダムデバイスはTheoDore TS'oによって書かれました。PGP 2.xおよびPGP 3.0（AKA PGP 5.0）の乱数発生器に緩く並べて基づいていました。）"
    },
    {
      "indent": 0,
      "text": "7.1.3. Windows CryptGenRandom",
      "section_title": true,
      "ja": "7.1.3. Windows CryptGenRandom"
    },
    {
      "indent": 0,
      "text": " Microsoft's recommendation to users of the widely deployed Windows operating system is generally to use the CryptGenRandom pseudo-random number generation call with the CryptAPI cryptographic service provider. This takes a handle to a cryptographic service provider library, a pointer to a buffer by which the caller can provide entropy and into which the generated pseudo-randomness is returned, and an indication of how many octets of randomness are desired.",
      "ja": "広く展開されているWindowsオペレーティングシステムのユーザーへのマイクロソフトの推奨事項は、一般的に、CryptAPI暗号化サービスプロバイダを使用してCryptGenrandom擬似乱数生成呼び出しを使用することです。これにより、暗号化サービスプロバイダライブラリにハンドルが取り込まれ、発信者がエントロピーを提供することができ、生成された擬似ランダム性が返される可能性があるバッファへのポインタ、およびランダム性の数のオクテットが望まれることがある。"
    },
    {
      "indent": 3,
      "text": "The Windows CryptAPI cryptographic service provider stores a seed state variable with every user. When CryptGenRandom is called, this is combined with any randomness provided in the call and with various system and user data such as the process ID, thread ID, system clock, system time, system counter, memory status, free disk clusters, and hashed user environment block. This data is all fed to SHA-1, and the output is used to seed an RC4 key stream. That key stream is used to produce the pseudo-random data requested and to update the user's seed state variable.",
      "ja": "Windows暗号化暗号化サービスプロバイダは、シード状態変数をすべてのユーザーに格納します。CryptGenRandomが呼び出されると、これは、呼び出しに提供され、プロセスID、スレッドID、システムクロック、システム時間、システムカウンタ、メモリステータス、空きディスククラスタ、およびハッシュされたユーザーなどのさまざまなシステムとユーザーデータと組み合わされます。環境ブロックこのデータはすべてSHA-1に供給され、出力はRC4キーストリームをシードするために使用されます。そのキーストリームは、要求された疑似ランダムデータを生成し、ユーザーのシード状態変数を更新するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Users of Windows \".NET\" will probably find it easier to use the RNGCryptoServiceProvider.GetBytes method interface.",
      "ja": "Windows \".NET\"のユーザーは、rngCryptoserviceProvider.getBytesメソッドインターフェイスを使いやすくすることが容易になります。"
    },
    {
      "indent": 3,
      "text": "For further information, see [WSC].",
      "ja": "詳細については、[WSC]を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.2. Generators Assuming a Source of Entropy",
      "section_title": true,
      "ja": "7.2. エントロピー源を想定している生成器"
    },
    {
      "indent": 3,
      "text": "The pseudo-random number generators described in the following three sections all assume that a seed value with sufficient entropy is provided to them. They then generate a strong sequence (see Section 6.2) from that seed.",
      "ja": "以下の3つのセクションで説明されている擬似乱数発生器はすべて、十分なエントロピーを持つシード値がそれらに提供されていると仮定します。それから彼らはその種から強いシーケンス（セクション6.2を参照）を生成します。"
    },
    {
      "indent": 0,
      "text": "7.2.1. X9.82 Pseudo-Random Number Generation",
      "section_title": true,
      "ja": "7.2.1. X9.82擬似乱数生成"
    },
    {
      "indent": 3,
      "text": "The ANSI X9F1 committee is in the final stages of creating a standard for random number generation covering both true randomness generators and pseudo-random number generators. It includes a number of pseudo-random number generators based on hash functions, one of which will probably be based on HMAC SHA hash constructs [RFC2104]. The draft version of this generator is described below, omitting a number of optional features [X9.82].",
      "ja": "ANSI X9F1委員会は、真のランダム性発生器と擬似乱数発生器の両方をカバーする乱数生成のための標準を作成する最終段階にあります。それはハッシュ関数に基づく数多くの擬似乱数発生器を含み、そのうちの1つはおそらくHMAC SHAハッシュ構築物[RFC2104]に基づいているでしょう。この生成器のドラフトバージョンは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "In the subsections below, the HMAC hash construct is simply referred to as HMAC but, of course, a particular standard SHA function must be selected in an particular use. Generally speaking, if the strength of the pseudo-random values to be generated is to be N bits, the SHA function chosen must generate N or more bits of output, and a source of at least N bits of input entropy will be required. The same hash function must be used throughout an instantiation of this generator.",
      "ja": "以下のサブセクションでは、HMACハッシュ構文は単にHMACと呼ばれますが、もちろん、特定の標準SHA関数を特定の用途で選択する必要があります。一般的に言って、生成される擬似ランダム値の強度がNビットである場合、選択されたSHA関数は、N個以上の出力ビットを生成しなければならず、入力エントロピーの少なくともNビットのソースが必要とされなければならない。このジェネレータのインスタンス化を通して同じハッシュ関数を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.2.1.1. Notation",
      "section_title": true,
      "ja": "7.2.1.1. 表記"
    },
    {
      "indent": 3,
      "text": "In the following sections, the notation give below is used:",
      "ja": "以下のセクションでは、以下の表記法が使用されます。"
    },
    {
      "indent": 6,
      "text": "hash_length is the output size of the underlying hash function in use.",
      "ja": "Hash_Lengthは、使用中の基礎となるハッシュ関数の出力サイズです。"
    },
    {
      "indent": 6,
      "text": "input_entropy is the input bit string that provides entropy to the generator.",
      "ja": "INPUT_ENTROPYは、ジェネレータにエントロピーを提供する入力ビット列です。"
    },
    {
      "indent": 6,
      "text": "K is a bit string of size hash_length that is part of the state of the generator and is updated at least once each time random bits are generated.",
      "ja": "kは、ジェネレータの状態の一部であり、ランダムビットが生成されるたびに少なくとも1回更新されるサイズhash_lengthのビット列である。"
    },
    {
      "indent": 6,
      "text": "V is a bit string of size hash_length and is part of the state of the generator. It is updated each time hash_length bits of output are generated.",
      "ja": "vはサイズhash_lengthのビット列であり、ジェネレータの状態の一部です。HASH_LENGTHビットが生成されるたびに更新されます。"
    },
    {
      "indent": 6,
      "text": "\"|\" represents concatenation.",
      "ja": "\"|\" は結合を表します。"
    },
    {
      "indent": 0,
      "text": "7.2.1.2. Initializing the Generator",
      "section_title": true,
      "ja": "7.2.1.2. 生成器の初期化"
    },
    {
      "indent": 3,
      "text": "Set V to all zero bytes, except the low-order bit of each byte is set to one.",
      "ja": "各バイトの下位ビットが1に設定されていることを除いて、Vをすべてのゼロバイトに設定します。"
    },
    {
      "indent": 3,
      "text": "Set K to all zero bytes, then set:",
      "ja": "kをすべてのゼロバイトに設定してから設定します。"
    },
    {
      "indent": 9,
      "text": "K = HMAC ( K, V | 0x00 | input_entropy )",
      "ja": "K = HMAC ( K, V | 0x00 | input_entropy )"
    },
    {
      "indent": 9,
      "text": "V = HMAC ( K, V )",
      "ja": "V = HMAC（k、v）"
    },
    {
      "indent": 9,
      "text": "K = HMAC( K, V | 0x01 | input_entropy )",
      "ja": "K = HMAC( K, V | 0x01 | input_entropy )"
    },
    {
      "indent": 9,
      "text": "V = HMAC( K, V )",
      "ja": "V = HMAC( K, V )）"
    },
    {
      "indent": 3,
      "text": "Note: All SHA algorithms produce an integral number of bytes, so the lengths of K and V will be integral numbers of bytes.",
      "ja": "注：すべてのSHAアルゴリズムは整数バイト数を生成するため、kとvの長さは整数バイト数になります。"
    },
    {
      "indent": 0,
      "text": "7.2.1.3. Generating Random Bits",
      "section_title": true,
      "ja": "7.2.1.3. ランダムビットの生成"
    },
    {
      "indent": 3,
      "text": "When output is called for, simply set:",
      "ja": "出力が呼び出されると、単に設定します。"
    },
    {
      "indent": 9,
      "text": "V = HMAC( K, V )",
      "ja": "V = HMAC( K, V )"
    },
    {
      "indent": 3,
      "text": "and use the leading bits from V. If more bits are needed than the length of V, set \"temp\" to a null bit string and then repeatedly perform:",
      "ja": "Vの長さよりも多くのビットが必要な場合は、NULLビット文字列に「TEMP」を設定してから、次のように実行してください。"
    },
    {
      "indent": 9,
      "text": "V = HMAC ( K, V ) temp = temp | V",
      "ja": "V = HMAC（K、V）TEMP = TEMP"
    },
    {
      "indent": 3,
      "text": "stopping as soon as temp is equal to or longer than the number of random bits requested. Use the requested number of leading bits from temp. The definition of the algorithm prohibits requesting more than 2^35 bits.",
      "ja": "TEMPが要求されたランダムビット数以上のようにすぐに停止します。一時的な先頭のビットの要求された数を使用してください。アルゴリズムの定義は2 ^ 35ビット以上の要求を禁止します。"
    },
    {
      "indent": 3,
      "text": "After extracting and saving the pseudo-random output bits as described above, before returning you must also perform two more HMACs as follows:",
      "ja": "上記のように疑似ランダム出力ビットを抽出して保存した後、戻る前に、次のようにさらに2つのHMACを実行する必要があります。"
    },
    {
      "indent": 9,
      "text": "K = HMAC ( K, V | 0x00 ) V = HMAC ( K, V )",
      "ja": "K = HMAC ( K, V | 0x00 ) V = HMAC ( K, V )"
    },
    {
      "indent": 0,
      "text": "7.2.2. X9.17 Key Generation",
      "section_title": true,
      "ja": "7.2.2. X9.17キーの生成"
    },
    {
      "indent": 9,
      "text": "The American National Standards Institute has specified the following method for generating a sequence of keys [X9.17]:",
      "ja": "American National Standards Instituteは、次の手順を作成するための次の方法を指定しました[X9.17]"
    },
    {
      "indent": 6,
      "text": "s is the initial 64 bit seed. 0",
      "ja": "Sは最初の64ビットシードです。0"
    },
    {
      "indent": 6,
      "text": "g is the sequence of generated 64-bit key quantities n",
      "ja": "Gは生成された64ビット鍵数nのシーケンスです"
    },
    {
      "indent": 6,
      "text": "k is a random key reserved for generating this key sequence.",
      "ja": "kはこのキーシーケンスを生成するために予約されているランダムキーです。"
    },
    {
      "indent": 6,
      "text": "t is the time at which a key is generated, to as fine a resolution as is available (up to 64 bits).",
      "ja": "Tは、鍵が生成される時刻であり、利用可能な（最大64ビット）のように細かい解像度として。"
    },
    {
      "indent": 6,
      "text": "DES ( K, Q ) is the DES encryption of quantity Q with key K.",
      "ja": "DES（k、q）は、キーKとの数量QのDES暗号化です。"
    },
    {
      "indent": 3,
      "text": "Then:",
      "ja": "それから："
    },
    {
      "indent": 9,
      "text": "g = DES ( k, DES ( k, t ) XOR s ) n n",
      "ja": "g = des（k、des（k、t）xor s）n n"
    },
    {
      "indent": 9,
      "text": "s = DES ( k, DES ( k, t ) XOR g ) n+1 n",
      "ja": "s = des（k、des（k、t）xor g）n 1 n"
    },
    {
      "indent": 3,
      "text": "If g sub n is to be used as a DES key, then every eighth bit should be adjusted for parity for that use, but the entire 64 bit unmodified g should be used in calculating the next s.",
      "ja": "G SUB NがDESキーとして使用される場合、その使用のためにすべての8ビットをパリティに調整する必要がありますが、64ビットの未修正G全体を次のSの計算に使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.2.3. DSS Pseudo-random Number Generation",
      "section_title": true,
      "ja": "7.2.3. DSS疑似乱数生成"
    },
    {
      "indent": 3,
      "text": "Appendix 3 of the NIST Digital Signature Standard [DSS] provides a method of producing a sequence of pseudo-random 160 bit quantities for use as private keys or the like. This has been modified by Change Notice 1 [DSS_CN1] to produce the following algorithm for generating general-purpose pseudo-random numbers:",
      "ja": "NISTデジタルシグネチャスタンダード[DSS]の付録3は、秘密鍵などとして使用するための擬似ランダム160ビット数量のシーケンスを作成する方法を提供する。これは変更通知1 [DSS_CN1]で変更され、汎用の疑似乱数を生成するための次のアルゴリズムを作成しています。"
    },
    {
      "indent": 9,
      "text": "t = 0x 67452301 EFCDAB89 98BADCFE 10325476 C3D2E1F0",
      "ja": "T = 0x 67452301 EFCDAB89 98BADCFE 10325476 C3D2E1F0"
    },
    {
      "indent": 9,
      "text": "XKEY = initial seed 0",
      "ja": "XKEY =初期シード0."
    },
    {
      "indent": 9,
      "text": "For j = 0 to ...",
      "ja": "j = 0から..."
    },
    {
      "indent": 13,
      "text": "XVAL = ( XKEY  + optional user input ) (Mod 2^512)\n             j",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "X = G( t, XVAL ) j",
      "ja": "X = G（T、XVAL）J."
    },
    {
      "indent": 13,
      "text": "XKEY   = ( 1 + XKEY  + X  ) (Mod 2^512)\n    j+1            j    j",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The quantities X thus produced are the pseudo-random sequence of 160-bit values. Two functions can be used for \"G\" above. Each produces a 160-bit value and takes two arguments, a 160-bit value and a 512 bit value.",
      "ja": "このようにして生成された量xは、160ビット値の擬似ランダムシーケンスである。上記「G」には2つの機能を使用できます。それぞれ160ビット値を生成し、160ビット値、512ビット値の2つの引数を取ります。"
    },
    {
      "indent": 3,
      "text": "The first is based on SHA-1 and works by setting the 5 linking variables, denoted H with subscripts in the SHA-1 specification, to the first argument divided into fifths. Then steps (a) through (e) of section 7 of the NIST SHA-1 specification are run over the second argument as if it were a 512-bit data block. The values of the linking variable after those steps are then concatenated to produce the output of G [SHA*].",
      "ja": "1つ目はSHA-1に基づいており、5分の1つの引数に、5分の1の引数に、5つのリンク変数をSHA-1仕様に設定し、5つのリンク変数を設定することによって機能します。その後、NIST SHA-1仕様のセクション7のステップ（a）から（e）は、512ビットのデータブロックであるかのように2番目の引数を介して実行されます。これらのステップの後のリンク変数の値は、次に連結されてG [SHA *]の出力を生成する。"
    },
    {
      "indent": 3,
      "text": "As an alternative method, NIST also defined an alternate G function based on multiple applications of the DES encryption function [DSS].",
      "ja": "代替方法として、NISTはまた、DES暗号化関数[DSS]の複数のアプリケーションに基づいて代替G関数を定義した。"
    },
    {
      "indent": 0,
      "text": "8. Examples of Randomness Required",
      "section_title": true,
      "ja": "8. 要求されるランダム性の例"
    },
    {
      "indent": 3,
      "text": "Below are two examples showing rough calculations of randomness needed for security. The first is for moderate security passwords, while the second assumes a need for a very high-security cryptographic key.",
      "ja": "以下は、セキュリティに必要なランダム性の大まかな計算を示す2つの例です。1つ目は中程度のセキュリティパスワードのためのものですが、2番目のセキュリティは非常に高いセキュリティの暗号化キーの必要性を想定しています。"
    },
    {
      "indent": 3,
      "text": "In addition, [ORMAN] and [RSA_BULL13] provide information on the public key lengths that should be used for exchanging symmetric keys.",
      "ja": "さらに、[ORMAN]と[RSA_BULL13]は、対称キーの交換に使用される公開鍵の長さに関する情報を提供します。"
    },
    {
      "indent": 0,
      "text": "8.1. Password Generation",
      "section_title": true,
      "ja": "8.1. パスワードの生成"
    },
    {
      "indent": 3,
      "text": "Assume that user passwords change once a year and that it is desired that the probability that an adversary could guess the password for a particular account be less than one in a thousand. Further assume that sending a password to the system is the only way to try a password. Then the crucial question is how often an adversary can try possibilities. Assume that delays have been introduced into a system so that an adversary can make at most one password try every six seconds. That's 600 per hour, or about 15,000 per day, or about 5,000,000 tries in a year. Assuming any sort of monitoring, it is unlikely that someone could actually try continuously for a year. Even if log files are only checked monthly, 500,000 tries is more plausible before the attack is noticed and steps are taken to change passwords and make it harder to try more passwords.",
      "ja": "ユーザーパスワードが年に1回、敵対者が特定のアカウントのパスワードを推測できる可能性が望まれることが望ましいと仮定します。システムにパスワードを送信することがパスワードを試す唯一の方法であると仮定します。それから重要な質問は、敵対者が可能性を試すことができる頻度です。敵対者が最大で1つのパスワードを作ることができるように、遅延がシステムに導入されたとします。それは1時間あたり600人、または1日15,000人、または約5,000,000人が1年に試しています。監視の種類を想定して、誰かが実際に1年間継続的に試みることができないことはありそうもない。ログファイルが毎月だけチェックされていても、攻撃が注目される前に500,000の試みがより深刻なものであり、パスワードを変更し、より多くのパスワードを試すのを難しくします。"
    },
    {
      "indent": 3,
      "text": "To have a one-in-a-thousand chance of guessing the password in 500,000 tries implies a universe of at least 500,000,000 passwords, or about 2^29. Thus, 29 bits of randomness are needed. This can probably be achieved by using the US DoD-recommended inputs for password generation, as it has 8 inputs that probably average over 5 bits of randomness each (see section 7.1). Using a list of 1,000 words, the password could be expressed as a three-word phrase (1,000,000,000 possibilities). By using case-insensitive letters and digits, six characters would suffice ((26+10)^6 = 2,176,782,336 possibilities).",
      "ja": "500,000トライでパスワードを推測する機会が1千千千台の機会を持つことは、少なくとも500,000,000のパスワード、または約2 ^ 29の宇宙を意味します。したがって、29ビットのランダム性が必要です。これはおそらく、それぞれ5ビットのランダム性を超える4つの入力を持つ8つの入力を持つので、パスワード生成のための米国のDOD推奨された入力を使用することによって達成されます（セクション7.1を参照）。1,000ワードのリストを使用して、パスワードは3単語のフレーズ（1,000,000,000の可能性）として表現できます。大文字と小文字を区別しない文字と桁数を使用することによって、6文字が十分であろう（（26 10）^ 6 = 2,176,782,336）。"
    },
    {
      "indent": 3,
      "text": "For a higher-security password, the number of bits required goes up. To decrease the probability by 1,000 requires increasing the universe of passwords by the same factor, which adds about 10 bits. Thus, to have only a one in a million chance of a password being guessed under the above scenario would require 39 bits of randomness and a password that was a four-word phrase from a 1,000 word list, or eight letters/digits. To go to a one-in-10^9 chance, 49 bits of randomness are needed, implying a five-word phrase or a ten-letter/digit password.",
      "ja": "より高いセキュリティパスワードの場合、必要なビット数は上がります。1,000の確率を減らすには、同じ要素でパスワードの宇宙を増やす必要があります。これにより、約10ビットが追加されます。したがって、上記のシナリオの下でパスワードの百万のチャンスを推測することは、1,000ワードリスト、または8文字/桁の4ワードの句である39ビットのランダム性とパスワードを必要とするでしょう。1 in-10 ^ 9のチャンスに移動するには、5ワード句または10文字/桁のパスワードを意味します。"
    },
    {
      "indent": 3,
      "text": "In a real system, of course, there are other factors. For example, the larger and harder to remember passwords are, the more likely users will bed to write them down, resulting in an additional risk of compromise.",
      "ja": "実際のシステムでは、もちろん、他の要因があります。たとえば、パスワードを覚えておくのが難しく、ユーザーがそれらを書き留める可能性が高くなる可能性が高くなり、その結果、妥協の危険性があります。"
    },
    {
      "indent": 0,
      "text": "8.2. A Very High Security Cryptographic Key",
      "section_title": true,
      "ja": "8.2. 非常に高いセキュリティ暗号鍵"
    },
    {
      "indent": 3,
      "text": "Assume that a very high security key is needed for symmetric encryption/decryption between two parties. Assume also that an adversary can observe communications and knows the algorithm being used. Within the field of random possibilities, the adversary can try key values in hopes of finding the one in use. Assume further that brute force trial of keys is the best the adversary can do.",
      "ja": "2つの当事者間の対称暗号化/復号化には非常に高いセキュリティキーが必要とされているとします。また、敵対者が通信を観察し、使用されているアルゴリズムを知っていると仮定する。ランダムな可能性の分野内で、敵対者は使用中のものを見つけることを期待して重要な値を試すことができます。さらに鍵のブルートフォース試験が敵対者ができることができることをさらに想定していると仮定する。"
    },
    {
      "indent": 0,
      "text": "8.2.1. Effort per Key Trial",
      "section_title": true,
      "ja": "8.2.1. 鍵の試行あたりの労力"
    },
    {
      "indent": 3,
      "text": "How much effort will it take to try each key? For very high-security applications, it is best to assume a low value of effort. Even if it would clearly take tens of thousands of computer cycles or more to try a single key, there may be some pattern that enables huge blocks of key values to be tested with much less effort per key. Thus, it is probably best to assume no more than a couple of hundred cycles per key. (There is no clear lower bound on this, as computers operate in parallel on a number of bits and a poor encryption algorithm could allow many keys or even groups of keys to be tested in parallel. However, we need to assume some value and can hope that a reasonably strong algorithm has been chosen for our hypothetical high-security task.)",
      "ja": "各キーを試すのにどのくらいの努力がありますか？非常に高セキュリティアプリケーションの場合、低価値の努力を想定するのが最善です。単一の鍵を試すためにそれ以上のコンピュータサイクル以上を明確にするとしても、キー値の巨大なブロックをテストすることを可能にするいくつかのパターンがあるかもしれません。したがって、鍵ごとに数百サイクル以上を想定するのがおそらく最善です。（これには、コンピュータが多数のビットで並行して動作するため、これは明確な下限はありません。合理的に強力なアルゴリズムが私たちの仮説的な高セキュリティタスクのために選択されたことを願っています。）"
    },
    {
      "indent": 3,
      "text": "If the adversary can command a highly parallel processor or a large network of work stations, 10^11 cycles per second is probably a minimum assumption today. Looking forward a few years, there should be at least an order of magnitude improvement. Thus, it is reasonable to assume that 10^10 keys could be checked per second, or 3.6*10^12 per hour or 6*10^14 per week, or 2.4*10^15 per month. This implies a need for a minimum of 63 bits of randomness in keys, to be sure that they cannot be found in a month. Even then it is possible that, a few years from now, a highly determined and resourceful adversary could break the key in 2 weeks; on average, they need try only half the keys.",
      "ja": "敵対者が高度に並列プロセッサまたは大規模なワークステーションネットワークを指揮することができる場合、毎秒10 ^ 11サイクルは今日の最小の仮定です。数年前に楽しみにして、少なくとも一桁の改善があるはずです。したがって、10 ^ 10のキーを毎秒1秒あたり、3.6 * 10 ^ 12、週あたり3.6 * 10 ^ 12、または1ヶ月あたり2.4 * 10 ^ 15であると仮定することは合理的です。これは、鍵で最低63ビットのランダム性が必要とされていることを意味します。それでも、今から数年前に、非常に決定され、機械的な敵対者が2週間で鍵を破る可能性があります。平均して、彼らはキーの半分だけを試す必要があります。"
    },
    {
      "indent": 0,
      "text": " These questions are considered in detail in \"Minimal Key Lengths for Symmetric Ciphers to Provide Adequate Commercial Security: A Report by an Ad Hoc Group of Cryptographers and Computer Scientists\" [KeyStudy] that was sponsored by the Business Software Alliance. It concluded that a reasonable key length in 1995 for very high security is in the range of 75 to 90 bits and, since the cost of cryptography does not vary much with the key size, it recommends 90 bits. To update these recommendations, just add 2/3 of a bit per year for Moore's law [MOORE]. This translates to a determination, in the year 2004, a reasonable key length is in the 81- to 96-bit range. In fact, today, it is increasingly common to use keys longer than 96 bits, such as 128-bit (or longer) keys with AES and keys with effective lengths of 112-bits with triple-DES.",
      "ja": "これらの質問は、「適切な商業的保証を提供するための対称暗号のための最低限の重要な長さ」で詳しく説明されています。非常に高いセキュリティのための1995年の合理的なキー長は75から90ビットの範囲内であり、暗号化のコストは重要なサイズでは大きく変わらないので、90ビットをお勧めします。これらの推奨事項を更新するには、ムーアの法則[ムーア]のために年間2/3の少し追加してください。これは、2004年の決定につながり、妥当なキー長は81~96ビットの範囲です。実際、今日は、AESを持つ128ビット（または長い）キーなど、96ビットよりも長いキーと、312ビットで112ビットを持つキーを使用することがますます一般的です。"
    },
    {
      "indent": 0,
      "text": "8.2.2. Meet-in-the-Middle Attacks",
      "section_title": true,
      "ja": "8.2.2. 中間一致攻撃"
    },
    {
      "indent": 3,
      "text": "If chosen or known plain text and the resulting encrypted text are available, a \"meet-in-the-middle\" attack is possible if the structure of the encryption algorithm allows it. (In a known plain text attack, the adversary knows all or part (possibly some standard header or trailer fields) of the messages being encrypted. In a chosen plain text attack, the adversary can force some chosen plain text to be encrypted, possibly by \"leaking\" an exciting text that is sent by the adversary over an encrypted channel because the text is so interesting.",
      "ja": "選択されたプレーンテキストと既知のプレーンテキストとその結果として生じる暗号化されたテキストが利用可能である場合、暗号化アルゴリズムの構造がそれを許す場合は「中間一致」攻撃が可能です。（既知のプレーンテキスト攻撃では、敵対者は暗号化されているメッセージの全部または部分（おそらく一部の標準のヘッダーまたはトレーラーフィールド）を知っています。選択されたプレーンテキスト攻撃では、敵対者は、選択されたプレーンテキストを暗号化することができます。テキストがとても面白いので、暗号化されたチャネルを介して敵対者によって送信されるエキサイティングなテキストを「漏らす」。"
    },
    {
      "indent": 3,
      "text": "The following is an oversimplified explanation of the meet-in-the-middle attack: the adversary can half-encrypt the known or chosen plain text with all possible first half-keys, sort the output, and then half-decrypt the encoded text with all the second half-keys. If a match is found, the full key can be assembled from the halves and used to decrypt other parts of the message or other messages. At its best, this type of attack can halve the exponent of the work required by the adversary while adding a very large but roughly constant factor of effort. Thus, if this attack can be mounted, a doubling of the amount of randomness in the very strong key to a minimum of 192 bits (96*2) is required for the year 2004, based on the [KeyStudy] analysis.",
      "ja": "以下は、中間攻撃の明確化された説明です。すべての後半キー。一致が見つかった場合は、フルキーを半分から組み立て、メッセージの他の部分やその他のメッセージを復号化するために使用できます。その最善では、このタイプの攻撃は、非常に大きいがほぼ一定の努力要因を追加しながら、敵対者が必要とする仕事の指数を半分にすることができます。したがって、この攻撃をマウントできる場合は、[KeyStudy]分析に基づいて、2004年の最低192ビット（96×2）に非常に強い鍵のランダム性の量を2倍にすることが必要です。"
    },
    {
      "indent": 3,
      "text": "This amount of randomness is well beyond the limit of that in the inputs recommended by the US DoD for password generation and could require user-typing timing, hardware random number generation, or other sources of randomness.",
      "ja": "このランダム性の量は、パスワード生成のために米国のDODによって推奨されている入力の限界をよく超えており、ユーザー入力タイミング、ハードウェアの乱数生成、またはその他のランダム性ソースを必要とする可能性があります。"
    },
    {
      "indent": 3,
      "text": "The meet-in-the-middle attack assumes that the cryptographic algorithm can be decomposed in this way. Hopefully no modern algorithm has this weakness, but there may be cases where we are not sure of that or even of what algorithm a key will be used with. Even if a basic algorithm is not subject to a meet-in-the-middle attack, an attempt to produce a stronger algorithm by applying the basic algorithm twice (or two different algorithms sequentially) with different keys will gain less added security than would be expected. Such a composite algorithm would be subject to a meet-in-the-middle attack.",
      "ja": "中間攻撃は、暗号化アルゴリズムがこのように分解できることを前提としています。うまくいけば、現代のアルゴリズムはこの脆弱性を持っていませんが、私たちが確かにそうでない、あるいはどんなアルゴリズムと一緒に使用されるのかについても、あまりにも存在しない場合があります。たとえ基本的なアルゴリズムがミドルインアタックメントの対象にならない場合でも、基本アルゴリズムを2回（または2つの異なるアルゴリズム）を異なるキーで適用することによってより強力なアルゴリズムを作成しようとすると、セキュリティが追加されます。予想される。そのような複合アルゴリズムは、ミドルミドル攻撃の対象となるであろう。"
    },
    {
      "indent": 3,
      "text": "Enormous resources may be required to mount a meet-in-the-middle attack, but they are probably within the range of the national security services of a major nation. Essentially all nations spy on other nations' traffic.",
      "ja": "中間的な攻撃をマウントするためには莫大なリソースが必要になるかもしれませんが、おそらく主要な国の国家セキュリティサービスの範囲内です。基本的にすべての国々が他の国の交通をスパイします。"
    },
    {
      "indent": 0,
      "text": "8.2.3. Other Considerations",
      "section_title": true,
      "ja": "8.2.3. その他の考慮事項"
    },
    {
      "indent": 3,
      "text": "[KeyStudy] also considers the possibilities of special-purpose code-breaking hardware and having an adequate safety margin.",
      "ja": "[KeyStudy]専用のコード破壊ハードウェアの可能性を考慮し、十分な安全マージンを持っています。"
    },
    {
      "indent": 3,
      "text": "Note that key length calculations such as those above are controversial and depend on various assumptions about the cryptographic algorithms in use. In some cases, a professional with a deep knowledge of algorithm-breaking techniques and of the strength of the algorithm in use could be satisfied with less than half of the 192 bit key size derived above.",
      "ja": "上記のようなキー長の計算は物議を醸しており、使用中の暗号化アルゴリズムについてのさまざまな仮定に依存しています。場合によっては、アルゴリズム - 破断技術の深い知識および使用中のアルゴリズムの強さを有する専門家は、上で導出された192ビットのキーサイズの半分以下で満たすことができる。"
    },
    {
      "indent": 3,
      "text": "For further examples of conservative design principles, see [FERGUSON].",
      "ja": "保守的設計原則のさらなる例については、[ファーガソン]を参照してください。"
    },
    {
      "indent": 0,
      "text": "9. Conclusion",
      "section_title": true,
      "ja": "9. 結論"
    },
    {
      "indent": 3,
      "text": "Generation of unguessable \"random\" secret quantities for security use is an essential but difficult task.",
      "ja": "セキュリティ使用のための不燃性の「ランダムな」秘密数量の生成は不可欠ではなく困難な作業です。"
    },
    {
      "indent": 3,
      "text": "Hardware techniques for producing the needed entropy would be relatively simple. In particular, the volume and quality would not need to be high, and existing computer hardware, such as audio input or disk drives, can be used.",
      "ja": "必要なエントロピーを生産するためのハードウェア技術は比較的簡単です。特に、音量と品質は高くする必要はないであろうとし、音声入力またはディスクドライブなどの既存のコンピュータハードウェアを使用することができる。"
    },
    {
      "indent": 3,
      "text": "Widely-available computational techniques can process low-quality random quantities from multiple sources, or a larger quantity of such low-quality input from one source, to produce a smaller quantity of higher-quality keying material. In the absence of hardware sources of randomness, a variety of user and software sources can frequently, with care, be used instead. However, most modern systems already have hardware, such as disk drives or audio input, that could be used to produce high-quality randomness.",
      "ja": "広く利用可能な計算技術は、複数のソースからの低品質のランダムな量、あるいは1つのソースからのこのような低品質の入力の低品質の量を処理して、より少ない量の高品質のキーイング材料を生成することができる。ランダム性のハードウェアソースがない場合、さまざまなユーザーおよびソフトウェアの情報源が頻繁に介護される可能性があります。ただし、最近のシステムでは、高品質のランダム性を生み出すために使用できるディスクドライブやオーディオ入力など、すでにハードウェアがあります。"
    },
    {
      "indent": 3,
      "text": "Once a sufficient quantity of high-quality seed key material (a couple of hundred bits) is available, computational techniques are available to produce cryptographically-strong sequences of computationally-unpredictable quantities from this seed material.",
      "ja": "十分な量の高品質のシード鍵材料（数百ビット）が利用可能であると、このシード材料から計算上予測不可能な量の暗号的に強いシーケンスを生成するために計算技術が利用可能である。"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The entirety of this document concerns techniques and recommendations for generating unguessable \"random\" quantities for use as passwords, cryptographic keys, initialization vectors, sequence numbers, and similar security applications.",
      "ja": "この文書全体は、パスワード、暗号鍵、初期化ベクトル、シーケンス番号、および同様のセキュリティアプリケーションとして使用するための不燃性の「ランダムな」数量を生成するための技術および推奨事項に関する。"
    },
    {
      "indent": 0,
      "text": "11. Acknowledgements",
      "section_title": true,
      "ja": "11. 謝辞"
    },
    {
      "indent": 3,
      "text": "Special thanks to Paul Hoffman and John Kelsey for their extensive comments and to Peter Gutmann, who has permitted the incorporation of material from his paper \"Software Generation of Practically Strong Random Numbers\".",
      "ja": "Paul HoffmanとJohn Kelseyのおかげで、豊富なコメントやPeter Gutmannのための特別なおかげで、彼の論文からの資料の「実質的に強い乱数のソフトウェア生成」からの材料の組み込みを許可しました。"
    },
    {
      "indent": 3,
      "text": "The following people (in alphabetic order) have contributed substantially to this document:",
      "ja": "以下の人々（アルファベット順）は実質的にこの文書に貢献しています。"
    },
    {
      "indent": 6,
      "text": "Steve Bellovin, Daniel Brown, Don Davis, Peter Gutmann, Tony Hansen, Sandy Harris, Paul Hoffman, Scott Hollenback, Russ Housley, Christian Huitema, John Kelsey, Mats Naslund, and Damir Rajnovic.",
      "ja": "Steve Bellovin、Daniel Brown、Don Davis、Peter Gutmann、Tony Hansen、Sandy Harris、Paul Hoffman、Scott Harenback、Russ Housle、Christian Huitema、John Kelsey、Mats Naslund、Damir Rajnovic。"
    },
    {
      "indent": 3,
      "text": "The following people (in alphabetic order) contributed to RFC 1750, the predecessor of this document:",
      "ja": "以下の人々（アルファベット順）はRFC 1750に貢献し、この文書の前身です。"
    },
    {
      "indent": 6,
      "text": "David M. Balenson, Don T. Davis, Carl Ellison, Marc Horowitz, Christian Huitema, Charlie Kaufman, Steve Kent, Hal Murray, Neil Haller, Richard Pitkin, Tim Redmond, and Doug Tygar.",
      "ja": "David M. Balenson、Don T. Davis、Carl Ellison、Marc Horowitz、Christian Huitema、Christian Huitema、Christian Huitema、Steve Kent、Hal Murray、Neil Haller、Richard Pitkin、Tim Redmond、Doug Tygar。"
    },
    {
      "indent": 0,
      "text": "Appendix A: Changes from RFC 1750",
      "ja": "付録A：RFC 1750からの変更"
    },
    {
      "indent": 3,
      "text": "1. Additional acknowledgements have been added.",
      "ja": "1. 追加の確認応答が追加されました。"
    },
    {
      "indent": 3,
      "text": "2. Insertion of section 5.3 on mixing with S-boxes.",
      "ja": "2. Sボックスとの混合時のセクション5.3の挿入"
    },
    {
      "indent": 3,
      "text": "3. Addition of section 3.3 on Ring Oscillator randomness sources.",
      "ja": "3. リングオシレータランダム性源についてのセクション3.3の追加。"
    },
    {
      "indent": 3,
      "text": "4. Addition of AES and the members of the SHA series producing more than 160 bits. Use of AES has been emphasized and the use of DES de-emphasized.",
      "ja": "4. AESの追加とSHAシリーズのメンバーは160ビット以上を生み出します。AESの使用が強調され、デスの使用が強調されました。"
    },
    {
      "indent": 3,
      "text": "5. Addition of section 6.3 on entropy pool techniques.",
      "ja": "5. エントロピープール技術に関するセクション6.3の追加"
    },
    {
      "indent": 3,
      "text": "6. Addition of section 7.2.3 on the pseudo-random number generation techniques given in FIPS 186-2 (with Change Notice 1), 7.2.1 on those given in X9.82, section 7.1.2 on the random number generation techniques of the /dev/random device in Linux and other UNIX systems, and section 7.1.3 on random number generation techniques in the Windows operating system.",
      "ja": "6. セクション7.2.3の追加は、FIPS 186-2（変更通知1を付ける）、7.2.1のx9.82で示されている擬似乱数生成技術について、7.1.2項の乱数生成技術についてLinuxおよび他のUNIXシステムの/ dev /ランダムデバイス、およびWindowsオペレーティングシステム内の乱数生成技術に関するセクション7.1.3。"
    },
    {
      "indent": 3,
      "text": "7. Addition of references to the \"Minimal Key Lengths for Symmetric Ciphers to Provide Adequate Commercial Security\" study published in January 1996 [KeyStudy] and to [RFC1948].",
      "ja": "7. 1996年1月[KeyStudy]と[RFC1948]に発行された「対称暗号の最小キー長」の参照の追加。"
    },
    {
      "indent": 3,
      "text": "8. Added caveats to using Diffie-Hellman as a mixing function and, because of those caveats and its computationally intensive nature, recommend against its use.",
      "ja": "8. 混合関数としてDiffie-Hellmanを使用する警告を追加し、それらの警告およびその計算的に集約的な性質のために、その使用に推奨する。"
    },
    {
      "indent": 3,
      "text": "9. Addition of references to the X9.82 effort and the [TURBID] and [NASLUND] papers.",
      "ja": "9. X9.82の取り組みと[濁り]および[ナスルンド]の論文への参照の追加。"
    },
    {
      "indent": 2,
      "text": "10. Addition of discussion of min-entropy and Renyi entropy and references to the [LUBY] book.",
      "ja": "10. 最小エントロピーとレニティエントロピーと[唇]本への参照の議論の追加。"
    },
    {
      "indent": 2,
      "text": "11. Major restructuring, minor wording changes, and a variety of reference updates.",
      "ja": "11. 主要なリストラ、マイナーな表現の変更、およびさまざまな参照更新プログラム。"
    },
    {
      "indent": 0,
      "text": "Informative References",
      "ja": "参考引用"
    },
    {
      "indent": 3,
      "text": "[AES] \"Specification of the Advanced Encryption Standard (AES)\", United States of America, US National Institute of Standards and Technology, FIPS 197, November 2001.",
      "ja": "[AES]「高度な暗号化規格（AES）」、アメリカ合衆国、米国国立標準技術研究所、FIPS 197、2001年11月。"
    },
    {
      "indent": 3,
      "text": "[ASYMMETRIC] Simmons, G., Ed., \"Secure Communications and Asymmetric Cryptosystems\", AAAS Selected Symposium 69, ISBN 0-86531-338-5, Westview Press, 1982.",
      "ja": "[非対称] Simmons、G.、ED。、「安全な通信と非対称暗号システム」、AAAS選択シンポジウム69、ISBN 0-86531-338-5、WestView Press、1982。"
    },
    {
      "indent": 3,
      "text": "[BBS] Blum, L., Blum, M., and M. Shub, \"A Simple Unpredictable Pseudo-Random Number Generator\", SIAM Journal on Computing, v. 15, n. 2, 1986.",
      "ja": "[BBS] Blum、L.、Blum、M.およびM. Shub、「単純な予測不可能な疑似乱数発生器」、コンピューティングに関するSIAMジャーナル、v。15、n。1986年2月2日。"
    },
    {
      "indent": 3,
      "text": "[BRILLINGER] Brillinger, D., \"Time Series: Data Analysis and Theory\", Holden-Day, 1981.",
      "ja": "[Brillinger] Brillinger、D.、「時系列：データ分析と理論」、Holden日、1981年。"
    },
    {
      "indent": 3,
      "text": "[CRC] \"C.R.C. Standard Mathematical Tables\", Chemical Rubber Publishing Company.",
      "ja": "[CRC]「C.R.c.標準数学表」、化学ゴム出版会社。"
    },
    {
      "indent": 3,
      "text": "[DAVIS] Davis, D., Ihaka, R., and P. Fenstermacher, \"Cryptographic Randomness from Air Turbulence in Disk Drives\", Advances in Cryptology - Crypto '94, Springer-Verlag Lecture Notes in Computer Science #839, 1984.",
      "ja": "[Davis] Davis、D.、Ihaka、R.、およびP.フェンシュタルサッハ、「ディスクドライブの空気乱流からの暗号ランダム性」、暗号学 -  Crypto '94、Springer-Verlag講義では、コンピュータサイエンスにおけるSpringer-Verlag講義についての進歩＃839,1984。"
    },
    {
      "indent": 3,
      "text": "[DES] \"Data Encryption Standard\", US National Institute of Standards and Technology, FIPS 46-3, October 1999. Also, \"Data Encryption Algorithm\", American National Standards Institute, ANSI X3.92-1981. See also FIPS 112, \"Password Usage\", which includes FORTRAN code for performing DES.",
      "ja": "「データ暗号化アルゴリズム」、ANSI X3.92-1981「データ暗号化アルゴリズム」、米国国立標準化学技術研究所、FIPS 46-3。FIPS 112、「パスワード使用量」も参照してください。これには、DESを実行するためのFortranコードが含まれています。"
    },
    {
      "indent": 3,
      "text": "[D-H] Rescorla, E., \"Diffie-Hellman Key Agreement Method\", RFC 2631, June 1999.",
      "ja": "[D-H] RESCORLA、E.、「DIFFIE-HELLMAN鍵協定方法」、RFC 2631、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[DNSSEC1] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, \"DNS Security Introduction and Requirements\", RFC 4033, March 2005.",
      "ja": "[DNSSEC1]、R.、Austein、R.、Larson、M.、M。、D.、S. Rose、「DNSセキュリティ紹介および要件」、RFC 4033、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[DNSSEC2] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, \"Resource Records for the DNS Security Extensions\", RFC 4034, March 2005.",
      "ja": "[DNSSEC2] Arends、R.、Austein、R.、Larson、M.、Massey、D.、およびS. Rose、「DNSセキュリティ拡張のリソースレコード」、RFC 4034、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[DNSSEC3] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, \"Protocol Modifications for the DNS Security Extensions\", RFC 4035, March 2005.",
      "ja": "[DNSSEC3] Arends、R.、Austein、R.、Larson、M.、Massey、D.、およびS. Rose、「DNSセキュリティ拡張のためのプロトコル変更」、RFC 4035、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[DoD] \"Password Management Guideline\", United States of America, Department of Defense, Computer Security Center, CSC-STD-002-85, April 1885.",
      "ja": "[DOD]「パスワード管理ガイドライン」、アメリカ合衆国、国防総省、コンピュータセキュリティセンター、CSC-STD-002-85、1885年4月。"
    },
    {
      "indent": 19,
      "text": "(See also \"Password Usage\", FIPS 112, which incorporates CSC-STD-002-85 as one of its appendices. FIPS 112 is currently available at: http://www.idl.nist.gov/fipspubs/fip112.htm.)",
      "ja": "（「パスワードの使用量」、CSC-STD-002-85をその付録の1つとして組み込んだFIPS 112も参照してください。FIPS 112は現在http://www.idl.nist.gov/fipspubs/fip112.htmで現在入手可能です。。）"
    },
    {
      "indent": 3,
      "text": "[DSS] \"Digital Signature Standard (DSS)\", US National Institute of Standards and Technology, FIPS 186-2, January 2000.",
      "ja": "[DSS]米国国立基準技術研究所、FIPS 186-2、2000年1月、米国国立署名標準（DSS） \"。"
    },
    {
      "indent": 3,
      "text": "[DSS_CN1] \"Digital Signature Standard Change Notice 1\", US National Institute of Standards and Technology, FIPS 186-2 Change Notice 1, 5, October 2001.",
      "ja": "[DSS_CN1]「デジタル署名標準変更通知1」、米国国立基準技術研究所、FIPS 186-2の変更1,5、2001年10月5日。"
    },
    {
      "indent": 3,
      "text": "[FERGUSON] Ferguson, N. and B. Schneier, \"Practical Cryptography\", Wiley Publishing Inc., ISBN 047122894X, April 2003.",
      "ja": "[ファーガソン]ファーガソン、N.およびB.Schneier、「実用的な暗号」、Wiley Publishing Inc.、ISBN 047122894X、2003年4月。"
    },
    {
      "indent": 3,
      "text": "[GIFFORD] Gifford, D., \"Natural Random Number\", MIT/LCS/TM-371, September 1988.",
      "ja": "[Gifford] Gifford、D.、「自然乱数」、MIT / LCS / TM-371、1988年9月。"
    },
    {
      "indent": 3,
      "text": "[IEEE_802.11i] \"Amendment to Standard for Telecommunications and Information Exchange Between Systems - LAN/MAN Specific Requirements - Part 11: Wireless Medium Access Control (MAC) and physical layer (PHY) specifications: Medium Access Control (MAC) Security Enhancements\", IEEE, January 2004.",
      "ja": "[IEEE_802.11i] \"システム間の電気通信および情報交換のための標準化の修正 -  LAN / MAN特有の要件 - 第11報：無線中アクセス制御（MAC）および物理層（PHY）仕様：中アクセス制御（MAC）セキュリティの強化、2004年1月、Ieee。"
    },
    {
      "indent": 3,
      "text": "[IPSEC] Kent, S. and R. Atkinson, \"Security Architecture for the Internet Protocol\", RFC 2401, November 1998.",
      "ja": "[IPSEC]ケント、S.およびR. Atkinson、1998年11月、RFC 2401、RFC 2401。"
    },
    {
      "indent": 3,
      "text": "[Jakobsson] Jakobsson, M., Shriver, E., Hillyer, B., and A. Juels, \"A practical secure random bit generator\", Proceedings of the Fifth ACM Conference on Computer and Communications Security, 1998.",
      "ja": "[Jakobsson] Jakobsson、M.、Shiver、E.、Hillyer、B.、およびA.ジュール、「実用的な安全なランダムビットジェネレータ」、コンピュータ通信セキュリティに関する第5回ACM会議の手続き、1998年。"
    },
    {
      "indent": 3,
      "text": "[KAUFMAN] Kaufman, C., Perlman, R., and M. Speciner, \"Network Security: Private Communication in a Public World\", Prentis Hall PTR, ISBN 0-13-046019-2, 2nd Edition 2002.",
      "ja": "Kaufman、C.、Perlman、R.、M. Speciliner、「ネットワークセキュリティ：公共の世界のプライベートコミュニケーション」、Prentis Hall Ptr、ISBN 0-13-046019-2、第2版2002。"
    },
    {
      "indent": 3,
      "text": "[KeyStudy] Blaze, M., Diffie, W., Riverst, R., Schneier, B. Shimomura, T., Thompson, E., and M. Weiner, \"Minimal Key Lengths for Symmetric Ciphers to Provide Adequate Commercial Security: A Report by an Ad Hoc Group of Cryptographers and Computer Scientists\", January 1996. Currently available at: http://www.crypto.com/papers/keylength.txt and http://www.securitydocs.com/library/441.",
      "ja": "[KeyStudy] Blaze、M.、Diffie、W.、Riverst、R.、Schneier、B. Shimomura、T.、Thompson、E.、M.Weiner、「対称的な繊維のための重要な長さは、適切な商務保障を提供するための主要な長さ：1996年1月の暗号化器とコンピュータ科学者のアドホックグループによる報告書。現在、http：//www.crypto.com/papers/keylength.txtとhttp://www.securitydocs.com/library/441。"
    },
    {
      "indent": 3,
      "text": "[KNUTH] Knuth, D., \"The Art of Computer Programming\", Volume 2: Seminumerical Algorithms, Chapter 3: Random Numbers, Addison-Wesley Publishing Company, 3rd Edition, November 1997.",
      "ja": "[KNUTH]ナイート、D.、「コンピュータプログラミングの技術」、第2巻：セミュニカルアルゴリズム、第3章：乱数、Addison-Wesley出版会社、第3版、1997年11月。"
    },
    {
      "indent": 3,
      "text": "[KRAWCZYK] Krawczyk, H., \"How to Predict Congruential Generators\", Journal of Algorithms, V. 13, N. 4, December 1992.",
      "ja": "[Krawczyk] Krawczyk、H。、「合同生成器の予測方法」、アルゴリズムジャーナル、V.13、N. 4、N. 4、1992年12月。"
    },
    {
      "indent": 3,
      "text": "[LUBY] Luby, M., \"Pseudorandomness and Cryptographic Applications\", Princeton University Press, ISBN 0691025460, 8 January 1996.",
      "ja": "[唇]リビー、M。、「疑似逆らさと暗号アプリケーション」、プリンストン大学プレス、ISBN 0691025460、1996年1月8日。"
    },
    {
      "indent": 3,
      "text": "[MAIL_PEM1] Linn, J., \"Privacy Enhancement for Internet Electronic Mail: Part I: Message Encryption and Authentication Procedures\", RFC 1421, February 1993.",
      "ja": "[MAIL_PEM1] LINN、J。、「インターネット電子メールのプライバシー強化：第1部：メッセージ暗号化および認証手順」、RFC 1421、1993年2月。"
    },
    {
      "indent": 3,
      "text": "[MAIL_PEM2] Kent, S., \"Privacy Enhancement for Internet Electronic Mail: Part II: Certificate-Based Key Management\", RFC 1422, February 1993.",
      "ja": "[Mail_PEM2]ケント、S。、「インターネット電子メールのプライバシー強化：その2：証明書ベースの鍵管理」、RFC 1422、1993年2月。"
    },
    {
      "indent": 3,
      "text": "[MAIL_PEM3] Balenson, D., \"Privacy Enhancement for Internet Electronic Mail: Part III: Algorithms, Modes, and Identifiers\", RFC 1423, February 1993.",
      "ja": "[MAIL_PEM3] Balenson、D.、「インターネット電子メールのプライバシー強化：そのIII：アルゴリズム、モード、識別子」、RFC 1423、1993年2月。"
    },
    {
      "indent": 3,
      "text": "[MAIL_PEM4] Kaliski, B., \"Privacy Enhancement for Internet Electronic Mail: Part IV: Key Certification and Related Services\", RFC 1424, February 1993.",
      "ja": "[MAIL_PEM4]カリスキ、B.、インターネット電子メールの「プライバシー強化：そのIV：KEY認証および関連サービス」RFC 1424、1993年2月。"
    },
    {
      "indent": 3,
      "text": "[MAIL_PGP1] Callas, J., Donnerhacke, L., Finney, H., and R. Thayer, \"OpenPGP Message Format\", RFC 2440, November 1998.",
      "ja": "[mail_pgp1] Callas、J.、Donnerhacke、L.、Finney、H.、およびR. Thayer、 \"OpenPGPメッセージフォーマット\"、RFC 2440、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[MAIL_PGP2] Elkins, M., Del Torto, D., Levien, R., and T. Roessler, \"MIME Security with OpenPGP\", RFC 3156, August 2001.",
      "ja": "[Mail_PGP2] Elkins、M.、Del Torto、D.、Levien、R.、およびT. Roessler、「OpenPGPとのMIMEセキュリティ」、RFC 3156、2001年8月。"
    },
    {
      "indent": 3,
      "text": "[S/MIME] RFCs 2632 through 2634:",
      "ja": "[S / MIME] RFCS 2632から2634："
    },
    {
      "indent": 19,
      "text": "Ramsdell, B., \"S/MIME Version 3 Certificate Handling\", RFC 2632, June 1999.",
      "ja": "Ramsdell、B.、「S / MIMEバージョン3証明書処理」、RFC 2632、1999年6月。"
    },
    {
      "indent": 19,
      "text": "Ramsdell, B., \"S/MIME Version 3 Message Specification\", RFC 2633, June 1999.",
      "ja": "Ramsdell、B.、「S / MIMEバージョン3メッセージ仕様」、RFC 2633、1999年6月。"
    },
    {
      "indent": 19,
      "text": "Hoffman, P., \"Enhanced Security Services for S/MIME\", RFC 2634, June 1999.",
      "ja": "Hoffman、P.、「S / MIMEの強化されたセキュリティサービス」、RFC 2634、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[MD4] Rivest, R., \"The MD4 Message-Digest Algorithm\", RFC 1320, April 1992.",
      "ja": "[MD4] Rivest、R.、「MD4メッセージ - ダイジェストアルゴリズム」、RFC 1320、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[MD5] Rivest, R., \"The MD5 Message-Digest Algorithm \", RFC 1321, April 1992.",
      "ja": "[MD5] Rivest、R.、「MD5メッセージダイジェストアルゴリズム」、RFC 1321、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[MODES] \"DES Modes of Operation\", US National Institute of Standards and Technology, FIPS 81, December 1980. Also: \"Data Encryption Algorithm - Modes of Operation\", American National Standards Institute, ANSI X3.106-1983.",
      "ja": "[MODES]米国国立標準技術研究所、FIPS 81、1980年12月の「データ暗号化アルゴリズム」、ANSI X3.106-1983。"
    },
    {
      "indent": 3,
      "text": "[MOORE] Moore's Law: the exponential increase in the logic density of silicon circuits. Originally formulated by Gordon Moore in 1964 as a doubling every year starting in 1962, in the late 1970s the rate fell to a doubling every 18 months and has remained there through the date of this document. See \"The New Hacker's Dictionary\", Third Edition, MIT Press, ISBN 0-262-18178-9, Eric S. Raymond, 1996.",
      "ja": "[ムーア]ムーアの法則：シリコン回路の論理密度の指数関数的増加1964年に1964年に毎年2倍のGordon Mooreによって策定された1970年代後半に、18ヶ月ごとに倍増し、この文書の日付を通して残っています。「新しいハッカーの辞書」、第3版、MIT PRESS、ISBN 0-262-18178-9、Eric S. Raymond、1996年を参照してください。"
    },
    {
      "indent": 3,
      "text": "[NASLUND] Naslund, M. and A. Russell, \"Extraction of Optimally Unbiased Bits from a Biased Source\", IEEE Transactions on Information Theory. 46(3), May 2000.",
      "ja": "[Naslund] Naslund、M.およびA. Russell、「バイアスソースからの最適な不偏ビットの抽出」、情報理論に関するIEEEトランザクション。2000年5月46（3）。"
    },
    {
      "indent": 3,
      "text": "[ORMAN] Orman, H. and P. Hoffman, \"Determining Strengths For Public Keys Used For Exchanging Symmetric Keys\", BCP 86, RFC 3766, April 2004.",
      "ja": "[Orman] Orman、H.およびP. Hoffman、「対称鍵の交換に使用される公開鍵の長さの決定」、BCP 86、RFC 3766、2004年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC1750] Eastlake 3rd, D., Crocker, S., and J. Schiller, \"Randomness Recommendations for Security\", RFC 1750, December 1994.",
      "ja": "[RFC1750]イーストレイク3RD、D.、Crocker、S.、J.Schiller、「セキュリティのためのランダム性推奨」、RFC 1750、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC1948] Bellovin, S., \"Defending Against Sequence Number Attacks\", RFC 1948, May 1996.",
      "ja": "[RFC1948] Bellovin、S.、「シーケンス番号攻撃に対する防御」、RFC 1948、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、Bellare、M.、R. Canetti、「HMAC：メッセージ認証用鍵付きハジング」、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RSA_BULL1] \"Suggestions for Random Number Generation in Software\", RSA Laboratories Bulletin #1, January 1996.",
      "ja": "[RSA_BULL1]「ソフトウェアにおける乱数生成の提案」、RSA Laboratories Bulletin＃1、1996年1月1日。"
    },
    {
      "indent": 3,
      "text": "[RSA_BULL13] Silverman, R., \"A Cost-Based Security Analysis of Symmetric and Asymmetric Key Lengths\", RSA Laboratories Bulletin #13, April 2000 (revised November 2001).",
      "ja": "[RSA_BULL13] Silverman、R.、「対称および非対称キー長のコストベースのセキュリティ分析」、2000年4月13日（2001年11月改訂）。"
    },
    {
      "indent": 3,
      "text": "[SBOX1] Mister, S. and C. Adams, \"Practical S-box Design\", Selected Areas in Cryptography, 1996.",
      "ja": "[SBOX1]ミスター、S、およびC. ADAMS、「実用的なSボックスデザイン」、暗号化された領域、1996年。"
    },
    {
      "indent": 3,
      "text": "[SBOX2] Nyberg, K., \"Perfect Non-linear S-boxes\", Advances in Cryptography, Eurocrypt '91 Proceedings, Springer-Verland, 1991.",
      "ja": "[SBOX2] Nyberg、K。、「完璧な非線形Sボックス」、暗号化、eurocrypt '91議事録、Springer-Verland、1991年。"
    },
    {
      "indent": 3,
      "text": "[SCHNEIER] Schneier, B., \"Applied Cryptography: Protocols, Algorithms, and Source Code in C\", 2nd Edition, John Wiley & Sons, 1996.",
      "ja": "[シュナリエ]シュナリエ、B.、「CRYPTOGRAGHOGRAGHAGRAGHAGLS：C内のプロトコル、アルゴリズム、およびソースコード」、第2版、John Wiley＆Sons、1996年。"
    },
    {
      "indent": 3,
      "text": "[SHANNON] Shannon, C., \"The Mathematical Theory of Communication\", University of Illinois Press, 1963. Originally from: Bell System Technical Journal, July and October, 1948.",
      "ja": "[Shannon] Shannon、C.、「Illinois大学コミュニケーションの数学理論」、1963年：Bell System Technical Journal、1948年7月および10月。"
    },
    {
      "indent": 3,
      "text": "[SHIFT1] Golub, S., \"Shift Register Sequences\", Aegean Park Press, Revised Edition, 1982.",
      "ja": "[Shift1] Golub、S.、「シフトレジスタシーケンス」、Aegean Park Press、Revised Edition、1982年。"
    },
    {
      "indent": 3,
      "text": "[SHIFT2] Barker, W., \"Cryptanalysis of Shift-Register Generated Stream Cypher Systems\", Aegean Park Press, 1984.",
      "ja": "[Shift2] Barker、W、「シフトレジスタ生成ストリームCypherシステムの暗号解読」、Aegean Park Press、1984。"
    },
    {
      "indent": 3,
      "text": "[SHA] \"Secure Hash Standard\", US National Institute of Science and Technology, FIPS 180-2, 1 August 2002.",
      "ja": "【SHA】米国国立科学技術研究所、FIPS 180-2、2002年8月1日。"
    },
    {
      "indent": 3,
      "text": "[SHA_RFC] Eastlake 3rd, D. and P. Jones, \"US Secure Hash Algorithm 1 (SHA1)\", RFC 3174, September 2001.",
      "ja": "[SHA_RFC]イーストレイク3RD、D.およびP. Jones、2001年9月、RFC 3174、「Secure Hash Algorithm 1（SHA1）」"
    },
    {
      "indent": 3,
      "text": "[SSH] Products of the SECSH Working Group, Works in Progress, 2005.",
      "ja": "[SSH] SECSHワーキンググループの製品は、2005年、進行中の作品です。"
    },
    {
      "indent": 3,
      "text": "[STERN] Stern, J., \"Secret Linear Congruential Generators are not Cryptographically Secure\", Proc. IEEE STOC, 1987.",
      "ja": "[Stern] Stern、J.、「Secret Linear Contribenty Generatorsは暗号的に安全ではありません」、Proc。IEEE STOC、1987年。"
    },
    {
      "indent": 3,
      "text": "[TLS] Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\", RFC 2246, January 1999.",
      "ja": "[TLS] Dierks、T.およびC. Allen、 \"Thels Protocol Version 1.0\"、RFC 2246、1999年1月。"
    },
    {
      "indent": 3,
      "text": "[TURBID] Denker, J., \"High Entropy Symbol Generator\", <http://www.av8n.com/turbid/paper/turbid.htm>, 2003.",
      "ja": "[Turbid] Denker、J.、「高エントロピーシンボルジェネレータ」、<http://www.av8n.com/turbid/paper/turbid.htm>、2003。"
    },
    {
      "indent": 3,
      "text": "[USENET_1] Kantor, B. and P. Lapsley, \"Network News Transfer Protocol\", RFC 977, February 1986.",
      "ja": "[USENET_1] Kantor、B.およびP. Lapsley、「ネットワークニュース転送プロトコル」、RFC 977、1986年2月。"
    },
    {
      "indent": 3,
      "text": "[USENET_2] Barber, S., \"Common NNTP Extensions\", RFC 2980, October 2000.",
      "ja": "[USENET_2] Barber、S.、Common NNTP Extensions \"、RFC 2980、2000年10月。"
    },
    {
      "indent": 3,
      "text": "[VON_NEUMANN] Von Nuemann, J., \"Various techniques used in connection with random digits\", Von Neumann's Collected Works, Vol. 5, Pergamon Press, 1963.",
      "ja": "[Von Neumann]フォンノイマン、J.、「ランダムな数字に関連して使用されるさまざまなテクニック」、Von Neumannの収集された作品、Vol。5、Pergamon Press、1963。"
    },
    {
      "indent": 3,
      "text": "[WSC] Howard, M. and D. LeBlanc, \"Writing Secure Code, Second Edition\", Microsoft Press, ISBN 0735617228, December 2002.",
      "ja": "[WSC]ハワード、M.およびD. Leblanc、「セキュアコードの書き込み、第2版」、マイクロソフトプレス、ISBN 0735617228、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[X9.17] \"American National Standard for Financial Institution Key Management (Wholesale)\", American Bankers Association, 1985.",
      "ja": "[X9.17]「金融機関鍵管理（卸売）」、アメリカンバンカー協会、1985年。"
    },
    {
      "indent": 3,
      "text": "[X9.82] \"Random Number Generation\", American National Standards Institute, ANSI X9F1, Work in Progress. Part 1 - Overview and General Principles. Part 2 - Non-Deterministic Random Bit Generators Part 3 - Deterministic Random Bit Generators",
      "ja": "[x9.82]「乱数生成」、アメリカ国立規格Institute、ANSI X9F1、進行中の業務。第1部 - 概要と一般原則。第2部 - 非決定論的ランダムビットジェネレータパート3  - 決定論的ランダムビットジェネレータ"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "Donald E. Eastlake 3rd Motorola Laboratories 155 Beaver Street Milford, MA 01757 USA",
      "ja": "Donald E.イーストレイク3rd Motorola Laboratories 155 Beaver Street Milford、MA 01757 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 508-786-7554 (w)\n       +1 508-634-2066 (h)\nEMail: Donald.Eastlake@motorola.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jeffrey I. Schiller MIT, Room E40-311 77 Massachusetts Avenue Cambridge, MA 02139-4307 USA",
      "ja": "Jeffrey I. Schiller Mit、部屋E40-311 77マサチューセッツ州アベニューケンブリッジ、MA 02139-4307アメリカ"
    },
    {
      "indent": 3,
      "text": "Phone: +1 617-253-0161\nEMail: jis@mit.edu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Steve Crocker",
      "ja": "スティーブクロッカー"
    },
    {
      "indent": 3,
      "text": "EMail: steve@stevecrocker.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全著作権宣言"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "著作権（C）インターネット社会（2005）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書は、BCP 78に含まれている権利、ライセンス、制限の対象となり、その中に述べた場合を除き、著者らはすべての権利を保持しています。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書と本明細書に含まれる情報は、「現状のまま」基準で提供されており、投稿者、または（いずれかの場合）、インターネット社会とインターネットエンジニアリングのタスクフォースがすべての保証を損なう、または本明細書における情報の使用が、特定の目的のためのあらゆる権利または黙示の保証を侵害しないことを含むがこれらに限定されないが、これに限定されない。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "この文書に記載されているテクノロジの実装または使用に関連すると主張される可能性がある、またはそのような権利の下でのライセンスの使用に関連すると主張される可能性がある、またはその他の権利の下にある範囲内である可能性がある、またはその他の権利の使用に関連すると主張する可能性がある、IETFは、IETFを取りません。利用可能です。そのような権利を特定するためにそれが独立した努力をしたことを表していません。RFC文書の権利に関する手順に関する情報は、BCP 78およびBCP 79にあります。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局へのIETF事務局と利用可能なライセンスの保証のコピー、またはこの仕様書の実装者や利用者による一般的なライセンスまたは許可を得るための試みの結果を得ることができます。IETFオンラインIPRリポジトリからhttp://www.ietf.org/ipr。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、著作権、特許または特許出願、またはこの規格を実装することが要求される可能性がある技術をカバーする可能性のある他の独自の権利を注意を及ぼすように興味のある当事者を勧めます。ietf-ipr@ietf.orgのIETFに情報を宛先に宛ててください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディタ機能のための資金は、現在インターネット社会によって提供されています。"
    }
  ]
}