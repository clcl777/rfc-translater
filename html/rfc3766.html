<!DOCTYPE html>


<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 3766 - Determining Strengths For Public Keys Used For Exchanging Symmetric Keys 日本語訳</title>

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">3766</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc3766">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 3766 - Determining Strengths For Public Keys Used For Exchanging Symmetric Keys 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc3766">
            https://datatracker.ietf.org/doc/html/rfc3766
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 3766 - 対称鍵の交換に使用される公開鍵の強度を決定する</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <h6 class="card-title">要約（自動生成）</h6>
            <p class="card-text">RFC 3766は、対称鍵を交換するために使用される公開鍵の強度を決定する方法に関するガイドラインを提供します。この文書の目的は、セキュリティレベルを確保するために必要な公開鍵の最小サイズを推奨することです。利用場面としては、SSL/TLSやVPNなどのセキュアな通信を行う際に、適切な鍵の強度を選択する際に参照されます。関連するRFCには、RFC 7427（デジタル署名のための汎用的な公開鍵アルゴリズムの使用）やRFC 5280（インターネットX.509公開鍵インフラストラクチャ証明書とCRLプロファイル）などがあります。RFC 3766は、セキュリティの専門家やシステム設計者にとって、適切な鍵強度を選択する際の重要なリソースとなります。</p>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                           H. Orman
Request for Comments: 3766                            Purple Streak Dev.
BCP: 86                                                       P. Hoffman
Category: Best Current Practice                           VPN Consortium
                                                              April 2004
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Determining Strengths For Public Keys Used For Exchanging Symmetric Keys
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
対称鍵の交換に使用される公開鍵の強度を決定する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、インターネットコミュニティのためのインターネットの最良の現在の慣行を指定し、改善のための議論と提案を要求します。このメモの分布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）インターネット社会（2004）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementors of systems that use public key cryptography to exchange symmetric keys need to make the public keys resistant to some predetermined level of attack. That level of attack resistance is the strength of the system, and the symmetric keys that are exchanged must be at least as strong as the system strength requirements. The three quantities, system strength, symmetric key strength, and public key strength, must be consistently matched for any network protocol usage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
対称鍵を交換するために公開鍵暗号を使用するシステムの実装者は、公開鍵をいくつかの所定のレベルの攻撃に耐える必要があります。そのレベルの攻撃抵抗はシステムの強度であり、交換される対称キーは少なくともシステム強度要件と同じくらい強い必要があります。3つの数量、システム強度、対称的なキー強度、および公開鍵の強さは、ネットワークプロトコルの使用方法について一貫して一致させる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While it is fairly easy to express the system strength requirements in terms of a symmetric key length and to choose a cipher that has a key length equal to or exceeding that requirement, it is harder to choose a public key that has a cryptographic strength meeting a symmetric key strength requirement. This document explains how to determine the length of an asymmetric key as a function of a symmetric key strength requirement. Some rules of thumb for estimating equivalent resistance to large-scale attacks on various algorithms are given. The document also addresses how changing the sizes of the underlying large integers (moduli, group sizes, exponents, and so on) changes the time to use the algorithms for key exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
対称鍵長の観点からシステム強度要件を表現し、その要件を超えるキーの長さを持つ暗号を選択することはかなり簡単ですが、暗号化された強度を満たす公開鍵を選択するのが難しいです。対称鍵強度要件この文書では、対称鍵強度要件の関数としての非対称鍵の長さを決定する方法について説明します。さまざまなアルゴリズムに対する大規模攻撃に対する等価抵抗を推定するための経験のある多くの経験則が与えられています。この文書は、基礎となる大きな整数（Moduli、Group Sizes、指数など）のサイズの変更にも対応しています（Moduli、Group Sizes、指数など）は、鍵交換のアルゴリズムを使用する時間を変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Model of Protecting Symmetric Keys with Public Keys. . . . . .  2
       1.1. The key exchange algorithms . . . . . . . . . . . . . . .  4
   2.  Determining the Effort to Factor . . . . . . . . . . . . . . .  5
       2.1. Choosing parameters for the equation. . . . . . . . . . .  6
       2.2. Choosing k from empirical reports . . . . . . . . . . . .  7
       2.3. Pollard&#39;s rho method. . . . . . . . . . . . . . . . . . .  7
       2.4. Limits of large memory and many machines. . . . . . . . .  8
       2.5. Special purpose machines. . . . . . . . . . . . . . . . .  9
   3.  Compute Time for the Algorithms. . . . . . . . . . . . . . . . 10
       3.1. Diffie-Hellman Key Exchange . . . . . . . . . . . . . . . 10
            3.1.1. Diffie-Hellman with elliptic curve groups. . . . . 11
       3.2. RSA encryption and decryption . . . . . . . . . . . . . . 11
       3.3. Real-world examples . . . . . . . . . . . . . . . . . . . 12
   4.  Equivalences of Key Sizes. . . . . . . . . . . . . . . . . . . 13
       4.1. Key equivalence against special purpose brute force
            hardware. . . . . . . . . . . . . . . . . . . . . . . . . 15
       4.2. Key equivalence against conventional CPU brute force
            attack. . . . . . . . . . . . . . . . . . . . . . . . . . 15
       4.3. A One Year Attack: 80 bits of strength. . . . . . . . . . 16
       4.4. Key equivalence for other ciphers . . . . . . . . . . . . 16
       4.5. Hash functions for deriving symmetric keys from public
            key algorithms. . . . . . . . . . . . . . . . . . . . . . 17
       4.6. Importance of randomness. . . . . . . . . . . . . . . . . 19
   5.  Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . 19
       5.1. TWIRL Correction. . . . . . . . . . . . . . . . . . . . . 20
   6.  Security Considerations. . . . . . . . . . . . . . . . . . . . 20
   7.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 20
       7.1. Informational References. . . . . . . . . . . . . . . . . 20
   8.  Authors&#39; Addresses . . . . . . . . . . . . . . . . . . . . . . 22
   9.  Full Copyright Statement . . . . . . . . . . . . . . . . . . . 23
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Model-of-Protecting-Symmetric-Keys-with-Public-Keys">
1. Model of Protecting Symmetric Keys with Public Keys
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 公開鍵で対称キーを保護するモデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many books on cryptography and security explain the need to exchange symmetric keys in public as well as the many algorithms that are used for this purpose. However, few of these discussions explain how the strengths of the public keys and the symmetric keys are related.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化およびセキュリティに関する多くの本は、この目的のために使用される多くのアルゴリズムだけでなく、一般のアルゴリズムと同様に対称鍵を交換する必要性を説明しています。ただし、これらの議論のうち、公開鍵と対称鍵の強みがどのように関連しているかについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 To understand this, picture a house with a strong lock on the front door. Next to the front door is a small lockbox that contains the key to the front door. A would-be burglar who wants to break into the house through the front door has two options: attack the lock on the front door, or attack the lock on the lockbox in order to retrieve the key. Clearly, the burglar is better off attacking the weaker of the two locks. The homeowner in this situation must make sure that adding the second entry option (the lockbox containing the front door key) is at least as strong as the lock on the front door, in order not to make the burglar&#39;s job easier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
これを理解するために、正面玄関の上の強いロック付きの家を撮影してください。フロントドアの横には、正面玄関へのキーを含む小さなロックボックスです。フロントドアを介して家に侵入したいという盗難は2つのオプションを持っています：キーを取得するために、ロックをロックしたり、ロックボックスのロックを攻撃したりします。明らかに、強盗は2つのロックの弱いものを攻撃するのが良いです。この状況の住宅所有者は、2番目のエントリオプション（前面扉キーを含むロックボックス）を追加することを確認してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementor designing a system for exchanging symmetric keys using public key cryptography must make a similar decision. Assume that an attacker wants to learn the contents of a message that is encrypted with a symmetric key, and that the symmetric key was exchanged between the sender and recipient using public key cryptography. The attacker has two options to recover the message: a brute-force attempt to determine the symmetric key by repeated guessing, or mathematical determination of the private key used as the key exchange key. A smart attacker will work on the easier of these two problems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
公開鍵暗号化を使用して対称キーを交換するためのシステムを設計する実装者は、同様の決定を下す必要があります。攻撃者が対称鍵で暗号化されているメッセージの内容を学習したいと考えると想定しており、公開鍵暗号を使用して送信者と受信者の間で交換されたことを想定しています。攻撃者には、メッセージを回復するための2つの選択肢があります。繰り返し推測によって対称鍵を決定しようとするブルートフォース、または鍵交換キーとして使用される秘密鍵の数学的決定を試みます。スマート攻撃者は、これら2つの問題のより簡単なものに取り組みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A simple-minded answer to the implementor&#39;s problem is to be sure that the key exchange system is always significantly stronger than the symmetric key; this can be done by choosing a very long public key. Such a design is usually not a good idea because the key exchanges become much more expensive in terms of processing time as the length of the public keys go up. Thus, the implementor is faced with the task of trying to match the difficulty of an attack on the symmetric key with the difficulty of an attack on the public key encryption. This analysis is not necessary if the key exchange can be performed with extreme security for almost no cost in terms of elapsed time or CPU effort; unfortunately, this is not the case for public key methods today.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装者の問題に対する簡単な志願は、鍵交換システムが常に対称鍵よりも大幅に強いことを確認することです。これは非常に長い公開鍵を選択することによって行うことができます。そのような設計は通常、公開鍵の長さが上がるにつれて、処理時間の点ではるかに高価になるので、通常は良い考えではありません。したがって、実装者は、公開鍵暗号化に対する攻撃の難しさを困難にして、対称鍵に対する攻撃の難しさを一致させようとするタスクに直面しています。経過時間またはCPUの努力の観点から、極端なセキュリティで鍵交換を実行できる場合は、この分析は必要ではありません。残念ながら、これは今日公開鍵方式の場合ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A third consideration is the minimum security requirement of the user. Assume the user is encrypting with CAST-128 and requires a symmetric key with a resistance time against brute-force attack of 20 years. He might start off by choosing a key with 86 random bits, and then use a one-way function such as SHA-1 to &#34;boost&#34; that to a block of 160 bits, and then take 128 of those bits as the key for CAST-128. In such a case, the key exchange algorithm need only match the difficulty of 86 bits, not 128 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第3の考慮事項は、ユーザの最小限のセキュリティ要件です。ユーザーがCAST-128で暗号化しており、20年のブルートフォースアタックに対する抵抗時間を持つ対称キーを必要とします。86ランダムビットでキーを選択してから、SHA-1などの一方向機能を160ビットのブロックに選択してから、キャストのキーとして128を取ることができます。-128。そのような場合、鍵交換アルゴリズムは、128ビットではなく、86ビットの難しさと一致するだけでよい。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The selection procedure is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
選択手順は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Determine the attack resistance necessary to satisfy the security requirements of the application. Do this by estimating the minimum number of computer operations that the attacker will be forced to do in order to compromise the security of the system and then take the logarithm base two of that number. Call that logarithm value &#34;n&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. アプリケーションのセキュリティ要件を満たすのに必要な攻撃抵抗を決定します。これを行い、システムのセキュリティを危険にさらし、その数字の2つの2つを取得するために攻撃者が強制的にするコンピュータ操作の最小数を推定することでこれを行います。対数値 &#34;n&#34;を呼び出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A 1996 report recommended 90 bits as a good all-around choice for system security. The 90 bit number should be increased by about 2/3 bit/year, or about 96 bits in 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1996年の報告書は、システムセキュリティのための良いオールアラフ選択として90ビットを推奨していました。90ビット数は、2005年に約2/3ビット/年、または約96ビット増加する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Choose a symmetric cipher that has a key with at least n bits and at least that much cryptanalytic strength.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 少なくともNビットと少なくともその極めて暗号化強度を持つキーを持つ対称暗号を選択してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Choose a key exchange algorithm with a resistance to attack of at least n bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 少なくともnビットの攻撃に対する抵抗を持つ鍵交換アルゴリズムを選択してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A fourth consideration might be the public key authentication method used to establish the identity of a user. This might be an RSA digital signature or a DSA digital signature. If the modulus for the authentication method isn&#39;t large enough, then the entire basis for trusting the communication might fall apart. The following step is thus added:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第4の考慮事項は、ユーザの身元を確立するために使用される公開鍵認証方法であり得る。これは、RSAデジタル署名またはDSAデジタル署名である可能性があります。認証方法のモジュラスが十分に大きくない場合は、通信を信頼するための全基準が崩れる可能性があります。このようにして次のステップが追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Choose an authentication algorithm with a resistance to attack of at least n bits. This ensures that a similar key exchanged cannot be forged between the two parties during the secrecy lifetime of the encrypted material. This may not be strictly necessary if the authentication keys are changed frequently and they have a well-understood usage lifetime, but in lieu of this, the n bit guidance is sound.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 少なくともnビットの攻撃に対する抵抗を持つ認証アルゴリズムを選択してください。これにより、暗号化された材料の存続寿命の間に、交換された同様のキーを交換することはできません。認証キーが頻繁に変更され、それらがよく理解された使用寿命を持つ場合、これは厳密に必要ではないかもしれませんが、これの代わりにNビットガイダンスは音です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-1--The-key-exchange-algorithms">
1.1. The key exchange algorithms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. 鍵交換アルゴリズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Diffie-Hellman method uses a group, a generator, and exponents. In today&#39;s Internet standards, the group operation is based on modular multiplication. Here, the group is defined by the multiplicative group of an integer, typically a prime p = 2q + 1, where q is a prime, and the arithmetic is done modulo p; the generator (which is often simply 2) is denoted by g.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Diffie-Hellmanメソッドは、グループ、ジェネレータ、および指数を使用します。今日のインターネット規格では、グループ操作はモジュラー乗算に基づいています。ここで、グループは、整数の乗法群、典型的にはプライムP = 2Q 1、ここでQはプライムであり、算術はモジュロPである。発電機（多くの場合単純に2）はgで表されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In Diffie-Hellman, Alice and Bob first agree (in public or in private) on the values for g and p. Alice chooses a secret large random integer (a), and Bob chooses a secret random large integer (b). Alice sends Bob A, which is g^a mod p; Bob sends Alice B, which is g^b mod p. Next, Alice computes B^a mod p, and Bob computes A^b mod p. These two numbers are equal, and the participants use a simple function of this number as the symmetric key k.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Diffie-Hellmanでは、AliceとBobがGとPの値に最初に（公開またはプライベートで）一致します。アリスは秘密の大きなランダム整数（a）を選択し、ボブは秘密のランダムな大きさの整数（b）を選択します。AliceはBOB Aを送信します。これはG ^ MOD Pです。ボブはAlice Bを送信します。これはG ^ B MOD Pです。次に、AliceはB ^ A mod Pを計算し、ボブは^ B MOD Pを計算する。これら2つの数字は等しく、参加者はこの数の単純な関数を対称鍵kとして使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that Diffie-Hellman key exchange can be done over different kinds of group representations. For instance, elliptic curves defined over finite fields are a particularly efficient way to compute the key exchange [SCH95].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Diffie-Hellman鍵交換は、異なる種類のグループ表現で行うことができます。例えば、有限フィールドにわたって定義された楕円曲線は、鍵交換を計算するための特に効率的な方法である[SCH95]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For RSA key exchange, assume that Bob has a public key (m) which is equal to p*q, where p and q are two secret prime numbers, and an encryption exponent e, and a decryption exponent d. For the key exchange, Alice sends Bob E = k^e mod m, where k is the secret symmetric key being exchanged. Bob recovers k by computing E^d mod m, and the two parties use k as their symmetric key. While Bob&#39;s encryption exponent e can be quite small (e.g., 17 bits), his decryption exponent d will have as many bits in it as m does.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA鍵交換の場合、BOBがP * Qに等しい公開鍵（M）を持っていると仮定し、ここで、P、Qは2つの秘密素数、暗号化指数e、および復号化指数dです。鍵交換のために、アリスはBOB E = k ^ E MOD Mを送ります。ここで、Kは交換されている秘密の対称鍵です。ボブはe ^ D MOD Mを計算することによってkを回復し、2つの締約国はそれらの対称鍵としてKを使用します。Bobの暗号化指数Eはかなり小さい（例えば、17ビット）、彼の復号指数DはMと同じくらい多くのビットを持ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Determining-the-Effort-to-Factor">
2. Determining the Effort to Factor
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 要因への努力を決定する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RSA public key encryption method is immune to brute force guessing attacks because the modulus (and thus, the secret exponent d) will have at least 512 bits, and that is too many possibilities to guess. The Diffie-Hellman exchange is also secure against guessing because the exponents will have at least twice as many bits as the symmetric keys that will be derived from them. However, both methods are susceptible to mathematical attacks that determine the structure of the public keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA公開鍵暗号化法は、弾性率（したがって秘密指数D）が少なくとも512ビットを持ち、推測する可能性が多すぎるため、RSA公開鍵暗号化方法は攻撃を推測しています。指数は、それらから派生する対称鍵と同じくらい2倍のビットを持つので、Diffie-Hellman交換も推測に対して安全です。しかしながら、両方の方法は公開鍵の構造を決定する数学的攻撃の影響を受けやすい。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Factoring an RSA modulus will result in complete compromise of the security of the private key. Solving the discrete logarithm problem for a Diffie-Hellman modular exponentiation system will similarly destroy the security of all key exchanges using the particular modulus. This document assumes that the difficulty of solving the discrete logarithm problem is equivalent to the difficulty of factoring numbers that are the same size as the modulus. In fact, it is slightly harder because it requires more operations; based on empirical evidence so far, the ratio of difficulty is at least 20, possibly as high as 64. Solving either problem requires a great deal of memory for the last stage of the algorithm, the matrix reduction step. Whether or not this memory requirement will continue to be the limiting factor in solving larger integer problems remains to be seen. At the current time it is not, and there is active research into parallel matrix algorithms that might mitigate the memory requirements for this problem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSAモジュラスをファクタリングすると、秘密鍵のセキュリティが完全に妥協されます。 Diffie-Hellmanモジュラー指数指数システムに対する離散対数問題を解決すると、特定の弾性率を使用してすべての主要な交換のセキュリティが同様に破壊されます。この文書では、離散対数問題を解決することの困難さが、弾性率と同じサイズの数値の難しさに等しいと仮定しています。実際、それがより多くの操作が必要なので少し難しいです。これまでの経験的証拠に基づいて、難易度の比は少なくとも20、おそらく64程度のものである。いずれの問題も解決する必要があるアルゴリズムの最後の段階、マトリックス低減ステップには、大きなメモリが必要です。このメモリ要件がより大きな整数の問題を解決するための制限要因であるかどうかは残っていないかどうか。現在時刻ではありません、そしてこの問題のためのメモリ要件を軽減するかもしれない並列行列アルゴリズムに積極的な研究があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The number field sieve (NFS) [GOR93] [LEN93] is the best method today for solving the discrete logarithm problem. The formula for estimating the number of simple arithmetic operations needed to factor an integer, n, using the NFS method is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数値篩（NFS）[GOR93] [LEN93]は、離散対数問題を解くための最良の方法です。NFSメソッドを使用して、整数nを率するのに必要な単純な算術演算の数を推定するための式は、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      L(n) = k * e^((1.92 + o(1)) * cubrt(ln(n) * (ln(ln(n)))^2))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Many people prefer to discuss the number of MIPS years (MYs) that are needed for large operations such as the number field sieve. For such an estimation, an operation in the L(n) formula is one computer instruction. Empirical evidence indicates that 4 or 5 instructions might be a closer match, but this is a minor factor and this document sticks with one operation/one instruction for this discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
多くの人々は、数フィールドの篩などの大きな操作に必要なミップス数（MYS）の数について議論することを好みます。このような推定のために、L（n）式の動作は1つのコンピュータ命令である。経験的証拠は、4または5の指示がより近い一致かもしれないことを示していますが、これはマイナーな要素であり、この文書はこの議論のための1つの操作/ 1つの指示を備えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1--Choosing-parameters-for-the-equation">
2.1. Choosing parameters for the equation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. 方程式のパラメータを選択する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The expression above has two parameters that can be estimated by empirical means: k and o(1). For the range of numbers we are interested in, there is little distinction between them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の式は、経験的手段によって推定することができる2つのパラメータを有する：KおよびO（1）。興味のある数字の範囲では、それらの間の区別はほとんどありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One could assume that k is 1 and o(1) is 0. This is reasonably valid if the expression is only used for estimating relative effort (instead of actual effort) and one assumes that the o(1) term is very small over the range of the numbers that are to be factored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Kが1であると仮定することができると仮定することができ、（実際の努力の代わりに）相対的な努力の推定にのみ使用されている場合には、これは合理的に有効であり、O（1）の用語が非常に小さいと仮定する具体的になる数字の範囲。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Or, one could assume that o(1) is small and roughly constant and thus its value can be folded into k; then estimate k from reported amounts of effort spent factoring large integers in tests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あるいは、O（1）が小さくておおよそ一定であり、したがってその値をkに折り畳むことができると仮定することができる。次に、テストにおける大きな整数を因果する努力の報告額からkを見積もります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document uses the second approach in order to get an estimate of the significance of the factor. It appears to be minor, based on the following calculations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この資料は、要因の重要性の推定値を得るために2番目のアプローチを使用します。以下の計算に基づいて、マイナーであるようです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sample values from recent work with the number field sieve include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数値フィールドの篩を使用した最近の作業からのサンプル値は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Test name Number of Number of MYs of effort decimal bits digits RSA130 130 430 500 RSA140 140 460 2000 RSA155 155 512 8000 RSA160 160 528 3000
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
テスト名努力のマイ（10進数）数桁数RSA140 140 460 2000 RSA155 155 512 8000 RSA160 160 528 3000
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are few precise measurements of the amount of time used for these factorizations. In most factorization tests, hundreds or thousands of computers are used over a period of several months, but the number of their cycles were used for the factoring project, the precise distribution of processor types, speeds, and so on are not usually reported. However, in all the above cases, the amount of effort used was far less than the L(n) formula would predict if k was 1 and o(1) was 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの因子に使用される時間の正確な測定はほとんどありません。ほとんどの因数分解テストでは、数ヶ月の期間にわたって数百または数千のコンピュータが使用されていますが、それらのサイクル数はファクタリングプロジェクトに使用されていましたが、プロセッサタイプ、速度などの正確な分布は通常報告されていません。しかしながら、上記のすべての場合において、使用される労力の量は、kが1であるかどうか（1）が0であったかどうかを予測するであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A similar estimate of effort, done in 1995, is in [ODL95].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1995年に行われた努力の同様の推定値は、[ODL95]にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Results indicating that for the Number Field Sieve factoring method, the actual number of operations is less than expected, are found in [DL].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数フィールド篩ファクタリング方法では、実際の操作数が予想されていないことを示す結果が、[DL]で見つかる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2--Choosing-k-from-empirical-reports">
2.2. Choosing k from empirical reports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. 経験的報告書からKを選ぶ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By solving for k from the empirical reports, it appears that k is approximately 0.02. This means that the &#34;effective key strength&#34; of the RSA algorithm is about 5 or 6 bits less than is implied by the naive application of equation L(n) (that is, setting k to 1 and o(1) to 0). These estimates of k are fairly stable over the numbers reported in the table. The estimate is limited to a single significant digit of k because it expresses real uncertainties; however, the effect of additional digits would have make only tiny changes to the recommended key sizes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
経験報告からKを解くことによって、Kは約0.02であるように思われる。これは、RSAアルゴリズムの「有効鍵強度」が、式L（n）のナイーブアプリケーション（すなわち、k~1および0（1）~0の設定）によって暗示されるよりも約5または6ビットであることを意味する。Kのこれらの推定値は、表に報告されている数字にかなり安定しています。推定値は、実際の不確実性を表現するため、Kの単一の桁数に制限されています。ただし、追加の数字の影響は、推奨されるキーサイズへの小さな変更点だけをしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The factorers of RSA130 used about 1700 MYs, but they felt that this was unrealistically high for prediction purposes; by using more memory on their machines, they could have easily reduced the time to 500 MYs. Thus, the value used in preparing the table above was 500. This story does, however, underscore the difficulty in getting an accurate measure of effort. This document takes the reported effort for factoring RSA155 as being the most accurate measure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA130の要素は約1700の私の私のマイですが、彼らは予測目的では非現実的に高かったと感じました。彼らのマシンでより多くのメモリを使用することによって、彼らは500の私の時間に時間を簡単に減らすことができました。したがって、上記の表を準備するのに使用される値は500であった。しかしながら、この物語は正確な努力を得ることの困難性を強調している。この文書は、RSA155が最も正確な尺度として因数分解するための報告された努力を取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a result of examining the empirical data, it appears that the L(n) formula can be used with the o(1) term set to 0 and with k set to 0.02 when talking about factoring numbers in the range of 100 to 200 decimal digits. The equation becomes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
経験的なデータを調べた結果として、L（n）式は0（1）式に設定され、kではkでkを使用することができ、10進数の10進数の範囲内のファクタリング数について話すときに0.02に設定されているように思われる数字式は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      L(n) =  0.02 * e^(1.92 * cubrt(ln(n) * (ln(ln(n)))^2))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To convert L(n) from simple math instructions to MYs, divide by 3*10^13. The equation for the number of MYs needed to factor an integer n then reduces to:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単純な数学指示からL（n）をMYSに変換するには、3 * 10 ^ 13で除算します。整数nを率するのに必要なMYSの数の方程式は、次のことを減らします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      MYs = 6 * 10^(-16) * e^(1.92 * cubrt(ln(n) * (ln(ln(n)))^2))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With what confidence can this formula be used for predicting the difficulty of factoring slightly larger numbers? The answer is that it should be a close upper bound, but each factorization effort is usually marked by some improvement in the algorithms or their implementations that makes the running time somewhat shorter than the formula would indicate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この式がわずかに大きい数になるのを予測するために、この式を使用することができるのはどのような信頼を使用することができますか？答えはそれが近い上限になるべきですが、それぞれの因数分解の取り組みは通常、アルゴリズムのいくつかの改善またはそれらの実装によって、実行時間を数式よりもやや短くします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3--Pollards-rho-method">
2.3. Pollard&#39;s rho method
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. ポラードのRhoメソッド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In Diffie-Hellman exchanges, there is a second attack, Pollard&#39;s rho method [POL78]. The algorithm relies on finding collisions between values computed in a large number space; its success rate is proportional to the square root of the size of the space. Because of Pollard&#39;s rho method, the search space in a DH key exchange for the key (the exponent in a g^a term), must be twice as large as the symmetric key. Therefore, to securely derive a key of K bits, an implementation must use an exponent with at least 2*K bits. See [ODL99] for more detail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Diffie-Hellmanの交換では、2番目の攻撃、PollardのRhoメソッド[POL78]があります。アルゴリズムは、大きな数のスペースで計算された値の間の衝突の検索に依存しています。その成功率はスペースのサイズの平方根に比例します。PollardのRhoメソッドのために、キーのDHキー交換の検索スペース（G ^ g ^ a項の指数）は、対称鍵の2倍の大きさでなければなりません。したがって、kビットのキーを確実に導出するために、実装は少なくとも2 * kビットの指数を使用しなければならない。詳しくは、[ODL99]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the Diffie-Hellman key exchange is done using an elliptic curve method, the NFS methods are of no avail. However, the collision method is still effective, and the need for an exponent (called a multiplier in EC&#39;s) with 2*K bits remains. The modulus used for the computation can also be 2*K bits, and this will be substantially smaller than the modulus needed for modular exponentiation methods as the desired security level increases past 64 bits of brute-force attack resistance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Diffie-Hellmanキー交換が楕円曲線方式を使用して行われると、NFSメソッドは無効です。しかしながら、衝突方法は依然として有効であり、2 * kビットを有する指数（ECの乗数と呼ばれる）の必要性は残る。計算に使用されるモジュラスは2 * kビットでもあり得、これは所望のセキュリティレベルが64ビットのブルートフォース攻撃抵抗を過去に増加するにつれて、モジュール式指数法に必要な弾性率よりも実質的に小さくなる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One might ask, how can you compare the number of computer instructions really needed for a discrete logarithm attack to the number needed to search the keyspace of a cipher? In comparing the efforts, one should consider what a &#34;basic operation&#34; is. For brute force search of the keyspace of a symmetric encryption algorithm like DES, the basic operation is the time to do a key setup and the time to do one encryption. For discrete logs, the basic operation is a modular squaring. The log of the ratio of these two operations can be used as a &#34;normalizing factor&#34; between the two kinds of computations. However, even for very large moduli (16K bits), this factor amounts to only a few bits of extra effort.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
尋ねるかもしれません、暗号のキースペースの検索に必要な数への離散対数攻撃に必要なコンピュータの指示の数をどのように比較することができますか？努力を比較する際には、「基本操作」が何であるかを考慮する必要があります。DESのような対称暗号化アルゴリズムのキースペースのブルートフォース検索のために、基本操作はキー設定と1つの暗号化を実行する時刻です。離散ログの場合、基本操作はモジュラー式の四角線です。これら2つの操作の比率のログは、2種類の計算の間の「正規化係数」として使用することができる。ただし、非常に大きなモジュリ（16Kビット）でも、この要因は追加の努力のわずか数ビットになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-4--Limits-of-large-memory-and-many-machines">
2.4. Limits of large memory and many machines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4. 大型メモリと多数の機械の限界
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Robert Silverman has examined the question of when it will be practical to factor RSA moduli larger than 512 bits. His analysis is based not only on the theoretical number of operations, but it also includes expectations about the availability of actual machines for performing the work (this document is based only on theoretical number of operations). He examines the question of whether or not we can expect there be enough machines, memory, and communication to factor a very large number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Robert Silvermanは、512ビットより大きいRSAモジュラスを要因するために実用的になるときの問題を検討しました。彼の分析は理論的な操作数だけでなく、作業を実行するための実際のマシンの可用性についての期待も含まれています（この文書は理論的な操作数にのみ基づいています）。彼は私たちが十分な機械、記憶、そして非常に大きな数を要因するのを期待できるかどうかという問題を調べます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The best factoring methods need a lot of random access memory for collecting data relations (sieving) and a critical final step that does a row reduction on a large matrix. The memory requirements are related to the size of the number being factored (or subjected to discrete logarithm solution). Silverman [SILIEEE99] [SIL00] has argued that there is a practical limit to the number of machines and the amount of RAM that can be brought to bear on a single problem in the foreseeable future. He sees two problems in attacking a 1024-bit RSA modulus: the machines doing the sieving will need 64-bit address spaces and the matrix row reduction machine will need several terabytes of memory. Silverman notes that very few 64-bit machines that have the 170 gigabytes of memory needed for sieving have been sold. Nearly a billion such machines are necessary for the sieving in a reasonable amount of time (a year or two).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
最良の因数分解方法は、データ関係を集めるための多くのランダムアクセスメモリと、大きなマトリックス上の行の低減を行う重要な最終ステップとを必要とする。メモリ要件は、因数分解されている数字のサイズ（または離散対数ソリューションにさらされています）に関連しています。Silverman [Silieee99] [SIL00]は、予見可能な将来に単一の問題に取り組むことができる機械の数やRAMの量に実用的な制限があると主張しました。彼は1024ビットRSAモジュラスを攻撃する際に2つの問題を見ています。篩分けを行うマシンは64ビットアドレススペースを必要とし、行列列の削減機は数テラバイトのメモリを必要とします。Silvermanは、篩い分けに必要な170ギガバイトのメモリを持つ64ビットマシンがほとんどありません。妥当な時間（年または2）の篩い分けのために、約10億のそのような機械が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Silverman&#39;s conclusion, based on the history of factoring efforts and Moore&#39;s Law, is that 1024-bit RSA moduli will not be factored until about 2037. This implies a much longer lifetime to RSA keys than the theoretical analysis indicates. He argues that predictions about how many machines and memory modules will be available can be with great confidence, based on Moore&#39;s Law extrapolations and the recent history of factoring efforts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シルバーマンの結論は、因子とムーアの法則の歴史に基づいて、1024ビットRSAモジュリが約2037年まで因りながら著しくなることはありません。彼は、ムーアの法外推外推定と最近の施設の歴史に基づいて、何台のマシンとメモリモジュールが利用可能になるかについての予測を主張しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One should give the practical considerations a great deal of weight, but in a risk analysis, the physical world is less predictable than trend graphs would indicate. In considering how much trust to put into the inability of the computer industry to satisfy the voracious needs of factorers, one must have some insight into economic considerations that are more complicated than the mathematics of factoring. The demand for computer memory is hard to predict because it is based on applications: a &#34;killer app&#34; might come along any day and send the memory industry into a frenzy of sales. The number of processors available on desktops may be limited by the number of desks, but very capable embedded systems account for more processor sales than desktops. As embedded systems absorb networking functions, it is not unimaginable that millions of 64-bit processors with at least gigabytes of memory will pervade our environment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実用的な考慮事項を大量の重さに与えるべきですが、リスク分析では、トレンドグラフよりも物理的な世界はあまり予測できません。コンピュータ業界が貪欲な要素を満足させることができないという信頼をどのくらい信頼しているかを考えると、因数分解の数学よりも複雑である経済的考察に関するいくつかの洞察がなければならない。コンピュータメモリの需要は、アプリケーションに基づいているので予測するのは困難です。「キラーアプリ」はいつでも来て、メモリ業界を販売の狂乱に送ります。デスクトップ上で利用可能なプロセッサの数は、デスクの数によって制限されるかもしれませんが、デスクトップよりも多くのプロセッサの販売のための非常に有能な組み込みシステムを占めています。組み込みシステムがネットワーキング機能を吸収するにつれて、少なくともギガバイブのメモリを持つ何百万もの64ビットプロセッサが私たちの環境に偏っていることは想像できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The bottom line on this is that the key length recommendations predicted by theory may be overly conservative, but they are what we have used for this document. This question of machine availability is one that should be reconsidered in light of current technology on a regular basis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これに関する一番下の行は、理論によって予測されたキー長の推奨事項が過度に保守的であるかもしれないということですが、それらはこの文書に使用したものです。機械可用性のこの問題は、現在の技術に照らして定期的に再検討されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-5--Special-purpose-machines">
2.5. Special purpose machines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.5. 特別な目的の機械
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In August of 2003, a design for a special-purpose &#34;sieving machine&#34; (TWIRL) surfaced [Shamir2003], and it substantially changed the cost estimates for factoring numbers up to 1024 bits in size. By applying many high-speed VLSI components in parallel, such a machine might be able to carry out the sieving of 512-bit numbers in 10 minutes at a cost of $10K for the hardware. A larger version could sieve a 1024- bit number in one year for a cost of $10M. The work cites some advances in approaches to the row reduction step in concluding that the security of 1024-bit RSA moduli is doubtful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2003年8月には、専用の「ふるい機械」（Twirl）の展示品[Shamir2003]のための設計があり、それは最大1024ビットのサイズまでの因数分数のためのコスト推定値を実質的に変えました。多くの高速VLSIコンポーネントを並列に適用することによって、そのような機械は、ハードウェアのために10分のコストで10分で512ビット数の篩分けを実行することができるかもしれません。より大きなバージョンは1年間で1024ビット数を濃くする可能性があります。この作品は、1024ビットRSA Moduliのセキュリティが疑わしいことを締めくくり、列車の削減ステップへのアプローチの進歩を求めています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The estimates for the time and cost for factoring 512-bit and 1024- bit numbers correspond to a speed-up factor of about 2 million over what can be achieved with commodity processors of a few years ago.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
512ビットおよび1024ビットの数値を因数導するための時間と費用の推定値は、数年前の商品プロセッサで達成できるものよりも約200万のスピードアップ係数に対応しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Compute-Time-for-the-Algorithms">
3. Compute Time for the Algorithms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. アルゴリズムの計算時間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes how long it takes to use the algorithms to perform key exchanges. Again, it is important to consider the increased time it takes to exchange symmetric keys when increasing the length of public keys. It is important to avoid choosing unfeasibly long public keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、アルゴリズムを使用してキー交換を実行するのにかかる時間について説明します。繰り返しますが、公開鍵の長さを増やすと、対称キーを交換するのにかかる時間を考慮することが重要です。実行不可能な公開鍵を選択することを避けることが重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--Diffie-Hellman-Key-Exchange">
3.1. Diffie-Hellman Key Exchange
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Diffie-Hellman Key Exchange
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Diffie-Hellman key exchange is done with a finite cyclic group G with a generator g and an exponent x. As noted in the Pollard&#39;s rho method section, the exponent has twice as many bits as are needed for the final key. Let the size of the group G be p, let the number of bits in the base 2 representation of p be j, and let the number of bits in the exponent be K.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Diffie-Hellman鍵交換は、発電機Gと指数xを有する有限の巡回グループGを用いて行われる。PollardのRHOメソッドセクションで述べたように、指数は最終キーに必要な2倍のビットを持ちます。グループGのサイズをPにし、基部2のビット数をPと表現し、指数のビット数をKにする。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In doing the operations that result in a shared key, a generator is raised to a power. The most efficient way to do this involves squaring a number K times and multiplying it several times along the way. Each of the numbers has j/w computer words in it, where w is the number of bits in a computer word (today that will be 32 or 64 bits). A naive assumption is that you will need to do j squarings and j/2 multiplies; fortunately, an efficient implementation will need fewer (NB: for the remainder of this section, n represents j/w).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有キーになる操作を実行すると、発電機が電源に上げられます。これを行うための最も効率的な方法は、数k回倍を帯びていて、その途中で数回掛けることを含みます。各数字にはJ / Wコンピュータの単語があります。ここで、Wはコンピューターワード内のビット数（今日32または64ビット）です。素朴な仮定は、Jの倍数とJ / 2の乗数を行う必要があることです。幸いなことに、効率的な実装はより少ない（NB：このセクションの残りの部分については、nはJ / Wを表す）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A squaring operation does not need to use quite as many operations as a multiplication; a reasonable estimate is that squaring takes .6 the number of machine instructions of a multiply. If one prepares a table ahead of time with several values of small integer powers of the generator g, then only about one fifth as many multiplies are needed as the naive formula suggests. Therefore, one needs to do the work of approximately .8*K multiplies of n-by-n word numbers. Further, each multiply and squaring must be followed by a modular reduction, and a good assumption is that it is as hard to do a modular reduction as it is to do an n-by-n word multiply. Thus, it takes K reductions for the squarings and .2*K reductions for the multiplies. Summing this, the total effort for a Diffie-Hellman key exchange with K bit exponents and a modulus of n words is approximately 2*K n-by-n-word multiplies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
二乗操作は、乗算と非常に多くの操作を使用する必要はありません。合理的な見積もりは、乗算の機械命令の数の数。ジェネレータGの小さい整数電力のいくつかの値を使用して前方にテーブルを準備すると、ナイーブ式が示唆されるように多くの乗算が必要とされる。したがって、約0.8 * k単語数の約.8 * kの加工を行う必要がある。さらに、各乗算および二乗の後にモジュール式の減少を続ける必要があり、良好な仮定は、それがN×n単語を乗算することができるのでモジュール式の減少を行うのが難しいということである。したがって、それは乗算のためのkの減少と.2 * k乗数の減少を取ります。これを合計すると、kビット指数とN個の単語の弾性率とのDiffie-Hellman鍵交換の総労力は、約2 * k n×ワード乗数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For 32-bit processors, integers that use less than about 30 computer words in their representation require at least n^2 instructions for an n-by-n-word multiply. Larger numbers will use less time, using Karatsuba multiplications, and they will scale as about n^(1.58) for larger n, but that is ignored for the current discussion. Note that 64-bit processors push the &#34;Karatsuba cross-over&#34; number out to even more bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
32ビットプロセッサの場合、それらの表現において約30個未満のコンピュータワードを使用する整数は、n行単位の乗算に対して少なくともn ^ 2命令を必要とする。karatsuba乗算を使用して、より大きな数の時間を使用し、それらはより大きなnのために約n ^（1.58）として拡張されますが、それは現在の議論では無視されます。64ビットプロセッサは、「カラツバクロスオーバー」をさらにビットにプッシュします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic result is: if you double the size of the Diffie-Hellman modular exponentiation group, you quadruple the number of operations needed for the computation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本的な結果は次のとおりです.Diffie-Hellmanモジュラー指数指数グループのサイズを2倍にする場合は、計算に必要な操作の数を4重ねます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1-1--Diffie-Hellman-with-elliptic-curve-groups">
3.1.1. Diffie-Hellman with elliptic curve groups
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1. 楕円曲線グループを持つDiffie-Hellman
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the ratios for computation effort as a function of modulus size hold even if you are using an elliptic curve (EC) group for Diffie-Hellman. However, for equivalent security, one can use smaller numbers in the case of elliptic curves. Assume that someone has chosen an modular exponentiation group with an 2048 bit modulus as being an appropriate security measure for a Diffie-Hellman application and wants to determine what advantage there would be to using an EC group instead. The calculation is relatively straightforward, if you assume that on the average, it is about 20 times more effort to do a squaring or multiplication in an EC group than in a modular exponentiation group. A rough estimate is that an EC group with equivalent security has about 200 bits in its representation. Then, assuming that the time is dominated by n-by-n-word operations, the relative time is computed as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Diffie-Hellmanの楕円曲線（EC）グループを使用していても、モジュラスサイズの関数としての計算努力の比率は保持されています。ただし、同等のセキュリティの場合、楕円曲線の場合は小さい数を使用できます。誰かがDiffie-Hellmanアプリケーションのための適切なセキュリティ対策として2048ビットモジュラスを持つモジュラー指数グループを選んだと仮定し、代わりにECグループを使用することがあるかを決定したいと仮定します。計算は比較的簡単です、あなたが平均的にそれを想定すると、モジュラー指数グループよりもECグループで二乗または乗算をするのは約20倍の努力です。大まかな見積もりは、同等のセキュリティを持つECグループに、その表現で約200ビットがあります。その後、時間がN×Wワード演算によって支配されていると仮定すると、相対時間は次のように計算される。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      ((2048/200)^2)/20 ~= 5
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
showing that an elliptic curve implementation should be five times as fast as a modular exponentiation implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
楕円曲線の実装がモジュール式の指数の実装の5倍になることを示す。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--RSA-encryption-and-decryption">
3.2. RSA encryption and decryption
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. RSA暗号化と復号化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assume that an RSA public key uses a modulus with j bits; its factors are two numbers of about j/2 bits each. The expected computation time for encryption and decryption are different. As before, we denote the number of words in the machine representation of the modulus by the symbol n.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA公開鍵がJビットとモジュラスを使用すると仮定する。その要因はそれぞれ約J / 2ビットの2ビットの2つの数です。暗号化と復号化の期待される計算時間は異なります。前述のように、我々は、シンボルnによる弾性率の機械表現における単語の数を示す。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most implementations of RSA use a small exponent for encryption. An encryption may involve as few as 16 squarings and one multiplication, using n-by-n-word operations. Each operation must be followed by a modular reduction, and therefore the time complexity is about 16*(.6 + 1) + 1 + 1 ~= 28 n-by-n-word multiplies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSAのほとんどの実装は暗号化のために小さな指数を使用します。暗号化は、n個のNワード操作を使用して、ほぼ16のスクエアと1つの乗算を含み得る。各操作の後にモジュール式の減少を続ける必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA decryption must use an exponent that has as many bits as the modulus, j. However, the Chinese Remainder Theorem applies, and all the computations can be done with a modulus of only n/2 words and an exponent of only j/2 bits. The computation must be done twice, once for each factor. The effort is equivalent to 2*(j/2) (n/2 by n/2)- word multiplies. Because multiplying numbers with n/2 words is only 1/4 as difficult as multiplying numbers with n words, the equivalent effort for RSA decryption is j/4 n-by-n-word multiplies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA復号化は、モジュラスと同じくらい多くのビットを持つ指数を使用する必要があります。ただし、中国の剰余定理が適用され、すべての計算はN / 2ワードのモジュラスとJ / 2ビットの指数で行うことができます。各要因に対して1回、計算を2回行う必要があります。努力は2 *（j / 2）（N / 2によるN / 2）に相当する - ワード乗数です。N / 2ワードとの数値を乗算することは、N個の単語で数を乗算するのと同じくらい難しいため、RSA復号化に対する同等の努力はJ / 4 n-n-word乗数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If you double the size of the modulus for RSA, the n-by-n multiplies will take four times as long. Further, the decryption time doubles because the exponent is larger. The overall scaling cost is a factor of 4 for encryption, a factor of 8 for decryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSAのモジュラスのサイズを2倍にすると、n by-nの乗数は長い間4倍かかります。また、指数が大きいため、復号化時間が2倍になる。全体的なスケーリングコストは、暗号化のための4の要因であり、復号化のための8倍です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3--Real-world-examples">
3.3. Real-world examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. 実世界の例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To make these numbers more real, here are a few examples of software implementations run on hardware that was current as of a few years before the publication of this document. The examples are included to show rough estimates of reasonable implementations; they are not benchmarks. As with all software, the performance will depend on the exact details of specialization of the code to the problem and the specific hardware.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの数をより本物にするために、この文書の出版の数年前の数年前のハードウェア上で実行されるソフトウェア実装のいくつかの例がいくつかあります。例は、合理的な実装の大まかな推定値を示すために含まれています。彼らはベンチマークではありません。すべてのソフトウェアと同様に、パフォーマンスは、問題に対するコードの専門化の正確な詳細と特定のハードウェアによって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The best time informally reported for a 1024-bit modular exponentiation (the decryption side of 2048-bit RSA), is 0.9 ms (about 450,000 CPU cycles) on a 500 MHz Itanium processor. This shows that newer processors are not losing ground on big number operations; the number of instructions is less than a 32-bit processor uses for a 256-bit modular exponentiation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1024ビットのモジュラー指数（2048ビットRSAの復号化側）について非公式に報告された最善の時期は、500 MHzのItaniumプロセッサ上の0.9 ms（約45万CPUサイクル）です。これは、新しいプロセッサが大きな数の操作で地面を失っていないことを示しています。命令の数は、256ビットのモジュール指数に対して32ビットプロセッサが使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For less advanced processors timing, the following two tables (computed by Tero Monenen at SSH Communications) for modular exponentiation, such as would be done in a Diffie-Hellman key exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高度なプロセッサのタイミングでは、次の2つのテーブル（SSH通信でTero Monenenによって計算された）は、Diffie-Hellman Key Exchangeで行われるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Celeron 400 MHz; compiled with GNU C compiler, optimized, some platform specific coding optimizations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Celeron 400 MHz。GNU Cコンパイラでコンパイルされ、最適化されたプラットフォーム固有のコーディングの最適化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
group modulus exponent time type size size mod 768 ~150 18 msec mod 1024 ~160 32 msec mod 1536 ~180 82 msec ecn 155 ~150 35 msec ecn 185 ~200 56 msec
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
グループモジュラス指数タイムタイプサイズサイズMOD 768~150 18 MSEC MOD 1024~160 32 MSEC MOD 1536~180 82ミリ秒ECN 155~150 35ミリ秒ECN 185~200 56ミリ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The group type is from [RFC2409] and is either modular exponentiation (&#34;mod&#34;) or elliptic curve (&#34;ecn&#34;). All sizes here and in subsequent tables are in bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
グループタイプは[RFC2409]からのもので、モジュラー指数（「MOD」）または楕円曲線（「ECN」）のいずれかです。こちらと後続のテーブルのすべてのサイズはビットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alpha 500 MHz compiled with Digital&#39;s C compiler, optimized, no platform specific code:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alpha 500 MHzはデジタルのCコンパイラでコンパイルされ、最適化されたプラットフォーム固有のコードなしです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
group modulus exponent time type size size mod 768 ~150 12 msec mod 1024 ~160 24 msec mod 1536 ~180 59 msec ecn 155 ~150 20 msec ecn 185 ~200 27 msec
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
グループモジュラス指数タイムタイプサイズサイズMOD 768~150 12 MSEC MOD 1024~160 24 MSEC MOD 1536~180 59 MSEC ECN 155~150 20 MSEC ECN 185~200 27ミリ秒
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following two tables (computed by Eric Young) were originally for RSA signing operations, using the Chinese Remainder representation. For ease of understanding, the parameters are presented here to show the interior calculations, i.e., the size of the modulus and exponent used by the software.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の2つのテーブル（Eric Youngによって計算された）は、中国の残りの表現を使用して、もともとRSA署名操作のためのものでした。理解を容易にするために、そのパラメータは、内部計算、すなわちソフトウェアによって使用されるモジュラスおよび指数のサイズを示すためにここに示されている。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Dual Pentium II-350:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デュアルPentium II-350：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 equiv equiv equiv modulus exponent time size size 256 256 1.5 ms 512 512 8.6 ms 1024 1024 55.4 ms 2048 2048 387 ms
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
等高大な等高線モジュラス指数タイムサイズサイズ256 256 1.5 MS 512 512 8.6 MS 1024 1024 55.4 MS 2048 2048 387 MS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alpha 264 600mhz:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alpha 264 600MHz：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 equiv equiv equiv modulus exponent time size size 512 512 1.4 ms
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
等高大な等価モジュラス指数タイムサイズサイズ512 512 1.4ミリ秒
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recent chips that accelerate exponentiation can perform 1024-bit exponentiations (1024 bit modulus, 1024 bit exponent) in about 3 milliseconds or less.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
遠隔を加速する最近のチップは、約3ミリ秒以下で1024ビットの範囲（1024ビットモジュラス、1024ビット指数）を実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Equivalences-of-Key-Sizes">
4. Equivalences of Key Sizes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. キーサイズの等価情報
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In order to determine how strong a public key is needed to protect a particular symmetric key, you first need to determine how much effort is needed to break the symmetric key. Many Internet security protocols require the use of TripleDES for strong symmetric encryption, and it is expected that the Advanced Encryption Standard (AES) will be adopted on the Internet in the coming years. Therefore, these two algorithms are discussed here. In this section, for illustrative purposes, we will implicitly assume that the system security requirement is 112 bits; this doesn&#39;t mean that 112 bits is recommended. In fact, 112 bits is arguably too strong for any practical purpose. It is used for illustration simply because that is the upper bound on the strength of TripleDES.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
特定の対称鍵を保護するためにどれほど強いかを判断するために、まず対称鍵を破るために必要な努力を判断する必要があります。多くのインターネットセキュリティプロトコルには、強い対称暗号化のためのトリプレープの使用が必要であり、今後数年間で高度な暗号化規格（AES）がインターネット上で採用されると予想されます。したがって、これら2つのアルゴリズムについてはここで説明します。このセクションでは、説明のために、システムセキュリティ要件が112ビットであると暗黙的に想定します。これは112ビットが推奨されるという意味ではありません。実際、112ビットは実用的な目的のために間違いなく強力なものです。それは単に三重版の強さの上限であるという理由だけで説明に使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If one could simply determine the number of MYs it takes to break TripleDES, the task of computing the public key size of equivalent strength would be easy. Unfortunately, that isn&#39;t the case here because there are many examples of DES-specific hardware that encrypt faster than DES in software on a standard CPU. Instead, one must determine the equivalent cost for a system to break TripleDES and a system to break the public key protecting a TripleDES key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トリプレープを分割するのにかかるMyの数を単純に決定できる場合は、同等の強度の公開鍵サイズを計算する作業が簡単です。残念ながら、標準のCPU上のソフトウェアのDESよりも速く暗号化するDES固有のハードウェアの例がたくさんあるため、これは当てはまりません。代わりに、TripleDesキーを保護する公開鍵を壊すためのシステムの同等のコストを決定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In 1998, the Electronic Frontier Foundation (EFF) built a DES-cracking machine [GIL98] for US$130,000 that could test about 1e11 DES keys per second (additional money was spent on the machine&#39;s design). The machine&#39;s builders fully admit that the machine is not well optimized, and it is estimated that ten times the amount of money could probably create a machine about 50 times as fast. Assuming more optimization by guessing that a system to test TripleDES keys runs about as fast as a system to test DES keys, so approximately US$1 million might test 5e12 TripleDES keys per second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1998年に、電子フロンティア財団（EFF）は、1秒あたり1E11 DESキーについてテストすることができる130,000ドルでDes-Cracking Machine [GIL98]を構築しました（追加のお金は機械の設計に費やされました）。マシンのビルダーは、機械がうまく最適化されていないことを完全に認めており、お金の量の10倍の量はおそらく約50倍の機械を早く作成できると推定されています。TripleDesキーをテストするシステムがDESキーをテストするためのシステムと同じくらい速く実行されることを推測することで、毎秒約1百万ドルの3倍のトリプレッジキーをテストすることができる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In case your adversaries are much richer than EFF, you may want to assume that they have US$1 trillion, enough to test 5e18 keys per second. An exhaustive search of the effective TripleDES space of 2^112 keys with this quite expensive system would take about 1e15 seconds or about 33 million years. (Note that such a system would also need 2^60 bytes of RAM [MH81], which is considered free in this calculation). This seems a needlessly conservative value. However, if computer logic speeds continue to increase in accordance with Moore&#39;s Law (doubling in speed every 1.5 years), then one might expect that in about 50 years, the computation could be completed in only one year. For the purposes of illustration, this 50 year resistance against a trillionaire is assumed to be the minimum security requirement for a set of applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あなたの敵対者がEFFよりもずっと豊かである場合は、1秒あたり5E18キーをテストするのに十分な1兆ドルを持っていると仮定したいと思うかもしれません。この非常に高価なシステムを持つ2 ^ 112キーの有効三重板空間の徹底的な検索は、約1e15秒または約3300万年かかります。（このようなシステムでも2 ^ 60バイトのRAM [MH81]が必要であって、この計算では自由に考えられます）。これは不必要に保守的な価値のようです。ただし、コンピュータのロジックの速度がムーアの法律（1.5歳ごとにスピードを倍増させる）に従って増加し続けると、約50年で、計算は1年に完了することができると予想される場合があります。説明の目的のために、この50年間の抵抗は、1組のアプリケーションの最小限のセキュリティ要件であると仮定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If 112 bits of attack resistance is the system security requirement, then the key exchange system for TripleDES should have equivalent difficulty; that is to say, if the attacker has US$1 trillion, you want him to spend all his money to buy hardware today and to know that he will &#34;crack&#34; the key exchange in not less than 33 million years. (Obviously, a rational attacker would wait for about 45 years before actually spending the money, because he could then get much better hardware, but all attackers benefit from this sort of wait equally.) It is estimated that a typical PC CPU of just a few years ago can generate over 500 MIPs and could be purchased for about US$100 in quantity; thus you get more than 5 MIPs/US$. Again, this number doubles about every 18 months. For one trillion US dollars, an attacker can get 5e12 MIP years of computer instructions on that recent-vintage hardware. This figure is used in the following estimates of equivalent costs for breaking key exchange systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
112ビットの攻撃抵抗がシステムセキュリティ要件である場合、3倍の主要な交換システムは同等の困難を持つべきです。つまり、攻撃者が1兆ドルを持っている場合、あなたは彼が今日ハードウェアを買うためにすべてのお金を使って、彼が3300万年以上の鍵交換を「亀裂」することを知っています。（明らかに、Rational Interacterは、実際にお金を費やす前に約45年間待つでしょうが、すべての攻撃者はこの種の待ち合わせから恩恵を受けることができます。）数年前に500 mingを超えることができ、数量で約100米ドルで購入することができます。したがって、あなたは5ミップ以上/ $ $を得る。繰り返しますが、この数は18ヶ月ごとに倍増します。1兆米ドルのために、攻撃者はその最近のビンテージハードウェア上の5E12ミップのコンピュータ指示を得ることができます。この図は、キー交換システムを破壊するための等価コストの以下の推定で使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--Key-equivalence-against-special-purpose-brute-force-hardware">
4.1. Key equivalence against special purpose brute force hardware
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 特別な目的のブルートフォースハードウェアに対する鍵と同等のもの
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the trillionaire attacker is to use conventional CPU&#39;s to &#34;crack&#34; a key exchange for a 112 bit key in the same time that the special purpose machine is spending on brute force search for the symmetric key, the key exchange system must use an appropriately large modulus. Assume that the trillionaire performs 5e12 MIPs of instructions per year. Use the following equation to estimate the modulus size to use with RSA encryption or DH key exchange:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Trillionaireの攻撃者が従来のCPUを使用する場合、特別目的機械が対称鍵のブルートフォース検索に支出しているのと同時に112ビットキーのためのキー交換を「亀裂」することである場合、鍵交換システムは適切に大きく使用されなければならない係数。TRILILINAIEAREは年間5E12の指示を行うとします。RSA暗号化またはDH鍵交換で使用するモジュラスサイズを推定するには、次の式を使用してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      5*10^33 = (6*10^-16)*e^(1.92*cubrt(ln(n)*(ln(ln(n)))^2))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Solving this approximately for n yields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これをほぼnの場合に解く：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      n = 10^(625) = 2^(2077)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, assuming similar logic speeds and the current efficiency of the number field sieve, moduli with about 2100 bits will have about the same resistance against attack as an 112-bit TripleDES key. This indicates that RSA public key encryption should use a modulus with around 2100 bits; for a Diffie-Hellman key exchange, one could use a slightly smaller modulus, but it is not a significant difference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、同様の論理速度と数フィールド篩の現在の効率を仮定すると、約2100ビットのモジュリは112ビットの三重演奏キーとしての攻撃に対してほぼ同じ抵抗を持ちます。これは、RSA公開鍵暗号化が約2100ビットのモジュラスを使用する必要があることを示しています。Diffie-Hellman鍵交換のために、わずかに小さいモジュラスを使用することができますが、それは大きな違いではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2-Key-equivalence-against-conventional-CPU-brute-force-attack">
4.2 Key equivalence against conventional CPU brute force attack
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2 従来のCPUブルートフォース攻撃に対する鍵の等価性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An alternative way of estimating this assumes that the attacker has a less challenging requirement: he must only &#34;crack&#34; the key exchange in less time than a brute force key search against the symmetric key would take with general purpose computers. This is an &#34;apples-to-apples&#34; comparison, because it assumes that the attacker needs only to have computation donated to his effort, not built from a personal or national fortune. The public key modulus will be larger than the one in 4.1, because the symmetric key is going to be viable for a longer period of time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これを推定する代替方法は、攻撃者が困難な要件を少なくしていることを前提としています。これは「りんごの対決」の比較です。対称鍵は長期間実行可能になるため、公開鍵モジュラスは4.1のものよりも大きくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assume that the number of CPU instructions to encrypt a block of material using TripleDES is 300. The estimated number of computer instructions to break 112 bit TripleDES key:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トリプレープを使用して材料ブロックを暗号化するためのCPU命令の数は300です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      300 * 2^112
      = 1.6 * 10^(36)
      = .02*e^(1.92*cubrt(ln(n)*(ln(ln(n)))^2))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Solving this approximately for n yields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これをほぼnの場合に解く：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      n = 10^(734) = 2^(2439)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, for general purpose CPU attacks, you can assume that moduli with about 2400 bits will have about the same strength against attack as an 112-bit TripleDES key. This indicates that RSA public key encryption should use a modulus with around 2400 bits; for a Diffie-Hellman key exchange, one could use a slightly smaller modulus, but it not a significant difference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、汎用のCPU攻撃の場合、約2400ビットのModuliが112ビットのトリプレッジキーとしての攻撃に対して同じ強度を持つようなものになると想定できます。これは、RSA公開鍵暗号化が約2400ビットのモジュラスを使用する必要があることを示しています。Diffie-Hellman鍵交換のために、わずかに小さいモジュラスを使用することができますが、それは大きな違いはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that some authors assume that the algorithms underlying the number field sieve will continue to get better over time. These authors recommend an even larger modulus, over 4000 bits, for protecting a 112-bit symmetric key for 50 years. This points out the difficulty of long-term cryptographic security: it is all but impossible to predict progress in mathematics and physics over such a long period of time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかの著者らは、数値フィールドの篩の基礎となるアルゴリズムが経時的に良くなると仮定していることに注意してください。これらの作者は、112ビットの対称鍵を50年間保護するために、4000ビット以上でさえもさらに大きなモジュラスを推奨します。これは長期暗号化セキュリティの難しさを指摘しています：それはそのような長期間にわたる数学と物理学の進歩を予測するのは不可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3--A-One-Year-Attack-80-bits-of-strength">
4.3. A One Year Attack: 80 bits of strength
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. 1年間の攻撃：80ビットの強み
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assuming a trillionaire spends his money today to buy hardware, what size key exchange numbers could he &#34;crack&#34; in one year? He can perform 5*e12 MYs of instructions, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トレリネアが今日ハードウェアを購入するために今日のお金を費やすと仮定して、1年間で彼が「亀裂」されたのはどのようなサイズの鍵交換数にかかっていましたか。彼は5 * E12の指示を実行することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      3*10^13 * 5*10^12 = .02*e^(1.92*cubrt(ln(n)*(ln(ln(n)))^2))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Solving for an approximation of n yields
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
N降伏の近似のための解決
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      n = 10^(360) = 2^(1195)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is about as many operations as it would take to crack an 80-bit symmetric key by brute force.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、ブルートフォースで80ビット対称キーをクラックするのにかかるものと同じくらい多くの操作です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, for protecting data that has a secrecy requirement of one year against an incredibly rich attacker, a key exchange modulus with about 1200 bits protecting an 80-bit symmetric key is safe even against a nation&#39;s resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、信じられないほど豊かな攻撃者に対して1年の秘密の要件を持つデータを保護するために、80ビットの対称鍵を保護する約1200ビットの鍵交換率は、国の資源に対しても安全です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-4--Key-equivalence-for-other-ciphers">
4.4. Key equivalence for other ciphers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. 他の暗号のための鍵の等価性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Extending this logic to the AES is straightforward. For purposes of estimation for key searching, one can think of the 128-bit AES as being at least 16 bits stronger than TripleDES but about three times as fast. The time and cost for a brute force attack is approximately 2^(16) more than for TripleDES, and thus, under the assumption that 128 bits of strength is the desired security goal, the recommended key exchange modulus size is about 700 bits longer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このロジックをAESに拡張することは簡単です。主な検索の推定の目的のために、128ビットAESを3倍よりも少なくとも16ビット以上であると考えることができますが、約3倍速いです。ブルートフォース攻撃の時間と費用は、3倍以上のほぼ2 ^（16）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If it is possible to design hardware for AES cracking that is considerably more efficient than hardware for DES cracking, then (again under the assumption that the key exchange strength must match the brute force effort) the moduli for protecting the key exchange can be made smaller. However, the existence of such designs is only a matter of speculation at this early moment in the AES lifetime.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AESクラッキングのためのハードウェアを設計することが可能であれば、（再び鍵交換強度がブルート力の取り組みと一致しなければならないと仮定して）主要な交換を保護するためのモジュリを小さくすることができる。。しかしながら、そのような設計の存在は、AES寿命のこの初期の瞬間における憶測の問題だけである。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The AES ciphers have key sizes of 128 bits up to 256 bits. Should a prudent minimum security requirement, and thus the key exchange moduli, have similar strengths? The answer to this depends on whether or not one expect Moore&#39;s Law to continue unabated. If it continues, one would expect 128 bit keys to be safe for about 60 years, and 256 bit keys would be safe for another 400 years beyond that, far beyond any imaginable security requirement. But such progress is difficult to predict, as it exceeds the physical capabilities of today&#39;s devices and would imply the existence of logic technologies that are unknown or infeasible today. Quantum computing is a candidate, but too little is known today to make confident predictions about its applicability to cryptography (which itself might change over the next 100 years!).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AES暗号は、最大256ビットの128ビットの主要サイズを持っています。慎重な最小限のセキュリティ要件、したがって鍵交換モードは同様の強みを持っているべきですか？これに対する答えは、ムーアの法則が妨害されていないかどうかによって異なります。それが続くならば、128ビットの鍵が約60年間安全になると予想され、256ビットの鍵はそれ以上の400年間安全であり、想像できるセキュリティ要件をはるかに超えています。しかし、そのような進歩は、今日の装置の身体的能力を超えているので、今日未知または実行不可能な論理技術の存在を暗示することを予測するのが困難です。量子コンピューティングは候補者ですが、今日は、暗号化への適用性について自信を持って予測するために、今日が知られています（それ自体は今後100年間で変化する可能性があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If Moore&#39;s Law does not continue to hold, if no new computational paradigms emerge, then keys of over 100 bits in length might well be safe &#34;forever&#34;. Note, however that others have come up with estimates based on assumptions of new computational paradigms emerging. For example, Lenstra and Verheul&#39;s web-based paper &#34;Selecting Cryptographic Key Sizes&#34; chooses a more conservative analysis than the one in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mooreの法則が続行しない場合は、新しい計算パラダイムが浮上しない場合、100ビット以上の長さのキーが安全な「永遠」になる可能性があります。しかしながら、新たな計算パラダイムの仮定に基づいて他の人が推定値を起こしていることに注意してください。たとえば、LenstraとVerhuulのWebベースの論文「暗号鍵サイズの選択」は、この文書の中のものよりも保存的な分析を選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
4.5. Hash functions for deriving symmetric keys from public key algorithms
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
4.5. 公開鍵アルゴリズムから対称鍵を導出するためのハッシュ関数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Diffie-Hellman algorithm results in a key that is hundreds or thousands of bits long, but ciphers need far fewer bits than that. How can one distill a long key down to a short one without losing strength?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Diffie-Hellmanアルゴリズムは、数百または数千のビットの長さのキーをもたらしますが、暗号はそれよりはるかに少ないビットを必要とします。強度を失うことなく、短いキーを短い方に蒸留するにはどうすればよいですか。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cryptographic one-way hash functions are the building blocks for this, and so long as they use all of the Diffie-Hellman key to derive each block of the symmetric key, they produce keys with sufficient strength.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号的な一方向ハッシュ関数はこれのためのビルディングブロックです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The usual recommendation is to use a good one-way hash function applied to he base material (the result of the key exchange) and to use a subset of the hash function output for the key. However, if the desired key length is greater than the output of the hash function, one might wonder how to reconcile the two.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常の推奨事項は、基本材料（鍵交換の結果）に適用された良好な一方向ハッシュ関数を使用し、キーのハッシュ関数出力のサブセットを使用することです。ただし、目的のキーの長さがハッシュ関数の出力よりも大きい場合は、2つを調整する方法が不思議になる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The step of deriving extra key bits must satisfy these requirements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
余分なキービットを導出するステップは、これらの要件を満たす必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The bits must not reveal any information about the key exchange secret
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- ビットは、鍵交換秘密に関する情報を明らかにしてはいけません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The bits must not be correlated with each other
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- ビットは互いに相関してはいけません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The bits must depend on all the bits of the key exchange secret
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- ビットは、鍵交換秘密のすべてのビットに依存する必要があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any good cryptographic hash function satisfies these three requirements. Note that the number of bits of output of the hash function is not specified. That is because even a hash function with a very short output can be iterated to produce more uncorrelated bits with just a little bit of care.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どんな良く暗号化ハッシュ関数もこれら3つの要件を満たしています。ハッシュ関数の出力ビット数は指定されていません。すぐに、非常に短い出力を持つハッシュ関数でさえ、少し少しの注意を払ってより多くの無相関ビットを生成するように繰り返される可能性があるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, SHA-1 has 160 bits of output. For deriving a key of attack resistance of 160 bits or less, SHA(DHkey) produces a good symmetric key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば、SHA  -  1は160ビットの出力を有する。160ビット以下の攻撃抵抗のキーを導出するために、SHA（DHKEY）は対称鍵を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suppose one wants a key with attack resistance of 160 bits, but it is to be used with a cipher that uses 192 bit keys. One can iterate SHA-1 as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
160ビットの攻撃抵抗を持つキーを望んでいるとしますが、192ビットキーを使用する暗号で使用されます。次のようにSHA-1を繰り返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Bits 1-160   of the symmetric key = K1 = SHA(DHkey | 0x00)
                   (that is, concatenate a single octet of value 0x00 to
                   the right side of the DHkey, and then hash)
      Bits 161-192 of the symmetric key = K2 =
                   select_32_bits(SHA(K1 | 0x01))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
But what if one wants 192 bits of strength for the cipher? Then the appropriate calculation is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、暗号に192ビットの強さを望んでいる場合はどうなりますか？それから適切な計算はです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Bits 1-160   of the symmetric key = SHA(0x00 | DHkey)
      Bits 161-192 of the symmetric key =
                   select_32_bits(SHA(0x01 | DHkey))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 (Note that in the description above, instead of concatenating a full octet, concatenating a single bit would also be sufficient.) The important distinction is that in the second case, the DH key is used for each part of the symmetric key. This assures that entropy of the DH key is not lost by iteration of the hash function over the same bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
（上記の説明では、フルオクテットを連結する代わりに、単一ビットを連結するのでも十分であることに注意してください。）重要な区別は、2番目の場合では、対称鍵の各部分にDHキーが使用されます。これにより、DHキーのエントロピーは、同じビットにわたるハッシュ関数の反復によって失われないことを保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From an efficiency point of view, if the symmetric key must have a great deal of entropy, it is probably best to use a cryptographic hash function with a large output block (192 bits or more), rather than iterating a smaller one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
効率的な観点から、対称鍵が大量のエントロピーを持たなければならない場合、小さい出力ブロック（192ビット以上）で暗号ハッシュ関数を使用するのが最善です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Newer hash algorithms with longer output (such as SHA-256, SHA-384, and SHA-512) can be used with the same level of security as the stretching algorithm described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
より長い出力（SHA-256、SHA-384、およびSHA-512など）を備えた新しいハッシュアルゴリズムは、上記のストレッチアルゴリズムと同じレベルのセキュリティで使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-6--Importance-of-randomness">
4.6. Importance of randomness
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. ランダム性の重要性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some of the calculations described in this document require random inputs; for example, the secret Diffie-Hellman exponents must be chosen based on n truly random bits (where n is the system security requirement). The number of truly random bits is extremely important to determining the strength of the output of the calculations. Using truly random numbers is often overlooked, and many security applications have been significantly weakened by using insufficient random inputs. A much more complete description of the importance of random numbers can be found in [ECS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書で説明されている計算のいくつかはランダムな入力を必要とします。たとえば、Secret Diffie-Hellmanの指数は、N個の真のランダムなビットに基づいて選択する必要があります（ここで、Nはシステムセキュリティ要件）。本当にランダムなビットの数は、計算の出力の強さを決定することが非常に重要です。真に乱数を使用することはしばしば見落とされ、そして不十分なランダム入力を使用することによって多くのセキュリティアプリケーションが大幅に弱くなってきた。乱数の重要性のはるかに完全な説明は[ECS]にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Conclusion">
5. Conclusion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 結論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this table it is assumed that attackers use general purpose computers, that the hardware is purchased in the year 2000, and that mathematical knowledge relevant to the problem remains the same as today. This is an pure &#34;apples-to-apples&#34; comparison demonstrating how the time for a key exchange scales with respect to the strength requirement. The subgroup size for DSA is included, if that is being used for supporting authentication as part of the protocol; the DSA modulus must be as long as the DH modulus, but the size of the &#34;q&#34; subgroup is also relevant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この表では、攻撃者は汎用コンピュータを使用しており、ハードウェアは2000年に購入され、その問題に関連する数学的知識は今日同じままです。これは、純粋な「りんごからりんご」の比較であり、鍵交換の時間が強度要件に関してどのようにスケールするかを示す。プロトコルの一部として認証をサポートするために使用されている場合は、DSAのサブグループサイズが含まれています。DSAモジュラスはDHモジュラスの長さでなければなりませんが、「Q」サブグループのサイズも関連性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------+-----------+--------------+--------------+
   | System      |           |              |              |
   | requirement | Symmetric | RSA or DH    | DSA subgroup |
   | for attack  | key size  | modulus size | size         |
   | resistance  | (bits)    | (bits)       | (bits)       |
   | (bits)      |           |              |              |
   +-------------+-----------+--------------+--------------+
   |     70      |     70    |      947     |     129      |
   |     80      |     80    |     1228     |     148      |
   |     90      |     90    |     1553     |     167      |
   |    100      |    100    |     1926     |     186      |
   |    150      |    150    |     4575     |     284      |
   |    200      |    200    |     8719     |     383      |
   |    250      |    250    |    14596     |     482      |
   +-------------+-----------+--------------+--------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1--TWIRL-Correction">
5.1. TWIRL Correction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. 回復した
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the TWIRL machine becomes a reality, and if there are advances in parallelism for row reduction in factoring, then conservative estimates would subtract about 11 bits from the system security column of the table. Thus, in order to get 89 bits of security, one would need an RSA modulus of about 1900 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Twirl Machineが現実になった場合、因数調整の行減少のために並列処理が進行している場合は、保守的な見積もりはテーブルのシステムセキュリティ列から約11ビットを減算します。したがって、89ビットのセキュリティを得るためには、約1900ビットのRSAモジュラスが必要になるでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Security-Considerations">
6. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The equations and values given in this document are meant to be as accurate as possible, based on the state of the art in general purpose computers at the time that this document is being written. No predictions can be completely accurate, and the formulas given here are not meant to be definitive statements of fact about cryptographic strengths. For example, some of the empirical results used in calibrating the formulas in this document are probably not completely accurate, and this inaccuracy affects the estimates. It is the authors&#39; hope that the numbers presented here vary from real world experience as little as possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書に記載されている式および値は、この文書が書かれている時点での汎用コンピュータにおける最新技術に基づいてできるだけ正確であることを意味している。予測は完全に正確であり得、ここで与えられた式は暗号強度についての事実の決定的な声明であることを意味していない。たとえば、この文書で式を校正するのに使用される経験的結果のいくつかは、おそらく完全に正確ではなく、この不正確さは推定値に影響を与えます。ここに提示された数字ができるだけ少ないのは現実世界の経験によって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--References">
7. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-1--Informational-References">
7.1. Informational References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 情報参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DL] Dodson, B. and A. K. Lenstra, NFS with four large primes: an explosive experiment, Proceedings Crypto 95, Lecture Notes in Comput. Sci. 963, (1995) 372-385.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DL] Dodson、B.およびA. K.Lenstra、4つの大きいプライムを備えたNFS：爆発的実験、議会暗号95、計算における講義について。SCI。963、（1995）372-385。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ECS] Eastlake, D., Crocker, S. and J. Schiller, &#34;Randomness Recommendations for Security&#34;, RFC 1750, December 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ECS]イーストレイク、D.、Crocker、S.およびJ.Schiller、「セキュリティのためのランダム性勧告」、RFC 1750、1994年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GIL98] Cracking DES: Secrets of Encryption Research, Wiretap Politics &amp; Chip Design , Electronic Frontier Foundation, John Gilmore (Ed.), 272 pages, May 1998, O&#39;Reilly &amp; Associates; ISBN: 1565925203
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GIL98]クラッキングDES：暗号化研究の秘密、政治政治＆チップ設計、電子フロンティア財団、ジョン・ギルモア（ED。）、272ページ、5月272ページ、O&#39;Reilly＆Associates。ISBN：1565925203
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GOR93] Gordon, D., &#34;Discrete logarithms in GF(p) using the number field sieve&#34;, SIAM Journal on Discrete Mathematics, 6 (1993), 124-138.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GOR93] GORDON、D.、「数フィールド篩を使用したGF（P）の離散対数」、Discrete MathematicsのSIAMジャーナル、6（1993）、124-138。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LEN93] Lenstra, A. K. and H. W. Lenstra, Jr. (eds), The development of the number field sieve, Lecture Notes in Math, 1554, Springer Verlag, Berlin, 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LEN93] Lenstra、A. K.およびH. W.Lenstra、Jr.（EDS）、数フィールドの篩の開発、数学、1554、Springer Verlag、Berlin、1993年の講演
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MH81] Merkle, R.C., and Hellman, M., &#34;On the Security of Multiple Encryption&#34;, Communications of the ACM, v. 24 n. 7, 1981, pp. 465-467.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MH81] Merkle、R.c.およびHellman、M.、「複数の暗号化のセキュリティに関する」、ACM、v。24 N。7,1981、PP。465-467。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ODL95] RSA Labs Cryptobytes, Volume 1, No. 2 - Summer 1995; The Future of Integer Factorization, A. M. Odlyzko
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ODL95] RSA LABS暗号バイト、第1巻、第2号 -  1995年夏;整数分析の将来A.M.ODLYZKO
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ODL99] A. M. Odlyzko, Discrete logarithms: The past and the future, Designs, Codes, and Cryptography (1999).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ODL99] A.M.ODLYZKO、離散対数：過去と未来、デザイン、コード、暗号化（1999）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[POL78] J. Pollard, &#34;Monte Carlo methods for index computation mod p&#34;, Mathematics of Computation, 32 (1978), 918-924.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[POL78] J.Pollard、「インデックス計算MOD Pのモンテカルロメソッド」、計算の数学、32（1978）、918-924。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2409] Harkins, D. and D. Carrel, &#34;The Internet Key Exchange (IKE)&#34;, RFC 2409, November 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2409] Harkins、D.およびD. Carrel、「インターネット鍵交換（IKE）」、RFC 2409、1998年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SCH95] R. Schroeppel, et al., Fast Key Exchange With Elliptic Curve Systems, In Don Coppersmith, editor, Advances in Cryptology -- CRYPTO 31 August 1995. Springer-Verlag
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SCH95] R.Schroeppelら、楕円曲線システムとの高速鍵交換、Don Coppersmith、編集者、暗号化の進歩 -  Crypto 1995年8月31日。Springer-Verlag
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SHAMIR03] Shamir, Adi and Eran Tromer, &#34;Factoring Large Numbers with the TWIRL Device&#34;, Advances in Cryptology - CRYPTO 2003, Springer, Lecture Notes in Computer Science 2729.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Shamir03] Shamir、ADIおよびEran Troome、「Dwirl Deviceを使った多数の大きな数」、Cryptolosyの進歩 -  Crypto 2003、Springer、Phatcher Science 2729。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SIL00] R. D. Silverman, RSA Laboratories Bulletin, Number 13 - April 2000, A Cost-Based Security Analysis of Symmetric and Asymmetric Key Lengths
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SIL00] R. D. Silverman、RSA Laboratories掲示板、13  -  2000年4月、対称キー長のコストベースのセキュリティ分析
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SILIEEE99] R. D. Silverman, &#34;The Mythical MIPS Year&#34;, IEEE Computer, August 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Silieee99] R.D. Silverman、「神話のミップス年」、IEEEコンピュータ、1999年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--Authors-Addresses">
8. Authors&#39; Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 著者の住所
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hilarie Orman Purple Streak Development 500 S. Maple Dr. Salem, UT 84653
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hilarie Orman Purple Streak開発500 S. Maple Dr. Salem、UT 84653
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: hilarie@purplestreak.com and ho@alum.mit.edu
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Paul Hoffman VPN Consortium 127 Segre Place Santa Cruz, CA 95060 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Paul Hoffman VPNコンソーシアム127 Segre Place Santa Cruz、CA 95060 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: paul.hoffman@vpnc.org
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--Full-Copyright-Statement">
9. Full Copyright Statement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 完全著作権宣言
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2004). This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）インターネット社会（2004）。この文書は、BCP 78に含まれている権利、ライセンス、制限の対象となり、その中に述べた場合を除き、著者らはすべての権利を保持しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein are provided on an &#34;AS IS&#34; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書と本明細書に含まれる情報は、「現状のまま」基準で提供されており、投稿者、または（いずれかの場合）、インターネット社会とインターネットエンジニアリングのタスクフォースがすべての保証を損なう、または本明細書における情報の使用が、特定の目的のためのあらゆる権利または黙示の保証を侵害しないことを含むがこれらに限定されないが、これに限定されない。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Intellectual Property
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
知的財産
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書に記載されているテクノロジの実装または使用に関連すると主張される可能性がある、またはそのような権利の下でのライセンスの使用に関連すると主張される可能性がある、またはその他の権利の下にある範囲内である可能性がある、またはその他の権利の使用に関連すると主張する可能性がある、IETFは、IETFを取りません。利用可能です。そのような権利を特定するためにそれが独立した努力をしたことを表していません。RFC文書の権利に関する手順に関する情報は、BCP 78およびBCP 79にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF事務局へのIETF事務局と利用可能なライセンスの保証のコピー、またはこの仕様書の実装者や利用者による一般的なライセンスまたは許可を得るための試みの結果を得ることができます。IETFオンラインIPRリポジトリからhttp://www.ietf.org/ipr。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFは、著作権、特許または特許出願、またはこの規格を実装することが要求される可能性がある技術をカバーする可能性のある他の独自の権利を注意を及ぼすように興味のある当事者を勧めます。ietf-ipr@ietf.orgのIETFに情報を宛先に宛ててください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFCエディタ機能のための資金は、現在インターネット社会によって提供されています。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
