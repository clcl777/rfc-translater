<!DOCTYPE html>


<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 7641 - Observing Resources in the Constrained Application Protocol (CoAP) 日本語訳</title>

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">7641</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc7641">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 7641 - Observing Resources in the Constrained Application Protocol (CoAP) 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc7641">
            https://datatracker.ietf.org/doc/html/rfc7641
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 7641 - 制約付きアプリケーションプロトコル（CoAP）でのリソースの監視</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <h6 class="card-title">要約（自動生成）</h6>
            <p class="card-text">RFC 7641は、CoAPでリソースを観測するための方法を提案しています。目的は、制約のある環境でのリソースの監視を可能にし、効率的なネットワークリソースの使用を促進することです。</p>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                         K. Hartke
Request for Comments: 7641                       Universitaet Bremen TZI
Category: Standards Track                                 September 2015
ISSN: 2070-1721
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Observing Resources in the Constrained Application Protocol (CoAP)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制約付きアプリケーションプロトコル（CoAP）でのリソースの監視
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Constrained Application Protocol (CoAP) is a RESTful application protocol for constrained nodes and networks. The state of a resource on a CoAP server can change over time. This document specifies a simple protocol extension for CoAP that enables CoAP clients to &#34;observe&#34; resources, i.e., to retrieve a representation of a resource and keep this representation updated by the server over a period of time. The protocol follows a best-effort approach for sending new representations to clients and provides eventual consistency between the state observed by each client and the actual resource state at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制約付きアプリケーションプロトコル（CoAP）は、制約付きノードおよびネットワーク用のRESTfulアプリケーションプロトコルです。 CoAPサーバー上のリソースの状態は、時間の経過とともに変化する可能性があります。このドキュメントでは、CoAPクライアントがリソースを「監視」できるようにする、つまり、リソースの表現を取得し、この表現を一定期間サーバーが更新し続けることを可能にするCoAPの単純なプロトコル拡張を指定します。このプロトコルは、新しい表現をクライアントに送信するためのベストエフォートアプローチに従い、各クライアントによって監視された状態とサーバーでの実際のリソース状態との間に最終的な一貫性を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これはInternet Standards Trackドキュメントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 5741のセクション2をご覧ください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7641.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7641で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）2015 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .  4
     1.1.  Background  . . . . . . . . . . . . . . . . . . . . . . .  4
     1.2.  Protocol Overview . . . . . . . . . . . . . . . . . . . .  4
     1.3.  Consistency Model . . . . . . . . . . . . . . . . . . . .  6
     1.4.  Observable Resources  . . . . . . . . . . . . . . . . . .  7
     1.5.  Requirements Notation . . . . . . . . . . . . . . . . . .  8
   2.  The Observe Option  . . . . . . . . . . . . . . . . . . . . .  9
   3.  Client-Side Requirements  . . . . . . . . . . . . . . . . . . 10
     3.1.  Request . . . . . . . . . . . . . . . . . . . . . . . . . 10
     3.2.  Notifications . . . . . . . . . . . . . . . . . . . . . . 10
     3.3.  Caching . . . . . . . . . . . . . . . . . . . . . . . . . 11
     3.4.  Reordering  . . . . . . . . . . . . . . . . . . . . . . . 12
     3.5.  Transmission  . . . . . . . . . . . . . . . . . . . . . . 13
     3.6.  Cancellation  . . . . . . . . . . . . . . . . . . . . . . 13
   4.  Server-Side Requirements  . . . . . . . . . . . . . . . . . . 14
     4.1.  Request . . . . . . . . . . . . . . . . . . . . . . . . . 14
     4.2.  Notifications . . . . . . . . . . . . . . . . . . . . . . 14
     4.3.  Caching . . . . . . . . . . . . . . . . . . . . . . . . . 15
     4.4.  Reordering  . . . . . . . . . . . . . . . . . . . . . . . 16
     4.5.  Transmission  . . . . . . . . . . . . . . . . . . . . . . 17
   5.  Intermediaries  . . . . . . . . . . . . . . . . . . . . . . . 20
   6.  Web Linking . . . . . . . . . . . . . . . . . . . . . . . . . 20
   7.  Security Considerations . . . . . . . . . . . . . . . . . . . 21
   8.  IANA Considerations . . . . . . . . . . . . . . . . . . . . . 22
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . . 22
     9.1.  Normative References  . . . . . . . . . . . . . . . . . . 22
     9.2.  Informative References  . . . . . . . . . . . . . . . . . 22
   Appendix A.  Examples . . . . . . . . . . . . . . . . . . . . . . 24
     A.1.  Client/Server Examples  . . . . . . . . . . . . . . . . . 24
     A.2.  Proxy Examples  . . . . . . . . . . . . . . . . . . . . . 28
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . . 30
   Author&#39;s Address  . . . . . . . . . . . . . . . . . . . . . . . . 30
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-1--Background">
1.1. Background
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. バックグラウンド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Constrained Application Protocol (CoAP) [RFC7252] is intended to provide RESTful services [REST] not unlike HTTP [RFC7230] while reducing the complexity of implementation as well as the size of packets exchanged in order to make these services useful in a highly constrained network of themselves highly constrained nodes [RFC7228].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制約付きアプリケーションプロトコル（CoAP）[RFC7252]は、HTTP [RFC7230]とは異なり、RESTfulサービス[REST]を提供することを目的としていますが、これらのサービスを非常に制約のあるサービスで役立つように交換するパケットのサイズだけでなく、実装の複雑さも軽減します高度に制約されたノード自体のネットワーク[RFC7228]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The model of REST is that of a client exchanging representations of resources with a server, where a representation captures the current or intended state of a resource. The server is the authority for representations of the resources in its namespace. A client interested in the state of a resource initiates a request to the server; the server then returns a response with a representation of the resource that is current at the time of the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESTのモデルは、リソースの表現をサーバーと交換するクライアントのモデルで、表現はリソースの現在の状態または意図された状態をキャプチャします。サーバーは、そのネームスペース内のリソースの表現に対する権限です。リソースの状態に関心のあるクライアントは、サーバーへの要求を開始します。次に、サーバーは、要求時に最新であるリソースの表現を含む応答を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This model does not work well when a client is interested in having a current representation of a resource over a period of time. Existing approaches from HTTP, such as repeated polling or HTTP long polling [RFC6202], generate significant complexity and/or overhead and thus are less applicable in a constrained environment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このモデルは、クライアントが一定期間リソースの現在の表現を保持することに関心がある場合はうまく機能しません。繰り返しポーリングやHTTPロングポーリング[RFC6202]などのHTTPからの既存のアプローチは、かなりの複雑さやオーバーヘッドを生成するため、制約のある環境ではあまり適用できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol specified in this document extends the CoAP core protocol with a mechanism for a CoAP client to &#34;observe&#34; a resource on a CoAP server: the client retrieves a representation of the resource and requests this representation be updated by the server as long as the client is interested in the resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントで指定されているプロトコルは、CoAPコアプロトコルを拡張して、CoAPクライアントがCoAPサーバー上のリソースを「監視」するメカニズムを備えています。クライアントは、リソースの表現を取得し、サーバーがこの表現を更新するように要求します。クライアントはリソースに関心があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol keeps the architectural properties of REST. It enables high scalability and efficiency through the support of caches and proxies. There is no intention, though, to solve the full set of problems that the existing HTTP solutions solve or to replace publish/subscribe networks that solve a much more general problem [RFC5989].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルはRESTのアーキテクチャプロパティを保持します。キャッシュとプロキシのサポートにより、高いスケーラビリティと効率を実現します。ただし、既存のHTTPソリューションが解決する問題の完全なセットを解決したり、より一般的な問題を解決するパブリッシュ/サブスクライブネットワークを置き換える意図はありません[RFC5989]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-2--Protocol-Overview">
1.2. Protocol Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. プロトコルの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol is based on the well-known observer design pattern [GOF]. In this design pattern, components called &#34;observers&#34; register at a specific, known provider called the &#34;subject&#34; that they are interested in being notified whenever the subject undergoes a change in state. The subject is responsible for administering its list of registered observers. If multiple subjects are of interest to an observer, the observer must register separately for all of them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルは、よく知られているオブザーバーデザインパターン[GOF]に基づいています。この設計パターンでは、「オブザーバー」と呼ばれるコンポーネントは、「サブジェクト」と呼ばれる特定の既知のプロバイダーに登録され、サブジェクトの状態が変化するたびに通知を受けることに関心があります。被験者は、登録されたオブザーバーのリストを管理する責任があります。複数のサブジェクトがオブザーバーに関心がある場合、オブザーバーはそれらすべてに対して個別に登録する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       Observer             Subject
                          |                    |
                          |    Registration    |
                          +-------------------&gt;|
                          |                    |
                          |    Notification    |
                          |&lt;-------------------+
                          |                    |
                          |    Notification    |
                          |&lt;-------------------+
                          |                    |
                          |    Notification    |
                          |&lt;-------------------+
                          |                    |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
Figure 1: The Observer Design Pattern
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
図1：オブザーバーの設計パターン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The observer design pattern is realized in CoAP as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブザーバーデザインパターンは、CoAPで次のように実現されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Subject: In the context of CoAP, the subject is a resource in the namespace of a CoAP server. The state of the resource can change over time, ranging from infrequent updates to continuous state transformations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
件名：CoAPのコンテキストでは、件名はCoAPサーバーのネームスペース内のリソースです。リソースの状態は、まれな更新から継続的な状態変換まで、時間の経過とともに変化する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Observer: An observer is a CoAP client that is interested in having a current representation of the resource at any given time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブザーバー：オブザーバーは、リソースの現在の表現を常に把握することに関心のあるCoAPクライアントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Registration: A client registers its interest in a resource by initiating an extended GET request to the server. In addition to returning a representation of the target resource, this request causes the server to add the client to the list of observers of the resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
登録：クライアントは、サーバーへの拡張GET要求を開始することにより、リソースへの関心を登録します。ターゲットリソースの表現を返すことに加えて、このリクエストにより、サーバーはリソースのオブザーバーのリストにクライアントを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Notification: Whenever the state of a resource changes, the server notifies each client in the list of observers of the resource. Each notification is an additional CoAP response sent by the server in reply to the single extended GET request and includes a complete, updated representation of the new resource state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知：リソースの状態が変化するたびに、サーバーはリソースのオブザーバーのリストにある各クライアントに通知します。各通知は、単一の拡張GET要求に応答してサーバーから送信される追加のCoAP応答であり、新しいリソースの状態の完全で更新された表現が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 2 below shows an example of a CoAP client registering its interest in a resource and receiving three notifications: the first with the current state upon registration, and then two upon changes to the resource state. Both the registration request and the notifications are identified as such by the presence of the Observe Option defined in this document. In notifications, the Observe Option additionally provides a sequence number for reordering detection. All notifications carry the token specified by the client, so the client can easily correlate them to the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の図2は、リソースへの関心を登録し、3つの通知を受信するCoAPクライアントの例を示しています。1つは登録時の現在の状態、もう1つはリソース状態の変更時です。登録要求と通知の両方は、このドキュメントで定義されている監視オプションの存在によって識別されます。通知では、監視オプションにより、検出を並べ替えるためのシーケンス番号が追加で提供されます。すべての通知にはクライアントが指定したトークンが含まれているため、クライアントはそれらを要求に簡単に関連付けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       Client                Server
                          |                    |
                          |  GET /temperature  |
                          |    Token: 0x4a     |   Registration
                          |  Observe: 0        |
                          +-------------------&gt;|
                          |                    |
                          |    2.05 Content    |
                          |    Token: 0x4a     |   Notification of
                          |  Observe: 12       |   the current state
                          |  Payload: 22.9 Cel |
                          |&lt;-------------------+
                          |                    |
                          |    2.05 Content    |
                          |    Token: 0x4a     |   Notification upon
                          |  Observe: 44       |   a state change
                          |  Payload: 22.8 Cel |
                          |&lt;-------------------+
                          |                    |
                          |    2.05 Content    |
                          |    Token: 0x4a     |   Notification upon
                          |  Observe: 60       |   a state change
                          |  Payload: 23.1 Cel |
                          |&lt;-------------------+
                          |                    |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
Figure 2: Observing a Resource in CoAP
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
図2：CoAPでのリソースの監視
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: In this document, &#34;Cel&#34; stands for &#34;degrees Celsius&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：このドキュメントでは、「Cel」は「摂氏」を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client remains on the list of observers as long as the server can determine the client&#39;s continued interest in the resource. The server may send a notification in a confirmable CoAP message to request an acknowledgement from the client. When the client deregisters, rejects a notification, or the transmission of a notification times out after several transmission attempts, the client is considered no longer interested in the resource and is removed by the server from the list of observers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがリソースに対するクライアントの継続的な関心を判別できる限り、クライアントはオブザーバーのリストに残ります。サーバーは、確認可能なCoAPメッセージで通知を送信して、クライアントからの確認応答を要求できます。クライアントが登録を解除するか、通知を拒否するか、数回の送信試行後に通知の送信がタイムアウトすると、クライアントはリソースに関心がないと見なされ、サーバーによってオブザーバーのリストから削除されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-3--Consistency-Model">
1.3. Consistency Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. 整合性モデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While a client is in the list of observers of a resource, the goal of the protocol is to keep the resource state observed by the client as closely in sync with the actual state at the server as possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがリソースのオブザーバーのリストに含まれている間、プロトコルの目標は、クライアントによって監視されるリソースの状態を、サーバーの実際の状態と可能な限り密接に同期させることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 It cannot be avoided that the client and the server become out of sync at times: First, there is always some latency between the change of the resource state and the receipt of the notification. Second, CoAP messages with notifications can get lost, which will cause the client to assume an old state until it receives a new notification. And third, the server may erroneously come to the conclusion that the client is no longer interested in the resource, which will cause the server to stop sending notifications and the client to assume an old state until it eventually registers its interest again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントとサーバーが時々同期しなくなるのを避けることはできません。最初に、リソースの状態の変化と通知の受信の間に常にある程度の待ち時間があります。第2に、通知を含むCoAPメッセージが失われる可能性があり、これにより、クライアントは新しい通知を受信するまで古い状態を引き継ぐことになります。 3番目に、サーバーは誤ってクライアントがリソースに関心を持たなくなったと誤って判断する可能性があります。これにより、サーバーは通知の送信を停止し、クライアントが最終的に再び関心を登録するまで古い状態を引き継ぐことになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol addresses this issue as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルはこの問題に次のように対処します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It follows a best-effort approach for sending the current representation to the client after a state change: clients should see the new state after a state change as soon as possible, and they should see as many states as possible. This is limited by congestion control, however, so a client cannot rely on observing every single state that a resource might go through.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o これは、状態変更後に現在の表現をクライアントに送信するためのベストエフォートアプローチに従います。状態変更後、クライアントはできるだけ早く新しい状態を確認し、できるだけ多くの状態を確認する必要があります。ただし、これは輻輳制御によって制限されるため、クライアントは、リソースが通過する可能性があるすべての状態の監視に依存することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It labels notifications with a maximum duration up to which it is acceptable for the observed state and the actual state to be out of sync. When the age of the notification received reaches this limit, the client cannot use the enclosed representation until it receives a new notification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 監視対象の状態と実際の状態が同期していないことが許容される最大期間で通知にラベルを付けます。受信した通知の経過時間がこの制限に達すると、クライアントは新しい通知を受信するまで囲まれた表現を使用できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It is designed on the principle of eventual consistency: the protocol guarantees that if the resource does not undergo a new change in state, eventually all registered observers will have a current representation of the latest resource state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 結果整合性の原則に基づいて設計されています。プロトコルは、リソースの状態が変化しない場合、登録されたすべてのオブザーバーが最新のリソース状態の現在の表現を持つことを保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-4--Observable-Resources">
1.4. Observable Resources
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. 観察可能なリソース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A CoAP server is the authority for determining under what conditions resources change their state and thus when observers are notified of new resource states. The protocol does not offer explicit means for setting up triggers or thresholds; it is up to the server to expose observable resources that change their state in a way that is useful in the application context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CoAPサーバーは、リソースが状態を変更する状況を決定するための権限であり、オブザーバーに新しいリソースの状態がいつ通知されるかを決定します。このプロトコルは、トリガーまたはしきい値を設定するための明示的な手段を提供しません。アプリケーションコンテキストで役立つように状態を変更する監視可能なリソースを公開するかどうかは、サーバーに依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, a CoAP server with an attached temperature sensor could expose one or more of the following resources:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、温度センサーが接続されたCoAPサーバーは、次のリソースの1つ以上を公開する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   o  &lt;coap://server/temperature&gt;, which changes its state every few
      seconds to a current reading of the temperature sensor;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   o  &lt;coap://server/temperature/felt&gt;, which changes its state to
      &#34;COLD&#34; whenever the temperature reading drops below a certain pre-
      configured threshold and to &#34;WARM&#34; whenever the reading exceeds a
      second, slightly higher threshold;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   o  &lt;coap://server/temperature/critical?above=42&gt;, which changes its
      state based on the client-specified parameter value either every
      few seconds to the current temperature reading if the temperature
      exceeds the threshold or to &#34;OK&#34; when the reading drops below;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &lt;coap://server/?query=select+avg(temperature)+from+Sensor.window: time(30sec)&gt;, which accepts expressions of arbitrary complexity and changes its state accordingly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &lt;coap：// server /？query = select + avg（temperature）+ from + Sensor.window：time（30sec）&gt;。これは、任意の複雑さの式を受け入れ、それに応じてその状態を変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, by designing CoAP resources that change their state on certain conditions, it is possible to update the client only when these conditions occur instead of supplying it continuously with raw sensor data. By parameterizing resources, this is not limited to conditions defined by the server, but can be extended to arbitrarily complex queries specified by the client. The application designer therefore can choose exactly the right level of complexity for the application envisioned and devices involved and is not constrained to a &#34;one size fits all&#34; mechanism built into the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、特定の条件で状態を変更するCoAPリソースを設計することにより、生のセンサーデータを継続的に提供する代わりに、これらの条件が発生した場合にのみクライアントを更新できます。リソースをパラメータ化することで、これはサーバーによって定義された条件に限定されず、クライアントによって指定された任意の複雑なクエリに拡張できます。したがって、アプリケーション設計者は、想定されるアプリケーションと関連するデバイスに適した複雑さのレベルを正確に選択でき、プロトコルに組み込まれた「1つのサイズですべてに適合する」メカニズムに制限されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-5--Requirements-Notation">
1.5. Requirements Notation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.5. 要件表記
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 RFC 2119 [RFC2119]で説明されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--The-Observe-Option">
2. The Observe Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 観察オプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Observe Option has the following properties. Its meaning depends on whether it is included in a GET request or in a response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
監視オプションには次のプロパティがあります。その意味は、GET要求に含まれるか、応答に含まれるかによって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       +-----+---+---+---+---+---------+--------+--------+---------+
       | No. | C | U | N | R | Name    | Format | Length | Default |
       +-----+---+---+---+---+---------+--------+--------+---------+
       |   6 |   | x | - |   | Observe | uint   | 0-3 B  | (none)  |
       +-----+---+---+---+---+---------+--------+--------+---------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            C=Critical, U=Unsafe, N=No-Cache-Key, R=Repeatable
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
Table 1: The Observe Option
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
表1：監視オプション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When included in a GET request, the Observe Option extends the GET method so it does not only retrieve a current representation of the target resource, but also requests the server to add or remove an entry in the list of observers of the resource depending on the option value. The list entry consists of the client endpoint and the token specified by the client in the request. Possible values are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETリクエストに含まれている場合、監視オプションはGETメソッドを拡張するので、ターゲットリソースの現在の表現を取得するだけでなく、サーバーに応じてリソースのオブザーバーのリストにエントリを追加または削除するようサーバーに要求します。オプション値。リストエントリは、クライアントエンドポイントと、リクエストでクライアントによって指定されたトークンで構成されます。可能な値は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0 (register) adds the entry to the list, if not present;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0（登録）は、存在しない場合、リストにエントリを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1 (deregister) removes the entry from the list, if present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1（登録解除）は、存在する場合、リストからエントリーを削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Observe Option is not critical for processing the request. If the server is unwilling or unable to add a new entry to the list of observers, then the request falls back to a normal GET request and the response does not include the Observe Option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
監視オプションは、リクエストの処理には重要ではありません。サーバーがオブザーバーのリストに新しいエントリを追加したくない、または追加できない場合、要求は通常のGET要求にフォールバックし、応答には監視オプションが含まれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Observe Option is not part of the Cache-Key: a cacheable response obtained with an Observe Option in the request can be used to satisfy a request without an Observe Option, and vice versa. When a stored response with an Observe Option is used to satisfy a normal GET request, the option MUST be removed before the response is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Observe OptionはCache-Keyの一部ではありません。リクエスト内のObserve Optionで取得されたキャッシュ可能な応答を使用して、Observe Optionなしでリクエストを満たすことができます。逆も同様です。 Observe Optionで保存された応答を使用して通常のGET要求を満たす場合、応答が返される前にオプションを削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When included in a response, the Observe Option identifies the message as a notification. This implies that a matching entry exists in the list of observers and that the server will notify the client of changes to the resource state. The option value is a sequence number for reordering detection (see Sections 3.4 and 4.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答に含まれる場合、監視オプションはメッセージを通知として識別します。これは、一致するエントリがオブザーバーのリストに存在し、サーバーがリソース状態の変更をクライアントに通知することを意味します。オプション値は、再順序付け検出のシーケンス番号です（セクション3.4および4.4を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value of the Observe Option is encoded as an unsigned integer in network byte order using a variable number of bytes (&#39;uint&#39; option format); see Section 3.2 of RFC 7252 [RFC7252].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Observe Optionの値は、可変バイト数（ &#39;uint&#39;オプション形式）を使用して、ネットワークバイトオーダーの符号なし整数としてエンコードされます。 RFC 7252 [RFC7252]のセクション3.2をご覧ください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Client-Side-Requirements">
3. Client-Side Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. クライアント側の要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--Request">
3.1. Request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. リクエスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client registers its interest in a resource by issuing a GET request with an Observe Option set to 0 (register). If the server returns a 2.xx response that includes an Observe Option as well, the server has successfully added an entry with the client endpoint and request token to the list of observers of the target resource, and the client will be notified of changes to the resource state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、監視オプションを0（登録）に設定してGET要求を発行することにより、リソースへの関心を登録します。サーバーがObserve Optionも含む2.xx応答を返した場合、サーバーはクライアントエンドポイントとリクエストトークンを含むエントリをターゲットリソースのオブザーバーのリストに正常に追加しており、クライアントへの変更が通知されますリソースの状態。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Like a fresh response can be used to satisfy a request without contacting the server, the stream of updates resulting from one observation request can be used to satisfy another (observation or normal GET) request if the target resource is the same. A client MUST aggregate such requests and MUST NOT register more than once for the same target resource. The target resource is identified by all options in the request that are part of the Cache-Key. This includes, for example, the full request URI and the Accept Option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しい応答を使用してサーバーに接続せずに要求を満たすことができるように、1つの監視要求から生じる更新のストリームを使用して、ターゲットリソースが同じ場合、別の（監視または通常のGET）要求を満たすことができます。クライアントはそのようなリクエストを集約しなければならず（MUST）、同じターゲットリソースに対して複数回登録してはなりません（MUST NOT）。ターゲットリソースは、キャッシュキーの一部であるリクエスト内のすべてのオプションによって識別されます。これには、たとえば、完全なリクエストURIとAccept Optionが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--Notifications">
3.2. Notifications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. お知らせ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Notifications are additional responses sent by the server in reply to the single extended GET request that created the registration. Each notification includes the token specified by the client in the request. The only difference between a notification and a normal response is the presence of the Observe Option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知は、登録を作成した単一の拡張GET要求に応答してサーバーが送信する追加の応答です。各通知には、リクエストでクライアントによって指定されたトークンが含まれます。通知と通常の応答の唯一の違いは、監視オプションの存在です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Notifications typically have a 2.05 (Content) response code. They include an Observe Option with a sequence number for reordering detection (see Section 3.4) and a payload in the same Content-Format as the initial response. If the client included one or more ETag Options in the GET request (see Section 3.3), notifications can have a 2.03 (Valid) response code rather than a 2.05 (Content) response code. Such notifications include an Observe Option with a sequence number but no payload.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、通知には2.05（コンテンツ）応答コードがあります。それらには、再順序付け検出のためのシーケンス番号（セクション3.4を参照）と最初の応答と同じContent-Formatのペイロードを持つObserve Optionが含まれています。クライアントがGETリクエストに1つ以上のETagオプションを含めた場合（セクション3.3を参照）、通知には2.05（コンテンツ）応答コードではなく2.03（有効）応答コードが含まれる場合があります。そのような通知には、ペイロードがなく、シーケンス番号が付いた監視オプションが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event that the resource changes in a way that would cause a normal GET request at that time to return a non-2.xx response (for example, when the resource is deleted), the server sends a notification with an appropriate response code (such as 4.04 Not Found) and removes the client&#39;s entry from the list of observers of the resource. Non-2.xx responses do not include an Observe Option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その時点で通常のGETリクエストが非2.xx応答を返すような方法でリソースが変更された場合（たとえば、リソースが削除された場合）、サーバーは適切な応答コードを含む通知を送信します（4.04 Not Foundなど）、リソースのオブザーバーのリストからクライアントのエントリを削除します。 2.xx以外の応答には、監視オプションは含まれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3--Caching">
3.3. Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. キャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As notifications are just additional responses to a GET request, notifications partake in caching as defined in Section 5.6 of RFC 7252 [RFC7252]. Both the freshness model and the validation model are supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知はGET要求に対する単なる追加の応答であるため、RFC 7252 [RFC7252]のセクション5.6で定義されているように、通知はキャッシングに参加します。鮮度モデルと検証モデルの両方がサポートされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-1--Freshness">
3.3.1. Freshness
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1. 鮮度
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client MAY store a notification like a response in its cache and use a stored notification that is fresh without contacting the server. Like a response, a notification is considered fresh while its age is not greater than the value indicated by the Max-Age Option (and no newer notification/response has been received).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、応答のような通知をキャッシュに格納し、サーバーに接続せずに新しい格納された通知を使用する場合があります。応答と同様に、通知は新しいと見なされますが、その経過時間はMax-Ageオプションで指定された値を超えません（新しい通知/応答は受信されません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server will do its best to keep the resource state observed by the client as closely in sync with the actual state as possible. However, a client cannot rely on observing every single state that a resource might go through. For example, if the network is congested or the state changes more frequently than the network can handle, the server can skip notifications for any number of intermediate states.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、クライアントが監視するリソースの状態を、実際の状態と可能な限り密接に同期させるように最善を尽くします。ただし、クライアントは、リソースが通過する可能性があるすべての状態の監視に依存することはできません。たとえば、ネットワークが混雑しているか、ネットワークが処理できるよりも頻繁に状態が変化する場合、サーバーは中間状態の通知をスキップできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server uses the Max-Age Option to indicate an age up to which it is acceptable that the observed state and the actual state are inconsistent. If the age of the latest notification becomes greater than its indicated Max-Age, then the client MUST NOT assume that the enclosed representation reflects the actual resource state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはMax-Age Optionを使用して、観測された状態と実際の状態が一致しないことが許容されるまでの経過時間を示します。最新の通知の経過時間が指定された最大経過時間よりも長くなる場合、クライアントは、囲まれた表現が実際のリソースの状態を反映していると想定してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To make sure it has a current representation and/or to re-register its interest in a resource, a client MAY issue a new GET request with the same token as the original at any time. All options MUST be identical to those in the original request except for the set of ETag Options. It is RECOMMENDED that the client does not issue the request while it still has a fresh notification/response for the resource in its cache. Additionally, the client SHOULD at least wait for a random amount of time between 5 and 15 seconds after Max-Age expired to reduce collisions with other clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の表現であることを確認したり、リソースへの関心を再登録したりするために、クライアントはいつでも元のトークンと同じトークンを使用して新しいGETリクエストを発行できます（MAY）。 ETagオプションのセットを除いて、すべてのオプションは元のリクエストのオプションと同じである必要があります。キャッシュ内のリソースに対する新しい通知/応答がまだある間は、クライアントが要求を発行しないことをお勧めします。さらに、クライアントは、他のクライアントとの衝突を減らすために、Max-Ageの期限が切れた後、少なくとも5〜15秒のランダムな時間待機する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-2--Validation">
3.3.2. Validation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.2. 検証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client has one or more notifications stored in its cache for a resource, it can use the ETag Option in the GET request to give the server an opportunity to select a stored notification to be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが1つ以上の通知をリソースのキャッシュに保存している場合、GETリクエストのETagオプションを使用して、サーバーに使用する保存済み通知を選択する機会を与えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The client MAY include an ETag Option for each stored response that is applicable in the GET request. Whenever the observed resource changes to a representation identified by one of the ETag Options, the server can select a stored response by sending a 2.03 (Valid) notification with an appropriate ETag Option instead of a 2.05 (Content) notification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントは、GETリクエストで適用可能な保存された各応答のETagオプションを含めることができます。監視対象のリソースがETagオプションの1つで識別される表現に変化するたびに、サーバーは、2.05（コンテンツ）通知ではなく、適切なETagオプションを含む2.03（有効）通知を送信することで、保存された応答を選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client implementation needs to keep all candidate responses in its cache until it is no longer interested in the target resource or it re-registers with a new set of entity tags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント実装は、ターゲットリソースに関心がなくなるか、新しいエンティティタグのセットに再登録するまで、すべての候補応答をキャッシュに保持する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-4--Reordering">
3.4. Reordering
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. 並べ替え
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Messages with notifications can arrive in a different order than they were sent. Since the goal is to keep the observed state as closely in sync with the actual state as possible, a client MUST consider the notification that was sent most recently as the freshest, regardless of the order of arrival.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知付きのメッセージは、送信された順序とは異なる順序で到着する場合があります。目的は、観測された状態を実際の状態と可能な限り密接に同期させることであるため、クライアントは、到着順序に関係なく、直近に送信された通知を最新のものと見なす必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To provide an order among notifications for the client, the server sets the value of the Observe Option in each notification to the 24 least significant bits of a strictly increasing sequence number. An incoming notification was sent more recently than the freshest notification so far when one of the following conditions is met:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントに通知間の順序を提供するために、サーバーは各通知の監視オプションの値を、厳密に増加するシーケンス番号の最下位24ビットに設定します。次のいずれかの条件が満たされた場合、これまでに受信した通知が最新の通知よりも最近送信されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                      (V1 &lt; V2 and V2 - V1 &lt; 2^23) or
                      (V1 &gt; V2 and V1 - V2 &gt; 2^23) or
                      (T2 &gt; T1 + 128 seconds)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where V1 is the value of the Observe Option in the freshest notification so far, V2 is the value of the Observe Option in the incoming notification, T1 is a client-local timestamp for the freshest notification so far, and T2 is a client-local timestamp for the incoming notification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、V1はこれまでの最新の通知の監視オプションの値、V2は受信通知の監視オプションの値、T1はこれまでの最新の通知のクライアントローカルタイムスタンプ、T2はクライアントローカルです。着信通知のタイムスタンプ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Design Note: The first two conditions verify that V1 is less than V2 in 24-bit serial number arithmetic [RFC1982]. The third condition ensures that if the server is generating serial numbers based on a local clock, the time elapsed between the two incoming messages is not so large that the difference between V1 and V2 has become larger than the largest integer that it is meaningful to add to a 24-bit serial number; in other words, after 128 seconds have elapsed without any notification, a client does not need to check the sequence numbers to assume that an incoming notification was sent more recently than the freshest notification it has received so far.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デザインノート：最初の2つの条件は、24ビットのシリアル番号演算[RFC1982]でV1がV2より小さいことを確認します。 3番目の条件は、サーバーがローカルクロックに基づいてシリアル番号を生成している場合、2つの着信メッセージ間の経過時間がそれほど大きくないため、V1とV2の差が、追加する意味のある最大の整数よりも大きくなっていることを保証します24ビットのシリアル番号。つまり、通知なしで128秒が経過した後、クライアントはシーケンス番号をチェックする必要がなく、着信通知がこれまでに受信した最新の通知よりも最近送信されたと想定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The duration of 128 seconds was chosen as a nice round number greater than MAX_LATENCY (Section 4.8.2 of RFC 7252 [RFC7252]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
128秒の期間は、MAX_LATENCY（RFC 7252 [RFC7252]のセクション4.8.2）を超える適切なラウンド数として選択されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5--Transmission">
3.5. Transmission
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. 伝染;感染
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A notification can be confirmable or non-confirmable, i.e., it can be sent in a confirmable or a non-confirmable message. The message type used for a notification is independent of the type used for the request and of any previous notification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知は、確認可能または確認不可能にすることができます。つまり、確認可能または確認不能なメッセージで送信できます。通知に使用されるメッセージタイプは、リクエストに使用されるタイプや以前の通知から独立しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client does not recognize the token in a confirmable notification, it MUST NOT acknowledge the message and SHOULD reject it with a Reset message; otherwise, the client MUST acknowledge the message as usual. In the case of a non-confirmable notification, rejecting the message with a Reset message is OPTIONAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
確認可能な通知でクライアントがトークンを認識しない場合、クライアントはメッセージを確認してはならず（MUST NOT）、リセットメッセージで拒否する必要があります（SHOULD）。それ以外の場合、クライアントは通常どおりメッセージを確認する必要があります。確認できない通知の場合、リセットメッセージでメッセージを拒否することはオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An acknowledgement message signals to the server that the client is alive and interested in receiving further notifications; if the server does not receive an acknowledgement in reply to a confirmable notification, it will assume that the client is no longer interested and will eventually remove the associated entry from the list of observers (Section 4.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
確認メッセージは、クライアントが生存していて、さらに通知を受信することに関心があることをサーバーに通知します。サーバーが確認可能な通知に応答して確認応答を受信しない場合、クライアントは興味がないと見なし、最終的に関連するエントリをオブザーバーのリストから削除します（セクション4.5）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6--Cancellation">
3.6. Cancellation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. キャンセル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client that is no longer interested in receiving notifications for a resource can simply &#34;forget&#34; the observation. When the server then sends the next notification, the client will not recognize the token in the message and thus will return a Reset message. This causes the server to remove the associated entry from the list of observers. The entries in lists of observers are effectively &#34;garbage collected&#34; by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースの通知を受信する必要がなくなったクライアントは、単に観察を「忘れる」だけです。その後、サーバーが次の通知を送信すると、クライアントはメッセージ内のトークンを認識しないため、リセットメッセージを返します。これにより、サーバーは関連するエントリをオブザーバーのリストから削除します。オブザーバーのリストのエントリは、サーバーによって事実上「ガベージコレクション」されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation Note: Due to potential message loss, the Reset message may not reach the server. The client may therefore have to reject multiple notifications, each with one Reset message, until the server finally removes the associated entry from the list of observers and stops sending notifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装上の注意：メッセージが失われる可能性があるため、リセットメッセージがサーバーに届かない場合があります。したがって、クライアントは、サーバーが最後に関連するエントリをオブザーバーのリストから削除して通知の送信を停止するまで、それぞれが1つのリセットメッセージを持つ複数の通知を拒否する必要がある場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some circumstances, it may be desirable to cancel an observation and release the resources allocated by the server to it more eagerly. In this case, a client MAY explicitly deregister by issuing a GET request that has the Token field set to the token of the observation to be cancelled and includes an Observe Option with the value set to 1 (deregister). All other options MUST be identical to those in the registration request except for the set of ETag Options. When the server receives such a request, it will remove any matching entry from the list of observers and process the GET request as usual.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状況によっては、監視をキャンセルし、サーバーによって割り当てられたリソースをより積極的に解放することが望ましい場合があります。この場合、クライアントは、トークンフィールドがキャンセルされる監視のトークンに設定され、値が1（登録解除）に設定された監視オプションを含むGETリクエストを発行することにより、明示的に登録を解除できます（MAY）。 ETagオプションのセットを除いて、他のすべてのオプションは、登録リクエストのオプションと同じでなければなりません。サーバーがこのようなリクエストを受信すると、一致するエントリがオブザーバーのリストから削除され、通常どおりGETリクエストが処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Server-Side-Requirements">
4. Server-Side Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. サーバー側の要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--Request">
4.1. Request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. リクエスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A GET request with an Observe Option set to 0 (register) requests the server not only to return a current representation of the target resource, but also to add the client to the list of observers of that resource. Upon success, the server returns a current representation of the resource and MUST keep this representation updated (as described in Section 1.3) as long as the client is on the list of observers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Observe Optionを0（登録）に設定したGET要求は、サーバーにターゲットリソースの現在の表現を返すだけでなく、そのリソースのオブザーバーのリストにクライアントを追加することも要求します。成功すると、サーバーはリソースの現在の表現を返し、クライアントがオブザーバーのリストにある限り、この表現を更新し続けなければなりません（セクション1.3で説明）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The entry in the list of observers is keyed by the client endpoint and the token specified by the client in the request. If an entry with a matching endpoint/token pair is already present in the list (which, for example, happens when the client wishes to reinforce its interest in a resource), the server MUST NOT add a new entry but MUST replace or update the existing one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブザーバーのリストのエントリは、クライアントエンドポイントと、リクエストでクライアントによって指定されたトークンによってキーが付けられます。一致するエンドポイント/トークンのペアを持つエントリがリストにすでに存在する場合（たとえば、クライアントがリソースへの関心を強化したい場合に発生します）、サーバーは新しいエントリを追加してはならず（MUST）、既存のもの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server that is unable or unwilling to add a new entry to the list of observers of a resource MAY silently ignore the registration request and process the GET request as usual. The resulting response MUST NOT include an Observe Option, the absence of which signals to the client that it will not be notified of changes to the resource and, e.g., needs to poll the resource for its state instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースのオブザーバーのリストに新しいエントリを追加できない、または追加したくないサーバーは、登録要求を無視し、通常どおりGET要求を処理できます（MAY）。結果の応答には監視オプションを含めてはなりません。監視オプションがないと、リソースへの変更が通知されないことをクライアントに通知し、たとえば、代わりにリソースの状態をポーリングする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the Observe Option in a GET request is set to 1 (deregister), then the server MUST remove any existing entry with a matching endpoint/ token pair from the list of observers and process the GET request as usual. The resulting response MUST NOT include an Observe Option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETリクエストのObserve Optionが1（登録解除）に設定されている場合、サーバーは、一致するエンドポイント/トークンのペアを持つ既存のエントリをオブザーバーのリストから削除し、通常どおりGETリクエストを処理する必要があります。結果の応答には、監視オプションを含めることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2--Notifications">
4.2. Notifications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. お知らせ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client is notified of changes to the resource state by additional responses sent by the server in reply to the GET request. Each such notification response (including the initial response) MUST echo the token specified by the client in the GET request. If there are multiple entries in the list of observers, the order in which the clients are notified is not defined; the server is free to use any method to determine the order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、GET要求への応答としてサーバーから送信される追加の応答によって、リソースの状態の変化を通知されます。そのような各通知応答（初期応答を含む）は、GET要求でクライアントによって指定されたトークンをエコーする必要があります。オブザーバのリストに複数のエントリがある場合、クライアントに通知される順序は定義されていません。サーバーは、任意の方法を使用して順序を決定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A notification SHOULD have a 2.05 (Content) or 2.03 (Valid) response code. However, in the event that the state of a resource changes in a way that would cause a normal GET request at that time to return a non-2.xx response (for example, when the resource is deleted), the server SHOULD notify the client by sending a notification with an appropriate response code (such as 4.04 Not Found) and subsequently MUST remove the associated entry from the list of observers of the resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
通知には、2.05（コンテンツ）または2.03（有効）応答コードが必要です（SHOULD）。ただし、リソースの状態がその時点で通常のGETリクエストが非2.xx応答を返すような方法で変化した場合（たとえば、リソースが削除された場合）、サーバーは通知する必要があります（SHOULD）クライアントは、適切な応答コード（4.04 Not Foundなど）を含む通知を送信し、その後、リソースのオブザーバーのリストから関連するエントリを削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Content-Format specified in a 2.xx notification MUST be the same as the one used in the initial response to the GET request. If the server is unable to continue sending notifications in this format, it SHOULD send a notification with a 4.06 (Not Acceptable) response code and subsequently MUST remove the associated entry from the list of observers of the resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.xx通知で指定されたContent-Formatは、GET要求への初期応答で使用されたものと同じでなければなりません。サーバーがこの形式で通知を送信し続けることができない場合は、4.06（Not Acceptable）応答コードで通知を送信する必要があり（SHOULD）、その後、リソースのオブザーバーのリストから関連するエントリを削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A 2.xx notification MUST include an Observe Option with a sequence number as specified in Section 4.4 below; a non-2.xx notification MUST NOT include an Observe Option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.xx通知には、以下のセクション4.4で指定されているシーケンス番号のある監視オプションを含める必要があります。 2.xx以外の通知には、監視オプションを含めることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3--Caching">
4.3. Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. キャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As notifications are just additional responses sent by the server in reply to a GET request, they are subject to caching as defined in Section 5.6 of RFC 7252 [RFC7252].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知は、GETリクエストへの応答としてサーバーから送信される単なる追加の応答であるため、RFC 7252 [RFC7252]のセクション5.6で定義されているように、キャッシュの対象になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3-1--Freshness">
4.3.1. Freshness
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1. 鮮度
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After returning the initial response, the server MUST keep the resource state that is observed by the client as closely in sync with the actual resource state as possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期応答を返した後、サーバーは、クライアントが監視するリソースの状態を、実際のリソースの状態と可能な限り密接に同期させなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since becoming out of sync at times cannot be avoided, the server MUST indicate for each representation an age up to which it is acceptable that the observed state and the actual state are inconsistent. This age is application dependent and MUST be specified in notifications using the Max-Age Option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
時々同期が外れることは避けられないので、サーバーは各表現について、観察された状態と実際の状態が矛盾していることが許容されるまでの経過時間を示さなければなりません（MUST）。この年齢はアプリケーションによって異なり、Max-Ageオプションを使用して通知で指定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the resource does not change and the client has a current representation, the server does not need to send a notification. However, if the client does not receive a notification, the client cannot tell if the observed state and the actual state are still in sync. Thus, when the age of the latest notification becomes greater than its indicated Max-Age, the client no longer has a usable representation of the resource state. The server MAY wish to prevent that by sending a new notification with the unchanged representation and a new Max-Age just before the Max-Age indicated earlier expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースが変更されず、クライアントに現在の表現がある場合、サーバーは通知を送信する必要はありません。ただし、クライアントが通知を受信しない場合、クライアントは監視された状態と実際の状態がまだ同期しているかどうかを判断できません。したがって、最新の通知の経過時間が指定されたMax-Ageよりも大きくなると、クライアントはリソースの状態の使用可能な表現を失います。サーバーは、以前のMax-Ageが期限切れになる直前に、変更されていない表現と新しいMax-Ageを含む新しい通知を送信することで、これを防止することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3-2--Validation">
4.3.2. Validation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2. 検証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client can include a set of entity tags in its request using the ETag Option. When an observed resource changes its state and the origin server is about to send a 2.05 (Content) notification, then whenever that notification has an entity tag in the set of entity tags specified by the client, the server MAY send a 2.03 (Valid) response with an appropriate ETag Option instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、ETagオプションを使用して、リクエストに一連のエンティティタグを含めることができます。監視対象のリソースの状態が変化し、配信元サーバーが2.05（コンテンツ）通知を送信しようとしている場合、その通知にクライアントによって指定されたエンティティタグのセットにエンティティタグが含まれている場合は常に、サーバーは2.03（有効）を送信できます（MAY）代わりに適切なETagオプションを使用して応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-4--Reordering">
4.4. Reordering
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. 並べ替え
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because messages can get reordered, the client needs a way to determine if a notification arrived later than a newer notification. For this purpose, the server MUST set the value of the Observe Option of each notification it sends to the 24 least significant bits of a strictly increasing sequence number. The sequence number MAY start at any value and MUST NOT increase so fast that it increases by more than 2^23 within less than 256 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージは並べ替えられる可能性があるため、クライアントは、通知が新しい通知よりも後に到着したかどうかを判別する方法を必要とします。この目的のために、サーバーは、送信する各通知の監視オプションの値を、厳密に増加するシーケンス番号の最下位24ビットに設定する必要があります。シーケンス番号は任意の値で開始してもよい（MAY）ので、256秒未満で2 ^ 23以上増加するほど速く増加してはならない（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sequence number selected for a notification MUST be greater than that of any preceding notification sent to the same client with the same token for the same resource. The value of the Observe Option MUST be current at the time of transmission; if a notification is retransmitted, the server MUST update the value of the option to the sequence number that is current at that time before retransmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知用に選択されたシーケンス番号は、同じリソースの同じトークンを使用して同じクライアントに送信された前の通知のシーケンス番号よりも大きい必要があります。監視オプションの値は、送信時に最新である必要があります。通知が再送信される場合、サーバーはオプションの値を再送信前のその時点でのシーケンス番号に更新する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation Note: A simple implementation that satisfies the requirements is to obtain a timestamp from a local clock. The sequence number then is the timestamp in ticks, where 1 tick = (256 seconds)/(2^23) = 30.52 microseconds. It is not necessary that the clock reflects the current time/date.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装上の注意：要件を満たす簡単な実装は、ローカルクロックからタイムスタンプを取得することです。シーケンス番号は、ティック単位のタイムスタンプです。1ティック=（256秒）/（2 ^ 23）= 30.52マイクロ秒です。クロックが現在の時刻/日付を反映している必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Another valid implementation is to store a 24-bit unsigned integer variable per resource and increment this variable each time the resource undergoes a change of state (provided that the resource changes its state less than 2^23 times in the first 256 seconds after every state change). This removes the need to update the value of the Observe Option on retransmission when the resource state did not change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
別の有効な実装は、リソースごとに24ビットの符号なし整数変数を格納し、リソースの状態が変化するたびにこの変数をインクリメントすることです（ただし、リソースが状態を変更するのは、各状態の最初の256秒で2 ^ 23回未満です）。変化する）。これにより、リソースの状態が変化しなかった場合に、再送信時に監視オプションの値を更新する必要がなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Design Note: The choice of a 24-bit option value and a time span of 256 seconds theoretically allows for a notification rate of up to 65536 notifications per second. Constrained nodes often have rather imprecise clocks, though, and inaccuracies of the client and server side may cancel out or add in effect. Therefore, the maximum notification rate is reduced to 32768 notifications per second. This is still well beyond the highest known design objective of around 1 kHz (most CoAP applications will be several orders of magnitude below that) but allows total clock inaccuracies of up to -50/+100%.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
デザインノート：24ビットのオプション値と256秒のタイムスパンを選択すると、理論的には1秒あたり最大65536通知の通知レートが可能になります。ただし、制約されたノードのクロックはかなり不正確であることが多く、クライアント側とサーバー側の不正確さが相殺されたり、実際に追加されたりする場合があります。したがって、最大通知レートは32768通知/秒に減少します。これは、既知の最も高い設計目標である1 kHzをはるかに上回っています（ほとんどのCoAPアプリケーションはその数桁下回ります）が、最大-50 / + 100％の合計クロック誤差を許容します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-5--Transmission">
4.5. Transmission
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. 伝染;感染
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A notification can be sent in a confirmable or a non-confirmable message. The message type used is typically application dependent and may be determined by the server for each notification individually.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知は、確認可能なメッセージまたは確認できないメッセージで送信できます。使用されるメッセージタイプは、通常、アプリケーションに依存し、通知ごとにサーバーによって個別に決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, for resources that change in a somewhat predictable or regular fashion, notifications can be sent in non-confirmable messages; for resources that change infrequently, notifications can be sent in confirmable messages. The server can combine these two approaches depending on the frequency of state changes and the importance of individual notifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、ある程度予測可能または定期的に変化するリソースの場合、確認不可能なメッセージで通知を送信できます。頻繁に変更されないリソースの場合、確認可能なメッセージで通知を送信できます。サーバーは、状態変更の頻度と個々の通知の重要性に応じて、これら2つのアプローチを組み合わせることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server MAY choose to skip sending a notification if it knows that it will send another notification soon, for example, when the state of a resource is changing frequently. It also MAY choose to send more than one notification for the same resource state. However, above all, the server MUST ensure that a client in the list of observers of a resource eventually observes the latest state if the resource does not undergo a new change in state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、リソースの状態が頻繁に変化している場合など、別の通知をすぐに送信することがわかっている場合、通知の送信をスキップすることを選択できます。また、同じリソース状態に対して複数の通知を送信することを選択する場合もあります。ただし、何よりも、サーバーは、リソースの状態の新しい変化を受けない場合、リソースのオブザーバーのリストにあるクライアントが最終的に最新の状態を監視することを保証する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, when state changes occur in bursts, the server can skip some notifications, send the notifications in non-confirmable messages, and make sure that the client observes the latest state change by repeating the last notification in a confirmable message when the burst is over.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、状態の変化がバーストで発生した場合、サーバーは一部の通知をスキップし、確認不可能なメッセージで通知を送信し、バーストが発生したときに確認可能なメッセージで最後の通知を繰り返すことにより、クライアントが最新の状態変化を確実に監視できるようにします以上。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client&#39;s acknowledgement of a confirmable notification signals that the client is interested in receiving further notifications. If a client rejects a confirmable or non-confirmable notification with a Reset message, or if the last attempt to retransmit a confirmable notification times out, then the client is considered no longer interested and the server MUST remove the associated entry from the list of observers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
確認可能な通知のクライアントの確認は、クライアントがさらなる通知の受信に関心があることを示します。クライアントがリセットメッセージで確認可能または確認不可能な通知を拒否した場合、または確認可能な通知を再送信する最後の試行がタイムアウトした場合、クライアントは関心がないと見なされ、サーバーは関連するエントリをオブザーバーのリストから削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation Note: To properly process a Reset message that rejects a non-confirmable notification, a server needs to remember the message IDs of the non-confirmable notifications it sends. This may be challenging for a server with constrained resources. However, since Reset messages are transmitted unreliably, the client must be prepared in case the Reset messages are not received by the server. Thus, a server can always pretend that a Reset message rejecting a non-confirmable notification was lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装上の注意：確認不可能な通知を拒否するリセットメッセージを適切に処理するには、サーバーは送信する確認不可能な通知のメッセージIDを記憶する必要があります。これは、リソースに制約があるサーバーにとっては困難な場合があります。ただし、リセットメッセージは確実に送信されないため、サーバーがリセットメッセージを受信しない場合に備えて、クライアントを準備する必要があります。したがって、サーバーは常に、確認できない通知を拒否するリセットメッセージが失われたと偽ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If a server does this, it could accelerate cancellation by sending the following notifications to that client in confirmable messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーがこれを行う場合、確認可能なメッセージでそのクライアントに次の通知を送信することにより、キャンセルを加速できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server that transmits notifications mostly in non-confirmable messages MUST send a notification in a confirmable message instead of a non-confirmable message at least every 24 hours. This prevents a client that went away or is no longer interested from remaining in the list of observers indefinitely.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ほとんどの場合確認不可能なメッセージで通知を送信するサーバーは、少なくとも24時間ごとに確認不可能なメッセージではなく確認可能なメッセージで通知を送信する必要があります。これにより、立ち去ったクライアントや興味がなくなったクライアントが無期限にオブザーバーのリストに残ることがなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-5-1--Congestion-Control">
4.5.1. Congestion Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.1. 輻輳制御
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Basic congestion control for CoAP is provided by the exponential back-off mechanism in Section 4.2 of RFC 7252 [RFC7252] and the limitations in Section 4.7 of RFC 7252 [RFC7252]. However, CoAP places the responsibility of congestion control for simple request/ response interactions only on the clients: rate-limiting request transmission implicitly controls the transmission of the responses. When a single request yields a potentially infinite number of notifications, additional responsibility needs to be placed on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CoAPの基本的な輻輳制御は、RFC 7252 [RFC7252]のセクション4.2の指数バックオフメカニズムと、RFC 7252 [RFC7252]のセクション4.7の制限によって提供されます。ただし、CoAPは、単純な要求/応答対話の輻輳制御の責任をクライアントにのみ置きます。レート制限要求の送信は、応答の送信を暗黙的に制御します。単一の要求が潜在的に無限の数の通知を生成する場合、追加の責任がサーバーに課される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order not to cause congestion, servers MUST strictly limit the number of simultaneous outstanding notifications/responses that they transmit to a given client to NSTART (1 by default; see Section 4.7 of RFC 7252 [RFC7252]). An outstanding notification/response is either a confirmable message for which an acknowledgement has not yet been received and whose last retransmission attempt has not yet timed out or a non-confirmable message for which the waiting time that results from the following rate-limiting rules has not yet elapsed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳を引き起こさないために、サーバーは、特定のクライアントに送信する同時未解決通知/応答の数をNSTARTに厳密に制限する必要があります（デフォルトでは1。RFC7252 [RFC7252]のセクション4.7を参照）。未解決の通知/応答は、確認応答がまだ受信されておらず、最後の再送信の試行がまだタイムアウトしていない確認可能なメッセージ、または次のレート制限ルールに起因する待機時間のある確認不可能なメッセージのいずれかです。まだ経過していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server SHOULD NOT send more than one non-confirmable notification per round-trip time (RTT) to a client on average. If the server cannot maintain an RTT estimate for a client, it SHOULD NOT send more than one non-confirmable notification every 3 seconds and SHOULD use an even less aggressive rate when possible (see also Section 3.1.2 of RFC 5405 [RFC5405]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、平均してラウンドトリップ時間（RTT）ごとに複数の確認不可能な通知をクライアントに送信してはなりません（SHOULD NOT）。サーバーがクライアントのRTT見積もりを維持できない場合は、3秒ごとに複数の確認不可能な通知を送信してはならず（SHOULD NOT）、可能な場合はさらに攻撃的なレートを使用する必要があります（RFC 5405 [RFC5405]のセクション3.1.2も参照）。 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Further congestion control optimizations and considerations are expected in the future with advanced CoAP congestion control mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高度なCoAP輻輳制御メカニズムにより、今後さらに輻輳制御の最適化と考慮事項が予想されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-5-2--Advanced-Transmission">
4.5.2. Advanced Transmission
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.2. 高度な伝送
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The state of an observed resource may change while the number of simultaneous outstanding notifications/responses to a client on the list of observers is greater than or equal to NSTART. In this case, the server cannot notify the client of the new resource state immediately but has to wait for an outstanding notification/response to complete first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
監視対象リソースの状態は、オブザーバーのリストにあるクライアントへの未解決の同時通知/応答の数がNSTART以上である間に変化する可能性があります。この場合、サーバーはクライアントに新しいリソースの状態をすぐに通知できませんが、未処理の通知/応答が最初に完了するのを待つ必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there exists an outstanding notification/response that the server transmits to the client and that pertains to the changed resource, then it is desirable for the server to stop working towards getting the representation of the old resource state to the client and to start transmitting the current representation to the client instead, so the resource state observed by the client stays closer in sync with the actual state at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがクライアントに送信し、変更されたリソースに関連する未解決の通知/応答が存在する場合、サーバーが古いリソースの状態の表現をクライアントに取得することに向けて動作を停止し、クライアントへの送信を開始することが望ましい代わりにクライアントへの現在の表現。したがって、クライアントによって監視されるリソースの状態は、サーバーでの実際の状態との同期を保ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For this purpose, the server MAY optimize the transmission process by aborting the transmission of the old notification (but not before the current transmission attempt is completed) and starting a new transmission for the new notification (but with the retransmission timer and counter of the aborted transmission retained).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この目的のために、サーバーは古い通知の送信を中止することによって（ただし、現在の送信試行が完了する前ではなく）、新しい通知の新しい送信を開始することによって（ただし、再送信タイマーと中止されたカウンターを使用して）送信プロセスを最適化できます（MAY）。伝送が保持されます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In more detail, a server MAY supersede an outstanding transmission that pertains to an observation as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
より詳細には、サーバーは次のように観測に関連する未処理の送信に取って代わることができます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Wait for the current (re)transmission attempt to be acknowledged, rejected, or to time out (confirmable transmission); or, wait for the waiting time to elapse or the transmission to be rejected (non-confirmable transmission).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 現在の（再）送信の試行が確認、拒否、またはタイムアウト（確認可能な送信）されるのを待ちます。または、待機時間が経過するか、送信が拒否される（確認できない送信）のを待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If the transmission is rejected or it was the last attempt to retransmit a notification, remove the associated entry from the list of observers of the observed resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 送信が拒否された場合、または通知を再送信する最後の試みであった場合は、監視対象リソースのオブザーバーのリストから関連するエントリを削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If the entry is still in the list of observers, start to transmit a new notification with a representation of the current resource state. Should the resource have changed its state more than once in the meantime, the notifications for the intermediate states are silently skipped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. エントリがまだオブザーバーのリストにある場合は、現在のリソースの状態を表す新しい通知の送信を開始します。その間にリソースがその状態を2回以上変更した場合、中間状態の通知は通知なくスキップされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. The new notification is transmitted with a new Message ID and the following transmission parameters: if the previous (re)transmission attempt timed out, retain its transmission parameters, increment the retransmission counter, and double the timeout; otherwise, initialize the transmission parameters as usual (see Section 4.2 of RFC 7252 [RFC7252]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 新しい通知は、新しいメッセージIDと次の送信パラメーターで送信されます。前の（再）送信の試行がタイムアウトした場合、その送信パラメーターを保持し、再送信カウンターをインクリメントし、タイムアウトを2倍にします。それ以外の場合は、通常どおり送信パラメータを初期化します（RFC 7252 [RFC7252]のセクション4.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible that the server later receives an acknowledgement for a confirmable notification that it superseded this way. Even though this does not signal consistency, it is valuable in that it signals the client&#39;s further interest in the resource. The server therefore should avoid inadvertently removing the associated entry from the list of observers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが後で、この方法に取って代わったという確認可能な通知の確認を受け取る可能性があります。これは一貫性を示すものではありませんが、リソースに対するクライアントのさらなる関心を示すという点で価値があります。したがって、サーバーは、オブザーバーのリストから関連するエントリを誤って削除しないようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Intermediaries">
5. Intermediaries
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 仲介人
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client may be interested in a resource in the namespace of a server that is reached through a chain of one or more CoAP intermediaries. In this case, the client registers its interest with the first intermediary towards the server, acting as if it was communicating with the server itself, as specified in Section 3. It is the task of this intermediary to provide the client with a current representation of the target resource and to keep the representation updated upon changes to the resource state, as specified in Section 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、1つ以上のCoAP仲介者のチェーンを介して到達するサーバーのネームスペース内のリソースに関心がある場合があります。この場合、クライアントはサーバーへの最初の仲介者に関心を登録し、セクション3で指定されているように、サーバー自体と通信しているかのように動作します。この仲介者の役割は、クライアントに現在の表現を提供することです。ターゲットリソース。セクション4で指定されているように、リソースの状態が変化したときに表現を更新し続けるため。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To perform this task, the intermediary SHOULD make use of the protocol specified in this document, taking the role of the client and registering its own interest in the target resource with the next hop towards the server. If the response returned by the next hop doesn&#39;t include an Observe Option, the intermediary MAY resort to polling the next hop or MAY itself return a response without an Observe Option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このタスクを実行するために、仲介者はこのドキュメントで指定されたプロトコルを利用して、クライアントの役割を果たし、サーバーへのネクストホップでターゲットリソースに自身の関心を登録する必要があります。ネクストホップから返された応答に監視オプションが含まれていない場合、仲介者はネクストホップのポーリングに頼るか、監視オプションなしで応答を返すことができます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The communication between each pair of hops is independent; each hop in the server role MUST determine individually how many notifications to send, of which message type, and so on. Each hop MUST generate its own values for the Observe Option in notifications and MUST set the value of the Max-Age Option according to the age of the local current representation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホップの各ペア間の通信は独立しています。サーバーロールの各ホップは、送信する通知の数、メッセージの種類などを個別に決定する必要があります。各ホップは、通知の監視オプションに独自の値を生成する必要があり、ローカルの現在の表現の経過時間に応じてMax-Ageオプションの値を設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If two or more clients have registered their interest in a resource with an intermediary, the intermediary MUST register itself only once with the next hop and fan out the notifications it receives to all registered clients. This relieves the next hop from sending the same notifications multiple times and thus enables scalability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つ以上のクライアントが仲介者のリソースへの関心を登録している場合、仲介者は自身をネクストホップに一度だけ登録し、すべての登録済みクライアントに受信する通知をファンアウトする必要があります。これにより、ネクストホップが同じ通知を複数回送信することから解放され、スケーラビリティが実現します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An intermediary is not required to act on behalf of a client to observe a resource; an intermediary MAY observe a resource, for example, just to keep its own cache up to date.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仲介者は、クライアントの代わりに行動してリソースを監視する必要はありません。仲介者は、たとえば、自身のキャッシュを最新の状態に保つために、リソースを監視できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Appendix A.2 for examples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例については、付録A.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Web-Linking">
6. Web Linking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. ウェブリンク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A web link [RFC5988] to a resource accessible over CoAP (for example, in a link-format document [RFC6690]) MAY include the target attribute &#34;obs&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CoAPを介してアクセス可能なリソースへのWebリンク[RFC5988]（たとえば、リンク形式のドキュメント[RFC6690]内）には、ターゲット属性「obs」を含めることができます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The &#34;obs&#34; attribute, when present, is a hint indicating that the destination of a link is useful for observation and thus, for example, should have a suitable graphical representation in a user interface. Note that this is only a hint; it is not a promise that the Observe Option can actually be used to perform the observation. A client may need to resort to polling the resource if the Observe Option is not returned in the response to the GET request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
「obs」属性は、存在する場合、リンクの宛先が観察に役立つことを示すヒントであり、したがって、たとえば、ユーザーインターフェイスに適切なグラフィック表現が必要です。これは単なるヒントであることに注意してください。観察オプションを実際に使用して観察を実行できるという保証はありません。 GETリクエストへの応答でObserve Optionが返されない場合、クライアントはリソースのポーリングに頼る必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A value MUST NOT be given for the &#34;obs&#34; attribute; any present value MUST be ignored by parsers. The &#34;obs&#34; attribute MUST NOT appear more than once in a given link-value; occurrences after the first MUST be ignored by parsers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「obs」属性に値を指定してはなりません（MUST NOT）。現在の値はパーサーによって無視される必要があります。 「obs」属性は、特定のリンク値に複数回出現してはなりません（MUST NOT）。最初の後ろの出現はパーサーによって無視されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Security-Considerations">
7. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The security considerations in Section 11 of [RFC7252], the CoAP specification, apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7252]のセクション11、CoAP仕様のセキュリティに関する考慮事項が適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Observing resources can dramatically increase the negative effects of amplification attacks. That is, not only can notifications messages be much larger than the request message, but the nature of the protocol can cause a significant number of notifications to be generated. Without client authentication, a server therefore MUST strictly limit the number of notifications that it sends between receiving acknowledgements that confirm the actual interest of the client in the data; i.e., any notifications sent in non-confirmable messages MUST be interspersed with confirmable messages. Note that an attacker may still spoof the acknowledgements if the confirmable messages are sufficiently predictable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースを観察すると、増幅攻撃の悪影響が劇的に増加する可能性があります。つまり、通知メッセージが要求メッセージよりもはるかに大きくなるだけでなく、プロトコルの性質により、大量の通知が生成される可能性があります。したがって、クライアント認証がない場合、サーバーは、データに対するクライアントの実際の関心を確認する確認応答を受信する間に送信する通知の数を厳密に制限する必要があります。つまり、確認不可能なメッセージで送信された通知には、確認可能なメッセージを挿入する必要があります。確認可能なメッセージが十分に予測可能である場合、攻撃者は依然として確認応答を偽装する可能性があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol follows a best-effort approach for keeping the state observed by a client and the actual resource state at a server in sync. This may have the client and the server become out of sync at times. Depending on the sensitivity of the observed resource, operating on an old state might be a security threat. The client therefore must be careful not to use a representation after its Max-Age expires, and the server must set the Max-Age Option to a sensible value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルは、クライアントが監視する状態とサーバーの実際のリソース状態を同期させるベストエフォートアプローチに従います。これにより、クライアントとサーバーが同期しなくなることがあります。観察されたリソースの機密性によっては、古い状態での操作がセキュリティ上の脅威になる場合があります。したがって、クライアントはMax-Ageの有効期限が切れた後に表現を使用しないように注意する必要があり、サーバーはMax-Age Optionを適切な値に設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with any protocol that creates state, attackers may attempt to exhaust the resources that the server has available for maintaining the list of observers for each resource. Servers may want to apply access controls to this creation of state. As degraded behavior, the server can always fall back to processing the request as a normal GET request (without an Observe Option) if it is unwilling or unable to add a client to the list of observers of a resource, including if system resources are exhausted or nearing exhaustion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態を作成する任意のプロトコルと同様に、攻撃者は、サーバーが各リソースのオブザーバーのリストを維持するために利用できるリソースを使い果たすことを試みる可能性があります。サーバーは、この状態の作成にアクセス制御を適用したい場合があります。低下した動作として、システムリソースが使い果たされているかどうかを含め、リソースのオブザーバーのリストにクライアントを追加したくない、またはできない場合、サーバーは常に通常のGETリクエスト（監視オプションなし）としてリクエストの処理にフォールバックできます。または消耗に近づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Intermediaries must be careful to ensure that notifications cannot be employed to create a loop. A simple way to break any loops is to employ caches for forwarding notifications in intermediaries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仲介者は、通知を使用してループを作成できないように注意する必要があります。ループを解消する簡単な方法は、中間で通知を転送するためにキャッシュを使用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Resources can be observed over CoAP that is secured by Datagram Transport Layer Security (DTLS) using any of the security modes described in Section 9 of RFC 7252. The use of DTLS is indicated by the &#34;coaps&#34; URI scheme. All notifications resulting from a GET request with an Observe Option MUST be returned within the same epoch of the same connection as the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースは、RFC 7252のセクション9で説明されているセキュリティモードのいずれかを使用して、Datagram Transport Layer Security（DTLS）によって保護されたCoAPを介して監視できます。DTLSの使用は、「coaps」URIスキームで示されます。 Observe Optionを使用したGETリクエストの結果であるすべての通知は、リクエストと同じ接続の同じエポック内で返される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--IANA-Considerations">
8. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. IANAに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following entry has been added to the CoAP Option Numbers registry:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のエントリがCoAPオプション番号レジストリに追加されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                     +--------+---------+-----------+
                     | Number | Name    | Reference |
                     +--------+---------+-----------+
                     |      6 | Observe | RFC 7641  |
                     +--------+---------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--References">
9. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-1--Normative-References">
9.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;http://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;http://www.rfc-editor.org/info/ rfc2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5988] Nottingham, M., &#34;Web Linking&#34;, RFC 5988, DOI 10.17487/RFC5988, October 2010, &lt;http://www.rfc-editor.org/info/rfc5988&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5988]ノッティンガム、M。、「Webリンク」、RFC 5988、DOI 10.17487 / RFC5988、2010年10月、&lt;http://www.rfc-editor.org/info/rfc5988&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7252] Shelby, Z., Hartke, K., and C. Bormann, &#34;The Constrained Application Protocol (CoAP)&#34;, RFC 7252, DOI 10.17487/RFC7252, June 2014, &lt;http://www.rfc-editor.org/info/rfc7252&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7252] Shelby、Z.、Hartke、K。、およびC. Bormann、「The Constrained Application Protocol（CoAP）」、RFC 7252、DOI 10.17487 / RFC7252、2014年6月、&lt;http：//www.rfc-editor。 org / info / rfc7252&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2--Informative-References">
9.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GOF] Gamma, E., Helm, R., Johnson, R., and J. Vlissides, &#34;Design Patterns: Elements of Reusable Object-Oriented Software&#34;, Addison-Wesley Professional Computing Series, 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GOF] Gamma、E.、Helm、R.、Johnson、R.、J。Vlissides、「設計パターン：再利用可能なオブジェクト指向ソフトウェアの要素」、Addison-Wesley Professional Computing Series、1994。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[REST] Fielding, R., &#34;Architectural Styles and the Design of Network-based Software Architectures&#34;, Ph.D. Dissertation, University of California, Irvine, 2000, &lt;http://www.ics.uci.edu/~fielding/pubs/dissertation/ fielding_dissertation.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[REST] Fielding、R。、「Architectural Styles and the Design of Network-based Software Architectures」、Ph.D。カリフォルニア大学アーバイン校の論文、2000年、&lt;http://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1982] Elz, R. and R. Bush, &#34;Serial Number Arithmetic&#34;, RFC 1982, DOI 10.17487/RFC1982, August 1996, &lt;http://www.rfc-editor.org/info/rfc1982&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1982] Elz、R. and R. Bush、 &#34;Serial Number Arithmetic&#34;、RFC 1982、DOI 10.17487 / RFC1982、August 1996、&lt;http://www.rfc-editor.org/info/rfc1982&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5405] Eggert, L. and G. Fairhurst, &#34;Unicast UDP Usage Guidelines for Application Designers&#34;, BCP 145, RFC 5405, DOI 10.17487/RFC5405, November 2008, &lt;http://www.rfc-editor.org/info/rfc5405&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5405] Eggert、L。およびG. Fairhurst、「アプリケーション設計者のためのユニキャストUDP使用ガイドライン」、BCP 145、RFC 5405、DOI 10.17487 / RFC5405、2008年11月、&lt;http://www.rfc-editor.org/info / rfc5405&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5989] Roach, A., &#34;A SIP Event Package for Subscribing to Changes to an HTTP Resource&#34;, RFC 5989, DOI 10.17487/RFC5989, October 2010, &lt;http://www.rfc-editor.org/info/rfc5989&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5989] Roach、A。、「HTTPリソースへの変更をサブスクライブするためのSIPイベントパッケージ」、RFC 5989、DOI 10.17487 / RFC5989、2010年10月、&lt;http://www.rfc-editor.org/info/rfc5989 &gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6202] Loreto, S., Saint-Andre, P., Salsano, S., and G. Wilkins, &#34;Known Issues and Best Practices for the Use of Long Polling and Streaming in Bidirectional HTTP&#34;, RFC 6202, DOI 10.17487/RFC6202, April 2011, &lt;http://www.rfc-editor.org/info/rfc6202&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6202] Loreto、S.、Saint-Andre、P.、Salsano、S。、およびG. Wilkins、「双方向HTTPでのロングポーリングとストリーミングの使用に関する既知の問題とベストプラクティス」、RFC 6202、DOI 10.17487 / RFC6202、2011年4月、&lt;http://www.rfc-editor.org/info/rfc6202&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6690] Shelby, Z., &#34;Constrained RESTful Environments (CoRE) Link Format&#34;, RFC 6690, DOI 10.17487/RFC6690, August 2012, &lt;http://www.rfc-editor.org/info/rfc6690&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6690] Shelby、Z。、「Constrained RESTful Environments（CoRE）Link Format」、RFC 6690、DOI 10.17487 / RFC6690、2012年8月、&lt;http://www.rfc-editor.org/info/rfc6690&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7228] Bormann, C., Ersue, M., and A. Keranen, &#34;Terminology for Constrained-Node Networks&#34;, RFC 7228, DOI 10.17487/RFC7228, May 2014, &lt;http://www.rfc-editor.org/info/rfc7228&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7228] Bormann、C.、Ersue、M.、and A. Keranen、 &#34;Terminology for Constrained-Node Networks&#34;、RFC 7228、DOI 10.17487 / RFC7228、May 2014、&lt;http://www.rfc-editor.org / info / rfc7228&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., &#34;Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing&#34;, RFC 7230, DOI 10.17487/RFC7230, June 2014, &lt;http://www.rfc-editor.org/info/rfc7230&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7230]フィールディング、R。、エド。およびJ. Reschke編、「Hypertext Transfer Protocol（HTTP / 1.1）：Message Syntax and Routing」、RFC 7230、DOI 10.17487 / RFC7230、2014年6月、&lt;http://www.rfc-editor.org/info/ rfc7230&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-A--Examples">
Appendix A. Examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録A.例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-1--ClientServer-Examples">
A.1. Client/Server Examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.1. クライアント/サーバーの例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Observed   CLIENT  SERVER     Actual
     t   State         |      |         State
         ____________  |      |  ____________
     1                 |      |
     2    unknown      |      |     18.5 Cel
     3                 +-----&gt;|                  Header: GET 0x41011633
     4                 | GET  |                   Token: 0x4a
     5                 |      |                Uri-Path: temperature
     6                 |      |                 Observe: 0 (register)
     7                 |      |
     8                 |      |
     9   ____________  |&lt;-----+                  Header: 2.05 0x61451633
    10                 | 2.05 |                   Token: 0x4a
    11    18.5 Cel     |      |                 Observe: 9
    12                 |      |                 Max-Age: 15
    13                 |      |                 Payload: &#34;18.5 Cel&#34;
    14                 |      |
    15                 |      |  ____________
    16   ____________  |&lt;-----+                  Header: 2.05 0x51457b50
    17                 | 2.05 |     19.2 Cel      Token: 0x4a
    18    19.2 Cel     |      |                 Observe: 16
    29                 |      |                 Max-Age: 15
    20                 |      |                 Payload: &#34;19.2 Cel&#34;
    21                 |      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     Figure 3: A Client Registers and Receives One Notification of the
         Current State and One of a New State upon a State Change
         Observed   CLIENT  SERVER     Actual
     t   State         |      |         State
         ____________  |      |  ____________
    22                 |      |
    23    19.2 Cel     |      |     19.2 Cel
    24                 |      |  ____________
    25                 | X----+                  Header: 2.05 0x51457b51
    26                 | 2.05 |     19.7 Cel      Token: 0x4a
    27                 |      |                 Observe: 25
    28                 |      |                 Max-Age: 15
    29                 |      |                 Payload: &#34;19.7 Cel&#34;
    30                 |      |
    31   ____________  |      |
    32                 |      |
    33    19.2 Cel     |      |
    34    (stale)      |      |
    35                 |      |
    36                 |      |
    37                 |      |
    38                 +-----&gt;|                  Header: GET 0x41011634
    39                 | GET  |                   Token: 0xb2
    40                 |      |                Uri-Path: temperature
    41                 |      |                 Observe: 0 (register)
    42                 |      |
    43                 |      |
    44   ____________  |&lt;-----+                  Header: 2.05 0x61451634
    45                 | 2.05 |                   Token: 0xb2
    46    19.7 Cel     |      |                 Observe: 44
    47                 |      |                 Max-Age: 15
    48                 |      |                    ETag: 0x78797a7a79
    49                 |      |                 Payload: &#34;19.7 Cel&#34;
    50                 |      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
Figure 4: The Client Re-registers after Max-Age Ends
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
図4：Max-Ageの終了後にクライアントが再登録する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Observed   CLIENT  SERVER     Actual
     t   State         |      |         State
         ____________  |      |  ____________
    51                 |      |
    52    19.7 Cel     |      |     19.7 Cel
    53                 |      |
    54                 |      |  ____________
    55                 |    crash
    56                 |
    57                 |
    58                 |
    59   ____________  |
    60                 |
    61    19.7 Cel     |
    62    (stale)      |
    63                 |   reboot____________
    64                 |      |
    65                 |      |     20.0 Cel
    66                 |      |
    67                 +-----&gt;|                  Header: GET 0x41011635
    68                 | GET  |                   Token: 0xf9
    69                 |      |                Uri-Path: temperature
    70                 |      |                 Observe: 0 (register)
    71                 |      |                    ETag: 0x78797a7a79
    72                 |      |
    73                 |      |
    74   ____________  |&lt;-----+                  Header: 2.05 0x61451635
    75                 | 2.05 |                   Token: 0xf9
    76    20.0 Cel     |      |                 Observe: 74
    77                 |      |                 Max-Age: 15
    78                 |      |                 Payload: &#34;20.0 Cel&#34;
    79                 |      |
    80                 |      |  ____________
    81   ____________  |&lt;-----+                  Header: 2.03 0x5143aa0c
    82                 | 2.03 |     19.7 Cel      Token: 0xf9
    83    19.7 Cel     |      |                 Observe: 81
    84                 |      |                    ETag: 0x78797a7a79
    85                 |      |                 Max-Age: 15
    86                 |      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Figure 5: The Client Re-registers and Gives the Server the Opportunity to Select a Stored Response
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
図5：クライアントが再登録し、サーバーに保存された応答を選択する機会を与える
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Observed   CLIENT  SERVER     Actual
     t   State         |      |         State
         ____________  |      |  ____________
    87                 |      |
    88    19.7 Cel     |      |     19.7 Cel
    89                 |      |
    90                 |      |  ____________
    91   ____________  |&lt;-----+                  Header: 2.05 0x4145aa0f
    92                 | 2.05 |     19.3 Cel      Token: 0xf9
    93    19.3 Cel     |      |                 Observe: 91
    94                 |      |                 Max-Age: 15
    95                 |      |                 Payload: &#34;19.3 Cel&#34;
    96                 |      |
    97                 |      |
    98                 +- - -&gt;|                  Header: 0x7000aa0f
    99                 |      |
   100                 |      |
   101                 |      |
   102                 |      |  ____________
   103                 |      |
   104                 |      |     19.0 Cel
   105                 |      |
   106   ____________  |      |
   107                 |      |
   108    19.3 Cel     |      |
   109    (stale)      |      |
   110                 |      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
Figure 6: The Client Rejects a Notification and Thereby Cancels the Observation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
図6：クライアントは通知を拒否し、それによって観察をキャンセルします
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-2--Proxy-Examples">
A.2. Proxy Examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2. プロキシの例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   CLIENT  PROXY  SERVER
      |      |      |
      |      +-----&gt;|     Header: GET 0x41015fb8
      |      | GET  |      Token: 0x1a
      |      |      |   Uri-Host: sensor.example
      |      |      |   Uri-Path: status
      |      |      |    Observe: 0 (register)
      |      |      |
      |      |&lt;-----+     Header: 2.05 0x61455fb8
      |      | 2.05 |      Token: 0x1a
      |      |      |    Observe: 42
      |      |      |    Max-Age: 60
      |      |      |    Payload: &#34;ready&#34;
      |      |      |
      +-----&gt;|      |     Header: GET 0x41011633
      | GET  |      |      Token: 0x9a
      |      |      |  Proxy-Uri: coap://sensor.example/status
      |      |      |
      |&lt;-----+      |     Header: 2.05 0x61451633
      | 2.05 |      |      Token: 0x9a
      |      |      |    Max-Age: 53
      |      |      |    Payload: &#34;ready&#34;
      |      |      |
      |      |&lt;-----+     Header: 2.05 0x514505fc0
      |      | 2.05 |      Token: 0x1a
      |      |      |    Observe: 135
      |      |      |    Max-Age: 60
      |      |      |    Payload: &#34;busy&#34;
      |      |      |
      +-----&gt;|      |     Header: GET 0x41011634
      | GET  |      |      Token: 0x9b
      |      |      |  Proxy-Uri: coap://sensor.example/status
      |      |      |
      |&lt;-----+      |     Header: 2.05 0x61451634
      | 2.05 |      |      Token: 0x9b
      |      |      |    Max-Age: 49
      |      |      |    Payload: &#34;busy&#34;
      |      |      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
Figure 7: A Proxy Observes a Resource to Keep its Cache Up to Date
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
図7：プロキシがリソースを監視してキャッシュを最新の状態に保つ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   CLIENT  PROXY  SERVER
      |      |      |
      +-----&gt;|      |     Header: GET 0x41011635
      | GET  |      |      Token: 0x6a
      |      |      |  Proxy-Uri: coap://sensor.example/status
      |      |      |    Observe: 0 (register)
      |      |      |
      |&lt;- - -+      |     Header: 0x60001635
      |      |      |
      |      +-----&gt;|     Header: GET 0x4101af90
      |      | GET  |      Token: 0xaa
      |      |      |   Uri-Host: sensor.example
      |      |      |   Uri-Path: status
      |      |      |    Observe: 0 (register)
      |      |      |
      |      |&lt;-----+     Header: 2.05 0x6145af90
      |      | 2.05 |      Token: 0xaa
      |      |      |    Observe: 67
      |      |      |    Max-Age: 60
      |      |      |    Payload: &#34;ready&#34;
      |      |      |
      |&lt;-----+      |     Header: 2.05 0x4145af94
      | 2.05 |      |      Token: 0x6a
      |      |      |    Observe: 17346
      |      |      |    Max-Age: 60
      |      |      |    Payload: &#34;ready&#34;
      |      |      |
      +- - -&gt;|      |     Header: 0x6000af94
      |      |      |
      |      |&lt;-----+     Header: 2.05 0x51455a20
      |      | 2.05 |      Token: 0xaa
      |      |      |    Observe: 157
      |      |      |    Max-Age: 60
      |      |      |    Payload: &#34;busy&#34;
      |      |      |
      |&lt;-----+      |     Header: 2.05 0x5145af9b
      | 2.05 |      |      Token: 0x6a
      |      |      |    Observe: 17436
      |      |      |    Max-Age: 60
      |      |      |    Payload: &#34;busy&#34;
      |      |      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Figure 8: A Client Observes a Resource through a Proxy
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
図8：クライアントがプロキシを介してリソースを監視する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgements
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Carsten Bormann was an original author of this document and is acknowledged for significant contribution to this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Carsten Bormannはこのドキュメントの原作者であり、このドキュメントへの多大な貢献により認められています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thanks to Daniele Alessandrelli, Jari Arkko, Peter A. Bigot, Angelo P. Castellani, Gilbert Clark, Esko Dijk, Thomas Fossati, Brian Frank, Bert Greevenbosch, Jeroen Hoebeke, Cullen Jennings, Matthias Kovatsch, Barry Leiba, Salvatore Loreto, Charles Palmer, Akbar Rahman, Zach Shelby, and Floris Van den Abeele for helpful comments and discussions that have shaped the document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ダニエル・アレッサンドレリ、ヤリ・アルコ、ピーター・A・ビゴ、アンジェロ・P・カステラーニ、ギルバート・クラーク、エスコ・ダイク、トーマス・フォッサティ、ブライアン・フランク、バート・グリーベンボッシュ、イェローエン・ホーベケ、カレン・ジェニングス、マティアス・コヴァッチ、バリー・レイバ、シャルヴァトーレ・ロレトのおかげで、Akbar Rahman、Zach Shelby、およびFloris Van den Abeeleは、ドキュメントを形成した有益なコメントとディスカッションを求めています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This work was supported in part by Klaus Tschira Foundation, Intel, Cisco, and Nokia.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この作品は、Klaus Tschira Foundation、Intel、Cisco、Nokiaによって部分的にサポートされました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Author&#39;s Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Klaus Hartke Universitaet Bremen TZI Postfach 330440 Bremen D-28359 Germany
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Klaus Hartke Universitaet Bremen TZI PO Box 330440ブレーメンD-28359ドイツ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +49-421-218-63905
   Email: hartke@tzi.org
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
