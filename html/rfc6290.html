<!DOCTYPE html>


<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 6290 - A Quick Crash Detection Method for the Internet Key Exchange Protocol (IKE) 日本語訳</title>

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">6290</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc6290">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 6290 - A Quick Crash Detection Method for the Internet Key Exchange Protocol (IKE) 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc6290">
            https://datatracker.ietf.org/doc/html/rfc6290
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 6290 - インターネットキーエクスチェンジプロトコル（IKE）のクイッククラッシュ検出方法</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <h6 class="card-title">要約（自動生成）</h6>
            <p class="card-text">RFC 6290は、IKEプロトコルのクラッシュ検出方法についての要約です。このRFCの目的は、IKEプロトコルの安定性と信頼性を向上させるために、クラッシュの検出と回復を効果的に行う方法を提案することです。</p>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                       Y. Nir, Ed.
Request for Comments: 6290                                   Check Point
Category: Standards Track                                  D. Wierbowski
ISSN: 2070-1721                                                      IBM
                                                             F. Detienne
                                                                P. Sethi
                                                                   Cisco
                                                               June 2011
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
A Quick Crash Detection Method for the Internet Key Exchange Protocol (IKE)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
インターネットキーエクスチェンジプロトコル（IKE）のクイッククラッシュ検出方法
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes an extension to the Internet Key Exchange Protocol version 2 (IKEv2) that allows for faster detection of Security Association (SA) desynchronization using a saved token.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、保存されたトークンを使用したセキュリティ協会（SA）の非同期化をより迅速に検出できるようにするインターネットキーエクスチェンジプロトコルバージョン2（IKEV2）への拡張について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an IPsec tunnel between two IKEv2 peers is disconnected due to a restart of one peer, it can take as much as several minutes for the other peer to discover that the reboot has occurred, thus delaying recovery. In this text, we propose an extension to the protocol that allows for recovery immediately following the restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つのピアの再起動のために2つのIKEV2ピアの間のIPSECトンネルが切断されると、他のピアが再起動が発生したことを発見するのに数分もかかる可能性があり、回復が遅れます。このテキストでは、再起動後すぐに回復できるプロトコルへの拡張を提案します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、インターネット標準トラックドキュメントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 5741のセクション2で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6290.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、http：//www.rfc-editor.org/info/rfc6290で取得できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）2011 IETF Trustおよび文書著者として特定された人。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、BCP 78およびIETFドキュメント（http://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、単純化されたBSDライセンスで説明されているように保証なしで提供される簡略化されたBSDライセンステキストを含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
     1.1.  Conventions Used in This Document  . . . . . . . . . . . .  3
   2.  RFC 5996 Crash Recovery  . . . . . . . . . . . . . . . . . . .  4
   3.  Protocol Outline . . . . . . . . . . . . . . . . . . . . . . .  5
   4.  Formats and Exchanges  . . . . . . . . . . . . . . . . . . . .  6
     4.1.  Notification Format  . . . . . . . . . . . . . . . . . . .  6
     4.2.  Passing a Token in the AUTH Exchange . . . . . . . . . . .  7
     4.3.  Replacing Tokens after Rekey or Resumption . . . . . . . .  8
     4.4.  Replacing the Token for an Existing SA . . . . . . . . . .  9
     4.5.  Presenting the Token in an Unprotected Message . . . . . .  9
   5.  Token Generation and Verification  . . . . . . . . . . . . . . 10
     5.1.  A Stateless Method of Token Generation . . . . . . . . . . 11
     5.2.  A Stateless Method with IP Addresses . . . . . . . . . . . 11
     5.3.  Token Lifetime . . . . . . . . . . . . . . . . . . . . . . 12
   6.  Backup Gateways  . . . . . . . . . . . . . . . . . . . . . . . 12
   7.  Interaction with Session Resumption  . . . . . . . . . . . . . 13
   8.  Operational Considerations . . . . . . . . . . . . . . . . . . 14
     8.1.  Who Should Implement This Specification  . . . . . . . . . 14
     8.2.  Response to Unknown Child SPI  . . . . . . . . . . . . . . 15
   9.  Security Considerations  . . . . . . . . . . . . . . . . . . . 16
     9.1.  QCD Token Generation and Handling  . . . . . . . . . . . . 16
     9.2.  QCD Token Transmission . . . . . . . . . . . . . . . . . . 17
     9.3.  QCD Token Enumeration  . . . . . . . . . . . . . . . . . . 18
   10. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 18
   11. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 18
   12. References . . . . . . . . . . . . . . . . . . . . . . . . . . 19
     12.1. Normative References . . . . . . . . . . . . . . . . . . . 19
     12.2. Informative References . . . . . . . . . . . . . . . . . . 19
   Appendix A.  The Path Not Taken  . . . . . . . . . . . . . . . . . 20
     A.1.  Initiating a New IKE SA  . . . . . . . . . . . . . . . . . 20
     A.2.  SIR  . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
     A.3.  Birth Certificates . . . . . . . . . . . . . . . . . . . . 20
     A.4.  Reducing Liveness Check Length . . . . . . . . . . . . . . 21
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKEv2, as described in [RFC5996] and its predecessor RFC 4306, has a method for recovering from a reboot of one peer. As long as traffic flows in both directions, the rebooted peer should re-establish the tunnels immediately. However, in many cases, the rebooted peer is a VPN gateway that protects only servers, so all traffic is inbound. In other cases, the non-rebooted peer has a dynamic IP address, so the rebooted peer cannot initiate IKE because its current IP address is unknown. In such cases, the rebooted peer will not be able to re-establish the tunnels. Section 2 describes how recovery works under RFC 5996, and explains why it may take several minutes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5996]とその前身RFC 4306で説明されているように、IKEV2には、1つのピアの再起動から回復する方法があります。トラフィックが両方向に流れる限り、再起動されたピアはすぐにトンネルを再確立するはずです。ただし、多くの場合、再起動されたピアはサーバーのみを保護するVPNゲートウェイであるため、すべてのトラフィックがインバウンドです。それ以外の場合、再弾丸のピアには動的なIPアドレスがあるため、現在のIPアドレスが不明であるため、再起動されたピアはIKEを開始できません。そのような場合、再起動されたピアはトンネルを再確立することができません。セクション2では、RFC 5996の下での回復の仕組みについて説明し、数分かかる理由について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The method proposed here is to send an octet string, called a &#34;QCD token&#34;, in the IKE_AUTH exchange that establishes the tunnel. That token can be stored on the peer as part of the IKE SA. After a reboot, the rebooted implementation can re-generate the token and send it to the peer, so as to delete the IKE SA. Deleting the IKE SA results in a quick establishment of new IPsec tunnels. This is described in Section 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで提案されている方法は、トンネルを確立するIKE_AUTH Exchangeで、「QCDトークン」と呼ばれるOctet Stringを送信することです。そのトークンは、IKE SAの一部としてピアに保存できます。再起動した後、再起動した実装は、トークンを再発生してピアに送信して、IKE SAを削除することができます。IKE SAを削除すると、新しいIPSECトンネルが迅速に確立されます。これはセクション3で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-1--Conventions-Used-in-This-Document">
1.1. Conventions Used in This Document
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. このドキュメントで使用されている規則
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「必須」、「そうしない」、「必須」、「必要」、「しない」、「そうしない」、「そうではない」、「そうでない」、「推奨」、「5月」、および「オプション」は、[RFC2119]に記載されているように解釈される。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The term &#34;token&#34; refers to an octet string that an implementation can generate using only the properties of a protected IKE message (such as IKE Security Parameter Indexes (SPIs)) as input. A conforming implementation MUST be able to generate the same token from the same input even after rebooting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「トークン」という用語は、入力として保護されたIKEメッセージ（IKEセキュリティパラメーターインデックス（SPI）など）のプロパティのみを使用して実装が生成できるオクテット文字列を指します。適合実装は、再起動後でも同じ入力から同じトークンを生成できる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The term &#34;token maker&#34; refers to an implementation that generates a token and sends it to the peer as specified in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「トークンメーカー」という用語は、トークンを生成し、このドキュメントで指定されているようにピアに送信する実装を指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The term &#34;token taker&#34; refers to an implementation that stores such a token or a digest thereof, in order to verify that a new token it receives is identical to the old token it has stored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「トークンテイカー」という用語は、そのようなトークンまたはそのダイジェストを保存する実装を指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The term &#34;non-volatile storage&#34; in this document refers to a data storage module that persists across restarts of the token maker. Examples of such a storage module include an internal disk, an internal flash memory module, an external disk, and an external database. A small non-volatile storage module is required for a token maker, but a larger one can be used to enhance performance, as described in Section 8.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの「不揮発性ストレージ」という用語は、トークンメーカーの再起動全体で持続するデータストレージモジュールを指します。このようなストレージモジュールの例には、内部ディスク、内部フラッシュメモリモジュール、外部ディスク、および外部データベースが含まれます。トークンメーカーには小さな不揮発性ストレージモジュールが必要ですが、セクション8.2で説明されているように、パフォーマンスを向上させるために、より大きなものを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--RFC-5996-Crash-Recovery">
2. RFC 5996 Crash Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. RFC 5996クラッシュ回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When one peer loses state or reboots, the other peer does not get any notification, so unidirectional IPsec traffic can still flow. The rebooted peer will not be able to decrypt it, however, and the only remedy is to send an unprotected INVALID_SPI notification as described in Section 3.10.1 of [RFC5996]. That section also describes the processing of such a notification:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つのピアが状態または再起動を失うと、もう1つのピアが通知を受け取らないため、単方向のIPSECトラフィックは引き続き流れる可能性があります。ただし、再起動されたピアはそれを復号化することはできません。唯一の救済策は、[RFC5996]のセクション3.10.1で説明されているように、保護されていない無効な_SPI通知を送信することです。そのセクションでは、そのような通知の処理についても説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If this Informational Message is sent outside the context of an IKE_SA, it should be used by the recipient only as a &#34;hint&#34; that something might be wrong (because it could easily be forged).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この情報メッセージがIKE_SAのコンテキストの外で送信される場合、受信者は何かが間違っている可能性があるという「ヒント」としてのみ使用する必要があります（簡単に偽造できるため）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the INVALID_SPI can only be used as a hint, the non-rebooted peer has to determine whether the IPsec SA and indeed the parent IKE SA are still valid. The method of doing this is described in Section 2.4 of [RFC5996]. This method, called &#34;liveness check&#34;, involves sending a protected empty INFORMATIONAL message, and awaiting a response. This procedure is sometimes referred to as &#34;Dead Peer Detection&#34; or DPD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Invalid_spiはヒントとしてのみ使用できるため、非再開のピアは、IPSEC SAと実際に親IKE SAがまだ有効かどうかを判断する必要があります。これを行う方法は、[RFC5996]のセクション2.4で説明されています。「livesing Check」と呼ばれるこの方法では、保護された空の情報メッセージを送信し、応答を待ちます。この手順は、「デッドピア検出」またはDPDと呼ばれることもあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 2.4 does not mandate how many times the liveness check message should be retransmitted, or for how long, but does recommend the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション2.4では、livenessチェックメッセージを再送信する回数、またはどのくらいの期間を義務付けていませんが、以下を推奨しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
It is suggested that messages be retransmitted at least a dozen times over a period of at least several minutes before giving up on an SA...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SAをあきらめる前に、少なくとも数分間にわたって少なくとも数十回メッセージを再送信することが提案されています...
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Those &#34;at least several minutes&#34; are a time during part of which both peers are active, but IPsec cannot be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの「少なくとも数分」は、両方のピアがアクティブな時期ですが、IPSECは使用できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Especially in the case of a reboot (rather than fail-over or administrative clearing of state), the peer does not recover immediately. Reboot, depending on the system, may take from a few seconds to a few minutes. This means that at first the peer just goes silent, i.e., does not send or respond to any messages. IKEv2 implementations can detect this situation and follow the rules given in Section 2.4:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に、再起動の場合（州のフェールオーバーまたは管理上の清算ではなく）、ピアはすぐに回復しません。再起動は、システムに応じて、数秒から数分かかる場合があります。これは、最初はピアが沈黙していること、つまりメッセージを送信または応答しないことを意味します。IKEV2の実装は、この状況を検出し、セクション2.4に記載されているルールに従うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If there has only been outgoing traffic on all of the SAs associated with an IKE SA, it is essential to confirm liveness of the other endpoint to avoid black holes. If no cryptographically protected messages have been received on an IKE SA or any of its Child SAs recently, the system needs to perform a liveness check in order to prevent sending messages to a dead peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IKE SAに関連付けられたすべてのSASに発信トラフィックしかなかった場合、ブラックホールを避けるために他のエンドポイントの活性を確認することが不可欠です。最近、IKE SAまたはその子SASの暗号化されたメッセージを受信していない場合、システムは、デッドピアにメッセージを送信するのを防ぐために、活性チェックを実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5996] does not mandate any time limits, but it is possible that the peer will start liveness checks even before the other end is sending INVALID_SPI notification, as it detected that the other end is not sending any packets anymore while it is still rebooting or recovering from the situation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5996]は時間制限を義務付けていませんが、反対側が再起動または再起動中にパケットを送信しなくなっていることを検出したため、他の端がInvalid_Spi通知を送信する前に、ピアが快適なチェックを開始する可能性があります。状況から回復します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This means that the several minutes recovery period is overlapping the actual recover time of the other peer; i.e., if the security gateway requires several minutes to boot up from the crash, then the other peers have already finished their liveness checks before the crashing peer even has a chance to send INVALID_SPI notifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、数分の回復期間が他のピアの実際の回復時間と重複していることを意味します。つまり、セキュリティゲートウェイがクラッシュから起動するために数分を必要とする場合、他のピアは、クラッシュするピアがInvalID_SPI通知を送信する機会さえある前に、すでに活気のチェックを終了しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are cases where the peer loses state and is able to recover immediately; in those cases it might take several minutes to recreate the IPsec SAs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアが状態を失い、すぐに回復できる場合があります。そのような場合、IPSEC SASを再現するには数分かかる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the IKEv2 specification specifically gives no guidance for the number of retries or the length of timeouts, as these do not affect interoperability. This means that implementations are allowed to use the hints provided by the INVALID_SPI messages to shorten those timeouts (i.e., a different environment and situation requiring different rules).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKEV2仕様は、相互運用性に影響を与えないため、RETRIERの数またはタイムアウトの長さのガイダンスを特に提供しないことに注意してください。これは、実装がInvalID_SPIメッセージによって提供されるヒントを使用して、それらのタイムアウトを短縮することが許可されていることを意味します（つまり、異なるルールを必要とする異なる環境と状況）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some existing IKEv2 implementations already do that (i.e., shorten timeouts or limit number of retries) based on these kinds of hints and also start liveness checks quickly after the other end goes silent. However, see Appendix A.4 for a discussion of why this may not be enough.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
既存のIKEV2実装の中には、これらの種類のヒントに基づいて既にそれを行っています（つまり、タイムアウトを短縮するか、レトリの数を制限します）。ただし、なぜこれで十分でない可能性があるのかについての議論については、付録A.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Protocol-Outline">
3. Protocol Outline
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. プロトコルの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Supporting implementations will send a notification, called a &#34;QCD token&#34;, as described in Section 4.1 in the first IKE_AUTH exchange messages. These are the first IKE_AUTH request and final IKE_AUTH response that contain the AUTH payloads. The generation of these tokens is a local matter for implementations, but considerations are described in Section 5. Implementations that send such a token will be called &#34;token makers&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装をサポートすると、最初のIKE_AUTH Exchangeメッセージのセクション4.1で説明されているように、「QCDトークン」と呼ばれる通知が送信されます。これらは、認証ペイロードを含む最初のIKE_AUTHリクエストと最終的なIKE_AUTH応答です。これらのトークンの生成は実装のためのローカルな問題ですが、考慮事項はセクション5で説明されています。そのようなトークンを送信する実装は「トークンメーカー」と呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A supporting implementation receiving such a token MUST store it (or a digest thereof) along with the IKE SA. Implementations that support this part of the protocol will be called &#34;token takers&#34;. Section 8.1 has considerations for which implementations need to be token takers, and which should be token makers. Implementations that are not token takers will silently ignore QCD tokens.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このようなトークンを受け取るサポート実装では、IKE SAとともにそれを保存（またはそのダイジェスト）が保存する必要があります。プロトコルのこの部分をサポートする実装は、「トークンテイカー」と呼ばれます。セクション8.1には、どの実装がトークンテイカーである必要があり、どの実装がトークンメーカーである必要があるかについての考慮事項があります。トークンテイカーではない実装は、QCDトークンを静かに無視します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a token maker receives a protected IKE request message with unknown IKE SPIs, it SHOULD generate a new token that is identical to the previous token, and send it to the requesting peer in an unprotected IKE message as described in Section 4.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークンメーカーが未知のIKEスピスを使用して保護されたIKE要求メッセージを受信すると、前のトークンと同一の新しいトークンを生成し、セクション4.5で説明した保護されていないIKEメッセージでリクエストピアに送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a token taker receives the QCD token in an unprotected notification, it MUST verify that the TOKEN_SECRET_DATA matches the token stored with the matching IKE SA. If the verification fails, or if the IKE SPIs in the message do not match any existing IKE SA, it SHOULD log the event. If it succeeds, it MUST silently delete the IKE SA associated with the IKE_SPI fields and all dependent child SAs. This event MAY also be logged. The token taker MUST accept such tokens from any IP address and port combination, so as to allow different kinds of high-availability configurations of the token maker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークンテイカーが保護されていない通知でQCDトークンを受け取った場合、token_secret_dataが一致するIKE SAと保存されているトークンと一致することを確認する必要があります。検証が失敗した場合、またはメッセージ内のIKE SPIが既存のIKESAと一致しない場合、イベントを記録する必要があります。それが成功した場合、IKE_SPIフィールドとすべての依存した子SASに関連するIKE SAを静かに削除する必要があります。このイベントも記録される場合があります。トークンテイカーは、トークンメーカーのさまざまな種類の高可用性構成を可能にするために、任意のIPアドレスとポートの組み合わせからそのようなトークンを受け入れる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A supporting token taker MAY immediately create new SAs using an Initial exchange, or it may wait for subsequent traffic to trigger the creation of new SAs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サポートするトークンテイカーは、初期交換を使用してすぐに新しいSASを作成するか、後続のトラフィックが新しいSASの作成をトリガーするのを待つ場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 7 for a short discussion about this extension&#39;s interaction with IKEv2 Session Resumption ([RFC5723]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この拡張機能とIKEV2セッションの再開（[RFC5723]）との相互作用についての短い議論については、セクション7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Formats-and-Exchanges">
4. Formats and Exchanges
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. フォーマットと交換
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--Notification-Format">
4.1. Notification Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 通知形式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notification payload called &#34;QCD token&#34; is formatted as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「QCDトークン」と呼ばれる通知ペイロードは、次のようにフォーマットされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                            1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       ! Next Payload  !C!  RESERVED   !         Payload Length        !
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       !  Protocol ID  !   SPI Size    ! QCD Token Notify Message Type !
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       !                                                               !
       ~                       TOKEN_SECRET_DATA                       ~
       !                                                               !
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Protocol ID (1 octet) MUST be 1, as this message is related to an IKE SA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o このメッセージはIKE SAに関連しているため、プロトコルID（1 Octet）は1でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SPI Size (1 octet) MUST be zero, in conformance with Section 3.10 of [RFC5996].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o [RFC5996]のセクション3.10に準拠して、SPIサイズ（1オクテット）はゼロでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o QCD Token Notify Message Type (2 octets) - MUST be 16419, the value assigned for QCD token notifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o QCDトークン通知メッセージタイプ（2オクテット） -  QCDトークン通知に割り当てられた値は16419でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TOKEN_SECRET_DATA (variable) contains a generated token as described in Section 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o token_secret_data（変数）には、セクション5で説明されているように生成されたトークンが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2--Passing-a-Token-in-the-AUTH-Exchange">
4.2. Passing a Token in the AUTH Exchange
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. 認証交換でトークンを渡します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For brevity, only the Extensible Authentication Protocol (EAP) version of an AUTH exchange will be presented here. The non-EAP version is very similar. The figures below are based on Appendix C.3 of [RFC5996].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
簡潔にするために、認証交換の拡張可能な認証プロトコル（EAP）バージョンのみがここに表示されます。EAP以外のバージョンは非常に似ています。以下の図は、[RFC5996]の付録C.3に基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
first request --&gt; IDi, [N(INITIAL_CONTACT)], [[N(HTTP_CERT_LOOKUP_SUPPORTED)], CERTREQ+], [IDr], [N(QCD_TOKEN)] [CP(CFG_REQUEST)], [N(IPCOMP_SUPPORTED)+], [N(USE_TRANSPORT_MODE)], [N(ESP_TFC_PADDING_NOT_SUPPORTED)], [N(NON_FIRST_FRAGMENTS_ALSO)], SA, TSi, TSr, [V+]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
最初のリクエスト - &gt; idi、[n（initial_contact）]、[[n（http_cert_lookup_supported）]、certreq]、[idr]、[n（qcd_token）] [cfg_request）]]]、[n（ipcomp_supported）]、[n（use_transport_mode）]、[n（esp_tfc_padding_not_supported）]、[n（non_first_fragments_also）]、sa、tsi、tsr、[v]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
first response &lt;-- IDr, [CERT+], AUTH, EAP, [V+]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
最初の応答&lt;-idr、[cert]、auth、eap、[v]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 / --&gt; EAP repeat 1..N times | \ &lt;-- EAP
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
/  - &gt; EAP Repeat 1..n times |\ &lt;-EAP
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
last request --&gt; AUTH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
最後のリクエスト - &gt; auth
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
last response &lt;-- AUTH, [N(QCD_TOKEN)] [CP(CFG_REPLY)], [N(IPCOMP_SUPPORTED)], [N(USE_TRANSPORT_MODE)], [N(ESP_TFC_PADDING_NOT_SUPPORTED)], [N(NON_FIRST_FRAGMENTS_ALSO)], SA, TSi, TSr, [N(ADDITIONAL_TS_POSSIBLE)], [V+]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
最後の応答&lt; -  auth、[n（qcd_token）] [cp（cfg_reply）]、[n（ipcomp_supported）]、[n（use_transport_mode）]、[n（esp_tfc_padding_not_supported）]、[n（non_first_fragments_also）、saTSI、TSR、[n（additional_ts_possible）]、[v]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the QCD_TOKEN notification is marked as optional because it is not required by this specification that every implementation be both token maker and token taker. If only one peer sends the QCD token, then a reboot of the other peer will not be recoverable by this method. This may be acceptable if traffic typically originates from the other peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QCD_TOKEN通知は、すべての実装がトークンメーカーとトークンテイカーの両方であることをこの仕様では必須ではないため、オプションとしてマークされていることに注意してください。1つのピアのみがQCDトークンを送信する場合、他のピアの再起動はこの方法で回復できません。これは、通常、トラフィックが他のピアから発生する場合に受け入れられる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In any case, the lack of a QCD_TOKEN notification MUST NOT be taken as an indication that the peer does not support this standard. Conversely, if a peer does not understand this notification, it will simply ignore it. Therefore, a peer may send this notification freely, even if it does not know whether the other side supports it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いずれにせよ、QCD_TOKEN通知の欠如は、ピアがこの基準をサポートしていないことを示す兆候とみなす必要はありません。逆に、ピアがこの通知を理解していない場合、それは単にそれを無視します。したがって、ピアは、反対側がそれをサポートしているかどうかがわからない場合でも、この通知を自由に送信する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The QCD_TOKEN notification is related to the IKE SA and should follow the AUTH payload and precede the Configuration payload and all payloads related to the child SA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QCD_TOKEN通知はIKE SAに関連しており、認証ペイロードに従っており、構成ペイロードとChild SAに関連するすべてのペイロードに先行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3--Replacing-Tokens-after-Rekey-or-Resumption">
4.3. Replacing Tokens after Rekey or Resumption
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Rekeyまたは再開後のトークンを交換します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After rekeying an IKE SA, the IKE SPIs are replaced, so the new SA also needs to have a token. If only the responder in the rekey exchange is the token maker, this can be done within the CREATE_CHILD_SA exchange. If the initiator is a token maker, then we need an extra informational exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ike SAを再キーした後、Ike Spisが交換されるため、新しいSAにはトークンも必要です。Reke ExchangeのResponderのみがトークンメーカーである場合、これはcreate_child_sa Exchange内で実行できます。イニシエーターがトークンメーカーの場合、追加の情報交換が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following figure shows the CREATE_CHILD_SA exchange for rekeying the IKE SA. Only the responder sends a QCD token.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の図は、IKE SAを再キーするためのcreate_child_sa Exchangeを示しています。応答者のみがQCDトークンを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
request --&gt; SA, Ni, [KEi]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
リクエスト - &gt; sa、ni、[kei]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
response &lt;-- SA, Nr, [KEr], N(QCD_TOKEN)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
応答&lt;-Sa、nr、[ker]、n（qcd_token）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the initiator is also a token maker, it SHOULD initiate an INFORMATIONAL exchange immediately after the CREATE_CHILD_SA exchange as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエーターがトークンメーカーでもある場合、次のようにcreate_child_sa交換の直後に情報交換を開始する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      request             --&gt; N(QCD_TOKEN)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
response &lt;--
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
応答&lt; - 
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For session resumption, as specified in [RFC5723], the situation is similar. The responder, which is necessarily the peer that has crashed, SHOULD send a new ticket within the protected payload of the IKE_SESSION_RESUME exchange. If the Initiator is also a token maker, it needs to send a QCD_TOKEN in a separate INFORMATIONAL exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5723]で指定されているように、セッション再開の場合、状況は似ています。必然的にクラッシュしたピアであるレスポンダーは、IKE_SESSION_RESUME Exchangeの保護されたペイロード内で新しいチケットを送信する必要があります。イニシエーターがトークンメーカーでもある場合、別の情報交換でQCD_TOKENを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The INFORMATIONAL exchange described in this section can also be used if QCD tokens need to be replaced due to a key rollover. However, since token takers are required to verify at least 4 QCD tokens, this is only necessary if secret QCD keys are rolled over more than four times as often as IKE SAs are rekeyed. See Section 5.1 for an example method that uses secret keys that may require rollover.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションで説明する情報交換は、キーロールオーバーのためにQCDトークンを交換する必要がある場合にも使用できます。ただし、トークンテイカーは少なくとも4つのQCDトークンを検証する必要があるため、これは、Ike SASが再キーになっている程度の頻度で秘密のQCDキーが巻き込まれた場合にのみ必要です。ロールオーバーを必要とする可能性のある秘密キーを使用する例の方法については、セクション5.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-4--Replacing-the-Token-for-an-Existing-SA">
4.4. Replacing the Token for an Existing SA
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. 既存のSAのトークンを交換します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With some token generation methods, such as that described in Section 5.2, a QCD token may sometimes become invalid, although the IKE SA is still perfectly valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション5.2で説明したようなトークン生成方法では、QCDトークンが無効になることがありますが、IKE SAはまだ完全に有効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In such a case, the token maker MUST send the new token in a protected message under that IKE SA. That exchange could be a simple INFORMATIONAL, such as in the last figure in the previous section, or else it can be part of a MOBIKE INFORMATIONAL exchange such as in the following figure taken from Section 2.2 of [RFC4555] and modified by adding a QCD_TOKEN notification:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのような場合、トークンメーカーは、そのIKE SAの下で保護されたメッセージで新しいトークンを送信する必要があります。その交換は、前のセクションの最後の図などの単純な情報である可能性があります。そうしないと、[RFC4555]のセクション2.2から取られ、QCD_TOKENを追加して修正されたような、モバイク情報交換の一部になる可能性があります。通知：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     (IP_I2:4500 -&gt; IP_R1:4500)
     HDR, SK { N(UPDATE_SA_ADDRESSES),
               N(NAT_DETECTION_SOURCE_IP),
               N(NAT_DETECTION_DESTINATION_IP) }  --&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                           &lt;-- (IP_R1:4500 -&gt; IP_I2:4500)
                               HDR, SK { N(NAT_DETECTION_SOURCE_IP),
                                    N(NAT_DETECTION_DESTINATION_IP) }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                           &lt;-- (IP_R1:4500 -&gt; IP_I2:4500)
                               HDR, SK { N(COOKIE2), [N(QCD_TOKEN)] }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     (IP_I2:4500 -&gt; IP_R1:4500)
     HDR, SK { N(COOKIE2), [N(QCD_TOKEN)] }  --&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A token taker MUST accept such gratuitous QCD_TOKEN notifications as long as they are carried in protected exchanges. A token maker SHOULD NOT generate them unless it is no longer able to generate the old QCD_TOKEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークンテイカーは、保護された交換で運ばれている限り、そのような無償のQCD_TOKEN通知を受け入れる必要があります。トークンメーカーは、古いQCD_TOKENを生成できなくなっていない限り、それらを生成してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-5--Presenting-the-Token-in-an-Unprotected-Message">
4.5. Presenting the Token in an Unprotected Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. 保護されていないメッセージでトークンを提示します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This QCD_TOKEN notification is unprotected, and is sent as a response to a protected IKE request, which uses an IKE SA that is unknown.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このQCD_TOKEN通知は保護されておらず、不明なIKE SAを使用する保護されたIKEリクエストへの応答として送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            message             --&gt; N(INVALID_IKE_SPI), N(QCD_TOKEN)+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If child SPIs are persistently mapped to IKE SPIs as described in Section 8.2, a token taker may get the following unprotected message in response to an Encapsulating Security Payload (ESP) or Authentication Header (AH) packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション8.2で説明されているように、子供のスピスがIke SPIに永続的にマッピングされている場合、トークンテイカーは、カプセル化セキュリティペイロード（ESP）または認証ヘッダー（AH）パケットに応じて、次の保護されていないメッセージを取得する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            message             --&gt; N(INVALID_SPI), N(QCD_TOKEN)+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The QCD_TOKEN and INVALID_IKE_SPI notifications are sent together to support both implementations that conform to this specification and implementations that don&#39;t. Similar to the description in Section 2.21 of [RFC5996], the IKE SPI and message ID fields in the packet headers are taken from the protected IKE request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QCD_TOKENおよびINVALID_IKE_SPI通知は、この仕様とそうでない実装に準拠する両方の実装をサポートするために一緒に送信されます。[RFC5996]のセクション2.21の説明と同様に、パケットヘッダーのIKE SPIおよびメッセージIDフィールドは、保護されたIKEリクエストから取得されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To support a periodic rollover of the secret used for token generation, the token taker MUST support at least four QCD_TOKEN notifications in a single packet. The token is considered verified if any of the QCD_TOKEN notifications matches. The token maker MAY generate up to four QCD_TOKEN notifications, based on several generations of keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークン生成に使用される秘密の定期的なロールオーバーをサポートするには、トークンテイカーは、単一のパケットで少なくとも4つのQCD_TOKEN通知をサポートする必要があります。トークンは、QCD_TOKEN通知のいずれかが一致する場合に確認されたと見なされます。トークンメーカーは、数世代のキーに基づいて、最大4つのQCD_TOKEN通知を生成する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the QCD_TOKEN verifies OK, the receiver MUST silently discard the IKE SA and all associated child SAs. If the QCD_TOKEN cannot be validated, a response MUST NOT be sent, and the event may be logged. Section 5 defines token verification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QCD_TOKENがOKを検証した場合、受信者はIKE SAおよび関連するすべての子SASを静かに廃棄する必要があります。QCD_TOKENを検証できない場合、応答を送信する必要はなく、イベントを記録することもできます。セクション5では、トークンの検証を定義しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Token-Generation-and-Verification">
5. Token Generation and Verification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. トークンの生成と検証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
No token generation method is mandated by this document. Two methods are documented in the following sub-sections, but they only serve as examples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、トークン生成方法は義務付けられていません。次のサブセクションには2つの方法が文書化されていますが、それらは例としてのみ機能します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following lists the requirements for a token generation mechanism:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下には、トークン生成メカニズムの要件をリストします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Tokens MUST be at least 16 octets long, and no more than 128 octets long, to facilitate storage and transmission. Tokens SHOULD be indistinguishable from random data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o トークンは、ストレージとトランスミッションを容易にするために、少なくとも16オクテット、長さ128オクテット以下でなければなりません。トークンは、ランダムデータと区別できない必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It should not be possible for an external attacker to guess the QCD token generated by an implementation. Cryptographic mechanisms such as a pseudo-random number generator (PRNG) and hash functions are RECOMMENDED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 外部攻撃者が実装によって生成されたQCDトークンを推測することは不可能です。擬似ランダム数ジェネレーター（PRNG）やハッシュ関数などの暗号化メカニズムが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The token maker MUST be able to re-generate or retrieve the token based on the IKE SPIs even after it reboots.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o トークンメーカーは、再起動した後でもIke Spisに基づいてトークンを再生成または取得できる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The method of token generation MUST be such that a collision of QCD tokens between different pairs of IKE SPI will be highly unlikely.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o トークン生成の方法は、IKE SPIの異なるペア間のQCDトークンの衝突が非常にありそうにないようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For verification, the token taker makes a bitwise comparison of the token stored along with the IKE SA with the token sent in the unprotected message. Multihomed takers might flip back-and-forth between several addresses, and have their tokens replaced as described in Section 4.4. To help avoid the case where the latest stored token does not match the address used after the maker lost state, the token taker MAY store several earlier tokens associated with the IKE SA, and silently discard the SA if any of them matches.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
検証のために、トークンテイカーは、保護されていないトークンと一緒に保存されたトークンと保護されていないメッセージで送信されたトークンを少し比較します。マルチホームのテイカーは、いくつかのアドレスの間で前後に反転し、セクション4.4で説明されているようにトークンを交換する可能性があります。最新の保存されたトークンがメーカーの失われた状態後に使用されたアドレスと一致しない場合を避けるために、トークンテイカーはIKE SAに関連付けられたいくつかの初期のトークンを保存し、それらのいずれかが一致する場合はSAを静かに捨てることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1--A-Stateless-Method-of-Token-Generation">
5.1. A Stateless Method of Token Generation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. トークン生成の無国籍方法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following describes a stateless method of generating a token. In this case, &#39;stateless&#39; means not maintaining any per-tunnel state, although there is a small amount of non-volatile storage required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、トークンを生成するステートレス方法について説明しています。この場合、「ステートレス」とは、トンネルあたりの状態を維持しないことを意味しますが、不揮発性のないストレージが少ないです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o At installation or immediately after the first boot of the token maker, 32 random octets are generated using a secure random number generator or a PRNG.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o インストール時またはトークンメーカーの最初のブーツの直後に、安全な乱数ジェネレーターまたはPRNGを使用して32のランダムオクテットが生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Those 32 bytes, called the &#34;QCD_SECRET&#34;, are stored in non-volatile storage on the machine, and kept indefinitely.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「QCD_Secret」と呼ばれるこれらの32バイトは、マシン上の不揮発性ストレージに保存され、無期限に保存されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If key rollover is required by policy, the implementation MAY periodically generate a new QCD_SECRET and keep up to 3 previous generations. When sending an unprotected QCD_TOKEN, as many as 4 notification payloads may be sent, each from a different QCD_SECRET.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ポリシーでキーロールオーバーが必要な場合、実装は定期的に新しいQCD_Secretを生成し、以前の3世代まで維持することができます。保護されていないQCD_TOKENを送信すると、それぞれ異なるQCD_Secretから4つの通知ペイロードが送信される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The TOKEN_SECRET_DATA is calculated as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o token_secret_dataは次のように計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
TOKEN_SECRET_DATA = HASH(QCD_SECRET | SPI-I | SPI-R)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
token_secret_data = hash（qcd_secret | spi-i | spi-r）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2--A-Stateless-Method-with-IP-Addresses">
5.2. A Stateless Method with IP Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. IPアドレスを備えたステートレスメソッド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This method is similar to the one in the previous section, except that the IP address of the token taker is also added to the block being hashed. This has the disadvantage that the token needs to be replaced (as described in Section 4.4) whenever the token taker changes its address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この方法は、トークンテイカーのIPアドレスがハッシュされているブロックに追加されていることを除いて、前のセクションの方法に似ています。これには、トークンテイカーがアドレスを変更するたびに、トークンを交換する必要があるという欠点があります（セクション4.4で説明されているように）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 9.2 for a discussion of a use-case for this method. When using this method, the TOKEN_SECRET_DATA field is calculated as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この方法のユースケースの議論については、セクション9.2を参照してください。この方法を使用する場合、token_secret_dataフィールドは次のように計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
TOKEN_SECRET_DATA = HASH(QCD_SECRET | SPI-I | SPI-R | IPaddr-T)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
token_secret_data = hash（qcd_secret | spi-i | spi-r | ipaddr-t）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IPaddr-T field specifies the IP address of the token taker. Secret rollover considerations are similar to those in the previous section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
iPaddr-Tフィールドは、トークンテイカーのIPアドレスを指定します。秘密のロールオーバーの考慮事項は、前のセクションのものと似ています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that with a multihomed token taker, the QCD token matches just one of the token taker IP addresses. Usually this is not a problem, as packets sent to the token maker come out the same IP address. If for some reason this changes, then the token maker can replace the token as described in Section 4.4. If IKEv2 Mobility and Multihoming (MOBIKE) is used, replacing the tokens SHOULD be piggybacked on the INFORMATIONAL exchange with the UPDATE_SA_ADDRESSES notifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチホームのトークンテイカーを使用すると、QCDトークンはトークンテイカーIPアドレスの1つだけと一致することに注意してください。通常、これは問題ではありません。トークンメーカーに送信されたパケットが同じIPアドレスを出しているためです。何らかの理由でこれが変更された場合、トークンメーカーはセクション4.4で説明されているようにトークンを置き換えることができます。IKEV2モビリティとマルチホミング（Mobike）を使用する場合、トークンを交換することは、update_sa_addresses通知と情報交換でピギーバックする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is a corner case where the token taker begins using a new IP address (because of multihoming, roaming, or normal network operations) and the token maker loses state before replacing the token. In that case, it will send a correct QCD token, but the token taker will still have the old token. In that case, the extension will not work, and the peers will revert to RFC 5996 recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークンテイカーが（マルチホミング、ローミング、または通常のネットワーク操作のため）新しいIPアドレスの使用を開始し、トークンメーカーがトークンを交換する前に状態を失うコーナーケースがあります。その場合、正しいQCDトークンを送信しますが、トークンテイカーにはまだ古いトークンがあります。その場合、拡張機能は機能せず、ピアはRFC 5996回復に戻ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-3--Token-Lifetime">
5.3. Token Lifetime
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. トークンライフタイム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The token is associated with a single IKE SA and SHOULD be deleted by the token taker when the SA is deleted or expires. More formally, the token is associated with the pair (SPI-I, SPI-R).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークンは単一のIKE SAに関連付けられており、SAが削除されたり期限切れになったときにトークンテイカーによって削除される必要があります。より正式には、トークンはペア（SPI-I、SPI-R）に関連付けられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Backup-Gateways">
6. Backup Gateways
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. バックアップゲートウェイ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Making crash detection and recovery quick is a worthy goal, but since rebooting a gateway takes a non-zero amount of time, many implementations choose to have a standby gateway ready to take over as soon as the primary gateway fails for any reason. [RFC6027] describes considerations for such clusters of gateways with synchronized state, but the rest of this section is relevant even when there is no synchronized state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クラッシュの検出と回復を迅速に行うことは価値のある目標ですが、ゲートウェイの再起動にはゼロ以外の時間がかかるため、多くの実装は、何らかの理由でプライマリゲートウェイが失敗するとすぐにスタンバイゲートウェイを引き継ぐことができます。[RFC6027]は、同期された状態を持つゲートウェイのこのようなクラスターの考慮事項について説明しますが、このセクションの残りの部分は、同期された状態がない場合でも関連します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If such a configuration is available, it is RECOMMENDED that the standby gateway be able to generate the same token as the active gateway. If the method described in Section 5.1 is used, this means that the QCD_SECRET field is identical in both gateways. This has the effect of having the crash recovery available immediately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような構成が利用可能な場合は、スタンバイゲートウェイがアクティブゲートウェイと同じトークンを生成できることをお勧めします。セクション5.1で説明した方法が使用されている場合、これは両方のゲートウェイでQCD_Secretフィールドが同一であることを意味します。これは、クラッシュ回復をすぐに利用できるようにする効果があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this refers to &#34;high-availability&#34; configurations, where only one gateway is active at any given moment. This is different from &#34;load sharing&#34; configurations where more than one gateway is active at the same time. For load sharing configurations, please see Section 9.2 for security considerations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、任意の瞬間に1つのゲートウェイのみがアクティブである「高可用性」構成を指すことに注意してください。これは、複数のゲートウェイが同時にアクティブになっている「負荷共有」構成とは異なります。負荷共有構成については、セキュリティに関する考慮事項については、セクション9.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Interaction-with-Session-Resumption">
7. Interaction with Session Resumption
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. セッション再開との相互作用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Session resumption, specified in [RFC5723], allows the setting up of a new IKE SA to consume less computing resources. This is particularly useful in the case of a remote access gateway that has many tunnels. A failure of such a gateway requires all these many remote access clients to establish an IKE SA either with the rebooted gateway or with a backup. This tunnel re-establishment occurs within a short period of time, creating a burden on the remote access gateway. Session resumption addresses this problem by having the clients store an encrypted derivative of the IKE SA for quick re-establishment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5723]で指定されたセッション再開により、新しいIKE SAのセットアップにより、コンピューティングリソースが少なくなります。これは、多くのトンネルを備えたリモートアクセスゲートウェイの場合に特に役立ちます。このようなゲートウェイの障害には、これらの多くのリモートアクセスクライアントがすべて、再起動したゲートウェイまたはバックアップを使用してIKE SAを確立する必要があります。このトンネルの再確立は、短期間で発生し、リモートアクセスゲートウェイに負担がかかります。セッション再開は、クライアントにIKE SAの暗号化された派生物を迅速に再確立するために保存させることにより、この問題に対処します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
What Session Resumption does not help is the problem of detecting that the peer gateway has failed. A failed gateway may go undetected for an arbitrarily long time, because IPsec does not have packet acknowledgement, and applications cannot signal the IPsec layer that the tunnel &#34;does not work&#34;. Section 2.4 of RFC 5996 does not specify how long an implementation needs to wait before beginning a liveness check, and only says &#34;not recently&#34; (see full quote in Section 2). In practice, some mobile devices wait a very long time before beginning a liveness check, in order to extend battery life by allowing parts of the device to remain in low-power modes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション再開が役に立たないのは、ピアゲートウェイが失敗したことを検出する問題です。IPSECにはパケットの確認がなく、アプリケーションがトンネルが「機能しない」というIPSECレイヤーを信号することはできないため、失敗したゲートウェイは任意に長時間検出されない場合があります。RFC 5996のセクション2.4では、livensionチェックを開始する前に実装が待機する必要がある期間を指定しておらず、「最近ではない」としか言いません（セクション2の完全な引用を参照）。実際には、一部のモバイルデバイスは、デバイスの部品が低電力モードのままになることでバッテリー寿命を延ばすために、活性チェックを開始する前に非常に長い時間待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QCD tokens provide a way to detect the failure of the peer in the case where a liveness check has not yet ended (or begun).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QCDトークンは、活性チェックがまだ終了していない（または始めた）場合にピアの障害を検出する方法を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A remote access client conforming to both specifications will store QCD tokens, as well as the Session Resumption ticket, if provided by the gateway. A remote access gateway conforming to both specifications will generate a QCD token for the client. When the gateway reboots, the client will discover this in either of two ways:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
両方の仕様に準拠しているリモートアクセスクライアントは、QCDトークンと、ゲートウェイによって提供される場合、セッション再開チケットを保存します。両方の仕様に準拠するリモートアクセスゲートウェイは、クライアント用のQCDトークンを生成します。ゲートウェイが再起動すると、クライアントは次の2つの方法のいずれかでこれを発見します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The client does regular liveness checks, or else the time for some other IKE exchange has come. Since the gateway is still down, the IKE exchange times out after several minutes. In this case, QCD does not help.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. クライアントは定期的な活性チェックを行います。そうしないと、他のIKE交換の時間が来ました。ゲートウェイはまだダウンしているため、ike交換は数分後に出ます。この場合、QCDは役に立ちません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Either the primary gateway or a backup gateway (see Section 6) is ready and sends a QCD token to the client. In that case, the client will quickly re-establish the IPsec tunnel, either with the rebooted primary gateway or the backup gateway as described in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. プライマリゲートウェイまたはバックアップゲートウェイ（セクション6を参照）のいずれかが準備ができており、QCDトークンをクライアントに送信します。その場合、クライアントは、このドキュメントで説明されているように、再起動されたプライマリゲートウェイまたはバックアップゲートウェイのいずれかを使用して、IPSECトンネルをすばやく再確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The full combined protocol looks like this:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
完全な組み合わせプロトコルは次のようになります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        Initiator                Responder
        -----------              -----------
       HDR, SAi1, KEi, Ni  --&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
&lt;-- HDR, SAr1, KEr, Nr, [CERTREQ]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
&lt;-HDR、sar1、ker、nr、[certreq]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HDR, SK {IDi, [CERT,]
       [CERTREQ,] [IDr,]
       AUTH, N(QCD_TOKEN)
       SAi2, TSi, TSr,
       N(TICKET_REQUEST)}  --&gt;
                           &lt;--    HDR, SK {IDr, [CERT,] AUTH,
                                  N(QCD_TOKEN), SAr2, TSi, TSr,
                                  N(TICKET_LT_OPAQUE) }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                ---- Reboot -----
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HDR, {}             --&gt;
                           &lt;--  HDR, N(QCD_TOKEN)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HDR, [N(COOKIE),]
       Ni, N(TICKET_OPAQUE)
       [,N+]               --&gt;
                           &lt;--  HDR, Nr [,N+]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--Operational-Considerations">
8. Operational Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 運用上の考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1--Who-Should-Implement-This-Specification">
8.1. Who Should Implement This Specification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. 誰がこの仕様を実装する必要があります
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Throughout this document, we have referred to reboot time alternatingly as the time that the implementation crashes and the time when it is ready to process IPsec packets and IKE exchanges. Depending on the hardware and software platforms and the cause of the reboot, rebooting may take anywhere from a few seconds to several minutes. If the implementation is down for a long time, the benefit of this protocol extension is reduced. For this reason, critical systems should implement backup gateways as described in Section 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメント全体を通して、実装がクラッシュする時間とIPSECパケットとIKE交換の処理準備ができた時間と交互に再起動することを参照しました。ハードウェアプラットフォームとソフトウェアプラットフォームと再起動の原因に応じて、再起動すると数秒から数分かかる場合があります。実装が長い間ダウンしている場合、このプロトコル拡張の利点は削減されます。このため、セクション6で説明されているように、重要なシステムがバックアップゲートウェイを実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementing the &#34;token maker&#34; side of QCD makes sense for IKE implementation where protected connections originate from the peer, such as inter-domain VPNs and remote access gateways. Implementing the &#34;token taker&#34; side of QCD makes sense for IKE implementations where protected connections originate, such as inter-domain VPNs and remote access clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QCDの「トークンメーカー」側を実装することは、ドメイン間VPNやリモートアクセスゲートウェイなど、保護された接続がピアに由来するIKE実装にとって理にかなっています。QCDの「トークンテイカー」側を実装することは、ドメイン間VPNやリモートアクセスクライアントなど、保護された接続が発生するIKE実装にとって理にかなっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To clarify this discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この議論を明確にするには：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For remote-access clients it makes sense to implement the token taker role.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o リモートアクセスクライアントにとって、トークンテイカーの役割を実装することは理にかなっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For remote-access gateways it makes sense to implement the token maker role.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o リモートアクセスゲートウェイの場合、トークンメーカーの役割を実装することは理にかなっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For inter-domain VPN gateways it makes sense to implement both roles, because it can&#39;t be known in advance where the traffic originates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ドメイン間VPNゲートウェイの場合、トラフィックが発生する場所が事前に知られていないため、両方の役割を実装することは理にかなっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It is perfectly valid to implement both roles in any case, for example, when using a single library or a single gateway to perform several roles.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o たとえば、単一のライブラリまたは単一のゲートウェイを使用していくつかのロールを実行する場合、どんな場合でも両方の役割を実装することは完全に有効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to limit the effects of Denial-of-Service (DoS) attacks, a token taker SHOULD limit the rate of QCD_TOKENs verified from a particular source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サービス拒否（DOS）攻撃の影響を制限するために、トークンテイカーは特定のソースから検証されたQCD_TOKENSのレートを制限する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If excessive amounts of IKE requests protected with unknown IKE SPIs arrive at a token maker, the IKE module SHOULD revert to the behavior described in Section 2.21 of [RFC5996] and either send an INVALID_IKE_SPI notification or ignore it entirely.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
未知のIKE Spisで保護された過剰な量のIKE要求がトークンメーカーに到着した場合、IKEモジュールは[RFC596]のセクション2.21で説明されている動作に戻り、Invalid_ike_spi通知を送信するか、完全に無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 9.2 requires that token makers never send a QCD token in the clear for a valid IKE SA and describes some configurations where this could occur. Implementations that may be installed in such configurations SHOULD automatically detect this and disable this extension in unsafe configurations and MUST allow the user to control whether the extension is enabled or disabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション9.2では、トークンメーカーが有効なIKE SAのQCDトークンをクリアに送信しないことを要求し、これが発生する可能性のある構成について説明します。このような構成にインストールされる可能性のある実装は、これを自動的に検出し、この拡張機能を安全でない構成で無効にし、ユーザーが拡張機能を有効にするか無効にしているかを制御できるようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2--Response-to-Unknown-Child-SPI">
8.2. Response to Unknown Child SPI
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. 未知の子SPIへの応答
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After a reboot, it is more likely that an implementation will receive IPsec packets than IKE packets. In that case, the rebooted implementation will send an INVALID_SPI notification, triggering a liveness check. The token will only be sent in a response to the liveness check, thus requiring an extra round trip.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再起動した後、実装がIKEパケットよりもIPSECパケットを受信する可能性が高くなります。その場合、再起動された実装により、nivalid_spi通知が送信され、livensionチェックがトリガーされます。トークンは、活性チェックへの応答でのみ送信されるため、追加の往復が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid this, an implementation that has access to enough non-volatile storage MAY store a mapping of child SPIs to owning IKE SPIs, or to generated tokens. If such a mapping is available and persistent across reboots, the rebooted implementation SHOULD respond to the IPsec packet with an INVALID_SPI notification, along with the appropriate QCD_TOKEN notifications. A token taker SHOULD verify the QCD token that arrives with an INVALID_SPI notification the same as if it arrived with the IKE SPIs of the parent IKE SA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これを回避するために、十分な不揮発性ストレージにアクセスできる実装により、子供のスピスのマッピングがIke Spisまたは生成されたトークンのマッピングを保存できます。このようなマッピングが利用可能であり、再起動全体で永続的である場合、再起動された実装は、適切なQCD_TOKEN通知とともに、INVALID_SPI通知を使用してIPSECパケットに応答する必要があります。トークンテイカーは、親IKE SAのIKEスピスと到着した場合と同じように無効な_SPI通知で到着するQCDトークンを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, a persistent storage module might not be updated in a timely manner and could be populated with tokens relating to IKE SPIs that have already been rekeyed. A token taker MUST NOT take an invalid QCD token sent along with an INVALID_SPI notification as evidence that the peer is either malfunctioning or attacking, but it SHOULD limit the rate at which such notifications are processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、永続的なストレージモジュールはタイムリーに更新されない可能性があり、すでに再キーにされているIKE SPIに関連するトークンを入力できます。トークンテイカーは、ピアが誤動作または攻撃を行っているという証拠として無効なQCDトークンを無効なQCDトークンと一緒に送信してはなりませんが、そのような通知が処理されるレートを制限する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--Security-Considerations">
9. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The extension described in this document must not reduce the security of IKEv2 or IPsec. Specifically, an eavesdropper must not learn any non-public information about the peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントで説明されている拡張機能は、IKEV2またはIPSECのセキュリティを減らしてはなりません。具体的には、盗聴者はピアに関する非公開情報を学習してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The proposed mechanism should be secure against attacks by a passive man in the middle (MITM) (eavesdropper). Such an attacker must not be able to disrupt an existing IKE session, either by resetting the session or by introducing significant delays. This requirement is especially significant, because this document introduces a new way to reset an IKE SA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
提案されたメカニズムは、中央（MITM）（Eavesdropper）の受動的な男による攻撃に対して安全でなければなりません。このような攻撃者は、セッションをリセットするか、かなりの遅延を導入することにより、既存のIKEセッションを混乱させることができない必要があります。このドキュメントはIKE SAをリセットする新しい方法を導入するため、この要件は特に重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mechanism need not be similarly secure against an active MITM, since this type of attacker is already able to disrupt IKE sessions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このタイプの攻撃者はすでにIKEセッションを破壊できるため、メカニズムはアクティブなMITMに対して同様に安全である必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-1--QCD-Token-Generation-and-Handling">
9.1. QCD Token Generation and Handling
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. QCDトークンの生成と取り扱い
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tokens MUST be hard to guess. This is critical, because if an attacker can guess the token associated with an IKE SA, they can tear down the IKE SA and associated tunnels at will. When the token is delivered in the IKE_AUTH exchange, it is encrypted. When it is sent again in an unprotected notification, it is not, but that is the last time this token is ever used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークンは推測するのが難しいに違いありません。これは重要です。なぜなら、攻撃者がIKE SAに関連付けられたトークンを推測できれば、IKE SAと関連するトンネルを自由に取り壊すことができるからです。トークンがIKE_AUTH Exchangeで配信されると、暗号化されます。保護されていない通知で再び送信された場合、そうではありませんが、このトークンが使用されるのは最後です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An aggregation of some tokens generated by one maker together with the related IKE SPIs MUST NOT give an attacker the ability to guess other tokens. Specifically, if one taker does not properly secure the QCD tokens and an attacker gains access to them, this attacker MUST NOT be able to guess other tokens generated by the same maker. This is the reason that the QCD_SECRET in Section 5.1 needs to be sufficiently long.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関連するIKE SPIと一緒に1つのメーカーによって生成されたいくつかのトークンの集約は、攻撃者に他のトークンを推測する能力を与えてはなりません。具体的には、1人のTakerがQCDトークンを適切に固定せず、攻撃者がアクセスを獲得している場合、この攻撃者は同じメーカーによって生成された他のトークンを推測できてはなりません。これが、セクション5.1のQCD_Secretが十分に長くする必要がある理由です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The token taker MUST store the token in a secure manner. No attacker should be able to gain access to a stored token.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークンテイカーは、トークンを安全な方法で保存する必要があります。攻撃者は、保存されたトークンにアクセスできるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The QCD_SECRET MUST be protected from access by other parties. Anyone gaining access to this value will be able to delete all the IKE SAs for this token maker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QCD_Secretは、他の当事者によるアクセスから保護する必要があります。この値にアクセスできる人は誰でも、このトークンメーカーのすべてのIKE SASを削除できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The QCD token is sent by the rebooted peer in an unprotected message. A message like that is subject to modification, deletion, and replay by an attacker. However, these attacks will not compromise the security of either side. Modification is meaningless because a modified token is simply an invalid token. Deletion will only cause the protocol not to work, resulting in a delay in tunnel re-establishment as described in Section 2. Replay is also meaningless, because the IKE SA has been deleted after the first transmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QCDトークンは、保護されていないメッセージで再起動されたピアによって送信されます。そのようなメッセージは、攻撃者による変更、削除、およびリプレイの対象となります。ただし、これらの攻撃はどちらの側のセキュリティを妥協しません。変更されたトークンは単に無効なトークンであるため、変更は無意味です。削除はプロトコルのみに機能しないため、セクション2で説明されているようにトンネルの再確立が遅れます。リプレイも意味がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2--QCD-Token-Transmission">
9.2. QCD Token Transmission
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. QCDトークン伝送
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A token maker MUST NOT send a valid QCD token in an unprotected message for an existing IKE SA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークンメーカーは、既存のIKE SAに対して無防備なメッセージで有効なQCDトークンを送信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This requirement is obvious and easy in the case of a single gateway. However, some implementations use a load balancer to divide the load between several physical gateways. It MUST NOT be possible even in such a configuration to trick one gateway into sending a valid QCD token for an IKE SA that is valid on another gateway. This is true whether the attempt to trick the gateway uses the token taker&#39;s IP address or a different IP address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この要件は、単一のゲートウェイの場合、明らかで簡単です。ただし、一部の実装では、ロードバランサーを使用して、いくつかの物理ゲートウェイ間で負荷を分割します。このような構成でさえ、1つのゲートウェイをトリックして、別のゲートウェイで有効なIKE SAの有効なQCDトークンを送信することはできません。これは、ゲートウェイをだまそうとする試みがトークンテイカーのIPアドレスまたは別のIPアドレスを使用するかどうかに当てはまります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPsec failure detection is not applicable to deployments where the QCD secret is shared by multiple gateways and the gateways cannot assess whether the token can be legitimately sent in the clear while another gateway may actually still own the SA&#39;s. Load balancing configurations typically fall in this category. In order for a load balancing configuration of IPsec gateways to support this specification, all members MUST be able to tell whether a particular IKE SA is active anywhere in the cluster. One way to do this is to synchronize a list of active IKE SPIs among all the cluster members.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPSEC障害検出は、QCDシークレットが複数のゲートウェイで共有され、ゲートウェイがトークンをクリアで合法的に送信できるかどうかを評価できない場合、ゲートウェイが実際にSAを所有している展開には適用されません。通常、ロードバランシング構成はこのカテゴリに分類されます。この仕様をサポートするIPSecゲートウェイの負荷分散構成のために、すべてのメンバーは、特定のIKE SAがクラスター内のどこでもアクティブであるかどうかを判断できる必要があります。これを行う1つの方法は、すべてのクラスターメンバーの間でアクティブなIKEスピスのリストを同期することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because it includes the token taker&#39;s IP address in the token generation, the method in Section 5.2 can (under certain conditions) prevent revealing the QCD token for an existing pair of IKE SPIs to an attacker who is using a different IP address, even in a load-sharing cluster without state synchronization. That method does not prevent revealing the QCD token to an active attacker who is spoofing the token taker&#39;s IP address. Such an attacker may attempt to direct messages to a cluster member other than the member responsible for the IKE SA in an attempt to trick that gateway into sending a QCD token for a valid IKE SA. That method should not be used unless the load balancer guarantees that IKE packets from the same source IP address always go to the same cluster member.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークンの生成にトークンテイカーのIPアドレスが含まれているため、セクション5.2の方法は（特定の条件下で）、IKEスピスの既存のペアのQCDトークンを、別のIPアドレスを使用している攻撃者に明らかにすることを防ぐことができます。状態同期なしの負荷分担クラスター。その方法では、トークンテイカーのIPアドレスをスプーフィングしているアクティブな攻撃者にQCDトークンを明らかにすることを妨げません。このような攻撃者は、有効なIKE SAのQCDトークンの送信にそのゲートウェイをだまそうとして、IKE SAの責任者以外のメンバー以外のメンバーにメッセージを向けようとする場合があります。ロードバランサーが同じソースIPアドレスのIKEパケットが常に同じクラスターメンバーに移動することを保証しない限り、その方法は使用しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3--QCD-Token-Enumeration">
9.3. QCD Token Enumeration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. QCDトークン列挙
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attacker may try to attack QCD if the generation algorithm described in Section 5.1 is used. The attacker will send several fake IKE requests to the gateway under attack, receiving and recording the QCD tokens in the responses. This will allow the attacker to create a dictionary of IKE SPIs to QCD tokens, which can later be used to tear down any IKE SA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃者は、セクション5.1で説明されている生成アルゴリズムが使用されている場合、QCDを攻撃しようとする場合があります。攻撃者は、いくつかの偽のIKEリクエストを攻撃中のゲートウェイに送信し、応答のQCDトークンを受け取り、記録します。これにより、攻撃者はIke Spisの辞書をQCDトークンに作成することができ、後でIKE SAを取り壊すために使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Three factors mitigate this threat:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3つの要因がこの脅威を軽減します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The space of all possible IKE SPI pairs is huge: 2^128, so making such a dictionary is impractical. Even if we assume that one implementation always generates predictable IKE SPIs, the space is still at least 2^64 entries, so making the dictionary is extremely hard. To ensure this, token makers MUST generate unpredictable IKE SPIs by using a cryptographically strong pseudo-random number generator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 可能なすべてのIke Spiペアのスペースは巨大です：2^128なので、そのような辞書を作ることは実用的ではありません。1つの実装が常に予測可能なIke Spisを生成すると仮定したとしても、スペースはまだ少なくとも2^64のエントリであるため、辞書の作成は非常に困難です。これを確実にするために、トークンメーカーは、暗号的に強力な擬似ランダム数ジェネレーターを使用して、予測不可能なIke Spisを生成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Throttling the amount of QCD_TOKEN notifications sent out, as discussed in Section 8.1, especially when not soon after a crash will limit the attacker&#39;s ability to construct a dictionary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o セクション8.1で説明されているように、QCD_TOKEN通知の量を調整します。特に、クラッシュの直後に攻撃者の辞書を構築する能力が制限されない場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The methods in Section 5.1 and Section 5.2 allow for a periodic change of the QCD_SECRET. Any such change invalidates the entire dictionary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o セクション5.1およびセクション5.2の方法では、QCD_Secretの定期的な変更が可能です。このような変更は、辞書全体を無効にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10--IANA-Considerations">
10. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has assigned a notify message type (16419) from the status types range (16406-40959) of the &#34;IKEv2 Notify Message Types&#34; registry with the name &#34;QUICK_CRASH_DETECTION&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、「IKEV2通知メッセージタイプ」のステータスタイプ範囲（16406-40959）から「Quick_Crash_Detection」という名前の[IKEV2通知]レジストリ」のnotifyメッセージタイプ（16419）を割り当てました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11--Acknowledgements">
11. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. 謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We would like to thank Hannes Tschofenig and Yaron Sheffer for their comments about Session Resumption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション再開に関するコメントについて、Hannes TschofenigとYaron Shefferに感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Others who have contributed valuable comments are, in alphabetical order, Lakshminath Dondeti, Paul Hoffman, Tero Kivinen, Scott C Moonen, Magnus Nystrom, and Keith Welter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
貴重なコメントを提供した他の人々は、アルファベット順に、ラクシュミナート・ドンデティ、ポール・ホフマン、テロ・キビネン、スコット・C・ムーナン、マグナス・ナイストロム、キース・ウェルターです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12--References">
12. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-1--Normative-References">
12.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4555] Eronen, P., &#34;IKEv2 Mobility and Multihoming Protocol (MOBIKE)&#34;, RFC 4555, June 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4555] Eronen、P。、「IKEV2モビリティおよびマルチホームプロトコル（MOBIKE）」、RFC 4555、2006年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5996] Kaufman, C., Hoffman, P., Nir, Y., and P. Eronen, &#34;Internet Key Exchange Protocol Version 2 (IKEv2)&#34;, RFC 5996, September 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5996] Kaufman、C.、Hoffman、P.、Nir、Y。、およびP. Eronen、「Internet Key Exchange Protocolバージョン2（IKEV2）」、RFC 5996、2010年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2--Informative-References">
12.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5723] Sheffer, Y. and H. Tschofenig, &#34;Internet Key Exchange Protocol Version 2 (IKEv2) Session Resumption&#34;, RFC 5723, January 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5723] Sheffer、Y。およびH. Tschofenig、「Internet Key Exchange Protocol 2（IKEV2）セッション再開」、RFC 5723、2010年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6027] Nir, Y., &#34;IPsec Cluster Problem Statement&#34;, RFC 6027, October 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6027] NIR、Y。、「IPSECクラスター問題ステートメント」、RFC 6027、2010年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[recovery] Detienne, F., Sethi, P., and Y. Nir, &#34;Safe IKE Recovery&#34;, Work in Progress, July 2009.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[回復] Detienne、F.、Sethi、P。、およびY. Nir、「Safe Ike Recovery」、2009年7月、進行中の作業。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-A--The-Path-Not-Taken">
Appendix A. The Path Not Taken
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録A. パスはとられていません
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-1--Initiating-a-New-IKE-SA">
A.1. Initiating a New IKE SA
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.1. 新しいIke SAを開始します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Instead of sending a QCD token, we could have the rebooted implementation start an Initial exchange with the peer, including the INITIAL_CONTACT notification. This would have the same effect, instructing the peer to erase the old IKE SA, as well as establishing a new IKE SA with fewer rounds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QCDトークンを送信する代わりに、再起動した実装で、initial_contact通知を含むピアとの初期交換を開始することができます。これには同じ効果があり、ピアに古いIke SAを消去するように指示し、より少ないラウンドで新しいIke SAを確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The disadvantage here is that in IKEv2, an authentication exchange MUST have a piggybacked Child SA set up. Since our use-case is such that the rebooted implementation does not have traffic flowing to the peer, there are no good selectors for such a Child SA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここでの欠点は、IKEV2では、認証交換がピギーバックされたチャイルドSAを設定する必要があることです。私たちのユースケースは、再起動された実装にピアへのトラフィックが流れないようなものであるため、そのような子SAの良いセレクターはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additionally, when authentication is asymmetric, such as when EAP is used, it is not possible for the rebooted implementation to initiate IKE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、EAPが使用される場合など、認証が非対称である場合、再起動された実装がIKEを開始することは不可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-2--SIR">
A.2. SIR
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2. お客様
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another proposal that was considered for this work item is the SIR extension, which is described in [recovery]. Under that proposal, the non-rebooted peer sends a non-protected query to the possibly rebooted peer, asking whether the IKE SA exists. The peer replies with either a positive or negative response, and the absence of a positive response, along with the existence of a negative response, is taken as proof that the IKE SA has really been lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この作業項目で考慮された別の提案は、[Recovery]に記載されているSIR拡張です。その提案の下で、再訓練されていないピアは、IKE SAが存在するかどうかを尋ねる、再起動されていないピアに保護されていないクエリを送信します。ピアは、肯定的または否定的な反応のいずれかで答え、否定的な反応の存在とともに肯定的な反応がないことは、IKE SAが本当に失われたという証拠とみなされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The working group preferred the QCD proposal to this one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ワーキンググループは、これよりもQCD提案を好みました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-3--Birth-Certificates">
A.3. Birth Certificates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.3. 出生証明書
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Birth Certificates is a method of crash detection that has never been formally defined. Bill Sommerfeld suggested this idea in a mail to the IPsec mailing list on August 7, 2000, in a thread discussing methods of crash detection:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
出生証明書は、正式に定義されていないクラッシュ検出の方法です。ビル・ソマーフェルドは、2000年8月7日にIPSECメーリングリストへのメールで、クラッシュ検出の方法を議論するスレッドでこのアイデアを提案しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
If we have the system sign a &#34;birth certificate&#34; when it reboots (including a reboot time or boot sequence number), we could include that with a &#34;bad spi&#34; ICMP error and in the negotiation of the IKE SA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
再起動時にシステムに「出生証明書」に署名している場合（再起動時間またはブートシーケンス番号を含む）、「悪いSPI」ICMPエラーとIKE SAの交渉にそれを含めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We believe that this method would have some problems. First, it requires Alice to store the certificate, so as to be able to compare the public keys. That requires more storage than does a QCD token. Additionally, the public key operations needed to verify the self-signed certificates are more expensive for Alice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この方法にはいくつかの問題があると考えています。まず、パブリックキーを比較できるように、アリスに証明書を保存する必要があります。QCDトークンよりも多くのストレージが必要です。さらに、自己署名証明書を確認するために必要な公開キー操作は、アリスにとってより高価です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We believe that a symmetric-key operation such as proposed here is more light-weight and simple than that implied by the Birth Certificate idea.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで提案されているような対称キー操作は、出生証明書のアイデアが暗示しているものよりも軽量でシンプルであると考えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-4--Reducing-Liveness-Check-Length">
A.4. Reducing Liveness Check Length
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4. 活性チェックの長さを削減します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some implementations require fewer retransmissions over a shorter period of time for cases of liveness check started because of an INVALID_SPI or INVALID_IKE_SPI notification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかの実装では、無効なことまたはInvalid_ike_spi通知が原因で起動されるlivensionチェックの場合には、短い期間にわたって再送信を減らす必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We believe that the default retransmission policy should represent a good balance between the need for a timely discovery of a dead peer, and a low probability of false detection. We expect the policy to be set to take the shortest time such that this probability achieves a certain target. Therefore, we believe that reducing the elapsed time and retransmission count may create an unacceptably high probability of false detection, and this can be triggered by a single INVALID_IKE_SPI notification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デフォルトの再送信ポリシーは、死んだピアのタイムリーな発見の必要性と誤検出の可能性が低いこととの良いバランスを表すべきであると考えています。この確率が特定のターゲットを達成するように、ポリシーが最短時間を取るように設定されると予想しています。したがって、経過時間と再送信数を減らすと、誤検出の容認できないほど高い確率が生じる可能性があると考えられており、これは単一の無効な_ike_spi通知によって引き起こされる可能性があると考えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additionally, even if the retransmission policy is reduced to, say, one minute, it is still a very noticeable delay from a human perspective, from the time that the gateway has come up (i.e., is able to respond with an INVALID_SPI or INVALID_IKE_SPI notification) and until the tunnels are active, or from the time the backup gateway has taken over until the tunnels are active. The use of QCD tokens can reduce this delay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、たとえば1分間に再送信ポリシーが削減されたとしても、ゲートウェイが上昇した時点から、人間の観点から非常に顕著な遅延です（つまり、Invalid_spiまたはInvalid_ike_spi通知で応答することができます。）そして、トンネルがアクティブになるまで、またはバックアップゲートウェイが引き継がれてからトンネルがアクティブになるまで。QCDトークンを使用すると、この遅延を減らすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Yoav Nir (editor) Check Point Software Technologies, Ltd. 5 Hasolelim st. Tel Aviv 67897 Israel
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Yoav Nir（編集者）チェックポイントソフトウェアテクノロジー、Ltd。5 Hasolelim St。Tel Aviv 67897イスラエル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: ynir@checkpoint.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David Wierbowski International Business Machines 1701 North Street Endicott, New York 13760 United States
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DavidWierbowski International Business Machines 1701 North Street Endicott、ニューヨーク13760米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: wierbows@us.ibm.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Frederic Detienne Cisco Systems, Inc. De Kleetlaan, 7 Diegem B-1831 Belgium
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Frederic Detienne Cisco Systems、Inc。De Kleetlaan、7 Diegem B-1831ベルギー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +32 2 704 5681
   EMail: fd@cisco.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pratima Sethi Cisco Systems, Inc. O&#39;Shaugnessy Road, 11 Bangalore, Karnataka 560027 India
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pratima Sethi Cisco Systems、Inc。O&#39;Shaugnessy Road、11 Bangalore、Karnataka 560027 India
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +91 80 4154 1654
   EMail: psethi@cisco.com
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
