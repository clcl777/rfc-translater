<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 3542 - Advanced Sockets Application Program Interface (API) for IPv6 日本語訳</title>
  <meta name="description" content="RFC 3542はIPv6に対応した高度なソケットアプリケーションプログラムインターフェース（API）についての仕様です。このRFCの目的は、IPv6ネットワーク上でのソケットプログラミングをサポートし、効率的なネットワーク通信を実現することです。">
  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="./master.css">
  <script src="./index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">3542</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc3542">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 3542 - Advanced Sockets Application Program Interface (API) for IPv6 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc3542">
            https://datatracker.ietf.org/doc/html/rfc3542
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 3542 - IPv6の高度なソケットアプリケーションプログラムインターフェイス（API）</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <p class="card-text">[要約] RFC 3542はIPv6に対応した高度なソケットアプリケーションプログラムインターフェース（API）についての仕様です。このRFCの目的は、IPv6ネットワーク上でのソケットプログラミングをサポートし、効率的なネットワーク通信を実現することです。</p>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                         W. Stevens
Request for Comments: 3542                                     M. Thomas
Obsoletes: 2292                                               Consultant
Category: Informational                                      E. Nordmark
                                                                     Sun
                                                               T. Jinmei
                                                                 Toshiba
                                                                May 2003
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Advanced Sockets Application Program Interface (API) for IPv6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
IPv6の高度なソケットアプリケーションプログラムインターフェイス（API）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、インターネットコミュニティに情報を提供します。いかなる種類のインターネット標準を指定しません。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2003). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）The Internet Society（2003）。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document provides sockets Application Program Interface (API) to support &#34;advanced&#34; IPv6 applications, as a supplement to a separate specification, RFC 3493. The expected applications include Ping, Traceroute, routing daemons and the like, which typically use raw sockets to access IPv6 or ICMPv6 header fields. This document proposes some portable interfaces for applications that use raw sockets under IPv6. There are other features of IPv6 that some applications will need to access: interface identification (specifying the outgoing interface and determining the incoming interface), IPv6 extension headers, and path Maximum Transmission Unit (MTU) information. This document provides API access to these features too. Additionally, some extended interfaces to libraries for the &#34;r&#34; commands are defined. The extension will provide better backward compatibility to existing implementations that are not IPv6-capable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、Socketsアプリケーションプログラムインターフェイス（API）を提供して、「高度な」IPv6アプリケーションを別の仕様の補足としてサポートしています。RFC3493。IPv6またはICMPV6ヘッダーフィールド。このドキュメントでは、IPv6の下で生のソケットを使用するアプリケーション用のいくつかのポータブルインターフェイスを提案しています。IPv6には、一部のアプリケーションにアクセスする必要がある他の機能があります。インターフェイス識別（発信インターフェイスの指定と着信インターフェイスの決定）、IPv6拡張ヘッダー、およびパス最大伝送ユニット（MTU）情報。このドキュメントは、これらの機能へのAPIアクセスも提供します。さらに、「r」コマンドのライブラリへのいくつかの拡張インターフェイスが定義されています。この拡張機能は、IPv6対応ではない既存の実装により、より良い後方互換性を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.   Introduction ..............................................  3
   2.   Common Structures and Definitions .........................  5
        2.1  The ip6_hdr Structure ................................  6
             2.1.1  IPv6 Next Header Values .......................  6
             2.1.2  IPv6 Extension Headers ........................  7
             2.1.3  IPv6 Options ..................................  8
        2.2  The icmp6_hdr Structure .............................. 10
             2.2.1  ICMPv6 Type and Code Values ................... 10
             2.2.2  ICMPv6 Neighbor Discovery Definitions ......... 11
             2.2.3  Multicast Listener Discovery Definitions ...... 14
             2.2.4  ICMPv6 Router Renumbering Definitions ......... 14
        2.3  Address Testing Macros ............................... 16
        2.4  Protocols File ....................................... 16
   3.   IPv6 Raw Sockets .......................................... 17
        3.1  Checksums ............................................ 18
        3.2  ICMPv6 Type Filtering ................................ 19
        3.3  ICMPv6 Verification of Received Packets .............. 22
   4.   Access to IPv6 and Extension Headers ...................... 22
        4.1  TCP Implications ..................................... 24
        4.2  UDP and Raw Socket Implications ...................... 25
   5.   Extensions to Socket Ancillary Data ....................... 26
        5.1  CMSG_NXTHDR .......................................... 26
        5.2  CMSG_SPACE ........................................... 26
        5.3  CMSG_LEN ............................................. 27
   6.   Packet Information ........................................ 27
        6.1  Specifying/Receiving the Interface ................... 28
        6.2  Specifying/Receiving Source/Destination Address ...... 29
        6.3  Specifying/Receiving the Hop Limit ................... 29
        6.4  Specifying the Next Hop Address ...................... 30
        6.5  Specifying/Receiving the Traffic Class value ......... 31
        6.6  Additional Errors with sendmsg() and setsockopt() .... 32
        6.7  Summary of Outgoing Interface Selection .............. 32
   7.   Routing Header Option ..................................... 33
        7.1  inet6_rth_space ...................................... 35
        7.2  inet6_rth_init ....................................... 35
        7.3  inet6_rth_add ........................................ 36
        7.4  inet6_rth_reverse .................................... 36
        7.5  inet6_rth_segments ................................... 36
        7.6  inet6_rth_getaddr .................................... 36
   8.   Hop-By-Hop Options ........................................ 37
        8.1  Receiving Hop-by-Hop Options ......................... 38
        8.2  Sending Hop-by-Hop Options ........................... 38
   9.   Destination Options ....................................... 39
        9.1  Receiving Destination Options ........................ 39
        9.2  Sending Destination Options .......................... 39
   10.  Hop-by-Hop and Destination Options Processing ............. 40
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
        10.1  inet6_opt_init ...................................... 41
        10.2  inet6_opt_append .................................... 41
        10.3  inet6_opt_finish .................................... 42
        10.4  inet6_opt_set_val ................................... 42
        10.5  inet6_opt_next ...................................... 42
        10.6  inet6_opt_find ...................................... 43
        10.7  inet6_opt_get_val ................................... 43
   11.  Additional Advanced API Functions ......................... 44
        11.1  Sending with the Minimum MTU ........................ 44
        11.2  Sending without Fragmentation ....................... 45
        11.3  Path MTU Discovery and UDP .......................... 46
        11.4  Determining the Current Path MTU .................... 47
   12.  Ordering of Ancillary Data and IPv6 Extension Headers ..... 48
   13.  IPv6-Specific Options with IPv4-Mapped IPv6 Addresses ..... 50
   14.  Extended interfaces for rresvport, rcmd and rexec ......... 51
        14.1  rresvport_af ........................................ 51
        14.2  rcmd_af ............................................. 51
        14.3  rexec_af ............................................ 52
   15.  Summary of New Definitions ................................ 52
   16.  Security Considerations ................................... 56
   17.  Changes from RFC 2292 ..................................... 57
   18.  References ................................................ 59
   19.  Acknowledgments ........................................... 59
   20.  Appendix A: Ancillary Data Overview ....................... 60
        20.1  The msghdr Structure ................................ 60
        20.2  The cmsghdr Structure ............................... 61
        20.3  Ancillary Data Object Macros ........................ 62
              20.3.1  CMSG_FIRSTHDR ............................... 63
              20.3.2  CMSG_NXTHDR ................................. 64
              20.3.3  CMSG_DATA ................................... 65
              20.3.4  CMSG_SPACE .................................. 65
              20.3.5  CMSG_LEN .................................... 65
   21.  Appendix B: Examples Using the inet6_rth_XXX() Functions .. 65
        21.1  Sending a Routing Header ............................ 65
        21.2  Receiving Routing Headers ........................... 70
   22.  Appendix C: Examples Using the inet6_opt_XXX() Functions .. 72
        22.1  Building Options .................................... 72
        22.2  Parsing Received Options ............................ 74
   23.  Authors&#39; Addresses ........................................ 76
   24.  Full Copyright Statement .................................. 77
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A separate specification [RFC-3493] contains changes to the sockets API to support IP version 6. Those changes are for TCP and UDP-based applications. This document defines some of the &#34;advanced&#34; features of the sockets API that are required for applications to take advantage of additional features of IPv6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
個別の仕様[RFC-3493]には、IPバージョン6をサポートするSockets APIの変更が含まれています。これらの変更は、TCPおよびUDPベースのアプリケーション用です。このドキュメントでは、IPv6の追加機能を活用するためにアプリケーションに必要なソケットAPIの「高度な」機能の一部を定義しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Today, the portability of applications using IPv4 raw sockets is quite high, but this is mainly because most IPv4 implementations started from a common base (the Berkeley source code) or at least started with the Berkeley header files. This allows programs such as Ping and Traceroute, for example, to compile with minimal effort on many hosts that support the sockets API. With IPv6, however, there is no common source code base that implementors are starting from, and the possibility for divergence at this level between different implementations is high. To avoid a complete lack of portability amongst applications that use raw IPv6 sockets, some standardization is necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
今日、IPv4 Raw Socketsを使用したアプリケーションの移植性は非常に高いですが、これは主に、ほとんどのIPv4実装が共通ベース（Berkeleyソースコード）から始まったか、少なくともBerkeley Headerファイルから始まったためです。これにより、たとえばPingやTracerouteなどのプログラムが、Sockets APIをサポートする多くのホストで最小限の労力でコンパイルできます。ただし、IPv6では、実装者が開始している一般的なソースコードベースはなく、異なる実装間のこのレベルでの発散の可能性が高いです。RAW IPv6ソケットを使用するアプリケーション間の携帯性の完全な不足を回避するには、いくつかの標準化が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are also features from the basic IPv6 specification that are not addressed in [RFC-3493]: sending and receiving Routing headers, Hop-by-Hop options, and Destination options, specifying the outgoing interface, being told of the receiving interface, and control of path MTU information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC-3493]で対処されていない基本IPv6仕様の機能もあります。ルーティングヘッダーの送信と受信、ホップバイホップオプション、および目的地のオプション、発信インターフェイスの指定、受信インターフェイス、および受信インターフェイスの指定、およびパスMTU情報の制御。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document updates and replaces RFC 2292. This revision is based on implementation experience of RFC 2292, as well as some additional extensions that have been found to be useful through the IPv6 deployment. Note, however, that further work on this document may still be needed. Once the API specification becomes mature and is deployed among implementations, it may be formally standardized by a more appropriate body, such as has been done with the Basic API [RFC-3493].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、RFC 2292を更新および置き換えます。この改訂は、RFC 2292の実装エクスペリエンスと、IPv6展開を通じて有用であることがわかった追加の拡張機能に基づいています。ただし、このドキュメントでのさらなる作業がまだ必要になる場合があることに注意してください。API仕様が成熟し、実装の間に展開されると、基本的なAPI [RFC-3493]で行われたように、より適切な本体によって正式に標準化される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document can be divided into the following main sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、次のメインセクションに分けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Definitions of the basic constants and structures required for applications to use raw IPv6 sockets. This includes structure definitions for the IPv6 and ICMPv6 headers and all associated constants (e.g., values for the Next Header field).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. RAW IPv6ソケットを使用するためにアプリケーションに必要な基本的な定数と構造の定義。これには、IPv6およびICMPV6ヘッダーの構造定義、および関連するすべての定数（次のヘッダーフィールドの値など）が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Some basic semantic definitions for IPv6 raw sockets. For example, a raw ICMPv4 socket requires the application to calculate and store the ICMPv4 header checksum. But with IPv6 this would require the application to choose the source IPv6 address because the source address is part of the pseudo header that ICMPv6 now uses for its checksum computation. It should be defined that with a raw ICMPv6 socket the kernel always calculates and stores the ICMPv6 header checksum.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. IPv6 RAWソケットの基本的なセマンティック定義。たとえば、RAW ICMPV4ソケットでは、ICMPV4ヘッダーチェックサムを計算および保存するためのアプリケーションが必要です。ただし、IPv6では、ソースアドレスがICMPv6が現在チェックサム計算に使用している擬似ヘッダーの一部であるため、ソースIPv6アドレスを選択するためにアプリケーションが必要になります。生のICMPv6ソケットでは、カーネルは常にICMPV6ヘッダーチェックサムを計算して保存することを定義する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Packet information: how applications can obtain the received interface, destination address, and received hop limit, along with specifying these values on a per-packet basis. There are a class of applications that need this capability and the technique should be portable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. パケット情報：アプリケーションが受信されたインターフェイス、宛先アドレス、および受信ホップ制限を取得する方法と、パケットごとにこれらの値を指定します。この機能を必要とするアプリケーションのクラスがあり、テクニックはポータブルでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Access to the optional Routing header, Hop-by-Hop options, and Destination options extension headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. オプションのルーティングヘッダー、ホップバイホップオプション、および宛先オプション拡張ヘッダーへのアクセス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Additional features required for improved IPv6 application portability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. IPv6アプリケーションのポータビリティを改善するために必要な追加機能。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The packet information along with access to the extension headers (Routing header, Hop-by-Hop options, and Destination options) are specified using the &#34;ancillary data&#34; fields that were added to the 4.3BSD Reno sockets API in 1990. The reason is that these ancillary data fields are part of the Posix standard [POSIX] and should therefore be adopted by most vendors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張ヘッダーへのアクセス（ルーティングヘッダー、ホップバイホップオプション、および宛先オプション）へのパケット情報は、1990年に4.3bsd Reno Sockets APIに追加された「補助データ」フィールドを使用して指定されています。これらの補助データフィールドはPOSIX標準[POSIX]の一部であるため、ほとんどのベンダーが採用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document does not address application access to either the authentication header or the encapsulating security payload header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、認証ヘッダーまたはカプセル化セキュリティペイロードヘッダーへのアプリケーションアクセスには対応していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many examples in this document omit error checking in favor of brevity and clarity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの多くの例は、簡潔さと明確さを支持してエラーチェックを省略します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We note that some of the functions and socket options defined in this document may have error returns that are not defined in this document. Some of these possible error returns will be recognized only as implementations proceed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントで定義されている機能とソケットオプションの一部には、このドキュメントで定義されていないエラーリターンがある場合があることに注意してください。これらの可能なエラーリターンの一部は、実装が進むにつれてのみ認識されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Datatypes in this document follow the Posix format: intN_t means a signed integer of exactly N bits (e.g., int16_t) and uintN_t means an unsigned integer of exactly N bits (e.g., uint32_t).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントのデータタイプは、POSIX形式に従います。INTN_Tとは、正確なnビット（int16_tなど）の署名された整数を意味し、uintn_tは正確なnビット（uint32_tなど）の符号なし整数を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that we use the (unofficial) terminology ICMPv4, IGMPv4, and ARPv4 to avoid any confusion with the newer ICMPv6 protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいICMPV6プロトコルとの混乱を避けるために、（非公式の）用語ICMPV4、IGMPV4、およびARPV4を使用していることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Common-Structures-and-Definitions">
2. Common Structures and Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 一般的な構造と定義
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many advanced applications examine fields in the IPv6 header and set and examine fields in the various ICMPv6 headers. Common structure definitions for these protocol headers are required, along with common constant definitions for the structure members.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くの高度なアプリケーションがIPv6ヘッダーのフィールドを調べ、さまざまなICMPv6ヘッダーのフィールドを設定および調べます。これらのプロトコルヘッダーの共通構造定義と、構造メンバーの共通定義定義が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This API assumes that the fields in the protocol headers are left in the network byte order, which is big-endian for the Internet protocols. If not, then either these constants or the fields being tested must be converted at run-time, using something like htons() or htonl().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このAPIは、プロトコルヘッダーのフィールドがネットワークバイト順序で残されていると想定しています。そうでない場合は、これらの定数またはテスト対象のフィールドのいずれかを、htons（）やhtonl（）のようなものを使用して、実行時に変換する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two new header files are defined: &lt;netinet/ip6.h&gt; and &lt;netinet/icmp6.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つの新しいヘッダーファイルが定義されています：&lt;netinet/ip6.h&gt;と&lt;netinet/icmp6.h&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an include file is specified, that include file is allowed to include other files that do the actual declaration or definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
含まれるファイルが指定されている場合、ファイルには実際の宣言または定義を実行する他のファイルを含めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1--The-ip6hdr-Structure">
2.1. The ip6_hdr Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. IP6_HDR構造
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following structure is defined as a result of including &lt;netinet/ip6.h&gt;. Note that this is a new header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の構造は、&lt;netinet/ip6.h&gt;を含めた結果として定義されます。これは新しいヘッダーであることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct ip6_hdr {
        union {
          struct ip6_hdrctl {
            uint32_t ip6_un1_flow; /* 4 bits version, 8 bits TC, 20 bits
                                      flow-ID */
            uint16_t ip6_un1_plen; /* payload length */
            uint8_t  ip6_un1_nxt;  /* next header */
            uint8_t  ip6_un1_hlim; /* hop limit */
          } ip6_un1;
          uint8_t ip6_un2_vfc;     /* 4 bits version, top 4 bits
                                      tclass */
        } ip6_ctlun;
        struct in6_addr ip6_src;   /* source address */
        struct in6_addr ip6_dst;   /* destination address */
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
#define ip6_vfc ip6_ctlun.ip6_un2_vfc #define ip6_flow ip6_ctlun.ip6_un1.ip6_un1_flow #define ip6_plen ip6_ctlun.ip6_un1.ip6_un1_plen #define ip6_nxt ip6_ctlun.ip6_un1.ip6_un1_nxt #define ip6_hlim ip6_ctlun.ip6_un1.ip6_un1_hlim #define ip6_hops ip6_ctlun.ip6_un1.ip6_un1_hlim
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
＃DEFINE IP6_VFC IP6_CTLUN.IP6_UN2_VFC #DEFINE IP6_FLOW IP6_CTLUN.IP6_UN1.IP6_UN1_FLOW #DEFINE IP6_PLEN IP6_CTLUN.IP6_UN1.IP6_UN1_PLEN hlim ip6_ctlun.ip6_un1.ip6_un1_hlim #define ip6_hops ip6_ctlun.ip6_un1.ip6_un1_hlim
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1-1--IPv6-Next-Header-Values">
2.1.1. IPv6 Next Header Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.1. IPv6次のヘッダー値
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6 defines many new values for the Next Header field. The following constants are defined as a result of including &lt;netinet/in.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6は、次のヘッダーフィールドの多くの新しい値を定義します。次の定数は、&lt;netinet/in.h&gt;を含める結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define IPPROTO_HOPOPTS   0   /* IPv6 Hop-by-Hop options */
      #define IPPROTO_IPV6     41   /* IPv6 header */
      #define IPPROTO_ROUTING  43   /* IPv6 Routing header */
      #define IPPROTO_FRAGMENT 44   /* IPv6 fragment header */
      #define IPPROTO_ESP      50   /* encapsulating security payload */
      #define IPPROTO_AH       51   /* authentication header */
      #define IPPROTO_ICMPV6   58   /* ICMPv6 */
      #define IPPROTO_NONE     59   /* IPv6 no next header */
      #define IPPROTO_DSTOPTS  60   /* IPv6 Destination options */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Berkeley-derived IPv4 implementations also define IPPROTO_IP to be 0. This should not be a problem since IPPROTO_IP is used only with IPv4 sockets and IPPROTO_HOPOPTS only with IPv6 sockets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Berkeley由来のIPv4実装は、IPPROTO_IPが0であると定義しています。IPPROTO_IPはIPv4ソケットでのみ使用されるため、IPv6ソケットでのみIpproto_hopoptsでのみ使用されるため、これは問題ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1-2--IPv6-Extension-Headers">
2.1.2. IPv6 Extension Headers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.2. IPv6拡張ヘッダー
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Six extension headers are defined for IPv6. We define structures for all except the Authentication header and Encapsulating Security Payload header, both of which are beyond the scope of this document. The following structures are defined as a result of including &lt;netinet/ip6.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6用に6つの拡張ヘッダーが定義されています。認証ヘッダーを除くすべての構造を定義し、セキュリティペイロードヘッダーをカプセル化します。どちらもこのドキュメントの範囲を超えています。次の構造は、&lt;netinet/ip6.h&gt;を含めた結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* Hop-by-Hop options header */
      struct ip6_hbh {
        uint8_t  ip6h_nxt;        /* next header */
        uint8_t  ip6h_len;        /* length in units of 8 octets */
          /* followed by options */
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* Destination options header */
      struct ip6_dest {
        uint8_t  ip6d_nxt;        /* next header */
        uint8_t  ip6d_len;        /* length in units of 8 octets */
          /* followed by options */
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* Routing header */
      struct ip6_rthdr {
        uint8_t  ip6r_nxt;        /* next header */
        uint8_t  ip6r_len;        /* length in units of 8 octets */
        uint8_t  ip6r_type;       /* routing type */
        uint8_t  ip6r_segleft;    /* segments left */
          /* followed by routing type specific data */
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* Type 0 Routing header */
      struct ip6_rthdr0 {
        uint8_t  ip6r0_nxt;       /* next header */
        uint8_t  ip6r0_len;       /* length in units of 8 octets */
        uint8_t  ip6r0_type;      /* always zero */
        uint8_t  ip6r0_segleft;   /* segments left */
        uint32_t ip6r0_reserved;  /* reserved field */
          /* followed by up to 127 struct in6_addr */
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* Fragment header */
      struct ip6_frag {
        uint8_t   ip6f_nxt;       /* next header */
        uint8_t   ip6f_reserved;  /* reserved field */
        uint16_t  ip6f_offlg;     /* offset, reserved, and flag */
        uint32_t  ip6f_ident;     /* identification */
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #if     BYTE_ORDER == BIG_ENDIAN
      #define IP6F_OFF_MASK       0xfff8  /* mask out offset from
                                             ip6f_offlg */
      #define IP6F_RESERVED_MASK  0x0006  /* reserved bits in
                                             ip6f_offlg */
      #define IP6F_MORE_FRAG      0x0001  /* more-fragments flag */
      #else   /* BYTE_ORDER == LITTLE_ENDIAN */
      #define IP6F_OFF_MASK       0xf8ff  /* mask out offset from
                                             ip6f_offlg */
      #define IP6F_RESERVED_MASK  0x0600  /* reserved bits in
                                             ip6f_offlg */
      #define IP6F_MORE_FRAG      0x0100  /* more-fragments flag */
      #endif
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1-3--IPv6-Options">
2.1.3. IPv6 Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.3. IPv6オプション
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Several options are defined for IPv6, and we define structures and macro definitions for some of them below. The following structures are defined as a result of including &lt;netinet/ip6.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6に対していくつかのオプションが定義されており、以下の一部の構造とマクロ定義を定義します。次の構造は、&lt;netinet/ip6.h&gt;を含めた結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* IPv6 options */
      struct ip6_opt {
        uint8_t  ip6o_type;
        uint8_t  ip6o_len;
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /*
       * The high-order 3 bits of the option type define the behavior
       * when processing an unknown option and whether or not the option
       * content changes in flight.
       */
      #define IP6OPT_TYPE(o)        ((o) &amp; 0xc0)
      #define IP6OPT_TYPE_SKIP      0x00
      #define IP6OPT_TYPE_DISCARD   0x40
      #define IP6OPT_TYPE_FORCEICMP 0x80
      #define IP6OPT_TYPE_ICMP      0xc0
      #define IP6OPT_MUTABLE        0x20
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define IP6OPT_PAD1           0x00  /* 00 0 00000 */
      #define IP6OPT_PADN           0x01  /* 00 0 00001 */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define IP6OPT_JUMBO          0xc2  /* 11 0 00010 */
      #define IP6OPT_NSAP_ADDR      0xc3  /* 11 0 00011 */
      #define IP6OPT_TUNNEL_LIMIT   0x04  /* 00 0 00100 */
      #define IP6OPT_ROUTER_ALERT   0x05  /* 00 0 00101 */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* Jumbo Payload Option */
      struct ip6_opt_jumbo {
        uint8_t  ip6oj_type;
        uint8_t  ip6oj_len;
        uint8_t  ip6oj_jumbo_len[4];
      };
      #define IP6OPT_JUMBO_LEN   6
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* NSAP Address Option */
      struct ip6_opt_nsap {
        uint8_t  ip6on_type;
        uint8_t  ip6on_len;
        uint8_t  ip6on_src_nsap_len;
        uint8_t  ip6on_dst_nsap_len;
          /* followed by source NSAP */
          /* followed by destination NSAP */
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* Tunnel Limit Option */
      struct ip6_opt_tunnel {
        uint8_t  ip6ot_type;
        uint8_t  ip6ot_len;
        uint8_t  ip6ot_encap_limit;
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* Router Alert Option */
      struct ip6_opt_router {
        uint8_t  ip6or_type;
        uint8_t  ip6or_len;
        uint8_t  ip6or_value[2];
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* Router alert values (in network byte order) */
      #ifdef _BIG_ENDIAN
      #define IP6_ALERT_MLD      0x0000
      #define IP6_ALERT_RSVP     0x0001
      #define  IP6_ALERT_AN      0x0002
      #else
      #define IP6_ALERT_MLD      0x0000
      #define IP6_ALERT_RSVP     0x0100
      #define IP6_ALERT_AN       0x0200
      #endif
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2--The-icmp6hdr-Structure">
2.2. The icmp6_hdr Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. ICMP6_HDR構造
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ICMPv6 header is needed by numerous IPv6 applications including Ping, Traceroute, router discovery daemons, and neighbor discovery daemons. The following structure is defined as a result of including &lt;netinet/icmp6.h&gt;. Note that this is a new header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMPV6ヘッダーは、Ping、Traceroute、Router Discovery Daemons、Neighbor Discovery Daemonsなど、多数のIPv6アプリケーションに必要です。次の構造は、&lt;netinet/icmp6.h&gt;を含めた結果として定義されます。これは新しいヘッダーであることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct icmp6_hdr {
        uint8_t     icmp6_type;   /* type field */
        uint8_t     icmp6_code;   /* code field */
        uint16_t    icmp6_cksum;  /* checksum field */
        union {
          uint32_t  icmp6_un_data32[1]; /* type-specific field */
          uint16_t  icmp6_un_data16[2]; /* type-specific field */
          uint8_t   icmp6_un_data8[4];  /* type-specific field */
        } icmp6_dataun;
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define icmp6_data32    icmp6_dataun.icmp6_un_data32
      #define icmp6_data16    icmp6_dataun.icmp6_un_data16
      #define icmp6_data8     icmp6_dataun.icmp6_un_data8
      #define icmp6_pptr      icmp6_data32[0]  /* parameter prob */
      #define icmp6_mtu       icmp6_data32[0]  /* packet too big */
      #define icmp6_id        icmp6_data16[0]  /* echo request/reply */
      #define icmp6_seq       icmp6_data16[1]  /* echo request/reply */
      #define icmp6_maxdelay  icmp6_data16[0]  /* mcast group
                                                  membership */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2-1--ICMPv6-Type-and-Code-Values">
2.2.1. ICMPv6 Type and Code Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1. ICMPV6タイプとコード値
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to a common structure for the ICMPv6 header, common definitions are required for the ICMPv6 type and code fields. The following constants are also defined as a result of including &lt;netinet/icmp6.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMPV6ヘッダーの共通構造に加えて、ICMPV6タイプとコードフィールドに共通の定義が必要です。次の定数は、&lt;netinet/icmp6.h&gt;を含めた結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define ICMP6_DST_UNREACH             1
      #define ICMP6_PACKET_TOO_BIG          2
      #define ICMP6_TIME_EXCEEDED           3
      #define ICMP6_PARAM_PROB              4
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define ICMP6_INFOMSG_MASK  0x80    /* all informational
                                             messages */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define ICMP6_ECHO_REQUEST          128
      #define ICMP6_ECHO_REPLY            129
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define ICMP6_DST_UNREACH_NOROUTE     0 /* no route to
                                                 destination */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define ICMP6_DST_UNREACH_ADMIN       1 /* communication with
                                                 destination */
                                              /* admin. prohibited */
      #define ICMP6_DST_UNREACH_BEYONDSCOPE 2 /* beyond scope of source
                                                 address */
      #define ICMP6_DST_UNREACH_ADDR        3 /* address unreachable */
      #define ICMP6_DST_UNREACH_NOPORT      4 /* bad port */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define ICMP6_TIME_EXCEED_TRANSIT     0 /* Hop Limit == 0 in
                                                 transit */
      #define ICMP6_TIME_EXCEED_REASSEMBLY  1 /* Reassembly time out */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define ICMP6_PARAMPROB_HEADER        0 /* erroneous header
                                                 field */
      #define ICMP6_PARAMPROB_NEXTHEADER    1 /* unrecognized
                                                 Next Header */
      #define ICMP6_PARAMPROB_OPTION        2 /* unrecognized
                                                 IPv6 option */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The five ICMP message types defined by IPv6 neighbor discovery (133- 137) are defined in the next section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6 Neighbor Discovery（133-137）によって定義された5つのICMPメッセージタイプは、次のセクションで定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2-2--ICMPv6-Neighbor-Discovery-Definitions">
2.2.2. ICMPv6 Neighbor Discovery Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.2. ICMPV6ネイバーディスカバリー定義
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following structures and definitions are defined as a result of including &lt;netinet/icmp6.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の構造と定義は、&lt;netinet/icmp6.h&gt;を含めた結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define ND_ROUTER_SOLICIT           133
      #define ND_ROUTER_ADVERT            134
      #define ND_NEIGHBOR_SOLICIT         135
      #define ND_NEIGHBOR_ADVERT          136
      #define ND_REDIRECT                 137
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct nd_router_solicit {     /* router solicitation */
        struct icmp6_hdr  nd_rs_hdr;
          /* could be followed by options */
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define nd_rs_type               nd_rs_hdr.icmp6_type
      #define nd_rs_code               nd_rs_hdr.icmp6_code
      #define nd_rs_cksum              nd_rs_hdr.icmp6_cksum
      #define nd_rs_reserved           nd_rs_hdr.icmp6_data32[0]
            struct nd_router_advert {      /* router advertisement */
        struct icmp6_hdr  nd_ra_hdr;
        uint32_t   nd_ra_reachable;   /* reachable time */
        uint32_t   nd_ra_retransmit;  /* retransmit timer */
          /* could be followed by options */
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define nd_ra_type               nd_ra_hdr.icmp6_type
      #define nd_ra_code               nd_ra_hdr.icmp6_code
      #define nd_ra_cksum              nd_ra_hdr.icmp6_cksum
      #define nd_ra_curhoplimit        nd_ra_hdr.icmp6_data8[0]
      #define nd_ra_flags_reserved     nd_ra_hdr.icmp6_data8[1]
      #define ND_RA_FLAG_MANAGED       0x80
      #define ND_RA_FLAG_OTHER         0x40
      #define nd_ra_router_lifetime    nd_ra_hdr.icmp6_data16[1]
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct nd_neighbor_solicit {   /* neighbor solicitation */
        struct icmp6_hdr  nd_ns_hdr;
        struct in6_addr   nd_ns_target; /* target address */
          /* could be followed by options */
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define nd_ns_type               nd_ns_hdr.icmp6_type
      #define nd_ns_code               nd_ns_hdr.icmp6_code
      #define nd_ns_cksum              nd_ns_hdr.icmp6_cksum
      #define nd_ns_reserved           nd_ns_hdr.icmp6_data32[0]
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct nd_neighbor_advert {    /* neighbor advertisement */
        struct icmp6_hdr  nd_na_hdr;
        struct in6_addr   nd_na_target; /* target address */
          /* could be followed by options */
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define nd_na_type               nd_na_hdr.icmp6_type
      #define nd_na_code               nd_na_hdr.icmp6_code
      #define nd_na_cksum              nd_na_hdr.icmp6_cksum
      #define nd_na_flags_reserved     nd_na_hdr.icmp6_data32[0]
      #if     BYTE_ORDER == BIG_ENDIAN
      #define ND_NA_FLAG_ROUTER        0x80000000
      #define ND_NA_FLAG_SOLICITED     0x40000000
      #define ND_NA_FLAG_OVERRIDE      0x20000000
      #else   /* BYTE_ORDER == LITTLE_ENDIAN */
      #define ND_NA_FLAG_ROUTER        0x00000080
      #define ND_NA_FLAG_SOLICITED     0x00000040
      #define ND_NA_FLAG_OVERRIDE      0x00000020
      #endif
            struct nd_redirect {           /* redirect */
        struct icmp6_hdr  nd_rd_hdr;
        struct in6_addr   nd_rd_target; /* target address */
        struct in6_addr   nd_rd_dst;    /* destination address */
          /* could be followed by options */
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define nd_rd_type               nd_rd_hdr.icmp6_type
      #define nd_rd_code               nd_rd_hdr.icmp6_code
      #define nd_rd_cksum              nd_rd_hdr.icmp6_cksum
      #define nd_rd_reserved           nd_rd_hdr.icmp6_data32[0]
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct nd_opt_hdr {         /* Neighbor discovery option header */
        uint8_t  nd_opt_type;
        uint8_t  nd_opt_len;      /* in units of 8 octets */
          /* followed by option specific data */
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
#define ND_OPT_SOURCE_LINKADDR 1 #define ND_OPT_TARGET_LINKADDR 2 #define ND_OPT_PREFIX_INFORMATION 3 #define ND_OPT_REDIRECTED_HEADER 4 #define ND_OPT_MTU 5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
#define nd_opt_source_linkaddr 1 #define nd_opt_target_linkaddr 2 #define nd_opt_prefix_information 3 #define nd_opt_redirection_header 4 #define nd_opt_mtu 5 5
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct nd_opt_prefix_info {    /* prefix information */
        uint8_t   nd_opt_pi_type;
        uint8_t   nd_opt_pi_len;
        uint8_t   nd_opt_pi_prefix_len;
        uint8_t   nd_opt_pi_flags_reserved;
        uint32_t  nd_opt_pi_valid_time;
        uint32_t  nd_opt_pi_preferred_time;
        uint32_t  nd_opt_pi_reserved2;
        struct in6_addr  nd_opt_pi_prefix;
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
#define ND_OPT_PI_FLAG_ONLINK 0x80 #define ND_OPT_PI_FLAG_AUTO 0x40
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
#define nd_opt_pi_flag_onlink 0x80 #define nd_opt_pi_flag_auto 0x40
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct nd_opt_rd_hdr {         /* redirected header */
        uint8_t   nd_opt_rh_type;
        uint8_t   nd_opt_rh_len;
        uint16_t  nd_opt_rh_reserved1;
        uint32_t  nd_opt_rh_reserved2;
          /* followed by IP header and data */
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct nd_opt_mtu {            /* MTU option */
        uint8_t   nd_opt_mtu_type;
        uint8_t   nd_opt_mtu_len;
        uint16_t  nd_opt_mtu_reserved;
        uint32_t  nd_opt_mtu_mtu;
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We note that the nd_na_flags_reserved flags have the same byte ordering problems as we showed with ip6f_offlg.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ND_NA_FLAGS_Reservedフラグには、IP6F_OFFLGで示したのと同じバイト順序付けの問題があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2-3--Multicast-Listener-Discovery-Definitions">
2.2.3. Multicast Listener Discovery Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.3. マルチキャストリスナーの発見定義
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following structures and definitions are defined as a result of including &lt;netinet/icmp6.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の構造と定義は、&lt;netinet/icmp6.h&gt;を含めた結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
#define MLD_LISTENER_QUERY 130 #define MLD_LISTENER_REPORT 131 #define MLD_LISTENER_REDUCTION 132
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
#define mld_listener_query 130 #define mld_listener_report 131 #define mld_listener_reduction 132
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct mld_hdr {
        struct icmp6_hdr  mld_icmp6_hdr;
        struct in6_addr   mld_addr; /* multicast address */
      };
      #define mld_type                 mld_icmp6_hdr.icmp6_type
      #define mld_code                 mld_icmp6_hdr.icmp6_code
      #define mld_cksum                mld_icmp6_hdr.icmp6_cksum
      #define mld_maxdelay             mld_icmp6_hdr.icmp6_data16[0]
      #define mld_reserved             mld_icmp6_hdr.icmp6_data16[1]
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2-4--ICMPv6-Router-Renumbering-Definitions">
2.2.4. ICMPv6 Router Renumbering Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.4. ICMPV6ルーターの変更定義
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following structures and definitions are defined as a result of including &lt;netinet/icmp6.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の構造と定義は、&lt;netinet/icmp6.h&gt;を含めた結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define ICMP6_ROUTER_RENUMBERING    138   /* router renumbering */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct icmp6_router_renum {  /* router renumbering header */
        struct icmp6_hdr  rr_hdr;
        uint8_t           rr_segnum;
        uint8_t           rr_flags;
        uint16_t          rr_maxdelay;
        uint32_t          rr_reserved;
      };
      #define rr_type                  rr_hdr.icmp6_type
      #define rr_code                  rr_hdr.icmp6_code
      #define rr_cksum                 rr_hdr.icmp6_cksum
      #define rr_seqnum                rr_hdr.icmp6_data32[0]
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* Router renumbering flags */
      #define ICMP6_RR_FLAGS_TEST        0x80
      #define ICMP6_RR_FLAGS_REQRESULT   0x40
      #define ICMP6_RR_FLAGS_FORCEAPPLY  0x20
      #define ICMP6_RR_FLAGS_SPECSITE    0x10
      #define ICMP6_RR_FLAGS_PREVDONE    0x08
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct rr_pco_match {    /* match prefix part */
        uint8_t          rpm_code;
        uint8_t          rpm_len;
        uint8_t          rpm_ordinal;
        uint8_t          rpm_matchlen;
        uint8_t          rpm_minlen;
        uint8_t          rpm_maxlen;
        uint16_t         rpm_reserved;
        struct in6_addr  rpm_prefix;
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* PCO code values */
      #define RPM_PCO_ADD              1
      #define RPM_PCO_CHANGE           2
      #define RPM_PCO_SETGLOBAL        3
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct rr_pco_use {    /* use prefix part */
        uint8_t          rpu_uselen;
        uint8_t          rpu_keeplen;
        uint8_t          rpu_ramask;
        uint8_t          rpu_raflags;
        uint32_t         rpu_vltime;
        uint32_t         rpu_pltime;
        uint32_t         rpu_flags;
        struct in6_addr  rpu_prefix;
      };
      #define ICMP6_RR_PCOUSE_RAFLAGS_ONLINK   0x20
      #define ICMP6_RR_PCOUSE_RAFLAGS_AUTO     0x10
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #if BYTE_ORDER == BIG_ENDIAN
      #define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME 0x80000000
      #define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME 0x40000000
      #elif BYTE_ORDER == LITTLE_ENDIAN
      #define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME 0x80
      #define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME 0x40
      #endif
            struct rr_result {    /* router renumbering result message */
        uint16_t         rrr_flags;
        uint8_t          rrr_ordinal;
        uint8_t          rrr_matchedlen;
        uint32_t         rrr_ifid;
        struct in6_addr  rrr_prefix;
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #if BYTE_ORDER == BIG_ENDIAN
      #define ICMP6_RR_RESULT_FLAGS_OOB        0x0002
      #define ICMP6_RR_RESULT_FLAGS_FORBIDDEN  0x0001
      #elif BYTE_ORDER == LITTLE_ENDIAN
      #define ICMP6_RR_RESULT_FLAGS_OOB        0x0200
      #define ICMP6_RR_RESULT_FLAGS_FORBIDDEN  0x0100
      #endif
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3--Address-Testing-Macros">
2.3. Address Testing Macros
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. マクロのアドレステスト
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic API ([RFC-3493]) defines some macros for testing an IPv6 address for certain properties. This API extends those definitions with additional address testing macros, defined as a result of including &lt;netinet/in.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本的なAPI（[RFC-3493]）は、特定のプロパティのIPv6アドレスをテストするためのマクロを定義します。このAPIは、これらの定義を追加のアドレステストマクロで拡張します。これは、&lt;netinet/in.h&gt;を含めた結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int  IN6_ARE_ADDR_EQUAL(const struct in6_addr *,
                              const struct in6_addr *);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This macro returns non-zero if the addresses are equal; otherwise it returns zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アドレスが等しい場合、このマクロはゼロ以外を返します。それ以外の場合は、ゼロを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-4--Protocols-File">
2.4. Protocols File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4. プロトコルファイル
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many hosts provide the file /etc/protocols that contains the names of the various IP protocols and their protocol number (e.g., the value of the protocol field in the IPv4 header for that protocol, such as 1 for ICMP). Some programs then call the function getprotobyname() to obtain the protocol value that is then specified as the third argument to the socket() function. For example, the Ping program contains code of the form
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くのホストは、さまざまなIPプロトコルの名前とそのプロトコル番号を含むファイル /etc /プロトコルを提供します（たとえば、ICMPの1など、そのプロトコルのIPv4ヘッダーのプロトコルフィールドの値）。一部のプログラムは、関数getProtobyname（）を呼び出して、ソケット（）関数の3番目の引数として指定されるプロトコル値を取得します。たとえば、Pingプログラムにはフォームのコードが含まれています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
struct protoent *proto;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
struct protoent *proto;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      proto = getprotobyname(&#34;icmp&#34;);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      s = socket(AF_INET, SOCK_RAW, proto-&gt;p_proto);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Common names are required for the new IPv6 protocols in this file, to provide portability of applications that call the getprotoXXX() functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このファイルの新しいIPv6プロトコルには、getProtoxxx（）関数を呼び出すアプリケーションの移植性を提供するために、共通名が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We define the following protocol names with the values shown. These are taken under http://www.iana.org/numbers.html.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表示されている値で次のプロトコル名を定義します。これらはhttp://www.iana.org/numbers.htmlで撮影されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      hopopt           0    # hop-by-hop options for ipv6
      ipv6            41    # ipv6
      ipv6-route      43    # routing header for ipv6
      ipv6-frag       44    # fragment header for ipv6
      esp             50    # encapsulating security payload for ipv6
      ah              51    # authentication header for ipv6
      ipv6-icmp       58    # icmp for ipv6
      ipv6-nonxt      59    # no next header for ipv6
      ipv6-opts       60    # destination options for ipv6
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--IPv6-Raw-Sockets">
3. IPv6 Raw Sockets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. IPv6 RAWソケット
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Raw sockets bypass the transport layer (TCP or UDP). With IPv4, raw sockets are used to access ICMPv4, IGMPv4, and to read and write IPv4 datagrams containing a protocol field that the kernel does not process. An example of the latter is a routing daemon for OSPF, since it uses IPv4 protocol field 89. With IPv6 raw sockets will be used for ICMPv6 and to read and write IPv6 datagrams containing a Next Header field that the kernel does not process. Examples of the latter are a routing daemon for OSPF for IPv6 and RSVP (protocol field 46).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
生のソケットは、輸送層（TCPまたはUDP）をバイパスします。IPv4を使用すると、RAWソケットを使用してICMPV4、IGMPV4にアクセスし、カーネルが処理しないプロトコルフィールドを含むIPv4データグラムの読み取りと書き込みです。後者の例は、IPv4プロトコルフィールド89を使用しているため、OSPFのルーティングデーモンです。IPv6のソケットを使用してICMPv6に使用され、カーネルが処理しない次のヘッダーフィールドを含むIPv6データグラムの読み取りと書き込みです。後者の例は、IPv6およびRSVPのOSPFのルーティングデーモンです（プロトコルフィールド46）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All data sent via raw sockets must be in network byte order and all data received via raw sockets will be in network byte order. This differs from the IPv4 raw sockets, which did not specify a byte ordering and used the host&#39;s byte order for certain IP header fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
生のソケットを介して送信されるすべてのデータはネットワークバイトの順序でなければならず、生のソケットを介して受信したすべてのデータはネットワークバイトの順序で行われます。これは、バイトの順序を指定せず、特定のIPヘッダーフィールドにホストのバイトオーダーを使用したIPv4 Raw Socketsとは異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another difference from IPv4 raw sockets is that complete packets (that is, IPv6 packets with extension headers) cannot be sent or received using the IPv6 raw sockets API. Instead, ancillary data objects are used to transfer the extension headers and hoplimit information, as described in Section 6. Should an application need access to the complete IPv6 packet, some other technique, such as the datalink interfaces BPF or DLPI, must be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv4 Raw Socketsとのもう1つの違いは、完全なパケット（つまり、拡張ヘッダー付きIPv6パケット）をIPv6 Raw Sockets APIを使用して送信または受信できないことです。代わりに、セクション6で説明されているように、補助的なデータオブジェクトは、拡張ヘッダーとHopLimit情報の転送に使用されます。アプリケーションでは、DatalinkインターフェイスBPFやDLPIなどのその他の手法をアプリケーションにアクセスする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All fields except the flow label in the IPv6 header that an application might want to change (i.e., everything other than the version number) can be modified using ancillary data and/or socket options by the application for output. All fields except the flow label in a received IPv6 header (other than the version number and Next Header fields) and all extension headers that an application might want to know are also made available to the application as ancillary data on input. Hence there is no need for a socket option similar to the IPv4 IP_HDRINCL socket option and on receipt the application will only receive the payload i.e., the data after the IPv6 header and all the extension headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションが変更したい可能性のあるIPv6ヘッダーのフローラベルを除くすべてのフィールド（つまり、バージョン番号以外のすべて）は、出力用のアプリケーションによって補助データおよび/またはソケットオプションを使用して変更できます。受信したIPv6ヘッダー（バージョン番号および次のヘッダーフィールド以外）のフローラベルを除くすべてのフィールドと、アプリケーションが知りたいと思う可能性のあるすべての拡張ヘッダーも、入力に関する補助データとしてアプリケーションに利用可能になります。したがって、IPv4 IP_HDRINCLソケットオプションと同様のソケットオプションは必要ありません。受領時には、アプリケーションはペイロード、つまりIPv6ヘッダーとすべての拡張ヘッダーの後のデータのみを受け取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This API does not define access to the flow label field, because today there is no standard usage of the field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このAPIは、フィールドの標準的な使用法がないため、フローラベルフィールドへのアクセスを定義するものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When writing to a raw socket the kernel will automatically fragment the packet if its size exceeds the path MTU, inserting the required fragment headers. On input the kernel reassembles received fragments, so the reader of a raw socket never sees any fragment headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
生のソケットに書き込むとき、カーネルは、そのサイズがパスMTUを超えた場合、パケットを自動的にフラグメントし、必要なフラグメントヘッダーを挿入します。入力時には、カーネルの再組み立てが受信されたフラグメントであるため、生のソケットの読者はフラグメントヘッダーを見ることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When we say &#34;an ICMPv6 raw socket&#34; we mean a socket created by calling the socket function with the three arguments AF_INET6, SOCK_RAW, and IPPROTO_ICMPV6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「ICMPV6 RAW SOCKET」と言うと、3つの引数AF_INET6、SOCK_RAW、およびIPPROTO_ICMPV6を使用してソケット関数を呼び出すことで作成されたソケットを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most IPv4 implementations give special treatment to a raw socket created with a third argument to socket() of IPPROTO_RAW, whose value is normally 255, to have it mean that the application will send down complete packets including the IPv4 header. (Note: This feature was added to IPv4 in 1988 by Van Jacobson to support traceroute, allowing a complete IP header to be passed by the application, before the IP_HDRINCL socket option was added.) We note that IPPROTO_RAW has no special meaning to an IPv6 raw socket (and the IANA currently reserves the value of 255 when used as a next-header field).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ほとんどのIPv4実装は、IPPROTO_RAWのSocket（）の3番目の引数で作成された生のソケットに対して特別な処理を提供します。これは通常255であるため、アプリケーションがIPv4ヘッダーを含む完全なパケットを送信することを意味します。（注：この機能は、1988年にVan JacobsonによってIPv4に追加され、Tracerouteをサポートし、IP_Hdrinclソケットオプションが追加される前に、アプリケーションで完全なIPヘッダーを渡すことができます。RAWソケット（およびIANAは現在、次のヘッダーフィールドとして使用すると255の値を予約しています）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--Checksums">
3.1. Checksums
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. チェックサム
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The kernel will calculate and insert the ICMPv6 checksum for ICMPv6 raw sockets, since this checksum is mandatory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
カーネルは、このチェックサムが必須であるため、ICMPV6生のソケットのICMPV6チェックサムを計算して挿入します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For other raw IPv6 sockets (that is, for raw IPv6 sockets created with a third argument other than IPPROTO_ICMPV6), the application must set the new IPV6_CHECKSUM socket option to have the kernel (1) compute and store a checksum for output, and (2) verify the received checksum on input, discarding the packet if the checksum is in error. This option prevents applications from having to perform source address selection on the packets they send. The checksum will incorporate the IPv6 pseudo-header, defined in Section 8.1 of [RFC-2460]. This new socket option also specifies an integer offset into the user data of where the checksum is located.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他の生のIPv6ソケット（つまり、ipproto_icmpv6以外の3番目の引数で作成された生のIPv6ソケットの場合）の場合、アプリケーションは、新しいIPv6_Checksumソケットオプションを設定して、カーネル（1）を計算し、出力のチェックサムを保存する必要があります。）入力に関する受信したチェックサムを確認し、チェックサムが誤っている場合はパケットを破棄します。このオプションは、アプリケーションが送信するパケットでソースアドレス選択を実行する必要がないことを防ぎます。チェックサムには、[RFC-2460]のセクション8.1で定義されているIPv6擬似ヘッダーが組み込まれます。この新しいソケットオプションは、チェックサムの配置場所のユーザーデータへの整数オフセットも指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int  offset = 2;
      setsockopt(fd, IPPROTO_IPV6, IPV6_CHECKSUM, &amp;offset,
                 sizeof(offset));
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By default, this socket option is disabled. Setting the offset to -1 also disables the option. By disabled we mean (1) the kernel will not calculate and store a checksum for outgoing packets, and (2) the kernel will not verify a checksum for received packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デフォルトでは、このソケットオプションは無効になっています。オフセットを-1に設定することもオプションを無効にします。（1）カーネルは発信パケットのチェックサムを計算して保存せず、（2）カーネルは受信パケットのチェックサムを確認しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This option assumes the use of the 16-bit one&#39;s complement of the one&#39;s complement sum as the checksum algorithm and that the checksum field is aligned on a 16-bit boundary. Thus, specifying a positive odd value as offset is invalid, and setsockopt() will fail for such offset values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオプションは、チェックサムアルゴリズムとしての16ビットの補体合計の補体の使用と、チェックサムフィールドが16ビットの境界に並べられていることを想定しています。したがって、正の奇数値をオフセットとして指定することは無効であり、SetSockopt（）はそのようなオフセット値で失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attempt to set IPV6_CHECKSUM for an ICMPv6 socket will fail. Also, an attempt to set or get IPV6_CHECKSUM for a non-raw IPv6 socket will fail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMPv6ソケットのIPv6_Checksumを設定する試みは失敗します。また、非RAW IPv6ソケットのIPv6_Checksumを設定または取得する試みは失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: Since the checksum is always calculated by the kernel for an ICMPv6 socket, applications are not able to generate ICMPv6 packets with incorrect checksums (presumably for testing purposes) using this API.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：チェックサムは常にICMPV6ソケットのカーネルによって計算されるため、アプリケーションはこのAPIを使用して誤ったチェックサム（おそらくテスト目的で）でICMPv6パケットを生成できません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--ICMPv6-Type-Filtering">
3.2. ICMPv6 Type Filtering
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. ICMPV6タイプフィルタリング
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMPv4 raw sockets receive most ICMPv4 messages received by the kernel. (We say &#34;most&#34; and not &#34;all&#34; because Berkeley-derived kernels never pass echo requests, timestamp requests, or address mask requests to a raw socket. Instead these three messages are processed entirely by the kernel.) But ICMPv6 is a superset of ICMPv4, also including the functionality of IGMPv4 and ARPv4. This means that an ICMPv6 raw socket can potentially receive many more messages than would be received with an ICMPv4 raw socket: ICMP messages similar to ICMPv4, along with neighbor solicitations, neighbor advertisements, and the three multicast listener discovery messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMPV4 RAWソケットは、カーネルで受信されたほとんどのICMPV4メッセージを受信します。（バークレー由来のカーネルがエコーリクエスト、タイムスタンプリクエスト、またはマスクリクエストを生のソケットに渡すことはないため、「ほとんど」と「すべて」とは「すべて」と言います。代わりに、これらの3つのメッセージは完全にケネルによって処理されます。）IGMPv4とArpv4の機能も含まれます。これは、ICMPV6 RAWソケットが、ICMPV4 RAWソケットで受信されるよりも多くのメッセージを受信する可能性があることを意味します。ICMPv4に似たICMPメッセージ、および近隣の勧誘、近隣広告、および3つのマルチキャストリスナーディスカバリーメッセージとともに。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most applications using an ICMPv6 raw socket care about only a small subset of the ICMPv6 message types. To transfer extraneous ICMPv6 messages from the kernel to user can incur a significant overhead. Therefore this API includes a method of filtering ICMPv6 messages by the ICMPv6 type field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMPV6 RAWソケットを使用するほとんどのアプリケーションは、ICMPV6メッセージタイプの小さなサブセットのみを注意してください。カーネルからユーザーに無関係なICMPV6メッセージを転送するには、重大なオーバーヘッドが発生する可能性があります。したがって、このAPIには、ICMPV6型フィールドによるICMPV6メッセージをフィルタリングする方法が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each ICMPv6 raw socket has an associated filter whose datatype is defined as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各icmpv6生ソケットには、データ型が次のように定義されている関連フィルターがあります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
struct icmp6_filter;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
struct icmp6_filter;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure, along with the macros and constants defined later in this section, are defined as a result of including the &lt;netinet/icmp6.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造は、このセクションの後半で定義されたマクロと定数とともに、&lt;netinet/icmp6.h&gt;を含めた結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current filter is fetched and stored using getsockopt() and setsockopt() with a level of IPPROTO_ICMPV6 and an option name of ICMP6_FILTER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のフィルターは、getsockopt（）およびsetSockopt（）を使用してICMP6_Filterのオプション名を使用してfetted ockopt（）およびsetSockopt（）を使用して保存されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Six macros operate on an icmp6_filter structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6つのマクロがICMP6_Filter構造で動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      void ICMP6_FILTER_SETPASSALL (struct icmp6_filter *);
      void ICMP6_FILTER_SETBLOCKALL(struct icmp6_filter *);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      void ICMP6_FILTER_SETPASS ( int, struct icmp6_filter *);
      void ICMP6_FILTER_SETBLOCK( int, struct icmp6_filter *);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
int ICMP6_FILTER_WILLPASS (int, const struct icmp6_filter *); int ICMP6_FILTER_WILLBLOCK(int, const struct icmp6_filter *);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
int icmp6_filter_willpass（int、const struct icmp6_filter *）;int icmp6_filter_willblock（int、const struct icmp6_filter *）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first argument to the last four macros (an integer) is an ICMPv6 message type, between 0 and 255. The pointer argument to all six macros is a pointer to a filter that is modified by the first four macros and is examined by the last two macros.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後の4つのマクロ（整数）の最初の引数は、0〜255のICMPV6メッセージタイプです。6つのマクロすべてへのポインター引数は、最初の4つのマクロによって変更され、最後の4つのマクロによって修正されたフィルターへのポインターです。2つのマクロ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first two macros, SETPASSALL and SETBLOCKALL, let us specify that all ICMPv6 messages are passed to the application or that all ICMPv6 messages are blocked from being passed to the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の2つのマクロ、SetPassallとSetBlockallは、すべてのICMPV6メッセージがアプリケーションに渡されるか、すべてのICMPV6メッセージがアプリケーションに渡されるのをブロックされることを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next two macros, SETPASS and SETBLOCK, let us specify that messages of a given ICMPv6 type should be passed to the application or not passed to the application (blocked).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の2つのマクロ、SetPassとSetBlockは、特定のICMPV6タイプのメッセージをアプリケーションに渡すか、アプリケーションに渡されないか（ブロックされていない）ことを指定しましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The final two macros, WILLPASS and WILLBLOCK, return true or false depending whether the specified message type is passed to the application or blocked from being passed to the application by the filter pointed to by the second argument.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後の2つのマクロ、ウィルパスとウィルブロックは、指定されたメッセージタイプがアプリケーションに渡されるか、2番目の引数によって指されたフィルターによってアプリケーションに渡されるのをブロックするかどうかに応じてtrueまたはfalseを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an ICMPv6 raw socket is created, it will by default pass all ICMPv6 message types to the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMPV6 RAWソケットが作成されると、デフォルトではすべてのICMPV6メッセージタイプをアプリケーションに渡します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example, a program that wants to receive only router advertisements could execute the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例として、ルーター広告のみを受け取りたいプログラムは、次のことを実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
struct icmp6_filter myfilt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
struct icmp6_filter myfilt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      fd = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ICMP6_FILTER_SETBLOCKALL(&amp;myfilt); ICMP6_FILTER_SETPASS(ND_ROUTER_ADVERT, &amp;myfilt); setsockopt(fd, IPPROTO_ICMPV6, ICMP6_FILTER, &amp;myfilt,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
icmp6_filter_setblockall（＆myfilt）;icmp6_filter_setpass（nd_router_advert、＆myfilt）;SetSockopt（FD、IPPROTO_ICMPV6、ICMP6_FILTER、＆MYFILT、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
sizeof(myfilt));
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
sizeof（myfilt））;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The filter structure is declared and then initialized to block all messages types. The filter structure is then changed to allow router advertisement messages to be passed to the application and the filter is installed using setsockopt().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィルター構造が宣言され、すべてのメッセージタイプをブロックするように初期化されます。次に、フィルター構造を変更して、ルーター広告メッセージをアプリケーションに渡すことができ、フィルターはsetSockopt（）を使用してインストールされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to clear an installed filter the application can issue a setsockopt for ICMP6_FILTER with a zero length. When no such filter has been installed, getsockopt() will return the kernel default filter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インストールされたフィルターをクリアするために、アプリケーションは長さがゼロのICMP6_FilterのSetSockoptを発行できます。そのようなフィルターがインストールされていない場合、GetSockopt（）はカーネルデフォルトフィルターを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The icmp6_filter structure is similar to the fd_set datatype used with the select() function in the sockets API. The icmp6_filter structure is an opaque datatype and the application should not care how it is implemented. All the application does with this datatype is allocate a variable of this type, pass a pointer to a variable of this type to getsockopt() and setsockopt(), and operate on a variable of this type using the six macros that we just defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMP6_Filter構造は、Sockets APIのSelect（）関数で使用されるFD_SETデータタイプに似ています。ICMP6_Filter構造は不透明なデータ型であり、アプリケーションがどのように実装されているかを気にしてはなりません。このデータタイプで行うすべてのアプリケーションは、このタイプの変数を割り当て、このタイプの変数へのポインターをgetSockopt（）とsetSockopt（）に渡し、定義した6つのマクロを使用してこのタイプの変数を操作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nevertheless, it is worth showing a simple implementation of this datatype and the six macros.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それにもかかわらず、このデータ型と6つのマクロの簡単な実装を示す価値があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct icmp6_filter {
        uint32_t  icmp6_filt[8];  /* 8*32 = 256 bits */
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define ICMP6_FILTER_WILLPASS(type, filterp) \
        ((((filterp)-&gt;icmp6_filt[(type) &gt;&gt; 5]) &amp; \
          (1 &lt;&lt; ((type) &amp; 31))) != 0)
      #define ICMP6_FILTER_WILLBLOCK(type, filterp) \
        ((((filterp)-&gt;icmp6_filt[(type) &gt;&gt; 5]) &amp; \
          (1 &lt;&lt; ((type) &amp; 31))) == 0)
      #define ICMP6_FILTER_SETPASS(type, filterp) \
        ((((filterp)-&gt;icmp6_filt[(type) &gt;&gt; 5]) |= \
          (1 &lt;&lt; ((type) &amp; 31))))
      #define ICMP6_FILTER_SETBLOCK(type, filterp) \
        ((((filterp)-&gt;icmp6_filt[(type) &gt;&gt; 5]) &amp;= \
          ~(1 &lt;&lt; ((type) &amp; 31))))
      #define ICMP6_FILTER_SETPASSALL(filterp) \
        memset((filterp), 0xFF, sizeof(struct icmp6_filter))
      #define ICMP6_FILTER_SETBLOCKALL(filterp) \
        memset((filterp), 0, sizeof(struct icmp6_filter))
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: These sample definitions have two limitations that an implementation may want to change. The first four macros evaluate their first argument two times. The second two macros require the inclusion of the &lt;string.h&gt; header for the memset() function.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：これらのサンプル定義には、実装が変更したい2つの制限があります。最初の4つのマクロは最初の引数を2回評価します。2番目の2つのマクロには、Memset（）関数に&lt;String.H&gt;ヘッダーを含める必要があります。））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3--ICMPv6-Verification-of-Received-Packets">
3.3. ICMPv6 Verification of Received Packets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. ICMPV6受信パケットの検証
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol stack will verify the ICMPv6 checksum and discard any packets with invalid checksums.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルスタックは、ICMPV6チェックサムを検証し、無効なチェックサムでパケットを破棄します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation might perform additional validity checks on the ICMPv6 message content and discard malformed packets. However, a portable application must not assume that such validity checks have been performed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、ICMPV6メッセージコンテンツの追加の妥当性チェックを実行し、不正なパケットを破棄する場合があります。ただし、ポータブルアプリケーションは、そのような妥当性チェックが実行されたと仮定してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol stack should not automatically discard packets if the ICMP type is unknown to the stack. For extensibility reasons received ICMP packets with any type (informational or error) must be passed to the applications (subject to ICMP6_FILTER filtering on the type value and the checksum verification).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMPタイプがスタックに不明な場合、プロトコルスタックはパケットを自動的に破棄してはなりません。拡張上の理由で、任意のタイプのICMPパケット（情報またはエラー）をアプリケーションに渡す必要があります（型値とチェックサムの検証に関するICMP6_FILTERフィルタリングの対象となります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Access-to-IPv6-and-Extension-Headers">
4. Access to IPv6 and Extension Headers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. IPv6および拡張ヘッダーへのアクセス
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications need to be able to control IPv6 header and extension header content when sending as well as being able to receive the content of these headers. This is done by defining socket option types which can be used both with setsockopt and with ancillary data. Ancillary data is discussed in Appendix A. The following optional information can be exchanged between the application and the kernel:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、これらのヘッダーのコンテンツを送信するだけでなく、送信時にIPv6ヘッダーと拡張ヘッダーのコンテンツを制御できる必要があります。これは、SetSockoptと補助データの両方で使用できるソケットオプションタイプを定義することによって行われます。補助データについては、付録Aで説明します。次のオプション情報は、アプリケーションとカーネルの間で交換できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The send/receive interface and source/destination address, 2. The hop limit, 3. Next hop address, 4. The traffic class, 5. Routing header, 6. Hop-by-Hop options header, and 7. Destination options header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. インターフェイスとソース/宛先アドレスを送信/受信、2。ホップ制限3.次のホップアドレス、4。トラフィッククラス、5。ルーティングヘッダー、6。ホップバイホップオプションヘッダー、および7.宛先オプションヘッダー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First, to receive any of this optional information (other than the next hop address, which can only be set) on a UDP or raw socket, the application must call setsockopt() to turn on the corresponding flag:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
まず、UDPまたはRAWソケットでこのオプションの情報（設定できる次のホップアドレス以外）を受信するには、アプリケーションがSetSockopt（）を呼び出して対応するフラグをオンにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
int on = 1;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
int on = 1;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVPKTINFO,  &amp;on, sizeof(on));
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVHOPLIMIT, &amp;on, sizeof(on));
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVRTHDR,    &amp;on, sizeof(on));
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVHOPOPTS,  &amp;on, sizeof(on));
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVDSTOPTS,  &amp;on, sizeof(on));
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVTCLASS,   &amp;on, sizeof(on));
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When any of these options are enabled, the corresponding data is returned as control information by recvmsg(), as one or more ancillary data objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのオプションのいずれかが有効になっている場合、対応するデータは、1つ以上の補助データオブジェクトとして、Recvmsg（）による制御情報として返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document does not define how to receive the optional information on a TCP socket. See Section 4.1 for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、TCPソケットでオプションの情報を受信する方法を定義するものではありません。詳細については、セクション4.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two different mechanisms exist for sending this optional information:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオプションの情報を送信するための2つの異なるメカニズムが存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Using setsockopt to specify the option content for a socket. These are known &#34;sticky&#34; options since they affect all transmitted packets on the socket until either a new setsockopt is done or the options are overridden using ancillary data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. SetSockoptを使用して、ソケットのオプションコンテンツを指定します。これらは、新しいSetSockoptが完了するか、補助データを使用してオプションがオーバーライドされるまで、ソケット上のすべての送信パケットに影響を与えるため、「粘着性」オプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Using ancillary data to specify the option content for a single datagram. This only applies to datagram and raw sockets; not to TCP sockets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 補助データを使用して、単一のデータグラムのオプションコンテンツを指定します。これは、データグラムと生のソケットにのみ適用されます。TCPソケットではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The three socket option parameters and the three cmsghdr fields that describe the options/ancillary data objects are summarized as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプション/補助データオブジェクトを説明する3つのソケットオプションパラメーターと3つのCMSGHDRフィールドは、次のように要約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      opt level/    optname/          optval/
      cmsg_level    cmsg_type         cmsg_data[]
      ------------  ------------      ------------------------
      IPPROTO_IPV6  IPV6_PKTINFO      in6_pktinfo structure
      IPPROTO_IPV6  IPV6_HOPLIMIT     int
      IPPROTO_IPV6  IPV6_NEXTHOP      socket address structure
      IPPROTO_IPV6  IPV6_RTHDR        ip6_rthdr structure
      IPPROTO_IPV6  IPV6_HOPOPTS      ip6_hbh structure
      IPPROTO_IPV6  IPV6_DSTOPTS      ip6_dest structure
      IPPROTO_IPV6  IPV6_RTHDRDSTOPTS ip6_dest structure
      IPPROTO_IPV6  IPV6_TCLASS       int
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(Note: IPV6_HOPLIMIT can be used as ancillary data items only)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
（注：IPv6_hoplimitは、補助データ項目としてのみ使用できます）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All these options are described in detail in Section 6, 7, 8 and 9. All the constants beginning with IPV6_ are defined as a result of including &lt;netinet/in.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのすべてのオプションについては、セクション6、7、8、および9で詳しく説明します。IPv6_で始まるすべての定数は、&lt;netinet/in.h&gt;を含む結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: We intentionally use the same constant for the cmsg_level member as is used as the second argument to getsockopt() and setsockopt() (what is called the &#34;level&#34;), and the same constant for the cmsg_type member as is used as the third argument to getsockopt() and setsockopt() (what is called the &#34;option name&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：getsockopt（）およびsetsockopt（）（「レベル」と呼ばれるもの）の2番目の引数として使用されるCMSG_LEVELメンバーに対して同じ定数を意図的に使用し、CMSG_TYPEメンバーと同じ定数を使用して使用します。getsockopt（）およびsetsockopt（）（「オプション名」と呼ばれるもの）に対する3番目の議論。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Issuing getsockopt() for the above options will return the sticky option value i.e., the value set with setsockopt(). If no sticky option value has been set getsockopt() will return the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のオプションに対してgetSockopt（）を発行すると、粘着性のオプション値、つまりsetsockopt（）で設定された値が返されます。粘着性のオプション値が設定されていない場合、GetSockopt（）は次の値を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- For the IPV6_PKTINFO option, it will return an in6_pktinfo structure with ipi6_addr being in6addr_any and ipi6_ifindex being zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- IPv6_pktinfoオプションの場合、IPI6_ADDRがIN6ADDR_ANY、IPI6_ifindexがゼロであるIN6_PKTINFO構造を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- For the IPV6_TCLASS option, it will return the kernel default value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- IPv6_TClassオプションの場合、カーネルのデフォルト値を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- For other options, it will indicate the lack of the option value with optlen being zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 他のオプションでは、Optlenがゼロであるオプション値がないことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The application does not explicitly need to access the data structures for the Routing header, Hop-by-Hop options header, and Destination options header, since the API to these features is through a set of inet6_rth_XXX() and inet6_opt_XXX() functions that we define in Section 7 and Section 10. Those functions simplify the interface to these features instead of requiring the application to know the intimate details of the extension header formats.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの機能のAPIは、INET6_RTH_XXX（）およびINET6_OPT_XXX（）機能のセットを使用するため、アプリケーションはルーティングヘッダー、ホップバイホップオプションヘッダー、および宛先オプションヘッダーのデータ構造にアクセスする必要はありません。セクション7およびセクション10で定義します。これらの関数は、アプリケーションに拡張ヘッダー形式の親密な詳細を知ることを要求する代わりに、これらの機能へのインターフェイスを簡素化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When specifying extension headers, this API assumes the header ordering and the number of occurrences of each header as described in [RFC-2460]. More details about the ordering issue will be discussed in Section 12.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張ヘッダーを指定するとき、このAPIは、[RFC-2460]で説明されているように、各ヘッダーのヘッダー順序と発生数を想定します。注文問題の詳細については、セクション12で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--TCP-Implications">
4.1. TCP Implications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. TCPの意味
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is not possible to use ancillary data to transmit the above options for TCP since there is not a one-to-one mapping between send operations and the TCP segments being transmitted. Instead an application can use setsockopt to specify them as sticky options. When the application uses setsockopt to specify the above options it is expected that TCP will start using the new information when sending segments. However, TCP may or may not use the new information when retransmitting segments that were originally sent when the old sticky options were in effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信操作と送信されるTCPセグメントの間に1対1のマッピングがないため、TCPの上記のオプションを送信するために補助データを使用することはできません。代わりに、アプリケーションはSetSockoptを使用して、それらを粘着性のオプションとして指定できます。アプリケーションがSetSockoptを使用して上記のオプションを指定する場合、TCPはセグメントを送信するときに新しい情報の使用を開始することが予想されます。ただし、TCPは、古い粘着性のオプションが有効になっているときに元々送信されたセグメントを再送信するときに、新しい情報を使用する場合と使用できない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is unclear how a TCP application can use received information (such as extension headers) due to the lack of mapping between received TCP segments and receive operations. In particular, the received information could not be used for access control purposes like on UDP and raw sockets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信したTCPセグメント間のマッピングがないため、TCPアプリケーションが受信情報（拡張ヘッダーなど）をどのように使用できるかは不明です。特に、受信した情報は、UDPや生のソケットなどのアクセス制御目的で使用できませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification therefore does not define how to get the received information on TCP sockets. The result of the IPV6_RECVxxx options on a TCP socket is undefined as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、この仕様では、TCPソケットで受信した情報を取得する方法を定義するものではありません。TCPソケットのIPv6_Recvxxxオプションの結果も定義されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2--UDP-and-Raw-Socket-Implications">
4.2. UDP and Raw Socket Implications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. UDPおよび生のソケットへの影響
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The receive behavior for UDP and raw sockets is quite straightforward. After the application has enabled an IPV6_RECVxxx socket option it will receive ancillary data items for every recvmsg() call containing the requested information. However, if the information is not present in the packet the ancillary data item will not be included. For example, if the application enables IPV6_RECVRTHDR and a received datagram does not contain a Routing header there will not be an IPV6_RTHDR ancillary data item. Note that due to buffering in the socket implementation there might be some packets queued when an IPV6_RECVxxx option is enabled and they might not have the ancillary data information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPと生のソケットの受信動作は非常に簡単です。アプリケーションがIPv6_Recvxxxソケットオプションを有効にした後、要求された情報を含むすべてのRecvmsg（）コールの補助データ項目を受け取ります。ただし、情報がパケットに存在しない場合、補助データ項目は含まれません。たとえば、アプリケーションがIPv6_recvrthdrを有効にし、受信したデータグラムにはルーティングヘッダーが含まれていない場合、IPv6_rthdrの補助データ項目はありません。ソケットの実装でのバッファリングにより、IPv6_Recvxxxオプションが有効になっている場合、補助的なデータ情報がない場合に、いくつかのパケットがキューになっている可能性があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For sending the application has the choice between using sticky options and ancillary data. The application can also use both having the sticky options specify the &#34;default&#34; and using ancillary data to override the default options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションを送信するには、粘着性のオプションを使用するか、補助データを使用するかを選択できます。また、アプリケーションでは、粘着性のオプションが「デフォルト」を指定することと、補助データを使用してデフォルトオプションをオーバーライドすることの両方を使用することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an ancillary data item is specified in a call to sendmsg(), the item will override an existing sticky option of the same name (if previously specified). For example, if the application has set IPV6_RTHDR using a sticky option and later passes IPV6_RTHDR as ancillary data this will override the IPV6_RTHDR sticky option and the routing header of the outgoing packet will be from the ancillary data item, not from the sticky option. Note, however, that other sticky options than IPV6_RTHDR will not be affected by the IPV6_RTHDR ancillary data item; the overriding mechanism only works for the same type of sticky options and ancillary data items.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sendmsg（）への呼び出しで補助的なデータ項目が指定されている場合、アイテムは同じ名前の既存の粘着性オプションをオーバーライドします（以前に指定された場合）。たとえば、アプリケーションがStickyオプションを使用してIPv6_RTHDRを設定し、後にIPv6_RTHDRを補助データとして渡す場合、これによりIPv6_RTHDRスティッキーオプションがオーバーライドされ、発信パケットのルーティングヘッダーは、Stickyオプションからではなく、補助データ項目からです。ただし、IPv6_rthdr以外の粘着性のオプションは、IPv6_rthdrの補助データ項目の影響を受けないことに注意してください。オーバーライドメカニズムは、同じタイプの粘着性のオプションと補助データ項目に対してのみ機能します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: the overriding rule is different from the one in RFC 2292. In RFC 2292, an ancillary data item overrode all sticky options previously defined. This was reasonable, because sticky options could only be specified as a set by a single socket option. However, in this API, each option is separated so that it can be specified as a single sticky option. Additionally, there are much more ancillary data items and sticky options than in RFC 2292, including ancillary-only one. Thus, it should be natural for application programmers to separate the overriding rule as well.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：オーバーライドルールは、RFC 2292のルールとは異なります。RFC2292では、補助的なデータ項目が以前に定義されたすべての粘着性オプションを覆しました。これは合理的でした。これは、粘着オプションが単一のソケットオプションで設定されたものとしてのみ指定できるためです。ただし、このAPIでは、各オプションが単一の粘着性オプションとして指定できるように分離されています。さらに、補助のみを含むRFC 2292よりもはるかに多くの補助的なデータ項目と粘着オプションがあります。したがって、それはそうでなければなりません。アプリケーションプログラマーがオーバーライドルールを分離することも自然です。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An application can also temporarily disable a particular sticky option by specifying a corresponding ancillary data item that could disable the sticky option when being used as an argument for a socket option. For example, if the application has set IPV6_HOPOPTS as a sticky option and later passes IPV6_HOPOPTS with a zero length as an ancillary data item, the packet will not have a Hop-by-Hop options header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、ソケットオプションの引数として使用されるときに粘着性オプションを無効にできる対応する補助データ項目を指定することにより、特定の粘着性オプションを一時的に無効にすることもできます。たとえば、アプリケーションがIPv6_hopoptsを粘着性オプションとして設定し、後に補助データ項目としてゼロ長でIPv6_hopoptsを渡す場合、パケットにはホップバイホップオプションヘッダーがありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Extensions-to-Socket-Ancillary-Data">
5. Extensions to Socket Ancillary Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. ソケットの補助データへの拡張
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification uses ancillary data as defined in Posix with some compatible extensions, which are described in the following subsections. Section 20 will provide a detailed overview of ancillary data and related structures and macros, including the extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様では、以下のサブセクションで説明されているいくつかの互換性のある拡張機能を備えたPOSIXで定義されている補助データを使用します。セクション20では、補助データと関連する構造とマクロの詳細な概要を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1--CMSGNXTHDR">
5.1. CMSG_NXTHDR
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. CMSG_NXTHDR
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct cmsghdr *CMSG_NXTHDR(const struct msghdr *mhdr,
                                  const struct cmsghdr *cmsg);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSG_NXTHDR() returns a pointer to the cmsghdr structure describing the next ancillary data object. Mhdr is a pointer to a msghdr structure and cmsg is a pointer to a cmsghdr structure. If there is not another ancillary data object, the return value is NULL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSG_NXTHDR（）次の補助データオブジェクトを記述するCMSGHDR構造へのポインターを返します。MHDRはMSGHDR構造へのポインターであり、CMSGはCMSGHDR構造へのポインターです。別の補助データオブジェクトがない場合、返品値はnullです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following behavior of this macro is new to this API: if the value of the cmsg pointer is NULL, a pointer to the cmsghdr structure describing the first ancillary data object is returned. That is, CMSG_NXTHDR(mhdr, NULL) is equivalent to CMSG_FIRSTHDR(mhdr). If there are no ancillary data objects, the return value is NULL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このマクロの次の動作は、このAPIの新しいものです。CMSGポインターの値がnullの場合、最初の補助データオブジェクトを記述するCMSGHDR構造へのポインターが返されます。つまり、CMSG_NXTHDR（MHDR、NULL）はCMSG_FIRSTHDR（MHDR）と同等です。補助的なデータオブジェクトがない場合、返品値はnullです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2--CMSGSPACE">
5.2. CMSG_SPACE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. CMSG_SPACE
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
socklen_t CMSG_SPACE(socklen_t length);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
socklen_t cmsg_space（socklen_t length）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This macro is new with this API. Given the length of an ancillary data object, CMSG_SPACE() returns an upper bound on the space required by the object and its cmsghdr structure, including any padding needed to satisfy alignment requirements. This macro can be used, for example, when allocating space dynamically for the ancillary data. This macro should not be used to initialize the cmsg_len member of a cmsghdr structure; instead use the CMSG_LEN() macro.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このマクロはこのAPIで新しくなっています。補助データオブジェクトの長さを考えると、CMSG_SPACE（）は、アライメント要件を満たすために必要なパディングを含む、オブジェクトとそのCMSGHDR構造に必要なスペースの上限を返します。このマクロは、たとえば、補助データに空間を動的に割り当てるときに使用できます。このマクロは、CMSGHDR構造のCMSG_LENメンバーを初期化するために使用しないでください。代わりに、cmsg_len（）マクロを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-3--CMSGLEN">
5.3. CMSG_LEN
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. cmsg_len
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
socklen_t CMSG_LEN(socklen_t length);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
socklen_t cmsg_len（socklen_t length）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This macro is new with this API. Given the length of an ancillary data object, CMSG_LEN() returns the value to store in the cmsg_len member of the cmsghdr structure, taking into account any padding needed to satisfy alignment requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このマクロはこのAPIで新しくなっています。補助データオブジェクトの長さを考えると、CMSG_LEN（）は、アライメント要件を満たすために必要なパディングを考慮して、CMSGHDR構造のCMSG_LENメンバーに保存する値を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note the difference between CMSG_SPACE() and CMSG_LEN(), shown also in the figure in Section 20.2: the former accounts for any required padding at the end of the ancillary data object and the latter is the actual length to store in the cmsg_len member of the ancillary data object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション20.2の図にも示されているcmsg_space（）とcmsg_len（）の違いに注意してください。補助データオブジェクトの端にある必要なパディングの前の説明と後者は、CMSG_LENメンバーの実際の長さであることです。補助データオブジェクト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Packet-Information">
6. Packet Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. パケット情報
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are five pieces of information that an application can specify for an outgoing packet using ancillary data:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
補助データを使用して、出て行くパケットにアプリケーションが指定できる5つの情報があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. the source IPv6 address, 2. the outgoing interface index, 3. the outgoing hop limit, 4. the next hop address, and 5. the outgoing traffic class value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. ソースIPv6アドレス、2。発信インターフェイスインデックス、3。発信ホップ制限、4。次のホップアドレス、5。発信トラフィッククラス値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Four similar pieces of information can be returned for a received packet as ancillary data:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信したパケットの場合、4つの同様の情報を補助データとして返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. the destination IPv6 address, 2. the arriving interface index, 3. the arriving hop limit, and 4. the arriving traffic class value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. 宛先IPv6アドレス、2。到着インターフェイスインデックス、3。到着ホップ制限、および4.到着するトラフィッククラス値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first two pieces of information are contained in an in6_pktinfo structure that is set with setsockopt() or sent as ancillary data with sendmsg() and received as ancillary data with recvmsg(). This structure is defined as a result of including &lt;netinet/in.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の2つの情報は、setsockopt（）で設定されたIN6_PKTINFO構造に含まれているか、sendmsg（）で補助データとして送信され、recvmsg（）で補助データとして受信されます。この構造は、&lt;netinet/in.h&gt;を含めた結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct in6_pktinfo {
        struct in6_addr ipi6_addr;    /* src/dst IPv6 address */
        unsigned int    ipi6_ifindex; /* send/recv interface index */
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the socket option and cmsghdr level will be IPPROTO_IPV6, the type will be IPV6_PKTINFO, and the first byte of the option value and cmsg_data[] will be the first byte of the in6_pktinfo structure. An application can clear any sticky IPV6_PKTINFO option by doing a
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソケットオプションとCMSGHDRレベルはIPPROTO_IPV6であり、タイプはIPv6_pktinfoであり、オプション値の最初のバイトとCMSG_DATA []はIN6_PKTINFO構造の最初のバイトになります。アプリケーションは、粘着性のあるipv6_pktinfoオプションを実行することでクリアできます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;regular&#34; setsockopt with ipi6_addr being in6addr_any and ipi6_ifindex being zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPI6_ADDRがIN6ADDR_ANYであり、IPI6_IFINDEXがゼロである「通常の」SetSockopt。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This information is returned as ancillary data by recvmsg() only if the application has enabled the IPV6_RECVPKTINFO socket option:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この情報は、アプリケーションがIPv6_Recvpktinfoソケットオプションを有効にした場合にのみ、recvmsg（）によって補助データとして返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int  on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVPKTINFO, &amp;on, sizeof(on));
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: The hop limit is not contained in the in6_pktinfo structure for the following reason. Some UDP servers want to respond to client requests by sending their reply out the same interface on which the request was received and with the source IPv6 address of the reply equal to the destination IPv6 address of the request. To do this the application can enable just the IPV6_RECVPKTINFO socket option and then use the received control information from recvmsg() as the outgoing control information for sendmsg(). The application need not examine or modify the in6_pktinfo structure at all. But if the hop limit were contained in this structure, the application would have to parse the received control information and change the hop limit member, since the received hop limit is not the desired value for an outgoing packet.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：ホップ制限は、次の理由でIN6_PKTINFO構造に含まれていません。一部のUDPサーバーは、リクエストが受信されたのと同じインターフェイスを送信して、返信のソースIPv6アドレスを使用して、返信を送信してクライアント要求に応答したいと考えています。リクエストの宛先IPv6アドレスに等しい。これを行うには、アプリケーションがIPv6_recvpktinfoソケットオプションのみを有効にすることができ、recvmsg（）の受信制御情報をsendmsg（）の発信制御情報として使用できます。IN6_PKTINFO構造。しかし、この構造にホップ制限が含まれている場合、受信したホップ制限は発信パケットの望ましい値ではないため、受信した制御情報を解析してホップ制限メンバーを変更する必要があります。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-1--SpecifyingReceiving-the-Interface">
6.1. Specifying/Receiving the Interface
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. インターフェイスの指定/受信
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Interfaces on an IPv6 node are identified by a small positive integer, as described in Section 4 of [RFC-3493]. That document also describes a function to map an interface name to its interface index, a function to map an interface index to its interface name, and a function to return all the interface names and indexes. Notice from this document that no interface is ever assigned an index of 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6ノード上のインターフェイスは、[RFC-3493]のセクション4で説明されているように、小さな正の整数によって識別されます。このドキュメントでは、インターフェイス名をインターフェイスインデックスにマッピングする関数、インターフェイスインデックスをインターフェイス名にマッピングする関数、およびすべてのインターフェイス名とインデックスを返す関数についても説明します。このドキュメントから、インターフェイスが0のインデックスが割り当てられていないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When specifying the outgoing interface, if the ipi6_ifindex value is 0, the kernel will choose the outgoing interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
発信インターフェイスを指定する場合、IPI6_ifindex値が0の場合、カーネルは発信インターフェイスを選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ordering among various options that can specify the outgoing interface, including IPV6_PKTINFO, is defined in Section 6.7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6_pktinfoを含む発信インターフェイスを指定できるさまざまなオプションの順序付けは、セクション6.7で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the IPV6_RECVPKTINFO socket option is enabled, the received interface index is always returned as the ipi6_ifindex member of the in6_pktinfo structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6_Recvpktinfoソケットオプションが有効になっている場合、受信されたインターフェイスインデックスは、IN6_PKTINFO構造のIPI6_IFINDEXメンバーとして常に返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2--SpecifyingReceiving-SourceDestination-Address">
6.2. Specifying/Receiving Source/Destination Address
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. ソース/宛先アドレスの指定/受信
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The source IPv6 address can be specified by calling bind() before each output operation, but supplying the source address together with the data requires less overhead (i.e., fewer system calls) and requires less state to be stored and protected in a multithreaded application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースIPv6アドレスは、各出力操作の前にbind（）を呼び出すことで指定できますが、ソースアドレスをデータと一緒に供給するには、より少ないオーバーヘッド（つまり、システム呼び出しが少なくなります）が必要であり、マルチスレッドアプリケーションで保存および保護される必要が少なくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When specifying the source IPv6 address as ancillary data, if the ipi6_addr member of the in6_pktinfo structure is the unspecified address (IN6ADDR_ANY_INIT or in6addr_any), then (a) if an address is currently bound to the socket, it is used as the source address, or (b) if no address is currently bound to the socket, the kernel will choose the source address. If the ipi6_addr member is not the unspecified address, but the socket has already bound a source address, then the ipi6_addr value overrides the already-bound source address for this output operation only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースIPv6アドレスを補助データとして指定する場合、IN6_PKTINFO構造のIPI6_ADDRメンバーが不特定のアドレス（IN6ADDR_ANY_INITまたはIN6ADDR_ANY）である場合、（a）アドレスが現在ソケットにバインドされている場合、ソースアドレスとして使用されます。または（b）現在ソケットにアドレスがバインドされていない場合、カーネルはソースアドレスを選択します。IPI6_ADDRメンバーが不特定のアドレスではないが、ソケットがすでにソースアドレスをバインドしている場合、IPI6_ADDR値は、この出力操作のみの既にバインドされたソースアドレスをオーバーライドします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The kernel must verify that the requested source address is indeed a unicast address assigned to the node. When the address is a scoped one, there may be ambiguity about its scope zone. This is particularly the case for link-local addresses. In such a case, the kernel must first determine the appropriate scope zone based on the zone of the destination address or the outgoing interface (if known), then qualify the address. This also means that it is not feasible to specify the source address for a non-binding socket by the IPV6_PKTINFO sticky option, unless the outgoing interface is also specified. The application should simply use bind() for such purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
カーネルは、要求されたソースアドレスが実際にノードに割り当てられたユニキャストアドレスであることを確認する必要があります。アドレスがスコープされたものである場合、そのスコープゾーンには曖昧さがあるかもしれません。これは、特にLink-Localアドレスの場合です。そのような場合、カーネルは、最初に宛先アドレスのゾーンまたは発信インターフェイス（既知の場合）に基づいて適切なスコープゾーンを決定する必要があります。これはまた、発信インターフェイスも指定されていない限り、IPv6_pktinfoスティッキーオプションによって、非バインディングソケットのソースアドレスを指定することが不可能であることを意味します。アプリケーションは、そのような目的でBind（）を単に使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPV6_PKTINFO can also be used as a sticky option for specifying the socket&#39;s default source address. However, the ipi6_addr member must be the unspecified address for TCP sockets, because it is not possible to dynamically change the source address of a TCP connection. When the IPV6_PKTINFO option is specified for a TCP socket with a non-unspecified address, the call will fail. This restriction should be applied even before the socket binds a specific address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6_pktinfoは、ソケットのデフォルトのソースアドレスを指定するための粘着性オプションとしても使用できます。ただし、TCP接続のソースアドレスを動的に変更することはできないため、IPI6_ADDRメンバーはTCPソケットの不特定のアドレスである必要があります。IPv6_pktinfoオプションが、非指定されていないアドレスを備えたTCPソケットに指定されている場合、通話は失敗します。この制限は、ソケットが特定のアドレスにバインドする前であっても適用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the in6_pktinfo structure is returned as ancillary data by recvmsg(), the ipi6_addr member contains the destination IPv6 address from the received packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
in6_pktinfo構造がrecvmsg（）によって補助データとして返される場合、IPI6_ADDRメンバーには受信パケットの宛先IPv6アドレスが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-3--SpecifyingReceiving-the-Hop-Limit">
6.3. Specifying/Receiving the Hop Limit
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. ホップ制限の指定/受信
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The outgoing hop limit is normally specified with either the IPV6_UNICAST_HOPS socket option or the IPV6_MULTICAST_HOPS socket option, both of which are described in [RFC-3493]. Specifying the hop limit as ancillary data lets the application override either the kernel&#39;s default or a previously specified value, for either a unicast destination or a multicast destination, for a single output operation. Returning the received hop limit is useful for IPv6 applications that need to verify that the received hop limit is 255 (e.g., that the packet has not been forwarded).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
発信ホップ制限は、通常、IPv6_unicast_hopsソケットオプションまたはIPv6_multicast_hopsソケットオプションのいずれかで指定されます。どちらも[RFC-3493]で説明されています。ホップ制限を補助データとして指定すると、アプリケーションは、ユニキャスト宛先またはマルチキャスト宛先のいずれかのカーネルのデフォルトまたは以前に指定された値のいずれかを、単一の出力操作にオーバーライドできます。受信したホップ制限を返すことは、受信したホップ制限が255であることを確認する必要があるIPv6アプリケーションに役立ちます（たとえば、パケットが転送されていないこと）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The received hop limit is returned as ancillary data by recvmsg() only if the application has enabled the IPV6_RECVHOPLIMIT socket option:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信したホップ制限は、アプリケーションがIPv6_Recvhoplimitソケットオプションを有効にした場合にのみ、recvmsg（）によって補助データとして返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int  on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVHOPLIMIT, &amp;on, sizeof(on));
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the cmsghdr structure containing this ancillary data, the cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be IPV6_HOPLIMIT, and the first byte of cmsg_data[] will be the first byte of the integer hop limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この補助データを含むCMSGHDR構造では、CMSG_LEVELメンバーはIPPROTO_IPV6であり、CMSG_TYPEメンバーはIPv6_hoplimitであり、CMSG_DATA []の最初のバイトは整数ホップ制限の最初のバイトになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nothing special need be done to specify the outgoing hop limit: just specify the control information as ancillary data for sendmsg(). As specified in [RFC-3493], the interpretation of the integer hop limit value is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
発信ホップ制限を指定するために特別なことは何もありません。SendMSG（）の補助データとして制御情報を指定するだけです。[RFC-3493]で指定されているように、整数ホップ制限値の解釈は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      x &lt; -1:        return an error of EINVAL
      x == -1:       use kernel default
      0 &lt;= x &lt;= 255: use x
      x &gt;= 256:      return an error of EINVAL
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This API defines IPV6_HOPLIMIT as an ancillary-only option, that is, the option name cannot be used as a socket option. This is because [RFC-3493] has more fine-grained socket options; IPV6_UNICAST_HOPS and IPV6_MULTICAST_HOPS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このAPIは、IPv6_hoplimitを補助のみのオプションとして定義します。つまり、オプション名はソケットオプションとして使用できません。これは、[RFC-3493]にはより細かいソケットオプションがあるためです。ipv6_unicast_hopsおよびipv6_multicast_hops。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-4--Specifying-the-Next-Hop-Address">
6.4. Specifying the Next Hop Address
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. 次のホップアドレスを指定します
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IPV6_NEXTHOP ancillary data object specifies the next hop for the datagram as a socket address structure. In the cmsghdr structure containing this ancillary data, the cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be IPV6_NEXTHOP, and the first byte of cmsg_data[] will be the first byte of the socket address structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6_Nexthop Ancillary Dataオブジェクトは、ソケットアドレス構造としてデータグラムの次のホップを指定します。この補助データを含むCMSGHDR構造では、CMSG_LEVELメンバーはIPPROTO_IPV6であり、CMSG_TYPEメンバーはIPv6_Nexthopであり、CMSG_DATA []の最初のバイトはソケットアドレス構造の最初のバイトになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is a privileged option. (Note: It is implementation defined and beyond the scope of this document to define what &#34;privileged&#34; means. Unix systems use this term to mean the process must have an effective user ID of 0.) This API only defines the case where the socket address contains an IPv6 address (i.e., the sa_family member is AF_INET6). And, in this case, the node identified by that address must be a neighbor of the sending host. If that address equals the destination IPv6 address of the datagram, then this is equivalent to the existing SO_DONTROUTE socket option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは特権的なオプションです。（注：「特権」の意味を定義するために、このドキュメントの範囲を超えて定義されている実装です。UNIXシステムは、この用語を使用して、効果的なユーザーIDを持つ必要があることを意味しますアドレスにはIPv6アドレスが含まれています（つまり、SA_FamilyメンバーはAF_INET6です）。そして、この場合、そのアドレスによって識別されたノードは、送信ホストの隣人でなければなりません。そのアドレスがデータグラムの宛先IPv6アドレスに等しい場合、これは既存のSO_DONTROUTEソケットオプションに相当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This option does not have any meaning for multicast destinations. In such a case, the specified next hop will be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオプションには、マルチキャストの目的地には意味がありません。そのような場合、指定された次のホップは無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the outgoing interface is specified by IPV6_PKTINFO as well, the next hop specified by this option must be reachable via the specified interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
発信インターフェイスがIPv6_pktinfoによっても指定されている場合、このオプションで指定された次のホップは、指定されたインターフェイスを介して到達可能でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to clear a sticky IPV6_NEXTHOP option the application must issue a setsockopt for IPV6_NEXTHOP with a zero length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sticky IPv6_Nexthopオプションをクリアするには、アプリケーションはゼロの長さのIPv6_NexthopのSetSockoptを発行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-5--SpecifyingReceiving-the-Traffic-Class-value">
6.5. Specifying/Receiving the Traffic Class value
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5. トラフィッククラスの値の指定/受信
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The outgoing traffic class is normally set to 0. Specifying the traffic class as ancillary data lets the application override either the kernel&#39;s default or a previously specified value, for either a unicast destination or a multicast destination, for a single output operation. Returning the received traffic class is useful for programs such as a diffserv debugging tool and for user level ECN (explicit congestion notification) implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
発信トラフィッククラスは通常0に設定されています。トラフィッククラスを補助データとして指定すると、アプリケーションは、ユニキャスト宛先またはマルチキャストの宛先のいずれかについて、カーネルのデフォルトまたは以前に指定された値のいずれかを単一の出力操作にオーバーライドできます。受信したトラフィッククラスを返すことは、DiffServデバッグツールなどのプログラムや、ユーザーレベルのECN（明示的な混雑通知）の実装に役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The received traffic class is returned as ancillary data by recvmsg() only if the application has enabled the IPV6_RECVTCLASS socket option:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信したトラフィッククラスは、アプリケーションがIPv6_RecvtClassソケットオプションを有効にした場合にのみ、recvmsg（）によって補助データとして返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int  on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVTCLASS, &amp;on, sizeof(on));
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the cmsghdr structure containing this ancillary data, the cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be IPV6_TCLASS, and the first byte of cmsg_data[] will be the first byte of the integer traffic class.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この補助データを含むCMSGHDR構造では、CMSG_LEVELメンバーはIPPROTO_IPV6であり、CMSG_TYPEメンバーはIPv6_TCLASSであり、CMSG_DATA []の最初のバイトは整数トラフィッククラスの最初のバイトになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To specify the outgoing traffic class value, just specify the control information as ancillary data for sendmsg() or using setsockopt(). Just like the hop limit value, the interpretation of the integer traffic class value is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
発信トラフィッククラスの値を指定するには、制御情報をsendmsg（）の補助データとして指定するか、setsockopt（）を使用してください。ホップ制限値と同じように、整数トラフィッククラス値の解釈は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      x &lt; -1:        return an error of EINVAL
      x == -1:       use kernel default
      0 &lt;= x &lt;= 255: use x
      x &gt;= 256:      return an error of EINVAL
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to clear a sticky IPV6_TCLASS option the application can specify -1 as the value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
粘着性のあるIPv6_TCLASSオプションをクリアするために、アプリケーションは-1を値として指定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are cases where the kernel needs to control the traffic class value and conflicts with the user-specified value on the outgoing traffic. An example is an implementation of ECN in the kernel, setting 2 bits of the traffic class value. In such cases, the kernel should override the user-specified value. On the incoming traffic, the kernel may mask some of the bits in the traffic class field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
カーネルがトラフィッククラスの値を制御し、発信トラフィックのユーザー指定値と競合する必要がある場合があります。例は、カーネルでのECNの実装であり、トラフィッククラス値の2ビットを設定します。そのような場合、カーネルはユーザー指定値をオーバーライドする必要があります。着信トラフィックでは、カーネルはトラフィッククラスフィールドの一部のビットをマスクする場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-6--Additional-Errors-with-sendmsg-and-setsockopt">
6.6. Additional Errors with sendmsg() and setsockopt()
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6. sendmsg（）およびsetSockopt（）を使用した追加のエラー
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the IPV6_PKTINFO socket option there are no additional errors possible with the call to recvmsg(). But when specifying the outgoing interface or the source address, additional errors are possible from sendmsg() or setsockopt(). Note that some implementations might only be able to return this type of errors for setsockopt(). The following are examples, but some of these may not be provided by some implementations, and some implementations may define additional errors:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6_pktinfoソケットオプションを使用すると、Recvmsg（）への呼び出しで追加のエラーはありません。ただし、発信インターフェイスまたはソースアドレスを指定する場合、sendmsg（）またはsetsockopt（）から追加のエラーが可能です。いくつかの実装は、setSockopt（）のこのタイプのエラーのみを返すことができる場合があることに注意してください。以下は例ですが、これらのいくつかはいくつかの実装によって提供されない場合があり、いくつかの実装では追加のエラーを定義する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ENXIO The interface specified by ipi6_ifindex does not exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
enxio ipi6_ifindexによって指定されたインターフェイスは存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ENETDOWN The interface specified by ipi6_ifindex is not enabled for IPv6 use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ENETDOWN IPI6_IFINDEXで指定されたインターフェイスは、IPv6の使用には有効になっていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EADDRNOTAVAIL ipi6_ifindex specifies an interface but the address ipi6_addr is not available for use on that interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
eaddrnotavail ipi6_ifindexインターフェイスを指定しますが、アドレスIPI6_addrはそのインターフェイスで使用できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EHOSTUNREACH No route to the destination exists over the interface specified by ipi6_ifindex.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ehostunReach IPI6_IFINDEXで指定されたインターフェイス上に宛先へのルートはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-7--Summary-of-Outgoing-Interface-Selection">
6.7. Summary of Outgoing Interface Selection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.7. 発信インターフェイス選択の概要
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and [RFC-3493] specify various methods that affect the selection of the packet&#39;s outgoing interface. This subsection summarizes the ordering among those in order to ensure deterministic behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントと[RFC-3493]は、パケットの発信インターフェイスの選択に影響するさまざまな方法を指定します。このサブセクションは、決定論的な行動を確保するために、それらの間の順序を要約しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a given outgoing packet on a given socket, the outgoing interface is determined in the following order:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のソケットの特定の発信パケットの場合、発信インターフェイスは次の順序で決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. if an interface is specified in an IPV6_PKTINFO ancillary data item, the interface is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. IPv6_pktinfo補助データ項目でインターフェイスが指定されている場合、インターフェイスが使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. otherwise, if an interface is specified in an IPV6_PKTINFO sticky option, the interface is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. それ以外の場合、IPv6_pktinfo Stickyオプションでインターフェイスが指定されている場合、インターフェイスが使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. otherwise, if the destination address is a multicast address and the IPV6_MULTICAST_IF socket option is specified for the socket, the interface is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. それ以外の場合、宛先アドレスがマルチキャストアドレスであり、IPv6_multicast_ifソケットオプションがソケットに指定されている場合、インターフェイスが使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. otherwise, if an IPV6_NEXTHOP ancillary data item is specified, the interface to the next hop is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. それ以外の場合、IPv6_nexthopの補助データ項目が指定されている場合、次のホップへのインターフェイスが使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. otherwise, if an IPV6_NEXTHOP sticky option is specified, the interface to the next hop is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. それ以外の場合、IPv6_Nexthop Stickyオプションが指定されている場合、次のホップへのインターフェイスが使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. otherwise, the outgoing interface should be determined in an implementation dependent manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. それ以外の場合、発信インターフェイスは、実装依存の方法で決定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ordering above particularly means if the application specifies an interface by the IPV6_MULTICAST_IF socket option (described in [RFC-3493]) as well as specifying a different interface by the IPV6_PKTINFO sticky option, the latter will override the former for every multicast packet on the corresponding socket. The reason for the ordering comes from expectation that the source address is specified as well and that the pair of the address and the outgoing interface should be preferred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の順序は、特にアプリケーションがIPv6_multicast_ifソケットオプション（[RFC-3493]で説明）によってインターフェイスを指定し、IPv6_pktinfoのスティッキーオプションによって異なるインターフェイスを指定する場合、後者は前者をオーバーライドします。対応するソケット。注文の理由は、ソースアドレスも指定されており、アドレスのペアと発信インターフェイスを優先することを期待することに起因しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In any case, the kernel must also verify that the source and destination addresses do not break their scope zones with regard to the outgoing interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いずれにせよ、カーネルは、ソースと宛先アドレスが発信インターフェイスに関してスコープゾーンを破らないことを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Routing-Header-Option">
7. Routing Header Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. ルーティングヘッダーオプション
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Source routing in IPv6 is accomplished by specifying a Routing header as an extension header. There can be different types of Routing headers, but IPv6 currently defines only the Type 0 Routing header [RFC-2460]. This type supports up to 127 intermediate nodes (limited by the length field in the extension header). With this maximum number of intermediate nodes, a source, and a destination, there are 128 hops.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6のソースルーティングは、ルーティングヘッダーを拡張ヘッダーとして指定することにより達成されます。ルーティングヘッダーにはさまざまな種類がありますが、IPv6は現在、タイプ0ルーティングヘッダー[RFC-2460]のみを定義しています。このタイプは、最大127個の中間ノードをサポートします（拡張ヘッダーの長さフィールドによって制限されます）。この最大数の中間ノード、ソース、および宛先には、128ホップがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Source routing with the IPv4 sockets API (the IP_OPTIONS socket option) requires the application to build the source route in the format that appears as the IPv4 header option, requiring intimate knowledge of the IPv4 options format. This IPv6 API, however, defines six functions that the application calls to build and examine a Routing header, and the ability to use sticky options or ancillary data to communicate this information between the application and the kernel using the IPV6_RTHDR option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv4ソケットAPI（IP_OPTIONSソケットオプション）を使用したソースルーティングでは、IPv4ヘッダーオプションとして表示される形式でソースルートを構築するためにアプリケーションが必要であるため、IPv4オプション形式の詳細な知識が必要です。ただし、このIPv6 APIは、アプリケーションがルーティングヘッダーを構築および調査するために呼び出す6つの機能と、IPv6_RTHDRオプションを使用してアプリケーションとカーネル間でこの情報を通信するために粘着性オプションまたは補助データを使用する機能を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Three functions build a Routing header:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3つの関数はルーティングヘッダーを構築します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      inet6_rth_space()    - return #bytes required for Routing header
      inet6_rth_init()     - initialize buffer data for Routing header
      inet6_rth_add()      - add one IPv6 address to the Routing header
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Three functions deal with a returned Routing header:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3つの関数は、返されたルーティングヘッダーを扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      inet6_rth_reverse()  - reverse a Routing header
      inet6_rth_segments() - return #segments in a Routing header
      inet6_rth_getaddr()  - fetch one address from a Routing header
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The function prototypes for these functions are defined as a result of including &lt;netinet/in.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの関数の関数プロトタイプは、&lt;netinet/in.h&gt;を含める結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To receive a Routing header the application must enable the IPV6_RECVRTHDR socket option:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ルーティングヘッダーを受信するには、アプリケーションがIPv6_RecvrthDRソケットオプションを有効にする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int  on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVRTHDR, &amp;on, sizeof(on));
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each received Routing header is returned as one ancillary data object described by a cmsghdr structure with cmsg_type set to IPV6_RTHDR. When multiple Routing headers are received, multiple ancillary data objects (with cmsg_type set to IPV6_RTHDR) will be returned to the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信したルーティングヘッダーは、CMSG_TypeがIPv6_RTHDRに設定されたCMSGHDR構造によって記述された1つの補助データオブジェクトとして返されます。複数のルーティングヘッダーを受信すると、複数の補助データオブジェクト（CMSG_TypeがIPv6_RTHDRに設定されています）がアプリケーションに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To send a Routing header the application specifies it either as ancillary data in a call to sendmsg() or using setsockopt(). For the sending side, this API assumes the number of occurrences of the Routing header as described in [RFC-2460]. That is, applications can only specify at most one outgoing Routing header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ルーティングヘッダーを送信するには、アプリケーションはそれをsendmsg（）への呼び出しで補助データとして指定するか、setsockopt（）を使用します。送信側の場合、このAPIは[RFC-2460]で説明されているように、ルーティングヘッダーの発生数を想定しています。つまり、アプリケーションは最大で1つの発信ルーティングヘッダーのみを指定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The application can remove any sticky Routing header by calling setsockopt() for IPV6_RTHDR with a zero option length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、ゼロオプションの長さでIPv6_rthdrのSetSockopt（）を呼び出すことにより、粘着性のルーティングヘッダーを削除できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When using ancillary data a Routing header is passed between the application and the kernel as follows: The cmsg_level member has a value of IPPROTO_IPV6 and the cmsg_type member has a value of IPV6_RTHDR. The contents of the cmsg_data[] member is implementation dependent and should not be accessed directly by the application, but should be accessed using the six functions that we are about to describe.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
補助データを使用する場合、アプリケーションとカーネルの間に次のようにルーティングヘッダーが渡されます。CMSG_LEVELメンバーはIPPROTO_IPV6の値を持ち、CMSG_TYPEメンバーはIPv6_RTHDRの値を持っています。CMSG_DATA []メンバーの内容は実装依存であり、アプリケーションで直接アクセスする必要はありませんが、説明しようとしている6つの関数を使用してアクセスする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following constant is defined as a result of including the &lt;netinet/in.h&gt;:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の定数は、&lt;netinet/in.h&gt;を含める結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define IPV6_RTHDR_TYPE_0    0 /* IPv6 Routing header type 0 */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a Routing header is specified, the destination address specified for connect(), sendto(), or sendmsg() is the final destination address of the datagram. The Routing header then contains the addresses of all the intermediate nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ルーティングヘッダーが指定されている場合、connect（）、sendto（）、またはsendmsg（）に指定された宛先アドレスがデータグラムの最終宛先アドレスです。ルーティングヘッダーには、すべての中間ノードのアドレスが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-1--inet6rthspace">
7.1. inet6_rth_space
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. inet6_rth_space
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
socklen_t inet6_rth_space(int type, int segments);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
socklen_t inet6_rth_space（int type、int segments）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function returns the number of bytes required to hold a Routing header of the specified type containing the specified number of segments (addresses). For an IPv6 Type 0 Routing header, the number of segments must be between 0 and 127, inclusive. The return value is just the space for the Routing header. When the application uses ancillary data it must pass the returned length to CMSG_SPACE() to determine how much memory is needed for the ancillary data object (including the cmsghdr structure).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、指定されたセグメント数（アドレス）を含む指定されたタイプのルーティングヘッダーを保持するために必要なバイト数を返します。IPv6タイプ0ルーティングヘッダーの場合、セグメントの数は0〜127でなければなりません。返品値は、ルーティングヘッダーのスペースにすぎません。アプリケーションが補助データを使用する場合、返された長さをCMSG_SPACE（）に渡す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the return value is 0, then either the type of the Routing header is not supported by this implementation or the number of segments is invalid for this type of Routing header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
戻り値が0の場合、この実装によってルーティングヘッダーのタイプがサポートされていないか、このタイプのルーティングヘッダーに対してセグメントの数が無効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: This function returns the size but does not allocate the space required for the ancillary data. This allows an application to allocate a larger buffer, if other ancillary data objects are desired, since all the ancillary data objects must be specified to sendmsg() as a single msg_control buffer.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：この関数はサイズを返しますが、補助データに必要なスペースを割り当てません。これにより、他の補助データオブジェクトが必要な場合、すべての補助データオブジェクトをSENDMSGに指定する必要があるため、より大きなバッファーを割り当てることができます。）単一のMSG_CONTROLバッファとして。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-2--inet6rthinit">
7.2. inet6_rth_init
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. inet6_rth_init
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      void *inet6_rth_init(void *bp, socklen_t bp_len, int type,
                           int segments);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function initializes the buffer pointed to by bp to contain a Routing header of the specified type and sets ip6r_len based on the segments parameter. bp_len is only used to verify that the buffer is large enough. The ip6r_segleft field is set to zero; inet6_rth_add() will increment it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、指定されたバッファーを初期化して、指定されたタイプのルーティングヘッダーを含み、セグメントパラメーターに基づいてIP6R_LENを設定します。BP_LENは、バッファが十分に大きいことを確認するためにのみ使用されます。IP6R_SEGLEFTフィールドはゼロに設定されています。inet6_rth_add（）はそれを増やします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the application uses ancillary data the application must initialize any cmsghdr fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションが補助データを使用する場合、アプリケーションはCMSGHDRフィールドを初期化する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The caller must allocate the buffer and its size can be determined by calling inet6_rth_space().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
発信者はバッファーを割り当てる必要があり、そのサイズはINET6_RTH_SPACE（）を呼び出すことで決定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon success the return value is the pointer to the buffer (bp), and this is then used as the first argument to the inet6_rth_add() function. Upon an error the return value is NULL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、戻り値はバッファー（BP）へのポインターであり、これはINET6_RTH_ADD（）関数の最初の引数として使用されます。エラーが発生すると、返品値はnullです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-3--inet6rthadd">
7.3. inet6_rth_add
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. inet6_rth_add
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int inet6_rth_add(void *bp, const struct in6_addr *addr);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function adds the IPv6 address pointed to by addr to the end of the Routing header being constructed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、構築されているルーティングヘッダーの最後にADDRによって指されたIPv6アドレスを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If successful, the segleft member of the Routing Header is updated to account for the new address in the Routing header and the return value of the function is 0. Upon an error the return value of the function is -1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功した場合、ルーティングヘッダーのsegleftメンバーが更新され、ルーティングヘッダーの新しいアドレスが考慮され、関数の戻り値は0です。エラー上、関数の返品値は-1です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-4--inet6rthreverse">
7.4. inet6_rth_reverse
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. inet6_rth_reverse
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int inet6_rth_reverse(const void *in, void *out);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function takes a Routing header extension header (pointed to by the first argument) and writes a new Routing header that sends datagrams along the reverse of that route. The function reverses the order of the addresses and sets the segleft member in the new Routing header to the number of segments. Both arguments are allowed to point to the same buffer (that is, the reversal can occur in place).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、ルーティングヘッダーエクステンションヘッダー（最初の引数で指された）を取り、そのルートの裏側に沿ってデータグラムを送信する新しいルーティングヘッダーを書き込みます。この関数は、アドレスの順序を逆転させ、新しいルーティングヘッダーにSegleftメンバーをセグメントの数に設定します。どちらの引数も同じバッファーを指すことが許可されています（つまり、逆転が所定の位置に発生する可能性があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The return value of the function is 0 on success, or -1 upon an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関数の返品値は成功した場合は0、エラー時に-1です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-5--inet6rthsegments">
7.5. inet6_rth_segments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5. inet6_rth_segments
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int inet6_rth_segments(const void *bp);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function returns the number of segments (addresses) contained in the Routing header described by bp. On success the return value is zero or greater. The return value of the function is -1 upon an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、BPで記述されたルーティングヘッダーに含まれるセグメントの数（アドレス）の数を返します。成功すると、返品値はゼロ以上です。関数の返品値は、エラー時に-1です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-6--inet6rthgetaddr">
7.6. inet6_rth_getaddr
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6. inet6_rth_getaddr
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct in6_addr *inet6_rth_getaddr(const void *bp, int index);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function returns a pointer to the IPv6 address specified by index (which must have a value between 0 and one less than the value returned by inet6_rth_segments()) in the Routing header described by bp. An application should first call inet6_rth_segments() to obtain the number of segments in the Routing header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、インデックスで指定されたIPv6アドレスへのポインターを返します（BPが記述されたルーティングヘッダーで、INET6_RTH_SEGMENTS（）によって返される値より0〜1個の値が必要です）。アプリケーションは、最初にinet6_rth_segments（）を呼び出して、ルーティングヘッダーのセグメントの数を取得する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon an error the return value of the function is NULL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー時に、関数の返品値はnullです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--Hop-By-Hop-Options">
8. Hop-By-Hop Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. ホップバイホップオプション
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A variable number of Hop-by-Hop options can appear in a single Hop-by-Hop options header. Each option in the header is TLV-encoded with a type, length, and value. This IPv6 API defines seven functions that the application calls to build and examine a Hop-by_Hop options header, and the ability to use sticky options or ancillary data to communicate this information between the application and the kernel. This uses the IPV6_HOPOPTS for a Hop-by-Hop options header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さまざまな数のホップバイホップオプションが、単一のホップバイホップオプションヘッダーに表示されます。ヘッダー内の各オプションは、タイプ、長さ、および値でTLVエンコードされています。このIPv6 APIは、アプリケーションがホップ-by_hopオプションヘッダーを構築および調査するために呼び出す7つの関数と、粘着性オプションまたは補助データを使用してアプリケーションとカーネルの間でこの情報を通知する機能を定義します。これは、ホップバイホップオプションヘッダーにIPv6_hopoptsを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Today several Hop-by-Hop options are defined for IPv6. Two pad options, Pad1 and PadN, are for alignment purposes and are automatically inserted by the inet6_opt_XXX() routines and ignored by the inet6_opt_XXX() routines on the receive side. This section of the API is therefore defined for other (and future) Hop-by-Hop options that an application may need to specify and receive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
今日、IPv6に対していくつかのホップバイホップオプションが定義されています。2つのパッドオプション、PAD1とPADNはアライメント目的であり、INET6_OPT_XXX（）ルーチンによって自動的に挿入され、受信側のINET6_OPT_XXX（）ルーチンによって無視されます。したがって、APIのこのセクションは、アプリケーションが指定および受信する必要がある他の（および将来の）ホップバイホップオプションに対して定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Four functions build an options header:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4つの関数はオプションヘッダーを作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      inet6_opt_init()     - initialize buffer data for options header
      inet6_opt_append()   - add one TLV option to the options header
      inet6_opt_finish()   - finish adding TLV options to the options
                             header
      inet6_opt_set_val()  - add one component of the option content to
                             the option
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Three functions deal with a returned options header:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3つの関数は、返されたオプションヘッダーを扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
inet6_opt_next() - extract the next option from the options header inet6_opt_find() - extract an option of a specified type from the header inet6_opt_get_val() - retrieve one component of the option content
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
inet6_opt_next（） - オプションヘッダーinet6_opt_find（）から次のオプションを抽出 - ヘッダーinet6_opt_get_val（）から指定されたタイプのオプションを抽出 - オプションコンテンツの1つのコンポーネントを取得します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Individual Hop-by-Hop options (and Destination options, which are described in Section 9 and are very similar to the Hop-by-Hop options) may have specific alignment requirements. For example, the 4-byte Jumbo Payload length should appear on a 4-byte boundary, and IPv6 addresses are normally aligned on an 8-byte boundary. These requirements and the terminology used with these options are discussed in Section 4.2 and Appendix B of [RFC-2460]. The alignment of first byte of each option is specified by two values, called x and y, written as &#34;xn + y&#34;. This states that the option must appear at an integer multiple of x bytes from the beginning of the options header (x can have the values 1, 2, 4, or 8), plus y bytes (y can have a value between 0 and 7, inclusive). The Pad1 and PadN options are inserted as needed to maintain the required alignment. The functions below need to know the alignment of the end of the option (which is always in the form &#34;xn,&#34; where x can have the values 1, 2, 4, or 8) and the total size of the data portion of the option. These are passed as the &#34;align&#34; and &#34;len&#34; arguments to inet6_opt_append().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
個々のホップバイホップオプション（およびセクション9で説明されており、ホップバイホップオプションに非常に似ている目的地オプション）には、特定のアライメント要件がある場合があります。たとえば、4バイトのジャンボペイロード長は4バイトの境界に表示され、IPv6アドレスは通常、8バイトの境界に揃っています。これらの要件とこれらのオプションで使用される用語については、[RFC-2460]のセクション4.2および付録Bで説明します。各オプションの最初のバイトのアライメントは、「xn y」と書かれたxとyと呼ばれる2つの値で指定されます。これは、オプションヘッダーの先頭からXバイトの整数倍に表示されなければならないことを示しています（xは値1、2、4、または8を持つことができます）とyバイト（yは0〜7の間の値を持つことができます、包括的）。必要に応じて、PAD1およびPADNオプションが挿入され、必要に応じて必要に応じて挿入されます。以下の関数は、オプションの終了のアラインメント（常に「xn」、xが値1、2、4、または8を持つことができる形式の形式である）と、データ部分のデータ部分の合計サイズを知る必要があります。オプション。これらは、inet6_opt_append（）の「align」および「len」引数として渡されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multiple Hop-by-Hop options must be specified by the application by placing them in a single extension header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のホップバイホップオプションを、単一の拡張ヘッダーに配置することにより、アプリケーションで指定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, we note that use of some Hop-by-Hop options or some Destination options, might require special privilege. That is, normal applications (without special privilege) might be forbidden from setting certain options in outgoing packets, and might never see certain options in received packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、いくつかのホップバイホップオプションまたはいくつかの目的地オプションを使用するには、特別な特権が必要になる場合があることに注意してください。つまり、通常のアプリケーション（特別な特権なし）は、発信パケットに特定のオプションを設定することを禁じられている可能性があり、受信パケットに特定のオプションが表示されない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1--Receiving-Hop-by-Hop-Options">
8.1. Receiving Hop-by-Hop Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. ホップバイホップオプションを受信します
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To receive a Hop-by-Hop options header the application must enable the IPV6_RECVHOPOPTS socket option:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホップバイホップオプションヘッダーを受信するには、アプリケーションがIPv6_recvhopoptsソケットオプションを有効にする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int  on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVHOPOPTS, &amp;on, sizeof(on));
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When using ancillary data a Hop-by-hop options header is passed between the application and the kernel as follows: The cmsg_level member will be IPPROTO_IPV6 and the cmsg_type member will be IPV6_HOPOPTS. These options are then processed by calling the inet6_opt_next(), inet6_opt_find(), and inet6_opt_get_val() functions, described in Section 10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
補助データを使用する場合、次のように、アプリケーションとカーネルの間にホップバイホップオプションヘッダーが渡されます。CMSG_LEVELメンバーはIPPROTO_IPV6であり、CMSG_TYPEメンバーはIPv6_hopoptsです。これらのオプションは、セクション10で説明されているINET6_OPT_NEXT（）、INET6_OPT_FIND（）、およびINET6_OPT_GET_VAL（）関数を呼び出すことにより処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2--Sending-Hop-by-Hop-Options">
8.2. Sending Hop-by-Hop Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. ホップバイホップオプションを送信します
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To send a Hop-by-Hop options header, the application specifies the header either as ancillary data in a call to sendmsg() or using setsockopt().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホップバイホップオプションヘッダーを送信するには、アプリケーションは、sendmsg（）への呼び出しの補助データとしてヘッダーを指定するか、setsockopt（）を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The application can remove any sticky Hop-by-Hop options header by calling setsockopt() for IPV6_HOPOPTS with a zero option length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、オプションの長さがゼロのIPv6_hopoptsのSetSockopt（）を呼び出すことにより、スティッキーホップバイホップオプションヘッダーを削除できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All the Hop-by-Hop options must be specified by a single ancillary data object. The cmsg_level member is set to IPPROTO_IPV6 and the cmsg_type member is set to IPV6_HOPOPTS. The option is normally constructed using the inet6_opt_init(), inet6_opt_append(), inet6_opt_finish(), and inet6_opt_set_val() functions, described in Section 10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのホップバイホップオプションは、単一の補助データオブジェクトで指定する必要があります。CMSG_LEVELメンバーはIPPROTO_IPV6に設定され、CMSG_TYPEメンバーはIPv6_hopoptsに設定されます。オプションは通常、inet6_opt_init（）、inet6_opt_append（）、inet6_opt_finish（）、およびinet6_opt_set_val（）関数を使用して構築されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional errors may be possible from sendmsg() and setsockopt() if the specified option is in error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたオプションが誤っている場合、sendmsg（）およびsetSockopt（）から追加のエラーが可能になる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--Destination-Options">
9. Destination Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 目的地オプション
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A variable number of Destination options can appear in one or more Destination options headers. As defined in [RFC-2460], a Destination options header appearing before a Routing header is processed by the first destination plus any subsequent destinations specified in the Routing header, while a Destination options header that is not followed by a Routing header is processed only by the final destination. As with the Hop-by-Hop options, each option in a Destination options header is TLV-encoded with a type, length, and value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さまざまな数の宛先オプションが、1つ以上の宛先オプションヘッダーに表示されます。[RFC-2460]で定義されているように、ルーティングヘッダーが最初の宛先によって処理される前に表示される宛先オプションヘッダーと、ルーティングヘッダーで指定された後続の宛先が、ルーティングヘッダーが続いていない宛先オプションヘッダーは処理のみで処理されます。最終目的地で。ホップバイホップオプションと同様に、宛先オプションヘッダーの各オプションは、タイプ、長さ、および値でTLVエンコードされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-1--Receiving-Destination-Options">
9.1. Receiving Destination Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. 目的地オプションを受信します
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To receive Destination options header the application must enable the IPV6_RECVDSTOPTS socket option:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先オプションを受信するには、アプリケーションを有効にする必要がありますIPv6_Recvdstoptsソケットオプション：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int  on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVDSTOPTS, &amp;on, sizeof(on));
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each Destination options header is returned as one ancillary data object described by a cmsghdr structure with cmsg_level set to IPPROTO_IPV6 and cmsg_type set to IPV6_DSTOPTS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各宛先オプションヘッダーは、CMSG_LEVELがIPPROTO_IPV6に設定されたCMSGHDR構造とIPv6_DSTOPTSに設定されたCMSG_TYPEを使用して、CMSGHDR構造によって記述された1つの補助データオブジェクトとして返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These options are then processed by calling the inet6_opt_next(), inet6_opt_find(), and inet6_opt_get_value() functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのオプションは、INET6_OPT_NEXT（）、INET6_OPT_FIND（）、およびINET6_OPT_GET_VALUE（）関数を呼び出して処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2--Sending-Destination-Options">
9.2. Sending Destination Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. 目的地オプションの送信
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To send a Destination options header, the application specifies it either as ancillary data in a call to sendmsg() or using setsockopt().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先オプションヘッダーを送信するには、アプリケーションは、sendmsg（）への呼び出しの補助データとしてそれを指定するか、setsockopt（）を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The application can remove any sticky Destination options header by calling setsockopt() for IPV6_RTHDRDSTOPTS/IPV6_DSTOPTS with a zero option length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、オプションの長さがゼロのIPv6_RTHDRDSTOPTS/IPv6_DSTOPTSのSetSockopt（）を呼び出すことにより、スティッキーデスティネーションオプションヘッダーを削除できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This API assumes the ordering about extension headers as described in [RFC-2460]. Thus, one set of Destination options can only appear before a Routing header, and one set can only appear after a Routing header (or in a packet with no Routing header). Each set can consist of one or more options but each set is a single extension header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このAPIは、[RFC-2460]で説明されているように、拡張ヘッダーに関する順序を想定しています。したがって、1つの宛先オプションのセットは、ルーティングヘッダーの前にのみ表示され、1つのセットはルーティングヘッダー（またはルーティングヘッダーのないパケット）の後にのみ表示できます。各セットは1つ以上のオプションで構成できますが、各セットは単一の拡張ヘッダーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Today all destination options that an application may want to specify can be put after (or without) a Routing header. Thus, applications should usually need IPV6_DSTOPTS only and should avoid using IPV6_RTHDRDSTOPTS whenever possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
今日、アプリケーションが指定したいすべての目的地オプションは、ルーティングヘッダーの後（またはなし）に配置できます。したがって、アプリケーションは通常、IPv6_dstoptsのみを必要とする必要があり、可能な限りIPv6_rthdrdstoptsの使用を避ける必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When using ancillary data a Destination options header is passed between the application and the kernel as follows: The set preceding a Routing header are specified with the cmsg_level member set to IPPROTO_IPV6 and the cmsg_type member set to IPV6_RTHDRDSTOPTS. Any setsockopt or ancillary data for IPV6_RTHDRDSTOPTS is silently ignored when sending packets unless a Routing header is also specified. Note that the &#34;Routing header&#34; here means the one specified by this API. Even when the kernel inserts a routing header in its internal routine (e.g., in a mobile IPv6 stack), the Destination options header specified by IPV6_RTHDRDSTOPTS will still be ignored unless the application explicitly specifies its own Routing header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
補助データを使用する場合、アプリケーションとカーネルの間に次のように宛先オプションヘッダーが渡されます。ルーティングヘッダーの前のセットは、CMSG_LEVELメンバーがIPPROTO_IPV6に設定され、CMSG_TYPEメンバーがIPv6_RTHDRDSTOPTSに設定されていることを指定します。ルーティングヘッダーも指定されていない限り、パケットを送信する場合、IPv6_RTHDRDSTOPTSのSetSockoptまたは補助データは静かに無視されます。ここでの「ルーティングヘッダー」は、このAPIで指定されたものを意味することに注意してください。カーネルがルーティングヘッダーを内部ルーチン（モバイルIPv6スタックなど）に挿入した場合でも、IPv6_rthdrdstoptsで指定された宛先オプションヘッダーは、アプリケーションが独自のルーティングヘッダーを明示的に指定しない限り無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set of Destination options after a Routing header, which are also used when no Routing header is present, are specified with the cmsg_level member is set to IPPROTO_IPV6 and the cmsg_type member is set to IPV6_DSTOPTS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ルーティングヘッダーが存在しないときにも使用されるルーティングヘッダーの後の宛先オプションのセットは、CMSG_LEVELメンバーがIPPROTO_IPV6に設定され、CMSG_TYPEメンバーはIPv6_DSTOPTSに設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Destination options are normally constructed using the inet6_opt_init(), inet6_opt_append(), inet6_opt_finish(), and inet6_opt_set_val() functions, described in Section 10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先オプションは、通常、INET6_OPT_INIT（）、INET6_OPT_APPEND（）、INET6_OPT_FINISH（）、およびINET6_OPT_SET_VAL（）関数を使用して構築されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional errors may be possible from sendmsg() and setsockopt() if the specified option is in error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたオプションが誤っている場合、sendmsg（）およびsetSockopt（）から追加のエラーが可能になる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10--Hop-by-Hop-and-Destination-Options-Processing">
10. Hop-by-Hop and Destination Options Processing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. ホップバイホップと宛先オプションの処理
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Building and parsing the Hop-by-Hop and Destination options is complicated for the reasons given earlier. We therefore define a set of functions to help the application. These functions assume the formatting rules specified in Appendix B in [RFC-2460] i.e., that the largest field is placed last in the option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホップバイホップと目的地のオプションを構築して解析することは、以前に与えられた理由で複雑です。したがって、アプリケーションを支援するために一連の関数を定義します。これらの関数は、[RFC-2460]の付録Bで指定されているフォーマットルールを想定しています。つまり、最大のフィールドがオプションで最後に配置されていることを想定しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The function prototypes for these functions are defined as a result of including &lt;netinet/in.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの関数の関数プロトタイプは、&lt;netinet/in.h&gt;を含める結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first 3 functions (init, append, and finish) are used both to calculate the needed buffer size for the options, and to actually encode the options once the application has allocated a buffer for the header. In order to only calculate the size the application must pass a NULL extbuf and a zero extlen to those functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の3つの機能（init、append、およびfinish）は、オプションに必要なバッファサイズを計算するために、またアプリケーションがヘッダーのバッファーを割り当てた後にオプションを実際にエンコードするために使用されます。サイズのみを計算するためには、アプリケーションはそれらの関数にnull extbufとゼロのextlenを渡す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-1--inet6optinit">
10.1. inet6_opt_init
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. inet6_opt_init
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int inet6_opt_init(void *extbuf, socklen_t extlen);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function returns the number of bytes needed for the empty extension header i.e., without any options. If extbuf is not NULL it also initializes the extension header to have the correct length field. In that case if the extlen value is not a positive (i.e., non-zero) multiple of 8 the function fails and returns -1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、空の拡張ヘッダーに必要なバイト数、つまりオプションがないことを返します。extbufがnullでない場合、拡張ヘッダーを初期化して正しい長さフィールドを持つようにします。その場合、extlen値が8の正の（つまり、非ゼロ）倍数でない場合、関数は失敗し、-1を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: since the return value on success is based on a &#34;constant&#34; parameter, i.e., the empty extension header, an implementation may return a constant value. However, this specification does not require the value be constant, and leaves it as implementation dependent. The application should not assume a particular constant value as a successful return value of this function.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：成功の返品値は「定数」パラメーター、つまり空の拡張ヘッダーに基づいているため、実装は一定の値を返す場合があります。ただし、この仕様は値を一定ではなく、実装として残します依存。アプリケーションは、この関数の成功した返品値として特定の一定の値を想定すべきではありません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-2--inet6optappend">
10.2. inet6_opt_append
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. inet6_opt_append
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int inet6_opt_append(void *extbuf, socklen_t extlen, int offset,
                           uint8_t type, socklen_t len, uint_t align,
                           void **databufp);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Offset should be the length returned by inet6_opt_init() or a previous inet6_opt_append(). This function returns the updated total length taking into account adding an option with length &#39;len&#39; and alignment &#39;align&#39;. If extbuf is not NULL then, in addition to returning the length, the function inserts any needed pad option, initializes the option (setting the type and length fields) and returns a pointer to the location for the option content in databufp. If the option does not fit in the extension header buffer the function returns -1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オフセットは、inet6_opt_init（）または以前のinet6_opt_append（）によって返される長さである必要があります。この関数は、長さの「LEN」とアライメント「ALIGN」を備えたオプションを追加することを考慮して、更新された総長さを返します。extbufがnullでない場合、長さを返すことに加えて、関数は必要なパッドオプションを挿入し、オプションを初期化（タイプと長さフィールドの設定）し、データビューFPのオプションコンテンツの位置へのポインターを返します。オプションが拡張ヘッダーバッファに適合しない場合、関数は-1を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Type is the 8-bit option type. Len is the length of the option data (i.e., excluding the option type and option length fields).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプは8ビットオプションタイプです。LENは、オプションデータの長さです（つまり、オプションタイプとオプションの長さフィールドを除く）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once inet6_opt_append() has been called the application can use the databuf directly, or use inet6_opt_set_val() to specify the content of the option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
INET6_OPT_APPEND（）が呼び出されると、アプリケーションはDataBufを直接使用するか、INET6_OPT_SET_VAL（）を使用してオプションのコンテンツを指定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The option type must have a value from 2 to 255, inclusive. (0 and 1 are reserved for the Pad1 and PadN options, respectively.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションタイプには、2〜255の値が含まれている必要があります。（0と1は、それぞれPAD1およびPADNオプション用に予約されています。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The option data length must have a value between 0 and 255, inclusive, and is the length of the option data that follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションデータの長さは、包括的0〜255の値を持つ必要があり、次のオプションデータの長さです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The align parameter must have a value of 1, 2, 4, or 8. The align value can not exceed the value of len.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alignパラメーターの値は1、2、4、または8の値を持っている必要があります。LENの値はLENの値を超えません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-3--inet6optfinish">
10.3. inet6_opt_finish
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3. inet6_opt_finish
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int inet6_opt_finish(void *extbuf, socklen_t extlen, int offset);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Offset should be the length returned by inet6_opt_init() or inet6_opt_append(). This function returns the updated total length taking into account the final padding of the extension header to make it a multiple of 8 bytes. If extbuf is not NULL the function also initializes the option by inserting a Pad1 or PadN option of the proper length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オフセットは、inet6_opt_init（）またはinet6_opt_append（）によって返される長さである必要があります。この関数は、拡張ヘッダーの最終的なパディングを考慮して、8バイトの倍数にするために、更新された総長さを返します。extbufがnullでない場合、関数は、適切な長さのPAD1またはPADNオプションを挿入することにより、オプションを初期化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the necessary pad does not fit in the extension header buffer the function returns -1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必要なパッドが拡張ヘッダーバッファに収まらない場合、関数は-1を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-4--inet6optsetval">
10.4. inet6_opt_set_val
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4. inet6_opt_set_val
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int inet6_opt_set_val(void *databuf, int offset, void *val,
                            socklen_t vallen);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Databuf should be a pointer returned by inet6_opt_append(). This function inserts data items of various sizes in the data portion of the option. Val should point to the data to be inserted. Offset specifies where in the data portion of the option the value should be inserted; the first byte after the option type and length is accessed by specifying an offset of zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DataBufは、inet6_opt_append（）によって返されるポインターである必要があります。この関数は、オプションのデータ部分にさまざまなサイズのデータ項目を挿入します。VALは、挿入するデータを指す必要があります。オフセットは、オプションのデータ部分で値を挿入する場所を指定します。オプションタイプと長さの後の最初のバイトには、ゼロのオフセットを指定することによりアクセスします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The caller should ensure that each field is aligned on its natural boundaries as described in Appendix B of [RFC-2460], but the function must not rely on the caller&#39;s behavior. Even when the alignment requirement is not satisfied, inet6_opt_set_val should just copy the data as required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
発信者は、[RFC-2460]の付録Bに記載されているように、各フィールドが自然境界に整合するようにする必要がありますが、機能は発信者の動作に依存してはなりません。アライメント要件が満たされていない場合でも、INET6_OPT_SET_VALは、必要に応じてデータをコピーするだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The function returns the offset for the next field (i.e., offset + vallen) which can be used when composing option content with multiple fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、複数のフィールドでオプションコンテンツを構成するときに使用できる次のフィールド（つまり、オフセットVallen）のオフセットを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-5--inet6optnext">
10.5. inet6_opt_next
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5. inet6_opt_next
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int inet6_opt_next(void *extbuf, socklen_t extlen, int offset,
                         uint8_t *typep, socklen_t *lenp,
                         void **databufp);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function parses received option extension headers returning the next option. Extbuf and extlen specifies the extension header. Offset should either be zero (for the first option) or the length returned by a previous call to inet6_opt_next() or inet6_opt_find(). It specifies the position where to continue scanning the extension buffer. The next option is returned by updating typep, lenp, and databufp. Typep stores the option type, lenp stores the length of the option data (i.e., excluding the option type and option length fields), and databufp points the data field of the option. This function returns the updated &#34;previous&#34; length computed by advancing past the option that was returned. This returned &#34;previous&#34; length can then be passed to subsequent calls to inet6_opt_next(). This function does not return any PAD1 or PADN options. When there are no more options or if the option extension header is malformed the return value is -1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、次のオプションを返すオプション拡張ヘッダーを解析します。ExtbufとExtlenは、拡張ヘッダーを指定します。オフセットは、ゼロ（最初のオプションの場合）またはinet6_opt_next（）またはinet6_opt_find（）への前の呼び出しによって返された長さのいずれかである必要があります。拡張バッファーのスキャンを続ける位置を指定します。次のオプションは、typep、lenp、およびdataBufpを更新することにより返されます。Typepはオプションタイプを保存し、LENPはオプションデータの長さ（つまり、オプションタイプとオプションの長さフィールドを除く）を保存し、DataBUFPはオプションのデータフィールドをポイントします。この関数は、返されたオプションを通過することによって計算された更新された「以前の」長さを返します。これにより、「前の」長さが返され、その後のINET6_OPT_NEXT（）への後続の呼び出しに渡すことができます。この関数は、PAD1またはPADNオプションを返しません。これ以上のオプションがない場合、またはオプション拡張ヘッダーが奇形である場合、戻り値は-1です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-6--inet6optfind">
10.6. inet6_opt_find
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.6. inet6_opt_find
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int inet6_opt_find(void *extbuf, socklen_t extlen, int offset,
                         uint8_t type, socklen_t *lenp,
                         void **databufp);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function is similar to the previously described inet6_opt_next() function, except this function lets the caller specify the option type to be searched for, instead of always returning the next option in the extension header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、前述のINET6_OPT_NEXT（）関数と類似しています。ただし、この関数により、拡張ヘッダーの次のオプションを常に返すのではなく、この関数が検索するオプションタイプを指定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an option of the specified type is located, the function returns the updated &#34;previous&#34; total length computed by advancing past the option that was returned and past any options that didn&#39;t match the type. This returned &#34;previous&#34; length can then be passed to subsequent calls to inet6_opt_find() for finding the next occurrence of the same option type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたタイプのオプションが配置されている場合、関数は、返されたオプションを超えて進出し、タイプと一致しないオプションを通過することによって計算された更新された「以前の」合計長さを返します。これにより、「以前の」長さが返され、同じオプションタイプの次の発生を見つけるために、INET6_OPT_FIND（）への後続の呼び出しに渡すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an option of the specified type is not located, the return value is -1. If the option extension header is malformed, the return value is -1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたタイプのオプションが配置されていない場合、戻り値は-1です。オプション拡張ヘッダーが奇形である場合、戻り値は-1です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-7--inet6optgetval">
10.7. inet6_opt_get_val
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7. inet6_opt_get_val
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int inet6_opt_get_val(void *databuf, int offset, void *val,
                            socklen_t vallen);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Databuf should be a pointer returned by inet6_opt_next() or inet6_opt_find(). This function extracts data items of various sizes in the data portion of the option. Val should point to the destination for the extracted data. Offset specifies from where in the data portion of the option the value should be extracted; the first byte after the option type and length is accessed by specifying an offset of zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DataBufは、inet6_opt_next（）またはinet6_opt_find（）によって返されるポインターである必要があります。この関数は、オプションのデータ部分にさまざまなサイズのデータ項目を抽出します。VALは、抽出されたデータの宛先を指す必要があります。オフセットは、オプションのデータ部分で値を抽出する必要がある場所から指定します。オプションタイプと長さの後の最初のバイトには、ゼロのオフセットを指定することによりアクセスします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is expected that each field is aligned on its natural boundaries as described in Appendix B of [RFC-2460], but the function must not rely on the alignment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC-2460]の付録Bに記載されているように、各フィールドはその自然境界に整合されると予想されますが、関数はアライメントに依存してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The function returns the offset for the next field (i.e., offset + vallen) which can be used when extracting option content with multiple fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、複数のフィールドでオプションコンテンツを抽出するときに使用できる次のフィールド（つまり、オフセットVallen）のオフセットを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11--Additional-Advanced-API-Functions">
11. Additional Advanced API Functions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. 追加の高度なAPI関数
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1--Sending-with-the-Minimum-MTU">
11.1. Sending with the Minimum MTU
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. 最小MTUで送信します
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unicast applications should usually let the kernel perform path MTU discovery [RFC-1981], as long as the kernel supports it, and should not care about the path MTU. Some applications, however, might not want to incur the overhead of path MTU discovery, especially if the applications only send a single datagram to a destination. A potential example is a DNS server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユニキャストアプリケーションは、通常、カーネルがそれをサポートしている限り、パスMTU発見[RFC-1981]を実行できるようにする必要があり、パスMTUを気にしないでください。ただし、一部のアプリケーションは、特にアプリケーションが単一のデータグラムのみを宛先に送信する場合、PATH MTU発見のオーバーヘッドを発生させたくない場合があります。潜在的な例は、DNSサーバーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC-1981] describes how path MTU discovery works for multicast destinations. From practice in using IPv4 multicast, however, many careless applications that send large multicast packets on the wire have caused implosion of ICMPv4 error messages. The situation can be worse when there is a filtering node that blocks the ICMPv4 messages. Though the filtering issue applies to unicast as well, the impact is much larger in the multicast cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC-1981]は、マルチキャストの目的地でMTU発見がどのように機能するかを説明しています。ただし、IPv4マルチキャストの使用の練習から、ワイヤー上に大きなマルチキャストパケットを送信する多くの不注意なアプリケーションは、ICMPV4エラーメッセージの破壊を引き起こしました。ICMPV4メッセージをブロックするフィルタリングノードがある場合、状況は悪化する可能性があります。フィルタリングの問題はユニキャストにも適用されますが、マルチキャストの場合には影響がはるかに大きくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, applications sending multicast traffic should explicitly enable path MTU discovery only when they understand that the benefit of possibly larger MTU usage outweighs the possible impact of MTU discovery for active sources across the delivery tree(s). This default behavior is based on the today&#39;s practice with IPv4 multicast and path MTU discovery. The behavior may change in the future once it is found that path MTU discovery effectively works with actual multicast applications and network configurations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、マルチキャストトラフィックを送信するアプリケーションは、おそらくより大きなMTU使用の利点が、配信ツリー全体のアクティブソースのMTU発見の可能性のある影響を上回ることを理解している場合にのみ、Path MTU発見を明示的に有効にする必要があります。このデフォルトの動作は、IPv4マルチキャストおよびPATH MTU発見による今日の実践に基づいています。Path MTU Discoveryが実際のマルチキャストアプリケーションとネットワーク構成で効果的に機能することがわかった場合、動作は将来変化する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification defines a mechanism to avoid path MTU discovery by sending at the minimum IPv6 MTU [RFC-2460]. If the packet is larger than the minimum MTU and this feature has been enabled the IP layer will fragment to the minimum MTU. To control the policy about path MTU discovery, applications can use the IPV6_USE_MIN_MTU socket option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、最小IPv6 MTU [RFC-2460]で送信することにより、PATH MTUの発見を回避するメカニズムを定義します。パケットが最小MTUよりも大きく、この機能が有効になっている場合、IPレイヤーは最小MTUに分割されます。PATH MTU発見に関するポリシーを制御するために、アプリケーションはIPv6_use_min_mtuソケットオプションを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described above, the default policy should depend on whether the destination is unicast or multicast. For unicast destinations path MTU discovery should be performed by default. For multicast destinations path MTU discovery should be disabled by default. This option thus takes the following three types of integer arguments:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のように、デフォルトのポリシーは、宛先がユニキャストであるかマルチキャストかによって異なります。ユニキャスト宛先の場合、パスMTU発見はデフォルトで実行する必要があります。マルチキャストの宛先の場合、パスMTU発見はデフォルトで無効にする必要があります。したがって、このオプションは、次の3種類の整数引数を取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
-1: perform path MTU discovery for unicast destinations but do not perform it for multicast destinations. Packets to multicast destinations are therefore sent with the minimum MTU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
-1：ユニキャストの目的地のPATH MTUディスカバリーを実行しますが、マルチキャストの目的地では実行しません。したがって、マルチキャストの宛先へのパケットは、最小MTUで送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0: always perform path MTU discovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0：常にPATH MTUディスカバリーを実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1: always disable path MTU discovery and send packets at the minimum MTU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1：PATH MTUディスカバリーを常に無効にし、最小MTUでパケットを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The default value of this option is -1. Values other than -1, 0, and 1 are invalid, and an error EINVAL will be returned for those values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオプションのデフォルト値は-1です。-1、0、および1以外の値は無効であり、これらの値に対してeinvalのエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example, if a unicast application intentionally wants to disable path MTU discovery, it will add the following lines:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例として、ユニキャストアプリケーションが意図的にPATH MTU発見を無効にしたい場合、次の行が追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int  on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &amp;on, sizeof(on));
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this API intentionally excludes the case where the application wants to perform path MTU discovery for multicast but to disable it for unicast. This is because such usage is not feasible considering a scale of performance issues around whether to do path MTU discovery or not. When path MTU discovery makes sense to a destination but not to a different destination, regardless of whether the destination is unicast or multicast, applications either need to toggle the option between sending such packets on the same socket, or use different sockets for the two classes of destinations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このAPIは、アプリケーションがマルチキャストのPATH MTUディスカバリーを実行するが、ユニキャスト用に無効にする場合を意図的に除外していることに注意してください。これは、Path MTUの発見を行うかどうかについてのパフォーマンスの問題の規模を考慮して、そのような使用が実行不可能であるためです。PATH MTUディスカバリーが目的地に理にかなっているが、目的地がユニキャストであるかマルチキャストであるかに関係なく、別の宛先には意味がない場合、アプリケーションは同じソケットでそのようなパケットを送信する間のオプションを切り替えるか、2つのクラスに異なるソケットを使用する必要があります目的地の。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This option can also be sent as ancillary data. In the cmsghdr structure containing this ancillary data, the cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be IPV6_USE_MIN_MTU, and the first byte of cmsg_data[] will be the first byte of the integer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオプションは、補助データとして送信することもできます。この補助データを含むCMSGHDR構造では、CMSG_LEVELメンバーはIPPROTO_IPV6であり、CMSG_TYPEメンバーはIPv6_USE_MIN_MTUであり、CMSG_DATA []の最初のバイトは整数の最初のバイトになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-2--Sending-without-Fragmentation">
11.2. Sending without Fragmentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. 断片化なしで送信します
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to provide for easy porting of existing UDP and raw socket applications IPv6 implementations will, when originating packets, automatically insert a fragment header in the packet if the packet is too big for the path MTU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
既存のUDPおよびRAWソケットアプリケーションの簡単な移植を提供するために、IPv6実装は、パケットがPATH MTUに大きすぎる場合、パケットがパケットにフラグメントヘッダーを自動的に挿入します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some applications might not want this behavior. An example is traceroute which might want to discover the actual path MTU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のアプリケーションは、この動作を望んでいない場合があります。例は、実際のパスMTUを発見したいと思うかもしれないTracerouteです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification defines a mechanism to turn off the automatic inserting of a fragment header for UDP and raw sockets. This can be enabled using the IPV6_DONTFRAG socket option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、UDPおよび生のソケットのフラグメントヘッダーの自動挿入をオフにするメカニズムを定義します。これは、IPv6_DontFrag Socketオプションを使用して有効にできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_DONTFRAG, &amp;on, sizeof(on));
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By default, this socket option is disabled. Setting the value to 0 also disables the option i.e., reverts to the default behavior of automatic inserting. This option can also be sent as ancillary data. In the cmsghdr structure containing this ancillary data, the cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be IPV6_DONTFRAG, and the first byte of cmsg_data[] will be the first byte of the integer. This API only specifies the use of this option for UDP and raw sockets, and does not define the usage for TCP sockets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デフォルトでは、このソケットオプションは無効になっています。値を0に設定すると、オプションも無効になります。つまり、自動挿入のデフォルト動作に戻ります。このオプションは、補助データとして送信することもできます。この補助データを含むCMSGHDR構造では、CMSG_LEVELメンバーはIPPROTO_IPV6であり、CMSG_TYPEメンバーはIPv6_DontFragであり、CMSG_DATA []の最初のバイトは整数の最初のバイトになります。このAPIは、UDPおよび生のソケットにこのオプションの使用のみを指定し、TCPソケットの使用を定義しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the data size is larger than the MTU of the outgoing interface, the packet will be discarded. Applications can know the result by enabling the IPV6_RECVPATHMTU option described below and receiving the corresponding ancillary data items. An additional error EMSGSIZE may also be returned in some implementations. Note, however, that some other implementations might not be able to return this additional error when sending a message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データサイズが発信インターフェイスのMTUよりも大きい場合、パケットは破棄されます。アプリケーションは、以下に説明するIPv6_RecvPathMTUオプションを有効にし、対応する補助データ項目を受信することにより、結果を知ることができます。いくつかの実装では、追加のエラーEMSGSIZEも返される場合があります。ただし、他のいくつかの実装は、メッセージを送信するときにこの追加のエラーを返すことができない場合があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-3--Path-MTU-Discovery-and-UDP">
11.3. Path MTU Discovery and UDP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3. Path MTU DiscoveryとUDP
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP and raw socket applications need to be able to determine the &#34;maximum send transport-message size&#34; (Section 5.1 of [RFC-1981]) to a given destination so that those applications can participate in path MTU discovery. This lets those applications send smaller datagrams to the destination, avoiding fragmentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPおよびRAWソケットアプリケーションは、「最大送信輸送メサージサイズ」（[RFC-1981]のセクション5.1）を特定の宛先に決定できるようにする必要があり、それらのアプリケーションがPath MTU発見に参加できるようにします。これにより、これらのアプリケーションは、断片化を回避して、より小さなデータグラムを宛先に送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is accomplished using a new ancillary data item (IPV6_PATHMTU) which is delivered to recvmsg() without any actual data. The application can enable the receipt of IPV6_PATHMTU ancillary data items by setting the IPV6_RECVPATHMTU socket option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、実際のデータなしでrecvmsg（）に配信される新しい補助データ項目（IPv6_pathmtu）を使用して達成されます。このアプリケーションは、IPv6_RecvPathMTUソケットオプションを設定することにより、IPv6_PathMTUの補助データ項目を受信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int  on = 1;
      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVPATHMTU, &amp;on, sizeof(on));
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By default, this socket option is disabled. Setting the value to 0 also disables the option. This API only specifies the use of this option for UDP and raw sockets, and does not define the usage for TCP sockets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デフォルトでは、このソケットオプションは無効になっています。値を0に設定することもオプションを無効にします。このAPIは、UDPおよび生のソケットにこのオプションの使用のみを指定し、TCPソケットの使用を定義しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the application is sending packets too big for the path MTU recvmsg() will return zero (indicating no data) but there will be a cmsghdr with cmsg_type set to IPV6_PATHMTU, and cmsg_len will indicate that cmsg_data is sizeof(struct ip6_mtuinfo) bytes long. This can happen when the sending node receives a corresponding ICMPv6 packet too big error, or when the packet is sent from a socket with the IPV6_DONTFRAG option being on and the packet size is larger than the MTU of the outgoing interface. This indication is considered as an ancillary data item for a separate (empty) message. Thus, when there are buffered messages (i.e., messages that the application has not received yet) on the socket the application will first receive the buffered messages and then receive the indication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションがパスの大きすぎるパケットを送信すると、MTU recvmsg（）はゼロを返します（データがないことを示します）が、CMSG_TYPEを備えたCMSGHDRがIPv6_PathmTUに設定され、CMSG_LENはCMSG_DATAがsizeof（struct ip6_mtuinfo）bytes longであることを示します。これは、送信ノードが対応するICMPv6パケットを受信している場合、またはパケットがソケットから送信され、IPv6_DontFragオプションがオンになり、パケットサイズが発信インターフェイスのMTUよりも大きい場合に発生する可能性があります。この表示は、別の（空の）メッセージの補助データ項目と見なされます。したがって、ソケットにバッファリングされたメッセージ（つまり、アプリケーションがまだ受信していないメッセージ）がある場合、アプリケーションは最初にバッファーメッセージを受信してから表示を受信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first byte of cmsg_data[] will point to a struct ip6_mtuinfo carrying the path MTU to use together with the IPv6 destination address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSG_DATA []の最初のバイトは、IPv6宛先アドレスと一緒に使用するパスMTUを運ぶstruct IP6_MTUINFOを指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct ip6_mtuinfo {
        struct sockaddr_in6 ip6m_addr; /* dst address including
                                          zone ID */
        uint32_t            ip6m_mtu;  /* path MTU in host byte order */
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This cmsghdr will be passed to every socket that sets the IPV6_RECVPATHMTU socket option, even if the socket is non-connected. Note that this also means an application that sets the option may receive an IPV6_MTU ancillary data item for each ICMP too big error the node receives, including such ICMP errors caused by other applications on the node. Thus, an application that wants to perform the path MTU discovery by itself needs to keep history of destinations that it has actually sent to and to compare the address returned in the ip6_mtuinfo structure to the history. An implementation may choose not to delivery data to a connected socket that has a foreign address that is different than the address specified in the ip6m_addr structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このCMSGHDRは、ソケットが接続されていない場合でも、IPv6_RecVPathMTUソケットオプションを設定するすべてのソケットに渡されます。これは、オプションを設定するアプリケーションが、ノード上の他のアプリケーションによって引き起こされるICMPエラーを含む、ノードが受信する各ICMPのIPv6_MTU補助データ項目を受信できることを意味することに注意してください。したがって、MTU発見をパス自体に実行したいアプリケーションは、実際に送信された目的地の歴史を維持し、IP6_MTUINFO構造で返されたアドレスを歴史に比較する必要があります。実装は、IP6M_ADDR構造で指定されたアドレスとは異なる外部アドレスを持つ接続されたソケットにデータを配信しないことを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an application sends a packet with a routing header, the final destination stored in the ip6m_addr member does not necessarily contain complete information of the entire path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションがルーティングヘッダーを使用してパケットを送信する場合、IP6M_ADDRメンバーに保存されている最終宛先には、必ずしもパス全体の完全な情報が含まれているわけではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-4--Determining-the-Current-Path-MTU">
11.4. Determining the Current Path MTU
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4. 現在のパスMTUの決定
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some applications might need to determine the current path MTU e.g., applications using IPV6_RECVPATHMTU might want to pick a good starting value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のアプリケーションは、現在のパスMTUを決定する必要がある場合があります。たとえば、IPv6_RecVPathMTUを使用したアプリケーションは、優れた開始値を選択する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification defines a get-only socket option to retrieve the current path MTU value for the destination of a given connected socket. If the IP layer does not have a cached path MTU value it will return the interface MTU for the interface that will be used when sending to the destination address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様では、特定の接続されたソケットの宛先の現在のパスMTU値を取得するためのGET専用ソケットオプションを定義します。IPレイヤーにキャッシュされたパスMTU値がない場合、宛先アドレスに送信するときに使用されるインターフェイスのインターフェイスMTUを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This information is retrieved using the IPV6_PATHMTU socket option. This option takes a pointer to the ip6_mtuinfo structure as the fourth argument, and the size of the structure should be passed as a value-result parameter in the fifth argument.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この情報は、IPv6_pathmtuソケットオプションを使用して取得されます。このオプションは、4番目の引数としてIP6_MTUINFO構造へのポインターを取り、構造のサイズを5番目の引数の値応答パラメーターとして渡す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct ip6_mtuinfo mtuinfo;
      socklen_t infolen = sizeof(mtuinfo);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
getsockopt(fd, IPPROTO_IPV6, IPV6_PATHMTU, &amp;mtuinfo, &amp;infolen);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
GetSockopt（FD、IPPROTO_IPV6、IPv6_Pathmtu、＆Mtuinfo、＆Infolen）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the call succeeds, the path MTU value is stored in the ip6m_mtu member of the ip6_mtuinfo structure. Since the socket is connected, the ip6m_addr member is meaningless and should not be referred to by the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コールが成功すると、PATH MTU値はIP6_MTUINFO構造のIP6M_MTUメンバーに保存されます。ソケットが接続されているため、IP6M_ADDRメンバーは無意味であり、アプリケーションで参照されるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This option can only be used for a connected socket, because a non-connected socket does not have the information of the destination and there is no way to pass the destination via getsockopt(). When getsockopt() for this option is issued on a non-connected socket, the call will fail. Despite this limitation, this option is still useful from a practical point of view, because applications that care about the path MTU tend to send a lot of packets to a single destination and to connect the socket to the destination for performance reasons. If the application needs to get the MTU value in a more generic way, it should use a more generic interface, such as routing sockets [TCPIPILLUST].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続されていないソケットには目的地の情報がなく、GetSockopt（）を介して目的地を通過する方法がないため、このオプションは接続ソケットにのみ使用できます。このオプションのgetSockopt（）が接続されていないソケットで発行されると、通話は失敗します。この制限にもかかわらず、このオプションは、MTUのパスに関心があるアプリケーションが多くのパケットを単一の宛先に送信し、パフォーマンス上の理由でソケットを宛先に接続する傾向があるため、実際の観点から依然として役立ちます。アプリケーションがより一般的な方法でMTU値を取得する必要がある場合、ルーティングソケット[Tcpipillust]などのより一般的なインターフェイスを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12--Ordering-of-Ancillary-Data-and-IPv6-Extension-Headers">
12. Ordering of Ancillary Data and IPv6 Extension Headers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. 補助データとIPv6拡張ヘッダーの順序付け
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Three IPv6 extension headers can be specified by the application and returned to the application using ancillary data with sendmsg() and recvmsg(): the Routing header, Hop-by-Hop options header, and Destination options header. When multiple ancillary data objects are transferred via recvmsg() and these objects represent any of these three extension headers, their placement in the control buffer is directly tied to their location in the corresponding IPv6 datagram. For example, when the application has enabled the IPV6_RECVRTHDR and IPV6_RECVDSTOPTS options and later receives an IPv6 packet with extension headers in the following order:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3つのIPv6拡張ヘッダーをアプリケーションで指定し、sendmsg（）およびrecvmsg（）を使用して補助データを使用してアプリケーションに返します。ルーティングヘッダー、ホップバイホップオプションヘッダー、および宛先オプションヘッダー。複数の補助的なデータオブジェクトがrecvmsg（）を介して転送され、これらのオブジェクトがこれらの3つの拡張ヘッダーのいずれかを表している場合、コントロールバッファーへの配置は、対応するIPv6データグラムの位置に直接結び付けられます。たとえば、アプリケーションがIPv6_RecvrthDRおよびIPv6_RecvdStoptsオプションを有効にし、後に次の順序で拡張ヘッダーを備えたIPv6パケットを受信した場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The IPv6 header A Hop-by-Hop options header A Destination options header (1) A Routing header An Authentication header A Destination options header (2) A UDP header and UDP data
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IPv6ヘッダーホップバイホップオプションヘッダー宛先オプションヘッダー（1）ルーティングヘッダー認証ヘッダー宛先オプションヘッダー（2）UDPヘッダーとUDPデータ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
then the application will receive three ancillary data objects in the following order:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、アプリケーションは次の順序で3つの補助データオブジェクトを受け取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
an object with cmsg_type set to IPV6_DSTOPTS, which represents the destination options header (1) an object with cmsg_type set to IPV6_RTHDR, which represents the Routing header an object with cmsg_type set to IPV6_DSTOPTS, which represents the destination options header (2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
cmsg_typeを持つオブジェクトは、IPv6_dstoptsに設定されています。これは、宛先オプションヘッダー（1）CMSG_Typeを持つオブジェクトをipv6_rthdrに設定します。これは、cmsg_toptsに設定されたオブジェクトをルーティングヘッダーに表すオブジェクトを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This example follows the header ordering described in [RFC-2460], but the receiving side of this specification does not assume the ordering. Applications may receive any numbers of objects in any order according to the ordering of the received IPv6 datagram.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例は、[RFC-2460]で説明されているヘッダー順序に続きますが、この仕様の受信側は順序付けを想定していません。アプリケーションは、受信したIPv6データグラムの順序に応じて、任意の数のオブジェクトを任意の数のオブジェクトを受信する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the sending side, however, this API imposes some ordering constraints according to [RFC-2460]. Applications using this API cannot make a packet with extension headers that do not follow the ordering. Note, however, that this does not mean applications must always follow the restriction. This is just a limitation in this API in order to give application programmers a guideline to construct headers in a practical manner. Should an application need to make an outgoing packet in an arbitrary order about the extension headers, some other technique, such as the datalink interfaces BPF or DLPI, must be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、送信側の場合、このAPIは[RFC-2460]に従っていくつかの順序制約を課します。このAPIを使用するアプリケーションは、注文に従わない拡張ヘッダーを備えたパケットを作成することはできません。ただし、これはアプリケーションが常に制限に従わなければならないという意味ではないことに注意してください。これは、アプリケーションプログラマーに実用的な方法でヘッダーを構築するためのガイドラインを提供するためのこのAPIの単なる制限です。アプリケーションが拡張ヘッダーについて任意の順序で送信パケットを作成する必要がある場合、DatalinkインターフェイスBPFやDLPIなどの他の手法を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The followings are more details about the constraints:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、制約の詳細です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Each IPV6_xxx ancillary data object for a particular type of extension header can be specified at most once in a single control buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 特定のタイプの拡張ヘッダーの各IPv6_xxx補助データオブジェクトは、1つのコントロールバッファーで最大で1回指定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- IPV6_xxx ancillary data objects can appear in any order in a control buffer, because there is no ambiguity of the ordering.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- IPv6_xxx順序付けのあいまいさがないため、IPv6_xxxの補助データオブジェクトは、コントロールバッファーで任意の順序で表示できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Each set of IPV6_xxx ancillary data objects and sticky options will be put in the outgoing packet along with the header ordering described in [RFC-2460].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- [RFC-2460]で説明されているヘッダー順序とともに、IPv6_xxxの補助データオブジェクトとスティッキーオプションの各セットが発信パケットに配置されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- An ancillary data object or a sticky option of IPV6_RTHDRDSTOPTS will affect the outgoing packet only when a Routing header is specified as an ancillary data object or a sticky option. Otherwise, the specified value for IPV6_RTHDRDSTOPTS will be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 補助データオブジェクトまたはIPv6_rthdrdstoptsの粘着性オプションは、ルーティングヘッダーが補助データオブジェクトまたは粘着性オプションとして指定されている場合にのみ、発信パケットに影響します。それ以外の場合、IPv6_RTHDRDSTOPTSの指定された値は無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, when an application sends a UDP datagram with a control data buffer containing ancillary data objects in the following order:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、アプリケーションが次の順序で補助データオブジェクトを含むコントロールデータバッファーを備えたUDPデータグラムを送信する場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
an object with cmsg_type set to IPV6_DSTOPTS an object with cmsg_type set to IPV6_RTHDRDSTOPTS an object with cmsg_type set to IPV6_HOPOPTS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
cmsg_toptsに設定されたcmsg_topts cmsg_toptsに設定されたオブジェクトcmsg_typeを備えたオブジェクトはipv6_rthdrdstopts cmsg_toptsに設定されているオブジェクト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and the sending socket does not have any sticky options, then the outgoing packet would be constructed as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、送信ソケットには粘着性のオプションがありません。その後、発信パケットは次のように構築されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The IPv6 header A Hop-by-Hop options header A Destination options header A UDP header and UDP data
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IPv6ヘッダーホップバイホップオプションヘッダー宛先オプションヘッダーUDPヘッダーとUDPデータ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where the destination options header corresponds to the ancillary data object with the type IPV6_DSTOPTS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先オプションヘッダーは、タイプIPv6_dstoptsを使用して補助データオブジェクトに対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the constraints above do not necessarily mean that the outgoing packet sent on the wire always follows the header ordering specified in this API document. The kernel may insert additional headers that break the ordering as a result. For example, if the kernel supports Mobile IPv6, an additional destination options header may be inserted before an authentication header, even without a routing header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の制約は、ワイヤー上に送信された送信パケットが常にこのAPIドキュメントで指定されたヘッダー順序に従うことを意味するわけではないことに注意してください。カーネルは、結果として順序を破る追加のヘッダーを挿入する場合があります。たとえば、カーネルがモバイルIPv6をサポートする場合、ルーティングヘッダーがなくても、認証ヘッダーの前に追加の宛先オプションヘッダーが挿入される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This API does not provide access to any other extension headers than the supported three types of headers. In particular, no information is provided about the IP security headers on an incoming packet, nor can be specified for an outgoing packet. This API is for applications that do not care about the existence of IP security headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このAPIは、サポートされている3種類のヘッダーよりも、他の拡張ヘッダーへのアクセスを提供しません。特に、着信パケットのIPセキュリティヘッダーに関する情報は提供されておらず、発信パケット用に指定することもできません。このAPIは、IPセキュリティヘッダーの存在を気にしないアプリケーション向けです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13--IPv6-Specific-Options-with-IPv4-Mapped-IPv6-Addresses">
13. IPv6-Specific Options with IPv4-Mapped IPv6 Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. IPv4マップIPv6アドレスを使用したIPv6固有のオプション
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The various socket options and ancillary data specifications defined in this document apply only to true IPv6 sockets. It is possible to create an IPv6 socket that actually sends and receives IPv4 packets, using IPv4-mapped IPv6 addresses, but the mapping of the options defined in this document to an IPv4 datagram is beyond the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントで定義されているさまざまなソケットオプションと補助データ仕様は、真のIPv6ソケットにのみ適用されます。IPv4-Mapped IPv6アドレスを使用して、IPv4パケットを実際に送信および受信するIPv6ソケットを作成することができますが、このドキュメントで定義されているオプションのマッピングは、IPv4データグラムにこのドキュメントの範囲を超えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, attempting to specify an IPv6-only option, such as the Hop-by-Hop options, Destination options, or Routing header on an IPv6 socket that is using IPv4-mapped IPv6 addresses, will probably result in an error. Some implementations, however, may provide access to the packet information (source/destination address, send/receive interface, and hop limit) on an IPv6 socket that is using IPv4-mapped IPv6 addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般に、IPv4-Mapped IPv6アドレスを使用しているIPv6ソケットのホップバイホップオプション、宛先オプション、またはルーティングヘッダーなど、IPv6のみのオプションを指定しようとすると、おそらくエラーが発生します。ただし、一部の実装では、IPv4マップのIPv6アドレスを使用しているIPv6ソケットのパケット情報（ソース/宛先アドレス、送信/受信インターフェイス、およびホップ制限）へのアクセスを提供する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14--Extended-interfaces-for-rresvport-rcmd-and-rexec">
14. Extended interfaces for rresvport, rcmd and rexec
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. RRESVPORT、RCMD、REXECの拡張インターフェイス
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Library functions that support the &#34;r&#34; commands hide the creation of a socket and the name resolution procedure from an application. When the libraries return an AF_INET6 socket to an application that do not support the address family, the application may encounter an unexpected result when, e.g., calling getpeername() for the socket. In order to support AF_INET6 sockets for the &#34;r&#34; commands while keeping backward compatibility, this section defines some extensions to the libraries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「R」コマンドをサポートするライブラリ関数は、ソケットの作成と、アプリケーションからの名前解決手順を非表示にします。ライブラリがAF_INET6ソケットをアドレスファミリをサポートしないアプリケーションに返すと、たとえばソケットのgetPeername（）を呼び出すと、アプリケーションが予期しない結果に遭遇する可能性があります。後方互換性を維持しながら「R」コマンドのAF_INET6ソケットをサポートするために、このセクションでは、ライブラリへのいくつかの拡張機能を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-1--rresvportaf">
14.1. rresvport_af
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1. rresvport_af
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rresvport() function is used by the rcmd() function, and this function is in turn called by many of the &#34;r&#34; commands such as rlogin. While new applications are not being written to use the rcmd() function, legacy applications such as rlogin will continue to use it and these will be ported to IPv6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rresvport（）関数はrcmd（）関数によって使用され、この関数はrloginなどの「r」コマンドの多くで順番に呼び出されます。RCMD（）関数を使用するための新しいアプリケーションは書かれていませんが、Rloginなどのレガシーアプリケーションは引き続き使用され、これらはIPv6に移植されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rresvport() creates an IPv4/TCP socket and binds a &#34;reserved port&#34; to the socket. Instead of defining an IPv6 version of this function we define a new function that takes an address family as its argument.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rresvport（）は、IPv4/TCPソケットを作成し、「予約ポート」をソケットにバインドします。この関数のIPv6バージョンを定義する代わりに、アドレスファミリをその引数として取る新しい関数を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #include &lt;unistd.h&gt;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int  rresvport_af(int *port, int family);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function behaves the same as the existing rresvport() function, but instead of creating an AF_INET TCP socket, it can also create an AF_INET6 TCP socket. The family argument is either AF_INET or AF_INET6, and a new error return is EAFNOSUPPORT if the address family is not supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は既存のrresvport（）関数と同じ動作をしますが、AF_INET TCPソケットを作成する代わりに、AF_INET6 TCPソケットを作成することもできます。家族の議論はaf_inetまたはaf_inet6のいずれかであり、アドレスファミリがサポートされていない場合、新しいエラーリターンはeafnosupportです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: There is little consensus on which header defines the rresvport() and rcmd() function prototypes. 4.4BSD defines it in &lt;unistd.h&gt;, others in &lt;netdb.h&gt;, and others don&#39;t define the function prototypes at all.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：ヘッダーがrresvport（）およびrcmd（）関数プロトタイプを定義するコンセンサスはほとんどありません。まったく。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2--rcmdaf">
14.2. rcmd_af
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2. RCMD_AF
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The existing rcmd() function can not transparently use AF_INET6 sockets since an application would not be prepared to handle AF_INET6 addresses returned by e.g., getpeername() on the file descriptor created by rcmd(). Thus a new function is needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
既存のrcmd（）関数は、rcmd（）によって作成されたファイル記述子のgetPeername（）で返されるAF_INET6アドレスを処理するためのアプリケーションが準備されていないため、AF_INET6ソケットを透過的に使用することはできません。したがって、新しい機能が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int rcmd_af(char **ahost, unsigned short rport,
                  const char *locuser, const char *remuser,
                  const char *cmd, int *fd2p, int af)
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function behaves the same as the existing rcmd() function, but instead of creating an AF_INET TCP socket, it can also create an AF_INET6 TCP socket. The family argument is AF_INET, AF_INET6, or AF_UNSPEC. When either AF_INET or AF_INET6 is specified, this function will create a socket of the specified address family. When AF_UNSPEC is specified, it will try all possible address families until a connection can be established, and will return the associated socket of the connection. A new error EAFNOSUPPORT will be returned if the address family is not supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は既存のrcmd（）関数と同じように動作しますが、AF_INET TCPソケットを作成する代わりに、AF_INET6 TCPソケットを作成することもできます。家族の議論は、af_inet、af_inet6、またはaf_unspecです。AF_INETまたはAF_INET6のいずれかが指定されている場合、この関数は指定されたアドレスファミリのソケットを作成します。AF_UNSPECが指定されると、接続が確立できるまですべての可能なアドレスファミリを試み、接続の関連ソケットを返します。アドレスファミリがサポートされていない場合、新しいエラーeafnosupportが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-3--rexecaf">
14.3. rexec_af
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3. rexec_af
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The existing rexec() function can not transparently use AF_INET6 sockets since an application would not be prepared to handle AF_INET6 addresses returned by e.g., getpeername() on the file descriptor created by rexec(). Thus a new function is needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
既存のrexec（）関数は、rexec（）によって作成されたファイル記述子のgetPeername（）で返されるAF_INET6アドレスを処理するためのアプリケーションが準備されていないため、AF_INET6ソケットを透過的に使用することはできません。したがって、新しい機能が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int rexec_af(char **ahost, unsigned short rport, const char *name,
                   const char *pass, const char *cmd, int *fd2p, int af)
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function behaves the same as the existing rexec() function, but instead of creating an AF_INET TCP socket, it can also create an AF_INET6 TCP socket. The family argument is AF_INET, AF_INET6, or AF_UNSPEC. When either AF_INET or AF_INET6 is specified, this function will create a socket of the specified address family. When AF_UNSPEC is specified, it will try all possible address families until a connection can be established, and will return the associated socket of the connection. A new error EAFNOSUPPORT will be returned if the address family is not supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は既存のrexec（）関数と同じ動作をしますが、AF_INET TCPソケットを作成する代わりに、AF_INET6 TCPソケットを作成することもできます。家族の議論は、af_inet、af_inet6、またはaf_unspecです。AF_INETまたはAF_INET6のいずれかが指定されている場合、この関数は指定されたアドレスファミリのソケットを作成します。AF_UNSPECが指定されると、接続が確立できるまですべての可能なアドレスファミリを試み、接続の関連ソケットを返します。アドレスファミリがサポートされていない場合、新しいエラーeafnosupportが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15--Summary-of-New-Definitions">
15. Summary of New Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. 新しい定義の概要
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following list summarizes the constants and structure, definitions discussed in this memo, sorted by header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のリストは、Headerでソートされたこのメモで説明されている定義、定義を要約しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      &lt;netinet/icmp6.h&gt; ICMP6_DST_UNREACH
      &lt;netinet/icmp6.h&gt; ICMP6_DST_UNREACH_ADDR
      &lt;netinet/icmp6.h&gt; ICMP6_DST_UNREACH_ADMIN
      &lt;netinet/icmp6.h&gt; ICMP6_DST_UNREACH_BEYONDSCOPE
      &lt;netinet/icmp6.h&gt; ICMP6_DST_UNREACH_NOPORT
      &lt;netinet/icmp6.h&gt; ICMP6_DST_UNREACH_NOROUTE
      &lt;netinet/icmp6.h&gt; ICMP6_ECHO_REPLY
      &lt;netinet/icmp6.h&gt; ICMP6_ECHO_REQUEST
      &lt;netinet/icmp6.h&gt; ICMP6_INFOMSG_MASK
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      &lt;netinet/icmp6.h&gt; ICMP6_PACKET_TOO_BIG
      &lt;netinet/icmp6.h&gt; ICMP6_PARAMPROB_HEADER
      &lt;netinet/icmp6.h&gt; ICMP6_PARAMPROB_NEXTHEADER
      &lt;netinet/icmp6.h&gt; ICMP6_PARAMPROB_OPTION
      &lt;netinet/icmp6.h&gt; ICMP6_PARAM_PROB
      &lt;netinet/icmp6.h&gt; ICMP6_ROUTER_RENUMBERING
      &lt;netinet/icmp6.h&gt; ICMP6_RR_FLAGS_FORCEAPPLY
      &lt;netinet/icmp6.h&gt; ICMP6_RR_FLAGS_PREVDONE
      &lt;netinet/icmp6.h&gt; ICMP6_RR_FLAGS_REQRESULT
      &lt;netinet/icmp6.h&gt; ICMP6_RR_FLAGS_SPECSITE
      &lt;netinet/icmp6.h&gt; ICMP6_RR_FLAGS_TEST
      &lt;netinet/icmp6.h&gt; ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME
      &lt;netinet/icmp6.h&gt; ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME
      &lt;netinet/icmp6.h&gt; ICMP6_RR_PCOUSE_RAFLAGS_AUTO
      &lt;netinet/icmp6.h&gt; ICMP6_RR_PCOUSE_RAFLAGS_ONLINK
      &lt;netinet/icmp6.h&gt; ICMP6_RR_RESULT_FLAGS_FORBIDDEN
      &lt;netinet/icmp6.h&gt; ICMP6_RR_RESULT_FLAGS_OOB
      &lt;netinet/icmp6.h&gt; ICMP6_TIME_EXCEEDED
      &lt;netinet/icmp6.h&gt; ICMP6_TIME_EXCEED_REASSEMBLY
      &lt;netinet/icmp6.h&gt; ICMP6_TIME_EXCEED_TRANSIT
      &lt;netinet/icmp6.h&gt; MLD_LISTENER_QUERY
      &lt;netinet/icmp6.h&gt; MLD_LISTENER_REDUCTION
      &lt;netinet/icmp6.h&gt; MLD_LISTENER_REPORT
      &lt;netinet/icmp6.h&gt; ND_NA_FLAG_OVERRIDE
      &lt;netinet/icmp6.h&gt; ND_NA_FLAG_ROUTER
      &lt;netinet/icmp6.h&gt; ND_NA_FLAG_SOLICITED
      &lt;netinet/icmp6.h&gt; ND_NEIGHBOR_ADVERT
      &lt;netinet/icmp6.h&gt; ND_NEIGHBOR_SOLICIT
      &lt;netinet/icmp6.h&gt; ND_OPT_MTU
      &lt;netinet/icmp6.h&gt; ND_OPT_PI_FLAG_AUTO
      &lt;netinet/icmp6.h&gt; ND_OPT_PI_FLAG_ONLINK
      &lt;netinet/icmp6.h&gt; ND_OPT_PREFIX_INFORMATION
      &lt;netinet/icmp6.h&gt; ND_OPT_REDIRECTED_HEADER
      &lt;netinet/icmp6.h&gt; ND_OPT_SOURCE_LINKADDR
      &lt;netinet/icmp6.h&gt; ND_OPT_TARGET_LINKADDR
      &lt;netinet/icmp6.h&gt; ND_RA_FLAG_MANAGED
      &lt;netinet/icmp6.h&gt; ND_RA_FLAG_OTHER
      &lt;netinet/icmp6.h&gt; ND_REDIRECT
      &lt;netinet/icmp6.h&gt; ND_ROUTER_ADVERT
      &lt;netinet/icmp6.h&gt; ND_ROUTER_SOLICIT
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      &lt;netinet/icmp6.h&gt; struct icmp6_filter{};
      &lt;netinet/icmp6.h&gt; struct icmp6_hdr{};
      &lt;netinet/icmp6.h&gt; struct icmp6_router_renum{};
      &lt;netinet/icmp6.h&gt; struct mld_hdr{};
      &lt;netinet/icmp6.h&gt; struct nd_neighbor_advert{};
      &lt;netinet/icmp6.h&gt; struct nd_neighbor_solicit{};
      &lt;netinet/icmp6.h&gt; struct nd_opt_hdr{};
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      &lt;netinet/icmp6.h&gt; struct nd_opt_mtu{};
      &lt;netinet/icmp6.h&gt; struct nd_opt_prefix_info{};
      &lt;netinet/icmp6.h&gt; struct nd_opt_rd_hdr{};
      &lt;netinet/icmp6.h&gt; struct nd_redirect{};
      &lt;netinet/icmp6.h&gt; struct nd_router_advert{};
      &lt;netinet/icmp6.h&gt; struct nd_router_solicit{};
      &lt;netinet/icmp6.h&gt; struct rr_pco_match{};
      &lt;netinet/icmp6.h&gt; struct rr_pco_use{};
      &lt;netinet/icmp6.h&gt; struct rr_result{};
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      &lt;netinet/in.h&gt;    IPPROTO_AH
      &lt;netinet/in.h&gt;    IPPROTO_DSTOPTS
      &lt;netinet/in.h&gt;    IPPROTO_ESP
      &lt;netinet/in.h&gt;    IPPROTO_FRAGMENT
      &lt;netinet/in.h&gt;    IPPROTO_HOPOPTS
      &lt;netinet/in.h&gt;    IPPROTO_ICMPV6
      &lt;netinet/in.h&gt;    IPPROTO_IPV6
      &lt;netinet/in.h&gt;    IPPROTO_NONE
      &lt;netinet/in.h&gt;    IPPROTO_ROUTING
      &lt;netinet/in.h&gt;    IPV6_CHECKSUM
      &lt;netinet/in.h&gt;    IPV6_DONTFRAG
      &lt;netinet/in.h&gt;    IPV6_DSTOPTS
      &lt;netinet/in.h&gt;    IPV6_HOPLIMIT
      &lt;netinet/in.h&gt;    IPV6_HOPOPTS
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      &lt;netinet/in.h&gt;    IPV6_NEXTHOP
      &lt;netinet/in.h&gt;    IPV6_PATHMTU
      &lt;netinet/in.h&gt;    IPV6_PKTINFO
      &lt;netinet/in.h&gt;    IPV6_RECVDSTOPTS
      &lt;netinet/in.h&gt;    IPV6_RECVHOPLIMIT
      &lt;netinet/in.h&gt;    IPV6_RECVHOPOPTS
      &lt;netinet/in.h&gt;    IPV6_RECVPKTINFO
      &lt;netinet/in.h&gt;    IPV6_RECVRTHDR
      &lt;netinet/in.h&gt;    IPV6_RECVTCLASS
      &lt;netinet/in.h&gt;    IPV6_RTHDR
      &lt;netinet/in.h&gt;    IPV6_RTHDRDSTOPTS
      &lt;netinet/in.h&gt;    IPV6_RTHDR_TYPE_0
      &lt;netinet/in.h&gt;    IPV6_RECVPATHMTU
      &lt;netinet/in.h&gt;    IPV6_TCLASS
      &lt;netinet/in.h&gt;    IPV6_USE_MIN_MTU
      &lt;netinet/in.h&gt;    struct in6_pktinfo{};
      &lt;netinet/in.h&gt;    struct ip6_mtuinfo{};
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      &lt;netinet/ip6.h&gt;   IP6F_MORE_FRAG
      &lt;netinet/ip6.h&gt;   IP6F_OFF_MASK
      &lt;netinet/ip6.h&gt;   IP6F_RESERVED_MASK
      &lt;netinet/ip6.h&gt;   IP6OPT_JUMBO
      &lt;netinet/ip6.h&gt;   IP6OPT_JUMBO_LEN
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      &lt;netinet/ip6.h&gt;   IP6OPT_MUTABLE
      &lt;netinet/ip6.h&gt;   IP6OPT_NSAP_ADDR
      &lt;netinet/ip6.h&gt;   IP6OPT_PAD1
      &lt;netinet/ip6.h&gt;   IP6OPT_PADN
      &lt;netinet/ip6.h&gt;   IP6OPT_ROUTER_ALERT
      &lt;netinet/ip6.h&gt;   IP6OPT_TUNNEL_LIMIT
      &lt;netinet/ip6.h&gt;   IP6OPT_TYPE_DISCARD
      &lt;netinet/ip6.h&gt;   IP6OPT_TYPE_FORCEICMP
      &lt;netinet/ip6.h&gt;   IP6OPT_TYPE_ICMP
      &lt;netinet/ip6.h&gt;   IP6OPT_TYPE_SKIP
      &lt;netinet/ip6.h&gt;   IP6_ALERT_AN
      &lt;netinet/ip6.h&gt;   IP6_ALERT_MLD
      &lt;netinet/ip6.h&gt;   IP6_ALERT_RSVP
      &lt;netinet/ip6.h&gt;   struct ip6_dest{};
      &lt;netinet/ip6.h&gt;   struct ip6_frag{};
      &lt;netinet/ip6.h&gt;   struct ip6_hbh{};
      &lt;netinet/ip6.h&gt;   struct ip6_hdr{};
      &lt;netinet/ip6.h&gt;   struct ip6_opt{};
      &lt;netinet/ip6.h&gt;   struct ip6_opt_jumbo{};
      &lt;netinet/ip6.h&gt;   struct ip6_opt_nsap{};
      &lt;netinet/ip6.h&gt;   struct ip6_opt_router{};
      &lt;netinet/ip6.h&gt;   struct ip6_opt_tunnel{};
      &lt;netinet/ip6.h&gt;   struct ip6_rthdr{};
      &lt;netinet/ip6.h&gt;   struct ip6_rthdr0{};
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following list summarizes the function and macro prototypes discussed in this memo, sorted by header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のリストは、このメモで説明されている関数とマクロプロトタイプを要約して、ヘッダーでソートします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      &lt;netinet/icmp6.h&gt; void ICMP6_FILTER_SETBLOCK(int, struct
                                               icmp6_filter *);
      &lt;netinet/icmp6.h&gt; void
                        ICMP6_FILTER_SETBLOCKALL(struct icmp6_filter *);
      &lt;netinet/icmp6.h&gt; void
                        ICMP6_FILTER_SETPASS(int,
                                             struct icmp6_filter *);
      &lt;netinet/icmp6.h&gt; void
                        ICMP6_FILTER_SETPASSALL(struct icmp6_filter *);
      &lt;netinet/icmp6.h&gt; int  ICMP6_FILTER_WILLBLOCK(int,
                                           const struct icmp6_filter *);
      &lt;netinet/icmp6.h&gt; int  ICMP6_FILTER_WILLPASS(int,
                                           const struct icmp6_filter *);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      &lt;netinet/in.h&gt;    int IN6_ARE_ADDR_EQUAL(const struct in6_addr *,
                                           const struct in6_addr *);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      &lt;netinet/in.h&gt;    int inet6_opt_append(void *, socklen_t, int,
                                             uint8_t, socklen_t, uint_t,
                                             void **);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      &lt;netinet/in.h&gt;    int inet6_opt_get_val(void *, int, void *,
                                              socklen_t);
      &lt;netinet/in.h&gt;    int inet6_opt_find(void *, socklen_t,
                                           int, uint8_t ,
                                           socklen_t *, void **);
      &lt;netinet/in.h&gt;    int inet6_opt_finish(void *, socklen_t, int);
      &lt;netinet/in.h&gt;    int inet6_opt_init(void *, socklen_t);
      &lt;netinet/in.h&gt;    int inet6_opt_next(void *, socklen_t,
                                           int, uint8_t *,
                                           socklen_t *, void **);
      &lt;netinet/in.h&gt;    int inet6_opt_set_val(void *, int,
                                              void *, socklen_t);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      &lt;netinet/in.h&gt;    int inet6_rth_add(void *,
                                          const struct in6_addr *);
      &lt;netinet/in.h&gt;    struct in6_addr inet6_rth_getaddr(const void *,
                                                          int);
      &lt;netinet/in.h&gt;    void *inet6_rth_init(void *, socklen_t,
                                             int, int);
      &lt;netinet/in.h&gt;    int inet6_rth_reverse(const void *, void *);
      &lt;netinet/in.h&gt;    int inet6_rth_segments(const void *);
      &lt;netinet/in.h&gt;    soccklen_t inet6_rth_space(int, int);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      &lt;netinet/ip6.h&gt;   int  IP6OPT_TYPE(uint8_t);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      &lt;sys/socket.h&gt;    socklen_t CMSG_LEN(socklen_t);
      &lt;sys/socket.h&gt;    socklen_t CMSG_SPACE(socklen_t);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      &lt;unistd.h&gt;        int rresvport_af(int *, int);
      &lt;unistd.h&gt;        int rcmd_af(char **, unsigned short,
                                    const char *, const char *,
                                    const char *, int *, int);
      &lt;unistd.h&gt;        int rexec_af(char **, unsigned short,
                                     const char *, const char *,
                                     const char *, int *, int);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="16--Security-Considerations">
16. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. セキュリティに関する考慮事項
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The setting of certain Hop-by-Hop options and Destination options may be restricted to privileged processes. Similarly some Hop-by-Hop options and Destination options may not be returned to non-privileged applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のホップバイホップオプションと宛先オプションの設定は、特権プロセスに制限される場合があります。同様に、一部のホップバイホップオプションと宛先オプションは、非具体的なアプリケーションに返されない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ability to specify an arbitrary source address using IPV6_PKTINFO must be prevented; at least for non-privileged processes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6_pktinfoを使用して任意のソースアドレスを指定する機能を防ぐ必要があります。少なくとも非主要なプロセスの場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="17--Changes-from-RFC-2292">
17. Changes from RFC 2292
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. RFC 2292からの変更
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Significant changes that affect the compatibility to RFC 2292:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 2292との互換性に影響する重要な変更：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Removed the IPV6_PKTOPTIONS socket option by allowing sticky options to be set with individual setsockopt() calls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 個々のSetSockopt（）呼び出しで粘着性オプションを設定できるようにすることにより、IPv6_pktoptionsソケットオプションを削除しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Removed the ability to be able to specify Hop-by-Hop and Destination options using multiple ancillary data items. The application, using the inet6_opt_xxx() routines (see below), is responsible for formatting the whole extension header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 複数の補助データ項目を使用して、ホップバイホップおよび宛先オプションを指定できる機能を削除しました。INET6_OPT_XXX（）ルーチン（以下を参照）を使用するアプリケーションは、拡張ヘッダー全体のフォーマットを担当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Removed the support for the loose/strict Routing header since that has been removed from the IPv6 specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- IPv6仕様から削除されたため、ルーズ/厳格なルーティングヘッダーのサポートを削除しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Loosened the constraints for jumbo payload option that this option was always hidden from applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- このオプションは常にアプリケーションから隠されていたというジャンボペイロードオプションの制約を緩めました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Disabled the use of the IPV6_HOPLIMIT sticky option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- IPv6_hoplimitスティッキーオプションの使用を無効にしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Removed ip6r0_addr field from the ip6_rthdr structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- IP6_RTHDR構造からIP6R0_ADDRフィールドを削除しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Intentionally unspecified how to get received packet&#39;s information on TCP sockets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- TCPソケットに関する受信パケットの情報を取得する方法を意図的に特定していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
New features:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新機能：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Added IPV6_RTHDRDSTOPTS to specify a Destination Options header before the Routing header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- IPv6_rthdrdstoptsを追加して、ルーティングヘッダーの前に宛先オプションヘッダーを指定しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Added separate IPV6_RECVxxx options to enable the receipt of the corresponding ancillary data items.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 対応する補助データ項目の受領を有効にするために、個別のIPv6_Recvxxxオプションを追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Added inet6_rth_xxx() and inet6_opt_xxx() functions to deal with routing or IPv6 options headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- INET6_RTH_XXX（）およびINET6_OPT_XXX（）を追加して、ルーティングまたはIPv6オプションヘッダーを扱うように機能します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Added extensions of libraries for the &#34;r&#34; commands.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 「R」コマンドのライブラリの拡張機能を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Introduced additional IPv6 option definitions such as IP6OPT_PAD1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- IP6OPT_PAD1などの追加のIPv6オプション定義を導入しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Added MLD and router renumbering definitions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- MLDおよびルーターの変更定義を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Added MTU-related socket options and ancillary data items.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- MTU関連のソケットオプションと補助データ項目を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Added options and ancillary data items to manipulate the traffic class field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- トラフィッククラスフィールドを操作するためのオプションと補助データ項目が追加されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Changed the name of ICMPv6 unreachable code 2 to be &#34;beyond scope of source address.&#34; ICMP6_DST_UNREACH_NOTNEIGHBOR was removed with this change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- ICMPV6の到達不可能なコード2の名前を「ソースアドレスの範囲を超えて」に変更しました。ICMP6_DST_UNREACH_NOTNEIGHBORは、この変更により削除されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clarifications:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Added clarifications on extension headers ordering; for the sending side, assume the recommended ordering described in RFC 2460. For the receiving side, do not assume any ordering and pass all headers to the application in the received order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 拡張ヘッダー注文に明確化を追加しました。送信側の場合、RFC 2460に記載されている推奨注文を想定してください。受信側については、注文を想定せず、受信順序ですべてのヘッダーをアプリケーションに渡さないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Added a summary about the interface selection rule.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- インターフェイス選択ルールに関する要約を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Clarified the ordering between IPV6_MULTICAST_IF and the IPV6_PKTINFO sticky option for multicast packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- IPv6_multicast_ifとマルチキャストパケットのIPv6_pktinfoスティッキーオプションの間の順序を明確にしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Clarified how sticky options and the ICMPv6 filter are turned off and that getsockopt() of a sticky option returns what was set with setsockopt().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 粘着性のオプションとICMPV6フィルターがオフになっている方法を明確にし、StickyオプションのGetSockopt（）がSetSockopt（）で設定されたものを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Clarified that IPV6_NEXTHOP should be ignored for a multicast destination, that it should not contradict with the specified outgoing interface, and that the next hop should be a sockaddr_in6 structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- IPv6_Nexthopは、マルチキャストの目的地では無視されるべきであり、指定された発信インターフェイスと矛盾するべきではないこと、次のホップはSockaddr_in6構造であることを明らかにしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Clarified corner cases of IPV6_CHECKSUM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- IPv6_Checksumの明確なコーナーケース。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Aligned with the POSIX standard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- POSIX標準と整合しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Editorial changes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
編集の変更：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Replaced MUST with must (since this is an informational document).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Mustに置き換えられた必要があります（これは情報ドキュメントであるため）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Revised abstract to be more clear and concise, particularly concentrating on differences from RFC 2292.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 改訂された要約は、特にRFC 2292との違いに集中して、より明確かつ簡潔にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Made the URL of assigned numbers less specific so that it would be more robust for future changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 割り当てられた数値のURLを具体的にしなくなり、将来の変更により堅牢になりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Updated the reference to the basic API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 基本的なAPIへの参照を更新しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Added a reference to the latest POSIX standard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 最新のPOSIX標準への参照を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Moved general specifications of ancillary data and CMSG macros to the appendix.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 補助データとCMSGマクロの一般仕様を付録に移動しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18--References">
18. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. 参考文献
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC-1981] McCann, J., Deering, S. and J. Mogul, &#34;Path MTU Discovery for IP version 6&#34;, RFC 1981, August 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC-1981] McCann、J.、Deering、S。、およびJ. Mogul、「IPバージョン6のPath MTU Discovery」、RFC 1981、1996年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC-2460] Deering, S. and R. Hinden, &#34;Internet Protocol, Version 6 (IPv6) Specification&#34;, RFC 2460, December 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC-2460] Deering、S。and R. Hinden、「Internet Protocol、バージョン6（IPv6）仕様」、RFC 2460、1998年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC-3493] Gilligan, R., Thomson, S., Bound, J., McCann, J. and W. Stevens, &#34;Basic Socket Interface Extensions for IPv6&#34;, RFC 3493, March 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC-3493] Gilligan、R.、Thomson、S.、Bound、J.、McCann、J。、およびW. Stevens、「IPv6の基本ソケットインターフェイス拡張」、RFC 3493、2003年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[POSIX] IEEE Std. 1003.1-2001 Standard for Information Technology -- Portable Operating System Interface (POSIX). Open group Technical Standard: Base Specifications, Issue 6, December 2001. ISO/IEC 9945:2002. http://www.opengroup.org/austin
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[posix] IEEE std。1003.1-2001情報技術の標準 - ポータブルオペレーティングシステムインターフェイス（POSIX）。オープングループの技術標準：基本仕様、2001年12月、第6号。ISO/IEC 9945：2002。http://www.opengroup.org/austin
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TCPIPILLUST] Wright, G., Stevens, W., &#34;TCP/IP Illustrated, Volume 2: The Implementation&#34;, Addison Wesley, 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Tcpipillust] Wright、G.、Stevens、W。、「TCP/IP Illustrated、Volume 2：The Information」、Addison Wesley、1994。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="19--Acknowledgments">
19. Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. 謝辞
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Matt Thomas and Jim Bound have been working on the technical details in this document for over a year. Keith Sklower is the original implementor of ancillary data in the BSD networking code. Craig Metz provided lots of feedback, suggestions, and comments based on his implementing many of these features as the document was being written. Mark Andrews first proposed the idea of the IPV6_USE_MIN_MTU option. Jun-ichiro Hagino contributed text for the traffic class API from a document of his own.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マット・トーマスとジム・バウンドは、この文書の技術的な詳細に1年以上取り組んできました。Keith Sklowerは、BSDネットワークコードの補助データの元の実装者です。Craig Metzは、ドキュメントが書かれているときにこれらの機能の多くを実装することに基づいて、多くのフィードバック、提案、およびコメントを提供しました。マークアンドリュースは、最初にIPv6_use_min_mtuオプションのアイデアを提案しました。Jun-Ithiro Haginoは、彼自身のドキュメントからトラフィッククラスAPIのテキストを提供しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following provided comments on earlier drafts: Pascal Anelli, Hamid Asayesh, Ran Atkinson, Karl Auerbach, Hamid Asayesh, Don Coolidge, Matt Crawford, Sam T. Denton, Richard Draves, Francis Dupont, Toerless Eckert, Lilian Fernandes, Bob Gilligan, Gerri Harter, Tim Hartrick, Bob Halley, Masaki Hirabaru, Michael Hunter, Yoshinobu Inoue, Mukesh Kacker, A. N. Kuznetsov, Sam Manthorpe, Pedro Marques, Jack McCann, der Mouse, John Moy, Lori Napoli, Thomas Narten, Atsushi Onoe, Steve Parker, Charles Perkins, Ken Powell, Tom Pusateri, Pedro Roque, Sameer Shah, Peter Sjodin, Stephen P. Spackman, Jinmei Tatuya, Karen Tracey, Sowmini Varadhan, Quaizar Vohra, Carl Williams, Steve Wise, Eric Wong, Farrell Woods, Kazu Yamamoto, Vladislav Yasevich, and Yoshifuji Hideaki.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、以前のドラフトに関するコメントを提供しました：パスカルアネッリ、ハミドアセイシュ、ランアトキンソン、カールアウアーバッハ、ハミドアセイシュ、ドンクーリッジ、マットクロフォード、サムT.デントン、リチャードドレーブス、フランシスデュポン、トアレスエッカート、リリアンフェルナンデス、ボブギリガン、ゲリリガンハーター、ティム・ハートリック、ボブ・ハレー、マサキ・ヒラバル、マイケル・ハンター、ヨシノブ・イノウエ、ムケシュ・カッカー、A。N。クズネツォフ、サム・マンソープ、ペドロ・マルケス、ジャック・マッキャン、デル・マウス、ジョン・モイ、ロリ・ナポリ、トーマス・ナルテンチャールズ・パーキンス、ケン・パウエル、トム・プサテリ、ペドロ・ロケ、サミャー・シャー、ピーター・ショディン、スティーブン・P・スパックマン、ジンメイ・タトゥヤ、カレン・トレーシー、ソウミニ・バラダン、Quaizar Vohra、Carl Williams、Steve Wise、Eric WongVladislav Yasevich、およびYoshifuji Hideaki。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20--Appendix-A-Ancillary-Data-Overview">
20. Appendix A: Ancillary Data Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20. 付録A：補助データの概要
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.2BSD allowed file descriptors to be transferred between separate processes across a UNIX domain socket using the sendmsg() and recvmsg() functions. Two members of the msghdr structure, msg_accrights and msg_accrightslen, were used to send and receive the descriptors. When the OSI protocols were added to 4.3BSD Reno in 1990 the names of these two fields in the msghdr structure were changed to msg_control and msg_controllen, because they were used by the OSI protocols for &#34;control information&#34;, although the comments in the source code call this &#34;ancillary data&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.2BSDでは、sendmsg（）およびrecvmsg（）関数を使用して、UNIXドメインソケットを横切る個別のプロセス間でファイル記述子を転送することができました。MSGHDR構造の2人のメンバーであるMSG_ACCRIGHTSとMSG_ACCRIGHTSLENが、記述子の送信と受信に使用されました。1990年にOSIプロトコルが4.3BSD RENOに追加されたとき、MSGHDR構造のこれら2つのフィールドの名前はMSG_CONTROLとMSG_CONTROLLENに変更されました。これを「補助データ」と呼びます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other than the OSI protocols, the use of ancillary data has been rare. In 4.4BSD, for example, the only use of ancillary data with IPv4 is to return the destination address of a received UDP datagram if the IP_RECVDSTADDR socket option is set. With Unix domain sockets ancillary data is still used to send and receive descriptors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OSIプロトコル以外に、補助データの使用はまれです。たとえば、4.4BSDでは、IPv4を使用した補助データの唯一の使用は、IP_RECVDSTADDRソケットオプションが設定されている場合、受信したUDPデータグラムの宛先アドレスを返すことです。UNIXドメインソケットでは、補助データを使用して記述子を送信および受信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nevertheless the ancillary data fields of the msghdr structure provide a clean way to pass information in addition to the data that is being read or written. The inclusion of the msg_control and msg_controllen members of the msghdr structure along with the cmsghdr structure that is pointed to by the msg_control member is required by the Posix sockets API standard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それにもかかわらず、MSGHDR構造の補助データフィールドは、読み取られているデータに加えて情報を渡すクリーンな方法を提供します。MSGHDR構造のMSG_CONTROLおよびMSG_CONTROLLENメンバーを、MSG_CONTROLメンバーが指すCMSGHDR構造とともに、POSIX Sockets API標準で要求されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-1--The-msghdr-Structure">
20.1. The msghdr Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1. MSGHDR構造
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The msghdr structure is used by the recvmsg() and sendmsg() functions. Its Posix definition is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MSGHDR構造は、recvmsg（）およびsendmsg（）関数によって使用されます。そのposix定義は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct msghdr {
        void      *msg_name;        /* ptr to socket address
                                       structure */
        socklen_t  msg_namelen;     /* size of socket address
                                       structure */
        struct iovec  *msg_iov;     /* scatter/gather array */
        int        msg_iovlen;      /* # elements in msg_iov */
        void      *msg_control;     /* ancillary data */
        socklen_t  msg_controllen;  /* ancillary data buffer length */
        int        msg_flags;       /* flags on received message */
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The structure is declared as a result of including &lt;sys/socket.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構造は、&lt;sys/socket.h&gt;を含めた結果として宣言されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: Before Posix the two &#34;void *&#34; pointers were typically &#34;char *&#34;, and the two socklen_t members were typically integers. Earlier drafts of Posix had the two socklen_t members as size_t, but it then changed these to socklen_t to simplify binary portability for 64-bit implementations and to align Posix with X/Open&#39;s Networking Services, Issue 5. The change in msg_control to a &#34;void *&#34; pointer affects any code that increments this pointer.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：POSIXの前に、2つの「void *」ポインターは通常「char *」であり、2つのsocklen_tメンバーは通常整数でした。Posixの以前のドラフトには2つのsocklen_tメンバーがsize_tとしてありましたが、バイナリを簡素化するためにこれらをsocklen_tに変更しました。64ビットの実装のポータビリティおよびX/OpenのネットワークサービスにPOSIXを整列させるために、問題。MSG_CONTROLの「void *」ポインターへの変更は、このポインターを増やすコードに影響します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most Berkeley-derived implementations limit the amount of ancillary data in a call to sendmsg() to no more than 108 bytes (an mbuf). This API requires a minimum of 10240 bytes of ancillary data, but it is recommended that the amount be limited only by the buffer space reserved by the socket (which can be modified by the SO_SNDBUF socket option). (Note: This magic number 10240 was picked as a value that should always be large enough. 108 bytes is clearly too small as the maximum size of a Routing header is 2048 bytes.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ほとんどのバークレー由来の実装は、sendmsg（）への呼び出し中の補助データの量を108バイト（MBUF）以下に制限しています。このAPIには、最低10240バイトの補助データが必要ですが、ソケット（SO_SNDBUFソケットオプションで変更できます）で予約されたバッファースペースによってのみ量を制限することをお勧めします。（注：このマジック番号10240は、常に十分に大きくする値として選択されました。108バイトは、ルーティングヘッダーの最大サイズが2048バイトであるため、明らかに小さすぎます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-2--The-cmsghdr-Structure">
20.2. The cmsghdr Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.2. CMSGHDR構造
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cmsghdr structure describes ancillary data objects transferred by recvmsg() and sendmsg(). Its Posix definition is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSGHDR構造は、recvmsg（）およびsendmsg（）によって転送される補助データオブジェクトを記述します。そのposix定義は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct cmsghdr {
        socklen_t  cmsg_len;   /* #bytes, including this header */
        int        cmsg_level; /* originating protocol */
        int        cmsg_type;  /* protocol-specific type */
                   /* followed by unsigned char cmsg_data[]; */
      };
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is declared as a result of including &lt;sys/socket.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造は、&lt;sys/socket.h&gt;を含めた結果として宣言されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: Before Posix the cmsg_len member was an integer, and not a socklen_t. See the Note in the previous section for why socklen_t is used here.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：POSIXの前に、CMSG_LENメンバーは整数であり、Socklen_Tではありませんでした。Socklen_Tがここで使用される理由については、前のセクションのメモを参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As shown in this definition, normally there is no member with the name cmsg_data[]. Instead, the data portion is accessed using the CMSG_xxx() macros, as described in Section 20.3. Nevertheless, it is common to refer to the cmsg_data[] member.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この定義に示されているように、通常、CMSG_DATAという名前のメンバーはいません。代わりに、セクション20.3で説明されているように、データ部分にCMSG_XXX（）マクロを使用してアクセスされます。それにもかかわらず、CMSG_DATA []メンバーを参照することが一般的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When ancillary data is sent or received, any number of ancillary data objects can be specified by the msg_control and msg_controllen members of the msghdr structure, because each object is preceded by a cmsghdr structure defining the object&#39;s length (the cmsg_len member). Historically Berkeley-derived implementations have passed only one object at a time, but this API allows multiple objects to be passed in a single call to sendmsg() or recvmsg(). The following example shows two ancillary data objects in a control buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
補助的なデータが送信または受信されると、各オブジェクトの前にオブジェクトの長さ（CMSG_LENメンバー）を定義するCMSGHDR構造が先行するため、MSGHDR構造のMSG_CONTROLおよびMSG_CONTROLLENメンバーによって任意の数の補助データオブジェクトを指定できます。歴史的に、バークレー由来の実装では、一度に1つのオブジェクトのみに合格していますが、このAPIにより、複数のオブジェクトをsendmsg（）またはrecvmsg（）への1回の呼び出しで渡すことができます。次の例は、コントロールバッファー内の2つの補助データオブジェクトを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
|&lt;--------------------------- msg_controllen -------------------------&gt;|
|                                 OR                                   |
|&lt;--------------------------- msg_controllen ----------------------&gt;|
|                                                                      |
|&lt;----- ancillary data object -----&gt;|&lt;---- ancillary data object -----&gt;|
|&lt;------ min CMSG_SPACE() ---------&gt;|&lt;----- min CMSG_SPACE() ---------&gt;|
|                                   |                                  |
|&lt;---------- cmsg_len ----------&gt;|  |&lt;-------- cmsg_len -----------&gt;|  |
|&lt;--------- CMSG_LEN() ---------&gt;|  |&lt;------- CMSG_LEN() ----------&gt;|  |
|                                |  |                               |  |
+-----+-----+-----+--+-----------+--+-----+-----+-----+--+----------+--+
|cmsg_|cmsg_|cmsg_|XX|   cmsg_   |XX|cmsg_|cmsg_|cmsg_|XX|  cmsg_   |XX|
|len  |level|type |XX|   data[]  |XX|len  |level|type |XX|  data[]  |XX|
+-----+-----+-----+--+-----------+--+-----+-----+-----+--+----------+--+
^
|
msg_control
points here
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fields shown as &#34;XX&#34; are possible padding, between the cmsghdr structure and the data, and between the data and the next cmsghdr structure, if required by the implementation. While sending an application may or may not include padding at the end of last ancillary data in msg_controllen and implementations must accept both as valid. On receiving a portable application must provide space for padding at the end of the last ancillary data as implementations may copy out the padding at the end of the control message buffer and include it in the received msg_controllen. When recvmsg() is called if msg_controllen is too small for all the ancillary data items including any trailing padding after the last item an implementation may set MSG_CTRUNC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「xx」として示されているフィールドは、実装で必要な場合は、「xx」と表示されているフィールドは、cmsghdr構造とデータの間、およびデータと次のcmsghdr構造の間で可能なパディングです。アプリケーションの送信中は、MSG_CONTROLLENの最後の補助データの最後にパディングを含める場合と含まない場合があり、実装は両方を有効であると受け入れる必要があります。受信時、ポータブルアプリケーションは、最後の補助データの最後にパディング用のスペースを提供する必要があります。実装により、コントロールメッセージバッファーの最後にパディングをコピーし、受信したMSG_CONTROLLENに含めることができます。MSG_CONTROLLENが、最後の項目の後の後続のパディングを含むすべての補助データ項目に対してMSG_CONTROLLENが小さすぎる場合、recvmsg（）が呼び出される場合、実装はmsg_ctruncを設定する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-3--Ancillary-Data-Object-Macros">
20.3. Ancillary Data Object Macros
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.3. 補助データオブジェクトマクロ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To aid in the manipulation of ancillary data objects, three macros from 4.4BSD are defined by Posix: CMSG_DATA(), CMSG_NXTHDR(), and CMSG_FIRSTHDR(). Before describing these macros, we show the following example of how they might be used with a call to recvmsg().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
補助データオブジェクトの操作を支援するために、4.4BSDの3つのマクロがPOSIXで定義されています：CMSG_DATA（）、CMSG_NXTHDR（）、およびCMSG_FIRSTHDR（）。これらのマクロを説明する前に、recvmsg（）への呼び出しでそれらをどのように使用するかについての次の例を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
struct msghdr msg; struct cmsghdr *cmsgptr;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
struct msghdr msg;struct cmsghdr *cmsgptr;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* fill in msg */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* call recvmsg() */
            for (cmsgptr = CMSG_FIRSTHDR(&amp;msg); cmsgptr != NULL;
           cmsgptr = CMSG_NXTHDR(&amp;msg, cmsgptr)) {
          if (cmsgptr-&gt;cmsg_len == 0) {
              /* Error handling */
           break;
          }
          if (cmsgptr-&gt;cmsg_level == ... &amp;&amp;
              cmsgptr-&gt;cmsg_type == ... ) {
              u_char  *ptr;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              ptr = CMSG_DATA(cmsgptr);
              /* process data pointed to by ptr */
          }
      }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We now describe the three Posix macros, followed by two more that are new with this API: CMSG_SPACE() and CMSG_LEN(). All these macros are defined as a result of including &lt;sys/socket.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、3つのPOSIXマクロについて説明し、その後にこのAPIで新しい2つのcmsg_space（）とcmsg_len（）を説明します。これらのすべてのマクロは、&lt;sys/socket.h&gt;を含める結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-3-1--CMSGFIRSTHDR">
20.3.1. CMSG_FIRSTHDR
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.3.1. CMSG_FIRSTHDR
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct cmsghdr *CMSG_FIRSTHDR(const struct msghdr *mhdr);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSG_FIRSTHDR() returns a pointer to the first cmsghdr structure in the msghdr structure pointed to by mhdr. The macro returns NULL if there is no ancillary data pointed to by the msghdr structure (that is, if either msg_control is NULL or if msg_controllen is less than the size of a cmsghdr structure).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSG_FIRSTHDR（）は、MHDRが指すMSGHDR構造の最初のCMSGHDR構造へのポインターを返します。MSGHDR構造によって指摘された補助データがない場合、マクロはnullを返します（つまり、MSG_CONTROLがnullの場合、またはMSG_CONTROLLENがCMSGHDR構造のサイズよりも小さい場合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One possible implementation could be
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可能な実装が1つある場合があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define CMSG_FIRSTHDR(mhdr) \
          ( (mhdr)-&gt;msg_controllen &gt;= sizeof(struct cmsghdr) ? \
            (struct cmsghdr *)(mhdr)-&gt;msg_control : \
            (struct cmsghdr *)NULL )
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: Most existing implementations do not test the value of msg_controllen, and just return the value of msg_control. The value of msg_controllen must be tested, because if the application asks recvmsg() to return ancillary data, by setting msg_control to point to the application&#39;s buffer and setting msg_controllen to the length of this buffer, the kernel indicates that no ancillary data is available by setting msg_controllen to 0 on return. It is also easier to put this test into this macro, than making the application perform the test.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：ほとんどの既存の実装はMSG_CONTROLLENの値をテストせず、MSG_CONTROLの値を返すだけです。MSG_CONTROLLENの値をテストする必要があります。なぜなら、アプリケーションがMSG_CONTROLを設定することにより、補助データを返すようにアプリケーションがRECVMSG（）を要求する場合、アプリケーションのバッファーとMSG_CONTROLLENをこのバッファーの長さに設定すると、カーネルは、返信時にMSG_CONTROLLENを0に設定することで補助データが利用できないことを示しています。また、このテストをこのマクロに入力する方が、アプリケーションにテストを実行するよりも簡単です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-3-2--CMSGNXTHDR">
20.3.2. CMSG_NXTHDR
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.3.2. CMSG_NXTHDR
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in Section 5.1, CMSG_NXTHDR has been extended to handle a NULL 2nd argument to mean &#34;get the first header&#34;. This provides an alternative way of coding the processing loop shown earlier:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション5.1で説明されているように、CMSG_NXTHDRは、「最初のヘッダーを取得」を意味するヌル2番目の引数を処理するために拡張されています。これにより、前述の処理ループをコーディングする別の方法が提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct msghdr  msg;
      struct cmsghdr  *cmsgptr = NULL;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* fill in msg */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* call recvmsg() */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      while ((cmsgptr = CMSG_NXTHDR(&amp;msg, cmsgptr)) != NULL) {
          if (cmsgptr-&gt;cmsg_len == 0) {
              /* Error handling */
           break;
          }
          if (cmsgptr-&gt;cmsg_level == ... &amp;&amp;
              cmsgptr-&gt;cmsg_type == ... ) {
              u_char  *ptr;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              ptr = CMSG_DATA(cmsgptr);
              /* process data pointed to by ptr */
          }
      }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One possible implementation could be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可能な実装の1つは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define CMSG_NXTHDR(mhdr, cmsg) \
        (((cmsg) == NULL) ? CMSG_FIRSTHDR(mhdr) : \
         (((u_char *)(cmsg) + ALIGN_H((cmsg)-&gt;cmsg_len) \
                            + ALIGN_D(sizeof(struct cmsghdr)) &gt; \
           (u_char *)((mhdr)-&gt;msg_control) + (mhdr)-&gt;msg_controllen) ? \
          (struct cmsghdr *)NULL : \
          (struct cmsghdr *)((u_char *)(cmsg) + \
                                        ALIGN_H((cmsg)-&gt;cmsg_len))))
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The macros ALIGN_H() and ALIGN_D(), which are implementation dependent, round their arguments up to the next even multiple of whatever alignment is required for the start of the cmsghdr structure and the data, respectively. (This is probably a multiple of 4 or 8 bytes.) They are often the same macro in implementations platforms where alignment requirement for header and data is chosen to be identical.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装依存であるMacroS Align_h（）およびAlign_d（）は、それぞれCMSGHDR構造とデータの開始に必要なアライメントの次の倍数まで、それぞれの倍数に至ります。（これはおそらく4バイトまたは8バイトの倍数です。）これらは、ヘッダーのアラインメント要件とデータが同一に選択される実装プラットフォームで同じマクロであることがよくあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-3-3--CMSGDATA">
20.3.3. CMSG_DATA
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.3.3. CMSG_DATA
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      unsigned char *CMSG_DATA(const struct cmsghdr *cmsg);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSG_DATA() returns a pointer to the data (what is called the cmsg_data[] member, even though such a member is not defined in the structure) following a cmsghdr structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSGHDR構造に従って、CMSG_DATA（）はデータへのポインタを返します（そのようなメンバーは構造で定義されていない場合でも、CMSG_DATA []メンバーと呼ばれるもの）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One possible implementation could be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可能な実装の1つは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define CMSG_DATA(cmsg) ( (u_char *)(cmsg) + \
                                ALIGN_D(sizeof(struct cmsghdr)) )
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-3-4--CMSGSPACE">
20.3.4. CMSG_SPACE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.3.4. CMSG_SPACE
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSG_SPACE is new with this API (see Section 5.2). It is used to determine how much space needs to be allocated for an ancillary data item.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSG_SPACEはこのAPIで新しくなっています（セクション5.2を参照）。補助データ項目に割り当てられる必要があるスペースの量を判断するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One possible implementation could be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可能な実装の1つは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define CMSG_SPACE(length) ( ALIGN_D(sizeof(struct cmsghdr)) + \
                                   ALIGN_H(length) )
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-3-5--CMSGLEN">
20.3.5. CMSG_LEN
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.3.5. cmsg_len
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSG_LEN is new with this API (see Section 5.3). It returns the value to store in the cmsg_len member of the cmsghdr structure, taking into account any padding needed to satisfy alignment requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSG_LENはこのAPIで新しくなっています（セクション5.3を参照）。アライメント要件を満たすために必要なパディングを考慮して、CMSGHDR構造のCMSG_LENメンバーに保存する値を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One possible implementation could be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可能な実装の1つは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define CMSG_LEN(length) ( ALIGN_D(sizeof(struct cmsghdr)) + \
                                 length )
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="21--Appendix-B-Examples-Using-the-inet6rthXXX-Functions">
21. Appendix B: Examples Using the inet6_rth_XXX() Functions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21. 付録B：INET6_RTH_XXX（）関数を使用した例
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here we show an example for both sending Routing headers and processing and reversing a received Routing header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここでは、ルーティングヘッダーの送信と受信したルーティングヘッダーの逆転の両方の例を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="21-1--Sending-a-Routing-Header">
21.1. Sending a Routing Header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.1. ルーティングヘッダーの送信
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example of these Routing header functions defined in this document, we go through the function calls for the example on p. 17 of [RFC-2460]. The source is S, the destination is D, and the three intermediate nodes are I1, I2, and I3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントで定義されているこれらのルーティングヘッダー関数の例として、pの例の関数呼び出しを説明します。[RFC-2460]の17。ソースはs、宛先はd、3つの中間ノードはi1、i2、およびi3です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              S -----&gt; I1 -----&gt; I2 -----&gt; I3 -----&gt; D
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      src:    *    S         S         S         S   S
      dst:    D   I1        I2        I3         D   D
      A[1]:  I1   I2        I1        I1        I1  I1
      A[2]:  I2   I3        I3        I2        I2  I2
      A[3]:  I3    D         D         D        I3  I3
      #seg:   3    3         2         1         0   3
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
src and dst are the source and destination IPv6 addresses in the IPv6 header. A[1], A[2], and A[3] are the three addresses in the Routing header. #seg is the Segments Left field in the Routing header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SRCとDSTは、IPv6ヘッダーのソースおよび宛先IPv6アドレスです。a [1]、a [2]、およびa [3]は、ルーティングヘッダーの3つのアドレスです。#Segは、ルーティングヘッダーのセグメント左フィールドです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The six values in the column beneath node S are the values in the Routing header specified by the sending application using sendmsg() of setsockopt(). The function calls by the sender would look like:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Node Sの下の列の6つの値は、SetSockopt（）のsendmsg（）を使用して送信アプリケーションによって指定されたルーティングヘッダーの値です。送信者による関数呼び出しは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      void  *extptr;
      socklen_t   extlen;
      struct msghdr  msg;
      struct cmsghdr  *cmsgptr;
      int   cmsglen;
      struct sockaddr_in6  I1, I2, I3, D;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      extlen = inet6_rth_space(IPV6_RTHDR_TYPE_0, 3);
      cmsglen = CMSG_SPACE(extlen);
      cmsgptr = malloc(cmsglen);
      cmsgptr-&gt;cmsg_len = CMSG_LEN(extlen);
      cmsgptr-&gt;cmsg_level = IPPROTO_IPV6;
      cmsgptr-&gt;cmsg_type = IPV6_RTHDR;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      extptr = CMSG_DATA(cmsgptr);
      extptr = inet6_rth_init(extptr, extlen, IPV6_RTHDR_TYPE_0, 3);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      inet6_rth_add(extptr, &amp;I1.sin6_addr);
      inet6_rth_add(extptr, &amp;I2.sin6_addr);
      inet6_rth_add(extptr, &amp;I3.sin6_addr);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      msg.msg_control = cmsgptr;
      msg.msg_controllen = cmsglen;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* finish filling in msg{}, msg_name = D */
      /* call sendmsg() */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We also assume that the source address for the socket is not specified (i.e., the asterisk in the figure).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、ソケットのソースアドレスが指定されていないと仮定します（つまり、図のアスタリスク）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The four columns of six values that are then shown between the five nodes are the values of the fields in the packet while the packet is in transit between the two nodes. Notice that before the packet is sent by the source node S, the source address is chosen (replacing the asterisk), I1 becomes the destination address of the datagram, the two addresses A[2] and A[3] are &#34;shifted up&#34;, and D is moved to A[3].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5つのノードの間に表示される6つの値の4つの列は、パケットが2つのノード間で輸送されている間に、パケット内のフィールドの値です。パケットがソースノードSによって送信される前に、ソースアドレスが選択され（アスタリスクの置換）、i1がデータグラムの宛先アドレスになり、2つのアドレスA [2]と[3]が「シフトアップ」されることに注意してください。、DはA [3]に移動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The columns of values that are shown beneath the destination node are the values returned by recvmsg(), assuming the application has enabled both the IPV6_RECVPKTINFO and IPV6_RECVRTHDR socket options. The source address is S (contained in the sockaddr_in6 structure pointed to by the msg_name member), the destination address is D (returned as an ancillary data object in an in6_pktinfo structure), and the ancillary data object specifying the Routing header will contain three addresses (I1, I2, and I3). The number of segments in the Routing header is known from the Hdr Ext Len field in the Routing header (a value of 6, indicating 3 addresses).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先ノードの下に表示される値の列は、アプリケーションがIPv6_RecvpktinfoとIPv6_Recvrthdrソケットオプションの両方が有効になっていると仮定して、Recvmsg（）によって返される値です。ソースアドレスはs（MSG_NAMEメンバーが指すsockaddr_in6構造に含まれています）、宛先アドレスはd（in6_pktinfo構造の補助データオブジェクトとして返されます）、ルーティングヘッダーを指定する補助データオブジェクトには3つのアドレスが含まれます。（I1、I2、およびI3）。ルーティングヘッダーのセグメントの数は、ルーティングヘッダーのHDR ext Lenフィールドからわかっています（6の値、3つのアドレスを示しています）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The return value from inet6_rth_segments() will be 3 and inet6_rth_getaddr(0) will return I1, inet6_rth_getaddr(1) will return I2, and inet6_rth_getaddr(2) will return I3,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
INET6_RTH_SEGMENTS（）からの返品値は3で、INET6_RTH_GETADDR（0）はi1、INET6_RTH_GETADDR（1）はI2を返し、INET6_RTH_GETADDR（2）はi3を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the receiving application then calls inet6_rth_reverse(), the order of the three addresses will become I3, I2, and I1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信アプリケーションがinet6_rth_reverse（）を呼び出す場合、3つのアドレスの順序はi3、i2、およびi1になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We can also show what an implementation might store in the ancillary data object as the Routing header is being built by the sending process. If we assume a 32-bit architecture where sizeof(struct cmsghdr) equals 12, with a desired alignment of 4-byte boundaries, then the call to inet6_rth_space(3) returns 68: 12 bytes for the cmsghdr structure and 56 bytes for the Routing header (8 + 3*16).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、送信プロセスによってルーティングヘッダーが構築されているため、補助データオブジェクトに実装が保存されるものを表示することもできます。sizeof（struct cmsghdr）が12に等しい32ビットアーキテクチャが4バイト境界の目的のアライメントであると仮定した場合、inet6_rth_space（3）への呼び出しは、CMSGHDR構造のために68：12バイト、ルーティングの場合は56バイトを返します。ヘッダー（8 3*16）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The call to inet6_rth_init() initializes the ancillary data object to contain a Type 0 Routing header:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inet6_rth_init（）への呼び出しは、補助データオブジェクトを初期化して、タイプ0ルーティングヘッダーを含むようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |       cmsg_len = 20                                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |       cmsg_level = IPPROTO_IPV6                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |       cmsg_type = IPV6_RTHDR                                  |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Next Header  | Hdr Ext Len=6 | Routing Type=0|  Seg Left=0   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                           Reserved                            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first call to inet6_rth_add() adds I1 to the list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inet6_rth_add（）への最初の呼び出しは、i1をリストに追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |       cmsg_len = 36                                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |       cmsg_level = IPPROTO_IPV6                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |       cmsg_type = IPV6_RTHDR                                  |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Next Header  | Hdr Ext Len=6 | Routing Type=0|  Seg Left=1   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                           Reserved                            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      +                                                               +
      |                                                               |
      +                           Address[1] = I1                     +
      |                                                               |
      +                                                               +
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cmsg_len is incremented by 16, and the Segments Left field is incremented by 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSG_LENは16で増分され、左フィールドのセグメントは1で増加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next call to inet6_rth_add() adds I2 to the list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inet6_rth_add（）の次の呼び出しは、i2をリストに追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |       cmsg_len = 52                                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |       cmsg_level = IPPROTO_IPV6                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |       cmsg_type = IPV6_RTHDR                                  |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Next Header  | Hdr Ext Len=6 | Routing Type=0|  Seg Left=2   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                           Reserved                            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      +                                                               +
      |                                                               |
      +                           Address[1] = I1                     +
      |                                                               |
      +                                                               +
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      +                                                               +
      |                                                               |
      +                           Address[2] = I2                     +
      |                                                               |
      +                                                               +
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cmsg_len is incremented by 16, and the Segments Left field is incremented by 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSG_LENは16で増分され、左フィールドのセグメントは1で増加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The last call to inet6_rth_add() adds I3 to the list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inet6_rth_add（）への最後の呼び出しは、i3をリストに追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |       cmsg_len = 68                                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |       cmsg_level = IPPROTO_IPV6                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |       cmsg_type = IPV6_RTHDR                                  |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Next Header  | Hdr Ext Len=6 | Routing Type=0|  Seg Left=3   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                           Reserved                            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      +                                                               +
      |                                                               |
      +                           Address[1] = I1                     +
      |                                                               |
      +                                                               +
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      +                                                               +
      |                                                               |
      +                           Address[2] = I2                     +
      |                                                               |
      +                                                               +
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      +                                                               +
      |                                                               |
      +                           Address[3] = I3                     +
      |                                                               |
      +                                                               +
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cmsg_len is incremented by 16, and the Segments Left field is incremented by 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSG_LENは16で増分され、左フィールドのセグメントは1で増加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="21-2--Receiving-Routing-Headers">
21.2. Receiving Routing Headers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.2. ルーティングヘッダーを受信します
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This example assumes that the application has enabled IPV6_RECVRTHDR socket option. The application prints and reverses a source route and uses that to echo the received data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例では、アプリケーションがIPv6_Recvrthdrソケットオプションを有効にしていることを前提としています。アプリケーションはソースルートを印刷および逆にし、それを使用して受信したデータをエコーします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct sockaddr_in6     addr;
      struct msghdr           msg;
      struct iovec            iov;
      struct cmsghdr          *cmsgptr;
      socklen_t               cmsgspace;
      void                    *extptr;
      int                     extlen;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int                     segments;
      int                     i;
      char                    databuf[8192];
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      segments = 100;        /* Enough */
      extlen = inet6_rth_space(IPV6_RTHDR_TYPE_0, segments);
      cmsgspace = CMSG_SPACE(extlen);
      cmsgptr = malloc(cmsgspace);
      if (cmsgptr == NULL) {
              perror(&#34;malloc&#34;);
              exit(1);
      }
      extptr = CMSG_DATA(cmsgptr);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      msg.msg_control = cmsgptr;
      msg.msg_controllen = cmsgspace;
      msg.msg_name = (struct sockaddr *)&amp;addr;
      msg.msg_namelen = sizeof (addr);
      msg.msg_iov = &amp;iov;
      msg.msg_iovlen = 1;
      iov.iov_base = databuf;
      iov.iov_len = sizeof (databuf);
      msg.msg_flags = 0;
      if (recvmsg(s, &amp;msg, 0) == -1) {
              perror(&#34;recvmsg&#34;);
              return;
      }
      if (msg.msg_controllen != 0 &amp;&amp;
          cmsgptr-&gt;cmsg_level == IPPROTO_IPV6 &amp;&amp;
          cmsgptr-&gt;cmsg_type == IPV6_RTHDR) {
              struct in6_addr *in6;
              char asciiname[INET6_ADDRSTRLEN];
              struct ip6_rthdr *rthdr;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              rthdr = (struct ip6_rthdr *)extptr;
              segments = inet6_rth_segments(extptr);
              printf(&#34;route (%d segments, %d left): &#34;,
                  segments, rthdr-&gt;ip6r_segleft);
              for (i = 0; i &lt; segments; i++) {
                      in6 = inet6_rth_getaddr(extptr, i);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                      if (in6 == NULL)
                              printf(&#34;&lt;NULL&gt; &#34;);
                      else
                              printf(&#34;%s &#34;, inet_ntop(AF_INET6,
                                  (void *)in6-&gt;s6_addr,
                                  asciiname, INET6_ADDRSTRLEN));
              }
              if (inet6_rth_reverse(extptr, extptr) == -1) {
                      printf(&#34;reverse failed&#34;);
                      return;
              }
      }
      iov.iov_base = databuf;
      iov.iov_len = strlen(databuf);
      if (sendmsg(s, &amp;msg, 0) == -1)
              perror(&#34;sendmsg&#34;);
      if (cmsgptr != NULL)
              free(cmsgptr);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: The above example is a simple illustration. It skips some error checks, including those involving the MSG_TRUNC and MSG_CTRUNC flags. It also leaves some type mismatches in favor of brevity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：上記の例は簡単なイラストです。MSG_TRUNCおよびMSG_CTRUNCフラグを含むエラーチェックをスキップします。また、いくつかのタイプの不一致を簡潔にしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22--Appendix-C-Examples-Using-the-inet6optXXX-Functions">
22. Appendix C: Examples Using the inet6_opt_XXX() Functions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22. 付録C：INET6_OPT_XXX（）関数を使用した例
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This shows how Hop-by-Hop and Destination options can be both built as well as parsed using the inet6_opt_XXX() functions. These examples assume that there are defined values for OPT_X and OPT_Y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、INET6_OPT_XXX（）関数を使用して、ホップバイホップと目的地のオプションをどのように構築し、解析できるかを示しています。これらの例は、opt_xとopt_yに定義された値があることを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: The example is a simple illustration. It skips some error checks and leaves some type mismatches in favor of brevity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：例は簡単なイラストです。いくつかのエラーチェックをスキップし、いくつかのタイプの不一致を簡潔にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-1--Building-Options">
22.1. Building Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.1. 構築オプション
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We now provide an example that builds two Hop-by-Hop options using the example in Appendix B of [RFC-2460].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC-2460]の付録Bの例を使用して、2つのホップバイホップオプションを構築する例を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      void *extbuf;
      socklen_t extlen;
      int currentlen;
      void *databuf;
      int offset;
      uint8_t value1;
      uint16_t value2;
      uint32_t value4;
      uint64_t value8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* Estimate the length */
            currentlen = inet6_opt_init(NULL, 0);
      if (currentlen == -1)
              return (-1);
      currentlen = inet6_opt_append(NULL, 0, currentlen, OPT_X,
                                    12, 8, NULL);
      if (currentlen == -1)
              return (-1);
      currentlen = inet6_opt_append(NULL, 0, currentlen, OPT_Y,
                                    7, 4, NULL);
      if (currentlen == -1)
              return (-1);
      currentlen = inet6_opt_finish(NULL, 0, currentlen);
      if (currentlen == -1)
              return (-1);
      extlen = currentlen;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      extbuf = malloc(extlen);
      if (extbuf == NULL) {
              perror(&#34;malloc&#34;);
              return (-1);
      }
      currentlen = inet6_opt_init(extbuf, extlen);
      if (currentlen == -1)
              return (-1);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      currentlen = inet6_opt_append(extbuf, extlen, currentlen,
          OPT_X, 12, 8, &amp;databuf);
      if (currentlen == -1)
              return (-1);
      /* Insert value 0x12345678 for 4-octet field */
      offset = 0;
      value4 = 0x12345678;
      offset = inet6_opt_set_val(databuf, offset,
                                 &amp;value4, sizeof (value4));
      /* Insert value 0x0102030405060708 for 8-octet field */
      value8 = 0x0102030405060708;
      offset = inet6_opt_set_val(databuf, offset,
                                 &amp;value8, sizeof (value8));
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      currentlen = inet6_opt_append(extbuf, extlen, currentlen,
          OPT_Y, 7, 4, &amp;databuf);
      if (currentlen == -1)
              return (-1);
      /* Insert value 0x01 for 1-octet field */
      offset = 0;
      value1 = 0x01;
      offset = inet6_opt_set_val(databuf, offset,
                                 &amp;value1, sizeof (value1));
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* Insert value 0x1331 for 2-octet field */
      value2 = 0x1331;
      offset = inet6_opt_set_val(databuf, offset,
                                 &amp;value2, sizeof (value2));
      /* Insert value 0x01020304 for 4-octet field */
      value4 = 0x01020304;
      offset = inet6_opt_set_val(databuf, offset,
                                 &amp;value4, sizeof (value4));
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      currentlen = inet6_opt_finish(extbuf, extlen, currentlen);
      if (currentlen == -1)
              return (-1);
      /* extbuf and extlen are now completely formatted */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-2--Parsing-Received-Options">
22.2. Parsing Received Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.2. 受信したオプションを解析します
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This example parses and prints the content of the two options in the previous example.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例は、前の例で2つのオプションのコンテンツを解析および印刷します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int
      print_opt(void *extbuf, socklen_t extlen)
      {
              struct ip6_dest *ext;
              int currentlen;
              uint8_t type;
              socklen_t len;
              void *databuf;
              int offset;
              uint8_t value1;
              uint16_t value2;
              uint32_t value4;
              uint64_t value8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              ext = (struct ip6_dest *)extbuf;
              printf(&#34;nxt %u, len %u (bytes %d)\n&#34;, ext-&gt;ip6d_nxt,
                  ext-&gt;ip6d_len, (ext-&gt;ip6d_len + 1) * 8);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              currentlen = 0;
              while (1) {
                      currentlen = inet6_opt_next(extbuf, extlen,
                                                  currentlen, &amp;type,
                                                  &amp;len, &amp;databuf);
                      if (currentlen == -1)
                              break;
                      printf(&#34;Received opt %u len %u\n&#34;,
                          type, len);
                      switch (type) {
                      case OPT_X:
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                              offset = 0;
                              offset =
                                  inet6_opt_get_val(databuf, offset,
                                                    &amp;value4,
                                                    sizeof (value4));
                              printf(&#34;X 4-byte field %x\n&#34;, value4);
                              offset =
                                  inet6_opt_get_val(databuf, offset,
                                                    &amp;value8,
                                                    sizeof (value8));
                              printf(&#34;X 8-byte field %llx\n&#34;, value8);
                              break;
                      case OPT_Y:
                              offset = 0;
                              offset =
                                  inet6_opt_get_val(databuf, offset,
                                                    &amp;value1,
                                                    sizeof (value1));
                              printf(&#34;Y 1-byte field %x\n&#34;, value1);
                              offset =
                                  inet6_opt_get_val(databuf, offset,
                                                    &amp;value2,
                                                    sizeof (value2));
                              printf(&#34;Y 2-byte field %x\n&#34;, value2);
                              offset =
                                  inet6_opt_get_val(databuf, offset,
                                                    &amp;value4,
                                                    sizeof (value4));
                              printf(&#34;Y 4-byte field %x\n&#34;, value4);
                              break;
                      default:
                              printf(&#34;Unknown option %u\n&#34;, type);
                              break;
                      }
              }
              return (0);
      }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="23--Authors-Addresses">
23. Authors&#39; Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
23. 著者のアドレス
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
W. Richard Stevens (deceased)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
W.リチャードスティーブンス（故人）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Matt Thomas 3am Software Foundry 8053 Park Villa Circle Cupertino, CA 95014
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Matt Thomas 3am Software Foundry 8053 Park Villa Circle Cupertino、CA 95014
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: matt@3am-software.com
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Erik Nordmark Sun Microsystems Laboratories, Europe 180, avenue de l&#39;Europe 38334 SAINT ISMIER Cedex, France
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Erik Nordmark Sun Microsystems Laboratories、Europe 180、Avenue de L&#39;Europe 38334 Saint Ismier Cedex、フランス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +33 (0)4 74 18 88 03
   Fax:   +33 (0)4 76 18 88 88
   EMail: Erik.Nordmark@sun.com
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tatuya JINMEI Corporate Research &amp; Development Center, Toshiba Corporation 1 Komukai Toshiba-cho, Kawasaki-shi Kanagawa 212-8582, Japan
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tatuya Jinmei Corporate Research＆Development Center、Toshiba Corporation 1 Komukai Toshiba-Cho、川崎-Shi Kanagawa 212-8582、日本
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: jinmei@isl.rdc.toshiba.co.jp
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="24--Full-Copyright-Statement">
24. Full Copyright Statement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
24. 完全な著作権声明
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2003). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）The Internet Society（2003）。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書と本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFCエディター機能の資金は現在、インターネット協会によって提供されています。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
