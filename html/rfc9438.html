<!DOCTYPE html>


<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 9438 - CUBIC for Fast and Long-Distance Networks 日本語訳</title>

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">9438</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc9438">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 9438 - CUBIC for Fast and Long-Distance Networks 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc9438">
            https://datatracker.ietf.org/doc/html/rfc9438
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 9438 - 高速および長距離ネットワーク用の立方体</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                             L. Xu
Request for Comments: 9438                                           UNL
Obsoletes: 8312                                                    S. Ha
Updates: 5681                                                   Colorado
Category: Standards Track                                        I. Rhee
ISSN: 2070-1721                                                   Bowery
                                                                 V. Goel
                                                              Apple Inc.
                                                          L. Eggert, Ed.
                                                                  NetApp
                                                             August 2023
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
CUBIC for Fast and Long-Distance Networks
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
高速および長距離ネットワーク用の立方体
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CUBIC is a standard TCP congestion control algorithm that uses a cubic function instead of a linear congestion window increase function to improve scalability and stability over fast and long-distance networks. CUBIC has been adopted as the default TCP congestion control algorithm by the Linux, Windows, and Apple stacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicは、線形輻輳ウィンドウの増加関数の代わりに立方機能を使用して、高速および長距離ネットワーク上のスケーラビリティと安定性を改善する標準のTCP混雑制御アルゴリズムです。Cubicは、Linux、Windows、およびAppleスタックによってデフォルトのTCP輻輳制御アルゴリズムとして採用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document updates the specification of CUBIC to include algorithmic improvements based on these implementations and recent academic work. Based on the extensive deployment experience with CUBIC, this document also moves the specification to the Standards Track and obsoletes RFC 8312. This document also updates RFC 5681, to allow for CUBIC&#39;s occasionally more aggressive sending behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、これらの実装と最近の学術作業に基づいてアルゴリズムの改善を含めるように、立方体の仕様を更新します。Cubicでの広範な展開エクスペリエンスに基づいて、このドキュメントは仕様を標準トラックおよび廃止RFC 8312に移動します。このドキュメントは、RFC 5681を更新して、Cubicのより積極的な送信動作を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、インターネット標準トラックドキュメントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 7841のセクション2で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9438.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https：//www.rfc-editor.org/info/rfc9438で取得できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2023 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（c）2023 IETF Trustおよび文書著者として特定された人。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、改訂されたBSDライセンスで説明されている保証なしで提供されるように、改訂されたBSDライセンステキストを含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction
   2.  Conventions
   3.  Design Principles of CUBIC
     3.1.  Principle 1 for the CUBIC Increase Function
     3.2.  Principle 2 for Reno-Friendliness
     3.3.  Principle 3 for RTT-Fairness
     3.4.  Principle 4 for the CUBIC Decrease Factor
   4.  CUBIC Congestion Control
     4.1.  Definitions
       4.1.1.  Constants of Interest
       4.1.2.  Variables of Interest
     4.2.  Window Increase Function
     4.3.  Reno-Friendly Region
     4.4.  Concave Region
     4.5.  Convex Region
     4.6.  Multiplicative Decrease
     4.7.  Fast Convergence
     4.8.  Timeout
     4.9.  Spurious Congestion Events
       4.9.1.  Spurious Timeouts
       4.9.2.  Spurious Fast Retransmits
     4.10. Slow Start
   5.  Discussion
     5.1.  Fairness to Reno
     5.2.  Using Spare Capacity
     5.3.  Difficult Environments
     5.4.  Investigating a Range of Environments
     5.5.  Protection against Congestion Collapse
     5.6.  Fairness within the Alternative Congestion Control
            Algorithm
     5.7.  Performance with Misbehaving Nodes and Outside Attackers
     5.8.  Behavior for Application-Limited Flows
     5.9.  Responses to Sudden or Transient Events
     5.10. Incremental Deployment
   6.  Security Considerations
   7.  IANA Considerations
   8.  References
     8.1.  Normative References
     8.2.  Informative References
   Appendix A.  Evolution of CUBIC since the Original Paper
   Appendix B.  Proof of the Average CUBIC Window Size
   Acknowledgments
   Authors&#39; Addresses
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CUBIC has been adopted as the default TCP congestion control algorithm in the Linux, Windows, and Apple stacks, and has been used and deployed globally. Extensive, decade-long deployment experience in vastly different Internet scenarios has convincingly demonstrated that CUBIC is safe for deployment on the global Internet and delivers substantial benefits over classical Reno congestion control [RFC5681]. It is therefore to be regarded as the currently most widely deployed standard for TCP congestion control. CUBIC can also be used for other transport protocols such as QUIC [RFC9000] and the Stream Control Transmission Protocol (SCTP) [RFC9260] as a default congestion controller.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicは、Linux、Windows、およびAppleスタックのデフォルトのTCP輻輳制御アルゴリズムとして採用されており、グローバルに使用および展開されています。非常に異なるインターネットシナリオでの広範な10年にわたる展開の経験は、Cubicがグローバルなインターネット上の展開に安全であり、古典的なリノ輻輳制御に大きな利益をもたらすことを説得力を持って実証しました[RFC5681]。したがって、現在最も広く展開されているTCP輻輳制御の基準と見なされるべきです。Cubicは、QUIC [RFC9000]やストリームコントロール伝送プロトコル（SCTP）[RFC9260]などの他の輸送プロトコルにデフォルトの混雑コントローラーとして使用することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The design of CUBIC was motivated by the well-documented problem classical Reno TCP has with low utilization over fast and long-distance networks [K03] [RFC3649]. This problem arises from a slow increase of the congestion window (cwnd) following a congestion event in a network with a large bandwidth-delay product (BDP). [HLRX07] indicates that this problem is frequently observed even in the range of congestion window sizes over several hundreds of packets. This problem is equally applicable to all Reno-style standards and their variants, including TCP-Reno [RFC5681], TCP-NewReno [RFC6582] [RFC6675], SCTP [RFC9260], TCP Friendly Rate Control (TFRC) [RFC5348], and QUIC congestion control [RFC9002], which use the same linear increase function for window growth. All Reno-style standards and their variants are collectively referred to as &#34;Reno&#34; in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicの設計は、高速および長距離ネットワークよりも使用されているクラシックリノTCPが十分に文書化された問題に動機付けられました[K03] [RFC3649]。この問題は、大きな帯域幅遅延製品（BDP）を備えたネットワークでの輻輳イベントに続いて、混雑ウィンドウ（CWND）のゆっくりとした増加から生じます。[HLRX07]は、この問題が数百のパケットにわたって輻輳ウィンドウサイズの範囲でさえ頻繁に観察されることを示しています。この問題は、TCP-RENO [RFC5681]、TCP-Newreno [RFC6582] [RFC6675]、SCTP [RFC9260]、TCPフレンドリーレートコントロール（TFRC）[RFC5348]、および[RFC5348]、など、すべてのリノスタイルの標準とそのバリエーションに等しく当てはまります。QUIC混雑制御[RFC9002]。これは、ウィンドウの成長に同じ線形増加関数を使用します。すべてのリノスタイルの標準とそのバリアントは、このドキュメントの「リノ」と総称されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CUBIC, originally proposed in [HRX08], is a modification to the congestion control algorithm of classical Reno to remedy this problem. Specifically, CUBIC uses a cubic function instead of the linear window increase function of Reno to improve scalability and stability under fast and long-distance networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もともと[HRX08]で提案されていたCubicは、この問題を改善するための古典的なRENOの輻輳制御アルゴリズムの変更です。具体的には、CubicはRENOの線形ウィンドウ増加関数の代わりに立方機能を使用して、高速および長距離ネットワークの下でのスケーラビリティと安定性を改善します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document updates the specification of CUBIC to include algorithmic improvements based on the Linux, Windows, and Apple implementations and recent academic work. Based on the extensive deployment experience with CUBIC, it also moves the specification to the Standards Track, obsoleting [RFC8312]. This requires an update to Section 3 of [RFC5681], which limits the aggressiveness of Reno TCP implementations. Since CUBIC is occasionally more aggressive than the algorithms defined in [RFC5681], this document updates the first paragraph of Section 3 of [RFC5681], replacing it with a normative reference to guideline (1) in Section 3 of [RFC5033], which allows for CUBIC&#39;s behavior as defined in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、Linux、Windows、およびAppleの実装と最近の学術作業に基づいたアルゴリズムの改善を含めるように、Cubicの仕様を更新します。Cubicでの広範な展開エクスペリエンスに基づいて、仕様を標準トラック、廃止[RFC8312]に移動します。これには、[RFC5681]のセクション3の更新が必要であり、Reno TCP実装の攻撃性を制限します。Cubicは[RFC5681]で定義されているアルゴリズムよりも攻撃的であることがあるため、このドキュメントは[RFC5681]のセクション3の最初の段落を更新し、[RFC5033]のセクション3のガイドライン（1）への規範的参照に置き換えます。このドキュメントで定義されているCubicの動作について。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specifically, CUBIC may increase the congestion window more aggressively than Reno during the congestion avoidance phase. According to [RFC5681], during congestion avoidance, the sender must not increment cwnd by more than Sender Maximum Segment Size (SMSS) bytes once per round-trip time (RTT), whereas CUBIC may increase cwnd much more aggressively. Additionally, CUBIC recommends the HyStart++ algorithm [RFC9406] for slow start, which allows for cwnd increases of more than SMSS bytes for incoming acknowledgments during slow start, while this behavior is not allowed as part of the standard behavior prescribed by [RFC5681].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具体的には、CUBICは、混雑回避段階で、RENOよりも誤って輻輳窓を増やす可能性があります。[RFC5681]によれば、輻輳回避中に、送信者は、往復時間（RTT）に1回送信者の最大セグメントサイズ（SMS）バイト以上のCWNDを増加させてはなりませんが、CUBICはCWNDをはるかに攻撃的に増加させる可能性があります。さらに、Cubicは、スロースタートのためにHystartアルゴリズム[RFC9406]を推奨します。これにより、スロースタート中に着信するためにSMSSを超えるCWNDの増加が可能になりますが、この動作は[RFC5681]によって規定されている標準的な動作の一部として許可されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Binary Increase Congestion Control (BIC-TCP) [XHR04], a predecessor of CUBIC, was selected as the default TCP congestion control algorithm by Linux in the year 2005 and had been used for several years by the Internet community at large.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicの前身であるBINARY増加渋滞制御（BIC-TCP）[XHR04]は、2005年にLinuxによってデフォルトのTCP混雑制御アルゴリズムとして選択され、インターネットコミュニティ全体で数年間使用されていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CUBIC uses a window increase function similar to BIC-TCP and is designed to be less aggressive and fairer to Reno in bandwidth usage than BIC-TCP while maintaining the strengths of BIC-TCP such as stability, window scalability, and RTT-fairness.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicは、BIC-TCPと同様のウィンドウ増加関数を使用し、安定性、窓のスケーラビリティ、RTTフェアネスなどのBIC-TCPの強度を維持しながら、BIC-TCPよりも帯域幅の使用において積極的で公平ではないように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5033] documents the IETF&#39;s best current practices for specifying new congestion control algorithms, specifically those that differ from the general congestion control principles outlined in [RFC2914]. It describes what type of evaluation is expected by the IETF to understand the suitability of a new congestion control algorithm and the process of enabling a specification to be approved for widespread deployment in the global Internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5033]は、[RFC2914]で概説されている一般的な輻輳制御原則とは異なる新しい混雑制御アルゴリズムを指定するためのIETFの最良の現在のプラクティスを文書化しています。これは、新しい輻輳制御アルゴリズムの適合性と、グローバルなインターネットでの広範な展開の仕様を承認できるようにするプロセスを理解するために、IETFがどのようなタイプの評価が予想されるかを説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are areas in which CUBIC differs from the congestion control algorithms previously published in Standards Track RFCs; those changes are specified in this document. However, it is not obvious that these changes go beyond the general congestion control principles outlined in [RFC2914], so the process documented in [RFC5033] may not apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Standards Track RFCSで以前に公開されていた輻輳制御アルゴリズムと立方体が異なる領域があります。これらの変更は、このドキュメントで指定されています。ただし、これらの変更が[RFC2914]で概説されている一般的な渋滞制御原則を超えていることは明らかではないため、[RFC5033]で文書化されたプロセスは適用されない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Also, the wide deployment of CUBIC on the Internet was driven by direct adoption in most of the popular operating systems and did not follow the practices documented in [RFC5033]. However, due to the resulting Internet-scale deployment experience over a long period of time, the IETF determined that CUBIC could be published as a Standards Track specification. This decision by the IETF does not alter the general guidance provided in [RFC2914].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、インターネット上のCubicの幅広い展開は、ほとんどの人気のあるオペレーティングシステムでの直接採用によって推進され、[RFC5033]で文書化された慣行に従いませんでした。ただし、結果として生じるインターネットスケールの展開エクスペリエンスが長期間にわたって展開されているため、IETFは、Cubicを標準の追跡仕様として公開できると判断しました。IETFによるこの決定は、[RFC2914]で提供される一般的なガイダンスを変更しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following sections
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のセクション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. briefly explain the design principles of CUBIC,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 立方体のデザイン原則を簡単に説明してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. provide the exact specification of CUBIC, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 立方体の正確な仕様を提供します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. discuss the safety features of CUBIC, following the guidelines specified in [RFC5033].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. [RFC5033]で指定されたガイドラインに従って、立方体の安全性について話し合います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Conventions">
2. Conventions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 規約
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, および &#34;OPTIONAL&#34; はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Design-Principles-of-CUBIC">
3. Design Principles of CUBIC
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 立方体のデザイン原則
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CUBIC is designed according to the following design principles:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicは、次の設計原則に従って設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Principle 1: For better network utilization and stability, CUBIC uses both the concave and convex profiles of a cubic function to increase the congestion window size, instead of using just a convex function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
原則1：ネットワークの利用と安定性を向上させるために、Cubicは、凸関数のみを使用するのではなく、Cubic関数の凹面プロファイルと凸プロファイルの両方を使用して、うっ血ウィンドウサイズを増やします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Principle 2: To be Reno-friendly, CUBIC is designed to behave like Reno in networks with short RTTs and small bandwidth where Reno performs well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
原則2：リノにやさしいため、Cubicは、短いRTTとリノがうまく機能する小さな帯域幅を備えたネットワークでリノのように振る舞うように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Principle 3: For RTT-fairness, CUBIC is designed to achieve linear bandwidth sharing among flows with different RTTs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
原則3：RTT-Fairnessの場合、Cubicは、異なるRTTを使用したフロー間の線形帯域幅共有を実現するように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Principle 4: CUBIC appropriately sets its multiplicative window decrease factor in order to achieve a balance between scalability and convergence speed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
原則4：Cubicは、スケーラビリティと収束速度のバランスをとるために、乗算ウィンドウの減少係数を適切に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--Principle-1-for-the-CUBIC-Increase-Function">
3.1. Principle 1 for the CUBIC Increase Function
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. キュービック増加関数の原則1
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For better network utilization and stability, CUBIC [HRX08] uses a cubic window increase function in terms of the elapsed time from the last congestion event. While most congestion control algorithms that provide alternatives to Reno increase the congestion window using convex functions, CUBIC uses both the concave and convex profiles of a cubic function for window growth.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークの利用と安定性を向上させるために、Cubic [HRX08]は、最後の輻輳イベントからの経過時間の観点から、立方窓増加関数を使用します。RENOの代替を提供するほとんどの輻輳制御アルゴリズムは、凸関数を使用して輻輳ウィンドウを増加させますが、Cubicは、窓の成長のために立方機能の凹面および凸プロファイルの両方を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After a window reduction in response to a congestion event detected by duplicate acknowledgments (ACKs), Explicit Congestion Notification-Echo (ECN-Echo (ECE)) ACKs [RFC3168], RACK-TLP for TCP [RFC8985], or QUIC loss detection [RFC9002], CUBIC remembers the congestion window size at which it received the congestion event and performs a multiplicative decrease of the congestion window. When CUBIC enters into congestion avoidance, it starts to increase the congestion window using the concave profile of the cubic function. The cubic function is set to have its plateau at the remembered congestion window size, so that the concave window increase continues until then. After that, the cubic function turns into a convex profile and the convex window increase begins.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重複謝辞（ACK）、明示的な混雑通知-エコー（ECN-エコー（ECE））ACKS [RFC3168]、TCP [RFC8985]のRACK-TLP、またはQUIC損失の検出によって検出された鬱血イベントに応答したウィンドウが減少した後、RFC9002]、Cubicは、混雑イベントを受け取った混雑ウィンドウサイズを覚えており、混雑ウィンドウの多重な減少を実行します。キュービックが混雑の回避に入ると、立方機能の凹面プロファイルを使用してうっ血ウィンドウを増やし始めます。立方体関数は、記憶されている混雑ウィンドウサイズにプラトーを置くように設定されているため、凹面の窓の増加はそれまで続きます。その後、立方体関数が凸のプロファイルに変わり、凸面のウィンドウの増加が始まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This style of window adjustment (concave and then convex) improves algorithm stability while maintaining high network utilization [CEHRX09]. This is because the window size remains almost constant, forming a plateau around the remembered congestion window size of the last congestion event, where network utilization is deemed highest. Under steady state, most window size samples of CUBIC are close to that remembered congestion window size, thus promoting high network utilization and stability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このスタイルのウィンドウ調整（凹面と凸）は、高いネットワーク利用を維持しながらアルゴリズムの安定性を向上させます[CEHRX09]。これは、ウィンドウサイズがほぼ一定のままであり、ネットワークの利用が最も高く見なされる最後の渋滞イベントの記憶されている輻輳ウィンドウサイズの周りにプラトーを形成するためです。定常状態では、Cubicのほとんどのウィンドウサイズのサンプルは、記憶されている混雑ウィンドウサイズに近いため、高いネットワークの利用と安定性を促進します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that congestion control algorithms that only use convex functions to increase the congestion window size have their maximum increments around the remembered congestion window size of the last congestion event and thus introduce many packet bursts around the saturation point of the network, likely causing frequent global loss synchronizations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
凸型関数のみを使用して渋滞ウィンドウサイズを増やすための渋滞制御アルゴリズムは、最後の輻輳イベントの記憶されている混雑ウィンドウサイズの周りに最大増加し、したがってネットワークの飽和点の周りに多くのパケットバーストを導入し、おそらく世界的な損失を引き起こす可能性が高いことに注意してください。同期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--Principle-2-for-Reno-Friendliness">
3.2. Principle 2 for Reno-Friendliness
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. リノフレンドリーの原則2
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CUBIC promotes per-flow fairness to Reno. Note that Reno performs well over paths with small BDPs and only experiences problems when attempting to increase bandwidth utilization on paths with large BDPs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicは、フローごとの公平性をリノに促進します。Renoは、小さなBDPでパスでよく実行され、大きなBDPのパスで帯域幅の利用を増やそうとする場合にのみ問題が発生していることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A congestion control algorithm designed to be friendly to Reno on a per-flow basis must increase its congestion window less aggressively in small-BDP networks than in large-BDP networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローごとにリノに友好的になるように設計された輻輳制御アルゴリズムは、大型BDPネットワークよりも小型BDPネットワークで積極的に誤って増加する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The aggressiveness of CUBIC mainly depends on the maximum window size before a window reduction, which is smaller in small-BDP networks than in large-BDP networks. Thus, CUBIC increases its congestion window less aggressively in small-BDP networks than in large-BDP networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キュービックの攻撃性は、主にウィンドウ削減前の最大ウィンドウサイズに依存します。これは、大型BDPネットワークよりも小型ネットワークでは小さくなります。したがって、Cubicは、大型BDPネットワークよりも、小型BDPネットワークで誤って誤って増加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Furthermore, in cases when the cubic function of CUBIC would increase the congestion window less aggressively than Reno, CUBIC simply follows the window size of Reno to ensure that CUBIC achieves at least the same throughput as Reno in small-BDP networks. The region where CUBIC behaves like Reno is called the &#34;Reno-friendly region&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、キュービックの立方機能がリノよりも積極的に誤った窓を増やす場合、キュービックは単にリノのウィンドウサイズに従い、キュービックが小型bdpネットワークでリノと少なくとも同じスループットを達成することを保証します。キュービックがリノのように振る舞う地域は、「リノに優しい地域」と呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3--Principle-3-for-RTT-Fairness">
3.3. Principle 3 for RTT-Fairness
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. RTT-Fairnessの原則3
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two CUBIC flows with different RTTs have a throughput ratio that is linearly proportional to the inverse of their RTT ratio, where the throughput of a flow is approximately the size of its congestion window divided by its RTT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
異なるRTTを持つ2つのキュービックフローには、RTT比の逆に直線的に比例するスループット比があり、流れのスループットは渋滞ウィンドウのサイズをRTTで割ったものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specifically, CUBIC maintains a window increase rate that is independent of RTTs outside the Reno-friendly region, and thus flows with different RTTs have similar congestion window sizes under steady state when they operate outside the Reno-friendly region.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具体的には、Cubicは、リノフレンドリーな地域以外のRTTとは独立したウィンドウの増加率を維持しているため、異なるRTTの流れは、リノに優しい地域の外側で動作する場合、定常状態の下で同様のうっ血窓サイズを持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This notion of a linear throughput ratio is similar to that of Reno under an asynchronous loss model, where flows with different RTTs have the same packet loss rate but experience loss events at different times. However, under a synchronous loss model, where flows with different RTTs experience loss events at the same time but have different packet loss rates, the throughput ratio of Reno flows with different RTTs is quadratically proportional to the inverse of their RTT ratio [XHR04].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この線形スループット比のこの概念は、異なるRTTを持つフローが同じパケット損失率を持っているが、異なる時期に発生した経験を持つ非同期損失モデルの下でのRenoの概念と類似しています。ただし、異なるRTTSを持つフローが同時に損失イベントを経験するが、パケット損失率が異なる同期損失モデルでは、RENOフローのスループット比は異なるRTTSのスループット比がRTT比の逆に2次的に比例します[XHR04]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CUBIC always ensures a linear throughput ratio that is independent of the loss environment. This is an improvement over Reno. While there is no consensus on the optimal throughput ratio for different RTT flows, over wired Internet paths, use of a linear throughput ratio seems more reasonable than equal throughputs (i.e., the same throughput for flows with different RTTs) or a higher-order throughput ratio (e.g., a quadratic throughput ratio of Reno in synchronous loss environments).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicは、常に損失環境とは無関係の線形スループット比を保証します。これはリノの改善です。さまざまなRTTフローの最適なスループット比にコンセンサスはありませんが、有線インターネットパスでは、線形スループット比の使用が等しいスループット（つまり、異なるRTTのフローの場合と同じスループット）または高次のスループットのスループットよりも合理的であると思われます。比率（例えば、同期損失環境におけるリノの二次スループット比）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-4--Principle-4-for-the-CUBIC-Decrease-Factor">
3.4. Principle 4 for the CUBIC Decrease Factor
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. キュービック減少係数の原則4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To achieve a balance between scalability and convergence speed, CUBIC sets the multiplicative window decrease factor to 0.7, whereas Reno uses 0.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スケーラビリティと収束速度のバランスをとるために、Cubicは乗算ウィンドウの減少係数を0.7に設定しますが、Renoは0.5を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While this improves the scalability of CUBIC, a side effect of this decision is slower convergence, especially under low statistical multiplexing. This design choice is following the observation that HighSpeed TCP (HSTCP) [RFC3649] and other approaches (e.g., [GV02]) made: the current Internet becomes more asynchronous with less frequent loss synchronizations under high statistical multiplexing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これによりキュービックのスケーラビリティが向上しますが、この決定の副作用は、特に低い統計的多重化の下での収束が遅いことです。この設計の選択は、高速TCP（HSTCP）[RFC3649]およびその他のアプローチ（例えば[GV02]）が作成したという観察に続いています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In such environments, even strict Multiplicative-Increase Multiplicative-Decrease (MIMD) can converge. CUBIC flows with the same RTT always converge to the same throughput independently of statistical multiplexing, thus achieving intra-algorithm fairness. In environments with sufficient statistical multiplexing, the convergence speed of CUBIC is reasonable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのような環境では、厳密な乗算増れた乗算 - 抑制（MIMD）でさえ収束することができます。同じRTTを備えた立方体の流れは、常に統計的多重化とは無関係に同じスループットに収束し、したがって、アルゴリズム内の公平性を達成します。十分な統計的多重化を伴う環境では、Cubicの収束速度が合理的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--CUBIC-Congestion-Control">
4. CUBIC Congestion Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 立方輻輳制御
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section discusses how the congestion window is updated during the different stages of the CUBIC congestion controller.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、立方輻輳コントローラーのさまざまな段階で輻輳ウィンドウがどのように更新されるかについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--Definitions">
4.1. Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The unit of all window sizes in this document is segments of the SMSS, and the unit of all times is seconds. Implementations can use bytes to express window sizes, which would require factoring in the SMSS wherever necessary and replacing _segments_acked_ (Figure 4) with the number of acknowledged bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントのすべてのウィンドウサイズのユニットは、SMSSのセグメントであり、史上最高のユニットは秒です。実装では、バイトを使用してウィンドウサイズを表現できます。これにより、必要に応じてSMSSで因数分解し、_segments_acked_（図4）を認められたバイトの数に置き換える必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1-1--Constants-of-Interest">
4.1.1. Constants of Interest
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. 関心のある定数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* __cubic_: CUBIC multiplicative decrease factor as described in Section 4.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* __CUBIC_：セクション4.6で説明されている立方体倍数減少係数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* __cubic_: CUBIC additive increase factor used in the Reno-friendly region as described in Section 4.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* __CUBIC_：セクション4.3で説明されているように、リノに優しい地域で使用される立方添加剤増加係数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _C_: Constant that determines the aggressiveness of CUBIC in competing with other congestion control algorithms in high-BDP networks. Please see Section 5 for more explanation on how it is set. The unit for _C_ is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _C_：高BDPネットワークで他の輻輳制御アルゴリズムと競合する際にキュービックの攻撃性を決定する定数。設定方法の詳細については、セクション5を参照してください。_c_のユニットはです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
segment 3 second
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
セグメント3秒
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1-2--Variables-of-Interest">
4.1.2. Variables of Interest
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. 関心のある変数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section defines the variables required to implement CUBIC:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、Cubicを実装するために必要な変数を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _RTT_: Smoothed round-trip time in seconds, calculated as described in [RFC6298].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _RTT_：[RFC6298]で説明されているように計算された秒単位で滑らかな往復時間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _cwnd_: Current congestion window in segments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _CWND_：セグメントの現在の混雑ウィンドウ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _ssthresh_: Current slow start threshold in segments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _SSTHRESH _：セグメントの現在のスロースタートしきい値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _cwnd_prior_: Size of _cwnd_ in segments at the time of setting _ssthresh_ most recently, either upon exiting the first slow start or just before _cwnd_ was reduced in the last congestion event.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _CWND_PRIOR_：最初のスロースタートを終了したときに_SSTHRESH_設定時のセグメントの_CWND_のサイズ、または_CWND_が最後の渋滞イベントで削減された直前。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _W_max_: Size of _cwnd_ in segments just before _cwnd_ was reduced in the last congestion event when fast convergence is disabled (same as _cwnd_prior_ on a congestion event). However, if fast convergence is enabled, _W_max_ may be further reduced based on the current saturation point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _W_MAX_：_CWND_の直前のセグメントの_CWND_のサイズは、速い収束が無効になっている前回の混雑イベントで削減されました（渋滞イベントで_CWND_PRIOR_と同じ）。ただし、高速収束が有効になっている場合、_W_MAX_は現在の飽和点に基づいてさらに削減される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _K_: The time period in seconds it takes to increase the congestion window size at the beginning of the current congestion avoidance stage to _W_max_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _K_：現在の輻輳回避段階の開始時に_W_MAX_に浸漬ウィンドウサイズを増やすのにかかる秒の期間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _t_current_: Current time of the system in seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _T_CURRENT_：システムの現在の時間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _t_epoch_: The time in seconds at which the current congestion avoidance stage started.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _T_EPOCH_：現在の混雑回避段階が始まる秒単位の時間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _cwnd_epoch_: The _cwnd_ at the beginning of the current congestion avoidance stage, i.e., at time _t_epoch_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _CWND_EPOCH_：現在の混雑回避段階の開始時の_CWND_、つまり時間_T_EPOCH_
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* W_cubic(_t_): The congestion window in segments at time _t_ in seconds based on the cubic increase function, as described in Section 4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* W_CUBIC（_T_）：セクション4.2で説明されているように、立方体増加関数に基づいて、秒単位のセグメントの輻輳ウィンドウ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _target_: Target value of the congestion window in segments after the next RTT -- that is, W_cubic(_t_ + _RTT_), as described in Section 4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _target_：セクション4.2で説明されているように、次のRTT、つまりw_cubic（_t_ _rtt_）後のセグメントの輻輳ウィンドウのターゲット値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _W_est_: An estimate for the congestion window in segments in the Reno-friendly region -- that is, an estimate for the congestion window of Reno.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _W_est_：リノに優しい地域のセグメントの輻輳ウィンドウの推定値 - つまり、リノの輻輳窓の推定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _segments_acked_: Number of SMSS-sized segments acked when a &#34;new ACK&#34; is received, i.e., an ACK that cumulatively acknowledges the delivery of previously unacknowledged data. This number will be a decimal value when a new ACK acknowledges an amount of data that is not SMSS-sized. Specifically, it can be less than 1 when a new ACK acknowledges a segment smaller than the SMSS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* _SEGMENTS_ACKED_：「新しいACK」を受信したときにSMSSサイズのセグメントの数がアクセスしました。つまり、以前に未把握されていないデータの提供を累積的に認識しているACK。この数値は、新しいACKがSMSSサイズではないデータの量を確認する場合、小数値になります。具体的には、新しいACKがSMSSよりも小さいセグメントを認めている場合、1未満になる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2--Window-Increase-Function">
4.2. Window Increase Function
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. ウィンドウの増加関数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CUBIC maintains the ACK clocking of Reno by increasing the congestion window only at the reception of a new ACK. It does not make any changes to the TCP Fast Recovery and Fast Retransmit algorithms [RFC6582] [RFC6675].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicは、新しいACKの受信時にのみ混雑ウィンドウを増やすことにより、RenoのACKクロッキングを維持します。TCP高速回復と高速再送信アルゴリズム[RFC6582] [RFC6675]に変更はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During congestion avoidance, after a congestion event is detected as described in Section 3.1, CUBIC uses a window increase function different from Reno.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳回避の間、セクション3.1で説明されているように混雑イベントが検出された後、CubicはRENOとは異なるウィンドウ増加関数を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CUBIC uses the following window increase function:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicは、次のウィンドウ増加関数を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
 3 W (t) = C * (t - K) + W cubic max
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
3 w（t）= c *（t -k）wキュービックマックス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
Figure 1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
図1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where _t_ is the elapsed time in seconds from the beginning of the current congestion avoidance stage -- that is,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、_t_は現在の輻輳回避段階の最初から数秒で経過時間です - つまり、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
t = t - t current epoch
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
t = t -t電流時代
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and where _t_epoch_ is the time at which the current congestion avoidance stage starts. _K_ is the time period that the above function takes to increase the congestion window size at the beginning of the current congestion avoidance stage to _W_max_ if there are no further congestion events. _K_ is calculated using the following equation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そして、_t_epoch_は、現在の混雑回避段階が始まる時期です。_K_は、これ以上の混雑イベントがない場合、現在の輻輳回避段階の開始時に輻輳ウィンドウサイズを_W_MAX_に増やすために上記の関数がかかる期間です。_K_は、次の方程式を使用して計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-32">
 3 W - cwnd max epoch K = C
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-32">
3 W -CWND MAX EPOCH K = C
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
Figure 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
図2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where _cwnd_epoch_ is the congestion window at the beginning of the current congestion avoidance stage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、_CWND_EPOCH_は、現在の混雑回避段階の開始時の混雑ウィンドウです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receiving a new ACK during congestion avoidance, CUBIC computes the _target_ congestion window size after the next _RTT_ using Figure 1 as follows, where _RTT_ is the smoothed round-trip time. The lower and upper bounds below ensure that CUBIC&#39;s congestion window increase rate is non-decreasing and is less than the increase rate of slow start [SXEZ19].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
混雑回避中に新しいACKを受信すると、Cubicは、次のように図1を使用して、次の_RTT_の後に_target_うっ血ウィンドウサイズを計算します。以下の下限と上限により、Cubicの混雑ウィンドウの増加率は非断片的であり、スロースタートの増加率よりも低いことを確認します[SXEZ19]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
 cwnd if W (t + RTT) &lt; cwnd cubic 1.5 * cwnd if W (t + RTT) &gt; 1.5 * cwnd target = cubic W (t + RTT) otherwise cubic
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
cwnd if w（t rtt）&lt;cwnd cubic 1.5 * cwnd if w（t rtt）&gt; 1.5 * cwnd target = cubic w（t rtt）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The elapsed time _t_ in Figure 1 MUST NOT include periods during which _cwnd_ has not been updated due to application-limited behavior (see Section 5.8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図1の経過時間_T_には、アプリケーションが制限された動作のために_CWND_が更新されていない期間を含めてはなりません（セクション5.8を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Depending on the value of the current congestion window size _cwnd_, CUBIC runs in three different regions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の輻輳ウィンドウサイズ_cwnd_の値に応じて、3つの異なる領域での立方体は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The Reno-friendly region, which ensures that CUBIC achieves at least the same throughput as Reno.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. キュービックがリノと少なくとも同じスループットを達成することを保証するリノに優しい地域。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The concave region, if CUBIC is not in the Reno-friendly region and _cwnd_ is less than _W_max_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Cubicがリノフレンドリーな領域になく、_CWND_が_W_MAX_よりも少ない場合、凹の領域。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The convex region, if CUBIC is not in the Reno-friendly region and _cwnd_ is greater than _W_max_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 凸領域は、キュービックがリノフレンドリーな領域になく、_CWND_が_W_MAX_よりも大きい場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To summarize, CUBIC computes both W_cubic(_t_) and _W_est_ (see Section 4.3) on receiving a new ACK in congestion avoidance and chooses the larger of the two values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要約すると、Cubicはw_cubic（_t_）と_w_est_（セクション4.3を参照）の両方を計算し、輻輳回避で新しいACKを受信し、2つの値のうち大きいものを選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next sections describe the exact actions taken by CUBIC in each region.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のセクションでは、各地域でCubicが取った正確なアクションについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3--Reno-Friendly-Region">
4.3. Reno-Friendly Region
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. リノにやさしい地域
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reno performs well in certain types of networks -- for example, under short RTTs and small bandwidths (or small BDPs). In these networks, CUBIC remains in the Reno-friendly region to achieve at least the same throughput as Reno.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RENOは、特定のタイプのネットワークでうまく機能します。たとえば、短いRTTや小さな帯域幅（または小さなBDP）の下で。これらのネットワークでは、キュービックはリノに優しい地域に残って、リノと少なくとも同じスループットを達成しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Reno-friendly region is designed according to the analysis discussed in [FHP00], which studies the performance of an AIMD algorithm with an additive factor of (segments per _RTT_) and a multiplicative factor of , denoted by AIMD(, ). _p_ is the packet loss rate. Specifically, the average congestion window size of AIMD(, ) can be calculated using Figure 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リノフレンドリーな領域は、[FHP00]で説明されている分析に従って設計されています。これは、AIMDアルゴリズムのパフォーマンスを、（_RTT_ごとのセグメント）とAIMD（、）で示された増殖因子のパフォーマンスを研究しています。_P_はパケット損失率です。具体的には、AIMD（、）の平均輻輳ウィンドウサイズは、図3を使用して計算できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">

                                                            * (1 + )
                                      AVG_AIMD(, ) =  
                                                        2 * (1 - ) * p
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
Figure 3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
図3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By the same analysis, to achieve an average window size similar to Reno that uses AIMD(1, 0.5), must be equal to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じ分析により、AIMD（1、0.5）を使用するRENOと同様の平均ウィンドウサイズを達成するには、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
 1 - 3 * 1 +
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
1-3 * 1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, CUBIC uses Figure 4 to estimate the window size _W_est_ in the Reno-friendly region with
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、Cubicは図4を使用して、リノフレンドリーな地域のウィンドウサイズ_W_est_を推定します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
 1 - cubic = 3 * cubic 1 + cubic
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
1 -Cubic = 3 * Cubic 1 Cubic
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
which achieves approximately the same average window size as Reno in many cases. The model used to calculate __cubic_ is not absolutely precise, but analysis and simulation as discussed in [AIMD-friendliness], as well as over a decade of experience with CUBIC in the public Internet, show that this approach produces acceptable levels of rate fairness between CUBIC and Reno flows. Also, no significant drawbacks of the model have been reported. However, continued detailed analysis of this approach would be beneficial. When receiving a new ACK in congestion avoidance (where _cwnd_ could be greater than or less than _W_max_), CUBIC checks whether W_cubic(_t_) is less than _W_est_. If so, CUBIC is in the Reno-friendly region and _cwnd_ SHOULD be set to _W_est_ at each reception of a new ACK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くの場合、RENOとほぼ同じ平均ウィンドウサイズを達成します。__CUBIC_を計算するために使用されるモデルは絶対に正確ではありませんが、[AIMD-フレンドリー]で説明されているように分析とシミュレーション、およびパブリックインターネットでのCubicでの10年以上の経験を示しています。立方体とリノの流れ。また、モデルの重要な欠点は報告されていません。ただし、このアプローチの継続的な詳細な分析は有益です。混雑回避で新しいACKを受信する場合（_CWND_は_W_MAX_よりも大きくなるか、それとも大きくなる可能性があります）、CubicはW_CUBIC（_T_）が_W_EST_より少ないかどうかを確認します。その場合、Cubicはリノフレンドリーな地域にあり、_CWND_は新しいACKの受信ごとに_W_est_に設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_W_est_ is set equal to _cwnd_epoch_ at the start of the congestion avoidance stage. After that, on every new ACK, _W_est_ is updated using Figure 4. Note that this equation uses _segments_acked_ and _cwnd_ is measured in segments. An implementation that measures _cwnd_ in bytes should adjust the equation accordingly using the number of acknowledged bytes and the SMSS. Also note that this equation works for connections with enabled or disabled delayed ACKs [RFC5681], as _segments_acked_ will be different based on the segments actually acknowledged by a new ACK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_W_est_は、うっ血回避段階の開始時に_cwnd_epoch_に等しく設定されます。その後、すべての新しいACKで、_W_est_は図4を使用して更新されます。この方程式は_segments_acked_および_cwnd_を使用してセグメントで測定されます。バイトで_CWND_を測定する実装は、それに応じて式を調整して、確認されたバイトとSMSの数を使用して調整する必要があります。また、_segments_acked_は新しいACKによって実際に認められているセグメントに基づいて_segments_acked_が異なるため、この方程式は有効または無効な遅延ACK [RFC5681]との接続に対して機能することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
 segments_acked W = W + * est est cubic cwnd
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
segments_acked w = w * est est cubic cwnd
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
Figure 4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
図4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once _W_est_ has grown to reach the _cwnd_ at the time of most recently setting _ssthresh_ -- that is, _W_est_ &gt;= _cwnd_prior_ -- the sender SHOULD set __cubic_ to 1 to ensure that it can achieve the same congestion window increment rate as Reno, which uses AIMD(1, 0.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_W_est_が最近設定された時点で_cwnd_に到達するように成長したら、_ssthresh_を設定します。AIMD（1、0.5）を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next two sections assume that CUBIC is not in the Reno-friendly region and uses the window increase function described in Section 4.2. Although _cwnd_ is incremented in the same way for both concave and convex regions, they are discussed separately to analyze and understand the difference between the two regions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の2つのセクションでは、Cubicはリノフレンドリーな地域にないと想定しており、セクション4.2で説明されているウィンドウ増加関数を使用しています。_CWND_は凹状領域と凸領域の両方で同じ方法で増加しますが、2つの領域の違いを分析および理解するために個別に議論されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-4--Concave-Region">
4.4. Concave Region
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. 凹の領域
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When receiving a new ACK in congestion avoidance, if CUBIC is not in the Reno-friendly region and _cwnd_ is less than _W_max_, then CUBIC is in the concave region. In this region, _cwnd_ MUST be incremented by
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
混雑回避で新しいACKを受け取ると、キュービックがリノフレンドリーな地域にいない場合、_CWND_が_W_MAX_未満である場合、Cubicは凹の領域にあります。この地域では、_CWND_を増やす必要があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-31">
target - cwnd cwnd
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-31">
ターゲット-CWND CWND
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
for each received new ACK, where _target_ is calculated as described in Section 4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション4.2で説明されているように、_target_が計算される新しいACKを受信した各ACKについて。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-5--Convex-Region">
4.5. Convex Region
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. 凸領域
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When receiving a new ACK in congestion avoidance, if CUBIC is not in the Reno-friendly region and _cwnd_ is larger than or equal to _W_max_, then CUBIC is in the convex region.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
混雑回避で新しいACKを受け取ると、キュービックがリノフレンドリーな地域にいない場合、_CWND_が_W_MAX_以上である場合、Cubicは凸領域にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The convex region indicates that the network conditions might have changed since the last congestion event, possibly implying more available bandwidth after some flow departures. Since the Internet is highly asynchronous, some amount of perturbation is always possible without causing a major change in available bandwidth.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
凸領域は、いくつかの流れの出発後、より利用可能な帯域幅を意味する可能性があることを意味する可能性があることを意味します。インターネットは非常に非同期であるため、利用可能な帯域幅に大きな変化をもたらすことなく、ある程度の摂動が常に可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless the cwnd is overridden by the AIMD window increase, CUBIC will behave cautiously when operating in this region. The convex profile aims to increase the window very slowly at the beginning when _cwnd_ is around _W_max_ and then gradually increases its rate of increase. This region is also called the &#34;maximum probing phase&#34;, since CUBIC is searching for a new _W_max_. In this region, _cwnd_ MUST be incremented by
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CWNDがAIMDウィンドウの増加によってオーバーライドされない限り、この地域で動作するときにCubicは慎重に振る舞います。凸プロファイルは、_CWND_が_W_MAX_の周りにあるときに最初にウィンドウを非常にゆっくりと増加させ、その後徐々に増加率を増加させることを目的としています。Cubicが新しい_W_Max_を検索しているため、この領域は「最大プロービングフェーズ」とも呼ばれます。この地域では、_CWND_を増やす必要があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-31">
target - cwnd cwnd
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-31">
ターゲット-CWND CWND
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
for each received new ACK, where _target_ is calculated as described in Section 4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション4.2で説明されているように、_target_が計算される新しいACKを受信した各ACKについて。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-6--Multiplicative-Decrease">
4.6. Multiplicative Decrease
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. 乗法減少
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a congestion event is detected by the mechanisms described in Section 3.1, CUBIC updates _W_max_ and reduces _cwnd_ and _ssthresh_ immediately, as described below. In the case of packet loss, the sender MUST reduce _cwnd_ and _ssthresh_ immediately upon entering loss recovery, similar to [RFC5681] (and [RFC6675]). Note that other mechanisms, such as Proportional Rate Reduction [RFC6937], can be used to reduce the sending rate during loss recovery more gradually. The parameter __cubic_ SHOULD be set to 0.7, which is different from the multiplicative decrease factor used in [RFC5681] (and [RFC6675]) during fast recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション3.1で説明されているメカニズムによって輻輳イベントが検出されると、Cubicの更新は_W_MAX_を更新し、_CWND_および_SSTHRESH_をすぐに削減します。パケット損失の場合、送信者は、[RFC5681]（および[RFC6675]）と同様に、損失回復をすぐに_CWND_および_SSTHRESH_を減らす必要があります。比例速度の低下[RFC6937]などの他のメカニズムを使用して、損失回復中の送信速度を徐々に減らすことができることに注意してください。パラメーター__CUBIC_は0.7に設定する必要があります。これは、速い回復中に[RFC5681]（および[RFC6675]）で使用される乗法減少係数とは異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In Figure 5, _flight_size_ is the amount of outstanding (unacknowledged) data in the network, as defined in [RFC5681]. Note that a rate-limited application with idle periods or periods when unable to send at the full rate permitted by _cwnd_ could easily encounter notable variations in the volume of data sent from one RTT to another, resulting in _flight_size_ that is significantly less than _cwnd_ when there is a congestion event. The congestion response would therefore decrease _cwnd_ to a much lower value than necessary. To avoid such suboptimal performance, the mechanisms described in [RFC7661] can be used. [RFC7661] describes how to manage and use _cwnd_ and _ssthresh_ during a rate-limited interval, and how to update _cwnd_ and _ssthresh_ after congestion has been detected. The mechanisms defined in [RFC7661] are safe to use even when _cwnd_ is greater than the receive window, because they validate _cwnd_ based on the amount of data acknowledged by the network in an RTT, which implicitly accounts for the allowed receive window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図5では、_Flight_size_は[RFC5681]で定義されているように、ネットワーク内の未解決の（未把持）データの量です。_cwnd_によって許可されている完全なレートで送信できない場合のアイドル期間または期間を備えたレート制限アプリケーションは、あるRTTから別のRTTに送信されるデータの量の顕著なバリエーションに簡単に遭遇し、_Flight_size_が_cwnd_よりも大幅に少ない_Flight_size_に遭遇する可能性があることに注意してください。混雑イベントがあります。したがって、輻輳応答は、_cwnd_を必要以上に低い値に減少させます。このような最適ではないパフォーマンスを回避するために、[RFC7661]で説明されているメカニズムを使用できます。[RFC7661]は、レート制限間隔で_CWND_および_SSTHRESH_を管理および使用する方法と、輻輳が検出された後の_CWND_および_SSTHRESH_を更新する方法について説明します。[RFC7661]で定義されているメカニズムは、_CWND_が受信ウィンドウよりも大きい場合でも使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some implementations of CUBIC currently use _cwnd_ instead of _flight_size_ when calculating a new _ssthresh_. Implementations that use _cwnd_ MUST use other measures to prevent _cwnd_ from growing when the volume of bytes in flight is smaller than _cwnd_. This also effectively prevents _cwnd_ from growing beyond the receive window. Such measures are important for preventing a CUBIC sender from using an arbitrarily high cwnd _value_ when calculating new values for _ssthresh_ and _cwnd_ when congestion is detected. This might not be as robust as the mechanisms described in [RFC7661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicのいくつかの実装は、新しい_SSTHRESH_を計算するときに_Flight_Size_の代わりに_CWND_を使用しています。_CWND_を使用する実装は、飛行中のバイトの量が_CWND_よりも小さいときに_CWND_の成長を防ぐために他のメジャーを使用する必要があります。これにより、_CWND_が受信ウィンドウを超えて成長することも事実上防止されます。このような措置は、輻輳が検出されたときに_SSTHRESH_および_CWND_の新しい値を計算するときに、立方センダーが任意の高いCWND _Value_を使用することを防ぐために重要です。これは、[RFC7661]で説明されているメカニズムほど堅牢ではない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A QUIC sender that uses a _cwnd_ _value_ to calculate new values for _cwnd_ and _ssthresh_ after detecting a congestion event is REQUIRED to apply similar mechanisms [RFC9002].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_cwnd_ _value_を使用して、come索イベントを検出した後、_cwnd_および_ssthresh_の新しい値を計算するquic送信者は、同様のメカニズムを適用するために必要です[RFC9002]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    ssthresh =  flight_size *       new  ssthresh
                               cubic
    cwnd      = cwnd                 save  cwnd
        prior
                max(ssthresh, 2)    reduction on loss, cwnd &gt;= 2 SMSS
    cwnd =      max(ssthresh, 1)    reduction on ECE, cwnd &gt;= 1 SMSS

    ssthresh =  max(ssthresh, 2)     ssthresh &gt;= 2 SMSS
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
Figure 5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
図5
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A side effect of setting __cubic_ to a value bigger than 0.5 is that packet loss can happen for more than one RTT in certain cases, but it can work efficiently in other cases -- for example, when HyStart++ [RFC9406] is used along with CUBIC or when the sending rate is limited by the application. While a more adaptive setting of __cubic_ could help limit packet loss to a single round, it would require detailed analyses and large-scale evaluations to validate such algorithms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
__cubic_を0.5より大きな値に設定する副作用は、特定の場合に複数のRTTでパケットの損失が発生する可能性があることですが、他の場合には効率的に動作する可能性があります。または、送信率がアプリケーションによって制限されている場合。__CUBIC_のより適応的な設定は、パケットの損失を1つのラウンドに制限するのに役立ちますが、そのようなアルゴリズムを検証するには、詳細な分析と大規模な評価が必要になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that CUBIC MUST continue to reduce _cwnd_ in response to congestion events detected by ECN-Echo ACKs until it reaches a value of 1 SMSS. If congestion events indicated by ECN-Echo ACKs persist, a sender with a _cwnd_ of 1 SMSS MUST reduce its sending rate even further. This can be achieved by using a retransmission timer with exponential backoff, as described in [RFC3168].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicは、ECNエコーACKによって検出された輻輳イベントに応じて、1つのSMSSの値に達するまで_CWND_を引き続き減らす必要があることに注意してください。ECNエコーAcksが示す混雑イベントが持続する場合、1つのSMSSの_CWND_を持つ送信者は、送信率をさらに低下させる必要があります。これは、[RFC3168]で説明されているように、指数関数的なバックオフを備えた再送信タイマーを使用することで実現できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-7--Fast-Convergence">
4.7. Fast Convergence
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. 高速収束
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To improve convergence speed, CUBIC uses a heuristic. When a new flow joins the network, existing flows need to give up some of their bandwidth to allow the new flow some room for growth if the existing flows have been using all the network bandwidth. To speed up this bandwidth release by existing flows, the following fast convergence mechanism SHOULD be implemented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
収束速度を改善するために、Cubicはヒューリスティックを使用します。新しいフローがネットワークに結合する場合、既存のフローがすべてのネットワーク帯域幅を使用している場合、既存のフローは帯域幅の一部を放棄する必要があります。既存のフローによるこの帯域幅リリースをスピードアップするには、次の高速収束メカニズムを実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With fast convergence, when a congestion event occurs, _W_max_ is updated as follows, before the window reduction described in Section 4.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
迅速な収束を使用すると、輻輳イベントが発生すると、セクション4.6で説明されているウィンドウの削減の前に、_W_MAX_が次のように更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              1 + 
                   cubic
       cwnd *  if  cwnd &lt; W     and fast convergence enabled,
W    =            2                  max
 max                     further reduce  W
                                          max
       cwnd             otherwise, remember cwnd before reduction
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During a congestion event, if the current _cwnd_ is less than _W_max_, this indicates that the saturation point experienced by this flow is getting reduced because of a change in available bandwidth. This flow can then release more bandwidth by reducing _W_max_ further. This action effectively lengthens the time for this flow to increase its congestion window, because the reduced _W_max_ forces the flow to plateau earlier. This allows more time for the new flow to catch up to its congestion window size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳イベント中に、現在の_CWND_が_W_MAX_未満の場合、これは、利用可能な帯域幅の変化のためにこの流れが経験する飽和点が減少していることを示しています。このフローは、_W_MAX_をさらに減らすことにより、より多くの帯域幅を放出できます。このアクションは、この流れが輻輳窓を増やすための時間を効果的に長くします。これは、_W_MAX_がより早くプラトーに流れを強制するためです。これにより、新しいフローが混雑のウィンドウサイズに追いつく時間が増えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fast convergence is designed for network environments with multiple CUBIC flows. In network environments with only a single CUBIC flow and without any other traffic, fast convergence SHOULD be disabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高速収束は、複数の立方体フローを備えたネットワーク環境向けに設計されています。単一の立方体の流れしかなく、他のトラフィックがないネットワーク環境では、高速収束を無効にする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-8--Timeout">
4.8. Timeout
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8. タイムアウト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of a timeout, CUBIC follows Reno to reduce _cwnd_ [RFC5681] but sets _ssthresh_ using __cubic_ (same as in Section 4.6) in a way that is different from Reno TCP [RFC5681].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイムアウトの場合、CubicはRENOに従って_CWND_ [RFC5681]を減らしますが、__CUBIC_（セクション4.6と同じ）を使用して_sSthresh_をリノTCP [RFC5681]とは異なる方法で設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During the first congestion avoidance stage after a timeout, CUBIC increases its congestion window size using Figure 1, where _t_ is the elapsed time since the beginning of the current congestion avoidance stage, _K_ is set to 0, and _W_max_ is set to the congestion window size at the beginning of the current congestion avoidance stage. In addition, for the Reno-friendly region, _W_est_ SHOULD be set to the congestion window size at the beginning of the current congestion avoidance stage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイムアウト後の最初の混雑回避段階では、Cubicは図1を使用して混雑のウィンドウサイズを増やします。ここで、_T_は現在の混雑回避段階の開始から経過時間です。現在の混雑回避段階の先頭にあるサイズ。さらに、リノフレンドリーな地域の場合、_W_est_は、現在の輻輳回避段階の開始時に渋滞ウィンドウサイズに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-9--Spurious-Congestion-Events">
4.9. Spurious Congestion Events
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9. 偽りの混雑イベント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In cases where CUBIC reduces its congestion window in response to having detected packet loss via duplicate ACKs or timeouts, it is possible that the missing ACK could arrive after the congestion window reduction and a corresponding packet retransmission. For example, packet reordering could trigger this behavior. A high degree of packet reordering could cause multiple congestion window reduction events, where spurious losses are incorrectly interpreted as congestion signals, thus degrading CUBIC&#39;s performance significantly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicが重複ACKまたはタイムアウトを介してパケット損失を検出したことに応じて混雑ウィンドウを減らす場合、輻輳ウィンドウの削減と対応するパケットの再送信後に欠けているACKが到着する可能性があります。たとえば、パケットの並べ替えはこの動作をトリガーする可能性があります。高度なパケットの並べ替えにより、複数の混雑の窓削減イベントが発生する可能性があります。このイベントでは、偽の損失が渋滞信号として誤って解釈されるため、Cubicのパフォーマンスを大幅に低下させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For TCP, there are two types of spurious events: spurious timeouts and spurious fast retransmits. In the case of QUIC, there are no spurious timeouts, as the loss is only detected after receiving an ACK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPの場合、偽のタイムアウトと偽の速い再送信の2つのタイプがあります。QUICの場合、ACKを受け取った後にのみ損失が検出されるため、偽のタイムアウトはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-9-1--Spurious-Timeouts">
4.9.1. Spurious Timeouts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1. 偽りのタイムアウト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation MAY detect spurious timeouts based on the mechanisms described in Forward RTO-Recovery [RFC5682]. Experimental alternatives include the Eifel detection algorithm [RFC3522]. When a spurious timeout is detected, a TCP implementation MAY follow the response algorithm described in [RFC4015] to restore the congestion control state and adapt the retransmission timer to avoid further spurious timeouts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、Forward RTO-Recovery [RFC5682]に記載されているメカニズムに基づいて、偽のタイムアウトを検出する場合があります。実験的な代替品には、EIFEL検出アルゴリズム[RFC3522]が含まれます。スプリアスタイムアウトが検出されると、TCP実装は[RFC4015]で説明されている応答アルゴリズムに従って、混雑コントロール状態を回復し、再送信タイマーを適応させて、さらなる偽りのタイムアウトを避けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-9-2--Spurious-Fast-Retransmits">
4.9.2. Spurious Fast Retransmits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.2. 偽りの速い再送信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receiving an ACK, a TCP implementation MAY detect spurious fast retransmits either using TCP Timestamps or via D-SACK [RFC2883]. As noted above, experimental alternatives include the Eifel detection algorithm [RFC3522], which uses TCP Timestamps; and DSACK-based detection [RFC3708], which uses DSACK information. A QUIC implementation can easily determine a spurious fast retransmit if a QUIC packet is acknowledged after it has been marked as lost and the original data has been retransmitted with a new QUIC packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACKを受信すると、TCP実装は、TCPタイムスタンプを使用してD-Sack [RFC2883]を使用して、偽の高速再送信を検出する場合があります。上記のように、実験的な代替品には、TCPタイムスタンプを使用するEIFEL検出アルゴリズム[RFC3522]が含まれます。DSACKベースの検出[RFC3708]は、DSACK情報を使用します。QUICの実装は、QUICパケットが失われたとマークされ、元のデータが新しいQUICパケットで再送信された後に認識された場合、偽の高速再送信を簡単に決定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section specifies a simple response algorithm when a spurious fast retransmit is detected by acknowledgments. Implementations would need to carefully evaluate the impact of using this algorithm in different environments that may experience a sudden change in available capacity (e.g., due to variable radio capacity, a routing change, or a mobility event).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、偽の高速再送信が謝辞によって検出されたときの単純な応答アルゴリズムを指定します。実装は、利用可能な容量が突然変化する可能性のあるさまざまな環境でこのアルゴリズムを使用することの影響を慎重に評価する必要があります（たとえば、可変無線容量、ルーティングの変更、またはモビリティイベントなど）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When packet loss is detected via acknowledgments, a CUBIC implementation MAY save the current value of the following variables before the congestion window is reduced.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
謝辞を介してパケットの損失が検出されると、渋滞ウィンドウが削減される前に、次の変数の現在の値を節約することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
undo_cwnd = cwnd undo_cwnd = cwnd prior prior undo_ssthresh = ssthresh undo_W = W max max undo_K = K undo_t = t epoch epoch undo_W = W est est
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
undo_cwnd = cwnd undo_cwnd = cwnd prior priut prior undo_sshresh = ssthresh undo_w = w max max undo_k = k undo_t = t epoch epoch undo_w = w est est
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the previously declared packet loss is confirmed to be spurious, CUBIC MAY restore the original values of the above-mentioned variables as follows if the current _cwnd_ is lower than _cwnd_prior_. Restoring the original values ensures that CUBIC&#39;s performance is similar to what it would be without spurious losses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前に宣言されたパケット損失が偽物であることが確認されると、Cubicは、現在の_CWND_が_CWND_PRIOR_よりも低い場合、上記の変数の元の値を次のように復元する場合があります。元の値を復元することで、Cubicのパフォーマンスが偽りの損失なしにそれがそうなるものと似ていることが保証されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              cwnd =      undo_cwnd      
              cwnd      = undo_cwnd      
                  prior            prior 
              ssthresh =  undo_ssthresh  
              W    =      undo_W         
               max              max      if cwnd &lt; cwnd
              K =         undo_K                       prior
              t      =    undo_t         
               epoch            epoch    
              W    =      undo_W         
               est              est
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In rare cases, when the detection happens long after a spurious fast retransmit event and the current _cwnd_ is already higher than _cwnd_prior_, CUBIC SHOULD continue to use the current and the most recent values of these variables.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
まれに、偽の高速再送信イベントの長い間、現在の_CWND_が_CWND_PRIOR_よりも高い後に検出が行われる場合、Cubicはこれらの変数の現在と最新の値を引き続き使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-10--Slow-Start">
4.10. Slow Start
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.10. スロースタート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When _cwnd_ is no more than _ssthresh_, CUBIC MUST employ a slow start algorithm. In general, CUBIC SHOULD use the HyStart++ slow start algorithm [RFC9406] or MAY use the Reno TCP slow start algorithm [RFC5681] in the rare cases when HyStart++ is not suitable. Experimental alternatives include hybrid slow start [HR11], a predecessor to HyStart++ that some CUBIC implementations have used as the default for the last decade, and limited slow start [RFC3742]. Whichever startup algorithm is used, work might be needed to ensure that the end of slow start and the first multiplicative decrease of congestion avoidance work well together.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_CWND_が_SSTHRESH_以下の場合、Cubicはスロースタートアルゴリズムを使用する必要があります。一般に、CubicはHystart Slow Start Algorithm [RFC9406]を使用するか、Hystartが適切でない場合にReno TCPスロースタートアルゴリズム[RFC5681]を使用する必要があります。実験的な代替品には、ハイブリッドスロースタート[HR11]が含まれます。これは、過去10年間のデフォルトとしていくつかの立方体の実装が使用されているハイスタートの前身であり、制限されたスロースタート[RFC3742]が含まれます。どちらのスタートアップアルゴリズムが使用されても、スロースタートの終了と輻輳回避の最初の乗法減少がうまく機能するようにするために作業が必要になる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When CUBIC uses HyStart++ [RFC9406], it may exit the first slow start without incurring any packet loss and thus _W_max_ is undefined. In this special case, CUBIC sets _cwnd_prior = cwnd_ and switches to congestion avoidance. It then increases its congestion window size using Figure 1, where _t_ is the elapsed time since the beginning of the current congestion avoidance stage, _K_ is set to 0, and _W_max_ is set to the congestion window size at the beginning of the current congestion avoidance stage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CubicがHystart [RFC9406]を使用すると、パケット損失を負担せずに最初のスロースタートを終了する可能性があるため、_W_MAX_は定義されていません。この特別な場合、Cubicは_cwnd_prior = cwnd_を設定し、混雑回避に切り替えます。次に、図1を使用して混雑のウィンドウサイズを増やします。ここで、_T_は現在の混雑回避段階の開始から経過時間、_K_は0に設定され、_W_MAX_は現在のうっ血回避の開始時に渋滞ウィンドウサイズに設定されます。ステージ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Discussion">
5. Discussion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 考察
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section further discusses the safety features of CUBIC, following the guidelines specified in [RFC5033].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、[RFC5033]で指定されたガイドラインに従って、立方体の安全機能についてさらに説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With a deterministic loss model where the number of packets between two successive packet losses is always _1/p_, CUBIC always operates with the concave window profile, which greatly simplifies the performance analysis of CUBIC. The average window size of CUBIC (see Appendix B) can be obtained via the following function:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つの連続したパケット損失の間のパケットの数が常に_1/P_である決定論的損失モデルでは、Cubicは常にConcaveウィンドウプロファイルで動作し、Cubicのパフォーマンス分析を大幅に簡素化します。Cubicの平均ウィンドウサイズ（付録Bを参照）は、次の関数を介して取得できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                  4 
                               C * (3 +      )        3
                            4            cubic      RTT
               AVG_W      =     * 
                    cubic     4 * (1 -      )     4 
                                        cubic        3
                                                      p
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
Figure 6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
図6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With __cubic_ set to 0.7, the above formula reduces to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
__cubic_を0.7に設定すると、上記の式が減少します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                               4 
                                          3
                                 4 C * 3.7     RTT
                    AVG_W      =    * 
                         cubic      1.2       4 
                                                  3
                                                 p
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
Figure 7
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
図7
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following subsection will determine the value of _C_ using Figure 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のサブセクションでは、図7を使用して_C_の値を決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1--Fairness-to-Reno">
5.1. Fairness to Reno
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. リノへの公平性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In environments where Reno is able to make reasonable use of the available bandwidth, CUBIC does not significantly change this state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Renoが利用可能な帯域幅を合理的に使用できる環境では、Cubicはこの状態を大幅に変更しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reno performs well in the following two types of networks:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RENOは、次の2つのタイプのネットワークでうまく機能します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. networks with a small bandwidth-delay product (BDP)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 小さな帯域幅遅延製品を備えたネットワーク（BDP）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. networks with short RTTs, but not necessarily a small BDP
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 短いRTTを持つネットワークですが、必ずしも小さなBDPではありません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CUBIC is designed to behave very similarly to Reno in the above two types of networks. The following two tables show the average window sizes of Reno TCP, HSTCP, and CUBIC TCP. The average window sizes of Reno TCP and HSTCP are from [RFC3649]. The average window size of CUBIC is calculated using Figure 7 and the CUBIC Reno-friendly region for three different values of _C_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicは、上記の2種類のネットワークでRenoと非常に同様に振る舞うように設計されています。次の2つのテーブルは、リノTCP、HSTCP、および立方TCPの平均ウィンドウサイズを示しています。リノTCPとHSTCPの平均ウィンドウサイズは[RFC3649]からのものです。Cubicの平均ウィンドウサイズは、_C_の3つの異なる値の図7とCubic Renoに優しい領域を使用して計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +=============+=======+========+================+=========+========+
   | Loss Rate P |  Reno |  HSTCP | CUBIC (C=0.04) |   CUBIC |  CUBIC |
   |             |       |        |                | (C=0.4) |  (C=4) |
   +=============+=======+========+================+=========+========+
   |     1.0e-02 |    12 |     12 |             12 |      12 |     12 |
   +-------------+-------+--------+----------------+---------+--------+
   |     1.0e-03 |    38 |     38 |             38 |      38 |     59 |
   +-------------+-------+--------+----------------+---------+--------+
   |     1.0e-04 |   120 |    263 |            120 |     187 |    333 |
   +-------------+-------+--------+----------------+---------+--------+
   |     1.0e-05 |   379 |   1795 |            593 |    1054 |   1874 |
   +-------------+-------+--------+----------------+---------+--------+
   |     1.0e-06 |  1200 |  12280 |           3332 |    5926 |  10538 |
   +-------------+-------+--------+----------------+---------+--------+
   |     1.0e-07 |  3795 |  83981 |          18740 |   33325 |  59261 |
   +-------------+-------+--------+----------------+---------+--------+
   |     1.0e-08 | 12000 | 574356 |         105383 |  187400 | 333250 |
   +-------------+-------+--------+----------------+---------+--------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Table 1: Reno TCP, HSTCP, and CUBIC with RTT = 0.1 Seconds
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
表1：RTT = 0.1秒でRENO TCP、HSTCP、およびCUBIC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 1 describes the response function of Reno TCP, HSTCP, and CUBIC in networks with _RTT_ = 0.1 seconds. The average window size is in SMSS-sized segments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表1に、_RTT_ = 0.1秒のネットワークでのRENO TCP、HSTCP、およびCUBICの応答関数を示しています。平均ウィンドウサイズは、SMSSサイズのセグメントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    +=============+=======+========+================+=========+=======+
    | Loss Rate P |  Reno |  HSTCP | CUBIC (C=0.04) |   CUBIC | CUBIC |
    |             |       |        |                | (C=0.4) | (C=4) |
    +=============+=======+========+================+=========+=======+
    |     1.0e-02 |    12 |     12 |             12 |      12 |    12 |
    +-------------+-------+--------+----------------+---------+-------+
    |     1.0e-03 |    38 |     38 |             38 |      38 |    38 |
    +-------------+-------+--------+----------------+---------+-------+
    |     1.0e-04 |   120 |    263 |            120 |     120 |   120 |
    +-------------+-------+--------+----------------+---------+-------+
    |     1.0e-05 |   379 |   1795 |            379 |     379 |   379 |
    +-------------+-------+--------+----------------+---------+-------+
    |     1.0e-06 |  1200 |  12280 |           1200 |    1200 |  1874 |
    +-------------+-------+--------+----------------+---------+-------+
    |     1.0e-07 |  3795 |  83981 |           3795 |    5926 | 10538 |
    +-------------+-------+--------+----------------+---------+-------+
    |     1.0e-08 | 12000 | 574356 |          18740 |   33325 | 59261 |
    +-------------+-------+--------+----------------+---------+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Table 2: Reno TCP, HSTCP, and CUBIC with RTT = 0.01 Seconds
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
表2：RTT = 0.01秒でRENO TCP、HSTCP、およびCUBIC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 2 describes the response function of Reno TCP, HSTCP, and CUBIC in networks with _RTT_ = 0.01 seconds. The average window size is in SMSS-sized segments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表2に、_RTT_ = 0.01秒のネットワークでのRENO TCP、HSTCP、およびCubicの応答関数を示しています。平均ウィンドウサイズは、SMSSサイズのセグメントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both tables show that CUBIC with any of these three _C_ values is more friendly to Reno TCP than HSTCP, especially in networks with a short _RTT_ where Reno TCP performs reasonably well. For example, in a network with _RTT_ = 0.01 seconds and p=10^-6, Reno TCP has an average window of 1200 packets. If the packet size is 1500 bytes, then Reno TCP can achieve an average rate of 1.44 Gbps. In this case, CUBIC with _C_=0.04 or _C_=0.4 achieves exactly the same rate as Reno TCP, whereas HSTCP is about ten times more aggressive than Reno TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どちらの表も、これらの3つの_C_値のいずれかを持つCubicが、HSTCPよりもReno TCPよりも優しいことを示しています。たとえば、_rtt_ = 0.01秒とp = 10^-6のネットワークでは、Reno TCPの平均ウィンドウは1200パケットです。パケットサイズが1500バイトの場合、Reno TCPは1.44 Gbpsの平均レートを達成できます。この場合、_c_ = 0.04または_c_ = 0.4の立方体は、reno TCPとまったく同じレートを達成しますが、HSTCPはReno TCPの約10倍の攻撃的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_C_ determines the aggressiveness of CUBIC in competing with other congestion control algorithms for bandwidth. CUBIC is more friendly to Reno TCP if the value of _C_ is lower. However, it is NOT RECOMMENDED to set _C_ to a very low value like 0.04, since CUBIC with a low _C_ cannot efficiently use the bandwidth in fast and long-distance networks. Based on these observations and extensive deployment experience, _C_=0.4 seems to provide a good balance between Reno-friendliness and aggressiveness of window increase. Therefore, _C_ SHOULD be set to 0.4. With _C_ set to 0.4, Figure 7 is reduced to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_C_は、帯域幅の他の輻輳制御アルゴリズムと競合する際にキュービックの攻撃性を決定します。_C_の値が低い場合、CubicはReno TCPにより優れています。ただし、低い_C_を持つCubicが高速および長距離ネットワークで帯域幅を効率的に使用できないため、_C_を0.04のような非常に低い値に設定することはお勧めしません。これらの観察と広範な展開体験に基づいて、_C_ = 0.4は、リノフレンドリーとウィンドウの増加の攻撃性のバランスをとるのが良いようです。したがって、_C_は0.4に設定する必要があります。_C_が0.4に設定されていると、図7はに縮小されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
 4 3 RTT AVG_W = 1.054 * cubic 4 3 p
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
4 3 rtt avg_w = 1.054 *立方4 3 p
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
Figure 8
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
図8
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 8 is then used in the next subsection to show the scalability of CUBIC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、次のサブセクションで図8を使用して、Cubicのスケーラビリティを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2--Using-Spare-Capacity">
5.2. Using Spare Capacity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. 予備容量を使用します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CUBIC uses a more aggressive window increase function than Reno for fast and long-distance networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicは、高速および長距離ネットワークのために、RENOよりも積極的なウィンドウ増加関数を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 3 shows that to achieve the 10 Gbps rate, Reno TCP requires a packet loss rate of 2.0e-10, while CUBIC TCP requires a packet loss rate of 2.9e-8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表3は、10 Gbpsレートを達成するために、Reno TCPのパケット損失率が2.0E-10を必要とするのに対し、Cubic TCPには2.9E-8のパケット損失率が必要であることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +===================+===========+=========+=========+=========+
      | Throughput (Mbps) | Average W |  Reno P | HSTCP P | CUBIC P |
      +===================+===========+=========+=========+=========+
      |                 1 |       8.3 |  2.0e-2 |  2.0e-2 |  2.0e-2 |
      +-------------------+-----------+---------+---------+---------+
      |                10 |      83.3 |  2.0e-4 |  3.9e-4 |  2.9e-4 |
      +-------------------+-----------+---------+---------+---------+
      |               100 |     833.3 |  2.0e-6 |  2.5e-5 |  1.4e-5 |
      +-------------------+-----------+---------+---------+---------+
      |              1000 |    8333.3 |  2.0e-8 |  1.5e-6 |  6.3e-7 |
      +-------------------+-----------+---------+---------+---------+
      |             10000 |   83333.3 | 2.0e-10 |  1.0e-7 |  2.9e-8 |
      +-------------------+-----------+---------+---------+---------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Table 3: Required Packet Loss Rate for Reno TCP, HSTCP, and CUBIC to Achieve a Certain Throughput
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
表3：特定のスループットを実現するために、リノTCP、HSTCP、およびCubicに必要なパケット損失率
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 3 describes the required packet loss rate for Reno TCP, HSTCP, and CUBIC to achieve a certain throughput, with 1500-byte packets and an _RTT_ of 0.1 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表3は、1500バイトのパケットと0.1秒の_RTT_を使用して、特定のスループットを実現するために、RENO TCP、HSTCP、およびCubicに必要なパケット損失率を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The test results provided in [HLRX07] indicate that, in typical cases with a degree of background traffic, CUBIC uses the spare bandwidth left unused by existing Reno TCP flows in the same bottleneck link without taking away much bandwidth from the existing flows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HLRX07]で提供されているテスト結果は、典型的なバックグラウンドトラフィックを持つ典型的な場合、Cubicは、既存のフローから多くの帯域幅を奪うことなく、同じボトルネックリンクの既存のReno TCPフローによって使用されない予備の帯域幅を使用することを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-3--Difficult-Environments">
5.3. Difficult Environments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. 難しい環境
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CUBIC is designed to remedy the poor performance of Reno in fast and long-distance networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicは、高速および長距離ネットワークでのリノのパフォーマンスの低下を改善するように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-4--Investigating-a-Range-of-Environments">
5.4. Investigating a Range of Environments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. さまざまな環境の調査
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CUBIC has been extensively studied using simulations, testbed emulations, Internet experiments, and Internet measurements, covering a wide range of network environments [HLRX07] [H16] [CEHRX09] [HR11] [BSCLU13] [LBEWK16]. They have convincingly demonstrated that CUBIC delivers substantial benefits over classical Reno congestion control [RFC5681].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicは、シミュレーション、テストベッドエミュレーション、インターネット実験、およびインターネット測定を使用して広範囲に研究されており、幅広いネットワーク環境[HLRX07] [H16] [CEHRX09] [HR11] [BSCLU13] [LBEWK16]をカバーしています。彼らは、Cubicが古典的なリノ輻輳制御に大きな利益をもたらすことを説得力を持って実証しました[RFC5681]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Same as Reno, CUBIC is a loss-based congestion control algorithm. Because CUBIC is designed to be more aggressive (due to a faster window increase function and bigger multiplicative decrease factor) than Reno in fast and long-distance networks, it can fill large drop-tail buffers more quickly than Reno and increases the risk of a standing queue [RFC8511]. In this case, proper queue sizing and management [RFC7567] could be used to mitigate the risk to some extent and reduce the packet queuing delay. Also, in large-BDP networks after a congestion event, CUBIC, due to its cubic window increase function, recovers quickly to the highest link utilization point. This means that link utilization is less sensitive to an active queue management (AQM) target that is lower than the amplitude of the whole sawtooth.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Renoと同じように、Cubicは損失ベースの混雑制御アルゴリズムです。Cubicは、高速および長距離ネットワークのRENOよりも、より速いウィンドウ増加関数と多重乗数の減少係数のために）より攻撃的になるように設計されているため、RENOよりも迅速に大きなドロップテールバッファーを埋め、Aのリスクを高めることができますスタンディングキュー[RFC8511]。この場合、適切なキューのサイジングと管理[RFC7567]を使用して、リスクをある程度緩和し、パケットキューイングの遅延を減らすことができます。また、輻輳イベントの後の大型BDPネットワークでは、Cubicの増加関数により、最高のリンク利用点に迅速に回復します。これは、リンクの使用率が、ノコギリ全体の振幅よりも低いアクティブキュー管理（AQM）ターゲットに敏感ではないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similar to Reno, the performance of CUBIC as a loss-based congestion control algorithm suffers in networks where packet loss is not a good indication of bandwidth utilization, such as wireless or mobile networks [LIU16].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Renoと同様に、損失ベースの輻輳制御アルゴリズムとしてのCubicのパフォーマンスは、パケット損失がワイヤレスネットワークやモバイルネットワークなどの帯域幅の利用の適切な兆候ではないネットワークに陥ります[Liu16]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-5--Protection-against-Congestion-Collapse">
5.5. Protection against Congestion Collapse
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. 混雑崩壊に対する保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With regard to the potential of causing congestion collapse, CUBIC behaves like Reno, since CUBIC modifies only the window adjustment algorithm of Reno. Thus, it does not modify the ACK clocking and timeout behaviors of Reno.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CubicはRenoのウィンドウ調整アルゴリズムのみを修正するため、混雑崩壊を引き起こす可能性に関して、キュービックはリノのように動作します。したがって、RENOのACKクロッキングとタイムアウトの動作は変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CUBIC also satisfies the &#34;full backoff&#34; requirement as described in [RFC5033]. After reducing the sending rate to one packet per RTT in response to congestion events detected by ECN-Echo ACKs, CUBIC then exponentially increases the transmission timer for each packet retransmission while congestion persists.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicは、[RFC5033]に記載されているように、「完全なバックオフ」要件も満たしています。ECNエコーAcksによって検出された輻輳イベントに応じて送信率をRTTごとに1つのパケットに引き下げた後、Cubicは、混雑が続く間、各パケットの再送信ごとに送信タイマーを指数関数的に増加させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-6--Fairness-within-the-Alternative-Congestion-Control-Algorithm">
5.6. Fairness within the Alternative Congestion Control Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6. 代替輻輳制御アルゴリズム内の公平性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CUBIC ensures convergence of competing CUBIC flows with the same RTT in the same bottleneck links to an equal throughput. When competing flows have different RTT values, their throughput ratio is linearly proportional to the inverse of their RTT ratios. This is true and is independent of the level of statistical multiplexing on the link. The convergence time depends on the network environments (e.g., bandwidth, RTT) and the level of statistical multiplexing, as mentioned in Section 3.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicは、同じBottleneckリンクで同じRTTを使用して競合するCubicフローの収束を等しいスループットに保証します。競合するフローのRTT値は異なる場合、スループット比はRTT比の逆に直線的に比例します。これは真実であり、リンク上の統計的多重化のレベルとは無関係です。収束時間は、セクション3.4で述べたように、ネットワーク環境（帯域幅、RTTなど）と統計的多重化のレベルに依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-7--Performance-with-Misbehaving-Nodes-and-Outside-Attackers">
5.7. Performance with Misbehaving Nodes and Outside Attackers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.7. 誤動作ノードと外部攻撃者によるパフォーマンス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CUBIC does not introduce new entities or signals, so its vulnerability to misbehaving nodes or attackers is unchanged from Reno.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicは新しいエンティティやシグナルを導入していないため、ノードや攻撃者の誤動作に対する脆弱性は、Renoから変化しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8--Behavior-for-Application-Limited-Flows">
5.8. Behavior for Application-Limited Flows
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8. アプリケーション制限フローの動作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A flow is application limited if it is currently sending less than what is allowed by the congestion window. This can happen if the flow is limited by either the sender application or the receiver application (via the receiver&#39;s advertised window) and thus sends less data than what is allowed by the sender&#39;s congestion window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在、輻輳ウィンドウで許可されているものよりも少ない送信している場合、フローはアプリケーションに制限されています。これは、フローが送信者アプリケーションまたはレシーバーアプリケーション（レシーバーの宣伝されたウィンドウを介して）によって制限され、送信者の混雑ウィンドウで許可されているものよりも少ないデータを送信する場合に発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CUBIC does not increase its congestion window if a flow is application limited. Per Section 4.2, it is required that _t_ in Figure 1 not include application-limited periods, such as idle periods; otherwise, W_cubic(_t_) might be very high after restarting from these periods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flowがアプリケーションに制限されている場合、Cubicは混雑ウィンドウを増やしません。セクション4.2に従って、図1の_T_には、アイドル期間などのアプリケーション制限期間が含まれないことが必要です。それ以外の場合、これらの期間から再起動した後、W_CUBIC（_T_）が非常に高くなる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-9--Responses-to-Sudden-or-Transient-Events">
5.9. Responses to Sudden or Transient Events
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.9. 突然または一時的なイベントへの応答
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there is a sudden increase in capacity, e.g., due to variable radio capacity, a routing change, or a mobility event, CUBIC is designed to utilize the newly available capacity more quickly than Reno.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
容量が突然増加している場合、たとえば、無線容量が可変、ルーティングの変更、モビリティイベントのために、CubicはRENOよりも新しく利用可能な容量をより迅速に利用するように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On the other hand, if there is a sudden decrease in capacity, CUBIC reduces more slowly than Reno. This remains true regardless of whether CUBIC is in Reno-friendly mode and regardless of whether fast convergence is enabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一方、容量が突然減少した場合、立方体はリノよりもゆっくりと減少します。これは、Cubicがリノフレンドリーモードであるかどうか、高速収束が有効になっているかどうかに関係なく、真実のままです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-10--Incremental-Deployment">
5.10. Incremental Deployment
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.10. 増分展開
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CUBIC requires only changes to congestion control at the sender, and it does not require any changes at receivers. That is, a CUBIC sender works correctly with Reno receivers. In addition, CUBIC does not require any changes to routers and does not require any assistance from routers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicは送信者での混雑制御の変更のみを必要とし、受信機での変更は必要ありません。つまり、立方センダーはリノレシーバーで正しく機能します。さらに、Cubicはルーターの変更を必要とせず、ルーターからの支援を必要としません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Security-Considerations">
6. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CUBIC makes no changes to the underlying security of a transport protocol and inherits the general security concerns described in [RFC5681]. Specifically, changing the window computation on the sender may allow an attacker, through dropping or injecting ACKs (as described in [RFC5681]), to either force the CUBIC implementation to reduce its bandwidth or convince it that there is no congestion when congestion does exist, and to use the CUBIC implementation as an attack vector against other hosts. These attacks are not new to CUBIC and are inherently part of any transport protocol like TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicは、輸送プロトコルの根本的なセキュリティに変更を加えず、[RFC5681]に記載されている一般的なセキュリティ上の懸念を継承します。具体的には、送信者のウィンドウ計算を変更すると、ACKをドロップまたは注入することで攻撃者が（[RFC5681]で説明されているように）攻撃者が帯域幅を減らすように強制するか、混雑が存在しない場合は混雑がないことを納得させることができます。、そして、立方体の実装を他のホストに対する攻撃ベクトルとして使用します。これらの攻撃はCubicにとって新しいものではなく、本質的にTCPのような輸送プロトコルの一部です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--IANA-Considerations">
7. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document does not require any IANA actions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、IANAアクションは必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--References">
8. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1--Normative-References">
8.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;https://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487/RFC2119、1997年3月、&lt;https://www.rfc-editor.org/info/RFC2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2883] Floyd, S., Mahdavi, J., Mathis, M., and M. Podolsky, &#34;An Extension to the Selective Acknowledgement (SACK) Option for TCP&#34;, RFC 2883, DOI 10.17487/RFC2883, July 2000, &lt;https://www.rfc-editor.org/info/rfc2883&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2883] Floyd、S.、Mahdavi、J.、Mathis、M。、およびM. Podolsky、「TCPの選択的承認（SACK）オプションの拡張」、RFC 2883、DOI 10.17487/RFC2883、2000年7月、&lt;&lt;https://www.rfc-editor.org/info/rfc2883&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2914] Floyd, S., &#34;Congestion Control Principles&#34;, BCP 41, RFC 2914, DOI 10.17487/RFC2914, September 2000, &lt;https://www.rfc-editor.org/info/rfc2914&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2914]フロイド、S。、「混雑制御原則」、BCP 41、RFC 2914、DOI 10.17487/RFC2914、2000年9月、&lt;https://www.rfc-editor.org/info/rfc2914&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, &#34;The Addition of Explicit Congestion Notification (ECN) to IP&#34;, RFC 3168, DOI 10.17487/RFC3168, September 2001, &lt;https://www.rfc-editor.org/info/rfc3168&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3168]ラマクリシュナン、K。、フロイド、S。、およびD.ブラック、「IPへの明示的な混雑通知（ECN）の追加」、RFC 3168、DOI 10.17487/RFC3168、2001年9月、&lt;https：// www。rfc-editor.org/info/rfc3168&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4015] Ludwig, R. and A. Gurtov, &#34;The Eifel Response Algorithm for TCP&#34;, RFC 4015, DOI 10.17487/RFC4015, February 2005, &lt;https://www.rfc-editor.org/info/rfc4015&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4015] Ludwig、R。およびA. Gurtov、「TCPのEIFEL応答アルゴリズム」、RFC 4015、DOI 10.17487/RFC4015、2005年2月、&lt;https://www.rfc-editor.org/info/rfc4015&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5033] Floyd, S. and M. Allman, &#34;Specifying New Congestion Control Algorithms&#34;, BCP 133, RFC 5033, DOI 10.17487/RFC5033, August 2007, &lt;https://www.rfc-editor.org/info/rfc5033&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5033] Floyd、S。およびM. Allman、「新しい混雑制御アルゴリズムの指定」、BCP 133、RFC 5033、DOI 10.17487/RFC5033、2007年8月、&lt;https://www.rfc-editor.org/info/rfc50333333333333333333333333&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5348] Floyd, S., Handley, M., Padhye, J., and J. Widmer, &#34;TCP Friendly Rate Control (TFRC): Protocol Specification&#34;, RFC 5348, DOI 10.17487/RFC5348, September 2008, &lt;https://www.rfc-editor.org/info/rfc5348&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5348] Floyd、S.、Handley、M.、Padhye、J。、およびJ. Widmer、「TCP Friendly Rate Control（TFRC）：プロトコル仕様」、RFC 5348、DOI 10.17487/RFC5348、2008年9月、&lt;https：//www.rfc-editor.org/info/rfc5348&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681] Allman, M., Paxson, V., and E. Blanton, &#34;TCP Congestion Control&#34;, RFC 5681, DOI 10.17487/RFC5681, September 2009, &lt;https://www.rfc-editor.org/info/rfc5681&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681] Allman、M.、Paxson、V.、およびE. Blanton、「TCP混雑制御」、RFC 5681、DOI 10.17487/RFC5681、2009年9月、&lt;https://www.rfc-editor.org/info/RFC5681&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5682] Sarolahti, P., Kojo, M., Yamamoto, K., and M. Hata, &#34;Forward RTO-Recovery (F-RTO): An Algorithm for Detecting Spurious Retransmission Timeouts with TCP&#34;, RFC 5682, DOI 10.17487/RFC5682, September 2009, &lt;https://www.rfc-editor.org/info/rfc5682&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5682] Sarolahti、P.、Kojo、M.、Yamamoto、K。、およびM. Hata、「Forward RTO-Recovery（F-RTO）：TCPで偽の再送信タイムアウトを検出するためのアルゴリズム」、RFC 5682、DOI 10.17487777487748774877487748774877487/RFC5682、2009年9月、&lt;https://www.rfc-editor.org/info/rfc5682&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, &#34;Computing TCP&#39;s Retransmission Timer&#34;, RFC 6298, DOI 10.17487/RFC6298, June 2011, &lt;https://www.rfc-editor.org/info/rfc6298&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6298] Paxson、V.、Allman、M.、Chu、J。、およびM. Sargent、「コンピューティングTCPの再送信タイマー」、RFC 6298、DOI 10.17487/RFC6298、2011年6月、&lt;https：//www.rfc-editor.org/info/rfc6298&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6582] Henderson, T., Floyd, S., Gurtov, A., and Y. Nishida, &#34;The NewReno Modification to TCP&#39;s Fast Recovery Algorithm&#34;, RFC 6582, DOI 10.17487/RFC6582, April 2012, &lt;https://www.rfc-editor.org/info/rfc6582&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6582] Henderson、T.、Floyd、S.、Gurtov、A。、およびY. Nishida、「TCPの高速回復アルゴリズムへのNewreno修正」、RFC 6582、DOI 10.17487/RFC6582、2012年4月、&lt;https：//www.rfc-editor.org/info/rfc6582&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6675] Blanton, E., Allman, M., Wang, L., Jarvinen, I., Kojo, M., and Y. Nishida, &#34;A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP&#34;, RFC 6675, DOI 10.17487/RFC6675, August 2012, &lt;https://www.rfc-editor.org/info/rfc6675&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6675] Blanton、E.、Allman、M.、Wang、L.、Jarvinen、I.、Kojo、M.、Y。nishida、「TCPの選択的承認（SACK）に基づく保守的な損失回復アルゴリズム」、RFC 6675、DOI 10.17487/RFC6675、2012年8月、&lt;https://www.rfc-editor.org/info/rfc6675&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7567] Baker, F., Ed. and G. Fairhurst, Ed., &#34;IETF Recommendations Regarding Active Queue Management&#34;, BCP 197, RFC 7567, DOI 10.17487/RFC7567, July 2015, &lt;https://www.rfc-editor.org/info/rfc7567&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7567]ベイカー、F。、編and G. Fairhurst、ed。、「アクティブキュー管理に関するIETF推奨」、BCP 197、RFC 7567、DOI 10.17487/RFC7567、2015年7月、&lt;https://www.rfc-editor.org/info/rfc7567&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba, B., &#34;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&#34;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba、B。、「RFC 2119キーワードの小文字と小文字の曖昧さ」、BCP 14、RFC 8174、DOI 10.17487/RFC8174、2017年5月、&lt;https：//www.rfc-editor.org/info/RFC8174&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8985] Cheng, Y., Cardwell, N., Dukkipati, N., and P. Jha, &#34;The RACK-TLP Loss Detection Algorithm for TCP&#34;, RFC 8985, DOI 10.17487/RFC8985, February 2021, &lt;https://www.rfc-editor.org/info/rfc8985&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8985] Cheng、Y.、Cardwell、N.、Dukkipati、N.、およびP. Jha、「TCPのRack-TLP損失検出アルゴリズム」、RFC 8985、DOI 10.17487/RFC8985、2月2021年、&lt;https：/&lt;https：/&lt;https：//www.rfc-editor.org/info/rfc8985&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9002] Iyengar, J., Ed. and I. Swett, Ed., &#34;QUIC Loss Detection and Congestion Control&#34;, RFC 9002, DOI 10.17487/RFC9002, May 2021, &lt;https://www.rfc-editor.org/info/rfc9002&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9002] Iyengar、J.、ed。and I. Swett、ed。、「QUIC損失検出と輻輳制御」、RFC 9002、DOI 10.17487/RFC9002、2021年5月、&lt;https://www.rfc-editor.org/info/rfc9002&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9406] Balasubramanian, P., Huang, Y., and M. Olson, &#34;HyStart++: Modified Slow Start for TCP&#34;, RFC 9406, DOI 10.17487/RFC9406, May 2023, &lt;https://www.rfc-editor.org/info/rfc9406&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9406] Balasubramanian、P.、Huang、Y.、およびM. Olson、「Hystart：TCPの修正スロースタート」、RFC 9406、DOI 10.17487/RFC9406、2023年5月、&lt;https：//www.rfc-editor。org/info/rfc9406&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2--Informative-References">
8.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[AIMD-friendliness] Briscoe, B. and O. Albisser, &#34;Friendliness between AIMD Algorithms&#34;, DOI 10.48550/arXiv.2305.10581, May 2023, &lt;https://arxiv.org/abs/2305.10581&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Aimd-frendliesly] Briscoe、B。and O. Albisser、「Aimd Algorithms間の親しみやすさ」、DOI 10.48550/arxiv.2305.10581、2023年5月、&lt;https://arxiv.org/abs/2305.10581&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BSCLU13] Belhareth, S., Sassatelli, L., Collange, D., Lopez-Pacheco, D., and G. Urvoy-Keller, &#34;Understanding TCP cubic performance in the cloud: A mean-field approach&#34;, 2013 IEEE 2nd International Conference on Cloud Networking (CloudNet), DOI 10.1109/cloudnet.2013.6710576, November 2013, &lt;https://doi.org/10.1109/cloudnet.2013.6710576&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BSCLU13] Belhareth、S.、Sassatelli、L.、Collange、D.、Lopez-Pacheco、D.、およびG. Urvoy-Keller、「クラウドでのTCPキュービックパフォーマンス：平均フィールドアプローチ」、2013 IEEEE第2回クラウドネットワーキングに関する国際会議（CloudNet）、DOI 10.1109/CloudNet.2013.6710576、2013年11月、&lt;https://doi.org/10.1109/cloudnet.2013.6710576&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CEHRX09] Cai, H., Eun, D., Ha, S., Rhee, I., and L. Xu, &#34;Stochastic convex ordering for multiplicative decrease internet congestion control&#34;, Computer Networks, vol. 53, no. 3, pp. 365-381, DOI 10.1016/j.comnet.2008.10.012, February 2009, &lt;https://doi.org/10.1016/j.comnet.2008.10.012&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Cehrx09] Cai、H.、Eun、D.、Ha、S.、Rhee、I。、およびL. Xu、「多重化のための確率的凸順序インターネット輻輳制御」、Computer Networks、vol。53、いいえ。3、pp。365-381、doi 10.1016/j.comnet.2008.10.012、2009年2月、&lt;https://doi.org/10.1016/j.comnet.2008.10.012&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FHP00] Floyd, S., Handley, M., and J. Padhye, &#34;A Comparison of Equation-Based and AIMD Congestion Control&#34;, May 2000, &lt;https://www.icir.org/tfrc/aimd.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FHP00] Floyd、S.、Handley、M。、およびJ. Padhye、「方程式ベースとAIMDの混雑制御の比較」、2000年5月&lt;https://www.icir.org/tfrc/aimd.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GV02] Gorinsky, S. and H. Vin, &#34;Extended Analysis of Binary Adjustment Algorithms&#34;, Technical Report TR2002-39, Department of Computer Sciences, The University of Texas at Austin, August 2002, &lt;https://citeseerx.ist.psu.edu/doc ument?repid=rep1&amp;type=pdf&amp;doi=1828bdcef118b02d3996b8e00b8a aa92b50abb0f&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GV02] Gorinsky、S。およびH. Vin、「バイナリ調整アルゴリズムの拡張分析」、テクニカルレポートTR2002-39、2002年8月、オースティンのテキサス大学コンピューターサイエンス学科、&lt;https://citeseerx.istist.psu.edu/doc ument？repid = rep1＆type = pdf＆doi = 1828bdcef118b02d3996b8e00b8a aa92bb50abb0f&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[H16] Ha, S., &#34;Deployment, Testbed, and Simulation Results for CUBIC&#34;, Wayback Machine archive, 3 November 2016, &lt;https://web.archive.org/web/20161118125842/ http://netsrv.csc.ncsu.edu/wiki/index.php/TCP_Testing&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[H16] HA、S。、「キュービックの展開、テストベッド、およびシミュレーション結果」、Wayback Machine Archive、2016年11月3日、&lt;https://web.archive.org/web/201611118125842/ http：//netsrv.cscs.ncsu.edu/wiki/index.php/tcp_testing&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HLRX07] Ha, S., Le, L., Rhee, I., and L. Xu, &#34;Impact of background traffic on performance of high-speed TCP variant protocols&#34;, Computer Networks, vol. 51, no. 7, pp. 1748-1762, DOI 10.1016/j.comnet.2006.11.005, May 2007, &lt;https://doi.org/10.1016/j.comnet.2006.11.005&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HLRX07] Ha、S.、Le、L.、Rhee、I。、およびL. Xu、「高速TCPバリアントプロトコルのパフォーマンスに対するバックグラウンドトラフィックの影響」、コンピューターネットワーク、Vol。51、いいえ。7、pp。1748-1762、doi 10.1016/j.comnet.2006.11.005、2007年5月、&lt;https://doi.org/10.1016/j.comnet.2006.11.005&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HR11] Ha, S. and I. Rhee, &#34;Taming the elephants: New TCP slow start&#34;, Computer Networks, vol. 55, no. 9, pp. 2092-2110, DOI 10.1016/j.comnet.2011.01.014, June 2011, &lt;https://doi.org/10.1016/j.comnet.2011.01.014&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HR11] HA、S。およびI. Rhee、「象の飼いならされた：新しいTCPスロースタート」、コンピューターネットワーク、Vol。55、いいえ。9、pp。2092-2110、doi 10.1016/j.comnet.2011.01.014、2011年6月、&lt;https://doi.org/10.1016/j.comnet.2011.01.014&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HRX08] Ha, S., Rhee, I., and L. Xu, &#34;CUBIC: a new TCP-friendly high-speed TCP variant&#34;, ACM SIGOPS Operating Systems Review, vol. 42, no. 5, pp. 64-74, DOI 10.1145/1400097.1400105, July 2008, &lt;https://doi.org/10.1145/1400097.1400105&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HRX08] Ha、S.、Rhee、I。、およびL. Xu、「Cubic：A New TCPに優しい高速TCPバリアント」、ACM Sigopsオペレーティングシステムレビュー、Vol。42、いいえ。5、pp。64-74、DOI 10.1145/1400097.1400105、2008年7月、&lt;https://doi.org/10.1145/1400097.1400105&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[K03] Kelly, T., &#34;Scalable TCP: improving performance in highspeed wide area networks&#34;, ACM SIGCOMM Computer Communication Review, vol. 33, no. 2, pp. 83-91, DOI 10.1145/956981.956989, April 2003, &lt;https://doi.org/10.1145/956981.956989&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[K03] Kelly、T。、「スケーラブルTCP：高速幅の広いエリアネットワークのパフォーマンスの向上」、ACM Sigcomm Computer Communication Review、Vol。33、いいえ。2、pp。83-91、DOI 10.1145/956981.956989、2003年4月、&lt;https://doi.org/10.1145/956981.956989&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LBEWK16] Lukaseder, T., Bradatsch, L., Erb, B., Van Der Heijden, R., and F. Kargl, &#34;A Comparison of TCP Congestion Control Algorithms in 10G Networks&#34;, 2016 IEEE 41st Conference on Local Computer Networks (LCN), DOI 10.1109/lcn.2016.121, November 2016, &lt;https://doi.org/10.1109/lcn.2016.121&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LBEWK16] Lukaseder、T.、Bradatsch、L.、Erb、B.、van der Heijden、R。、およびF. Kargl、「10GネットワークにおけるTCP輻輳制御アルゴリズムの比較」、2016 IEEE 41st Conference on Local Computerネットワーク（LCN）、DOI 10.1109/LCN.2016.121、2016年11月、&lt;https://doi.org/10.1109/lcn.2016.121&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LIU16] Liu, K. and J. Lee, &#34;On Improving TCP Performance over Mobile Data Networks&#34;, IEEE Transactions on Mobile Computing, vol. 15, no. 10, pp. 2522-2536, DOI 10.1109/tmc.2015.2500227, October 2016, &lt;https://doi.org/10.1109/tmc.2015.2500227&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Liu16] Liu、K。およびJ. Lee、「モバイルデータネットワーク上のTCPパフォーマンスの改善」、IEEEトランザクションに関するモバイルコンピューティング、Vol。15、いいえ。10、pp。2522-2536、doi 10.1109/tmc.2015.2500227、2016年10月、&lt;https://doi.org/10.1109/tmc.2015.2500227&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3522] Ludwig, R. and M. Meyer, &#34;The Eifel Detection Algorithm for TCP&#34;, RFC 3522, DOI 10.17487/RFC3522, April 2003, &lt;https://www.rfc-editor.org/info/rfc3522&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3522] Ludwig、R。およびM. Meyer、「TCPのEIFEL検出アルゴリズム」、RFC 3522、DOI 10.17487/RFC3522、2003年4月、&lt;https://www.rfc-editor.org/info/rfc3522&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3649] Floyd, S., &#34;HighSpeed TCP for Large Congestion Windows&#34;, RFC 3649, DOI 10.17487/RFC3649, December 2003, &lt;https://www.rfc-editor.org/info/rfc3649&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3649] Floyd、S。、「大鬱血窓用の高速TCP」、RFC 3649、DOI 10.17487/RFC3649、2003年12月、&lt;https://www.rfc-editor.org/info/rfc369&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3708] Blanton, E. and M. Allman, &#34;Using TCP Duplicate Selective Acknowledgement (DSACKs) and Stream Control Transmission Protocol (SCTP) Duplicate Transmission Sequence Numbers (TSNs) to Detect Spurious Retransmissions&#34;, RFC 3708, DOI 10.17487/RFC3708, February 2004, &lt;https://www.rfc-editor.org/info/rfc3708&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3708] Blanton、E。およびM. Allman、「TCPを使用して、TCPを複製する選択的承認（DSACK）およびストリーム制御伝送プロトコル（SCTP）重複透過シーケンス番号（TSN）を使用して、偽りの再送信を検出します」、RFC 3708、DOI 10.17487/RFC3708、2004年2月、&lt;https://www.rfc-editor.org/info/rfc3708&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3742] Floyd, S., &#34;Limited Slow-Start for TCP with Large Congestion Windows&#34;, RFC 3742, DOI 10.17487/RFC3742, March 2004, &lt;https://www.rfc-editor.org/info/rfc3742&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3742] Floyd、S。、「大鬱血窓を備えたTCPの限定スロースタート」、RFC 3742、DOI 10.17487/RFC3742、2004年3月、&lt;https://www.rfc-editor.org/info/rfc3742&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6937] Mathis, M., Dukkipati, N., and Y. Cheng, &#34;Proportional Rate Reduction for TCP&#34;, RFC 6937, DOI 10.17487/RFC6937, May 2013, &lt;https://www.rfc-editor.org/info/rfc6937&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6937] Mathis、M.、Dukkipati、N。、およびY. Cheng、「TCPの比例速度削減」、RFC 6937、DOI 10.17487/RFC6937、2013年5月、&lt;https://www.rfc-editor.org/情報/RFC6937&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7661] Fairhurst, G., Sathiaseelan, A., and R. Secchi, &#34;Updating TCP to Support Rate-Limited Traffic&#34;, RFC 7661, DOI 10.17487/RFC7661, October 2015, &lt;https://www.rfc-editor.org/info/rfc7661&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7661] Fairhurst、G.、Sathiaseelan、A。、およびR. Secchi、「TCPを更新するためのレート制限トラフィックをサポートする」、RFC 7661、DOI 10.17487/RFC7661、2015年10月、&lt;https：//www.rfc-editor.org/info/rfc7661&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8312] Rhee, I., Xu, L., Ha, S., Zimmermann, A., Eggert, L., and R. Scheffenegger, &#34;CUBIC for Fast Long-Distance Networks&#34;, RFC 8312, DOI 10.17487/RFC8312, February 2018, &lt;https://www.rfc-editor.org/info/rfc8312&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8312] Rhee、I.、Xu、L.、Ha、S.、Zimmermann、A.、Eggert、L。、およびR. Scheffenegger、「高速距離ネットワークのための立方」、RFC 8312、DOI 10.17487/RFC83122、2018年2月、&lt;https://www.rfc-editor.org/info/rfc8312&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8511] Khademi, N., Welzl, M., Armitage, G., and G. Fairhurst, &#34;TCP Alternative Backoff with ECN (ABE)&#34;, RFC 8511, DOI 10.17487/RFC8511, December 2018, &lt;https://www.rfc-editor.org/info/rfc8511&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8511] Khademi、N.、Welzl、M.、Armitage、G。、およびG. Fairhurst、「ECN（ABE）とのTCP代替バックオフ」、RFC 8511、DOI 10.17487/RFC8511、2018年12月、&lt;https：//www.rfc-editor.org/info/rfc8511&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9000] Iyengar, J., Ed. and M. Thomson, Ed., &#34;QUIC: A UDP-Based Multiplexed and Secure Transport&#34;, RFC 9000, DOI 10.17487/RFC9000, May 2021, &lt;https://www.rfc-editor.org/info/rfc9000&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9000] Iyengar、J.、ed。and M. Thomson、ed。、「Quic：UDPベースの多重化および安全な輸送」、RFC 9000、DOI 10.17487/RFC9000、2021年5月、&lt;https://www.rfc-editor.org/info/rfc9000&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9260] Stewart, R., Txen, M., and K. Nielsen, &#34;Stream Control Transmission Protocol&#34;, RFC 9260, DOI 10.17487/RFC9260, June 2022, &lt;https://www.rfc-editor.org/info/rfc9260&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9260] Stewart、R.、Txen、M。、およびK. Nielsen、「Stream Control Transmission Protocol」、RFC 9260、DOI 10.17487/RFC9260、2022年6月、&lt;https://www.rfc-editor.org/info/RFC9260&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SXEZ19] Sun, W., Xu, L., Elbaum, S., and D. Zhao, &#34;Model-Agnostic and Efficient Exploration of Numerical Congestion Control State Space of Real-World TCP Implementations&#34;, IEEE/ACM Transactions on Networking, vol. 29, no. 5, pp. 1990-2004, DOI 10.1109/tnet.2021.3078161, October 2021, &lt;https://doi.org/10.1109/tnet.2021.3078161&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Sxez19] Sun、W.、Xu、L.、Elbaum、S。、およびD. Zhao、「現実世界のTCP実装の数値輻輳制御状態空間のモデルに依存して効率的な調査」、ネットワーク上のIEEE/ACMトランザクション、Vol。29、いいえ。5、pp。1990-2004、doi 10.1109/tnet.2021.3078161、2021年10月、&lt;https://doi.org/10.1109/tnet.2021.3078161&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XHR04] Xu, L., Harfoush, K., and I. Rhee, &#34;Binary increase congestion control (BIC) for fast long-distance networks&#34;, IEEE INFOCOM 2004, DOI 10.1109/infcom.2004.1354672, March 2004, &lt;https://doi.org/10.1109/infcom.2004.1354672&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Xhr04] Xu、L.、Harfoush、K。、およびI. Rhee、「高速距離ネットワークのバイナリ増加渋滞制御（BIC）」、IEEE InfoCom 2004、DOI 10.1109/INFCOM.2004.1354672、2004年3月、&lt;httpsps：//doi.org/10.1109/infcom.2004.1354672&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-A--Evolution-of-CUBIC-since-the-Original-Paper">
Appendix A. Evolution of CUBIC since the Original Paper
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録A. 元の論文以来のキュービックの進化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CUBIC has gone through a few changes since the initial release [HRX08] of its algorithm and implementation. This appendix highlights the differences between the original paper and [RFC8312].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cubicは、アルゴリズムと実装の最初のリリース[HRX08]以来、いくつかの変更を行ってきました。この付録は、元の論文と[RFC8312]の違いを強調しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The original paper [HRX08] includes the pseudocode of CUBIC implementation using Linux&#39;s pluggable congestion control framework, which excludes system-specific optimizations. The simplified pseudocode might be a good starting point for learning about CUBIC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 元の論文[HRX08]には、システム固有の最適化を除外するLinuxのプラグ可能な渋滞制御フレームワークを使用した立方体実装の擬似コードが含まれています。単純化された擬似コードは、Cubicについて学ぶための良い出発点かもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* [HRX08] also includes experimental results showing its performance and fairness.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* [HRX08]には、そのパフォーマンスと公平性を示す実験結果も含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The definition of the __cubic_ constant was changed in [RFC8312]. For example, __cubic_ in the original paper was referred to as the window decrease constant, while [RFC8312] changed it to &#34;CUBIC multiplicative decrease factor&#34;. With this change, the current congestion window size after a congestion event as listed in [RFC8312] was __cubic_ * _W_max_, while it was (1-__cubic_) * _W_max_ in the original paper.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* __CUBIC_定数の定義は[RFC8312]で変更されました。たとえば、元の論文の__CUBIC_は、ウィンドウの減少定数と呼ばれ、[RFC8312]は「Cubic Multiplicative Declase係数」に変更されました。この変更により、[RFC8312]にリストされている輻輳イベントの後の現在の混雑ウィンドウサイズは、__cubic_ * _w_max_でしたが、元の論文の（1 -__ cubic_） * _w_max_でした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Its pseudocode used _W_(last_max)_, while [RFC8312] used _W_max_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* その擬似コードは_W_（last_max）_を使用し、[rfc8312]は_w_max_を使用しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Its AIMD-friendly window was _W_tcp_, while [RFC8312] used _W_est_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* AIMDに優しいウィンドウは_W_TCP_でしたが、[RFC8312]は_W_est_を使用しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-B--Proof-of-the-Average-CUBIC-Window-Size">
Appendix B. Proof of the Average CUBIC Window Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録B. 平均立方窓サイズの証明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This appendix contains a proof for the average CUBIC window size _AVG_W_cubic_ in Figure 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この付録には、図6の平均立方ウィンドウサイズ_AVG_W_CUBIC_の証拠が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We find _AVG_W_cubic_ under a deterministic loss model, where the number of packets between two successive packet losses is 1/_p_. With this model, CUBIC always operates with the concave window profile and the time period between two successive packet losses is _K_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つの連続したパケット損失の間のパケットの数は1/_P_である決定論的損失モデルの下で_AVG_W_CUBIC_を見つけます。このモデルでは、Cubicは常に凹面のウィンドウプロファイルで動作し、2つの連続したパケット損失の間の期間は_K_です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The average window size _AVG_W_cubic_ is defined as follows, where the numerator 1/_p_ is the total number of packets between two successive packet losses and the denominator _K_/_RTT_ is the total number of RTTs between two successive packet losses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
平均ウィンドウサイズ_AVG_W_CUBIC_は次のように定義されます。ここで、分子1/_P_は2つの連続したパケット損失と分母_K _/_ RTT_の間のパケットの総数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-29">
 1 p AVG_W = cubic K RTT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-29">
1 P avg_w = cubic k rtt
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
Figure 9
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
図9
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Below, we find _K_ as a function of CUBIC parameters __cubic_ and _C_, and network parameters _p_ and _RTT_. According to the definition of _K_ in Figure 2, we have
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下に、_K_は立方パラメーター__CUBIC_および_C_、およびネットワークパラメーター_P_および_RTT_の関数として見つかります。図2の_K_の定義によれば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-30">
 3 W - W * max max cubic K = C
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-30">
3 w -w * max max max cubic k = c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 10
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
図10
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The total number of packets between two successive packet losses can also be obtained as follows, using the window increase function in Figure 1. Specifically, the window size in the first RTT (i.e., _n_=1, or equivalently, _t_=0) is _C_(-_K_)^3+_W_max_ and the window size in the last RTT (i.e., _n_=_K_/_RTT_, or equivalently, _t_=_K_- _RTT_) is _C_(-_RTT_)^3+_W_max_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図1のウィンドウ増加関数を使用して、2つの連続したパケット損失の間のパケットの総数も次のように取得できます。具体的には、最初のRTTのウィンドウサイズ（つまり、_n_ = 1、または同等に、_t_ = 0）はです。_c _（-_ k _）^3 _w_max_および最後のRTTのウィンドウサイズ（つまり、_n _ = _ k _/_ rtt_、または同等に、_t _ = _ k_-_rtt_）は_c _（-_ rtt _）^3 _w_max_。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       K

                      RTT

                  1                     3       
                   =   C((n-1) * RTT-K)  + W   
                  p                         max
                      n=1
                       K

                      RTT

                               3    3       
                    =   C * RTT (-n)  + W   
                                        max
                      n=1
                                   K

                                  RTT

                              3       3           K
                    = -C * RTT  *    n  + W    * 
                                          max   RTT
                                  n=1
                                          4
                              3   1   K             K
                     -C * RTT  *  *  + W    * 
                                  4  RTT     max   RTT
                                 4
                           1    K            K
                    = -C *  *  + W    * 
                           4   RTT    max   RTT
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 11
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
図11
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After solving the equations in Figures 10 and 11 for _K_ and _W_max_, we have
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_k_および_w_max_の図10および11の方程式を解くと、私たちは持っています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">

                                     4 * 1-     
                                 4          cubic    RTT
                             K =    * 
                                   C * 3 +          p
                                            cubic
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 12
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
図12
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The average CUBIC window size _AVG_W_cubic_ can be obtained by substituting _K_ from Figure 12 in Figure 9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図9の図12から_K_を置換することにより、平均立方ウィンドウサイズ_AVG_W_CUBIC_を取得できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                            1       
                                   C * 3 +            3
                            p    4           cubic   RTT
              AVG_W      =  =    * 
                   cubic    K       4 * 1-           3
                                        cubic     p
                           RTT
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Richard Scheffenegger and Alexander Zimmermann originally coauthored [RFC8312].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リチャード・シェフェンガーとアレクサンダー・ジマーマンは元々共著[RFC8312]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These individuals suggested improvements to this document:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの個人は、このドキュメントの改善を提案しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Bob Briscoe<br>* Christian Huitema<br>* Gorry Fairhurst<br>* Jonathan Morton<br>* Juhamatti Kuusisaari<br>* Junho Choi<br>* Markku Kojo<br>* Martin Duke<br>* Martin Thomson<br>* Matt Mathis<br>* Matt Olson<br>* Michael Welzl<br>* Mirja Khlewind<br>* Mohit P. Tahiliani<br>* Neal Cardwell<br>* Praveen Balasubramanian<br>* Randall Stewart<br>* Richard Scheffenegger<br>* Rod Grimes<br>* Spencer Dawkins<br>* Tom Henderson<br>* Tom Petch<br>* Wesley Rosenblum<br>* Yoav Nir<br>* Yoshifumi Nishida<br>* Yuchung Cheng
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
*ボブ・ブリスコ<br>*クリスチャンフイテマ<br>* Gorry Fairhurst<br>*ジョナサンモートン<br>* Juhamatti Kuusisaari<br>* Junho Choi<br>* Markku Kojo<br>*マーティンデューク<br>*マーティン・トムソン<br>*マット・マティス<br>*マット・オルソン<br>*マイケル・ウェルツル<br>* Mirja Khlewind<br>* Mohit P. Tahiliani<br>*ニール・カードウェル<br>* Praveen Balasubramanian<br>*ランドール・スチュワート<br>*リチャード・シェフェンガー<br>*ロッドグライム<br>*スペンサードーキンス<br>*トム・ヘンダーソン<br>*トム・ペッチ<br>* Wesley Rosenblum<br>* yoav nir<br>*ヨシフミ西田<br>* Yuchung Cheng
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lisong Xu University of Nebraska-Lincoln Department of Computer Science and Engineering Lincoln, NE 68588-0115 United States of America Email: xu@unl.edu URI: https://cse.unl.edu/~xu/
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソングXUネブラスカ大学リンカーン大学コンピュータサイエンスエンジニアリング局リンカーン、NE 68588-0115アメリカ合衆国電子メール：xu@unl.edu URI：https：//cse.unl.edu/~xu/
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sangtae Ha University of Colorado at Boulder Department of Computer Science Boulder, CO 80309-0430 United States of America Email: sangtae.ha@colorado.edu URI: https://netstech.org/sangtaeha/
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コロラド州サンタエ校ボルダー校コンピュータサイエンス科、コロラド州80309-0430アメリカ合衆国電子メール：sangtae.ha@colorado.edu uri：https：//netstech.org/sangtaeha/
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Injong Rhee Bowery Farming 151 W 26th Street, 12th Floor New York, NY 10001 United States of America Email: injongrhee@gmail.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Injong Rhee Bowery Farming 151 W 26th Street、12階ニューヨーク、ニューヨーク10001アメリカ合衆国電子メール：injongrhee@gmail.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Vidhi Goel Apple Inc. One Apple Park Way Cupertino, CA 95014 United States of America Email: vidhi_goel@apple.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Vidhi Goel Apple Inc. One Apple Park Way Cupertino、CA 95014アメリカ合衆国電子メール：vidhi_goel@apple.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lars Eggert (editor) NetApp Stenbergintie 12 B FI-02700 Kauniainen Finland Email: lars@eggert.org URI: https://eggert.org/
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lars Eggert（編集者）NetApp Stenbergintie 12 B FI-02700 Kauniainen Finland Email：lars@eggert.org Uri：https：//eggert.org/
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
