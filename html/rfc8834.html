<!DOCTYPE html>


<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 8834 - Media Transport and Use of RTP in WebRTC 日本語訳</title>

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">8834</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc8834">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 8834 - Media Transport and Use of RTP in WebRTC 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc8834">
            https://datatracker.ietf.org/doc/html/rfc8834
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 8834 - WebRTCにおけるメディア輸送とRTPの使用</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <h6 class="card-title">要約（自動生成）</h6>
            <p class="card-text">RFC 8834は、WebRTC (Web Real-Time Communication) アプリケーションにおけるメディアトランスポートとRTP (Real-time Transport Protocol) の使用に関するガイドラインを提供します。この文書の目的は、Webブラウザやその他のデバイス間でのリアルタイムのオーディオ、ビデオ、データ通信を可能にするための標準的な方法を定義することにあります。利用場面としては、ビデオ会議、ライブストリーミング、ファイル共有など、リアルタイム通信が必要なあらゆるWebアプリケーションが挙げられます。関連するRFCには、RFC 3550 (RTPの基本仕様)、RFC 7742 (WebRTCビデオ通信の使用)、RFC 7874 (WebRTCのデータチャネルの使用) などがあります。これらの文書と合わせて、WebRTC技術の全体像とそのインターネット上での実装方法が理解できます。</p>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                        C. Perkins
Request for Comments: 8834                         University of Glasgow
Category: Standards Track                                  M. Westerlund
ISSN: 2070-1721                                                 Ericsson
                                                                  J. Ott
                                             Technical University Munich
                                                            January 2021
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
Media Transport and Use of RTP in WebRTC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
WebRTCにおけるメディア輸送とRTPの使用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The framework for Web Real-Time Communication (WebRTC) provides support for direct interactive rich communication using audio, video, text, collaboration, games, etc. between two peers&#39; web browsers. This memo describes the media transport aspects of the WebRTC framework. It specifies how the Real-time Transport Protocol (RTP) is used in the WebRTC context and gives requirements for which RTP features, profiles, and extensions need to be supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Webリアルタイム通信（WebRTC）のためのフレームワークは、2つのピアのWebブラウザ間のオーディオ、ビデオ、テキスト、コラボレーション、ゲームなどを使用して直接的なインタラクティブリッチ通信をサポートします。このメモは、WebRTCフレームワークのメディアトランスポートの側面を説明しています。リアルタイムトランスポートプロトコル（RTP）をWEBRTCコンテキストで使用する方法を指定し、どのRTP機能、プロファイル、および拡張機能をサポートする必要がある要件を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これはインターネット規格のトラック文書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表します。それは公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による出版の承認を受けました。インターネット規格に関する詳細情報は、RFC 7841のセクション2で利用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8834.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書の現在のステータス、任意のエラータ、およびフィードバックを提供する方法に関する情報は、https：//www.rfc-editor.org/info/rfc8834で取得できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2021 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）2021 IETF信頼と文書著者として識別された人。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、この文書の公開日に有効なIETF文書（https://truste.ietf.org/License-info）に関するBCP 78とIETF信頼の法的規定を受けています。この文書に関してあなたの権利と制限を説明するので、これらの文書を慎重に見直してください。この文書から抽出されたコードコンポーネントには、信頼法の法的規定のセクション4。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction
   2.  Rationale
   3.  Terminology
   4.  WebRTC Use of RTP: Core Protocols
     4.1.  RTP and RTCP
     4.2.  Choice of the RTP Profile
     4.3.  Choice of RTP Payload Formats
     4.4.  Use of RTP Sessions
     4.5.  RTP and RTCP Multiplexing
     4.6.  Reduced Size RTCP
     4.7.  Symmetric RTP/RTCP
     4.8.  Choice of RTP Synchronization Source (SSRC)
     4.9.  Generation of the RTCP Canonical Name (CNAME)
     4.10. Handling of Leap Seconds
   5.  WebRTC Use of RTP: Extensions
     5.1.  Conferencing Extensions and Topologies
       5.1.1.  Full Intra Request (FIR)
       5.1.2.  Picture Loss Indication (PLI)
       5.1.3.  Slice Loss Indication (SLI)
       5.1.4.  Reference Picture Selection Indication (RPSI)
       5.1.5.  Temporal-Spatial Trade-Off Request (TSTR)
       5.1.6.  Temporary Maximum Media Stream Bit Rate Request (TMMBR)
     5.2.  Header Extensions
       5.2.1.  Rapid Synchronization
       5.2.2.  Client-to-Mixer Audio Level
       5.2.3.  Mixer-to-Client Audio Level
       5.2.4.  Media Stream Identification
       5.2.5.  Coordination of Video Orientation
   6.  WebRTC Use of RTP: Improving Transport Robustness
     6.1.  Negative Acknowledgements and RTP Retransmission
     6.2.  Forward Error Correction (FEC)
   7.  WebRTC Use of RTP: Rate Control and Media Adaptation
     7.1.  Boundary Conditions and Circuit Breakers
     7.2.  Congestion Control Interoperability and Legacy Systems
   8.  WebRTC Use of RTP: Performance Monitoring
   9.  WebRTC Use of RTP: Future Extensions
   10. Signaling Considerations
   11. WebRTC API Considerations
   12. RTP Implementation Considerations
     12.1.  Configuration and Use of RTP Sessions
       12.1.1.  Use of Multiple Media Sources within an RTP Session
       12.1.2.  Use of Multiple RTP Sessions
       12.1.3.  Differentiated Treatment of RTP Streams
     12.2.  Media Source, RTP Streams, and Participant Identification
       12.2.1.  Media Source Identification
       12.2.2.  SSRC Collision Detection
       12.2.3.  Media Synchronization Context
   13. Security Considerations
   14. IANA Considerations
   15. References
     15.1.  Normative References
     15.2.  Informative References
   Acknowledgements
   Authors&#39; Addresses
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Real-time Transport Protocol (RTP) [RFC3550] provides a framework for delivery of audio and video teleconferencing data and other real-time media applications. Previous work has defined the RTP protocol, along with numerous profiles, payload formats, and other extensions. When combined with appropriate signaling, these form the basis for many teleconferencing systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リアルタイムトランスポートプロトコル（RTP）[RFC3550]は、オーディオおよびビデオのテレビ会議データやその他のリアルタイムメディアアプリケーションを配信するためのフレームワークを提供します。以前の作業は、多数のプロファイル、ペイロードフォーマット、およびその他の拡張とともに、RTPプロトコルを定義しました。適切なシグナリングと組み合わせると、これらは多くのテレビ会議システムの基礎を形成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Web Real-Time Communication (WebRTC) framework provides the protocol building blocks to support direct, interactive, real-time communication using audio, video, collaboration, games, etc. between two peers&#39; web browsers. This memo describes how the RTP framework is to be used in the WebRTC context. It proposes a baseline set of RTP features that are to be implemented by all WebRTC endpoints, along with suggested extensions for enhanced functionality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Webリアルタイム通信（WebRTC）フレームワークは、2つのピアのWebブラウザ間のオーディオ、ビデオ、コラボレーション、ゲームなどを使用して、ダイレクト、インタラクティブ、リアルタイム通信をサポートするプロトコルビルディングブロックを提供します。このメモは、rtpフレームワークをWebRTCコンテキストで使用する方法を説明しています。これは、すべてのWebRTCエンドポイントによって実装されるべきRTP機能のベースラインセットを提案します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo specifies a protocol intended for use within the WebRTC framework but is not restricted to that context. An overview of the WebRTC framework is given in [RFC8825].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、WebRTCフレームワーク内での使用を目的としたプロトコルを指定しますが、そのコンテキストに限られません。WebRTCフレームワークの概要は[RFC8825]に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The structure of this memo is as follows. Section 2 outlines our rationale for preparing this memo and choosing these RTP features. Section 3 defines terminology. Requirements for core RTP protocols are described in Section 4, and suggested RTP extensions are described in Section 5. Section 6 outlines mechanisms that can increase robustness to network problems, while Section 7 describes congestion control and rate adaptation mechanisms. The discussion of mandated RTP mechanisms concludes in Section 8 with a review of performance monitoring and network management tools. Section 9 gives some guidelines for future incorporation of other RTP and RTP Control Protocol (RTCP) extensions into this framework. Section 10 describes requirements placed on the signaling channel. Section 11 discusses the relationship between features of the RTP framework and the WebRTC application programming interface (API), and Section 12 discusses RTP implementation considerations. The memo concludes with security considerations (Section 13) and IANA considerations (Section 14).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモの構造は以下の通りです。セクション2は、このメモを準備し、これらのRTP機能を選択するための根拠の概要を示しています。セクション3は用語を定義します。コアRTPプロトコルの要件はセクション4で説明されており、推奨されるRTP拡張機能はセクション5で説明されています。セクション6では、ネットワークの問題に対する堅牢性を高めることができるメカニズムの概要、7は輻輳制御とレート適応メカニズムを説明します。義務付けられたRTPメカニズムの議論はセクション8では、パフォーマンス監視およびネットワーク管理ツールのレビューを締結しています。セクション9は、このフレームワークへの他のRTPおよびRTP制御プロトコル（RTCP）拡張の将来の組み込みのためのガイドラインを提供します。セクション10は、シグナリングチャネル上に配置された要件を説明しています。セクション11は、RTPフレームワークの機能とWebRTCアプリケーションプログラミングインタフェース（API）との関係を説明し、セクション12はRTP実装の考慮事項について説明します。メモはセキュリティ上の考慮事項（セクション13）とIANAの考慮事項（第14節）を締結しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Rationale">
2. Rationale
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 根拠
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RTP framework comprises the RTP data transfer protocol, the RTP control protocol, and numerous RTP payload formats, profiles, and extensions. This range of add-ons has allowed RTP to meet various needs that were not envisaged by the original protocol designers and support many new media encodings, but it raises the question of what extensions are to be supported by new implementations. The development of the WebRTC framework provides an opportunity to review the available RTP features and extensions and define a common baseline RTP feature set for all WebRTC endpoints. This builds on the past 20 years of RTP development to mandate the use of extensions that have shown widespread utility, while still remaining compatible with the wide installed base of RTP implementations where possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPフレームワークは、RTPデータ転送プロトコル、RTP制御プロトコル、および多数のRTPペイロードフォーマット、プロファイル、および拡張機能を備えています。この範囲のアドオンは、RTPが元のプロトコル設計者によって想定されていないさまざまなニーズを満たし、多くの新しいメディアエンコーディングをサポートしていますが、新しい実装でどの拡張をサポートするかという問題が発生します。WebRTCフレームワークの開発は、利用可能なRTP機能と拡張機能を見直し、すべてのWebRTCエンドポイントに共通のベースラインRTP機能を定義する機会を提供します。これは、幅広いユーティリティを示している拡張機能の使用を義務付けるために、過去20年間のRTP開発に基づいていますが、可能な限りRTP実装の広い幅広いベースと互換性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP and RTCP extensions that are not discussed in this document can be implemented by WebRTC endpoints if they are beneficial for new use cases. However, they are not necessary to address the WebRTC use cases and requirements identified in [RFC7478].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントで説明されていないRTPおよびRTCP拡張は、新しいユースケースに有益である場合は、WEBRTCエンドポイントによって実装できます。ただし、[RFC7478]で識別されたWebRTCの使用例と要件に対処する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the baseline set of RTP features and extensions defined in this memo is targeted at the requirements of the WebRTC framework, it is expected to be broadly useful for other conferencing-related uses of RTP. In particular, it is likely that this set of RTP features and extensions will be appropriate for other desktop or mobile video-conferencing systems, or for room-based high-quality telepresence applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモに定義されているRTP機能と拡張機能のベースラインセットは、WebRTCフレームワークの要件を標的としていますが、RTPの他の会議関連の使用にとって広く役立つと予想されます。特に、このRTP機能と拡張機能のセットは、他のデスクトップまたはモバイルビデオ会議システム、または部屋ベースの高品質のテレプレゼンスアプリケーションに適している可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Terminology">
3. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here. Lower- or mixed-case uses of these key words are not to be interpreted as carrying special significance in this memo.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「必須」、「必須」、「必須」、「SHALL」、「必ず」、「推奨する」、「推奨する」、「推奨する」、「推奨する」、「推奨する」、「5月」「この文書では、BCP 14 [RFC2119] [RFC8174]に記載されている場合に解釈されるべきであり、ここに示すように、すべての首都に表示されます。これらのキーワードの下位または混血の使用は、このメモで特別な意味を持つと解釈されるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We define the following additional terms:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の追加の用語を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebRTC MediaStream: The MediaStream concept defined by the W3C in the WebRTC API [W3C.WD-mediacapture-streams]. A MediaStream consists of zero or more MediaStreamTracks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebRTC MediaStream：WABRTC API [W3C.WD-MediaCapture-Streams]のW3Cによって定義されたMediastreamの概念。MediaStreamは、ゼロ以上のメディアストレアトラックで構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MediaStreamTrack: Part of the MediaStream concept defined by the W3C in the WebRTC API [W3C.WD-mediacapture-streams]. A MediaStreamTrack is an individual stream of media from any type of media source such as a microphone or a camera, but conceptual sources such as an audio mix or a video composition are also possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MediastreamTrack：W3Cで定義されたMediaStream概念の一部。webrtc API [w3c.wd-mediaiacapture-streams]。MediaStreamTrackは、マイクロフォンやカメラなどの任意の種類のメディアソースからのメディアの個々のストリームであるが、オーディオミックスやビデオ構成などの概念的な情報源も可能である。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transport-layer flow: A unidirectional flow of transport packets that are identified by a particular 5-tuple of source IP address, source port, destination IP address, destination port, and transport protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランスポート層の流れ：ソースIPアドレス、送信元ポート、宛先IPアドレス、宛先ポート、およびトランスポートプロトコルの特定の5タプルによって識別されるトランスポートパケットの一方向フロー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bidirectional transport-layer flow: A bidirectional transport-layer flow is a transport-layer flow that is symmetric. That is, the transport-layer flow in the reverse direction has a 5-tuple where the source and destination address and ports are swapped compared to the forward path transport-layer flow, and the transport protocol is the same.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
双方向輸送層の流れ：双方向輸送層の流れは対称的な輸送層の流れです。すなわち、逆方向のトランスポート層の流れは、順方向経路トランスポート層の流れと比較して、送信元アドレスとポートが交換され、トランスポートプロトコルは同じである。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document uses the terminology from [RFC7656] and [RFC8825]. Other terms are used according to their definitions from the RTP specification [RFC3550]. In particular, note the following frequently used terms: RTP stream, RTP session, and endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この資料は[RFC7656]から[RFC8825]の用語を使用しています。他の用語はRTP仕様[RFC3550]からのそれらの定義に従って使用されます。特に、次の頻繁に使用される用語：RTP Stream、RTPセッション、およびエンドポイントに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--WebRTC-Use-of-RTP-Core-Protocols">
4. WebRTC Use of RTP: Core Protocols
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. WebRTC RTPの使用：コアプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following sections describe the core features of RTP and RTCP that need to be implemented, along with the mandated RTP profiles. Also described are the core extensions providing essential features that all WebRTC endpoints need to implement to function effectively on today&#39;s networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のセクションでは、必須のRTPプロファイルとともに実装する必要があるRTPとRTCPのコア機能について説明します。また、すべてのWebRTCエンドポイントが今日のネットワーク上で効果的に機能するために実装する必要があるという本質的な機能を提供するコア拡張機能についても説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--RTP-and-RTCP">
4.1. RTP and RTCP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. RTPとRTCP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Real-time Transport Protocol (RTP) [RFC3550] is REQUIRED to be implemented as the media transport protocol for WebRTC. RTP itself comprises two parts: the RTP data transfer protocol and the RTP Control Protocol (RTCP). RTCP is a fundamental and integral part of RTP and MUST be implemented and used in all WebRTC endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リアルタイムトランスポートプロトコル（RFC3550]は、WEBRTCのメディアトランスポートプロトコルとして実装する必要があります。RTP自体は、RTPデータ転送プロトコルとRTP制御プロトコル（RTCP）の2つの部分を含む。RTCPはRTPの基本的かつ不可欠な部分であり、すべてのWebRTCエンドポイントで実装して使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following RTP and RTCP features are sometimes omitted in limited-functionality implementations of RTP, but they are REQUIRED in all WebRTC endpoints:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のRTP機能とRTCP機能は、RTPの限定機能実装では省略されることがありますが、それらはすべてのWebRTCエンドポイントで必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Support for use of multiple simultaneous synchronization source (SSRC) values in a single RTP session, including support for RTP endpoints that send many SSRC values simultaneously, following [RFC3550] and [RFC8108]. The RTCP optimizations for multi-SSRC sessions defined in [RFC8861] MAY be supported; if supported, the usage MUST be signaled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* [RFC3550]と[RFC8108]に続いて、多くのSSRC値を同時に送信するRTPエンドポイントのサポートを含む、単一のRTPセッションで複数の同時同期ソース（SSRC）値を使用するためのサポート。[RFC8861]で定義されているMulti-SSRCセッションのRTCP最適化をサポートすることができます。サポートされている場合、使用量はシグナリングされなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Random choice of SSRC on joining a session; collision detection and resolution for SSRC values (see also Section 4.8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* セッションに参加する上のSSRCのランダム選択SSRC値の衝突検出と解像度（セクション4.8を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Support for reception of RTP data packets containing contributing source (CSRC) lists, as generated by RTP mixers, and RTCP packets relating to CSRCs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* RTPミキサーによって生成された、CSRCSに関連するRTCPパケットを含む、貢献ソース（CSRC）リストを含むRTPデータパケットの受信のサポート。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Sending correct synchronization information in the RTCP Sender Reports, to allow receivers to implement lip synchronization; see Section 5.2.1 regarding support for the rapid RTP synchronization extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Receiversの同期情報をRTCP送信側レポートに送信して、受信側がLIP同期を実装できるようにします。Rapid RTP同期拡張のサポートについては、セクション5.2.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Support for multiple synchronization contexts. Participants that send multiple simultaneous RTP packet streams SHOULD do so as part of a single synchronization context, using a single RTCP CNAME for all streams and allowing receivers to play the streams out in a synchronized manner. For compatibility with potential future versions of this specification, or for interoperability with non-WebRTC devices through a gateway, receivers MUST support multiple synchronization contexts, indicated by the use of multiple RTCP CNAMEs in an RTP session. This specification mandates the usage of a single CNAME when sending RTP streams in some circumstances; see Section 4.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 複数の同期コンテキストをサポートします。複数の同時RTPパケットストリームを送信する参加者は、すべてのストリームに対して単一のRTCP CNAMEを使用して、受信側を同期してストリーミングを再生できるようにするために、単一の同期コンテキストの一部としてそうする必要があります。この仕様の将来のバージョンの互換性、またはゲートウェイを介した非WebRTCデバイスとの相互運用性との互換性のために、受信機はRTPセッションで複数のRTCP CNAMEを使用して示されている複数の同期コンテキストをサポートしなければなりません。この仕様は、状況によってRTPストリームを送信するときの単一のCNAMEの使用法を義務付けています。セクション4.9を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Support for sending and receiving RTCP Sender Report (SR), Receiver Report (RR), Source Description (SDES), and BYE packet types. Note that support for other RTCP packet types is OPTIONAL unless mandated by other parts of this specification. Note that additional RTCP packet types are used by the RTP/SAVPF profile (Section 4.2) and the other RTCP extensions (Section 5). WebRTC endpoints that implement the Session Description Protocol (SDP) bundle negotiation extension will use the SDP Grouping Framework &#34;mid&#34; attribute to identify media streams. Such endpoints MUST implement the RTCP SDES media identification (MID) item described in [RFC8843].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* RTCP送信者レポート（SR）、受信者レポート（RR）、ソース記述（SDES）、およびBYEパケットタイプの送信および受信のサポート。この仕様の他の部分で義務付けられていない限り、他のRTCPパケットタイプのサポートはオプションです。追加のRTCPパケットタイプは、RTP / SAVPFプロファイル（セクション4.2）と他のRTCP拡張機能（セクション5）によって使用されます。セッション記述プロトコル（SDP）バンドルネゴシエーション拡張機能を実装するWebRTCエンドポイントは、SDPグループ化フレームワーク「MID」属性を使用してメディアストリームを識別します。そのようなエンドポイントは、[RFC8843]に記載されているRTCP SDESメディアID（MID）項目を実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Support for multiple endpoints in a single RTP session, and for scaling the RTCP transmission interval according to the number of participants in the session; support for randomized RTCP transmission intervals to avoid synchronization of RTCP reports; support for RTCP timer reconsideration (Section 6.3.6 of [RFC3550]) and reverse reconsideration (Section 6.3.4 of [RFC3550]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 単一のRTPセッションで複数のエンドポイントをサポートし、セッション内の参加者数に応じてRTCP送信間隔をスケーリングするためのサポート。RTCPレポートの同期を回避するためのランダム化されたRTCP伝送間隔のサポート。RTCPタイマーのサポート再検討（[RFC3550]のセクション6.3.6）と逆再検討（[RFC3550]のセクション6.3.4）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Support for configuring the RTCP bandwidth as a fraction of the media bandwidth, and for configuring the fraction of the RTCP bandwidth allocated to senders -- e.g., using the SDP &#34;b=&#34; line [RFC4566] [RFC3556].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* *メディア帯域幅の一部としてRTCP帯域幅を構成するためのサポート、および送信者に割り当てられるRTCP帯域幅の一部を構成するためのサポート-たとえば、SDP &#34;b =&#34; line [RFC4566] [RFC3556]を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Support for the reduced minimum RTCP reporting interval described in Section 6.2 of [RFC3550]. When using the reduced minimum RTCP reporting interval, the fixed (nonreduced) minimum interval MUST be used when calculating the participant timeout interval (see Sections 6.2 and 6.3.5 of [RFC3550]). The delay before sending the initial compound RTCP packet can be set to zero (see Section 6.2 of [RFC3550] as updated by [RFC8108]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* [RFC3550]のセクション6.2で説明されている最小RTCPレポート間隔を減らすためのサポート。最小RTCPレポート間隔を減らすと、参加者タイムアウト間隔を計算するときに固定（不要）の最小間隔を使用する必要があります（[RFC3550のセクション6.2と6.3.5]）。初期化合物RTCPパケットを送信する前の遅延はゼロに設定できます（[RFC8108]で更新されている[RFC3550]のセクション6.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Support for discontinuous transmission. RTP allows endpoints to pause and resume transmission at any time. When resuming, the RTP sequence number will increase by one, as usual, while the increase in the RTP timestamp value will depend on the duration of the pause. Discontinuous transmission is most commonly used with some audio payload formats, but it is not audio specific and can be used with any RTP payload format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 不連続変速機の支援RTPにより、エンドポイントがいつでも送信を一時停止して再開できます。再開すると、RTPシーケンス番号は通常どおりに1つ増加しますが、RTPタイムスタンプ値の増加は一時停止期間によって異なります。不連続の送信は、一部のオーディオペイロード形式で最も一般的に使用されていますが、オーディオ固有ではなく、RTPペイロード形式で使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Ignore unknown RTCP packet types and RTP header extensions. This is to ensure robust handling of future extensions, middlebox behaviors, etc., that can result in receiving RTP header extensions or RTCP packet types that were not signaled. If a compound RTCP packet that contains a mixture of known and unknown RTCP packet types is received, the known packet types need to be processed as usual, with only the unknown packet types being discarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 不明なRTCPパケットタイプとRTPヘッダー拡張機能を無視します。これは、シグナリングされていなかったRTPヘッダー拡張子またはRTCPパケットタイプを受信する可能性がある、将来の拡張機能、ミドルボックスビヘイビアなどの堅牢な処理を確実にすることです。既知および不明なRTCPパケットタイプの混合を含む複合RTCPパケットが受信された場合、未知のパケットタイプのみが廃棄されているだけで、既知のパケットタイプを通常どおりに処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is known that a significant number of legacy RTP implementations, especially those targeted at systems with only Voice over IP (VoIP), do not support all of the above features and in some cases do not support RTCP at all. Implementers are advised to consider the requirements for graceful degradation when interoperating with legacy implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の特徴をサポートしていない場合や、すべての機能をサポートしていない場合は、かなりの数の従来のRTP実装、特にシステムを対象としたもの、および場合によってはRTCPをサポートしていないことが知られています。実装者は、レガシー実装と相互運用されるときに、優雅な劣化に対する要件を考慮することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other implementation considerations are discussed in Section 12.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その他の実施に関する考慮事項については、第12節で議論されている。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2--Choice-of-the-RTP-Profile">
4.2. Choice of the RTP Profile
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. RTPプロファイルの選択
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The complete specification of RTP for a particular application domain requires the choice of an RTP profile. For WebRTC use, the extended secure RTP profile for RTCP-based feedback (RTP/SAVPF) [RFC5124], as extended by [RFC7007], MUST be implemented. The RTP/SAVPF profile is the combination of the basic RTP/AVP profile [RFC3551], the RTP profile for RTCP-based feedback (RTP/AVPF) [RFC4585], and the secure RTP profile (RTP/SAVP) [RFC3711].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のアプリケーションドメインに対するRTPの完全な指定は、RTPプロファイルの選択を必要とします。WebRTCの使用の場合、[RFC7007]によって拡張されたRTCPベースのフィードバック（RTP / SAVPF）[RFC5124]の拡張安全なRTPプロファイルを実装する必要があります。RTP / SAVPFプロファイルは、基本的なRTP / AVPプロファイル[RFC3551]、RTCPベースのフィードバック（RTP / AVPF）[RFC4585]、およびSecure RTPプロファイル（RTP / SAVP）[RFC3711]の組み合わせです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RTCP-based feedback extensions [RFC4585] are needed for the improved RTCP timer model. This allows more flexible transmission of RTCP packets in response to events, rather than strictly according to bandwidth, and is vital for being able to report congestion signals as well as media events. These extensions also allow saving RTCP bandwidth, and an endpoint will commonly only use the full RTCP bandwidth allocation if there are many events that require feedback. The timer rules are also needed to make use of the RTP conferencing extensions discussed in Section 5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCPタイマーモデルの改良されたRTCPベースのフィードバック拡張[RFC4585]が必要です。これにより、帯域幅に応じて厳密によりもむしろイベントに応答してRTCPパケットのより柔軟な送信が可能になり、メディアイベントと同様に輻輳信号を報告できることが不可欠です。これらの拡張機能ではRTCP帯域幅を保存することもでき、フィードバックを必要とするイベントが多数ある場合にのみ、エンドポイントは一般的にフルRTCP帯域幅割り当てのみを使用します。タイマー規則は、セクション5.1で説明したRTP会議拡張機能を利用するためにも必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      |  Note: The enhanced RTCP timer model defined in the RTP/AVPF
      |  profile is backwards compatible with legacy systems that
      |  implement only the RTP/AVP or RTP/SAVP profile, given some
      |  constraints on parameter configuration such as the RTCP
      |  bandwidth value and &#34;trr-int&#34;.  The most important factor for
      |  interworking with RTP/(S)AVP endpoints via a gateway is to set
      |  the &#34;trr-int&#34; parameter to a value representing 4 seconds; see
      |  Section 7.1.3 of [RFC8108].
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The secure RTP (SRTP) profile extensions [RFC3711] are needed to provide media encryption, integrity protection, replay protection, and a limited form of source authentication. WebRTC endpoints MUST NOT send packets using the basic RTP/AVP profile or the RTP/AVPF profile; they MUST employ the full RTP/SAVPF profile to protect all RTP and RTCP packets that are generated. In other words, implementations MUST use SRTP and Secure RTCP (SRTCP). The RTP/SAVPF profile MUST be configured using the cipher suites, DTLS-SRTP protection profiles, keying mechanisms, and other parameters described in [RFC8827].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュアRTP（SRTP）プロファイル拡張[RFC3711]は、メディア暗号化、整合性保護、再生保護、および限られた形式のソース認証を提供するために必要です。WebRTCエンドポイントは、基本的なRTP / AVPプロファイルまたはRTP / AVPFプロファイルを使用してパケットを送信してはいけません。生成されたすべてのRTPパケットとRTCPパケットを保護するために、完全なRTP / SAVPFプロファイルを使用する必要があります。つまり、実装はSRTPとSecure RTCP（SRTCP）を使用する必要があります。RTP / SAVPFプロファイルは、暗号スイート、DTLS-SRTP保護プロファイル、キーイングメカニズム、および[RFC8827]に記載されているパラメータを使用して構成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3--Choice-of-RTP-Payload-Formats">
4.3. Choice of RTP Payload Formats
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. RTPペイロードフォーマットの選択
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mandatory-to-implement audio codecs and RTP payload formats for WebRTC endpoints are defined in [RFC7874]. Mandatory-to-implement video codecs and RTP payload formats for WebRTC endpoints are defined in [RFC7742]. WebRTC endpoints MAY additionally implement any other codec for which an RTP payload format and associated signaling has been defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebRTCエンドポイントの実装の必須オーディオコーデックとRTPペイロードフォーマットは[RFC7874]で定義されています。WebRTCエンドポイントのための実装の実行中のビデオコーデックとRTPペイロードフォーマットは[RFC7742]で定義されています。WEBRTCエンドポイントは、RTPペイロードフォーマットと関連シグナリングが定義されている他のコーデックをさらに実装することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebRTC endpoints cannot assume that the other participants in an RTP session understand any RTP payload format, no matter how common. The mapping between RTP payload type numbers and specific configurations of particular RTP payload formats MUST be agreed before those payload types/formats can be used. In an SDP context, this can be done using the &#34;a=rtpmap:&#34; and &#34;a=fmtp:&#34; attributes associated with an &#34;m=&#34; line, along with any other SDP attributes needed to configure the RTP payload format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRTCエンドポイントは、RTPセッションの他の参加者がRTPペイロードフォーマットを理解していると仮定することはできません。RTPペイロードタイプ数と特定のRTPペイロードフォーマットの特定の構成のマッピングは、それらのペイロードタイプ/フォーマットを使用することができる前に合意する必要があります。SDPコンテキストでは、RTPペイロードフォーマットを設定するために必要な他のSDP属性とともに、 &#34;m =&#34;行に関連付けられている &#34;a = rtpmap：&#34;と &#34;a = fmtp：&#34;属性を使用して実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints can signal support for multiple RTP payload formats or multiple configurations of a single RTP payload format, as long as each unique RTP payload format configuration uses a different RTP payload type number. As outlined in Section 4.8, the RTP payload type number is sometimes used to associate an RTP packet stream with a signaling context. This association is possible provided unique RTP payload type numbers are used in each context. For example, an RTP packet stream can be associated with an SDP &#34;m=&#34; line by comparing the RTP payload type numbers used by the RTP packet stream with payload types signaled in the &#34;a=rtpmap:&#34; lines in the media sections of the SDP. This leads to the following considerations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、各固有のRTPペイロードフォーマット構成が異なるRTPペイロードタイプ番号を使用する限り、複数のRTPペイロードフォーマットまたは単一のRTPペイロードフォーマットの複数の構成をサポートすることができます。セクション4.8で概説されているように、RTPペイロードタイプ番号は、RTPパケットストリームをシグナリングコンテキストと関連付けるために使用されることがあります。このアソシエーションは可能で提供されています。これは、各コンテキストで固有のRTPペイロードタイプ番号が使用されています。例えば、RTPパケットストリームは、RTPパケットストリームによって使用されるRTPペイロードタイプ番号と「A = RTPMAP：」行でシグナリングされているRTPペイロードタイプとを比較することによって、SDP「M =」行を関連付けることができる。SDP。これにより、以下の考慮事項がもたがります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If RTP packet streams are being associated with signaling contexts based on the RTP payload type, then the assignment of RTP payload type numbers MUST be unique across signaling contexts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RTPペイロードタイプに基づいてRTPパケットストリームがシグナリングコンテキストに関連付けられている場合、RTPペイロードタイプ番号の割り当てはシグナリングコンテキスト間で一意である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the same RTP payload format configuration is used in multiple contexts, then a different RTP payload type number has to be assigned in each context to ensure uniqueness.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
同じRTPペイロードフォーマット構成が複数のコンテキストで使用されている場合は、独自性を確保するために各コンテキストで異なるRTPペイロードタイプ番号を割り当てる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the RTP payload type number is not being used to associate RTP packet streams with a signaling context, then the same RTP payload type number can be used to indicate the exact same RTP payload format configuration in multiple contexts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RTPペイロードタイプ番号がRTPパケットストリームをシグナリングコンテキストに関連付けるために使用されていない場合、同じRTPペイロードタイプ番号を使用して、複数のコンテキストでの正確なRTPペイロードフォーマット構成を示すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A single RTP payload type number MUST NOT be assigned to different RTP payload formats, or different configurations of the same RTP payload format, within a single RTP session (note that the &#34;m=&#34; lines in an SDP BUNDLE group [RFC8843] form a single RTP session).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一のRTPペイロード形式、または単一のRTPペイロード形式、または同じRTPペイロード形式の異なる構成に割り当ててはならない（SDPバンドルグループの「M =」行[RFC8843]がフォームにするシングルRTPセッション）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint that has signaled support for multiple RTP payload formats MUST be able to accept data in any of those payload formats at any time, unless it has previously signaled limitations on its decoding capability. This requirement is constrained if several types of media (e.g., audio and video) are sent in the same RTP session. In such a case, a source (SSRC) is restricted to switching only between the RTP payload formats signaled for the type of media that is being sent by that source; see Section 4.4. To support rapid rate adaptation by changing codecs, RTP does not require advance signaling for changes between RTP payload formats used by a single SSRC that were signaled during session setup.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のRTPペイロードフォーマットに対するシグナリングサポートを受けたエンドポイントは、以前にその復号化機能に限定されていない限り、いつでもそれらのペイロードフォーマットのいずれかでデータを受け入れることができなければなりません。この要件は、同じRTPセッションでいくつかの種類のメディア（例えば、オーディオおよびビデオ）が送信されている場合に制約があります。そのような場合、ソース（SSRC）は、そのソースによって送信されているメディアの種類に対してシグナリングされたRTPペイロードフォーマットの間でのみ切り替えられるように制限される。セクション4.4を参照してください。コーデックを変更することによって迅速なレート適応をサポートするために、セッション設定中にシグナリングされた単一のSSRCによって使用されるRTPペイロードフォーマットの間の変更については、RTPは前進シグナリングを必要としません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If performing changes between two RTP payload types that use different RTP clock rates, an RTP sender MUST follow the recommendations in Section 4.1 of [RFC7160]. RTP receivers MUST follow the recommendations in Section 4.3 of [RFC7160] in order to support sources that switch between clock rates in an RTP session. These recommendations for receivers are backwards compatible with the case where senders use only a single clock rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
異なるRTPクロックレートを使用する2つのRTPペイロードタイプの間で変更を実行する場合、RTP送信者は[RFC7160]のセクション4.1の推奨事項に従わなければなりません。RTP受信機は、RTPセッションでのクロックレートを切り替えるソースをサポートするために、[RFC7160]のセクション4.3の推奨事項に従う必要があります。受信者のためのこれらの推奨事項は、送信者が単一のクロックレートしか使用されていない場合と逆方向に互換性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-4--Use-of-RTP-Sessions">
4.4. Use of RTP Sessions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. RTPセッションの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An association amongst a set of endpoints communicating using RTP is known as an RTP session [RFC3550]. An endpoint can be involved in several RTP sessions at the same time. In a multimedia session, each type of media has typically been carried in a separate RTP session (e.g., using one RTP session for the audio and a separate RTP session using a different transport-layer flow for the video). WebRTC endpoints are REQUIRED to implement support for multimedia sessions in this way, separating each RTP session using different transport-layer flows for compatibility with legacy systems (this is sometimes called session multiplexing).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPを使用して通信する一連のエンドポイントの関連付けは、RTPセッション[RFC3550]として知られています。エンドポイントは複数のRTPセッションに同時に関与できます。マルチメディアセッションでは、各タイプのメディアは通常別のRTPセッション（例えば、ビデオのための異なるトランスポート層フローを使用して、オーディオのための1つのRTPセッションおよび別個のRTPセッションを使用して）実行されてきた。WebRTCエンドポイントは、このようにマルチメディアセッションのサポートを実装する必要があり、レガシーシステムとの互換性のために異なるトランスポート層の流れを使用して各RTPセッションを分離する必要があります（これはセッション多重化と呼ばれます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In modern-day networks, however, with the widespread use of network address/port translators (NAT/NAPT) and firewalls, it is desirable to reduce the number of transport-layer flows used by RTP applications. This can be done by sending all the RTP packet streams in a single RTP session, which will comprise a single transport-layer flow. This will prevent the use of some quality-of-service mechanisms, as discussed in Section 12.1.3. Implementations are therefore also REQUIRED to support transport of all RTP packet streams, independent of media type, in a single RTP session using a single transport-layer flow, according to [RFC8860] (this is sometimes called SSRC multiplexing). If multiple types of media are to be used in a single RTP session, all participants in that RTP session MUST agree to this usage. In an SDP context, the mechanisms described in [RFC8843] can be used to signal such a bundle of RTP packet streams forming a single RTP session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、現代のネットワークでは、ネットワークアドレス/ポートトランスレータ（NAT / NAPT）とファイアウォールの広範な使用では、RTPアプリケーションで使用されるトランスポートレイヤフローの数を減らすことが望ましいです。これは、単一のRTPセッションですべてのRTPパケットストリームを送信することによって実行できます。これは、単一のトランスポート層の流れを含むであろう。セクション12.1.3で説明したように、これにより、あるサービス品質メカニズムの使用を防ぎます。したがって、[RFC8860]によると、単一のトランスポート層の流れを使用した単一のRTPセッションで、メディアタイプとは無関係に、メディアタイプとは無関係に、実装はすべて、メディアタイプから単一のRTPセッションのトランスポートをサポートするために必要です（これはSSRC多重化と呼ばれます）。複数の種類のメディアを単一のRTPセッションで使用する場合は、そのRTPセッションのすべての参加者がこの使用法に同意する必要があります。SDPコンテキストでは、[RFC8843]で説明されているメカニズムを使用して、単一のRTPセッションを構成するRTPパケットストリームのバンドルをシグナリングできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Further discussion about the suitability of different RTP session structures and multiplexing methods to different scenarios can be found in [RFC8872].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
異なるRTPセッション構造の適合性と異なるシナリオへの多重化方法の適合性についてのさらなる説明は、[RFC8872]にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-5--RTP-and-RTCP-Multiplexing">
4.5. RTP and RTCP Multiplexing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. RTPとRTCPの多重化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Historically, RTP and RTCP have been run on separate transport-layer flows (e.g., two UDP ports for each RTP session, one for RTP and one for RTCP). With the increased use of Network Address/Port Translation (NAT/NAPT), this has become problematic, since maintaining multiple NAT bindings can be costly. It also complicates firewall administration, since multiple ports need to be opened to allow RTP traffic. To reduce these costs and session setup times, implementations are REQUIRED to support multiplexing RTP data packets and RTCP control packets on a single transport-layer flow [RFC5761]. Such RTP and RTCP multiplexing MUST be negotiated in the signaling channel before it is used. If SDP is used for signaling, this negotiation MUST use the mechanism defined in [RFC5761]. Implementations can also support sending RTP and RTCP on separate transport-layer flows, but this is OPTIONAL to implement. If an implementation does not support RTP and RTCP sent on separate transport-layer flows, it MUST indicate that using the mechanism defined in [RFC8858].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
歴史的には、RTPとRTCPは別々のトランスポート層の流れ（例えば、各RTPセッションのための2つのUDPポート、RTP、RTCP用1つ）で実行されています。ネットワークアドレス/ポート変換（NAT / NAPT）の使用を増やすと、複数のNATバインディングを維持することができるため、これは問題が発生しました。 RTPトラフィックを許可するために複数のポートを開く必要があるため、ファイアウォール管理も複雑になります。これらのコストとセッションのセットアップ時間を短縮するためには、単一のトランスポート層の流れ[RFC5761]でRTPデータパケットとRTCP制御パケットの多重化をサポートするために実装が必要です。そのようなRTPおよびRTCP多重化は、それが使用される前にシグナリングチャネル内でネゴシエートされなければならない。 SDPがシグナリングに使用されている場合、このネゴシエーションは[RFC5761]で定義されているメカニズムを使用する必要があります。実装は、別々のトランスポート層フローでRTPとRTCPの送信もサポートできますが、これは実装するためのオプションです。実装が別々のトランスポート層のフローで送信されたRTPとRTCPをサポートしていない場合は、[RFC8858]で定義されているメカニズムを使用していることを示している必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the use of RTP and RTCP multiplexed onto a single transport-layer flow ensures that there is occasional traffic sent on that port, even if there is no active media traffic. This can be useful to keep NAT bindings alive [RFC6263].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一のトランスポート層の流れにrtpとrtcpを多重化することで、アクティブなメディアトラフィックがなくても、そのポートに送信されたときにトラフィックが送信されることが保証されます。これは、NATバインディングを生きている[RFC6263]を保持するのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-6--Reduced-Size-RTCP">
4.6. Reduced Size RTCP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. 縮小サイズRTCP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCP packets are usually sent as compound RTCP packets, and [RFC3550] requires that those compound packets start with an SR or RR packet. When using frequent RTCP feedback messages under the RTP/AVPF profile [RFC4585], these statistics are not needed in every packet, and they unnecessarily increase the mean RTCP packet size. This can limit the frequency at which RTCP packets can be sent within the RTCP bandwidth share.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCPパケットは通常、複合RTCPパケットとして送信され、[RFC3550]はそれらの複合パケットがSRまたはRRパケットで始まる必要があります。RTP / AVPFプロファイル[RFC4585]では、頻繁なRTCPフィードバックメッセージを使用する場合、これらの統計はすべてのパケットに必要ではなく、平均RTCPパケットサイズを不必要に増やします。これにより、RTCPパケットをRTCP帯域幅共有内で送信できる周波数を制限できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid this problem, [RFC5506] specifies how to reduce the mean RTCP message size and allow for more frequent feedback. Frequent feedback, in turn, is essential to make real-time applications quickly aware of changing network conditions and to allow them to adapt their transmission and encoding behavior. Implementations MUST support sending and receiving noncompound RTCP feedback packets [RFC5506]. Use of noncompound RTCP packets MUST be negotiated using the signaling channel. If SDP is used for signaling, this negotiation MUST use the attributes defined in [RFC5506]. For backwards compatibility, implementations are also REQUIRED to support the use of compound RTCP feedback packets if the remote endpoint does not agree to the use of noncompound RTCP in the signaling exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この問題を回避するために、[RFC5506]は平均RTCPメッセージサイズを減らし、より頻繁なフィードバックを可能にする方法を指定します。頻繁なフィードバックは、次に、リアルタイムのアプリケーションをネットワーク状態の変化を迅速に認識させ、それらがそれらの送信および符号化動作を適応させることを可能にするために不可欠です。実装は、非コンパウンドRTCPフィードバックパケットの送受信をサポートしている必要があります[RFC5506]。非直交RTCPパケットの使用は、シグナリングチャネルを使用してネゴシエートする必要があります。SDPがシグナリングに使用されている場合、このネゴシエーションは[RFC5506]で定義されている属性を使用する必要があります。後方互換性のために、リモートエンドポイントがシグナリング交換内の非直交RTCPの使用に同意しない場合の複合RTCPフィードバックパケットの使用をサポートするためにも実装が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-7--Symmetric-RTPRTCP">
4.7. Symmetric RTP/RTCP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. 対称RTP / RTCP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To ease traversal of NAT and firewall devices, implementations are REQUIRED to implement and use symmetric RTP [RFC4961]. The reason for using symmetric RTP is primarily to avoid issues with NATs and firewalls by ensuring that the send and receive RTP packet streams, as well as RTCP, are actually bidirectional transport-layer flows. This will keep alive the NAT and firewall pinholes and help indicate consent that the receive direction is a transport-layer flow the intended recipient actually wants. In addition, it saves resources, specifically ports at the endpoints, but also in the network, because the NAT mappings or firewall state is not unnecessarily bloated. The amount of per-flow QoS state kept in the network is also reduced.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NATおよびファイアウォールデバイスのトラバースを容易にするために、実装は対称RTP [RFC4961]を実装して使用する必要があります。Symmetric RTPを使用する理由は、主に、RTCPとともにRTCPと同様にRTCPの送信と受信RTPパケットストリームが実際には双方向トランスポート層のフローであることを確認することで、主にNATとファイアウォールに関する問題を回避することです。これはNATとファイアウォールのピンホールを生かし、受信方向がトランスポート層の流れが実際に望んでいることを確認します。さらに、NATマッピングまたはファイアウォールの状態が不必要に隠れていないため、リソース、特にエンドポイントにポートが保存されます。ネットワーク内に保持されているフローごとのQoS状態の量も減少します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-8--Choice-of-RTP-Synchronization-Source-SSRC">
4.8. Choice of RTP Synchronization Source (SSRC)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8. RTP同期ソースの選択（SSRC）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations are REQUIRED to support signaled RTP synchronization source (SSRC) identifiers. If SDP is used, this MUST be done using the &#34;a=ssrc:&#34; SDP attribute defined in Sections 4.1 and 5 of [RFC5576] and the &#34;previous-ssrc&#34; source attribute defined in Section 6.2 of [RFC5576]; other per-SSRC attributes defined in [RFC5576] MAY be supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、シグナリングされたRTP同期ソース（SSRC）識別子をサポートするために必要です。SDPが使用されている場合、これは[RFC5576]のセクション4.1および5で定義されている「A = SSRC：」SDP属性と[RFC5576]のセクション6.2で定義されている「前-SRC」ソース属性を使用して行わなければなりません。[RFC5576]で定義されている他のSSRCごとの属性がサポートされている可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While support for signaled SSRC identifiers is mandated, their use in an RTP session is OPTIONAL. Implementations MUST be prepared to accept RTP and RTCP packets using SSRCs that have not been explicitly signaled ahead of time. Implementations MUST support random SSRC assignment and MUST support SSRC collision detection and resolution, according to [RFC3550]. When using signaled SSRC values, collision detection MUST be performed as described in Section 5 of [RFC5576].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シグナリングされたSSRC識別子のサポートが義務付けられている間は、RTPセッションでの使用はオプションです。実装は、明示的に先に通知されていないSSRCを使用してRTPおよびRTCPパケットを受け入れるように準備する必要があります。実装はランダムなSSRC割り当てをサポートし、[RFC3550]によると、SSRC衝突検出と解像度をサポートする必要があります。シグナリングされたSSRC値を使用する場合は、[RFC5576]のセクション5に記載されているように衝突検出を実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is often desirable to associate an RTP packet stream with a non-RTP context. For users of the WebRTC API, a mapping between SSRCs and MediaStreamTracks is provided per Section 11. For gateways or other usages, it is possible to associate an RTP packet stream with an &#34;m=&#34; line in a session description formatted using SDP. If SSRCs are signaled, this is straightforward (in SDP, the &#34;a=ssrc:&#34; line will be at the media level, allowing a direct association with an &#34;m=&#34; line). If SSRCs are not signaled, the RTP payload type numbers used in an RTP packet stream are often sufficient to associate that packet stream with a signaling context. For example, if RTP payload type numbers are assigned as described in Section 4.3 of this memo, the RTP payload types used by an RTP packet stream can be compared with values in SDP &#34;a=rtpmap:&#34; lines, which are at the media level in SDP and so map to an &#34;m=&#34; line.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPパケットストリームを非RTPコンテキストと関連付けることがしばしば望ましい。WebRTC APIのユーザーにとって、SSRCSとMediaStreamトラック間のマッピングがセクション11ごとに提供されています。ゲートウェイまたはその他の使用方法は、SDPを使用してフォーマットされたセッション記述内のRTPパケットストリームを &#34;M =&#34;行に関連付けることができます。SSRCがシグナリングされている場合、これは簡単です（SDPでは、 &#34;A = SSRC：&#34;行はメディアレベルにあり、 &#34;m =&#34;行の直接の関連付けを可能にします。SSRCSがシグナリングされていない場合、RTPパケットストリームで使用されるRTPペイロードタイプ番号は、そのパケットストリームをシグナリングコンテキストに関連付けるのに十分です。たとえば、このメモのセクション4.3で説明されているようにRTPペイロードタイプ番号が割り当てられている場合、RTPパケットストリームで使用されるRTPペイロードタイプは、メディアレベルにあるSDP &#34;A = RTPMAP：&#34;行の値と比較できます。SDPでは「M =」行にマップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-9--Generation-of-the-RTCP-Canonical-Name-CNAME">
4.9. Generation of the RTCP Canonical Name (CNAME)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9. RTCP正規名の生成（CNAME）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RTCP Canonical Name (CNAME) provides a persistent transport-level identifier for an RTP endpoint. While the SSRC identifier for an RTP endpoint can change if a collision is detected or when the RTP application is restarted, its RTCP CNAME is meant to stay unchanged for the duration of an RTCPeerConnection [W3C.WebRTC], so that RTP endpoints can be uniquely identified and associated with their RTP packet streams within a set of related RTP sessions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCP正規名（CNAME）は、RTPエンドポイントの持続的なトランスポートレベルの識別子を提供します。RTPエンドポイントのSSRC識別子は、衝突が検出された場合、またはRTPアプリケーションが再起動されると、RTCP CNAMEが変更されずにRTCPERECONCENCE（W3C.WEBRTC]の間変更をとることを目的としているため、RTPエンドポイントが一意になることがあります。関連RTPセッションのセット内のRTPパケットストリームに識別され関連付けられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each RTP endpoint MUST have at least one RTCP CNAME, and that RTCP CNAME MUST be unique within the RTCPeerConnection. RTCP CNAMEs identify a particular synchronization context -- i.e., all SSRCs associated with a single RTCP CNAME share a common reference clock. If an endpoint has SSRCs that are associated with several unsynchronized reference clocks, and hence different synchronization contexts, it will need to use multiple RTCP CNAMEs, one for each synchronization context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各RTPエンドポイントには、少なくとも1つのRTCP CNAMEが必要です.RTCP CNAMEはRTCPERECONCECTION内で一意である必要があります。RTCP CNAMESは特定の同期コンテキストを識別します - すなわち、単一のRTCP CNAMEに関連するすべてのSSRCは共通基準クロックを共有します。エンドポイントに、複数の非同期参照クロック、したがって異なる同期コンテキストに関連付けられているSSRCがある場合は、同期コンテキストごとに複数のRTCP CNAMEを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Taking the discussion in Section 11 into account, a WebRTC endpoint MUST NOT use more than one RTCP CNAME in the RTP sessions belonging to a single RTCPeerConnection (that is, an RTCPeerConnection forms a synchronization context). RTP middleboxes MAY generate RTP packet streams associated with more than one RTCP CNAME, to allow them to avoid having to resynchronize media from multiple different endpoints that are part of a multiparty RTP session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション11での議論を考慮すると、WebRTCエンドポイントは、単一のRTCPeerConnectionに属するRTPセッションで複数のRTCP CNAMEを使用してはいけません（つまり、RTCPeerConnectionフォームは同期コンテキストです）。RTPミドルボックスは、複数のRTCP CNAMEに関連付けられているRTPパケットストリームを生成して、マルチパーティRTPセッションの一部である複数の異なるエンドポイントからメディアを再同期させることを回避できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RTP specification [RFC3550] includes guidelines for choosing a unique RTP CNAME, but these are not sufficient in the presence of NAT devices. In addition, long-term persistent identifiers can be problematic from a privacy viewpoint (Section 13). Accordingly, a WebRTC endpoint MUST generate a new, unique, short-term persistent RTCP CNAME for each RTCPeerConnection, following [RFC7022], with a single exception; if explicitly requested at creation, an RTCPeerConnection MAY use the same CNAME as an existing RTCPeerConnection within their common same-origin context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP仕様[RFC3550]には、一意のRTP CNAMEを選択するためのガイドラインが含まれていますが、これらはNATデバイスの存在下では十分ではありません。さらに、長期持続識別子は、プライバシー視点から問題となる可能性があります（セクション13）。したがって、WebRTCエンドポイントは、[RFC7022]、単一の例外を持つ、RTCPeerconnectionごとに、新しい固有の短期間の永続的なRTCP CNAMEを生成する必要があります。作成時に明示的に要求された場合、RTCPeerConnectionは、共通の同じ原点コンテキスト内で既存のRTCPeerConnectionと同じCNAMEを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A WebRTC endpoint MUST support reception of any CNAME that matches the syntax limitations specified by the RTP specification [RFC3550] and cannot assume that any CNAME will be chosen according to the form suggested above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebRTCエンドポイントは、RTP仕様[RFC3550]で指定された構文制限と一致するCNAMEの受信をサポートし、上記の形式に従ってCNAMEが選択されると想定できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-10--Handling-of-Leap-Seconds">
4.10. Handling of Leap Seconds
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.10. うるう秒の取り扱い
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The guidelines given in [RFC7164] regarding handling of leap seconds to limit their impact on RTP media play-out and synchronization SHOULD be followed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP秒の取り扱いに関する[RFC7164]で与えられたガイドラインRTPメディアの再生と同期に影響を与える必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--WebRTC-Use-of-RTP-Extensions">
5. WebRTC Use of RTP: Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. rtp：拡張子のWebRTCの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are a number of RTP extensions that are either needed to obtain full functionality, or extremely useful to improve on the baseline performance, in the WebRTC context. One set of these extensions is related to conferencing, while others are more generic in nature. The following subsections describe the various RTP extensions mandated or suggested for use within WebRTC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebRTCコンテキストでは、フル機能を取得するために必要な数のRTP拡張機能が必要です。これらの拡張の1つのセットは会議に関連していますが、他の人はより一般的なものです。以下のサブセクションでは、WebRTC内での使用に義務付けられているか、または提案されたさまざまなRTP拡張機能について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1--Conferencing-Extensions-and-Topologies">
5.1. Conferencing Extensions and Topologies
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. 会議拡張とトポロジー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP is a protocol that inherently supports group communication. Groups can be implemented by having each endpoint send its RTP packet streams to an RTP middlebox that redistributes the traffic, by using a mesh of unicast RTP packet streams between endpoints, or by using an IP multicast group to distribute the RTP packet streams. These topologies can be implemented in a number of ways as discussed in [RFC7667].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPは、グループ通信を本質的にサポートするプロトコルです。各エンドポイントを、エンドポイント間でUnicast RTPパケットストリームのメッシュを再配布する、またはRTPマルチキャストグループを使用してRTPパケットストリームを配布することで、RTPパケットストリームをRTPミドルボックスに送信することによって実装できます。これらのトポロジは、[RFC7667]で説明されているように、さまざまな方法で実装できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the use of IP multicast groups is popular in IPTV systems, the topologies based on RTP middleboxes are dominant in interactive video-conferencing environments. Topologies based on a mesh of unicast transport-layer flows to create a common RTP session have not seen widespread deployment to date. Accordingly, WebRTC endpoints are not expected to support topologies based on IP multicast groups or mesh-based topologies, such as a point-to-multipoint mesh configured as a single RTP session (&#34;Topo-Mesh&#34; in the terminology of [RFC7667]). However, a point-to-multipoint mesh constructed using several RTP sessions, implemented in WebRTC using independent RTCPeerConnections [W3C.WebRTC], can be expected to be used in WebRTC and needs to be supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPマルチキャストグループの使用はIPTVシステムで普及しているが、RTPミドルボックスに基づくトポロジは、対話型ビデオ会議環境では支配的です。共通のRTPセッションを作成するためのユニキャストトランスポート層のメッシュに基づくトポロジは、日付に広く展開されていません。したがって、WebRTCエンドポイントは、単一のRTPセッションとして設定されているポイントツーマルチポイントメッシュなどのIPマルチキャストグループまたはメッシュベースのトポロジに基づいてトポロジをサポートすることは期待されていません（[RFC7667]の用語では「トポメッシュ」）。。ただし、Independent RTCPeerConnections [W3C.WeBRTC]を使用してWebRTCで実装された複数のRTPセッションを使用して構築されたポイントツーマルチポイントメッシュは、WebRTCで使用されることが期待されており、サポートされる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebRTC endpoints implemented according to this memo are expected to support all the topologies described in [RFC7667] where the RTP endpoints send and receive unicast RTP packet streams to and from some peer device, provided that peer can participate in performing congestion control on the RTP packet streams. The peer device could be another RTP endpoint, or it could be an RTP middlebox that redistributes the RTP packet streams to other RTP endpoints. This limitation means that some of the RTP middlebox-based topologies are not suitable for use in WebRTC. Specifically:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモに従って実装されているWEBRTCエンドポイントは、RTPパケットの輻輳制御の実行に参加できるように、RTPエンドポイントが一部のピアデバイスとの間でUnicast RTPパケットストリームを送信および受信する[RFC7667]に記載されているすべてのトポロジをサポートすることが予想されます。ストリームピアデバイスは別のRTPエンドポイントである可能性があるか、RTPパケットストリームを他のRTPエンドポイントに再配布するRTPミドルボックスである可能性があります。この制限は、RTPミドルボックスベースのトポロジのいくつかがWebRTCでの使用には適していないことを意味します。具体的には：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Video-switching Multipoint Control Units (MCUs) (Topo-Video-switch-MCU) SHOULD NOT be used, since they make the use of RTCP for congestion control and quality-of-service reports problematic (see Section 3.8 of [RFC7667]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* ビデオスイッチングマルチポイントコントロールユニット（MCU）（TOPO-VIDEO-SWITCH-MCU）は、輻輳制御およびサービス品質レポートの問題があるためRTCPを使用しているため、使用しないでください（[RFC7667]のセクション3.8を参照）。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The Relay-Transport Translator (Topo-PtM-Trn-Translator) topology SHOULD NOT be used, because its safe use requires a congestion control algorithm or RTP circuit breaker that handles point to multipoint, which has not yet been standardized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 安全な使用には、まだ標準化されていないポイントを処理する輻輳制御アルゴリズムまたはRTPサーキットブレーカが必要なので、リレートランスポートトランスレータ（TOPO-PTM-TRNトランスレータ）トポロジを使用しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following topology can be used, however it has some issues worth noting:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のトポロジを使用することができますが、注目に値するいくつかの問題があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Content-modifying MCUs with RTCP termination (Topo-RTCP-terminating-MCU) MAY be used. Note that in this RTP topology, RTP loop detection and identification of active senders is the responsibility of the WebRTC application; since the clients are isolated from each other at the RTP layer, RTP cannot assist with these functions (see Section 3.9 of [RFC7667]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* RTCP終端（TOPO-RTCP末端-MCU）を用いたコンテンツ修飾MCUを使用することができる。このRTPトポロジでは、RTPループの検出とアクティブな送信者の識別がWEBRTCアプリケーションの責任です。クライアントはRTP層で互いに絶縁されているため、RTPはこれらの機能を支援できません（[RFC7667]のセクション3.9を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RTP extensions described in Sections 5.1.1 to 5.1.6 are designed to be used with centralized conferencing, where an RTP middlebox (e.g., a conference bridge) receives a participant&#39;s RTP packet streams and distributes them to the other participants. These extensions are not necessary for interoperability; an RTP endpoint that does not implement these extensions will work correctly but might offer poor performance. Support for the listed extensions will greatly improve the quality of experience; to provide a reasonable baseline quality, some of these extensions are mandatory to be supported by WebRTC endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション5.1.1から5.1.6に記載されているRTP拡張は、RTPミドルボックス（例えば、会議ブリッジ）が参加者のRTPパケットストリームを受信し、他の参加者に配布するようになる集中化会議で使用されるように設計されています。これらの拡張は相互運用性には必要ありません。これらの拡張機能を実装していないRTPエンドポイントは正しく機能しますが、パフォーマンスが悪い場合があります。リストされている拡張のサポートは経験の質を大幅に向上させます。合理的なベースライン品質を提供するために、これらの拡張機能のいくつかは、WEBRTCエンドポイントによってサポートされることを必須です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RTCP conferencing extensions are defined in &#34;Extended RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/ AVPF)&#34; [RFC4585] and &#34;Codec Control Messages in the RTP Audio-Visual Profile with Feedback (AVPF)&#34; [RFC5104]; they are fully usable by the secure variant of this profile (RTP/SAVPF) [RFC5124].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCP会議拡張機能は、「リアルタイムトランスポートコントロールプロトコル（RTCP）ベースのフィードバック（RTP / AVPF）「RFC4585」および「フィードバック付きのRTPオーディオビジュアルプロファイル（AVPF）のCODEC制御メッセージ」で定義されています。「[RFC5104]。それらはこのプロファイルの安全な変形（RTP / SAVPF）[RFC5124]によって完全に使用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1-1--Full-Intra-Request-FIR">
5.1.1. Full Intra Request (FIR)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.1. フルイントラリクエスト（用）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Full Intra Request message is defined in Sections 3.5.1 and 4.3.1 of Codec Control Messages [RFC5104]. It is used to make the mixer request a new Intra picture from a participant in the session. This is used when switching between sources to ensure that the receivers can decode the video or other predictive media encoding with long prediction chains. WebRTC endpoints that are sending media MUST understand and react to FIR feedback messages they receive, since this greatly improves the user experience when using centralized mixer-based conferencing. Support for sending FIR messages is OPTIONAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
完全なINTRA REQUESTメッセージは、CODEC制御メッセージのセクション3.5.1および4.3.1で定義されています[RFC5104]。それはミキサーがセッション内の参加者から新しいイントラピクチャを要求させるために使用されます。これは、受信機が長い予測チェーンを符号化するビデオまたは他の予測メディアを復号することができるようにソース間を切り替えるときに使用される。メディアを送信しているWEBRTCエンドポイントは、集中ミキサーベースの会議を使用する場合のユーザーエクスペリエンスを大幅に向上させるため、受信したFIRフィードバックメッセージに理解し、反応する必要があります。FIRメッセージを送信するためのサポートはオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1-2--Picture-Loss-Indication-PLI">
5.1.2. Picture Loss Indication (PLI)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.2. 写真損失表示（PLI）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Picture Loss Indication message is defined in Section 6.3.1 of the RTP/AVPF profile [RFC4585]. It is used by a receiver to tell the sending encoder that it lost the decoder context and would like to have it repaired somehow. This is semantically different from the Full Intra Request above, as there could be multiple ways to fulfill the request. WebRTC endpoints that are sending media MUST understand and react to PLI feedback messages as a loss-tolerance mechanism. Receivers MAY send PLI messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
画像損失指示メッセージは、RTP / AVPFプロファイル[RFC4585]のセクション6.3.1で定義されています。送信エンコーダにデコーダのコンテキストを失ったことを伝えるために受信機によって使用され、どういうわけか修復したいと思います。要求を満たすための複数の方法がある可能性があるため、これは上記のフルイントラ要求とは意味的に異なります。メディアを送信しているWEBRTCエンドポイントは、損失許容誤差メカニズムとしてPLIフィードバックメッセージに理解し、反応する必要があります。受信者はPLIメッセージを送信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1-3--Slice-Loss-Indication-SLI">
5.1.3. Slice Loss Indication (SLI)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.3. スライス損失指示（SLI）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Slice Loss Indication message is defined in Section 6.3.2 of the RTP/AVPF profile [RFC4585]. It is used by a receiver to tell the encoder that it has detected the loss or corruption of one or more consecutive macro blocks and would like to have these repaired somehow. It is RECOMMENDED that receivers generate SLI feedback messages if slices are lost when using a codec that supports the concept of macro blocks. A sender that receives an SLI feedback message SHOULD attempt to repair the lost slice(s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スライス損失指示メッセージは、RTP / AVPFプロファイル[RFC4585]のセクション6.3.2で定義されています。それは、それが1つまたは複数の連続したマクロブロックの損失または破損を検出したことをエンコーダに伝えるために受信機によって使用され、そしてこれらの修理を経験したいと思う。マクロブロックの概念をサポートするコーデックを使用するときにスライスが失われると、受信機がSLIフィードバックメッセージを生成することをお勧めします。SLIフィードバックメッセージを受信する送信者は、失われたスライスを修復しようとするはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1-4--Reference-Picture-Selection-Indication-RPSI">
5.1.4. Reference Picture Selection Indication (RPSI)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.4. 参照画像選択表示（RPSI）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reference Picture Selection Indication (RPSI) messages are defined in Section 6.3.3 of the RTP/AVPF profile [RFC4585]. Some video-encoding standards allow the use of older reference pictures than the most recent one for predictive coding. If such a codec is in use, and if the encoder has learned that encoder-decoder synchronization has been lost, then a known-as-correct reference picture can be used as a base for future coding. The RPSI message allows this to be signaled. Receivers that detect that encoder-decoder synchronization has been lost SHOULD generate an RPSI feedback message if the codec being used supports reference-picture selection. An RTP packet-stream sender that receives such an RPSI message SHOULD act on that messages to change the reference picture, if it is possible to do so within the available bandwidth constraints and with the codec being used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参照ピクチャ選択表示（RPSI）メッセージは、RTP / AVPFプロファイル[RFC4585]のセクション6.3.3で定義されています。一部のビデオエンコーディング標準は、予測コーディング用の最新のものより古い参照ピクチャの使用を可能にします。そのようなコーデックが使用されている場合、およびエンコーダがエンコーダ - デコーダの同期が失われたことを学習した場合、既知の符号化の基本として、既知のAS正しい参照ピクチャを使用することができる。RPSIメッセージはこれをシグナリングすることを可能にします。使用されているコーデックが参照ピクチャの選択をサポートしている場合、エンコーダデコーダの同期が失われたことを検出する受信機は、RPSIフィードバックメッセージを生成する必要があります。そのようなRPSIメッセージを受信するRTPパケットストリーム送信者は、利用可能な帯域幅の制約内およびコーデックを使用することが可能であるならば、参照ピクチャを変更するためにそのメッセージに行動する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1-5--Temporal-Spatial-Trade-Off-Request-TSTR">
5.1.5. Temporal-Spatial Trade-Off Request (TSTR)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.5. 時間的空間トレードオフ要求（TSTR）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The temporal-spatial trade-off request and notification are defined in Sections 3.5.2 and 4.3.2 of [RFC5104]. This request can be used to ask the video encoder to change the trade-off it makes between temporal and spatial resolution -- for example, to prefer high spatial image quality but low frame rate. Support for TSTR requests and notifications is OPTIONAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
時間的空間トレードオフ要求と通知は、[RFC5104]のセクション3.5.2と4.3.2で定義されています。この要求を使用して、ビデオエンコーダには、時間的および空間的解像度の間になるトレードオフを変更するように依頼するために、例えば、高い空間画質が高いが低フレームレートを好む。TSTR要求と通知のサポートはオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1-6--Temporary-Maximum-Media-Stream-Bit-Rate-Request-TMMBR">
5.1.6. Temporary Maximum Media Stream Bit Rate Request (TMMBR)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.6. 一時最大メディアストリームビットレート要求（TMMBR）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Temporary Maximum Media Stream Bit Rate Request (TMMBR) feedback message is defined in Sections 3.5.4 and 4.2.1 of Codec Control Messages [RFC5104]. This request and its corresponding Temporary Maximum Media Stream Bit Rate Notification (TMMBN) message [RFC5104] are used by a media receiver to inform the sending party that there is a current limitation on the amount of bandwidth available to this receiver. There can be various reasons for this: for example, an RTP mixer can use this message to limit the media rate of the sender being forwarded by the mixer (without doing media transcoding) to fit the bottlenecks existing towards the other session participants. WebRTC endpoints that are sending media are REQUIRED to implement support for TMMBR messages and MUST follow bandwidth limitations set by a TMMBR message received for their SSRC. The sending of TMMBR messages is OPTIONAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一時最大メディアストリームビットレート要求（TMMBR）フィードバックメッセージは、Codec Controlメッセージ[RFC5104]のセクション3.5.4および4.2.1で定義されています。この要求とその対応する一時最大メディアストリームビットレート通知（TMMBN）メッセージ[RFC5104]は、この受信側に利用可能な帯域幅の量に電流制限があることを送信側に通知するためにメディア受信機によって使用されます。これにはさまざまな理由が発生する可能性があります。たとえば、RTPミキサーはこのメッセージを使用して、（メディアトランスコーディングを行わずに）他のセッション参加者に存在するボトルネックに合うように、ミキサーによって転送されている送信者のメディアレートを制限できます。メディアを送信しているWEBRTCエンドポイントは、TMMBRメッセージのサポートを実装するために必要であり、SSRCに対して受信されたTMMBRメッセージによって設定された帯域幅の制限に従わなければなりません。TMMBRメッセージの送信はオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2--Header-Extensions">
5.2. Header Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. ヘッダー拡張
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RTP specification [RFC3550] provides the capability to include RTP header extensions containing in-band data, but the format and semantics of the extensions are poorly specified. The use of header extensions is OPTIONAL in WebRTC, but if they are used, they MUST be formatted and signaled following the general mechanism for RTP header extensions defined in [RFC8285], since this gives well-defined semantics to RTP header extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP仕様[RFC3550]は、インバンドデータを含むRTPヘッダー拡張機能を含む機能を提供しますが、拡張機能の形式と意味は不十分です。Header Extensionsの使用はWebRTCではオプションですが、使用されている場合は、[RFC8285]で定義されたRTPヘッダー拡張機能の一般的なメカニズムに従ってフォーマットされ、シグナリングされなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As noted in [RFC8285], the requirement from the RTP specification that header extensions are &#34;designed so that the header extension may be ignored&#34; [RFC3550] stands. To be specific, header extensions MUST only be used for data that can safely be ignored by the recipient without affecting interoperability and MUST NOT be used when the presence of the extension has changed the form or nature of the rest of the packet in a way that is not compatible with the way the stream is signaled (e.g., as defined by the payload type). Valid examples of RTP header extensions might include metadata that is additional to the usual RTP information but that can safely be ignored without compromising interoperability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8285]に記載されているように、RTP仕様の要件は、ヘッダー拡張機能が「ヘッダー拡張機能を無視できるように設計されています」[RFC3550]を表します。具体的には、ヘッダ拡張は、相互運用性に影響を与えずに受信者によって無視されることができるデータにのみ使用されなければなりません。ストリームがシグナリングされる方法と互換性がありません（たとえば、ペイロードタイプで定義されているように）。RTPヘッダー拡張の有効な例には、通常のRTP情報に追加のメタデータが含まれますが、相互運用性を犠牲にすることなく安全に無視される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2-1--Rapid-Synchronization">
5.2.1. Rapid Synchronization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.1. 迅速な同期
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many RTP sessions require synchronization between audio, video, and other content. This synchronization is performed by receivers, using information contained in RTCP SR packets, as described in the RTP specification [RFC3550]. This basic mechanism can be slow, however, so it is RECOMMENDED that the rapid RTP synchronization extensions described in [RFC6051] be implemented in addition to RTCP SR-based synchronization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くのRTPセッションは、オーディオ、ビデオ、およびその他のコンテンツの間の同期を必要とします。この同期は、RTP仕様[RFC3550]で説明されているように、RTCP SRパケットに含まれる情報を使用して受信機によって実行されます。しかしながら、この基本的なメカニズムは遅くなる可能性があるため、RTCP SRベースの同期に加えて[RFC6051]に記載されているRapid RTP同期拡張機能を実装することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This header extension uses the generic header extension framework described in [RFC8285] and so needs to be negotiated before it can be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このヘッダー拡張機能は[RFC8285]で説明されている一般的なヘッダー拡張フレームワークを使用しているため、使用する前にネゴシエートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2-2--Client-to-Mixer-Audio-Level">
5.2.2. Client-to-Mixer Audio Level
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.2. クライアントからミキサーのオーディオレベル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client-to-mixer audio level extension [RFC6464] is an RTP header extension used by an endpoint to inform a mixer about the level of audio activity in the packet to which the header is attached. This enables an RTP middlebox to make mixing or selection decisions without decoding or detailed inspection of the payload, reducing the complexity in some types of mixers. It can also save decoding resources in receivers, which can choose to decode only the most relevant RTP packet streams based on audio activity levels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントからミキサーのオーディオレベルの拡張[RFC6464]は、ヘッダーが接続されているパケット内のオーディオアクティビティのレベルに関するミキサーに通知するためのエンドポイントによって使用されるRTPヘッダー拡張です。これにより、RTPミドルボックスは、ペイロードの復号化または詳細検査なしにミキシングまたは選択の決定を下すことができ、いくつかのタイプのミキサーで複雑さを軽減します。また、受信者内の復号化リソースを保存することもできます。これにより、オーディオアクティビティレベルに基づいて最も関連のあるRTPパケットストリームのみをデコードすることもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client-to-mixer audio level header extension [RFC6464] MUST be implemented. It is REQUIRED that implementations be capable of encrypting the header extension according to [RFC6904], since the information contained in these header extensions can be considered sensitive. The use of this encryption is RECOMMENDED; however, usage of the encryption can be explicitly disabled through API or signaling.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントからミキサーのオーディオレベルのヘッダー拡張[RFC6464]を実装する必要があります。これらのヘッダー拡張に含まれる情報は敏感に見えるので、実装は[RFC6904]に従ってヘッダー拡張を暗号化することができることが必要です。この暗号化の使用をお勧めします。ただし、暗号化の使用は、APIまたはシグナリングによって明示的に無効にできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This header extension uses the generic header extension framework described in [RFC8285] and so needs to be negotiated before it can be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このヘッダー拡張機能は[RFC8285]で説明されている一般的なヘッダー拡張フレームワークを使用しているため、使用する前にネゴシエートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2-3--Mixer-to-Client-Audio-Level">
5.2.3. Mixer-to-Client Audio Level
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.3. ミキサー間のオーディオレベル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mixer-to-client audio level header extension [RFC6465] provides an endpoint with the audio level of the different sources mixed into a common source stream by an RTP mixer. This enables a user interface to indicate the relative activity level of each session participant, rather than just being included or not based on the CSRC field. This is a pure optimization of non-critical functions and is hence OPTIONAL to implement. If this header extension is implemented, it is REQUIRED that implementations be capable of encrypting the header extension according to [RFC6904], since the information contained in these header extensions can be considered sensitive. It is further RECOMMENDED that this encryption be used, unless the encryption has been explicitly disabled through API or signaling.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mixer-To-Clientオーディオレベルヘッダー拡張[RFC6465]は、RTPミキサーによって共通のソースストリームに混在するさまざまなソースのオーディオレベルを持つエンドポイントを提供します。これにより、CSRCフィールドに基づいて、各セッション参加者の相対的なアクティビティレベルを示すことができます。これは重要ではない関数の純粋な最適化であり、したがって実装するためのオプションです。このヘッダ拡張機能が実装されている場合、これらのヘッダ拡張子に含まれる情報は敏感であると見なすことができるので、実装は[RFC6904]に従ってヘッダ拡張を暗号化することができることが必要である。暗号化がAPIまたはシグナリングによって明示的に無効にされていない限り、この暗号化を使用することをさらに推奨します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This header extension uses the generic header extension framework described in [RFC8285] and so needs to be negotiated before it can be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このヘッダー拡張機能は[RFC8285]で説明されている一般的なヘッダー拡張フレームワークを使用しているため、使用する前にネゴシエートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2-4--Media-Stream-Identification">
5.2.4. Media Stream Identification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.4. メディアストリーム識別
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebRTC endpoints that implement the SDP bundle negotiation extension will use the SDP Grouping Framework &#34;mid&#34; attribute to identify media streams. Such endpoints MUST implement the RTP MID header extension described in [RFC8843].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDPバンドルネゴシエーション拡張機能を実装するWEBRTCエンドポイントは、メディアストリームを識別するためにSDP Grouping Framework &#34;Mid&#34;属性を使用します。そのようなエンドポイントは[RFC8843]に記載されているRTP MIDヘッダー拡張機能を実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This header extension uses the generic header extension framework described in [RFC8285] and so needs to be negotiated before it can be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このヘッダー拡張機能は[RFC8285]で説明されている一般的なヘッダー拡張フレームワークを使用しているため、使用する前にネゴシエートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2-5--Coordination-of-Video-Orientation">
5.2.5. Coordination of Video Orientation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.5. ビデオの向きの調整
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebRTC endpoints that send or receive video MUST implement the coordination of video orientation (CVO) RTP header extension as described in Section 4 of [RFC7742].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7742]のセクション4に記載されているように、ビデオを送受信するためのWEBRTCエンドポイント（CVO）RTPヘッダー拡張子の調整を実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This header extension uses the generic header extension framework described in [RFC8285] and so needs to be negotiated before it can be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このヘッダー拡張機能は[RFC8285]で説明されている一般的なヘッダー拡張フレームワークを使用しているため、使用する前にネゴシエートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--WebRTC-Use-of-RTP-Improving-Transport-Robustness">
6. WebRTC Use of RTP: Improving Transport Robustness
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. RTPのWebRTCの使用：輸送用堅牢性の向上
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are tools that can make RTP packet streams robust against packet loss and reduce the impact of loss on media quality. However, they generally add some overhead compared to a non-robust stream. The overhead needs to be considered, and the aggregate bitrate MUST be rate controlled to avoid causing network congestion (see Section 7). As a result, improving robustness might require a lower base encoding quality but has the potential to deliver that quality with fewer errors. The mechanisms described in the following subsections can be used to improve tolerance to packet loss.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPパケットストリームをパケット損失に対して堅牢にすることができるツールがあり、メディア品質に対する損失の影響を減らすことができます。しかしながら、それらは一般的に非堅牢なストリームと比較していくつかのオーバーヘッドを追加する。オーバーヘッドを考慮する必要があり、集約ビットレートはネットワークの輻輳を引き起こすことを回避するためにレート制御されなければなりません（セクション7を参照）。その結果、堅牢性の向上はより低い基本符号化品質を必要とするかもしれないが、その品質をより少ない誤差で提供する可能性を有する。以下のサブセクションに記載されているメカニズムを使用して、パケット損失に対する許容誤差を改善することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-1--Negative-Acknowledgements-and-RTP-Retransmission">
6.1. Negative Acknowledgements and RTP Retransmission
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. 否定的な確認応答とRTP再送信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a consequence of supporting the RTP/SAVPF profile, implementations can send negative acknowledgements (NACKs) for RTP data packets [RFC4585]. This feedback can be used to inform a sender of the loss of particular RTP packets, subject to the capacity limitations of the RTCP feedback channel. A sender can use this information to optimize the user experience by adapting the media encoding to compensate for known lost packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP / SAVPFプロファイルをサポートすることの結果として、実装はRTPデータパケット[RFC4585]に否定的な確認応答（NACK）を送信することができます。このフィードバックは、RTCPフィードバックチャネルの容量制限を条件として、特定のRTPパケットの損失を送信者に知らせるために使用できます。送信者はこの情報を使用して、既知の失われたパケットを補償するためにメディアエンコーディングを適応させることによってユーザエクスペリエンスを最適化することができる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP packet stream senders are REQUIRED to understand the generic NACK message defined in Section 6.2.1 of [RFC4585], but they MAY choose to ignore some or all of this feedback (following Section 4.2 of [RFC4585]). Receivers MAY send NACKs for missing RTP packets. Guidelines on when to send NACKs are provided in [RFC4585]. It is not expected that a receiver will send a NACK for every lost RTP packet; rather, it needs to consider the cost of sending NACK feedback and the importance of the lost packet to make an informed decision on whether it is worth telling the sender about a packet-loss event.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPパケットストリーム送信者は、[RFC4585]のセクション6.2.1で定義されている一般的なNACKメッセージを理解する必要がありますが、このフィードバックの一部または全部を無視することを選択できます（[RFC4585]のセクション4.2）。受信者は、RTPパケットが見つからないためにNACKを送信することができます。NACKを送信するときのガイドラインは[RFC4585]に提供されています。受信者が失われたRTPパケットごとにNACKを送信することは予想されません。そうではなく、NACKフィードバックを送信するコストと、失われたパケットの重要性をパケット損失イベントについて送信者に伝える価値があるかどうかについての情報に基づいた決定を下す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RTP retransmission payload format [RFC4588] offers the ability to retransmit lost packets based on NACK feedback. Retransmission needs to be used with care in interactive real-time applications to ensure that the retransmitted packet arrives in time to be useful, but it can be effective in environments with relatively low network RTT. (An RTP sender can estimate the RTT to the receivers using the information in RTCP SR and RR packets, as described at the end of Section 6.4.1 of [RFC3550]). The use of retransmissions can also increase the forward RTP bandwidth and can potentially cause increased packet loss if the original packet loss was caused by network congestion. Note, however, that retransmission of an important lost packet to repair decoder state can have lower cost than sending a full intra frame. It is not appropriate to blindly retransmit RTP packets in response to a NACK. The importance of lost packets and the likelihood of them arriving in time to be useful need to be considered before RTP retransmission is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP再送ペイロードフォーマット[RFC4588]は、NACKフィードバックに基づいて紛失したパケットを再送信する機能を提供します。再送信は、再送されたパケットが有用であるために時間内に到着することを確実にするために、対話型リアルタイムアプリケーションの注意とともに使用される必要がありますが、比較的低いネットワークRTTを持つ環境で効果的である可能性があります。 [RFC3550]のセクション6.4.1の末尾で説明されているように、RTCP SRおよびRRパケット内の情報を使用してRTTを受信機に推定できます。再送信の使用はまた、順方向RTP帯域幅を増加させる可能性があり、元のパケット損失がネットワークの輻輳によって引き起こされた場合にパケット損失の増加を引き起こす可能性があります。ただし、復号化されたパケットを修復するための重要な失われたパケットの再送は、フルイントラフレームを送信するよりも低コストを持つことができます。 NACKに応答してRTPパケットを盲目的に再送信するのには適していません。紛失したパケットの重要性とそれらの可能性は、RTP再送が使用される前に考慮される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Receivers are REQUIRED to implement support for RTP retransmission packets [RFC4588] sent using SSRC multiplexing and MAY also support RTP retransmission packets sent using session multiplexing. Senders MAY send RTP retransmission packets in response to NACKs if support for the RTP retransmission payload format has been negotiated and the sender believes it is useful to send a retransmission of the packet(s) referenced in the NACK. Senders do not need to retransmit every NACKed packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信機は、SSRC多重化を使用して送信されたRTP再送パケット[RFC4588]のサポートを実装するために必要であり、セッション多重化を使用して送信されたRTP再送パケットもサポートすることがあります。送信者は、RTP再送ペイロードフォーマットのサポートがネゴシエートされている場合、NACKに応答してRTP再送パケットを送信し、送信者がNACKで参照されたパケットの再送信を信じていると信じています。送信者は、すべてのNACKEDパケットを再送信する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2--Forward-Error-Correction-FEC">
6.2. Forward Error Correction (FEC)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. 順方向誤り訂正（FEC）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of Forward Error Correction (FEC) can provide an effective protection against some degree of packet loss, at the cost of steady bandwidth overhead. There are several FEC schemes that are defined for use with RTP. Some of these schemes are specific to a particular RTP payload format, and others operate across RTP packets and can be used with any payload format. Note that using redundant encoding or FEC will lead to increased play-out delay, which needs to be considered when choosing FEC schemes and their parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
順方向誤り訂正（FEC）の使用は、定常帯域幅のオーバーヘッドのコストで、ある程度のパケット損失に対する効果的な保護を提供することができる。RTPで使用するために定義されているいくつかのFECスキームがあります。これらのスキームのいくつかは特定のRTPペイロード形式に固有のものであり、他のものはRTPパケット間で動作し、任意のペイロード形式で使用できます。冗長エンコードまたはFECを使用すると、FEC方式とそのパラメータを選択するときに考慮する必要がある再生遅延が増加することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebRTC endpoints MUST follow the recommendations for FEC use given in [RFC8854]. WebRTC endpoints MAY support other types of FEC, but these MUST be negotiated before they are used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebRTCエンドポイントは[RFC8854]で与えられたFEC使用のための推奨事項に従う必要があります。WebRTCエンドポイントは他のタイプのFECをサポートできますが、これらは使用される前にネゴシエートされなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--WebRTC-Use-of-RTP-Rate-Control-and-Media-Adaptation">
7. WebRTC Use of RTP: Rate Control and Media Adaptation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. RTPのWEBRTCの使用：レート制御とメディア適応
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebRTC will be used in heterogeneous network environments using a variety of link technologies, including both wired and wireless links, to interconnect potentially large groups of users around the world. As a result, the network paths between users can have widely varying one-way delays, available bitrates, load levels, and traffic mixtures. Individual endpoints can send one or more RTP packet streams to each participant, and there can be several participants. Each of these RTP packet streams can contain different types of media, and the type of media, bitrate, and number of RTP packet streams as well as transport-layer flows can be highly asymmetric. Non-RTP traffic can share the network paths with RTP transport-layer flows. Since the network environment is not predictable or stable, WebRTC endpoints MUST ensure that the RTP traffic they generate can adapt to match changes in the available network capacity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRTCは、世界中の潜在的に大きなユーザーグループを相互接続するために、有線および無線のリンクを含むさまざまなリンク技術を使用して、異種ネットワーク環境で使用されます。その結果、ユーザ間のネットワーク経路は、一方向の遅延、利用可能なビットレート、負荷レベル、およびトラフィック混合物を広く変えることができる。個々のエンドポイントは、各参加者に1つ以上のRTPパケットストリームを送信でき、いくつかの参加者がある可能性があります。これらのRTPパケットストリームのそれぞれは、異なる種類のメディアを含めることができ、媒体の種類、ビットレート、およびRTPパケットストリームの数、ならびにトランスポート層の流れは非常に非対称であり得る。RTP以外のトラフィックは、RTPトランスポート層フローを含むネットワークパスを共有できます。ネットワーク環境は予測可能または安定していないため、WEBRTCエンドポイントで発生したRTPトラフィックが、利用可能なネットワーク容量の変更に適応できるようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The quality of experience for users of WebRTC is very dependent on effective adaptation of the media to the limitations of the network. Endpoints have to be designed so they do not transmit significantly more data than the network path can support, except for very short time periods; otherwise, high levels of network packet loss or delay spikes will occur, causing media quality degradation. The limiting factor on the capacity of the network path might be the link bandwidth, or it might be competition with other traffic on the link (this can be non-WebRTC traffic, traffic due to other WebRTC flows, or even competition with other WebRTC flows in the same session).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebRTCのユーザーのための経験の質は、ネットワークの制限に対するメディアの効果的な適応に非常に依存しています。エンドポイントは、非常に短い期間を除いて、ネットワークパスよりも大幅に多くのデータを送信しないように設計する必要があります。そうでなければ、高レベルのネットワークパケット損失または遅延スパイクが発生し、メディア品質劣化を引き起こします。ネットワーク経路の容量に対する制限要因はリンク帯域幅である可能性があるか、リンク上の他のトラフィックとの競合である可能性があります（これは、WEBRTCトラフィック、他のWebRTCの流れによるトラフィック、あるいは他のWebRTCフローとの競合などでさえも可能です。同じセッションで）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An effective media congestion control algorithm is therefore an essential part of the WebRTC framework. However, at the time of this writing, there is no standard congestion control algorithm that can be used for interactive media applications such as WebRTC&#39;s flows. Some requirements for congestion control algorithms for RTCPeerConnections are discussed in [RFC8836]. If a standardized congestion control algorithm that satisfies these requirements is developed in the future, this memo will need to be updated to mandate its use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、効果的なメディア輻輳制御アルゴリズムはWebRTCフレームワークの必須部分です。ただし、この書き込み時には、WebRTCのフローなどの対話型メディアアプリケーションに使用できる標準的な輻輳制御アルゴリズムはありません。RTCPeerconcectionsの輻輳制御アルゴリズムのためのいくつかの要件は[RFC8836]で説明されています。これらの要件を満たす標準化された輻輳制御アルゴリズムが将来開発された場合、このメモはその使用を義務付けるように更新する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-1--Boundary-Conditions-and-Circuit-Breakers">
7.1. Boundary Conditions and Circuit Breakers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 境界条件とサーキットブレーカ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebRTC endpoints MUST implement the RTP circuit breaker algorithm that is described in [RFC8083]. The RTP circuit breaker is designed to enable applications to recognize and react to situations of extreme network congestion. However, since the RTP circuit breaker might not be triggered until congestion becomes extreme, it cannot be considered a substitute for congestion control, and applications MUST also implement congestion control to allow them to adapt to changes in network capacity. The congestion control algorithm will have to be proprietary until a standardized congestion control algorithm is available. Any future RTP congestion control algorithms are expected to operate within the envelope allowed by the circuit breaker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebRTCエンドポイントは、[RFC8083]に記載されているRTPサーキットブレーカアルゴリズムを実装する必要があります。RTPサーキットブレーカは、アプリケーションが極端なネットワーク輻輳の状況に認識して反応できるように設計されています。ただし、輻輳が極端になるまでRTPサーキットブレーカがトリガされない可能性があるため、輻輳制御の代替と見なすことはできず、アプリケーションもネットワーク容量の変化に適応できるように輻輳制御を実行する必要があります。輻輳制御アルゴリズムは、標準化された輻輳制御アルゴリズムが利用可能になるまで独自のものである必要があります。将来のRTP輻輳制御アルゴリズムは、遮断器によって許容される包絡線内で動作すると予想されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The session-establishment signaling will also necessarily establish boundaries to which the media bitrate will conform. The choice of media codecs provides upper and lower bounds on the supported bitrates that the application can utilize to provide useful quality, and the packetization choices that exist. In addition, the signaling channel can establish maximum media bitrate boundaries using, for example, the SDP &#34;b=AS:&#34; or &#34;b=CT:&#34; lines and the RTP/AVPF TMMBR messages (see Section 5.1.6 of this memo). Signaled bandwidth limitations, such as SDP &#34;b=AS:&#34; or &#34;b=CT:&#34; lines received from the peer, MUST be followed when sending RTP packet streams. A WebRTC endpoint receiving media SHOULD signal its bandwidth limitations. These limitations have to be based on known bandwidth limitations, for example the capacity of the edge links.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション確立シグナリングはまた、メディアビットレートが適合する境界を必ず確立するであろう。メディアコーデックの選択は、サポートされているビットレート上の上限および下限を提供し、アプリケーションが有用な品質を提供するために使用できること、および存在するパケット化の選択肢を提供します。さらに、シグナリングチャネルは、例えば、SDP「B = AS：」または「B = CT：」行およびRTP / AVPF TMMBRメッセージを使用して最大のメディアビットレート境界を確立することができる（このメモのセクション5.1.6を参照）。。SDP &#34;B = AS：&#34;または &#34;B = CT：&#34; LINESのようなシグナリングされた帯域幅の制限は、RTPパケットストリームを送信するときに従う必要があります。WebRTCエンドポイント受信メディアは、その帯域幅の制限をシグナリングする必要があります。これらの制限は、既知の帯域幅の制限、例えばエッジリンクの容量に基づいている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-2--Congestion-Control-Interoperability-and-Legacy-Systems">
7.2. Congestion Control Interoperability and Legacy Systems
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. 輻輳制御の相互運用性とレガシーシステム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All endpoints that wish to interwork with WebRTC MUST implement RTCP and provide congestion feedback via the defined RTCP reporting mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebRTCとの相互作用を希望するすべてのエンドポイントはRTCPを実装し、定義されたRTCPレポートメカニズムを介して輻輳フィードバックを提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When interworking with legacy implementations that support RTCP using the RTP/AVP profile [RFC3551], congestion feedback is provided in RTCP RR packets every few seconds. Implementations that have to interwork with such endpoints MUST ensure that they keep within the RTP circuit breaker [RFC8083] constraints to limit the congestion they can cause.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP / AVPプロファイル[RFC3551]を使用してRTCPをサポートするレガシー実装でインターワーキングする場合、輻輳フィードバックは数秒ごとにRTCP RRパケットに提供されます。そのようなエンドポイントと相互作用しなければならない実装は、RTPサーキットブレーカ[RFC8083]の制約を確実に保証しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a legacy endpoint supports RTP/AVPF, this enables negotiation of important parameters for frequent reporting, such as the &#34;trr-int&#34; parameter, and the possibility that the endpoint supports some useful feedback format for congestion control purposes such as TMMBR [RFC5104]. Implementations that have to interwork with such endpoints MUST ensure that they stay within the RTP circuit breaker [RFC8083] constraints to limit the congestion they can cause, but they might find that they can achieve better congestion response depending on the amount of feedback that is available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レガシエンドポイントがRTP / AVPFをサポートしている場合、これにより、 &#34;trr-int&#34;パラメータなどの頻繁なレポートのための重要なパラメータのネゴシエーションと、エンドポイントがTMMBR [RFC5104]のような輻輳制御目的でいくつかの有用なフィードバックフォーマットをサポートする可能性があります。。そのようなエンドポイントと相互作用しなければならない実装は、RTPサーキットブレーカー[RFC8083]の制約を確実にして、それらが発生する可能性がある輻輳を制限することを確実にする必要がありますが、利用可能なフィードバックの量に応じてより良い輻輳応答を達成できることがわかります。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With proprietary congestion control algorithms, issues can arise when different algorithms and implementations interact in a communication session. If the different implementations have made different choices in regards to the type of adaptation, for example one sender based, and one receiver based, then one could end up in a situation where one direction is dual controlled when the other direction is not controlled. This memo cannot mandate behavior for proprietary congestion control algorithms, but implementations that use such algorithms ought to be aware of this issue and try to ensure that effective congestion control is negotiated for media flowing in both directions. If the IETF were to standardize both sender- and receiver-based congestion control algorithms for WebRTC traffic in the future, the issues of interoperability, control, and ensuring that both directions of media flow are congestion controlled would also need to be considered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
独自の輻輳制御アルゴリズムを使用すると、異なるアルゴリズムと実装が通信セッションで対話すると問題が発生する可能性があります。異なる実装が適応の種類に関して異なる選択を行った場合、例えば1つの送信者ベース、および1つの受信機ベースでは、他の方向が制御されないときに一方向が二重制御される状況で終わることができる。このメモは独自の輻輳制御アルゴリズムの動作を義務付けることはできませんが、そのようなアルゴリズムを使用する実装はこの問題を認識し、実効輻輳制御が両方向に流れるメディアに対してネゴシエートされることを試みます。IETFが将来のWebRTCトラフィックの送信者と受信側の輻輳制御アルゴリズムの両方を標準化する場合は、相互運用性、制御、およびメディアフローの両方向が輻輳制御されていることを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--WebRTC-Use-of-RTP-Performance-Monitoring">
8. WebRTC Use of RTP: Performance Monitoring
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. WEBRTC RTPの使用：性能監視
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in Section 4.1, implementations are REQUIRED to generate RTCP Sender Report (SR) and Receiver Report (RR) packets relating to the RTP packet streams they send and receive. These RTCP reports can be used for performance monitoring purposes, since they include basic packet-loss and jitter statistics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション4.1で説明されているように、それらが送受信するRTPパケットストリームに関するRTCP送信者レポート（SR）および受信者レポート（RR）パケットを生成するためには実装が必要です。これらのRTCPレポートは、基本的なパケット損失およびジッタ統計を含むため、パフォーマンス監視の目的に使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A large number of additional performance metrics are supported by the RTCP Extended Reports (XR) framework; see [RFC3611] and [RFC6792]. At the time of this writing, it is not clear what extended metrics are suitable for use in WebRTC, so there is no requirement that implementations generate RTCP XR packets. However, implementations that can use detailed performance monitoring data MAY generate RTCP XR packets as appropriate. The use of RTCP XR packets SHOULD be signaled; implementations MUST ignore RTCP XR packets that are unexpected or not understood.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCP Extended Reports（XR）フレームワークでは、多数の追加のパフォーマンスメトリックがサポートされています。[RFC3611]と[RFC6792]を参照してください。この書き込み時には、WebRTCでの使用に適しているのは明確ではないため、実装がRTCP XRパケットを生成する必要はありません。ただし、詳細なパフォーマンス監視データを使用できる実装は、必要に応じてRTCP XRパケットを生成する可能性があります。RTCP XRパケットの使用はシグナリングされるべきです。実装は、予期しないか理解されていないRTCP XRパケットを無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--WebRTC-Use-of-RTP-Future-Extensions">
9. WebRTC Use of RTP: Future Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. rtpの使用：将来の拡張子
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible that the core set of RTP protocols and RTP extensions specified in this memo will prove insufficient for the future needs of WebRTC. In this case, future updates to this memo have to be made following &#34;Guidelines for Writers of RTP Payload Format Specifications&#34; [RFC2736], &#34;How to Write an RTP Payload Format&#34; [RFC8088], and &#34;Guidelines for Extending the RTP Control Protocol (RTCP)&#34; [RFC5968]. They also SHOULD take into account any future guidelines for extending RTP and related protocols that have been developed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモに指定されているRTPプロトコルとRTP拡張のコアセットが、WebRTCの将来のニーズには不十分であることが可能です。この場合、このメモの将来の更新は、「RTPペイロード形式の仕組みのガイドライン[RFC2736]、「RTPペイロードフォーマットの作成方法」[RFC8088]、およびRTP制御プロトコルの拡張のガイドラインに従って作成する必要があります。（RTCP） &#34;[RFC5968]。彼らはまた、開発されたRTPおよび関連プロトコルを拡張するための将来のガイドラインを考慮に入れるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Authors of future extensions are urged to consider the wide range of environments in which RTP is used when recommending extensions, since extensions that are applicable in some scenarios can be problematic in others. Where possible, the WebRTC framework will adopt RTP extensions that are of general utility, to enable easy implementation of a gateway to other applications using RTP, rather than adopt mechanisms that are narrowly targeted at specific WebRTC use cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将来の拡張機能の著者は、いくつかのシナリオで適用可能な拡張機能が他のものでは問題がある可能性があるため、RTPが推奨されるときにRTPが使用される幅広い環境を考慮することが促されています。可能であれば、WEBRTCフレームワークは、特定のWEBRTCユースケースで狭くターゲティングされたメカニズムを採用するのではなく、RTPを使用して他のアプリケーションへのゲートウェイを簡単に実装できるようにするために、一般的なユーティリティのRTP拡張機能を採用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10--Signaling-Considerations">
10. Signaling Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. シグナリングの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP is built with the assumption that an external signaling channel exists and can be used to configure RTP sessions and their features. The basic configuration of an RTP session consists of the following parameters:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPは、外部シグナリングチャネルが存在し、RTPセッションとその機能を設定するために使用できるという仮定を使用して構築されています。RTPセッションの基本構成は、次のパラメータで構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP profile: The name of the RTP profile to be used in the session. The RTP/AVP [RFC3551] and RTP/AVPF [RFC4585] profiles can interoperate on a basic level, as can their secure variants, RTP/ SAVP [RFC3711] and RTP/SAVPF [RFC5124]. The secure variants of the profiles do not directly interoperate with the nonsecure variants, due to the presence of additional header fields for authentication in SRTP packets and cryptographic transformation of the payload. WebRTC requires the use of the RTP/SAVPF profile, and this MUST be signaled. Interworking functions might transform this into the RTP/SAVP profile for a legacy use case by indicating to the WebRTC endpoint that the RTP/SAVPF is used and configuring a &#34;trr-int&#34; value of 4 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPプロファイル：セッションで使用されるRTPプロファイルの名前。RTP / AVP [RFC3551]とRTP / AVPF [RFC4585]プロファイルは、安全なバリエーション、RTP / SAVP [RFC3711]とRTP / SAVPF [RFC5124]と同様に、基本レベルで相互運用できます。SRTPパケットでの認証のための追加のヘッダーフィールドとペイロードの暗号変換のための追加のヘッダーフィールドが存在するため、プロファイルの安全なバリエーションは、非セキュアバリアントと直接相互運用されません。WebRTCはRTP / SAVPFプロファイルの使用を必要とし、これはシグナリングされなければなりません。インターワーキング機能は、RTP / SAVPFが使用され、4秒の &#34;TRR-INT&#34;値を設定しているWEBRTCエンドポイントを示すことによって、レガシユースケースのRTP / SAVPプロファイルに変換する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transport information: Source and destination IP address(es) and ports for RTP and RTCP MUST be signaled for each RTP session. In WebRTC, these transport addresses will be provided by Interactive Connectivity Establishment (ICE) [RFC8445] that signals candidates and arrives at nominated candidate address pairs. If RTP and RTCP multiplexing [RFC5761] is to be used such that a single port -- i.e., transport-layer flow -- is used for RTP and RTCP flows, this MUST be signaled (see Section 4.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランスポート情報：RTPセッションごとにRTPおよびRTCPの送信元と宛先IPアドレスと宛先のポートをシグナリングする必要があります。WebRTCでは、これらのトランスポートアドレスは、候補と候補と呼ばれる候補アドレスペアに到達する対話型接続確立（氷）[RFC8445]によって提供されます。RTPおよびRTCP多重化[RFC5761]を使用する場合は、RTPおよびRTCPフローに1つのポート・レイヤー・フローが使用されるように使用される場合、これはシグナリングされなければなりません（セクション4.5を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP payload types, media formats, and format parameters: The mapping between media type names (and hence the RTP payload formats to be used) and the RTP payload type numbers MUST be signaled. Each media type MAY also have a number of media type parameters that MUST also be signaled to configure the codec and RTP payload format (the &#34;a=fmtp:&#34; line from SDP). Section 4.3 of this memo discusses requirements for uniqueness of payload types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPペイロードタイプ、メディアフォーマット、およびフォーマットパラメータ：メディアタイプ名の間のマッピング（したがって、使用されるRTPペイロードフォーマット）とRTPペイロードタイプ番号をシグナリングする必要があります。各メディアタイプには、コーデックとRTPペイロード形式（SDPからの &#34;A = FMTP：&#34;行）を設定するようにシグナリングされなければならない多数のメディアタイプパラメータがあります。このメモのセクション4.3は、ペイロードタイプの一意性の要件について説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP extensions: The use of any additional RTP header extensions and RTCP packet types, including any necessary parameters, MUST be signaled. This signaling ensures that a WebRTC endpoint&#39;s behavior, especially when sending, is predictable and consistent. For robustness and compatibility with non-WebRTC systems that might be connected to a WebRTC session via a gateway, implementations are REQUIRED to ignore unknown RTCP packets and RTP header extensions (see also Section 4.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP拡張：必要なパラメータを含む、追加のRTPヘッダー拡張機能とRTCPパケットタイプの使用をシグナリングする必要があります。このシグナリングは、特に送信時のWEBRTCエンドポイントの動作が予測可能で一貫していることを保証します。ゲートウェイを介してWebRTCセッションに接続される可能性のある非WebRTCシステムとの堅牢性と互換性のために、未知のRTCPパケットとRTPヘッダー拡張機能を無視するために実装が必要です（セクション4.1も参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCP bandwidth: Support for exchanging RTCP bandwidth values with the endpoints will be necessary. This SHALL be done as described in &#34;Session Description Protocol (SDP) Bandwidth Modifiers for RTP Control Protocol (RTCP) Bandwidth&#34; [RFC3556] if using SDP, or something semantically equivalent. This also ensures that the endpoints have a common view of the RTCP bandwidth. A common view of the RTCP bandwidth among different endpoints is important to prevent differences in RTCP packet timing and timeout intervals causing interoperability problems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCP帯域幅：RTCP帯域幅値を交換するためのサポートエンドポイントが必要になります。これは、SDPを使用している場合、または意味的に同等のものの「SESSTDESCRUストによく、RTCP）帯域幅」[RFC3556]の「セッション記述プロトコル（SDP）帯域幅」「[RFC3556]。これにより、エンドポイントにRTCP帯域幅の共通のビューがあることが保証されます。異なるエンドポイント間のRTCP帯域幅の共通のビューは、RTCPパケットのタイミングとタイムアウト間隔の違いを防ぐために重要です。相互運用性の問題を引き起こします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These parameters are often expressed in SDP messages conveyed within an offer/answer exchange. RTP does not depend on SDP or the offer/ answer model but does require all the necessary parameters to be agreed upon and provided to the RTP implementation. Note that in WebRTC, it will depend on the signaling model and API how these parameters need to be configured, but they will need to either be set in the API or explicitly signaled between the peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのパラメータは、オファー/回答Exchange内で伝達されたSDPメッセージではしばしば表現されます。RTPはSDPまたはOffer / Answerモデルに依存しませんが、RTPの実装に合意され提供するすべての必要なパラメータを必要とします。WEBRTCでは、シグナリングモデルとAPIに依存します。これらのパラメータを設定する必要があるのは、APIに設定するか、ピア間で明示的にシグナリングされている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11--WebRTC-API-Considerations">
11. WebRTC API Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. WebRTC APIの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The WebRTC API [W3C.WebRTC] and the Media Capture and Streams API [W3C.WD-mediacapture-streams] define and use the concept of a MediaStream that consists of zero or more MediaStreamTracks. A MediaStreamTrack is an individual stream of media from any type of media source, such as a microphone or a camera, but conceptual sources, like an audio mix or a video composition, are also possible. The MediaStreamTracks within a MediaStream might need to be synchronized during playback.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
webrtc api [w3c.webrtc]とメディアキャプチャとストリームAPI [w3c.wd-mediaiacapture-streams]は、0個以上のMediaStreamトラックからなるMediastreamの概念を定義して使用します。MediaStreamTrackは、マイクロフォンやカメラなどの任意の種類のメディアソースからのメディアの個々のメディアストリームであるが、オーディオミックスやビデオ構成のような概念的な情報源も可能である。Mediastream内のメディアストレアトラックは再生中に同期される必要があるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A MediaStreamTrack&#39;s realization in RTP, in the context of an RTCPeerConnection, consists of a source packet stream, identified by an SSRC, sent within an RTP session that is part of the RTCPeerConnection. The MediaStreamTrack can also result in additional packet streams, and thus SSRCs, in the same RTP session. These can be dependent packet streams from scalable encoding of the source stream associated with the MediaStreamTrack, if such a media encoder is used. They can also be redundancy packet streams; these are created when applying Forward Error Correction (Section 6.2) or RTP retransmission (Section 6.1) to the source packet stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCPEerconnectionのコンテキストでは、RTPERCERCONNECTIONのコンテキストでのRTPのMediaStreamTrackの実現は、RTCPeerConnectionの一部であるRTPセッション内で送信されたSSRCによって識別されるソースパケットストリームで構成されています。MediastreamTrackは、同じRTPセッションで、追加のパケットストリーム、したがってSSRCSをもたらすことができます。これらは、そのようなメディアエンコーダが使用されている場合、MediastreamTrackに関連付けられているソースストリームのスケーラブルエンコードからの依存パケットストリームであり得る。それらは冗長パケットストリームでもあります。これらは、順方向誤り訂正（第6.2項）またはRTP再送（セクション6.1）をソースパケットストリームに適用するときに作成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is important to note that the same media source can be feeding multiple MediaStreamTracks. As different sets of constraints or other parameters can be applied to the MediaStreamTrack, each MediaStreamTrack instance added to an RTCPeerConnection SHALL result in an independent source packet stream with its own set of associated packet streams and thus different SSRC(s). It will depend on applied constraints and parameters if the source stream and the encoding configuration will be identical between different MediaStreamTracks sharing the same media source. If the encoding parameters and constraints are the same, an implementation could choose to use only one encoded stream to create the different RTP packet streams. Note that such optimizations would need to take into account that the constraints for one of the MediaStreamTracks can change at any moment, meaning that the encoding configurations might no longer be identical, and two different encoder instances would then be needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じメディアソースが複数のメディアストレアトラックを給紙することができることに注意することが重要です。異なる制約または他のパラメータをMediaStreamTrackに適用できるように、RTCPeerConnectionに追加された各MediaStreamTrackインスタンスは、独立したパケットストリームの独自のセット、したがって異なるSSRCを持つ独立したソースパケットストリームをもたらさなければならない。ソースストリームとエンコード構成が同じメディアソースを共有する異なるMediaStreamトラック間で同じになる場合は、適用された制約とパラメータに依存します。符号化パラメータと制約が同じである場合、実装は異なるRTPパケットストリームを作成するために1つのエンコードされたストリームのみを使用することを選択することができる。そのような最適化は、メディアストレアトラックのうちの1つの制約が任意の瞬間に変化する可能性があることを考慮に入れる必要があることに注意して、符号化構成はもはや同一ではなく、2つの異なるエンコーダインスタンスが必要とされるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The same MediaStreamTrack can also be included in multiple MediaStreams; thus, multiple sets of MediaStreams can implicitly need to use the same synchronization base. To ensure that this works in all cases and does not force an endpoint to disrupt the media by changing synchronization base and CNAME during delivery of any ongoing packet streams, all MediaStreamTracks and their associated SSRCs originating from the same endpoint need to be sent using the same CNAME within one RTCPeerConnection. This is motivating the use of a single CNAME in Section 4.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じMediaStreamTrackも複数のメディアストリームに含めることができます。したがって、複数組のメディアストリームは暗黙的に同じ同期ベースを使用する必要があります。これがすべての場合で機能し、進行中のパケットストリームの配信中に同期ベースとCNAMEを変更してエンドポイントを強制的にしないようにして、すべてのMediaStreamTracksと同じエンドポイントから発信されたその関連SSRCを同じエンドポイントから送信する必要があります。1つのRTCPERECONNECTION内のCNAME。これはセクション4.9で単一のCNAMEの使用をやる気にしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      |  The requirement to use the same CNAME for all SSRCs that
      |  originate from the same endpoint does not require a middlebox
      |  that forwards traffic from multiple endpoints to only use a
      |  single CNAME.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Different CNAMEs normally need to be used for different RTCPeerConnection instances, as specified in Section 4.9. Having two communication sessions with the same CNAME could enable tracking of a user or device across different services (see Section 4.4.1 of [RFC8826] for details). A web application can request that the CNAMEs used in different RTCPeerConnections (within a same-origin context) be the same; this allows for synchronization of the endpoint&#39;s RTP packet streams across the different RTCPeerConnections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション4.9で規定されているように、さまざまなCNAMEを通常、さまざまなRTCPEerConnectionインスタンスに使用する必要があります。同じCNAMEを持つ2つの通信セッションを持つことは、さまざまなサービスを介してユーザーまたはデバイスを追跡できるようになりました（詳細については[RFC8826のセクション4.4.1を参照）。Webアプリケーションは、異なるRTCPeerConnectionsで使用されているCNAMEが（同じ原点コンテキスト内）に要求することができます。これにより、エンドポイントのRTPパケットストリームを異なるRTCPERECONCONECTIONに同期させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      |  Note: This doesn&#39;t result in a tracking issue, since the
      |  creation of matching CNAMEs depends on existing tracking within
      |  a single origin.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above will currently force a WebRTC endpoint that receives a MediaStreamTrack on one RTCPeerConnection and adds it as outgoing one on any RTCPeerConnection to perform resynchronization of the stream. Since the sending party needs to change the CNAME to the one it uses, this implies it has to use a local system clock as the timebase for the synchronization. Thus, the relative relation between the timebase of the incoming stream and the system sending out needs to be defined. This relation also needs monitoring for clock drift and likely adjustments of the synchronization. The sending entity is also responsible for congestion control for its sent streams. In cases of packet loss, the loss of incoming data also needs to be handled. This leads to the observation that the method that is least likely to cause issues or interruptions in the outgoing source packet stream is a model of full decoding, including repair, followed by encoding of the media again into the outgoing packet stream. Optimizations of this method are clearly possible and implementation specific.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記は現在、1つのRTCPERCONCONNECTIONでMediaStreamトラックを受信し、それをOracleAning Oneとして追加して、ストリームの再同期を実行するように強制します。送信先はCNAMEを使用するものに変更する必要があるため、これは同期のタイムベースとしてローカルシステムクロックを使用する必要があることを意味します。したがって、着信ストリームのタイムベースと送信システムのタイムベースとの間の相対関係を定義する必要がある。この関係には、クロックドリフトの監視と同期の調整が可能になります。送信エンティティは、送信されたストリームの輻輳制御を担当しています。パケット損失の場合、着信データの損失も処理する必要があります。これにより、発信元パケットストリームで問題や中断を少なくとも生じさせる可能性が最も低いという観察につながり、修理を含む完全な復号化のモデルであり、それに続くメディアを送信パケットストリームに符号化します。この方法の最適化は明らかに可能であり、実装特有のものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A WebRTC endpoint MUST support receiving multiple MediaStreamTracks, where each of the different MediaStreamTracks (and its sets of associated packet streams) uses different CNAMEs. However, MediaStreamTracks that are received with different CNAMEs have no defined synchronization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebRTCエンドポイントは、異なるMediaStreamTracks（およびその関連パケットストリームのセット）が異なるCNAMEを使用する複数のMediaStreamTracksを受信するサポートしなければなりません。ただし、異なるCNAMEで受信されたMediastreamTrackは、定義された同期はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      |  Note: The motivation for supporting reception of multiple
      |  CNAMEs is to allow for forward compatibility with any future
      |  changes that enable more efficient stream handling when
      |  endpoints relay/forward streams.  It also ensures that
      |  endpoints can interoperate with certain types of multistream
      |  middleboxes or endpoints that are not WebRTC.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;JavaScript Session Establishment Protocol (JSEP)&#34; [RFC8829] specifies that the binding between the WebRTC MediaStreams, MediaStreamTracks, and the SSRC is done as specified in &#34;WebRTC MediaStream Identification in the Session Description Protocol&#34; [RFC8830]. Section 4.1 of the MediaStream Identification (MSID) document [RFC8830] also defines how to map source packet streams with unknown SSRCs to MediaStreamTracks and MediaStreams. This later is relevant to handle some cases of legacy interoperability. Commonly, the RTP payload type of any incoming packets will reveal if the packet stream is a source stream or a redundancy or dependent packet stream. The association to the correct source packet stream depends on the payload format in use for the packet stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;JavaScriptセッション確立プロトコル（jsep）&#34; [RFC8829] WebRTC MediaStream、MediaStreamTracks、およびSSRC間のバインディングが &#34;Session Description Protocolのwebrtc MediaStream Identive&#34; [RFC8830]で指定されているように指定します。MediaStream Identide（MSID）文書のセクション4.1 [RFC8830]は、MediaStreamTracksおよびMediaStreamsに、ソースパケットストリームを不明なSSRCを使用してマッピングする方法も定義します。これは後でレガシー相互運用性の場合には扱うことに関連しています。一般に、任意の着信パケットのRTPペイロードタイプは、パケットストリームがソースストリームまたは冗長パケットストリームであるかどうかを明らかにします。正しいソースパケットストリームへの関連付けは、パケットストリームに使用されているペイロード形式によって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, this specification puts a requirement on the WebRTC API to realize a method for determining the CSRC list (Section 4.1) as well as the mixer-to-client audio levels (Section 5.2.3) (when supported); the basic requirements for this is further discussed in Section 12.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、この仕様は、CSRCリスト（セクション4.1）の決定方法（セクション4.1）とミキサー間のオーディオレベル（サポートされている場合）を実現するための要件を実現します。これに対する基本的な要件は、12.2.1項でさらに説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12--RTP-Implementation-Considerations">
12. RTP Implementation Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. RTP実装に関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following discussion provides some guidance on the implementation of the RTP features described in this memo. The focus is on a WebRTC endpoint implementation perspective, and while some mention is made of the behavior of middleboxes, that is not the focus of this memo.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の議論は、このメモに記載されているRTP機能の実装に関するいくつかのガイダンスを提供します。焦点はWebRTCエンドポイントの実装の観点から見ていますが、これはこのメモの焦点ではありませんミドルボックスの動作について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-1--Configuration-and-Use-of-RTP-Sessions">
12.1. Configuration and Use of RTP Sessions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. RTPセッションの設定と使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A WebRTC endpoint will be a simultaneous participant in one or more RTP sessions. Each RTP session can convey multiple media sources and include media data from multiple endpoints. In the following, some ways in which WebRTC endpoints can configure and use RTP sessions are outlined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebRTCエンドポイントは、1つ以上のRTPセッションの同時参加者になります。各RTPセッションは複数のメディアソースを伝達し、複数のエンドポイントからメディアデータを含めることができます。以下では、WEBRTCエンドポイントがRTPセッションを設定して使用できる方法が概説されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-1-1--Use-of-Multiple-Media-Sources-within-an-RTP-Session">
12.1.1. Use of Multiple Media Sources within an RTP Session
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1.1. RTPセッション内の複数のメディアソースの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP is a group communication protocol, and every RTP session can potentially contain multiple RTP packet streams. There are several reasons why this might be desirable:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPはグループ通信プロトコルであり、すべてのRTPセッションに複数のRTPパケットストリームが含まれている可能性があります。これが望ましいかもしれない理由はいくつかあります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Multiple media types:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 複数のメディアタイプ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Outside of WebRTC, it is common to use one RTP session for each type of media source (e.g., one RTP session for audio sources and one for video sources, each sent over different transport-layer flows). However, to reduce the number of UDP ports used, the default in WebRTC is to send all types of media in a single RTP session, as described in Section 4.4, using RTP and RTCP multiplexing (Section 4.5) to further reduce the number of UDP ports needed. This RTP session then uses only one bidirectional transport-layer flow but will contain multiple RTP packet streams, each containing a different type of media. A common example might be an endpoint with a camera and microphone that sends two RTP packet streams, one video and one audio, into a single RTP session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
WEBRTCの外部では、各タイプのメディアソース（例えば、オーディオソース用の1つのRTPセッションおよびビデオソース用の1つのRTPセッション、それぞれ異なるトランスポートレイヤフローを介して送信された）に1つのRTPセッションを使用することが一般的である。ただし、使用されるUDPポートの数を減らすために、webrtcのデフォルトは、4.4節で説明されているように、単一のRTPセッションですべてのタイプのメディアを送信することです.RTPとRTCP多重化（セクション4.5）の使用（セクション4.5）必要なポート。このRTPセッションは、1つの双方向トランスポート層の流れのみを使用しますが、それぞれ異なるタイプのメディアを含む複数のRTPパケットストリームが含まれます。一般的な例は、2つのRTPパケットストリーム、1つのビデオ、および1つのオーディオを単一のRTPセッションに送信するカメラとマイクロフォンを備えたエンドポイントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Multiple capture devices:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 複数のキャプチャデバイス：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A WebRTC endpoint might have multiple cameras, microphones, or other media capture devices, and so it might want to generate several RTP packet streams of the same media type. Alternatively, it might want to send media from a single capture device in several different formats or quality settings at once. Both can result in a single endpoint sending multiple RTP packet streams of the same media type into a single RTP session at the same time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
WebRTCエンドポイントには、複数のカメラ、マイクロフォン、またはその他のメディアキャプチャデバイスがある可能性があるため、同じメディアタイプの複数のRTPパケットストリームを生成したい場合があります。あるいは、単一のキャプチャデバイスからいくつかの異なるフォーマットまたは品質設定でメディアを一度に送信することをお勧めします。どちらも、同じメディアタイプの複数のRTPパケットストリームを同時に単一のRTPセッションに送信する単一のエンドポイントが発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Associated repair data:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 関連する修復データ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An endpoint might send an RTP packet stream that is somehow associated with another stream. For example, it might send an RTP packet stream that contains FEC or retransmission data relating to another stream. Some RTP payload formats send this sort of associated repair data as part of the source packet stream, while others send it as a separate packet stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
エンドポイントは、他のストリームに関連付けられていることをどういうわけか関連付けられているRTPパケットストリームを送信することがあります。例えば、それは他のストリームに関するFECまたは再送信データを含むRTPパケットストリームを送信するかもしれない。いくつかのRTPペイロードフォーマットは、ソースパケットストリームの一部としてこの種の関連する修復データを送信しますが、他のものは別のパケットストリームとして送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Layered or multiple-description coding:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 階層化または複数記述コーディング：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Within a single RTP session, an endpoint can use a layered media codec -- for example, H.264 Scalable Video Coding (SVC) -- or a multiple-description codec that generates multiple RTP packet streams, each with a distinct RTP SSRC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
単一のRTPセッション内では、エンドポイントは、レイヤードメディアコーデックを使用することができます - 例えば、H.264スケーラブルビデオコーディング（SVC） - または複数のRTPパケットストリームを生成する複数記述コーデック、それぞれは異なるRTP SSRCを備えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* RTP mixers, translators, and other middleboxes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* RTPミキサー、翻訳者、その他のミドルボックス：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An RTP session, in the WebRTC context, is a point-to-point association between an endpoint and some other peer device, where those devices share a common SSRC space. The peer device might be another WebRTC endpoint, or it might be an RTP mixer, translator, or some other form of media-processing middlebox. In the latter cases, the middlebox might send mixed or relayed RTP streams from several participants, which the WebRTC endpoint will need to render. Thus, even though a WebRTC endpoint might only be a member of a single RTP session, the peer device might be extending that RTP session to incorporate other endpoints. WebRTC is a group communication environment, and endpoints need to be capable of receiving, decoding, and playing out multiple RTP packet streams at once, even in a single RTP session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
WebRTCコンテキスト内のRTPセッションは、エンドポイントと他のピアデバイスとの間のポイントツーポイントの関連付けであり、そこでそれらのデバイスは共通のSSRCスペースを共有します。ピアデバイスは別のWebRTCエンドポイントである可能性があるか、RTPミキサー、翻訳者、またはその他の形式のメディア処理ミドルボックスである可能性があります。後者の場合、ミドルボックスはいくつかの参加者から混在または中継されたRTPストリームを送信することができます。これは、WebRTCエンドポイントがレンダリングする必要があります。したがって、WebRTCエンドポイントが単一のRTPセッションのメンバーである可能性があるとしても、ピアデバイスはそのRTPセッションをそのRTPセッションに組み込むことができます。WebRTCはグループ通信環境であり、エンドポイントは単一のRTPセッションでも、一度に複数のRTPパケットストリームを受信し、復号化、および再生することができる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-1-2--Use-of-Multiple-RTP-Sessions">
12.1.2. Use of Multiple RTP Sessions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1.2. 複数のRTPセッションの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to sending and receiving multiple RTP packet streams within a single RTP session, a WebRTC endpoint might participate in multiple RTP sessions. There are several reasons why a WebRTC endpoint might choose to do this:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一のRTPセッション内で複数のRTPパケットストリームを送受信することに加えて、WEBRTCエンドポイントが複数のRTPセッションに参加する可能性があります。WebRTCエンドポイントがこれを実行することを選択することができる理由はいくつかあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* To interoperate with legacy devices:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* レガシーデバイスと相互運用するには：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The common practice in the non-WebRTC world is to send different types of media in separate RTP sessions -- for example, using one RTP session for audio and another RTP session, on a separate transport-layer flow, for video. All WebRTC endpoints need to support the option of sending different types of media on different RTP sessions so they can interwork with such legacy devices. This is discussed further in Section 4.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
非WBRTCの世界における一般的な慣行は、ビデオのための別のトランスポート層の流れのための、別々のRTPセッションと別のRTPセッションの1つのRTPセッションを使用して、別々のRTPセッションでさまざまな種類のメディアを送信することです。すべてのWebRTCエンドポイントは、さまざまなRTPセッションでさまざまな種類のメディアを送信するオプションをサポートする必要があります。これについてはセクション4.4でさらに説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* To provide enhanced quality of service:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 強化されたサービス品質を提供するには：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Some network-based quality-of-service mechanisms operate on the granularity of transport-layer flows. If use of these mechanisms to provide differentiated quality of service for some RTP packet streams is desired, then those RTP packet streams need to be sent in a separate RTP session using a different transport-layer flow, and with appropriate quality-of-service marking. This is discussed further in Section 12.1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
一部のネットワークベースのサービス品質メカニズムは、トランスポート層の流れの粒状度に対して動作します。これらのメカニズムを使用して微分されたサービス品質を提供する場合、いくつかのRTPパケットストリームに望ましい場合は、それらのRTPパケットストリームを別のトランスポート層の流れを使用して別のRTPセッションで送信する必要があります。。これについては、セクション12.1.3でさらに説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* To separate media with different purposes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* メディアを異なる目的で区切るために：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An endpoint might want to send RTP packet streams that have different purposes on different RTP sessions, to make it easy for the peer device to distinguish them. For example, some centralized multiparty conferencing systems display the active speaker in high resolution but show low-resolution &#34;thumbnails&#34; of other participants. Such systems might configure the endpoints to send simulcast high- and low-resolution versions of their video using separate RTP sessions to simplify the operation of the RTP middlebox. In the WebRTC context, this is currently possible by establishing multiple WebRTC MediaStreamTracks that have the same media source in one (or more) RTCPeerConnection. Each MediaStreamTrack is then configured to deliver a particular media quality and thus media bitrate, and it will produce an independently encoded version with the codec parameters agreed specifically in the context of that RTCPeerConnection. The RTP middlebox can distinguish packets corresponding to the low- and high-resolution streams by inspecting their SSRC, RTP payload type, or some other information contained in RTP payload, RTP header extension, or RTCP packets. However, it can be easier to distinguish the RTP packet streams if they arrive on separate RTP sessions on separate transport-layer flows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
エンドポイントは、異なるRTPセッションでさまざまな目的のRTPパケットストリームを送信し、ピアデバイスがそれらを区別できるようにすることができます。たとえば、一部の集中型マルチパーティ会議システムは、アクティブスピーカーを高解像度で表示しますが、他の参加者の低解像度の「サムネイル」を表示します。そのようなシステムは、RTPミドルボックスの操作を単純化するために、独立したRTPセッションを使用して、ビデオのシムルキャスト高解像度および低解像度バージョンを送信するためのエンドポイントを構成することがあります。 WEBRTCコンテキストでは、これは現在、1つのRTCPEerconnectionに同じメディアソースを持つ複数のWebRTC MediaStreamTrackを確立することによって可能です。次いで、各MediaStreamTrackは、特定のメディア品質とメディアビットレートを配信するように構成されており、そのRTCPERCONNECTIONのコンテキストで具体的に合意されたコーデックパラメータを使用して独立してエンコードされたバージョンを作成します。 RTPミドルボックスは、SSRC、RTPペイロードタイプ、またはRTPペイロード、RTPヘッダー拡張、またはRTCPパケットに含まれる他の情報を検査することによって、低分解能ストリームに対応するパケットを区別できます。ただし、RTPパケットストリームを別々のトランスポート層フロー上の別々のRTPセッションに到着させることが簡単になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* To directly connect with multiple peers:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 複数のピアと直接接続するには：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A multiparty conference does not need to use an RTP middlebox. Rather, a multi-unicast mesh can be created, comprising several distinct RTP sessions, with each participant sending RTP traffic over a separate RTP session (that is, using an independent RTCPeerConnection object) to every other participant, as shown in Figure 1. This topology has the benefit of not requiring an RTP middlebox node that is trusted to access and manipulate the media data. The downside is that it increases the used bandwidth at each sender by requiring one copy of the RTP packet streams for each participant that is part of the same session beyond the sender itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
マルチパーティ会議はRTPミドルボックスを使用する必要はありません。むしろ、図1に示すように、各参加者は別のRTPセッション（つまり、独立RTCPERECONCONECTOR OBJECT）を介してRTPトラフィックを送信する（つまり、独立したRTCPERECONCONECTIONオブジェクトを使用して）RTPトラフィックを送信して、複数のユニキャストメッシュを作成できます。トポロジには、メディアデータのアクセスと操作に信頼されているRTPミドルボックスノードが必要ないという利点があります。下側は、送信者自体を超えた同じセッションの一部である各参加者に対してRTPパケットストリームの1つのコピーを必要とすることによって、各送信者の使用帯域幅を増加させることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +---+     +---+
      | A |&lt;---&gt;| B |
      +---+     +---+
        ^         ^
         \       /
          \     /
           v   v
           +---+
           | C |
           +---+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
Figure 1: Multi-unicast Using Several RTP Sessions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
図1：複数のRTPセッションを使用したマルチユニキャスト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The multi-unicast topology could also be implemented as a single RTP session, spanning multiple peer-to-peer transport-layer connections, or as several pairwise RTP sessions, one between each pair of peers. To maintain a coherent mapping of the relationship between RTP sessions and RTCPeerConnection objects, it is RECOMMENDED that this be implemented as several individual RTP sessions. The only downside is that endpoint A will not learn of the quality of any transmission happening between B and C, since it will not see RTCP reports for the RTP session between B and C, whereas it would if all three participants were part of a single RTP session. Experience with the Mbone tools (experimental RTP-based multicast conferencing tools from the late 1990s) has shown that RTCP reception quality reports for third parties can be presented to users in a way that helps them understand asymmetric network problems, and the approach of using separate RTP sessions prevents this. However, an advantage of using separate RTP sessions is that it enables using different media bitrates and RTP session configurations between the different peers, thus not forcing B to endure the same quality reductions as C will if there are limitations in the transport from A to C. It is believed that these advantages outweigh the limitations in debugging power.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
マルチユニキャストトポロジは、複数のピアツーピアトランスポート層接続にまたがる単一のRTPセッションとして、またはピアの各ペアの間に1つずつ、1つのRTPセッションとして実装できます。 RTPセッションとRTCPERECONCECTIONオブジェクト間の関係のコヒーレントマッピングを維持するために、これが複数の個々のRTPセッションとして実装されることをお勧めします。唯一の欠点は、ANDPOINT AがBとCの間のRTPセッションのRTCPレポートを見ていないため、3つの参加者全員が単一の参加者の一部であれば、BとCの間の伝送の品質についてはわからないことです。 RTPセッションMBone Toolsの経験（1990年度後半からの実験的なRTPベースのマルチキャスト会議ツール）の経験が、第三者のRTCP受信品質報告が、非対称なネットワークの問題を理解するのを助ける方法でユーザーに提示できることを示しました。 RTPセッションはこれを防ぎます。ただし、別々のRTPセッションを使用することの利点は、異なるピア間で異なるメディアビットレートとRTPセッション構成を使用することを可能にします。したがって、AからCへのトランスポートに制限がある場合は、Bを強制的に使用できません。 。これらの利点は、デバッグ電力の制限を上回っていると考えられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* To indirectly connect with multiple peers:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 複数のピアと間接的に接続するには
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A common scenario in multiparty conferencing is to create indirect connections to multiple peers, using an RTP mixer, translator, or some other type of RTP middlebox. Figure 2 outlines a simple topology that might be used in a four-person centralized conference. The middlebox acts to optimize the transmission of RTP packet streams from certain perspectives, either by only sending some of the received RTP packet stream to any given receiver, or by providing a combined RTP packet stream out of a set of contributing streams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
マルチパーティ会議の一般的なシナリオは、RTPミキサー、翻訳者、またはその他のRTPミドルボックスを使用して、複数のピアへの間接的な接続を作成することです。図2は、4名の集中会議で使用される可能性がある単純なトポロジを概説しています。MiddleBoxは、受信したRTPパケットストリームのいくつかを任意の受信機に送信することによって、または一組の寄与ストリームから組み合わされたRTPパケットストリームを提供することによって、特定の観点からのRTPパケットストリームの送信を最適化するように機能する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +---+      +-------------+      +---+
      | A |&lt;----&gt;|             |&lt;----&gt;| B |
      +---+      | RTP mixer,  |      +---+
                 | translator, |
                 | or other    |
      +---+      | middlebox   |      +---+
      | C |&lt;----&gt;|             |&lt;----&gt;| D |
      +---+      +-------------+      +---+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
Figure 2: RTP Mixer with Only Unicast Paths
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
図2：ユニキャストパスのみのRTPミキサー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
There are various methods of implementation for the middlebox. If implemented as a standard RTP mixer or translator, a single RTP session will extend across the middlebox and encompass all the endpoints in one multiparty session. Other types of middleboxes might use separate RTP sessions between each endpoint and the middlebox. A common aspect is that these RTP middleboxes can use a number of tools to control the media encoding provided by a WebRTC endpoint. This includes functions like requesting the breaking of the encoding chain and having the encoder produce a so-called Intra frame. Another common aspect is limiting the bitrate of a stream to better match the mixed output. Other aspects are controlling the most suitable frame rate, picture resolution, and the trade-off between frame rate and spatial quality. The middlebox has the responsibility to correctly perform congestion control, identify sources, and manage synchronization while providing the application with suitable media optimizations. The middlebox also has to be a trusted node when it comes to security, since it manipulates either the RTP header or the media itself (or both) received from one endpoint before sending them on towards the endpoint(s); thus they need to be able to decrypt and then re-encrypt the RTP packet stream before sending it out.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ミドルボックスにはさまざまな実装方法があります。標準のRTPミキサーまたはトランスレータとして実装されている場合、単一のRTPセッションはミドルボックスを介して拡張され、1つのマルチパーティセッションですべてのエンドポイントを網羅します。他の種類のミドルボックスは、各エンドポイントとミドルボックスの間に別々のRTPセッションを使用する可能性があります。一般的な態様は、これらのRTPミドルボックスが、WebRTCエンドポイントによって提供されるメディアエンコーディングを制御するために多数のツールを使用できることです。これには、符号化チェーンの破損を要求し、エンコーダがいわゆるイントラフレームを生成するような機能を含む。別の一般的な態様は、混合出力をよりよく一致させるためにストリームのビットレートを制限することである。他の態様は、フレームレートと空間品質との間の最適なフレームレート、ピクチャ解像度、およびトレードオフを制御している。ミドルボックスには、適切なメディア最適化を使用してアプリケーションを提供しながら、輻輳制御を正しく実行し、ソースの識別、および同期の管理を行う責任があります。ミドルボックスは、エンドポイントに向かって送信する前にRTPヘッダーまたはメディア自体（またはその両方）を操作するため、セキュリティに関しては信頼できるノードである必要があります。したがって、それらを送信する前に、RTPパケットストリームを復号化してから再暗号化できるようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Mixers are expected to not forward RTCP reports regarding RTP packet streams across themselves. This is due to the difference between the RTP packet streams provided to the different endpoints. The original media source lacks information about a mixer&#39;s manipulations prior to being sent to the different receivers. This scenario also results in an endpoint&#39;s feedback or requests going to the mixer. When the mixer can&#39;t act on this by itself, it is forced to go to the original media source to fulfill the receiver&#39;s request. This will not necessarily be explicitly visible to any RTP and RTCP traffic, but the interactions and the time to complete them will indicate such dependencies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ミキサーは、RTPパケットストリームに関するRTCPレポートを自分の間で転送しないことが予想されます。これは、さまざまなエンドポイントに提供されたRTPパケットストリーム間の違いによるものです。元のメディアソースは、さまざまな受信機に送信される前のミキサーの操作に関する情報を欠いています。このシナリオはまた、エンドポイントのフィードバックまたはミキサーに行く要求をもたらします。ミキサーがそれ自体によってこれに機能しないとき、それは受信者の要求を満たすために元のメディアソースに行くことを余儀なくされます。これは必ずしもRTPトラフィックとRTCPトラフィックには明示的に表示されるわけではありませんが、それらを完了する時間はそのような依存関係を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Providing source authentication in multiparty scenarios is a challenge. In the mixer-based topologies, endpoints source authentication is based on, firstly, verifying that media comes from the mixer by cryptographic verification and, secondly, trust in the mixer to correctly identify any source towards the endpoint. In RTP sessions where multiple endpoints are directly visible to an endpoint, all endpoints will have knowledge about each others&#39; master keys and can thus inject packets claiming to come from another endpoint in the session. Any node performing relay can perform noncryptographic mitigation by preventing forwarding of packets that have SSRC fields that came from other endpoints before. For cryptographic verification of the source, SRTP would require additional security mechanisms -- for example, Timed Efficient Stream Loss-Tolerant Authentication (TESLA) for SRTP [RFC4383] -- that are not part of the base WebRTC standards.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
マルチパーティシナリオでソース認証を提供することは課題です。ミキサーベースのトポロジでは、エンドポイントソース認証は、まず、メディアが暗号検証によってミキサーから来て、次に、ミキサーを信頼してエンドポイントに向かってソースを正しく識別することを検証しています。複数のエンドポイントがエンドポイントに直接表示されているRTPセッションでは、すべてのエンドポイントが互いのマスターキーに関する知識を持ち、セッションで別のエンドポイントから来るように主張するパケットを注入できます。RELAYを実行するノードは、以前に他のエンドポイントから来たSSRCフィールドを持つパケットの転送を防ぐことで、非暗黙的緩和を実行できます。ソースの暗号検証のために、SRTPは追加のセキュリティメカニズムを必要とするでしょう - たとえば、SRTP [RFC4383]のTESLA（RFC4383]  - ベースWebRTC規格の一部ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* To forward media between multiple peers:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 複数のピア間でメディアを転送するには：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
It is sometimes desirable for an endpoint that receives an RTP packet stream to be able to forward that RTP packet stream to a third party. The are some obvious security and privacy implications in supporting this, but also potential uses. This is supported in the W3C API by taking the received and decoded media and using it as a media source that is re-encoded and transmitted as a new stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
そのRTPパケットストリームを第三者に転送できるようにするためにRTPパケットストリームを受信するエンドポイントが望ましい場合がある。これをサポートする際のいくつかの明白なセキュリティとプライバシーの影響もありますが、潜在的な用途です。これは、受信および復号化されたメディアを取得し、それを再符号化して新しいストリームとして送信されるメディアソースとして使用することによって、W3C APIでサポートされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
At the RTP layer, media forwarding acts as a back-to-back RTP receiver and RTP sender. The receiving side terminates the RTP session and decodes the media, while the sender side re-encodes and transmits the media using an entirely separate RTP session. The original sender will only see a single receiver of the media, and will not be able to tell that forwarding is happening based on RTP-layer information, since the RTP session that is used to send the forwarded media is not connected to the RTP session on which the media was received by the node doing the forwarding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RTP層では、メディア転送はバックツーバックRTP受信者およびRTP送信者として機能します。受信側はRTPセッションを終了してメディアを復号し、送信側は完全に別々のRTPセッションを使用してメディアを再エンコードして送信します。元の送信者はメディアの単一の受信者だけを見ることができ、転送されたメディアの送信に使用されるRTPセッションはRTPセッションに接続されていないため、RTP層の情報に基づいて転送が起こっていることを伝えることはできません。媒体が転送を行っているノードによって受信された。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The endpoint that is performing the forwarding is responsible for producing an RTP packet stream suitable for onwards transmission. The outgoing RTP session that is used to send the forwarded media is entirely separate from the RTP session on which the media was received. This will require media transcoding for congestion control purposes to produce a suitable bitrate for the outgoing RTP session, reducing media quality and forcing the forwarding endpoint to spend the resource on the transcoding. The media transcoding does result in a separation of the two different legs, removing almost all dependencies, and allowing the forwarding endpoint to optimize its media transcoding operation. The cost is greatly increased computational complexity on the forwarding node. Receivers of the forwarded stream will see the forwarding device as the sender of the stream and will not be able to tell from the RTP layer that they are receiving a forwarded stream rather than an entirely new RTP packet stream generated by the forwarding device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
転送を実行しているエンドポイントは、以降の送信に適したRTPパケットストリームを生成する責任があります。転送されたメディアを送信するために使用される発信RTPセッションは、メディアが受信されたRTPセッションとは完全に分離されています。これにより、輻輳制御の目的で媒体トランスコーディングが必要になり、発信RTPセッションのための適切なビットレートを作成し、メディア品質を低減し、転送エンドポイントを強制的にトランスコーディングに費やすことが必要になる。メディアトランスコーディングは、2つの異なる脚部を分離し、ほぼすべての依存関係を除去し、転送エンドポイントがそのメディアトランスコーディング動作を最適化することを可能にする。コストは転送ノード上で計算量の複雑さを大幅に向上させます。転送されたストリームの受信機は、転送装置をストリームの送信者として見ることができ、それらが転送装置によって生成された全く新しいRTPパケットストリームではなく転送ストリームを受信していることをRTP層から指示することができない。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-1-3--Differentiated-Treatment-of-RTP-Streams">
12.1.3. Differentiated Treatment of RTP Streams
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1.3. RTPストリームの微分処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are use cases for differentiated treatment of RTP packet streams. Such differentiation can happen at several places in the system. First of all is the prioritization within the endpoint sending the media, which controls both which RTP packet streams will be sent and their allocation of bitrate out of the current available aggregate, as determined by the congestion control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPパケットストリームの区別処理のためのユースケースがあります。そのような分化はシステム内のいくつかの場所で起こり得る。まず最初に、輻輳制御によって決定されるように、どちらのRTPパケットストリームが送信されるようになるメディアを送信するエンドポイント内の優先順位付けです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is expected that the WebRTC API [W3C.WebRTC] will allow the application to indicate relative priorities for different MediaStreamTracks. These priorities can then be used to influence the local RTP processing, especially when it comes to determining how to divide the available bandwidth between the RTP packet streams for the sake of congestion control. Any changes in relative priority will also need to be considered for RTP packet streams that are associated with the main RTP packet streams, such as redundant streams for RTP retransmission and FEC. The importance of such redundant RTP packet streams is dependent on the media type and codec used, with regard to how robust that codec is against packet loss. However, a default policy might be to use the same priority for a redundant RTP packet stream as for the source RTP packet stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebRTC API [W3C.Webrtc]は、アプリケーションが異なるメディアストレアトラックに対する相対的な優先順位を示すことを期待されます。次いで、これらの優先順位を使用して、特に輻輳制御のためにRTPパケットストリーム間の使用可能な帯域幅を分割する方法を決定することになると、ローカルRTP処理に影響を与えることができる。RTP再送のための冗長ストリームやFECなど、主要なRTPパケットストリームに関連付けられているRTPパケットストリームについて、相対優先順位の変更も考慮する必要があります。そのような冗長RTPパケットストリームの重要性は、コーデックがパケット損失に伴う堅牢なメディアタイプおよびコーデックによって異なります。ただし、デフォルトのポリシーは、ソースRTPパケットストリームに関して、冗長RTPパケットストリームに対して同じ優先順位を使用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Secondly, the network can prioritize transport-layer flows and subflows, including RTP packet streams. Typically, differential treatment includes two steps, the first being identifying whether an IP packet belongs to a class that has to be treated differently, the second consisting of the actual mechanism for prioritizing packets. Three common methods for classifying IP packets are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第二に、ネットワークは、RTPパケットストリームを含むトランスポート層のフローおよびサブフローを優先することができる。典型的には、差動処理は2つのステップを含み、第1のステップは、IPパケットが異なるように扱われる必要があるクラスに属するかどうかを識別する、第2はパケットを優先する実際のメカニズムからなる。IPパケットを分類するための3つの一般的な方法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DiffServ: The endpoint marks a packet with a DiffServ code point to indicate to the network that the packet belongs to a particular class.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
diffserv：エンドポイントは、パケットが特定のクラスに属するネットワークに示すDiffServコードポイントを持つパケットをマークします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flow based: Packets that need to be given a particular treatment are identified using a combination of IP and port address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローベース：特定の治療を受ける必要があるパケットは、IPアドレスとポートアドレスの組み合わせを使用して識別されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Deep packet inspection: A network classifier (DPI) inspects the packet and tries to determine if the packet represents a particular application and type that is to be prioritized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
深いパケット検査：ネットワーク分類器（DPI）はパケットを検査し、パケットが優先される特定のアプリケーションとタイプを表すかどうかを判断しようとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flow-based differentiation will provide the same treatment to all packets within a transport-layer flow, i.e., relative prioritization is not possible. Moreover, if the resources are limited, it might not be possible to provide differential treatment compared to best effort for all the RTP packet streams used in a WebRTC session. The use of flow-based differentiation needs to be coordinated between the WebRTC system and the network(s). The WebRTC endpoint needs to know that flow-based differentiation might be used to provide the separation of the RTP packet streams onto different UDP flows to enable a more granular usage of flow-based differentiation. The used flows, their 5-tuples, and prioritization will need to be communicated to the network so that it can identify the flows correctly to enable prioritization. No specific protocol support for this is specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローベースの微分は、トランスポート層の流れの中ですべてのパケットに同じ扱いを提供します。すなわち、相対的な優先順位付けは不可能です。さらに、リソースが制限されている場合、WebRTCセッションで使用されるすべてのRTPパケットストリームに対して最良の努力と比較して差動処理を提供することは不可能であるかもしれない。フローベースの微分の使用は、WebRTCシステムとネットワークとの間で調整される必要があります。WebRTCエンドポイントは、フローベースの区別のより粒状の識別を可能にするために、RTPパケットストリームの分離をさまざまなUDPフローに分離するためにフローベースの差別化を使用することを知る必要があります。使用されたフロー、それらの5タプル、および優先順位付けは、優先順位付けを可能にするために正確にフローを識別できるようにネットワークに伝達される必要があります。これを特定のプロトコルサポートはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DiffServ assumes that either the endpoint or a classifier can mark the packets with an appropriate Differentiated Services Code Point (DSCP) so that the packets are treated according to that marking. If the endpoint is to mark the traffic, two requirements arise in the WebRTC context: 1) The WebRTC endpoint has to know which DSCPs to use and know that it can use them on some set of RTP packet streams. 2) The information needs to be propagated to the operating system when transmitting the packet. Details of this process are outside the scope of this memo and are further discussed in &#34;Differentiated Services Code Point (DSCP) Packet Markings for WebRTC QoS&#34; [RFC8837].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DIFFSERVは、エンドポイントまたは分類器のいずれかが、パケットがそのマーキングに従って処理されるように、適切な微分サービスコードポイント（DSCP）を持つパケットをマークすることができると仮定します。エンドポイントがトラフィックをマークするのであれば、WEBRTCコンテキストでは2つの要件が発生します。2）パケットを送信するときに情報をオペレーティングシステムに伝播する必要があります。このプロセスの詳細は、このメモの範囲外であり、「WebRTC QoSの差別化サービスコードポイント（DSCP）パケットマーキング」[RFC8837]でさらに議論されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Despite the SRTP media encryption, deep packet inspectors will still be fairly capable of classifying the RTP streams. The reason is that SRTP leaves the first 12 bytes of the RTP header unencrypted. This enables easy RTP stream identification using the SSRC and provides the classifier with useful information that can be correlated to determine, for example, the stream&#39;s media type. Using packet sizes, reception times, packet inter-spacing, RTP timestamp increments, and sequence numbers, fairly reliable classifications are achieved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SRTPメディア暗号化にもかかわらず、ディープパケット検査官は依然としてRTPストリームを分類することができます。その理由は、SRTPがRTPヘッダーの最初の12バイトを暗号化されていないためです。これにより、SSRCを使用して簡単なRTPストリーム識別を可能にし、たとえばストリームのメディアタイプを決定するために相関させることができる有用な情報を含む分類子を提供する。パケットサイズ、受信時間、パケット間間隔、RTPタイムスタンプの増分、およびシーケンス番号、かなり信頼できる分類が達成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For packet-based marking schemes, it might be possible to mark individual RTP packets differently based on the relative priority of the RTP payload. For example, video codecs that have I, P, and B pictures could prioritize any payloads carrying only B frames less, as these are less damaging to lose. However, depending on the QoS mechanism and what markings are applied, this can result in not only different packet-drop probabilities but also packet reordering; see [RFC8837] and [RFC7657] for further discussion. As a default policy, all RTP packets related to an RTP packet stream ought to be provided with the same prioritization; per-packet prioritization is outside the scope of this memo but might be specified elsewhere in future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットベースのマーキング方式の場合、RTPペイロードの相対優先順位に基づいて個々のRTPパケットを異なるようにマークすることが可能です。例えば、i、p、およびbピクチャを有するビデオコーデックは、それらが失われるのが少ないほど、Bフレームのみを持つペイロードを担う任意のペイロードを優先することができる。ただし、QoSメカニズムとどのようなマーキングが適用されるかによっては、パケットドロップ確率だけでなくパケットの並べ替えも生じる可能性があります。さらなる議論のための[RFC8837]と[RFC7657]を参照してください。デフォルトポリシーとして、RTPパケットストリームに関連するすべてのRTPパケットは同じ優先順位付けを提供する必要があります。パケットごとの優先順位付けはこのメモの範囲外ですが、将来他の場所で指定される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is also important to consider how RTCP packets associated with a particular RTP packet stream need to be marked. RTCP compound packets with Sender Reports (SRs) ought to be marked with the same priority as the RTP packet stream itself, so the RTCP-based round-trip time (RTT) measurements are done using the same transport-layer flow priority as the RTP packet stream experiences. RTCP compound packets containing an RR packet ought to be sent with the priority used by the majority of the RTP packet streams reported on. RTCP packets containing time-critical feedback packets can use higher priority to improve the timeliness and likelihood of delivery of such feedback.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のRTPパケットストリームに関連するRTCPパケットをマークする必要があるかを検討することも重要です。送信者レポートを持つRTCP複合パケット（SRS）は、RTPパケットストリーム自体と同じ優先順位でマークされるべきであるため、RTCPベースの往復時間（RTT）測定値はRTPと同じトランスポート層のフロー優先順位を使用して行われます。パケットストリームの経験RRパケットを含むRTCPコンパウンドパケットは、報告されたRTPパケットストリームの大部分によって使用される優先順位とともに送信されるべきです。タイムクリティカルなフィードバックパケットを含むRTCPパケットは、このようなフィードバックの配信の適時性と可能性を向上させるために、より高い優先順位を使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2--Media-Source-RTP-Streams-and-Participant-Identification">
12.2. Media Source, RTP Streams, and Participant Identification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2. メディアソース、RTPストリーム、および参加者の識別情報
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2-1--Media-Source-Identification">
12.2.1. Media Source Identification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.1. メディアソースの識別
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each RTP packet stream is identified by a unique synchronization source (SSRC) identifier. The SSRC identifier is carried in each of the RTP packets comprising an RTP packet stream, and is also used to identify that stream in the corresponding RTCP reports. The SSRC is chosen as discussed in Section 4.8. The first stage in demultiplexing RTP and RTCP packets received on a single transport-layer flow at a WebRTC endpoint is to separate the RTP packet streams based on their SSRC value; once that is done, additional demultiplexing steps can determine how and where to render the media.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各RTPパケットストリームは、固有の同期ソース（SSRC）識別子によって識別されます。SSRC識別子は、RTPパケットストリームを含むRTPパケットのそれぞれで搬送され、対応するRTCPレポートでそのストリームを識別するためにも使用されます。SSRCはセクション4.8で説明したように選択されます。WebRTCエンドポイントで単一のトランスポート層の流れで受信されたRTPおよびRTCPパケットを逆重化する最初の段階は、SSRC値に基づいてRTPパケットストリームを分離することです。それが完了すると、追加の逆多重化ステップは、メディアのどのようにおよびどこにレンダリングするかを決定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP allows a mixer, or other RTP-layer middlebox, to combine encoded streams from multiple media sources to form a new encoded stream from a new media source (the mixer). The RTP packets in that new RTP packet stream can include a contributing source (CSRC) list, indicating which original SSRCs contributed to the combined source stream. As described in Section 4.1, implementations need to support reception of RTP data packets containing a CSRC list and RTCP packets that relate to sources present in the CSRC list. The CSRC list can change on a packet-by-packet basis, depending on the mixing operation being performed. Knowledge of what media sources contributed to a particular RTP packet can be important if the user interface indicates which participants are active in the session. Changes in the CSRC list included in packets need to be exposed to the WebRTC application using some API if the application is to be able to track changes in session participation. It is desirable to map CSRC values back into WebRTC MediaStream identities as they cross this API, to avoid exposing the SSRC/CSRC namespace to WebRTC applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPは、ミキサー、または他のRTP層ミドルボックスを使用して、新しいメディアソースからの符号化ストリームを組み合わせて、新しいメディアソース（ミキサー）から新しい符号化ストリームを形成することができます。その新しいRTPパケットストリームのRTPパケットは、どのオリジナルのSSRCが複合元ストリームに寄与したかを示す貢献ソース（CSRC）リストを含むことができる。セクション4.1で説明されているように、実装はCSRCリストを含むRTPデータパケットとCSRCリストに存在するソースに関連するRTCPパケットの受信をサポートする必要があります。実行されているミキシング動作に応じて、CSRCリストはパケットごとに変更することができます。ユーザインタフェースがセッション内でアクティブになっているかを示す場合、どのメディアソースが特定のRTPパケットに寄与したのかの知識が重要になる可能性があります。アプリケーションがセッション参加の変更を追跡できる場合、パケットに含まれるCSRCリストの変更は、一部のAPIを使用してWebRTCアプリケーションに公開する必要があります。 SSRC / CSRCネームスペースをWEBRTCアプリケーションに公開することを避けるために、CSRC値をWebRTC MediaStream IDにマッピングすることが望ましいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the mixer-to-client audio level extension [RFC6465] is being used in the session (see Section 5.2.3), the information in the CSRC list is augmented by audio-level information for each contributing source. It is desirable to expose this information to the WebRTC application using some API, after mapping the CSRC values to WebRTC MediaStream identities, so it can be exposed in the user interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションでミキサー間のオーディオレベルの拡張子[RFC6465]が使用されている場合（セクション5.2.3を参照）、CSRCリストの情報は、各貢献ソースのオーディオレベルの情報によって拡張されます。CSRC値をWEBRTC MediaStream IDにマッピングした後、この情報をWebRTCアプリケーションに公開することが望ましいので、ユーザーインターフェイスに公開することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2-2--SSRC-Collision-Detection">
12.2.2. SSRC Collision Detection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.2. SSRC衝突検出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RTP standard requires RTP implementations to have support for detecting and handling SSRC collisions -- i.e., be able to resolve the conflict when two different endpoints use the same SSRC value (see Section 8.2 of [RFC3550]). This requirement also applies to WebRTC endpoints. There are several scenarios where SSRC collisions can occur:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP標準は、SSRCの衝突の検出および処理をサポートするためにRTP実装を必要とする - すなわち、2つの異なるエンドポイントが同じSSRC値を使用するときに競合を解決できるようにする（[RFC3550のセクション8.2参照）。この要件はWebRTCエンドポイントにも適用されます。SSRCの衝突が発生する可能性があるいくつかのシナリオがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* In a point-to-point session where each SSRC is associated with either of the two endpoints and the main media-carrying SSRC identifier will be announced in the signaling channel, a collision is less likely to occur due to the information about used SSRCs. If SDP is used, this information is provided by source-specific SDP attributes [RFC5576]. Still, collisions can occur if both endpoints start using a new SSRC identifier prior to having signaled it to the peer and received acknowledgement on the signaling message. &#34;Source-Specific Media Attributes in the Session Description Protocol (SDP)&#34; [RFC5576] contains a mechanism to signal how the endpoint resolved the SSRC collision.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 各SSRCが2つのエンドポイントのいずれかとメインメディアキャリングSSRC識別子のいずれかに関連付けられているポイントツーポイントセッションでは、シグナリングチャネルでアナウンスされます。使用されているSSRCの情報のために、衝突は発生しにくいです。SDPが使用されている場合、この情報はソース固有のSDP属性[RFC5576]によって提供されます。それでも、両方のエンドポイントがピアにシグナリングされ、シグナリングメッセージで確認応答を受信した後に、両方のエンドポイントが新しいSSRC識別子を使用して開始すると衝突が発生する可能性があります。セッション記述プロトコル（SDP）のソース固有のメディア属性（SDP） &#34;[RFC5576]は、エンドポイントがSSRC衝突を解決した方法を送信するためのメカニズムを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* SSRC values that have not been signaled could also appear in an RTP session. This is more likely than it appears, since some RTP functions use extra SSRCs to provide their functionality. For example, retransmission data might be transmitted using a separate RTP packet stream that requires its own SSRC, separate from the SSRC of the source RTP packet stream [RFC4588]. In those cases, an endpoint can create a new SSRC that strictly doesn&#39;t need to be announced over the signaling channel to function correctly on both RTP and RTCPeerConnection level.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* シグナリングされていないSSRC値もRTPセッションに表示されます。いくつかのRTP関数は、機能を提供するために追加のSSRCを使用するため、これは表示される可能性が高いです。例えば、再送データは、ソースRTPパケットストリームのSSRCとは別の独自のSSRCを必要とする別々のRTPパケットストリームを使用して送信され得る[RFC4588]。そのような場合、エンドポイントは、RTPとRTCPERECONCECTIONレベルの両方でシグナリングチャネルを介して正しく機能するように厳密に発表する必要がない新しいSSRCを作成できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Multiple endpoints in a multiparty conference can create new sources and signal those towards the RTP middlebox. In cases where the SSRC/CSRC are propagated between the different endpoints from the RTP middlebox, collisions can occur.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* マルチパーティ会議の複数のエンドポイントは、新しいソースを作成し、RTPミドルボックスに向かって信号を送ることができます。SSRC / CSRCがRTPミドルボックスからの異なるエンドポイント間で伝播されている場合は、衝突が発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* An RTP middlebox could connect an endpoint&#39;s RTCPeerConnection to another RTCPeerConnection from the same endpoint, thus forming a loop where the endpoint will receive its own traffic. While it is clearly considered a bug, it is important that the endpoint be able to recognize and handle the case when it occurs. This case becomes even more problematic when media mixers and such are involved, where the stream received is a different stream but still contains this client&#39;s input.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* RTPミドルボックスは、同じエンドポイントからEndpointのRTCPEerConnectionを別のRTCPeerConnectionに接続でき、エンドポイントが独自のトラフィックを受信するループを作成できます。それは明らかにバグと見なされていますが、エンドポイントが発生したときにケースを認識して処理できることが重要です。メディアミキサーなどが関与している場合、この場合はさらに問題があります。ここで、受信したストリームは別のストリームですが、まだこのクライアントの入力が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These SSRC/CSRC collisions can only be handled on the RTP level when the same RTP session is extended across multiple RTCPeerConnections by an RTP middlebox. To resolve the more generic case where multiple RTCPeerConnections are interconnected, identification of the media source or sources that are part of a MediaStreamTrack being propagated across multiple interconnected RTCPeerConnection needs to be preserved across these interconnections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのSSRC / CSRCの衝突は、RTPミドルボックスによって同じRTPセッションが複数のRTCPERECONCONECTIONSにわたって拡張されたときにのみRTPレベルでのみ処理できます。複数のRTCPeerConnectionが相互接続されているより一般的なケースを解決するには、MediaStreamTrackの一部であるメディアソースまたはソースの識別は、これらの相互接続にわたって保存される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2-3--Media-Synchronization-Context">
12.2.3. Media Synchronization Context
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.3. メディア同期コンテキスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an endpoint sends media from more than one media source, it needs to consider if (and which of) these media sources are to be synchronized. In RTP/RTCP, synchronization is provided by having a set of RTP packet streams be indicated as coming from the same synchronization context and logical endpoint by using the same RTCP CNAME identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントが複数のメディアソースからメディアを送信すると、これらのメディアソースが同期されるかどうかを考慮する必要があります。RTP / RTCPでは、同じRTCP CNAME識別子を使用して、同じ同期コンテキストおよび論理エンドポイントから来るように、同じ同期コンテキストおよび論理エンドポイントからのようなRTPパケットストリームのセットを表示することによって同期が提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next provision is that the internal clocks of all media sources -- i.e., what drives the RTP timestamp -- can be correlated to a system clock that is provided in RTCP Sender Reports encoded in an NTP format. By correlating all RTP timestamps to a common system clock for all sources, the timing relation of the different RTP packet streams, also across multiple RTP sessions, can be derived at the receiver and, if desired, the streams can be synchronized. The requirement is for the media sender to provide the correlation information; whether or not the information is used is up to the receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の規定は、すべてのメディアソースの内部クロック - すなわちRTPタイムスタンプを駆動するものは、NTPフォーマットでエンコードされたRTCP送信者レポートで提供されるシステムクロックと相関させることができるということです。すべてのRTPタイムスタンプをすべてのソースに対して共通のシステムクロックに相関させることによって、複数のRTPセッションにまたがる異なるRTPパケットストリームのタイミング関係は、受信機で導出することができ、必要に応じてストリームを同期させることができる。要件は、メディア送信者が相関情報を提供することです。情報が使用されているかどうかは受信者次第です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13--Security-Considerations">
13. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The overall security architecture for WebRTC is described in [RFC8827], and security considerations for the WebRTC framework are described in [RFC8826]. These considerations also apply to this memo.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebRTCの全体的なセキュリティアーキテクチャは[RFC8827]で説明されており、WebRTCフレームワークのセキュリティ上の考慮事項は[RFC8826]に記載されています。これらの考慮事項はこのメモにも適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The security considerations of the RTP specification, the RTP/SAVPF profile, and the various RTP/RTCP extensions and RTP payload formats that form the complete protocol suite described in this memo apply. It is believed that there are no new security considerations resulting from the combination of these various protocol extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモに記述されている完全なプロトコルスイートを形成するRTP仕様、RTP / SAVPFプロファイル、およびさまざまなRTP / RTCP拡張機能とRTPペイロード形式のセキュリティ上の考慮事項。これらのさまざまなプロトコル拡張の組み合わせから生じる新しいセキュリティ上の考慮事項はないと考えられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;Extended Secure RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/SAVPF)&#34; [RFC5124] provides handling of fundamental issues by offering confidentiality, integrity, and partial source authentication. A media-security solution that is mandatory to implement and use is created by combining this secured RTP profile and DTLS-SRTP keying [RFC5764], as defined by Section 5.5 of [RFC8827].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「リアルタイムトランスポートコントロールプロトコル（RTCP）ベースのフィードバック（RTP / SAVPF）の拡張セキュアRTPプロファイル（RFC5124]は、機密性、整合性、および部分的なソース認証を提供することによって、基本的な問題の処理を提供します。[RFC8827]のセクション5.5で定義されているように、実装と使用に必須のメディアセキュリティソリューションは、この保護されたRTPプロファイルとDTLS-SRTPキーイング[RFC5764]を組み合わせることによって作成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCP packets convey a Canonical Name (CNAME) identifier that is used to associate RTP packet streams that need to be synchronized across related RTP sessions. Inappropriate choice of CNAME values can be a privacy concern, since long-term persistent CNAME identifiers can be used to track users across multiple WebRTC calls. Section 4.9 of this memo mandates generation of short-term persistent RTCP CNAMES, as specified in RFC 7022, resulting in untraceable CNAME values that alleviate this risk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCPパケットは、関連するRTPセッション間で同期する必要があるRTPパケットストリームを関連付けるために使用される正規名（CNAME）識別子を伝えます。長期の永続CNAME識別子を使用して複数のWebRTC呼び出しにわたってユーザーを追跡できるため、CNAME値の選択肢はプライバシーに関する懸念になる可能性があります。このメモのセクション4.9は、RFC 7022で指定されているように、短期間の永続RTCP CNAMEの生成を義務付け、このリスクを軽減するCNAME値が発生しない。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some potential denial-of-service attacks exist if the RTCP reporting interval is configured to an inappropriate value. This could be done by configuring the RTCP bandwidth fraction to an excessively large or small value using the SDP &#34;b=RR:&#34; or &#34;b=RS:&#34; lines [RFC3556] or some similar mechanism, or by choosing an excessively large or small value for the RTP/AVPF minimal receiver report interval (if using SDP, this is the &#34;a=rtcp-fb:... trr-int&#34; parameter) [RFC4585]. The risks are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCPレポートインターバルが不適切な値に設定されている場合、潜在的なサービス拒否攻撃が存在する。これは、SDP「B = RR：」または「B = RS：」行[RFC3556]またはいくつかの同様のメカニズムを使用して、RTCP帯域幅の小数を過度に大きくまたは小さい値に設定することによって行うことができます。RTP / AVPFの最小受信者レポート間隔の値（SDPを使用する場合、これは &#34;A = RTCP-FB：... TRR-INT&#34;パラメータ）[RFC4585]です。リスクは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. the RTCP bandwidth could be configured to make the regular reporting interval so large that effective congestion control cannot be maintained, potentially leading to denial of service due to congestion caused by the media traffic;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. RTCP帯域幅は、正常な報告間隔を大きくするように構成され、効果的な輻輳制御を維持できないため、メディアトラフィックによって引き起こされる輻輳によるサービス拒否につながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. the RTCP interval could be configured to a very small value, causing endpoints to generate high-rate RTCP traffic, potentially leading to denial of service due to the RTCP traffic not being congestion controlled; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. RTCP間隔は非常に小さい値に設定され、エンドポイントが高速RTCPトラフィックを生成する可能性があり、RTCPトラフィックが輻輳制御されていないRTCPトラフィックが拒否される可能性があります。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. RTCP parameters could be configured differently for each endpoint, with some of the endpoints using a large reporting interval and some using a smaller interval, leading to denial of service due to premature participant timeouts due to mismatched timeout periods that are based on the reporting interval. This is a particular concern if endpoints use a small but nonzero value for the RTP/AVPF minimal receiver report interval (trr-int) [RFC4585], as discussed in Section 6.1 of [RFC8108].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. RTCPパラメータは、エンドポイントごとに、エンドポイントごとに異なる方法で設定され、一部のエンドポイントは、レポート間隔に基づくミスマッチタイムアウト期間が一致しているため、早期参加者のタイムアウトのためにサービス拒否を引き起こす可能性があります。これは、[RFC8108]のセクション6.1で説明されているように、エンドポイントがRTP / AVPFの最小受信者レポート間隔（TRR-INT）[RFC4585]の小さいがゼロ以外の値を使用している場合、特に懸念されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Premature participant timeout can be avoided by using the fixed (nonreduced) minimum interval when calculating the participant timeout (see Section 4.1 of this memo and Section 7.1.2 of [RFC8108]). To address the other concerns, endpoints SHOULD ignore parameters that configure the RTCP reporting interval to be significantly longer than the default five-second interval specified in [RFC3550] (unless the media data rate is so low that the longer reporting interval roughly corresponds to 5% of the media data rate), or that configure the RTCP reporting interval small enough that the RTCP bandwidth would exceed the media bandwidth.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">

        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The guidelines in [RFC6562] apply when using variable bitrate (VBR) audio codecs such as Opus (see Section 4.3 for discussion of mandated audio codecs). The guidelines in [RFC6562] also apply, but are of lesser importance, when using the client-to-mixer audio level header extensions (Section 5.2.2) or the mixer-to-client audio level header extensions (Section 5.2.3). The use of the encryption of the header extensions are RECOMMENDED, unless there are known reasons, like RTP middleboxes performing voice-activity-based source selection or third-party monitoring that will greatly benefit from the information, and this has been expressed using API or signaling. If further evidence is produced to show that information leakage is significant from audio-level indications, then use of encryption needs to be mandated at that time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6562]のガイドラインは、opusなどの可変ビットレート（VBR）オーディオコーデックを使用するときに適用されます（必須オーディオコーデックの説明についてはセクション4.3を参照）。[RFC6562]のガイドラインは適用されますが、クライアントからミキサーのオーディオレベルのヘッダー拡張（セクション5.2.2）またはミキサー間のオーディオレベルのヘッダー拡張（セクション5.2.3）を使用する場合もあります。。ヘッダ拡張機能の暗号化の使用は、Voice-Activityベースのソース選択またはその情報から大きく恩恵を受けるサードパーティの監視を実行するRTPミドルボックスなど、既知の理由がない限り、これがAPIまたはAPIを使用して表明されています。シグナリング情報漏洩がオーディオレベルの表示から重要であることを示すためにさらなる証拠が生まれた場合、その時点で暗号化の使用は必須である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In multiparty communication scenarios using RTP middleboxes, a lot of trust is placed on these middleboxes to preserve the session&#39;s security. The middlebox needs to maintain confidentiality and integrity and perform source authentication. As discussed in Section 12.1.1, the middlebox can perform checks that prevent any endpoint participating in a conference from impersonating another. Some additional security considerations regarding multiparty topologies can be found in [RFC7667].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPミドルボックスを使用したマルチパーティコミュニケーションシナリオでは、セッションのセキュリティを維持するためにこれらのミドルボックスに多くの信頼があります。ミドルボックスは、機密性と整合性を維持し、ソース認証を実行する必要があります。12.1.1項で説明されているように、ミドルボックスは、会議に参加しているエンドポイントが別の偽装を防ぐのを防ぐチェックを実行できます。マルチパーティトポロジに関する追加のセキュリティ上の考慮事項は、[RFC7667]にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14--IANA-Considerations">
14. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document has no IANA actions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書にはIANAの行動がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15--References">
15. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1--Normative-References">
15.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;https://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] BRADNER、S、「RFCSで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;https：//www.rfc-editor.org/info/RFC2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2736] Handley, M. and C. Perkins, &#34;Guidelines for Writers of RTP Payload Format Specifications&#34;, BCP 36, RFC 2736, DOI 10.17487/RFC2736, December 1999, &lt;https://www.rfc-editor.org/info/rfc2736&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2736]ハンドリー、M.およびC. PERKINS、「RTPペイロードフォーマットの作成者のためのガイドライン」、BCP 36、RFC 2736、DOI 10.17487 / RFC2736、1999年12月、&lt;https：//www.rfc-editor.org/情報/ RFC2736&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3550] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &#34;RTP: A Transport Protocol for Real-Time Applications&#34;, STD 64, RFC 3550, DOI 10.17487/RFC3550, July 2003, &lt;https://www.rfc-editor.org/info/rfc3550&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3550] Schulzrinne、H.、Casner、S.、Frederick、R.、およびV. Jacobson、「RTP：リアルタイムアプリケーション用輸送プロトコル」、STD 64、RFC 3550、DOI 10.17487 / RFC3550、2003年7月、&lt;https://www.rfc-editor.org/info/rfc3550&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3551] Schulzrinne, H. and S. Casner, &#34;RTP Profile for Audio and Video Conferences with Minimal Control&#34;, STD 65, RFC 3551, DOI 10.17487/RFC3551, July 2003, &lt;https://www.rfc-editor.org/info/rfc3551&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3551] Schulzrinne、H.およびS.Casner、STD 65、RFC 3551、DOI 10.17487 / RFC3551、2003年7月、&lt;https：///www.rfc-編集者。ORG / INFO / RFC3551&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3556] Casner, S., &#34;Session Description Protocol (SDP) Bandwidth Modifiers for RTP Control Protocol (RTCP) Bandwidth&#34;, RFC 3556, DOI 10.17487/RFC3556, July 2003, &lt;https://www.rfc-editor.org/info/rfc3556&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3556] Casner、S.、「セッション記述プロトコル（SDP）帯域幅修飾子（RTCP）帯域幅（RFC）帯域幅（RFC 3556、DOI 10.17487 / RFC3556、2003年7月、&lt;https：//www.rfc-editor.org/ info / rfc3556&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3711] Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &#34;The Secure Real-time Transport Protocol (SRTP)&#34;, RFC 3711, DOI 10.17487/RFC3711, March 2004, &lt;https://www.rfc-editor.org/info/rfc3711&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3711] Baugher、M.、McGrew、D.、Naslund、M.、Carrara、E.、K.Norrman、「安全なリアルタイムトランスポートプロトコル（SRTP）」、RFC 3711、DOI 10.17487 / RFC3711、3月2004年、&lt;https：//www.rfc-editor.org/info/rfc3711&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4566] Handley, M., Jacobson, V., and C. Perkins, &#34;SDP: Session Description Protocol&#34;, RFC 4566, DOI 10.17487/RFC4566, July 2006, &lt;https://www.rfc-editor.org/info/rfc4566&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4566]ハンドリー、M.、Jacobson、V.、およびC.Perkins、「SDP：セッション記述プロトコル」、RFC 4566、DOI 10.17487 / RFC4566、2006年7月、&lt;https：//www.rfc-editor.org/情報/ RFC4566&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4585] Ott, J., Wenger, S., Sato, N., Burmeister, C., and J. Rey, &#34;Extended RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/AVPF)&#34;, RFC 4585, DOI 10.17487/RFC4585, July 2006, &lt;https://www.rfc-editor.org/info/rfc4585&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4585] OTT、J.、Wenger、S.、Sato、N.、Burmeister、C.、J.REY、「リアルタイムトランスポート制御プロトコルのための拡張RTPプロファイル（RTCP）ベースのフィードバック（RTP / AVPF）&#34;、RFC 4585、DOI 10.17487 / RFC4585、2006年7月、&lt;https://www.rfc-editor.org/info/rfc4585&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4588] Rey, J., Leon, D., Miyazaki, A., Varsa, V., and R. Hakenberg, &#34;RTP Retransmission Payload Format&#34;, RFC 4588, DOI 10.17487/RFC4588, July 2006, &lt;https://www.rfc-editor.org/info/rfc4588&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4588] Rey、J.、Leon、D.、Miyazaki、A.、Varsa、V.およびR.Hakenberg、「RTP再送ペイロードフォーマット」、RFC 4588、DOI 10.17487 / RFC4588、2006年7月、&lt;https：//www.rfc-editor.org/info/rfc4588&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4961] Wing, D., &#34;Symmetric RTP / RTP Control Protocol (RTCP)&#34;, BCP 131, RFC 4961, DOI 10.17487/RFC4961, July 2007, &lt;https://www.rfc-editor.org/info/rfc4961&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4961]ウィング、D.、「対称RTP / RTP制御プロトコル（RTCP）」、BCP 131、RFC 4961、DOI 10.17487 / RFC4961、2007年7月、&lt;https：//www.rfc-editor.org/info/rfc4961&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5104] Wenger, S., Chandra, U., Westerlund, M., and B. Burman, &#34;Codec Control Messages in the RTP Audio-Visual Profile with Feedback (AVPF)&#34;, RFC 5104, DOI 10.17487/RFC5104, February 2008, &lt;https://www.rfc-editor.org/info/rfc5104&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5104] Wenger、S、Chandra、U.、Westerlund、M.、およびB.Burman、「フィードバック付きRTPオーディオビジュアルプロファイル（AVPF）」、RFC 5104、DOI 10.17487 / RFC5104、2月2008年、&lt;https://www.rfc-editor.org/info/rfc5104&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5124] Ott, J. and E. Carrara, &#34;Extended Secure RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/SAVPF)&#34;, RFC 5124, DOI 10.17487/RFC5124, February 2008, &lt;https://www.rfc-editor.org/info/rfc5124&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5124] OTT、J.およびE.Carrara、「リアルタイムトランスポート制御プロトコル（RTCP）ベースのフィードバック（RTP / SAVPF）」、RFC 5124、DOI 10.17487 / RFC5124、2008年2月、&lt;HTTPS）//www.rfc-editor.org/info/rfc5124&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5506] Johansson, I. and M. Westerlund, &#34;Support for Reduced-Size Real-Time Transport Control Protocol (RTCP): Opportunities and Consequences&#34;, RFC 5506, DOI 10.17487/RFC5506, April 2009, &lt;https://www.rfc-editor.org/info/rfc5506&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5506] Johansson、I.およびM. Westerlund、「サイズのリアルタイムトランスポートコントロールプロトコル（RTCP）のサポート：機会と結果」、RFC 5506、DOI 10.17487 / RFC5506、2009年4月、&lt;HTTPS：// WWW.rfc-editor.org / info / rfc5506&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5761] Perkins, C. and M. Westerlund, &#34;Multiplexing RTP Data and Control Packets on a Single Port&#34;, RFC 5761, DOI 10.17487/RFC5761, April 2010, &lt;https://www.rfc-editor.org/info/rfc5761&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5761] Perkins、C、M. Westerlund、 &#34;1つのポート上のRFCのRTPデータとコントロールパケット&#34;、RFC 5761、DOI 10.17487 / RFC5761、2010年4月、&lt;https://www.rfc-editor.org/info/ RFC5761&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5764] McGrew, D. and E. Rescorla, &#34;Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP)&#34;, RFC 5764, DOI 10.17487/RFC5764, May 2010, &lt;https://www.rfc-editor.org/info/rfc5764&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5764] MCGREW、D.およびE. RESCORLA、セキュアリアルタイムトランスポートプロトコル（SRTP） &#34;、RFC 5764、DOI 10.17487 / RFC5764、2010年5月、&lt;HTTPS）：//www.rfc-editor.org/info/rfc5764&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6051] Perkins, C. and T. Schierl, &#34;Rapid Synchronisation of RTP Flows&#34;, RFC 6051, DOI 10.17487/RFC6051, November 2010, &lt;https://www.rfc-editor.org/info/rfc6051&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6051] Perkins、CおよびT.Schierl、「RTPフローの迅速な同期」、RFC 6051、DOI 10.17487 / RFC6051、2010年11月、&lt;https：//www.rfc-editor.org/info/rfc6051&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6464] Lennox, J., Ed., Ivov, E., and E. Marocco, &#34;A Real-time Transport Protocol (RTP) Header Extension for Client-to-Mixer Audio Level Indication&#34;, RFC 6464, DOI 10.17487/RFC6464, December 2011, &lt;https://www.rfc-editor.org/info/rfc6464&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6464] Lennox、J.、Ed。、Ivov、E.、およびE.Marocco、「クライアントからミキサーのオーディオレベル表示のためのリアルタイムトランスポートプロトコル（RTP）ヘッダ拡張」、RFC 6464、DOI 10.17487 /RFC6464、2011年12月、&lt;https://www.rfc-editor.org/info/rfc6464&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6465] Ivov, E., Ed., Marocco, E., Ed., and J. Lennox, &#34;A Real-time Transport Protocol (RTP) Header Extension for Mixer-to-Client Audio Level Indication&#34;, RFC 6465, DOI 10.17487/RFC6465, December 2011, &lt;https://www.rfc-editor.org/info/rfc6465&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6465] IVOV、E.、ED。、Marocco、E.、ED。、およびJ.Lennox、「ミキサー間のオーディオレベル表示のためのリアルタイムトランスポートプロトコル（RTP）ヘッダ拡張」、RFC 6465、DOI 10.17487 / RFC6465、2011年12月、&lt;https://www.rfc-editor.org/info/rfc6465&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6562] Perkins, C. and JM. Valin, &#34;Guidelines for the Use of Variable Bit Rate Audio with Secure RTP&#34;, RFC 6562, DOI 10.17487/RFC6562, March 2012, &lt;https://www.rfc-editor.org/info/rfc6562&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6562] Perkins、C、JM。Valin、「セキュアRTPを搭載した可変ビットレートオーディオの使用に関するガイドライン」、RFC 6562、DOI 10.17487 / RFC6562、2012年3月、&lt;https：//www.rfc-editor.org/info/rfc6562&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6904] Lennox, J., &#34;Encryption of Header Extensions in the Secure Real-time Transport Protocol (SRTP)&#34;, RFC 6904, DOI 10.17487/RFC6904, April 2013, &lt;https://www.rfc-editor.org/info/rfc6904&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6904] Lennox、J.、「セキュアリアルタイムトランスポートプロトコル（SRTP）」、RFC 6904、DOI 10.17487 / RFC6904、2013年4月、&lt;https：//ww.rfc-editor.org/情報/ RFC6904&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7007] Terriberry, T., &#34;Update to Remove DVI4 from the Recommended Codecs for the RTP Profile for Audio and Video Conferences with Minimal Control (RTP/AVP)&#34;, RFC 7007, DOI 10.17487/RFC7007, August 2013, &lt;https://www.rfc-editor.org/info/rfc7007&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7007] Terriberry、T.、 &#34;最小限のコントロール（RTP / AVP）&#34;、RFC 7007、DOI 10.17487 / RFC7007、2013年8月、&lt;https：//www.rfc-editor.org/info/rfc7007&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7022] Begen, A., Perkins, C., Wing, D., and E. Rescorla, &#34;Guidelines for Choosing RTP Control Protocol (RTCP) Canonical Names (CNAMEs)&#34;, RFC 7022, DOI 10.17487/RFC7022, September 2013, &lt;https://www.rfc-editor.org/info/rfc7022&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7022] BEGEN、A。、PERKINS、C、WING、D.、およびE.RescoRA、「RTP制御プロトコル（RTCP）正規名（CNAME）（CNAMES）（CNAMES） &#34;、RFC 7022、DOI 10.17487 / RFC7022、2013年9月&lt;https://www.rfc-editor.org/info/rfc7022&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7160] Petit-Huguenin, M. and G. Zorn, Ed., &#34;Support for Multiple Clock Rates in an RTP Session&#34;, RFC 7160, DOI 10.17487/RFC7160, April 2014, &lt;https://www.rfc-editor.org/info/rfc7160&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7160] Petit-Huguenin、M.およびG. Zorn、ED。、「RTPセッションにおける複数のクロックレートのサポート」、RFC 7160、DOI 10.17487 / RFC7160、2014年4月、&lt;https：//www.rfc-編集者.ORG / INFO / RFC7160&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7164] Gross, K. and R. Brandenburg, &#34;RTP and Leap Seconds&#34;, RFC 7164, DOI 10.17487/RFC7164, March 2014, &lt;https://www.rfc-editor.org/info/rfc7164&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7164] Gross、K.およびR. Brandenburg、 &#34;RTPおよびLeap Seconds&#34;、RFC 7164、DOI 10.17487 / RFC7164、2014年3月、&lt;https://www.rfc-editor.org/info/rfc7164&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7742] Roach, A.B., &#34;WebRTC Video Processing and Codec Requirements&#34;, RFC 7742, DOI 10.17487/RFC7742, March 2016, &lt;https://www.rfc-editor.org/info/rfc7742&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7742] ROCH、A.B.、「WEBRTCビデオ処理およびコーデック要件」、RFC 7742、DOI 10.17487 / RFC7742、2016年3月、&lt;https：//www.rfc-editor.org/info/rfc7742&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7874] Valin, JM. and C. Bran, &#34;WebRTC Audio Codec and Processing Requirements&#34;, RFC 7874, DOI 10.17487/RFC7874, May 2016, &lt;https://www.rfc-editor.org/info/rfc7874&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7874] valin、jm。BRAN、「WEBRTCオーディオコーデックおよび処理要件」、RFC 7874、DOI 10.17487 / RFC7874、2016年5月、&lt;https：//www.rfc-editor.org/info/rfc7874&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8083] Perkins, C. and V. Singh, &#34;Multimedia Congestion Control: Circuit Breakers for Unicast RTP Sessions&#34;, RFC 8083, DOI 10.17487/RFC8083, March 2017, &lt;https://www.rfc-editor.org/info/rfc8083&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8083] Perkins、C、V.Singh、 &#34;マルチメディア輻輳制御：ユニキャストRTPセッションのためのサーキットブレーカー&#34;、RFC 8083、DOI 10.17487 / RFC8083、2017年3月、&lt;https：//www.rfc-editor.org/info/ RFC8083&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8108] Lennox, J., Westerlund, M., Wu, Q., and C. Perkins, &#34;Sending Multiple RTP Streams in a Single RTP Session&#34;, RFC 8108, DOI 10.17487/RFC8108, March 2017, &lt;https://www.rfc-editor.org/info/rfc8108&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8108] Lennox、J.、Westerlund、M.、Wu、Q.、およびC. Perkins、「単一のRTPセッションで複数のRTPストリームを送信する」、RFC 8108、DOI 10.17487 / RFC8108、2017年3月、&lt;https：//www.rfc-editor.org/info/rfc8108&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba, B., &#34;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&#34;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba、B、「RFC 2119キーワードの大文字の曖昧さ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、&lt;https：//www.rfc-editor.org/info/RFC8174&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8285] Singer, D., Desineni, H., and R. Even, Ed., &#34;A General Mechanism for RTP Header Extensions&#34;, RFC 8285, DOI 10.17487/RFC8285, October 2017, &lt;https://www.rfc-editor.org/info/rfc8285&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8285]歌手、D.、Desineni、H.、およびR.偶数、「RTPヘッダー拡張のための一般的なメカニズム」、RFC 8285、DOI 10.17487 / RFC8285、2017年10月、&lt;https：//www.rfc-editor.org/info/rfc8285&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8825] Alvestrand, H., &#34;Overview: Real-Time Protocols for Browser-Based Applications&#34;, RFC 8825, DOI 10.17487/RFC8825, January 2021, &lt;https://www.rfc-editor.org/info/rfc8825&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8825] ALVESTRAND、H。、「概要：ブラウザベースのアプリケーション用リアルタイムプロトコル」、RFC 8825、DOI 10.17487 / RFC8825、2021年1月、&lt;https：//www.rfc-editor.org/info/rfc8825&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8826] Rescorla, E., &#34;Security Considerations for WebRTC&#34;, RFC 8826, DOI 10.17487/RFC8826, January 2021, &lt;https://www.rfc-editor.org/info/rfc8826&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8826] Rescorla、E.、「WebRTCのセキュリティ上の考慮事項」、RFC 8826、DOI 10.17487 / RFC8826、2021年1月、&lt;https：//www.rfc-editor.org/info/rfc8826&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8827] Rescorla, E., &#34;WebRTC Security Architecture&#34;, RFC 8827, DOI 10.17487/RFC8827, January 2021, &lt;https://www.rfc-editor.org/info/rfc8827&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8827] Rescorla、E.、「Webrtc Security Architecture」、RFC 8827、DOI 10.17487 / RFC8827、2021年1月、&lt;https：//www.rfc-editor.org/info/rfc8827&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8843] Holmberg, C., Alvestrand, H., and C. Jennings, &#34;Negotiating Media Multiplexing Using the Session Description Protocol (SDP)&#34;, RFC 8843, DOI 10.17487/RFC8843, January 2021, &lt;https://www.rfc-editor.org/info/rfc8843&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8843] Holmberg、C、Alvestrand、H.、およびC.ジェンニング、「セッション記述プロトコル（SDP）」、RFC 8843、DOI 10.17487 / RFC8843、&lt;https：// www。rfc-editor.org/info/rfc8843&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8854] Uberti, J., &#34;WebRTC Forward Error Correction Requirements&#34;, RFC 8854, DOI 10.17487/RFC8854, January 2021, &lt;https://www.rfc-editor.org/info/rfc8854&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8854] Uberti、J.、 &#34;Webrtc順方向訂正要件&#34;、RFC 8854、DOI 10.17487 / RFC8854、2021年1月、&lt;https：//www.rfc-editor.org/info/rfc8854&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8858] Holmberg, C., &#34;Indicating Exclusive Support of RTP and RTP Control Protocol (RTCP) Multiplexing Using the Session Description Protocol (SDP)&#34;, RFC 8858, DOI 10.17487/RFC8858, January 2021, &lt;https://www.rfc-editor.org/info/rfc8858&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8858] Holmberg、C、「RTPとRTP制御プロトコルの排他的サポートとRTP）多重化（SDP） &#34;、RFC 8858、DOI 10.17487 / RFC8858、2021年1月、&lt;https：// www。rfc-editor.org/info/rfc8858&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8860] Westerlund, M., Perkins, C., and J. Lennox, &#34;Sending Multiple Types of Media in a Single RTP Session&#34;, RFC 8860, DOI 10.17487/RFC8860, January 2021, &lt;https://www.rfc-editor.org/info/rfc8860&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8860] Westerlund、M.、Perkins、C.、J.Lennox、「1つのRTPセッションで複数種類のメディアを送信する」、RFC 8860、DOI 10.17487 / RFC8860、2021年1月、&lt;https：//www.rfc-editor.org/info/rfc8860&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8861] Lennox, J., Westerlund, M., Wu, Q., and C. Perkins, &#34;Sending Multiple RTP Streams in a Single RTP Session: Grouping RTP Control Protocol (RTCP) Reception Statistics and Other Feedback&#34;, RFC 8861, DOI 10.17487/RFC8861, January 2021, &lt;https://www.rfc-editor.org/info/rfc8861&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8861] Lennox、J.、Westerlund、M.、Wu、Q.、およびC.Perkins、「1つのRTPセッションで複数のRTPストリームを送信する：グループ化RTP制御プロトコル（RTCP）受信統計およびその他のフィードバック」、RFC 8861、DOI 10.17487 / RFC8861、2021年1月、&lt;https://www.rfc-editor.org/info/rfc8861&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[W3C.WD-mediacapture-streams] Jennings, C., Aboba, B., Bruaroey, J-I., and H. Boström, &#34;Media Capture and Streams&#34;, W3C Candidate Recommendation, &lt;https://www.w3.org/TR/mediacapture-streams/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[W3C.WD-MediaCapture-Streams] Jennings、C、Aboba、B.、Bruaroey、Ji。、およびH.Boström、「メディアキャプチャおよびストリーム」、W3C候補勧告、&lt;https：//www.w3.org/ TR / MediaCapture-Streams /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[W3C.WebRTC] Jennings, C., Boström, H., and J-I. Bruaroey, &#34;WebRTC 1.0: Real-time Communication Between Browsers&#34;, W3C Proposed Recommendation, &lt;https://www.w3.org/TR/webrtc/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[W3C.Webrtc]ジェニング、C、Boström、H.、およびJ-I。Bruaroey、 &#34;WebRTC 1.0：ブラウザ間のリアルタイム通信&#34;、W3Cは推奨事項、&lt;https：//www.w3.org/tr/webrtc/&gt;を提案しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-2--Informative-References">
15.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3611] Friedman, T., Ed., Caceres, R., Ed., and A. Clark, Ed., &#34;RTP Control Protocol Extended Reports (RTCP XR)&#34;, RFC 3611, DOI 10.17487/RFC3611, November 2003, &lt;https://www.rfc-editor.org/info/rfc3611&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3611] Friedman、T.、Ed。、Caceres、R.、Ed。、およびA. Clark、Ed。、「RTP Control Protocol Extended Reports（RTCP XR）」、RFC 3611、DOI 10.17487 / RFC3611、2003年11月、&lt;https://www.rfc-editor.org/info/rfc3611&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4383] Baugher, M. and E. Carrara, &#34;The Use of Timed Efficient Stream Loss-Tolerant Authentication (TESLA) in the Secure Real-time Transport Protocol (SRTP)&#34;, RFC 4383, DOI 10.17487/RFC4383, February 2006, &lt;https://www.rfc-editor.org/info/rfc4383&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4383] Baugher、M.およびE. Carrara、「安全なリアルタイムトランスポートプロトコル（SRTP）」、RFC 4383、DOI 10.17487 / RFC4383、2006年2月、&lt;https://www.rfc-editor.org/info/rfc4383&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5576] Lennox, J., Ott, J., and T. Schierl, &#34;Source-Specific Media Attributes in the Session Description Protocol (SDP)&#34;, RFC 5576, DOI 10.17487/RFC5576, June 2009, &lt;https://www.rfc-editor.org/info/rfc5576&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5576] Lennox、J.、OTT、J.、およびT.Schierl、「セッション記述プロトコル（SDP）」、RFC 5576、DOI 10.17487 / RFC5576、2009年6月、&lt;https：//のソース固有のメディア属性www.rfc-editor.org/info/rfc5576&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5968] Ott, J. and C. Perkins, &#34;Guidelines for Extending the RTP Control Protocol (RTCP)&#34;, RFC 5968, DOI 10.17487/RFC5968, September 2010, &lt;https://www.rfc-editor.org/info/rfc5968&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5968] OTT、J.およびC.PERKINS、「RTP制御プロトコル（RTCP制御プロトコル）」、RFC 5968、DOI 10.17487 / RFC5968、2010年9月、&lt;https://ww.rfc-editor.org/info/ RFC5968&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6263] Marjou, X. and A. Sollaud, &#34;Application Mechanism for Keeping Alive the NAT Mappings Associated with RTP / RTP Control Protocol (RTCP) Flows&#34;, RFC 6263, DOI 10.17487/RFC6263, June 2011, &lt;https://www.rfc-editor.org/info/rfc6263&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6263] Marjou、X.およびA. SOLLAUD、「RTP / RTP制御プロトコル（RTCP）フロー（RTCP / RTP制御プロトコル（RTCP）フロー（RTCP）フロー（RTCP / RTP制御プロトコル（RTCP）フロー（RFC 6263）、DOI 10.17487 / RFC6263、&lt;https：//www.rfc-editor.org/info/rfc6263&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6792] Wu, Q., Ed., Hunt, G., and P. Arden, &#34;Guidelines for Use of the RTP Monitoring Framework&#34;, RFC 6792, DOI 10.17487/RFC6792, November 2012, &lt;https://www.rfc-editor.org/info/rfc6792&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6792] WU、Q。、ED。、HUNT、G、およびP. ARDEN、「RTP監視フレームワークの使用に関するガイドライン」、RFC 6792、DOI 10.17487 / RFC6792、2012年11月、&lt;https：// www。rfc-editor.org/info/rfc6792&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7478] Holmberg, C., Hakansson, S., and G. Eriksson, &#34;Web Real-Time Communication Use Cases and Requirements&#34;, RFC 7478, DOI 10.17487/RFC7478, March 2015, &lt;https://www.rfc-editor.org/info/rfc7478&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7478] Holmberg、C.、Hakansson、S.、およびG.エリスクソン、「Webリアルタイム通信ユースケースおよび要件」、RFC 7478、DOI 10.17487 / RFC7478、2015年3月、&lt;https：//www.rfc-editor.org/info/rfc7478&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7656] Lennox, J., Gross, K., Nandakumar, S., Salgueiro, G., and B. Burman, Ed., &#34;A Taxonomy of Semantics and Mechanisms for Real-Time Transport Protocol (RTP) Sources&#34;, RFC 7656, DOI 10.17487/RFC7656, November 2015, &lt;https://www.rfc-editor.org/info/rfc7656&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7656] Lennox、J.、Gross、K.、Nandakumar、S.、Salgueiro、G.、B. Burman、ED。、「リアルタイムトランスポートプロトコル（RTP）ソースのためのセマンティクスおよびメカニズムの分類」、RFC 7656、DOI 10.17487 / RFC7656、2015年11月、&lt;https：//www.rfc-editor.org/info/rfc7656&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7657] Black, D., Ed. and P. Jones, &#34;Differentiated Services (Diffserv) and Real-Time Communication&#34;, RFC 7657, DOI 10.17487/RFC7657, November 2015, &lt;https://www.rfc-editor.org/info/rfc7657&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7657]黒、D.、ED。P. Jones、「差別化サービス（DiffServ）およびリアルタイム通信」、RFC 7657、DOI 10.17487 / RFC 7657、2015年11月、&lt;https：//www.rfc-editor.org/info/rfc7657&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7667] Westerlund, M. and S. Wenger, &#34;RTP Topologies&#34;, RFC 7667, DOI 10.17487/RFC7667, November 2015, &lt;https://www.rfc-editor.org/info/rfc7667&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7667] Westerlund、M.およびS.Wenger、 &#34;RTPトポロジ&#34;、RFC 7667、DOI 10.17487 / RFC7667、2015年11月、&lt;https：//www.rfc-editor.org/info/rfc7667&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8088] Westerlund, M., &#34;How to Write an RTP Payload Format&#34;, RFC 8088, DOI 10.17487/RFC8088, May 2017, &lt;https://www.rfc-editor.org/info/rfc8088&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8088] Westerlund、M。、「RTPペイロードフォーマットの作成方法」、RFC 8088、DOI 10.17487 / RFC8088、2017年5月、&lt;https：//www.rfc-editor.org/info/rfc8088&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8445] Keranen, A., Holmberg, C., and J. Rosenberg, &#34;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal&#34;, RFC 8445, DOI 10.17487/RFC8445, July 2018, &lt;https://www.rfc-editor.org/info/rfc8445&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8445]ケラネン、A.、Holmberg、C.、J.Rosenberg、「インタラクティブ接続施設（氷）：ネットワークアドレス翻訳者のためのプロトコル」、RFC 8445、DOI 10.17487 / RFC8445、2018年7月、&lt;https://www.rfc-editor.org/info/rfc8445&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8829] Uberti, J., Jennings, C., and E. Rescorla, Ed., &#34;JavaScript Session Establishment Protocol (JSEP)&#34;, RFC 8829, DOI 10.17487/RFC8829, January 2021, &lt;https://www.rfc-editor.org/info/rfc8829&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8829] Uberti、J.、Jennings、C.、およびE. Rescorla、ED。、「Javascriptセッション設立プロトコル（JSEP）」、RFC 8829、DOI 10.17487 / RFC8829、2021年1月、&lt;https：//www.rfc-editor.org/info/rfc8829&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8830] Alvestrand, H., &#34;WebRTC MediaStream Identification in the Session Description Protocol&#34;, RFC 8830, DOI 10.17487/RFC8830, January 2021, &lt;https://www.rfc-editor.org/info/rfc8830&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8830] alvestrand、H.、 &#34;Webrtc MediaStream Identive&#34;、RFC 8830、DOI 10.17487 / RFC8830、1月2021年1月、&lt;https：//www.rfc-editor.org/info/rfc8830&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8836] Jesup, R. and Z. Sarker, Ed., &#34;Congestion Control Requirements for Interactive Real-Time Media&#34;, RFC 8836, DOI 10.17487/RFC8836, January 2021, &lt;https://www.rfc-editor.org/info/rfc8836&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8836] Jesup、R.およびZ.Sarker、Ed。、「インタラクティブリアルタイムメディアの輻輳制御要件」、RFC 8836、DOI 10.17487 / RFC8836、2021年1月、&lt;https://www.rfc-editor.org/ info / rfc8836&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8837] Jones, P., Dhesikan, S., Jennings, C., and D. Druta, &#34;Differentiated Services Code Point (DSCP) Packet Markings for WebRTC QoS&#34;, RFC 8837, DOI 10.17487/RFC8837, January 2021, &lt;https://www.rfc-editor.org/info/rfc8837&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8837] Jones、P.、Ashesikan、S.、Jennings、C、およびD. Druta、「微分サービスコードポイント（DSCP）パケットマーキング」、RFC 8837、DOI 10.17487 / RFC8837、2021年1月、&lt;https://www.rfc-editor.org/info/rfc8837&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8872] Westerlund, M., Burman, B., Perkins, C., Alvestrand, H., and R. Even, &#34;Guidelines for Using the Multiplexing Features of RTP to Support Multiple Media Streams&#34;, RFC 8872, DOI 10.17487/RFC8872, January 2021, &lt;https://www.rfc-editor.org/info/rfc8872&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8872] Westerlund、M.、Burman、B.、Perkins、C.、Alvestrand、H.、R.さえ、「複数のメディアストリームをサポートするためのRTPの多重化機能を使用するためのガイドライン」、RFC 8872、DOI 10.17487 /RFC8872、2021年1月、&lt;https://www.rfc-editor.org/info/rfc8872&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgements
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authors would like to thank Bernard Aboba, Harald Alvestrand, Cary Bran, Ben Campbell, Alissa Cooper, Spencer Dawkins, Charles Eckel, Alex Eleftheriadis, Christian Groves, Chris Inacio, Cullen Jennings, Olle Johansson, Suhas Nandakumar, Dan Romascanu, Jim Spring, Martin Thomson, and the other members of the IETF RTCWEB working group for their valuable feedback.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者は、Bernard Aboba、Harald Alvestrand、Cary Bran、Ben Campbell、Alissa Cooper、Spencer Dawkins、Charles Eckel、Alex Eleftheriadis、Chrisian Groves、Chris Inacio、Cullen Jennings、Olle Johansson、Suhas Nandakumar、Dan Romascanu、Jim Spring、Martin Thomson、そしてIETF RTCWebワーキンググループの貴重なフィードバックのための他のメンバー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者の住所
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Colin Perkins University of Glasgow School of Computing Science Glasgow G12 8QQ United Kingdom
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Colin Perkins Glasgow大学コンピューティングサイエンスグラスゴーG12 8QQイギリス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Email: csp@csperkins.org
   URI:   https://csperkins.org/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Magnus Westerlund Ericsson Torshamnsgatan 23 SE-164 80 Kista Sweden
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Magnus Westerlund Ericsson Torshamnsgatan 23 SE-164 80キスタスウェーデン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Email: magnus.westerlund@ericsson.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jörg Ott Technical University Munich Department of Informatics Chair of Connected Mobility Boltzmannstrasse 3 85748 Garching Germany
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JörgOTT技術大学ミュンヘン情報学長の議長の議長の議長の議長Boltzmannstrasse 3 85748 Garchingドイツ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Email: ott@in.tum.de
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
