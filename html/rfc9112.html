<!DOCTYPE html>


<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 9112 - HTTP/1.1 (RFC 9112) 日本語訳</title>
  <meta name="description" content="RFC 9112は、インターネット標準トラックの一部として、HTTP/1.1プロトコルの仕様を定義しています。この文書は、Web通信の基礎となるプロトコルのバージョン1.1に関する詳細な定義とガイドラインを提供し、メッセージの形式、接続の管理、エラーハンドリングなどをカバーしています。HTTP/1.1は、Webページのリクエストと配信に広く利用されており、インターネット上での情報交換の効率と信頼性を高めることを目的としています。関連するRFCには、RFC 7230（HTTP/1.1メッセージ構文とルーティング）、RFC 7231（HTTP/1.1セマンティクスとコンテンツ）、RFC 7232（HTTP/1.1条件付きリクエスト）、RFC 7233（HTTP/1.1レンジリクエスト）、RFC 7234（HTTP/1.1キャッシング）などがあります。RFC 9112はこれらのRFCを置き換え、HTTP/1.1に関する最新の標準を提供します。">

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="./master.css">
  <script src="./index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">9112</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc9112">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 9112 - HTTP/1.1 (RFC 9112) 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc9112">
            https://datatracker.ietf.org/doc/html/rfc9112
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 9112 - HTTP/1.1（RFC 9112）</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <p class="card-text">[要約] RFC 9112は、インターネット標準トラックの一部として、HTTP/1.1プロトコルの仕様を定義しています。この文書は、Web通信の基礎となるプロトコルのバージョン1.1に関する詳細な定義とガイドラインを提供し、メッセージの形式、接続の管理、エラーハンドリングなどをカバーしています。HTTP/1.1は、Webページのリクエストと配信に広く利用されており、インターネット上での情報交換の効率と信頼性を高めることを目的としています。関連するRFCには、RFC 7230（HTTP/1.1メッセージ構文とルーティング）、RFC 7231（HTTP/1.1セマンティクスとコンテンツ）、RFC 7232（HTTP/1.1条件付きリクエスト）、RFC 7233（HTTP/1.1レンジリクエスト）、RFC 7234（HTTP/1.1キャッシング）などがあります。RFC 9112はこれらのRFCを置き換え、HTTP/1.1に関する最新の標準を提供します。</p>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 9112                                         Adobe
STD: 99                                               M. Nottingham, Ed.
Obsoletes: 7230                                                   Fastly
Category: Standards Track                                J. Reschke, Ed.
ISSN: 2070-1721                                               greenbytes
                                                               June 2022
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-32">
HTTP/1.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-32">
HTTP/1.1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document specifies the HTTP/1.1 message syntax, message parsing, connection management, and related security concerns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HyperText Transfer Protocol（HTTP）は、分散、共同、ハイパーテキスト情報システムのためのステートレスアプリケーションレベルのプロトコルです。このドキュメントは、HTTP/1.1メッセージの構文、メッセージの解析、接続管理、および関連するセキュリティの懸念を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document obsoletes portions of RFC 7230.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、RFC 7230の一部を廃止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、インターネット標準トラックドキュメントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 7841のセクション2で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9112.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https：//www.rfc-editor.org/info/rfc9112で取得できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2022 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（c）2022 IETF Trustおよび文書著者として特定された人。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、修正されたBSDライセンスで説明されているように保証なしで提供される修正されたBSDライセンステキストを含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントには、2008年11月10日までに公開または公開されたIETFドキュメントまたはIETFの寄付からの資料が含まれている場合があります。IETF標準プロセスの外。そのような資料の著作権を制御する人から適切なライセンスを取得せずに、このドキュメントはIETF標準プロセスの外側に変更されない場合があり、その派生作業は、ITF標準プロセスの外側で作成されない場合があります。RFCとしての出版またはそれを英語以外の言語に翻訳するため。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction
     1.1.  Requirements Notation
     1.2.  Syntax Notation
   2.  Message
     2.1.  Message Format
     2.2.  Message Parsing
     2.3.  HTTP Version
   3.  Request Line
     3.1.  Method
     3.2.  Request Target
       3.2.1.  origin-form
       3.2.2.  absolute-form
       3.2.3.  authority-form
       3.2.4.  asterisk-form
     3.3.  Reconstructing the Target URI
   4.  Status Line
   5.  Field Syntax
     5.1.  Field Line Parsing
     5.2.  Obsolete Line Folding
   6.  Message Body
     6.1.  Transfer-Encoding
     6.2.  Content-Length
     6.3.  Message Body Length
   7.  Transfer Codings
     7.1.  Chunked Transfer Coding
       7.1.1.  Chunk Extensions
       7.1.2.  Chunked Trailer Section
       7.1.3.  Decoding Chunked
     7.2.  Transfer Codings for Compression
     7.3.  Transfer Coding Registry
     7.4.  Negotiating Transfer Codings
   8.  Handling Incomplete Messages
   9.  Connection Management
     9.1.  Establishment
     9.2.  Associating a Response to a Request
     9.3.  Persistence
       9.3.1.  Retrying Requests
       9.3.2.  Pipelining
     9.4.  Concurrency
     9.5.  Failures and Timeouts
     9.6.  Tear-down
     9.7.  TLS Connection Initiation
     9.8.  TLS Connection Closure
   10. Enclosing Messages as Data
     10.1.  Media Type message/http
     10.2.  Media Type application/http
   11. Security Considerations
     11.1.  Response Splitting
     11.2.  Request Smuggling
     11.3.  Message Integrity
     11.4.  Message Confidentiality
   12. IANA Considerations
     12.1.  Field Name Registration
     12.2.  Media Type Registration
     12.3.  Transfer Coding Registration
     12.4.  ALPN Protocol ID Registration
   13. References
     13.1.  Normative References
     13.2.  Informative References
   Appendix A.  Collected ABNF
   Appendix B.  Differences between HTTP and MIME
     B.1.  MIME-Version
     B.2.  Conversion to Canonical Form
     B.3.  Conversion of Date Formats
     B.4.  Conversion of Content-Encoding
     B.5.  Conversion of Content-Transfer-Encoding
     B.6.  MHTML and Line Length Limitations
   Appendix C.  Changes from Previous RFCs
     C.1.  Changes from HTTP/0.9
     C.2.  Changes from HTTP/1.0
       C.2.1.  Multihomed Web Servers
       C.2.2.  Keep-Alive Connections
       C.2.3.  Introduction of Transfer-Encoding
     C.3.  Changes from RFC 7230
   Acknowledgements
   Index
   Authors&#39; Addresses
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Hypertext Transfer Protocol (HTTP) is a stateless application-level request/response protocol that uses extensible semantics and self-descriptive messages for flexible interaction with network-based hypertext information systems. HTTP/1.1 is defined by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HyperText Transfer Protocol（HTTP）は、ネットワークベースのハイパーテキスト情報システムとの柔軟な相互作用のために、拡張可能なセマンティクスと自己記述的なメッセージを使用するステートレスアプリケーションレベルのリクエスト/応答プロトコルです。HTTP/1.1は次のように定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* This document
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* このドキュメント
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* &#34;HTTP Semantics&#34; [HTTP]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 「HTTPセマンティクス」[HTTP]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* &#34;HTTP Caching&#34; [CACHING]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 「HTTPキャッシュ」[キャッシュ]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies how HTTP semantics are conveyed using the HTTP/1.1 message syntax, framing, and connection management mechanisms. Its goal is to define the complete set of requirements for HTTP/1.1 message parsers and message-forwarding intermediaries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、HTTP/1.1メッセージの構文、フレーミング、および接続管理メカニズムを使用してHTTPセマンティクスがどのように伝達されるかを指定します。その目標は、HTTP/1.1メッセージパーサーとメッセージを送信する仲介者の要件の完全なセットを定義することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document obsoletes the portions of RFC 7230 related to HTTP/1.1 messaging and connection management, with the changes being summarized in Appendix C.3. The other parts of RFC 7230 are obsoleted by &#34;HTTP Semantics&#34; [HTTP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、HTTP/1.1メッセージングと接続管理に関連するRFC 7230の部分を廃止し、変更は付録C.3に要約されています。RFC 7230の他の部分は、「HTTPセマンティクス」[HTTP]によって廃止されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-1--Requirements-Notation">
1.1. Requirements Notation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. 要件表記
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, および &#34;OPTIONAL&#34; はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Conformance criteria and considerations regarding error handling are defined in Section 2 of [HTTP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー処理に関する適合基準と考慮事項は、[HTTP]のセクション2で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-2--Syntax-Notation">
1.2. Syntax Notation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. 構文表記
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234], extended with the notation for case-sensitivity in strings defined in [RFC7405].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様では、[RFC7405]で定義された文字列の症例感度の表記法とともに拡張された[RFC5234]の拡張されたBackus-NAURフォーム（ABNF）表記を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It also uses a list extension, defined in Section 5.6.1 of [HTTP], that allows for compact definition of comma-separated lists using a &#34;#&#34; operator (similar to how the &#34;*&#34; operator indicates repetition). Appendix A shows the collected grammar with all list operators expanded to standard ABNF notation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、[http]のセクション5.6.1で定義されているリスト拡張子を使用して、「＃」演算子を使用してコンマ分離リストのコンパクトな定義を可能にします（「*」演算子が繰り返しを示す方法と同様）。付録Aは、収集された文法が標準のABNF表記に拡張されたすべてのリストオペレーターを含む文法を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a convention, ABNF rule names prefixed with &#34;obs-&#34; denote obsolete grammar rules that appear for historical reasons.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
慣習として、ABNFルール名は「obs-」が付いている名前を付けて、歴史的な理由で表示される時代遅れの文法ルールを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following core rules are included by reference, as defined in [RFC5234], Appendix B.1: ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote), HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line feed), OCTET (any 8-bit sequence of data), SP (space), and VCHAR (any visible [USASCII] character).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5234]、付録B.1：アルファ（文字）、CR（キャリッジリターン）、CRLF（CR LF）、CTL（コントロール）、数字（10-9）で定義されているように、次のコアルールが参照により含まれます。、dquote（二重引用）、hexdig（hexadecimal 0-9/a-f/a-f）、htab（水平タブ）、lf（ラインフィード）、オクテット（データの8ビットシーケンス）、sp（スペース）、およびvchar（目に見える[usascii]文字）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rules below are defined in [HTTP]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のルールは[http]で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     BWS           = &lt;BWS, see [HTTP], Section 5.6.3&gt;
     OWS           = &lt;OWS, see [HTTP], Section 5.6.3&gt;
     RWS           = &lt;RWS, see [HTTP], Section 5.6.3&gt;
     absolute-path = &lt;absolute-path, see [HTTP], Section 4.1&gt;
     field-name    = &lt;field-name, see [HTTP], Section 5.1&gt;
     field-value   = &lt;field-value, see [HTTP], Section 5.5&gt;
     obs-text      = &lt;obs-text, see [HTTP], Section 5.6.4&gt;
     quoted-string = &lt;quoted-string, see [HTTP], Section 5.6.4&gt;
     token         = &lt;token, see [HTTP], Section 5.6.2&gt;
     transfer-coding =
                     &lt;transfer-coding, see [HTTP], Section 10.1.4&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rules below are defined in [URI]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のルールは[uri]で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     absolute-URI  = &lt;absolute-URI, see [URI], Section 4.3&gt;
     authority     = &lt;authority, see [URI], Section 3.2&gt;
     uri-host      = &lt;host, see [URI], Section 3.2.2&gt;
     port          = &lt;port, see [URI], Section 3.2.3&gt;
     query         = &lt;query, see [URI], Section 3.4&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Message">
2. Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.1 clients and servers communicate by sending messages. See Section 3 of [HTTP] for the general terminology and core concepts of HTTP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.1クライアントとサーバーは、メッセージを送信して通信します。HTTPの一般用語とコア概念については、[HTTP]のセクション3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1--Message-Format">
2.1. Message Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. メッセージ形式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An HTTP/1.1 message consists of a start-line followed by a CRLF and a sequence of octets in a format similar to the Internet Message Format [RFC5322]: zero or more header field lines (collectively referred to as the &#34;headers&#34; or the &#34;header section&#34;), an empty line indicating the end of the header section, and an optional message body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.1メッセージは、インターネットメッセージ形式[RFC5322]と同様の形式のCRLFとオクテットのシーケンスに続くスタートラインと続いて構成されています。「ヘッダーセクション」）、ヘッダーセクションの端を示す空の行、およびオプションのメッセージ本文。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
HTTP-message = start-line CRLF *( field-line CRLF ) CRLF [ message-body ]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
http-message = start-line crlf *（field-line crlf）crlf [message-body]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A message can be either a request from client to server or a response from server to client. Syntactically, the two types of messages differ only in the start-line, which is either a request-line (for requests) or a status-line (for responses), and in the algorithm for determining the length of the message body (Section 6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージは、クライアントからサーバーへのリクエスト、またはサーバーからクライアントへの応答のいずれかです。構文的に、2種類のメッセージは、リクエストライン（リクエスト用）またはステータスライン（応答用）のいずれかであるスタートラインのみが異なり、メッセージ本文の長さを決定するためのアルゴリズム（セクション）が異なります。6）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     start-line     = request-line / status-line
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In theory, a client could receive requests and a server could receive responses, distinguishing them by their different start-line formats. In practice, servers are implemented to only expect a request (a response is interpreted as an unknown or invalid request method), and clients are implemented to only expect a response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
理論的には、クライアントはリクエストを受信し、サーバーは応答を受信し、異なるスタートライン形式で区別することができます。実際には、サーバーはリクエストのみを期待するように実装されます（応答は未知または無効な要求方法として解釈されます）、クライアントは応答のみを期待するために実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP makes use of some protocol elements similar to the Multipurpose Internet Mail Extensions (MIME) [RFC2045]. See Appendix B for the differences between HTTP and MIME messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPは、多目的インターネットメールエクステンション（MIME）[RFC2045]に似たいくつかのプロトコル要素を使用しています。HTTPメッセージとMIMEメッセージの違いについては、付録Bを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2--Message-Parsing">
2.2. Message Parsing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. メッセージの解析
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The normal procedure for parsing an HTTP message is to read the start-line into a structure, read each header field line into a hash table by field name until the empty line, and then use the parsed data to determine if a message body is expected. If a message body has been indicated, then it is read as a stream until an amount of octets equal to the message body length is read or the connection is closed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPメッセージを解析するための通常の手順は、開始線を構造に読み取り、空のラインまで各ヘッダーフィールドラインをフィールド名でハッシュテーブルに読み取り、解析されたデータを使用してメッセージ本文が予想されるかどうかを判断することです。。メッセージ本文が示されている場合、メッセージボディの長さに等しいオクテットの量が読み取られるか、接続が閉じられるまで、それはストリームとして読み取られます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A recipient MUST parse an HTTP message as a sequence of octets in an encoding that is a superset of US-ASCII [USASCII]. Parsing an HTTP message as a stream of Unicode characters, without regard for the specific encoding, creates security vulnerabilities due to the varying ways that string processing libraries handle invalid multibyte character sequences that contain the octet LF (%x0A). String-based parsers can only be safely used within protocol elements after the element has been extracted from the message, such as within a header field line value after message parsing has delineated the individual field lines.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信者は、US-ASCII [USASCII]のスーパーセットであるエンコードのオクテットのシーケンスとしてHTTPメッセージを解析する必要があります。特定のエンコードに関係なく、HTTPメッセージをユニコード文字のストリームとして解析すると、文字列処理ライブラリがオクテットLF（％x0a）を含む無効なマルチバイト文字シーケンスを処理する方法がさまざまな方法でセキュリティの脆弱性を作成します。文字列ベースのパーサーは、メッセージから個々のフィールドラインを描写した後のヘッダーフィールドライン値内など、メッセージから要素が抽出された後、プロトコル要素内でのみ安全に使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
起動線とフィールドのラインターミネーターはシーケンスCRLFですが、受信者は単一のLFをラインターミネーターとして認識し、前のCRを無視する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content. A recipient of such a bare CR MUST consider that element to be invalid or replace each bare CR with SP before processing the element or forwarding the message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者は、コンテンツ以外のプロトコル要素内で、むき出しのCR（すぐにLFが続きません）を生成してはなりません。そのような裸のCRの受信者は、要素を処理するか、メッセージを転送する前に、その要素が無効であるか、各裸のCRをSPに置き換えることを考慮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Older HTTP/1.0 user agent implementations might send an extra CRLF after a POST request as a workaround for some early server applications that failed to read message body content that was not terminated by a line-ending. An HTTP/1.1 user agent MUST NOT preface or follow a request with an extra CRLF. If terminating the request message body with a line-ending is desired, then the user agent MUST count the terminating CRLF octets as part of the message body length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
古いHTTP/1.0ユーザーエージェントの実装は、回線終了によって終了しなかったメッセージボディコンテンツの読み取りに失敗したいくつかの初期サーバーアプリケーションの回避策として、POSTリクエストの後に追加のCRLFを送信する場合があります。HTTP/1.1ユーザーエージェントは、余分なCRLFでリクエストに従って序文または従ってはなりません。リクエストメッセージ本文をライン終了で終了する場合、ユーザーエージェントはメッセージボディの長さの一部として終了CRLFオクテットをカウントする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the interest of robustness, a server that is expecting to receive and parse a request-line SHOULD ignore at least one empty line (CRLF) received prior to the request-line.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
堅牢性のために、リクエストラインを受信して解析することを期待しているサーバーは、リクエストラインの前に少なくとも1つの空の行（CRLF）を無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender MUST NOT send whitespace between the start-line and the first header field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者は、起動線と最初のヘッダーフィールドの間に白人を送信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A recipient that receives whitespace between the start-line and the first header field MUST either reject the message as invalid or consume each whitespace-preceded line without further processing of it (i.e., ignore the entire line, along with any subsequent lines preceded by whitespace, until a properly formed header field is received or the header section is terminated). Rejection or removal of invalid whitespace-preceded lines is necessary to prevent their misinterpretation by downstream recipients that might be vulnerable to request smuggling (Section 11.2) or response splitting (Section 11.1) attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スタートラインと最初のヘッダーフィールドの間に白文学を受信する受信者は、それをさらに処理することなく、各白文学前のラインを無効として拒否するか、それをさらに処理することなく消費する必要があります（つまり、白文学が前に先行する後続の線とともに、ライン全体を無視する必要があります。、適切に形成されたヘッダーフィールドが受信されるか、ヘッダーセクションが終了するまで）。密輸（セクション11.2）または応答の分割（セクション11.1）攻撃に対して脆弱な下流の受信者による誤解を防ぐために、無効な白文字前の線の拒否または除去が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP要求メッセージのみをリッスンするサーバーがHTTPリクエストメッセージに表示されるものを処理する場合、HTTPリクエストメッセージに表示される場合、上記の堅牢性の例外を除いてHTTP-Message文法と一致しないオクテットのシーケンスを受信すると、サーバーはサーバーです。400（悪い要求）応答で応答し、接続を閉じる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3--HTTP-Version">
2.3. HTTP Version
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. HTTPバージョン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP uses a &#34;&lt;major&gt;.&lt;minor&gt;&#34; numbering scheme to indicate versions of the protocol. This specification defines version &#34;1.1&#34;. Section 2.5 of [HTTP] specifies the semantics of HTTP version numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPは、「&lt;major&gt;。&lt;minor&gt;」番号付けスキームを使用して、プロトコルのバージョンを示します。この仕様はバージョン「1.1」を定義します。[HTTP]のセクション2.5は、HTTPバージョン番号のセマンティクスを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The version of an HTTP/1.x message is indicated by an HTTP-version field in the start-line. HTTP-version is case-sensitive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.xメッセージのバージョンは、起動線のHTTPバージョンフィールドで示されています。HTTP-versionは症例に敏感です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     HTTP-version  = HTTP-name &#34;/&#34; DIGIT &#34;.&#34; DIGIT
     HTTP-name     = %s&#34;HTTP&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an HTTP/1.1 message is sent to an HTTP/1.0 recipient [HTTP/1.0] or a recipient whose version is unknown, the HTTP/1.1 message is constructed such that it can be interpreted as a valid HTTP/1.0 message if all of the newer features are ignored. This specification places recipient-version requirements on some new features so that a conformant sender will only use compatible features until it has determined, through configuration or the receipt of a message, that the recipient supports HTTP/1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.1メッセージがHTTP/1.0レシピエント[HTTP/1.0]またはバージョンが不明な受信者に送信されると、HTTP/1.1メッセージが構築され、すべてがすべての場合に有効なHTTP/1.0メッセージとして解釈できるように作成されます。新しい機能は無視されます。この仕様は、いくつかの新機能に受信者バージョン要件を掲載しているため、コンフォーマント送信者は、受信者がHTTP/1.1をサポートすることを構成またはメッセージの受信を通じて決定するまで互換性のある機能を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Intermediaries that process HTTP messages (i.e., all intermediaries other than those acting as tunnels) MUST send their own HTTP-version in forwarded messages, unless it is purposefully downgraded as a workaround for an upstream issue. In other words, an intermediary is not allowed to blindly forward the start-line without ensuring that the protocol version in that message matches a version to which that intermediary is conformant for both the receiving and sending of messages. Forwarding an HTTP message without rewriting the HTTP-version might result in communication errors when downstream recipients use the message sender&#39;s version to determine what features are safe to use for later communication with that sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPメッセージ（つまり、トンネルとして行動するもの以外のすべての仲介者）を処理する仲介者は、上流の問題の回避策として意図的に格下げされていない限り、転送されたメッセージで独自のHTTPバージョンを送信する必要があります。言い換えれば、そのメッセージのプロトコルバージョンが、その仲介者がメッセージの受信と送信の両方に適合しているバージョンと一致することを保証することなく、仲介者は盲目的にスタートラインを転送することは許可されていません。下流の受信者がメッセージ送信者のバージョンを使用して、その送信者との後の通信に安全な機能を決定する場合、HTTPバージョンを書き直さずにHTTPメッセージを転送すると、通信エラーが発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server MAY send an HTTP/1.0 response to an HTTP/1.1 request if it is known or suspected that the client incorrectly implements the HTTP specification and is incapable of correctly processing later version responses, such as when a client fails to parse the version number correctly or when an intermediary is known to blindly forward the HTTP-version even when it doesn&#39;t conform to the given minor version of the protocol. Such protocol downgrades SHOULD NOT be performed unless triggered by specific client attributes, such as when one or more of the request header fields (e.g., User-Agent) uniquely match the values sent by a client known to be in error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、クライアントがHTTP仕様を誤って実装し、クライアントがバージョン番号を解析できない場合など、クライアントが後のバージョン応答を正しく処理できないことがわかっているか疑われる場合、HTTP/1.1要求にHTTP/1.0応答を送信できます。正しく、または仲介者が特定のマイナーバージョンのプロトコルに準拠していない場合でも、HTTPバージョンを盲目的に転送することが知られている場合。このようなプロトコルの格下げは、1つ以上のリクエストヘッダーフィールド（ユーザーエージェントなど）が誤っていることが知られているクライアントが送信した値と一意に一致する場合など、特定のクライアント属性によってトリガーされない限り、実行しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Request-Line">
3. Request Line
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. リクエスト行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A request-line begins with a method token, followed by a single space (SP), the request-target, and another single space (SP), and ends with the protocol version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストラインは、メソッドトークンから始まり、その後にシングルスペース（SP）、リクエストターゲット、および別の単一スペース（SP）が続き、プロトコルバージョンで終わります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     request-line   = method SP request-target SP HTTP-version
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the request-line grammar rule requires that each of the component elements be separated by a single SP octet, recipients MAY instead parse on whitespace-delimited word boundaries and, aside from the CRLF terminator, treat any form of whitespace as the SP separator while ignoring preceding or trailing whitespace; such whitespace includes one or more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR. However, lenient parsing can result in request smuggling security vulnerabilities if there are multiple recipients of the message and each has its own unique interpretation of robustness (see Section 11.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストラインの文法ルールでは、各コンポーネント要素を単一のSPオクテットで区切る必要がありますが、受信者は代わりに白人格差の単語境界を解析し、CRLFターミネーターを除いて、あらゆる形式のホワイトスペースをSP分離器として扱うことができます。先行または後続の空白を無視します。このような白文学には、次のオクテットの1つ以上が含まれます。SP、HTAB、VT（％x0b）、ff（％x0c）、または裸のcr。ただし、メッセージの複数の受信者がいる場合、それぞれが堅牢性の独自の解釈がある場合、寛大な解析は、セキュリティの脆弱性を密輸する要求につながる可能性があります（セクション11.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP does not place a predefined limit on the length of a request-line, as described in Section 2.3 of [HTTP]. A server that receives a method longer than any that it implements SHOULD respond with a 501 (Not Implemented) status code. A server that receives a request-target longer than any URI it wishes to parse MUST respond with a 414 (URI Too Long) status code (see Section 15.5.15 of [HTTP]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPは、[HTTP]のセクション2.3で説明されているように、要求ラインの長さに定義済みの制限を掲載しません。実装するどのメソッドよりも長くメソッドを受信するサーバーは、501（実装されていない）ステータスコードで応答する必要があります。解析したいURIよりも長くリクエストターゲットを受信するサーバーは、414（URIが長すぎる）ステータスコードで応答する必要があります（[HTTP]のセクション15.5.15を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Various ad hoc limitations on request-line length are found in practice. It is RECOMMENDED that all HTTP senders and recipients support, at a minimum, request-line lengths of 8000 octets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストラインの長さへのさまざまなアドホック制限が実際に見つかります。すべてのHTTP送信者と受信者が、少なくとも8000オクテットのリクエストラインの長さをサポートすることをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--Method">
3.1. Method
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 方法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The method token indicates the request method to be performed on the target resource. The request method is case-sensitive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メソッドトークンは、ターゲットリソースで実行される要求方法を示します。要求方法はケースに敏感です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     method         = token
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The request methods defined by this specification can be found in Section 9 of [HTTP], along with information regarding the HTTP method registry and considerations for defining new methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様で定義された要求方法は、[http]のセクション9に記載されており、HTTPメソッドレジストリに関する情報と新しいメソッドを定義するための考慮事項があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--Request-Target">
3.2. Request Target
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. ターゲットをリクエストします
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The request-target identifies the target resource upon which to apply the request. The client derives a request-target from its desired target URI. There are four distinct formats for the request-target, depending on both the method being requested and whether the request is to a proxy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストターゲットは、リクエストを適用するターゲットリソースを識別します。クライアントは、目的のターゲットURIからリクエストターゲットを導き出します。要求されているメソッドとリクエストがプロキシにあるかどうかに応じて、リクエストターゲットには4つの異なる形式があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     request-target = origin-form
                    / absolute-form
                    / authority-form
                    / asterisk-form
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
No whitespace is allowed in the request-target. Unfortunately, some user agents fail to properly encode or exclude whitespace found in hypertext references, resulting in those disallowed characters being sent as the request-target in a malformed request-line.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストターゲットでは、Whitespaceは許可されていません。残念ながら、一部のユーザーエージェントは、ハイパーテキスト参照で見つかったWhitespaceを適切にエンコードまたは除外できないため、不正な文字が不正な要求ラインでリクエストターゲットとして送信されることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded. A recipient SHOULD NOT attempt to autocorrect and then process the request without a redirect, since the invalid request-line might be deliberately crafted to bypass security filters along the request chain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
無効なリクエストラインの受信者は、400（悪い要求）エラーまたは301（永続的に移動）リダイレクトを適切にエンコードした状態で301（永続的に移動）で応答する必要があります。無効なリクエストラインがリクエストチェーンに沿ってセキュリティフィルターをバイパスするように意図的に作成される可能性があるため、受信者はリダイレクトなしで自動整列してからリクエストを処理しようとしないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client MUST send a Host header field (Section 7.2 of [HTTP]) in all HTTP/1.1 request messages. If the target URI includes an authority component, then a client MUST send a field value for Host that is identical to that authority component, excluding any userinfo subcomponent and its &#34;@&#34; delimiter (Section 4.2 of [HTTP]). If the authority component is missing or undefined for the target URI, then a client MUST send a Host header field with an empty field value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、すべてのHTTP/1.1要求メッセージでホストヘッダーフィールド（[HTTP]のセクション7.2）を送信する必要があります。ターゲットURIに機関コンポーネントが含まれている場合、クライアントは、userinfoサブコンポーネントとその「@」デリミッター（[http]のセクション4.2）を除く、その権限コンポーネントと同一のホストのフィールド値を送信する必要があります。ターゲットURIの権限コンポーネントが欠落または未定義の場合、クライアントは空のフィールド値でホストヘッダーフィールドを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message that lacks a Host header field and to any request message that contains more than one Host header field line or a Host header field with an invalid field value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ホストヘッダーフィールドがないHTTP/1.1リクエストメッセージと、複数のホストヘッダーフィールドラインまたは無効なフィールド値を持つホストヘッダーフィールドを含むリクエストメッセージに400（悪い要求）ステータスコードで応答する必要があります。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-1--origin-form">
3.2.1. origin-form
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. 原点形式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The most common form of request-target is the &#34;origin-form&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストターゲットの最も一般的な形式は「原点形式」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
origin-form = absolute-path [ &#34;?&#34; query ]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Origin-form = absolute-path [&#34;？&#34;クエリ]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When making a request directly to an origin server, other than a CONNECT or server-wide OPTIONS request (as detailed below), a client MUST send only the absolute path and query components of the target URI as the request-target. If the target URI&#39;s path component is empty, the client MUST send &#34;/&#34; as the path within the origin-form of request-target. A Host header field is also sent, as defined in Section 7.2 of [HTTP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続またはサーバー全体のオプション要求以外のオリジンサーバーに直接リクエストを行う場合（以下の詳細）、クライアントはターゲットURIの絶対パスとクエリコンポーネントのみをリクエストターゲットとして送信する必要があります。ターゲットURIのパスコンポーネントが空の場合、クライアントはリクエストターゲットの起源形式内のパスとして「/」を送信する必要があります。[HTTP]のセクション7.2で定義されているように、ホストヘッダーフィールドも送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, a client wishing to retrieve a representation of the resource identified as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、識別されたリソースの表現を取得したいクライアント
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     http://www.example.org/where?q=now
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
directly from the origin server would open (or reuse) a TCP connection to port 80 of the host &#34;www.example.org&#34; and send the lines:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Origin Serverから直接、ホスト「www.example.org」のポート80へのTCP接続を開きます（または再利用します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   GET /where?q=now HTTP/1.1
   Host: www.example.org
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
followed by the remainder of the request message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストメッセージの残りの部分が続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-2--absolute-form">
3.2.2. absolute-form
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2. 絶対形式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When making a request to a proxy, other than a CONNECT or server-wide OPTIONS request (as detailed below), a client MUST send the target URI in &#34;absolute-form&#34; as the request-target.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続またはサーバー全体のオプションリクエスト（以下の詳細）を除いて、プロキシにリクエストを行う場合、クライアントはターゲットURIをリクエストターゲットとして「Absolute-form」で送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     absolute-form  = absolute-URI
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The proxy is requested to either service that request from a valid cache, if possible, or make the same request on the client&#39;s behalf either to the next inbound proxy server or directly to the origin server indicated by the request-target. Requirements on such &#34;forwarding&#34; of messages are defined in Section 7.6 of [HTTP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロキシは、可能であれば有効なキャッシュからその要求を要求するか、クライアントに代わって次のインバウンドプロキシサーバーに、またはリクエストターゲットで示されているOriginサーバーに直接同じリクエストを行うように要求されます。このようなメッセージの「転送」に関する要件は、[HTTP]のセクション7.6で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An example absolute-form of request-line would be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストラインの絶対的な形式の例は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client MUST send a Host header field in an HTTP/1.1 request even if the request-target is in the absolute-form, since this allows the Host information to be forwarded through ancient HTTP/1.0 proxies that might not have implemented Host.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、リクエストターゲットが絶対フォームにある場合でも、ホストヘッダーフィールドをHTTP/1.1リクエストで送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a proxy receives a request with an absolute-form of request-target, the proxy MUST ignore the received Host header field (if any) and instead replace it with the host information of the request-target. A proxy that forwards such a request MUST generate a new Host field value based on the received request-target rather than forward the received Host field value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロキシがリクエストターゲットの絶対形式でリクエストを受信した場合、プロキシは受信したホストヘッダーフィールドを無視し（もしあれば）、代わりにリクエストターゲットのホスト情報に置き換える必要があります。そのような要求を転送するプロキシは、受信したホストフィールド値を転送するのではなく、受信した要求標的に基づいて新しいホストフィールド値を生成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an origin server receives a request with an absolute-form of request-target, the origin server MUST ignore the received Host header field (if any) and instead use the host information of the request-target. Note that if the request-target does not have an authority component, an empty Host header field will be sent in this case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Origin Serverがリクエストターゲットの絶対形式でリクエストを受信した場合、Origin Serverは受信したホストヘッダーフィールド（存在する場合）を無視し、代わりにリクエストターゲットのホスト情報を使用する必要があります。リクエストターゲットに権限コンポーネントがない場合、この場合は空のホストヘッダーフィールドが送信されることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server MUST accept the absolute-form in requests even though most HTTP/1.1 clients will only send the absolute-form to a proxy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ほとんどのHTTP/1.1クライアントは絶対フォームをプロキシに送信するだけであっても、サーバーはリクエストで絶対フォームを受け入れる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-3--authority-form">
3.2.3. authority-form
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3. 権限形式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;authority-form&#34; of request-target is only used for CONNECT requests (Section 9.3.6 of [HTTP]). It consists of only the uri-host and port number of the tunnel destination, separated by a colon (&#34;:&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストターゲットの「権限形式」は、接続要求にのみ使用されます（[HTTP]のセクション9.3.6）。これは、コロン（ &#34;：&#34;）で区切られたトンネルの目的地のURIホストとポート番号のみで構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
authority-form = uri-host &#34;:&#34; port
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
authority-form = uri-host &#34;：&#34;ポート
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When making a CONNECT request to establish a tunnel through one or more proxies, a client MUST send only the host and port of the tunnel destination as the request-target. The client obtains the host and port from the target URI&#39;s authority component, except that it sends the scheme&#39;s default port if the target URI elides the port. For example, a CONNECT request to &#34;http://www.example.com&#34; looks like the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つ以上のプロキシを介してトンネルを確立するための接続要求を作成する場合、クライアントはトンネルの宛先のホストとポートのみを要求ターゲットとして送信する必要があります。クライアントは、ターゲットURIがポートを削減する場合にスキームのデフォルトポートを送信することを除いて、ターゲットURIの権限コンポーネントからホストとポートを取得します。たとえば、「http://www.example.com」への接続要求は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CONNECT www.example.com:80 HTTP/1.1 Host: www.example.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
www.example.com:80 http/1.1ホスト：www.example.comを接続します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-4--asterisk-form">
3.2.4. asterisk-form
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.4. アスタリスク形式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;asterisk-form&#34; of request-target is only used for a server-wide OPTIONS request (Section 9.3.7 of [HTTP]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストターゲットの「アスタリスク形式」は、サーバー全体のオプション要求にのみ使用されます（[http]のセクション9.3.7）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
asterisk-form = &#34;*&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Asterisk-form = &#34;*&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client wishes to request OPTIONS for the server as a whole, as opposed to a specific named resource of that server, the client MUST send only &#34;*&#34; (%x2A) as the request-target. For example,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがそのサーバーの特定の名前のリソースとは対照的に、クライアントがサーバー全体のオプションを要求したい場合、クライアントはリクエストターゲットとして「*」（％x2a）のみを送信する必要があります。例えば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPTIONS * HTTP/1.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプション * http/1.1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a proxy receives an OPTIONS request with an absolute-form of request-target in which the URI has an empty path and no query component, then the last proxy on the request chain MUST send a request-target of &#34;*&#34; when it forwards the request to the indicated origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロキシが、URIに空のパスがあり、クエリコンポーネントがないリクエストターゲットの絶対形式を使用してオプションリクエストを受信した場合、リクエストチェーンの最後のプロキシは「*」のリクエストターゲットを送信する必要があります。指定されたOriginサーバーへの要求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, the request
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、リクエスト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OPTIONS http://www.example.org:8001 HTTP/1.1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
would be forwarded by the final proxy as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最終的なプロキシAsによって転送されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OPTIONS * HTTP/1.1
   Host: www.example.org:8001
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
after connecting to port 8001 of host &#34;www.example.org&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホスト「www.example.org」のポート8001に接続した後。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3--Reconstructing-the-Target-URI">
3.3. Reconstructing the Target URI
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. ターゲットURIの再構築
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The target URI is the request-target when the request-target is in absolute-form. In that case, a server will parse the URI into its generic components for further evaluation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットURIは、リクエストターゲットが絶対形式になっている場合のリクエストターゲットです。その場合、サーバーはURIをその一般的なコンポーネントに解析して、さらなる評価を行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Otherwise, the server reconstructs the target URI from the connection context and various parts of the request message in order to identify the target resource (Section 7.1 of [HTTP]):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それ以外の場合、サーバーは、ターゲットリソース（[http]のセクション7.1）を識別するために、接続コンテキストとリクエストメッセージのさまざまな部分からターゲットURIを再構築します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* If the server&#39;s configuration provides for a fixed URI scheme, or a scheme is provided by a trusted outbound gateway, that scheme is used for the target URI. This is common in large-scale deployments because a gateway server will receive the client&#39;s connection context and replace that with their own connection to the inbound server. Otherwise, if the request is received over a secured connection, the target URI&#39;s scheme is &#34;https&#34;; if not, the scheme is &#34;http&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* サーバーの構成が固定URIスキームを提供する場合、またはスキームが信頼できるアウトバウンドゲートウェイによって提供される場合、そのスキームはターゲットURIに使用されます。これは、ゲートウェイサーバーがクライアントの接続コンテキストを受信し、インバウンドサーバーへの独自の接続に置き換えるため、大規模な展開で一般的です。それ以外の場合、リクエストが担保付き接続で受信された場合、ターゲットURIのスキームは「HTTPS」です。そうでない場合、スキームは「HTTP」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* If the request-target is in authority-form, the target URI&#39;s authority component is the request-target. Otherwise, the target URI&#39;s authority component is the field value of the Host header field. If there is no Host header field or if its field value is empty or invalid, the target URI&#39;s authority component is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* リクエストターゲットが権限形式にある場合、ターゲットURIの権限コンポーネントはリクエストターゲットです。それ以外の場合、ターゲットURIの権限コンポーネントは、ホストヘッダーフィールドのフィールド値です。ホストヘッダーフィールドがない場合、またはそのフィールド値が空または無効な場合、ターゲットURIの権限コンポーネントは空です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* If the request-target is in authority-form or asterisk-form, the target URI&#39;s combined path and query component is empty. Otherwise, the target URI&#39;s combined path and query component is the request-target.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* リクエストターゲットが権威形式またはアスタリスク形式である場合、ターゲットURIの組み合わせパスとクエリコンポーネントが空です。それ以外の場合、ターゲットURIの組み合わせパスとクエリコンポーネントがリクエストターゲットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The components of a reconstructed target URI, once determined as above, can be recombined into absolute-URI form by concatenating the scheme, &#34;://&#34;, authority, and combined path and query component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 再構築されたターゲットURIのコンポーネントは、上記のように決定されると、スキームを合わせて「//」、権威、およびクエリコンポーネントを結合することにより、絶対尿型に再結合できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example 1: The following message received over a secure connection
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例1：安全な接続で受信した次のメッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   GET /pub/WWW/TheProject.html HTTP/1.1
   Host: www.example.org
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
has a target URI of
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
のターゲットURIがあります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     https://www.example.org/pub/WWW/TheProject.html
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example 2: The following message received over an insecure connection
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例2：安全でない接続を介して受信した次のメッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OPTIONS * HTTP/1.1
   Host: www.example.org:8080
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
has a target URI of
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
のターゲットURIがあります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     http://www.example.org:8080
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the target URI&#39;s authority component is empty and its URI scheme requires a non-empty authority (as is the case for &#34;http&#34; and &#34;https&#34;), the server can reject the request or determine whether a configured default applies that is consistent with the incoming connection&#39;s context. Context might include connection details like address and port, what security has been applied, and locally defined information specific to that server&#39;s configuration. An empty authority is replaced with the configured default before further processing of the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットURIの権限コンポーネントが空であり、そのURIスキームが空でない権限を必要とする場合（「HTTP」と「HTTPS」の場合と同様）、サーバーは、構成されたデフォルトが適用されるかどうかを要求または判断することができます。着信接続のコンテキスト。コンテキストには、アドレスやポートなどの接続の詳細、適用されているセキュリティ、およびそのサーバーの構成に固有のローカルで定義された情報が含まれる場合があります。空の権限は、リクエストをさらに処理する前に、設定されたデフォルトに置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Supplying a default name for authority within the context of a secured connection is inherently unsafe if there is any chance that the user agent&#39;s intended authority might differ from the default. A server that can uniquely identify an authority from the request context MAY use that identity as a default without this risk. Alternatively, it might be better to redirect the request to a safe resource that explains how to obtain a new client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーエージェントの意図された権限がデフォルトと異なる可能性がある場合、保護された接続のコンテキスト内で権限のデフォルト名を提供することは、本質的に安全ではありません。要求コンテキストから権限を一意に識別できるサーバーは、このリスクなしにそのIDをデフォルトとして使用する場合があります。または、新しいクライアントを取得する方法を説明する安全なリソースにリクエストをリダイレクトする方が良いかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that reconstructing the client&#39;s target URI is only half of the process for identifying a target resource. The other half is determining whether that target URI identifies a resource for which the server is willing and able to send a response, as defined in Section 7.4 of [HTTP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのターゲットURIの再構築は、ターゲットリソースを識別するプロセスの半分にすぎないことに注意してください。残りの半分は、そのターゲットURIが、[HTTP]のセクション7.4で定義されているように、サーバーが応答を送信することを望んでいるリソースを識別するかどうかを決定しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Status-Line">
4. Status Line
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. ステータス行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first line of a response message is the status-line, consisting of the protocol version, a space (SP), the status code, and another space and ending with an OPTIONAL textual phrase describing the status code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答メッセージの最初の行は、プロトコルバージョン、スペース（SP）、ステータスコード、および別のスペースで構成されるステータスラインであり、ステータスコードを説明するオプションのテキストフレーズで終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
status-line = HTTP-version SP status-code SP [ reason-phrase ]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
ステータスライン= http-version spステータスコードSP [Reason-Phrase]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the status-line grammar rule requires that each of the component elements be separated by a single SP octet, recipients MAY instead parse on whitespace-delimited word boundaries and, aside from the line terminator, treat any form of whitespace as the SP separator while ignoring preceding or trailing whitespace; such whitespace includes one or more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR. However, lenient parsing can result in response splitting security vulnerabilities if there are multiple recipients of the message and each has its own unique interpretation of robustness (see Section 11.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステータスラインの文法ルールでは、各コンポーネント要素を単一のSPオクテットで分離する必要がありますが、受信者は代わりに、白人削除された単語の境界を解析し、ラインターミネーターを除いて、あらゆる形式のホワイトスペースをSP分離器として扱うことができます。先行または後続の空白を無視します。このような白文学には、次のオクテットの1つ以上が含まれます。SP、HTAB、VT（％x0b）、ff（％x0c）、または裸のcr。ただし、メッセージの複数の受信者がいる場合、それぞれが堅牢性の独自の解釈がある場合、寛大な解析はセキュリティの脆弱性を分割する可能性があります（セクション11.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The status-code element is a 3-digit integer code describing the result of the server&#39;s attempt to understand and satisfy the client&#39;s corresponding request. A recipient parses and interprets the remainder of the response message in light of the semantics defined for that status code, if the status code is recognized by that recipient, or in accordance with the class of that status code when the specific code is unrecognized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステータスコード要素は、クライアントの対応する要求を理解し、満たそうとするサーバーの試みの結果を説明する3桁の整数コードです。受信者は、そのステータスコードがその受信者によって認識されている場合、または特定のコードが認識されていない場合にそのステータスコードのクラスに従って、そのステータスコードで定義されたセマンティクスに照らして、応答メッセージの残りを解析および解釈します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     status-code    = 3DIGIT
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP&#39;s core status codes are defined in Section 15 of [HTTP], along with the classes of status codes, considerations for the definition of new status codes, and the IANA registry for collecting such definitions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPのコアステータスコードは、[HTTP]のセクション15で定義され、ステータスコードのクラス、新しいステータスコードの定義に関する考慮事項、およびそのような定義を収集するIANAレジストリが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reason-phrase element exists for the sole purpose of providing a textual description associated with the numeric status code, mostly out of deference to earlier Internet application protocols that were more frequently used with interactive text clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Interactive Textクライアントでより頻繁に使用される以前のインターネットアプリケーションプロトコルに主に敬意を払って、数値ステータスコードに関連付けられたテキスト説明を提供するという唯一の目的のために、Reason-Phrase要素が存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     reason-phrase  = 1*( HTAB / SP / VCHAR / obs-text )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client SHOULD ignore the reason-phrase content because it is not a reliable channel for information (it might be translated for a given locale, overwritten by intermediaries, or discarded when the message is forwarded via other versions of HTTP). A server MUST send the space that separates the status-code from the reason-phrase even when the reason-phrase is absent (i.e., the status-line would end with the space).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、情報の信頼できるチャネルではないため、Reason-Phraseコンテンツを無視する必要があります（特定のロケールに対して翻訳されたり、仲介者によって上書きされたり、HTTPの他のバージョンを介してメッセージを転送したときに破棄されます）。サーバーは、Reason-Phraseが存在しない場合でも、ステータスコードをReason-Phraseから分離するスペースを送信する必要があります（つまり、ステータスラインがスペースで終了します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Field-Syntax">
5. Field Syntax
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. フィールド構文
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each field line consists of a case-insensitive field name followed by a colon (&#34;:&#34;), optional leading whitespace, the field line value, and optional trailing whitespace.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各フィールドラインは、ケースに依存しないフィールド名で構成されており、それに続くコロン（ &#34;：&#34;）、オプションの先頭の白文学、フィールドライン値、およびオプションの末尾の白文学が続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
field-line = field-name &#34;:&#34; OWS field-value OWS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
field-line = field-name &#34;：&#34; ows field-value ows
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rules for parsing within field values are defined in Section 5.5 of [HTTP]. This section covers the generic syntax for header field inclusion within, and extraction from, HTTP/1.1 messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールド値内の解析のルールは、[HTTP]のセクション5.5で定義されています。このセクションでは、HTTP/1.1メッセージからのヘッダーフィールドを含めるための一般的な構文をカバーします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1--Field-Line-Parsing">
5.1. Field Line Parsing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. フィールドライン解析
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Messages are parsed using a generic algorithm, independent of the individual field names. The contents within a given field line value are not parsed until a later stage of message interpretation (usually after the message&#39;s entire field section has been processed).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージは、個々のフィールド名とは無関係に、一般的なアルゴリズムを使用して解析されます。特定のフィールドライン値内の内容は、メッセージ解釈の後期段階まで解析されません（通常、メッセージのフィールド全体が処理された後）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
No whitespace is allowed between the field name and colon. In the past, differences in the handling of such whitespace have led to security vulnerabilities in request routing and response handling. A server MUST reject, with a response status code of 400 (Bad Request), any received request message that contains whitespace between a header field name and colon. A proxy MUST remove any such whitespace from a response message before forwarding the message downstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールド名とコロンの間には、白面は許可されていません。過去には、このような白文学の取り扱いの違いは、リクエストルーティングと応答処理のセキュリティの脆弱性につながりました。サーバーは、400の応答ステータスコード（悪い要求）を拒否する必要があります。プロキシは、メッセージを下流に転送する前に、応答メッセージからそのような空白を削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A field line value might be preceded and/or followed by optional whitespace (OWS); a single SP preceding the field line value is preferred for consistent readability by humans. The field line value does not include that leading or trailing whitespace: OWS occurring before the first non-whitespace octet of the field line value, or after the last non-whitespace octet of the field line value, is excluded by parsers when extracting the field line value from a field line.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドライン値の前に、および/またはその後にオプションのWhitespace（OWS）が続く場合があります。フィールドライン値に先行する単一のSPは、人間が一貫した読みやすくするために好まれます。フィールドラインの値には、フィールドライン値の最初の非白色のオクテットの前、またはフィールドライン値の最後の非白色オクテットの後に発生する先頭または末尾のホワイトスペースは含まれていませんが、フィールドを抽出するときにパーサーによって除外されます。フィールドラインからのライン値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2--Obsolete-Line-Folding">
5.2. Obsolete Line Folding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. 時代遅れの線の折りたたみ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Historically, HTTP/1.x field values could be extended over multiple lines by preceding each extra line with at least one space or horizontal tab (obs-fold). This specification deprecates such line folding except within the &#34;message/http&#34; media type (Section 10.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
歴史的に、HTTP/1.xフィールド値は、少なくとも1つのスペースまたは水平タブ（obs倍）を持つ各追加線を前にすることにより、複数の線に拡張できます。この仕様は、「メッセージ/http」メディアタイプ（セクション10.1）内を除き、そのようなラインの折りたたみを非難します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
obs-fold = OWS CRLF RWS ; obsolete line folding
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
obsfold = ows crlf rws;時代遅れの線の折りたたみ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender MUST NOT generate a message that includes line folding (i.e., that has any field line value that contains a match to the obs-fold rule) unless the message is intended for packaging within the &#34;message/http&#34; media type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者は、メッセージが「メッセージ/http」メディアタイプ内のパッケージを目的としていない限り、行の折りたたみ（つまり、obs倍ルールに一致するフィールドライン値がある）を含むメッセージを生成してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server that receives an obs-fold in a request message that is not within a &#34;message/http&#34; container MUST either reject the message by sending a 400 (Bad Request), preferably with a representation explaining that obsolete line folding is unacceptable, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「メッセージ/http」コンテナ内にない要求メッセージで倍数を受信するサーバーは、400（悪い要求）を送信することでメッセージを拒否する必要があります。フィールド値を解釈するか、メッセージを下流に転送する前に、受信した各SPオクテットで断片を交換します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A proxy or gateway that receives an obs-fold in a response message that is not within a &#34;message/http&#34; container MUST either discard the message and replace it with a 502 (Bad Gateway) response, preferably with a representation explaining that unacceptable line folding was received, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「メッセージ/http」コンテナ内にない応答メッセージの倍数を受信するプロキシまたはゲートウェイは、メッセージを破棄し、502（悪いゲートウェイ）応答に置き換える必要があります。折りたたみを受け取ったか、フィールド値を解釈するか、下流のメッセージを転送する前に、受信した各SPオクテットで溶けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A user agent that receives an obs-fold in a response message that is not within a &#34;message/http&#34; container MUST replace each received obs-fold with one or more SP octets prior to interpreting the field value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「メッセージ/http」コンテナ内にない応答メッセージで倍数を受信するユーザーエージェントは、フィールド値を解釈する前に、受信した各SPオクテットにそれぞれ1つ以上のSPオクテットに置き換える必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Message-Body">
6. Message Body
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. メッセージ本文
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The message body (if any) of an HTTP/1.1 message is used to carry content (Section 6.4 of [HTTP]) for the request or response. The message body is identical to the content unless a transfer coding has been applied, as described in Section 6.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.1メッセージのメッセージ本文（もしあれば）は、要求または応答のコンテンツ（[http]のセクション6.4）を運ぶために使用されます。セクション6.1で説明されているように、メッセージ本文は、転送コーディングが適用されない限り、コンテンツと同一です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     message-body = *OCTET
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rules for determining when a message body is present in an HTTP/1.1 message differ for requests and responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
http/1.1メッセージにメッセージ本文がいつ存在するかを決定するためのルールは、リクエストと応答に対して異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The presence of a message body in a request is signaled by a Content-Length or Transfer-Encoding header field. Request message framing is independent of method semantics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエスト内のメッセージ本文の存在は、コンテンツレングスまたは転送エンコードヘッダーフィールドによって通知されます。リクエストメッセージフレーミングは、メソッドセマンティクスとは無関係です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The presence of a message body in a response, as detailed in Section 6.3, depends on both the request method to which it is responding and the response status code. This corresponds to when response content is allowed by HTTP semantics (Section 6.4.1 of [HTTP]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション6.3で詳述されているように、応答内のメッセージ本文の存在は、応答している要求方法と応答ステータスコードの両方に依存します。これは、応答コンテンツがHTTPセマンティクスによって許可される場合に対応します（[HTTP]のセクション6.4.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-1--Transfer-Encoding">
6.1. Transfer-Encoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. 転送エンコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Transfer-Encoding header field lists the transfer coding names corresponding to the sequence of transfer codings that have been (or will be) applied to the content in order to form the message body. Transfer codings are defined in Section 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
転送エンコードヘッダーフィールドには、メッセージ本文を形成するためにコンテンツに適用された（または適用される）転送コーディングのシーケンスに対応する転送コーディング名をリストします。転送コーディングはセクション7で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     Transfer-Encoding = #transfer-coding
                          ; defined in [HTTP], Section 10.1.4
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transfer-Encoding is analogous to the Content-Transfer-Encoding field of MIME, which was designed to enable safe transport of binary data over a 7-bit transport service ([RFC2045], Section 6). However, safe transport has a different focus for an 8bit-clean transfer protocol. In HTTP&#39;s case, Transfer-Encoding is primarily intended to accurately delimit dynamically generated content. It also serves to distinguish encodings that are only applied in transit from the encodings that are a characteristic of the selected representation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
転送エンコードは、7ビット輸送サービス（[RFC2045]、セクション6）でバイナリデータの安全な輸送を可能にするように設計されたMIMEのコンテンツ移動エンコードフィールドに類似しています。ただし、安全な輸送には、8ビットクリーン転送プロトコルの焦点が異なります。HTTPの場合、転送エンコードは主に動的に生成されたコンテンツを正確に区切ることを目的としています。また、選択した表現の特徴であるエンコーディングからのみ、輸送中に適用されるエンコーディングを区別するのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance. A sender MUST NOT apply the chunked transfer coding more than once to a message body (i.e., chunking an already chunked message is not allowed). If any transfer coding other than chunked is applied to a request&#39;s content, the sender MUST apply chunked as the final transfer coding to ensure that the message is properly framed. If any transfer coding other than chunked is applied to a response&#39;s content, the sender MUST either apply chunked as the final transfer coding or terminate the message by closing the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信者は、コンテンツサイズが事前に不明な場合にメッセージのフレーミングに重要な役割を果たすため、チャンク転送コーディング（セクション7.1）を解析できる必要があります。送信者は、チャンクされた転送コーディングをメッセージ本文に複数回適用してはなりません（つまり、すでにチャンクされたメッセージをチャンキングすることは許可されていません）。チャンク以外の転送コーディングがリクエストのコンテンツに適用される場合、送信者は最終転送コーディングとしてチャンクされている必要があります。チャンク以外の転送コーディングが応答のコンテンツに適用される場合、送信者は最終転送コーディングとしてチャンクを適用するか、接続を閉じてメッセージを終了する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transfer-Encoding: gzip, chunked
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
転送エンコード：GZIP、チャンク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
indicates that the content has been compressed using the gzip coding and then chunked using the chunked coding while forming the message body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GZIPコーディングを使用してコンテンツが圧縮され、メッセージ本文の形成中にチャンクコーディングを使用してチャンクされていることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike Content-Encoding (Section 8.4.1 of [HTTP]), Transfer-Encoding is a property of the message, not of the representation. Any recipient along the request/response chain MAY decode the received transfer coding(s) or apply additional transfer coding(s) to the message body, assuming that corresponding changes are made to the Transfer-Encoding field value. Additional information about the encoding parameters can be provided by other header fields not defined by this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテンツエンコード（[http]のセクション8.4.1）とは異なり、転送エンコードはメッセージのプロパティであり、表現ではありません。要求/応答チェーンに沿った受信者は、受信した転送コーディングをデコードするか、メッセージ本文に追加の転送コーディングを適用する場合があります。エンコードパラメーターに関する追加情報は、この仕様で定義されていない他のヘッダーフィールドによって提供できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transfer-Encoding MAY be sent in a response to a HEAD request or in a 304 (Not Modified) response (Section 15.4.5 of [HTTP]) to a GET request, neither of which includes a message body, to indicate that the origin server would have applied a transfer coding to the message body if the request had been an unconditional GET. This indication is not required, however, because any recipient on the response chain (including the origin server) can remove transfer codings when they are not needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
転送エンコードは、ヘッドリクエストへの応答または304（変更されていない）応答（[http]のセクション15.4.5）で送信される場合があります。リクエストが無条件のGETであった場合、サーバーはメッセージ本文に転送コーディングを適用していました。ただし、応答チェーンの受信者（Origin Serverを含む）の受信者は、不要な場合に転送コードを削除できるため、この表示は必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server MUST NOT send a Transfer-Encoding header field in any response with a status code of 1xx (Informational) or 204 (No Content). A server MUST NOT send a Transfer-Encoding header field in any 2xx (Successful) response to a CONNECT request (Section 9.3.6 of [HTTP]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、1xxまたは204（コンテンツなし）のステータスコードを使用して、任意の応答で転送エンコードヘッダーフィールドを送信してはなりません。サーバーは、接続要求に対する2xx（成功）応答（[http]のセクション9.3.6）で転送エンコードヘッダーフィールドを送信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server that receives a request message with a transfer coding it does not understand SHOULD respond with 501 (Not Implemented).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
わからない転送コーディングでリクエストメッセージを受信するサーバーは、501（実装されていない）で応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transfer-Encoding was added in HTTP/1.1. It is generally assumed that implementations advertising only HTTP/1.0 support will not understand how to process transfer-encoded content, and that an HTTP/1.0 message received with a Transfer-Encoding is likely to have been forwarded without proper handling of the chunked transfer coding in transit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transfer-EncodingはHTTP/1.1に追加されました。一般に、実装広告はHTTP/1.0サポートのみが転送エンコードコンテンツの処理方法を理解していないこと、および転送エンコードで受信したHTTP/1.0メッセージは、チャンク転送コーディングの適切な処理なしに転送された可能性が高いと想定されています。輸送中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client MUST NOT send a request containing Transfer-Encoding unless it knows the server will handle HTTP/1.1 requests (or later minor revisions); such knowledge might be in the form of specific user configuration or by remembering the version of a prior received response. A server MUST NOT send a response containing Transfer-Encoding unless the corresponding request indicates HTTP/1.1 (or later minor revisions).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、サーバーがHTTP/1.1リクエスト（または後のマイナーリビジョン）を処理することがわかっていない限り、転送エンコードを含むリクエストを送信してはなりません。このような知識は、特定のユーザー構成の形であるか、以前に受信した応答のバージョンを覚えている可能性があります。対応する要求がHTTP/1.1（または後のマイナーリビジョン）を示していない限り、サーバーは転送エンコードを含む応答を送信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Early implementations of Transfer-Encoding would occasionally send both a chunked transfer coding for message framing and an estimated Content-Length header field for use by progress bars. This is why Transfer-Encoding is defined as overriding Content-Length, as opposed to them being mutually incompatible. Unfortunately, forwarding such a message can lead to vulnerabilities regarding request smuggling (Section 11.2) or response splitting (Section 11.1) attacks if any downstream recipient fails to parse the message according to this specification, particularly when a downstream recipient only implements HTTP/1.0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
転送エンコードの早期実装により、メッセージフレーミング用のチャンク転送コーディングと、進行状況バーが使用するための推定コンテンツ長ヘッダーフィールドの両方が時々送信されます。これが、転送エンコードが相互に互換性がないのではなく、最優先のコンテンツレングスとして定義される理由です。残念ながら、そのようなメッセージを転送すると、要求の密輸（セクション11.2）または応答分割（セクション11.1）攻撃に関する脆弱性につながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server MAY reject a request that contains both Content-Length and Transfer-Encoding or process such a request in accordance with the Transfer-Encoding alone. Regardless, the server MUST close the connection after responding to such a request to avoid the potential attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、コンテンツレングスと転送エンコードの両方を含むリクエストを拒否するか、転送エンコードのみに従ってそのような要求を処理する場合があります。とにかく、サーバーは、潜在的な攻撃を回避するためにそのような要求に応答した後、接続を閉じる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server or client that receives an HTTP/1.0 message containing a Transfer-Encoding header field MUST treat the message as if the framing is faulty, even if a Content-Length is present, and close the connection after processing the message. The message sender might have retained a portion of the message, in buffer, that could be misinterpreted by further use of the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
転送エンコードヘッダーフィールドを含むHTTP/1.0メッセージを受信するサーバーまたはクライアントは、コンテンツ長が存在していても、フレーミングが故障しているかのようにメッセージを扱う必要があり、メッセージを処理した後に接続を閉じます。メッセージ送信者は、バッファーでメッセージの一部を保持している可能性があります。これは、接続のさらなる使用によって誤って解釈される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2--Content-Length">
6.2. Content-Length
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. コンテンツレングス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a message does not have a Transfer-Encoding header field, a Content-Length header field (Section 8.6 of [HTTP]) can provide the anticipated size, as a decimal number of octets, for potential content. For messages that do include content, the Content-Length field value provides the framing information necessary for determining where the data (and message) ends. For messages that do not include content, the Content-Length indicates the size of the selected representation (Section 8.6 of [HTTP]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージに転送エンコードヘッダーフィールドがない場合、コンテンツレングスヘッダーフィールド（[http]のセクション8.6）は、潜在的なコンテンツに対して、10進数のオクテットとして予想されるサイズを提供できます。コンテンツを含むメッセージの場合、コンテンツレングスのフィールド値は、データ（およびメッセージ）が終了する場所を決定するために必要なフレーミング情報を提供します。コンテンツを含むメッセージの場合、コンテンツ長は選択された表現のサイズを示します（[http]のセクション8.6）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者は、転送エンコードヘッダーフィールドを含むメッセージにコンテンツレングスヘッダーフィールドを送信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      |  *Note:* HTTP&#39;s use of Content-Length for message framing
      |  differs significantly from the same field&#39;s use in MIME, where
      |  it is an optional field used only within the &#34;message/external-
      |  body&#34; media-type.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-3--Message-Body-Length">
6.3. Message Body Length
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. メッセージボディの長さ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The length of a message body is determined by one of the following (in order of precedence):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージ本文の長さは、次のいずれか（優先順位で）によって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Any response to a HEAD request and any response with a 1xx (Informational), 204 (No Content), or 304 (Not Modified) status code is always terminated by the first empty line after the header fields, regardless of the header fields present in the message, and thus cannot contain a message body or trailer section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. ヘッドリクエストへの応答と1xx（情報）、204（コンテンツなし）、または304（変更されていない）ステータスコードを含む応答は、ヘッダーフィールドの後に最初の空の行によって常に終了します。メッセージ、したがってメッセージ本文またはトレーラーセクションを含めることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Any 2xx (Successful) response to a CONNECT request implies that the connection will become a tunnel immediately after the empty line that concludes the header fields. A client MUST ignore any Content-Length or Transfer-Encoding header fields received in such a message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 接続要求に対する2xx（成功）応答は、ヘッダーフィールドを終了する空の行の直後に接続がトンネルになることを意味します。クライアントは、そのようなメッセージで受信したコンテンツレングスまたは転送エンコードヘッダーフィールドを無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If a message is received with both a Transfer-Encoding and a Content-Length header field, the Transfer-Encoding overrides the Content-Length. Such a message might indicate an attempt to perform request smuggling (Section 11.2) or response splitting (Section 11.1) and ought to be handled as an error. An intermediary that chooses to forward the message MUST first remove the received Content-Length field and process the Transfer-Encoding (as described below) prior to forwarding the message downstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 転送エンコードとコンテンツ長ヘッダーフィールドの両方でメッセージが受信された場合、転送エンコードはコンテンツレングスをオーバーライドします。このようなメッセージは、要求の密輸（セクション11.2）または応答分割（セクション11.1）を実行する試みを示している可能性があり、エラーとして処理する必要があります。メッセージを転送することを選択した仲介者は、最初に受信したコンテンツレングスフィールドを削除し、メッセージを下流に転送する前に（以下で説明するように）転送エンコードを処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. If a Transfer-Encoding header field is present and the chunked transfer coding (Section 7.1) is the final encoding, the message body length is determined by reading and decoding the chunked data until the transfer coding indicates the data is complete.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 転送エンコードヘッダーフィールドが存在し、チャンクされた転送コーディング（セクション7.1）が最終エンコーディングである場合、メッセージボディの長さは、転送コーディングがデータが完了することを示すまで、チャンクデータを読み取り、デコードすることによって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
If a Transfer-Encoding header field is present in a response and the chunked transfer coding is not the final encoding, the message body length is determined by reading the connection until it is closed by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
転送エンコードヘッダーフィールドが応答中に存在し、チャンクされた転送コーディングが最終エンコードではない場合、メッセージボディの長さは、サーバーによって閉じられるまで接続を読み取ることによって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
If a Transfer-Encoding header field is present in a request and the chunked transfer coding is not the final encoding, the message body length cannot be determined reliably; the server MUST respond with the 400 (Bad Request) status code and then close the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
転送エンコードヘッダーフィールドがリクエストに存在し、チャンクされた転送コーディングが最終エンコードではない場合、メッセージボディの長さを確実に決定することはできません。サーバーは、400（悪い要求）ステータスコードで応答し、接続を閉じる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. If a message is received without Transfer-Encoding and with an invalid Content-Length header field, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error, unless the field value can be successfully parsed as a comma-separated list (Section 5.6.1 of [HTTP]), all values in the list are valid, and all values in the list are the same (in which case, the message is processed with that single value used as the Content-Length field value). If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection. If it is in a response message received by a proxy, the proxy MUST close the connection to the server, discard the received response, and send a 502 (Bad Gateway) response to the client. If it is in a response message received by a user agent, the user agent MUST close the connection to the server and discard the received response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 転送エンコードなしでメッセージが受信され、コンテンツレングスのヘッダーフィールドが無効になった場合、メッセージフレーミングは無効であり、フィールド値をコンマ分離リストとして正常に解析できる場合を除き、受信者はそれを回復不可能なエラーとして扱う必要があります。（[http]のセクション5.6.1）、リスト内のすべての値は有効であり、リスト内のすべての値は同じです（この場合、メッセージはコンテンツレングスのフィールド値として使用される単一値で処理されます）。回復不可能なエラーがリクエストメッセージにある場合、サーバーは400（悪い要求）ステータスコードで応答し、接続を閉じる必要があります。プロキシによって受信された応答メッセージにある場合、プロキシはサーバーへの接続を閉じ、受信した応答を破棄し、クライアントに502（悪いゲートウェイ）応答を送信する必要があります。ユーザーエージェントが受信した応答メッセージに含まれている場合、ユーザーエージェントはサーバーへの接続を閉じて、受信した応答を破棄する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. If a valid Content-Length header field is present without Transfer-Encoding, its decimal value defines the expected message body length in octets. If the sender closes the connection or the recipient times out before the indicated number of octets are received, the recipient MUST consider the message to be incomplete and close the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. 有効なコンテンツレングスヘッダーフィールドが転送エンコードなしで存在する場合、その小数値はオクテットの予想されるメッセージボディの長さを定義します。指定されたオクテットの数を受信する前に送信者が接続を閉じるか、受信者がタイムアウトした場合、受信者はメッセージが不完全で接続を閉じることを検討する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. If this is a request message and none of the above are true, then the message body length is zero (no message body is present).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. これがリクエストメッセージであり、上記のいずれも真でない場合、メッセージボディの長さはゼロです（メッセージ本文は存在しません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. Otherwise, this is a response message without a declared message body length, so the message body length is determined by the number of octets received prior to the server closing the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. それ以外の場合、これはメッセージボディの長さが宣言されていない応答メッセージであるため、メッセージボディの長さは、サーバーが接続を閉じる前に受信したオクテットの数によって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible. The close-delimiting feature exists primarily for backwards compatibility with HTTP/1.0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワーク障害によって中断された部分的に受信されたメッセージから正常に完了した、密接に決定された応答メッセージを区別する方法がないため、サーバーは可能な限りエンコードまたは長さの削除メッセージを生成する必要があります。HTTP/1.0との逆方向の互換性のために、密接な導入機能は主に存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      |  *Note:* Request messages are never close-delimited because they
      |  are always explicitly framed by length or transfer coding, with
      |  the absence of both implying the request ends immediately after
      |  the header section.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server MAY reject a request that contains a message body but not a Content-Length by responding with 411 (Length Required).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、411（長さが必要）で応答することにより、メッセージ本文を含むがコンテンツ長ではないリクエストを拒否する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless a transfer coding other than chunked has been applied, a client that sends a request containing a message body SHOULD use a valid Content-Length header field if the message body length is known in advance, rather than the chunked transfer coding, since some existing services respond to chunked with a 411 (Length Required) status code even though they understand the chunked transfer coding. This is typically because such services are implemented via a gateway that requires a content length in advance of being called, and the server is unable or unwilling to buffer the entire request before processing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンク以外の転送コーディングが適用されていない限り、メッセージ本文を含むリクエストを送信するクライアントは、既存の一部が既存のためにチャンクされた転送コーディングではなく、メッセージボディの長さが事前に知られている場合は有効なコンテンツ長ヘッダーフィールドを使用する必要がありますサービスは、チャンクされた転送コーディングを理解していても、411（長さが必要）ステータスコードでチャンキングに応答します。これは通常、そのようなサービスが、呼び出される前にコンテンツの長さを必要とするゲートウェイを介して実装されており、サーバーが処理前にリクエスト全体をバッファリングすることができないか、または不本意なためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A user agent that sends a request that contains a message body MUST send either a valid Content-Length header field or use the chunked transfer coding. A client MUST NOT use the chunked transfer coding unless it knows the server will handle HTTP/1.1 (or later) requests; such knowledge can be in the form of specific user configuration or by remembering the version of a prior received response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージ本文を含むリクエストを送信するユーザーエージェントは、有効なコンテンツレングスヘッダーフィールドを送信するか、チャンク転送コーディングを使用する必要があります。クライアントは、サーバーがHTTP/1.1（またはそれ以降）リクエストを処理することを知っていない限り、チャンク転送コーディングを使用してはなりません。このような知識は、特定のユーザー構成の形で、または以前に受信した応答のバージョンを覚えている可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the final response to the last request on a connection has been completely received and there remains additional data to read, a user agent MAY discard the remaining data or attempt to determine if that data belongs as part of the prior message body, which might be the case if the prior message&#39;s Content-Length value is incorrect. A client MUST NOT process, cache, or forward such extra data as a separate response, since such behavior would be vulnerable to cache poisoning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続の最後のリクエストに対する最終的な応答が完全に受信され、読み取る追加データが残っている場合、ユーザーエージェントは残りのデータを破棄するか、そのデータが以前のメッセージ本文の一部として属するかどうかを判断しようとすることができます。事前のメッセージのコンテンツレングス値が正しくない場合。クライアントは、そのような動作が中毒をキャッシュすることに対して脆弱であるため、そのような追加データを個別の応答として処理、キャッシュ、または転送してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Transfer-Codings">
7. Transfer Codings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. コーディングを転送します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transfer coding names are used to indicate an encoding transformation that has been, can be, or might need to be applied to a message&#39;s content in order to ensure &#34;safe transport&#34; through the network. This differs from a content coding in that the transfer coding is a property of the message rather than a property of the representation that is being transferred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
転送コーディング名は、ネットワークを介した「安全な輸送」を確保するために、メッセージのコンテンツに適用される、または適用する必要がある、または必要なエンコード変換を示すために使用されます。これは、転送コーディングが転送されている表現のプロパティではなく、メッセージのプロパティであるという点で、コンテンツコーディングとは異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All transfer-coding names are case-insensitive and ought to be registered within the HTTP Transfer Coding registry, as defined in Section 7.3. They are used in the Transfer-Encoding (Section 6.1) and TE (Section 10.1.4 of [HTTP]) header fields (the latter also defining the &#34;transfer-coding&#34; grammar).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての転送コーディング名はケース非感受性であり、セクション7.3で定義されているように、HTTP転送コーディングレジストリ内に登録する必要があります。それらは、転送エンコード（セクション6.1）およびTE（[HTTP]のセクション10.1.4）ヘッダーフィールド（後者も「転送コーディング」文法も定義する）で使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-1--Chunked-Transfer-Coding">
7.1. Chunked Transfer Coding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. チャンク転送コーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The chunked transfer coding wraps content in order to transfer it as a series of chunks, each with its own size indicator, followed by an OPTIONAL trailer section containing trailer fields. Chunked enables content streams of unknown size to be transferred as a sequence of length-delimited buffers, which enables the sender to retain connection persistence and the recipient to know when it has received the entire message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンクされた転送コーディングは、コンテンツをラップして、それぞれが独自のサイズインジケーターを備えた一連のチャンクとして転送し、その後、トレーラーフィールドを含むオプションのトレーラーセクションが続きます。Chunkedにより、未知のサイズのコンテンツストリームを一連の長さの識別バッファーとして転送できます。これにより、送信者は接続の持続性を保持し、受信者はメッセージ全体をいつ受け取ったかを知ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     chunked-body   = *chunk
                      last-chunk
                      trailer-section
                      CRLF
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
chunk = chunk-size [ chunk-ext ] CRLF chunk-data CRLF chunk-size = 1*HEXDIG last-chunk = 1*(&#34;0&#34;) [ chunk-ext ] CRLF
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
chunk = chunk-size [chunk-ext] crlf chunk-data crlf chunk-size = 1*hexdig last-chunk = 1*（ &#34;0&#34;）[chunk-ext] crlf
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     chunk-data     = 1*OCTET ; a sequence of chunk-size octets
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The chunk-size field is a string of hex digits indicating the size of the chunk-data in octets. The chunked transfer coding is complete when a chunk with a chunk-size of zero is received, possibly followed by a trailer section, and finally terminated by an empty line.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンクサイズのフィールドは、オクテットのチャンクデータのサイズを示す一連の16進数です。チャンクされた転送コーディングは、ゼロのチャンクサイズのチャンクが受信され、おそらくトレーラーセクションが続き、最終的に空のラインで終了すると完了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A recipient MUST be able to parse and decode the chunked transfer coding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信者は、チャンク転送コーディングを解析およびデコードできる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.1 does not define any means to limit the size of a chunked response such that an intermediary can be assured of buffering the entire response. Additionally, very large chunk sizes may cause overflows or loss of precision if their values are not represented accurately in a receiving implementation. Therefore, recipients MUST anticipate potentially large hexadecimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer representation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.1は、充電された応答のサイズを制限する手段を定義しません。これにより、中間者が応答全体をバッファリングすることを保証できます。さらに、非常に大きなチャンクサイズは、受信の実装で値が正確に表されない場合、オーバーフローまたは精度の損失を引き起こす可能性があります。したがって、受信者は、潜在的に大きな16進数を予測し、整数変換のオーバーフローまたは整数表現による精度の損失による解析エラーを防ぐ必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The chunked coding does not define any parameters. Their presence SHOULD be treated as an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンクされたコーディングは、パラメーターを定義しません。それらの存在はエラーとして扱われるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-1-1--Chunk-Extensions">
7.1.1. Chunk Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.1. チャンクエクステンション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The chunked coding allows each chunk to include zero or more chunk extensions, immediately following the chunk-size, for the sake of supplying per-chunk metadata (such as a signature or hash), mid-message control information, or randomization of message body size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンクされたコーディングにより、各チャンクは、チャンクサイズの直後に、チャンクごとのメタデータ（署名やハッシュなど）、メッセージ本文のランダム化を供給するために、ゼロ以上のチャンク拡張機能を含めることができます。サイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     chunk-ext      = *( BWS &#34;;&#34; BWS chunk-ext-name
                         [ BWS &#34;=&#34; BWS chunk-ext-val ] )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
chunk-ext-name = token chunk-ext-val = token / quoted-string
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Chunk-ext-name = token chunk-ext-val = token / quoted-string
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The chunked coding is specific to each connection and is likely to be removed or recoded by each recipient (including intermediaries) before any higher-level application would have a chance to inspect the extensions. Hence, the use of chunk extensions is generally limited to specialized HTTP services such as &#34;long polling&#34; (where client and server can have shared expectations regarding the use of chunk extensions) or for padding within an end-to-end secured connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンクされたコーディングは各接続に固有のものであり、高レベルのアプリケーションが拡張を検査する機会がある前に、各受信者（仲介者を含む）によって削除または再確認される可能性があります。したがって、チャンクエクステンションの使用は、一般に、「長いポーリング」（クライアントとサーバーがチャンク拡張機能の使用に関して期待を共有できる）などの特殊なHTTPサービスまたはエンドツーエンドの保護された接続内のパディングに限定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A recipient MUST ignore unrecognized chunk extensions. A server ought to limit the total length of chunk extensions received in a request to an amount reasonable for the services provided, in the same way that it applies length limitations and timeouts for other parts of a message, and generate an appropriate 4xx (Client Error) response if that amount is exceeded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信者は、認識されていないチャンク拡張機能を無視する必要があります。サーバーは、メッセージの他の部分に長さの制限とタイムアウトを適用し、適切な4XX（クライアントエラーを生成するのと同じように、提供されるサービスの合理的な金額にリクエストで受信されたチャンク拡張機能の総長を制限する必要があります（クライアントエラー）その量を超えた場合の応答。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-1-2--Chunked-Trailer-Section">
7.1.2. Chunked Trailer Section
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.2. チャンクされたトレーラーセクション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A trailer section allows the sender to include additional fields at the end of a chunked message in order to supply metadata that might be dynamically generated while the content is sent, such as a message integrity check, digital signature, or post-processing status. The proper use and limitations of trailer fields are defined in Section 6.5 of [HTTP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トレーラーセクションを使用すると、送信者は、メッセージの整合性チェック、デジタル署名、ポスト処理ステータスなど、コンテンツの送信中に動的に生成されるメタデータを提供するために、チャンクメッセージの最後に追加のフィールドを含めることができます。トレーラーフィールドの適切な使用と制限は、[HTTP]のセクション6.5で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     trailer-section   = *( field-line CRLF )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A recipient that removes the chunked coding from a message MAY selectively retain or discard the received trailer fields. A recipient that retains a received trailer field MUST either store/ forward the trailer field separately from the received header fields or merge the received trailer field into the header section. A recipient MUST NOT merge a received trailer field into the header section unless its corresponding header field definition explicitly permits and instructs how the trailer field value can be safely merged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージからチャンクされたコーディングを削除する受信者は、受信したトレーラーフィールドを選択的に保持または破棄することができます。受信したトレーラーフィールドを保持する受信者は、トレーラーフィールドを受け取ったヘッダーフィールドとは別に保存/転送するか、受信したトレーラーフィールドをヘッダーセクションにマージする必要があります。受信者は、対応するヘッダーフィールドの定義が明示的に許可され、トレーラーフィールド値を安全に統合する方法を指示しない限り、受信したトレーラーフィールドをヘッダーセクションにマージしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-1-3--Decoding-Chunked">
7.1.3. Decoding Chunked
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.3. ダンクのデコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A process for decoding the chunked transfer coding can be represented in pseudo-code as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンクされた転送コーディングをデコードするプロセスは、擬似コードで表すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     length := 0
     read chunk-size, chunk-ext (if any), and CRLF
     while (chunk-size &gt; 0) {
        read chunk-data and CRLF
        append chunk-data to content
        length := length + chunk-size
        read chunk-size, chunk-ext (if any), and CRLF
     }
     read trailer field
     while (trailer field is not empty) {
        if (trailer fields are stored/forwarded separately) {
            append trailer field to existing trailer fields
        }
        else if (trailer field is understood and defined as mergeable) {
            merge trailer field with existing header fields
        }
        else {
            discard trailer field
        }
        read trailer field
     }
     Content-Length := length
     Remove &#34;chunked&#34; from Transfer-Encoding
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-2--Transfer-Codings-for-Compression">
7.2. Transfer Codings for Compression
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. 圧縮のためにコーディングを転送します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following transfer coding names for compression are defined by the same algorithm as their corresponding content coding:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮の次の転送コーディング名は、対応するコンテンツコーディングと同じアルゴリズムによって定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
compress (and x-compress) See Section 8.4.1.1 of [HTTP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTTP]のセクション8.4.1.1を参照してください（およびX-Compress）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
deflate See Section 8.4.1.2 of [HTTP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デフレート[HTTP]のセクション8.4.1.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
gzip (and x-gzip) See Section 8.4.1.3 of [HTTP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GZIP（およびX-GZIP）[HTTP]のセクション8.4.1.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The compression codings do not define any parameters. The presence of parameters with any of these compression codings SHOULD be treated as an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮コーディングは、パラメーターを定義しません。これらの圧縮コーディングのいずれかを使用したパラメーターの存在は、エラーとして扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-3--Transfer-Coding-Registry">
7.3. Transfer Coding Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. コーディングレジストリを転送します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;HTTP Transfer Coding Registry&#34; defines the namespace for transfer coding names. It is maintained at &lt;https://www.iana.org/assignments/http-parameters&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「HTTP転送コーディングレジストリ」は、転送コーディング名の名前空間を定義します。&lt;https://www.iana.org/assignments/http-parameters&gt;に維持されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Registrations MUST include the following fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
登録には、次のフィールドを含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Name
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 名前
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Description
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Pointer to specification text
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 仕様テキストへのポインタ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Names of transfer codings MUST NOT overlap with names of content codings (Section 8.4.1 of [HTTP]) unless the encoding transformation is identical, as is the case for the compression codings defined in Section 7.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
転送コーディングの名前は、セクション7.2で定義されている圧縮コーディングの場合のように、エンコード変換が同一でない限り、コンテンツコーディングの名前（[http]のセクション8.4.1）と重複してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TE header field (Section 10.1.4 of [HTTP]) uses a pseudo-parameter named &#34;q&#34; as the rank value when multiple transfer codings are acceptable. Future registrations of transfer codings SHOULD NOT define parameters called &#34;q&#34; (case-insensitively) in order to avoid ambiguities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TEヘッダーフィールド（[HTTP]のセクション10.1.4）は、複数の転送コードが許容される場合、「Q」という名前の擬似パラメーターをランク値として使用します。曖昧さを避けるために、転送コーディングの将来の登録は、「Q」（ケースインテンシテーブ）と呼ばれるパラメーターを定義してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Values to be added to this namespace require IETF Review (see Section 4.8 of [RFC8126]) and MUST conform to the purpose of transfer coding defined in this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この名前空間に追加する値は、IETFレビューが必要であり（[RFC8126]のセクション4.8を参照）、この仕様で定義された転送コーディングの目的に準拠する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of program names for the identification of encoding formats is not desirable and is discouraged for future encodings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコード形式の識別にプログラム名を使用することは望ましくなく、将来のエンコーディングには阻止されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-4--Negotiating-Transfer-Codings">
7.4. Negotiating Transfer Codings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. 転送コードの交渉
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TE field (Section 10.1.4 of [HTTP]) is used in HTTP/1.1 to indicate what transfer codings, besides chunked, the client is willing to accept in the response and whether the client is willing to preserve trailer fields in a chunked transfer coding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TEフィールド（[HTTP]のセクション10.1.4）はHTTP/1.1で使用され、どの転送コーディングを示すかを示します。コーディングを転送します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client MUST NOT send the chunked transfer coding name in TE; chunked is always acceptable for HTTP/1.1 recipients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、TEでチャンクされた転送コーディング名を送信してはなりません。チャンクは、HTTP/1.1レシピエントで常に受け入れられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Three examples of TE use are below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
米国の3つの例を以下に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   TE: deflate
   TE:
   TE: trailers, deflate;q=0.5
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When multiple transfer codings are acceptable, the client MAY rank the codings by preference using a case-insensitive &#34;q&#34; parameter (similar to the qvalues used in content negotiation fields; see Section 12.4.2 of [HTTP]). The rank value is a real number in the range 0 through 1, where 0.001 is the least preferred and 1 is the most preferred; a value of 0 means &#34;not acceptable&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数の転送コードが許容される場合、クライアントは、ケースに依存しない「Q」パラメーターを使用して好みによってコーディングをランク付けできます（コンテンツネゴシエーションフィールドで使用されるQ値と同様です。[HTTP]のセクション12.4.2を参照）。ランク値は0〜1の範囲の実数です。0.001は最も好ましくなく、1が最も優先されます。0の値は「受け入れられない」を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the TE field value is empty or if no TE field is present, the only acceptable transfer coding is chunked. A message with no transfer coding is always acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TEフィールド値が空の場合、またはTEフィールドが存在しない場合、唯一の許容可能な転送コーディングがチャンキングされます。転送コーディングのないメッセージは常に受け入れられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The keyword &#34;trailers&#34; indicates that the sender will not discard trailer fields, as described in Section 6.5 of [HTTP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーワード「トレーラー」は、[HTTP]のセクション6.5で説明されているように、送信者がトレーラーフィールドを破棄しないことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the TE header field only applies to the immediate connection, a sender of TE MUST also send a &#34;TE&#34; connection option within the Connection header field (Section 7.6.1 of [HTTP]) in order to prevent the TE header field from being forwarded by intermediaries that do not support its semantics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TEヘッダーフィールドは即時接続にのみ適用されるため、TEの送信者は、TEヘッダーフィールドが存在するのを防ぐために、接続ヘッダーフィールド内に「TE」接続オプション（[HTTP]のセクション7.6.1）を送信する必要があります。そのセマンティクスをサポートしていない仲介者によって転送されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--Handling-Incomplete-Messages">
8. Handling Incomplete Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 不完全なメッセージの処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、キャンセルされた要求またはトリガーされたタイムアウトの例外により、不完全な要求メッセージを受信するサーバーは、接続を閉じる前にエラー応答を送信する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client that receives an incomplete response message, which can occur when a connection is closed prematurely or when decoding a supposedly chunked transfer coding fails, MUST record the message as incomplete. Cache requirements for incomplete responses are defined in Section 3.3 of [CACHING].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続が時期尚早に閉じられている場合、または刻んだ転送コーディングのデコードが失敗したときに発生する可能性のある不完全な応答メッセージを受信するクライアントは、メッセージを不完全として記録する必要があります。不完全な応答のキャッシュ要件は、[キャッシュ]のセクション3.3で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a response terminates in the middle of the header section (before the empty line is received) and the status code might rely on header fields to convey the full meaning of the response, then the client cannot assume that meaning has been conveyed; the client might need to repeat the request in order to determine what action to take next.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーセクションの中央で応答が終了し（空の行が受信される前に）、ステータスコードがヘッダーフィールドに依存して応答の完全な意味を伝える場合、クライアントは意味が伝えられていると仮定できません。クライアントは、次に実行するアクションを決定するためにリクエストを繰り返す必要がある場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A message body that uses the chunked transfer coding is incomplete if the zero-sized chunk that terminates the encoding has not been received. A message that uses a valid Content-Length is incomplete if the size of the message body received (in octets) is less than the value given by Content-Length. A response that has neither chunked transfer coding nor Content-Length is terminated by closure of the connection and, if the header section was received intact, is considered complete unless an error was indicated by the underlying connection (e.g., an &#34;incomplete close&#34; in TLS would leave the response incomplete, as described in Section 9.8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコードを終了するゼロサイズのチャンクが受信されていない場合、チャンク転送コーディングを使用するメッセージ本文は不完全です。有効なコンテンツレングスを使用するメッセージは、（オクテットで）受信したメッセージ本文のサイズがコンテンツレングスで与えられる値よりも少ない場合、不完全です。接続された転送コーディングもコンテンツ長もない応答は、接続の閉鎖によって終了し、ヘッダーセクションがそのまま受信された場合、基礎となる接続によってエラーが示されない限り完全とみなされます（例えば、「不完全な閉じる」TLSは、セクション9.8で説明されているように、応答を不完全なままにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--Connection-Management">
9. Connection Management
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 接続管理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP messaging is independent of the underlying transport- or session-layer connection protocol(s). HTTP only presumes a reliable transport with in-order delivery of requests and the corresponding in-order delivery of responses. The mapping of HTTP request and response structures onto the data units of an underlying transport protocol is outside the scope of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPメッセージングは、基礎となる輸送またはセッション層接続プロトコルとは無関係です。HTTPは、リクエストの順序配信と対応する応答の配信を伴う信頼できる輸送のみを推定します。基礎となる輸送プロトコルのデータ単位へのHTTP要求と応答構造のマッピングは、この仕様の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in Section 7.3 of [HTTP], the specific connection protocols to be used for an HTTP interaction are determined by client configuration and the target URI. For example, the &#34;http&#34; URI scheme (Section 4.2.1 of [HTTP]) indicates a default connection of TCP over IP, with a default TCP port of 80, but the client might be configured to use a proxy via some other connection, port, or protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTTP]のセクション7.3で説明したように、HTTP相互作用に使用される特定の接続プロトコルは、クライアント構成とターゲットURIによって決定されます。たとえば、「HTTP」URIスキーム（[HTTP]のセクション4.2.1）は、デフォルトのTCPポートが80のTCPのデフォルト接続を示しますが、クライアントは他の接続を介してプロキシを使用するように構成されている場合があります。、ポート、またはプロトコル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP implementations are expected to engage in connection management, which includes maintaining the state of current connections, establishing a new connection or reusing an existing connection, processing messages received on a connection, detecting connection failures, and closing each connection. Most clients maintain multiple connections in parallel, including more than one connection per server endpoint. Most servers are designed to maintain thousands of concurrent connections, while controlling request queues to enable fair use and detect denial-of-service attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP実装は、現在の接続の状態の維持、新しい接続の確立、既存の接続の確立、接続で受信したメッセージの処理、接続障害の検出、各接続の閉鎖など、接続管理に関与することが期待されています。ほとんどのクライアントは、サーバーエンドポイントごとに複数の接続を含む、複数の接続を並行して維持しています。ほとんどのサーバーは、数千の同時接続を維持するように設計されていますが、リクエストキューを制御して公正使用を可能にし、サービス拒否攻撃を検出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-1--Establishment">
9.1. Establishment
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. 確率
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is beyond the scope of this specification to describe how connections are established via various transport- or session-layer protocols. Each HTTP connection maps to one underlying transport connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さまざまな輸送またはセッション層プロトコルを介して接続がどのように確立されるかを説明するのは、この仕様の範囲を超えています。各HTTP接続は、1つの基礎となる輸送接続にマップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2--Associating-a-Response-to-a-Request">
9.2. Associating a Response to a Request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. リクエストへの応答を関連付けます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.1 does not include a request identifier for associating a given request message with its corresponding one or more response messages. Hence, it relies on the order of response arrival to correspond exactly to the order in which requests are made on the same connection. More than one response message per request only occurs when one or more informational responses (1xx; see Section 15.2 of [HTTP]) precede a final response to the same request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.1には、特定の要求メッセージを対応する1つ以上の応答メッセージに関連付けるための要求識別子は含まれていません。したがって、同じ接続でリクエストが行われる順序に正確に対応するために、応答の到着の順序に依存しています。要求ごとに複数の応答メッセージは、1つ以上の情報応答（1xx; [http]のセクション15.2を参照）が同じリクエストに対する最終的な応答の前に発生した場合にのみ発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client that has more than one outstanding request on a connection MUST maintain a list of outstanding requests in the order sent and MUST associate each received response message on that connection to the first outstanding request that has not yet received a final (non-1xx) response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続に複数の未解決のリクエストを持っているクライアントは、送信された注文の未解決のリクエストのリストを維持する必要があり、最終（非1xx）を受け取っていない最初の未解決のリクエストにその接続に関する各受信応答メッセージを関連付ける必要があります。応答。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client receives data on a connection that doesn&#39;t have outstanding requests, the client MUST NOT consider that data to be a valid response; the client SHOULD close the connection, since message delimitation is now ambiguous, unless the data consists only of one or more CRLF (which can be discarded per Section 2.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが未解決のリクエストを持たない接続に関するデータを受信した場合、クライアントはそのデータを有効な応答と見なしてはなりません。データが1つ以上のCRLFのみで構成されていない限り、メッセージの区切りが曖昧になるため、クライアントは接続を閉じる必要があります（セクション2.2に従って破棄できます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3--Persistence">
9.3. Persistence
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. 持続性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.1 defaults to the use of &#34;persistent connections&#34;, allowing multiple requests and responses to be carried over a single connection. HTTP implementations SHOULD support persistent connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.1は、「永続的な接続」の使用にデフォルトであり、複数のリクエストと応答を単一の接続に渡すことができます。HTTP実装は、永続的な接続をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A recipient determines whether a connection is persistent or not based on the protocol version and Connection header field (Section 7.6.1 of [HTTP]) in the most recently received message, if any:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信者は、最近受信したメッセージのプロトコルバージョンと接続ヘッダーフィールド（[http]のセクション7.6.1）に基づいて、接続が永続的かどうかを決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* If the &#34;close&#34; connection option is present (Section 9.6), the connection will not persist after the current response; else,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 「閉じる」接続オプションが存在する場合（セクション9.6）、現在の応答の後に接続が続きません。そうしないと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* If the received protocol is HTTP/1.1 (or later), the connection will persist after the current response; else,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 受信したプロトコルがHTTP/1.1（またはそれ以降）の場合、現在の応答の後に接続が持続します。そうしないと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* If the received protocol is HTTP/1.0, the &#34;keep-alive&#34; connection option is present, either the recipient is not a proxy or the message is a response, and the recipient wishes to honor the HTTP/1.0 &#34;keep-alive&#34; mechanism, the connection will persist after the current response; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 受信したプロトコルがHTTP/1.0の場合、「キープアライブ」接続オプションが存在する場合、受信者はプロキシではないか、メッセージが応答であり、受信者はHTTP/1.0 &#34;Keep-Alive&#34;メカニズムを尊重したいと考えています。、接続は現在の応答の後に続きます。それ以外は、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The connection will close after the current response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 現在の応答の後、接続は閉じられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client that does not support persistent connections MUST send the &#34;close&#34; connection option in every request message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
永続的な接続をサポートしていないクライアントは、すべてのリクエストメッセージに「閉じる」接続オプションを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server that does not support persistent connections MUST send the &#34;close&#34; connection option in every response message that does not have a 1xx (Informational) status code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
永続的な接続をサポートしないサーバーは、1xx（情報）ステータスコードがないすべての応答メッセージに「閉じる」接続オプションを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client MAY send additional requests on a persistent connection until it sends or receives a &#34;close&#34; connection option or receives an HTTP/1.0 response without a &#34;keep-alive&#34; connection option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、「閉じる」接続オプションを送信または受信するか、「キープアライブ」接続オプションなしでHTTP/1.0応答を受信するまで、永続的な接続に追加のリクエストを送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to remain persistent, all messages on a connection need to have a self-defined message length (i.e., one not defined by closure of the connection), as described in Section 6. A server MUST read the entire request message body or close the connection after sending its response; otherwise, the remaining data on a persistent connection would be misinterpreted as the next request. Likewise, a client MUST read the entire response message body if it intends to reuse the same connection for a subsequent request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション6で説明されているように、接続に関するすべてのメッセージが自己定義のメッセージ長（つまり、接続の閉鎖によって定義されていないもの）がある必要があります。応答を送信した後の接続。それ以外の場合、永続的な接続に関する残りのデータは、次のリクエストとして誤解されます。同様に、クライアントは、後続のリクエストのために同じ接続を再利用する予定の場合、応答メッセージ本体全体を読み取る必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A proxy server MUST NOT maintain a persistent connection with an HTTP/1.0 client (see Appendix C.2.2 for information and discussion of the problems with the Keep-Alive header field implemented by many HTTP/1.0 clients).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロキシサーバーは、HTTP/1.0クライアントとの永続的な接続を維持してはなりません（多くのHTTP/1.0クライアントによって実装されたKEEP-ALIVEヘッダーフィールドの問題の情報と議論については、付録C.2.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Appendix C.2.2 for more information on backwards compatibility with HTTP/1.0 clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.0クライアントとの後方互換性の詳細については、付録C.2.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3-1--Retrying-Requests">
9.3.1. Retrying Requests
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.1. リクエストの再試行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Connections can be closed at any time, with or without intention. Implementations ought to anticipate the need to recover from asynchronous close events. The conditions under which a client can automatically retry a sequence of outstanding requests are defined in Section 9.2.2 of [HTTP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続は、意図の有無にかかわらず、いつでも閉じることができます。実装は、非同期の緊密なイベントから回復する必要性を予測する必要があります。クライアントが一連の未解決の要求を自動的に再試行できる条件は、[HTTP]のセクション9.2.2で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3-2--Pipelining">
9.3.2. Pipelining
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.2. パイプライン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client that supports persistent connections MAY &#34;pipeline&#34; its requests (i.e., send multiple requests without waiting for each response). A server MAY process a sequence of pipelined requests in parallel if they all have safe methods (Section 9.2.1 of [HTTP]), but it MUST send the corresponding responses in the same order that the requests were received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
永続的な接続をサポートするクライアントは、リクエストを「パイプライン」する場合があります（つまり、各応答を待つことなく複数のリクエストを送信します）。サーバーは、すべて安全な方法（[http]のセクション9.2.1）がある場合、すべてのパイプラインリクエストを並行して処理できますが、リクエストが受信されたのと同じ順序で対応する応答を送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client that pipelines requests SHOULD retry unanswered requests if the connection closes before it receives all of the corresponding responses. When retrying pipelined requests after a failed connection (a connection not explicitly closed by the server in its last complete response), a client MUST NOT pipeline immediately after connection establishment, since the first remaining request in the prior pipeline might have caused an error response that can be lost again if multiple requests are sent on a prematurely closed connection (see the TCP reset problem described in Section 9.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パイプラインが要求するクライアントは、対応するすべての応答を受信する前に接続が閉じる場合、未回答の要求を再試行する必要があります。接続に失敗した後にパイプラインリクエストを再試行する場合（最後の完全な応答でサーバーによって接続が明示的に閉じられていない）、クライアントは、以前のパイプラインの最初の残りの要求がエラー応答を引き起こした可能性があるため、接続確立の直後にパイプラインをしてはなりません。早期に閉じた接続で複数のリクエストが送信されると、再び失われる可能性があります（セクション9.6で説明されているTCPリセット問題を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Idempotent methods (Section 9.2.2 of [HTTP]) are significant to pipelining because they can be automatically retried after a connection failure. A user agent SHOULD NOT pipeline requests after a non-idempotent method, until the final response status code for that method has been received, unless the user agent has a means to detect and recover from partial failure conditions involving the pipelined sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
iDempotentメソッド（[http]のセクション9.2.2）は、接続の障害後に自動的に再試行できるため、パイプラインに重要です。ユーザーエージェントが、パイプ化されたシーケンスを含む部分的な障害条件を検出および回復する手段を持っている場合を除き、その方法の最終的な応答ステータスコードが受信されるまで、非公開法の後にパイプライン要求を要求してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An intermediary that receives pipelined requests MAY pipeline those requests when forwarding them inbound, since it can rely on the outbound user agent(s) to determine what requests can be safely pipelined. If the inbound connection fails before receiving a response, the pipelining intermediary MAY attempt to retry a sequence of requests that have yet to receive a response if the requests all have idempotent methods; otherwise, the pipelining intermediary SHOULD forward any received responses and then close the corresponding outbound connection(s) so that the outbound user agent(s) can recover accordingly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パイプラインのリクエストを受信する仲介者は、アウトバウンドユーザーエージェントに依存して安全にパイプラインできるリクエストを決定できるため、インバウンドを転送するときにそれらのリクエストをパイプラインする場合があります。応答を受信する前にインバウンド接続が失敗した場合、パイプライン中間の仲介者は、リクエストがすべて等量のメソッドを持っている場合、応答をまだ受け取っていない一連の要求を再試行しようとする場合があります。それ以外の場合、パイプラインの仲介者は、受信した応答を転送し、対応するアウトバウンド接続を閉じて、それに応じてアウトバウンドユーザーエージェントが回復できるようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-4--Concurrency">
9.4. Concurrency
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4. 並行性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client ought to limit the number of simultaneous open connections that it maintains to a given server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、特定のサーバーに維持する同時のオープン接続の数を制限する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Previous revisions of HTTP gave a specific number of connections as a ceiling, but this was found to be impractical for many applications. As a result, this specification does not mandate a particular maximum number of connections but, instead, encourages clients to be conservative when opening multiple connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPの以前の改訂により、特定の数の接続が天井として与えられましたが、これは多くのアプリケーションでは非現実的であることがわかりました。その結果、この仕様では、特定の最大数の接続数を義務付けているわけではありませんが、代わりに、複数の接続を開くときにクライアントが保守的であることを奨励します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multiple connections are typically used to avoid the &#34;head-of-line blocking&#34; problem, wherein a request that takes significant server-side processing and/or transfers very large content would block subsequent requests on the same connection. However, each connection consumes server resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、複数の接続が使用され、「ヘッドオブラインブロッキング」問題を回避するために使用されます。これにより、サーバー側の大幅な処理や非常に大きなコンテンツを転送するリクエストが、同じ接続の後続のリクエストをブロックします。ただし、各接続はサーバーリソースを消費します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Furthermore, using multiple connections can cause undesirable side effects in congested networks. Using larger numbers of connections can also cause side effects in otherwise uncongested networks, because their aggregate and initially synchronized sending behavior can cause congestion that would not have been present if fewer parallel connections had been used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、複数の接続を使用すると、混雑したネットワークで望ましくない副作用が発生する可能性があります。また、より多くの接続を使用すると、それ以外の場合は拡張されていないネットワークに副作用を引き起こす可能性があります。なぜなら、それらの総合的に同期した送信動作は、並列接続が少ない場合は存在しなかった混雑を引き起こす可能性があるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that a server might reject traffic that it deems abusive or characteristic of a denial-of-service attack, such as an excessive number of open connections from a single client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、単一のクライアントからの過剰な数のオープン接続など、サービス拒否攻撃の虐待的または特性と見なされるトラフィックを拒否する可能性があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-5--Failures-and-Timeouts">
9.5. Failures and Timeouts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5. 障害とタイムアウト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers will usually have some timeout value beyond which they will no longer maintain an inactive connection. Proxy servers might make this a higher value since it is likely that the client will be making more connections through the same proxy server. The use of persistent connections places no requirements on the length (or existence) of this timeout for either the client or the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは通常、それを超えて非アクティブな接続を維持しなくなるタイムアウト値があります。プロキシサーバーは、クライアントが同じプロキシサーバーを介してより多くの接続を行う可能性が高いため、これをより高い値にする可能性があります。永続的な接続を使用すると、クライアントまたはサーバーのいずれかのこのタイムアウトの長さ（または存在）に要件がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client or server that wishes to time out SHOULD issue a graceful close on the connection. Implementations SHOULD constantly monitor open connections for a received closure signal and respond to it as appropriate, since prompt closure of both sides of a connection enables allocated system resources to be reclaimed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイムアウトを希望するクライアントまたはサーバーは、接続に優雅なクローズを発行する必要があります。接続の両側の迅速な閉鎖により、割り当てられたシステムリソースを再生することができるため、実装は閉鎖信号のオープン接続を常に監視し、必要に応じて応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client, server, or proxy MAY close the transport connection at any time. For example, a client might have started to send a new request at the same time that the server has decided to close the &#34;idle&#34; connection. From the server&#39;s point of view, the connection is being closed while it was idle, but from the client&#39;s point of view, a request is in progress.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント、サーバー、またはプロキシは、いつでもトランスポート接続を閉じることができます。たとえば、クライアントは、サーバーが「アイドル」接続を閉じることを決定したと同時に、新しいリクエストを送信し始めた可能性があります。サーバーの観点から見ると、接続はアイドル状態で閉じられていますが、クライアントの観点からは、リクエストが進行中です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server SHOULD sustain persistent connections, when possible, and allow the underlying transport&#39;s flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry. The latter technique can exacerbate network congestion or server load.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、可能であれば、永続的な接続を維持し、基礎となるトランスポートのフロー制御メカニズムを許可して、クライアントが再試行することを期待して接続を終了するのではなく、一時的な過負荷を解決します。後者の手法は、ネットワークの混雑またはサーバーの負荷を悪化させる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client sending a message body SHOULD monitor the network connection for an error response while it is transmitting the request. If the client sees a response that indicates the server does not wish to receive the message body and is closing the connection, the client SHOULD immediately cease transmitting the body and close its side of the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージ本文を送信するクライアントは、リクエストを送信している間にネットワーク接続を監視する必要があります。クライアントが、サーバーがメッセージ本文を受信したくないことを示す応答を確認し、接続を閉じている場合、クライアントはすぐにボディの送信を停止し、接続の側面を閉じる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-6--Tear-down">
9.6. Tear-down
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6. 取り壊す
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;close&#34; connection option is defined as a signal that the sender will close this connection after completion of the response. A sender SHOULD send a Connection header field (Section 7.6.1 of [HTTP]) containing the &#34;close&#34; connection option when it intends to close a connection. For example,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「閉じる」接続オプションは、応答の完了後に送信者がこの接続を閉じるという信号として定義されます。送信者は、接続を閉じる予定の場合に「閉じる」接続オプションを含む接続ヘッダーフィールド（[http]のセクション7.6.1）を送信する必要があります。例えば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Connection: close
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続：閉じます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
as a request header field indicates that this is the last request that the client will send on this connection, while in a response, the same field indicates that the server is going to close this connection after the response message is complete.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストヘッダーフィールドは、これがクライアントがこの接続で送信する最後のリクエストであることを示していますが、応答では、同じフィールドは、応答メッセージが完了した後にサーバーがこの接続を閉じることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the field name &#34;Close&#34; is reserved, since using that name as a header field might conflict with the &#34;close&#34; connection option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その名前をヘッダーフィールドとして使用すると、「クローズ」接続オプションと競合する可能性があるため、フィールド名「close」は予約されていることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client that sends a &#34;close&#34; connection option MUST NOT send further requests on that connection (after the one containing the &#34;close&#34;) and MUST close the connection after reading the final response message corresponding to this request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「閉じる」接続オプションを送信するクライアントは、その接続にさらに要求を送信してはなりません（「閉じる」を含む後）は、この要求に対応する最終応答メッセージを読んだ後に接続を閉じる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server that receives a &#34;close&#34; connection option MUST initiate closure of the connection (see below) after it sends the final response to the request that contained the &#34;close&#34; connection option. The server SHOULD send a &#34;close&#34; connection option in its final response on that connection. The server MUST NOT process any further requests received on that connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「閉じる」接続オプションを受信するサーバーは、「閉じる」接続オプションを含むリクエストに最終的な応答を送信した後、接続の閉鎖を開始する必要があります（以下を参照）。サーバーは、その接続の最終応答で「閉じる」接続オプションを送信する必要があります。サーバーは、その接続で受信したリクエストを処理してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server that sends a &#34;close&#34; connection option MUST initiate closure of the connection (see below) after it sends the response containing the &#34;close&#34; connection option. The server MUST NOT process any further requests received on that connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「閉じる」接続オプションを送信するサーバーは、「閉じる」接続オプションを含む応答を送信した後、接続の閉鎖を開始する必要があります（以下を参照）。サーバーは、その接続で受信したリクエストを処理してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client that receives a &#34;close&#34; connection option MUST cease sending requests on that connection and close the connection after reading the response message containing the &#34;close&#34; connection option; if additional pipelined requests had been sent on the connection, the client SHOULD NOT assume that they will be processed by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「閉じる」接続オプションを受信するクライアントは、「閉じる」接続オプションを含む応答メッセージを読んだ後、その接続の要求の送信を停止し、接続を閉じる必要があります。接続に追加のパイプラインリクエストが送信されていた場合、クライアントはサーバーによって処理されると想定してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a server performs an immediate close of a TCP connection, there is a significant risk that the client will not be able to read the last HTTP response. If the server receives additional data from the client on a fully closed connection, such as another request sent by the client before receiving the server&#39;s response, the server&#39;s TCP stack will send a reset packet to the client; unfortunately, the reset packet might erase the client&#39;s unacknowledged input buffers before they can be read and interpreted by the client&#39;s HTTP parser.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがTCP接続の即時閉鎖を実行する場合、クライアントが最後のHTTP応答を読み取ることができないという重大なリスクがあります。サーバーの応答を受信する前にクライアントから送信された別の要求など、完全に閉じた接続でサーバーがクライアントから追加のデータを受信した場合、サーバーのTCPスタックはクライアントにリセットパケットを送信します。残念ながら、リセットパケットは、クライアントのHTTPパーサーによって読み取って解釈する前に、クライアントの未把持の入力バッファーを消去する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid the TCP reset problem, servers typically close a connection in stages. First, the server performs a half-close by closing only the write side of the read/write connection. The server then continues to read from the connection until it receives a corresponding close by the client, or until the server is reasonably certain that its own TCP stack has received the client&#39;s acknowledgement of the packet(s) containing the server&#39;s last response. Finally, the server fully closes the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPリセットの問題を回避するために、サーバーは通常、ステージで接続を閉じます。まず、サーバーは、読み取り/書き込み接続の書き込み側のみを閉じることにより、半分を実行します。その後、サーバーは、クライアントが対応する閉鎖を受信するまで、またはサーバーがサーバーの最後の応答を含むパケットのクライアントの確認を受信したことをサーバーが合理的に確信するまで、接続から読み続けます。最後に、サーバーは接続を完全に閉じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is unknown whether the reset problem is exclusive to TCP or might also be found in other transport connection protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リセットの問題がTCP専用であるか、他の輸送接続プロトコルにも見られるかどうかは不明です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that a TCP connection that is half-closed by the client does not delimit a request message, nor does it imply that the client is no longer interested in a response. In general, transport signals cannot be relied upon to signal edge cases, since HTTP/1.1 is independent of transport.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントによって半分閉鎖されているTCP接続は、要求メッセージを区切らないことも、クライアントがもはや応答に関心がないことを意味しないことに注意してください。一般に、HTTP/1.1は輸送とは無関係であるため、輸送信号はエッジケースを信号に依存することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-7--TLS-Connection-Initiation">
9.7. TLS Connection Initiation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.7. TLS接続開始
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Conceptually, HTTP/TLS is simply sending HTTP messages over a connection secured via TLS [TLS13].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
概念的には、HTTP/TLSは、TLS [TLS13]を介して保護された接続を介してHTTPメッセージを送信しているだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The HTTP client also acts as the TLS client. It initiates a connection to the server on the appropriate port and sends the TLS ClientHello to begin the TLS handshake. When the TLS handshake has finished, the client may then initiate the first HTTP request. All HTTP data MUST be sent as TLS &#34;application data&#34; but is otherwise treated like a normal connection for HTTP (including potential reuse as a persistent connection).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPクライアントは、TLSクライアントとしても機能します。適切なポートのサーバーへの接続を開始し、TLS ClientHelloを送信してTLSハンドシェイクを開始します。TLSの握手が終了したら、クライアントは最初のHTTP要求を開始することがあります。すべてのHTTPデータは、TLS「アプリケーションデータ」として送信する必要がありますが、それ以外の場合はHTTPの通常の接続のように扱われます（潜在的な再利用を含む）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-8--TLS-Connection-Closure">
9.8. TLS Connection Closure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.8. TLS接続閉鎖
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS uses an exchange of closure alerts prior to (non-error) connection closure to provide secure connection closure; see Section 6.1 of [TLS13]. When a valid closure alert is received, an implementation can be assured that no further data will be received on that connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSは、（非エラー）接続閉鎖の前に閉鎖アラートの交換を使用して、安全な接続閉鎖を提供します。[TLS13]のセクション6.1を参照してください。有効な閉鎖アラートが受信された場合、その接続でそれ以上のデータが受信されないことを実装することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an implementation knows that it has sent or received all the message data that it cares about, typically by detecting HTTP message boundaries, it might generate an &#34;incomplete close&#34; by sending a closure alert and then closing the connection without waiting to receive the corresponding closure alert from its peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装が、通常はHTTPメッセージの境界を検出することにより、それが気にかけているすべてのメッセージデータを送信または受信したことを知っている場合、閉鎖アラートを送信してから、対応するのを待つことなく接続を閉じることにより、「不完全なクローズ」を生成する可能性がありますピアからの閉鎖アラート。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An incomplete close does not call into question the security of the data already received, but it could indicate that subsequent data might have been truncated. As TLS is not directly aware of HTTP message framing, it is necessary to examine the HTTP data itself to determine whether messages are complete. Handling of incomplete messages is defined in Section 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不完全なクローズは、すでに受信したデータのセキュリティに疑問を投げかけることはありませんが、後続のデータが切り捨てられている可能性があることを示す可能性があります。TLSはHTTPメッセージフレーミングを直接認識していないため、メッセージが完了したかどうかを判断するためにHTTPデータ自体を調べる必要があります。不完全なメッセージの処理は、セクション8で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When encountering an incomplete close, a client SHOULD treat as completed all requests for which it has received either
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不完全なクローズに遭遇したとき、クライアントはどちらかを受け取ったすべてのリクエストを完了するにつれて扱う必要があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. as much data as specified in the Content-Length header field or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. コンテンツレングスヘッダーフィールドで指定されているように多くのデータまたは
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. the terminal zero-length chunk (when Transfer-Encoding of chunked is used).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 端子ゼロ長塊（チャンクの転送エンコードが使用される場合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A response that has neither chunked transfer coding nor Content-Length is complete only if a valid closure alert has been received. Treating an incomplete message as complete could expose implementations to attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
充電された転送コーディングもコンテンツ長もない応答は、有効な閉鎖アラートが受信された場合にのみ完了します。不完全なメッセージを完全に扱うと、攻撃に実装を公開する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client detecting an incomplete close SHOULD recover gracefully.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不完全なクローズを検出するクライアントは、優雅に回復するはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients MUST send a closure alert before closing the connection. Clients that do not expect to receive any more data MAY choose not to wait for the server&#39;s closure alert and simply close the connection, thus generating an incomplete close on the server side.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、接続を閉じる前に閉鎖アラートを送信する必要があります。これ以上のデータを受け取ることを期待していないクライアントは、サーバーのクロージャーアラートを待機せず、接続を閉じるだけで、サーバー側に不完全な近接を生成することを選択する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers SHOULD be prepared to receive an incomplete close from the client, since the client can often locate the end of server data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはサーバーデータの終了を見つけることができることが多いため、クライアントから不完全なクローズを受信するようにサーバーを準備する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers MUST attempt to initiate an exchange of closure alerts with the client before closing the connection. Servers MAY close the connection after sending the closure alert, thus generating an incomplete close on the client side.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、接続を閉じる前にクライアントとの閉鎖アラートの交換を開始しようとする必要があります。サーバーは、クロージャーアラートを送信した後に接続を閉じる可能性があり、クライアント側に不完全なクローズを生成する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10--Enclosing-Messages-as-Data">
10. Enclosing Messages as Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. メッセージをデータとして囲む
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-1--Media-Type-messagehttp">
10.1. Media Type message/http
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. メディアタイプメッセージ/http
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;message/http&#34; media type can be used to enclose a single HTTP request or response message, provided that it obeys the MIME restrictions for all &#34;message&#34; types regarding line length and encodings. Because of the line length limitations, field values within &#34;message/http&#34; are allowed to use line folding (obs-fold), as described in Section 5.2, to convey the field value over multiple lines. A recipient of &#34;message/http&#34; data MUST replace any obsolete line folding with one or more SP characters when the message is consumed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「メッセージ/HTTP」メディアタイプを使用して、単一のHTTP要求または応答メッセージを囲むことができます。ラインの長さの制限のため、セクション5.2で説明されているように、「メッセージ/HTTP」内のフィールド値は、複数の行でフィールド値を伝えるために、ライン折りたたみ（倍数）を使用できます。「メッセージ/http」データの受信者は、メッセージが消費されたときに、時代遅れの線の折りたたみを1つ以上のSP文字に置き換える必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Type name: message
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプ名：メッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Subtype name: http
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブタイプ名：http
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Required parameters: N/A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必要なパラメーター：n/a
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Optional parameters: version, msgtype
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションのパラメーター：バージョン、msgtype
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
version: The HTTP-version number of the enclosed message (e.g., &#34;1.1&#34;). If not present, the version can be determined from the first line of the body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
バージョン：囲まれたメッセージのHTTPバージョン数（例： &#34;1.1&#34;）。存在しない場合、バージョンはボディの最初の行から決定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
msgtype: The message type -- &#34;request&#34; or &#34;response&#34;. If not present, the type can be determined from the first line of the body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
msgtype：メッセージタイプ - 「リクエスト」または「応答」。存在しない場合、タイプは身体の最初の行から決定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding considerations: only &#34;7bit&#34;, &#34;8bit&#34;, or &#34;binary&#34; are permitted
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考慮事項のエンコード：「7ビット」、「8ビット」、または「バイナリ」のみが許可されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Security considerations: see Section 11
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティ上の考慮事項：セクション11を参照してください
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Interoperability considerations: N/A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相互運用性の考慮事項：n/a
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Published specification: RFC 9112 (see Section 10.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
公開された仕様：RFC 9112（セクション10.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that use this media type: N/A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメディアタイプを使用するアプリケーション：n/a
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fragment identifier considerations: N/A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグメント識別子の考慮事項：n/a
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Additional information:  Magic number(s):  N/A
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-28">
Deprecated alias names for this type: N/A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-28">
このタイプの非推奨エイリアス名：n/a
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                            File extension(s):  N/A
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                            Macintosh file type code(s):  N/A
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Person and email address to contact for further information: See Aut hors&#39; Addresses section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
詳細については、個人とメールアドレスをお問い合わせください：Aut Horsのアドレスセクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Intended usage: COMMON
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
意図された使用法：共通
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Restrictions on usage: N/A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用に関する制限：n/a
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Author: See Authors&#39; Addresses section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者：著者のアドレスセクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Change controller: IESG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Change Controller：IESG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-2--Media-Type-applicationhttp">
10.2. Media Type application/http
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. メディアタイプアプリケーション/http
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;application/http&#34; media type can be used to enclose a pipeline of one or more HTTP request or response messages (not intermixed).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「アプリケーション/HTTP」メディアタイプを使用して、1つ以上のHTTP要求または応答メッセージのパイプラインを囲むことができます（混合されていません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Type name: application
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプ名：アプリケーション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Subtype name: http
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブタイプ名：http
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Required parameters: N/A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必要なパラメーター：n/a
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Optional parameters: version, msgtype
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションのパラメーター：バージョン、msgtype
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
version: The HTTP-version number of the enclosed messages (e.g., &#34;1.1&#34;). If not present, the version can be determined from the first line of the body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
バージョン：囲まれたメッセージのHTTPバージョン数（例： &#34;1.1&#34;）。存在しない場合、バージョンはボディの最初の行から決定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
msgtype: The message type -- &#34;request&#34; or &#34;response&#34;. If not present, the type can be determined from the first line of the body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
msgtype：メッセージタイプ - 「リクエスト」または「応答」。存在しない場合、タイプは身体の最初の行から決定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding considerations: HTTP messages enclosed by this type are in &#34;binary&#34; format; use of an appropriate Content-Transfer-Encoding is required when transmitted via email.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考慮事項のエンコード：このタイプで囲まれたHTTPメッセージは「バイナリ」形式です。電子メールで送信される場合、適切なコンテンツ移動エンコードの使用が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Security considerations: see Section 11
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティ上の考慮事項：セクション11を参照してください
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Interoperability considerations: N/A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相互運用性の考慮事項：n/a
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Published specification: RFC 9112 (see Section 10.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
公開された仕様：RFC 9112（セクション10.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that use this media type: N/A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメディアタイプを使用するアプリケーション：n/a
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fragment identifier considerations: N/A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグメント識別子の考慮事項：n/a
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Additional information:  Deprecated alias names for this type:  N/A
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                            Magic number(s):  N/A
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                            File extension(s):  N/A
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                            Macintosh file type code(s):  N/A
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Person and email address to contact for further information: See Aut hors&#39; Addresses section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
詳細については、個人とメールアドレスをお問い合わせください：Aut Horsのアドレスセクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Intended usage: COMMON
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
意図された使用法：共通
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Restrictions on usage: N/A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用に関する制限：n/a
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Author: See Authors&#39; Addresses section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者：著者のアドレスセクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Change controller: IESG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Change Controller：IESG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11--Security-Considerations">
11. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. セキュリティ上の考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section is meant to inform developers, information providers, and users about known security considerations relevant to HTTP message syntax and parsing. Security considerations about HTTP semantics, content, and routing are addressed in [HTTP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションは、HTTPメッセージの構文と解析に関連する既知のセキュリティに関する考慮事項について、開発者、情報プロバイダー、およびユーザーに通知することを目的としています。HTTPセマンティクス、コンテンツ、およびルーティングに関するセキュリティ上の考慮事項は、[HTTP]で対処されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1--Response-Splitting">
11.1. Response Splitting
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. 応答分割
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Response splitting (a.k.a. CRLF injection) is a common technique, used in various attacks on Web usage, that exploits the line-based nature of HTTP message framing and the ordered association of requests to responses on persistent connections [Klein]. This technique can be particularly damaging when the requests pass through a shared cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答分割（別名CRLFインジェクション）は、Web使用に関するさまざまな攻撃で使用される一般的な手法であり、HTTPメッセージフレーミングのラインベースの性質と、永続的な接続の応答とのリクエストの順序付き関連を活用します[Klein]。この手法は、リクエストが共有キャッシュを通過する場合に特に損害を与える可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Response splitting exploits a vulnerability in servers (usually within an application server) where an attacker can send encoded data within some parameter of the request that is later decoded and echoed within any of the response header fields of the response. If the decoded data is crafted to look like the response has ended and a subsequent response has begun, the response has been split, and the content within the apparent second response is controlled by the attacker. The attacker can then make any other request on the same persistent connection and trick the recipients (including intermediaries) into believing that the second half of the split is an authoritative answer to the second request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答の分割は、攻撃者がリクエストの一部のパラメーター内でエンコードされたデータを送信して、後でデコードされ、応答の応答ヘッダーフィールドのいずれか内にエコーされます。デコードされたデータが応答が終了し、その後の応答が開始されるように作成され、応答が分割され、見かけの2番目の応答内のコンテンツが攻撃者によって制御されます。攻撃者は、同じ永続的な接続で他の要求を行い、受信者（仲介者を含む）をだまして、分割の後半が2番目の要求に対する権威ある回答であると信じることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, a parameter within the request-target might be read by an application server and reused within a redirect, resulting in the same parameter being echoed in the Location header field of the response. If the parameter is decoded by the application and not properly encoded when placed in the response field, the attacker can send encoded CRLF octets and other content that will make the application&#39;s single response look like two or more responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、リクエストターゲット内のパラメーターはアプリケーションサーバーによって読み取られ、リダイレクト内で再利用される場合があり、その結果、同じパラメーターが応答の位置ヘッダーフィールドにエコーされます。パラメーターがアプリケーションによってデコードされ、応答フィールドに配置されたときに適切にエンコードされていない場合、攻撃者はエンコードされたCRLFオクテットおよびその他のコンテンツを送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A common defense against response splitting is to filter requests for data that looks like encoded CR and LF (e.g., &#34;%0D&#34; and &#34;%0A&#34;). However, that assumes the application server is only performing URI decoding rather than more obscure data transformations like charset transcoding, XML entity translation, base64 decoding, sprintf reformatting, etc. A more effective mitigation is to prevent anything other than the server&#39;s core protocol libraries from sending a CR or LF within the header section, which means restricting the output of header fields to APIs that filter for bad octets and not allowing application servers to write directly to the protocol stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答分割に対する一般的な防御は、エンコードされたCRやLF（「％0D」および「％0A」などのように見えるデータのリクエストをフィルタリングすることです。ただし、Application Serverは、Charset Transcoding、XML Entity Translation、Base64 Decoding、Sprintf Reforattingなど、より曖昧なデータ変換ではなく、URIデコードのみを実行していると想定しています。より効果的な緩和は、サーバーのコアプロトコルライブラリ以外を防ぐことですヘッダーセクション内でCRまたはLFを送信します。これは、ヘッダーフィールドの出力をAPIに制限し、悪いオクテットをフィルタリングすることを意味し、アプリケーションサーバーがプロトコルストリームに直接書き込むことを許可しないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-2--Request-Smuggling">
11.2. Request Smuggling
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. 密輸をリクエストします
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Request smuggling ([Linhart]) is a technique that exploits differences in protocol parsing among various recipients to hide additional requests (which might otherwise be blocked or disabled by policy) within an apparently harmless request. Like response splitting, request smuggling can lead to a variety of attacks on HTTP usage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエスト密輸（[linhart]）は、さまざまな受信者間のプロトコル解析の違いを活用して、明らかに無害な要求内で追加の要求（そうでなければポリシーによってブロックまたは無効にされる可能性がある）を非表示にする手法です。応答の分割と同様に、リクエストの密輸は、HTTP使用に対するさまざまな攻撃につながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification has introduced new requirements on request parsing, particularly with regard to message framing in Section 6.3, to reduce the effectiveness of request smuggling.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様により、特にセクション6.3のメッセージフレーミングに関して、リクエストの解析に関する新しい要件が導入され、要求の密輸の有効性が低下しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-3--Message-Integrity">
11.3. Message Integrity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3. メッセージの整合性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP does not define a specific mechanism for ensuring message integrity, instead relying on the error-detection ability of underlying transport protocols and the use of length or chunk-delimited framing to detect completeness. Historically, the lack of a single integrity mechanism has been justified by the informal nature of most HTTP communication. However, the prevalence of HTTP as an information access mechanism has resulted in its increasing use within environments where verification of message integrity is crucial.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPは、メッセージの整合性を確保するための特定のメカニズムを定義しません。代わりに、基礎となる輸送プロトコルのエラー検出能力と、完全性を検出するための長さまたはチャンク削除フレーミングの使用に依存します。歴史的に、単一の整合性メカニズムの欠如は、ほとんどのHTTP通信の非公式の性質によって正当化されてきました。ただし、情報アクセスメカニズムとしてのHTTPの有病率は、メッセージの整合性の検証が重要な環境内での使用の増加をもたらしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mechanisms provided with the &#34;https&#34; scheme, such as authenticated encryption, provide protection against modification of messages. Care is needed, however, to ensure that connection closure cannot be used to truncate messages (see Section 9.8). User agents might refuse to accept incomplete messages or treat them specially. For example, a browser being used to view medical history or drug interaction information needs to indicate to the user when such information is detected by the protocol to be incomplete, expired, or corrupted during transfer. Such mechanisms might be selectively enabled via user agent extensions or the presence of message integrity metadata in a response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
認証された暗号化などの「HTTPS」スキームで提供されるメカニズムは、メッセージの変更に対する保護を提供します。ただし、メッセージの切り捨てに接続クロージャーを使用できないことを確認するには注意が必要です（セクション9.8を参照）。ユーザーエージェントは、不完全なメッセージを受け入れるか、特別に扱うことを拒否する場合があります。たとえば、病歴や薬物相互作用情報を表示するために使用されるブラウザは、そのような情報がプロトコルによって検出され、転送中に不完全、期限切れ、または破損していることを検出した場合にユーザーに示す必要があります。このようなメカニズムは、ユーザーエージェント拡張またはメッセージの整合性メタデータの存在を介して選択的に有効にされる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;http&#34; scheme provides no protection against accidental or malicious modification of messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「HTTP」スキームは、メッセージの偶発的または悪意のある変更に対する保護を提供しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Extensions to the protocol might be used to mitigate the risk of unwanted modification of messages by intermediaries, even when the &#34;https&#34; scheme is used. Integrity might be assured by using message authentication codes or digital signatures that are selectively added to messages via extensible metadata fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルへの拡張は、「HTTPS」スキームが使用されている場合でも、仲介者によるメッセージの不要な変更のリスクを軽減するために使用される場合があります。拡張可能なメタデータフィールドを介してメッセージに選択的に追加されるメッセージ認証コードまたはデジタル署名を使用することにより、整合性が保証される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-4--Message-Confidentiality">
11.4. Message Confidentiality
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4. メッセージの機密性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP relies on underlying transport protocols to provide message confidentiality when that is desired. HTTP has been specifically designed to be independent of the transport protocol, such that it can be used over many forms of encrypted connection, with the selection of such transports being identified by the choice of URI scheme or within user agent configuration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPは、基礎となる輸送プロトコルに依存して、それが必要な場合にメッセージの機密性を提供します。HTTPは、トランスポートプロトコルとは独立しているように特別に設計されており、多くの形式の暗号化された接続で使用できるように、そのようなトランスポートの選択はURIスキームの選択またはユーザーエージェント構成によって識別されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;https&#34; scheme can be used to identify resources that require a confidential connection, as described in Section 4.2.2 of [HTTP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTTPS]スキームを使用して、[HTTP]のセクション4.2.2で説明されているように、機密接続を必要とするリソースを識別できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12--IANA-Considerations">
12. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The change controller for the following registrations is: &#34;IETF (iesg@ietf.org) - Internet Engineering Task Force&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の登録の変更コントローラーは、「IETF（iesg@ietf.org） - インターネットエンジニアリングタスクフォース」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-1--Field-Name-Registration">
12.1. Field Name Registration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. フィールド名登録
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has added the following field names to the &#34;Hypertext Transfer Protocol (HTTP) Field Name Registry&#34; at &lt;https://www.iana.org/assignments/http-fields&gt;, as described in Section 18.4 of [HTTP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、[http]のセクション18.4で説明されているように、「https://www.iana.org/assignments/http-fields&gt; &lt;https://www.iana.org/assignments/http-fields&gt; &lt;https://www.iana.org&gt; &lt;https://www.iana.org&gt; &lt;https://www.iana.org&gt;」の「ハイパーテキスト転送プロトコル（http）フィールド名レジストリ」に追加したフィールド名を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +===================+===========+=========+============+
   | Field Name        | Status    | Section | Comments   |
   +===================+===========+=========+============+
   | Close             | permanent | 9.6     | (reserved) |
   +-------------------+-----------+---------+------------+
   | MIME-Version      | permanent | B.1     |            |
   +-------------------+-----------+---------+------------+
   | Transfer-Encoding | permanent | 6.1     |            |
   +-------------------+-----------+---------+------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
Table 1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
表1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2--Media-Type-Registration">
12.2. Media Type Registration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2. メディアタイプの登録
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has updated the &#34;Media Types&#34; registry at &lt;https://www.iana.org/assignments/media-types&gt; with the registration information in Sections 10.1 and 10.2 for the media types &#34;message/ http&#34; and &#34;application/http&#34;, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、&lt;https://www.iana.org/assignments/media-types&gt; &lt;https://www.iana.org&gt;の「メディアタイプ」レジストリを更新しました。&#34;、 それぞれ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-3--Transfer-Coding-Registration">
12.3. Transfer Coding Registration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3. コーディング登録を転送します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has updated the &#34;HTTP Transfer Coding Registry&#34; at &lt;https://www.iana.org/assignments/http-parameters/&gt; with the registration procedure of Section 7.3 and the content coding names summarized in the table below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、セクション7.3の登録手順で「https://www.iana.org/assignments/http-parameters/&gt; &lt;https://www.iana.org/assignments/http-parameters/&gt;」の「HTTP転送レジストリ」を更新し、以下の表にまとめたコンテンツコーディング名を更新しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +============+===========================================+=========+
   | Name       | Description                               | Section |
   +============+===========================================+=========+
   | chunked    | Transfer in a series of chunks            | 7.1     |
   +------------+-------------------------------------------+---------+
   | compress   | UNIX &#34;compress&#34; data format [Welch]       | 7.2     |
   +------------+-------------------------------------------+---------+
   | deflate    | &#34;deflate&#34; compressed data ([RFC1951])     | 7.2     |
   |            | inside the &#34;zlib&#34; data format ([RFC1950]) |         |
   +------------+-------------------------------------------+---------+
   | gzip       | GZIP file format [RFC1952]                | 7.2     |
   +------------+-------------------------------------------+---------+
   | trailers   | (reserved)                                | 12.3    |
   +------------+-------------------------------------------+---------+
   | x-compress | Deprecated (alias for compress)           | 7.2     |
   +------------+-------------------------------------------+---------+
   | x-gzip     | Deprecated (alias for gzip)               | 7.2     |
   +------------+-------------------------------------------+---------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Table 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
表2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      |  *Note:* the coding name &#34;trailers&#34; is reserved because its use
      |  would conflict with the keyword &#34;trailers&#34; in the TE header
      |  field (Section 10.1.4 of [HTTP]).
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-4--ALPN-Protocol-ID-Registration">
12.4. ALPN Protocol ID Registration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.4. ALPNプロトコルID登録
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has updated the &#34;TLS Application-Layer Protocol Negotiation (ALPN) Protocol IDs&#34; registry at &lt;https://www.iana.org/assignments/ tls-extensiontype-values/&gt; with the registration below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、「TLSアプリケーションレイヤープロトコルネゴシエーション（ALPN）プロトコルIDS」レジストリを&lt;https://www.iana.org/assignments/ tls-extensiontype-values/&gt;に更新しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          +==========+=============================+===========+
          | Protocol | Identification Sequence     | Reference |
          +==========+=============================+===========+
          | HTTP/1.1 | 0x68 0x74 0x74 0x70 0x2f    | RFC 9112  |
          |          | 0x31 0x2e 0x31 (&#34;http/1.1&#34;) |           |
          +----------+-----------------------------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Table 3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
表3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13--References">
13. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-1--Normative-References">
13.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CACHING] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., &#34;HTTP Caching&#34;, STD 98, RFC 9111, DOI 10.17487/RFC9111, June 2022, &lt;https://www.rfc-editor.org/info/rfc9111&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[キャッシュ]フィールディング、R。、編、ノッティンガム、M.、編、J。レスケ、編、「HTTPキャッシュ」、STD 98、RFC 9111、DOI 10.17487/RFC9111、2022年6月、&lt;https：//www.rfc-editor.org/info/rfc9111&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTTP] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., &#34;HTTP Semantics&#34;, STD 97, RFC 9110, DOI 10.17487/RFC9110, June 2022, &lt;https://www.rfc-editor.org/info/rfc9110&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTTP] Fielding、R.、Ed。、Nottingham、M.、Ed。、およびJ. Reschke、ed。、 &#34;HTTP Semantics&#34;、Std 97、RFC 9110、DOI 10.17487/RFC9110、2022年6月、&lt;https：//www.rfc-editor.org/info/rfc9110&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1950] Deutsch, P. and J-L. Gailly, &#34;ZLIB Compressed Data Format Specification version 3.3&#34;, RFC 1950, DOI 10.17487/RFC1950, May 1996, &lt;https://www.rfc-editor.org/info/rfc1950&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1950] Deutsch、P。およびJ-L。Gailly、「Zlib圧縮データ形式の仕様バージョン3.3」、RFC 1950、DOI 10.17487/RFC1950、1996年5月、&lt;https://www.rfc-editor.org/info/rfc1950&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1951] Deutsch, P., &#34;DEFLATE Compressed Data Format Specification version 1.3&#34;, RFC 1951, DOI 10.17487/RFC1951, May 1996, &lt;https://www.rfc-editor.org/info/rfc1951&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1951] Deutsch、P。、「圧縮データ形式の仕様バージョン1.3」、RFC 1951、DOI 10.17487/RFC1951、1996年5月、&lt;https://www.rfc-editor.org/info/rfc1951&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1952] Deutsch, P., &#34;GZIP file format specification version 4.3&#34;, RFC 1952, DOI 10.17487/RFC1952, May 1996, &lt;https://www.rfc-editor.org/info/rfc1952&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1952] Deutsch、P。、「GZIPファイル形式の仕様バージョン4.3」、RFC 1952、DOI 10.17487/RFC1952、1996年5月、&lt;https://www.rfc-editor.org/info/rfc1952&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;https://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487/RFC2119、1997年3月、&lt;https://www.rfc-editor.org/info/RFC2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5234] Crocker, D., Ed. and P. Overell, &#34;Augmented BNF for Syntax Specifications: ABNF&#34;, STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, &lt;https://www.rfc-editor.org/info/rfc5234&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5234] Crocker、D.、ed。P. Overell、「構文仕様のためのBNFの増強：ABNF：STD 68、RFC 5234、DOI 10.17487/RFC5234、2008年1月、&lt;https://www.rfc-editor.org/info/rfc5234&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7405] Kyzivat, P., &#34;Case-Sensitive String Support in ABNF&#34;, RFC 7405, DOI 10.17487/RFC7405, December 2014, &lt;https://www.rfc-editor.org/info/rfc7405&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7405] Kyzivat、P。、「ABNFでのケースセンシティブストリングサポート」、RFC 7405、DOI 10.17487/RFC7405、2014年12月、&lt;https://www.rfc-editor.org/info/rfc7405&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba, B., &#34;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&#34;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487/RFC8174、2017年5月、&lt;https：//www.rfc-editor.org/info/RFC8174&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS13] Rescorla, E., &#34;The Transport Layer Security (TLS) Protocol Version 1.3&#34;, RFC 8446, DOI 10.17487/RFC8446, August 2018, &lt;https://www.rfc-editor.org/info/rfc8446&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS13] Rescorla、E。、「輸送層セキュリティ（TLS）プロトコルバージョン1.3」、RFC 8446、DOI 10.17487/RFC8446、2018年8月、&lt;https://www.rfc-editor.org/info/rfc846&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[URI] Berners-Lee, T., Fielding, R., and L. Masinter, &#34;Uniform Resource Identifier (URI): Generic Syntax&#34;, STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, &lt;https://www.rfc-editor.org/info/rfc3986&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[URI] Berners-Lee、T.、Fielding、R。、およびL. Masinter、「Uniform Resource Identifier（URI）：Generic Syntax」、Std 66、RFC 3986、DOI 10.17487/RFC3986、2005年1月、&lt;https：//www.rfc-editor.org/info/rfc3986&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[USASCII] American National Standards Institute, &#34;Coded Character Set -- 7-bit American Standard Code for Information Interchange&#34;, ANSI X3.4, 1986.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[USASCII] American National Standards Institute、「コード化された文字セット - 情報交換のための7ビットアメリカ標準コード」、ANSI X3.4、1986。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Welch] Welch, T., &#34;A Technique for High-Performance Data Compression&#34;, IEEE Computer 17(6), DOI 10.1109/MC.1984.1659158, June 1984, &lt;https://ieeexplore.ieee.org/document/1659158/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ウェルチ]ウェルチ、T。、「高性能データ圧縮の手法」、IEEEコンピューター17（6）、DOI 10.1109/MC.1984.1659158、1984年6月、&lt;https://ieeexplore.ieee.org/document/165915888/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-2--Informative-References">
13.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTTP/1.0] Berners-Lee, T., Fielding, R., and H. Frystyk, &#34;Hypertext Transfer Protocol -- HTTP/1.0&#34;, RFC 1945, DOI 10.17487/RFC1945, May 1996, &lt;https://www.rfc-editor.org/info/rfc1945&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTTP/1.0] Berners-Lee、T.、Fielding、R。、およびH. Frystyk、「HyperText Transfer Protocol-HTTP/1.0」、RFC 1945、DOI 10.17487/RFC1945、1996年5月、&lt;https：// wwwwwwwwwwwwwwwwwwww.rfc-editor.org/info/rfc1945&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Klein] Klein, A., &#34;Divide and Conquer - HTTP Response Splitting, Web Cache Poisoning Attacks, and Related Topics&#34;, March 2004, &lt;https://packetstormsecurity.com/papers/general/ whitepaper_httpresponse.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[クライン]クライン、A。、「分割と征服-HTTP応答分割、Webキャッシュ中毒攻撃、および関連トピック」、2004年3月&lt;https://packetstormsecurity.com/papers/general/ whitepaper_httpresponse.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Linhart] Linhart, C., Klein, A., Heled, R., and S. Orrin, &#34;HTTP Request Smuggling&#34;, June 2005, &lt;https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Linhart] Linhart、C.、Klein、A.、Heled、R。、およびS. Orrin、「HTTP Request Smuggling」、2005年6月、&lt;https://www.cgisecurity.com/lib/http-request-smuggling.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2045] Freed, N. and N. Borenstein, &#34;Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies&#34;, RFC 2045, DOI 10.17487/RFC2045, November 1996, &lt;https://www.rfc-editor.org/info/rfc2045&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2045] Freed、N。およびN. Borenstein、「多目的インターネットメール拡張機能（MIME）パート1：インターネットメッセージボディの形式」、RFC 2045、DOI 10.17487/RFC2045、1996年11月、&lt;https：//www.rfc-editor.org/info/rfc2045&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2046] Freed, N. and N. Borenstein, &#34;Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types&#34;, RFC 2046, DOI 10.17487/RFC2046, November 1996, &lt;https://www.rfc-editor.org/info/rfc2046&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2046] Freed、N。およびN. Borenstein、「多目的インターネットメール拡張機能（MIME）パート2：メディアタイプ」、RFC 2046、DOI 10.17487/RFC2046、1996年11月、&lt;https://www.rfc-editor.orgg/info/rfc2046&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2049] Freed, N. and N. Borenstein, &#34;Multipurpose Internet Mail Extensions (MIME) Part Five: Conformance Criteria and Examples&#34;, RFC 2049, DOI 10.17487/RFC2049, November 1996, &lt;https://www.rfc-editor.org/info/rfc2049&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2049] Freed、N。and N. Borenstein、「多目的インターネットメール拡張機能（MIME）パート5：適合基準と例」、RFC 2049、DOI 10.17487/RFC2049、1996年11月、&lt;https：//www.rfc-editor.org/info/rfc2049&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2068] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., and T. Berners-Lee, &#34;Hypertext Transfer Protocol -- HTTP/1.1&#34;, RFC 2068, DOI 10.17487/RFC2068, January 1997, &lt;https://www.rfc-editor.org/info/rfc2068&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2068] Fielding、R.、Gettys、J.、Mogul、J.、Frystyk、H。、およびT. Berners-Lee、 &#34;HyperText Transfer Protocol-HTTP/1.1&#34;、RFC 2068、DOI 10.17487/RFC2068、1月1997、&lt;https://www.rfc-editor.org/info/rfc2068&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2557] Palme, J., Hopmann, A., and N. Shelness, &#34;MIME Encapsulation of Aggregate Documents, such as HTML (MHTML)&#34;, RFC 2557, DOI 10.17487/RFC2557, March 1999, &lt;https://www.rfc-editor.org/info/rfc2557&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2557] Palme、J.、Hopmann、A。、およびN. Shelness、「HTML（MHTML）などの集計文書のMIMEカプセル化」、RFC 2557、DOI 10.17487/RFC2557、1999年3月、&lt;HTTPS：//.rfc-editor.org/info/rfc2557&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5322] Resnick, P., Ed., &#34;Internet Message Format&#34;, RFC 5322, DOI 10.17487/RFC5322, October 2008, &lt;https://www.rfc-editor.org/info/rfc5322&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5322] Resnick、P.、ed。、「インターネットメッセージフォーマット」、RFC 5322、DOI 10.17487/RFC5322、2008年10月、&lt;https://www.rfc-editor.org/info/rfc5321。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., &#34;Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing&#34;, RFC 7230, DOI 10.17487/RFC7230, June 2014, &lt;https://www.rfc-editor.org/info/rfc7230&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7230] Fielding、R.、ed。and J. Reschke、ed。、「HyperText Transfer Protocol（HTTP/1.1）：メッセージの構文とルーティング」、RFC 7230、DOI 10.17487/RFC7230、2014年6月、&lt;https://www.rfc-editor.org/info/RFC7230&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8126] Cotton, M., Leiba, B., and T. Narten, &#34;Guidelines for Writing an IANA Considerations Section in RFCs&#34;, BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, &lt;https://www.rfc-editor.org/info/rfc8126&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8126] Cotton、M.、Leiba、B。、およびT. Narten、「RFCSでIANA考慮事項セクションを書くためのガイドライン」、BCP 26、RFC 8126、DOI 10.17487/RFC8126、2017年6月、&lt;https：// wwwwwwwwwwwwwwwwwwww.rfc-editor.org/info/rfc8126&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-A--Collected-ABNF">
Appendix A. Collected ABNF
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録A. ABNFを収集しました
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the collected ABNF below, list rules are expanded per Section 5.6.1 of [HTTP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の収集されたABNFでは、[HTTP]のセクション5.6.1ごとにリストルールが拡張されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   BWS = &lt;BWS, see [HTTP], Section 5.6.3&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   HTTP-message = start-line CRLF *( field-line CRLF ) CRLF [
    message-body ]
   HTTP-name = %x48.54.54.50 ; HTTP
   HTTP-version = HTTP-name &#34;/&#34; DIGIT &#34;.&#34; DIGIT
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OWS = &lt;OWS, see [HTTP], Section 5.6.3&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   RWS = &lt;RWS, see [HTTP], Section 5.6.3&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Transfer-Encoding = [ transfer-coding *( OWS &#34;,&#34; OWS transfer-coding
    ) ]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   absolute-URI = &lt;absolute-URI, see [URI], Section 4.3&gt;
   absolute-form = absolute-URI
   absolute-path = &lt;absolute-path, see [HTTP], Section 4.1&gt;
   asterisk-form = &#34;*&#34;
   authority = &lt;authority, see [URI], Section 3.2&gt;
   authority-form = uri-host &#34;:&#34; port
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   chunk = chunk-size [ chunk-ext ] CRLF chunk-data CRLF
   chunk-data = 1*OCTET
   chunk-ext = *( BWS &#34;;&#34; BWS chunk-ext-name [ BWS &#34;=&#34; BWS chunk-ext-val
    ] )
   chunk-ext-name = token
   chunk-ext-val = token / quoted-string
   chunk-size = 1*HEXDIG
   chunked-body = *chunk last-chunk trailer-section CRLF
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   field-line = field-name &#34;:&#34; OWS field-value OWS
   field-name = &lt;field-name, see [HTTP], Section 5.1&gt;
   field-value = &lt;field-value, see [HTTP], Section 5.5&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   last-chunk = 1*&#34;0&#34; [ chunk-ext ] CRLF
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   message-body = *OCTET
   method = token
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   obs-fold = OWS CRLF RWS
   obs-text = &lt;obs-text, see [HTTP], Section 5.6.4&gt;
   origin-form = absolute-path [ &#34;?&#34; query ]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   port = &lt;port, see [URI], Section 3.2.3&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   query = &lt;query, see [URI], Section 3.4&gt;
   quoted-string = &lt;quoted-string, see [HTTP], Section 5.6.4&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   reason-phrase = 1*( HTAB / SP / VCHAR / obs-text )
   request-line = method SP request-target SP HTTP-version
   request-target = origin-form / absolute-form / authority-form /
    asterisk-form
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
start-line = request-line / status-line status-code = 3DIGIT status-line = HTTP-version SP status-code SP [ reason-phrase ]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
start-line = request-line / status-line status-code = 3digit status-line = http-version spステータスコードSP [Reason-Phrase]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   token = &lt;token, see [HTTP], Section 5.6.2&gt;
   trailer-section = *( field-line CRLF )
   transfer-coding = &lt;transfer-coding, see [HTTP], Section 10.1.4&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   uri-host = &lt;host, see [URI], Section 3.2.2&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-B--Differences-between-HTTP-and-MIME">
Appendix B. Differences between HTTP and MIME
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録B. HTTPとMIMEの違い
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.1 uses many of the constructs defined for the Internet Message Format [RFC5322] and Multipurpose Internet Mail Extensions (MIME) [RFC2045] to allow a message body to be transmitted in an open variety of representations and with extensible fields. However, some of these constructs have been reinterpreted to better fit the needs of interactive communication, leading to some differences in how MIME constructs are used within HTTP. These differences were carefully chosen to optimize performance over binary connections, allow greater freedom in the use of new media types, ease date comparisons, and accommodate common implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.1は、インターネットメッセージ形式[RFC5322]および多目的インターネットメールエクステンション（MIME）[RFC2045]で定義された多くのコンストラクトを使用して、メッセージ本文をオープンなさまざまな表現と拡張可能なフィールドで送信できるようにします。ただし、これらのコンストラクトのいくつかは、インタラクティブなコミュニケーションのニーズに合わせてより適切に適合するように再解釈されており、HTTP内でMIMEコンストラクトがどのように使用されるかにいくつかの違いにつながります。これらの違いは、バイナリ接続のパフォーマンスを最適化し、新しいメディアタイプの使用の自由度を高め、日付の比較を容易にし、一般的な実装に対応するために慎重に選択されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This appendix describes specific areas where HTTP differs from MIME. Proxies and gateways to and from strict MIME environments need to be aware of these differences and provide the appropriate conversions where necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この付録では、HTTPがMIMEと異なる特定の領域について説明しています。厳格なマイム環境との間でのプロキシとゲートウェイは、これらの違いを認識し、必要に応じて適切な変換を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-1--MIME-Version">
B.1. MIME-Version
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.1. mime-version
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP is not a MIME-compliant protocol. However, messages can include a single MIME-Version header field to indicate what version of the MIME protocol was used to construct the message. Use of the MIME-Version header field indicates that the message is in full conformance with the MIME protocol (as defined in [RFC2045]). Senders are responsible for ensuring full conformance (where possible) when exporting HTTP messages to strict MIME environments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPはMIME準拠のプロトコルではありません。ただし、メッセージには、メッセージの構築に使用されたMIMEプロトコルのバージョンを示すために、単一のMime-versionヘッダーフィールドを含めることができます。Mime-versionヘッダーフィールドの使用は、メッセージがmimeプロトコルに完全に適合していることを示しています（[RFC2045]で定義されています）。送信者は、HTTPメッセージを厳格なMIME環境にエクスポートするときに（可能な場合）、完全な適合性を確保する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-2--Conversion-to-Canonical-Form">
B.2. Conversion to Canonical Form
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.2. 標準形式への変換
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MIME requires that an Internet mail body part be converted to canonical form prior to being transferred, as described in Section 4 of [RFC2049], and that content with a type of &#34;text&#34; represents line breaks as CRLF, forbidding the use of CR or LF outside of line break sequences [RFC2046]. In contrast, HTTP does not care whether CRLF, bare CR, or bare LF are used to indicate a line break within content.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MIMEでは、[RFC2049]のセクション4で説明されているように、転送される前にインターネットメールボディの部分を標準形式に変換する必要があり、「テキスト」の種類を持つコンテンツは、CRLFとしての線切断を表し、CRまたはCRの使用を禁止することを必要とします。ラインブレイクシーケンスの外側のLF [RFC2046]。対照的に、HTTPは、CRLF、Bare CR、またはBare LFがコンテンツ内のラインブレイクを示すために使用されるかどうかを気にしません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A proxy or gateway from HTTP to a strict MIME environment ought to translate all line breaks within text media types to the RFC 2049 canonical form of CRLF. Note, however, this might be complicated by the presence of a Content-Encoding and by the fact that HTTP allows the use of some charsets that do not use octets 13 and 10 to represent CR and LF, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPから厳格なMIME環境へのプロキシまたはゲートウェイは、テキストメディアタイプ内のすべてのラインブレークをRFC 2049 CRLF形式に変換する必要があります。ただし、これは、コンテンツエンコードの存在と、HTTPがそれぞれCRとLFを表すためにオクテット13と10を使用しない一部の充電器を使用できるという事実によって複雑になる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Conversion will break any cryptographic checksums applied to the original content unless the original content is already in canonical form. Therefore, the canonical form is recommended for any content that uses such checksums in HTTP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンバージョンは、元のコンテンツがすでに標準的な形式でない限り、元のコンテンツに適用される暗号化チェックサムを破壊します。したがって、HTTPでそのようなチェックサムを使用するコンテンツには、標準形式が推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-3--Conversion-of-Date-Formats">
B.3. Conversion of Date Formats
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.3. 日付形式の変換
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.1 uses a restricted set of date formats (Section 5.6.7 of [HTTP]) to simplify the process of date comparison. Proxies and gateways from other protocols ought to ensure that any Date header field present in a message conforms to one of the HTTP/1.1 formats and rewrite the date if necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.1は、日付の比較のプロセスを簡素化するために、制限付き日付形式（[HTTP]のセクション5.6.7）を使用します。他のプロトコルからのプロキシとゲートウェイは、メッセージに存在する日付ヘッダーフィールドがHTTP/1.1形式のいずれかに適合し、必要に応じて日付を書き換えることを保証する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-4--Conversion-of-Content-Encoding">
B.4. Conversion of Content-Encoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.4. コンテンツエンコードの変換
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MIME does not include any concept equivalent to HTTP&#39;s Content-Encoding header field. Since this acts as a modifier on the media type, proxies and gateways from HTTP to MIME-compliant protocols ought to either change the value of the Content-Type header field or decode the representation before forwarding the message. (Some experimental applications of Content-Type for Internet mail have used a media-type parameter of &#34;;conversions=&lt;content-coding&gt;&#34; to perform a function equivalent to Content-Encoding. However, this parameter is not part of the MIME standards.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MIMEには、HTTPのコンテンツエンコードヘッダーフィールドに相当するコンセプトは含まれていません。これはメディアタイプの修飾子として機能するため、HTTPからMIMEに準拠したプロトコルへのプロキシとゲートウェイは、メッセージを転送する前にコンテンツタイプのヘッダーフィールドの値を変更するか、表現をデコードする必要があります。（インターネットメールのコンテンツタイプのいくつかの実験的アプリケーションでは、 &#34;; conventions = &lt;content-coding&gt;&#34;のメディアタイプのパラメーターを使用して、コンテンツエンコードに相当する関数を実行しました。ただし、このパラメーターはMIME標準の一部ではありません。。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-5--Conversion-of-Content-Transfer-Encoding">
B.5. Conversion of Content-Transfer-Encoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.5. コンテンツ移動エンコードの変換
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP does not use the Content-Transfer-Encoding field of MIME. Proxies and gateways from MIME-compliant protocols to HTTP need to remove any Content-Transfer-Encoding prior to delivering the response message to an HTTP client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPは、MIMEのコンテンツ転移エンコードフィールドを使用しません。MIMEに準拠したプロトコルからHTTPまでのプロキシとゲートウェイは、HTTPクライアントに応答メッセージを配信する前に、コンテンツ転移エンコードを削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Proxies and gateways from HTTP to MIME-compliant protocols are responsible for ensuring that the message is in the correct format and encoding for safe transport on that protocol, where &#34;safe transport&#34; is defined by the limitations of the protocol being used. Such a proxy or gateway ought to transform and label the data with an appropriate Content-Transfer-Encoding if doing so will improve the likelihood of safe transport over the destination protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPからMIMEに準拠したプロトコルへのプロキシとゲートウェイは、メッセージが正しい形式であることを保証し、そのプロトコルの安全な輸送のためのエンコードであり、「安全な輸送」が使用されているプロトコルの制限によって定義されます。このようなプロキシまたはゲートウェイは、適切なコンテンツトランスファーエンコードでデータを変換およびラベル付けする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-6--MHTML-and-Line-Length-Limitations">
B.6. MHTML and Line Length Limitations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.6. MHTMLおよびラインの長さの制限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP implementations that share code with MHTML [RFC2557] implementations need to be aware of MIME line length limitations. Since HTTP does not have this limitation, HTTP does not fold long lines. MHTML messages being transported by HTTP follow all conventions of MHTML, including line length limitations and folding, canonicalization, etc., since HTTP transfers message-bodies without modification and, aside from the &#34;multipart/byteranges&#34; type (Section 14.6 of [HTTP]), does not interpret the content or any MIME header lines that might be contained therein.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MHTML [RFC2557]とコードを共有するHTTP実装は、MIMEラインの長さの制限を認識する必要があります。HTTPにはこの制限がないため、HTTPは長い行を折りません。HTTPは変更なしでメッセージボディを転送し、「MultiPart/Byteranges」タイプ（[http]のセクション14.6」を除いて、MHTMLのすべての規則に従って、ラインの長さの制限と折り畳み、標準化などを含むMHTMLのすべての規則に従います。）、その中に含まれる可能性のあるコンテンツまたはMIMEヘッダーラインを解釈しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-C--Changes-from-Previous-RFCs">
Appendix C. Changes from Previous RFCs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録C.以前のRFCからの変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="C-1--Changes-from-HTTP0-9">
C.1. Changes from HTTP/0.9
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
C.1. HTTP/0.9からの変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since HTTP/0.9 did not support header fields in a request, there is no mechanism for it to support name-based virtual hosts (selection of resource by inspection of the Host header field). Any server that implements name-based virtual hosts ought to disable support for HTTP/0.9. Most requests that appear to be HTTP/0.9 are, in fact, badly constructed HTTP/1.x requests caused by a client failing to properly encode the request-target.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/0.9はリクエストでヘッダーフィールドをサポートしていなかったため、名前ベースの仮想ホスト（ホストヘッダーフィールドの検査によるリソースの選択）をサポートするメカニズムはありません。名前ベースの仮想ホストを実装するサーバーは、HTTP/0.9のサポートを無効にする必要があります。HTTP/0.9のように見えるほとんどのリクエストは、実際には、クライアントがリクエストターゲットを適切にエンコードしないことによって引き起こされるひどく構築されたHTTP/1.x要求です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="C-2--Changes-from-HTTP1-0">
C.2. Changes from HTTP/1.0
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
C.2. HTTP/1.0からの変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="C-2-1--Multihomed-Web-Servers">
C.2.1. Multihomed Web Servers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
C.2.1. マルチホームWebサーバー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The requirements that clients and servers support the Host header field (Section 7.2 of [HTTP]), report an error if it is missing from an HTTP/1.1 request, and accept absolute URIs (Section 3.2) are among the most important changes defined by HTTP/1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバーがホストヘッダーフィールドをサポートする要件（[HTTP]のセクション7.2）は、HTTP/1.1要求から欠落している場合のエラーを報告し、絶対URIS（セクション3.2）を受け入れることは、次の最も重要な変更の1つです。HTTP/1.1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Older HTTP/1.0 clients assumed a one-to-one relationship of IP addresses and servers; there was no established mechanism for distinguishing the intended server of a request other than the IP address to which that request was directed. The Host header field was introduced during the development of HTTP/1.1 and, though it was quickly implemented by most HTTP/1.0 browsers, additional requirements were placed on all HTTP/1.1 requests in order to ensure complete adoption. At the time of this writing, most HTTP-based services are dependent upon the Host header field for targeting requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
古いHTTP/1.0クライアントは、IPアドレスとサーバーの1対1の関係を想定していました。その要求が指示されたIPアドレス以外の要求の意図したサーバーを区別するための確立されたメカニズムはありませんでした。ホストヘッダーフィールドはHTTP/1.1の開発中に導入され、ほとんどのHTTP/1.0ブラウザによって迅速に実装されましたが、完全な採用を確実にするためにすべてのHTTP/1.1要求に追加要件が配置されました。この執筆時点では、ほとんどのHTTPベースのサービスは、リクエストをターゲットにするためのホストヘッダーフィールドに依存しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="C-2-2--Keep-Alive-Connections">
C.2.2. Keep-Alive Connections
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
C.2.2. アリブな接続を維持します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In HTTP/1.0, each connection is established by the client prior to the request and closed by the server after sending the response. However, some implementations implement the explicitly negotiated (&#34;Keep-Alive&#34;) version of persistent connections described in Section 19.7.1 of [RFC2068].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.0では、各接続はリクエストの前にクライアントによって確立され、応答を送信した後にサーバーによって閉じられます。ただし、一部の実装は、[RFC2068]のセクション19.7.1で説明されている永続的な接続の明示的にネゴシエートされた（「キープアライブ」）バージョンを実装しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some clients and servers might wish to be compatible with these previous approaches to persistent connections, by explicitly negotiating for them with a &#34;Connection: keep-alive&#34; request header field. However, some experimental implementations of HTTP/1.0 persistent connections are faulty; for example, if an HTTP/1.0 proxy server doesn&#39;t understand Connection, it will erroneously forward that header field to the next inbound server, which would result in a hung connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のクライアントとサーバーは、「接続：キープアライブ」リクエストヘッダーフィールドで明示的に交渉することにより、永続的な接続に対するこれらの以前のアプローチと互換性があることを望む場合があります。ただし、HTTP/1.0の永続的な接続のいくつかの実験的実装に故障しています。たとえば、HTTP/1.0プロキシサーバーが接続を理解していない場合、そのヘッダーフィールドが次のインバウンドサーバーに誤って転送されると、接続が吊り下がります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One attempted solution was the introduction of a Proxy-Connection header field, targeted specifically at proxies. In practice, this was also unworkable, because proxies are often deployed in multiple layers, bringing about the same problem discussed above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解決策の1つは、特にプロキシをターゲットとするプロキシ接続ヘッダーフィールドの導入でした。実際には、これも実行できませんでした。なぜなら、プロキシはしばしば複数の層に展開され、上記の同じ問題をもたらすからです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a result, clients are encouraged not to send the Proxy-Connection header field in any requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その結果、クライアントは、どのリクエストでもプロキシ接続ヘッダーフィールドを送信しないことをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients are also encouraged to consider the use of &#34;Connection: keep-alive&#34; in requests carefully; while they can enable persistent connections with HTTP/1.0 servers, clients using them will need to monitor the connection for &#34;hung&#34; requests (which indicate that the client ought to stop sending the header field), and this mechanism ought not be used by clients at all when a proxy is being used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、クライアントは、リクエストで「接続：維持」の使用を慎重に検討することも奨励されています。HTTP/1.0サーバーとの永続的な接続を有効にすることはできますが、クライアントを使用するクライアントは、「HUNG」要求の接続を監視する必要があります（クライアントがヘッダーフィールドの送信を停止する必要があることを示します）。プロキシが使用されている場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="C-2-3--Introduction-of-Transfer-Encoding">
C.2.3. Introduction of Transfer-Encoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
C.2.3. 転送エンコードの導入
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.1 introduces the Transfer-Encoding header field (Section 6.1). Transfer codings need to be decoded prior to forwarding an HTTP message over a MIME-compliant protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.1では、転送エンコードヘッダーフィールドを導入します（セクション6.1）。MIMEに準拠したプロトコルを介してHTTPメッセージを転送する前に、転送コーディングをデコードする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="C-3--Changes-from-RFC-7230">
C.3. Changes from RFC 7230
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
C.3. RFC 7230からの変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most of the sections introducing HTTP&#39;s design goals, history, architecture, conformance criteria, protocol versioning, URIs, message routing, and header fields have been moved to [HTTP]. This document has been reduced to just the messaging syntax and connection management requirements specific to HTTP/1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPの設計目標、履歴、アーキテクチャ、適合基準、プロトコルバージョン、URIS、メッセージルーティング、ヘッダーフィールドを導入するセクションのほとんどが[HTTP]に移動されました。このドキュメントは、HTTP/1.1に固有のメッセージング構文と接続管理要件のみに削減されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bare CRs have been prohibited outside of content. (Section 2.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
裸のCRSはコンテンツ以外で禁止されています。（セクション2.2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ABNF definition of authority-form has changed from the more general authority component of a URI (in which port is optional) to the specific host:port format that is required by CONNECT. (Section 3.2.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
権限形式のABNF定義は、URIのより一般的な権限コンポーネント（ポートがオプション）から特定のホスト：Connectが必要とするポート形式に変更されました。（セクション3.2.3）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recipients are required to avoid smuggling/splitting attacks when processing an ambiguous message framing. (Section 6.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
曖昧なメッセージフレーミングを処理する際に、密輸/分割攻撃を避ける必要があります。（セクション6.1）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the ABNF for chunked extensions, (bad) whitespace around &#34;;&#34; and &#34;=&#34; has been reintroduced. Whitespace was removed in [RFC7230], but that change was found to break existing implementations. (Section 7.1.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンクされたエクステンションのABNFで、（悪い）白い空間 &#34;;&#34;および「=」は再導入されています。Whitespaceは[RFC7230]で削除されましたが、その変更は既存の実装を破ることがわかった。（セクション7.1.1）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Trailer field semantics now transcend the specifics of chunked transfer coding. The decoding algorithm for chunked (Section 7.1.3) has been updated to encourage storage/forwarding of trailer fields separately from the header section, to only allow merging into the header section if the recipient knows the corresponding field definition permits and defines how to merge, and otherwise to discard the trailer fields instead of merging. The trailer part is now called the trailer section to be more consistent with the header section and more distinct from a body part. (Section 7.1.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トレーラーフィールドセマンティクスは、チャンク転送コーディングの詳細を超越しました。チャンクされたデコードアルゴリズム（セクション7.1.3）は、ヘッダーセクションとは別にトレーラーフィールドのストレージ/転送を促進するために更新されました。、およびマージする代わりにトレーラーフィールドを破棄するため。トレーラーの部分は、ヘッダーセクションとより一貫性があり、身体部分とより明確になるように、トレーラーセクションと呼ばれます。（セクション7.1.2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transfer coding parameters called &#34;q&#34; are disallowed in order to avoid conflicts with the use of ranks in the TE header field. (Section 7.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「Q」と呼ばれる転送コーディングパラメーターは、TEヘッダーフィールドでのランクの使用との競合を回避するために禁止されています。（セクション7.3）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgements
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Appendix &#34;Acknowledgements&#34; of [HTTP], which applies to this document as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[http]の付録「謝辞」を参照してください。これはこのドキュメントにも適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Index
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
索引
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A C D F G H M O R T X
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a c d f g h m o r t x
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
a
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
absolute-form (of request-target) Section 3.2.2 application/http Media Type *_Section 10.2_* asterisk-form (of request-target) Section 3.2.4 authority-form (of request-target) Section 3.2.3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
絶対形式（リクエストターゲットの）セクション3.2.2アプリケーション/HTTPメディアタイプ * _Section 10.2_ * ASTERISK-FORM（リクエストターゲットの）セクション3.2.4 Authority-Form（リクエストターゲットの）セクション3.2.3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
C
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         chunked (Coding Format)  Section 6.1; Section 6.3
         chunked (transfer coding)  *_Section 7.1_*
         close  Section 9.3; *_Section 9.6_*
         compress (transfer coding)  *_Section 7.2_*
         Connection header field  Section 9.6
         Content-Length header field  Section 6.2
         Content-Transfer-Encoding header field  Appendix B.5
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
D
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
d
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
deflate (transfer coding) *_Section 7.2_*
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Deflate（転送コーディング） *_Section 7.2_ *
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
F
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
f
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Fields
            Close  *_Section 9.6, Paragraph 4_*
            MIME-Version  *_Appendix B.1_*
            Transfer-Encoding  *_Section 6.1_*
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
G
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
g
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Grammar
            ALPHA  *_Section 1.2_*
            CR  *_Section 1.2_*
            CRLF  *_Section 1.2_*
            CTL  *_Section 1.2_*
            DIGIT  *_Section 1.2_*
            DQUOTE  *_Section 1.2_*
            HEXDIG  *_Section 1.2_*
            HTAB  *_Section 1.2_*
            HTTP-message  *_Section 2.1_*
            HTTP-name  *_Section 2.3_*
            HTTP-version  *_Section 2.3_*
            LF  *_Section 1.2_*
            OCTET  *_Section 1.2_*
            SP  *_Section 1.2_*
            Transfer-Encoding  *_Section 6.1_*
            VCHAR  *_Section 1.2_*
            absolute-form  Section 3.2; *_Section 3.2.2_*
            asterisk-form  Section 3.2; *_Section 3.2.4_*
            authority-form  Section 3.2; *_Section 3.2.3_*
            chunk  *_Section 7.1_*
            chunk-data  *_Section 7.1_*
            chunk-ext  Section 7.1; *_Section 7.1.1_*
            chunk-ext-name  *_Section 7.1.1_*
            chunk-ext-val  *_Section 7.1.1_*
            chunk-size  *_Section 7.1_*
            chunked-body  *_Section 7.1_*
            field-line  *_Section 5_*; Section 7.1.2
            field-name  Section 5
            field-value  Section 5
            last-chunk  *_Section 7.1_*
            message-body  *_Section 6_*
            method  *_Section 3.1_*
            obs-fold  *_Section 5.2_*
            origin-form  Section 3.2; *_Section 3.2.1_*
            reason-phrase  *_Section 4_*
            request-line  *_Section 3_*
            request-target  *_Section 3.2_*
            start-line  *_Section 2.1_*
            status-code  *_Section 4_*
            status-line  *_Section 4_*
            trailer-section  Section 7.1; *_Section 7.1.2_*
         gzip (transfer coding)  *_Section 7.2_*
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Header Fields MIME-Version *_Appendix B.1_* Transfer-Encoding *_Section 6.1_* header line Section 2.1 header section Section 2.1 headers Section 2.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ヘッダーフィールドMime-version * _Appendix B.1_ *転送エンコード * _Section 6.1_ *ヘッダーラインセクション2.1ヘッダーセクションセクション2.1ヘッダーセクション2.1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
M
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
m
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Media Type
            application/http  *_Section 10.2_*
            message/http  *_Section 10.1_*
         message/http Media Type  *_Section 10.1_*
         method  *_Section 3.1_*
         MIME-Version header field  *_Appendix B.1_*
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
O
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
o
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
origin-form (of request-target) Section 3.2.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
起源形式（リクエストターゲットの）セクション3.2.1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
R
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
r
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
request-target *_Section 3.2_*
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
リクエストターゲット *_セクション3.2_ *
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
T
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
t
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Transfer-Encoding header field *_Section 6.1_*
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
転送エンコードヘッダーフィールド *_Section 6.1_ *
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
X
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
バツ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         x-compress (transfer coding)  *_Section 7.2_*
         x-gzip (transfer coding)  *_Section 7.2_*
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Roy T. Fielding (editor) Adobe 345 Park Ave San Jose, CA 95110 United States of America Email: fielding@gbiv.com URI: https://roy.gbiv.com/
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Roy T. Fielding（編集者）Adobe 345 Park Ave San Jose、CA 95110アメリカ合衆国電子メール：Fielding@gbiv.com URI：https：//roy.gbiv.com/
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mark Nottingham (editor) Fastly Prahran Australia Email: mnot@mnot.net URI: https://www.mnot.net/
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マーク・ノッティンガム（編集者）急速にPrahran Australiaメール：mnot@mnot.net uri：https：//www.mnot.net/
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Julian Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   48155 Münster
   Germany
   Email: julian.reschke@greenbytes.de
   URI:   https://greenbytes.de/tech/webdav/
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
