<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 4038 - Application Aspects of IPv6 Transition 日本語訳</title>
  <meta name="description" content="要約：RFC 4038は、IPv6移行のアプリケーションの側面に関するガイドラインです。IPv6移行におけるアプリケーションの課題と解決策に焦点を当てています。目的：このRFCの目的は、IPv6移行においてアプリケーションが直面する問題を理解し、効果的な解決策を提供することです。">
  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="./master.css">
  <script src="./index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">4038</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc4038">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 4038 - Application Aspects of IPv6 Transition 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc4038">
            https://datatracker.ietf.org/doc/html/rfc4038
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 4038 - IPv6遷移のアプリケーションの側面</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <p class="card-text">[要約] 要約：RFC 4038は、IPv6移行のアプリケーションの側面に関するガイドラインです。IPv6移行におけるアプリケーションの課題と解決策に焦点を当てています。目的：このRFCの目的は、IPv6移行においてアプリケーションが直面する問題を理解し、効果的な解決策を提供することです。</p>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                     M-K. Shin, Ed.
Request for Comments: 4038                                     ETRI/NIST
Category: Informational                                        Y-G. Hong
                                                                    ETRI
                                                               J. Hagino
                                                                     IIJ
                                                               P. Savola
                                                               CSC/FUNET
                                                            E. M. Castro
                                                               GSYC/URJC
                                                              March 2005
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
Application Aspects of IPv6 Transition
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
IPv6遷移のアプリケーションの側面
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、インターネットコミュニティに情報を提供します。いかなる種類のインターネット標準を指定しません。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2005).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）The Internet Society（2005）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As IPv6 networks are deployed and the network transition is discussed, one should also consider how to enable IPv6 support in applications running on IPv6 hosts, and the best strategy to develop IP protocol support in applications. This document specifies scenarios and aspects of application transition. It also proposes guidelines on how to develop IP version-independent applications during the transition period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6ネットワークが展開され、ネットワークトランジションが議論されるため、IPv6ホストで実行されているアプリケーションでIPv6サポートを有効にする方法を検討する必要があります。このドキュメントは、アプリケーションの移行のシナリオと側面を指定します。また、移行期間中にIPバージョンに依存しないアプリケーションを開発する方法に関するガイドラインを提案しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction .................................................  3
   2.  Overview of IPv6 Application Transition ......................  3
   3.  Problems with IPv6 Application Transition ....................  5
       3.1.  IPv6 Support in the OS and Applications Are Unrelated...  5
       3.2.  DNS Does Not Indicate Which IP Version Will Be Used ....  6
       3.3.  Supporting Many Versions of an Application Is Difficult.  6
   4.  Description of Transition Scenarios and Guidelines ...........  7
       4.1.  IPv4 Applications in a Dual-Stack Node .................  7
       4.2.  IPv6 Applications in a Dual-Stack Node .................  8
       4.3.  IPv4/IPv6 Applications in a Dual-Stack Node ............ 11
       4.4.  IPv4/IPv6 Applications in an IPv4-only Node ............ 12
   5.  Application Porting Considerations ........................... 12
       5.1.  Presentation Format for an IP Address .................. 13
       5.2.  Transport Layer API .................................... 14
       5.3.  Name and Address Resolution ............................ 15
       5.4.  Specific IP Dependencies ............................... 16
             5.4.1.  IP Address Selection ........................... 16
             5.4.2.  Application Framing ............................ 16
             5.4.3.  Storage of IP addresses ........................ 17
       5.5.  Multicast Applications ................................. 17
   6.  Developing IP Version - Independent Applications ............. 18
       6.1.  IP Version - Independent Structures..................... 18
       6.2.  IP Version - Independent APIs........................... 19
             6.2.1.  Example of Overly Simplistic TCP Server
                     Application .................................... 20
             6.2.2.  Example of Overly Simplistic TCP Client
                     Application .................................... 21
             6.2.3.  Binary/Presentation Format Conversion .......... 22
       6.3.  Iterated Jobs for Finding the Working Address .......... 23
             6.3.1.  Example of TCP Server Application .............. 23
             6.3.2.  Example of TCP Client Application .............. 25
   7.  Transition Mechanism Considerations .......................... 26
   8.  Security Considerations ...................................... 26
   9.  Acknowledgments .............................................. 27
   10. References ................................................... 27
   Appendix A.  Other Binary/Presentation Format Conversions ........ 30
       A.1.  Binary to Presentation Using inet_ntop() ............... 30
       A.2.  Presentation to Binary Using inet_pton() ............... 31
   Authors&#39; Addresses ............................................... 32
   Full Copyright Statement ......................................... 33
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As IPv6 is introduced in the IPv4-based Internet, several general issues will arise, such as routing, addressing, DNS, and scenarios.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6がIPv4ベースのインターネットで導入されると、ルーティング、アドレス指定、DNS、シナリオなど、いくつかの一般的な問題が発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An important key to a successful IPv6 transition is compatibility with the large installed base of IPv4 hosts and routers. This issue has already been extensively studied, and work is still in progress. [2893BIS] describes the basic transition mechanisms: dual-stack deployment and tunneling. Various other kinds of mechanisms have been developed for the transition to an IPv6 network. However, these transition mechanisms take no stance on whether applications support IPv6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6遷移を成功させるための重要な鍵は、IPv4ホストとルーターの大きな設置ベースとの互換性です。この問題はすでに広範囲に研究されており、作業はまだ進行中です。[2893bis]は、基本的な遷移メカニズム：デュアルスタックの展開とトンネリングについて説明しています。IPv6ネットワークへの移行のために、他のさまざまな種類のメカニズムが開発されています。ただし、これらの遷移メカニズムは、アプリケーションがIPv6をサポートするかどうかについての姿勢をとっていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies application aspects of IPv6 transition. Two inter-related topics are covered:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、IPv6遷移のアプリケーションの側面を指定します。相互に関連する2つのトピックがカバーされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. How different network transition techniques affect applications, and strategies for applications to support IPv6 and IPv4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. 異なるネットワーク遷移手法がアプリケーションにどのように影響するか、およびIPv6とIPv4をサポートするアプリケーションの戦略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. How to develop IPv6-capable or protocol-independent applications (&#34;application porting guidelines&#34;) using standard APIs [RFC3493][RFC3542].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. 標準API [RFC3493] [RFC3542]を使用して、IPv6対応またはプロトコル非依存性アプリケーション（「アプリケーションポーティングガイドライン」）を開発する方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the context of this document, the term &#34;application&#34; covers all kinds of applications, but the focus is on those network applications which have been developed using relatively low-level APIs (such as the &#34;C&#34; language, using standard libraries). Many such applications could be command-line driven, but that is not a requirement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントのコンテキストでは、「アプリケーション」という用語はあらゆる種類のアプリケーションをカバーしていますが、比較的低レベルのAPI（標準ライブラリを使用して「C」言語など）を使用して開発されたネットワークアプリケーションに焦点が当てられています。そのようなアプリケーションの多くはコマンドライン駆動型かもしれませんが、それは要件ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications will have to be modified to support IPv6 (and IPv4) by using one of a number of techniques described in sections 2 - 4. Guidelines for developing such applications are presented in sections 5 and 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション2-4で説明されている多くの手法のいずれかを使用して、IPv6（およびIPv4）をサポートするためにアプリケーションを変更する必要があります。このようなアプリケーションを開発するためのガイドラインは、セクション5および6に示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Overview-of-IPv6-Application-Transition">
2. Overview of IPv6 Application Transition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. IPv6アプリケーションの遷移の概要
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The transition of an application can be classified by using four different cases (excluding the first case when there is no IPv6 support in either the application or the operating system):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションの遷移は、4つの異なるケースを使用して分類できます（アプリケーションまたはオペレーティングシステムのいずれにもIPv6サポートがない場合の最初のケースを除く）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +-------------------+
      |       appv4       | (appv4 - IPv4-only applications)
      +-------------------+
      | TCP / UDP / others| (transport protocols - TCP, UDP,
      +-------------------+  SCTP, DCCP, etc.)
      |    IPv4 | IPv6    | (IP protocols supported/enabled in the OS)
      +-------------------+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Case 1. IPv4 applications in a dual-stack node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ケース1.デュアルスタックノードのIPv4アプリケーション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +-------------------+ (appv4 - IPv4-only applications)
      |  appv4  |  appv6  | (appv6 - IPv6-only applications)
      +-------------------+
      | TCP / UDP / others| (transport protocols - TCP, UDP,
      +-------------------+             SCTP, DCCP, etc.)
      |    IPv4 | IPv6    | (IP protocols supported/enabled in the OS)
      +-------------------+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Case 2. IPv4-only applications and IPv6-only applications in a dual-stack node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ケース2.デュアルスタックノードのIPv4のみのアプリケーションとIPv6のみのアプリケーション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +-------------------+
      |     appv4/v6      | (appv4/v6 - applications supporting
      +-------------------+             both IPv4 and IPv6)
      | TCP / UDP / others| (transport protocols - TCP, UDP,
      +-------------------+             SCTP, DCCP, etc.)
      |    IPv4 | IPv6    | (IP protocols supported/enabled in the OS)
      +-------------------+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Case 3. Applications supporting both IPv4 and IPv6 in a dual-stack node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ケース3.デュアルスタックノードでIPv4とIPv6の両方をサポートするアプリケーション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +-------------------+
      |     appv4/v6      | (appv4/v6 - applications supporting
      +-------------------+             both IPv4 and IPv6)
      | TCP / UDP / others| (transport protocols - TCP, UDP,
      +-------------------+             SCTP, DCCP, etc.)
      |       IPv4        | (IP protocols supported/enabled in the OS)
      +-------------------+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Case 4. Applications supporting both IPv4 and IPv6 in an IPv4-only node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ケース4. IPv4のみのノードでIPv4とIPv6の両方をサポートするアプリケーション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Figure 1. Overview of Application Transition
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
図1.アプリケーションの遷移の概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Figure 1 shows the cases of application transition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
図1は、アプリケーション遷移のケースを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Case 1: IPv4-only applications in a dual-stack node. IPv6 protocol is introduced in a node, but applications are not yet ported to support IPv6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ケース1：デュアルスタックノードのIPv4のみのアプリケーション。IPv6プロトコルはノードで導入されていますが、アプリケーションはまだIPv6をサポートするために移植されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Case 2: IPv4-only applications and IPv6-only applications in a dual-stack node. Applications are ported for IPv6-only. Therefore there are two similar applications, one for each protocol version (e.g., ping and ping6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ケース2：デュアルスタックノードのIPv4のみのアプリケーションとIPv6のみのアプリケーション。アプリケーションはIPv6のみに移植されます。したがって、2つの同様のアプリケーションがあります。1つは各プロトコルバージョン（PingおよびPing6など）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Case 3: Applications supporting both IPv4 and IPv6 in a dual stack node. Applications are ported for both IPv4 and IPv6 support. Therefore, the existing IPv4 applications can be removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ケース3：デュアルスタックノードでIPv4とIPv6の両方をサポートするアプリケーション。アプリケーションは、IPv4サポートとIPv6サポートの両方に移植されます。したがって、既存のIPv4アプリケーションを削除できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Case 4: Applications supporting both IPv4 and IPv6 in an IPv4-only node. Applications are ported for both IPv4 and IPv6 support, but the same applications may also have to work when IPv6 is not being used (e.g., disabled from the OS).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ケース4：IPv4のみのノードでIPv4とIPv6の両方をサポートするアプリケーション。アプリケーションはIPv4サポートとIPv6サポートの両方に移植されますが、IPv6が使用されていない場合に同じアプリケーションも機能する必要があります（OSから無効になっています）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first two cases are not interesting in the longer term; only few applications are inherently IPv4- or IPv6-specific, and should work with both protocols without having to care about which one is being used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の2つのケースは長期的には興味深いものではありません。本質的にIPv4-またはIPv6固有のアプリケーションはわずかであり、どちらが使用されているかを気にせずに両方のプロトコルで動作する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Problems-with-IPv6-Application-Transition">
3. Problems with IPv6 Application Transition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. IPv6アプリケーションの遷移の問題
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are several reasons why the transition period between IPv4 and IPv6 applications may not be straightforward. These issues are described in this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv4アプリケーションとIPv6アプリケーションの間の遷移期間が簡単ではない理由はいくつかあります。これらの問題については、このセクションで説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--IPv6-Support-in-the-OS-and-Applications-Are-Unrelated">
3.1. IPv6 Support in the OS and Applications Are Unrelated
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. OSおよびアプリケーションでのIPv6サポートは無関係です
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Considering the cases described in the previous section, IPv4 and IPv6 protocol stacks are likely to co-exist in a node for a long time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前のセクションで説明したケースを考慮すると、IPv4およびIPv6プロトコルスタックは、長い間ノードに共存する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, most applications are expected to be able to handle both IPv4 and IPv6 during another long period. A dual-stack operating system is not intended to have both IPv4 and IPv6 applications. Therefore, IPv6-capable application transition may be independent of protocol stacks in a node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、ほとんどのアプリケーションは、別の長期にわたってIPv4とIPv6の両方を処理できることが期待されています。デュアルスタックオペレーティングシステムは、IPv4アプリケーションとIPv6アプリケーションの両方を搭載することを目的としていません。したがって、IPv6対応アプリケーションの遷移は、ノード内のプロトコルスタックとは無関係になる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications capable of both IPv4 and IPv6 will probably have to work properly in IPv4-only nodes (whether the IPv6 protocol is completely disabled or there is no IPv6 connectivity at all).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv4とIPv6の両方が可能なアプリケーションは、おそらくIPv4のみのノードで適切に動作する必要があります（IPv6プロトコルが完全に無効になっているか、IPv6接続がまったくないかどうか）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--DNS-Does-Not-Indicate-Which-IP-Version-Will-Be-Used">
3.2. DNS Does Not Indicate Which IP Version Will Be Used
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. DNSは、どのIPバージョンが使用されるかを示していません
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a node, the DNS name resolver gathers the list of destination addresses. DNS queries and responses are sent by using either IPv4 or IPv6 to carry the queries, regardless of the protocol version of the data records [DNSTRANS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードでは、DNS名リゾルバーが宛先アドレスのリストを収集します。DNSクエリと応答は、データレコード[DNSTRANS]のプロトコルバージョンに関係なく、IPv4またはIPv6のいずれかを使用してクエリを運ぶことにより送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DNS name resolution issue related to application transition is that by only doing a DNS name lookup a client application can not be certain of the version of the peer application. For example, if a server application does not support IPv6 yet but runs on a dual-stack machine for other IPv6 services, and this host is listed with an AAAA record in the DNS, the client application will fail to connect to the server application. This is caused by a mismatch between the DNS query result (i.e., IPv6 addresses) and a server application version (i.e., IPv4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションの移行に関連するDNS名解決の問題は、DNS名を検索するだけで、クライアントアプリケーションがピアアプリケーションのバージョンを確信できないということです。たとえば、サーバーアプリケーションがまだIPv6をサポートせず、他のIPv6サービスのデュアルスタックマシンで実行している場合、このホストはDNSのAAAAレコードでリストされている場合、クライアントアプリケーションはサーバーアプリケーションに接続できません。これは、DNSクエリ結果（つまり、IPv6アドレス）とサーバーアプリケーションバージョン（つまり、IPv4）の間の不一致によって引き起こされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using SRV records would avoid these problems. Unfortunately, they are not used widely enough to be applicable in most cases. Hence an operational solution is to use &#34;service names&#34; in the DNS. If a node offers multiple services, but only some of them over IPv6, a DNS name may be added for each of these services or group of services (with the associated A/AAAA records), not just a single name for the physical machine, also including the AAAA records. However, the applications cannot depend on this operational practice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SRVレコードを使用すると、これらの問題が回避されます。残念ながら、それらはほとんどの場合に適用できるほど広く使用されていません。したがって、運用ソリューションは、DNSで「サービス名」を使用することです。ノードが複数のサービスを提供しているが、その一部のみがIPv6を介して提供している場合、これらのサービスまたはグループ（関連するA/AAAAレコードを使用）の各サービスに対してDNS名を追加できます。物理マシンの単一の名前だけでなく、AAAAレコードも含まれます。ただし、アプリケーションはこの運用慣行に依存することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The application should request all IP addresses without address family constraints and try all the records returned from the DNS, in some order, until a working address is found. In particular, the application has to be able to handle all IP versions returned from the DNS. This issue is discussed in more detail in [DNSOPV6].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、家族の制約なしですべてのIPアドレスを要求し、作業アドレスが見つかるまでDNSから返されたすべてのレコードをある程度試してみてください。特に、アプリケーションは、DNSから返されるすべてのIPバージョンを処理できる必要があります。この問題については、[dnsopv6]で詳細に説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3--Supporting-Many-Versions-of-an-Application-is-Difficult">
3.3. Supporting Many Versions of an Application is Difficult
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. アプリケーションの多くのバージョンをサポートすることは困難です
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During the application transition period, system administrators may have various versions of the same application (an IPv4-only application, an IPv6-only application, or an application supporting both IPv4 and IPv6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションの移行期間中、システム管理者は同じアプリケーションのさまざまなバージョン（IPv4のみのアプリケーション、IPv6のみのアプリケーション、またはIPv4とIPv6の両方をサポートするアプリケーション）を持っている場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Typically one cannot know which IP versions must be supported prior to doing a DNS lookup *and* trying (see section 3.2) the addresses returned. Therefore if multiple versions of the same application are available, the local users have difficulty selecting the right version supporting the exact IP version required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、DNSルックアップ *および *試行（セクション3.2を参照）を実行する前に、どのIPバージョンをサポートする必要があるかを知ることはできません。したがって、同じアプリケーションの複数のバージョンが利用可能な場合、ローカルユーザーは必要な正確なIPバージョンをサポートする適切なバージョンを選択するのが困難です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid problems with one application not supporting the specified protocol version, it is desirable to have hybrid applications supporting both.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたプロトコルバージョンをサポートしていない1つのアプリケーションの問題を回避するには、両方をサポートするハイブリッドアプリケーションを持つことが望ましいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An alternative approach for local client applications could be to have a &#34;wrapper application&#34; that performs certain tasks (such as figuring out which protocol version will be used) and calls the IPv4/IPv6-only applications as necessary. This application would perform connection establishment (or similar tasks) and pass the opened socket to another application. However, as applications such as this would have to do more than just perform a DNS lookup or determine the literal IP address given, they will become complex -- likely much more so than a hybrid application. Furthermore, writing &#34;wrapping&#34; applications that perform complex operations with IP addresses (such as FTP clients) might be even more challenging or even impossible. In short, wrapper applications do not look like a robust approach for application transition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ローカルクライアントアプリケーションの代替アプローチは、特定のタスク（どのプロトコルバージョンが使用されるかを把握するなど）を実行し、必要に応じてIPv4/IPv6のみのアプリケーションを呼び出す「ラッパーアプリケーション」を持つことです。このアプリケーションは、接続確立（または同様のタスク）を実行し、開いたソケットを別のアプリケーションに渡します。ただし、このようなアプリケーションは、DNSルックアップを実行したり、指定された文字通りのIPアドレスを決定する以上のことを行う必要があるため、複雑になります。ハイブリッドアプリケーションよりもはるかに多いでしょう。さらに、IPアドレス（FTPクライアントなど）で複雑な操作を実行する「ラッピング」アプリケーションを作成することは、さらに挑戦的または不可能でさえあります。要するに、ラッパーアプリケーションは、アプリケーション遷移の堅牢なアプローチのようには見えません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Description-of-Transition-Scenarios-and-Guidelines">
4. Description of Transition Scenarios and Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 移行シナリオとガイドラインの説明
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the IPv6 network is deployed, applications supporting IPv6 can use IPv6 network services to establish IPv6 connections. However, upgrading every node to IPv6 at the same time is not feasible, and transition from IPv4 to IPv6 will be a gradual process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6ネットワークが展開されると、IPv6ネットワークをサポートするアプリケーションはIPv6ネットワークサービスを使用してIPv6接続を確立できます。ただし、すべてのノードを同時にIPv6にアップグレードすることは実行不可能であり、IPv4からIPv6への移行は段階的なプロセスになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Dual-stack nodes provide one solution to maintaining IPv4 compatibility in unicast communications. In this section we will analyze different application transition scenarios (as introduced in section 2) and guidelines for maintaining interoperability between applications running in different types of nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デュアルスタックノードは、ユニキャスト通信におけるIPv4互換性を維持するための1つのソリューションを提供します。このセクションでは、さまざまなアプリケーション遷移シナリオ（セクション2で導入されている）と、さまざまなタイプのノードで実行されているアプリケーション間の相互運用性を維持するためのガイドラインを分析します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the first two cases, IPv4-only and IPv6-only applications, are not interesting in the longer term; only few applications are inherently IPv4- or IPv6-specific, and should work with both protocols without having to care about which one is being used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の2つのケース、IPv4のみのアプリケーションとIPv6のみのアプリケーションは、長期的には興味深いものではないことに注意してください。本質的にIPv4-またはIPv6固有のアプリケーションはわずかであり、どちらが使用されているかを気にせずに両方のプロトコルで動作する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--IPv4-Applications-in-a-Dual-Stack-Node">
4.1. IPv4 Applications in a Dual-Stack Node
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. デュアルスタックノードのIPv4アプリケーション
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this scenario, the IPv6 protocol is added in a node, but IPv6- capable applications aren&#39;t yet available or installed. Although the node implements the dual stack, IPv4 applications can only manage IPv4 communications and accept/establish connections from/to nodes that implement an IPv4 stack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このシナリオでは、IPv6プロトコルはノードに追加されますが、IPv6-有能なアプリケーションはまだ利用可能またはインストールされていません。ノードはデュアルスタックを実装していますが、IPv4アプリケーションはIPv4通信のみを管理し、IPv4スタックを実装するノードからの接続を受け入れる/確立できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To allow an application to communicate with other nodes using IPv6, the first priority is to port applications to IPv6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションがIPv6を使用して他のノードと通信できるようにするために、最優先事項はアプリケーションをIPv6にポートすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some cases (e.g., when no source code is available), existing IPv4 applications can work if the Bump-in-the-Stack [BIS] or Bump-in-the-API [BIA] mechanism is installed in the node. We strongly recommend that application developers not use these mechanisms when application source code is available. Also, they should not be used as an excuse not to port software or to delay porting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
場合によっては（たとえば、ソースコードが利用できない場合）、既存のIPv4アプリケーションは、ノードにバンプイン[BIS]またはBump-in-api [BIA]メカニズムがノードにインストールされている場合に機能します。アプリケーションソースコードが利用可能な場合、アプリケーション開発者はこれらのメカニズムを使用しないことを強くお勧めします。また、それらは、ソフトウェアを移植したり、移植を遅らせたりしない言い訳として使用すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When [BIA] or [BIS] is used, the problem described in section 3.2 arises - (the IPv4 client in a [BIS]/[BIA] node tries to connect to an IPv4 server in a dual stack system). However, one can rely on the [BIA]/[BIS] mechanism, which should cycle through all the addresses instead of applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BIA]または[BIS]を使用すると、セクション3.2で説明されている問題が発生します（[BIS]/[BIA]ノードのIPv4クライアントは、デュアルスタックシステムのIPv4サーバーに接続しようとします）。ただし、[bia]/[bis]メカニズムに依存することができます。これは、アプリケーションではなくすべてのアドレスを循環する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BIS] and [BIA] do not work with all kinds of applications - in particular, with applications that exchange IP addresses as application data (e.g., FTP). These mechanisms provide IPv4 temporary addresses to the applications and locally make a translation between IPv4 and IPv6 communication. Therefore, these IPv4 temporary addresses are only valid in the node scope.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BIS]および[BIA]は、あらゆる種類のアプリケーション、特にアプリケーションデータ（FTPなど）としてIPアドレスを交換するアプリケーションでは機能しません。これらのメカニズムは、アプリケーションにIPv4の一時的なアドレスを提供し、IPv4とIPv6通信の間の翻訳を局所的に作成します。したがって、これらのIPv4の一時アドレスは、ノードスコープでのみ有効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2--IPv6-Applications-in-a-Dual-Stack-Node">
4.2. IPv6 Applications in a Dual-Stack Node
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. デュアルスタックノードのIPv6アプリケーション
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As we have seen in the previous section, applications should be ported to IPv6. The easiest way to port an IPv4 application is to substitute the old IPv4 API references with the new IPv6 APIs with one-to-one mapping. This way the application will be IPv6-only. This IPv6-only source code cannot work in IPv4-only nodes, so the old IPv4 application should be maintained in these nodes. This necessitates having two similar applications working with different protocol versions, depending on the node they are running (e.g., telnet and telnet6). This case is undesirable, as maintaining two versions of the same source code per application could be difficult. This approach would also cause problems for users having to select which version of the application to use, as described in section 3.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前のセクションで見たように、アプリケーションはIPv6に移植する必要があります。IPv4アプリケーションをポートする最も簡単な方法は、古いIPv4 API参照を新しいIPv6 APIに1対1のマッピングに置き換えることです。このようにして、アプリケーションはIPv6のみになります。このIPv6のみのソースコードは、IPv4のみのノードでは動作できないため、古いIPv4アプリケーションをこれらのノードに維持する必要があります。これには、実行中のノード（たとえば、TelnetやTelnet6）に応じて、異なるプロトコルバージョンで動作する2つの同様のアプリケーションが必要です。このケースは望ましくありません。アプリケーションごとに同じソースコードの2つのバージョンを維持することは困難な場合があります。また、このアプローチは、セクション3.3で説明されているように、使用するアプリケーションのバージョンを選択する必要があるユーザーに問題を引き起こします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most implementations of dual stack allow IPv6-only applications to interoperate with both IPv4 and IPv6 nodes. IPv4 packets going to IPv6 applications on a dual-stack node reach their destination because their addresses are mapped by using IPv4-mapped IPv6 addresses: the IPv6 address ::FFFF:x.y.z.w represents the IPv4 address x.y.z.w.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デュアルスタックのほとんどの実装により、IPv6のみのアプリケーションがIPv4ノードとIPv6ノードの両方と相互操作できます。IPv4-Mapped IPv6アドレスを使用してアドレスがマッピングされるため、デュアルスタックノードのIPv6アプリケーションに到達するIPv4アプリケーションが宛先に到達します。IPv6アドレス:: ffff：x.y.z.wは、IPv4アドレスX.Y.Z.Wを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +----------------------------------------------+
      | +------------------------------------------+ |
      | |                                          | |
      | |        IPv6-only applications            | |
      | |                                          | |
      | +------------------------------------------+ |
      |                      |                       |
      | +------------------------------------------+ |
      | |                                          | |
      | |   TCP / UDP / others (SCTP, DCCP, etc.)  | |
      | |                                          | |
      | +------------------------------------------+ |
      |    IPv4-mapped    |        |    IPv6         |
      |  IPv6 addresses   |        |   addresses     |
      | +--------------------+ +-------------------+ |
      | |        IPv4        | |      IPv6         | |
      | +--------------------+ +-------------------+ |
      |   IPv4       |                 |             |
      |   addresses  |                 |             |
      +--------------|-----------------|-------------+
                     |                 |
                IPv4 packets      IPv6 packets
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We will analyze the behaviour of IPv6-applications that exchange IPv4 packets with IPv4 applications by using the client/server model. We consider the default case to be when the IPV6_V6ONLY socket option has not been set. In these dual-stack nodes, this default behavior allows a limited amount of IPv4 communication using the IPv4-mapped IPv6 addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント/サーバーモデルを使用して、IPv4パケットをIPv4アプリケーションと交換するIPv6アプリケーションの動作を分析します。デフォルトのケースは、IPv6_V6onlyソケットオプションが設定されていない場合と考えられます。これらのデュアルスタックノードでは、このデフォルトの動作により、IPv4-Mapped IPv6アドレスを使用して、限られた量のIPv4通信が可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IPv6-only server: When an IPv4 client application sends data to an IPv6-only server application running on a dual-stack node by using the wildcard address, the IPv4 client address is interpreted as the IPv4-mapped IPv6 address in the dual-stack node. This allows the IPv6 application to manage the communication. The IPv6 server will use this mapped address as if it were a regular IPv6 address, and a usual IPv6 connection. However, IPv4 packets will be exchanged between the nodes. Kernels with dual stack properly interpret IPv4-mapped IPv6 addresses as IPv4 ones, and vice versa.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IPv6のみのサーバー：IPv4クライアントアプリケーションがWildCardアドレスを使用してデュアルスタックノードで実行されているIPv6のみのサーバーアプリケーションにデータを送信すると、IPv4クライアントアドレスはデュアルスタックのIPv4マップIPv6アドレスとして解釈されますノード。これにより、IPv6アプリケーションが通信を管理できます。IPv6サーバーは、このマッピングされたアドレスを通常のIPv6アドレスであり、通常のIPv6接続であるかのように使用します。ただし、IPv4パケットはノード間で交換されます。デュアルスタックを備えたカーネルは、IPv4-Mapped IPv6アドレスをIPv4のアドレスとして適切に解釈し、その逆も同様です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IPv6-only client: IPv6-only client applications in a dual-stack node will not receive IPv4-mapped addresses from the hostname resolution API functions unless a special hint, AI_V4MAPPED, is given. If it is, the IPv6 client will use the returned mapped address as if it were a regular IPv6 address, and a usual IPv6 connection. However, IPv4 packets will be exchanged between applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IPv6のみのクライアント：デュアルスタックノードのIPv6のみのクライアントアプリケーションは、特別なヒント、AI_V4Mappedが与えられない限り、ホスト名解像度API関数からIPv4マップのアドレスを受信しません。もしそうなら、IPv6クライアントは、通常のIPv6アドレスと通常のIPv6接続であるかのように、返されたマッピングアドレスを使用します。ただし、IPv4パケットはアプリケーション間で交換されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Respectively, with IPV6_V6ONLY set, an IPv6-only server application will only communicate with IPv6 nodes, and an IPv6-only client only with IPv6 servers, as the mapped addresses have been disabled. This option could be useful if applications use new IPv6 features such as Flow Label. If communication with IPv4 is needed, either IPV6_V6ONLY must not be used, or dual-stack applications must be used, as described in section 4.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それぞれIPv6_v6onlyセットを使用すると、IPv6のみのサーバーアプリケーションは、マッピングされたアドレスが無効になっているため、IPv6ノードとIPv6のみのクライアントのみをIPv6サーバーでのみ通信します。このオプションは、アプリケーションがフローラベルなどの新しいIPv6機能を使用する場合に役立ちます。IPv4との通信が必要な場合は、セクション4.3で説明されているように、IPv6_v6onlyを使用する必要はないか、デュアルスタックアプリケーションを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some implementations of dual-stack do not allow IPv4-mapped IPv6 addresses to be used for interoperability between IPv4 and IPv6 applications. In these cases, there are two ways to handle the problem:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デュアルスタックのいくつかの実装では、IPv4アプリケーションとIPv6アプリケーション間の相互運用性にIPv4-MappのIPv6アドレスを使用することはできません。これらの場合、問題を処理するには2つの方法があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. Deploy two different versions of the application (possibly attached with &#39;6&#39; in the name).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. アプリケーションの2つの異なるバージョンを展開します（名前に「6」で添付されます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. Deploy just one application supporting both protocol versions as described in the next section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. 次のセクションで説明されているように、両方のプロトコルバージョンをサポートするアプリケーションを1つだけ展開します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first method is not recommended because of a significant number of problems associated with selecting the right applications. These problems are described in sections 3.2 and 3.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
適切なアプリケーションの選択に関連するかなりの数の問題があるため、最初の方法は推奨されません。これらの問題は、セクション3.2および3.3で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, there are two distinct cases to consider when writing one application to support both protocols:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、両方のプロトコルをサポートするために1つのアプリケーションを作成する際に考慮すべき2つの異なるケースがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. Whether the application can (or should) support both IPv4 and IPv6 through IPv4-mapped IPv6 addresses or the applications should support both explicitly (see section 4.3), and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. アプリケーションがIPv4とIPv6の両方をサポートできる（またはIPv4とIPv6の両方がIPv6アドレスをサポートできるかどうか、またはアプリケーションが明示的にサポートする必要があります（セクション4.3を参照）、および
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. Whether the systems in which the applications are used support IPv6 (see section 4.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. アプリケーションが使用されるシステムがIPv6をサポートするかどうか（セクション4.4を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that some systems will disable (by default) support for internal IPv4-mapped IPv6 addresses. The security concerns regarding these are legitimate, but disabling them internally breaks one transition mechanism for server applications originally written to bind() and listen() to a single socket by using a wildcard address. This forces the software developer to rewrite the daemon to create two separate sockets, one for IPv4 only and the other for IPv6 only, and then to use select(). However, mapping-enabling of IPv4 addresses on any particular system is controlled by the OS owner and not necessarily by a developer. This complicates developers&#39; work, as they now have to rewrite the daemon network code to handle both environments, even for the same OS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のシステムは、内部IPv4マップIPv6アドレスの（デフォルトで）サポートを無効にすることに注意してください。これらに関するセキュリティの懸念は正当なものですが、それらを無効にすると、ワイルドカードアドレスを使用して、bind（）およびlisten（）に単一のソケットに当初書かれたサーバーアプリケーションの1つの遷移メカニズムが内部的に破損します。これにより、ソフトウェア開発者はデーモンを書き換えて2つの別々のソケットを作成するようになります。1つはIPv4のみ、もう1つはIPv6のみで、次にSelect（）を使用します。ただし、特定のシステムでのIPv4アドレスのマッピングエバレーションは、OSの所有者によって制御され、必ずしも開発者によってではありません。これにより、開発者の作業が複雑になります。これは、同じOSであっても、両方の環境を処理するためにデーモンネットワークコードを書き直す必要があるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3--IPv4IPv6-Applications-in-a-Dual-Stack-Node">
4.3. IPv4/IPv6 Applications in a Dual-Stack Node
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. デュアルスタックノードのIPv4/IPv6アプリケーション
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications should be ported to support both IPv4 and IPv6. Over time, the existing IPv4-only applications could be removed. As we have only one version of each application, the source code will typically be easy to maintain and to modify, and there are no problems managing which application to select for which communication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、IPv4とIPv6の両方をサポートするために移植する必要があります。時間が経つにつれて、既存のIPv4のみのアプリケーションを削除できます。各アプリケーションのバージョンは1つしかないため、ソースコードは通常、メンテナンスと変更が容易であり、どのアプリケーションを選択するかを選択するのに問題はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This transition case is the most advisable. During the IPv6 transition period, applications supporting both IPv4 and IPv6 should be able to communicate with other applications, irrespective of the version of the protocol stack or the application in the node. Dual applications allow more interoperability between heterogeneous applications and nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この遷移ケースは最も推奨されます。IPv6遷移期間中、IPv4とIPv6の両方をサポートするアプリケーションは、プロトコルスタックのバージョンやノード内のアプリケーションに関係なく、他のアプリケーションと通信できるはずです。デュアルアプリケーションにより、不均一なアプリケーションとノード間の相互運用性が向上します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the source code is written in a protocol-independent way, without dependencies on either IPv4 or IPv6, applications will be able to communicate with any combination of applications and types of nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースコードがIPv4またはIPv6のいずれかに依存せずにプロトコルに依存しない方法で記述されている場合、アプリケーションはアプリケーションとノードのタイプの任意の組み合わせと通信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations typically prefer IPv6 by default if the remote node and application support it. However, if IPv6 connections fail, version-independent applications will automatically try IPv4 ones. The resolver returns a list of valid addresses for the remote node, and applications can iterate through all of them until connection succeeds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、実装は、リモートノードとアプリケーションがサポートする場合、デフォルトではデフォルトでIPv6を好みます。ただし、IPv6接続が失敗した場合、バージョンに依存しないアプリケーションは自動的にIPv4のアプリケーションを試します。Resolverは、リモートノードの有効なアドレスのリストを返し、アプリケーションは接続が成功するまですべてを繰り返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Application writers should be aware of this protocol ordering, which is typically the default, but the applications themselves usually need not be [RFC3484].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションライターは、通常はデフォルトであるこのプロトコルの順序に注意する必要がありますが、アプリケーション自体は通常[RFC3484]である必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the source code is written in a protocol-dependent way, the application will support IPv4 and IPv6 explicitly by using two separate sockets. Note that there are some differences in bind() implementation - that is, in whether one can first bind to IPv6 wildcard addresses, and then to those for IPv4. Writing applications that cope with this can be a pain. Implementing IPV6_V6ONLY simplifies this. The IPv4 wildcard bind fails on some systems because the IPv4 address space is embedded into IPv6 address space when IPv4-mapped IPv6 addresses are used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースコードがプロトコル依存的に記述されている場合、アプリケーションは2つの別々のソケットを使用してIPv4とIPv6を明示的にサポートします。bind（）実装にはいくつかの違いがあることに注意してください。つまり、最初にIPv6ワイルドカードアドレスにバインドできるかどうか、次にIPv4の違いがあるかどうかに注意してください。これに対処するアプリケーションを書くことは痛みになる可能性があります。IPv6_v6onlyを実装すると、これが簡素化されます。IPv4アドレススペースがIPv4マップのIPv6アドレスを使用すると、IPv4アドレススペースがIPv6アドレス空間に埋め込まれているため、一部のシステムでIPv4ワイルドカードバインドが失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A more detailed porting guideline is described in section 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
より詳細な移植ガイドラインについては、セクション6で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-4--IPv4IPv6-Applications-in-an-IPv4-Only-Node">
4.4. IPv4/IPv6 Applications in an IPv4-Only Node
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. IPv4のみのノードでのIPv4/IPv6アプリケーション
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As the transition is likely to take place over a longer time frame, applications already ported to support both IPv4 and IPv6 may be run on IPv4-only nodes. This would typically be done to avoid supporting two application versions for older and newer operating systems, or to support a case in which the user wants to disable IPv6 for some reason.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
遷移はより長い時間枠で行われる可能性が高いため、IPv4とIPv6の両方をサポートするためにすでに移植されているアプリケーションは、IPv4のみのノードで実行される場合があります。これは通常、古いオペレーティングシステムと新しいオペレーティングシステムの2つのアプリケーションバージョンのサポートを避けたり、ユーザーが何らかの理由でIPv6を無効にしたい場合をサポートするために行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The most important case is the application support on systems where IPv6 support can be dynamically enabled or disabled by the users. Applications on such a system should be able to handle a situation IPv6 would not be enabled. Another scenario is when an application is deployed on older systems that do not support IPv6 at all (even the basic APIs such as getaddrinfo). In this case, the application designer has to make a case-by-case judgment call as to whether it makes sense to have compile-time toggle between an older and a newer API (having to support both in the code), or whether to provide getaddrinfo etc. function support on older platforms as part of the application libraries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最も重要なケースは、IPv6サポートをユーザーが動的に有効にしたり無効にしたりできるシステムのアプリケーションサポートです。このようなシステムのアプリケーションは、IPv6を有効にしない状況を処理できるはずです。別のシナリオは、IPv6をまったくサポートしていない古いシステムにアプリケーションを展開する場合です（getaddrinfoなどの基本的なAPIでさえ）。この場合、アプリケーションデザイナーは、古いAPIと新しいAPI（コードの両方でサポートしなければならない）をコンパイルすることが理にかなっているかどうか、またはするかどうかについて、ケースバイケースの判断電話をかける必要があります。アプリケーションライブラリの一部として、古いプラットフォームでgetaddrinfoなどを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Depending on application/operating system support, some may want to ignore this case, but usually no assumptions can be made, and applications should also work in this scenario.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーション/オペレーティングシステムのサポートに応じて、このケースを無視したい人もいますが、通常は仮定を行うことはできません。また、アプリケーションもこのシナリオで機能する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An example is an application that issues a socket() command, first trying AF_INET6 and then AF_INET. However, if the kernel does not have IPv6 support, the call will result in an EPROTONOSUPPORT or EAFNOSUPPORT error. Typically, errors like these lead to exiting the socket loop, and AF_INET will not even be tried. The application will need to handle this case or build the loop so that errors are ignored until the last address family.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例は、Socket（）コマンドを発行するアプリケーションで、最初にAF_INET6を試してからAF_INETを試します。ただし、カーネルにIPv6のサポートがない場合、呼び出しはeprotonosupportまたはeafnosupportエラーになります。通常、このようなエラーはソケットループを終了することにつながり、AF_INETは試行されません。アプリケーションは、このケースを処理するか、ループを構築して、最後のアドレスファミリまでエラーが無視されるようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This case is just an extension of the IPv4/IPv6 support in the previous case, covering one relatively common but often-ignored case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このケースは、以前のケースでのIPv4/IPv6サポートの単なる拡張であり、比較的一般的ではあるが頻繁にイノベーションされたケースをカバーしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Application-Porting-Considerations">
5. Application Porting Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. アプリケーションの移植に関する考慮事項
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The minimum changes for IPv4 applications to work with IPv6 are based on the different size and format of IPv4 and IPv6 addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv4アプリケーションがIPv6を使用するための最小変更は、IPv4およびIPv6アドレスの異なるサイズと形式に基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications have been developed with IPv4 network protocol in mind. This assumption has resulted in many IP dependencies through source code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、IPv4ネットワークプロトコルを念頭に置いて開発されています。この仮定により、ソースコードを介して多くのIP依存関係が生じました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following list summarizes the more common IP version dependencies in applications:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のリストは、アプリケーションのより一般的なIPバージョンの依存関係をまとめたものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
a) Presentation format for an IP address: An ASCII string that represents the IP address, a dotted-decimal string for IPv4, and a hexadecimal string for IPv6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
a) IPアドレスのプレゼンテーション形式：IPアドレスを表すASCII文字列、IPv4用の点線式文字列、およびIPv6の16進文字列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
b) Transport layer API: Functions to establish communications and to exchange information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
b) トランスポートレイヤーAPI：コミュニケーションを確立し、情報を交換する機能。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
c) Name and address resolution: Conversion functions between hostnames and IP addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
c) 名前とアドレス解決：ホスト名とIPアドレス間の変換関数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
d) Specific IP dependencies: More specific IP version dependencies, such as IP address selection, application framing, and storage of IP addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
d) 特定のIP依存関係：IPアドレスの選択、アプリケーションフレーミング、IPアドレスのストレージなど、より特定のIPバージョン依存関係。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
e) Multicast applications: One must find the IPv6 equivalents to the IPv4 multicast addresses and use the right socket configuration options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
e) マルチキャストアプリケーション：IPv6マルチキャストアドレスに相当するIPv6を見つけて、適切なソケット構成オプションを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following subsections describe the problems with the aforementioned IP version dependencies. Although application source code can be ported to IPv6 with minimum changes related to IP addresses, some recommendations are given to modify the source code in a protocol-independent way, which will allow applications to work with both IPv4 and IPv6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のサブセクションでは、前述のIPバージョン依存関係の問題について説明します。IPアドレスに関連する最小変更でアプリケーションソースコードをIPv6に移植できますが、プロトコルに依存しない方法でソースコードを変更するための推奨事項が与えられます。これにより、アプリケーションはIPv4とIPv6の両方で動作できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1--Presentation-Format-for-an-IP-Address">
5.1. Presentation Format for an IP Address
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. IPアドレスのプレゼンテーション形式
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many applications use IP addresses to identify network nodes and to establish connections to destination addresses. For instance, using the client/server model, clients usually need an IP address as an application parameter to connect to a server. This IP address is usually provided in the presentation format, as a string. There are two problems when porting the presentation format for an IP address: the allocated memory and the management of the presentation format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くのアプリケーションは、IPアドレスを使用してネットワークノードを識別し、宛先アドレスへの接続を確立します。たとえば、クライアント/サーバーモデルを使用すると、クライアントは通常、サーバーに接続するためのアプリケーションパラメーターとしてIPアドレスが必要です。このIPアドレスは、通常、文字列としてプレゼンテーション形式で提供されます。IPアドレスのプレゼンテーション形式を移植する際には、割り当てられたメモリとプレゼンテーション形式の管理を2つの問題があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Usually, the memory allocated to contain an IPv4 address representation as a string is unable to contain an IPv6 address. Applications should be modified to prevent buffer overflows made possible by the larger IPv6 address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、文字列がIPv6アドレスを含めることができないため、IPv4アドレス表現を含むように割り当てられたメモリ。より大きなIPv6アドレスによって可能になったバッファオーバーフローを防ぐために、アプリケーションを変更する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv4 and IPv6 do not use the same presentation format. IPv4 uses a dot (.) to separate the four octets written in decimal notation, and IPv6 uses a colon (:) to separate each pair of octets written in hexadecimal notation [RFC3513]. In cases where one must be able to specify, for example, port numbers with the address (see below), it may be desirable to require placing the address inside the square brackets [TextRep].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv4とIPv6は、同じプレゼンテーション形式を使用しません。IPv4はDOT（。）を使用して小数点以下で記述された4つのオクテットを分離し、IPv6はコロン（:)の各ペアのオクテットの各ペアを16進表[RFC3513]で分離します。たとえば、アドレスのあるポート番号（以下を参照）を指定できる必要がある場合は、正方形の括弧内にアドレスを配置する必要があることが望ましい場合があります[Textrep]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A particular problem with IP address parsers comes when the input is actually a combination of IP address and port number. With IPv4 these are often coupled with a colon; for example, &#34;192.0.2.1:80&#34;. However, this approach would be ambiguous with IPv6, as colons are already used to structure the address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPアドレスパーサーの特定の問題は、入力が実際にIPアドレスとポート番号の組み合わせである場合に発生します。IPv4では、これらは多くの場合、結腸と結合されます。たとえば、「192.0.2.1:80」。ただし、コロンはすでに住所を構築するために使用されているため、このアプローチはIPv6ではあいまいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, the IP address parsers that take the port number separated with a colon should distinguish IPv6 addresses somehow. One way is to enclose the address in brackets, as is done with Uniform Resource Locators (URLs) [RFC2732]; for example, http://[2001:db8::1]:80.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、コロンで区切られたポート番号を取得するIPアドレスパーサーは、IPv6アドレスを何らかの形で区別する必要があります。1つの方法は、均一なリソースロケーター（URL）[RFC2732]で行われるように、括弧内のアドレスを囲むことです。たとえば、http：// [2001：db8 :: 1]：80。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some applications also need to specify IPv6 prefixes and lengths: The prefix length should be inserted outside of the square brackets, if used; for example, [2001:db8::]/64 or 2001:db8::/64 and not [2001:db8::/64]. Note that prefix/length notation is syntactically indistinguishable from a legal URI; therefore, the prefix/length notation must not be used when it isn&#39;t clear from the context that it&#39;s used to specify the prefix and length and not, for example, a URI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のアプリケーションは、IPv6プレフィックスと長さを指定する必要があります。使用する場合は、接頭辞の長さを四角いブラケットの外側に挿入する必要があります。たとえば、[2001：db8 ::]/64または2001：db8 ::/64ではなく[2001：db8 ::/64]。接頭辞/長さの表記は、法的URIと構文的に区別できないことに注意してください。したがって、接頭辞/長さの表記は、たとえばURIではなく、プレフィックスと長さを指定するために使用されていることをコンテキストから明らかにしていない場合は、使用する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some specific cases, it may be necessary to give a zone identifier as part of the address; for example, fe80::1%eth0. In general, applications should not need to parse these identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定の場合には、アドレスの一部としてゾーン識別子を指定する必要がある場合があります。たとえば、Fe80 :: 1％ETH0。一般に、アプリケーションはこれらの識別子を解析する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IP address parsers should support enclosing the IPv6 address in brackets, even when the address is not used in conjunction with a port number. Requiring that the user always give a literal IP address enclosed in brackets is not recommended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPアドレスパーサーは、アドレスがポート番号と組み合わせて使用されていない場合でも、ブラケット内のIPv6アドレスを囲むことをサポートする必要があります。ユーザーが常にブラケットに囲まれた文字通りのIPアドレスを与えることを要求することは推奨されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that some applications may also represent IPv6 address literals differently; for example, SMTP [RFC2821] uses [IPv6:2001:db8::1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のアプリケーションは、IPv6アドレスリテラルを異なる方法で表す場合があることに注意してください。たとえば、SMTP [RFC2821]は[IPv6：2001：db8 :: 1]を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the use of address literals is strongly discouraged for general-purpose direct input to the applications. Host names and DNS should be used instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アドレスリテラルの使用は、アプリケーションへの一般的な直接入力のために強く推奨されていることに注意してください。代わりにホスト名とDNSを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2--Transport-Layer-API">
5.2. Transport Layer API
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. トランスポートレイヤーAPI
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Communication applications often include a transport module that establishes communications. Usually this module manages everything related to communications and uses a transport-layer API, typically as a network library. When an application is ported to IPv6, most changes should be made in this application transport module in order to be adapted to the new IPv6 API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通信アプリケーションには、多くの場合、通信を確立するトランスポートモジュールが含まれます。通常、このモジュールは通信に関連するすべてを管理し、通常はネットワークライブラリとして輸送層APIを使用します。アプリケーションがIPv6に移植される場合、新しいIPv6 APIに適合するために、このアプリケーション輸送モジュールにほとんどの変更を加える必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the general case, porting an existing application to IPv6 requires an examination of the following issues related to the API:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般的なケースでは、既存のアプリケーションをIPv6に移植するには、APIに関連する次の問題を調べる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Network Information Storage: IP address Data Structures The new structures must contain 128-bit IP addresses. The use of generic address structures, which can store any address family, is recommended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- ネットワーク情報ストレージ：IPアドレスデータ構造新しい構造には、128ビットIPアドレスを含める必要があります。任意のアドレスファミリを保存できる一般的なアドレス構造の使用をお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Sometimes special addresses are hard-coded in the application source code. Developers should pay attention to these in order to use the new address format. Some of these special IP addresses are wildcard local, loopback, and broadcast. IPv6 does not have the broadcast addresses, so applications can use multicast instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
アプリケーションソースコードでは、特別なアドレスがハードコーディングされる場合があります。開発者は、新しいアドレス形式を使用するためにこれらに注意を払う必要があります。これらの特別なIPアドレスのいくつかは、ワイルドカードローカル、ループバック、ブロードキャストです。IPv6にはブロードキャストアドレスがないため、アプリケーションは代わりにマルチキャストを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Address Conversion Functions The address conversion functions convert the binary address representation to the presentation format and vice versa. The new conversion functions are specified to the IPv6 address format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- アドレス変換関数アドレス変換関数バイナリアドレス表現をプレゼンテーション形式に変換し、その逆も同様です。新しい変換関数は、IPv6アドレス形式に指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Communication API Functions These functions manage communications. Their signatures are defined based on a generic socket address structure. The same functions are valid for IPv6; however, the IP address data structures used when calling these functions require the updates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- 通信API関数これらの関数は通信を管理します。それらの署名は、一般的なソケットアドレス構造に基づいて定義されます。同じ関数はIPv6に対して有効です。ただし、これらの関数を呼び出すときに使用されるIPアドレスデータ構造には、更新が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Network Configuration Options These are used when different communication models are configured for Input/Output (I/O) operations (blocking/nonblocking, I/O multiplexing, etc.) and should be translated for IPv6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- ネットワーク構成オプションこれらは、入力/出力（I/O）操作（ブロッキング/ノンブロッキング、I/Oマルチプレックスなど）に異なる通信モデルが構成されている場合に使用され、IPv6用に翻訳する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-3--Name-and-Address-Resolution">
5.3. Name and Address Resolution
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. 名前とアドレス解決
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From the application point of view, the name and address resolution is a system-independent process. An application calls functions in a system library, the resolver, which is linked into the application when it is built. However, these functions use IP address structures, that are protocol dependent and must be reviewed to support the new IPv6 resolution calls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションの観点から、名前とアドレスの解決はシステムに依存しないプロセスです。アプリケーションは、システムライブラリで機能を呼び出します。リゾルバーは、ビルド時にアプリケーションにリンクされます。ただし、これらの関数は、プロトコルに依存するIPアドレス構造を使用し、新しいIPv6解像度呼び出しをサポートするためにレビューする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With IPv6, there are two new basic resolution functions, getaddrinfo() and getnameinfo(). The first returns a list of all configured IP addresses for a hostname. These queries can be constrained to one protocol family; for instance, only IPv4 or only IPv6 addresses. However, it is recommended that all configured IP addresses be obtained to allow applications to work with every kind of node. The second function returns the hostname associated to an IP address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6の場合、2つの新しい基本解像度関数、getaddrinfo（）とgetNameInfo（）があります。最初は、ホスト名のすべての設定されたIPアドレスのリストを返します。これらのクエリは、1つのプロトコルファミリに制約できます。たとえば、IPv4またはIPv6のみがアドレス指定されます。ただし、アプリケーションがあらゆる種類のノードで動作できるように、構成されたすべてのIPアドレスを取得することをお勧めします。2番目の関数は、IPアドレスに関連付けられたホスト名を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-4--Specific-IP-Dependencies">
5.4. Specific IP Dependencies
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. 特定のIP依存関係
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-4-1--IP-Address-Selection">
5.4.1. IP Address Selection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4.1. IPアドレスの選択
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike the IPv4 model, IPv6 promotes the configuration of multiple IP addresses per node, however, applications only use a destination/source pair for a communication. Choosing the right IP source and destination addresses is a key factor that may determine the route of IP datagrams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv4モデルとは異なり、IPv6はノードあたりの複数のIPアドレスの構成を宣伝しますが、アプリケーションは通信に宛先/ソースペアのみを使用します。適切なIPソースと宛先アドレスを選択することは、IPデータグラムのルートを決定できる重要な要素です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Typically, nodes, not applications, automatically solve the source address selection. A node will choose the source address for a communication following some rules of best choice, per [RFC3484], but will also allow applications to make changes in the ordering rules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、アプリケーションではなくノードがソースアドレスの選択を自動的に解決します。ノードは、[RFC3484]によると、最良の選択のいくつかのルールに従って通信のソースアドレスを選択しますが、アプリケーションが順序付けルールを変更できるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When selecting the destination address, applications usually ask a resolver for the destination IP address. The resolver returns a set of valid IP addresses from a hostname. Unless applications have a specific reason to select any particular destination address, they should try each element in the list until the communication succeeds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先アドレスを選択するとき、アプリケーションは通常、宛先IPアドレスのリゾルバーを尋ねます。リゾルバーは、ホスト名から有効なIPアドレスのセットを返します。アプリケーションに特定の宛先アドレスを選択する特定の理由がない限り、通信が成功するまでリスト内の各要素を試す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some cases, the application may need to specify its source address. The destination address selection process picks the best destination for the source address (instead of picking the best source address for the chosen destination address). Note that if it is not yet known which protocol will be used for communication there may be an increase in complexity for IP version - independent applications that have to specify the source address (especially for client applications. Fortunately, specifying the source address is not typically required).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
場合によっては、アプリケーションがソースアドレスを指定する必要がある場合があります。宛先アドレスの選択プロセスは、選択した宛先アドレスに最適なソースアドレスを選択する代わりに、ソースアドレスに最適な宛先を選択します。どのプロトコルが通信に使用されるかがまだわかっていない場合、IPバージョンの複雑さが増加する可能性があることに注意してください - ソースアドレスを指定する必要がある独立したアプリケーション（特にクライアントアプリケーションで。幸いなことに、ソースアドレスを指定することは通常、必須）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-4-2--Application-Framing">
5.4.2. Application Framing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4.2. アプリケーションフレーミング
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Application Level Framing (ALF) architecture controls mechanisms that traditionally fall within the transport layer. Applications implementing ALF are often responsible for packetizing data into Application Data Units (ADUs). The application problem with ALF arrives from the ADU size selection to obtain better performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションレベルのフレーミング（ALF）アーキテクチャは、伝統的に輸送層内に該当するメカニズムを制御します。ALFを実装するアプリケーションは、多くの場合、データをアプリケーションデータユニット（ADU）にパケット化する責任があります。ALFのアプリケーションの問題は、ADUサイズの選択から到着し、パフォーマンスを向上させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications using connectionless protocols (such as UDP) typically need application framing. These applications have three choices: (1) to use packet sizes no larger than the IPv6 minimum Maximum Transmission Unit (MTU) of 1280 bytes [RFC2460], (2) to use any packet sizes, but to force IPv6 fragmentation/reassembly when necessary, or (3) to optimize the packet size and avoid unnecessary fragmentation/reassembly, and to guess or find out the optimal packet sizes that can be sent and received, end-to-end, on the network. This memo takes no stance on that approach is best.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続のないプロトコル（UDPなど）を使用したアプリケーションは、通常、アプリケーションフレーミングが必要です。これらのアプリケーションには3つの選択肢があります。（1）1280バイト[RFC2460]のIPv6最小最大透過ユニット（MTU）を使用するパケットサイズを使用するには[RFC2460]、（2）パケットサイズを使用しますが、必要に応じてIPv6の断片化/再組み立てを強制します。、または（3）パケットサイズを最適化し、不必要な断片化/再組み立てを回避し、ネットワーク上でエンドツーエンドで送信および受信できる最適なパケットサイズを推測または調べます。このメモは、そのアプローチが最適ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the most optimal ALF depends on dynamic factors such as Path MTU or whether IPv4 or IPv6 is being used (due to different header sizes, possible IPv6-in-IPv4 tunneling overhead, etc.). These factors have to be taken into consideration when application framing is implemented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最も最適なALFは、Path MTUやIPv4またはIPv6などの動的要因に依存していることに注意してください（異なるヘッダーサイズ、IPv6-in-IPV4トンネルのオーバーヘッドなど）。これらの要因は、アプリケーションフレーミングが実装されている場合に考慮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-4-3--Storage-of-IP-Addresses">
5.4.3. Storage of IP Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4.3. IPアドレスのストレージ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some applications store IP addresses as remote peer information. For instance, one of the most popular ways to register remote nodes in collaborative applications uses IP addresses as registry keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のアプリケーションは、IPアドレスをリモートピア情報として保存します。たとえば、コラボレーティブアプリケーションでリモートノードを登録する最も一般的な方法の1つは、IPアドレスをレジストリキーとして使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the source code that stores IP addresses can be modified to IPv6 by following the previous basic porting recommendations, applications should not store IP addresses for the following reasons:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPアドレスを保存するソースコードは、以前の基本的なポーティング推奨事項に従うことでIPv6に変更できますが、アプリケーションは次の理由でIPアドレスを保存してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- IP addresses can change throughout time; for instance, after a renumbering process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- IPアドレスは時間をかけて変更できます。たとえば、変更プロセスの後。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The same node can reach a destination host using different IP addresses, possibly with a different protocol version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- 同じノードは、異なるプロトコルバージョンを使用して、異なるIPアドレスを使用して宛先ホストに到達できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When possible, applications should store names such as FQDNs or other protocol-independent identities instead of addresses. In this case applications are only bound to specific addresses at run time, or for the duration of a cache lifetime. Other types of applications, such as massive peer-to-peer systems with their own rendezvous and discovery mechanisms, may need to cache addresses for performance reasons, but cached addresses should not be treated as permanent, reliable information. In highly dynamic networks, any form of name resolution may be impossible, and here again addresses must be cached.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可能な場合、アプリケーションは、アドレスの代わりにFQDNSまたはその他のプロトコルに依存しないアイデンティティなどの名前を保存する必要があります。この場合、アプリケーションは、実行時に特定のアドレスにのみ拘束されます。独自のランデブーや発見メカニズムを備えた大規模なピアツーピアシステムなど、他のタイプのアプリケーションは、パフォーマンス上の理由でアドレスをキャッシュする必要がある場合がありますが、キャッシュされたアドレスは、永続的で信頼できる情報として扱われるべきではありません。非常に動的なネットワークでは、あらゆる形式の名前解像度が不可能である可能性があり、ここでもアドレスをキャッシュする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-5--Multicast-Applications">
5.5. Multicast Applications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. マルチキャストアプリケーション
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is an additional problem in porting multicast applications. When multicast facilities are used some changes must be carried out to support IPv6. First, applications must change the IPv4 multicast addresses to IPv6 ones, and second, the socket configuration options must be changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチキャストアプリケーションの移植には追加の問題があります。マルチキャスト施設を使用する場合、IPv6をサポートするためにいくつかの変更を実行する必要があります。まず、アプリケーションはIPv4マルチキャストアドレスをIPv6のアドレスに変更する必要があり、次にはソケット構成オプションを変更する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All IPv6 multicast addresses encode scope; the scope was only implicit in IPv4 (with multicast groups in 239/8). Also, although a large number of application-specific multicast addresses have been assigned with IPv4, this has been (luckily enough) avoided with IPv6. So there are no direct equivalents for all the multicast addresses. For link-local multicast, it&#39;s possible to pick almost anything within the link-local scope. The global groups could use unicast prefix - based addresses [RFC3306]. All in all, this may force the application developers to write more protocol-dependent code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのIPv6マルチキャストアドレスはスコープをエンコードします。スコープはIPv4でのみ暗黙的でした（239/8にマルチキャストグループがあります）。また、IPv4には多数のアプリケーション固有のマルチキャストアドレスが割り当てられていますが、これは（幸運にも十分に）IPv6で避けられています。したがって、すべてのマルチキャストアドレスに直接相当するものはありません。Link-Local Multicastの場合、Link-Localスコープ内でほとんどすべてを選択することができます。グローバルグループは、ユニキャストプレフィックスベースのアドレス[RFC3306]を使用できます。全体として、これにより、アプリケーション開発者はより多くのプロトコル依存コードを記述するように強制される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another problem is that IPv6 multicast does not yet have a standardized mechanism for traditional Any Source Multicast for Interdomain multicast. The models for Any Source Multicast (ASM) or Source-Specific Multicast (SSM) are generally similar between IPv4 and IPv6, but it is possible that PIM-SSM will become more widely deployed in IPv6 due to its simpler architecture.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別の問題は、IPv6マルチキャストには、インタードメインマルチキャスト用の従来のソースマルチキャストの標準化されたメカニズムがまだないことです。任意のソースマルチキャスト（ASM）またはソース固有のマルチキャスト（SSM）のモデルは一般にIPv4とIPv6の間で類似していますが、PIM-SSMがその単純なアーキテクチャによりIPv6に広く展開される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It might be beneficial to port the applications to use SSM semantics, requiring off-band source discovery mechanisms and a different API [RFC3678]. Inter-domain ASM service is available only through a method embedding the Rendezvous Point address in the multicast address [Embed-RP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSMセマンティクスを使用するようにアプリケーションを移植することが有益である可能性があり、バンドオフソース発見メカニズムと異なるAPI [RFC3678]が必要です。ドメイン間ASMサービスは、マルチキャストアドレス[Embed-RP]のランデブーポイントアドレスを埋め込むメソッドを介してのみ利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another generic problem with multiparty conferencing applications, similar to the issues with peer-to-peer applications, is that all users of the session must use the same protocol version (IPv4 or IPv6), or some form of proxy or translator (e.g., [MUL-GW]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアツーピアアプリケーションの問題と同様に、マルチパーティ会議アプリケーションの別の一般的な問題は、セッションのすべてのユーザーが同じプロトコルバージョン（IPv4またはIPv6）、または何らかの形のプロキシまたは翻訳者（例えば[）を使用する必要があることです。mul-gw]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Developing-IP-Version---Independent-Applications">
6. Developing IP Version - Independent Applications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. IPバージョンの開発 - 独立したアプリケーション
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As stated, dual applications working with both IPv4 and IPv6 are recommended. These applications should avoid IP dependencies in the source code. However, if IP dependencies are required, one of the better solutions would be to build a communication library that provides an IP version - independent API to applications and that hides all dependencies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
述べたように、IPv4とIPv6の両方で動作するデュアルアプリケーションが推奨されます。これらのアプリケーションは、ソースコードのIP依存関係を回避する必要があります。ただし、IP依存関係が必要な場合、より良い解決策の1つは、IPバージョンを提供する通信ライブラリを構築することです。アプリケーションに独立したAPIとすべての依存関係を隠すことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To develop IP version - independent applications, the following guidelines should be considered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPバージョン - 独立したアプリケーションを開発するには、次のガイドラインを考慮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-1--IP-Version---Independent-Structures">
6.1. IP Version - Independent Structures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. IPバージョン - 独立した構造
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All memory structures and APIs should be IP version-independent. One should avoid structs in_addr, in6_addr, sockaddr_in, and sockaddr_in6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのメモリ構造とAPIは、IPバージョンに依存する必要があります。struct in_addr、in6_addr、sockaddr_in、およびsockaddr_in6を避ける必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suppose a network address is passed to some function, foo(). If one uses struct in_addr or struct in6_addr, results an extra parameter to indicate address family, as below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークアドレスが何らかの関数foo（）に渡されるとします。struct in_addrまたはstruct in6_addrを使用している場合、以下のようにアドレスファミリを示すために追加のパラメーターを生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct in_addr in4addr;
      struct in6_addr in6addr;
       /* IPv4 case */
      foo(&amp;in4addr, AF_INET);
       /* IPv6 case */
      foo(&amp;in6addr, AF_INET6);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This leads to duplicated code and having to consider each scenario from both perspectives independently, which is difficult to maintain. So we should use struct sockaddr_storage, as below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これにより、コードが複製され、両方の視点から独立して各シナリオを考慮することができなくなり、維持が困難になります。したがって、以下のように、struct sockaddr_storageを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct sockaddr_storage ss;
      int sslen;
      /* AF independent! - use sockaddr when passing a pointer */
      /* note: it&#39;s typically necessary to also pass the length
         explicitly */
      foo((struct sockaddr *)&amp;ss, sslen);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2--IP-Version---Independent-APIs">
6.2. IP Version - Independent APIs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. IPバージョン - 独立したAPI
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The new address independent variants getaddrinfo() and getnameinfo() hide the gory details of name-to-address and address-to-name translations. They implement functionalities of the following functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいアドレスの独立バリエーションgetaddrinfo（）およびgetnameInfo（）は、名前からアドレスへのgoryの詳細とアドレス間翻訳を非表示にします。彼らは次の機能の機能を実装します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
gethostbyname() gethostbyaddr() getservbyname() getservbyport()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
gethostbyname（）gethostbyaddr（）getservbyname（）getservbyport（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
They also obsolete the functionality of gethostbyname2(), defined in [RFC2133].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、[RFC2133]で定義されているgethostbyname2（）の機能を廃止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The new variants can perform hostname/address and service name/port lookups, though the features can be turned off, if desired. Getaddrinfo() can return multiple addresses, as below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいバリアントは、ホスト名/アドレスとサービス名/ポートルックアップを実行できますが、必要に応じて機能をオフにできます。getaddrinfo（）は、以下のように複数のアドレスを返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
localhost. IN A 127.0.0.1 IN A 127.0.0.2 IN AAAA ::1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
localhost。127.0.0.1で127.0.0.2でAAAA :: 1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this example, if IPv6 is preferred, getaddrinfo first returns ::1; then both 127.0.0.1 and 127.0.0.2 are in a random order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例では、IPv6が優先される場合、getaddrinfoが最初に戻ります:: 1;次に、127.0.0.1と127.0.0.2の両方がランダムな順序になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Getaddrinfo() and getnameinfo() can query hostname and service name/port at once.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
getaddrinfo（）およびgetnameInfo（）は、ホスト名とサービス名/ポートを一度にクエリすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hardcoding AF-dependent knowledge is not preferred in the program. Constructs such as that below should be avoided:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハードコードAF依存の知識は、プログラムでは好まれません。以下のような構成要素は避けるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* BAD EXAMPLE */
       switch (sa-&gt;sa_family) {
       case AF_INET:
               salen = sizeof(struct sockaddr_in);
               break;
      }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Instead, we should use the ai_addrlen member of the addrinfo structure, as returned by getaddrinfo().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代わりに、getaddrinfo（）によって返されるように、addrinfo構造のAI_ADDRLENメンバーを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The gethostbyname(), gethostbyaddr(), getservbyname(), and getservbyport() are mainly used to get server and client sockets. In the following sections, we will see simple examples creating these sockets by using the new IPv6 resolution functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
gethostbyname（）、gethostbyaddr（）、getservbyname（）、およびgetservbyport（）は、主にサーバーとクライアントのソケットを取得するために使用されます。次のセクションでは、新しいIPv6解像度関数を使用して、これらのソケットを作成する簡単な例を確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2-1--Example-of-Overly-Simplistic-TCP-Server-Application">
6.2.1. Example of Overly Simplistic TCP Server Application
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1. 過度に単純化されたTCPサーバーアプリケーションの例
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A simple TCP server socket at service name (or port number string) SERVICE:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サービス名（またはポート番号文字列）サービスのシンプルなTCPサーバーソケット：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /*
       * BAD EXAMPLE: does not implement the getaddrinfo loop as
       * specified in 6.3.  This may result in one of the following:
       *  - an IPv6 server, listening at the wildcard address,
       *    allowing IPv4 addresses through IPv4-mapped IPv6 addresses.
       *  - an IPv4 server, if IPv6 is not enabled,
       *  - an IPv6-only server, if IPv6 is enabled but IPv4-mapped IPv6
       *    addresses are not used by default, or
       *  - no server at all, if getaddrinfo supports IPv6, but the
       *    system doesn&#39;t, and socket(AF_INET6, ...) exits with an
       *    error.
       */
      struct addrinfo hints, *res;
      int error, sockfd;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      memset(&amp;hints, 0, sizeof(hints));
      hints.ai_flags = AI_PASSIVE;
      hints.ai_family = AF_UNSPEC;
      hints.ai_socktype = SOCK_STREAM;
      error = getaddrinfo(NULL, SERVICE, &amp;hints, &amp;res);
      if (error != 0) {
         /* handle getaddrinfo error */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      sockfd = socket(res-&gt;family, res-&gt;ai_socktype, res-&gt;ai_protocol);
      if (sockfd &lt; 0) {
         /* handle socket error */
      }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      if (bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen) &lt; 0) {
         /* handle bind error */
      }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* ... */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
freeaddrinfo(res);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Freeaddrinfo（res）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2-2--Example-of-Overly-Simplistic-TCP-Client-Application">
6.2.2. Example of Overly Simplistic TCP Client Application
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2. 過度に単純なTCPクライアントアプリケーションの例
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A simple TCP client socket connecting to a server running at node name (or IP address presentation format) SERVER_NODE and service name (or port number string) SERVICE follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノード名（またはIPアドレスプレゼンテーション形式）で実行されているサーバーに接続するシンプルなTCPクライアントソケットServer_Nodeおよびサービス名（またはポート番号文字列）サービスは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /*
       * BAD EXAMPLE: does not implement the getaddrinfo loop as
       * specified in 6.3.  This may result in one of the following:
       *  - an IPv4 connection to an IPv4 destination,
       *  - an IPv6 connection to an IPv6 destination,
       *  - an attempt to try to reach an IPv6 destination (if AAAA
       *    record found), but failing -- without fallbacks -- because:
       *     o getaddrinfo supports IPv6 but the system does not
       *     o IPv6 routing doesn&#39;t exist, so falling back to e.g., TCP
       *       timeouts
       *     o IPv6 server reached, but service not IPv6-enabled or
       *       firewalled away
       *  - if the first destination is not reached, there is no
       *    fallback to the next records
       */
      struct addrinfo hints, *res;
      int error, sockfd;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      memset(&amp;hints, 0, sizeof(hints));
      hints.ai_family = AF_UNSPEC;
      hints.ai_socktype = SOCK_STREAM;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      error = getaddrinfo(SERVER_NODE, SERVICE, &amp;hints, &amp;res);
      if (error != 0) {
           /* handle getaddrinfo error */
      }
            sockfd = socket(res-&gt;family, res-&gt;ai_socktype, res-&gt;ai_protocol);
      if (sockfd &lt; 0) {
           /* handle socket error */
      }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      if (connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen) &lt; 0 ) {
           /* handle connect error */
      }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* ... */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
freeaddrinfo(res);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Freeaddrinfo（res）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2-3--BinaryPresentation-Format-Conversion">
6.2.3. Binary/Presentation Format Conversion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3. バイナリ/プレゼンテーション形式の変換
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We should consider the binary and presentation address format conversion APIs. The following functions convert network address structure in its presentation address format and vice versa:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイナリおよびプレゼンテーションアドレス形式のフォーマット変換APIを考慮する必要があります。次の関数は、プレゼンテーションアドレス形式でネットワークアドレス構造を変換し、その逆の場合は次のことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
inet_ntop() inet_pton()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
inet_ntop（）inet_pton（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both are from the basic socket extensions for IPv6. However, these conversion functions are protocol-dependent. It is better to use getnameinfo()/getaddrinfo() (inet_pton and inet_ntop equivalents are described in Appendix A).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どちらもIPv6の基本ソケット拡張機能からです。ただし、これらの変換関数はプロトコル依存です。getNameInfo（）/getAddrinfo（）（inet_ptonおよびinet_ntopの等価物を付録Aに記載することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Conversion from network address structure to presentation format can be written as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークアドレス構造からプレゼンテーション形式への変換は、次のように記述できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct sockaddr_storage ss;
      char addrStr[INET6_ADDRSTRLEN];
      char servStr[NI_MAXSERV];
      int error;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* fill ss structure */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      error = getnameinfo((struct sockaddr *)&amp;ss, sizeof(ss),
                          addrStr, sizeof(addrStr),
                          servStr, sizeof(servStr),
                          NI_NUMERICHOST);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Conversions from presentation format to network address structure can be written as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プレゼンテーション形式からネットワークアドレス構造への変換は、次のように記述できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct addrinfo hints, *res;
      char addrStr[INET6_ADDRSTRLEN];
      int error;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* fill addrStr buffer */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      memset(&amp;hints, 0, sizeof(hints));
      hints.ai_family = AF_UNSPEC;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      error = getaddrinfo(addrStr, NULL, &amp;hints, &amp;res);
      if (error != 0) {
          /* handle getaddrinfo error */
      }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* res-&gt;ai_addr contains the network address structure */
      /* ... */
      freeaddrinfo(res);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-3--Iterated-Jobs-for-Finding-the-Working-Address">
6.3. Iterated Jobs for Finding the Working Address
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. 作業アドレスを見つけるためのジョブを繰り返しました
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a client code, when multiple addresses are returned from getaddrinfo(), we should try all of them until connection succeeds. When a failure occurs with socket(), connect(), bind(), or some other function, the code should go on to try the next address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントコードでは、getaddrinfo（）から複数のアドレスが返される場合、接続が成功するまですべてを試す必要があります。socket（）、connect（）、bind（）、またはその他の関数で障害が発生した場合、コードは次のアドレスを試すために続行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, if something is wrong with the socket call because the address family is not supported (i.e., in case of section 4.4), applications should try the next address structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、アドレスファミリがサポートされていないためにソケットコールに何か問題がある場合（つまり、セクション4.4の場合）、アプリケーションは次のアドレス構造を試す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: In the following examples, the socket() return value error handling could be simplified by always continuing on with the socket loop instead of performing special checking of specific error numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：次の例では、特定のエラー番号の特別なチェックを実行する代わりに、ソケットループを常に継続することにより、ソケット（）戻り値エラー処理が簡素化される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-3-1--Example-of-TCP-Server-Application">
6.3.1. Example of TCP Server Application
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. TCPサーバーアプリケーションの例
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The previous TCP server example should be written as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前のTCPサーバーの例は、次のように記述する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      #define MAXSOCK 2
      struct addrinfo hints, *res;
      int error, sockfd[MAXSOCK], nsock=0;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      memset(&amp;hints, 0, sizeof(hints));
      hints.ai_flags = AI_PASSIVE;
      hints.ai_family = AF_UNSPEC;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
hints.ai_socktype = SOCK_STREAM;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
hints.ai_socktype = sock_stream;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      error = getaddrinfo(NULL, SERVICE, &amp;hints, &amp;res);
      if (error != 0) {
          /* handle getaddrinfo error */
      }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      for (aip=res; aip &amp;&amp; nsock &lt; MAXSOCK; aip=aip-&gt;ai_next) {
          sockfd[nsock] = socket(aip-&gt;ai_family,
                                 aip-&gt;ai_socktype,
                                 aip-&gt;ai_protocol);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          if (sockfd[nsock] &lt; 0) {
              switch errno {
                   case EAFNOSUPPORT:
                   case EPROTONOSUPPORT:
                       /*
                        *  e.g., skip the errors until
                        *  the last address family,
                        *  see section 4.4.
                        */
                        if (aip-&gt;ai_next)
                                continue;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        else {
                               /* handle unknown protocol errors */
                                break;
                        }
                   default:
                        /* handle other socket errors */
                        ;
               }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          } else {
              int on = 1;
              /* optional: works better if dual-binding to wildcard
                 address */
              if (aip-&gt;ai_family == AF_INET6) {
                  setsockopt(sockfd[nsock], IPPROTO_IPV6, IPV6_V6ONLY,
                             (char *)&amp;on, sizeof(on));
                  /* errors are ignored */
              }
              if (bind(sockfd[nsock], aip-&gt;ai_addr,
                                      aip-&gt;ai_addrlen) &lt; 0 ) {
                  /* handle bind error */
                  close(sockfd[nsock]);
                  continue;
              }
                    if (listen(sockfd[nsock], SOMAXCONN) &lt; 0) {
                  /* handle listen errors */
                  close(sockfd[nsock]);
                  continue;
              }
          }
          nsock++;
      }
      freeaddrinfo(res);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* check that we were able to obtain the sockets */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-3-2--Example-of-TCP-Client-Application">
6.3.2. Example of TCP Client Application
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2. TCPクライアントアプリケーションの例
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The previous TCP client example should be written as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前のTCPクライアントの例は、次のように記述する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct addrinfo hints, *res, *aip;
      int sockfd, error;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      memset(&amp;hints, 0, sizeof(hints));
      hints.ai_family   = AF_UNSPEC;
      hints.ai_socktype = SOCK_STREAM;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      error = getaddrinfo(SERVER_NODE, SERVICE, &amp;hints, &amp;res);
      if (error != 0) {
          /* handle getaddrinfo error */
      }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      for (aip=res; aip; aip=aip-&gt;ai_next) {
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          sockfd = socket(aip-&gt;ai_family,
                          aip-&gt;ai_socktype,
                          aip-&gt;ai_protocol);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          if (sockfd &lt; 0) {
              switch errno {
                   case EAFNOSUPPORT:
                   case EPROTONOSUPPORT:
                       /*
                        *  e.g., skip the errors until
                        *  the last address family,
                        *  see section 4.4.
                        */
                        if (aip-&gt;ai_next)
                                continue;
                        else {
                               /* handle unknown protocol errors */
                                break;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   default:
                        /* handle other socket errors */
                        ;
               }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          } else {
              if (connect(sockfd, aip-&gt;ai_addr, aip-&gt;ai_addrlen) == 0)
                  break;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              /* handle connect errors */
              close(sockfd);
              sockfd=-1;
          }
      }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      if (sockfd &gt; 0) {
          /* socket connected to server address */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* ... */
      }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
freeaddrinfo(res);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Freeaddrinfo（res）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Transition-Mechanism-Considerations">
7. Transition Mechanism Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 遷移メカニズムの考慮事項
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mechanism [NAT-PT] introduces a special set of addresses, formed of an NAT-PT prefix and an IPv4 address these refer to IPv4 addresses translated by NAT-PT DNS-ALG. In some cases, one might be tempted to handle these differently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メカニズム[NAT-PT]は、NAT-PTプレフィックスとIPv4アドレスで形成された特別なアドレスセットを導入します。場合によっては、これらを異なって処理するように誘惑されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, IPv6 applications must not be required to distinguish &#34;normal&#34; and &#34;NAT-PT translated&#34; addresses (or any other kind of special addresses, including the IPv4-mapped IPv6 addresses): This would be completely impractical, and if the distinction must be made, it must be done elsewhere (e.g., kernel, system libraries).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、「通常」と「NAT-PT翻訳」アドレス（またはIPv4マップされたIPv6アドレスを含む他の種類の特別なアドレス）を区別するためにIPv6アプリケーションを必要としないでください。これは完全に非実用的であり、区別が必要な場合作られてください、それは他の場所で行う必要があります（例：カーネル、システムライブラリ）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--Security-Considerations">
8. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. セキュリティに関する考慮事項
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are a number of security considerations for IPv6 transition, but those are outside the scope of this memo.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6トランジションには多くのセキュリティ上の考慮事項がありますが、これらはこのメモの範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To ensure the availability and robustness of the service even when transitioning to IPv6, this memo describes a number of ways to make applications more resistant to failures by cycling through addresses until a working one is found. Doing this properly is critical to maintain availability and to avoid loss of service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6に移行する場合でも、サービスの可用性と堅牢性を確保するために、このメモは、作業が見つかるまでアドレスを介してサイクリングすることにより、アプリケーションをより耐性に耐性にする方法を説明します。これを適切に行うことは、可用性を維持し、サービスの損失を避けるために重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A special consideration about application transition is how IPv4- mapped IPv6 addresses are handled. The use in the API can be seen both as a merit (easier application transition) and as a burden (difficulty in ensuring whether the use was legitimate). Note that some systems will disable (by default) support for internal IPv4- mapped IPv6 addresses. The security concerns regarding these on the wire are legitimate, but disabling it internally breaks one transition mechanism for server applications originally written to bind() and listen() to a single socket by using a wildcard address [V6MAPPED]. This should be considered in more detail when applications are designed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションの遷移に関する特別な考慮事項は、IPv4マッピングされたIPv6アドレスの処理方法です。APIでの使用は、メリット（アプリケーションの移行の容易）と負担（使用が合法かどうかを確認するのが難しい）の両方として見ることができます。一部のシステムは、内部IPv4マッピングIPv6アドレスの（デフォルトで）サポートを無効にすることに注意してください。ワイヤー上のこれらに関するセキュリティの懸念は合法ですが、それを無効にすると、ワイルドカードアドレス[V6マップ]を使用して、bind（）およびliste（）に単一ソケットにbind（）と（）に書かれたサーバーアプリケーションの1つの遷移メカニズムが内部的に破損します。これは、アプリケーションが設計されている場合に、より詳細に検討する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--Acknowledgments">
9. Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 謝辞
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some of guidelines for development of IP version-independent applications (section 6) were first brought up by [AF-APP]. Other work to document application porting guidelines has also been in progress; for example, [IP-GGF] and [PRT]. We would like to thank the members of the v6ops working group and the application area for helpful comments. Special thanks are due to Brian E. Carpenter, Antonio Querubin, Stig Venaas, Chirayu Patel, Jordi Palet, and Jason Lin for extensive review of this document. We acknowledge Ron Pike for proofreading the document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPバージョンに依存しないアプリケーション（セクション6）の開発に関するガイドラインのいくつかは、最初に[AF-APP]によって提起されました。アプリケーションの移植ガイドラインを文書化する他の作業も進行中です。たとえば、[IP-GGF]および[PRT]。有益なコメントについては、V6OPSワーキンググループのメンバーとアプリケーションエリアに感謝します。この文書の広範なレビューをしてくれたブライアン・E・カーペンター、アントニオ・クルービン、スティグ・ヴェナス、チラユ・パテル、ジョルディ・パレット、ジェイソン・リンに感謝します。ドキュメントを校正してくれたRon Pikeに感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10--References">
10. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 参考文献
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-1--Normative-References">
10.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. 引用文献
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3493] Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &#34;Basic Socket Interface Extensions for IPv6&#34;, RFC 3493, February 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3493] Gilligan、R.、Thomson、S.、Bound、J.、McCann、J。、およびW. Stevens、「IPv6の基本ソケットインターフェイス拡張」、RFC 3493、2003年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3542] Stevens, W., Thomas, M., Nordmark, E., and T. Jinmei, &#34;Advanced Sockets Application Program Interface (API) for IPv6&#34;, RFC 3542, May 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3542] Stevens、W.、Thomas、M.、Nordmark、E。、およびT. Jinmei、「IPv6用Advanced Socketsアプリケーションプログラムインターフェイス（API）」、RFC 3542、2003年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BIS] Tsuchiya, K., Higuchi, H., and Y. Atarashi, &#34;Dual Stack Hosts using the &#34;Bump-In-the-Stack&#34; Technique (BIS)&#34;, RFC 2767, February 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Bis] Tsuchiya、K.、Higuchi、H。、およびY. atarashi、「Bump-in-the-Stack」テクニック（BIS）を使用してデュアルスタックホスト」、RFC 2767、2000年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BIA] Lee, S., Shin, M-K., Kim, Y-J., Nordmark, E., and A. Durand, &#34;Dual Stack Hosts Using &#34;Bump-in-the-API&#34; (BIA)&#34;, RFC 3338, October 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Bia] Lee、S.、Shin、M-K。、Kim、Y-J。、Nordmark、E。、およびA. Durand、「Bump-in-api」（BIA）を使用してデュアルスタックホスト」、RFC 3338、2002年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2460] Deering, S. and R. Hinden, &#34;Internet Protocol, Version 6 (IPv6) Specification&#34;, RFC 2460, December 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2460] Deering、S。およびR. Hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、RFC 2460、1998年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3484] Draves, R., &#34;Default Address Selection for Internet Protocol version 6 (IPv6)&#34;, RFC 3484, February 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3484] Draves、R。、「インターネットプロトコルバージョン6（IPv6）のデフォルトアドレス選択」、RFC 3484、2003年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3513] Hinden, R. and S. Deering, &#34;Internet Protocol Version 6 (IPv6) Addressing Architecture&#34;, RFC 3513, April 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3513] Hinden、R。およびS. Deering、「インターネットプロトコルバージョン6（IPv6）アドレス指定アーキテクチャ」、RFC 3513、2003年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-2--Informative-References">
10.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. 参考引用
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2893BIS] Nordmark, E. and R. E. Gilligan, &#34;Basic Transition Mechanisms for IPv6 Hosts and Routers&#34;, Work in Progress, June 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2893bis] Nordmark、E。およびR. E. Gilligan、「IPv6ホストとルーターの基本的な遷移メカニズム」、2004年6月、進行中の作業。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2133] Gilligan, R., Thomson, S., Bound, J., and W. Stevens, &#34;Basic Socket Interface Extensions for IPv6&#34;, RFC 2133, April 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2133] Gilligan、R.、Thomson、S.、Bound、J。、およびW. Stevens、「IPv6の基本ソケットインターフェイス拡張」、RFC 2133、1997年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2732] Hinden, R., Carpenter, B., and L. Masinter, &#34;Format for Literal IPv6 Addresses in URL&#39;s&#34;, RFC 2732, December 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2732] Hinden、R.、Carpenter、B。、およびL. Masinter、「URLのリテラルIPv6アドレスの形式」、RFC 2732、1999年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2821] Klensin, J., &#34;Simple Mail Transfer Protocol&#34;, RFC 2821, April 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2821]クレンシン、J。、「Simple Mail Transfer Protocol」、RFC 2821、2001年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TextRep] Main, A., &#34;Textual Representation of IPv4 and IPv6 Addresses&#34;, Work in Progress, October 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Textrep] Main、A。、「IPv4およびIPv6アドレスのテキスト表現」、2003年10月の作業。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NAT-PT] Tsirtsis, G. and P. Srisuresh, &#34;Network Address Translation - Protocol Translation (NAT-PT)&#34;, RFC 2766, February 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Nat-Pt] Tsirtsis、G。およびP. Srisuresh、「ネットワークアドレス変換 - プロトコル翻訳（NAT-PT）」、RFC 2766、2000年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DNSTRANS] Durand, A. and J. Ihren, &#34;DNS IPv6 Transport Operational Guidelines&#34;, BCP 91, RFC 3901, September 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Dnstrans] Durand、A。およびJ. Ihren、「DNS IPv6輸送運用ガイドライン」、BCP 91、RFC 3901、2004年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DNSOPV6] Durand, A., Ihren, J. and P. Savola, &#34;Operational Considerations and Issues with IPv6 DNS&#34;, Work in Progress, May 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Dnsopv6] Durand、A.、Ihren、J。、およびP. Savola、「IPv6 DNSの運用上の考慮事項と問題」、2004年5月、進行中の作業。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[AF-APP] Hagino, J., &#34;Implementing AF-independent application&#34;, http://www.kame.net/newsletter/19980604/, 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[AF-APP] Hagino、J。、「AF独立アプリケーションの実装」、http：//www.kame.net/newsletter/19980604/、2001。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[V6MAPPED] Hagino, J., &#34;IPv4 mapped address considered harmful&#34;, Work in Progress, April 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[V6Mapped] Hagino、J。、「有害と見なされるIPv4マッピングアドレス」、2002年4月、進行中の作業。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IP-GGF] Chown, T., Bound, J., Jiang, S. and P. O&#39;Hanlon, &#34;Guidelines for IP version independence in GGF specifications&#34;, Global Grid Forum(GGF) Documentation, work in Progress, September 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IP-GGF] Chown、T.、Bound、J.、Jiang、S。、およびP. O&#39;Hanlon、「GGF仕様におけるIPバージョンの独立性のガイドライン」、Global Grid Forum（GGF）ドキュメント、作業中の作業、9月2003年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Embed-RP] Savola, P. and B. Haberman, &#34;Embedding the Rendezvous Point (RP) Address in an IPv6 Multicast Address&#34;, RFC 3956, November 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Embed-RP] Savola、P。およびB. Haberman、「IPv6マルチキャストアドレスにRendezvous Point（RP）アドレスを埋め込む」、RFC 3956、2004年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3306] Haberman, B. and D. Thaler, &#34;Unicast-Prefix-based IPv6 Multicast Addresses&#34;, RFC 3306, August 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3306] Haberman、B。およびD. Thaler、「Unicast-PrefixベースのIPv6マルチキャストアドレス」、RFC 3306、2002年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3678] Thaler, D., Fenner, B., and B. Quinn, &#34;Socket Interface Extensions for Multicast Source Filters, RFC 3678, January 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3678] Thaler、D.、Fenner、B。、およびB. Quinn、「マルチキャストソースフィルターのソケットインターフェイス拡張、RFC 3678、2004年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MUL-GW] Venaas, S., &#34;An IPv4 - IPv6 multicast gateway&#34;, Work in Progress, February 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Mul -GW] Venaas、S。、「IPv4 -IPv6マルチキャストゲートウェイ」、2003年2月に進行中の作業。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PRT] Castro, E. M., &#34;Programming guidelines on transition to IPv6 LONG project&#34;, Work in Progress, January 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PRT] Castro、E。M.、「IPv6 Long Projectへの移行に関するプログラミングガイドライン」、2003年1月の作業。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix A. Other Binary/Presentation Format Conversions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録A. その他のバイナリ/プレゼンテーション形式変換
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 6.2.3 describes the preferred way to perform binary/presentation format conversions; these can also be done by using inet_pton() and inet_ntop() and by writing protocol-dependent code. This approach is not recommended, but it is provided here for reference and comparison.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション6.2.3では、バイナリ/プレゼンテーション形式の変換を実行するための好ましい方法について説明します。これらは、inet_pton（）およびinet_ntop（）を使用したり、プロトコル依存コードを作成したりすることもできます。このアプローチは推奨されませんが、参照と比較のためにここで提供されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that inet_ntop()/inet_pton() lose the scope identifier (if used, e.g., with link-local addresses) in the conversions, contrary to the getaddrinfo()/getnameinfo() functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inet_ntop（）/inet_pton（）は、getaddrinfo（）/getnameInfo（）関数に反して、変換でスコープ識別子（例えば、リンクローカルアドレスを使用して、リンクローカルアドレスを使用する場合）を失うことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-1--Binary-to-Presentation-Using-inetntop">
A.1. Binary to Presentation Using inet_ntop()
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.1. INET_NTOP（）を使用してプレゼンテーションするバイナリからプレゼンテーション
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Conversions from network address structure to presentation format can be written as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークアドレス構造からプレゼンテーション形式への変換は、次のように記述できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
struct sockaddr_storage ss; char addrStr[INET6_ADDRSTRLEN];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
struct sockaddr_storage ss;char addrstr [inet6_addrstrlen];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* fill ss structure */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
switch (ss.ss_family) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
switch（ss.ss_family）{
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           case AF_INET:
                inet_ntop(ss.ss_family,
                         &amp;((struct sockaddr_in *)&amp;ss)-&gt;sin_addr,
                         addrStr,
                         sizeof(addrStr));
                break;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           case AF_INET6:
                inet_ntop(ss.ss_family,
                          &amp;((struct sockaddr_in6 *)&amp;ss)-&gt;sin6_addr,
                          addrStr,
                          sizeof(addrStr));
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
break;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
壊す;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           default:
                /* handle unknown family */
      }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that, the destination buffer addrStr should be long enough to contain the presentation address format: INET_ADDRSTRLEN for IPv4 and INET6_ADDRSTRLEN for IPv6. As INET6_ADDRSTRLEN is longer than INET_ADDRSTRLEN, the first one is used as the destination buffer length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先バッファaddRSTRは、プレゼンテーションアドレス形式を含めるのに十分な長さである必要があります：IPv4のINET_ADDRSTRLENおよびIPv6のINET6_ADDRSTRLEN。INET6_ADDRSTRLENはINET_ADDRSTRLENよりも長いため、最初のものは宛先バッファーの長さとして使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-2--Presentation-to-Binary-Using-inetpton">
A.2. Presentation to Binary Using inet_pton()
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2. inet_pton（）を使用してバイナリへのプレゼンテーション
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Conversions from presentation format to network address structure can be written as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プレゼンテーション形式からネットワークアドレス構造への変換は、次のように記述できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct sockaddr_storage ss;
      struct sockaddr_in *sin;
      struct sockaddr_in6 *sin6;
      char addrStr[INET6_ADDRSTRLEN];
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* fill addrStr buffer and ss.ss_family */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      switch (ss.ss_family) {
            case AF_INET:
                  sin = (struct sockaddr_in *)&amp;ss;
                  inet_pton(ss.ss_family,
                            addrStr,
                            (sockaddr *)&amp;sin-&gt;sin_addr));
                  break;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            case AF_INET6:
                  sin6 = (struct sockaddr_in6 *)&amp;ss;
                  inet_pton(ss.ss_family,
                            addrStr,
                            (sockaddr *)&amp;sin6-&gt;sin6_addr);
                  break;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            default:
                /* handle unknown family */
      }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that, the address family of the presentation format must be known.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プレゼンテーション形式のアドレスファミリを既知である必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Myung-Ki Shin ETRI/NIST 820 West Diamond Avenue Gaithersburg, MD 20899, USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Myung-ki shin etri/nist 820 West Diamond Avenue Gaithersburg、MD 20899、米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1 301 975-3613
   Fax:   +1 301 590-0932
   EMail: mshin@nist.gov
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Yong-Guen Hong ETRI PEC 161 Gajeong-Dong, Yuseong-Gu, Daejeon 305-350, Korea
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Yong-Guen Hong Etri Pec 161 Gajeong-Dong、Yusong-Gu、Daejeon 305-350、韓国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +82 42 860 6447
   Fax:   +82 42 861 5404
   EMail: yghong@pec.etri.re.kr
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jun-ichiro itojun HAGINO Research Laboratory, Internet Initiative Japan Inc. Takebashi Yasuda Bldg., 3-13 Kanda Nishiki-cho, Chiyoda-ku,Tokyo 101-0054, JAPAN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jun-Ithiro Itojun Hagino Research Laboratory、Internet Initiative Japan Inc. Takebashi Yasuda Bldg。、3-13 Kanda Nishiki-Cho、Chiyoda-Ku、Tokyo 101-0054、日本
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +81-3-5259-6350
   Fax:   +81-3-5259-6351
   EMail: itojun@iijlab.net
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pekka Savola CSC/FUNET Espoo, Finland
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pekka Savola CSC/Funet Espoo、フィンランド
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: psavola@funet.fi
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Eva M. Castro Rey Juan Carlos University (URJC) Departamento de Informatica, Estadistica y Telematica C/Tulipan s/n 28933 Madrid - SPAIN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Eva M. Castro Rey Juan Carlos University（URJC）Departamento de Informatica、Estadistica y Telematica C/Tulipan S/N 28933 Madrid -Spain
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: eva@gsyc.escet.urjc.es
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完全な著作権声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2005).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）The Internet Society（2005）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78に含まれる権利、ライセンス、および制限の対象となり、そこに記載されている場合を除き、著者はすべての権利を保持しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein are provided on an &#34;AS IS&#34; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントとここに含まれる情報は、「現状のまま」に基づいて提供されています。また、貢献者、彼/彼女が代表する組織（もしあれば）が後援する組織、インターネット協会とインターネット工学タスクフォースは、すべての保証、明示的または明示的、またはすべての保証を否認します。本書の情報の使用が、商品性または特定の目的に対する適合性の権利または黙示的な保証を侵害しないという保証を含むがこれらに限定されないことを含む。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Intellectual Property
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
知的財産
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFは、知的財産権またはその他の権利の有効性または範囲に関して、本書に記載されている技術の実装または使用、またはそのような権利に基づくライセンスに基づくライセンスの範囲に関連すると主張される可能性のある他の権利に関しては、立場を取得しません。利用可能になります。また、そのような権利を特定するために独立した努力をしたことも表明していません。RFCドキュメントの権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF事務局に行われたIPR開示のコピーと、利用可能にするライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような独自の権利の使用のための一般的なライセンスまたは許可を取得しようとする試みの結果を取得できます。http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFは、関心のある当事者に、著作権、特許、または特許出願、またはこの基準を実装するために必要なテクノロジーをカバーする可能性のあるその他の独自の権利を注意深く招待します。ietf-ipr@ietf.orgのIETFへの情報をお問い合わせください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFCエディター機能の資金は現在、インターネット協会によって提供されています。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
