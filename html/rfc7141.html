<!DOCTYPE html>


<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 7141 - Byte and Packet Congestion Notification 日本語訳</title>

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">7141</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc7141">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 7141 - Byte and Packet Congestion Notification 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc7141">
            https://datatracker.ietf.org/doc/html/rfc7141
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 7141 - バイトおよびパケットの輻輳通知</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <h6 class="card-title">要約（自動生成）</h6>
            <p class="card-text">RFC 7141は、ネットワークのバイトとパケットの混雑を通知するための仕様です。その目的は、ネットワークの混雑状況を正確に把握し、トラフィック制御や品質の向上を可能にすることです。</p>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                        B. Briscoe
Request for Comments: 7141                                            BT
BCP: 41                                                        J. Manner
Updates: 2309, 2914                                     Aalto University
Category: Best Current Practice                            February 2014
ISSN: 2070-1721
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
Byte and Packet Congestion Notification
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
バイトおよびパケットの輻輳通知
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document provides recommendations of best current practice for dropping or marking packets using any active queue management (AQM) algorithm, including Random Early Detection (RED), BLUE, Pre-Congestion Notification (PCN), and newer schemes such as CoDel (Controlled Delay) and PIE (Proportional Integral controller Enhanced). We give three strong recommendations: (1) packet size should be taken into account when transports detect and respond to congestion indications, (2) packet size should not be taken into account when network equipment creates congestion signals (marking, dropping), and therefore (3) in the specific case of RED, the byte-mode packet drop variant that drops fewer small packets should not be used. This memo updates RFC 2309 to deprecate deliberate preferential treatment of small packets in AQM algorithms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、ランダム早期検出（RED）、BLUE、事前輻輳通知（PCN）、およびCoDel（制御遅延）などの新しいスキームを含む、アクティブキュー管理（AQM）アルゴリズムを使用してパケットをドロップまたはマーキングするための現在のベストプラクティスの推奨事項を提供します）およびPIE（強化された比例積分コントローラー）。 3つの強力な推奨事項を提示します。（1）トランスポートが輻輳の兆候を検出して応答する場合はパケットサイズを考慮する必要があります。（2）ネットワーク機器が輻輳信号（マーキング、ドロップ）を作成する場合はパケットサイズを考慮しない必要があります。 （3）REDの特定のケースでは、小さいパケットをドロップするバイトモードパケットドロップバリアントを使用しないでください。このメモはRFC 2309を更新して、AQMアルゴリズムでの小さなパケットの意図的な優先的な扱いを廃止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo documents an Internet Best Current Practice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、インターネットの現在のベストプラクティスを文書化したものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on BCPs is available in Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。 BCPの詳細については、RFC 5741のセクション2をご覧ください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7141.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7141で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）2014 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4
     1.1.  Terminology and Scoping . . . . . . . . . . . . . . . . .   6
     1.2.  Example Comparing Packet-Mode Drop and Byte-Mode Drop . .   7
   2.  Recommendations . . . . . . . . . . . . . . . . . . . . . . .   9
     2.1.  Recommendation on Queue Measurement . . . . . . . . . . .   9
     2.2.  Recommendation on Encoding Congestion Notification  . . .  10
     2.3.  Recommendation on Responding to Congestion  . . . . . . .  11
     2.4.  Recommendation on Handling Congestion Indications When
           Splitting or Merging Packets  . . . . . . . . . . . . . .  12
   3.  Motivating Arguments  . . . . . . . . . . . . . . . . . . . .  13
     3.1.  Avoiding Perverse Incentives to (Ab)use Smaller Packets .  13
     3.2.  Small != Control  . . . . . . . . . . . . . . . . . . . .  14
     3.3.  Transport-Independent Network . . . . . . . . . . . . . .  14
     3.4.  Partial Deployment of AQM . . . . . . . . . . . . . . . .  16
     3.5.  Implementation Efficiency . . . . . . . . . . . . . . . .  17
   4.  A Survey and Critique of Past Advice  . . . . . . . . . . . .  17
     4.1.  Congestion Measurement Advice . . . . . . . . . . . . . .  18
       4.1.1.  Fixed-Size Packet Buffers . . . . . . . . . . . . . .  18
       4.1.2.  Congestion Measurement without a Queue  . . . . . . .  19
     4.2.  Congestion Notification Advice  . . . . . . . . . . . . .  20
       4.2.1.  Network Bias When Encoding  . . . . . . . . . . . . .  20
       4.2.2.  Transport Bias When Decoding  . . . . . . . . . . . .  22
       4.2.3.  Making Transports Robust against Control Packet
               Losses  . . . . . . . . . . . . . . . . . . . . . . .  23
       4.2.4.  Congestion Notification: Summary of Conflicting
               Advice  . . . . . . . . . . . . . . . . . . . . . . .  24
   5.  Outstanding Issues and Next Steps . . . . . . . . . . . . . .  25
     5.1.  Bit-congestible Network . . . . . . . . . . . . . . . . .  25
     5.2.  Bit- and Packet-Congestible Network . . . . . . . . . . .  26
   6.  Security Considerations . . . . . . . . . . . . . . . . . . .  26
   7.  Conclusions . . . . . . . . . . . . . . . . . . . . . . . . .  27
   8.  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  28
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  28
     9.1.  Normative References  . . . . . . . . . . . . . . . . . .  28
     9.2.  Informative References  . . . . . . . . . . . . . . . . .  29
   Appendix A.  Survey of RED Implementation Status  . . . . . . . .  33
   Appendix B.  Sufficiency of Packet-Mode Drop  . . . . . . . . . .  34
     B.1.  Packet-Size (In)Dependence in Transports  . . . . . . . .  35
     B.2.  Bit-Congestible and Packet-Congestible Indications  . . .  38
   Appendix C.  Byte-Mode Drop Complicates Policing Congestion
                Response . . . . . . . . . . . . . . . . . . . . . .  39
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document provides recommendations of best current practice for how we should correctly scale congestion control functions with respect to packet size for the long term. It also recognises that expediency may be necessary to deal with existing widely deployed protocols that don&#39;t live up to the long-term goal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、長期的にパケットサイズに関して輻輳制御機能を正しくスケーリングする方法に関する現在のベストプラクティスの推奨事項を提供します。また、長期的な目標を達成できない既存の広く展開されているプロトコルに対処するには、便宜が必要になる場合があることも認識しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When signalling congestion, the problem of how (and whether) to take packet sizes into account has exercised the minds of researchers and practitioners for as long as active queue management (AQM) has been discussed. Indeed, one reason AQM was originally introduced was to reduce the lock-out effects that small packets can have on large packets in tail-drop queues. This memo aims to state the principles we should be using and to outline how these principles will affect future protocol design, taking into account pre-existing deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳を通知するとき、パケットサイズを考慮する方法（およびその方法）の問題は、アクティブキュー管理（AQM）が存在する限り、研究者や実務家の心を動かしてきました。実際、AQMが最初に導入された理由の1つは、テールドロップキューの大きなパケットに対して小さなパケットが持つ可能性のあるロックアウト効果を減らすことでした。このメモは、既存の展開を考慮に入れて、使用すべき原則を述べ、これらの原則が将来のプロトコル設計にどのように影響するかを概説することを目的としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The question of whether to take into account packet size arises at three stages in the congestion notification process:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットサイズを考慮するかどうかの問題は、輻輳通知プロセスの3つの段階で発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Measuring congestion: When a congested resource measures locally how congested it is, should it measure its queue length in time, bytes, or packets?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳の測定：輻輳したリソースがローカルでどれだけ輻輳しているかを測定する場合、それは時間、バイト、またはパケットでそのキューの長さを測定する必要がありますか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding congestion notification into the wire protocol: When a congested network resource signals its level of congestion, should the probability that it drops/marks each packet depend on the size of the particular packet in question?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳通知をワイヤープロトコルにエンコードする：輻輳したネットワークリソースがその輻輳のレベルを通知する場合、各パケットをドロップ/マークする確率は、問題の特定のパケットのサイズに依存する必要がありますか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Decoding congestion notification from the wire protocol: When a transport interprets the notification in order to decide how much to respond to congestion, should it take into account the size of each missing or marked packet?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ワイヤープロトコルからの輻輳通知のデコード：トランスポートが輻輳にどの程度応答するかを決定するために通知を解釈するとき、欠落ま​​たはマークされた各パケットのサイズを考慮する必要がありますか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consensus has emerged over the years concerning the first stage, which Section 2.1 records in the RFC Series. In summary: If possible, it is best to measure congestion by time in the queue; otherwise, the choice between bytes and packets solely depends on whether the resource is congested by bytes or packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 2.1でセクション2.1に記録されている第1ステージに関するコンセンサスが長年にわたって浮上しています。要約：可能であれば、キュー内の時間で輻輳を測定するのが最善です。それ以外の場合、バイトとパケットのどちらを選択するかは、リソースがバイトまたはパケットによって輻輳しているかどうかにのみ依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The controversy is mainly around the last two stages: whether to allow for the size of the specific packet notifying congestion i) when the network encodes or ii) when the transport decodes the congestion notification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
論争は主に最後の2つの段階の周りです：混雑を通知する特定のパケットのサイズを許可するかどうかi）ネットワークがエンコードするとき、またはii）トランスポートが混雑通知をデコードするとき。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Currently, the RFC series is silent on this matter other than a paper trail of advice referenced from [RFC2309], which conditionally recommends byte-mode (packet-size dependent) drop [pktByteEmail].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在、RFCシリーズは、[RFC2309]から参照されているバイトモード（パケットサイズに依存）のドロップ[pktByteEmail]を条件付きで推奨するペーパートレイルトレイトを除いて、この問題については触れていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reducing the number of small packets dropped certainly has some tempting advantages: i) it drops fewer control packets, which tend to be small and ii) it makes TCP&#39;s bit rate less dependent on packet size. However, there are ways of addressing these issues at the transport layer, rather than reverse engineering network forwarding to fix the problems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ドロップされる小さなパケットの数を減らすと、確かにいくつかの魅力的な利点があります。i）ドロップする制御パケットが少なくなる傾向があり、ii）パケットサイズに依存するTCPのビットレートが少なくなります。ただし、ネットワーク転送をリバースエンジニアリングして問題を修正するのではなく、トランスポート層でこれらの問題に対処する方法があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo updates [RFC2309] to deprecate deliberate preferential treatment of packets in AQM algorithms solely because of their size. It recommends that (1) packet size should be taken into account when transports detect and respond to congestion indications, (2) not when network equipment creates them. This memo also adds to the congestion control principles enumerated in BCP 41 [RFC2914].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、[RFC2309]を更新して、AQMアルゴリズムでのパケットの意図的な優先的な扱いを非推奨にしました。 （1）トランスポートが輻輳表示を検出してそれに応答するときは、（2）ネットワーク機器が輻輳表示を作成するときではなく、（1）パケットサイズを考慮することをお勧めします。このメモは、BCP 41 [RFC2914]に列挙されている輻輳制御の原則にも追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the particular case of Random Early Detection (RED), this means that the byte-mode packet drop variant should not be used to drop fewer small packets, because that creates a perverse incentive for transports to use tiny segments, consequently also opening up a DoS vulnerability. Fortunately, all the RED implementers who responded to our admittedly limited survey (Section 4.2.4) have not followed the earlier advice to use byte-mode drop, so the position this memo argues for seems to already exist in implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ランダム早期検出（RED）の特定のケースでは、これは、バイトモードパケットドロップバリアントを使用して小さなパケットをドロップするべきではないことを意味します。これは、トランスポートが小さなセグメントを使用するためのひねくれたインセンティブを作成し、その結果、 DoSの脆弱性。幸いにも、私たちの確かに限られた調査（セクション4.2.4）に回答したすべてのRED実装者は、バイトモードドロップを使用するための以前のアドバイスに従っていないため、このメモが主張する位置は実装にすでに存在しているようです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, at the transport layer, TCP congestion control is a widely deployed protocol that doesn&#39;t scale with packet size (i.e., its reduction in rate does not take into account the size of a lost packet). To date, this hasn&#39;t been a significant problem because most TCP implementations have been used with similar packet sizes. But, as we design new congestion control mechanisms, this memo recommends that we build in scaling with packet size rather than assuming that we should follow TCP&#39;s example.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、トランスポート層では、TCP輻輳制御は広く展開されているプロトコルであり、パケットサイズに比例しません（つまり、レートの低下では、失われたパケットのサイズは考慮されません）。これまでのところ、ほとんどのTCP実装が同様のパケットサイズで使用されているため、これは重大な問題ではありません。ただし、新しい輻輳制御メカニズムを設計するとき、このメモは、TCPの例に従う必要があると想定するのではなく、パケットサイズでスケーリングを組み込むことを推奨します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo continues as follows. First, it discusses terminology and scoping. Section 2 gives concrete formal recommendations, followed by motivating arguments in Section 3. We then critically survey the advice given previously in the RFC Series and the research literature (Section 4), referring to an assessment of whether or not this advice has been followed in production networks (Appendix A). To wrap up, outstanding issues are discussed that will need resolution both to inform future protocol designs and to handle legacy AQM deployments (Section 5). Then security issues are collected together in Section 6 before conclusions are drawn in Section 7. The interested reader can find discussion of more detailed issues on the theme of byte vs. packet in the appendices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは次のように続きます。まず、用語とスコーピングについて説明します。セクション2では具体的な正式な推奨事項を示し、その後セクション3で動機付けの議論を行います。次に、RFCシリーズおよび研究文献（セクション4）で以前に与えられたアドバイスを批判的に調査し、このアドバイスが従われたかどうかの評価を参照します。本番ネットワーク（付録A）。まとめとして、将来のプロトコル設計に通知し、レガシーAQMデプロイメントを処理するための解決策が必要な未解決の問題について説明します（セクション5）。次に、セクション6でセキュリティの問題をまとめてから、セクション7で結論を出します。関心のある読者は、付録でバイトとパケットのテーマに関するより詳細な問題の説明を見つけることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo intentionally includes a non-negligible amount of material on the subject. For the busy reader, Section 2 summarises the recommendations for the Internet community.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモには、対象に関する無視できない量の資料が意図的に含まれています。忙しい読者のために、セクション2はインターネットコミュニティの推奨事項を要約しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-1--Terminology-and-Scoping">
1.1. Terminology and Scoping
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. 用語とスコーピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 [RFC2119]で説明されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo applies to the design of all AQM algorithms, for example, Random Early Detection (RED) [RFC2309], BLUE [BLUE02], Pre-Congestion Notification (PCN) [RFC5670], Controlled Delay (CoDel) [CoDel], and the Proportional Integral controller Enhanced (PIE) [PIE]. Throughout, RED is used as a concrete example because it is a widely known and deployed AQM algorithm. There is no intention to imply that the advice is any less applicable to the other algorithms, nor that RED is preferred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、ランダム早期検出（RED）[RFC2309]、ブルー[BLUE02]、輻輳前通知（PCN）[RFC5670]、制御遅延（CoDel）[CoDel]など、すべてのAQMアルゴリズムの設計に適用されます。 Proportional Integral Controller Enhanced（PIE）[PIE]。 REDは、広く知られ、展開されているAQMアルゴリズムであるため、全体を通して具体的な例として使用されています。このアドバイスが他のアルゴリズムにあまり適用されないこと、またはREDが推奨されることを暗示する意図はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Congestion Notification: Congestion notification is a changing signal that aims to communicate the probability that the network resource(s) will not be able to forward the level of traffic load offered (or that there is an impending risk that they will not be able to).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳通知：輻輳通知は変化する信号であり、ネットワークリソースが提供されたトラフィック負荷のレベルを転送できなくなる可能性があることを通知することを目的としています（またはそれらができない差し迫ったリスクがある） 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The &#39;impending risk&#39; qualifier is added, because AQM systems set a virtual limit smaller than the actual limit to the resource, then notify the transport when this virtual limit is exceeded in order to avoid uncontrolled congestion of the actual capacity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
AQMシステムはリソースに実際の制限よりも小さい仮想制限を設定するため、「差し迫ったリスク」修飾子が追加され、実際の容量の制御されない輻輳を回避するために、この仮想制限を超えたときにトランスポートに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Congestion notification communicates a real number bounded by the range [ 0 , 1 ]. This ties in with the most well-understood measure of congestion notification: drop probability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
輻輳通知は、[0、1]の範囲で囲まれた実数を伝えます。これは、最もよく理解されている輻輳通知の測定値、つまりドロップ確率と関連しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Explicit and Implicit Notification: The byte vs. packet dilemma concerns congestion notification irrespective of whether it is signalled implicitly by drop or explicitly using ECN [RFC3168] or PCN [RFC5670]. Throughout this document, unless clear from the context, the term &#39;marking&#39; will be used to mean notifying congestion explicitly, while &#39;congestion notification&#39; will be used to mean notifying congestion either implicitly by drop or explicitly by marking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
明示的および暗黙的な通知：バイト対パケットのジレンマは、ドロップによって暗黙的に通知されるのか、またはECN [RFC3168]またはPCN [RFC5670]を明示的に使用して通知されるのかに関係なく、輻輳通知に関係します。このドキュメント全体を通して、文脈から明らかでない限り、「マーキング」という用語は、輻輳を明示的に通知することを意味するために使用され、「輻輳通知」は、ドロップによって暗黙的にまたは明示的にマーキングによって輻輳を通知することを意味するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bit-congestible vs. Packet-congestible: If the load on a resource depends on the rate at which packets arrive, it is called &#39;packet-congestible&#39;. If the load depends on the rate at which bits arrive, it is called &#39;bit-congestible&#39;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビット一致とパケット一致：リソースの負荷がパケットの到着速度に依存する場合、それは「パケット一致」と呼ばれます。負荷がビットの到着速度に依存する場合、それは「ビット一致」と呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Examples of packet-congestible resources are route look-up engines and firewalls, because load depends on how many packet headers they have to process. Examples of bit-congestible resources are transmission links, radio power, and most buffer memory, because the load depends on how many bits they have to transmit or store. Some machine architectures use fixed-size packet buffers, so buffer memory in these cases is packet-congestible (see Section 4.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
負荷は、処理する必要のあるパケットヘッダーの数に依存するため、パケットが密集するリソースの例として、ルートルックアップエンジンやファイアウォールがあります。負荷は送信または保存する必要のあるビット数に依存するため、ビットが密集するリソースの例としては、送信リンク、無線電力、ほとんどのバッファメモリがあります。一部のマシンアーキテクチャは固定サイズのパケットバッファを使用するため、これらの場合のバッファメモリはパケットに適合します（セクション4.1.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The path through a machine will typically encounter both packet-congestible and bit-congestible resources. However, currently, a design goal of network processing equipment such as routers and firewalls is to size the packet-processing engine(s) relative to the lines in order to keep packet processing uncongested, even under worst-case packet rates with runs of minimum-size packets. Therefore, packet congestion is currently rare (see Section 3.3 of [RFC6077]), but there is no guarantee that it will not become more common in the future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
マシンを経由するパスは、通常、パケットが密集しているリソースとビットが密集しているリソースの両方に遭遇します。ただし、現在、ルーターやファイアウォールなどのネットワーク処理機器の設計目標は、最低限の実行で最悪のパケットレートでもパケット処理を輻輳させないようにするために、ラインに対してパケット処理エンジンのサイズを決めることです。サイズのパケット。したがって、現在のところパケットの輻輳はまれです（[RFC6077]のセクション3.3を参照）。ただし、今後輻輳が発生しなくなるとは限りません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note that information is generally processed or transmitted with a minimum granularity greater than a bit (e.g., octets). The appropriate granularity for the resource in question should be used, but for the sake of brevity we will talk in terms of bytes in this memo.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
情報は通常、ビットよりも大きい最小粒度（オクテットなど）で処理または送信されることに注意してください。問題のリソースに適切な粒度を使用する必要がありますが、簡潔にするために、このメモではバイトの観点から説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Coarser Granularity: Resources may be congestible at higher levels of granularity than bits or packets, for instance stateful firewalls are flow-congestible and call-servers are session-congestible. This memo focuses on congestion of connectionless resources, but the same principles may be applicable for congestion notification protocols controlling per-flow and per-session processing or state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
より粗い粒度：リソースは、ビットやパケットよりも高いレベルの粒度で密集している可能性があります。たとえば、ステートフルファイアウォールはフローで密集し、コールサーバーはセッションで密集します。このメモはコネクションレスリソースの輻輳に焦点を当てていますが、フローごとおよびセッションごとの処理または状態を制御する輻輳通知プロトコルにも同じ原則が適用される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RED Terminology: In RED, whether to use packets or bytes when measuring queues is called, respectively, &#39;packet-mode queue measurement&#39; or &#39;byte-mode queue measurement&#39;. And whether the probability of dropping a particular packet is independent or dependent on its size is called, respectively, &#39;packet-mode drop&#39; or &#39;byte-mode drop&#39;. The terms &#39;byte-mode&#39; and &#39;packet-mode&#39; should not be used without specifying whether they apply to queue measurement or to drop.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REDの用語：REDでは、キューを測定するときにパケットを使用するかバイトを使用するかは、それぞれ「パケットモードキュー測定」または「バイトモードキュー測定」と呼ばれます。また、特定のパケットをドロップする確率が独立しているか、そのサイズに依存しているかは、それぞれ「パケットモードドロップ」または「バイトモードドロップ」と呼ばれます。 「バイトモード」および「パケットモード」という用語は、キュー測定に適用されるかドロップに適用されるかを指定せずに使用しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-2--Example-Comparing-Packet-Mode-Drop-and-Byte-Mode-Drop">
1.2. Example Comparing Packet-Mode Drop and Byte-Mode Drop
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. パケットモードドロップとバイトモードドロップの比較例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Taking RED as a well-known example algorithm, a central question addressed by this document is whether to recommend RED&#39;s packet-mode drop variant and to deprecate byte-mode drop. Table 1 compares how packet-mode and byte-mode drop affect two flows of different size packets. For each it gives the expected number of packets and of bits dropped in one second. Each example flow runs at the same bit rate of 48 Mbps, but one is broken up into small 60 byte packets and the other into large 1,500 byte packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
よく知られているアルゴリズムの例としてREDを取り上げ、このドキュメントで扱われている中心的な質問は、REDのパケットモードドロップバリアントを推奨するか、バイトモードドロップを非推奨にするかです。表1は、パケットモードとバイトモードのドロップが異なるサイズのパケットの2つのフローにどのように影響するかを比較しています。それぞれに、1秒間にドロップされたパケットとビットの予想数を示します。各サンプルフローは48 Mbpsの同じビットレートで実行されますが、1つは小さな60バイトパケットに分割され、もう1つは大きな1,500バイトパケットに分割されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To keep up the same bit rate, in one second there are about 25 times more small packets because they are 25 times smaller. As can be seen from the table, the packet rate is 100,000 small packets versus 4,000 large packets per second (pps).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じビットレートを維持するために、1秒間に25分の1の小さいパケットがあるため、パケットは25分の1になります。この表からわかるように、パケットレートは100,000の小さなパケット対4,000の大きなパケット/秒（pps）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     Parameter            Formula         Small packets Large packets
     -------------------- --------------- ------------- -------------
     Packet size          s/8                      60 B       1,500 B
     Packet size          s                       480 b      12,000 b
     Bit rate             x                     48 Mbps       48 Mbps
     Packet rate          u = x/s              100 kpps        4 kpps
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Packet-mode Drop Pkt-loss probability p 0.1% 0.1% Pkt-loss rate p*u 100 pps 4 pps Bit-loss rate p*u*s 48 kbps 48 kbps
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
パケットモードドロップパケット損失確率p 0.1％0.1％パケット損失率p * u 100 pps 4 ppsビット損失率p * u * s 48 kbps 48 kbps
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     Byte-mode Drop       MTU, M=12,000 b
     Pkt-loss probability b = p*s/M              0.004%          0.1%
     Pkt-loss rate        b*u                     4 pps         4 pps
     Bit-loss rate        b*u*s               1.92 kbps       48 kbps
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Table 1: Example Comparing Packet-Mode and Byte-Mode Drop
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
表1：パケットモードとバイトモードのドロップの比較例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For packet-mode drop, we illustrate the effect of a drop probability of 0.1%, which the algorithm applies to all packets irrespective of size. Because there are 25 times more small packets in one second, it naturally drops 25 times more small packets, that is, 100 small packets but only 4 large packets. But if we count how many bits it drops, there are 48,000 bits in 100 small packets and 48,000 bits in 4 large packets -- the same number of bits of small packets as large.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットモードドロップの場合、0.1％のドロップ確率の影響を示します。このアルゴリズムは、サイズに関係なくすべてのパケットに適用されます。 1秒間に25倍以上の小さなパケットがあるため、自然に25倍以上の小さなパケットがドロップされます。つまり、100の小さなパケットが4つの大きなパケットだけになります。しかし、それが何ビット落ちたかを数えると、100の小さなパケットで48,000ビット、4つの大きなパケットで48,000ビット-小さなパケットのビット数と同じ数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The packet-mode drop algorithm drops any bit with the same probability whether the bit is in a small or a large packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パケットモードドロップアルゴリズムは、ビットが小さいパケットでも大きいパケットでも、同じ確率でビットをドロップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 For byte-mode drop, again we use an example drop probability of 0.1%, but only for maximum size packets (assuming the link maximum transmission unit (MTU) is 1,500 B or 12,000 b). The byte-mode algorithm reduces the drop probability of smaller packets proportional to their size, making the probability that it drops a small packet 25 times smaller at 0.004%. But there are 25 times more small packets, so dropping them with 25 times lower probability results in dropping the same number of packets: 4 drops in both cases. The 4 small dropped packets contain 25 times less bits than the 4 large dropped packets: 1,920 compared to 48,000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
バイトモードドロップの場合も、0.1％のドロップ確率の例を使用しますが、これは最大サイズのパケットに対してのみです（リンクの最大伝送ユニット（MTU）が1,500 Bまたは12,000 bであると想定）。バイトモードアルゴリズムは、サイズに比例して小さいパケットのドロップ確率を減らし、小さいパケットをドロップする確率を0.004％で25倍小さくします。ただし、小さいパケットは25倍多いため、25倍低い確率でドロップすると、同じ数のパケットがドロップされます。どちらの場合も4ドロップです。 4つの小さなドロップされたパケットのビット数は、4つの大きなドロップされたパケットの25分の1です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The byte-mode drop algorithm drops any bit with a probability proportionate to the size of the packet it is in.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
バイトモードドロップアルゴリズムは、パケットのサイズに比例する確率でビットをドロップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Recommendations">
2. Recommendations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 推奨事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section gives recommendations related to network equipment in Sections 2.1 and 2.2, and we discuss the implications on transport protocols in Sections 2.3 and 2.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、セクション2.1および2.2でネットワーク機器に関連する推奨事項を示し、セクション2.3および2.4でトランスポートプロトコルへの影響について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1--Recommendation-on-Queue-Measurement">
2.1. Recommendation on Queue Measurement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. キュー測定に関する推奨事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ideally, an AQM would measure the service time of the queue to measure congestion of a resource. However service time can only be measured as packets leave the queue, where it is not always expedient to implement a full AQM algorithm. To predict the service time as packets join the queue, an AQM algorithm needs to measure the length of the queue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
理想的には、AQMはキューのサービス時間を測定して、リソースの輻輳を測定します。ただし、サービス時間は、パケットがキューを離れるときにのみ測定できます。この場合、完全なAQMアルゴリズムを実装することが常に適切であるとは限りません。パケットがキューに加わるときのサービス時間を予測するには、AQMアルゴリズムでキューの長さを測定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this case, if the resource is bit-congestible, the AQM implementation SHOULD measure the length of the queue in bytes and, if the resource is packet-congestible, the implementation SHOULD measure the length of the queue in packets. Subject to the exceptions below, no other choice makes sense, because the number of packets waiting in the queue isn&#39;t relevant if the resource gets congested by bytes and vice versa. For example, the length of the queue into a transmission line would be measured in bytes, while the length of the queue into a firewall would be measured in packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この場合、リソースがビットコンセッション可能である場合、AQM実装はキューの長さをバイト単位で測定する必要があり（SHOULD）、リソースがパケットコンジェスト可能である場合、実装はキューの長さをパケット単位で測定する必要があります（SHOULD）。以下の例外を条件として、リソースがバイトで輻輳した場合、またはその逆の場合、キューで待機しているパケットの数は関係ないため、他の選択は意味がありません。たとえば、伝送ラインへのキューの長さはバイト単位で測定され、ファイアウォールへのキューの長さはパケット単位で測定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid the pathological effects of tail drop, the AQM can then transform this service time or queue length into the probability of dropping or marking a packet (e.g., RED&#39;s piecewise linear function between thresholds).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
テールドロップの病理学的影響を回避するために、AQMはこのサービス時間またはキューの長さをパケットのドロップまたはマーキングの確率に変換できます（たとえば、しきい値間のREDの区分的線形関数）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
What this advice means for RED as a specific example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具体的な例として、このアドバイスがREDにとって意味すること：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. A RED implementation SHOULD use byte-mode queue measurement for measuring the congestion of bit-congestible resources and packet-mode queue measurement for packet-congestible resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. REDの実装では、ビットが密集するリソースの輻輳を測定するためにバイトモードキュー測定を使用し、パケットが密集するリソースに対してパケットモードキュー測定を使用する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. An implementation SHOULD NOT make it possible to configure the way a queue measures itself, because whether a queue is bit-congestible or packet-congestible is an inherent property of the queue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 実装は、キューがそれ自体を測定する方法を構成することを可能にするべきではありません。なぜなら、キューがビットコンセッション可能であるか、パケットコンセッション可能であるかは、キューの固有のプロパティだからです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Exceptions to these recommendations might be necessary, for instance where a packet-congestible resource has to be configured as a proxy bottleneck for a bit-congestible resource in an adjacent box that does not support AQM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの推奨事項の例外が必要になる場合があります。たとえば、パケットが密集するリソースを、AQMをサポートしない隣接するボックス内のビットが密集するリソースのプロキシボトルネックとして構成する必要がある場合などです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The recommended approach in less straightforward scenarios, such as fixed-size packet buffers, resources without a queue, and buffers comprising a mix of packet and bit-congestible resources, is discussed in Section 4.1. For instance, Section 4.1.1 explains that the queue into a line should be measured in bytes even if the queue consists of fixed-size packet buffers, because the root cause of any congestion is bytes arriving too fast for the line -- packets filling buffers are merely a symptom of the underlying congestion of the line.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
固定サイズのパケットバッファー、キューのないリソース、パケットとビットが混み合うリソースの組み合わせで構成されるバッファーなど、それほど単純ではないシナリオで推奨されるアプローチについては、セクション4.1で説明します。たとえば、セクション4.1.1は、キューが固定サイズのパケットバッファーで構成されている場合でも、回線へのキューはバイト単位で測定する必要があると説明しています。バッファは、単に回線の混雑の兆候にすぎません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2--Recommendation-on-Encoding-Congestion-Notification">
2.2. Recommendation on Encoding Congestion Notification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. 混雑通知のエンコードに関する推奨事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When encoding congestion notification (e.g., by drop, ECN, or PCN), the probability that network equipment drops or marks a particular packet to notify congestion SHOULD NOT depend on the size of the packet in question. As the example in Section 1.2 illustrates, to drop any bit with probability 0.1%, it is only necessary to drop every packet with probability 0.1% without regard to the size of each packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳通知をエンコードする場合（ドロップ、ECN、PCNなど）、ネットワーク機器が特定のパケットをドロップまたはマークして、輻輳を通知する確率は、問題のパケットのサイズに依存してはいけません（SHOULD NOT）。セクション1.2の例が示すように、0.1％の確率でビットをドロップするには、各パケットのサイズに関係なく、0.1％の確率ですべてのパケットをドロップする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This approach ensures the network layer offers sufficient congestion information for all known and future transport protocols and also ensures no perverse incentives are created that would encourage transports to use inappropriately small packet sizes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアプローチは、ネットワークレイヤーがすべての既知および将来のトランスポートプロトコルに十分な輻輳情報を提供することを保証し、トランスポートが不適切に小さいパケットサイズを使用することを促す不正なインセンティブが作成されないことも保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
What this advice means for RED as a specific example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具体的な例として、このアドバイスがREDにとって意味すること：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The RED AQM algorithm SHOULD NOT use byte-mode drop, i.e., it ought to use packet-mode drop. Byte-mode drop is more complex, it creates the perverse incentive to fragment segments into tiny pieces and it is vulnerable to floods of small packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. RED AQMアルゴリズムでは、バイトモードドロップを使用しないでください。つまり、パケットモードドロップを使用する必要があります。バイトモードドロップはより複雑であり、セグメントを小さな断片にフラグメント化するという不正なインセンティブを作成し、小さなパケットのフラッドに対して脆弱です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If a vendor has implemented byte-mode drop, and an operator has turned it on, it is RECOMMENDED that the operator use packet-mode drop instead, after establishing if there are any implications on the relative performance of applications using different packet sizes. The unlikely possibility of some application-specific legacy use of byte-mode drop is the only reason that all the above recommendations on encoding congestion notification are not phrased more strongly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. ベンダーがバイトモードドロップを実装していて、オペレーターがそれをオンにしている場合、異なるパケットサイズを使用するアプリケーションの相対的なパフォーマンスに何らかの影響があるかどうかを確認した後、オペレーターが代わりにパケットモードドロップを使用することをお勧めします。バイトモードドロップのアプリケーション固有のレガシー使用の可能性は低いですが、輻輳通知のエンコードに関する上記のすべての推奨事項がこれ以上強く表現されていない唯一の理由です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
RED as a whole SHOULD NOT be switched off. Without RED, a tail-drop queue biases against large packets and is vulnerable to floods of small packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
赤は全体としてオフにしないでください。 REDがない場合、テールドロップキューは大きなパケットに偏り、小さなパケットのフラッディングに対して脆弱です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note well that RED&#39;s byte-mode queue drop is completely orthogonal to byte-mode queue measurement and should not be confused with it. If a RED implementation has a byte-mode but does not specify what sort of byte-mode, it is most probably byte-mode queue measurement, which is fine. However, if in doubt, the vendor should be consulted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REDのバイトモードキュードロップは、バイトモードキュー測定と完全に直交しており、それと混同しないように注意してください。 REDの実装にバイトモードがあるが、バイトモードの種類を指定していない場合、それはおそらくバイトモードのキュー測定であり、問​​題ありません。ただし、疑わしい場合は、ベンダーに相談する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A survey (Appendix A) showed that there appears to be little, if any, installed base of the byte-mode drop variant of RED. This suggests that deprecating byte-mode drop will have little, if any, incremental deployment impact.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
調査（付録A）では、REDのバイトモードドロップバリアントのインストールベースがあったとしても、ほとんどないようでした。これは、非推奨のバイトモードドロップが段階的な展開の影響を持っているとしても、ほとんどないことを示唆しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3--Recommendation-on-Responding-to-Congestion">
2.3. Recommendation on Responding to Congestion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. 混雑への対応に関する推奨事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a transport detects that a packet has been lost or congestion marked, it SHOULD consider the strength of the congestion indication as proportionate to the size in octets (bytes) of the missing or marked packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランスポートは、パケットが失われた、またはマークされた輻輳が検出された場合、輻輳表示の強度を、欠落またはマークされたパケットのオクテット（バイト）単位のサイズに比例すると見なすべきです（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In other words, when a packet indicates congestion (by being lost or marked), it can be considered conceptually as if there is a congestion indication on every octet of the packet, not just one indication per packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
言い換えると、パケットが（紛失またはマークによって）輻輳を示す場合、概念的には、パケットごとの1つの表示ではなく、パケットのすべてのオクテットに輻輳表示があるかのように考えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To be clear, the above recommendation solely describes how a transport should interpret the meaning of a congestion indication, as a long term goal. It makes no recommendation on whether a transport should act differently based on this interpretation. It merely aids interoperability between transports, if they choose to make their actions depend on the strength of congestion indications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
明確にするために、上記の推奨事項は、トランスポートが輻輳の兆候の意味を長期的な目標としてどのように解釈すべきかについてのみ説明しています。トランスポートがこの解釈に基づいて異なる動作をするべきかどうかについては推奨していません。混雑の兆候の強さに依存してアクションを実行することを選択した場合、トランスポート間の相互運用性を支援するだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This definition will be useful as the IETF transport area continues its programme of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この定義は、IETFトランスポートエリアが次のプログラムを継続するときに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o updating host-based congestion control protocols to take packet size into account, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o パケットサイズを考慮してホストベースの輻輳制御プロトコルを更新し、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o making transports less sensitive to losing control packets like SYNs and pure ACKs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SYNや純粋なACKなどの制御パケットの損失に対するトランスポートの感度を低くする。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
What this advice means for the case of TCP:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアドバイスがTCPの場合に意味すること：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If two TCP flows with different packet sizes are required to run at equal bit rates under the same path conditions, this SHOULD be done by altering TCP (Section 4.2.2), not network equipment (the latter affects other transports besides TCP).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 同じパス条件で等しいビットレートで実行するために、異なるパケットサイズの2つのTCPフローが必要な場合、これは、ネットワーク機器ではなくTCPを変更することによって行われる必要があります（セクション4.2.2）（後者はTCP以外の他のトランスポートに影響します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If it is desired to improve TCP performance by reducing the chance that a SYN or a pure ACK will be dropped, this SHOULD be done by modifying TCP (Section 4.2.3), not network equipment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. SYNまたは純粋なACKがドロップされる可能性を減らすことによってTCPパフォーマンスを改善することが望まれる場合、これはネットワーク機器ではなく、TCP（セクション4.2.3）を変更することによって行われる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To be clear, we are not recommending at all that TCPs under equivalent conditions should aim for equal bit rates. We are merely saying that anyone trying to do such a thing should modify their TCP algorithm, not the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
明確にするために、同等の条件下でのTCPが等しいビットレートを目標とすることをまったくお勧めしません。そのようなことを行おうとする人は、ネットワークではなく、TCPアルゴリズムを変更するべきだと言っているだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These recommendations are phrased as &#39;SHOULD&#39; rather than &#39;MUST&#39;, because there may be cases where expediency dictates that compatibility with pre-existing versions of a transport protocol make the recommendations impractical.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの推奨事項は、「必須」ではなく「SHOULD」と表現されています。これは、便宜上、既存のバージョンのトランスポートプロトコルとの互換性のために推奨事項が実用的でない場合があるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.4. Recommendation on Handling Congestion Indications When Splitting or Merging Packets
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.4. パケットを分割またはマージするときの輻輳表示の処理に関する推奨事項
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packets carrying congestion indications may be split or merged in some circumstances (e.g., at an RTP / RTP Control Protocol (RTCP) transcoder or during IP fragment reassembly). Splitting and merging only make sense in the context of ECN, not loss.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳指示を運ぶパケットは、状況によっては（たとえば、RTP / RTP制御プロトコル（RTCP）トランスコーダーで、またはIPフラグメントの再構成中に）分割またはマージされる場合があります。分割とマージは、ECNのコンテキストでのみ意味があり、損失ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The general rule to follow is that the number of octets in packets with congestion indications SHOULD be equivalent before and after merging or splitting. This is based on the principle used above; that an indication of congestion on a packet can be considered as an indication of congestion on each octet of the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
従うべき一般的なルールは、輻輳表示のあるパケットのオクテット数は、マージまたはスプリットの前後で同等であるべきである（SHOULD）。これは、上記で使用された原理に基づいています。パケットの輻輳の表示は、パケットの各オクテットの輻輳の表示と見なすことができること。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above rule is not phrased with the word &#39;MUST&#39; to allow the following exception. There are cases in which pre-existing protocols were not designed to conserve congestion-marked octets (e.g., IP fragment reassembly [RFC3168] or loss statistics in RTCP receiver reports [RFC3550] before ECN was added [RFC6679]). When any such protocol is updated, it SHOULD comply with the above rule to conserve marked octets. However, the rule may be relaxed if it would otherwise become too complex to interoperate with pre-existing implementations of the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のルールは、次の例外を許可するために「MUST」という語句が含まれていません。既存のプロトコルが輻輳マーク付きのオクテットを節約するように設計されていない場合があります（たとえば、IPフラグメント再構成[RFC3168]またはECNが追加される前のRTCPレシーバーレポートの損失統計[RFC3550] [RFC6679]）。そのようなプロトコルが更新されるとき、それはマークされたオクテットを保存するために上記のルールに従うべきです（SHOULD）。ただし、ルールが複雑になりすぎて、既存のプロトコル実装と相互運用できない場合は、ルールが緩和される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 One can think of a splitting or merging process as if all the incoming congestion-marked octets increment a counter and all the outgoing marked octets decrement the same counter. In order to ensure that congestion indications remain timely, even the smallest positive remainder in the conceptual counter should trigger the next outgoing packet to be marked (causing the counter to go negative).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
分割またはマージプロセスは、すべての着信輻輳マーク付きオクテットがカウンターをインクリメントし、すべての発信マーク付きオクテットが同じカウンターをデクリメントするかのように考えることができます。輻輳の表示がタイムリーなままであることを確実にするために、概念的なカウンターの最小の正の余りでさえ、次の発信パケットがマークされるようにトリガーする必要があります（カウンターを負にする）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Motivating-Arguments">
3. Motivating Arguments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. やる気を起こさせる議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section is informative. It justifies the recommendations made in the previous section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションは参考情報です。これは、前のセクションで行われた推奨事項を正当化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--Avoiding-Perverse-Incentives-to-Abuse-Smaller-Packets">
3.1. Avoiding Perverse Incentives to (Ab)use Smaller Packets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 小さいパケットを（Ab）使用するための不正なインセンティブの回避
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Increasingly, it is being recognised that a protocol design must take care not to cause unintended consequences by giving the parties in the protocol exchange perverse incentives [Evol_cc] [RFC3426]. Given there are many good reasons why larger path maximum transmission units (PMTUs) would help solve a number of scaling issues, we do not want to create any bias against large packets that is greater than their true cost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコル設計では、プロトコル交換の当事者に不正なインセンティブ[Evol_cc] [RFC3426]を与えることにより、意図しない結果を引き起こさないように注意を払う必要があることがますます認識されています。より大きなパス最大伝送ユニット（PMTU）が多くのスケーリング問題の解決に役立つ理由は数多くあるため、実際のコストよりも大きな大きなパケットに対してバイアスをかけたくありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Imagine a scenario where the same bit rate of packets will contribute the same to bit congestion of a link irrespective of whether it is sent as fewer larger packets or more smaller packets. A protocol design that caused larger packets to be more likely to be dropped than smaller ones would be dangerous in both of the following cases:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットのビットレートが同じか、リンクのビットの輻輳が同じかというシナリオを想像してみてください。リンクが大きなパケットとして送信されるか、小さなパケットとして送信されるかは関係ありません。大きなパケットが小さなパケットよりもドロップされる可能性が高いプロトコル設計は、次のどちらの場合でも危険です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Malicious transports: A queue that gives an advantage to small packets can be used to amplify the force of a flooding attack. By sending a flood of small packets, the attacker can get the queue to discard more large-packet traffic, allowing more attack traffic to get through to cause further damage. Such a queue allows attack traffic to have a disproportionately large effect on regular traffic without the attacker having to do much work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
悪意のあるトランスポート：小さなパケットに有利なキューは、フラッディング攻撃の力を増幅するために使用される可能性があります。攻撃者は小さなパケットのフラッドを送信することにより、キューに大きなパケットのトラフィックを廃棄させ、より多くの攻撃トラフィックが通過してさらなる被害を与えることができます。このようなキューにより、攻撃者は多くの作業を行わなくても、攻撃トラフィックが通常のトラフィックに過度に大きな影響を与えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Non-malicious transports: Even if an application designer is not actually malicious, if over time it is noticed that small packets tend to go faster, designers will act in their own interest and use smaller packets. Queues that give advantage to small packets create an evolutionary pressure for applications or transports to send at the same bit rate but break their data stream down into tiny segments to reduce their drop rate. Encouraging a high volume of tiny packets might in turn unnecessarily overload a completely unrelated part of the system, perhaps more limited by header processing than bandwidth.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
悪意のないトランスポート：アプリケーション設計者が実際には悪意のないものであっても、時間の経過とともに小さなパケットの方が速くなる傾向にある場合、設計者は自分の利益のために行動し、小さなパケットを使用します。小さなパケットに有利なキューは、アプリケーションまたはトランスポートに同じビットレートで送信するという進化的なプレッシャーを生み出しますが、データストリームを小さなセグメントに分割して、ドロップレートを減らします。大量の小さなパケットを奨励すると、システムの完全に無関係な部分が不必要に過負荷になる可能性があり、おそらく帯域幅よりもヘッダー処理によって制限されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Imagine that two unresponsive flows arrive at a bit-congestible transmission link each with the same bit rate, say 1 Mbps, but one consists of 1,500 B and the other 60 B packets, which are 25x smaller. Consider a scenario where gentle RED [gentle_RED] is used,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つの無応答フローが、それぞれ1 Mbpsなどの同じビットレートでビットが混み合う伝送リンクに到着しますが、1つは1,500 Bのパケットで構成され、他の60 Bのパケットは25倍小さくなります。穏やかなRED [gentle_RED]が使用されているシナリオを考えてみましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
along with the variant of RED we advise against, i.e., where the RED algorithm is configured to adjust the drop probability of packets in proportion to each packet&#39;s size (byte-mode packet drop). In this case, RED aims to drop 25x more of the larger packets than the smaller ones. Thus, for example, if RED drops 25% of the larger packets, it will aim to drop 1% of the smaller packets (but, in practice, it may drop more as congestion increases; see Appendix B.4 of [RFC4828]). Even though both flows arrive with the same bit rate, the bit rate the RED queue aims to pass to the line will be 750 kbps for the flow of larger packets but 990 kbps for the smaller packets (because of rate variations, it will actually be a little less than this target).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REDのバリアントとともに、私たちはお勧めしません。つまり、REDアルゴリズムが各パケットのサイズに比例してパケットのドロップ確率を調整するように構成されている場合（バイトモードパケットドロップ）。この場合、REDは、大きなパケットを小さなパケットよりも25倍多くドロップすることを目的としています。したがって、たとえば、REDが大きなパケットの25％をドロップした場合、小さなパケットの1％をドロップすることを目指します（ただし、実際には、輻輳が増加するにつれて、さらにドロップする可能性があります。[RFC4828]の付録B.4を参照してください） 。両方のフローが同じビットレートで到着する場合でも、REDキューが回線に渡すことを目的とするビットレートは、大きなパケットのフローでは750 kbpsですが、小さなパケットでは990 kbpsになります（レートの変動のため、実際にはこの目標より少し少ない）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that, although the byte-mode drop variant of RED amplifies small-packet attacks, tail-drop queues amplify small-packet attacks even more (see Security Considerations in Section 6). Wherever possible, neither should be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REDのバイトモードドロップバリアントは小パケット攻撃を増幅しますが、テールドロップキューは小パケット攻撃をさらに増幅します（セクション6のセキュリティに関する考慮事項を参照）。可能な限り、どちらも使用しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--Small--Control">
3.2. Small != Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 小さい！=コントロール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Dropping fewer control packets considerably improves performance. It is tempting to drop small packets with lower probability in order to improve performance, because many control packets tend to be smaller (TCP SYNs and ACKs, DNS queries and responses, SIP messages, HTTP GETs, etc). However, we must not give control packets preference purely by virtue of their smallness, otherwise it is too easy for any data source to get the same preferential treatment simply by sending data in smaller packets. Again, we should not create perverse incentives to favour small packets rather than to favour control packets, which is what we intend.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ドロップする制御パケットが少ないほど、パフォーマンスが大幅に向上します。多くの制御パケットは小さくなる傾向があるため（TCP SYNとACK、DNSクエリと応答、SIPメッセージ、HTTP GETなど）、パフォーマンスを向上させるために小さいパケットをドロップする可能性が低くなります。ただし、制御パケットに優先度を与えるのは、その小ささだけであってはなりません。さもないと、データソースが小さなパケットでデータを送信するだけでは、同じ優先度の扱いが簡単になりすぎます。繰り返しますが、制御パケットを優先するのではなく、小さなパケットを優先するように不正なインセンティブを作成するべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Just because many control packets are small does not mean all small packets are control packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くの制御パケットが小さいからといって、すべての小さいパケットが制御パケットであるとは限りません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So, rather than fix these problems in the network, we argue that the transport should be made more robust against losses of control packets (see Section 4.2.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、ネットワークでこれらの問題を修正するのではなく、制御パケットの損失に対してトランスポートをより堅牢にする必要があると主張します（セクション4.2.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3--Transport-Independent-Network">
3.3. Transport-Independent Network
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. トランスポートに依存しないネットワーク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP congestion control ensures that flows competing for the same resource each maintain the same number of segments in flight, irrespective of segment size. So under similar conditions, flows with different segment sizes will get different bit rates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP輻輳制御は、同じリソースを求めて競合するフローが、セグメントのサイズに関係なく、飛行中の同じ数のセグメントを維持することを保証します。したがって、同様の条件下で、異なるセグメントサイズのフローは異なるビットレートを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 To counter this effect, it seems tempting not to follow our recommendation, and instead for the network to bias congestion notification by packet size in order to equalise the bit rates of flows with different packet sizes. However, in order to do this, the queuing algorithm has to make assumptions about the transport, which become embedded in the network. Specifically:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
この影響に対抗するために、推奨事項に従わず、代わりにネットワークがパケットサイズごとに輻輳通知にバイアスをかけて、さまざまなパケットサイズのフローのビットレートを等しくするようにしたいと思います。ただし、これを行うために、キューイングアルゴリズムは、ネットワークに組み込まれるトランスポートについての仮定を行う必要があります。具体的には：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The queuing algorithm has to assume how aggressively the transport will respond to congestion (see Section 4.2.4). If the network assumes the transport responds as aggressively as TCP NewReno, it will be wrong for Compound TCP and differently wrong for Cubic TCP, etc. To achieve equal bit rates, each transport then has to guess what assumption the network made, and work out how to replace this assumed aggressiveness with its own aggressiveness.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o キューイングアルゴリズムは、トランスポートが輻輳にどれほど積極的に応答するかを想定する必要があります（セクション4.2.4を参照）。ネットワークがトランスポートがTCP NewRenoと同じくらい積極的に応答することを想定している場合、それはコンパウンドTCPでは間違っており、キュービックTCPなどでは間違っています。等しいビットレートを実現するには、各トランスポートがネットワークの想定を推測し、解決する必要があります。この想定される攻撃性を独自の攻撃性に置き換える方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Also, if the network biases congestion notification by packet size, it has to assume a baseline packet size -- all proposed algorithms use the local MTU (for example, see the byte-mode loss probability formula in Table 1). Then if the non-Reno transports mentioned above are trying to reverse engineer what the network assumed, they also have to guess the MTU of the congested link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o また、ネットワークがパケットサイズによって輻輳通知にバイアスをかける場合、ベースラインパケットサイズを想定する必要があります。提案されたすべてのアルゴリズムはローカルMTUを使用します（たとえば、表1のバイトモード損失確率の公式を参照）。次に、上記の非Renoトランスポートが、ネットワークが想定したものをリバースエンジニアリングしようとしている場合、輻輳したリンクのMTUを推測する必要もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even though reducing the drop probability of small packets (e.g., RED&#39;s byte-mode drop) helps ensure TCP flows with different packet sizes will achieve similar bit rates, we argue that this correction should be made to any future transport protocols based on TCP, not to the network in order to fix one transport, no matter how predominant it is. Effectively, favouring small packets is reverse engineering of network equipment around one particular transport protocol (TCP), contrary to the excellent advice in [RFC3426], which asks designers to question &#34;Why are you proposing a solution at this layer of the protocol stack, rather than at another layer?&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
小さなパケットのドロップ確率（REDのバイトモードドロップなど）を減らすことで、異なるパケットサイズのTCPフローが同様のビットレートを実現できるようにしますが、この修正はTCPベースの将来のトランスポートプロトコルに対して行う必要があると主張します。 1つのトランスポートを修正するために、それがどれほど優勢であっても、ネットワークに接続します。事実上、小さなパケットを優先することは、特定のトランスポートプロトコル（TCP）を中心とするネットワーク機器のリバースエンジニアリングであり、[RFC3426]の優れたアドバイスとは対照的に、デザイナーに「プロトコルスタックのこのレイヤーでソリューションを提案するのはなぜですか。別のレイヤーではなく？」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In contrast, if the network never takes packet size into account, the transport can be certain it will never need to guess any assumptions that the network has made. And the network passes two pieces of information to the transport that are sufficient in all cases: i) congestion notification on the packet and ii) the size of the packet. Both are available for the transport to combine (by taking packet size into account when responding to congestion) or not. Appendix B checks that these two pieces of information are sufficient for all relevant scenarios.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
対照的に、ネットワークでパケットサイズが考慮されない場合、トランスポートは、ネットワークが行った想定を推測する必要がないことを確信できます。そして、ネットワークは2つの情報をトランスポートに渡します。これらの情報はすべての場合に十分です：i）パケットの輻輳通知とii）パケットのサイズ。トランスポートで両方を組み合わせて（輻輳に応答するときにパケットサイズを考慮に入れることにより）、または組み合わせないことができます。付録Bは、これら2つの情報がすべての関連シナリオに十分であることを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the network does not take packet size into account, it allows transport protocols to choose whether or not to take packet size into account. However, if the network were to bias congestion notification by packet size, transport protocols would have no choice; those that did not take into account packet size themselves would unwittingly become dependent on packet size, and those that already took packet size into account would end up taking it into account twice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークがパケットサイズを考慮しない場合、トランスポートプロトコルはパケットサイズを考慮するかどうかを選択できます。ただし、ネットワークがパケットサイズによって輻輳通知にバイアスをかける場合は、トランスポートプロトコルに選択肢がありません。パケットサイズ自体を考慮に入れなかったものは、無意識のうちにパケットサイズに依存するようになり、すでにパケットサイズを考慮に入れたものは、2度考慮に入れられてしまいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-4--Partial-Deployment-of-AQM">
3.4. Partial Deployment of AQM
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. AQMの部分的な展開
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In overview, the argument in this section runs as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
概要では、このセクションの引数は次のように実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Because the network does not and cannot always drop packets in proportion to their size, it shouldn&#39;t be given the task of making drop signals depend on packet size at all.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ネットワークはパケットのサイズに比例してパケットをドロップするわけではなく、常にドロップできるわけではないため、ドロップ信号がパケットサイズに依存するようにするタスクをまったく与えるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Transports on the other hand don&#39;t always want to make their rate response proportional to the size of dropped packets, but if they want to, they always can.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 一方、トランスポートは、レート応答をドロップされたパケットのサイズに常に比例させたいわけではありませんが、必要に応じて、常にそうすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The argument is similar to the end-to-end argument that says &#34;Don&#39;t do X in the network if end systems can do X by themselves, and they want to be able to choose whether to do X anyway&#34;. Actually the following argument is stronger; in addition it says &#34;Don&#39;t give the network task X that could be done by the end systems, if X is not deployed on all network nodes, and end systems won&#39;t be able to tell whether their network is doing X, or whether they need to do X themselves.&#34; In this case, the X in question is &#34;making the response to congestion depend on packet size&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この議論は、「エンドシステムが自分でXを実行でき、Xを実行するかどうかを選択できるようにしたい場合は、ネットワークでXを実行しない」というエンドツーエンドの引数に似ています。実際、次の議論はより強力です。さらに、「Xがすべてのネットワークノードに展開されておらず、エンドシステムがネットワークがXを実行しているかどうかを判断できない場合は、エンドシステムが実行できるネットワークタスクXを与えないでください。 Xを自分で行う必要があるかどうか」この場合、問題のXは「輻輳への応答をパケットサイズに依存させる」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We will now re-run this argument reviewing each step in more depth. The argument applies solely to drop, not to ECN marking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、このステップを再実行して、各ステップをさらに詳しく確認します。この議論はドロップにのみ適用され、ECNマーキングには適用されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A queue drops packets for either of two reasons: a) to signal to host congestion controls that they should reduce the load and b) because there is no buffer left to store the packets. Active queue management tries to use drops as a signal for hosts to slow down (case a) so that drops due to buffer exhaustion (case b) should not be necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キューは2つの理由のいずれかでパケットをドロップします。a）ホストの輻輳制御に負荷を軽減するように通知するため、およびb）パケットを格納するためのバッファーが残っていないためアクティブなキュー管理は、ホストがスローダウンする信号（ケースa）としてドロップを使用しようとするため、バッファーの枯渇（ケースb）によるドロップは必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AQM is not universally deployed in every queue in the Internet; many cheap Ethernet bridges, software firewalls, NATs on consumer devices, etc implement simple tail-drop buffers. Even if AQM were universal, it has to be able to cope with buffer exhaustion (by switching to a behaviour like tail drop), in order to cope with unresponsive or excessive transports. For these reasons networks will sometimes be dropping packets as a last resort (case b) rather than under AQM control (case a).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AQMは、インターネットのすべてのキューに普遍的に配備されているわけではありません。多くの安価なイーサネットブリッジ、ソフトウェアファイアウォール、コンシューマデバイスのNATなどは、単純なテールドロップバッファを実装しています。 AQMが普遍的であったとしても、無応答または過度のトランスポートに対処するために、（テールドロップなどの動作に切り替えることにより）バッファーの枯渇に対処できなければなりません。これらの理由により、ネットワークは、AQM制御（ケースa）ではなく、最後の手段（ケースb）としてパケットをドロップすることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When buffers are exhausted (case b), they don&#39;t naturally drop packets in proportion to their size. The network can only reduce the probability of dropping smaller packets if it has enough space to store them somewhere while it waits for a larger packet that it can drop. If the buffer is exhausted, it does not have this choice. Admittedly tail drop does naturally drop somewhat fewer small packets, but exactly how few depends more on the mix of sizes than the size of the packet in question. Nonetheless, in general, if we wanted networks to do size-dependent drop, we would need universal deployment of (packet-size dependent) AQM code, which is currently unrealistic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
バッファが使い果たされると（ケースb）、サイズに比例してパケットが自然にドロップされなくなります。ネットワークは、大きなパケットがドロップされるのを待つ間、どこかにパケットを格納するのに十分なスペースがある場合にのみ、小さなパケットをドロップする可能性を減らすことができます。バッファが使い果たされた場合、この選択肢はありません。確かにテールドロップでは、当然、小さなパケットがいくらか少なくなりますが、正確にどれだけ少ないかは、問題のパケットのサイズよりもサイズの組み合わせに依存します。それにもかかわらず、一般に、ネットワークにサイズ依存のドロップを実行させたい場合は、（非現実的な）（パケットサイズに依存する）AQMコードのユニバーサルな展開が必要になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A host transport cannot know whether any particular drop was a deliberate signal from an AQM or a sign of a queue shedding packets due to buffer exhaustion. Therefore, because the network cannot universally do size-dependent drop, it should not do it all.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホストトランスポートは、特定のドロップがAQMからの意図的な信号であったのか、またはバッファの枯渇によるキューからのパケットの排出の兆候であったのかを知ることができません。したがって、ネットワークはサイズに依存したドロップを普遍的に行うことができないため、すべてを行うべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whereas universality is desirable in the network, diversity is desirable between different transport-layer protocols -- some, like standards track TCP congestion control [RFC5681], may not choose to make their rate response proportionate to the size of each dropped packet, while others will (e.g., TCP-Friendly Rate Control for Small Packets (TFRC-SP) [RFC4828]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークでは普遍性が望まれますが、さまざまなトランスポート層プロトコル間の多様性が望まれます。標準の追跡TCP輻輳制御[RFC5681]などの一部は、レート応答をドロップされた各パケットのサイズに比例させることを選択しない場合もあれば、します（たとえば、小さいパケットのTCPに適したレート制御（TFRC-SP）[RFC4828]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5--Implementation-Efficiency">
3.5. Implementation Efficiency
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. 実装効率
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Biasing against large packets typically requires an extra multiply and divide in the network (see the example byte-mode drop formula in Table 1). Taking packet size into account at the transport rather than in the network ensures that neither the network nor the transport needs to do a multiply operation -- multiplication by packet size is effectively achieved as a repeated add when the transport adds to its count of marked bytes as each congestion event is fed to it. Also, the work to do the biasing is spread over many hosts, rather than concentrated in just the congested network element. These aren&#39;t principled reasons in themselves, but they are a happy consequence of the other principled reasons.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
大きなパケットに対するバイアスには、通常、ネットワークで追加の乗算と除算が必要です（表1のバイトモードドロップ式の例を参照）。ネットワークではなくトランスポートでパケットサイズを考慮に入れることにより、ネットワークもトランスポートも乗算操作を行う必要がなくなります-パケットサイズによる乗算は、トランスポートがマークされたバイトのカウントに追加するときに繰り返し加算として効果的に達成されます各輻輳イベントがそれに供給されるとき。また、バイアスをかける作業は、輻輳したネットワーク要素だけに集中するのではなく、多くのホストに分散されます。これらはそれ自体が原則的な理由ではありませんが、他の原則的な理由の幸せな結果です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--A-Survey-and-Critique-of-Past-Advice">
4. A Survey and Critique of Past Advice
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 過去のアドバイスの調査と批評
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section is informative, not normative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションは参考情報であり、規範的ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The original 1993 paper on RED [RED93] proposed two options for the RED active queue management algorithm: packet mode and byte mode. Packet mode measured the queue length in packets and dropped (or marked) individual packets with a probability independent of their size. Byte mode measured the queue length in bytes and marked an individual packet with probability in proportion to its size (relative to the maximum packet size). In the paper&#39;s outline of further work, it was stated that no recommendation had been made on whether the queue size should be measured in bytes or packets, but noted that the difference could be significant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1993年のREDに関する最初の論文[RED93]は、REDアクティブキュー管理アルゴリズムの2つのオプション、パケットモードとバイトモードを提案しました。パケットモードでは、パケットの長さを測定し、サイズに依存しない確率で個々のパケットをドロップ（またはマーク）しました。バイトモードでは、キューの長さをバイト単位で測定し、そのサイズに比例した確率で（最大パケットサイズに対して）個々のパケットにマークを付けました。このペーパーの今後の作業の概要では、キューのサイズをバイト単位で測定するかパケット単位で測定するかについての勧告は行われていなかったと述べられましたが、違いが大きくなる可能性があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When RED was recommended for general deployment in 1998 [RFC2309], the two modes were mentioned implying the choice between them was a question of performance, referring to a 1997 email [pktByteEmail] for advice on tuning. A later addendum to this email introduced the insight that there are in fact two orthogonal choices:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REDが1998年の一般的な展開に推奨されたとき[RFC2309]、2つのモードのどちらが選択されるかはパフォーマンスの問題であることを示唆し、チューニングのアドバイスについて1997年の電子メール[pktByteEmail]を参照しました。この電子メールの後の補遺は、実際には2つの直交する選択肢があるという洞察を紹介しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o whether to measure queue length in bytes or packets (Section 4.1), and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o キューの長さをバイトまたはパケットのどちらで測定するか（セクション4.1）、および
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o whether the drop probability of an individual packet should depend on its own size (Section 4.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 個々のパケットのドロップ確率がそれ自体のサイズに依存するかどうか（セクション4.2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rest of this section is structured accordingly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションの残りの部分は、それに応じて構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--Congestion-Measurement-Advice">
4.1. Congestion Measurement Advice
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 輻輳測定のアドバイス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The choice of which metric to use to measure queue length was left open in RFC 2309. It is now well understood that queues for bit-congestible resources should be measured in bytes, and queues for packet-congestible resources should be measured in packets [pktByteEmail].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キューの長さを測定するために使用するメトリックの選択は、RFC 2309で開いたままにしました。ビット一致リソースのキューはバイト単位で測定する必要があり、パケット一致リソースのキューはパケット単位で測定する必要があることがよく理解されています[pktByteEmail ]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Congestion in some legacy bit-congestible buffers is only measured in packets not bytes. In such cases, the operator has to take into account a typical mix of packet sizes when setting the thresholds. Any AQM algorithm on such a buffer will be oversensitive to high proportions of small packets, e.g., a DoS attack, and under-sensitive to high proportions of large packets. However, there is no need to make allowances for the possibility of such a legacy in future protocol design. This is safe because any under-sensitivity during unusual traffic mixes cannot lead to congestion collapse given that the buffer will eventually revert to tail drop, which discards proportionately more large packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のレガシービットが混み合うバッファーの輻輳は、バイト単位ではなくパケット単位でのみ測定されます。このような場合、オペレーターは、しきい値を設定する際に、パケットサイズの一般的な組み合わせを考慮する必要があります。このようなバッファのAQMアルゴリズムは、DoS攻撃などの小さなパケットの割合が高い場合は過敏になり、大きなパケットの割合が大きい場合は感度が低くなります。ただし、将来のプロトコル設計でこのような遺産の可能性を考慮に入れる必要はありません。異常なトラフィックミックス中の感度不足は、バッファが最終的にテールドロップに戻り、より大きなパケットが比例して破棄されることを考えると、輻輳の崩壊につながることがないため、安全です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1-1--Fixed-Size-Packet-Buffers">
4.1.1. Fixed-Size Packet Buffers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. 固定サイズのパケットバッファ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The question of whether to measure queues in bytes or packets seems to be well understood. However, measuring congestion is confusing when the resource is bit-congestible but the queue into the resource is packet-congestible. This section outlines the approach to take.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キューをバイトとパケットのどちらで測定するかという問題は、よく理解されているようです。ただし、リソースがビット輻輳しているが、リソースへのキューがパケット輻輳している場合、輻輳の測定は混乱を招きます。このセクションでは、採用するアプローチの概要を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some, mostly older, queuing hardware allocates fixed-size buffers in which to store each packet in the queue. This hardware forwards packets to the line in one of two ways:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部の、ほとんどが古いキューイングハードウェアは、各パケットをキューに格納するために固定サイズのバッファーを割り当てます。このハードウェアは、次の2つの方法のいずれかでパケットを回線に転送します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o With some hardware, any fixed-size buffers not completely filled by a packet are padded when transmitted to the wire. This case should clearly be treated as packet-congestible, because both queuing and transmission are in fixed MTU-size units. Therefore, the queue length in packets is a good model of congestion of the link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
o一部のハードウェアでは、パケットで完全に満たされていない固定サイズのバッファーは、ワイヤーに送信されるときにパディングされます。キューイングと送信の両方が固定MTUサイズ単位であるため、このケースは明らかにパケットの混雑性として扱われるべきです。したがって、パケットのキューの長さはリンクの輻輳の良いモデルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o More commonly, hardware with fixed-size packet buffers transmits packets to the line without padding. This implies a hybrid forwarding system with transmission congestion dependent on the size of packets but queue congestion dependent on the number of packets, irrespective of their size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o より一般的には、固定サイズのパケットバッファーを備えたハードウェアは、パディングなしでパケットを回線に送信します。これは、パケットのサイズに依存する送信の輻輳が、そのサイズに関係なくパケットの数に依存するキューの輻輳を伴うハイブリッド転送システムを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Nonetheless, there would be no queue at all unless the line had become congested -- the root cause of any congestion is too many bytes arriving for the line. Therefore, the AQM should measure the queue length as the sum of all the packet sizes in bytes that are queued up waiting to be serviced by the line, irrespective of whether each packet is held in a fixed-size buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
それにもかかわらず、回線が輻輳していなければ、キューはまったくありません。輻輳の根本的な原因は、回線に到着するバイト数が多すぎることです。したがって、AQMはキューの長さを、各パケットが固定サイズのバッファーに保持されているかどうかに関係なく、回線によってサービスされるのを待機してキューに入れられたすべてのパケットサイズの合計としてバイト単位で測定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the (unlikely) first case where use of padding means the queue should be measured in packets, further confusion is likely because the fixed buffers are rarely all one size. Typically, pools of different-sized buffers are provided (Cisco uses the term &#39;buffer carving&#39; for the process of dividing up memory into these pools [IOSArch]). Usually, if the pool of small buffers is exhausted, arriving small packets can borrow space in the pool of large buffers, but not vice versa. However, there is no need to consider all this complexity, because the root cause of any congestion is still line overload -- buffer consumption is only the symptom. Therefore, the length of the queue should be measured as the sum of the bytes in the queue that will be transmitted to the line, including any padding. In the (unusual) case of transmission with padding, this means the sum of the sizes of the small buffers queued plus the sum of the sizes of the large buffers queued.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パディングの使用がキューをパケットで測定する必要があることを意味する（まれに）最初のケースでは、固定バッファがほとんどすべて1つのサイズであるため、さらに混乱が生じる可能性があります。通常、異なるサイズのバッファのプールが提供されます（シスコは、メモリをこれらのプールに分割するプロセスに「バッファカービング」という用語を使用します[IOSArch]）。通常、小さなバッファーのプールが使い果たされた場合、到着した小さなパケットは大きなバッファーのプールのスペースを借りることができますが、その逆はできません。ただし、輻輳の根本原因は依然として回線の過負荷であるため、このすべての複雑さを考慮する必要はありません。バッファの消費は単なる症状です。したがって、キューの長さは、パディングを含め、回線に送信されるキュー内のバイトの合計として測定する必要があります。パディング付きの（異常な）送信の場合、これは、キューに入れられた小さなバッファのサイズの合計とキューに入れられた大きなバッファのサイズの合計を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We will return to borrowing of fixed-size buffers when we discuss biasing the drop/marking probability of a specific packet because of its size in Section 4.2.1. But here, we can repeat the simple rule for how to measure the length of queues of fixed buffers: no matter how complicated the buffering scheme is, ultimately a transmission line is nearly always bit-congestible so the number of bytes queued up waiting for the line measures how congested the line is, and it is rarely important to measure how congested the buffering system is.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション4.2.1でサイズが原因で特定のパケットのドロップ/マーキング確率にバイアスをかけることについて説明すると、固定サイズのバッファの借用に戻ります。しかし、ここでは、固定バッファのキューの長さを測定する方法について単純なルールを繰り返すことができます。バッファリングスキームがどれほど複雑であっても、最終的には伝送ラインはほぼ常にビットが混み合うため、キューに入れられて待機しているバイト数lineは、回線の混雑度を測定します。バッファリングシステムの混雑度を測定することはほとんど重要ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1-2--Congestion-Measurement-without-a-Queue">
4.1.2. Congestion Measurement without a Queue
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. キューなしの輻輳測定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 AQM algorithms are nearly always described assuming there is a queue for a congested resource and the algorithm can use the queue length to determine the probability that it will drop or mark each packet. But not all congested resources lead to queues. For instance, power- limited resources are usually bit-congestible if energy is primarily required for transmission rather than header processing, but it is rare for a link protocol to build a queue as it approaches maximum power.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
AQMアルゴリズムは、ほとんどの場合、輻輳したリソースのキューがあると想定して説明され、アルゴリズムはキューの長さを使用して、各パケットをドロップまたはマークする確率を決定できます。ただし、すべての輻輳リソースがキューにつながるわけではありません。たとえば、電力が限られたリソースは、ヘッダー処理ではなく送信にエネルギーが主に必要な場合、通常ビットコンジェクティビティですが、リンクプロトコルが最大電力に近づくときにキューを構築することはまれです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nonetheless, AQM algorithms do not require a queue in order to work. For instance, spectrum congestion can be modelled by signal quality using the target bit-energy-to-noise-density ratio. And, to model radio power exhaustion, transmission-power levels can be measured and compared to the maximum power available. [ECNFixedWireless] proposes a practical and theoretically sound way to combine congestion notification for different bit-congestible resources at different layers along an end-to-end path, whether wireless or wired, and whether with or without queues.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それにもかかわらず、AQMアルゴリズムが機能するためにキューを必要としません。たとえば、スペクトルの輻輳は、目標のビットエネルギー対ノイズ密度比を使用して信号品質によってモデル化できます。また、無線電力の枯渇をモデル化するために、送信電力レベルを測定し、利用可能な最大電力と比較できます。 [ECNFixedWireless]は、ワイヤレスか有線か、キューの有無にかかわらず、エンドツーエンドパスに沿ったさまざまなレイヤーでさまざまなビットが混み合うリソースの輻輳通知を組み合わせる実用的かつ理論的に健全な方法を提案します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In wireless protocols that use request to send / clear to send (RTS / CTS) control, such as some variants of IEEE802.11, it is reasonable to base an AQM on the time spent waiting for transmission opportunities (TXOPs) even though the wireless spectrum is usually regarded as congested by bits (for a given coding scheme). This is because requests for TXOPs queue up as the spectrum gets congested by all the bits being transferred. So the time that TXOPs are queued directly reflects bit congestion of the spectrum.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IEEE802.11の一部のバリアントなど、送信要求/送信クリア（RTS / CTS）制御を使用する無線プロトコルでは、無線であっても、送信機会（TXOP）の待機に費やされた時間に基づいてAQMを行うのが妥当です。スペクトルは通常、ビットで混雑していると見なされます（特定のコーディング方式の場合）。これは、転送されるすべてのビットによってスペクトルが輻輳すると、TXOPの要求がキューに入れられるためです。したがって、TXOPがキューに入れられる時間は、スペクトルのビット輻輳を直接反映します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2--Congestion-Notification-Advice">
4.2. Congestion Notification Advice
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. 混雑通知アドバイス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2-1--Network-Bias-When-Encoding">
4.2.1. Network Bias When Encoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. エンコード時のネットワークバイアス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2-1-1--Advice-on-Packet-Size-Bias-in-RED">
4.2.1.1. Advice on Packet-Size Bias in RED
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1.1. REDのパケットサイズバイアスに関するアドバイス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The previously mentioned email [pktByteEmail] referred to by [RFC2309] advised that most scarce resources in the Internet were bit-congestible, which is still believed to be true (Section 1.1). But it went on to offer advice that is updated by this memo. It said that drop probability should depend on the size of the packet being considered for drop if the resource is bit-congestible, but not if it is packet-congestible. The argument continued that if packet drops were inflated by packet size (byte-mode dropping), &#34;a flow&#39;s fraction of the packet drops is then a good indication of that flow&#39;s fraction of the link bandwidth in bits per second&#34;. This was consistent with a referenced policing mechanism being worked on at the time for detecting unusually high bandwidth flows, eventually published in 1999 [pBox]. However, the problem could and should have been solved by making the policing mechanism count the volume of bytes randomly dropped, not the number of packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2309]によって言及された前述の電子メール[pktByteEmail]は、インターネットのほとんどの希少なリソースはビットが混雑していることを忠告しています。しかし、それはこのメモによって更新されるアドバイスを提供し続けました。ドロップ確率は、リソースがビット輻輳可能である場合、ドロップと見なされるパケットのサイズに依存する必要があるが、パケット輻輳可能である場合は依存しないと述べた。議論は、パケットドロップがパケットサイズ（バイトモードドロップ）によって拡大された場合、「パケットドロップのフローの割合はビット/秒でのリンク帯域幅のそのフローの割合の良い指標である」と続けました。これは、異常に高い帯域幅のフローを検出するために当時取り組まれていた参照ポリシングメカニズムと一貫しており、最終的に1999年に公開されました[pBox]ただし、この問題は、パケットの数ではなく、ランダムにドロップされたバイトの量をポリシングメカニズムにカウントさせることで解決できたはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A few months before RFC 2309 was published, an addendum was added to the above archived email referenced from the RFC, in which the final paragraph seemed to partially retract what had previously been said. It clarified that the question of whether the probability of dropping/marking a packet should depend on its size was not related to whether the resource itself was bit-congestible, but a completely orthogonal question. However, the only example given had the queue measured in packets but packet drop depended on the size of the packet in question. No example was given the other way round.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 2309が公開される数か月前に、RFCから参照された上記のアーカイブされた電子メールに補遺が追加されました。最後の段落では、以前の発言が部分的に撤回されているように見えました。パケットをドロップ/マーキングする確率がそのサイズに依存するかどうかの問題は、リソース自体がビットコンセッション可能であるかどうかとは関係なく、完全に直交する問題であることを明らかにしました。ただし、与えられた唯一の例では、キューがパケット単位で測定されましたが、パケットのドロップは問題のパケットのサイズに依存していました。逆の例はありませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In 2000, Cnodder et al. [REDbyte] pointed out that there was an error in the part of the original 1993 RED algorithm that aimed to distribute drops uniformly, because it didn&#39;t correctly take into account the adjustment for packet size. They recommended an algorithm called RED_4 to fix this. But they also recommended a further change, RED_5, to adjust the drop rate dependent on the square of the relative packet size. This was indeed consistent with one implied motivation behind RED&#39;s byte-mode drop -- that we should reverse engineer the network to improve the performance of dominant end-to-end congestion control mechanisms. This memo makes a different recommendations in Section 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2000年に、Cnodder等。 [REDbyte]は、パケットサイズの調整を正しく考慮していなかったため、ドロップを均一に分散することを目的とした元の1993 REDアルゴリズムの一部にエラーがあったことを指摘しました。彼らはこれを修正するためにRED_4と呼ばれるアルゴリズムを推奨しました。ただし、相対パケットサイズの2乗に応じてドロップ率を調整するために、RED_5をさらに変更することも推奨しました。これは、REDのバイトモードドロップの背後にある暗黙の動機と実際に一致していました。つまり、ネットワークをリバースエンジニアリングして、主要なエンドツーエンドの輻輳制御メカニズムのパフォーマンスを向上させる必要があります。このメモは、セクション2で異なる推奨事項を作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By 2003, a further change had been made to the adjustment for packet size, this time in the RED algorithm of the ns2 simulator. Instead of taking each packet&#39;s size relative to a &#39;maximum packet size&#39;, it was taken relative to a &#39;mean packet size&#39;, intended to be a static value representative of the &#39;typical&#39; packet size on the link. We have not been able to find a justification in the literature for this change; however, Eddy and Allman conducted experiments [REDbias] that assessed how sensitive RED was to this parameter, amongst other things. This changed algorithm can often lead to drop probabilities of greater than 1 (which gives a hint that there is probably a mistake in the theory somewhere).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2003年までに、パケットサイズの調整にさらに変更が加えられました。今回は、ns2シミュレーターのREDアルゴリズムが変更されました。各パケットのサイズを「最大パケットサイズ」と比較する代わりに、「平均パケットサイズ」と比較しました。これは、リンク上の「典型的な」パケットサイズを表す静的な値となることを目的としています。この変化についての正当性を文献で見つけることはできませんでした。ただし、EddyとAllmanは、特にこのパラメーターに対するREDの感度を評価する実験[REDbias]を実施しました。この変更されたアルゴリズムは、多くの場合、1を超える確率の低下につながる可能性があります（これは、おそらくどこかで理論に誤りがあることを示唆しています）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On 10-Nov-2004, this variant of byte-mode packet drop was made the default in the ns2 simulator. It seems unlikely that byte-mode drop has ever been implemented in production networks (Appendix A); therefore, any conclusions based on ns2 simulations that use RED without disabling byte-mode drop are likely to behave very differently from RED in production networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2004年11月10日、このバイトモードパケットドロップのバリアントは、ns2シミュレーターのデフォルトになりました。バイトモードのドロップがプロダクションネットワークで実装された可能性は低いようです（付録A）。したがって、バイトモードドロップを無効にせずにREDを使用するns2シミュレーションに基づく結論は、運用ネットワークのREDとは非常に異なる動作をする可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2-1-2--Packet-Size-Bias-Regardless-of-AQM">
4.2.1.2. Packet-Size Bias Regardless of AQM
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1.2. AQMに関係なくパケットサイズバイアス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The byte-mode drop variant of RED (or a similar variant of other AQM algorithms) is not the only possible bias towards small packets in queuing systems. We have already mentioned that tail-drop queues naturally tend to lock out large packets once they are full.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REDのバイトモードドロップバリアント（または他のAQMアルゴリズムの同様のバリアント）は、キューイングシステムで小さなパケットに向かう可能性のある唯一のバイアスではありません。テールドロップキューがいっぱいになると、当然、大きなパケットがロックアウトされる傾向があることはすでに説明しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
But also, queues with fixed-size buffers reduce the probability that small packets will be dropped if (and only if) they allow small packets to borrow buffers from the pools for larger packets (see Section 4.1.1). Borrowing effectively makes the maximum queue size for small packets greater than that for large packets, because more buffers can be used by small packets while less will fit large packets. Incidentally, the bias towards small packets from buffer borrowing is nothing like as large as that of RED&#39;s byte-mode drop.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、固定サイズのバッファーを備えたキューは、小さいパケットが大きいパケット用のプールからバッファーを借りることを許可する場合にのみ（小さい場合のみ）、小さいパケットがドロップされる確率を減らします（セクション4.1.1を参照）。借りることで、小さなパケットがより多くのバッファを使用できる一方で、より少ないパケットが大きなパケットに適合できるため、小さなパケットの最大キューサイズは大きなパケットよりも大きくなります。ちなみに、バッファの借用による小さなパケットへのバイアスは、REDのバイトモードドロップほど大きくはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nonetheless, fixed-buffer memory with tail drop is still prone to lock out large packets, purely because of the tail-drop aspect. So, fixed-size packet buffers should be augmented with a good AQM algorithm and packet-mode drop. If an AQM is too complicated to implement with multiple fixed buffer pools, the minimum necessary to prevent large-packet lockout is to ensure that smaller packets never use the last available buffer in any of the pools for larger packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それにもかかわらず、テールドロップの側面があるため、テールドロップを備えた固定バッファメモリは、大きなパケットをロックアウトする傾向があります。したがって、固定サイズのパケットバッファーは、優れたAQMアルゴリズムとパケットモードドロップで拡張する必要があります。 AQMが複雑すぎて複数の固定バッファプールを実装できない場合、大きなパケットのロックアウトを防ぐために最低限必要なのは、小さなパケットが、大きなパケットのプールで最後に利用可能なバッファを使用しないようにすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2-2--Transport-Bias-When-Decoding">
4.2.2. Transport Bias When Decoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. デコード時のトランスポートバイアス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above proposals to alter the network equipment to bias towards smaller packets have largely carried on outside the IETF process. Whereas, within the IETF, there are many different proposals to alter transport protocols to achieve the same goals, i.e., either to make the flow bit rate take into account packet size, or to protect control packets from loss. This memo argues that altering transport protocols is the more principled approach.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
より小さなパケットに偏るようにネットワーク機器を変更する上記の提案は、主にIETFプロセスの外で行われてきました。一方、IETF内では、同じ目的を達成するためにトランスポートプロトコルを変更する多くの異なる提案があります。つまり、フロービットレートにパケットサイズを考慮させるか、制御パケットを損失から保護します。このメモは、トランスポートプロトコルの変更がより原則的なアプローチであると主張しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A recently approved experimental RFC adapts its transport-layer protocol to take into account packet sizes relative to typical TCP packet sizes. This proposes a new small-packet variant of TCP-friendly rate control (TFRC [RFC5348]), which is called TFRC-SP [RFC4828]. Essentially, it proposes a rate equation that inflates the flow rate by the ratio of a typical TCP segment size (1,500 B including TCP header) over the actual segment size [PktSizeEquCC]. (There are also other important differences of detail relative to TFRC, such as using virtual packets [CCvarPktSize] to avoid responding to multiple losses per round trip and using a minimum inter-packet interval.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最近承認された実験的なRFCは、トランスポート層プロトコルを適応させて、通常のTCPパケットサイズと比較したパケットサイズを考慮に入れます。これは、TFRC-SP [RFC4828]と呼ばれる、TCPフレンドリなレート制御（TFRC [RFC5348]）の新しい小さなパケットバリアントを提案します。基本的には、実際のセグメントサイズ[PktSizeEquCC]に対する一般的なTCPセグメントサイズ（TCPヘッダーを含めて1,500 B）の比率で流量を増加させるレート方程式を提案します。 （仮想パケット[CCvarPktSize]を使用してラウンドトリップあたりの複数の損失に応答することを回避したり、最小のパケット間間隔を使用したりするなど、TFRCに関連するその他の重要な詳細の違いもあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 4.5.1 of the TFRC-SP specification discusses the implications of operating in an environment where queues have been configured to drop smaller packets with proportionately lower probability than larger ones. But it only discusses TCP operating in such an environment, only mentioning TFRC-SP briefly when discussing how to define fairness with TCP. And it only discusses the byte-mode dropping version of RED as it was before Cnodder et al. pointed out that it didn&#39;t sufficiently bias towards small packets to make TCP independent of packet size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFRC-SP仕様のセクション4.5.1は、大きいパケットよりも小さいパケットを比例して低い確率でドロップするようにキューが構成されている環境での動作の影響について説明しています。ただし、そのような環境で動作するTCPについてのみ説明し、TCPとの公平性を定義する方法について説明するときは、TFRC-SPについて簡単に説明します。また、Cnodderらの以前のように、REDのバイトモードドロップバージョンについてのみ説明します。は、TCPをパケットサイズに依存させないように、小さなパケットに十分に偏っていないことを指摘しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So the TFRC-SP specification doesn&#39;t address the issue of whether the network or the transport _should_ handle fairness between different packet sizes. In Appendix B.4 of RFC 4828, it discusses the possibility of both TFRC-SP and some network buffers duplicating each other&#39;s attempts to deliberately bias towards small packets. But the discussion is not conclusive, instead reporting simulations of many of the possibilities in order to assess performance but not recommending any particular course of action.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、TFRC-SP仕様は、ネットワークまたはトランスポートが異なるパケットサイズ間の公平性を処理する必要があるかどうかの問題に対処していません。 RFC 4828の付録B.4では、TFRC-SPと一部のネットワークバッファーの両方が、意図的に小さなパケットに偏らせる試みを重複させる可能性について説明しています。しかし、議論は決定的なものではなく、パフォーマンスを評価するために可能性の多くのシミュレーションを報告しますが、特定の行動方針を推奨しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The paper originally proposing TFRC with virtual packets (VP-TFRC) [CCvarPktSize] proposed that there should perhaps be two variants to cater for the different variants of RED. However, as the TFRC-SP authors point out, there is no way for a transport to know whether some queues on its path have deployed RED with byte-mode packet drop (except if an exhaustive survey found that no one has deployed it! -- see Appendix A). Incidentally, VP-TFRC also proposed that byte-mode RED dropping should really square the packet-size compensation factor (like that of Cnodder&#39;s RED_5, but apparently unaware of it).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当初、仮想パケットを使用したTFRC（VP-TFRC）[CCvarPktSize]を提案しているペーパーでは、REDのさまざまなバリアントに対応するために、2つのバリアントが存在する必要があると提案されています。ただし、TFRC-SPの作成者が指摘するように、パス上のいくつかのキューがバイトモードパケットドロップでREDを展開したかどうかをトランスポートが知る方法はありません（徹底的な調査で誰も展開していないことが判明した場合を除きます！- -付録Aを参照）。ちなみに、VP-TFRCは、バイトモードのREDドロップが実際にパケットサイズの補正係数を二乗することも提案しました（CnodderのRED_5と同様ですが、明らかにそれを認識していません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pre-congestion notification [RFC5670] is an IETF technology to use a virtual queue for AQM marking for packets within one Diffserv class in order to give early warning prior to any real queuing. The PCN-marking algorithms have been designed not to take into account packet size when forwarding through queues. Instead, the general principle has been to take the sizes of marked packets into account when monitoring the fraction of marking at the edge of the network, as recommended here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
事前輻輳通知[RFC5670]は、実際のキューイングの前に早期警告を出すために、1つのDiffservクラス内のパケットのAQMマーキングに仮想キューを使用するIETFテクノロジーです。 PCNマーキングアルゴリズムは、キューを介して転送するときにパケットサイズを考慮しないように設計されています。代わりに、一般的な原則は、ここで推奨されているように、ネットワークのエッジでのマーキングの割合を監視するときに、マークされたパケットのサイズを考慮することでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2-3--Making-Transports-Robust-against-Control-Packet-Losses">
4.2.3. Making Transports Robust against Control Packet Losses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3. 制御パケット損失に対して堅牢なトランスポートを作成する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recently, two RFCs have defined changes to TCP that make it more robust against losing small control packets [RFC5562] [RFC5690]. In both cases, they note that the case for these two TCP changes would be weaker if RED were biased against dropping small packets. We argue here that these two proposals are a safer and more principled way to achieve TCP performance improvements than reverse engineering RED to benefit TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最近、2つのRFCがTCPへの変更を定義し、小さな制御パケットの損失に対してより堅牢にする[RFC5562] [RFC5690]。どちらの場合も、REDが小さなパケットのドロップに対してバイアスをかけた場合、これらの2つのTCP変更のケースはより弱いことに注意してください。ここでは、これら2つの提案は、TCPにメリットをもたらすREDのリバースエンジニアリングよりも、TCPパフォーマンスの向上を実現するためのより安全で原理的な方法であると主張します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although there are no known proposals, it would also be possible and perfectly valid to make control packets robust against drop by requesting a scheduling class with lower drop probability, which would be achieved by re-marking to a Diffserv code point [RFC2474] within the same behaviour aggregate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
既知の提案はありませんが、ドロップ確率がより低いスケジューリングクラスを要求することにより、ドロップに対して制御パケットをロバストにすることも可能で完全に有効です。これは、Diffservコードポイント[RFC2474]内で再マーキングすることによって達成されます。同じ動作の集計。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Although not brought to the IETF, a simple proposal from Wischik [DupTCP] suggests that the first three packets of every TCP flow should be routinely duplicated after a short delay. It shows that this would greatly improve the chances of short flows completing quickly, but it would hardly increase traffic levels on the Internet, because Internet bytes have always been concentrated in the large flows. It further shows that the performance of many typical applications depends on completion of long serial chains of short messages. It argues that, given most of the value people get from the Internet is concentrated within short flows, this simple expedient would greatly increase the value of the best-effort Internet at minimal cost. A similar but more extensive approach has been evaluated on Google servers [GentleAggro].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
IETFには持ち込まれませんでしたが、Wischik [DupTCP]からの簡単な提案では、すべてのTCPフローの最初の3つのパケットは、少し遅れて定期的に複製する必要があると示唆されています。これにより、短いフローが迅速に完了する可能性が大幅に向上しますが、インターネットのトラフィックレベルはほとんど増加しません。これは、インターネットのバイトが常に大きなフローに集中しているためです。さらに、多くの一般的なアプリケーションのパフォーマンスは、短いメッセージの長いシリアルチェーンの完了に依存することも示しています。人々がインターネットから得る価値のほとんどが短いフローに集中していることを考えると、この単純な手段は最小限のコストでベストエフォートのインターネットの価値を大幅に増加させると主張しています。同様の、しかしより広範なアプローチがGoogleサーバーで評価されています[GentleAggro]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The proposals discussed in this sub-section are experimental approaches that are not yet in wide operational use, but they are existence proofs that transports can make themselves robust against loss of control packets. The examples are all TCP-based, but applications over non-TCP transports could mitigate loss of control packets by making similar use of Diffserv, data duplication, FEC, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このサブセクションで説明する提案は、まだ広く運用されていない実験的なアプローチですが、トランスポートが制御パケットの損失に対してそれ自体を堅牢にすることができる存在証明です。例はすべてTCPベースですが、非TCPトランスポート上のアプリケーションは、Diffserv、データ複製、FECなどを同様に使用することで、制御パケットの損失を軽減できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2-4--Congestion-Notification-Summary-of-Conflicting-Advice">
4.2.4. Congestion Notification: Summary of Conflicting Advice
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.4. 混雑通知：矛盾するアドバイスの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-----------+-----------------+-----------------+-------------------+
   | transport |  RED_1 (packet- |  RED_4 (linear  |   RED_5 (square   |
   |        cc |    mode drop)   | byte-mode drop) |  byte-mode drop)  |
   +-----------+-----------------+-----------------+-------------------+
   |    TCP or |    s/sqrt(p)    |    sqrt(s/p)    |     1/sqrt(p)     |
   |      TFRC |                 |                 |                   |
   |   TFRC-SP |    1/sqrt(p)    |   1/sqrt(s*p)   |   1/(s*sqrt(p))   |
   +-----------+-----------------+-----------------+-------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
Table 2: Dependence of flow bit rate per RTT on packet size, s, and drop probability, p, when there is network and/or transport bias towards small packets to varying degrees
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
表2：小さなパケットへのネットワークやトランスポートのバイアスがさまざまな程度にある場合のRTTあたりのフロービットレートのパケットサイズ（s）およびドロップ確率（p）への依存性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 2 aims to summarise the potential effects of all the advice from different sources. Each column shows a different possible AQM behaviour in different queues in the network, using the terminology of Cnodder et al. outlined earlier (RED_1 is basic RED with packet-mode drop). Each row shows a different transport behaviour: TCP [RFC5681] and TFRC [RFC5348] on the top row with TFRC-SP [RFC4828] below. Each cell shows how the bits per round trip of a flow depends on packet size, s, and drop probability, p. In order to declutter the formulae to focus on packet-size dependence, they are all given per round trip, which removes any RTT term.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表2は、さまざまなソースからのすべてのアドバイスの潜在的な影響を要約することを目的としています。各列は、Cnodderらの用語を使用して、ネットワーク内のさまざまなキューで考えられるさまざまなAQM動作を示しています。前に概説しました（RED_1は、パケットモードドロップのある基本的なREDです）。各行は異なるトランスポート動作を示しています。一番上の行にはTCP [RFC5681]とTFRC [RFC5348]があり、下にTFRC-SP [RFC4828]が示されています。各セルは、フローのラウンドトリップあたりのビットがパケットサイズsとドロップ確率pにどのように依存するかを示します。パケットサイズの依存に焦点を当てた式を整理するために、それらはすべてラウンドトリップごとに与えられ、RTT項を削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Let us assume that the goal is for the bit rate of a flow to be independent of packet size. Suppressing all inessential details, the table shows that this should either be achievable by not altering the TCP transport in a RED_5 network, or using the small packet TFRC-SP transport (or similar) in a network without any byte-mode dropping RED (top right and bottom left). Top left is the &#39;do nothing&#39; scenario, while bottom right is the &#39;do both&#39; scenario in which the bit rate would become far too biased towards small packets. Of course, if any form of byte-mode dropping RED has been deployed on a subset of queues that congest, each path through the network will present a different hybrid scenario to its transport.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目標は、フローのビットレートがパケットサイズに依存しないことであると仮定します。重要ではないすべての詳細を抑制した表は、RED_5ネットワークでTCPトランスポートを変更しないか、バイトモードREDをドロップしないネットワークでスモールパケットTFRC-SPトランスポート（または類似のもの）を使用してこれを実現できることを示しています（上部）右と左下）。左上は「何もしない」シナリオですが、右下は「両方を行う」シナリオで、ビットレートが小さいパケットに偏りすぎています。もちろん、バイトモードドロップREDのいずれかの形式が輻輳しているキューのサブセットに展開されている場合、ネットワークを介する各パスは、そのトランスポートに対して異なるハイブリッドシナリオを提示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whatever the case, we can see that the linear byte-mode drop column in the middle would considerably complicate the Internet. Even if one believes the network should be doing the biasing, linear byte-mode drop is a half-way house that doesn&#39;t bias enough towards small packets. Section 2 recommends that _all_ bias in network equipment towards small packets should be turned off -- if indeed any equipment vendors have implemented it -- leaving packet-size bias solely as the preserve of the transport layer (solely the leftmost, packet-mode drop column).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いずれにせよ、真ん中の線形バイトモードドロップ列がインターネットをかなり複雑にすることがわかります。ネットワークがバイアスをかける必要があると信じていても、線形バイトモードドロップは小さなパケットに十分にバイアスしない中間的な方法です。セクション2は、小さなパケットに対するネットワーク機器の_all_バイアスをオフにすることをお勧めします-実際に機器ベンダーがそれを実装している場合-パケットサイズバイアスをトランスポート層の保護（単に左端のパケットモードドロップのみ）として残しますカラム）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In practice, it seems that no deliberate bias towards small packets has been implemented for production networks. Of the 19% of vendors who responded to a survey of 84 equipment vendors, none had implemented byte-mode drop in RED (see Appendix A for details).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実際には、小さなパケットへの意図的なバイアスは、本番ネットワークには実装されていないようです。 84の機器ベンダーの調査に回答したベンダーの19％のうち、REDでバイトモードドロップを実装したベンダーはありませんでした（詳細は付録Aを参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Outstanding-Issues-and-Next-Steps">
5. Outstanding Issues and Next Steps
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 未解決の問題と次のステップ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1--Bit-congestible-Network">
5.1. Bit-congestible Network
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. ビット混雑ネットワーク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a connectionless network with nearly all resources being bit-congestible, the recommended position is clear -- the network should not make allowance for packet sizes and the transport should. This leaves two outstanding issues:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ほぼすべてのリソースがビット混雑であるコネクションレス型ネットワークの場合、推奨される位置は明確です。ネットワークはパケットサイズを考慮に入れるべきではなく、トランスポートも考慮すべきです。これには2つの未解決の問題があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The question of how to handle any legacy AQM deployments using byte-mode drop;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o バイトモードドロップを使用してレガシーAQMデプロイメントを処理する方法に関する質問。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The need to start a programme to update transport congestion control protocol standards to take packet size into account.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o パケットサイズを考慮するために、トランスポート輻輳制御プロトコル標準を更新するプログラムを開始する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A survey of equipment vendors (Section 4.2.4) found no evidence that byte-mode packet drop had been implemented, so deployment will be sparse at best. A migration strategy is not really needed to remove an algorithm that may not even be deployed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
機器ベンダーの調査（セクション4.2.4）では、バイトモードパケットドロップが実装されたという証拠は見られなかったため、配置はせいぜいまばらです。デプロイされていない可能性のあるアルゴリズムを削除するために、移行戦略は実際には必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A programme of experimental updates to take packet size into account in transport congestion control protocols has already started with TFRC-SP [RFC4828].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランスポート輻輳制御プロトコルでパケットサイズを考慮する実験的な更新プログラムは、TFRC-SP [RFC4828]ですでに開始されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2--Bit--and-Packet-Congestible-Network">
5.2. Bit- and Packet-Congestible Network
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. ビットおよびパケット圧縮可能ネットワーク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The position is much less clear-cut if the Internet becomes populated by a more even mix of both packet-congestible and bit-congestible resources (see Appendix B.2). This problem is not pressing, because most Internet resources are designed to be bit-congestible before packet processing starts to congest (see Section 1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットが密集しているリソースとビットが密集しているリソースの両方がより均一に混在するようになると、立場はそれほど明確ではなくなります（付録B.2を参照）。パケット処理が輻輳し始める前にほとんどのインターネットリソースがビット輻輳するように設計されているため、この問題は差し迫っていません（セクション1.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IRTF&#39;s Internet Congestion Control Research Group (ICCRG) has set itself the task of reaching consensus on generic forwarding mechanisms that are necessary and sufficient to support the Internet&#39;s future congestion control requirements (the first challenge in [RFC6077]). The research question of whether packet congestion might become common and what to do if it does may in the future be explored in the IRTF (the &#34;Challenge 3: Packet Size&#34; in [RFC6077]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IRTFのインターネット輻輳制御研究グループ（ICCRG）は、インターネットの将来の輻輳制御要件（[RFC6077]の最初の課題）をサポートするために必要かつ十分な汎用転送メカニズムについてコンセンサスを得るというタスクを設定しました。パケットの輻輳が一般的になるかどうか、およびそれが将来起こる場合の対処法に関する調査問題は、IRTF（[RFC6077]の「Challenge 3：Packet Size」）で検討される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that sometimes it seems that resources might be congested by neither bits nor packets, e.g., where the queue for access to a wireless medium is in units of transmission opportunities. However, the root cause of congestion of the underlying spectrum is overload of bits (see Section 4.1.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
場合によっては、リソースがビットでもパケットでも輻輳していないように見えることがあります。たとえば、無線メディアへのアクセスのキューが送信機会の単位になっている場合などです。ただし、基になるスペクトルの輻輳の根本的な原因は、ビットの過負荷です（セクション4.1.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Security-Considerations">
6. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo recommends that queues do not bias drop probability due to packets size. For instance, dropping small packets less often than large ones creates a perverse incentive for transports to break down their flows into tiny segments. One of the benefits of implementing AQM was meant to be to remove this perverse incentive that tail-drop queues gave to small packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、キューがパケットサイズのためにドロップ確率を偏らせないことを推奨します。たとえば、大きなパケットよりも小さなパケットをドロップする頻度が低いと、トランスポートがフローを小さなセグメントに分割するための不正なインセンティブが生じます。 AQMを実装する利点の1つは、テールドロップキューが小さなパケットに与えたこの邪魔なインセンティブを取り除くことでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In practice, transports cannot all be trusted to respond to congestion. So another reason for recommending that queues not bias drop probability towards small packets is to avoid the vulnerability to small-packet DDoS attacks that would otherwise result. One of the benefits of implementing AQM was meant to be to remove tail drop&#39;s DoS vulnerability to small packets, so we shouldn&#39;t add it back again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実際には、トランスポートはすべて混雑に対応するために信頼することができません。したがって、キューがドロップ確率を小さなパケットに偏らせないことを推奨するもう1つの理由は、そうでなければ発生する可能性がある小さなパケットのDDoS攻撃に対する脆弱性を回避するためです。 AQMを実装する利点の1つは、テールドロップのDoS脆弱性を小さなパケットに削除することでした。そのため、再度追加することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If most queues implemented AQM with byte-mode drop, the resulting network would amplify the potency of a small-packet DDoS attack. At the first queue, the stream of packets would push aside a greater proportion of large packets, so more of the small packets would survive to attack the next queue. Thus a flood of small packets would continue on towards the destination, pushing regular traffic with large packets out of the way in one queue after the next, but suffering much less drop itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ほとんどのキューがバイトモードドロップでAQMを実装した場合、結果として生じるネットワークは、小さなパケットのDDoS攻撃の可能性を増幅します。最初のキューでは、パケットのストリームが大きなパケットのより大きな割合を押しのけるため、小さなパケットの多くが次のキューを攻撃するために生き残ります。したがって、小さなパケットのフラッドが宛先に向かって継続し、大きなパケットを含む通常のトラフィックを次のキューの途中で押し出しますが、ドロップ自体の影響ははるかに少なくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Appendix C explains why the ability of networks to police the response of _any_ transport to congestion depends on bit-congestible network resources only doing packet-mode drop, not byte-mode drop. In summary, it says that making drop probability depend on the size of the packets that bits happen to be divided into simply encourages the bits to be divided into smaller packets. Byte-mode drop would therefore irreversibly complicate any attempt to fix the Internet&#39;s incentive structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
付録Cは、ネットワークが輻輳に対する_any_トランスポートの応答をポリシングする能力が、ビットモードドロップではなく、パケットモードドロップのみを行うビット混雑ネットワークリソースに依存する理由を説明しています。要約すると、ドロップ確率を作ることは、ビットが分割されるパケットのサイズに依存するということは、ビットがより小さなパケットに分割されることを単に促進するだけであると言います。したがって、バイトモードのドロップは、インターネットのインセンティブ構造を修正しようとする試みを不可逆的に複雑にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Conclusions">
7. Conclusions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 結論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo identifies the three distinct stages of the congestion notification process where implementations need to decide whether to take packet size into account. The recommendations provided in Section 2 of this memo are different in each case:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、実装がパケットサイズを考慮するかどうかを決定する必要がある、輻輳通知プロセスの3つの異なる段階を識別します。このメモのセクション2で提供される推奨事項は、それぞれの場合で異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When network equipment measures the length of a queue, if it is not feasible to use time; it is recommended to count in bytes if the network resource is congested by bytes, or to count in packets if is congested by packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ネットワーク機器がキューの長さを測定するとき、時間を使用することが現実的でない場合。ネットワークリソースがバイトで混雑している場合はバイトでカウントするか、パケットで混雑している場合はパケットでカウントすることをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When network equipment decides whether to drop (or mark) a packet, it is recommended that the size of the particular packet should not be taken into account.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ネットワーク機器がパケットをドロップ（またはマーク）するかどうかを決定する場合、特定のパケットのサイズを考慮に入れないことをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o However, when a transport algorithm responds to a dropped or marked packet, the size of the rate reduction should be proportionate to the size of the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ただし、トランスポートアルゴリズムがドロップまたはマークされたパケットに応答する場合、レート削減のサイズはパケットのサイズに比例する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In summary, the answers are &#39;it depends&#39;, &#39;no&#39;, and &#39;yes&#39;, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要約すると、答えはそれぞれ「依存する」、「いいえ」、「はい」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the specific case of RED, this means that byte-mode queue measurement will often be appropriate, but the use of byte-mode drop is very strongly discouraged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REDの特定のケースでは、これはバイトモードキュー測定が適切であることが多いことを意味しますが、バイトモードドロップの使用は非常に推奨されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the transport layer, the IETF should continue updating congestion control protocols to take into account the size of each packet that indicates congestion. Also, the IETF should continue to make protocols less sensitive to losing control packets like SYNs, pure ACKs, and DNS exchanges. Although many control packets happen to be small, the alternative of network equipment favouring all small packets would be dangerous. That would create perverse incentives to split data transfers into smaller packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランスポート層では、IETFは輻輳を示す各パケットのサイズを考慮に入れるために、輻輳制御プロトコルの更新を継続する必要があります。また、IETFは、SYN、純粋なACK、DNS交換などの制御パケットの損失に対するプロトコルの感度を下げ続ける必要があります。多くの制御パケットはたまたま小さいですが、すべての小さいパケットを優先するネットワーク機器の代替は危険です。これは、データ転送をより小さなパケットに分割するための不正なインセンティブを作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The memo develops these recommendations from principled arguments concerning scaling, layering, incentives, inherent efficiency, security, and &#39;policeability&#39;. It also addresses practical issues such as specific buffer architectures and incremental deployment. Indeed, a limited survey of RED implementations is discussed, which shows there appears to be little, if any, installed base of RED&#39;s byte-mode drop. Therefore, it can be deprecated with little, if any, incremental deployment complications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモは、スケーリング、階層化、インセンティブ、固有の効率、セキュリティ、および「取り決め可能性」に関する原理的な議論からこれらの推奨事項を作成します。また、特定のバッファアーキテクチャや増分展開などの実際的な問題にも対処します。実際、RED実装の限られた調査が議論されており、REDのバイトモードドロップのインストールベースがあったとしてもほとんどないように見えます。したがって、展開の複雑さを少しでも増やしながら、廃止することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The recommendations have been developed on the well-founded basis that most Internet resources are bit-congestible, not packet-congestible. We need to know the likelihood that this assumption will prevail in the longer term and, if it might not, what protocol changes will be needed to cater for a mix of the two. The IRTF Internet Congestion Control Research Group (ICCRG) is currently working on these problems [RFC6077].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
推奨事項は、ほとんどのインターネットリソースがビットに対応しており、パケットに対応していないという根拠に基づいて作成されています。この仮定が長期的に行き渡る可能性と、そうでない場合は、この2つの組み合わせに対応するために必要なプロトコルの変更を知る必要があります。 IRTFインターネット輻輳制御研究グループ（ICCRG）は現在これらの問題に取り組んでいます[RFC6077]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--Acknowledgements">
8. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thank you to Sally Floyd, who gave extensive and useful review comments. Also thanks for the reviews from Philip Eardley, David Black, Fred Baker, David Taht, Toby Moncaster, Arnaud Jacquet, and Mirja Kuehlewind, as well as helpful explanations of different hardware approaches from Larry Dunn and Fred Baker. We are grateful to Bruce Davie and his colleagues for providing a timely and efficient survey of RED implementation in Cisco&#39;s product range. Also, grateful thanks to Toby Moncaster, Will Dormann, John Regnault, Simon Carter, and Stefaan De Cnodder who further helped survey the current status of RED implementation and deployment, and, finally, thanks to the anonymous individuals who responded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
広範囲で有用なレビューコメントを提供してくれたサリー・フロイドに感謝します。また、Philip Eardley、David Black、Fred Baker、David Taht、Toby Moncaster、Arnaud Jacquet、Mirja Kuehlewindによるレビュー、およびLarry DunnとFred Bakerによるさまざまなハードウェアアプローチの役立つ説明にも感謝します。シスコの製品群におけるREDの実装に関するタイムリーで効率的な調査を提供してくれたBruce Davie氏とその同僚に感謝します。また、REDの実装と展開の現在の状況の調査をさらに支援してくれたToby Moncaster、Will Dormann、John Regnault、Simon Carter、およびStefaan De Cnodderに感謝し、最後に、回答した匿名の個人に感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bob Briscoe and Jukka Manner were partly funded by Trilogy and Trilogy 2, research projects (ICT-216372, ICT-317756) supported by the European Community under its Seventh Framework Programme. The views expressed here are those of the authors only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bob BriscoeとJukka Mannerは、その7番目のフレームワークプログラムの下で欧州共同体によってサポートされているTrilogyおよびTrilogy 2の研究プロジェクト（ICT-216372、ICT-317756）から部分的に資金提供を受けました。ここで表明されている見解は著者のみの見解です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--References">
9. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-1--Normative-References">
9.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2309] Braden, B., Clark, D., Crowcroft, J., Davie, B., Deering, S., Estrin, D., Floyd, S., Jacobson, V., Minshall, G., Partridge, C., Peterson, L., Ramakrishnan, K., Shenker, S., Wroclawski, J., and L. Zhang, &#34;Recommendations on Queue Management and Congestion Avoidance in the Internet&#34;, RFC 2309, April 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2309]ブレーデン、B。、クラーク、D。、クロウクロフト、J。、デイビー、B。、ディアリング、S。、エストリン、D。、フロイド、S。、ジェイコブソン、V。、ミンシャル、G。、パートリッジ、 C.、Peterson、L.、Ramakrishnan、K.、Shenker、S.、Wroclawski、J。、およびL. Zhang、「インターネットでのキュー管理と輻輳回避に関する推奨事項」、RFC 2309、1998年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2914] Floyd, S., &#34;Congestion Control Principles&#34;, BCP 41, RFC 2914, September 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2914]フロイド、S。、「輻輳制御原則」、BCP 41、RFC 2914、2000年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, &#34;The Addition of Explicit Congestion Notification (ECN) to IP&#34;, RFC 3168, September 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3168]ラマクリシュナン、K。、フロイド、S。、およびD.ブラック、「IPへの明示的輻輳通知（ECN）の追加」、RFC 3168、2001年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2--Informative-References">
9.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BLUE02] Feng, W-c., Shin, K., Kandlur, D., and D. Saha, &#34;The BLUE active queue management algorithms&#34;, IEEE/ACM Transactions on Networking 10(4) 513-528, August 2002, &lt;http://dx.doi.org/10.1109/TNET.2002.801399&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BLUE02] Feng、Wc。、Shin、K.、Kandlur、D。、およびD. Saha、「BLUEアクティブキュー管理アルゴリズム」、IEEE / ACM Transactions on Networking 10（4）513-528、2002年8月、&lt; http://dx.doi.org/10.1109/TNET.2002.801399&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CCvarPktSize] Widmer, J., Boutremans, C., and J-Y. Le Boudec, &#34;End-to-end congestion control for TCP-friendly flows with variable packet size&#34;, ACM CCR 34(2) 137-151, April 2004, &lt;http://doi.acm.org/10.1145/997150.997162&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CCvarPktSize] Widmer、J.、Boutremans、C、およびJ-Y。 Le Boudec、「可変パケットサイズのTCPフレンドリーフローのエンドツーエンドの輻輳制御」、ACM CCR 34（2）137-151、2004年4月、&lt;http://doi.acm.org/10.1145/997150.997162&gt; 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CHOKe_Var_Pkt] Psounis, K., Pan, R., and B. Prabhaker, &#34;Approximate Fair Dropping for Variable-Length Packets&#34;, IEEE Micro 21(1):48-56, January-February 2001, &lt;http://ieeexplore.ieee.org/xpl/ articleDetails.jsp?arnumber=903061&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CHOKe_Var_Pkt] Psounis、K.、Pan、R。、およびB. Prabhaker、「可変長パケットの近似フェアドロップ」、IEEE Micro 21（1）：48-56、2001年1月〜2月、&lt;http：// ieeexplore.ieee.org/xpl/ articleDetails.jsp？arnumber = 903061&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CoDel] Nichols, K. and V. Jacobson, &#34;Controlled Delay Active Queue Management&#34;, Work in Progress, February 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CoDel] Nichols、K。およびV. Jacobson、「Controlled Delay Active Queue Management」、Work in Progress、2013年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DRQ] Shin, M., Chong, S., and I. Rhee, &#34;Dual-Resource TCP/AQM for Processing-Constrained Networks&#34;, IEEE/ACM Transactions on Networking Vol 16, issue 2, April 2008, &lt;http://dx.doi.org/10.1109/TNET.2007.900415&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DRQ]シン、M。、チョン、S。、およびI.リー、「処理に制約のあるネットワーク用のデュアルリソースTCP / AQM」、IEEE / ACM Transactions on Networking Vol 16、発行2、2008年4月、&lt;http： //dx.doi.org/10.1109/TNET.2007.900415&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DupTCP] Wischik, D., &#34;Short messages&#34;, Philosophical Transactions of the Royal Society A 366(1872):1941-1953, June 2008, &lt;http://rsta.royalsocietypublishing.org/content/366/1872/ 1941.full.pdf+html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DupTCP] Wischik、D。、「短いメッセージ」、王立協会の哲学的トランザクションA 366（1872）：1941-1953、2008年6月、&lt;http://rsta.royalsocietypublishing.org/content/366/1872/ 1941 .full.pdf + html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ECNFixedWireless] Siris, V., &#34;Resource Control for Elastic Traffic in CDMA Networks&#34;, Proc. ACM MOBICOM&#39;02 , September 2002, &lt;http://www.ics.forth.gr/netlab/publications/ resource_control_elastic_cdma.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ECNFixedWireless] Siris、V。、「CDMAネットワークにおけるエラスティックトラフィックのリソース制御」、Proc。 ACM MOBICOM&#39;02、2002年9月、&lt;http://www.ics.forth.gr/netlab/publications/resource_control_elastic_cdma.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Evol_cc] Gibbens, R. and F. Kelly, &#34;Resource pricing and the evolution of congestion control&#34;, Automatica 35(12)1969-1985, December 1999, &lt;http://www.sciencedirect.com/science/article/pii/ S0005109899001351&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Evol_cc] Gibbens、R。およびF. Kelly、「リソースの価格設定と輻輳制御の進化」、Automatica 35（12）1969-1985、1999年12月、&lt;http://www.sciencedirect.com/science/article/ pii / S0005109899001351&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GentleAggro] Flach, T., Dukkipati, N., Terzis, A., Raghavan, B., Cardwell, N., Cheng, Y., Jain, A., Hao, S., Katz-Bassett, E., and R. Govindan, &#34;Reducing web latency: the virtue of gentle aggression&#34;, ACM SIGCOMM CCR 43(4)159-170, August 2013, &lt;http://doi.acm.org/10.1145/2486001.2486014&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GentleAggro] Flach、T.、Dukkipati、N.、Terzis、A.、Raghavan、B.、Cardwell、N.、Cheng、Y.、Jain、A.、Hao、S.、Katz-Bassett、E。、およびR.ゴビンダン、「Webレイテンシの削減：穏やかな攻撃の美徳」、ACM SIGCOMM CCR 43（4）159-170、2013年8月、&lt;http://doi.acm.org/10.1145/2486001.2486014&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IOSArch] Bollapragada, V., White, R., and C. Murphy, &#34;Inside Cisco IOS Software Architecture&#34;, Cisco Press: CCIE Professional Development ISBN13: 978-1-57870-181-0, July 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IOSArch] Bollapragada、V.、White、R。、およびC. Murphy、「Inside Cisco IOS Software Architecture」、Cisco Press：CCIE Professional Development ISBN13：978-1-57870-181-0、June 2000。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PIE] Pan, R., Natarajan, P., Piglione, C., Prabhu, M., Subramanian, V., Baker, F., and B. Steeg, &#34;PIE: A Lightweight Control Scheme To Address the Bufferbloat Problem&#34;, Work in Progress, February 2014.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PIE]パン、R。、ナタラジャン、P。、ピグリオーネ、C。、プラブ、M。、サブラマニアン、V。、ベイカー、F。、およびB.スティーグ、「PIE：バッファブロート問題に対処する軽量制御スキーム&#34;、2014年2月の作業中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PktSizeEquCC] Vasallo, P., &#34;Variable Packet Size Equation-Based Congestion Control&#34;, ICSI Technical Report tr-00-008, 2000, &lt;http://http.icsi.berkeley.edu/ftp/global/pub/ techreports/2000/tr-00-008.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PktSizeEquCC] Vasallo、P。、「可変パケットサイズの方程式ベースの輻輳制御」、ICSIテクニカルレポートtr-00-008、2000、&lt;http://http.icsi.berkeley.edu/ftp/global/pub/techreports /2000/tr-00-008.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RED93] Floyd, S. and V. Jacobson, &#34;Random Early Detection (RED) gateways for Congestion Avoidance&#34;, IEEE/ACM Transactions on Networking 1(4) 397--413, August 1993, &lt;http://ieeexplore.ieee.org/xpls/ abs_all.jsp?arnumber=251892&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RED93]フロイド、S。、およびV.ジェイコブソン、「輻輳回避のためのランダム早期検出（RED）ゲートウェイ」、IEEE / ACM Transactions on Networking 1（4）397--413、1993年8月、&lt;http：// ieeexplore。 ieee.org/xpls/ abs_all.jsp？arnumber = 251892&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[REDbias] Eddy, W. and M. Allman, &#34;A Comparison of RED&#39;s Byte and Packet Modes&#34;, Computer Networks 42(3) 261--280, June 2003, &lt;http://www.ir.bbn.com/documents/articles/redbias.ps&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[REDbias] Eddy、W。およびM. Allman、「A Comparison of RED&#39;s Byte and Packet Modes」、Computer Networks 42（3）261--280、2003年6月、&lt;http://www.ir.bbn.com/ documents / articles / redbias.ps&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[REDbyte] De Cnodder, S., Elloumi, O., and K. Pauwels, &#34;Effect of different packet sizes on RED performance&#34;, Proc. 5th IEEE Symposium on Computers and Communications (ISCC) 793-799, July 2000, &lt;http://ieeexplore.ieee.org/xpls/ abs_all.jsp?arnumber=860741&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[REDbyte] De Cnodder、S.、Elloumi、O。、およびK. Pauwels、「REDパフォーマンスに対するさまざまなパケットサイズの影響」、Proc。コンピュータと通信に関する第5回IEEEシンポジウム（ISCC）793-799、2000年7月、&lt;http://ieeexplore.ieee.org/xpls/ abs_all.jsp？arnumber = 860741&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2474] Nichols, K., Blake, S., Baker, F., and D. Black, &#34;Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers&#34;, RFC 2474, December 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2474] Nichols、K.、Blake、S.、Baker、F。、およびD. Black、「Definition of the Differentiated Services Field（DS Field）in the IPv4 and IPv6 Headers」、RFC 2474、1998年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3426] Floyd, S., &#34;General Architectural and Policy Considerations&#34;, RFC 3426, November 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3426] Floyd、S。、「General Architectural and Policy Considerations」、RFC 3426、2002年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3550] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &#34;RTP: A Transport Protocol for Real-Time Applications&#34;, STD 64, RFC 3550, July 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3550] Schulzrinne、H.、Casner、S.、Frederick、R。、およびV. Jacobson、「RTP：A Transport Protocol for Real-Time Applications」、STD 64、RFC 3550、2003年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3714] Floyd, S. and J. Kempf, &#34;IAB Concerns Regarding Congestion Control for Voice Traffic in the Internet&#34;, RFC 3714, March 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3714]フロイドS.およびJ.ケンプ、「インターネットにおける音声トラフィックの輻輳制御に関するIABの懸念」、RFC 3714、2004年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4828] Floyd, S. and E. Kohler, &#34;TCP Friendly Rate Control (TFRC): The Small-Packet (SP) Variant&#34;, RFC 4828, April 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4828] Floyd、S。およびE. Kohler、「TCP Friendly Rate Control（TFRC）：The Small-Packet（SP）Variant」、RFC 4828、2007年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5348] Floyd, S., Handley, M., Padhye, J., and J. Widmer, &#34;TCP Friendly Rate Control (TFRC): Protocol Specification&#34;, RFC 5348, September 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5348] Floyd、S.、Handley、M.、Padhye、J。、およびJ. Widmer、「TCP Friendly Rate Control（TFRC）：Protocol Specification」、RFC 5348、2008年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5562] Kuzmanovic, A., Mondal, A., Floyd, S., and K. Ramakrishnan, &#34;Adding Explicit Congestion Notification (ECN) Capability to TCP&#39;s SYN/ACK Packets&#34;, RFC 5562, June 2009.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5562]クズマノビッチ、A。、モンダル、A。、フロイド、S。、およびK.ラマクリシュナン、「TCPのSYN / ACKパケットへの明示的輻輳通知（ECN）機能の追加」、RFC 5562、2009年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5670] Eardley, P., &#34;Metering and Marking Behaviour of PCN-Nodes&#34;, RFC 5670, November 2009.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5670] Eardley、P。、「PCNノードの測定とマーキングの動作」、RFC 5670、2009年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681] Allman, M., Paxson, V., and E. Blanton, &#34;TCP Congestion Control&#34;, RFC 5681, September 2009.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681] Allman、M.、Paxson、V。、およびE. Blanton、「TCP Congestion Control」、RFC 5681、2009年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5690] Floyd, S., Arcia, A., Ros, D., and J. Iyengar, &#34;Adding Acknowledgement Congestion Control to TCP&#34;, RFC 5690, February 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5690] Floyd、S.、Arcia、A.、Ros、D。、およびJ. Iyengar、「Adding Acknowledgement Congestion Control Control to TCP」、RFC 5690、2010年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6077] Papadimitriou, D., Welzl, M., Scharf, M., and B. Briscoe, &#34;Open Research Issues in Internet Congestion Control&#34;, RFC 6077, February 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6077] Papadimitriou、D.、Welzl、M.、Scharf、M.、and B. Briscoe、 &#34;Open Research Issues in Internet Congestion Control&#34;、RFC 6077、February 2011。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6679] Westerlund, M., Johansson, I., Perkins, C., O&#39;Hanlon, P., and K. Carlberg, &#34;Explicit Congestion Notification (ECN) for RTP over UDP&#34;, RFC 6679, August 2012.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6679] Westerlund、M.、Johansson、I.、Perkins、C.、O&#39;Hanlon、P。、およびK. Carlberg、「RTP over UDPの明示的輻輳通知（ECN）」、RFC 6679、2012年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6789] Briscoe, B., Woundy, R., and A. Cooper, &#34;Congestion Exposure (ConEx) Concepts and Use Cases&#34;, RFC 6789, December 2012.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6789] Briscoe、B.、Woundy、R。、およびA. Cooper、「Congestion Exposure（ConEx）Concepts and Use Cases」、RFC 6789、2012年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Rate_fair_Dis] Briscoe, B., &#34;Flow Rate Fairness: Dismantling a Religion&#34;, ACM CCR 37(2)63-74, April 2007, &lt;http://portal.acm.org/citation.cfm?id=1232926&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Rate_fair_Dis] Briscoe、B。、「Flow Rate Fairness：Dismantling a Religion」、ACM CCR 37（2）63-74、2007年4月、&lt;http://portal.acm.org/citation.cfm?id=1232926&gt; 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[gentle_RED] Floyd, S., &#34;Recommendation on using the &#34;gentle_&#34; variant of RED&#34;, Web page , March 2000, &lt;http://www.icir.org/floyd/red/gentle.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[gentle_RED] Floyd、S。、「REDの &#34;gentle_&#34;バリアントの使用に関する推奨」、Webページ、2000年3月、&lt;http://www.icir.org/floyd/red/gentle.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[pBox] Floyd, S. and K. Fall, &#34;Promoting the Use of End-to-End Congestion Control&#34;, IEEE/ACM Transactions on Networking 7(4) 458--472, August 1999, &lt;http://ieeexplore.ieee.org/ xpls/abs_all.jsp?arnumber=793002&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[pBox]フロイド、S。、およびK.フォール、「エンドツーエンドの輻輳制御の使用の促進」、IEEE / ACM Transactions on Networking 7（4）458--472、1999年8月、&lt;http：// ieeexplore .ieee.org / xpls / abs_all.jsp？arnumber = 793002&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[pktByteEmail] Floyd, S., &#34;RED: Discussions of Byte and Packet Modes&#34;, email, March 1997, &lt;http://ee.lbl.gov/floyd/REDaveraging.txt&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[pktByteEmail] Floyd、S。、「RED：ディスカッションのバイトモードとパケットモード」、電子メール、1997年3月、&lt;http://ee.lbl.gov/floyd/REDaveraging.txt&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-A--Survey-of-RED-Implementation-Status">
Appendix A. Survey of RED Implementation Status
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録A. REDの実装状況の調査
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This Appendix is informative, not normative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この付録は参考情報であり、規範的ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In May 2007 a survey was conducted of 84 vendors to assess how widely drop probability based on packet size has been implemented in RED Table 3. About 19% of those surveyed replied, giving a sample size of 16. Although in most cases we do not have permission to identify the respondents, we can say that those that have responded include most of the larger equipment vendors, covering a large fraction of the market. The two who gave permission to be identified were Cisco and Alcatel-Lucent. The others range across the large network equipment vendors at L3 &amp; L2, firewall vendors, wireless equipment vendors, as well as large software businesses with a small selection of networking products. All those who responded confirmed that they have not implemented the variant of RED with drop dependent on packet size (2 were fairly sure they had not but needed to check more thoroughly). At the time the survey was conducted, Linux did not implement RED with packet-size bias of drop, although we have not investigated a wider range of open source code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2007年5月に、パケットサイズに基づくドロップ確率がRED表3にどのように実装されているかを評価するために、84ベンダーの調査が行われました。調査された回答者の約19％が回答し、サンプルサイズは16でした。ほとんどの場合、回答者を特定する許可があれば、回答者には市場の大部分をカバーするほとんどの大規模な機器ベンダーが含まれていると言えます。特定を許可された2人は、シスコとアルカテルルーセントでした。その他は、L3とL2の大規模なネットワーク機器ベンダー、ファイアウォールベンダー、無線機器ベンダー、および少数のネットワーク製品を備えた大規模なソフトウェアビジネスに及びます。応答したすべての人が、パケットサイズに依存するドロップを伴うREDのバリアントを実装していないことを確認しました（2は、彼らがそうではなかったが、より徹底的にチェックする必要があったことはかなり確かでした）。調査が行われた時点では、LinuxはパケットサイズバイアスがドロップのREDを実装していませんでしたが、オープンソースコードの幅広い範囲については調査していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     +-------------------------------+----------------+--------------+
     |                      Response | No. of vendors | % of vendors |
     +-------------------------------+----------------+--------------+
     |               Not implemented |             14 |          17% |
     |    Not implemented (probably) |              2 |           2% |
     |                   Implemented |              0 |           0% |
     |                   No response |             68 |          81% |
     | Total companies/orgs surveyed |             84 |         100% |
     +-------------------------------+----------------+--------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
Table 3: Vendor Survey on byte-mode drop variant of RED (lower drop probability for small packets)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
表3：REDのバイトモードドロップバリアントに関するベンダー調査（小さなパケットのドロップ確率が低い）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where reasons were given for why the byte-mode drop variant had not been implemented, the extra complexity of packet-bias code was most prevalent, though one vendor had a more principled reason for avoiding it -- similar to the argument of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイトモードドロップバリアントが実装されなかった理由が示された場合、パケットバイアスコードの余分な複雑さが最も一般的でしたが、1つのベンダーがそれを回避するためのより原則的な理由を持っていました-このドキュメントの議論と同様です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Our survey was of vendor implementations, so we cannot be certain about operator deployment. But we believe many queues in the Internet are still tail drop. The company of one of the co-authors (BT) has widely deployed RED; however, many tail-drop queues are bound to still exist, particularly in access network equipment and on middleboxes like firewalls, where RED is not always available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちの調査はベンダーの実装に関するものだったので、オペレーターの配備について確信が持てません。しかし、インターネットのキューの多くは依然としてテールドロップであると考えています。共著者の1人（BT）の会社は、REDを広く展開しています。ただし、特にアクセスネットワーク機器やファイアウォールのようなミドルボックスでは、REDが常に利用できるとは限らないため、多くのテールドロップキューが依然として存在することになっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Routers using a memory architecture based on fixed-size buffers with borrowing may also still be prevalent in the Internet. As explained in Section 4.2.1, these also provide a marginal (but legitimate) bias towards small packets. So even though RED byte-mode drop is not prevalent, it is likely there is still some bias towards small packets in the Internet due to tail-drop and fixed-buffer borrowing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
借用の固定サイズバッファーに基づくメモリアーキテクチャを使用するルーターも、インターネットで普及している可能性があります。セクション4.2.1で説明したように、これらは小さなパケットに対する限界的な（しかし正当な）バイアスも提供します。そのため、REDバイトモードドロップは普及していませんが、テールドロップと固定バッファの借用が原因で、インターネットの小さなパケットに偏っている可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-B--Sufficiency-of-Packet-Mode-Drop">
Appendix B. Sufficiency of Packet-Mode Drop
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録B.パケットモードドロップの十分性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This Appendix is informative, not normative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この付録は参考情報であり、規範的ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here we check that packet-mode drop (or marking) in the network gives sufficiently generic information for the transport layer to use. We check against a 2x2 matrix of four scenarios that may occur now or in the future (Table 4). Checking the two scenarios in each of the horizontal and vertical dimensions tests the extremes of sensitivity to packet size in the transport and in the network respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここでは、ネットワークのパケットモードドロップ（またはマーキング）が、トランスポート層が使用するのに十分に一般的な情報を提供することを確認します。現在または将来発生する可能性のある4つのシナリオの2x2マトリックスに対してチェックします（表4）。水平および垂直の各次元で2つのシナリオをチェックすると、トランスポートおよびネットワークそれぞれのパケットサイズに対する極端な感度がテストされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this section does not consider byte-mode drop at all. Having deprecated byte-mode drop, the goal here is to check that packet-mode drop will be sufficient in all cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、バイトモードのドロップはまったく考慮されていないことに注意してください。バイトモードドロップが廃止されたため、ここでの目標は、すべてのケースでパケットモードドロップで十分であることを確認することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------------------------+-----------------+-----------------+
   |                  Transport -&gt; |  a) Independent | b) Dependent on |
   | ----------------------------- |  of packet size |  packet size of |
   | Network                       |  of congestion  |    congestion   |
   |                               |  notifications  |  notifications  |
   +-------------------------------+-----------------+-----------------+
   | 1) Predominantly bit-         |   Scenario a1)  |   Scenario b1)  |
   | congestible network           |                 |                 |
   | 2) Mix of bit-congestible and |   Scenario a2)  |   Scenario b2)  |
   | pkt-congestible network       |                 |                 |
   +-------------------------------+-----------------+-----------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
Table 4: Four Possible Congestion Scenarios
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
表4：4つの考えられる輻輳シナリオ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Appendix B.1 focuses on the horizontal dimension of Table 4 checking that packet-mode drop (or marking) gives sufficient information, whether or not the transport uses it -- scenarios b) and a) respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
付録B.1は、トランスポートが使用するかどうかにかかわらず、パケットモードドロップ（またはマーキング）が十分な情報を提供するかどうかをチェックする表4の水平方向のディメンションに焦点を当てています（シナリオb）およびa）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Appendix B.2 focuses on the vertical dimension of Table 4, checking that packet-mode drop gives sufficient information to the transport whether resources in the network are bit-congestible or packet-congestible (these terms are defined in Section 1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
付録B.2は、表4の垂直方向のディメンションに焦点を当てており、ネットワーク内のリソースがビットコンセッション可能かパケットコンセッション可能かを問わず、パケットモードドロップがトランスポートに十分な情報を提供することを確認します（これらの用語はセクション1.1で定義されています）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Notation: To be concrete, we will compare two flows with different packet sizes, s_1 and s_2. As an example, we will take s_1 = 60 B = 480 b and s_2 = 1,500 B = 12,000 b.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表記法：具体的には、パケットサイズが異なる2つのフロー、s_1とs_2を比較します。例として、s_1 = 60 B = 480 bおよびs_2 = 1,500 B = 12,000 bとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A flow&#39;s bit rate, x [bps], is related to its packet rate, u [pps], by
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
フローのビットレートx [bps]は、パケットレートu [pps]に関連しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
x(t) = s*u(t).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
x（t）= s * u（t）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In the bit-congestible case, path congestion will be denoted by p_b, and in the packet-congestible case by p_p. When either case is implied, the letter p alone will denote path congestion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ビット輻輳の場合、パスの輻輳はp_bで示され、パケット輻輳の場合はp_pで示されます。どちらの場合も暗示される場合、文字pだけがパスの輻輳を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-1--Packet-Size-InDependence-in-Transports">
B.1. Packet-Size (In)Dependence in Transports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.1. トランスポートのパケットサイズ（入力）依存
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In all cases, we consider a packet-mode drop queue that indicates congestion by dropping (or marking) packets with probability p irrespective of packet size. We use an example value of loss (marking) probability, p=0.1%.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのケースで、パケットサイズに関係なく確率pでパケットをドロップ（またはマーキング）することで輻輳を示すパケットモードドロップキューを検討します。損失（マーキング）確率の例の値、p = 0.1％を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A transport like TCP as specified in RFC 5681 treats a congestion notification on any packet whatever its size as one event. However, a network with just the packet-mode drop algorithm gives more information if the transport chooses to use it. We will use Table 5 to illustrate this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 5681で指定されているTCPのようなトランスポートは、パケットの混雑通知を、そのサイズに関係なく1つのイベントとして扱います。ただし、パケットモードのドロップアルゴリズムのみのネットワークでは、トランスポートが使用することを選択した場合、より多くの情報が提供されます。表5を使用してこれを説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We will set aside the last column until later. The columns labelled &#39;Flow 1&#39; and &#39;Flow 2&#39; compare two flows consisting of 60 B and 1,500 B packets respectively. The body of the table considers two separate cases, one where the flows have an equal bit rate and the other with equal packet rates. In both cases, the two flows fill a 96 Mbps link. Therefore, in the equal bit rate case, they each have half the bit rate (48Mbps). Whereas, with equal packet rates, Flow 1 uses 25 times smaller packets so it gets 25 times less bit rate -- it only gets 1/(1+25) of the link capacity (96 Mbps / 26 = 4 Mbps after rounding). In contrast Flow 2 gets 25 times more bit rate (92 Mbps) in the equal packet rate case because its packets are 25 times larger. The packet rate shown for each flow could easily be derived once the bit rate was known by dividing the bit rate by packet size, as shown in the column labelled &#39;Formula&#39;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後の列は後で取ります。 「フロー1」および「フロー2」というラベルの付いた列は、それぞれ60 Bパケットと1,500 Bパケットで構成される2つのフローを比較しています。テーブルの本文では、2つの別々のケースを考慮します。1つはフローのビットレートが等しく、もう1つはパケットレートが等しい場合です。どちらの場合も、2つのフローは96 Mbpsリンクを満たします。したがって、等しいビットレートの場合、それぞれのビットレートは半分になります（48Mbps）。一方、等しいパケットレートでは、フロー1は25倍小さいパケットを使用するため、ビットレートは25分の1になります-リンク容量の1 /（1 + 25）のみを取得します（96 Mbps / 26 =丸め後の4 Mbps）。対照的に、フロー2は、パケットが25倍大きいため、等しいパケットレートの場合に25倍のビットレート（92 Mbps）を取得します。 「式」というラベルの付いた列に示されているように、ビットレートがパケットサイズで除算されてビットレートがわかると、各フローに表示されるパケットレートは簡単に導き出せます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Parameter               Formula       Flow 1   Flow 2 Combined
      ----------------------- ----------- -------- -------- --------
      Packet size             s/8             60 B  1,500 B    (Mix)
      Packet size             s              480 b 12,000 b    (Mix)
      Pkt loss probability    p               0.1%     0.1%     0.1%
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      EQUAL BIT RATE CASE
      Bit rate                x            48 Mbps  48 Mbps  96 Mbps
      Packet rate             u = x/s     100 kpps   4 kpps 104 kpps
      Absolute pkt-loss rate  p*u          100 pps    4 pps  104 pps
      Absolute bit-loss rate  p*u*s        48 kbps  48 kbps  96 kbps
      Ratio of lost/sent pkts p*u/u           0.1%     0.1%     0.1%
      Ratio of lost/sent bits p*u*s/(u*s)     0.1%     0.1%     0.1%
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      EQUAL PACKET RATE CASE
      Bit rate                x             4 Mbps  92 Mbps  96 Mbps
      Packet rate             u = x/s       8 kpps   8 kpps  15 kpps
      Absolute pkt-loss rate  p*u            8 pps    8 pps   15 pps
      Absolute bit-loss rate  p*u*s         4 kbps  92 kbps  96 kbps
      Ratio of lost/sent pkts p*u/u           0.1%     0.1%     0.1%
      Ratio of lost/sent bits p*u*s/(u*s)     0.1%     0.1%     0.1%
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
Table 5: Absolute Loss Rates and Loss Ratios for Flows of Small and Large Packets and Both Combined
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
表5：小さいパケットと大きいパケット、および両方を組み合わせたフローの絶対損失率と損失率
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So far, we have merely set up the scenarios. We now consider congestion notification in the scenario. Two TCP flows with the same round-trip time aim to equalise their packet-loss rates over time; that is, the number of packets lost in a second, which is the packets per second (u) multiplied by the probability that each one is dropped (p). Thus, TCP converges on the case labelled &#39;Equal packet rate&#39; in the table, where both flows aim for the same absolute packet-loss rate (both 8 pps in the table).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これまでのところ、シナリオを設定しただけです。次に、シナリオで輻輳通知を検討します。同じ往復時間を持つ2つのTCPフローは、時間の経過に伴うパケット損失率を等しくすることを目的としています。つまり、1秒あたりに失われたパケット数。1秒あたりのパケット数（u）に、各パケットがドロップされる確率（p）を掛けたものです。したがって、TCPは、表の「等しいパケットレート」とラベル付けされたケースに収束します。この場合、両方のフローが同じ絶対パケット損失率を目指します（表では両方とも8 pps）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packet-mode drop actually gives flows sufficient information to measure their loss rate in bits per second, if they choose, not just packets per second. Each flow can count the size of a lost or marked packet and scale its rate response in proportion (as TFRC-SP does). The result is shown in the row entitled &#39;Absolute bit-loss rate&#39;, where the bits lost in a second is the packets per second (u) multiplied by the probability of losing a packet (p) multiplied by the packet size (s). Such an algorithm would try to remove any imbalance in the bit-loss rate such as the wide disparity in the case labelled &#39;Equal packet rate&#39; (4k bps vs. 92 kbps). Instead, a packet-size-dependent algorithm would aim for equal bit-loss rates, which would drive both flows towards the case labelled &#39;Equal bit rate&#39;, by driving them to equal bit-loss rates (both 48 kbps in this example).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットモードドロップは、実際に、1秒あたりのパケットだけでなく、必要に応じて損失率をビット/秒で測定するための十分な情報をフローに提供します。各フローは、失われたパケットまたはマークされたパケットのサイズをカウントし、その比率応答を（TFRC-SPが行うように）比例してスケーリングできます。結果は、「絶対ビット損失率」というタイトルの行に示されています。1秒あたりの損失ビットは、1秒あたりのパケット数（u）に、パケット損失の確率（p）にパケットサイズ（s）を掛けたものです。 。このようなアルゴリズムは、「等しいパケットレート」（4k bps対92 kbps）とラベル付けされた場合の広い視差など、ビット損失率の不均衡を取り除こうとします。代わりに、パケットサイズに依存するアルゴリズムは、等しいビット損失率を目指します。これにより、両方のフローを等しいビット損失率（この例では48 kbps）に駆動することにより、両方のフローを「等しいビットレート」というラベルの付いたケースに向けます。 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The explanation so far has assumed that each flow consists of packets of only one constant size. Nonetheless, it extends naturally to flows with mixed packet sizes. In the right-most column of Table 5, a flow of mixed-size packets is created simply by considering Flow 1 and Flow 2 as a single aggregated flow. There is no need for a flow to maintain an average packet size. It is only necessary for the transport to scale its response to each congestion indication by the size of each individual lost (or marked) packet. Taking, for example, the case labelled &#39;Equal packet rate&#39;, in one second about 8 small packets and 8 large packets are lost (making closer to 15 than 16 losses per second due to rounding). If the transport multiplies each loss by its size, in one second it responds to 8*480 and 8*12,000 lost bits, adding up to 96,000 lost bits in a second. This double checks correctly, being the same as 0.1% of the total bit rate of 96 Mbps. For completeness, the formula for absolute bit-loss rate is p(u1*s1+u2*s2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これまでの説明では、各フローは1つの一定サイズのパケットのみで構成されると想定していました。それでも、パケットサイズが混在するフローに自然に拡張されます。表5の右端の列では、混合サイズのパケットのフローは、フロー1とフロー2を1つの集約されたフローと見なすだけで作成されます。フローで平均パケットサイズを維持する必要はありません。トランスポートが各輻輳表示への応答をスケーリングする必要があるのは、失われた（またはマークされた）個々のパケットのサイズだけです。たとえば、「等しいパケットレート」というラベルの付いたケースでは、1秒で約8個の小さなパケットと8個の大きなパケットが失われます（四捨五入により、1秒あたりの損失が16よりも15に近くなります）。トランスポートが各損失にそのサイズを掛けると、1秒で8 * 480および8 * 12,000の損失ビットに応答し、1秒で最大96,000の損失ビットが追加されます。これは正しくチェックされ、96 Mbpsの総ビットレートの0.1％と同じです。完全を期すために、絶対ビット損失率の式はp（u1 * s1 + u2 * s2）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Incidentally, a transport will always measure the loss probability the same, irrespective of whether it measures in packets or in bytes. In other words, the ratio of lost packets to sent packets will be the same as the ratio of lost bytes to sent bytes. (This is why TCP&#39;s bit rate is still proportional to packet size, even when byte counting is used, as recommended for TCP in [RFC5681], mainly for orthogonal security reasons.) This is intuitively obvious by comparing two example flows; one with 60 B packets, the other with 1,500 B packets. If both flows pass through a queue with drop probability 0.1%, each flow will lose 1 in 1,000 packets. In the stream of 60 B packets, the ratio of lost bytes to sent bytes will be 60 B in every 60,000 B; and in the stream of 1,500 B packets, the loss ratio will be 1,500 B out of 1,500,000 B. When the transport responds to the ratio of lost to sent packets, it will measure the same ratio whether it measures in packets or bytes: 0.1% in both cases. The fact that this ratio is the same whether measured in packets or bytes can be seen in Table 5, where the ratio of lost packets to sent packets and the ratio of lost bytes to sent bytes is always 0.1% in all cases (recall that the scenario was set up with p=0.1%).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ちなみに、トランスポートは、パケットで測定するかバイトで測定するかに関係なく、常に同じ損失確率を測定します。つまり、失われたパケットと送信されたパケットの比率は、失われたバイトと送信されたバイトの比率と同じになります。 （[RFC5681]のTCPで推奨されているように、主に直交セキュリティの理由から、バイトカウントが使用されている場合でも、TCPのビットレートがパケットサイズに比例するのはこのためです。 1つは60 Bパケット、もう1つは1,500 Bパケットです。両方のフローがドロップ確率0.1％でキューを通過する場合、各フローは1,000パケットに1パケットを失います。 60 Bパケットのストリームでは、失われたバイトと送信されたバイトの比率は60,000 Bごとに60 Bになります。 1,500 Bパケットのストリームでは、損失率は1,500,000 Bのうち1,500 Bになります。トランスポートが損失と送信パケットの比率に応答すると、パケットまたはバイトのどちらで測定しても同じ比率が測定されます：0.1％両方の場合において。パケットでもバイトでも、この比率が同じであるという事実は、送信パケットに対する損失パケットの比率と送信バイトに対する損失バイトの比率が常に0.1％である表5で確認できます（シナリオはp = 0.1％で設定されました）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This discussion of how the ratio can be measured in packets or bytes is only raised here to highlight that it is irrelevant to this memo! Whether or not a transport depends on packet size depends on how this ratio is used within the congestion control algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
比率をパケットまたはバイトで測定する方法についてのこの議論は、このメモとは無関係であることを強調するために、ここでのみ取り上げられています！トランスポートがパケットサイズに依存するかどうかは、この比率が輻輳制御アルゴリズム内でどのように使用されるかに依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 So far, we have shown that packet-mode drop passes sufficient information to the transport layer so that the transport can take bit congestion into account, by using the sizes of the packets that indicate congestion. We have also shown that the transport can choose not to take packet size into account if it wishes. We will now consider whether the transport can know which to do.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
これまで、パケットモードドロップはトランスポート層に十分な情報を渡し、トランスポートが輻輳を示すパケットのサイズを使用してビットの輻輳を考慮することができることを示しました。また、トランスポートは、必要に応じてパケットサイズを考慮しないことを選択できることも示しました。次に、トランスポートがどちらを実行するかを認識できるかどうかを検討します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-2--Bit-Congestible-and-Packet-Congestible-Indications">
B.2. Bit-Congestible and Packet-Congestible Indications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.2. ビット変換可能およびパケット変換可能表示
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a thought-experiment, imagine an idealised congestion notification protocol that supports both bit-congestible and packet-congestible resources. It would require at least two ECN flags, one for each of the bit-congestible and packet-congestible resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
思考実験として、ビット輻輳可能リソースとパケット輻輳可能リソースの両方をサポートする理想的な輻輳通知プロトコルを想像してみてください。少なくとも2つのECNフラグが必要です。ビットが輻輳するリソースとパケットが輻輳するリソースのそれぞれに1つずつです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. A packet-congestible resource trying to code congestion level p_p into a packet stream should mark the idealised &#39;packet congestion&#39; field in each packet with probability p_p irrespective of the packet&#39;s size. The transport should then take a packet with the packet congestion field marked to mean just one mark, irrespective of the packet size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 輻輳レベルp_pをパケットストリームにコーディングしようとするパケット密集リソースは、パケットのサイズに関係なく、各パケットの理想化された「パケット輻輳」フィールドを確率p_pでマークする必要があります。トランスポートは、パケットのサイズに関係なく、1つのマークのみを意味するようにマークされたパケット輻輳フィールドを持つパケットを受け取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. A bit-congestible resource trying to code time-varying byte-congestion level p_b into a packet stream should mark the &#39;byte congestion&#39; field in each packet with probability p_b, again irrespective of the packet&#39;s size. Unlike before, the transport should take a packet with the byte congestion field marked to count as a mark on each byte in the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 時変バイト輻輳レベルp_bをパケットストリームにコード化しようとするビット混雑リソースは、パケットのサイズに関係なく、各パケットの「バイト輻輳」フィールドを確率p_bでマークする必要があります。以前とは異なり、トランスポートは、パケットの各バイトのマークとしてカウントするようにマークされたバイト輻輳フィールドを持つパケットを受け取る必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This hides a fundamental problem -- much more fundamental than whether we can magically create header space for yet another ECN flag, or whether it would work while being deployed incrementally. Distinguishing drop from delivery naturally provides just one implicit bit of congestion indication information -- the packet is either dropped or not. It is hard to drop a packet in two ways that are distinguishable remotely. This is a similar problem to that of distinguishing wireless transmission losses from congestive losses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは根本的な問題を隠します-さらに別のECNフラグのヘッダースペースを魔法のように作成できるかどうか、または段階的に展開しながら機能するかどうかよりもはるかに根本的な問題です。ドロップと配信を区別すると、当然、輻輳表示情報の暗黙のビットが1つだけ提供されます。パケットはドロップされるか、ドロップされないかのどちらかです。リモートで区別できる2つの方法でパケットをドロップするのは困難です。これは、ワイヤレス伝送損失を輻輳損失から区別する問題と同様の問題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This problem would not be solved, even if ECN were universally deployed. A congestion notification protocol must survive a transition from low levels of congestion to high. Marking two states is feasible with explicit marking, but it is much harder if packets are dropped. Also, it will not always be cost-effective to implement AQM at every low-level resource, so drop will often have to suffice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この問題は、ECNが広く導入されていても解決されません。輻輳通知プロトコルは、低レベルの輻輳から高レベルへの移行に耐えなければなりません。 2つの状態のマーキングは、明示的なマーキングで実現可能ですが、パケットがドロップされると、はるかに困難になります。また、すべての低レベルのリソースにAQMを実装することは、必ずしも費用対効果が高いとは限らないため、ドロップで十分な場合がよくあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 We are not saying two ECN fields will be needed (and we are not saying that somehow a resource should be able to drop a packet in one of two different ways so that the transport can distinguish which sort of drop it was!). These two congestion notification channels are a conceptual device to illustrate a dilemma we could face in the future. Section 3 gives four good reasons why it would be a bad idea to allow for packet size by biasing drop probability in favour of small packets within the network. The impracticality of our thought experiment shows that it will be hard to give transports a practical way to know whether or not to take into account the size of congestion indication packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2つのECNフィールドが必要になるとは言いません（そして、トランスポートがどの種類のドロップであったかをトランスポートが識別できるように、リソースが2つの異なる方法のいずれかでパケットをドロップできる必要があるとは言いません）。これらの2つの輻輳通知チャネルは、将来直面する可能性のあるジレンマを示す概念的なデバイスです。セクション3では、ネットワーク内の小さなパケットを優先してドロップ確率をバイアスすることでパケットサイズを許容するのが悪い考えとなる4つの理由を説明します。私たちの思考実験が非現実的であることは、輻輳表示パケットのサイズを考慮するかどうかを知るための実用的な方法をトランスポートに提供することが難しいことを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fortunately, this dilemma is not pressing because by design most equipment becomes bit-congested before its packet processing becomes congested (as already outlined in Section 1.1). Therefore, transports can be designed on the relatively sound assumption that a congestion indication will usually imply bit congestion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
幸い、このジレンマは差し迫ったものではありません。パケット処理が混雑する前に、ほとんどの機器が設計上ビット混雑するためです（すでにセクション1.1で概説しています）。したがって、トランスポートは、輻輳表示が通常ビット輻輳を意味するという比較的健全な仮定に基づいて設計できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nonetheless, although the above idealised protocol isn&#39;t intended for implementation, we do want to emphasise that research is needed to predict whether there are good reasons to believe that packet congestion might become more common, and if so, to find a way to somehow distinguish between bit and packet congestion [RFC3714].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それにもかかわらず、上記の理想化されたプロトコルは実装を目的としていませんが、パケットの輻輳がより一般的になる可能性があると考える正当な理由があるかどうかを予測するために調査が必要であることを強調し、そうであれば、何らかの方法を見つける必要がありますビットとパケットの混雑を区別する[RFC3714]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recently, the dual resource queue (DRQ) proposal [DRQ] has been made on the premise that, as network processors become more cost-effective, per-packet operations will become more complex (irrespective of whether more function in the network is desirable). Consequently the premise is that CPU congestion will become more common. DRQ is a proposed modification to the RED algorithm that folds both bit congestion and packet congestion into one signal (either loss or ECN).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最近、デュアルリソースキュー（DRQ）の提案[DRQ]が行われました。これは、ネットワークプロセッサの費用対効果が高くなるにつれ、パケットごとの操作がより複雑になることを前提としています（ネットワークでより多くの機能が必要かどうかに関係なく）。 。したがって、CPUの輻輳がより一般的になることを前提としています。 DRQは、REDアルゴリズムに提案された修正であり、ビットの輻輳とパケットの輻輳の両方を1つの信号（損失またはECN）に折りたたみます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, we note one further complication. Strictly, packet-congestible resources are often cycle-congestible. For instance, for routing lookups, load depends on the complexity of each lookup and whether or not the pattern of arrivals is amenable to caching. This also reminds us that any solution must not require a forwarding engine to use excessive processor cycles in order to decide how to say it has no spare processor cycles.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、もう1つの複雑な問題に注意してください。厳密に言えば、パケットが密集しているリソースは、多くの場合サイクルが密集しています。たとえば、ルーティングルックアップの場合、負荷は各ルックアップの複雑さと、到着のパターンがキャッシングに適しているかどうかによって異なります。これはまた、どのソリューションも、予備のプロセッササイクルがないと言う方法を決定するために、転送エンジンが過度のプロセッササイクルを使用する必要がないことを思い出させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-C--Byte-Mode-Drop-Complicates-Policing-Congestion-Response">
Appendix C. Byte-Mode Drop Complicates Policing Congestion Response
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録C.バイトモードドロップにより、ポリシングの輻輳応答が複雑になる
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section is informative, not normative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションは参考情報であり、規範的ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two main classes of approach to policing congestion response: (i) policing at each bottleneck link or (ii) policing at the edges of networks. Packet-mode drop in RED is compatible with either, while byte-mode drop precludes edge policing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳応答のポリシングには、2つの主要なクラスのアプローチがあります。（i）各ボトルネックリンクでのポリシング、または（ii）ネットワークのエッジでのポリシング。 REDのパケットモードドロップはどちらとも互換性がありますが、バイトモードドロップはエッジポリシングを排除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The simplicity of an edge policer relies on one dropped or marked packet being equivalent to another of the same size without having to know which link the drop or mark occurred at. However, the byte-mode drop algorithm has to depend on the local MTU of the line -- it needs to use some concept of a &#39;normal&#39; packet size. Therefore, one dropped or marked packet from a byte-mode drop algorithm is not necessarily equivalent to another from a different link. A policing function local to the link can know the local MTU where the congestion occurred. However, a policer at the edge of the network cannot, at least not without a lot of complexity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
エッジポリサーの単純さは、ドロップまたはマークが発生したリンクを知らなくても、1つのドロップまたはマークされたパケットが同じサイズの別のパケットと同等であることに依存しています。ただし、バイトモードドロップアルゴリズムは、回線のローカルMTUに依存する必要があります。「通常の」パケットサイズの概念を使用する必要があります。したがって、バイトモードドロップアルゴリズムからドロップまたはマークされたパケットは、必ずしも別のリンクからのパケットと同等であるとは限りません。リンクに対してローカルなポリシング機能は、輻輳が発生したローカルMTUを知ることができます。ただし、ネットワークのエッジにあるポリサーは、少なくとも多くの複雑さがなければ不可能ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The early research proposals for type (i) policing at a bottleneck link [pBox] used byte-mode drop, then detected flows that contributed disproportionately to the number of packets dropped. However, with no extra complexity, later proposals used packet-mode drop and looked for flows that contributed a disproportionate amount of dropped bytes [CHOKe_Var_Pkt].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプ（i）のボトルネックリンク[pBox]でのポリシングに関する初期の研究提案では、バイトモードドロップを使用し、ドロップされたパケット数に不釣り合いに寄与するフローを検出しました。ただし、余分な複雑さはありませんでしたが、後の提案ではパケットモードドロップを使用し、不均衡な量のドロップバイトに寄与するフローを探しました[CHOKe_Var_Pkt]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Work is progressing on the Congestion Exposure (ConEx) protocol [RFC6789], which enables a type (ii) edge policer located at a user&#39;s attachment point. The idea is to be able to take an integrated view of the effect of all a user&#39;s traffic on any link in the internetwork. However, byte-mode drop would effectively preclude such edge policing because of the MTU issue above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Congestion Exposure（ConEx）プロトコル[RFC6789]で作業が進行中です。これにより、ユーザーの接続ポイントにあるタイプ（ii）のエッジポリサーが有効になります。アイデアは、インターネットワーク内の任意のリンクに対するすべてのユーザーのトラフィックの影響を統合的に表示できるようにすることです。ただし、バイトモードのドロップは、上記のMTUの問題のため、このようなエッジポリシングを事実上排除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Indeed, making drop probability depend on the size of the packets that bits happen to be divided into would simply encourage the bits to be divided into smaller packets in order to confuse policing. In contrast, as long as a dropped/marked packet is taken to mean that all the bytes in the packet are dropped/marked, a policer can remain robust against sequences of bits being re-divided into different size packets or across different size flows [Rate_fair_Dis].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実際、ドロップ確率をビットが分割されるパケットのサイズに依存させることは、ポリシングを混乱させるためにビットをより小さなパケットに分割することを単に促進するだけです。対照的に、ドロップ/マークされたパケットがパケット内のすべてのバイトがドロップ/マークされていることを意味している限り、ポリサーはビットのシーケンスが異なるサイズのパケットまたは異なるサイズのフローに再分割されることに対して堅牢であり続けることができます[ Rate_fair_Dis]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bob Briscoe BT B54/77, Adastral Park Martlesham Heath Ipswich IP5 3RE UK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bob Briscoe BT B54 / 77、Adastral Park Martlesham Heath Ipswich IP5 3RE UK
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +44 1473 645196
   EMail: bob.briscoe@bt.com
   URI:   http://bobbriscoe.net/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jukka Manner Aalto University Department of Communications and Networking (Comnet) P.O. Box 13000 FIN-00076 Aalto Finland
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jukka Manner Aalto大学コミュニケーションおよびネットワーキング学科（Comnet）P.O.ボックス13000 FIN-00076アアルトフィンランド
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +358 9 470 22481
   EMail: jukka.manner@aalto.fi
   URI:   http://www.netlab.tkk.fi/~jmanner/
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
