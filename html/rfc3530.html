<!DOCTYPE html>


<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 3530 - Network File System (NFS) version 4 Protocol 日本語訳</title>

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">3530</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc3530">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 3530 - Network File System (NFS) version 4 Protocol 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc3530">
            https://datatracker.ietf.org/doc/html/rfc3530
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 3530 - ネットワークファイルシステム（NFS）バージョン4プロトコル</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <h6 class="card-title">要約（自動生成）</h6>
            <p class="card-text">RFC 3530は、NFSバージョン4プロトコルに関する標準仕様です。NFSは、ネットワーク上でファイル共有を行うためのプロトコルであり、バージョン4はその最新バージョンです。このRFCの目的は、NFSv4プロトコルの仕様と機能を定義し、ネットワーク上でのファイル共有を効率的かつセキュアに行うことです。</p>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                         S. Shepler
Request for Comments: 3530                                  B. Callaghan
Obsoletes: 3010                                              D. Robinson
Category: Standards Track                                     R. Thurlow
                                                  Sun Microsystems, Inc.
                                                                C. Beame
                                                        Hummingbird Ltd.
                                                               M. Eisler
                                                               D. Noveck
                                                 Network Appliance, Inc.
                                                              April 2003
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
Network File System (NFS) version 4 Protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
ネットワークファイルシステム（NFS）バージョン4プロトコル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2003). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（C）The Internet Society（2003）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Network File System (NFS) version 4 is a distributed filesystem protocol which owes heritage to NFS protocol version 2, RFC 1094, and version 3, RFC 1813. Unlike earlier versions, the NFS version 4 protocol supports traditional file access while integrating support for file locking and the mount protocol. In addition, support for strong security (and its negotiation), compound operations, client caching, and internationalization have been added. Of course, attention has been applied to making NFS version 4 operate well in an Internet environment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークファイルシステム（NFS）バージョン4は、NFSプロトコルバージョン2、RFC 1094、およびバージョン3、RFC 1813の遺産を受け継ぐ分散ファイルシステムプロトコルです。以前のバージョンとは異なり、NFSバージョン4プロトコルは、ファイルのロックとマウントプロトコル。さらに、強力なセキュリティ（およびそのネゴシエーション）、複合操作、クライアントキャッシング、および国際化のサポートが追加されました。もちろん、NFSバージョン4がインターネット環境で適切に動作するように注意が払われています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document replaces RFC 3010 as the definition of the NFS version 4 protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、NFSバージョン4プロトコルの定義としてRFC 3010を置き換えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Key Words
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
キーワード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 [RFC2119]で説明されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.   Introduction . . . . . . . . . . . . . . . . . . . . . . .    8
        1.1.  Changes since RFC 3010 . . . . . . . . . . . . . . .    8
        1.2.  NFS version 4 Goals. . . . . . . . . . . . . . . . .    9
        1.3.  Inconsistencies of this Document with Section 18 . .    9
        1.4.  Overview of NFS version 4 Features . . . . . . . . .   10
              1.4.1.  RPC and Security . . . . . . . . . . . . . .   10
              1.4.2.  Procedure and Operation Structure. . . . . .   10
              1.4.3.  Filesystem Mode. . . . . . . . . . . . . . .   11
                      1.4.3.1.  Filehandle Types . . . . . . . . .   11
                      1.4.3.2.  Attribute Types. . . . . . . . . .   12
                      1.4.3.3.  Filesystem Replication and
                                Migration. . . . . . . . . . . . .   13
              1.4.4.  OPEN and CLOSE . . . . . . . . . . . . . . .   13
              1.4.5.  File locking . . . . . . . . . . . . . . . .   13
              1.4.6.  Client Caching and Delegation. . . . . . . .   13
        1.5.  General Definitions. . . . . . . . . . . . . . . . .   14
   2.   Protocol Data Types. . . . . . . . . . . . . . . . . . . .   16
        2.1.  Basic Data Types . . . . . . . . . . . . . . . . . .   16
        2.2.  Structured Data Types. . . . . . . . . . . . . . . .   18
   3.   RPC and Security Flavor. . . . . . . . . . . . . . . . . .   23
        3.1.  Ports and Transports . . . . . . . . . . . . . . . .   23
              3.1.1.  Client Retransmission Behavior . . . . . . .   24
        3.2.  Security Flavors . . . . . . . . . . . . . . . . . .   25
              3.2.1.  Security mechanisms for NFS version 4. . . .   25
                      3.2.1.1.  Kerberos V5 as a security triple .   25
                      3.2.1.2.  LIPKEY as a security triple. . . .   26
                      3.2.1.3.  SPKM-3 as a security triple. . . .   27
        3.3.  Security Negotiation . . . . . . . . . . . . . . . .   27
              3.3.1.  SECINFO. . . . . . . . . . . . . . . . . . .   28
              3.3.2.  Security Error . . . . . . . . . . . . . . .   28
        3.4.  Callback RPC Authentication. . . . . . . . . . . . .   28
   4.  Filehandles . . . . . . . . . . . . . . . . . . . . . . . .   30
        4.1.  Obtaining the First Filehandle . . . . . . . . . . .   30
              4.1.1.  Root Filehandle. . . . . . . . . . . . . . .   31
              4.1.2.  Public Filehandle. . . . . . . . . . . . . .   31
        4.2.  Filehandle Types . . . . . . . . . . . . . . . . . .   31
              4.2.1.  General Properties of a Filehandle . . . . .   32
              4.2.2.  Persistent Filehandle. . . . . . . . . . . .   32
              4.2.3.  Volatile Filehandle. . . . . . . . . . . . .   33
              4.2.4.  One Method of Constructing a
                      Volatile Filehandle. . . . . . . . . . . . .   34
        4.3.  Client Recovery from Filehandle Expiration . . . . .   35
   5.   File Attributes. . . . . . . . . . . . . . . . . . . . . .   35
        5.1.  Mandatory Attributes . . . . . . . . . . . . . . . .   37
        5.2.  Recommended Attributes . . . . . . . . . . . . . . .   37
        5.3.  Named Attributes . . . . . . . . . . . . . . . . . .   37
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
        5.4.  Classification of Attributes . . . . . . . . . . . .   38
        5.5.  Mandatory Attributes - Definitions . . . . . . . . .   39
        5.6.  Recommended Attributes - Definitions . . . . . . . .   41
        5.7.  Time Access. . . . . . . . . . . . . . . . . . . . .   46
        5.8.  Interpreting owner and owner_group . . . . . . . . .   47
        5.9.  Character Case Attributes. . . . . . . . . . . . . .   49
        5.10. Quota Attributes . . . . . . . . . . . . . . . . . .   49
        5.11. Access Control Lists . . . . . . . . . . . . . . . .   50
               5.11.1.  ACE type . . . . . . . . . . . . . . . . .   51
               5.11.2.  ACE Access Mask. . . . . . . . . . . . . .   52
               5.11.3.  ACE flag . . . . . . . . . . . . . . . . .   54
               5.11.4.  ACE who  . . . . . . . . . . . . . . . . .   55
               5.11.5.  Mode Attribute . . . . . . . . . . . . . .   56
               5.11.6.  Mode and ACL Attribute . . . . . . . . . .   57
               5.11.7.  mounted_on_fileid. . . . . . . . . . . . .   57
   6.  Filesystem Migration and Replication  . . . . . . . . . . .   58
        6.1.  Replication. . . . . . . . . . . . . . . . . . . . .   58
        6.2.  Migration. . . . . . . . . . . . . . . . . . . . . .   59
        6.3.  Interpretation of the fs_locations Attribute . . . .   60
        6.4.  Filehandle Recovery for Migration or Replication . .   61
   7.  NFS Server Name Space . . . . . . . . . . . . . . . . . . .   61
        7.1.  Server Exports . . . . . . . . . . . . . . . . . . .   61
        7.2.  Browsing Exports . . . . . . . . . . . . . . . . . .   62
        7.3.  Server Pseudo Filesystem . . . . . . . . . . . . . .   62
        7.4.  Multiple Roots . . . . . . . . . . . . . . . . . . .   63
        7.5.  Filehandle Volatility. . . . . . . . . . . . . . . .   63
        7.6.  Exported Root. . . . . . . . . . . . . . . . . . . .   63
        7.7.  Mount Point Crossing . . . . . . . . . . . . . . . .   63
        7.8.  Security Policy and Name Space Presentation. . . . .   64
   8.   File Locking and Share Reservations. . . . . . . . . . . .   65
        8.1.  Locking. . . . . . . . . . . . . . . . . . . . . . .   65
              8.1.1.    Client ID. . . . . . . . . . . . . . . . .   66
              8.1.2.    Server Release of Clientid . . . . . . . .   69
              8.1.3.    lock_owner and stateid Definition. . . . .   69
              8.1.4.    Use of the stateid and Locking . . . . . .   71
              8.1.5.    Sequencing of Lock Requests. . . . . . . .   73
              8.1.6.    Recovery from Replayed Requests. . . . . .   74
              8.1.7.    Releasing lock_owner State . . . . . . . .   74
              8.1.8.    Use of Open Confirmation . . . . . . . . .   75
        8.2.  Lock Ranges. . . . . . . . . . . . . . . . . . . . .   76
        8.3.  Upgrading and Downgrading Locks. . . . . . . . . . .   76
        8.4.  Blocking Locks . . . . . . . . . . . . . . . . . . .   77
        8.5.  Lease Renewal. . . . . . . . . . . . . . . . . . . .   77
        8.6.  Crash Recovery . . . . . . . . . . . . . . . . . . .   78
               8.6.1.   Client Failure and Recovery. . . . . . . .   79
               8.6.2.   Server Failure and Recovery. . . . . . . .   79
               8.6.3.   Network Partitions and Recovery. . . . . .   81
        8.7.   Recovery from a Lock Request Timeout or Abort . . .   85
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
        8.8.   Server Revocation of Locks. . . . . . . . . . . . .   85
        8.9.   Share Reservations. . . . . . . . . . . . . . . . .   86
        8.10.  OPEN/CLOSE Operations . . . . . . . . . . . . . . .   87
               8.10.1.  Close and Retention of State
                        Information. . . . . . . . . . . . . . . .   88
        8.11.  Open Upgrade and Downgrade. . . . . . . . . . . . .   88
        8.12.  Short and Long Leases . . . . . . . . . . . . . . .   89
        8.13.  Clocks, Propagation Delay, and Calculating Lease
               Expiration. . . . . . . . . . . . . . . . . . . . .   89
        8.14.  Migration, Replication and State. . . . . . . . . .   90
               8.14.1.  Migration and State. . . . . . . . . . . .   90
               8.14.2.  Replication and State. . . . . . . . . . .   91
               8.14.3.  Notification of Migrated Lease . . . . . .   92
               8.14.4.  Migration and the Lease_time Attribute . .   92
   9.  Client-Side Caching . . . . . . . . . . . . . . . . . . . .   93
        9.1.   Performance Challenges for Client-Side Caching. . .   93
        9.2.   Delegation and Callbacks. . . . . . . . . . . . . .   94
               9.2.1.  Delegation Recovery . . . . . . . . . . . .   96
        9.3.   Data Caching. . . . . . . . . . . . . . . . . . . .   98
               9.3.1.   Data Caching and OPENs . . . . . . . . . .   98
               9.3.2.   Data Caching and File Locking. . . . . . .   99
               9.3.3.   Data Caching and Mandatory File Locking. .  101
               9.3.4.   Data Caching and File Identity . . . . . .  101
        9.4.   Open Delegation . . . . . . . . . . . . . . . . . .  102
               9.4.1.   Open Delegation and Data Caching . . . . .  104
               9.4.2.   Open Delegation and File Locks . . . . . .  106
               9.4.3.   Handling of CB_GETATTR . . . . . . . . . .  106
               9.4.4.   Recall of Open Delegation. . . . . . . . .  109
               9.4.5.   Clients that Fail to Honor
                        Delegation Recalls . . . . . . . . . . . .  111
               9.4.6.   Delegation Revocation. . . . . . . . . . .  112
        9.5.   Data Caching and Revocation . . . . . . . . . . . .  112
               9.5.1.   Revocation Recovery for Write Open
                        Delegation . . . . . . . . . . . . . . . .  113
        9.6.   Attribute Caching . . . . . . . . . . . . . . . . .  113
        9.7.   Data and Metadata Caching and Memory Mapped Files .  115
        9.8.   Name Caching  . . . . . . . . . . . . . . . . . . .  118
        9.9.   Directory Caching . . . . . . . . . . . . . . . . .  119
   10.  Minor Versioning . . . . . . . . . . . . . . . . . . . . .  120
   11.  Internationalization . . . . . . . . . . . . . . . . . . .  122
        11.1.  Stringprep profile for the utf8str_cs type. . . . .  123
               11.1.1.  Intended applicability of the
                        nfs4_cs_prep profile . . . . . . . . . . .  123
               11.1.2.  Character repertoire of nfs4_cs_prep . . .  124
               11.1.3.  Mapping used by nfs4_cs_prep . . . . . . .  124
               11.1.4.  Normalization used by nfs4_cs_prep . . . .  124
               11.1.5.  Prohibited output for nfs4_cs_prep . . . .  125
               11.1.6.  Bidirectional output for nfs4_cs_prep. . .  125
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
        11.2.  Stringprep profile for the utf8str_cis type . . . .  125
               11.2.1.  Intended applicability of the
                        nfs4_cis_prep profile. . . . . . . . . . .  125
               11.2.2.  Character repertoire of nfs4_cis_prep  . .  125
               11.2.3.  Mapping used by nfs4_cis_prep  . . . . . .  125
               11.2.4.  Normalization used by nfs4_cis_prep  . . .  125
               11.2.5.  Prohibited output for nfs4_cis_prep  . . .  126
               11.2.6.  Bidirectional output for nfs4_cis_prep . .  126
        11.3.  Stringprep profile for the utf8str_mixed type . . .  126
               11.3.1.  Intended applicability of the
                        nfs4_mixed_prep profile. . . . . . . . . .  126
               11.3.2.  Character repertoire of nfs4_mixed_prep  .  126
               11.3.3.  Mapping used by nfs4_cis_prep  . . . . . .  126
               11.3.4.  Normalization used by nfs4_mixed_prep  . .  127
               11.3.5.  Prohibited output for nfs4_mixed_prep  . .  127
               11.3.6.  Bidirectional output for nfs4_mixed_prep .  127
        11.4.  UTF-8 Related Errors. . . . . . . . . . . . . . . .  127
   12.  Error Definitions  . . . . . . . . . . . . . . . . . . . .  128
   13.  NFS version 4 Requests . . . . . . . . . . . . . . . . . .  134
        13.1.  Compound Procedure. . . . . . . . . . . . . . . . .  134
        13.2.  Evaluation of a Compound Request. . . . . . . . . .  135
        13.3.  Synchronous Modifying Operations. . . . . . . . . .  136
        13.4.  Operation Values. . . . . . . . . . . . . . . . . .  136
   14.  NFS version 4 Procedures . . . . . . . . . . . . . . . . .  136
        14.1.  Procedure 0: NULL - No Operation. . . . . . . . . .  136
        14.2.  Procedure 1: COMPOUND - Compound Operations . . . .  137
               14.2.1.   Operation 3: ACCESS - Check Access
                         Rights. . . . . . . . . . . . . . . . . .  140
               14.2.2.   Operation 4: CLOSE - Close File . . . . .  142
               14.2.3.   Operation 5: COMMIT - Commit
                         Cached Data . . . . . . . . . . . . . . .  144
               14.2.4.   Operation 6: CREATE - Create a
                         Non-Regular File Object . . . . . . . . .  147
               14.2.5.   Operation 7: DELEGPURGE -
                         Purge Delegations Awaiting Recovery . . .  150
               14.2.6.   Operation 8: DELEGRETURN - Return
                         Delegation. . . . . . . . . . . . . . . .  151
               14.2.7.   Operation 9: GETATTR - Get Attributes . .  152
               14.2.8.   Operation 10: GETFH - Get Current
                         Filehandle. . . . . . . . . . . . . . . .  153
               14.2.9.   Operation 11: LINK - Create Link to a
                         File. . . . . . . . . . . . . . . . . . .  154
               14.2.10.  Operation 12: LOCK - Create Lock  . . . .  156
               14.2.11.  Operation 13: LOCKT - Test For Lock . . .  160
               14.2.12.  Operation 14: LOCKU - Unlock File . . . .  162
               14.2.13.  Operation 15: LOOKUP - Lookup Filename. .  163
               14.2.14.  Operation 16: LOOKUPP - Lookup
                         Parent Directory. . . . . . . . . . . . .  165
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
               14.2.15.  Operation 17: NVERIFY - Verify
                         Difference in Attributes  . . . . . . . .  166
               14.2.16.  Operation 18: OPEN - Open a Regular
                         File. . . . . . . . . . . . . . . . . . .  168
               14.2.17.  Operation 19: OPENATTR - Open Named
                         Attribute Directory . . . . . . . . . . .  178
               14.2.18.  Operation 20: OPEN_CONFIRM -
                         Confirm Open . . . . . . . . . . . . . .   180
               14.2.19.  Operation 21: OPEN_DOWNGRADE -
                         Reduce Open File Access . . . . . . . . .  182
               14.2.20.  Operation 22: PUTFH - Set
                         Current Filehandle. . . . . . . . . . . .  184
               14.2.21.  Operation 23: PUTPUBFH -
                         Set Public Filehandle . . . . . . . . . .  185
               14.2.22.  Operation 24: PUTROOTFH -
                         Set Root Filehandle . . . . . . . . . . .  186
               14.2.23.  Operation 25: READ - Read from File . . .  187
               14.2.24.  Operation 26: READDIR -
                         Read Directory. . . . . . . . . . . . . .  190
               14.2.25.  Operation 27: READLINK -
                         Read Symbolic Link. . . . . . . . . . . .  193
               14.2.26.  Operation 28: REMOVE -
                         Remove Filesystem Object. . . . . . . . .  195
               14.2.27.  Operation 29: RENAME -
                         Rename Directory Entry. . . . . . . . . .  197
               14.2.28.  Operation 30: RENEW - Renew a Lease . . .  200
               14.2.29.  Operation 31: RESTOREFH -
                         Restore Saved Filehandle. . . . . . . . .  201
               14.2.30.  Operation 32: SAVEFH - Save
                         Current Filehandle. . . . . . . . . . . .  202
               14.2.31.  Operation 33: SECINFO - Obtain
                         Available Security. . . . . . . . . . . .  203
               14.2.32.  Operation 34: SETATTR - Set Attributes. .  206
               14.2.33.  Operation 35: SETCLIENTID -
                         Negotiate Clientid. . . . . . . . . . . .  209
               14.2.34.  Operation 36: SETCLIENTID_CONFIRM -
                         Confirm Clientid. . . . . . . . . . . . .  213
               14.2.35.  Operation 37: VERIFY -
                         Verify Same Attributes. . . . . . . . . .  217
               14.2.36.  Operation 38: WRITE - Write to File . . .  218
               14.2.37.  Operation 39: RELEASE_LOCKOWNER -
                         Release Lockowner State . . . . . . . . .  223
               14.2.38.  Operation 10044: ILLEGAL -
                         Illegal operation . . . . . . . . . . . .  224
   15.  NFS version 4 Callback Procedures  . . . . . . . . . . . .  225
        15.1.  Procedure 0: CB_NULL - No Operation . . . . . . . .  225
        15.2.  Procedure 1: CB_COMPOUND - Compound
               Operations. . . . . . . . . . . . . . . . . . . . .  226
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
               15.2.1.  Operation 3: CB_GETATTR - Get
                        Attributes . . . . . . . . . . . . . . . .  228
               15.2.2.  Operation 4: CB_RECALL -
                        Recall an Open Delegation. . . . . . . . .  229
               15.2.3.  Operation 10044: CB_ILLEGAL -
                        Illegal Callback Operation . . . . . . . .  230
   16.  Security Considerations  . . . . . . . . . . . . . . . . .  231
   17.  IANA Considerations  . . . . . . . . . . . . . . . . . . .  232
        17.1.  Named Attribute Definition. . . . . . . . . . . . .  232
        17.2.  ONC RPC Network Identifiers (netids). . . . . . . .  232
   18.  RPC definition file  . . . . . . . . . . . . . . . . . . .  234
   19.  Acknowledgements . . . . . . . . . . . . . . . . . . . . .  268
   20.  Normative References . . . . . . . . . . . . . . . . . . .  268
   21.  Informative References . . . . . . . . . . . . . . . . . .  270
   22.  Authors&#39; Information . . . . . . . . . . . . . . . . . . .  273
        22.1.  Editor&#39;s Address. . . . . . . . . . . . . . . . . .  273
        22.2.  Authors&#39; Addresses. . . . . . . . . . . . . . . . .  274
   23.  Full Copyright Statement . . . . . . . . . . . . . . . . .  275
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-1--Changes-since-RFC-3010">
1.1. Changes since RFC 3010
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. RFC 3010以降の変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This definition of the NFS version 4 protocol replaces or obsoletes the definition present in [RFC3010]. While portions of the two documents have remained the same, there have been substantive changes in others. The changes made between [RFC3010] and this document represent implementation experience and further review of the protocol. While some modifications were made for ease of implementation or clarification, most updates represent errors or situations where the [RFC3010] definition were untenable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルのこの定義は、[RFC3010]に存在する定義を置き換えるか廃止します。 2つのドキュメントの一部は同じままですが、他のドキュメントには実質的な変更がありました。 [RFC3010]とこのドキュメントの間に行われた変更は、実装の経験とプロトコルのさらなるレビューを表しています。実装や説明を簡単にするためにいくつかの変更が行われましたが、ほとんどの更新は、[RFC3010]の定義が受け入れられないエラーまたは状況を表しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following list is not all inclusive of all changes but presents some of the most notable changes or additions made:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のリストはすべての変更を網羅しているわけではありませんが、行われた最も注目すべき変更または追加の一部を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The state model has added an open_owner4 identifier. This was done to accommodate Posix based clients and the model they use for file locking. For Posix clients, an open_owner4 would correspond to a file descriptor potentially shared amongst a set of processes and the lock_owner4 identifier would correspond to a process that is locking a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 状態モデルにopen_owner4識別子が追加されました。これは、Posixベースのクライアントと、ファイルロックに使用するモデルに対応するために行われました。 Posixクライアントの場合、open_owner4は一連のプロセス間で共有される可能性のあるファイル記述子に対応し、lock_owner4識別子はファイルをロックしているプロセスに対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Clarifications and error conditions were added for the handling of the owner and group attributes. Since these attributes are string based (as opposed to the numeric uid/gid of previous versions of NFS), translations may not be available and hence the changes made.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 所有者とグループの属性の処理に関する説明とエラー条件が追加されました。これらの属性は文字列ベースであるため（NFSの以前のバージョンの数値のuid / gidとは対照的に）、変換が利用できず、変更が行われる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Clarifications for the ACL and mode attributes to address evaluation and partial support.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 評価と部分的なサポートに対処するためのACLおよびモード属性の明確化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For identifiers that are defined as XDR opaque, limits were set on their size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o XDR不透明として定義されている識別子の場合、サイズに制限が設定されていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Added the mounted_on_filed attribute to allow Posix clients to correctly construct local mounts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mounts_on_filed属性が追加され、Posixクライアントがローカルマウントを正しく構築できるようになりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Modified the SETCLIENTID/SETCLIENTID_CONFIRM operations to deal correctly with confirmation details along with adding the ability to specify new client callback information. Also added clarification of the callback information itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SETCLIENTID / SETCLIENTID_CONFIRM操作を変更し、確認の詳細を正しく処理するとともに、新しいクライアントコールバック情報を指定する機能を追加しました。コールバック情報自体の説明も追加されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Added a new operation LOCKOWNER_RELEASE to enable notifying the server that a lock_owner4 will no longer be used by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 新しい操作LOCKOWNER_RELEASEが追加され、lock_owner4がクライアントによって使用されなくなることをサーバーに通知できるようになりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RENEW operation changes to identify the client correctly and allow for additional error returns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RENEWオペレーションが変更され、クライアントが正しく識別され、追加のエラーが返されるようになりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Verify error return possibilities for all operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o すべての操作でエラーが返される可能性を確認してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Remove use of the pathname4 data type from LOOKUP and OPEN in favor of having the client construct a sequence of LOOKUP operations to achieive the same effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントが一連のLOOKUP操作を作成して同じ効果を得るために、LOOKUPおよびOPENからpathname4データ型の使用を削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Clarification of the internationalization issues and adoption of the new stringprep profile framework.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 国際化の問題の明確化と新しいstringprepプロファイルフレームワークの採用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-2--NFS-Version-4-Goals">
1.2. NFS Version 4 Goals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. NFSバージョン4の目標
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 protocol is a further revision of the NFS protocol defined already by versions 2 [RFC1094] and 3 [RFC1813]. It retains the essential characteristics of previous versions: design for easy recovery, independent of transport protocols, operating systems and filesystems, simplicity, and good performance. The NFS version 4 revision has the following goals:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルは、バージョン2 [RFC1094]および3 [RFC1813]ですでに定義されているNFSプロトコルのさらなる改訂版です。トランスポートプロトコル、オペレーティングシステム、ファイルシステムに依存しない簡単なリカバリの設計、シンプルさ、優れたパフォーマンスなど、以前のバージョンの重要な特性を保持しています。 NFSバージョン4リビジョンには次の目標があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Improved access and good performance on the Internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o インターネット上でのアクセスとパフォーマンスの向上。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The protocol is designed to transit firewalls easily, perform well where latency is high and bandwidth is low, and scale to very large numbers of clients per server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このプロトコルは、ファイアウォールを簡単に通過できるように設計されており、レイテンシが高く帯域幅が低い場合に良好に機能し、サーバーごとに非常に多くのクライアントに対応できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Strong security with negotiation built into the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o プロトコルにネゴシエーションが組み込まれた強力なセキュリティ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The protocol builds on the work of the ONCRPC working group in supporting the RPCSEC_GSS protocol. Additionally, the NFS version 4 protocol provides a mechanism to allow clients and servers the ability to negotiate security and require clients and servers to support a minimal set of security schemes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このプロトコルは、RPCSEC_GSSプロトコルをサポートするONCRPCワーキンググループの作業に基づいています。さらに、NFSバージョン4プロトコルは、クライアントとサーバーがセキュリティをネゴシエートできるようにするメカニズムを提供し、クライアントとサーバーが最小限のセキュリティスキームのセットをサポートすることを要求します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Good cross-platform interoperability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 優れたクロスプラットフォームの相互運用性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The protocol features a filesystem model that provides a useful, common set of features that does not unduly favor one filesystem or operating system over another.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このプロトコルは、ファイルシステムモデルを備えており、ファイルシステムやオペレーティングシステムを別のファイルシステムよりも不当に支持しない、便利で一般的な一連の機能を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Designed for protocol extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o プロトコル拡張用に設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The protocol is designed to accept standard extensions that do not compromise backward compatibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このプロトコルは、下位互換性を損なわない標準の拡張機能を受け入れるように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-3--Inconsistencies-of-this-Document-with-Section-18">
1.3. Inconsistencies of this Document with Section 18
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. このドキュメントとセクション18の不一致
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 18, RPC Definition File, contains the definitions in XDR description language of the constructs used by the protocol. Prior to Section 18, several of the constructs are reproduced for purposes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション18、RPC定義ファイルには、プロトコルで使用される構成体のXDR記述言語での定義が含まれています。セクション18より前は、目的に合わせていくつかの構成が複製されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
of explanation. The reader is warned of the possibility of errors in the reproduced constructs outside of Section 18. For any part of the document that is inconsistent with Section 18, Section 18 is to be considered authoritative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明の。読者は、セクション18の外で複製された構成にエラーの可能性があることを警告されます。セクション18と矛盾するドキュメントの部分については、セクション18が信頼できると見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-4--Overview-of-NFS-version-4-Features">
1.4. Overview of NFS version 4 Features
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. NFSバージョン4機能の概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To provide a reasonable context for the reader, the major features of NFS version 4 protocol will be reviewed in brief. This will be done to provide an appropriate context for both the reader who is familiar with the previous versions of the NFS protocol and the reader that is new to the NFS protocols. For the reader new to the NFS protocols, there is still a fundamental knowledge that is expected. The reader should be familiar with the XDR and RPC protocols as described in [RFC1831] and [RFC1832]. A basic knowledge of filesystems and distributed filesystems is expected as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
読者に妥当なコンテキストを提供するために、NFSバージョン4プロトコルの主な機能を簡単に復習します。これは、NFSプロトコルの以前のバージョンに精通しているリーダーと、NFSプロトコルに新しいリーダーの両方に適切なコンテキストを提供するために行われます。 NFSプロトコルを初めて使用する読者にとって、期待される基本的な知識はまだあります。 [RFC1831]および[RFC1832]で説明されているように、読者はXDRおよびRPCプロトコルに精通している必要があります。ファイルシステムと分散ファイルシステムの基本的な知識も必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-4-1--RPC-and-Security">
1.4.1. RPC and Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.1. RPCとセキュリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with previous versions of NFS, the External Data Representation (XDR) and Remote Procedure Call (RPC) mechanisms used for the NFS version 4 protocol are those defined in [RFC1831] and [RFC1832]. To meet end to end security requirements, the RPCSEC_GSS framework [RFC2203] will be used to extend the basic RPC security. With the use of RPCSEC_GSS, various mechanisms can be provided to offer authentication, integrity, and privacy to the NFS version 4 protocol. Kerberos V5 will be used as described in [RFC1964] to provide one security framework. The LIPKEY GSS-API mechanism described in [RFC2847] will be used to provide for the use of user password and server public key by the NFS version 4 protocol. With the use of RPCSEC_GSS, other mechanisms may also be specified and used for NFS version 4 security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前のバージョンのNFSと同様に、NFSバージョン4プロトコルに使用される外部データ表現（XDR）およびリモートプロシージャコール（RPC）メカニズムは、[RFC1831]および[RFC1832]で定義されているメカニズムです。エンドツーエンドのセキュリティ要件を満たすために、RPCSEC_GSSフレームワーク[RFC2203]を使用して、基本的なRPCセキュリティを拡張します。 RPCSEC_GSSを使用すると、NFSバージョン4プロトコルに認証、整合性、およびプライバシーを提供するさまざまなメカニズムを提供できます。 [RFC1964]で説明されているようにKerberos V5を使用して、1つのセキュリティフレームワークを提供します。 [RFC2847]で説明されているLIPKEY GSS-APIメカニズムは、NFSバージョン4プロトコルによるユーザーパスワードとサーバー公開鍵の使用を提供するために使用されます。 RPCSEC_GSSを使用すると、NFSバージョン4のセキュリティに他のメカニズムを指定して使用することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To enable in-band security negotiation, the NFS version 4 protocol has added a new operation which provides the client a method of querying the server about its policies regarding which security mechanisms must be used for access to the server&#39;s filesystem resources. With this, the client can securely match the security mechanism that meets the policies specified at both the client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インバンドセキュリティネゴシエーションを有効にするために、NFSバージョン4プロトコルには、サーバーのファイルシステムリソースへのアクセスに使用する必要のあるセキュリティメカニズムに関するポリシーについてサーバーに問い合わせる方法をクライアントに提供する新しい操作が追加されています。これにより、クライアントは、クライアントとサーバーの両方で指定されたポリシーを満たすセキュリティメカニズムに安全に一致させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-4-2--Procedure-and-Operation-Structure">
1.4.2. Procedure and Operation Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.2. 手順と操作構造
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A significant departure from the previous versions of the NFS protocol is the introduction of the COMPOUND procedure. For the NFS version 4 protocol, there are two RPC procedures, NULL and COMPOUND. The COMPOUND procedure is defined in terms of operations and these operations correspond more closely to the traditional NFS procedures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSプロトコルの以前のバージョンからの大きな違いは、COMPOUNDプロシージャの導入です。 NFSバージョン4プロトコルには、NULLとCOMPOUNDの2つのRPCプロシージャがあります。 COMPOUNDプロシージャは操作に関して定義されており、これらの操作は従来のNFSプロシージャにより密接に対応しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the use of the COMPOUND procedure, the client is able to build simple or complex requests. These COMPOUND requests allow for a reduction in the number of RPCs needed for logical filesystem operations. For example, without previous contact with a server a client will be able to read data from a file in one request by combining LOOKUP, OPEN, and READ operations in a single COMPOUND RPC. With previous versions of the NFS protocol, this type of single request was not possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャを使用すると、クライアントは単純または複雑な要求を作成できます。これらのCOMPOUND要求により、論理ファイルシステム操作に必要なRPCの数を減らすことができます。たとえば、サーバーとの事前の接触がなければ、クライアントは、LOOKUP、OPEN、およびREAD操作を1つのCOMPOUND RPCで組み合わせることにより、1つの要求でファイルからデータを読み取ることができます。以前のバージョンのNFSプロトコルでは、このタイプの単一要求は不可能でした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The model used for COMPOUND is very simple. There is no logical OR or ANDing of operations. The operations combined within a COMPOUND request are evaluated in order by the server. Once an operation returns a failing result, the evaluation ends and the results of all evaluated operations are returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDに使用されるモデルは非常に単純です。操作の論理ORまたはAND演算はありません。 COMPOUNDリクエスト内で結合された操作は、サーバーによって順番に評価されます。操作が失敗した結果を返すと、評価は終了し、評価されたすべての操作の結果がクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 protocol continues to have the client refer to a file or directory at the server by a &#34;filehandle&#34;. The COMPOUND procedure has a method of passing a filehandle from one operation to another within the sequence of operations. There is a concept of a &#34;current filehandle&#34; and &#34;saved filehandle&#34;. Most operations use the &#34;current filehandle&#34; as the filesystem object to operate upon. The &#34;saved filehandle&#34; is used as temporary filehandle storage within a COMPOUND procedure as well as an additional operand for certain operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルは、引き続き「ファイルハンドル」によってクライアントにサーバーのファイルまたはディレクトリを参照させます。 COMPOUNDプロシージャには、一連の操作内である操作から別の操作にファイルハンドルを渡す方法があります。 「現在のファイルハンドル」と「保存されたファイルハンドル」の概念があります。ほとんどの操作は、操作対象のファイルシステムオブジェクトとして「現在のファイルハンドル」を使用します。 「保存されたファイルハンドル」は、COMPOUNDプロシージャ内の一時的なファイルハンドルストレージとして、また特定の操作の追加のオペランドとして使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-4-3--Filesystem-Model">
1.4.3. Filesystem Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3. ファイルシステムモデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The general filesystem model used for the NFS version 4 protocol is the same as previous versions. The server filesystem is hierarchical with the regular files contained within being treated as opaque byte streams. In a slight departure, file and directory names are encoded with UTF-8 to deal with the basics of internationalization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルに使用される一般的なファイルシステムモデルは、以前のバージョンと同じです。サーバーファイルシステムは階層構造になっており、通常のファイルは不透明なバイトストリームとして扱われます。わずかな出発点として、ファイル名とディレクトリ名は国際化の基本に対処するためにUTF-8でエンコードされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 protocol does not require a separate protocol to provide for the initial mapping between path name and filehandle. Instead of using the older MOUNT protocol for this mapping, the server provides a ROOT filehandle that represents the logical root or top of the filesystem tree provided by the server. The server provides multiple filesystems by gluing them together with pseudo filesystems. These pseudo filesystems provide for potential gaps in the path names between real filesystems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルは、パス名とファイルハンドル間の初期マッピングを提供するために、別個のプロトコルを必要としません。このマッピングに古いMOUNTプロトコルを使用する代わりに、サーバーは、サーバーによって提供されるファイルシステムツリーの論理ルートまたはトップを表すROOTファイルハンドルを提供します。サーバーは、疑似ファイルシステムと一緒に接着することにより、複数のファイルシステムを提供します。これらの疑似ファイルシステムは、実際のファイルシステム間のパス名に潜在的なギャップを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-4-3-1--Filehandle-Types">
1.4.3.1. Filehandle Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3.1. ファイルハンドルのタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In previous versions of the NFS protocol, the filehandle provided by the server was guaranteed to be valid or persistent for the lifetime of the filesystem object to which it referred. For some server implementations, this persistence requirement has been difficult to meet. For the NFS version 4 protocol, this requirement has been relaxed by introducing another type of filehandle, volatile. With persistent and volatile filehandle types, the server implementation can match the abilities of the filesystem at the server along with the operating environment. The client will have knowledge of the type of filehandle being provided by the server and can be prepared to deal with the semantics of each.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
以前のバージョンのNFSプロトコルでは、サーバーが提供するファイルハンドルは、それが参照するファイルシステムオブジェクトの存続期間中、有効または永続的であることが保証されていました。一部のサーバー実装では、この永続性要件を満たすのが困難でした。 NFSバージョン4プロトコルの場合、この要件は、別のタイプのファイルハンドルであるvolatileを導入することで緩和されています。永続的で揮発性のファイルハンドルタイプを使用すると、サーバーの実装は、サーバーのファイルシステムの機能と動作環境を一致させることができます。クライアントは、サーバーによって提供されるファイルハンドルのタイプの知識を持ち、それぞれのセマンティクスを処理する準備ができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-4-3-2--Attribute-Types">
1.4.3.2. Attribute Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3.2. 属性タイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 protocol introduces three classes of filesystem or file attributes. Like the additional filehandle type, the classification of file attributes has been done to ease server implementations along with extending the overall functionality of the NFS protocol. This attribute model is structured to be extensible such that new attributes can be introduced in minor revisions of the protocol without requiring significant rework.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルは、ファイルシステムまたはファイル属性の3つのクラスを導入します。追加のファイルハンドルタイプと同様に、ファイル属性の分類は、NFSプロトコルの全体的な機能を拡張するとともに、サーバーの実装を容易にするために行われました。この属性モデルは拡張可能なように構成されているため、プロトコルのマイナーリビジョンに新しい属性を導入でき、大幅な再作業は必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The three classifications are: mandatory, recommended and named attributes. This is a significant departure from the previous attribute model used in the NFS protocol. Previously, the attributes for the filesystem and file objects were a fixed set of mainly UNIX attributes. If the server or client did not support a particular attribute, it would have to simulate the attribute the best it could.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3つの分類は、必須、推奨、名前付きの属性です。これは、NFSプロトコルで使用されていた以前の属性モデルとは大きく異なります。以前は、ファイルシステムとファイルオブジェクトの属性は、主にUNIX属性の固定セットでした。サーバーまたはクライアントが特定の属性をサポートしていなかった場合、属性をできる限りシミュレートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mandatory attributes are the minimal set of file or filesystem attributes that must be provided by the server and must be properly represented by the server. Recommended attributes represent different filesystem types and operating environments. The recommended attributes will allow for better interoperability and the inclusion of more operating environments. The mandatory and recommended attribute sets are traditional file or filesystem attributes. The third type of attribute is the named attribute. A named attribute is an opaque byte stream that is associated with a directory or file and referred to by a string name. Named attributes are meant to be used by client applications as a method to associate application specific data with a regular file or directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必須属性は、サーバーによって提供される必要があり、サーバーによって適切に表される必要があるファイルまたはファイルシステム属性の最小セットです。推奨される属性は、さまざまなファイルシステムタイプと動作環境を表します。推奨される属性により、相互運用性が向上し、より多くのオペレーティング環境を含めることができます。必須および推奨の属性セットは、従来のファイルまたはファイルシステムの属性です。 3番目のタイプの属性は、名前付き属性です。名前付き属性は、ディレクトリまたはファイルに関連付けられ、文字列名で参照される不透明なバイトストリームです。名前付き属性は、アプリケーション固有のデータを通常のファイルまたはディレクトリに関連付ける方法としてクライアントアプリケーションによって使用されることを意図しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One significant addition to the recommended set of file attributes is the Access Control List (ACL) attribute. This attribute provides for directory and file access control beyond the model used in previous versions of the NFS protocol. The ACL definition allows for specification of user and group level access control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
推奨されるファイル属性のセットに対する重要な追加機能の1つは、アクセス制御リスト（ACL）属性です。この属性は、NFSプロトコルの以前のバージョンで使用されていたモデルを超えて、ディレクトリとファイルのアクセス制御を提供します。 ACL定義では、ユーザーおよびグループレベルのアクセス制御を指定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-4-3-3--Filesystem-Replication-and-Migration">
1.4.3.3. Filesystem Replication and Migration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3.3. ファイルシステムの複製と移行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the use of a special file attribute, the ability to migrate or replicate server filesystems is enabled within the protocol. The filesystem locations attribute provides a method for the client to probe the server about the location of a filesystem. In the event of a migration of a filesystem, the client will receive an error when operating on the filesystem and it can then query as to the new file system location. Similar steps are used for replication, the client is able to query the server for the multiple available locations of a particular filesystem. From this information, the client can use its own policies to access the appropriate filesystem location.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特別なファイル属性を使用すると、サーバーのファイルシステムを移行または複製する機能がプロトコル内で有効になります。ファイルシステムの場所属性は、クライアントがファイルシステムの場所についてサーバーを調査する方法を提供します。ファイルシステムの移行が発生した場合、クライアントはファイルシステムでの操作時にエラーを受け取り、新しいファイルシステムの場所を照会できます。レプリケーションにも同様の手順が使用され、クライアントはサーバーに特定のファイルシステムの複数の利用可能な場所を問い合わせることができます。この情報から、クライアントは独自のポリシーを使用して適切なファイルシステムの場所にアクセスできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-4-4--OPEN-and-CLOSE">
1.4.4. OPEN and CLOSE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.4. 開くと閉じる
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 protocol introduces OPEN and CLOSE operations. The OPEN operation provides a single point where file lookup, creation, and share semantics can be combined. The CLOSE operation also provides for the release of state accumulated by OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルでは、OPENおよびCLOSE操作が導入されています。 OPEN操作は、ファイルの検索、作成、および共有のセマンティクスを組み合わせることができる単一のポイントを提供します。 CLOSE操作は、OPENによって蓄積された状態の解放も提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-4-5--File-locking">
1.4.5. File locking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.5. ファイルのロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the NFS version 4 protocol, the support for byte range file locking is part of the NFS protocol. The file locking support is structured so that an RPC callback mechanism is not required. This is a departure from the previous versions of the NFS file locking protocol, Network Lock Manager (NLM). The state associated with file locks is maintained at the server under a lease-based model. The server defines a single lease period for all state held by a NFS client. If the client does not renew its lease within the defined period, all state associated with the client&#39;s lease may be released by the server. The client may renew its lease with use of the RENEW operation or implicitly by use of other operations (primarily READ).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルでは、バイト範囲ファイルロックのサポートはNFSプロトコルの一部です。ファイルロックのサポートは、RPCコールバックメカニズムが不要になるように構造化されています。これは、NFSファイルロックプロトコルの以前のバージョンであるNetwork Lock Manager（NLM）からの逸脱です。ファイルロックに関連付けられた状態は、リースベースのモデルの下でサーバーで維持されます。サーバーは、NFSクライアントが保持するすべての状態に対して単一のリース期間を定義します。クライアントが定義された期間内にリースを更新しない場合、クライアントのリースに関連付けられたすべての状態がサーバーによって解放される可能性があります。クライアントは、RENEW操作を使用して、または他の操作（主にREAD）を使用して暗黙的にリースを更新できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-4-6--Client-Caching-and-Delegation">
1.4.6. Client Caching and Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.6. クライアントのキャッシュと委任
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The file, attribute, and directory caching for the NFS version 4 protocol is similar to previous versions. Attributes and directory information are cached for a duration determined by the client. At the end of a predefined timeout, the client will query the server to see if the related filesystem object has been updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルのファイル、属性、およびディレクトリキャッシングは、以前のバージョンと同様です。属性とディレクトリ情報は、クライアントによって決定された期間キャッシュされます。事前定義されたタイムアウトの最後に、クライアントはサーバーに問い合わせて、関連するファイルシステムオブジェクトが更新されているかどうかを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For file data, the client checks its cache validity when the file is opened. A query is sent to the server to determine if the file has been changed. Based on this information, the client determines if the data cache for the file should kept or released. Also, when the file is closed, any modified data is written to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルデータの場合、クライアントはファイルが開かれるときにキャッシュの有効性をチェックします。クエリがサーバーに送信され、ファイルが変更されたかどうかが判断されます。この情報に基づいて、クライアントはファイルのデータキャッシュを保持するか解放するかを決定します。また、ファイルを閉じると、変更されたデータがサーバーに書き込まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an application wants to serialize access to file data, file locking of the file data ranges in question should be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションがファイルデータへのアクセスをシリアル化する場合は、問題のファイルデータ範囲のファイルロックを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The major addition to NFS version 4 in the area of caching is the ability of the server to delegate certain responsibilities to the client. When the server grants a delegation for a file to a client, the client is guaranteed certain semantics with respect to the sharing of that file with other clients. At OPEN, the server may provide the client either a read or write delegation for the file. If the client is granted a read delegation, it is assured that no other client has the ability to write to the file for the duration of the delegation. If the client is granted a write delegation, the client is assured that no other client has read or write access to the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キャッシュの分野でNFSバージョン4に追加された主な点は、サーバーが特定の責任をクライアントに委任できることです。サーバーがクライアントにファイルの委任を許可すると、クライアントは他のクライアントとのそのファイルの共有に関して特定のセマンティクスが保証されます。 OPENでは、サーバーはクライアントにファイルの読み取りまたは書き込みの委任を提供できます。クライアントに読み取り委任が許可されている場合、他のクライアントが委任の期間中ファイルに書き込むことができないことが保証されます。クライアントに書き込み委任が付与されている場合、クライアントは、他のクライアントがファイルへの読み取りまたは書き込みアクセス権を持たないことが保証されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Delegations can be recalled by the server. If another client requests access to the file in such a way that the access conflicts with the granted delegation, the server is able to notify the initial client and recall the delegation. This requires that a callback path exist between the server and client. If this callback path does not exist, then delegations can not be granted. The essence of a delegation is that it allows the client to locally service operations such as OPEN, CLOSE, LOCK, LOCKU, READ, WRITE without immediate interaction with the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任はサーバーによって取り消すことができます。別のクライアントがアクセスを許可された委任と競合するような方法でファイルへのアクセスを要求した場合、サーバーは最初のクライアントに通知して委任を取り消すことができます。これには、サーバーとクライアントの間にコールバックパスが存在する必要があります。このコールバックパスが存在しない場合、委任は許可されません。委任の本質は、クライアントがサーバーと直接対話することなく、OPEN、CLOSE、LOCK、LOCKU、READ、WRITEなどの操作をローカルでサービスできるようにすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-5--General-Definitions">
1.5. General Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.5. 一般的な定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following definitions are provided for the purpose of providing an appropriate context for the reader.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の定義は、読者に適切なコンテキストを提供する目的で提供されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client The &#34;client&#34; is the entity that accesses the NFS server&#39;s resources. The client may be an application which contains the logic to access the NFS server directly. The client may also be the traditional operating system client remote filesystem services for a set of applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント「クライアント」は、NFSサーバーのリソースにアクセスするエンティティです。クライアントは、NFSサーバーに直接アクセスするためのロジックを含むアプリケーションである場合があります。クライアントは、一連のアプリケーション用の従来のオペレーティングシステムクライアントのリモートファイルシステムサービスであることもあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
In the case of file locking the client is the entity that maintains a set of locks on behalf of one or more applications. This client is responsible for crash or failure recovery for those locks it manages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
ファイルロックの場合、クライアントは1つ以上のアプリケーションのために一連のロックを維持するエンティティです。このクライアントは、管理するロックのクラッシュまたは障害回復を担当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Note that multiple clients may share the same transport and multiple clients may exist on the same network node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
複数のクライアントが同じトランスポートを共有し、複数のクライアントが同じネットワークノードに存在する場合があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clientid A 64-bit quantity used as a unique, short-hand reference to a client supplied Verifier and ID. The server is responsible for supplying the Clientid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clientidクライアントが提供するVerifierとIDへの一意の簡略参照として使用される64ビットの数量。サーバーは、Clientidの提供を担当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lease An interval of time defined by the server for which the client is irrevocably granted a lock. At the end of a lease period the lock may be revoked if the lease has not been extended. The lock must be revoked if a conflicting lock has been granted after the lease interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リースクライアントがロックを取り返しのつかない形で許可されるサーバーによって定義された時間間隔。リース期間が終了すると、リースが延長されていない場合、ロックが取り消されることがあります。リース期間後に競合するロックが付与されている場合は、ロックを取り消す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
All leases granted by a server have the same fixed interval. Note that the fixed interval was chosen to alleviate the expense a server would have in maintaining state about variable length leases across server failures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
サーバーによって付与されたすべてのリースには、同じ固定間隔があります。固定間隔は、サーバーの障害が発生しても可変長のリースに関する状態をサーバーが維持するのにかかる費用を軽減するために選択されたことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lock The term &#34;lock&#34; is used to refer to both record (byte-range) locks as well as share reservations unless specifically stated otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック「ロック」という用語は、特に明記されていない限り、レコード（バイト範囲）ロックと共有予約の両方を指すために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Server The &#34;Server&#34; is the entity responsible for coordinating client access to a set of filesystems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー「サーバー」は、一連のファイルシステムへのクライアントアクセスの調整を担当するエンティティです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stable Storage NFS version 4 servers must be able to recover without data loss from multiple power failures (including cascading power failures, that is, several power failures in quick succession), operating system failures, and hardware failure of components other than the storage medium itself (for example, disk, nonvolatile RAM).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安定したストレージNFSバージョン4サーバーは、複数の電源障害（カスケード電源障害、つまり連続した複数の電源障害を含む）、オペレーティングシステム障害、およびストレージメディア自体以外のコンポーネントのハードウェア障害によるデータ損失なしに回復できる必要があります（たとえば、ディスク、不揮発性RAM）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Some examples of stable storage that are allowable for an NFS server include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
NFSサーバーで許容される安定したストレージの例には次のものがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
1. Media commit of data, that is, the modified data has been successfully written to the disk media, for example, the disk platter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
1. データのメディアコミット、つまり変更されたデータは、ディスクメディア（ディスクプラッターなど）に正常に書き込まれました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
2. An immediate reply disk drive with battery-backed on-drive intermediate storage or uninterruptible power system (UPS).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
2. バッテリバックアップ式のドライブ上の中間ストレージまたは無停電電源システム（UPS）を備えた即時応答ディスクドライブ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
3. Server commit of data with battery-backed intermediate storage and recovery software.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
3. バッテリバックアップ式の中間ストレージおよびリカバリソフトウェアを使用した、サーバーによるデータのコミット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
4. Cache commit with uninterruptible power system (UPS) and recovery software.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
4. 無停電電源システム（UPS）と回復ソフトウェアによるキャッシュコミット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateid A 128-bit quantity returned by a server that uniquely defines the open and locking state provided by the server for a specific open or lock owner for a specific file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateid特定のファイルの特定のオープンまたはロック所有者に対してサーバーによって提供されるオープンおよびロック状態を一意に定義する、サーバーによって返される128ビットの数量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Stateids composed of all bits 0 or all bits 1 have special meaning and are reserved values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
すべてのビット0またはすべてのビット1で構成されるStateidには特別な意味があり、予約値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Verifier A 64-bit quantity generated by the client that the server can use to determine if the client has restarted and lost all previous lock state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベリファイアクライアントが再生成し、以前のロック状態をすべて失ったかどうかを判断するためにサーバーが使用できる、クライアントが生成した64ビットの量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Protocol-Data-Types">
2. Protocol Data Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. プロトコルデータタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The syntax and semantics to describe the data types of the NFS version 4 protocol are defined in the XDR [RFC1832] and RPC [RFC1831] documents. The next sections build upon the XDR data types to define types and structures specific to this protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルのデータ型を記述するための構文とセマンティクスは、XDR [RFC1832]およびRPC [RFC1831]ドキュメントで定義されています。次のセクションでは、XDRデータ型に基づいて、このプロトコルに固有の型と構造を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1--Basic-Data-Types">
2.1. Basic Data Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. 基本的なデータ型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Data Type       Definition
   ____________________________________________________________________
   int32_t         typedef int             int32_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint32_t typedef unsigned int uint32_t;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint32_t typedef unsigned int uint32_t;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
int64_t typedef hyper int64_t;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
int64_t typedef hyper int64_t;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint64_t typedef unsigned hyper uint64_t;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint64_t typedef unsigned hyper uint64_t;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   attrlist4       typedef opaque        attrlist4&lt;&gt;;
                   Used for file/directory attributes
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bitmap4 typedef uint32_t bitmap4&lt;&gt;; Used in attribute array encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bitmap4 typedef uint32_t bitmap4 &lt;&gt;;属性配列エンコーディングで使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
changeid4 typedef uint64_t changeid4; Used in definition of change_info
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
changeid4 typedef uint64_t changeid4; change_infoの定義で使用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
clientid4 typedef uint64_t clientid4; Shorthand reference to client identification
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
clientid4 typedef uint64_t clientid4;クライアントIDの省略表記
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
component4 typedef utf8str_cs component4; Represents path name components
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
component4 typedef utf8str_cs component4;パス名コンポーネントを表します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
count4 typedef uint32_t count4; Various count parameters (READ, WRITE, COMMIT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
count4 typedef uint32_t count4;さまざまなカウントパラメータ（READ、WRITE、COMMIT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length4 typedef uint64_t length4; Describes LOCK lengths
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length4 typedef uint64_t length4;ロックの長さについて説明します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
linktext4 typedef utf8str_cs linktext4; Symbolic link contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
linktext4 typedef utf8str_cs linktext4;シンボリックリンクの内容
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mode4 typedef uint32_t mode4; Mode attribute data type
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mode4 typedef uint32_t mode4;モード属性のデータ型
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs_cookie4 typedef uint64_t nfs_cookie4; Opaque cookie value for READDIR
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs_cookie4 typedef uint64_t nfs_cookie4; READDIRの不透明なCookie値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   nfs_fh4         typedef opaque          nfs_fh4&lt;NFS4_FHSIZE&gt;;
                   Filehandle definition; NFS4_FHSIZE is defined as 128
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs_ftype4 enum nfs_ftype4; Various defined file types
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs_ftype4列挙型nfs_ftype4;さまざまな定義済みファイルタイプ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfsstat4 enum nfsstat4; Return value for operations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfsstat4列挙型nfsstat4;操作の戻り値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
offset4 typedef uint64_t offset4; Various offset designations (READ, WRITE, LOCK, COMMIT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
offset4 typedef uint64_t offset4;さまざまなオフセット指定（READ、WRITE、LOCK、COMMIT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pathname4 typedef component4 pathname4&lt;&gt;; Represents path name for LOOKUP, OPEN and others
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pathname4 typedef component4 pathname4 &lt;&gt;; LOOKUP、OPENなどのパス名を表します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
qop4 typedef uint32_t qop4; Quality of protection designation in SECINFO
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
qop4 typedef uint32_t qop4; SECINFOでの保護品質の指定
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sec_oid4 typedef opaque sec_oid4&lt;&gt;; Security Object Identifier The sec_oid4 data type is not really opaque. Instead contains an ASN.1 OBJECT IDENTIFIER as used by GSS-API in the mech_type argument to GSS_Init_sec_context. See [RFC2743] for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sec_oid4 typedef不透明なsec_oid4 &lt;&gt;;セキュリティオブジェクト識別子sec_oid4データ型は実際には不透明ではありません。代わりに、GSS_APIがGSS_Init_sec_contextのmech_type引数で使用するASN.1 OBJECT IDENTIFIERが含まれています。詳細については、[RFC2743]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
seqid4 typedef uint32_t seqid4; Sequence identifier used for file locking
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
seqid4 typedef uint32_t seqid4;ファイルのロックに使用されるシーケンス識別子
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8string typedef opaque utf8string&lt;&gt;; UTF-8 encoding for strings
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8string typedef不透明utf8string &lt;&gt;;文字列のUTF-8エンコーディング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_cis typedef opaque utf8str_cis; Case-insensitive UTF-8 string
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_cis typedef opaque utf8str_cis;大文字と小文字を区別しないUTF-8文字列
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_cs typedef opaque utf8str_cs; Case-sensitive UTF-8 string
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_cs typedef opaque utf8str_cs;大文字と小文字を区別するUTF-8文字列
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_mixed typedef opaque utf8str_mixed; UTF-8 strings with a case sensitive prefix and a case insensitive suffix.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_mixed typedef opaque utf8str_mixed;大文字と小文字を区別する接頭辞と大文字と小文字を区別しない接尾辞を持つUTF-8文字列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
verifier4 typedef opaque verifier4[NFS4_VERIFIER_SIZE]; Verifier used for various operations (COMMIT, CREATE, OPEN, READDIR, SETCLIENTID, SETCLIENTID_CONFIRM, WRITE) NFS4_VERIFIER_SIZE is defined as 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
verifier4 typedef opaque verifier4 [NFS4_VERIFIER_SIZE];さまざまな操作（COMMIT、CREATE、OPEN、READDIR、SETCLIENTID、SETCLIENTID_CONFIRM、WRITE）に使用されるベリファイアNFS4_VERIFIER_SIZEは8と定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2--Structured-Data-Types">
2.2. Structured Data Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. 構造化データタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   nfstime4
                  struct nfstime4 {
                          int64_t seconds;
                          uint32_t nseconds;
                  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfstime4 structure gives the number of seconds and nanoseconds since midnight or 0 hour January 1, 1970 Coordinated Universal Time (UTC). Values greater than zero for the seconds field denote dates after the 0 hour January 1, 1970. Values less than zero for the seconds field denote dates before the 0 hour January 1, 1970. In both cases, the nseconds field is to be added to the seconds field for the final time representation. For example, if the time to be represented is one-half second before 0 hour January 1, 1970, the seconds field would have a value of negative one (-1) and the nseconds fields would have a value of one-half second (500000000). Values greater than 999,999,999 for nseconds are considered invalid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfstime4構造体は、1970年1月1日午前0時または0時間からの秒数およびナノ秒数を示します。協定世界時（UTC）。秒フィールドのゼロより大きい値は、1970年1月1日0時間より後の日付を示します。秒フィールドのゼロより小さい値は、1970年1月1日0時間より前の日付を示します。どちらの場合でも、n秒フィールドは最終時刻表現の秒フィールド。たとえば、表現される時間が1970年1月1日0時間前の0.5秒である場合、秒フィールドの値は負の1（-1）になり、n秒フィールドの値は0.5秒（ 500000000）。 n秒の999,999,999より大きい値は無効と見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This data type is used to pass time and date information. A server converts to and from its local representation of time when processing time values, preserving as much accuracy as possible. If the precision of timestamps stored for a filesystem object is less than defined, loss of precision can occur. An adjunct time maintenance protocol is recommended to reduce client and server time skew.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このデータ型は、日時情報を渡すために使用されます。サーバーは、時間値を処理するときに、時間のローカル表現との間で変換を行い、可能な限り正確さを維持します。ファイルシステムオブジェクトに格納されたタイムスタンプの精度が定義された精度よりも低い場合、精度が失われる可能性があります。クライアントとサーバーの時間のずれを減らすために、付属の時間保守プロトコルをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_how4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_how4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  enum time_how4 {
                          SET_TO_SERVER_TIME4 = 0,
                          SET_TO_CLIENT_TIME4 = 1
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
settime4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
settime4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  union settime4 switch (time_how4 set_it) {
                   case SET_TO_CLIENT_TIME4:
                           nfstime4       time;
                   default:
                           void;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above definitions are used as the attribute definitions to set time values. If set_it is SET_TO_SERVER_TIME4, then the server uses its local representation of time for the time value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の定義は、時間値を設定するための属性定義として使用されます。 set_itがSET_TO_SERVER_TIME4の場合、サーバーは時間の値としてローカルの時間表現を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
specdata4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
specdata4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct specdata4 {
                          uint32_t specdata1; /* major device number */
                          uint32_t specdata2; /* minor device number */
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This data type represents additional information for the device file types NF4CHR and NF4BLK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このデータタイプは、デバイスファイルタイプNF4CHRおよびNF4BLKの追加情報を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fsid4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fsid4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct fsid4 {
                    uint64_t        major;
                    uint64_t        minor;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This type is the filesystem identifier that is used as a mandatory attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このタイプは、必須属性として使用されるファイルシステム識別子です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_location4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_location4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct fs_location4 {
                          utf8str_cis    server&lt;&gt;;
                          pathname4     rootpath;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct fs_locations4 {
                          pathname4     fs_root;
                          fs_location4  locations&lt;&gt;;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_location4 and fs_locations4 data types are used for the fs_locations recommended attribute which is used for migration and replication support.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_location4およびfs_locations4データ型は、移行およびレプリケーションのサポートに使用されるfs_locations推奨属性に使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fattr4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fattr4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct fattr4 {
                          bitmap4       attrmask;
                          attrlist4     attr_vals;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fattr4 structure is used to represent file and directory attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fattr4構造は、ファイルとディレクトリの属性を表すために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The bitmap is a counted array of 32 bit integers used to contain bit values. The position of the integer in the array that contains bit n can be computed from the expression (n / 32) and its bit within that integer is (n mod 32).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビットマップは、ビット値を含むために使用される32ビット整数のカウントされた配列です。ビットnを含む配列内の整数の位置は、式（n / 32）から計算でき、その整数内のビットは（n mod 32）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                           0            1
         +-----------+-----------+-----------+--
         |  count    | 31  ..  0 | 63  .. 32 |
         +-----------+-----------+-----------+--
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
change_info4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
change_info4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct change_info4 {
                          bool          atomic;
                          changeid4     before;
                          changeid4     after;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is used with the CREATE, LINK, REMOVE, RENAME operations to let the client know the value of the change attribute for the directory in which the target filesystem object resides.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造はCREATE、LINK、REMOVE、RENAME操作で使用され、ターゲットファイルシステムオブジェクトが存在するディレクトリの変更属性の値をクライアントに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
clientaddr4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
clientaddr4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct clientaddr4 {
                          /* see struct rpcb in RFC 1833 */
                          string r_netid&lt;&gt;;    /* network id */
                          string r_addr&lt;&gt;;     /* universal address */
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The clientaddr4 structure is used as part of the SETCLIENTID operation to either specify the address of the client that is using a clientid or as part of the callback registration. The r_netid and r_addr fields are specified in [RFC1833], but they are underspecified in [RFC1833] as far as what they should look like for specific protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
clientaddr4構造体は、SETCLIENTID操作の一部として使用され、clientidを使用しているクライアントのアドレスを指定するか、コールバック登録の一部として使用されます。 r_netidおよびr_addrフィールドは[RFC1833]で指定されていますが、特定のプロトコルでどのように見えるかについては[RFC1833]で過小指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For TCP over IPv4 and for UDP over IPv4, the format of r_addr is the US-ASCII string:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP over IPv4およびUDP over IPv4の場合、r_addrの形式はUS-ASCII文字列です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
h1.h2.h3.h4.p1.p2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
h1.h2.h3.h4.p1.p2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The prefix, &#34;h1.h2.h3.h4&#34;, is the standard textual form for representing an IPv4 address, which is always four octets long. Assuming big-endian ordering, h1, h2, h3, and h4, are respectively, the first through fourth octets each converted to ASCII-decimal. Assuming big-endian ordering, p1 and p2 are, respectively, the first and second octets each converted to ASCII-decimal. For example, if a host, in big-endian order, has an address of 0x0A010307 and there is a service listening on, in big endian order, port 0x020F (decimal 527), then the complete universal address is &#34;10.1.3.7.2.15&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プレフィックス「h1.h2.h3.h4」は、IPv4アドレスを表すための標準のテキスト形式であり、常に4オクテットです。ビッグエンディアンの順序付けであると仮定すると、h1、h2、h3、およびh4はそれぞれ、最初のオクテットから4番目のオクテットがASCIIの10進数に変換されます。ビッグエンディアンの順序付けを想定すると、p1とp2はそれぞれ、ASCII 10進数に変換された最初と2番目のオクテットです。たとえば、ビッグエンディアン順のホストのアドレスが0x0A010307で、ビッグエンディアン順のポート0x020F（10進数の527）をリッスンしているサービスがある場合、完全なユニバーサルアドレスは「10.1.3.7.2.15」になります。 」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For TCP over IPv4 the value of r_netid is the string &#34;tcp&#34;. For UDP over IPv4 the value of r_netid is the string &#34;udp&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv4上のTCPの場合、r_netidの値は文字列「tcp」です。 UDP over IPv4の場合、r_netidの値は文字列「udp」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For TCP over IPv6 and for UDP over IPv6, the format of r_addr is the US-ASCII string:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP over IPv6およびUDP over IPv6の場合、r_addrの形式はUS-ASCII文字列です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         x1:x2:x3:x4:x5:x6:x7:x8.p1.p2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The suffix &#34;p1.p2&#34; is the service port, and is computed the same way as with universal addresses for TCP and UDP over IPv4. The prefix, &#34;x1:x2:x3:x4:x5:x6:x7:x8&#34;, is the standard textual form for representing an IPv6 address as defined in Section 2.2 of [RFC2373]. Additionally, the two alternative forms specified in Section 2.2 of [RFC2373] are also acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サフィックス「p1.p2」はサービスポートであり、IPv4を介したTCPおよびUDPのユニバーサルアドレスと同じ方法で計算されます。接頭辞「x1：x2：x3：x4：x5：x6：x7：x8」は、[RFC2373]のセクション2.2で定義されているIPv6アドレスを表すための標準のテキスト形式です。さらに、[RFC2373]のセクション2.2で指定されている2つの代替形式も許容されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For TCP over IPv6 the value of r_netid is the string &#34;tcp6&#34;. For UDP over IPv6 the value of r_netid is the string &#34;udp6&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP over IPv6の場合、r_netidの値は文字列「tcp6」です。 UDP over IPv6の場合、r_netidの値は文字列「udp6」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cb_client4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cb_client4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct cb_client4 {
                          unsigned int  cb_program;
                          clientaddr4   cb_location;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is used by the client to inform the server of its call back address; includes the program number and client address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造は、クライアントがサーバーにコールバックアドレスを通知するために使用されます。プログラム番号とクライアントアドレスが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs_client_id4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs_client_id4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct nfs_client_id4 {
                          verifier4     verifier;
                          opaque        id&lt;NFS4_OPAQUE_LIMIT&gt;;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is part of the arguments to the SETCLIENTID operation. NFS4_OPAQUE_LIMIT is defined as 1024.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造は、SETCLIENTID操作の引数の一部です。 NFS4_OPAQUE_LIMITは1024として定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
open_owner4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
open_owner4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct open_owner4 {
                          clientid4     clientid;
                          opaque        owner&lt;NFS4_OPAQUE_LIMIT&gt;;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is used to identify the owner of open state. NFS4_OPAQUE_LIMIT is defined as 1024.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造は、オープン状態の所有者を識別するために使用されます。 NFS4_OPAQUE_LIMITは1024として定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
lock_owner4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
lock_owner4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct lock_owner4 {
                          clientid4     clientid;
                          opaque        owner&lt;NFS4_OPAQUE_LIMIT&gt;;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is used to identify the owner of file locking state. NFS4_OPAQUE_LIMIT is defined as 1024.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造は、ファイルロック状態の所有者を識別するために使用されます。 NFS4_OPAQUE_LIMITは1024として定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
open_to_lock_owner4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
open_to_lock_owner4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct open_to_lock_owner4 {
                          seqid4          open_seqid;
                          stateid4        open_stateid;
                          seqid4          lock_seqid;
                          lock_owner4     lock_owner;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is used for the first LOCK operation done for an open_owner4. It provides both the open_stateid and lock_owner such that the transition is made from a valid open_stateid sequence to that of the new lock_stateid sequence. Using this mechanism avoids the confirmation of the lock_owner/lock_seqid pair since it is tied to established state in the form of the open_stateid/open_seqid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造は、open_owner4に対して行われる最初のLOCK操作に使用されます。有効なopen_stateidシーケンスから新しいlock_stateidシーケンスへの移行が行われるように、open_stateidとlock_ownerの両方を提供します。このメカニズムを使用すると、open_stateid / open_seqidの形式で確立された状態に関連付けられるため、lock_owner / lock_seqidペアの確認が回避されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stateid4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stateid4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct stateid4 {
                    uint32_t        seqid;
                    opaque          other[12];
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is used for the various state sharing mechanisms between the client and server. For the client, this data structure is read-only. The starting value of the seqid field is undefined. The server is required to increment the seqid field monotonically at each transition of the stateid. This is important since the client will inspect the seqid in OPEN stateids to determine the order of OPEN processing done by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造は、クライアントとサーバー間のさまざまな状態共有メカニズムに使用されます。クライアントの場合、このデータ構造は読み取り専用です。 seqidフィールドの開始値は未定義です。サーバーは、stateidの各遷移でseqidフィールドを単調に増分する必要があります。クライアントはOPENステートIDのseqidを検査して、サーバーが行うOPEN処理の順序を決定するため、これは重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--RPC-and-Security-Flavor">
3. RPC and Security Flavor
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. RPCとセキュリティの味
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 protocol is a Remote Procedure Call (RPC) application that uses RPC version 2 and the corresponding eXternal Data Representation (XDR) as defined in [RFC1831] and [RFC1832]. The RPCSEC_GSS security flavor as defined in [RFC2203] MUST be used as the mechanism to deliver stronger security for the NFS version 4 protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルは、RPCバージョン2と、[RFC1831]および[RFC1832]で定義されている対応する外部データ表現（XDR）を使用するリモートプロシージャコール（RPC）アプリケーションです。 [RFC2203]で定義されているRPCSEC_GSSセキュリティフレーバーは、NFSバージョン4プロトコルにより強力なセキュリティを提供するメカニズムとして使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--Ports-and-Transports">
3.1. Ports and Transports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. ポートとトランスポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Historically, NFS version 2 and version 3 servers have resided on port 2049. The registered port 2049 [RFC3232] for the NFS protocol should be the default configuration. Using the registered port for NFS services means the NFS client will not need to use the RPC binding protocols as described in [RFC1833]; this will allow NFS to transit firewalls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
歴史的に、NFSバージョン2およびバージョン3サーバーはポート2049に存在していました。NFSプロトコル用の登録済みポート2049 [RFC3232]がデフォルトの構成である必要があります。 NFSサービスに登録されたポートを使用することは、[RFC1833]で説明されているように、NFSクライアントがRPCバインディングプロトコルを使用する必要がないことを意味します。これにより、NFSがファイアウォールを通過できるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where an NFS version 4 implementation supports operation over the IP network protocol, the supported transports between NFS and IP MUST be among the IETF-approved congestion control transport protocols, which include TCP and SCTP. To enhance the possibilities for interoperability, an NFS version 4 implementation MUST support operation over the TCP transport protocol, at least until such time as a standards track RFC revises this requirement to use a different IETF-approved congestion control transport protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4の実装がIPネットワークプロトコルを介した操作をサポートする場合、NFSとIPの間でサポートされるトランスポートは、TCPとSCTPを含むIETF承認の輻輳制御トランスポートプロトコルの中になければなりません（MUST）。相互運用性の可能性を高めるために、NFSバージョン4の実装は、少なくとも標準の追跡RFCがこの要件を改訂して別のIETF承認の輻輳制御トランスポートプロトコルを使用するまで、TCPトランスポートプロトコルを介した操作をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If TCP is used as the transport, the client and server SHOULD use persistent connections. This will prevent the weakening of TCP&#39;s congestion control via short lived connections and will improve performance for the WAN environment by eliminating the need for SYN handshakes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPがトランスポートとして使用される場合、クライアントとサーバーは永続的な接続を使用する必要があります（SHOULD）。これにより、存続期間の短い接続を介したTCPの輻輳制御の弱体化が防止され、SYNハンドシェイクが不要になるため、WAN環境のパフォーマンスが向上します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As noted in the Security Considerations section, the authentication model for NFS version 4 has moved from machine-based to principal-based. However, this modification of the authentication model does not imply a technical requirement to move the TCP connection management model from whole machine-based to one based on a per user model. In particular, NFS over TCP client implementations have traditionally multiplexed traffic for multiple users over a common TCP connection between an NFS client and server. This has been true, regardless whether the NFS client is using AUTH_SYS, AUTH_DH, RPCSEC_GSS or any other flavor. Similarly, NFS over TCP server implementations have assumed such a model and thus scale the implementation of TCP connection management in proportion to the number of expected client machines. It is intended that NFS version 4 will not modify this connection management model. NFS version 4 clients that violate this assumption can expect scaling issues on the server and hence reduced service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「セキュリティに関する考慮事項」セクションで述べたように、NFSバージョン4の認証モデルは、マシンベースからプリンシパルベースに移行しました。ただし、この認証モデルの変更は、TCP接続管理モデルをマシンベース全体からユーザーごとのモデルに基づくものに移行するための技術的要件を意味するものではありません。特に、NFS over TCPクライアントの実装では、NFSクライアントとサーバー間の共通のTCP接続を介して、複数のユーザーのトラフィックを従来から多重化しています。これは、NFSクライアントがAUTH_SYS、AUTH_DH、RPCSEC_GSSまたはその他のフレーバーを使用しているかどうかに関係なく当てはまります。同様に、NFS over TCPサーバーの実装はそのようなモデルを想定しているため、予想されるクライアントマシンの数に比例してTCP接続管理の実装を拡張します。 NFSバージョン4はこの接続管理モデルを変更しないことを意図しています。この仮定に違反するNFSバージョン4クライアントは、サーバーでのスケーリングの問題を予期し、それによりサービスが低下する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that for various timers, the client and server should avoid inadvertent synchronization of those timers. For further discussion of the general issue refer to [Floyd].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さまざまなタイマーについて、クライアントとサーバーはそれらのタイマーの不注意な同期を回避する必要があることに注意してください。一般的な問題の詳細については、[Floyd]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1-1--Client-Retransmission-Behavior">
3.1.1. Client Retransmission Behavior
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1. クライアントの再送信動作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When processing a request received over a reliable transport such as TCP, the NFS version 4 server MUST NOT silently drop the request, except if the transport connection has been broken. Given such a contract between NFS version 4 clients and servers, clients MUST NOT retry a request unless one or both of the following are true:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPなどの信頼できるトランスポートを介して受信した要求を処理するとき、NFSバージョン4サーバーは、トランスポート接続が切断されている場合を除いて、要求を黙ってドロップしてはなりません（MUST NOT）。 NFSバージョン4のクライアントとサーバーの間でそのような契約が与えられている場合、次のいずれかまたは両方が当てはまらない限り、クライアントは要求を再試行してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The transport connection has been broken
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o トランスポート接続が切断されました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The procedure being retried is the NULL procedure
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 再試行中のプロシージャはNULLプロシージャです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since reliable transports, such as TCP, do not always synchronously inform a peer when the other peer has broken the connection (for example, when an NFS server reboots), the NFS version 4 client may want to actively &#34;probe&#34; the connection to see if has been broken. Use of the NULL procedure is one recommended way to do so. So, when a client experiences a remote procedure call timeout (of some arbitrary implementation specific amount), rather than retrying the remote procedure call, it could instead issue a NULL procedure call to the server. If the server has died, the transport connection break will eventually be indicated to the NFS version 4 client. The client can then reconnect, and then retry the original request. If the NULL procedure call gets a response, the connection has not broken. The client can decide to wait longer for the original request&#39;s response, or it can break the transport connection and reconnect before re-sending the original request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPなどの信頼できるトランスポートは、他のピアが接続を切断したとき（たとえば、NFSサーバーが再起動したとき）に常に同期的にピアに通知するわけではないため、NFSバージョン4クライアントは接続をアクティブに「プローブ」して確認する場合があります。壊れている場合。 NULLプロシージャの使用は、そのための1つの推奨される方法です。したがって、クライアントがリモートプロシージャコールのタイムアウトを（任意の実装固有の量の）経験した場合、リモートプロシージャコールを再試行するのではなく、代わりにサーバーにNULLプロシージャコールを発行できます。サーバーが停止した場合、トランスポート接続の切断が最終的にNFSバージョン4クライアントに示されます。その後、クライアントは再接続して、元の要求を再試行できます。 NULLプロシージャコールが応答を受け取った場合、接続は切断されていません。クライアントは、元の要求の応答をさらに長く待つか、元の要求を再送信する前にトランスポート接続を切断して再接続するかを決定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For callbacks from the server to the client, the same rules apply, but the server doing the callback becomes the client, and the client receiving the callback becomes the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーからクライアントへのコールバックについても同じルールが適用されますが、コールバックを実行するサーバーがクライアントになり、コールバックを受信するクライアントがサーバーになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--Security-Flavors">
3.2. Security Flavors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. セキュリティフレーバー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Traditional RPC implementations have included AUTH_NONE, AUTH_SYS, AUTH_DH, and AUTH_KRB4 as security flavors. With [RFC2203] an additional security flavor of RPCSEC_GSS has been introduced which uses the functionality of GSS-API [RFC2743]. This allows for the use of various security mechanisms by the RPC layer without the additional implementation overhead of adding RPC security flavors. For NFS version 4, the RPCSEC_GSS security flavor MUST be used to enable the mandatory security mechanism. Other flavors, such as, AUTH_NONE, AUTH_SYS, and AUTH_DH MAY be implemented as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
従来のRPC実装には、セキュリティフレーバーとしてAUTH_NONE、AUTH_SYS、AUTH_DH、およびAUTH_KRB4が含まれていました。 [RFC2203]では、GSS-API [RFC2743]の機能を使用するRPCSEC_GSSの追加のセキュリティフレーバーが導入されています。これにより、RPCセキュリティフレーバーを追加することによる追加の実装オーバーヘッドなしで、RPCレイヤーによるさまざまなセキュリティメカニズムの使用が可能になります。 NFSバージョン4の場合、RPCSEC_GSSセキュリティフレーバーを使用して、必須のセキュリティメカニズムを有効にする必要があります。 AUTH_NONE、AUTH_SYS、AUTH_DHなどの他のフレーバーも実装できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-1--Security-mechanisms-for-NFS-version-4">
3.2.1. Security mechanisms for NFS version 4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. NFSバージョン4のセキュリティメカニズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of RPCSEC_GSS requires selection of: mechanism, quality of protection, and service (authentication, integrity, privacy). The remainder of this document will refer to these three parameters of the RPCSEC_GSS security as the security triple.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPCSEC_GSSを使用するには、メカニズム、保護品質、およびサービス（認証、整合性、プライバシー）の選択が必要です。このドキュメントの残りの部分では、RPCSEC_GSSセキュリティのこれら3つのパラメータをセキュリティトリプルと呼びます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-1-1--Kerberos-V5-as-a-security-triple">
3.2.1.1. Kerberos V5 as a security triple
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1.1. セキュリティトリプルとしてのKerberos V5
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Kerberos V5 GSS-API mechanism as described in [RFC1964] MUST be implemented and provide the following security triples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1964]で説明されているKerberos V5 GSS-APIメカニズムを実装して、次のセキュリティトリプルを提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
column descriptions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列の説明：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1 == number of pseudo flavor
   2 == name of pseudo flavor
   3 == mechanism&#39;s OID
   4 == mechanism&#39;s algorithm(s)
   5 == RPCSEC_GSS service
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1      2     3                    4             5
   --------------------------------------------------------------------
   390003 krb5  1.2.840.113554.1.2.2 DES MAC MD5   rpc_gss_svc_none
   390004 krb5i 1.2.840.113554.1.2.2 DES MAC MD5   rpc_gss_svc_integrity
   390005 krb5p 1.2.840.113554.1.2.2 DES MAC MD5   rpc_gss_svc_privacy
                                     for integrity,
                                     and 56 bit DES
                                     for privacy.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Note that the pseudo flavor is presented here as a mapping aid to the implementor. Because this NFS protocol includes a method to negotiate security and it understands the GSS-API mechanism, the pseudo flavor is not needed. The pseudo flavor is needed for NFS version 3 since the security negotiation is done via the MOUNT protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ここでは、疑似フレーバーが実装者へのマッピング補助として示されていることに注意してください。このNFSプロトコルには、セキュリティをネゴシエートする方法が含まれており、GSS-APIメカニズムを理解しているため、疑似フレーバーは必要ありません。セキュリティネゴシエーションはMOUNTプロトコルを介して行われるため、NFSバージョン3には疑似フレーバーが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a discussion of NFS&#39; use of RPCSEC_GSS and Kerberos V5, please see [RFC2623].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSによるRPCSEC_GSSおよびKerberos V5の使用については、[RFC2623]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Users and implementors are warned that 56 bit DES is no longer considered state of the art in terms of resistance to brute force attacks. Once a revision to [RFC1964] is available that adds support for AES, implementors are urged to incorporate AES into their NFSv4 over Kerberos V5 protocol stacks, and users are similarly urged to migrate to the use of AES.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーと実装者は、ブルートフォース攻撃に対する耐性の観点から、56ビットDESが最先端の技術とは見なされなくなったことを警告しています。 AESのサポートを追加する[RFC1964]のリビジョンが利用可能になると、実装者はKerberos V5プロトコルスタック上のNFSv4にAESを組み込むことを求められ、ユーザーは同様にAESの使用に移行するよう求められます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-1-2--LIPKEY-as-a-security-triple">
3.2.1.2. LIPKEY as a security triple
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1.2. セキュリティトリプルとしてのLIPKEY
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LIPKEY GSS-API mechanism as described in [RFC2847] MUST be implemented and provide the following security triples. The definition of the columns matches the previous subsection &#34;Kerberos V5 as security triple&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2847]で説明されているLIPKEY GSS-APIメカニズムを実装して、次のセキュリティトリプルを提供する必要があります。列の定義は、前のサブセクション「セキュリティトリプルとしてのKerberos V5」に一致します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1      2        3                   4              5
   --------------------------------------------------------------------
   390006 lipkey   1.3.6.1.5.5.9       negotiated  rpc_gss_svc_none
   390007 lipkey-i 1.3.6.1.5.5.9       negotiated  rpc_gss_svc_integrity
   390008 lipkey-p 1.3.6.1.5.5.9       negotiated  rpc_gss_svc_privacy
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mechanism algorithm is listed as &#34;negotiated&#34;. This is because LIPKEY is layered on SPKM-3 and in SPKM-3 [RFC2847] the confidentiality and integrity algorithms are negotiated. Since SPKM-3 specifies HMAC-MD5 for integrity as MANDATORY, 128 bit cast5CBC for confidentiality for privacy as MANDATORY, and further specifies that HMAC-MD5 and cast5CBC MUST be listed first before weaker algorithms, specifying &#34;negotiated&#34; in column 4 does not impair interoperability. In the event an SPKM-3 peer does not support the mandatory algorithms, the other peer is free to accept or reject the GSS-API context creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メカニズムアルゴリズムは「交渉済み」としてリストされています。これは、LIPKEYがSPKM-3およびSPKM-3 [RFC2847]で階層化されているため、機密性と整合性のアルゴリズムがネゴシエートされるためです。 SPKM-3は整合性のためにHMAC-MD5をMANDATORYとして指定し、プライバシーの機密性のために128ビットcast5CBCをMANDATORYとして指定し、さらに、HMAC-MD5およびcast5CBCを弱いアルゴリズムの前に最初にリストする必要があることを指定し、列4に「ネゴシエート済み」を指定しても問題はありません。相互運用性。 SPKM-3ピアが必須アルゴリズムをサポートしていない場合、他のピアはGSS-APIコンテキストの作成を自由に受け入れたり拒否したりできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because SPKM-3 negotiates the algorithms, subsequent calls to LIPKEY&#39;s GSS_Wrap() and GSS_GetMIC() by RPCSEC_GSS will use a quality of protection value of 0 (zero). See section 5.2 of [RFC2025] for an explanation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SPKM-3はアルゴリズムをネゴシエートするため、RPCSEC_GSSによるLIPKEYのGSS_Wrap()およびGSS_GetMIC()への後続の呼び出しは、保護品質値0（ゼロ）を使用します。説明については、[RFC2025]のセクション5.2をご覧ください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LIPKEY uses SPKM-3 to create a secure channel in which to pass a user name and password from the client to the server. Once the user name and password have been accepted by the server, calls to the LIPKEY context are redirected to the SPKM-3 context. See [RFC2847] for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LIPKEYはSPKM-3を使用して、クライアントからサーバーにユーザー名とパスワードを渡すための安全なチャネルを作成します。ユーザー名とパスワードがサーバーに受け入れられると、LIPKEYコンテキストへの呼び出しはSPKM-3コンテキストにリダイレクトされます。詳細については、[RFC2847]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-1-3--SPKM-3-as-a-security-triple">
3.2.1.3. SPKM-3 as a security triple
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1.3. セキュリティトリプルとしてのSPKM-3
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SPKM-3 GSS-API mechanism as described in [RFC2847] MUST be implemented and provide the following security triples. The definition of the columns matches the previous subsection &#34;Kerberos V5 as security triple&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2847]で説明されているSPKM-3 GSS-APIメカニズムを実装して、次のセキュリティトリプルを提供する必要があります。列の定義は、前のサブセクション「セキュリティトリプルとしてのKerberos V5」と一致します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1      2        3                   4              5
   --------------------------------------------------------------------
   390009 spkm3    1.3.6.1.5.5.1.3     negotiated  rpc_gss_svc_none
   390010 spkm3i   1.3.6.1.5.5.1.3     negotiated  rpc_gss_svc_integrity
   390011 spkm3p   1.3.6.1.5.5.1.3     negotiated  rpc_gss_svc_privacy
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a discussion as to why the mechanism algorithm is listed as &#34;negotiated&#34;, see the previous section &#34;LIPKEY as a security triple.&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メカニズムアルゴリズムが「交渉済み」と表示される理由については、前のセクション「セキュリティトリプルとしてのLIPKEY」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because SPKM-3 negotiates the algorithms, subsequent calls to SPKM-3&#39;s GSS_Wrap() and GSS_GetMIC() by RPCSEC_GSS will use a quality of protection value of 0 (zero). See section 5.2 of [RFC2025] for an explanation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SPKM-3はアルゴリズムをネゴシエートするため、RPCSEC_GSSによるSPKM-3のGSS_Wrap()およびGSS_GetMIC()への後続の呼び出しは、0（ゼロ）の保護品質値を使用します。説明については、[RFC2025]のセクション5.2をご覧ください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even though LIPKEY is layered over SPKM-3, SPKM-3 is specified as a mandatory set of triples to handle the situations where the initiator (the client) is anonymous or where the initiator has its own certificate. If the initiator is anonymous, there will not be a user name and password to send to the target (the server). If the initiator has its own certificate, then using passwords is superfluous.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LIPKEYはSPKM-3の上に階層化されていますが、SPKM-3は、イニシエーター（クライアント）が匿名であるか、イニシエーターが独自の証明書を持っている状況を処理するための必須のトリプルセットとして指定されています。イニシエーターが匿名の場合、ターゲット（サーバー）に送信するユーザー名とパスワードはありません。イニシエーターが独自の証明書を持っている場合、パスワードの使用は不必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3--Security-Negotiation">
3.3. Security Negotiation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. セキュリティ交渉
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the NFS version 4 server potentially offering multiple security mechanisms, the client needs a method to determine or negotiate which mechanism is to be used for its communication with the server. The NFS server may have multiple points within its filesystem name space that are available for use by NFS clients. In turn the NFS server may be configured such that each of these entry points may have different or multiple security mechanisms in use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4サーバーは複数のセキュリティメカニズムを提供する可能性があるため、クライアントは、サーバーとの通信に使用するメカニズムを決定またはネゴシエートする方法が必要です。 NFSサーバーは、NFSクライアントが使用できるファイルシステム名前空間内に複数のポイントを持っている場合があります。次に、NFSサーバーは、これらのエントリポイントのそれぞれが、異なるまたは複数のセキュリティメカニズムを使用するように構成できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The security negotiation between client and server must be done with a secure channel to eliminate the possibility of a third party intercepting the negotiation sequence and forcing the client and server to choose a lower level of security than required or desired. See the section &#34;Security Considerations&#34; for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバー間のセキュリティネゴシエーションは、サードパーティがネゴシエーションシーケンスを傍受し、クライアントとサーバーが必要または望ましいレベルよりも低いセキュリティレベルを選択する可能性を排除するために、安全なチャネルで行う必要があります。詳細については、「セキュリティに関する考慮事項」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-1--SECINFO">
3.3.1. SECINFO
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1. SECINFO
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The new SECINFO operation will allow the client to determine, on a per filehandle basis, what security triple is to be used for server access. In general, the client will not have to use the SECINFO operation except during initial communication with the server or when the client crosses policy boundaries at the server. It is possible that the server&#39;s policies change during the client&#39;s interaction therefore forcing the client to negotiate a new security triple.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいSECINFO操作により、クライアントはファイルハンドルごとに、サーバーアクセスに使用するセキュリティトリプルを決定できます。一般に、クライアントは、サーバーとの最初の通信中、またはクライアントがサーバーでポリシーの境界を越えるときを除いて、SECINFO操作を使用する必要はありません。クライアントの対話中にサーバーのポリシーが変更される可能性があるため、クライアントは新しいセキュリティトリプルをネゴシエートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-2--Security-Error">
3.3.2. Security Error
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.2. セキュリティエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on the assumption that each NFS version 4 client and server must support a minimum set of security (i.e., LIPKEY, SPKM-3, and Kerberos-V5 all under RPCSEC_GSS), the NFS client will start its communication with the server with one of the minimal security triples. During communication with the server, the client may receive an NFS error of NFS4ERR_WRONGSEC. This error allows the server to notify the client that the security triple currently being used is not appropriate for access to the server&#39;s filesystem resources. The client is then responsible for determining what security triples are available at the server and choose one which is appropriate for the client. See the section for the &#34;SECINFO&#34; operation for further discussion of how the client will respond to the NFS4ERR_WRONGSEC error and use SECINFO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各NFSバージョン4クライアントとサーバーは最低限のセキュリティセット（つまり、すべてRPCSEC_GSSの下のLIPKEY、SPKM-3、およびKerberos-V5）をサポートする必要があるという想定に基づいて、NFSクライアントは次のいずれかでサーバーとの通信を開始します。最小限のセキュリティトリプル。サーバーとの通信中に、クライアントはNFS4ERR_WRONGSECのNFSエラーを受け取る場合があります。このエラーにより、サーバーは、現在使用されているセキュリティトリプルがサーバーのファイルシステムリソースへのアクセスに適切でないことをクライアントに通知できます。次にクライアントは、サーバーで利用可能なセキュリティトリプルを決定し、クライアントに適したものを選択します。クライアントがNFS4ERR_WRONGSECエラーに応答してSECINFOを使用する方法の詳細については、「SECINFO」操作のセクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-4--Callback-RPC-Authentication">
3.4. Callback RPC Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. コールバックRPC認証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Except as noted elsewhere in this section, the callback RPC (described later) MUST mutually authenticate the NFS server to the principal that acquired the clientid (also described later), using the security flavor the original SETCLIENTID operation used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションの他の箇所で言及されている場合を除き、コールバックRPC（後述）は、元のSETCLIENTID操作で使用されたセキュリティフレーバーを使用して、clientid（これも後述）を取得したプリンシパルに対してNFSサーバーを相互認証する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For AUTH_NONE, there are no principals, so this is a non-issue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AUTH_NONEの場合、プリンシパルがないため、これは問題にはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AUTH_SYS has no notions of mutual authentication or a server principal, so the callback from the server simply uses the AUTH_SYS credential that the user used when he set up the delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AUTH_SYSには相互認証やサーバープリンシパルの概念がないため、サーバーからのコールバックは、ユーザーが委任を設定したときに使用したAUTH_SYS資格情報を使用するだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For AUTH_DH, one commonly used convention is that the server uses the credential corresponding to this AUTH_DH principal:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AUTH_DHの場合、一般的に使用される規則の1つは、サーバーがこのAUTH_DHプリンシパルに対応する資格を使用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
unix.host@domain
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
うにｘ。ほｓｔ＠どまいん
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where host and domain are variables corresponding to the name of server host and directory services domain in which it lives such as a Network Information System domain or a DNS domain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、hostおよびdomainは、ネットワーク情報システムドメインやDNSドメインなど、サーバーホストおよびディレクトリサービスドメインが存在するサーバー名に対応する変数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because LIPKEY is layered over SPKM-3, it is permissible for the server to use SPKM-3 and not LIPKEY for the callback even if the client used LIPKEY for SETCLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LIPKEYはSPKM-3を介して階層化されているため、クライアントがSETCLIENTIDにLIPKEYを使用した場合でも、サーバーはコールバックにLIPKEYではなくSPKM-3を使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regardless of what security mechanism under RPCSEC_GSS is being used, the NFS server, MUST identify itself in GSS-API via a GSS_C_NT_HOSTBASED_SERVICE name type. GSS_C_NT_HOSTBASED_SERVICE names are of the form:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPCSEC_GSSで使用されているセキュリティメカニズムに関係なく、NFSサーバーは、GSS_C_NT_HOSTBASED_SERVICE名前タイプを介してGSS-APIで自身を識別しなければなりません（MUST）。 GSS_C_NT_HOSTBASED_SERVICEの名前の形式は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
service@hostname
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
service @ hostname
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For NFS, the &#34;service&#34; element is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSの場合、「サービス」要素は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
nfs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
同じ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations of security mechanisms will convert nfs@hostname to various different forms. For Kerberos V5 and LIPKEY, the following form is RECOMMENDED:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティメカニズムを実装すると、nfs @ hostnameがさまざまな形式に変換されます。 Kerberos V5およびLIPKEYの場合、次の形式が推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
nfs/hostname
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
nfs /ホスト名
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For Kerberos V5, nfs/hostname would be a server principal in the Kerberos Key Distribution Center database. This is the same principal the client acquired a GSS-API context for when it issued the SETCLIENTID operation, therefore, the realm name for the server principal must be the same for the callback as it was for the SETCLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Kerberos V5の場合、nfs / hostnameはKerberosキー配布センターデータベースのサーバープリンシパルになります。これは、クライアントがSETCLIENTID操作を発行したときにGSS-APIコンテキストを取得したプリンシパルと同じであるため、サーバープリンシパルのレルム名は、SETCLIENTIDの場合と同じようにコールバックでも同じである必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For LIPKEY, this would be the username passed to the target (the NFS version 4 client that receives the callback).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LIPKEYの場合、これはターゲット（コールバックを受信するNFSバージョン4クライアント）に渡されるユーザー名になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be noted that LIPKEY may not work for callbacks, since the LIPKEY client uses a user id/password. If the NFS client receiving the callback can authenticate the NFS server&#39;s user name/password pair, and if the user that the NFS server is authenticating to has a public key certificate, then it works.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LIPKEYクライアントはユーザーID /パスワードを使用するため、コールバックに対してLIPKEYが機能しない場合があることに注意してください。コールバックを受信するNFSクライアントがNFSサーバーのユーザー名/パスワードのペアを認証でき、NFSサーバーが認証するユーザーが公開鍵証明書を持っている場合、それは機能します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In situations where the NFS client uses LIPKEY and uses a per-host principal for the SETCLIENTID operation, instead of using LIPKEY for SETCLIENTID, it is RECOMMENDED that SPKM-3 with mutual authentication be used. This effectively means that the client will use a certificate to authenticate and identify the initiator to the target on the NFS server. Using SPKM-3 and not LIPKEY has the following advantages:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSクライアントがLIPKEYを使用し、SETCLIENTID操作にホストごとのプリンシパルを使用する状況では、SETCLIENTIDにLIPKEYを使用する代わりに、相互認証付きのSPKM-3を使用することをお勧めします。つまり、クライアントは証明書を使用して、NFSサーバー上のターゲットに対してイニシエーターを認証および識別します。 LIPKEYではなくSPKM-3を使用すると、次の利点があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o When the server does a callback, it must authenticate to the principal used in the SETCLIENTID. Even if LIPKEY is used, because LIPKEY is layered over SPKM-3, the NFS client will need to have a certificate that corresponds to the principal used in the SETCLIENTID operation. From an administrative perspective, having a user name, password, and certificate for both the client and server is redundant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
oサーバーがコールバックを行うとき、サーバーはSETCLIENTIDで使用されるプリンシパルに対して認証する必要があります。 LIPKEYが使用されている場合でも、LIPKEYはSPKM-3を介して階層化されているため、NFSクライアントには、SETCLIENTID操作で使用されるプリンシパルに対応する証明書が必要です。管理の観点からは、クライアントとサーバーの両方にユーザー名、パスワード、および証明書を用意することは冗長です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LIPKEY was intended to minimize additional infrastructure requirements beyond a certificate for the target, and the expectation is that existing password infrastructure can be leveraged for the initiator. In some environments, a per-host password does not exist yet. If certificates are used for any per-host principals, then additional password infrastructure is not needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LIPKEYは、ターゲットの証明書を超える追加のインフラストラクチャ要件を最小限に抑えることを目的としており、既存のパスワードインフラストラクチャをイニシエーターに活用できることが期待されています。一部の環境では、ホストごとのパスワードはまだ存在しません。ホストごとのプリンシパルに証明書が使用されている場合、追加のパスワードインフラストラクチャは必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In cases when a host is both an NFS client and server, it can share the same per-host certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ホストがNFSクライアントとサーバーの両方である場合、同じホストごとの証明書を共有できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Filehandles">
4. Filehandles
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. ファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The filehandle in the NFS protocol is a per server unique identifier for a filesystem object. The contents of the filehandle are opaque to the client. Therefore, the server is responsible for translating the filehandle to an internal representation of the filesystem object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSプロトコルのファイルハンドルは、ファイルシステムオブジェクトのサーバーごとの一意の識別子です。ファイルハンドルの内容はクライアントに対して不透明です。したがって、サーバーは、ファイルハンドルをファイルシステムオブジェクトの内部表現に変換する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--Obtaining-the-First-Filehandle">
4.1. Obtaining the First Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 最初のファイルハンドルを取得する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The operations of the NFS protocol are defined in terms of one or more filehandles. Therefore, the client needs a filehandle to initiate communication with the server. With the NFS version 2 protocol [RFC1094] and the NFS version 3 protocol [RFC1813], there exists an ancillary protocol to obtain this first filehandle. The MOUNT protocol, RPC program number 100005, provides the mechanism of translating a string based filesystem path name to a filehandle which can then be used by the NFS protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSプロトコルの操作は、1つ以上のファイルハンドルで定義されます。したがって、クライアントはサーバーとの通信を開始するためにファイルハンドルを必要とします。 NFSバージョン2プロトコル[RFC1094]およびNFSバージョン3プロトコル[RFC1813]を使用すると、この最初のファイルハンドルを取得するための補助プロトコルが存在します。 MOUNTプロトコル（RPCプログラム番号100005）は、文字列ベースのファイルシステムパス名を、NFSプロトコルで使用できるファイルハンドルに変換するメカニズムを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MOUNT protocol has deficiencies in the area of security and use via firewalls. This is one reason that the use of the public filehandle was introduced in [RFC2054] and [RFC2055]. With the use of the public filehandle in combination with the LOOKUP operation in the NFS version 2 and 3 protocols, it has been demonstrated that the MOUNT protocol is unnecessary for viable interaction between NFS client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MOUNTプロトコルには、セキュリティおよびファイアウォール経由の使用の分野での欠点があります。これは、パブリックファイルハンドルの使用が[RFC2054]と[RFC2055]で導入された1つの理由です。 NFSバージョン2および3プロトコルでのLOOKUP操作と組み合わせてパブリックファイルハンドルを使用すると、NFSクライアントとサーバー間の実行可能な対話にはMOUNTプロトコルが不要であることが実証されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, the NFS version 4 protocol will not use an ancillary protocol for translation from string based path names to a filehandle. Two special filehandles will be used as starting points for the NFS client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、NFSバージョン4プロトコルは、文字列ベースのパス名からファイルハンドルへの変換に補助プロトコルを使用しません。 NFSクライアントの開始点として、2つの特別なファイルハンドルが使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1-1--Root-Filehandle">
4.1.1. Root Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. ルートファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first of the special filehandles is the ROOT filehandle. The ROOT filehandle is the &#34;conceptual&#34; root of the filesystem name space at the NFS server. The client uses or starts with the ROOT filehandle by employing the PUTROOTFH operation. The PUTROOTFH operation instructs the server to set the &#34;current&#34; filehandle to the ROOT of the server&#39;s file tree. Once this PUTROOTFH operation is used, the client can then traverse the entirety of the server&#39;s file tree with the LOOKUP operation. A complete discussion of the server name space is in the section &#34;NFS Server Name Space&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の特別なファイルハンドルはROOTファイルハンドルです。 ROOTファイルハンドルは、NFSサーバーでのファイルシステム名前空間の「概念的な」ルートです。クライアントは、PUTROOTFH操作を使用して、ROOTファイルハンドルを使用するか、ROOTファイルハンドルで開始します。 PUTROOTFH操作は、「現在の」ファイルハンドルをサーバーのファイルツリーのROOTに設定するようサーバーに指示します。このPUTROOTFH操作を使用すると、クライアントはLOOKUP操作を使用してサーバーのファイルツリー全体をトラバースできます。サーバーの名前空間の詳細については、「NFSサーバーの名前空間」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1-2--Public-Filehandle">
4.1.2. Public Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. 公開ファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second special filehandle is the PUBLIC filehandle. Unlike the ROOT filehandle, the PUBLIC filehandle may be bound or represent an arbitrary filesystem object at the server. The server is responsible for this binding. It may be that the PUBLIC filehandle and the ROOT filehandle refer to the same filesystem object. However, it is up to the administrative software at the server and the policies of the server administrator to define the binding of the PUBLIC filehandle and server filesystem object. The client may not make any assumptions about this binding. The client uses the PUBLIC filehandle via the PUTPUBFH operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2番目の特別なファイルハンドルはPUBLICファイルハンドルです。 ROOTファイルハンドルとは異なり、PUBLICファイルハンドルはバインドされるか、サーバーで任意のファイルシステムオブジェクトを表す場合があります。サーバーはこのバインディングを担当します。 PUBLICファイルハンドルとROOTファイルハンドルが同じファイルシステムオブジェクトを参照している可能性があります。ただし、PUBLICファイルハンドルとサーバーファイルシステムオブジェクトのバインディングを定義するのは、サーバーの管理ソフトウェアとサーバー管理者のポリシー次第です。クライアントは、このバインディングについて何も想定していません。クライアントは、PUTPUBFH操作を介してPUBLICファイルハンドルを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2--Filehandle-Types">
4.2. Filehandle Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. ファイルハンドルのタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the NFS version 2 and 3 protocols, there was one type of filehandle with a single set of semantics. This type of filehandle is termed &#34;persistent&#34; in NFS Version 4. The semantics of a persistent filehandle remain the same as before. A new type of filehandle introduced in NFS Version 4 is the &#34;volatile&#34; filehandle, which attempts to accommodate certain server environments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン2および3プロトコルでは、単一のセマンティクスのセットを持つ1種類のファイルハンドルがありました。このタイプのファイルハンドルは、NFSバージョン4では「永続的」と呼ばれています。永続的ファイルハンドルのセマンティクスは以前と同じです。 NFSバージョン4で導入された新しいタイプのファイルハンドルは、「揮発性」ファイルハンドルであり、特定のサーバー環境に対応しようとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The volatile filehandle type was introduced to address server functionality or implementation issues which make correct implementation of a persistent filehandle infeasible. Some server environments do not provide a filesystem level invariant that can be used to construct a persistent filehandle. The underlying server filesystem may not provide the invariant or the server&#39;s filesystem programming interfaces may not provide access to the needed invariant. Volatile filehandles may ease the implementation of server functionality such as hierarchical storage management or filesystem reorganization or migration. However, the volatile filehandle increases the implementation burden for the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性ファイルハンドルタイプは、永続ファイルハンドルの正しい実装を実行不可能にするサーバーの機能または実装の問題に対処するために導入されました。一部のサーバー環境では、永続的なファイルハンドルの構築に使用できるファイルシステムレベルの不変条件を提供していません。基盤となるサーバーのファイルシステムが不変条件を提供していないか、サーバーのファイルシステムのプログラミングインターフェイスが必要な不変条件へのアクセスを提供していない可能性があります。揮発性ファイルハンドルにより、階層ストレージ管理やファイルシステムの再編成や移行などのサーバー機能の実装が容易になる場合があります。ただし、揮発性ファイルハンドルは、クライアントの実装負担を増やします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the client will need to handle persistent and volatile filehandles differently, a file attribute is defined which may be used by the client to determine the filehandle types being returned by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは永続的なファイルハンドルと揮発性のファイルハンドルを別々に処理する必要があるため、サーバーによって返されるファイルハンドルのタイプを決定するためにクライアントが使用できるファイル属性が定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2-1--General-Properties-of-a-Filehandle">
4.2.1. General Properties of a Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. ファイルハンドルの一般的なプロパティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The filehandle contains all the information the server needs to distinguish an individual file. To the client, the filehandle is opaque. The client stores filehandles for use in a later request and can compare two filehandles from the same server for equality by doing a byte-by-byte comparison. However, the client MUST NOT otherwise interpret the contents of filehandles. If two filehandles from the same server are equal, they MUST refer to the same file. Servers SHOULD try to maintain a one-to-one correspondence between filehandles and files but this is not required. Clients MUST use filehandle comparisons only to improve performance, not for correct behavior. All clients need to be prepared for situations in which it cannot be determined whether two filehandles denote the same object and in such cases, avoid making invalid assumptions which might cause incorrect behavior. Further discussion of filehandle and attribute comparison in the context of data caching is presented in the section &#34;Data Caching and File Identity&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルハンドルには、サーバーが個々のファイルを識別するために必要なすべての情報が含まれています。クライアントにとって、ファイルハンドルは不透明です。クライアントは、後の要求で使用するためにファイルハンドルを格納し、バイトごとの比較を行うことにより、同じサーバーからの2つのファイルハンドルが等しいかどうかを比較できます。ただし、クライアントはファイルハンドルの内容を別の方法で解釈してはなりません（MUST NOT）。同じサーバーからの2つのファイルハンドルが等しい場合、それらは同じファイルを参照する必要があります。サーバーは、ファイルハンドルとファイル間の1対1の対応を維持するように努めるべきですが、これは必須ではありません。クライアントは、正しい動作ではなく、パフォーマンスを向上させるためにのみファイルハンドル比較を使用する必要があります。すべてのクライアントは、2つのファイルハンドルが同じオブジェクトを示しているかどうかを判断できない状況に備える必要があります。そのような場合は、正しくない動作を引き起こす可能性のある無効な仮定を行わないでください。データキャッシュのコンテキストでのファイルハンドルと属性比較の詳細については、「データキャッシュとファイルID」のセクションで説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example, in the case that two different path names when traversed at the server terminate at the same filesystem object, the server SHOULD return the same filehandle for each path. This can occur if a hard link is used to create two file names which refer to the same underlying file object and associated data. For example, if paths /a/b/c and /a/d/c refer to the same file, the server SHOULD return the same filehandle for both path names traversals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例として、サーバーでトラバースしたときに2つの異なるパス名が同じファイルシステムオブジェクトで終了する場合、サーバーは各パスに対して同じファイルハンドルを返す必要があります（SHOULD）。これは、ハードリンクを使用して、同じ基本ファイルオブジェクトと関連データを参照する2つのファイル名を作成する場合に発生する可能性があります。たとえば、パス/ a / b / cと/ a / d / cが同じファイルを参照する場合、サーバーは両方のパス名トラバーサルに対して同じファイルハンドルを返す必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2-2--Persistent-Filehandle">
4.2.2. Persistent Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. 永続的なファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A persistent filehandle is defined as having a fixed value for the lifetime of the filesystem object to which it refers. Once the server creates the filehandle for a filesystem object, the server MUST accept the same filehandle for the object for the lifetime of the object. If the server restarts or reboots the NFS server must honor the same filehandle value as it did in the server&#39;s previous instantiation. Similarly, if the filesystem is migrated, the new NFS server must honor the same filehandle as the old NFS server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
永続ファイルハンドルは、それが参照するファイルシステムオブジェクトの存続期間中、固定値を持つと定義されています。サーバーがファイルシステムオブジェクトのファイルハンドルを作成したら、サーバーはオブジェクトの存続期間中、オブジェクトの同じファイルハンドルを受け入れる必要があります。サーバーが再起動または再起動する場合、NFSサーバーはサーバーの以前のインスタンス化と同じファイルハンドル値を受け入れる必要があります。同様に、ファイルシステムが移行される場合、新しいNFSサーバーは古いNFSサーバーと同じファイルハンドルを受け入れる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The persistent filehandle will be become stale or invalid when the filesystem object is removed. When the server is presented with a persistent filehandle that refers to a deleted object, it MUST return an error of NFS4ERR_STALE. A filehandle may become stale when the filesystem containing the object is no longer available. The file system may become unavailable if it exists on removable media and the media is no longer available at the server or the filesystem in whole has been destroyed or the filesystem has simply been removed from the server&#39;s name space (i.e., unmounted in a UNIX environment).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
永続ファイルハンドルは、ファイルシステムオブジェクトが削除されると、古くなるか無効になります。サーバーが、削除されたオブジェクトを参照する永続的なファイルハンドルを提示されると、NFS4ERR_STALEのエラーを返さなければなりません（MUST）。オブジェクトを含むファイルシステムが利用できなくなると、ファイルハンドルが古くなる場合があります。ファイルシステムがリムーバブルメディアに存在し、サーバーでメディアが利用できなくなった場合、またはファイルシステム全体が破壊された場合、またはファイルシステムがサーバーの名前空間から削除された場合（つまり、UNIX環境でマウント解除された場合） ）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2-3--Volatile-Filehandle">
4.2.3. Volatile Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3. 揮発性ファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A volatile filehandle does not share the same longevity characteristics of a persistent filehandle. The server may determine that a volatile filehandle is no longer valid at many different points in time. If the server can definitively determine that a volatile filehandle refers to an object that has been removed, the server should return NFS4ERR_STALE to the client (as is the case for persistent filehandles). In all other cases where the server determines that a volatile filehandle can no longer be used, it should return an error of NFS4ERR_FHEXPIRED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性ファイルハンドルは、永続ファイルハンドルと同じ寿命特性を共有しません。サーバーは、揮発性ファイルハンドルが多くの異なる時点で有効ではなくなったと判断する場合があります。揮発性ファイルハンドルが削除されたオブジェクトを参照しているとサーバーが明確に判断できる場合、サーバーはNFS4ERR_STALEをクライアントに返す必要があります（永続ファイルハンドルの場合と同様）。揮発性ファイルハンドルが使用できなくなったとサーバーが判断する他のすべてのケースでは、NFS4ERR_FHEXPIREDのエラーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mandatory attribute &#34;fh_expire_type&#34; is used by the client to determine what type of filehandle the server is providing for a particular filesystem. This attribute is a bitmask with the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必須属性「fh_expire_type」は、サーバーが特定のファイルシステムに提供しているファイルハンドルのタイプを決定するためにクライアントによって使用されます。この属性は、次の値を持つビットマスクです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_PERSISTENT The value of FH4_PERSISTENT is used to indicate a persistent filehandle, which is valid until the object is removed from the filesystem. The server will not return NFS4ERR_FHEXPIRED for this filehandle. FH4_PERSISTENT is defined as a value in which none of the bits specified below are set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_PERSISTENT FH4_PERSISTENTの値は、オブジェクトがファイルシステムから削除されるまで有効な永続的なファイルハンドルを示すために使用されます。サーバーは、このファイルハンドルに対してNFS4ERR_FHEXPIREDを返しません。 FH4_PERSISTENTは、以下に指定されたビットが設定されていない値として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOLATILE_ANY The filehandle may expire at any time, except as specifically excluded (i.e., FH4_NO_EXPIRE_WITH_OPEN).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOLATILE_ANYファイルハンドルは、明確に除外されている場合（FH4_NO_EXPIRE_WITH_OPENなど）を除き、いつでも期限切れになる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_NOEXPIRE_WITH_OPEN May only be set when FH4_VOLATILE_ANY is set. If this bit is set, then the meaning of FH4_VOLATILE_ANY is qualified to exclude any expiration of the filehandle when it is open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_NOEXPIRE_WITH_OPEN FH4_VOLATILE_ANYが設定されている場合にのみ設定できます。このビットが設定されている場合、FH4_VOLATILE_ANYの意味は、ファイルハンドルが開いているときにファイルハンドルの有効期限を除外するように修飾されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOL_MIGRATION The filehandle will expire as a result of migration. If FH4_VOL_ANY is set, FH4_VOL_MIGRATION is redundant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOL_MIGRATIONファイルハンドルは、移行の結果として期限切れになります。 FH4_VOL_ANYが設定されている場合、FH4_VOL_MIGRATIONは冗長です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOL_RENAME The filehandle will expire during rename. This includes a rename by the requesting client or a rename by any other client. If FH4_VOL_ANY is set, FH4_VOL_RENAME is redundant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOL_RENAMEファイルハンドルは名前変更中に期限切れになります。これには、要求元クライアントによる名前変更、または他のクライアントによる名前変更が含まれます。 FH4_VOL_ANYが設定されている場合、FH4_VOL_RENAMEは冗長です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers which provide volatile filehandles that may expire while open (i.e., if FH4_VOL_MIGRATION or FH4_VOL_RENAME is set or if FH4_VOLATILE_ANY is set and FH4_NOEXPIRE_WITH_OPEN not set), should deny a RENAME or REMOVE that would affect an OPEN file of any of the components leading to the OPEN file. In addition, the server should deny all RENAME or REMOVE requests during the grace period upon server restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オープン中に期限切れになる可能性のある揮発性ファイルハンドルを提供するサーバー（つまり、FH4_VOL_MIGRATIONまたはFH4_VOL_RENAMEが設定されている場合、またはFH4_VOLATILE_ANYが設定され、FH4_NOEXPIRE_WITH_OPENが設定されていない場合）は、ファイルを開く。さらに、サーバーは、サーバーの再起動時の猶予期間中、すべてのRENAMEまたはREMOVE要求を拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the bits FH4_VOL_MIGRATION and FH4_VOL_RENAME allow the client to determine that expiration has occurred whenever a specific event occurs, without an explicit filehandle expiration error from the server. FH4_VOL_ANY does not provide this form of information. In situations where the server will expire many, but not all filehandles upon migration (e.g., all but those that are open), FH4_VOLATILE_ANY (in this case with FH4_NOEXPIRE_WITH_OPEN) is a better choice since the client may not assume that all filehandles will expire when migration occurs, and it is likely that additional expirations will occur (as a result of file CLOSE) that are separated in time from the migration event itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOL_MIGRATIONビットとFH4_VOL_RENAMEビットを使用すると、クライアントは、サーバーからの明示的なファイルハンドル有効期限エラーなしで、特定のイベントが発生するたびに有効期限が発生したと判断できます。 FH4_VOL_ANYは、この形式の情報を提供しません。移行時にサーバーが多くのファイルハンドルを期限切れにする状況（たとえば、開いているファイルハンドルを除くすべて）では、FH4_VOLATILE_ANY（この場合はFH4_NOEXPIRE_WITH_OPEN）は、クライアントがすべてのファイルハンドルが期限切れになると想定しない場合があるため、より適切な選択です。移行が発生し、移行イベント自体から時間的に分離された（ファイルのCLOSEの結果として）追加の有効期限が発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2-4--One-Method-of-Constructing-a-Volatile-Filehandle">
4.2.4. One Method of Constructing a Volatile Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.4. 揮発性ファイルハンドルを構築する1つの方法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A volatile filehandle, while opaque to the client could contain:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性のファイルハンドル。ただし、クライアントには不透明です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[volatile bit = 1 | server boot time | slot | generation number]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[揮発性ビット= 1 |サーバーの起動時間|スロット|世代番号]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o slot is an index in the server volatile filehandle table
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o スロットは、サーバーの揮発性ファイルハンドルテーブルのインデックスです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o generation number is the generation number for the table entry/slot
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 世代番号は、テーブルエントリ/スロットの世代番号です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client presents a volatile filehandle, the server makes the following checks, which assume that the check for the volatile bit has passed. If the server boot time is less than the current server boot time, return NFS4ERR_FHEXPIRED. If slot is out of range, return NFS4ERR_BADHANDLE. If the generation number does not match, return NFS4ERR_FHEXPIRED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが揮発性ファイルハンドルを提示すると、サーバーは次のチェックを行います。これは、揮発性ビットのチェックに合格したことを前提としています。サーバーの起動時間が現在のサーバーの起動時間よりも短い場合は、NFS4ERR_FHEXPIREDを返します。スロットが範囲外の場合は、NFS4ERR_BADHANDLEを返します。世代番号が一致しない場合は、NFS4ERR_FHEXPIREDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server reboots, the table is gone (it is volatile).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが再起動すると、テーブルは消えます（揮発性です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If volatile bit is 0, then it is a persistent filehandle with a different structure following it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性ビットが0の場合、それはその後に別の構造を持つ永続ファイルハンドルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3--Client-Recovery-from-Filehandle-Expiration">
4.3. Client Recovery from Filehandle Expiration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. ファイルハンドルの有効期限からのクライアントの回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If possible, the client SHOULD recover from the receipt of an NFS4ERR_FHEXPIRED error. The client must take on additional responsibility so that it may prepare itself to recover from the expiration of a volatile filehandle. If the server returns persistent filehandles, the client does not need these additional steps.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可能であれば、クライアントはNFS4ERR_FHEXPIREDエラーの受信から回復する必要があります（SHOULD）。クライアントは、揮発性ファイルハンドルの期限切れから回復する準備をするために、追加の責任を負う必要があります。サーバーが永続的なファイルハンドルを返す場合、クライアントはこれらの追加手順を必要としません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For volatile filehandles, most commonly the client will need to store the component names leading up to and including the filesystem object in question. With these names, the client should be able to recover by finding a filehandle in the name space that is still available or by starting at the root of the server&#39;s filesystem name space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性ファイルハンドルの場合、最も一般的には、クライアントは問題のファイルシステムオブジェクトに至るまでのコンポーネント名を格納する必要があります。これらの名前を使用すると、クライアントは、まだ使用可能な名前空間でファイルハンドルを見つけるか、サーバーのファイルシステム名前空間のルートから開始することで回復できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the expired filehandle refers to an object that has been removed from the filesystem, obviously the client will not be able to recover from the expired filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
期限切れのファイルハンドルがファイルシステムから削除されたオブジェクトを参照している場合、明らかにクライアントは期限切れのファイルハンドルから回復することができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is also possible that the expired filehandle refers to a file that has been renamed. If the file was renamed by another client, again it is possible that the original client will not be able to recover. However, in the case that the client itself is renaming the file and the file is open, it is possible that the client may be able to recover. The client can determine the new path name based on the processing of the rename request. The client can then regenerate the new filehandle based on the new path name. The client could also use the compound operation mechanism to construct a set of operations like: RENAME A B LOOKUP B GETFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
期限切れのファイルハンドルが名前が変更されたファイルを参照している可能性もあります。ファイルの名前が別のクライアントによって変更された場合、元のクライアントが回復できない可能性があります。ただし、クライアント自体がファイルの名前を変更していて、ファイルが開いている場合は、クライアントが回復できる可能性があります。クライアントは、名前変更要求の処理に基づいて新しいパス名を決定できます。その後、クライアントは新しいパス名に基づいて新しいファイルハンドルを再生成できます。クライアントは、複合操作メカニズムを使用して、次のような一連の操作を作成することもできます。RENAME A B LOOKUP B GETFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the COMPOUND procedure does not provide atomicity. This example only reduces the overhead of recovering from an expired filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャは原子性を提供しないことに注意してください。この例では、期限切れのファイルハンドルからの回復のオーバーヘッドのみを削減します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--File-Attributes">
5. File Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. ファイル属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To meet the requirements of extensibility and increased interoperability with non-UNIX platforms, attributes must be handled in a flexible manner. The NFS version 3 fattr3 structure contains a fixed list of attributes that not all clients and servers are able to support or care about. The fattr3 structure can not be extended as new needs arise and it provides no way to indicate non-support. With the NFS version 4 protocol, the client is able query what attributes the server supports and construct requests with only those supported attributes (or a subset thereof).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNIX以外のプラットフォームとの拡張性および相互運用性の要件を満たすには、属性を柔軟に処理する必要があります。 NFSバージョン3のfattr3構造には、すべてのクライアントとサーバーがサポートまたは処理できる属性の固定リストが含まれています。新しい必要性が生じた場合、fattr3構造は拡張できず、サポートされていないことを示す方法はありません。 NFSバージョン4プロトコルを使用すると、クライアントはサーバーがサポートする属性を照会し、サポートされている属性（またはそのサブセット）のみを使用して要求を作成できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To this end, attributes are divided into three groups: mandatory, recommended, and named. Both mandatory and recommended attributes are supported in the NFS version 4 protocol by a specific and well-defined encoding and are identified by number. They are requested by setting a bit in the bit vector sent in the GETATTR request; the server response includes a bit vector to list what attributes were returned in the response. New mandatory or recommended attributes may be added to the NFS protocol between major revisions by publishing a standards-track RFC which allocates a new attribute number value and defines the encoding for the attribute. See the section &#34;Minor Versioning&#34; for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このため、属性は必須、推奨、名前付きの3つのグループに分類されます。必須属性と推奨属性は、NFSバージョン4プロトコルで特定の明確に定義されたエンコーディングによってサポートされ、番号で識別されます。これらは、GETATTR要求で送信されたビットベクトルにビットを設定することによって要求されます。サーバー応答には、応答で返された属性をリストするビットベクトルが含まれています。新しい必須または推奨の属性は、新しい属性番号の値を割り当て、属性のエンコーディングを定義する標準トラックRFCを公開することにより、メジャーリビジョン間のNFSプロトコルに追加できます。詳細については、「マイナーバージョン管理」のセクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Named attributes are accessed by the new OPENATTR operation, which accesses a hidden directory of attributes associated with a file system object. OPENATTR takes a filehandle for the object and returns the filehandle for the attribute hierarchy. The filehandle for the named attributes is a directory object accessible by LOOKUP or READDIR and contains files whose names represent the named attributes and whose data bytes are the value of the attribute. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前付き属性は、ファイルシステムオブジェクトに関連付けられた属性の非表示ディレクトリにアクセスする新しいOPENATTR操作によってアクセスされます。 OPENATTRはオブジェクトのファイルハンドルを受け取り、属性階層のファイルハンドルを返します。名前付き属性のファイルハンドルは、LOOKUPまたはREADDIRによってアクセス可能なディレクトリオブジェクトであり、名前が名前付き属性を表し、データバイトが属性の値であるファイルが含まれています。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
LOOKUP &#34;foo&#34; ; look up file GETATTR attrbits OPENATTR ; access foo&#39;s named attributes LOOKUP &#34;x11icon&#34; ; look up specific attribute READ 0,4096 ; read stream of bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
LOOKUP &#34;foo&#34;;ファイルGETATTR attrbits OPENATTRを検索します。 fooの名前付き属性にアクセスLOOKUP &#34;x11icon&#34;;特定の属性READ 0,4096を検索します。バイトのストリームを読み取る
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Named attributes are intended for data needed by applications rather than by an NFS client implementation. NFS implementors are strongly encouraged to define their new attributes as recommended attributes by bringing them to the IETF standards-track process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前付き属性は、NFSクライアント実装ではなく、アプリケーションが必要とするデータを対象としています。 NFS実装者は、IETF標準化プロセスにそれらを持ち込むことにより、推奨属性として新しい属性を定義することを強くお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set of attributes which are classified as mandatory is deliberately small since servers must do whatever it takes to support them. A server should support as many of the recommended attributes as possible but by their definition, the server is not required to support all of them. Attributes are deemed mandatory if the data is both needed by a large number of clients and is not otherwise reasonably computable by the client when support is not provided on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは属性をサポートするために必要なことを何でも行う必要があるため、必須として分類される属性のセットは意図的に小さくなっています。サーバーは可能な限り多くの推奨属性をサポートする必要がありますが、その定義により、サーバーはすべての属性をサポートする必要はありません。多数のクライアントがデータを必要とし、サーバーでサポートが提供されていない場合にクライアントが合理的に計算できない場合、属性は必須と見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the hidden directory returned by OPENATTR is a convenience for protocol processing. The client should not make any assumptions about the server&#39;s implementation of named attributes and whether the underlying filesystem at the server has a named attribute directory or not. Therefore, operations such as SETATTR and GETATTR on the named attribute directory are undefined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENATTRによって返される隠しディレクトリは、プロトコル処理に便利です。クライアントは、サーバーの名前付き属性の実装について、およびサーバーの基礎となるファイルシステムに名前付き属性のディレクトリがあるかどうかについて、何も想定しないでください。したがって、名前付き属性ディレクトリーに対するSETATTRやGETATTRなどの操作は未定義です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1--Mandatory-Attributes">
5.1. Mandatory Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. 必須属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These MUST be supported by every NFS version 4 client and server in order to ensure a minimum level of interoperability. The server must store and return these attributes and the client must be able to function with an attribute set limited to these attributes. With just the mandatory attributes some client functionality may be impaired or limited in some ways. A client may ask for any of these attributes to be returned by setting a bit in the GETATTR request and the server must return their value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最小レベルの相互運用性を確保するために、これらはすべてのNFSバージョン4クライアントとサーバーでサポートされる必要があります。サーバーはこれらの属性を格納して返す必要があり、クライアントはこれらの属性に制限された属性セットで機能できる必要があります。必須属性だけでは、クライアント機能の一部が何らかの方法で損なわれたり制限されたりする場合があります。クライアントは、GETATTR要求にビットを設定することにより、これらの属性のいずれかが返されるように要求する場合があり、サーバーはそれらの属性を返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2--Recommended-Attributes">
5.2. Recommended Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. 推奨属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These attributes are understood well enough to warrant support in the NFS version 4 protocol. However, they may not be supported on all clients and servers. A client may ask for any of these attributes to be returned by setting a bit in the GETATTR request but must handle the case where the server does not return them. A client may ask for the set of attributes the server supports and should not request attributes the server does not support. A server should be tolerant of requests for unsupported attributes and simply not return them rather than considering the request an error. It is expected that servers will support all attributes they comfortably can and only fail to support attributes which are difficult to support in their operating environments. A server should provide attributes whenever they don&#39;t have to &#34;tell lies&#34; to the client. For example, a file modification time should be either an accurate time or should not be supported by the server. This will not always be comfortable to clients but the client is better positioned decide whether and how to fabricate or construct an attribute or whether to do without the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの属性は、NFSバージョン4プロトコルでのサポートを保証するのに十分に理解されています。ただし、すべてのクライアントとサーバーでサポートされているとは限りません。クライアントは、GETATTR要求にビットを設定することにより、これらの属性のいずれかが返されるように要求できますが、サーバーがそれらの属性を返さない場合を処理する必要があります。クライアントは、サーバーがサポートする属性のセットを要求する場合があり、サーバーがサポートしない属性を要求してはなりません。サーバーは、サポートされていない属性の要求に対して寛容であり、要求をエラーと見なすのではなく、単にそれらを返さないようにする必要があります。サーバーは快適にできるすべての属性をサポートし、オペレーティング環境でサポートするのが難しい属性のサポートにのみ失敗することが予想されます。サーバーは、クライアントに「嘘をつく」必要がない場合はいつでも属性を提供する必要があります。たとえば、ファイルの変更時刻は正確な時刻であるか、サーバーでサポートされていない必要があります。これはクライアントにとって常に快適であるとは限りませんが、クライアントは、属性を作成または構築するかどうか、またどのように作成するか、または属性なしで実行するかどうかを決定するのに適しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-3--Named-Attributes">
5.3. Named Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. 名前付き属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These attributes are not supported by direct encoding in the NFS Version 4 protocol but are accessed by string names rather than numbers and correspond to an uninterpreted stream of bytes which are stored with the filesystem object. The name space for these attributes may be accessed by using the OPENATTR operation. The OPENATTR operation returns a filehandle for a virtual &#34;attribute directory&#34; and further perusal of the name space may be done using READDIR and LOOKUP operations on this filehandle. Named attributes may then be examined or changed by normal READ and WRITE and CREATE operations on the filehandles returned from READDIR and LOOKUP. Named attributes may have attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの属性は、NFSバージョン4プロトコルの直接エンコーディングではサポートされていませんが、数値ではなく文字列名でアクセスされ、ファイルシステムオブジェクトに格納されている未解釈のバイトストリームに対応しています。これらの属性の名前空間には、OPENATTR操作を使用してアクセスできます。 OPENATTR操作は、仮想「属性ディレクトリ」のファイルハンドルを返し、このファイルハンドルでREADDIRおよびLOOKUP操作を使用して、名前空間をさらに詳しく調べることができます。次に、名前付き属性は、READDIRおよびLOOKUPから返されたファイルハンドルに対する通常のREADおよびWRITEおよびCREATE操作によって検査または変更できます。名前付き属性には属性を含めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is recommended that servers support arbitrary named attributes. A client should not depend on the ability to store any named attributes in the server&#39;s filesystem. If a server does support named attributes, a client which is also able to handle them should be able to copy a file&#39;s data and meta-data with complete transparency from one location to another; this would imply that names allowed for regular directory entries are valid for named attribute names as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが任意の名前付き属性をサポートすることをお勧めします。クライアントは、サーバーのファイルシステムに名前付き属性を格納する機能に依存すべきではありません。サーバーが名前付き属性をサポートしている場合、それらも処理できるクライアントは、ある場所から別の場所に完全に透過的にファイルのデータとメタデータをコピーできるはずです。これは、通常のディレクトリエントリに許可されている名前が名前付き属性名にも有効であることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Names of attributes will not be controlled by this document or other IETF standards track documents. See the section &#34;IANA Considerations&#34; for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性の名前は、このドキュメントまたは他のIETF標準トラックドキュメントによって制御されません。詳細については、「IANAに関する考慮事項」のセクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-4--Classification-of-Attributes">
5.4. Classification of Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. 属性の分類
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each of the Mandatory and Recommended attributes can be classified in one of three categories: per server, per filesystem, or per filesystem object. Note that it is possible that some per filesystem attributes may vary within the filesystem. See the &#34;homogeneous&#34; attribute for its definition. Note that the attributes time_access_set and time_modify_set are not listed in this section because they are write-only attributes corresponding to time_access and time_modify, and are used in a special instance of SETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必須属性と推奨属性はそれぞれ、サーバーごと、ファイルシステムごと、またはファイルシステムオブジェクトごとの3つのカテゴリのいずれかに分類できます。ファイルシステムごとの属性の一部がファイルシステム内で異なる可能性があることに注意してください。その定義については、「同種」属性を参照してください。属性time_access_setおよびtime_modify_setは、time_accessおよびtime_modifyに対応する書き込み専用属性であり、SETATTRの特別なインスタンスで使用されるため、このセクションにはリストされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The per server attribute is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーごとの属性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
lease_time
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
リース時間
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The per filesystem attributes are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルシステムごとの属性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
supp_attr, fh_expire_type, link_support, symlink_support, unique_handles, aclsupport, cansettime, case_insensitive, case_preserving, chown_restricted, files_avail, files_free, files_total, fs_locations, homogeneous, maxfilesize, maxname, maxread, maxwrite, no_trunc, space_avail, space_free, space_total, time_delta
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
supp_attr、fh_expire_type、link_support、symlink_support、unique_handles、aclsupport、cansettime、case_insensitive、case_preserving、chown_restricted、files_avail、files_free、files_total、fs_locations、同種、maxfilesize、maxname、maxread、maxwrite、no_trunc、space_avdelta、space_avail、space_avail
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The per filesystem object attributes are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルシステムごとのオブジェクト属性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
type, change, size, named_attr, fsid, rdattr_error, filehandle, ACL, archive, fileid, hidden, maxlink, mimetype, mode, numlinks, owner, owner_group, rawdev, space_used, system, time_access, time_backup, time_create, time_metadata, time_modify, mounted_on_fileid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
type、change、size、named_attr、fsid、rdattr_error、filehandle、ACL、archive、fileid、hidden、maxlink、mimetype、mode、numlinks、owner、owner_group、rawdev、space_used、system、time_access、time_backup、time_create、time_metadata、time_modify、 Mounted_on_fileid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For quota_avail_hard, quota_avail_soft, and quota_used see their definitions below for the appropriate classification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_avail_hard、quota_avail_soft、およびquota_usedの適切な分類については、以下の定義を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-5--Mandatory-Attributes---Definitions">
5.5. Mandatory Attributes - Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. 必須属性-定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Name              #    DataType     Access   Description
   ___________________________________________________________________
   supp_attr         0    bitmap       READ     The bit vector which
                                                would retrieve all
                                                mandatory and
                                                recommended attributes
                                                that are supported for
                                                this object.  The
                                                scope of this
                                                attribute applies to
                                                all objects with a
                                                matching fsid.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type 1 nfs4_ftype READ The type of the object (file, directory, symlink, etc.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプ1 nfs4_ftype READオブジェクトのタイプ（ファイル、ディレクトリ、シンボリックリンクなど）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fh_expire_type 2 uint32 READ Server uses this to specify filehandle expiration behavior to the client. See the section &#34;Filehandles&#34; for additional description.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fh_expire_type 2 uint32 READサーバーはこれを使用して、ファイルハンドルの有効期限の動作をクライアントに指定します。詳細については、「ファイルハンドル」のセクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
change 3 uint64 READ A value created by the server that the client can use to determine if file data, directory contents or attributes of the object have been modified. The server may return the object&#39;s time_metadata attribute for this attribute&#39;s value but only if the filesystem object can not be updated more frequently than the resolution of time_metadata.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
change 3 uint64 READサーバーによって作成された値で、クライアントがオブジェクトのファイルデータ、ディレクトリの内容、または属性が変更されたかどうかを判断するために使用できます。サーバーは、この属性の値に対してオブジェクトのtime_metadata属性を返すことがありますが、それは、ファイルシステムオブジェクトがtime_metadataの解決よりも頻繁に更新できない場合に限られます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
size 4 uint64 R/W The size of the object in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
size 4 uint64 R / Wオブジェクトのサイズ（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
link_support 5 bool READ True, if the object&#39;s filesystem supports hard links.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
link_support 5 bool READ True、オブジェクトのファイルシステムがハードリンクをサポートしている場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
symlink_support 6 bool READ True, if the object&#39;s filesystem supports symbolic links.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
symlink_support 6 bool READ True、オブジェクトのファイルシステムがシンボリックリンクをサポートしている場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
named_attr 7 bool READ True, if this object has named attributes. In other words, object has a non-empty named attribute directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
named_attr 7 bool READ True、このオブジェクトに名前付き属性がある場合。つまり、オブジェクトには空でない名前付き属性ディレクトリがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fsid 8 fsid4 READ Unique filesystem identifier for the filesystem holding this object. fsid contains major and minor components each of which are uint64.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fsid 8 fsid4 READこのオブジェクトを保持するファイルシステムの一意のファイルシステム識別子。 fsidには、uint64であるメジャーコンポーネントとマイナーコンポーネントが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unique_handles 9 bool READ True, if two distinct filehandles guaranteed to refer to two different filesystem objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unique_handles 9 bool READ True、2つの異なるファイルハンドルが2つの異なるファイルシステムオブジェクトを参照することが保証されている場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
lease_time 10 nfs_lease4 READ Duration of leases at server in seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
lease_time 10 nfs_lease4 READサーバーでのリース期間（秒単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rdattr_error 11 enum READ Error returned from getattr during readdir.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rdattr_error 11列挙型READ READDIR中にgetattrから返されたREADエラー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
filehandle 19 nfs_fh4 READ The filehandle of this object (primarily for readdir requests).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
filehandle 19 nfs_fh4 READこのオブジェクトのファイルハンドル（主にreaddirリクエスト用）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-6--Recommended-Attributes---Definitions">
5.6. Recommended Attributes - Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6. 推奨属性-定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Name                #    Data Type      Access   Description
   _____________________________________________________________________
   ACL                 12   nfsace4&lt;&gt;      R/W      The access control
                                                    list for the object.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
aclsupport 13 uint32 READ Indicates what types of ACLs are supported on the current filesystem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
aclsupport 13 uint32 READ現在のファイルシステムでサポートされているACLのタイプを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
archive 14 bool R/W True, if this file has been archived since the time of last modification (deprecated in favor of time_backup).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
archive 14 bool R / W True、このファイルが最後に変更された時刻以降にアーカイブされている場合（time_backupの代わりに非推奨）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cansettime 15 bool READ True, if the server is able to change the times for a filesystem object as specified in a SETATTR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cansettime 15 bool READサーバーがSETATTR操作で指定されたファイルシステムオブジェクトの時間を変更できる場合はTrue。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
case_insensitive 16 bool READ True, if filename comparisons on this filesystem are case insensitive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
case_insensitive 16 bool READ True、このファイルシステムでのファイル名の比較で大文字と小文字が区別されない場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
case_preserving 17 bool READ True, if filename case on this filesystem are preserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
case_preserving 17 bool READ True。このファイルシステムでファイル名の大文字と小文字が保持される場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chown_restricted 18 bool READ If TRUE, the server will reject any request to change either the owner or the group associated with a file if the caller is not a privileged user (for example, &#34;root&#34; in UNIX operating environments or in Windows 2000 the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chown_restricted 18 bool READ TRUEの場合、呼び出し元が特権ユーザー（たとえば、UNIXオペレーティング環境またはWindows 2000の「root」）でない場合、サーバーはファイルに関連付けられた所有者またはグループのいずれかを変更する要求を拒否します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-52">
&#34;Take Ownership&#34; privilege).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-52">
「所有権を取得」特権）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fileid 20 uint64 READ A number uniquely identifying the file within the filesystem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fileid 20 uint64 READファイルシステム内のファイルを一意に識別する番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
files_avail 21 uint64 READ File slots available to this user on the filesystem containing this object - this should be the smallest relevant limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
files_avail 21 uint64 READこのオブジェクトを含むファイルシステム上のこのユーザーが使用できるファイルスロット-これは、関連する最小の制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
files_free 22 uint64 READ Free file slots on the filesystem containing this object - this should be the smallest relevant limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
files_free 22 uint64 READこのオブジェクトを含むファイルシステム上の空きファイルスロット-これは、関連する最小の制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
files_total 23 uint64 READ Total file slots on the filesystem containing this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
files_total 23 uint64 READこのオブジェクトを含むファイルシステム上の合計ファイルスロット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations 24 fs_locations READ Locations where this filesystem may be found. If the server returns NFS4ERR_MOVED as an error, this attribute MUST be supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations 24 fs_locations READこのファイルシステムが見つかる可能性がある場所。サーバーがエラーとしてNFS4ERR_MOVEDを返す場合、この属性はサポートされている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
hidden 25 bool R/W True, if the file is considered hidden with respect to the Windows API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
hidden 25 bool R / W True、ファイルがWindows APIに関して非表示と見なされる場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 homogeneous 26 bool READ True, if this object&#39;s filesystem is homogeneous, i.e., are per filesystem attributes the same for all filesystem&#39;s objects?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
同種26 bool READ True、このオブジェクトのファイルシステムが同種の場合、つまり、ファイルシステムごとの属性がすべてのファイルシステムのオブジェクトで同じかどうか。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
maxfilesize 27 uint64 READ Maximum supported file size for the filesystem of this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
maxfilesize 27 uint64 READこのオブジェクトのファイルシステムでサポートされる最大ファイルサイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
maxlink 28 uint32 READ Maximum number of links for this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
maxlink 28 uint32 READこのオブジェクトのリンクの最大数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
maxname 29 uint32 READ Maximum filename size supported for this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
maxname 29 uint32 READこのオブジェクトでサポートされる最大ファイル名サイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
maxread 30 uint64 READ Maximum read size supported for this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
maxread 30 uint64 READこのオブジェクトでサポートされる最大読み取りサイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
maxwrite 31 uint64 READ Maximum write size supported for this object. This attribute SHOULD be supported if the file is writable. Lack of this attribute can lead to the client either wasting bandwidth or not receiving the best performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
maxwrite 31 uint64 READこのオブジェクトでサポートされる最大書き込みサイズ。ファイルが書き込み可能である場合、この属性はサポートされるべきです（SHOULD）。この属性がないと、クライアントが帯域幅を浪費したり、最高のパフォーマンスを受け取っていない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mimetype 32 utf8&lt;&gt; R/W MIME body type/subtype of this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mimetype 32 utf8 &lt;&gt; R / WこのオブジェクトのMIMEボディタイプ/サブタイプ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mode 33 mode4 R/W UNIX-style mode and permission bits for this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モード33モード4 R / W UNIXスタイルのモードおよびこのオブジェクトの許可ビット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
no_trunc 34 bool READ True, if a name longer than name_max is used, an error be returned and name is not truncated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
no_trunc 34 bool READ True、name_maxより長い名前が使用された場合、エラーが返され、名前は切り捨てられません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
numlinks 35 uint32 READ Number of hard links to this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
numlinks 35 uint32 READこのオブジェクトへのハードリンクの数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
owner 36 utf8&lt;&gt; R/W The string name of the owner of this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
owner 36 utf8 &lt;&gt; R / Wこのオブジェクトの所有者の文字列名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
owner_group 37 utf8&lt;&gt; R/W The string name of the group ownership of this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
owner_group 37 utf8 &lt;&gt; R / Wこのオブジェクトのグループ所有権の文字列名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_avail_hard 38 uint64 READ For definition see &#34;Quota Attributes&#34; section below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_avail_hard 38 uint64 READ定義については、以下の「割り当て属性」セクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_avail_soft 39 uint64 READ For definition see &#34;Quota Attributes&#34; section below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_avail_soft 39 uint64 READ定義については、以下の「割り当て属性」セクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_used 40 uint64 READ For definition see &#34;Quota Attributes&#34; section below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_used 40 uint64 READ定義については、以下の「割り当て属性」セクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rawdev 41 specdata4 READ Raw device identifier. UNIX device major/minor node information. If the value of type is not NF4BLK or NF4CHR, the value return SHOULD NOT be considered useful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rawdev 41 specdata4 READ Rawデバイス識別子。 UNIXデバイスのメジャー/マイナーノード情報。 typeの値がNF4BLKまたはNF4CHRでない場合、戻り値は有用であると見なされるべきではありません（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
space_avail 42 uint64 READ Disk space in bytes available to this user on the filesystem containing this object - this should be the smallest relevant limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
space_avail 42 uint64 READこのオブジェクトを含むファイルシステム上のこのユーザーが利用できるディスク容量（バイト単位）-これは、関連する最小の制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 space_free 43 uint64 READ Free disk space in bytes on the filesystem containing this object - this should be the smallest relevant limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
space_free 43 uint64 READこのオブジェクトを含むファイルシステムの空きディスク領域（バイト単位）-これは、関連する最小の制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
space_total 44 uint64 READ Total disk space in bytes on the filesystem containing this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
space_total 44 uint64 READこのオブジェクトを含むファイルシステム上の合計ディスク容量（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
space_used 45 uint64 READ Number of filesystem bytes allocated to this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
space_used 45 uint64 READこのオブジェクトに割り当てられたファイルシステムのバイト数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
system 46 bool R/W True, if this file is a &#34;system&#34; file with respect to the Windows API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
system 46 bool R / WこのファイルがWindows APIに関する「システム」ファイルである場合はtrue。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_access 47 nfstime4 READ The time of last access to the object by a read that was satisfied by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_access 47 nfstime4 READサーバーが満足した読み取りによってオブジェクトに最後にアクセスした時刻。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_access_set 48 settime4 WRITE Set the time of last access to the object. SETATTR use only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_access_set 48 settime4 WRITEオブジェクトへの最後のアクセス時刻を設定します。 SETATTRの使用のみ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_backup 49 nfstime4 R/W The time of last backup of the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_backup 49 nfstime4 R / Wオブジェクトの最後のバックアップの時刻。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_create 50 nfstime4 R/W The time of creation of the object. This attribute does not have any relation to the traditional UNIX file attribute &#34;ctime&#34; or &#34;change time&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_create 50 nfstime4 R / Wオブジェクトの作成時刻。この属性は、従来のUNIXファイル属性「ctime」または「change time」とは関係ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_delta 51 nfstime4 READ Smallest useful server time granularity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_delta 51 nfstime4 READ最小の有用なサーバー時間粒度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_metadata 52 nfstime4 READ The time of last meta-data modification of the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_metadata 52 nfstime4 READオブジェクトのメタデータが最後に変更された時刻。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_modify 53 nfstime4 READ The time of last modification to the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_modify 53 nfstime4 READオブジェクトが最後に変更された時刻。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_modify_set 54 settime4 WRITE Set the time of last modification to the object. SETATTR use only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_modify_set 54 settime4 WRITEオブジェクトの最終変更時刻を設定します。 SETATTRの使用のみ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mounted_on_fileid 55 uint64 READ Like fileid, but if the target filehandle is the root of a filesystem return the fileid of the underlying directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mounted_on_fileid 55 uint64 READ fileidと似ていますが、ターゲットファイルハンドルがファイルシステムのルートである場合、基礎となるディレクトリのfileidを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-7--Time-Access">
5.7. Time Access
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.7. 時間アクセス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As defined above, the time_access attribute represents the time of last access to the object by a read that was satisfied by the server. The notion of what is an &#34;access&#34; depends on server&#39;s operating environment and/or the server&#39;s filesystem semantics. For example, for servers obeying POSIX semantics, time_access would be updated only by the READLINK, READ, and READDIR operations and not any of the operations that modify the content of the object. Of course, setting the corresponding time_access_set attribute is another way to modify the time_access attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上で定義したように、time_access属性は、サーバーが満足した読み取りによるオブジェクトへの最後のアクセス時間を表します。 「アクセス」とは何かの概念は、サーバーの動作環境やサーバーのファイルシステムのセマンティクスに依存します。たとえば、POSIXセマンティクスに従うサーバーの場合、time_accessはREADLINK、READ、およびREADDIR操作によってのみ更新され、オブジェクトの内容を変更する操作では更新されません。もちろん、対応するtime_access_set属性を設定することは、time_access属性を変更するもう1つの方法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whenever the file object resides on a writable filesystem, the server should make best efforts to record time_access into stable storage. However, to mitigate the performance effects of doing so, and most especially whenever the server is satisfying the read of the object&#39;s content from its cache, the server MAY cache access time updates and lazily write them to stable storage. It is also acceptable to give administrators of the server the option to disable time_access updates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルオブジェクトが書き込み可能なファイルシステムに存在する場合は常に、サーバーはtime_accessを安定したストレージに記録するために最善の努力をする必要があります。ただし、そうすることによるパフォーマンスへの影響を軽減するために、特にサーバーがキャッシュからのオブジェクトのコンテンツの読み取りを満たしている場合は常に、サーバーはアクセス時間の更新をキャッシュして、それらを安定したストレージに遅延書き込みする場合があります。サーバーの管理者に、time_access更新を無効にするオプションを与えることもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8--Interpreting-owner-and-ownergroup">
5.8. Interpreting owner and owner_group
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8. ownerおよびowner_groupの解釈
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The recommended attributes &#34;owner&#34; and &#34;owner_group&#34; (and also users and groups within the &#34;acl&#34; attribute) are represented in terms of a UTF-8 string. To avoid a representation that is tied to a particular underlying implementation at the client or server, the use of the UTF-8 string has been chosen. Note that section 6.1 of [RFC2624] provides additional rationale. It is expected that the client and server will have their own local representation of owner and owner_group that is used for local storage or presentation to the end user. Therefore, it is expected that when these attributes are transferred between the client and server that the local representation is translated to a syntax of the form &#34;user@dns_domain&#34;. This will allow for a client and server that do not use the same local representation the ability to translate to a common syntax that can be interpreted by both.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
推奨される属性「owner」と「owner_group」（および「acl」属性内のユーザーとグループ）は、UTF-8文字列で表されます。クライアントまたはサーバーで特定の基本的な実装に関連付けられている表現を回避するために、UTF-8文字列の使用が選択されています。 [RFC2624]のセクション6.1が追加の根拠を提供していることに注意してください。クライアントとサーバーは、ローカルストレージまたはエンドユーザーへの提示に使用される所有者とowner_groupの独自のローカル表現を持つことが期待されます。したがって、これらの属性がクライアントとサーバー間で転送されると、ローカル表現が「user @ dns_domain」の形式の構文に変換されることが期待されます。これにより、同じローカル表現を使用しないクライアントとサーバーが、両方で解釈できる共通の構文に変換できるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, security principals may be represented in different ways by different security mechanisms. Servers normally translate these representations into a common format, generally that used by local storage, to serve as a means of identifying the users corresponding to these security principals. When these local identifiers are translated to the form of the owner attribute, associated with files created by such principals they identify, in a common format, the users associated with each corresponding set of security principals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、セキュリティプリンシパルは、さまざまなセキュリティメカニズムによってさまざまな方法で表すことができます。サーバーは通常、これらの表現を一般的にローカルストレージで使用される一般的な形式に変換し、これらのセキュリティプリンシパルに対応するユーザーを識別する手段として機能します。これらのローカル識別子が所有者属性の形式に変換され、そのようなプリンシパルによって作成されたファイルに関連付けられている場合、それらは共通の形式で、対応するセキュリティプリンシパルの各セットに関連付けられたユーザーを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The translation used to interpret owner and group strings is not specified as part of the protocol. This allows various solutions to be employed. For example, a local translation table may be consulted that maps between a numeric id to the user@dns_domain syntax. A name service may also be used to accomplish the translation. A server may provide a more general service, not limited by any particular translation (which would only translate a limited set of possible strings) by storing the owner and owner_group attributes in local storage without any translation or it may augment a translation method by storing the entire string for attributes for which no translation is available while using the local representation for those cases in which a translation is available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者とグループの文字列を解釈するために使用される変換は、プロトコルの一部として指定されていません。これにより、さまざまなソリューションを使用できます。たとえば、数値IDをuser @ dns_domain構文にマッピングするローカル変換テーブルが参照される場合があります。ネームサービスを使用して、変換を行うこともできます。サーバーは、owner属性とowner_group属性を翻訳なしでローカルストレージに格納することにより、特定の翻訳に限定されない（可能な文字列の限られたセットのみを翻訳する）より一般的なサービスを提供するか、または翻訳が利用可能な場合にローカル表現を使用しているときに、翻訳が利用できない属性の文字列全体。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Servers that do not provide support for all possible values of the owner and owner_group attributes, should return an error (NFS4ERR_BADOWNER) when a string is presented that has no translation, as the value to be set for a SETATTR of the owner, owner_group, or acl attributes. When a server does accept an owner or owner_group value as valid on a SETATTR (and similarly for the owner and group strings in an acl), it is promising to return that same string when a corresponding GETATTR is done. Configuration changes and ill-constructed name translations (those that contain aliasing) may make that promise impossible to honor. Servers should make appropriate efforts to avoid a situation in which these attributes have their values changed when no real change to ownership has occurred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ownerおよびowner_group属性のすべての可能な値をサポートしていないサーバーは、所有者、owner_group、またはacl属性。サーバーが所有者またはowner_groupの値をSETATTRで有効であると（そして同様にACLの所有者およびグループ文字列でも）受け入れる場合、対応するGETATTRが実行されたときに同じ文字列を返すことが約束されています。設定の変更と不適切に構築された名前変換（エイリアスを含むもの）は、その約束を守ることを不可能にする可能性があります。サーバーは、所有権に実際の変更が発生していないときにこれらの属性の値が変更される状況を回避するために、適切な努力をする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;dns_domain&#34; portion of the owner string is meant to be a DNS domain name. For example, user@ietf.org. Servers should accept as valid a set of users for at least one domain. A server may treat other domains as having no valid translations. A more general service is provided when a server is capable of accepting users for multiple domains, or for all domains, subject to security constraints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者文字列の「dns_domain」部分は、DNSドメイン名であることを意味します。たとえば、user @ ietf.org。サーバーは、少なくとも1つのドメインのユーザーのセットを有効なものとして受け入れる必要があります。サーバーは他のドメインを有効な翻訳がないものとして扱う場合があります。サーバーが複数のドメインまたはすべてのドメインのユーザーを受け入れることができる場合、より一般的なサービスが提供され、セキュリティの制約を受けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case where there is no translation available to the client or server, the attribute value must be constructed without the &#34;@&#34;. Therefore, the absence of the @ from the owner or owner_group attribute signifies that no translation was available at the sender and that the receiver of the attribute should not use that string as a basis for translation into its own internal format. Even though the attribute value can not be translated, it may still be useful. In the case of a client, the attribute string may be used for local display of ownership.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントまたはサーバーで使用可能な変換がない場合、属性値は「@」なしで構築する必要があります。したがって、ownerまたはowner_group属性に@がない場合は、送信者で変換が利用できなかったこと、および属性の受信者がその文字列を独自の内部形式への変換の基礎として使用してはならないことを意味します。属性値は変換できませんが、それでも役立つ場合があります。クライアントの場合、所有権のローカル表示に属性文字列を使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To provide a greater degree of compatibility with previous versions of NFS (i.e., v2 and v3), which identified users and groups by 32-bit unsigned uid&#39;s and gid&#39;s, owner and group strings that consist of decimal numeric values with no leading zeros can be given a special interpretation by clients and servers which choose to provide such support. The receiver may treat such a user or group string as representing the same user as would be represented by a v2/v3 uid or gid having the corresponding numeric value. A server is not obligated to accept such a string, but may return an NFS4ERR_BADOWNER instead. To avoid this mechanism being used to subvert user and group translation, so that a client might pass all of the owners and groups in numeric form, a server SHOULD return an NFS4ERR_BADOWNER error when there is a valid translation for the user or owner designated in this way. In that case, the client must use the appropriate name@domain string and not the special form for compatibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前のバージョンのNFS（つまり、v2とv3）との互換性を高めるには、32ビットの符号なしuidとgidでユーザーとグループを識別しましたが、先頭にゼロがない10進数の数値で構成される所有者とグループの文字列は、そのようなサポートを提供することを選択するクライアントとサーバーによって特別な解釈が与えられます。受信者は、そのようなユーザーまたはグループ文字列を、対応する数値を持つv2 / v3 uidまたはgidによって表されるのと同じユーザーを表すものとして扱うことができます。サーバーはそのような文字列を受け入れる義務はありませんが、代わりにNFS4ERR_BADOWNERを返す場合があります。このメカニズムがユーザーとグループの変換を覆すために使用されないようにして、クライアントがすべての所有者とグループを数値形式で渡すことができるように、サーバーは、これで指定されたユーザーまたは所有者の有効な変換があるときにNFS4ERR_BADOWNERエラーを返す必要があります。仕方。その場合、クライアントは、互換性のための特別な形式ではなく、適切なname @ domain文字列を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The owner string &#34;nobody&#34; may be used to designate an anonymous user, which will be associated with a file created by a security principal that cannot be mapped through normal means to the owner attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者文字列「nobody」は、匿名ユーザーを指定するために使用できます。匿名ユーザーは、通常の方法では所有者属性にマップできないセキュリティプリンシパルによって作成されたファイルに関連付けられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-9--Character-Case-Attributes">
5.9. Character Case Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.9. 文字ケース属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With respect to the case_insensitive and case_preserving attributes, each UCS-4 character (which UTF-8 encodes) has a &#34;long descriptive name&#34; [RFC1345] which may or may not included the word &#34;CAPITAL&#34; or &#34;SMALL&#34;. The presence of SMALL or CAPITAL allows an NFS server to implement unambiguous and efficient table driven mappings for case insensitive comparisons, and non-case-preserving storage. For general character handling and internationalization issues, see the section &#34;Internationalization&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
case_insensitiveおよびcase_preserving属性に関して、各UCS-4文字（UTF-8がエンコード）には、「CAPITAL」または「SMALL」という単語が含まれる場合と含まれない場合がある「長い説明的な名前」[RFC1345]があります。 SMALLまたはCAPITALの存在により、NFSサーバーは、大文字と小文字を区別しない比較のための明確で効率的なテーブル駆動のマッピング、および大文字と小文字を保持しないストレージを実装できます。一般的な文字処理と国際化の問題については、「国際化」のセクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-10--Quota-Attributes">
5.10. Quota Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.10. 割り当て属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the attributes related to filesystem quotas, the following definitions apply:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムクォータに関連する属性には、次の定義が適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_avail_soft The value in bytes which represents the amount of additional disk space that can be allocated to this file or directory before the user may reasonably be warned. It is understood that this space may be consumed by allocations to other files or directories though there is a rule as to which other files or directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_avail_softユーザーに警告する前に、このファイルまたはディレクトリに割り当てることができる追加のディスク容量を表すバイト単位の値。このスペースは、他のファイルまたはディレクトリに関する規則はありますが、他のファイルまたはディレクトリへの割り当てによって消費される可能性があることは理解されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_avail_hard The value in bytes which represent the amount of additional disk space beyond the current allocation that can be allocated to this file or directory before further allocations will be refused. It is understood that this space may be consumed by allocations to other files or directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_avail_hardこれ以上の割り当てが拒否される前に、このファイルまたはディレクトリに割り当てることができる現在の割り当てを超える追加のディスク領域の量を表すバイト単位の値。このスペースは、他のファイルまたはディレクトリへの割り当てによって消費される可能性があることを理解してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_used The value in bytes which represent the amount of disc space used by this file or directory and possibly a number of other similar files or directories, where the set of &#34;similar&#34; meets at least the criterion that allocating space to any file or directory in the set will reduce the &#34;quota_avail_hard&#34; of every other file or directory in the set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_usedこのファイルまたはディレクトリ、および場合によっては他の類似のファイルまたはディレクトリによって使用されるディスク領域の量を表すバイト単位の値。「類似」のセットは、少なくとも、ファイルまたはディレクトリに領域を割り当てる基準を満たします。セットは、セット内の他のすべてのファイルまたはディレクトリの &#34;quota_avail_hard&#34;を減らします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Note that there may be a number of distinct but overlapping sets of files or directories for which a quota_used value is maintained (e.g., &#34;all files with a given owner&#34;, &#34;all files with a given group owner&#34;, etc.).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
quota_usedの値が維持されているファイルまたはディレクトリのセットが重複している可能性があることに注意してください（たとえば、「特定の所有者のすべてのファイル」、「特定のグループ所有者のすべてのファイル」など）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The server is at liberty to choose any of those sets but should do so in a repeatable way. The rule may be configured per-filesystem or may be &#34;choose the set with the smallest quota&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
サーバーはこれらのセットのいずれかを自由に選択できますが、繰り返し可能な方法で選択する必要があります。ルールはファイルシステムごとに構成することも、「割り当て量が最小のセットを選択する」こともできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-11--Access-Control-Lists">
5.11. Access Control Lists
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11. アクセス制御リスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 ACL attribute is an array of access control entries (ACE). Although, the client can read and write the ACL attribute, the NFSv4 model is the server does all access control based on the server&#39;s interpretation of the ACL. If at any point the client wants to check access without issuing an operation that modifies or reads data or metadata, the client can use the OPEN and ACCESS operations to do so. There are various access control entry types, as defined in the Section &#34;ACE type&#34;. The server is able to communicate which ACE types are supported by returning the appropriate value within the aclsupport attribute. Each ACE covers one or more operations on a file or directory as described in the Section &#34;ACE Access Mask&#34;. It may also contain one or more flags that modify the semantics of the ACE as defined in the Section &#34;ACE flag&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4 ACL属性は、アクセス制御エントリ（ACE）の配列です。クライアントはACL属性を読み書きできますが、NFSv4モデルはサーバーがACLのサーバーの解釈に基づいてすべてのアクセス制御を行うモデルです。クライアントがデータまたはメタデータを変更または読み取る操作を発行せずにアクセスを確認する必要がある場合は、OPENおよびACCESS操作を使用して確認できます。セクション「ACEタイプ」で定義されているように、さまざまなアクセス制御エントリタイプがあります。サーバーは、aclsupport属性内で適切な値を返すことにより、サポートされているACEタイプを通信できます。各ACEは、「ACEアクセスマスク」で説明されているように、ファイルまたはディレクトリに対する1つ以上の操作をカバーします。セクション「ACEフラグ」で定義されているように、ACEのセマンティクスを変更する1つ以上のフラグが含まれる場合もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS ACE attribute is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS ACE属性は次のように定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         typedef uint32_t        acetype4;
         typedef uint32_t        aceflag4;
         typedef uint32_t        acemask4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         struct nfsace4 {
                 acetype4        type;
                 aceflag4        flag;
                 acemask4        access_mask;
                 utf8str_mixed   who;
         };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To determine if a request succeeds, each nfsace4 entry is processed in order by the server. Only ACEs which have a &#34;who&#34; that matches the requester are considered. Each ACE is processed until all of the bits of the requester&#39;s access have been ALLOWED. Once a bit (see below) has been ALLOWED by an ACCESS_ALLOWED_ACE, it is no longer considered in the processing of later ACEs. If an ACCESS_DENIED_ACE is encountered where the requester&#39;s access still has unALLOWED bits in common with the &#34;access_mask&#34; of the ACE, the request is denied. However, unlike the ALLOWED and DENIED ACE types, the ALARM and AUDIT ACE types do not affect a requester&#39;s access, and instead are for triggering events as a result of a requester&#39;s access attempt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストが成功したかどうかを判断するために、各nfsace4エントリはサーバーによって順番に処理されます。要求者に一致する「who」を持つACEのみが考慮されます。各ACEは、要求者のアクセスのすべてのビットが許可されるまで処理されます。 ACCESS_ALLOWED_ACEによってビット（以下を参照）が許可されると、以降のACEの処理では考慮されなくなります。リクエスターのアクセスにACEの「access_mask」と共通のunALLOWEDビットが含まれているACCESS_DENIED_ACEが検出された場合、要求は拒否されます。ただし、ALLOWEDおよびDENIED ACEタイプとは異なり、ALARMおよびAUDIT ACEタイプはリクエスターのアクセスに影響を与えず、リクエスターのアクセス試行の結果としてイベントをトリガーするためのものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, all AUDIT and ALARM ACEs are processed until end of the ACL. When the ACL is fully processed, if there are bits in requester&#39;s mask that have not been considered whether the server allows or denies the access is undefined. If there is a mode attribute on the file, then this cannot happen, since the mode&#39;s MODE4_*OTH bits will map to EVERYONE@ ACEs that unambiguously specify the requester&#39;s access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、すべてのAUDITおよびALARM ACEは、ACLの終わりまで処理されます。 ACLが完全に処理されたときに、サーバーがアクセスを許可するか拒否するかが考慮されていないリクエスターのマスクにビットがある場合は、未定義です。ファイルにモード属性がある場合、モードのMODE4_ * OTHビットはリクエスタのアクセスを明確に指定するEVERYONE @ ACEにマップされるため、これは起こりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 ACL model is quite rich. Some server platforms may provide access control functionality that goes beyond the UNIX-style mode attribute, but which is not as rich as the NFS ACL model. So that users can take advantage of this more limited functionality, the server may indicate that it supports ACLs as long as it follows the guidelines for mapping between its ACL model and the NFS version 4 ACL model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4 ACLモデルは非常に豊富です。一部のサーバープラットフォームは、UNIXスタイルのモード属性を超えるアクセス制御機能を提供しますが、NFS ACLモデルほど豊富ではありません。ユーザーがこのより制限された機能を利用できるように、サーバーは、ACLモデルとNFSバージョン4 ACLモデル間のマッピングのガイドラインに従う限り、ACLをサポートしていることを示す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The situation is complicated by the fact that a server may have multiple modules that enforce ACLs. For example, the enforcement for NFS version 4 access may be different from the enforcement for local access, and both may be different from the enforcement for access through other protocols such as SMB. So it may be useful for a server to accept an ACL even if not all of its modules are able to support it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーには、ACLを適用する複数のモジュールがある場合があるため、状況は複雑です。たとえば、NFSバージョン4アクセスの強制はローカルアクセスの強制とは異なる場合があり、両方ともSMBなどの他のプロトコルを介したアクセスの強制とは異なる場合があります。そのため、すべてのモジュールがACLをサポートできるわけではない場合でも、サーバーがACLを受け入れると便利な場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The guiding principle in all cases is that the server must not accept ACLs that appear to make the file more secure than it really is.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての場合の指針となる原則は、サーバーがファイルを実際よりも安全にするように見えるACLを受け入れてはならないということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-11-1--ACE-type">
5.11.1. ACE type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.1. エースタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Type         Description
   _____________________________________________________
   ALLOW        Explicitly grants the access defined in
                acemask4 to the file or directory.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DENY Explicitly denies the access defined in acemask4 to the file or directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DENY acemask4で定義されたファイルまたはディレクトリへのアクセスを明示的に拒否します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AUDIT LOG (system dependent) any access attempt to a file or directory which uses any of the access methods specified in acemask4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AUDIT LOG（システム依存）acemask4で指定されたアクセス方法のいずれかを使用するファイルまたはディレクトリへのアクセス試行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ALARM Generate a system ALARM (system dependent) when any access attempt is made to a file or directory for the access methods specified in acemask4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ALARM acemask4で指定されたアクセス方法でファイルまたはディレクトリへのアクセスが試行されると、システムALARM（システム依存）を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server need not support all of the above ACE types. The bitmask constants used to represent the above definitions within the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、上記のACEタイプのすべてをサポートする必要はありません。内の上記の定義を表すために使用されるビットマスク定数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
aclsupport attribute are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
aclsupport属性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      const ACL4_SUPPORT_ALLOW_ACL    = 0x00000001;
      const ACL4_SUPPORT_DENY_ACL     = 0x00000002;
      const ACL4_SUPPORT_AUDIT_ACL    = 0x00000004;
      const ACL4_SUPPORT_ALARM_ACL    = 0x00000008;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The semantics of the &#34;type&#34; field follow the descriptions provided above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「タイプ」フィールドのセマンティクスは、上記の説明に従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The constants used for the type field (acetype4) are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプフィールド（acetype4）に使用される定数は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      const ACE4_ACCESS_ALLOWED_ACE_TYPE      = 0x00000000;
      const ACE4_ACCESS_DENIED_ACE_TYPE       = 0x00000001;
      const ACE4_SYSTEM_AUDIT_ACE_TYPE        = 0x00000002;
      const ACE4_SYSTEM_ALARM_ACE_TYPE        = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients should not attempt to set an ACE unless the server claims support for that ACE type. If the server receives a request to set an ACE that it cannot store, it MUST reject the request with NFS4ERR_ATTRNOTSUPP. If the server receives a request to set an ACE that it can store but cannot enforce, the server SHOULD reject the request with NFS4ERR_ATTRNOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがそのACEタイプのサポートを要求しない限り、クライアントはACEを設定しないでください。サーバーは、格納できないACEを設定する要求を受信した場合、NFS4ERR_ATTRNOTSUPPを使用して要求を拒否する必要があります。サーバーが格納できるが強制できないACEを設定する要求を受信した場合、サーバーはNFS4ERR_ATTRNOTSUPPを使用して要求を拒否する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example: suppose a server can enforce NFS ACLs for NFS access but cannot enforce ACLs for local access. If arbitrary processes can run on the server, then the server SHOULD NOT indicate ACL support. On the other hand, if only trusted administrative programs run locally, then the server may indicate ACL support.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例：サーバーがNFSアクセスにNFS ACLを適用できるが、ローカルアクセスにはACLを適用できないとします。サーバー上で任意のプロセスを実行できる場合、サーバーはACLサポートを示すべきではありません（SHOULD NOT）。一方、信頼できる管理プログラムのみがローカルで実行されている場合、サーバーはACLサポートを示している可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-11-2--ACE-Access-Mask">
5.11.2. ACE Access Mask
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.2. ACEアクセスマスク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The access_mask field contains values based on the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
access_maskフィールドには、以下に基づく値が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Access                 Description
   _______________________________________________________________
   READ_DATA              Permission to read the data of the file
   LIST_DIRECTORY         Permission to list the contents of a
                          directory
   WRITE_DATA             Permission to modify the file&#39;s data
   ADD_FILE               Permission to add a new file to a
                          directory
   APPEND_DATA            Permission to append data to a file
   ADD_SUBDIRECTORY       Permission to create a subdirectory to a
                          directory
   READ_NAMED_ATTRS       Permission to read the named attributes
                          of a file
   WRITE_NAMED_ATTRS      Permission to write the named attributes
                          of a file
   EXECUTE                Permission to execute a file
   DELETE_CHILD           Permission to delete a file or directory
                          within a directory
   READ_ATTRIBUTES        The ability to read basic attributes
                          (non-acls) of a file
   WRITE_ATTRIBUTES       Permission to change basic attributes
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 (non-acls) of a file DELETE Permission to Delete the file READ_ACL Permission to Read the ACL WRITE_ACL Permission to Write the ACL WRITE_OWNER Permission to change the owner SYNCHRONIZE Permission to access file locally at the server with synchronous reads and writes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルの（acls以外）DELETEファイルを削除するための権限READ_ACL ACLを読み取るための権限ACLを書き込むためのWRITE_ACL権限所有者を変更するための権限WRITE_OWNER同期読み取りと書き込みを使用してサーバーでローカルにファイルにアクセスするための権限SYNCHRONIZE権限
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The bitmask constants used for the access mask field are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクセスマスクフィールドに使用されるビットマスク定数は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACE4_READ_DATA            = 0x00000001;
   const ACE4_LIST_DIRECTORY       = 0x00000001;
   const ACE4_WRITE_DATA           = 0x00000002;
   const ACE4_ADD_FILE             = 0x00000002;
   const ACE4_APPEND_DATA          = 0x00000004;
   const ACE4_ADD_SUBDIRECTORY     = 0x00000004;
   const ACE4_READ_NAMED_ATTRS     = 0x00000008;
   const ACE4_WRITE_NAMED_ATTRS    = 0x00000010;
   const ACE4_EXECUTE              = 0x00000020;
   const ACE4_DELETE_CHILD         = 0x00000040;
   const ACE4_READ_ATTRIBUTES      = 0x00000080;
   const ACE4_WRITE_ATTRIBUTES     = 0x00000100;
   const ACE4_DELETE               = 0x00010000;
   const ACE4_READ_ACL             = 0x00020000;
   const ACE4_WRITE_ACL            = 0x00040000;
   const ACE4_WRITE_OWNER          = 0x00080000;
   const ACE4_SYNCHRONIZE          = 0x00100000;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Server implementations need not provide the granularity of control that is implied by this list of masks. For example, POSIX-based systems might not distinguish APPEND_DATA (the ability to append to a file) from WRITE_DATA (the ability to modify existing contents); both masks would be tied to a single &#34;write&#34; permission. When such a server returns attributes to the client, it would show both APPEND_DATA and WRITE_DATA if and only if the write permission is enabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの実装は、このマスクのリストが意味する細かい制御を提供する必要はありません。たとえば、POSIXベースのシステムでは、APPEND_DATA（ファイルに追加する機能）とWRITE_DATA（既存の内容を変更する機能）を区別できない場合があります。両方のマスクは、単一の「書き込み」権限に関連付けられます。このようなサーバーが属性をクライアントに返す場合、書き込み権限が有効になっている場合にのみ、APPEND_DATAとWRITE_DATAの両方が表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a server receives a SETATTR request that it cannot accurately implement, it should error in the direction of more restricted access. For example, suppose a server cannot distinguish overwriting data from appending new data, as described in the previous paragraph. If a client submits an ACE where APPEND_DATA is set but WRITE_DATA is not (or vice versa), the server should reject the request with NFS4ERR_ATTRNOTSUPP. Nonetheless, if the ACE has type DENY, the server may silently turn on the other bit, so that both APPEND_DATA and WRITE_DATA are denied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、正確に実装できないSETATTR要求を受信した場合、より制限されたアクセスの方向でエラーを発生させるはずです。たとえば、前の段落で説明したように、サーバーがデータの上書きと新しいデータの追加を区別できないとします。クライアントがAPPEND_DATAが設定されているがWRITE_DATAが設定されていない（またはその逆の）ACEを送信する場合、サーバーはNFS4ERR_ATTRNOTSUPPで要求を拒否する必要があります。それにもかかわらず、ACEのタイプがDENYの場合、サーバーは暗黙的に他のビットをオンにして、APPEND_DATAとWRITE_DATAの両方が拒否されるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-11-3--ACE-flag">
5.11.3. ACE flag
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.3. ACEフラグ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;flag&#34; field contains values based on the following descriptions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「フラグ」フィールドには、以下の説明に基づく値が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_FILE_INHERIT_ACE Can be placed on a directory and indicates that this ACE should be added to each new non-directory file created.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_FILE_INHERIT_ACEディレクトリに配置でき、このACEを、作成された新しいディレクトリ以外の各ファイルに追加する必要があることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_DIRECTORY_INHERIT_ACE Can be placed on a directory and indicates that this ACE should be added to each new directory created.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_DIRECTORY_INHERIT_ACEディレクトリに配置でき、このACEを、作成される新しい各ディレクトリに追加する必要があることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_INHERIT_ONLY_ACE Can be placed on a directory but does not apply to the directory, only to newly created files/directories as specified by the above two flags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_INHERIT_ONLY_ACEディレクトリに配置できますが、ディレクトリには適用されません。上記の2つのフラグで指定された、新しく作成されたファイル/ディレクトリにのみ適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_NO_PROPAGATE_INHERIT_ACE Can be placed on a directory. Normally when a new directory is created and an ACE exists on the parent directory which is marked ACL4_DIRECTORY_INHERIT_ACE, two ACEs are placed on the new directory. One for the directory itself and one which is an inheritable ACE for newly created directories. This flag tells the server to not place an ACE on the newly created directory which is inheritable by subdirectories of the created directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_NO_PROPAGATE_INHERIT_ACEディレクトリに配置できます。通常、新しいディレクトリが作成され、ACL4_DIRECTORY_INHERIT_ACEとマークされた親ディレクトリにACEが存在する場合、2つのACEが新しいディレクトリに配置されます。 1つはディレクトリ自体用で、もう1つは新しく作成されたディレクトリ用の継承可能なACEです。このフラグは、新しく作成されたディレクトリにACEを配置しないようサーバーに指示します。これは、作成されたディレクトリのサブディレクトリによって継承されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_SUCCESSFUL_ACCESS_ACE_FLAG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_SUCCESSFUL_ACCESS_ACE_FLAG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACL4_FAILED_ACCESS_ACE_FLAG The ACE4_SUCCESSFUL_ACCESS_ACE_FLAG (SUCCESS) and ACE4_FAILED_ACCESS_ACE_FLAG (FAILED) flag bits relate only to ACE4_SYSTEM_AUDIT_ACE_TYPE (AUDIT) and ACE4_SYSTEM_ALARM_ACE_TYPE (ALARM) ACE types. If during the processing of the file&#39;s ACL, the server encounters an AUDIT or ALARM ACE that matches the principal attempting the OPEN, the server notes that fact, and the presence, if any, of the SUCCESS and FAILED flags encountered in the AUDIT or ALARM ACE. Once the server completes the ACL processing, and the share reservation processing, and the OPEN call, it then notes if the OPEN succeeded or failed. If the OPEN succeeded, and if the SUCCESS flag was set for a matching AUDIT or ALARM, then the appropriate AUDIT or ALARM event occurs. If the OPEN failed, and if the FAILED flag was set for the matching AUDIT or ALARM, then the appropriate AUDIT or ALARM event occurs. Clearly either or both of the SUCCESS or FAILED can be set, but if neither is set, the AUDIT or ALARM ACE is not useful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACL4_FAILED_ACCESS_ACE_FLAG ACE4_SUCCESSFUL_ACCESS_ACE_FLAG（SUCCESS）およびACE4_FAILED_ACCESS_ACE_FLAG（FAILED）フラグビットは、ACE4_SYSTEM_AUDIT_ACE_TYPE（AUDIT）およびACE4_SYSTEM_ALARM_ACE_TYPE（ALARM）ACEタイプにのみ関連します。ファイルのACLの処理中に、サーバーがOPENを試行するプリンシパルと一致するAUDITまたはALARM ACEを検出した場合、サーバーはその事実と、AUDITまたはALARMで検出されたSUCCESSおよびFAILEDフラグの存在（存在する場合）を記録しますエース。サーバーは、ACL処理、共有予約処理、およびOPEN呼び出しを完了すると、OPENが成功したか失敗したかを記録します。 OPENが成功し、一致するAUDITまたはALARMにSUCCESSフラグが設定されている場合、適切なAUDITまたはALARMイベントが発生します。 OPENが失敗し、一致するAUDITまたはALARMにFAILEDフラグが設定されている場合、適切なAUDITまたはALARMイベントが発生します。 SUCCESSまたはFAILEDのどちらかまたは両方を設定できることは明らかですが、どちらも設定されていない場合、AUDITまたはALARM ACEは役に立ちません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The previously described processing applies to that of the ACCESS operation as well. The difference being that &#34;success&#34; or &#34;failure&#34; does not mean whether ACCESS returns NFS4_OK or not. Success means whether ACCESS returns all requested and supported bits. Failure means whether ACCESS failed to return a bit that was requested and supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
前述の処理は、ACCESS操作の処理にも適用されます。違いは、「成功」または「失敗」は、ACCESSがNFS4_OKを返すかどうかを意味しないということです。成功とは、ACCESSが要求されサポートされているすべてのビットを返すかどうかを意味します。失敗とは、ACCESSが要求およびサポートされているビットを返せなかったかどうかを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_IDENTIFIER_GROUP Indicates that the &#34;who&#34; refers to a GROUP as defined under UNIX.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_IDENTIFIER_GROUP「who」がUNIXで定義されているGROUPを指すことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The bitmask constants used for the flag field are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグフィールドに使用されるビットマスク定数は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACE4_FILE_INHERIT_ACE             = 0x00000001;
   const ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;
   const ACE4_NO_PROPAGATE_INHERIT_ACE     = 0x00000004;
   const ACE4_INHERIT_ONLY_ACE             = 0x00000008;
   const ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;
   const ACE4_FAILED_ACCESS_ACE_FLAG       = 0x00000020;
   const ACE4_IDENTIFIER_GROUP             = 0x00000040;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server need not support any of these flags. If the server supports flags that are similar to, but not exactly the same as, these flags, the implementation may define a mapping between the protocol-defined flags and the implementation-defined flags. Again, the guiding principle is that the file not appear to be more secure than it really is.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはこれらのフラグをサポートする必要はありません。サーバーがこれらのフラグに類似しているが完全に同じではないフラグをサポートしている場合、実装はプロトコル定義のフラグと実装定義のフラグとの間のマッピングを定義できます。繰り返しになりますが、基本原則は、ファイルが実際よりも安全であるように見えないということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, suppose a client tries to set an ACE with ACE4_FILE_INHERIT_ACE set but not ACE4_DIRECTORY_INHERIT_ACE. If the server does not support any form of ACL inheritance, the server should reject the request with NFS4ERR_ATTRNOTSUPP. If the server supports a single &#34;inherit ACE&#34; flag that applies to both files and directories, the server may reject the request (i.e., requiring the client to set both the file and directory inheritance flags). The server may also accept the request and silently turn on the ACE4_DIRECTORY_INHERIT_ACE flag.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、クライアントがACE4_FILE_INHERIT_ACEを設定してACE4_DIRECTORY_INHERIT_ACEを設定せずにACEを設定しようとしているとします。サーバーがどの形式のACL継承もサポートしていない場合、サーバーはNFS4ERR_ATTRNOTSUPPを使用して要求を拒否する必要があります。サーバーがファイルとディレクトリの両方に適用される単一の「継承ACE」フラグをサポートしている場合、サーバーは要求を拒否する可能性があります（つまり、クライアントにファイルとディレクトリの両方の継承フラグを設定するよう要求する）。サーバーは要求を受け入れ、サイレントにACE4_DIRECTORY_INHERIT_ACEフラグをオンにすることもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-11-4--ACE-who">
5.11.4. ACE who
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.4. エースフー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are several special identifiers (&#34;who&#34;) which need to be understood universally, rather than in the context of a particular DNS domain. Some of these identifiers cannot be understood when an NFS client accesses the server, but have meaning when a local process accesses the file. The ability to display and modify these permissions is permitted over NFS, even if none of the access methods on the server understands the identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のDNSドメインのコンテキストではなく、普遍的に理解する必要があるいくつかの特別な識別子（「who」）があります。これらの識別子の一部は、NFSクライアントがサーバーにアクセスするときには理解できませんが、ローカルプロセスがファイルにアクセスするときには意味があります。これらのアクセス許可を表示および変更する機能は、サーバー上のアクセス方法が識別子を理解していない場合でも、NFSを介して許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Who                    Description
   _______________________________________________________________
   &#34;OWNER&#34;                The owner of the file.
   &#34;GROUP&#34;                The group associated with the file.
   &#34;EVERYONE&#34;             The world.
   &#34;INTERACTIVE&#34;          Accessed from an interactive terminal.
   &#34;NETWORK&#34;              Accessed via the network.
   &#34;DIALUP&#34;               Accessed as a dialup user to the server.
   &#34;BATCH&#34;                Accessed from a batch job.
   &#34;ANONYMOUS&#34;            Accessed without any authentication.
   &#34;AUTHENTICATED&#34;        Any authenticated user (opposite of
                          ANONYMOUS)
   &#34;SERVICE&#34;              Access from a system service.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid conflict, these special identifiers are distinguish by an appended &#34;@&#34; and should appear in the form &#34;xxxx@&#34; (note: no domain name after the &#34;@&#34;). For example: ANONYMOUS@.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
競合を回避するために、これらの特別な識別子は「@」が付加されて区別され、「xxxx @」の形式で表示される必要があります（注：「@」の後にドメイン名はありません）。例：ANONYMOUS @。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-11-5--Mode-Attribute">
5.11.5. Mode Attribute
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.5. モード属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 mode attribute is based on the UNIX mode bits. The following bits are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4のモード属性は、UNIXモードビットに基づいています。次のビットが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      const MODE4_SUID = 0x800;  /* set user id on execution */
      const MODE4_SGID = 0x400;  /* set group id on execution */
      const MODE4_SVTX = 0x200;  /* save text even after use */
      const MODE4_RUSR = 0x100;  /* read permission: owner */
      const MODE4_WUSR = 0x080;  /* write permission: owner */
      const MODE4_XUSR = 0x040;  /* execute permission: owner */
      const MODE4_RGRP = 0x020;  /* read permission: group */
      const MODE4_WGRP = 0x010;  /* write permission: group */
      const MODE4_XGRP = 0x008;  /* execute permission: group */
      const MODE4_ROTH = 0x004;  /* read permission: other */
      const MODE4_WOTH = 0x002;  /* write permission: other */
      const MODE4_XOTH = 0x001;  /* execute permission: other */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bits MODE4_RUSR, MODE4_WUSR, and MODE4_XUSR apply to the principal identified in the owner attribute. Bits MODE4_RGRP, MODE4_WGRP, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビットMODE4_RUSR、MODE4_WUSR、およびMODE4_XUSRは、所有者属性で識別されるプリンシパルに適用されます。ビットMODE4_RGRP、MODE4_WGRP、および
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MODE4_XGRP apply to the principals identified in the owner_group attribute. Bits MODE4_ROTH, MODE4_WOTH, MODE4_XOTH apply to any principal that does not match that in the owner group, and does not have a group matching that of the owner_group attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MODE4_XGRPは、owner_group属性で識別されたプリンシパルに適用されます。ビットMODE4_ROTH、MODE4_WOTH、MODE4_XOTHは、所有者グループのプリンシパルと一致しないプリンシパルに適用され、owner_group属性のグループと一致するグループを持ちません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remaining bits are not defined by this protocol and MUST NOT be used. The minor version mechanism must be used to define further bit usage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残りのビットはこのプロトコルでは定義されておらず、使用してはなりません（MUST NOT）。マイナーバージョンのメカニズムを使用して、ビット使用量をさらに定義する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that in UNIX, if a file has the MODE4_SGID bit set and no MODE4_XGRP bit set, then READ and WRITE must use mandatory file locking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNIXでは、ファイルにMODE4_SGIDビットが設定されており、MODE4_XGRPビットが設定されていない場合、READおよびWRITEは必須のファイルロックを使用する必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-11-6--Mode-and-ACL-Attribute">
5.11.6. Mode and ACL Attribute
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.6. モードとACL属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server that supports both mode and ACL must take care to synchronize the MODE4_*USR, MODE4_*GRP, and MODE4_*OTH bits with the ACEs which have respective who fields of &#34;OWNER@&#34;, &#34;GROUP@&#34;, and &#34;EVERYONE@&#34; so that the client can see semantically equivalent access permissions exist whether the client asks for owner, owner_group and mode attributes, or for just the ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モードとACLの両方をサポートするサーバーは、MODE4_ * USR、MODE4_ * GRP、およびMODE4_ * OTHビットを、「OWNER @」、「GROUP @」、および「EVERYONE @」のそれぞれのwhoフィールドを持つACEと同期するように注意する必要があります&#34;クライアントが所有者、owner_groupおよびモード属性を要求するか、またはACLのみを要求するかに関係なく、クライアントは意味的に同等のアクセス許可が存在することを確認できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the mode attribute includes bits (e.g., MODE4_SVTX) that have nothing to do with ACL semantics, it is permitted for clients to specify both the ACL attribute and mode in the same SETATTR operation. However, because there is no prescribed order for processing the attributes in a SETATTR, the client must ensure that ACL attribute, if specified without mode, would produce the desired mode bits, and conversely, the mode attribute if specified without ACL, would produce the desired &#34;OWNER@&#34;, &#34;GROUP@&#34;, and &#34;EVERYONE@&#34; ACEs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モード属性には、ACLセマンティクスとは何の関係もないビット（MODE4_SVTXなど）が含まれているため、クライアントが同じSETATTR操作でACL属性とモードの両方を指定することが許可されています。ただし、SETATTR内の属性を処理するための所定の順序がないため、クライアントは、ACL属性がモードなしで指定されている場合は、目的のモードビットを生成し、逆に、モード属性がACLなしで指定されている場合は、希望する「OWNER @」、「GROUP @」、および「EVERYONE @」ACE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-11-7--mountedonfileid">
5.11.7. mounted_on_fileid
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.7. Mounted_on_fileid
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNIX-based operating environments connect a filesystem into the namespace by connecting (mounting) the filesystem onto the existing file object (the mount point, usually a directory) of an existing filesystem. When the mount point&#39;s parent directory is read via an API like readdir(), the return results are directory entries, each with a component name and a fileid. The fileid of the mount point&#39;s directory entry will be different from the fileid that the stat() system call returns. The stat() system call is returning the fileid of the root of the mounted filesystem, whereas readdir() is returning the fileid stat() would have returned before any filesystems were mounted on the mount point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNIXベースのオペレーティング環境では、ファイルシステムを既存のファイルシステムの既存のファイルオブジェクト（マウントポイント、通常はディレクトリ）に接続（マウント）することにより、ファイルシステムをネームスペースに接続します。マウントポイントの親ディレクトリがreaddir()のようなAPIを介して読み取られると、返される結果はディレクトリエントリであり、それぞれにコンポーネント名とファイルIDがあります。マウントポイントのディレクトリエントリのファイルIDは、stat()システムコールが返すファイルIDとは異なります。 stat()システムコールはマウントされたファイルシステムのルートのファイルIDを返しますが、readdir()はファイルIDを返します。stat()は、ファイルシステムがマウントポイントにマウントされる前に返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike NFS version 3, NFS version 4 allows a client&#39;s LOOKUP request to cross other filesystems. The client detects the filesystem crossing whenever the filehandle argument of LOOKUP has an fsid attribute different from that of the filehandle returned by LOOKUP. A UNIX-based client will consider this a &#34;mount point crossing&#34;. UNIX has a legacy scheme for allowing a process to determine its current working directory. This relies on readdir() of a mount point&#39;s parent and stat() of the mount point returning fileids as previously described. The mounted_on_fileid attribute corresponds to the fileid that readdir() would have returned as described previously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン3とは異なり、NFSバージョン4では、クライアントのLOOKUP要求が他のファイルシステムを通過することができます。クライアントは、LOOKUPのfilehandle引数に、LOOKUPから返されたファイルハンドルのfsid属性とは異なるfsid属性がある場合に、ファイルシステムの交差を検出します。 UNIXベースのクライアントは、これを「マウントポイントクロッシング」と見なします。 UNIXには、プロセスが現在の作業ディレクトリを決定できるようにするためのレガシースキームがあります。これは、前述のように、マウントポイントの親のreaddir()とマウントポイントのstat()がファイルIDを返すことに依存しています。 Mounted_on_fileid属性は、前述のようにreaddir()が返すはずのファイルIDに対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the NFS version 4 client could simply fabricate a fileid corresponding to what mounted_on_fileid provides (and if the server does not support mounted_on_fileid, the client has no choice), there is a risk that the client will generate a fileid that conflicts with one that is already assigned to another object in the filesystem. Instead, if the server can provide the mounted_on_fileid, the potential for client operational problems in this area is eliminated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4クライアントは、mounted_on_fileidが提供するものに対応するファイルIDを単純に作成することができます（サーバーがMounted_on_fileidをサポートしていない場合、クライアントは選択肢がありません）、クライアントが、ファイルシステムの別のオブジェクトにすでに割り当てられています。代わりに、サーバーがMounted_on_fileidを提供できる場合、この領域でのクライアントの操作上の問題の可能性が排除されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server detects that there is no mounted point at the target file object, then the value for mounted_on_fileid that it returns is the same as that of the fileid attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットファイルオブジェクトにマウントされたポイントがないことをサーバーが検出した場合、サーバーが返すMounted_on_fileidの値は、fileid属性の値と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mounted_on_fileid attribute is RECOMMENDED, so the server SHOULD provide it if possible, and for a UNIX-based server, this is straightforward. Usually, mounted_on_fileid will be requested during a READDIR operation, in which case it is trivial (at least for UNIX-based servers) to return mounted_on_fileid since it is equal to the fileid of a directory entry returned by readdir(). If mounted_on_fileid is requested in a GETATTR operation, the server should obey an invariant that has it returning a value that is equal to the file object&#39;s entry in the object&#39;s parent directory, i.e., what readdir() would have returned. Some operating environments allow a series of two or more filesystems to be mounted onto a single mount point. In this case, for the server to obey the aforementioned invariant, it will need to find the base mount point, and not the intermediate mount points.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mounted_on_fileid属性は推奨されるので、サーバーは可能であればそれを提供する必要があります（SHOULD）。UNIXベースのサーバーの場合、これは簡単です。通常、mounted_on_fileidはREADDIR操作中に要求されます。その場合、readdir()によって返されるディレクトリエントリのfileidと等しいため、mounted_on_fileidを返すのは（少なくともUNIXベースのサーバーの場合）簡単です。 GETATTR操作でMounted_on_fileidが要求された場合、サーバーは、オブジェクトの親ディレクトリにあるファイルオブジェクトのエントリと等しい値を返す不変条件に従う必要があります。つまり、readdir()が返す結果になります。一部のオペレーティング環境では、一連の2つ以上のファイルシステムを単一のマウントポイントにマウントできます。この場合、サーバーが前述の不変式に従うためには、中間マウントポイントではなく、ベースマウントポイントを見つける必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Filesystem-Migration-and-Replication">
6. Filesystem Migration and Replication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. ファイルシステムの移行と複製
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the use of the recommended attribute &#34;fs_locations&#34;, the NFS version 4 server has a method of providing filesystem migration or replication services. For the purposes of migration and replication, a filesystem will be defined as all files that share a given fsid (both major and minor values are the same).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
推奨属性「fs_locations」を使用すると、NFSバージョン4サーバーには、ファイルシステムの移行または複製サービスを提供する方法があります。移行と複製の目的で、ファイルシステムは、指定されたfsidを共有するすべてのファイルとして定義されます（メジャー値とマイナー値は同じです）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_locations attribute provides a list of filesystem locations. These locations are specified by providing the server name (either DNS domain or IP address) and the path name representing the root of the filesystem. Depending on the type of service being provided, the list will provide a new location or a set of alternate locations for the filesystem. The client will use this information to redirect its requests to the new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations属性は、ファイルシステムの場所のリストを提供します。これらの場所は、サーバー名（DNSドメインまたはIPアドレスのいずれか）とファイルシステムのルートを表すパス名を指定することによって指定されます。提供されるサービスのタイプに応じて、リストにはファイルシステムの新しい場所または一連の代替場所が表示されます。クライアントはこの情報を使用して、要求を新しいサーバーにリダイレクトします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-1--Replication">
6.1. Replication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. レプリケーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 It is expected that filesystem replication will be used in the case of read-only data. Typically, the filesystem will be replicated on two or more servers. The fs_locations attribute will provide the list of these locations to the client. On first access of the filesystem, the client should obtain the value of the fs_locations attribute. If, in the future, the client finds the server unresponsive, the client may attempt to use another server specified by fs_locations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
読み取り専用データの場合、ファイルシステムの複製が使用されることが予想されます。通常、ファイルシステムは2つ以上のサーバーに複製されます。 fs_locations属性は、これらの場所のリストをクライアントに提供します。ファイルシステムへの最初のアクセス時に、クライアントはfs_locations属性の値を取得する必要があります。将来クライアントがサーバーが応答しないと判断した場合、クライアントはfs_locationsで指定された別のサーバーを使用しようとする可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If applicable, the client must take the appropriate steps to recover valid filehandles from the new server. This is described in more detail in the following sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
該当する場合、クライアントは適切な手順を実行して、新しいサーバーから有効なファイルハンドルを回復する必要があります。これについては、次のセクションで詳しく説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2--Migration">
6.2. Migration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. マイグレーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Filesystem migration is used to move a filesystem from one server to another. Migration is typically used for a filesystem that is writable and has a single copy. The expected use of migration is for load balancing or general resource reallocation. The protocol does not specify how the filesystem will be moved between servers. This server-to-server transfer mechanism is left to the server implementor. However, the method used to communicate the migration event between client and server is specified here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムの移行は、サーバー間でファイルシステムを移動するために使用されます。移行は通常、書き込み可能で単一のコピーを持つファイルシステムに使用されます。予想される移行の用途は、負荷分散または一般的なリソースの再割り当てです。プロトコルは、サーバー間でのファイルシステムの移動方法を指定しません。このサーバー間の転送メカニズムは、サーバーの実装者に任されています。ただし、クライアントとサーバー間の移行イベントの通信に使用される方法は、ここで指定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the servers participating in the migration have completed the move of the filesystem, the error NFS4ERR_MOVED will be returned for subsequent requests received by the original server. The NFS4ERR_MOVED error is returned for all operations except PUTFH and GETATTR. Upon receiving the NFS4ERR_MOVED error, the client will obtain the value of the fs_locations attribute. The client will then use the contents of the attribute to redirect its requests to the specified server. To facilitate the use of GETATTR, operations such as PUTFH must also be accepted by the server for the migrated file system&#39;s filehandles. Note that if the server returns NFS4ERR_MOVED, the server MUST support the fs_locations attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
移行に参加しているサーバーがファイルシステムの移動を完了すると、元のサーバーが受信した後続の要求に対してエラーNFS4ERR_MOVEDが返されます。 NFS4ERR_MOVEDエラーは、PUTFHおよびGETATTRを除くすべての操作で返されます。 NFS4ERR_MOVEDエラーを受信すると、クライアントはfs_locations属性の値を取得します。次に、クライアントは属性の内容を使用して、その要求を指定されたサーバーにリダイレクトします。 GETATTRの使用を容易にするために、移行されたファイルシステムのファイルハンドルについて、PUTFHなどの操作もサーバーで受け入れられる必要があります。サーバーがNFS4ERR_MOVEDを返す場合、サーバーはfs_locations属性をサポートする必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client requests more attributes than just fs_locations, the server may return fs_locations only. This is to be expected since the server has migrated the filesystem and may not have a method of obtaining additional attribute data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがfs_locations以外の属性を要求した場合、サーバーはfs_locationsのみを返す場合があります。サーバーはファイルシステムを移行しており、追加の属性データを取得する方法がない可能性があるため、これは予想されることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server implementor needs to be careful in developing a migration solution. The server must consider all of the state information clients may have outstanding at the server. This includes but is not limited to locking/share state, delegation state, and asynchronous file writes which are represented by WRITE and COMMIT verifiers. The server should strive to minimize the impact on its clients during and after the migration process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー実装者は、移行ソリューションの開発に注意する必要があります。サーバーは、クライアントがサーバーで未処理になっている可能性があるすべての状態情報を考慮する必要があります。これには、ロック/共有状態、委任状態、およびWRITEおよびCOMMITベリファイアによって表される非同期ファイル書き込みが含まれますが、これらに限定されません。サーバーは、移行プロセス中および移行後のクライアントへの影響を最小限に抑えるよう努めるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-3--Interpretation-of-the-fslocations-Attribute">
6.3. Interpretation of the fs_locations Attribute
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. fs_locations属性の解釈
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_location attribute is structured in the following way:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_location属性は、次のように構造化されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fs_location {
           utf8str_cis     server&lt;&gt;;
           pathname4       rootpath;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fs_locations {
           pathname4       fs_root;
           fs_location     locations&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_location struct is used to represent the location of a filesystem by providing a server name and the path to the root of the filesystem. For a multi-homed server or a set of servers that use the same rootpath, an array of server names may be provided. An entry in the server array is an UTF8 string and represents one of a traditional DNS host name, IPv4 address, or IPv6 address. It is not a requirement that all servers that share the same rootpath be listed in one fs_location struct. The array of server names is provided for convenience. Servers that share the same rootpath may also be listed in separate fs_location entries in the fs_locations attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_location構造体は、サーバー名とファイルシステムのルートへのパスを提供することにより、ファイルシステムの場所を表すために使用されます。同じrootpathを使用するマルチホームサーバーまたはサーバーのセットの場合、サーバー名の配列が提供される場合があります。サーバー配列のエントリはUTF8文字列であり、従来のDNSホスト名、IPv4アドレス、またはIPv6アドレスの1つを表します。同じrootpathを共有するすべてのサーバーを1つのfs_location構造体にリストする必要はありません。サーバー名の配列は、便宜上提供されています。同じルートパスを共有するサーバーは、fs_locations属性の個別のfs_locationエントリにリストされる場合もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_locations struct and attribute then contains an array of locations. Since the name space of each server may be constructed differently, the &#34;fs_root&#34; field is provided. The path represented by fs_root represents the location of the filesystem in the server&#39;s name space. Therefore, the fs_root path is only associated with the server from which the fs_locations attribute was obtained. The fs_root path is meant to aid the client in locating the filesystem at the various servers listed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations構造体と属性には、場所の配列が含まれます。各サーバーの名前空間は異なる方法で構築される可能性があるため、「fs_root」フィールドが提供されています。 fs_rootで表されるパスは、サーバーの名前空間でのファイルシステムの場所を表します。したがって、fs_rootパスは、fs_locations属性の取得元のサーバーにのみ関連付けられています。 fs_rootパスは、クライアントがリストされたさまざまなサーバーでファイルシステムを見つけるのを助けることを目的としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 As an example, there is a replicated filesystem located at two servers (servA and servB). At servA the filesystem is located at path &#34;/a/b/c&#34;. At servB the filesystem is located at path &#34;/x/y/z&#34;. In this example the client accesses the filesystem first at servA with a multi-component lookup path of &#34;/a/b/c/d&#34;. Since the client used a multi-component lookup to obtain the filehandle at &#34;/a/b/c/d&#34;, it is unaware that the filesystem&#39;s root is located in servA&#39;s name space at &#34;/a/b/c&#34;. When the client switches to servB, it will need to determine that the directory it first referenced at servA is now represented by the path &#34;/x/y/z/d&#34; on servB. To facilitate this, the fs_locations attribute provided by servA would have a fs_root value of &#34;/a/b/c&#34; and two entries in fs_location. One entry in fs_location will be for itself (servA) and the other will be for servB with a path of &#34;/x/y/z&#34;. With this information, the client is able to substitute &#34;/x/y/z&#34; for the &#34;/a/b/c&#34; at the beginning of its access path and construct &#34;/x/y/z/d&#34; to use for the new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
例として、2つのサーバー（servAとservB）に複製されたファイルシステムがあります。 servAでは、ファイルシステムはパス &#34;/ a / b / c&#34;にあります。 servBでは、ファイルシステムはパス &#34;/ x / y / z&#34;にあります。この例では、クライアントは最初にservAで「/ a / b / c / d」のマルチコンポーネントルックアップパスを使用してファイルシステムにアクセスします。クライアントは「/ a / b / c / d」でファイルハンドルを取得するためにマルチコンポーネントルックアップを使用したため、ファイルシステムのルートが「/ a / b / c」でservAの名前空間にあることは認識されません。クライアントがservBに切り替わるとき、servAで最初に参照されたディレクトリがservBのパス &#34;/ x / y / z / d&#34;で表されていることを確認する必要があります。これを容易にするために、servAによって提供されるfs_locations属性は、 &#34;/ a / b / c&#34;のfs_root値と、fs_locationに2つのエントリーを持っています。 fs_locationの1つのエントリはそれ自体（servA）用であり、もう1つは &#34;/ x / y / z&#34;のパスを持つservB用です。この情報を使用して、クライアントはアクセスパスの先頭にある「/ a / b / c」を「/ x / y / z」に置き換え、「/ x / y / z / d」を構成して、新しいサーバー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See the section &#34;Security Considerations&#34; for a discussion on the recommendations for the security flavor to be used by any GETATTR operation that requests the &#34;fs_locations&#34; attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「fs_locations」属性を要求するGETATTR操作で使用されるセキュリティフレーバーの推奨事項については、「セキュリティに関する考慮事項」のセクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-4--Filehandle-Recovery-for-Migration-or-Replication">
6.4. Filehandle Recovery for Migration or Replication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. 移行または複製のためのファイルハンドルの回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Filehandles for filesystems that are replicated or migrated generally have the same semantics as for filesystems that are not replicated or migrated. For example, if a filesystem has persistent filehandles and it is migrated to another server, the filehandle values for the filesystem will be valid at the new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複製または移行されるファイルシステムのファイルハンドルは、通常、複製または移行されないファイルシステムの場合と同じセマンティクスを持っています。たとえば、ファイルシステムに永続的なファイルハンドルがあり、それが別のサーバーに移行された場合、ファイルシステムのファイルハンドル値は新しいサーバーで有効になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For volatile filehandles, the servers involved likely do not have a mechanism to transfer filehandle format and content between themselves. Therefore, a server may have difficulty in determining if a volatile filehandle from an old server should return an error of NFS4ERR_FHEXPIRED. Therefore, the client is informed, with the use of the fh_expire_type attribute, whether volatile filehandles will expire at the migration or replication event. If the bit FH4_VOL_MIGRATION is set in the fh_expire_type attribute, the client must treat the volatile filehandle as if the server had returned the NFS4ERR_FHEXPIRED error. At the migration or replication event in the presence of the FH4_VOL_MIGRATION bit, the client will not present the original or old volatile filehandle to the new server. The client will start its communication with the new server by recovering its filehandles using the saved file names.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性ファイルハンドルの場合、関連するサーバーには、ファイルハンドル形式とコンテンツをサーバー間で転送するメカニズムがない可能性があります。したがって、サーバーは、古いサーバーからの揮発性ファイルハンドルがNFS4ERR_FHEXPIREDのエラーを返すかどうかを判断するのが難しい場合があります。したがって、fh_expire_type属性を使用すると、揮発性ファイルハンドルが移行またはレプリケーションイベントで期限切れになるかどうかがクライアントに通知されます。 FH4_VOL_MIGRATIONビットがfh_expire_type属性で設定されている場合、クライアントは、サーバーがNFS4ERR_FHEXPIREDエラーを返したかのように、揮発性ファイルハンドルを処理する必要があります。 FH4_VOL_MIGRATIONビットが存在する状態での移行または複製イベントでは、クライアントは元のまたは古い揮発性ファイルハンドルを新しいサーバーに提示しません。クライアントは、保存されたファイル名を使用してファイルハンドルを回復することにより、新しいサーバーとの通信を開始します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--NFS-Server-Name-Space">
7. NFS Server Name Space
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. NFSサーバー名前空間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-1--Server-Exports">
7.1. Server Exports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. サーバーのエクスポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On a UNIX server the name space describes all the files reachable by pathnames under the root directory or &#34;/&#34;. On a Windows NT server the name space constitutes all the files on disks named by mapped disk letters. NFS server administrators rarely make the entire server&#39;s filesystem name space available to NFS clients. More often portions of the name space are made available via an &#34;export&#34; feature. In previous versions of the NFS protocol, the root filehandle for each export is obtained through the MOUNT protocol; the client sends a string that identifies the export of name space and the server returns the root filehandle for it. The MOUNT protocol supports an EXPORTS procedure that will enumerate the server&#39;s exports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNIXサーバーでは、名前空間は、ルートディレクトリまたは「/」の下のパス名によって到達可能なすべてのファイルを記述します。 Windows NTサーバーでは、名前空間は、マップされたディスク文字によって名前が付けられたディスク上のすべてのファイルを構成します。 NFSサーバー管理者がサーバーのファイルシステム全体の名前空間をNFSクライアントが使用できるようにすることはほとんどありません。多くの場合、名前空間の一部は「エクスポート」機能を介して利用可能になります。以前のバージョンのNFSプロトコルでは、各エクスポートのルートファイルハンドルはMOUNTプロトコルを介して取得されました。クライアントは名前空間のエクスポートを識別する文字列を送信し、サーバーはそのルートファイルハンドルを返します。 MOUNTプロトコルは、サーバーのエクスポートを列挙するEXPORTSプロシージャをサポートしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-2--Browsing-Exports">
7.2. Browsing Exports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. エクスポートの閲覧
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 protocol provides a root filehandle that clients can use to obtain filehandles for these exports via a multi-component LOOKUP. A common user experience is to use a graphical user interface (perhaps a file &#34;Open&#34; dialog window) to find a file via progressive browsing through a directory tree. The client must be able to move from one export to another export via single-component, progressive LOOKUP operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルは、クライアントがマルチコンポーネントLOOKUPを介してこれらのエクスポートのファイルハンドルを取得するために使用できるルートファイルハンドルを提供します。一般的なユーザーエクスペリエンスは、グラフィカルユーザーインターフェイス（おそらくファイルの[開く]ダイアログウィンドウ）を使用して、ディレクトリツリーを順次参照してファイルを見つけることです。クライアントは、単一コンポーネントのプログレッシブLOOKUP操作を介して、あるエクスポートから別のエクスポートに移動できる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This style of browsing is not well supported by the NFS version 2 and 3 protocols. The client expects all LOOKUP operations to remain within a single server filesystem. For example, the device attribute will not change. This prevents a client from taking name space paths that span exports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このブラウジングのスタイルは、NFSバージョン2および3プロトコルでは十分にサポートされていません。クライアントは、すべてのLOOKUP操作が単一のサーバーファイルシステム内に留まることを期待しています。たとえば、デバイス属性は変更されません。これにより、クライアントは、複数のエクスポートにまたがる名前空間パスを取得できなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An automounter on the client can obtain a snapshot of the server&#39;s name space using the EXPORTS procedure of the MOUNT protocol. If it understands the server&#39;s pathname syntax, it can create an image of the server&#39;s name space on the client. The parts of the name space that are not exported by the server are filled in with a &#34;pseudo filesystem&#34; that allows the user to browse from one mounted filesystem to another. There is a drawback to this representation of the server&#39;s name space on the client: it is static. If the server administrator adds a new export the client will be unaware of it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのオートマウンタは、MOUNTプロトコルのEXPORTSプロシージャを使用して、サーバーの名前空間のスナップショットを取得できます。サーバーのパス名構文を理解していれば、クライアント上にサーバーの名前空間のイメージを作成できます。サーバーによってエクスポートされない名前空間の部分は、ユーザーが1つのマウントされたファイルシステムから別のファイルシステムにブラウズできるようにする「疑似ファイルシステム」で埋められます。クライアント上のサーバーの名前空間のこの表現には欠点があります。それは静的なものです。サーバー管理者が新しいエクスポートを追加した場合、クライアントはそれを認識しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-3--Server-Pseudo-Filesystem">
7.3. Server Pseudo Filesystem
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. サーバー疑似ファイルシステム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS version 4 servers avoid this name space inconsistency by presenting all the exports within the framework of a single server name space. An NFS version 4 client uses LOOKUP and READDIR operations to browse seamlessly from one export to another. Portions of the server name space that are not exported are bridged via a &#34;pseudo filesystem&#34; that provides a view of exported directories only. A pseudo filesystem has a unique fsid and behaves like a normal, read only filesystem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4サーバーは、単一のサーバー名前空間のフレームワーク内ですべてのエクスポートを提示することにより、この名前空間の不整合を回避します。 NFSバージョン4クライアントは、LOOKUPおよびREADDIR操作を使用して、1つのエクスポートから別のエクスポートへシームレスにブラウズします。エクスポートされないサーバー名前空間の部分は、エクスポートされたディレクトリのみのビューを提供する「疑似ファイルシステム」を介してブリッジされます。疑似ファイルシステムには固有のfsidがあり、通常の読み取り専用ファイルシステムのように動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on the construction of the server&#39;s name space, it is possible that multiple pseudo filesystems may exist. For example,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの名前空間の構成に基づいて、複数の疑似ファイルシステムが存在する可能性があります。例えば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /a         pseudo filesystem
   /a/b       real filesystem
   /a/b/c     pseudo filesystem
   /a/b/c/d   real filesystem
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each of the pseudo filesystems are considered separate entities and therefore will have a unique fsid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各疑似ファイルシステムは個別のエンティティと見なされるため、一意のfsidを持ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-4--Multiple-Roots">
7.4. Multiple Roots
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. 複数の根
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DOS and Windows operating environments are sometimes described as having &#34;multiple roots&#34;. Filesystems are commonly represented as disk letters. MacOS represents filesystems as top level names. NFS version 4 servers for these platforms can construct a pseudo file system above these root names so that disk letters or volume names are simply directory names in the pseudo root.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DOSおよびWindowsオペレーティング環境は、「複数のルート」を持つものとして説明されることがあります。ファイルシステムは通常、ディスク文字として表されます。 MacOSはファイルシステムをトップレベルの名前として表します。これらのプラットフォーム用のNFSバージョン4サーバーは、これらのルート名の上に疑似ファイルシステムを構築できるため、ディスク文字またはボリューム名は疑似ルート内の単なるディレクトリ名になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-5--Filehandle-Volatility">
7.5. Filehandle Volatility
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5. ファイルハンドルのボラティリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nature of the server&#39;s pseudo filesystem is that it is a logical representation of filesystem(s) available from the server. Therefore, the pseudo filesystem is most likely constructed dynamically when the server is first instantiated. It is expected that the pseudo filesystem may not have an on disk counterpart from which persistent filehandles could be constructed. Even though it is preferable that the server provide persistent filehandles for the pseudo filesystem, the NFS client should expect that pseudo file system filehandles are volatile. This can be confirmed by checking the associated &#34;fh_expire_type&#34; attribute for those filehandles in question. If the filehandles are volatile, the NFS client must be prepared to recover a filehandle value (e.g., with a multi-component LOOKUP) when receiving an error of NFS4ERR_FHEXPIRED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの疑似ファイルシステムの性質は、サーバーから利用可能なファイルシステムの論理表現であるということです。したがって、サーバーが最初にインスタンス化されるときに、疑似ファイルシステムが動的に構築される可能性が最も高くなります。疑似ファイルシステムには、永続的なファイルハンドルを構築できるディスク上の対応物がない可能性があります。サーバーが疑似ファイルシステムに永続的なファイルハンドルを提供することが望ましい場合でも、NFSクライアントは疑似ファイルシステムのファイルハンドルが揮発性であることを期待する必要があります。これは、問題のファイルハンドルの関連する「fh_expire_type」属性を確認することで確認できます。ファイルハンドルが揮発性の場合、NFS4ERR_FHEXPIREDのエラーを受信したときに、ファイルハンドル値を回復するために（たとえば、マルチコンポーネントLOOKUPを使用して）NFSクライアントを準備する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-6--Exported-Root">
7.6. Exported Root
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6. エクスポートされたルート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server&#39;s root filesystem is exported, one might conclude that a pseudo-filesystem is not needed. This would be wrong. Assume the following filesystems on a server:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーのルートファイルシステムがエクスポートされた場合、疑似ファイルシステムは必要ないと結論するかもしれません。これは間違っているでしょう。サーバー上に次のファイルシステムがあるとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         /       disk1  (exported)
         /a      disk2  (not exported)
         /a/b    disk3  (exported)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because disk2 is not exported, disk3 cannot be reached with simple LOOKUPs. The server must bridge the gap with a pseudo-filesystem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
disk2はエクスポートされないため、単純なLOOKUPでdisk3に到達することはできません。サーバーは、疑似ファイルシステムでギャップを埋める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-7--Mount-Point-Crossing">
7.7. Mount Point Crossing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.7. マウントポイントクロッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server filesystem environment may be constructed in such a way that one filesystem contains a directory which is &#39;covered&#39; or mounted upon by a second filesystem. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーのファイルシステム環境は、1つのファイルシステムが2番目のファイルシステムによって「カバー」またはマウントされるディレクトリを含むように構築できます。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         /a/b            (filesystem 1)
         /a/b/c/d        (filesystem 2)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The pseudo filesystem for this server may be constructed to look like:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このサーバーの疑似ファイルシステムは、次のように構築できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         /               (place holder/not exported)
         /a/b            (filesystem 1)
         /a/b/c/d        (filesystem 2)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is the server&#39;s responsibility to present the pseudo filesystem that is complete to the client. If the client sends a lookup request for the path &#34;/a/b/c/d&#34;, the server&#39;s response is the filehandle of the filesystem &#34;/a/b/c/d&#34;. In previous versions of the NFS protocol, the server would respond with the filehandle of directory &#34;/a/b/c/d&#34; within the filesystem &#34;/a/b&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
完全な疑似ファイルシステムをクライアントに提示するのはサーバーの責任です。クライアントがパス「/ a / b / c / d」の検索要求を送信する場合、サーバーの応答はファイルシステム「/ a / b / c / d」のファイルハンドルです。 NFSプロトコルの以前のバージョンでは、サーバーはファイルシステム「/ a / b」内のディレクトリ「/ a / b / c / d」のファイルハンドルで応答しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS client will be able to determine if it crosses a server mount point by a change in the value of the &#34;fsid&#34; attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSクライアントは、「fsid」属性の値を変更することで、サーバーのマウントポイントを通過するかどうかを判別できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-8--Security-Policy-and-Name-Space-Presentation">
7.8. Security Policy and Name Space Presentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.8. セキュリティポリシーと名前空間の表示
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The application of the server&#39;s security policy needs to be carefully considered by the implementor. One may choose to limit the viewability of portions of the pseudo filesystem based on the server&#39;s perception of the client&#39;s ability to authenticate itself properly. However, with the support of multiple security mechanisms and the ability to negotiate the appropriate use of these mechanisms, the server is unable to properly determine if a client will be able to authenticate itself. If, based on its policies, the server chooses to limit the contents of the pseudo filesystem, the server may effectively hide filesystems from a client that may otherwise have legitimate access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーのセキュリティポリシーの適用は、実装者が慎重に検討する必要があります。クライアントが自分自身を適切に認証する能力に対するサーバーの認識に基づいて、疑似ファイルシステムの一部の視認性を制限することを選択できます。ただし、複数のセキュリティメカニズムのサポートと、これらのメカニズムの適切な使用をネゴシエートする機能により、サーバーは、クライアントが自身を認証できるかどうかを適切に判断できません。そのポリシーに基づいて、サーバーが疑似ファイルシステムのコンテンツを制限することを選択した場合、サーバーは、正当なアクセス権を持つクライアントからファイルシステムを効果的に隠すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As suggested practice, the server should apply the security policy of a shared resource in the server&#39;s namespace to the components of the resource&#39;s ancestors. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
推奨される方法として、サーバーはサーバーの名前空間にある共有リソースのセキュリティポリシーをリソースの祖先のコンポーネントに適用する必要があります。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         /
         /a/b
         /a/b/c
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The /a/b/c directory is a real filesystem and is the shared resource. The security policy for /a/b/c is Kerberos with integrity. The server should apply the same security policy to /, /a, and /a/b. This allows for the extension of the protection of the server&#39;s namespace to the ancestors of the real shared resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
/ a / b / cディレクトリは実際のファイルシステムであり、共有リソースです。 / a / b / cのセキュリティポリシーは、完全性を備えたKerberosです。サーバーは同じセキュリティポリシーを/、/ a、および/ a / bに適用する必要があります。これにより、サーバーの名前空間の保護を実際の共有リソースの祖先に拡張できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the case of the use of multiple, disjoint security mechanisms in the server&#39;s resources, the security for a particular object in the server&#39;s namespace should be the union of all security mechanisms of all direct descendants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーのリソースで複数の分離したセキュリティメカニズムを使用する場合、サーバーの名前空間の特定のオブジェクトのセキュリティは、すべての直接の子孫のすべてのセキュリティメカニズムの和集合でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--File-Locking-and-Share-Reservations">
8. File Locking and Share Reservations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. ファイルのロックと共有の予約
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Integrating locking into the NFS protocol necessarily causes it to be stateful. With the inclusion of share reservations the protocol becomes substantially more dependent on state than the traditional combination of NFS and NLM [XNFS]. There are three components to making this state manageable:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックをNFSプロトコルに統合すると、必然的にそれがステートフルになります。共有予約を含めると、プロトコルは、NFSとNLMの従来の組み合わせ[XNFS]よりも大幅に状態に依存するようになります。この状態を管理可能にするための3つのコンポーネントがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Clear division between client and server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントとサーバーの明確な区別
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Ability to reliably detect inconsistency in state between client and server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントとサーバー間の状態の不整合を確実に検出する機能
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Simple and robust recovery mechanisms
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o シンプルで堅牢な回復メカニズム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this model, the server owns the state information. The client communicates its view of this state to the server as needed. The client is also able to detect inconsistent state before modifying a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このモデルでは、サーバーが状態情報を所有します。クライアントは、必要に応じて、この状態のビューをサーバーに伝えます。クライアントは、ファイルを変更する前に、矛盾した状態を検出することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To support Win32 share reservations it is necessary to atomically OPEN or CREATE files. Having a separate share/unshare operation would not allow correct implementation of the Win32 OpenFile API. In order to correctly implement share semantics, the previous NFS protocol mechanisms used when a file is opened or created (LOOKUP, CREATE, ACCESS) need to be replaced. The NFS version 4 protocol has an OPEN operation that subsumes the NFS version 3 methodology of LOOKUP, CREATE, and ACCESS. However, because many operations require a filehandle, the traditional LOOKUP is preserved to map a file name to filehandle without establishing state on the server. The policy of granting access or modifying files is managed by the server based on the client&#39;s state. These mechanisms can implement policy ranging from advisory only locking to full mandatory locking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Win32共有予約をサポートするには、ファイルをアトミックにOPENまたはCREATEする必要があります。個別の共有/共有解除操作があると、Win32 OpenFile APIを正しく実装できません。共有セマンティクスを正しく実装するには、ファイルを開いたり作成したりするときに使用されていた以前のNFSプロトコルメカニズム（LOOKUP、CREATE、ACCESS）を置き換える必要があります。 NFSバージョン4プロトコルには、LOOKUP、CREATE、およびACCESSのNFSバージョン3手法を包含するOPEN操作があります。ただし、多くの操作にはファイルハンドルが必要なため、サーバーで状態を確立せずにファイル名をファイルハンドルにマップするために、従来のLOOKUPが維持されます。アクセスの許可またはファイルの変更のポリシーは、クライアントの状態に基づいてサーバーによって管理されます。これらのメカニズムは、アドバイザリーのみのロックから完全な必須ロックまでのポリシーを実装できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1--Locking">
8.1. Locking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. ロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is assumed that manipulating a lock is rare when compared to READ and WRITE operations. It is also assumed that crashes and network partitions are relatively rare. Therefore it is important that the READ and WRITE operations have a lightweight mechanism to indicate if they possess a held lock. A lock request contains the heavyweight information required to establish a lock and uniquely define the lock owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READおよびWRITE操作と比較した場合、ロックの操作はまれであると想定されています。また、クラッシュやネットワークパーティションが比較的まれであることも想定されています。したがって、READおよびWRITE操作には、ロックが保持されているかどうかを示す軽量のメカニズムがあることが重要です。ロック要求には、ロックを確立し、ロック所有者を一意に定義するために必要な重い情報が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following sections describe the transition from the heavy weight information to the eventual stateid used for most client and server locking and lease interactions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のセクションでは、重い情報から、ほとんどのクライアントおよびサーバーのロックとリースの相互作用に使用される最終的なステートIDへの移行について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1-1--Client-ID">
8.1.1. Client ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1. クライアントID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each LOCK request, the client must identify itself to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK要求ごとに、クライアントはサーバーに対して自身を識別する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is done in such a way as to allow for correct lock identification and crash recovery. A sequence of a SETCLIENTID operation followed by a SETCLIENTID_CONFIRM operation is required to establish the identification onto the server. Establishment of identification by a new incarnation of the client also has the effect of immediately breaking any leased state that a previous incarnation of the client might have had on the server, as opposed to forcing the new client incarnation to wait for the leases to expire. Breaking the lease state amounts to the server removing all lock, share reservation, and, where the server is not supporting the CLAIM_DELEGATE_PREV claim type, all delegation state associated with same client with the same identity. For discussion of delegation state recovery, see the section &#34;Delegation Recovery&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、正しいロックの識別とクラッシュの回復を可能にするような方法で行われます。サーバー上でIDを確立するには、SETCLIENTID操作とそれに続くSETCLIENTID_CONFIRM操作のシーケンスが必要です。また、クライアントの新しいインカネーションによる識別の確立は、クライアントの以前のインカネーションがサーバー上で持っていた可能性のあるリース状態を、新しいクライアントのインカネーションがリースの期限が切れるのを待つのを強いるのとは対照的に、即座に壊す効果があります。リース状態を解除すると、サーバーはすべてのロック、共有予約を削除し、サーバーがCLAIM_DELEGATE_PREVクレームタイプをサポートしていない場合は、同じIDを持つ同じクライアントに関連付けられたすべての委任状態になります。委任状態の回復については、「委任の回復」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client identification is encapsulated in the following structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントIDは次の構造でカプセル化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         struct nfs_client_id4 {
                 verifier4     verifier;
                 opaque        id&lt;NFS4_OPAQUE_LIMIT&gt;;
         };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first field, verifier is a client incarnation verifier that is used to detect client reboots. Only if the verifier is different from that which the server has previously recorded the client (as identified by the second field of the structure, id) does the server start the process of canceling the client&#39;s leased state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のフィールドであるベリファイアは、クライアントの再起動を検出するために使用されるクライアントインカネーションベリファイアです。ベリファイアがサーバーが以前にクライアントを記録したもの（構造体の2番目のフィールド、idで識別される）と異なる場合のみ、サーバーはクライアントのリース状態をキャンセルするプロセスを開始します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second field, id is a variable length string that uniquely defines the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2番目のフィールドidは、クライアントを一意に定義する可変長文字列です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are several considerations for how the client generates the id string:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがID文字列を生成する方法には、いくつかの考慮事項があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The string should be unique so that multiple clients do not present the same string. The consequences of two clients presenting the same string range from one client getting an error to one client having its leased state abruptly and unexpectedly canceled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 複数のクライアントが同じ文字列を提示しないように、文字列は一意である必要があります。 2つのクライアントが同じ文字列を提示することによる影響は、1つのクライアントがエラーを取得することから、1つのクライアントがリース状態を突然予期せずにキャンセルすることまでさまざまです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The string should be selected so the subsequent incarnations (e.g., reboots) of the same client cause the client to present the same string. The implementor is cautioned against an approach that requires the string to be recorded in a local file because this precludes the use of the implementation in an environment where there is no local disk and all file access is from an NFS version 4 server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 同じクライアントの後続のインカネーション（再起動など）がクライアントに同じ文字列を表示させるように、文字列を選択する必要があります。ローカルディスクがなく、すべてのファイルアクセスがNFSバージョン4サーバーからの環境で実装を使用できないため、文字列をローカルファイルに記録する必要があるアプローチに対して実装者は警告されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The string should be different for each server network address that the client accesses, rather than common to all server network addresses. The reason is that it may not be possible for the client to tell if the same server is listening on multiple network addresses. If the client issues SETCLIENTID with the same id string to each network address of such a server, the server will think it is the same client, and each successive SETCLIENTID will cause the server to begin the process of removing the client&#39;s previous leased state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 文字列は、すべてのサーバーネットワークアドレスに共通するのではなく、クライアントがアクセスするサーバーネットワークアドレスごとに異なる必要があります。その理由は、同じサーバーが複数のネットワークアドレスでリッスンしているかどうかをクライアントが判断できない可能性があるためです。クライアントがそのようなサーバーの各ネットワークアドレスに同じID文字列でSETCLIENTIDを発行すると、サーバーはそれを同じクライアントであると見なし、後続の各SETCLIENTIDによってサーバーはクライアントの以前のリース状態を削除するプロセスを開始します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The algorithm for generating the string should not assume that the client&#39;s network address won&#39;t change. This includes changes between client incarnations and even changes while the client is stilling running in its current incarnation. This means that if the client includes just the client&#39;s and server&#39;s network address in the id string, there is a real risk, after the client gives up the network address, that another client, using a similar algorithm for generating the id string, will generate a conflicting id string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 文字列を生成するアルゴリズムは、クライアントのネットワークアドレスが変更されないことを前提としてはなりません。これには、クライアントインカネーション間の変更や、クライアントが現在のインカネーションで実行されている間の変更も含まれます。これは、クライアントがid文字列にクライアントとサーバーのネットワークアドレスのみを含んでいる場合、クライアントがネットワークアドレスを放棄した後、id文字列を生成するための同様のアルゴリズムを使用する別のクライアントが競合するID文字列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given the above considerations, an example of a well generated id string is one that includes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の考慮事項を踏まえると、適切に生成されたid文字列の例は、次のものを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server&#39;s network address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーのネットワークアドレス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client&#39;s network address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントのネットワークアドレス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For a user level NFS version 4 client, it should contain additional information to distinguish the client from other user level clients running on the same host, such as a process id or other unique sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ユーザーレベルのNFSバージョン4クライアントの場合、プロセスIDや他の一意のシーケンスなど、同じホスト上で実行されている他のユーザーレベルのクライアントからクライアントを区別するための追加情報を含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Additional information that tends to be unique, such as one or more of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 以下の1つ以上など、一意になる傾向がある追加情報。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The client machine&#39;s serial number (for privacy reasons, it is best to perform some one way function on the serial number).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- クライアントマシンのシリアル番号（プライバシー上の理由から、シリアル番号に対して一方向の機能を実行することをお勧めします）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- A MAC address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- MACアドレス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The timestamp of when the NFS version 4 software was first installed on the client (though this is subject to the previously mentioned caution about using information that is stored in a file, because the file might only be accessible over NFS version 4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- NFSバージョン4ソフトウェアがクライアントに最初にインストールされたときのタイムスタンプ（ただし、NFSバージョン4を介してのみファイルにアクセスできるため、ファイルに格納されている情報の使用に関する前述の注意が必要です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- A true random number. However since this number ought to be the same between client incarnations, this shares the same problem as that of the using the timestamp of the software installation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- 真の乱数。ただし、この数はクライアントのインカネーション間で同じである必要があるため、ソフトウェアインストールのタイムスタンプを使用する場合と同じ問題を共有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a security measure, the server MUST NOT cancel a client&#39;s leased state if the principal established the state for a given id string is not the same as the principal issuing the SETCLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティ対策として、プリンシパルが特定のID文字列の状態を確立した場合、サーバーはクライアントのリース状態をキャンセルしてはいけません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that SETCLIENTID and SETCLIENTID_CONFIRM has a secondary purpose of establishing the information the server needs to make callbacks to the client for purpose of supporting delegations. It is permitted to change this information via SETCLIENTID and SETCLIENTID_CONFIRM within the same incarnation of the client without removing the client&#39;s leased state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDおよびSETCLIENTID_CONFIRMには、サーバーが委任をサポートする目的でクライアントにコールバックを行うために必要な情報を確立するという二次的な目的があることに注意してください。クライアントのリース状態を削除せずに、クライアントの同じインカネーション内でSETCLIENTIDおよびSETCLIENTID_CONFIRMを介してこの情報を変更することが許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once a SETCLIENTID and SETCLIENTID_CONFIRM sequence has successfully completed, the client uses the shorthand client identifier, of type clientid4, instead of the longer and less compact nfs_client_id4 structure. This shorthand client identifier (a clientid) is assigned by the server and should be chosen so that it will not conflict with a clientid previously assigned by the server. This applies across server restarts or reboots. When a clientid is presented to a server and that clientid is not recognized, as would happen after a server reboot, the server will reject the request with the error NFS4ERR_STALE_CLIENTID. When this happens, the client must obtain a new clientid by use of the SETCLIENTID operation and then proceed to any other necessary recovery for the server reboot case (See the section &#34;Server Failure and Recovery&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDおよびSETCLIENTID_CONFIRMシーケンスが正常に完了すると、クライアントは、長くてコンパクトでないnfs_client_id4構造体の代わりに、clientid4タイプの短縮クライアント識別子を使用します。この省略形のクライアント識別子（clientid）はサーバーによって割り当てられ、サーバーによって以前に割り当てられたclientidと競合しないように選択する必要があります。これは、サーバーの再起動または再起動全体に適用されます。サーバーにクライアントIDが提示され、そのクライアントIDが認識されない場合（サーバーのリブート後に発生する可能性があります）、サーバーはエラーNFS4ERR_STALE_CLIENTIDで要求を拒否します。これが発生した場合、クライアントはSETCLIENTID操作を使用して新しいclientidを取得し、サーバーの再起動の場合に必要なその他の回復に進む必要があります（「サーバーの障害と回復」のセクションを参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client must also employ the SETCLIENTID operation when it receives a NFS4ERR_STALE_STATEID error using a stateid derived from its current clientid, since this also indicates a server reboot which has invalidated the existing clientid (see the next section &#34;lock_owner and stateid Definition&#34; for details).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、クライアントは、現在のclientidから派生したstateidを使用してNFS4ERR_STALE_STATEIDエラーを受信したときにSETCLIENTID操作を使用する必要があります。これは、既存のclientidを無効にしたサーバーの再起動も示すためです（詳細については、次のセクション「lock_ownerおよびstateidの定義」を参照してください）。 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See the detailed descriptions of SETCLIENTID and SETCLIENTID_CONFIRM for a complete specification of the operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作の完全な仕様については、SETCLIENTIDおよびSETCLIENTID_CONFIRMの詳細な説明を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1-2--Server-Release-of-Clientid">
8.1.2. Server Release of Clientid
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2. Clientidのサーバーリリース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server determines that the client holds no associated state for its clientid, the server may choose to release the clientid. The server may make this choice for an inactive client so that resources are not consumed by those intermittently active clients. If the client contacts the server after this release, the server must ensure the client receives the appropriate error so that it will use the SETCLIENTID/SETCLIENTID_CONFIRM sequence to establish a new identity. It should be clear that the server must be very hesitant to release a clientid since the resulting work on the client to recover from such an event will be the same burden as if the server had failed and restarted. Typically a server would not release a clientid unless there had been no activity from that client for many minutes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがそのclientidに関連付けられた状態を保持していないとサーバーが判断した場合、サーバーはclientidを解放することを選択できます。サーバーは、非アクティブなクライアントに対してこの選択を行って、断続的にアクティブなクライアントによってリソースが消費されないようにすることができます。このリリースの後でクライアントがサーバーに接続する場合、サーバーは、クライアントが適切なエラーを受信して​​、SETCLIENTID / SETCLIENTID_CONFIRMシーケンスを使用して新しいIDを確立できるようにする必要があります。このようなイベントから回復するためのクライアントでの作業は、サーバーに障害が発生して再起動した場合と同じ負担になるため、サーバーがclientidを解放するのをためらう必要があることは明らかです。通常、サーバーは、そのクライアントから何分間もアクティビティがない場合を除いて、clientidを解放しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that if the id string in a SETCLIENTID request is properly constructed, and if the client takes care to use the same principal for each successive use of SETCLIENTID, then, barring an active denial of service attack, NFS4ERR_CLID_INUSE should never be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDリクエストのid文字列が適切に構成されていて、クライアントがSETCLIENTIDを連続して使用するたびに同じプリンシパルを使用する場合、アクティブなサービス拒否攻撃を禁止すると、NFS4ERR_CLID_INUSEが返されないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, client bugs, server bugs, or perhaps a deliberate change of the principal owner of the id string (such as the case of a client that changes security flavors, and under the new flavor, there is no mapping to the previous owner) will in rare cases result in NFS4ERR_CLID_INUSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、クライアントのバグ、サーバーのバグ、またはおそらくID文字列の主所有者の意図的な変更（セキュリティフレーバーを変更するクライアントの場合、新しいフレーバーでは、以前の所有者へのマッピングはありません）まれに、NFS4ERR_CLID_INUSEが発生する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In that event, when the server gets a SETCLIENTID for a client id that currently has no state, or it has state, but the lease has expired, rather than returning NFS4ERR_CLID_INUSE, the server MUST allow the SETCLIENTID, and confirm the new clientid if followed by the appropriate SETCLIENTID_CONFIRM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その場合、サーバーは、現在状態がないか、状態があるが、リースが期限切れであるクライアントIDのSETCLIENTIDを取得すると、NFS4ERR_CLID_INUSEを返すのではなく、SETCLIENTIDを許可し、その後に続く場合は新しいclientidを確認する必要があります。適切なSETCLIENTID_CONFIRM。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1-3--lockowner-and-stateid-Definition">
8.1.3. lock_owner and stateid Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.3. lock_ownerとstateidの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When requesting a lock, the client must present to the server the clientid and an identifier for the owner of the requested lock. These two fields are referred to as the lock_owner and the definition of those fields are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックを要求するとき、クライアントはサーバーにクライアントIDと要求されたロックの所有者の識別子を提示する必要があります。これらの2つのフィールドは、lock_ownerと呼ばれ、これらのフィールドの定義は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A clientid returned by the server as part of the client&#39;s use of the SETCLIENTID operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントによるSETCLIENTID操作の使用の一部としてサーバーから返されたclientid。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A variable length opaque array used to uniquely define the owner of a lock managed by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントが管理するロックの所有者を一意に定義するために使用される可変長の不透明な配列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This may be a thread id, process id, or other unique value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
これは、スレッドID、プロセスID、またはその他の一意の値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server grants the lock, it responds with a unique stateid. The stateid is used as a shorthand reference to the lock_owner, since the server will be maintaining the correspondence between them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがロックを許可すると、サーバーは一意の状態IDで応答します。サーバーはそれらの間の対応を維持するため、stateidはlock_ownerへの省略参照として使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server is free to form the stateid in any manner that it chooses as long as it is able to recognize invalid and out-of-date stateids. This requirement includes those stateids generated by earlier instances of the server. From this, the client can be properly notified of a server restart. This notification will occur when the client presents a stateid to the server from a previous instantiation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、無効で古くなった状態IDを認識できる限り、任意の方法で自由に状態IDを形成できます。この要件には、サーバーの以前のインスタンスによって生成された状態IDが含まれます。これにより、サーバーの再起動をクライアントに適切に通知できます。この通知は、クライアントが以前のインスタンス化からサーバーに状態IDを提示したときに発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server must be able to distinguish the following situations and return the error as specified:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、次の状況を区別して、指定されたエラーを返すことができる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The stateid was generated by an earlier server instance (i.e., before a server reboot). The error NFS4ERR_STALE_STATEID should be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o stateidは、以前のサーバーインスタンス（つまり、サーバーの再起動前）によって生成されました。エラーNFS4ERR_STALE_STATEIDが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The stateid was generated by the current server instance but the stateid no longer designates the current locking state for the lockowner-file pair in question (i.e., one or more locking operations has occurred). The error NFS4ERR_OLD_STATEID should be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o stateidは現在のサーバーインスタンスによって生成されましたが、stateidは、問題のロック所有者とファイルのペアの現在のロック状態を指定しなくなりました（つまり、1つ以上のロック操作が発生しました）。エラーNFS4ERR_OLD_STATEIDが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This error condition will only occur when the client issues a locking request which changes a stateid while an I/O request that uses that stateid is outstanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このエラー状態は、stateidを使用するI / O要求が未解決であるときに、クライアントがstateidを変更するロック要求を発行した場合にのみ発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The stateid was generated by the current server instance but the stateid does not designate a locking state for any active lockowner-file pair. The error NFS4ERR_BAD_STATEID should be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o stateidは現在のサーバーインスタンスによって生成されましたが、stateidはアクティブなロック所有者とファイルのペアのロック状態を指定していません。エラーNFS4ERR_BAD_STATEIDが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This error condition will occur when there has been a logic error on the part of the client or server. This should not happen.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このエラー状態は、クライアントまたはサーバー側で論理エラーが発生したときに発生します。これは起こらないはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One mechanism that may be used to satisfy these requirements is for the server to,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの要件を満たすために使用できるメカニズムの1つは、サーバーが
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o divide the &#34;other&#34; field of each stateid into two fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 各状態IDの「その他」フィールドを2つのフィールドに分割します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- A server verifier which uniquely designates a particular server instantiation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- 特定のサーバーのインスタンス化を一意に指定するサーバー検証。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- An index into a table of locking-state structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- ロック状態構造のテーブルへのインデックス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o utilize the &#34;seqid&#34; field of each stateid, such that seqid is monotonically incremented for each stateid that is associated with the same index into the locking-state table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 各stateidの「seqid」フィールドを利用して、seqidが、ロッキング状態テーブルへの同じインデックスに関連付けられている各stateidに対して単調に増加するようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By matching the incoming stateid and its field values with the state held at the server, the server is able to easily determine if a stateid is valid for its current instantiation and state. If the stateid is not valid, the appropriate error can be supplied to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信したstateidとそのフィールド値をサーバーで保持されている状態と照合することにより、stateidが現在のインスタンス化と状態に対して有効かどうかをサーバーが簡単に判断できます。 stateidが有効でない場合、適切なエラーがクライアントに提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1-4--Use-of-the-stateid-and-Locking">
8.1.4. Use of the stateid and Locking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.4. stateidとLockingの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All READ, WRITE and SETATTR operations contain a stateid. For the purposes of this section, SETATTR operations which change the size attribute of a file are treated as if they are writing the area between the old and new size (i.e., the range truncated or added to the file by means of the SETATTR), even where SETATTR is not explicitly mentioned in the text.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのREAD、WRITE、およびSETATTR操作には、stateidが含まれています。このセクションの目的のために、ファイルのサイズ属性を変更するSETATTR操作は、古いサイズと新しいサイズの間の領域（つまり、SETATTRを使用して切り捨てられた、またはファイルに追加された範囲）を書き込むかのように扱われます。 SETATTRがテキストで明示的に言及されていない場合でも。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the lock_owner performs a READ or WRITE in a situation in which it has established a lock or share reservation on the server (any OPEN constitutes a share reservation) the stateid (previously returned by the server) must be used to indicate what locks, including both record locks and share reservations, are held by the lockowner. If no state is established by the client, either record lock or share reservation, a stateid of all bits 0 is used. Regardless whether a stateid of all bits 0, or a stateid returned by the server is used, if there is a conflicting share reservation or mandatory record lock held on the file, the server MUST refuse to service the READ or WRITE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
lock_ownerがサーバー上でロックまたは共有予約を確立している状況でREADまたはWRITEを実行する場合（OPENは共有予約を構成します）、stateid（以前にサーバーから返された）を使用して、次のようなロックを示す必要があります。レコードロックと共有予約の両方がロック所有者によって保持されます。レコードロックまたは共有予約のいずれかの状態がクライアントによって確立されていない場合、すべてのビット0のstateidが使用されます。すべてのビット0の状態IDを使用するか、サーバーから返される状態IDを使用するかに関係なく、競合する共有予約または必須のレコードロックがファイルに保持されている場合、サーバーはREADまたはWRITE操作のサービスを拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Share reservations are established by OPEN operations and by their nature are mandatory in that when the OPEN denies READ or WRITE operations, that denial results in such operations being rejected with error NFS4ERR_LOCKED. Record locks may be implemented by the server as either mandatory or advisory, or the choice of mandatory or advisory behavior may be determined by the server on the basis of the file being accessed (for example, some UNIX-based servers support a &#34;mandatory lock bit&#34; on the mode attribute such that if set, record locks are required on the file before I/O is possible). When record locks are advisory, they only prevent the granting of conflicting lock requests and have no effect on READs or WRITEs. Mandatory record locks, however, prevent conflicting I/O operations. When they are attempted, they are rejected with NFS4ERR_LOCKED. When the client gets NFS4ERR_LOCKED on a file it knows it has the proper share reservation for, it will need to issue a LOCK request on the region of the file that includes the region the I/O was to be performed on, with an appropriate locktype (i.e., READ*_LT for a READ operation, WRITE*_LT for a WRITE operation).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
共有の予約はOPEN操作によって確立されます。OPEN予約がREADまたはWRITE操作を拒否すると、そのような操作はエラーNFS4ERR_LOCKEDで拒否されます。レコードロックは必須または助言のいずれかとしてサーバーによって実装されるか、必須または助言の動作の選択は、アクセスされているファイルに基づいてサーバーによって決定されます（たとえば、一部のUNIXベースのサーバーは「必須ロックをサポートします設定されている場合、I / Oが可能になる前にファイルにレコードロックが必要となるように、mode属性の「ビット」。レコードロックが助言である場合、それらは競合するロック要求の許可を防ぐだけで、READまたはWRITEには影響を与えません。ただし、必須のレコードロックは、I / O操作の競合を防ぎます。試行された場合、NFS4ERR_LOCKEDで拒否されます。クライアントは、適切な共有予約があることを知っているファイルでNFS4ERR_LOCKEDを取得すると、適切なロックタイプを使用して、I / Oが実行される領域を含むファイルの領域でLOCK要求を発行する必要があります。 （つまり、READ操作の場合はREAD * _LT、WRITE操作の場合はWRITE * _LT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With NFS version 3, there was no notion of a stateid so there was no way to tell if the application process of the client sending the READ or WRITE operation had also acquired the appropriate record lock on the file. Thus there was no way to implement mandatory locking. With the stateid construct, this barrier has been removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン3では、stateidの概念がなかったため、READまたはWRITE操作を送信するクライアントのアプリケーションプロセスもファイルの適切なレコードロックを取得したかどうかを判断する方法がありませんでした。したがって、強制ロックを実装する方法はありませんでした。 stateidコンストラクトにより、この障壁が取り除かれました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that for UNIX environments that support mandatory file locking, the distinction between advisory and mandatory locking is subtle. In fact, advisory and mandatory record locks are exactly the same in so far as the APIs and requirements on implementation. If the mandatory lock attribute is set on the file, the server checks to see if the lockowner has an appropriate shared (read) or exclusive (write) record lock on the region it wishes to read or write to. If there is no appropriate lock, the server checks if there is a conflicting lock (which can be done by attempting to acquire the conflicting lock on the behalf of the lockowner, and if successful, release the lock after the READ or WRITE is done), and if there is, the server returns NFS4ERR_LOCKED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必須ファイルロックをサポートするUNIX環境では、アドバイザリロックと必須ロックの違いはわずかです。実際、勧告および必須のレコードロックは、APIと実装の要件に関する限り、まったく同じです。必須のロック属性がファイルに設定されている場合、サーバーは、ロックオーナーが読み取りまたは書き込みを希望する領域に適切な共有（読み取り）または排他（書き込み）レコードロックを持っているかどうかを確認します。適切なロックがない場合、サーバーは競合するロックがあるかどうかをチェックします（これは、ロック所有者の代わりに競合するロックを取得しようとすることで実行でき、成功した場合は、READまたはWRITEの実行後にロックを解放します）。がある場合、サーバーはNFS4ERR_LOCKEDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For Windows environments, there are no advisory record locks, so the server always checks for record locks during I/O requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Windows環境の場合、アドバイザリレコードロックはないため、サーバーはI / O要求時に常にレコードロックをチェックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, the NFS version 4 LOCK operation does not need to distinguish between advisory and mandatory record locks. It is the NFS version 4 server&#39;s processing of the READ and WRITE operations that introduces the distinction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、NFSバージョン4のLOCK操作では、アドバイザリレコードロックと必須レコードロックを区別する必要はありません。区別を導入するのは、NFSバージョン4サーバーによるREADおよびWRITE操作の処理です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every stateid other than the special stateid values noted in this section, whether returned by an OPEN-type operation (i.e., OPEN, OPEN_DOWNGRADE), or by a LOCK-type operation (i.e., LOCK or LOCKU), defines an access mode for the file (i.e., READ, WRITE, or READ-WRITE) as established by the original OPEN which began the stateid sequence, and as modified by subsequent OPENs and OPEN_DOWNGRADEs within that stateid sequence. When a READ, WRITE, or SETATTR which specifies the size attribute, is done, the operation is subject to checking against the access mode to verify that the operation is appropriate given the OPEN with which the operation is associated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションに記載されている特殊なstateid値以外のすべてのstateidは、OPENタイプの操作（OPEN、OPEN_DOWNGRADE）によって返されるか、LOCKタイプの操作（LOCKまたはLOCKU）によって返されるかに関係なく、 stateidシーケンスを開始した元のOPENによって確立され、そのstateidシーケンス内の後続のOPENおよびOPEN_DOWNGRADEによって変更されたファイル（つまり、READ、WRITE、またはREAD-WRITE）。サイズ属性を指定するREAD、WRITE、またはSETATTRが実行されると、操作はアクセスモードに対してチェックされ、操作が関連付けられているOPENが指定されている場合、操作が適切であることを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In the case of WRITE-type operations (i.e., WRITEs and SETATTRs which set size), the server must verify that the access mode allows writing and return an NFS4ERR_OPENMODE error if it does not. In the case, of READ, the server may perform the corresponding check on the access mode, or it may choose to allow READ on opens for WRITE only, to accommodate clients whose write implementation may unavoidably do reads (e.g., due to buffer cache constraints). However, even if READs are allowed in these circumstances, the server MUST still check for locks that conflict with the READ (e.g., another open specify denial of READs). Note that a server which does enforce the access mode check on READs need not explicitly check for conflicting share reservations since the existence of OPEN for read access guarantees that no conflicting share reservation can exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
WRITEタイプの操作（つまり、サイズを設定するWRITEおよびSETATTR）の場合、サーバーはアクセスモードが書き込みを許可していることを確認し、許可していない場合はNFS4ERR_OPENMODEエラーを返す必要があります。 READの場合、サーバーはアクセスモードで対応するチェックを実行するか、または書き込みの実装が読み取りを不可避に行う可能性があるクライアントに対応するために、書き込みのみのオープンでREADを許可することを選択できます（たとえば、バッファーキャッシュの制約のため） ）。ただし、これらの状況でREADが許可されている場合でも、サーバーはREADと競合するロックを確認する必要があります（たとえば、別のオープン指定のREAD拒否）。読み取りアクセスにOPENが存在すると、競合する共有予約が存在しないことが保証されるため、READでアクセスモードチェックを実行するサーバーは、競合する共有予約を明示的にチェックする必要がないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A stateid of all bits 1 (one) MAY allow READ operations to bypass locking checks at the server. However, WRITE operations with a stateid with bits all 1 (one) MUST NOT bypass locking checks and are treated exactly the same as if a stateid of all bits 0 were used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのビット1のstateidは、READ操作がサーバーでのロックチェックをバイパスすることを許可する場合があります。ただし、ビットがすべて1の状態IDを持つWRITE操作は、ロックチェックをバイパスしてはならず（MUST）、すべてのビット0の状態IDが使用された場合とまったく同じように扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A lock may not be granted while a READ or WRITE operation using one of the special stateids is being performed and the range of the lock request conflicts with the range of the READ or WRITE operation. For the purposes of this paragraph, a conflict occurs when a shared lock is requested and a WRITE operation is being performed, or an exclusive lock is requested and either a READ or a WRITE operation is being performed. A SETATTR that sets size is treated similarly to a WRITE as discussed above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特別な状態IDの1つを使用するREADまたはWRITE操作が実行されている間、ロックが許可されず、ロック要求の範囲がREADまたはWRITE操作の範囲と競合します。この段落では、共有ロックが要求されてWRITE操作が実行されているとき、または排他ロックが要求されてREADまたはWRITE操作が実行されているときに競合が発生します。サイズを設定するSETATTRは、前述のWRITEと同様に扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1-5--Sequencing-of-Lock-Requests">
8.1.5. Sequencing of Lock Requests
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.5. ロック要求の順序付け
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Locking is different than most NFS operations as it requires &#34;at-most-one&#34; semantics that are not provided by ONCRPC. ONCRPC over a reliable transport is not sufficient because a sequence of locking requests may span multiple TCP connections. In the face of retransmission or reordering, lock or unlock requests must have a well defined and consistent behavior. To accomplish this, each lock request contains a sequence number that is a consecutively increasing integer. Different lock_owners have different sequences. The server maintains the last sequence number (L) received and the response that was returned. The first request issued for any given lock_owner is issued with a sequence number of zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックは、ONCRPCによって提供されない「最大1つ」のセマンティクスを必要とするため、ほとんどのNFS操作とは異なります。一連のロック要求が複数のTCP接続にまたがる可能性があるため、信頼できるトランスポートを介したONCRPCでは不十分です。再送信または並べ替えに直面して、ロックまたはロック解除要求は、明確に定義された一貫した動作を備えている必要があります。これを実現するために、各ロック要求には、連続的に増加する整数であるシーケンス番号が含まれています。異なるlock_ownersには異なるシーケンスがあります。サーバーは、最後に受信したシーケンス番号（L）と返された応答を保持します。特定のlock_ownerに対して発行された最初の要求は、シーケンス番号0で発行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that for requests that contain a sequence number, for each lock_owner, there should be no more than one outstanding request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンス番号を含むリクエストの場合、lock_ownerごとに、未解決のリクエストが1つだけあることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a request (r) with a previous sequence number (r &lt; L) is received, it is rejected with the return of error NFS4ERR_BAD_SEQID. Given a properly-functioning client, the response to (r) must have been received before the last request (L) was sent. If a duplicate of last request (r == L) is received, the stored response is returned. If a request beyond the next sequence (r == L + 2) is received, it is rejected with the return of error NFS4ERR_BAD_SEQID. Sequence history is reinitialized whenever the SETCLIENTID/SETCLIENTID_CONFIRM sequence changes the client verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前のシーケンス番号（r &lt;L）の要求（r）を受け取ると、エラーNFS4ERR_BAD_SEQIDが返されて拒否されます。クライアントが適切に機能している場合、（r）への応答は、最後の要求（L）が送信される前に受信されている必要があります。最後のリクエストの重複（r == L）が受信されると、保存されているレスポンスが返されます。次のシーケンス（r == L + 2）を超えるリクエストが受信されると、エラーNFS4ERR_BAD_SEQIDが返されて拒否されます。 SETCLIENTID / SETCLIENTID_CONFIRMシーケンスがクライアント検証を変更するたびに、シーケンス履歴が再初期化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the sequence number is represented with an unsigned 32-bit integer, the arithmetic involved with the sequence number is mod 2^32. For an example of modulo arithmetic involving sequence numbers see [RFC793].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンス番号は符号なし32ビット整数で表されるため、シーケンス番号に関連する演算はmod 2 ^ 32です。シーケンス番号を含むモジュロ演算の例については、[RFC793]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is critical the server maintain the last response sent to the client to provide a more reliable cache of duplicate non-idempotent requests than that of the traditional cache described in [Juszczak]. The traditional duplicate request cache uses a least recently used algorithm for removing unneeded requests. However, the last lock request and response on a given lock_owner must be cached as long as the lock state exists on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Juszczak]で説明されている従来のキャッシュよりも信頼性の高い重複しない非べき要求のキャッシュを提供するために、サーバーがクライアントに送信された最後の応答を維持することが重要です。従来の重複リクエストキャッシュは、最も古い使用頻度の低いアルゴリズムを使用して、不要なリクエストを削除します。ただし、サーバーにロック状態が存在する限り、特定のlock_ownerの最後のロック要求とロック応答をキャッシュする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client MUST monotonically increment the sequence number for the CLOSE, LOCK, LOCKU, OPEN, OPEN_CONFIRM, and OPEN_DOWNGRADE operations. This is true even in the event that the previous operation that used the sequence number received an error. The only exception to this rule is if the previous operation received one of the following errors: NFS4ERR_STALE_CLIENTID, NFS4ERR_STALE_STATEID, NFS4ERR_BAD_STATEID, NFS4ERR_BAD_SEQID, NFS4ERR_BADXDR, NFS4ERR_RESOURCE, NFS4ERR_NOFILEHANDLE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、CLOSE、LOCK、LOCKU、OPEN、OPEN_CONFIRM、およびOPEN_DOWNGRADE操作のシーケンス番号を単調に増分する必要があります。これは、シーケンス番号を使用した前の操作がエラーを受け取った場合にも当てはまります。このルールの唯一の例外は、前の操作が次のエラーのいずれかを受け取った場合です：NFS4ERR_STALE_CLIENTID、NFS4ERR_STALE_STATEID、NFS4ERR_BAD_STATEID、NFS4ERR_BAD_SEQID、NFS4ERR_BADXDR、NFS4ERR_RESOURCE、NFS4ERR_NOFILEHANDLE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1-6--Recovery-from-Replayed-Requests">
8.1.6. Recovery from Replayed Requests
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.6. リプレイされたリクエストからの回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described above, the sequence number is per lock_owner. As long as the server maintains the last sequence number received and follows the methods described above, there are no risks of a Byzantine router re-sending old requests. The server need only maintain the (lock_owner, sequence number) state as long as there are open files or closed files with locks outstanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のように、シーケンス番号はlock_ownerごとです。サーバーが受信した最後のシーケンス番号を維持し、上記の方法に従う限り、ビザンチンルーターが古いリクエストを再送信するリスクはありません。ロックが未解決の開いているファイルまたは閉じたファイルがある限り、サーバーは（lock_owner、シーケンス番号）状態を維持するだけで済みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK, LOCKU, OPEN, OPEN_DOWNGRADE, and CLOSE each contain a sequence number and therefore the risk of the replay of these operations resulting in undesired effects is non-existent while the server maintains the lock_owner state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK、LOCKU、OPEN、OPEN_DOWNGRADE、およびCLOSEにはそれぞれシーケンス番号が含まれているため、サーバーがlock_owner状態を維持している間、これらの操作が再現されて望ましくない結果が生じるリスクはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1-7--Releasing-lockowner-State">
8.1.7. Releasing lock_owner State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.7. lock_owner状態の解放
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a particular lock_owner no longer holds open or file locking state at the server, the server may choose to release the sequence number state associated with the lock_owner. The server may make this choice based on lease expiration, for the reclamation of server memory, or other implementation specific details. In any event, the server is able to do this safely only when the lock_owner no longer is being utilized by the client. The server may choose to hold the lock_owner state in the event that retransmitted requests are received. However, the period to hold this state is implementation specific.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のlock_ownerがサーバーでオープンまたはファイルロック状態を保持しなくなった場合、サーバーは、lock_ownerに関連付けられたシーケンス番号状態を解放することを選択できます。サーバーは、サーバーのメモリの再生、またはその他の実装固有の詳細について、リースの有効期限に基づいてこの選択を行う場合があります。いずれの場合でも、サーバーは、lock_ownerがクライアントによって使用されなくなった場合にのみ、安全にこれを実行できます。サーバーは、再送信された要求が受信された場合に、lock_owner状態を保持することを選択できます。ただし、この状態を保持する期間は実装によって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that a LOCK, LOCKU, OPEN_DOWNGRADE, or CLOSE is retransmitted after the server has previously released the lock_owner state, the server will find that the lock_owner has no files open and an error will be returned to the client. If the lock_owner does have a file open, the stateid will not match and again an error is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが以前にlock_owner状態を解放した後にLOCK、LOCKU、OPEN_DOWNGRADE、またはCLOSEが再送信された場合、サーバーは、lock_ownerが開いているファイルがないことを検出し、エラーがクライアントに返されます。 lock_ownerがファイルを開いている場合、stateidは一致せず、再びエラーがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1-8--Use-of-Open-Confirmation">
8.1.8. Use of Open Confirmation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.8. オープン確認の使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that an OPEN is retransmitted and the lock_owner is being used for the first time or the lock_owner state has been previously released by the server, the use of the OPEN_CONFIRM operation will prevent incorrect behavior. When the server observes the use of the lock_owner for the first time, it will direct the client to perform the OPEN_CONFIRM for the corresponding OPEN. This sequence establishes the use of an lock_owner and associated sequence number. Since the OPEN_CONFIRM sequence connects a new open_owner on the server with an existing open_owner on a client, the sequence number may have any value. The OPEN_CONFIRM step assures the server that the value received is the correct one. See the section &#34;OPEN_CONFIRM - Confirm Open&#34; for further details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENが再送信され、lock_ownerが初めて使用される場合、またはサーバーによって以前にlock_owner状態が解放されている場合、OPEN_CONFIRM操作を使用すると、不正な動作を防止できます。サーバーは、lock_ownerの使用を初めて確認するときに、対応するOPENに対してOPEN_CONFIRMを実行するようにクライアントに指示します。このシーケンスは、lock_ownerおよび関連するシーケンス番号の使用を確立します。 OPEN_CONFIRMシーケンスは、サーバー上の新しいopen_ownerをクライアント上の既存のopen_ownerに接続するため、シーケンス番号は任意の値を持つことができます。 OPEN_CONFIRMステップは、受け取った値が正しいものであることをサーバーに保証します。詳細については、「OPEN_CONFIRM-オープンの確認」セクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are a number of situations in which the requirement to confirm an OPEN would pose difficulties for the client and server, in that they would be prevented from acting in a timely fashion on information received, because that information would be provisional, subject to deletion upon non-confirmation. Fortunately, these are situations in which the server can avoid the need for confirmation when responding to open requests. The two constraints are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENを確認するための要件が​​クライアントとサーバーに困難をもたらす多くの状況があり、それらの情報は暫定的なものであり、削除の対象となるため、受信した情報に対してタイムリーに機能することが妨げられます。未確認。幸いなことに、これらは、サーバーがオープン要求に応答するときに確認の必要を回避できる状況です。 2つの制約は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server must not bestow a delegation for any open which would require confirmation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは、確認を必要とするオープンに対して委任を与えてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server MUST NOT require confirmation on a reclaim-type open (i.e., one specifying claim type CLAIM_PREVIOUS or CLAIM_DELEGATE_PREV).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは、再利用タイプのオープン（つまり、クレームタイプCLAIM_PREVIOUSまたはCLAIM_DELEGATE_PREVを指定するもの）の確認を要求してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These constraints are related in that reclaim-type opens are the only ones in which the server may be required to send a delegation. For CLAIM_NULL, sending the delegation is optional while for CLAIM_DELEGATE_CUR, no delegation is sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの制約は、サーバーが委任を送信する必要がある場合があるのは、再利用タイプのオープンだけであるという点で関連しています。 CLAIM_NULLの場合、委任の送信はオプションですが、CLAIM_DELEGATE_CURの場合、委任は送信されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Delegations being sent with an open requiring confirmation are troublesome because recovering from non-confirmation adds undue complexity to the protocol while requiring confirmation on reclaim-type opens poses difficulties in that the inability to resolve the status of the reclaim until lease expiration may make it difficult to have timely determination of the set of locks being reclaimed (since the grace period may expire).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
確認を必要とするオープンで送信される委任は厄介です。非確認から回復するとプロトコルが過度に複雑になりますが、再利用タイプのオープンで確認を要求すると、リースの期限が切れるまで再利用のステータスを解決できないために困難になる場合があるため困難です。 （猶予期間が期限切れになる可能性があるため）再利用されるロックのセットをタイムリーに決定する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Requiring open confirmation on reclaim-type opens is avoidable because of the nature of the environments in which such opens are done. For CLAIM_PREVIOUS opens, this is immediately after server reboot, so there should be no time for lockowners to be created, found to be unused, and recycled. For CLAIM_DELEGATE_PREV opens, we are dealing with a client reboot situation. A server which supports delegation can be sure that no lockowners for that client have been recycled since client initialization and thus can ensure that confirmation will not be required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このようなオープンが行われる環境の性質上、再利用タイプのオープンでオープン確認を要求することは避けられます。 CLAIM_PREVIOUSが開いている場合、これはサーバーの再起動直後なので、ロック所有者が作成され、未使用であることが判明し、リサイクルされる時間はありません。 CLAIM_DELEGATE_PREVが開いている場合は、クライアントの再起動状況を処理しています。委任をサポートするサーバーは、クライアントの初期化以降、そのクライアントのロック所有者がリサイクルされていないことを確認できるため、確認が不要であることを確認できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2--Lock-Ranges">
8.2. Lock Ranges
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. ロック範囲
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol allows a lock owner to request a lock with a byte range and then either upgrade or unlock a sub-range of the initial lock. It is expected that this will be an uncommon type of request. In any case, servers or server filesystems may not be able to support sub-range lock semantics. In the event that a server receives a locking request that represents a sub-range of current locking state for the lock owner, the server is allowed to return the error NFS4ERR_LOCK_RANGE to signify that it does not support sub-range lock operations. Therefore, the client should be prepared to receive this error and, if appropriate, report the error to the requesting application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルにより、ロック所有者はバイト範囲のロックを要求し、初期ロックのサブ範囲をアップグレードまたはロック解除できます。これは珍しいタイプのリクエストになると予想されます。いずれの場合も、サーバーまたはサーバーファイルシステムは、サブレンジロックセマンティクスをサポートできない場合があります。サーバーがロック所有者の現在のロック状態のサブ範囲を表すロック要求を受信した場合、サーバーはエラーNFS4ERR_LOCK_RANGEを返して、サブ範囲のロック操作をサポートしていないことを示すことができます。したがって、クライアントはこのエラーを受信する準備をして、必要に応じて、要求元のアプリケーションにエラーを報告する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client is discouraged from combining multiple independent locking ranges that happen to be adjacent into a single request since the server may not support sub-range requests and for reasons related to the recovery of file locking state in the event of server failure. As discussed in the section &#34;Server Failure and Recovery&#34; below, the server may employ certain optimizations during recovery that work effectively only when the client&#39;s behavior during lock recovery is similar to the client&#39;s locking behavior prior to server failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはサブレンジリクエストをサポートしていない可能性があるため、サーバーに障害が発生した場合のファイルロック状態の回復に関連する理由により、クライアントは、偶然に隣接する複数の独立したロック範囲を1つのリクエストに結合しないでください。以下の「サーバーの障害と回復」で説明するように、サーバーは、ロックの回復中のクライアントの動作がサーバーの障害前のクライアントのロックの動作と類似している場合にのみ効果的に機能する特定の最適化を回復中に使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-3--Upgrading-and-Downgrading-Locks">
8.3. Upgrading and Downgrading Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. ロックのアップグレードとダウングレード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client has a write lock on a record, it can request an atomic downgrade of the lock to a read lock via the LOCK request, by setting the type to READ_LT. If the server supports atomic downgrade, the request will succeed. If not, it will return NFS4ERR_LOCK_NOTSUPP. The client should be prepared to receive this error, and if appropriate, report the error to the requesting application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがレコードに書き込みロックを持っている場合、タイプをREAD_LTに設定することにより、LOCKリクエストを介してロックの読み取りロックへのアトミックダウングレードを要求できます。サーバーがアトミックダウングレードをサポートしている場合、リクエストは成功します。そうでない場合は、NFS4ERR_LOCK_NOTSUPPを返します。クライアントは、このエラーを受け取る準備をして、必要に応じて、要求元のアプリケーションにエラーを報告する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client has a read lock on a record, it can request an atomic upgrade of the lock to a write lock via the LOCK request by setting the type to WRITE_LT or WRITEW_LT. If the server does not support atomic upgrade, it will return NFS4ERR_LOCK_NOTSUPP. If the upgrade can be achieved without an existing conflict, the request will succeed. Otherwise, the server will return either NFS4ERR_DENIED or NFS4ERR_DEADLOCK. The error NFS4ERR_DEADLOCK is returned if the client issued the LOCK request with the type set to WRITEW_LT and the server has detected a deadlock. The client should be prepared to receive such errors and if appropriate, report the error to the requesting application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがレコードに読み取りロックを持っている場合、タイプをWRITE_LTまたはWRITEW_LTに設定することで、LOCKリクエストを介してロックの書き込みロックへのアトミックアップグレードを要求できます。サーバーがアトミックアップグレードをサポートしていない場合、サーバーはNFS4ERR_LOCK_NOTSUPPを返します。既存の競合なしでアップグレードを達成できる場合、要求は成功します。それ以外の場合、サーバーはNFS4ERR_DENIEDまたはNFS4ERR_DEADLOCKを返します。クライアントがタイプをWRITEW_LTに設定してLOCK要求を発行し、サーバーがデッドロックを検出した場合、エラーNFS4ERR_DEADLOCKが返されます。クライアントは、このようなエラーを受信する準備をして、必要に応じて、要求元のアプリケーションにエラーを報告する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-4--Blocking-Locks">
8.4. Blocking Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. ロックのブロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some clients require the support of blocking locks. The NFS version 4 protocol must not rely on a callback mechanism and therefore is unable to notify a client when a previously denied lock has been granted. Clients have no choice but to continually poll for the lock. This presents a fairness problem. Two new lock types are added, READW and WRITEW, and are used to indicate to the server that the client is requesting a blocking lock. The server should maintain an ordered list of pending blocking locks. When the conflicting lock is released, the server may wait the lease period for the first waiting client to re-request the lock. After the lease period expires the next waiting client request is allowed the lock. Clients are required to poll at an interval sufficiently small that it is likely to acquire the lock in a timely manner. The server is not required to maintain a list of pending blocked locks as it is used to increase fairness and not correct operation. Because of the unordered nature of crash recovery, storing of lock state to stable storage would be required to guarantee ordered granting of blocking locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のクライアントでは、ブロックロックのサポートが必要です。 NFSバージョン4プロトコルは、コールバックメカニズムに依存してはならないため、以前に拒否されたロックが許可されたときにクライアントに通知できません。クライアントは、ロックを継続的にポーリングする以外に選択肢はありません。これは公平性の問題を示します。 READWとWRITEWの2つの新しいロックタイプが追加され、クライアントがブロッキングロックを要求していることをサーバーに示すために使用されます。サーバーは、保留中のブロッキングロックの順序付きリストを維持する必要があります。競合するロックが解放されると、サーバーは、最初の待機中のクライアントがロックを再要求するまでリース期間待機します。リース期間が終了すると、次の待機中のクライアント要求はロックを許可されます。クライアントは、適時にロックを取得する可能性が高いほど十分に短い間隔でポーリングする必要があります。サーバーは、公平性を高めるために使用され、正しい操作ではないため、保留中のブロックされたロックのリストを維持する必要はありません。クラッシュリカバリの順序付けされていない性質のため、ブロックされたロックの順序付けられた許可を保証するには、ロック状態を安定したストレージに保存する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers may also note the lock types and delay returning denial of the request to allow extra time for a conflicting lock to be released, allowing a successful return. In this way, clients can avoid the burden of needlessly frequent polling for blocking locks. The server should take care in the length of delay in the event the client retransmits the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ロックのタイプを記録し、要求の拒否の拒否を遅らせて、競合するロックが解放されるまでの時間を追加して、正常な戻りを可能にすることもできます。このようにして、クライアントは、ロックをブロックするための不必要に頻繁なポーリングの負担を回避できます。サーバーは、クライアントが要求を再送信する場合の遅延時間に注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-5--Lease-Renewal">
8.5. Lease Renewal
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5. リース更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The purpose of a lease is to allow a server to remove stale locks that are held by a client that has crashed or is otherwise unreachable. It is not a mechanism for cache consistency and lease renewals may not be denied if the lease interval has not expired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リースの目的は、クラッシュしたクライアントや他の方法で到達できないクライアントが保持している古いロックをサーバーが削除できるようにすることです。これはキャッシュの整合性のためのメカニズムではなく、リース間隔が満了していない場合、リースの更新が拒否されない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following events cause implicit renewal of all of the leases for a given client (i.e., all those sharing a given clientid). Each of these is a positive indication that the client is still active and that the associated state held at the server, for the client, is still valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のイベントにより、特定のクライアント（つまり、特定のclientidを共有するすべてのリース）のすべてのリースが暗黙的に更新されます。これらはそれぞれ、クライアントがまだアクティブであり、クライアントでサーバーに保持されている関連する状態がまだ有効であることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An OPEN with a valid clientid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 有効なclientidを持つOPEN。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Any operation made with a valid stateid (CLOSE, DELEGPURGE, DELEGRETURN, LOCK, LOCKU, OPEN, OPEN_CONFIRM, OPEN_DOWNGRADE, READ, RENEW, SETATTR, WRITE). This does not include the special stateids of all bits 0 or all bits 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 有効な状態ID（CLOSE、DELEGPURGE、DELEGRETURN、LOCK、LOCKU、OPEN、OPEN_CONFIRM、OPEN_DOWNGRADE、READ、RENEW、SETATTR、WRITE）で行われた操作。これには、すべてのビット0またはすべてのビット1の特別な状態IDは含まれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note that if the client had restarted or rebooted, the client would not be making these requests without issuing the SETCLIENTID/SETCLIENTID_CONFIRM sequence. The use of the SETCLIENTID/SETCLIENTID_CONFIRM sequence (one that changes the client verifier) notifies the server to drop the locking state associated with the client. SETCLIENTID/SETCLIENTID_CONFIRM never renews a lease.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントが再起動または再起動した場合、クライアントはSETCLIENTID / SETCLIENTID_CONFIRMシーケンスを発行せずにこれらの要求を作成しないことに注意してください。 SETCLIENTID / SETCLIENTID_CONFIRMシーケンス（クライアントベリファイアを変更するシーケンス）を使用すると、クライアントに関連付けられたロック状態を削除するようサーバーに通知されます。 SETCLIENTID / SETCLIENTID_CONFIRMがリースを更新することはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the server has rebooted, the stateids (NFS4ERR_STALE_STATEID error) or the clientid (NFS4ERR_STALE_CLIENTID error) will not be valid hence preventing spurious renewals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーが再起動した場合、stateids（NFS4ERR_STALE_STATEIDエラー）またはclientid（NFS4ERR_STALE_CLIENTIDエラー）は無効になり、誤った更新を防ぎます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This approach allows for low overhead lease renewal which scales well. In the typical case no extra RPC calls are required for lease renewal and in the worst case one RPC is required every lease period (i.e., a RENEW operation). The number of locks held by the client is not a factor since all state for the client is involved with the lease renewal action.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアプローチにより、拡張性の高い低オーバーヘッドのリース更新が可能になります。通常の場合、リースの更新に追加のRPC呼び出しは必要ありません。最悪の場合、リース期間ごとに1つのRPCが必要です（つまり、RENEW操作）。クライアントのすべての状態はリースの更新アクションに関係しているため、クライアントが保持しているロックの数は要因ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since all operations that create a new lease also renew existing leases, the server must maintain a common lease expiration time for all valid leases for a given client. This lease time can then be easily updated upon implicit lease renewal actions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいリースを作成するすべての操作は既存のリースも更新するため、サーバーは、特定のクライアントのすべての有効なリースについて、共通のリース有効期限を維持する必要があります。このリース時間は、暗黙のリース更新アクションで簡単に更新できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-6--Crash-Recovery">
8.6. Crash Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6. クラッシュリカバリー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The important requirement in crash recovery is that both the client and the server know when the other has failed. Additionally, it is required that a client sees a consistent view of data across server restarts or reboots. All READ and WRITE operations that may have been queued within the client or network buffers must wait until the client has successfully recovered the locks protecting the READ and WRITE operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クラッシュリカバリの重要な要件は、クライアントとサーバーの両方が、もう一方に障害が発生したことを認識していることです。さらに、サーバーの再起動または再起動後も、クライアントはデータの一貫したビューを見る必要があります。クライアントまたはネットワークバッファー内でキューに入れられた可能性のあるすべてのREADおよびWRITE操作は、クライアントがREADおよびWRITE操作を保護するロックを正常に回復するまで待機する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-6-1--Client-Failure-and-Recovery">
8.6.1. Client Failure and Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6.1. クライアントの障害と回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event that a client fails, the server may recover the client&#39;s locks when the associated leases have expired. Conflicting locks from another client may only be granted after this lease expiration. If the client is able to restart or reinitialize within the lease period the client may be forced to wait the remainder of the lease period before obtaining new locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントに障害が発生した場合、関連するリースの有効期限が切れると、サーバーはクライアントのロックを回復できます。別のクライアントからの競合するロックは、このリースの有効期限が切れた後にのみ許可されます。クライアントがリース期間内に再起動または再初期化できる場合、クライアントは新しいロックを取得する前に、リース期間の残りの期間を待機するように強制される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To minimize client delay upon restart, lock requests are associated with an instance of the client by a client supplied verifier. This verifier is part of the initial SETCLIENTID call made by the client. The server returns a clientid as a result of the SETCLIENTID operation. The client then confirms the use of the clientid with SETCLIENTID_CONFIRM. The clientid in combination with an opaque owner field is then used by the client to identify the lock owner for OPEN. This chain of associations is then used to identify all locks for a particular client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再起動時のクライアントの遅延を最小限に抑えるため、ロック要求は、クライアントが提供するベリファイアによってクライアントのインスタンスに関連付けられます。このベリファイアは、クライアントが行った最初のSETCLIENTID呼び出しの一部です。サーバーは、SETCLIENTID操作の結果としてclientidを返します。次にクライアントは、SETCLIENTID_CONFIRMを使用してclientidの使用を確認します。 clientidは不透明な所有者フィールドと組み合わせて、OPENのロック所有者を識別するためにクライアントによって使用されます。この関連付けのチェーンは、特定のクライアントのすべてのロックを識別するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the verifier will be changed by the client upon each initialization, the server can compare a new verifier to the verifier associated with currently held locks and determine that they do not match. This signifies the client&#39;s new instantiation and subsequent loss of locking state. As a result, the server is free to release all locks held which are associated with the old clientid which was derived from the old verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベリファイアは初期化のたびにクライアントによって変更されるため、サーバーは新しいベリファイアを現在保持されているロックに関連付けられているベリファイアと比較し、それらが一致しないことを確認できます。これは、クライアントの新しいインスタンス化とその後のロック状態の喪失を意味します。その結果、サーバーは、古いベリファイアから派生した古いクライアントIDに関連付けられている、保持されているすべてのロックを解放できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the verifier must have the same uniqueness properties of the verifier for the COMMIT operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベリファイアには、COMMIT操作のベリファイアと同じ一意性プロパティが必要であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-6-2--Server-Failure-and-Recovery">
8.6.2. Server Failure and Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6.2. サーバーの障害と回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server loses locking state (usually as a result of a restart or reboot), it must allow clients time to discover this fact and re-establish the lost locking state. The client must be able to re-establish the locking state without having the server deny valid requests because the server has granted conflicting access to another client. Likewise, if there is the possibility that clients have not yet re-established their locking state for a file, the server must disallow READ and WRITE operations for that file. The duration of this recovery period is equal to the duration of the lease period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがロック状態を失うと（通常は再起動または再起動の結果として）、クライアントがこの事実を発見して、失われたロック状態を再確立できるようにする必要があります。サーバーは別のクライアントに競合するアクセスを許可しているため、サーバーは有効な要求を拒否せずに、クライアントはロック状態を再確立できる必要があります。同様に、クライアントがファイルのロック状態をまだ再確立していない可能性がある場合、サーバーはそのファイルのREADおよびWRITE操作を禁止する必要があります。この回復期間の期間は、リース期間の期間と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A client can determine that server failure (and thus loss of locking state) has occurred, when it receives one of two errors. The NFS4ERR_STALE_STATEID error indicates a stateid invalidated by a reboot or restart. The NFS4ERR_STALE_CLIENTID error indicates a clientid invalidated by reboot or restart. When either of these are received, the client must establish a new clientid (See the section &#34;Client ID&#34;) and re-establish the locking state as discussed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントは、2つのエラーのいずれかを受け取ったときに、サーバー障害（およびロック状態の喪失）が発生したと判断できます。 NFS4ERR_STALE_STATEIDエラーは、再起動または再起動によって無効にされた状態IDを示します。 NFS4ERR_STALE_CLIENTIDエラーは、クライアントIDが再起動または再起動によって無効化されたことを示します。これらのいずれかが受信されると、クライアントは新しいclientid（「クライアントID」のセクションを参照）を確立し、以下で説明するようにロック状態を再確立する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The period of special handling of locking and READs and WRITEs, equal in duration to the lease period, is referred to as the &#34;grace period&#34;. During the grace period, clients recover locks and the associated state by reclaim-type locking requests (i.e., LOCK requests with reclaim set to true and OPEN operations with a claim type of CLAIM_PREVIOUS). During the grace period, the server must reject READ and WRITE operations and non-reclaim locking requests (i.e., other LOCK and OPEN operations) with an error of NFS4ERR_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックとREADおよびWRITEの特別な処理の期間は、リース期間と同じ長さで、「猶予期間」と呼ばれます。猶予期間中、クライアントは再利用タイプのロックリクエスト（つまり、再利用がtrueに設定されたLOCKリクエストとクレームタイプがCLAIM_PREVIOUSのOPEN操作）によって、ロックと関連する状態を回復します。猶予期間中、サーバーはREADおよびWRITE操作と非再利用ロック要求（つまり、他のLOCKおよびOPEN操作）をNFS4ERR_GRACEのエラーで拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server can reliably determine that granting a non-reclaim request will not conflict with reclamation of locks by other clients, the NFS4ERR_GRACE error does not have to be returned and the non-reclaim client request can be serviced. For the server to be able to service READ and WRITE operations during the grace period, it must again be able to guarantee that no possible conflict could arise between an impending reclaim locking request and the READ or WRITE operation. If the server is unable to offer that guarantee, the NFS4ERR_GRACE error must be returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非再利用リクエストの許可が他のクライアントによるロックの再利用と競合しないことをサーバーが確実に判断できる場合、NFS4ERR_GRACEエラーを返す必要はなく、非再利用クライアントリクエストを処理できます。サーバーが猶予期間中にREADおよびWRITE操作を処理できるようにするには、差し迫った再利用ロック要求とREADまたはWRITE操作の間に起こり得る競合が発生しないことを保証できる必要があります。サーバーがその保証を提供できない場合は、NFS4ERR_GRACEエラーをクライアントに返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a server to provide simple, valid handling during the grace period, the easiest method is to simply reject all non-reclaim locking requests and READ and WRITE operations by returning the NFS4ERR_GRACE error. However, a server may keep information about granted locks in stable storage. With this information, the server could determine if a regular lock or READ or WRITE operation can be safely processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが猶予期間中に単純で有効な処理を提供するための最も簡単な方法は、NFS4ERR_GRACEエラーを返すことにより、すべての非再利用ロック要求とREADおよびWRITE操作を単に拒否することです。ただし、サーバーは、許可されたロックに関する情報を安定したストレージに保持する場合があります。この情報を使用して、サーバーは、通常のロックまたはREADまたはWRITE操作を安全に処理できるかどうかを判断できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, if a count of locks on a given file is available in stable storage, the server can track reclaimed locks for the file and when all reclaims have been processed, non-reclaim locking requests may be processed. This way the server can ensure that non-reclaim locking requests will not conflict with potential reclaim requests. With respect to I/O requests, if the server is able to determine that there are no outstanding reclaim requests for a file by information from stable storage or another similar mechanism, the processing of I/O requests could proceed normally for the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、特定のファイルのロック数が安定したストレージで利用できる場合、サーバーはファイルの再生ロックを追跡でき、すべての再生が処理されると、非再生ロック要求が処理される場合があります。このようにして、サーバーは非再利用ロック要求が潜在的な再利用要求と競合しないことを保証できます。 I / O要求に関して、安定したストレージまたは他の同様のメカニズムからの情報によって、サーバーがファイルに対する未解決の再利用要求がないと判断できる場合、I / O要求の処理はファイルに対して正常に続行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To reiterate, for a server that allows non-reclaim lock and I/O requests to be processed during the grace period, it MUST determine that no lock subsequently reclaimed will be rejected and that no lock subsequently reclaimed would have prevented any I/O operation processed during the grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
繰り返しますが、非再利用ロックとI / O要求が猶予期間中に処理されることを許可するサーバーでは、その後再利用されるロックは拒否されず、その後再利用されるロックはI / O操作を妨げなかったと判断する必要があります。猶予期間中に処理されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients should be prepared for the return of NFS4ERR_GRACE errors for non-reclaim lock and I/O requests. In this case the client should employ a retry mechanism for the request. A delay (on the order of several seconds) between retries should be used to avoid overwhelming the server. Further discussion of the general issue is included in [Floyd]. The client must account for the server that is able to perform I/O and non-reclaim locking requests within the grace period as well as those that can not do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、非再利用ロックおよびI / O要求に対してNFS4ERR_GRACEエラーが返されるように準備する必要があります。この場合、クライアントは要求に対して再試行メカニズムを採用する必要があります。サーバーが過負荷にならないように、再試行間の遅延（数秒程度）を使用する必要があります。一般的な問題の詳細については、[Floyd]に記載されています。クライアントは、猶予期間内にI / Oおよび非再利用ロック要求を実行できるサーバーと、そうでないサーバーを考慮に入れる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reclaim-type locking request outside the server&#39;s grace period can only succeed if the server can guarantee that no conflicting lock or I/O request has been granted since reboot or restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの猶予期間外の再利用タイプのロック要求は、再起動または再起動以降、サーバーが競合するロックまたはI / O要求が許可されていないことを保証できる場合にのみ成功します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server may, upon restart, establish a new value for the lease period. Therefore, clients should, once a new clientid is established, refetch the lease_time attribute and use it as the basis for lease renewal for the lease associated with that server. However, the server must establish, for this restart event, a grace period at least as long as the lease period for the previous server instantiation. This allows the client state obtained during the previous server instance to be reliably re-established.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、再起動時に、リース期間の新しい値を確立できます。したがって、クライアントは、新しいclientidが確立されたら、lease_time属性を再フェッチして、そのサーバーに関連付けられているリースのリース更新の基礎として使用する必要があります。ただし、サーバーは、この再起動イベントに対して、少なくとも前回のサーバーのインスタンス化のリース期間と同じくらいの猶予期間を確立する必要があります。これにより、前のサーバーインスタンスで取得したクライアントの状態を確実に再確立できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-6-3--Network-Partitions-and-Recovery">
8.6.3. Network Partitions and Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6.3. ネットワークパーティションとリカバリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the duration of a network partition is greater than the lease period provided by the server, the server will have not received a lease renewal from the client. If this occurs, the server may free all locks held for the client. As a result, all stateids held by the client will become invalid or stale. Once the client is able to reach the server after such a network partition, all I/O submitted by the client with the now invalid stateids will fail with the server returning the error NFS4ERR_EXPIRED. Once this error is received, the client will suitably notify the application that held the lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークパーティションの期間がサーバーによって提供されるリース期間よりも長い場合、サーバーはクライアントからリースの更新を受信して​​いません。これが発生した場合、サーバーはクライアントのために保持していたすべてのロックを解放する可能性があります。その結果、クライアントが保持するすべての状態IDが無効または古くなります。このようなネットワークパーティションの後でクライアントがサーバーに到達すると、無効な状態IDでクライアントから送信されたすべてのI / Oが失敗し、サーバーはエラーNFS4ERR_EXPIREDを返します。このエラーが受信されると、クライアントは、ロックを保持していたアプリケーションに適切に通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a courtesy to the client or as an optimization, the server may continue to hold locks on behalf of a client for which recent communication has extended beyond the lease period. If the server receives a lock or I/O request that conflicts with one of these courtesy locks, the server must free the courtesy lock and grant the new request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントへの礼儀として、または最適化として、サーバーは、最近の通信がリース期間を超えて延長されたクライアントに代わってロックを保持し続ける場合があります。サーバーがこれらのサービスロックのいずれかと競合するロックまたはI / O要求を受信した場合、サーバーはサービスロックを解放し、新しい要求を許可する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a network partition is combined with a server reboot, there are edge conditions that place requirements on the server in order to avoid silent data corruption following the server reboot. Two of these edge conditions are known, and are discussed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークパーティションをサーバーの再起動と組み合わせると、サーバーの再起動後にデータのサイレント破損を回避するためにサーバーに要件を課すエッジ条件があります。これらのエッジ条件のうち2つは既知であり、以下で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first edge condition has the following scenario:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のエッジ条件には、次のシナリオがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. Client A acquires a lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. クライアントAがロックを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. Client A and server experience mutual network partition, such that client A is unable to renew its lease.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. クライアントAとサーバーは相互ネットワークパーティションを経験しているため、クライアントAはリースを更新できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. Client A&#39;s lease expires, so server releases lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. クライアントAのリースが期限切れになるため、サーバーはロックを解放します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
4. Client B acquires a lock that would have conflicted with that of Client A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
4. クライアントBは、クライアントAのロックと競合するロックを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
5. Client B releases the lock
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
5. クライアントBがロックを解放します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
6. Server reboots
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
6. サーバーが再起動する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
7. Network partition between client A and server heals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
7. クライアントAとサーバー間のネットワークパーティションが修復されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
8. Client A issues a RENEW operation, and gets back a NFS4ERR_STALE_CLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
8. クライアントAはRENEW操作を発行し、NFS4ERR_STALE_CLIENTIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
9. Client A reclaims its lock within the server&#39;s grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
9. クライアントAは、サーバーの猶予期間内にロックを取り戻します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, at the final step, the server has erroneously granted client A&#39;s lock reclaim. If client B modified the object the lock was protecting, client A will experience object corruption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、最後のステップで、サーバーは誤ってクライアントAのロック再利用を許可しました。ロックが保護していたオブジェクトをクライアントBが変更した場合、クライアントAはオブジェクトの破損を経験します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second known edge condition follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2番目の既知のエッジ条件は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. Client A acquires a lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. クライアントAがロックを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. Server reboots.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. サーバーが再起動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. Client A and server experience mutual network partition, such that client A is unable to reclaim its lock within the grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. クライアントAとサーバーは相互ネットワークパーティションを経験しているため、クライアントAは猶予期間内にロックを取り戻すことができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
4. Server&#39;s reclaim grace period ends. Client A has no locks recorded on server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
4. サーバーの再利用猶予期間が終了します。クライアントAには、サーバーに記録されたロックはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
5. Client B acquires a lock that would have conflicted with that of Client A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
5. クライアントBは、クライアントAのロックと競合するロックを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
6. Client B releases the lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
6. クライアントBがロックを解放します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
7. Server reboots a second time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
7. サーバーがもう一度再起動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
8. Network partition between client A and server heals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
8. クライアントAとサーバー間のネットワークパーティションが修復されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
9. Client A issues a RENEW operation, and gets back a NFS4ERR_STALE_CLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
9. クライアントAはRENEW操作を発行し、NFS4ERR_STALE_CLIENTIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
10. Client A reclaims its lock within the server&#39;s grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
10. クライアントAは、サーバーの猶予期間内にロックを取り戻します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with the first edge condition, the final step of the scenario of the second edge condition has the server erroneously granting client A&#39;s lock reclaim.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のエッジ条件と同様に、2番目のエッジ条件のシナリオの最後のステップでは、サーバーが誤ってクライアントAのロック再利用を許可します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Solving the first and second edge conditions requires that the server either assume after it reboots that edge condition occurs, and thus return NFS4ERR_NO_GRACE for all reclaim attempts, or that the server record some information stable storage. The amount of information the server records in stable storage is in inverse proportion to how harsh the server wants to be whenever the edge conditions occur. The server that is completely tolerant of all edge conditions will record in stable storage every lock that is acquired, removing the lock record from stable storage only when the lock is unlocked by the client and the lock&#39;s lockowner advances the sequence number such that the lock release is not the last stateful event for the lockowner&#39;s sequence. For the two aforementioned edge conditions, the harshest a server can be, and still support a grace period for reclaims, requires that the server record in stable storage information some minimal information. For example, a server implementation could, for each client, save in stable storage a record containing:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1番目と2番目のエッジ条件を解決するには、サーバーがリブート後にそのエッジ条件が発生したと想定し、すべての再利用試行に対してNFS4ERR_NO_GRACEを返すか、サーバーが情報の安定したストレージを記録する必要があります。サーバーが安定したストレージに記録する情報の量は、エッジ条件が発生するたびにサーバーがどの程度厳しくなりたいかに反比例します。すべてのエッジ条件を完全に許容するサーバーは、取得されたすべてのロックを安定したストレージに記録し、ロックがクライアントによってロック解除され、ロックのロック所有者がシーケンス番号を進めてロックが解放される場合にのみ、安定したストレージからロックレコードを削除しますロック所有者のシーケンスの最後のステートフルイベントではありません。前述の2つのエッジ条件の場合、サーバーが最も過酷な状態であり、再生の猶予期間をサポートするには、サーバーが最小限の情報を安定したストレージ情報に記録する必要があります。たとえば、サーバーの実装では、クライアントごとに、以下を含むレコードを安定したストレージに保存できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the client&#39;s id string
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントのID文字列
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o a boolean that indicates if the client&#39;s lease expired or if there was administrative intervention (see the section, Server Revocation of Locks) to revoke a record lock, share reservation, or delegation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントのリースが期限切れになったか、レコードのロックを取り消し、予約を共有したり、委任したりするための管理介入（「サーバーのロックの取り消し」を参照）があったかどうかを示すブール値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o a timestamp that is updated the first time after a server boot or reboot the client acquires record locking, share reservation, or delegation state on the server. The timestamp need not be updated on subsequent lock requests until the server reboots.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーの起動または再起動後に初めてクライアントが更新されるタイムスタンプは、サーバーでレコードのロック、共有の予約、または委任状態を取得します。サーバーが再起動するまで、後続のロック要求でタイムスタンプを更新する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server implementation would also record in the stable storage the timestamps from the two most recent server reboots.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの実装では、最新の2回のサーバー再起動からのタイムスタンプも安定したストレージに記録されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assuming the above record keeping, for the first edge condition, after the server reboots, the record that client A&#39;s lease expired means that another client could have acquired a conflicting record lock, share reservation, or delegation. Hence the server must reject a reclaim from client A with the error NFS4ERR_NO_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の記録を保持すると仮定すると、最初のエッジ条件で、サーバーの再起動後、クライアントAのリースが期限切れになったという記録は、別のクライアントが競合するレコードロック、共有予約、または委任を取得した可能性があることを意味します。したがって、サーバーはエラーNFS4ERR_NO_GRACEでクライアントAからの再利用を拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the second edge condition, after the server reboots for a second time, the record that the client had an unexpired record lock, share reservation, or delegation established before the server&#39;s previous incarnation means that the server must reject a reclaim from client A with the error NFS4ERR_NO_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2番目のエッジ条件の場合、サーバーが2回再起動した後、サーバーの以前のインカネーションの前にクライアントが期限切れのないレコードロック、共有予約、または委任を確立したというレコードは、サーバーがクライアントAからの再利用を拒否する必要があることを意味しますエラーNFS4ERR_NO_GRACE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regardless of the level and approach to record keeping, the server MUST implement one of the following strategies (which apply to reclaims of share reservations, record locks, and delegations):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レコード保持のレベルとアプローチに関係なく、サーバーは次の戦略の1つを実装する必要があります（共有予約、レコードロック、および委任の再利用に適用されます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. Reject all reclaims with NFS4ERR_NO_GRACE. This is superharsh, but necessary if the server does not want to record lock state in stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. NFS4ERR_NO_GRACEを使用してすべての再利用を拒否します。これは非常に厳しいですが、サーバーが安定したストレージにロック状態を記録したくない場合に必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. Record sufficient state in stable storage such that all known edge conditions involving server reboot, including the two noted in this section, are detected. False positives are acceptable. Note that at this time, it is not known if there are other edge conditions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. このセクションで説明した2つを含め、サーバーの再起動に関連するすべての既知のエッジ条件が検出されるように、安定したストレージに十分な状態を記録します。誤検知は許容されます。現時点では、他のエッジ条件があるかどうかは不明です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
In the event, after a server reboot, the server determines that there is unrecoverable damage or corruption to the the stable storage, then for all clients and/or locks affected, the server MUST return NFS4ERR_NO_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
イベントでは、サーバーの再起動後、サーバーは安定したストレージに回復不可能な損傷または破損があると判断し、影響を受けるすべてのクライアントやロックに対して、サーバーはNFS4ERR_NO_GRACEを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A mandate for the client&#39;s handling of the NFS4ERR_NO_GRACE error is outside the scope of this specification, since the strategies for such handling are very dependent on the client&#39;s operating environment. However, one potential approach is described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがNFS4ERR_NO_GRACEエラーを処理することの義務は、この仕様の範囲外です。そのような処理の戦略は、クライアントの動作環境に大きく依存しているためです。ただし、考えられるアプローチの1つを以下で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client receives NFS4ERR_NO_GRACE, it could examine the change attribute of the objects the client is trying to reclaim state for, and use that to determine whether to re-establish the state via normal OPEN or LOCK requests. This is acceptable provided the client&#39;s operating environment allows it. In otherwords, the client implementor is advised to document for his users the behavior. The client could also inform the application that its record lock or share reservations (whether they were delegated or not) have been lost, such as via a UNIX signal, a GUI pop-up window, etc. See the section, &#34;Data Caching and Revocation&#34; for a discussion of what the client should do for dealing with unreclaimed delegations on client state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、NFS4ERR_NO_GRACEを受信すると、クライアントが状態を再利用しようとしているオブジェクトの変更属性を調べ、それを使用して、通常のOPEN要求またはLOCK要求によって状態を再確立するかどうかを判断します。これは、クライアントの動作環境で許可されている場合に許容されます。言い換えると、クライアントの実装者は、ユーザーのために動作を文書化することをお勧めします。クライアントは、UNIXシグナル、GUIポップアップウィンドウなどを介して、レコードロックまたは共有予約（委任されているかどうかにかかわらず）が失われたことをアプリケーションに通知することもできます。「データキャッシュとクライアントの状態に関する取り立てられていない委任に対処するためにクライアントが何をすべきかについての議論については、「取り消し」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For further discussion of revocation of locks see the section &#34;Server Revocation of Locks&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックの取り消しの詳細については、「サーバーのロックの取り消し」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-7--Recovery-from-a-Lock-Request-Timeout-or-Abort">
8.7. Recovery from a Lock Request Timeout or Abort
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7. ロックリクエストのタイムアウトまたは中止からの回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event a lock request times out, a client may decide to not retry the request. The client may also abort the request when the process for which it was issued is terminated (e.g., in UNIX due to a signal). It is possible though that the server received the request and acted upon it. This would change the state on the server without the client being aware of the change. It is paramount that the client re-synchronize state with server before it attempts any other operation that takes a seqid and/or a stateid with the same lock_owner. This is straightforward to do without a special re-synchronize operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック要求がタイムアウトした場合、クライアントは要求を再試行しないことを決定できます。クライアントは、それが発行されたプロセスが終了したときに要求を中止することもできます（たとえば、UNIXでシグナルが原因で）。ただし、サーバーがリクエストを受信し、それを処理した可能性があります。これにより、クライアントが変更を意識することなく、サーバーの状態が変更されます。同じlock_ownerでseqidやstateidを取得する他の操作を試みる前に、クライアントがサーバーと状態を再同期することが最も重要です。これは、特別な再同期操作なしで簡単に実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the server maintains the last lock request and response received on the lock_owner, for each lock_owner, the client should cache the last lock request it sent such that the lock request did not receive a response. From this, the next time the client does a lock operation for the lock_owner, it can send the cached request, if there is one, and if the request was one that established state (e.g., a LOCK or OPEN operation), the server will return the cached result or if never saw the request, perform it. The client can follow up with a request to remove the state (e.g., a LOCKU or CLOSE operation). With this approach, the sequencing and stateid information on the client and server for the given lock_owner will re-synchronize and in turn the lock state will re-synchronize.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、lock_ownerで受信した最後のロック要求と応答を維持するため、lock_ownerごとに、クライアントが送信した最後のロック要求をキャッシュして、ロック要求が応答を受信しないようにする必要があります。これにより、次にクライアントがlock_ownerに対してロック操作を行うときに、キャッシュされた要求があれば送信できます。要求がその確立された状態（たとえば、LOCKまたはOPEN操作）の場合、サーバーはキャッシュされた結果を返すか、要求を見たことがない場合は実行します。クライアントは、状態を削除する要求をフォローアップできます（LOCKUまたはCLOSE操作など）。このアプローチでは、指定されたlock_ownerのクライアントとサーバーのシーケンス情報とstateid情報が再同期され、ロック状態が再同期されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-8--Server-Revocation-of-Locks">
8.8. Server Revocation of Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.8. ロックのサーバー失効
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At any point, the server can revoke locks held by a client and the client must be prepared for this event. When the client detects that its locks have been or may have been revoked, the client is responsible for validating the state information between itself and the server. Validating locking state for the client means that it must verify or reclaim state for each lock currently held.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いつでも、サーバーはクライアントが保持しているロックを取り消すことができ、クライアントはこのイベントに備える必要があります。ロックが取り消されたか、取り消された可能性があることをクライアントが検出した場合、クライアントは自身とサーバーの間の状態情報を検証する責任があります。クライアントのロック状態を検証するとは、現在保持されている各ロックの状態を確認または再利用する必要があることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first instance of lock revocation is upon server reboot or re-initialization. In this instance the client will receive an error (NFS4ERR_STALE_STATEID or NFS4ERR_STALE_CLIENTID) and the client will proceed with normal crash recovery as described in the previous section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックの取り消しの最初のインスタンスは、サーバーの再起動時または再初期化時です。この場合、クライアントはエラー（NFS4ERR_STALE_STATEIDまたはNFS4ERR_STALE_CLIENTID）を受け取り、クライアントは前のセクションで説明したように通常のクラッシュリカバリを続行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The second lock revocation event is the inability to renew the lease before expiration. While this is considered a rare or unusual event, the client must be prepared to recover. Both the server and client will be able to detect the failure to renew the lease and are capable of recovering without data corruption. For the server, it tracks the last renewal event serviced for the client and knows when the lease will expire. Similarly, the client must track operations which will renew the lease period. Using the time that each such request was sent and the time that the corresponding reply was received, the client should bound the time that the corresponding renewal could have occurred on the server and thus determine if it is possible that a lease period expiration could have occurred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2番目のロック失効イベントは、有効期限が切れる前にリースを更新できないことです。これはまれまたは異常なイベントと見なされますが、クライアントは回復する準備をする必要があります。サーバーとクライアントの両方がリースの更新の失敗を検出でき、データを破損することなく回復できます。サーバーの場合、クライアントに提供された最後の更新イベントを追跡し、リースの期限が切れる時期を認識します。同様に、クライアントはリース期間を更新する操作を追跡する必要があります。そのような各要求が送信された時間と対応する応答が受信された時間を使用して、クライアントは、対応する更新がサーバーで発生する可能性がある時間をバインドし、リース期間の期限切れが発生する可能性があるかどうかを判断する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The third lock revocation event can occur as a result of administrative intervention within the lease period. While this is considered a rare event, it is possible that the server&#39;s administrator has decided to release or revoke a particular lock held by the client. As a result of revocation, the client will receive an error of NFS4ERR_ADMIN_REVOKED. In this instance the client may assume that only the lock_owner&#39;s locks have been lost. The client notifies the lock holder appropriately. The client may not assume the lease period has been renewed as a result of failed operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3番目のロック失効イベントは、リース期間内の管理者の介入の結果として発生する可能性があります。これはまれなイベントと考えられていますが、サーバーの管理者がクライアントによって保持されている特定のロックを解放または取り消すことを決定した可能性があります。失効の結果として、クライアントはNFS4ERR_ADMIN_REVOKEDのエラーを受け取ります。この場合、クライアントは、lock_ownerのロックのみが失われたと想定する場合があります。クライアントはロックホルダーに適切に通知します。クライアントは、操作の失敗の結果としてリース期間が更新されたと想定しない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client determines the lease period may have expired, the client must mark all locks held for the associated lease as &#34;unvalidated&#34;. This means the client has been unable to re-establish or confirm the appropriate lock state with the server. As described in the previous section on crash recovery, there are scenarios in which the server may grant conflicting locks after the lease period has expired for a client. When it is possible that the lease period has expired, the client must validate each lock currently held to ensure that a conflicting lock has not been granted. The client may accomplish this task by issuing an I/O request, either a pending I/O or a zero-length read, specifying the stateid associated with the lock in question. If the response to the request is success, the client has validated all of the locks governed by that stateid and re-established the appropriate state between itself and the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、リース期間が終了した可能性があると判断した場合、関連付けられたリースに対して保持されているすべてのロックを「未検証」としてマークする必要があります。これは、クライアントがサーバーとの適切なロック状態を再確立または確認できなかったことを意味します。クラッシュリカバリに関する前のセクションで説明したように、クライアントのリース期間が終了した後、サーバーが競合するロックを許可するシナリオがあります。リース期間が終了した可能性がある場合、クライアントは現在保持されている各ロックを検証して、競合するロックが許可されていないことを確認する必要があります。クライアントは、保留中のI / Oまたは長さゼロの読み取りのいずれかであるI / O要求を発行し、問題のロックに関連付けられた状態IDを指定して、このタスクを実行できます。要求への応答が成功した場合、クライアントはそのステートIDによって管理されるすべてのロックを検証し、クライアントとサーバー間の適切な状態を再確立しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the I/O request is not successful, then one or more of the locks associated with the stateid was revoked by the server and the client must notify the owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I / O要求が成功しない場合、stateidに関連付けられた1つ以上のロックがサーバーによって取り消され、クライアントは所有者に通知する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-9--Share-Reservations">
8.9. Share Reservations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.9. 予約を共有する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A share reservation is a mechanism to control access to a file. It is a separate and independent mechanism from record locking. When a client opens a file, it issues an OPEN operation to the server specifying the type of access required (READ, WRITE, or BOTH) and the type of access to deny others (deny NONE, READ, WRITE, or BOTH). If the OPEN fails the client will fail the application&#39;s open request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有予約は、ファイルへのアクセスを制御するメカニズムです。これは、レコードのロックとは別の独立したメカニズムです。クライアントがファイルを開くと、必要なアクセスのタイプ（READ、WRITE、またはBOTH）と他のアクセスを拒否するタイプ（NONE、READ、WRITE、またはBOTHを拒否）を指定して、サーバーにOPEN操作を発行します。 OPENが失敗すると、クライアントはアプリケーションのオープン要求を失敗させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pseudo-code definition of the semantics:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セマンティクスの疑似コード定義：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
if (request.access == 0) return (NFS4ERR_INVAL)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
if（request.access == 0）return（NFS4ERR_INVAL）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
else if ((request.access &amp; file_state.deny)) || (request.deny &amp; file_state.access)) return (NFS4ERR_DENIED)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
else if（（request.access＆file_state.deny））|| （request.deny＆file_state.access））return（NFS4ERR_DENIED）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This checking of share reservations on OPEN is done with no exception for an existing OPEN for the same open_owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENでの共有予約のこのチェックは、同じopen_ownerに対する既存のOPENを例外なく実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The constants used for the OPEN and OPEN_DOWNGRADE operations for the access and deny fields are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクセスおよび拒否フィールドのOPENおよびOPEN_DOWNGRADE操作に使用される定数は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const OPEN4_SHARE_ACCESS_READ   = 0x00000001;
   const OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;
   const OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const OPEN4_SHARE_DENY_NONE     = 0x00000000;
   const OPEN4_SHARE_DENY_READ     = 0x00000001;
   const OPEN4_SHARE_DENY_WRITE    = 0x00000002;
   const OPEN4_SHARE_DENY_BOTH     = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-10--OPENCLOSE-Operations">
8.10. OPEN/CLOSE Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.10. OPEN / CLOSE操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To provide correct share semantics, a client MUST use the OPEN operation to obtain the initial filehandle and indicate the desired access and what if any access to deny. Even if the client intends to use a stateid of all 0&#39;s or all 1&#39;s, it must still obtain the filehandle for the regular file with the OPEN operation so the appropriate share semantics can be applied. For clients that do not have a deny mode built into their open programming interfaces, deny equal to NONE should be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正しい共有セマンティクスを提供するには、クライアントはOPEN操作を使用して初期ファイルハンドルを取得し、目的のアクセスと、拒否するアクセスがある場合はそれを示す必要があります。クライアントがすべて0またはすべて1の状態IDを使用する場合でも、適切な共有セマンティクスを適用できるように、OPEN操作で通常のファイルのファイルハンドルを取得する必要があります。オープンプログラミングインターフェイスに拒否モードが組み込まれていないクライアントの場合は、NONEと等しいdenyを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The OPEN operation with the CREATE flag, also subsumes the CREATE operation for regular files as used in previous versions of the NFS protocol. This allows a create with a share to be done atomically.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CREATEフラグを指定したOPEN操作は、NFSプロトコルの以前のバージョンで使用されていた通常のファイルのCREATE操作も含みます。これにより、共有を使用した作成をアトミックに実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CLOSE operation removes all share reservations held by the lock_owner on that file. If record locks are held, the client SHOULD release all locks before issuing a CLOSE. The server MAY free all outstanding locks on CLOSE but some servers may not support the CLOSE of a file that still has record locks held. The server MUST return failure, NFS4ERR_LOCKS_HELD, if any locks would exist after the CLOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSE操作は、そのファイルのlock_ownerによって保持されているすべての共有予約を削除します。レコードロックが保持されている場合、クライアントはCLOSEを発行する前にすべてのロックを解放する必要があります（SHOULD）。サーバーはCLOSEのすべての未処理のロックを解放してもよい（MAY）が、一部のサーバーは、まだレコードロックが保持されているファイルのCLOSEをサポートしない場合があります。 CLOSEの後にロックが存在する場合、サーバーは失敗、NFS4ERR_LOCKS_HELDを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The LOOKUP operation will return a filehandle without establishing any lock state on the server. Without a valid stateid, the server will assume the client has the least access. For example, a file opened with deny READ/WRITE cannot be accessed using a filehandle obtained through LOOKUP because it would not have a valid stateid (i.e., using a stateid of all bits 0 or all bits 1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
LOOKUP操作は、サーバーでロック状態を確立せずにファイルハンドルを返します。有効な状態IDがない場合、サーバーはクライアントのアクセスが最小であると想定します。たとえば、読み取り/書き込み拒否で開いたファイルは、有効な状態IDがないため（つまり、すべてのビット0またはすべてのビット1の状態IDを使用しているため）、LOOKUPを通じて取得したファイルハンドルを使用してアクセスできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-10-1--Close-and-Retention-of-State-Information">
8.10.1. Close and Retention of State Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.10.1. 状態情報のクローズと保持
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since a CLOSE operation requests deallocation of a stateid, dealing with retransmission of the CLOSE, may pose special difficulties, since the state information, which normally would be used to determine the state of the open file being designated, might be deallocated, resulting in an NFS4ERR_BAD_STATEID error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSE操作はstateidの割り当て解除を要求するため、CLOSEの再送信を処理すると、通常、指定されている開いているファイルの状態を判断するために使用される状態情報が割り当て解除され、 NFS4ERR_BAD_STATEIDエラー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers may deal with this problem in a number of ways. To provide the greatest degree assurance that the protocol is being used properly, a server should, rather than deallocate the stateid, mark it as close-pending, and retain the stateid with this status, until later deallocation. In this way, a retransmitted CLOSE can be recognized since the stateid points to state information with this distinctive status, so that it can be handled without error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはこの問題をさまざまな方法で処理します。プロトコルが適切に使用されていることを最大限保証するために、サーバーは、stateidの割り当てを解除するのではなく、それをクローズペンディングとしてマークし、後で割り当て解除されるまで、stateidをこのステータスで保持する必要があります。このようにして、stateidがこの特徴的なステータスの状態情報を指すため、再送信されたCLOSEを認識でき、エラーなしで処理できるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When adopting this strategy, a server should retain the state information until the earliest of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この戦略を採用する場合、サーバーは次の最も早い段階まで状態情報を保持する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Another validly sequenced request for the same lockowner, that is not a retransmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 同じロック所有者に対する別の有効にシーケンスされた要求。これは再送信ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The time that a lockowner is freed by the server due to period with no activity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o アクティビティがない期間が原因で、ロック所有者がサーバーによって解放された時間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o All locks for the client are freed as a result of a SETCLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントのすべてのロックは、SETCLIENTIDの結果として解放されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers may avoid this complexity, at the cost of less complete protocol error checking, by simply responding NFS4_OK in the event of a CLOSE for a deallocated stateid, on the assumption that this case must be caused by a retransmitted close. When adopting this approach, it is desirable to at least log an error when returning a no-error indication in this situation. If the server maintains a reply-cache mechanism, it can verify the CLOSE is indeed a retransmission and avoid error logging in most cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはこの複雑さを回避できますが、プロトコルエラーチェックの完全性は低下しますが、割り当て解除された状態IDのCLOSEのイベントでNFS4_OKに応答するだけで、このケースは再送信されたクローズが原因であると想定されます。このアプローチを採用する場合、この状況でエラーなしの表示を返すときは、少なくともエラーをログに記録することが望ましいです。サーバーが返信キャッシュメカニズムを維持している場合、サーバーはCLOSEが実際に再送信であることを確認でき、ほとんどの場合、エラーログを回避できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-11--Open-Upgrade-and-Downgrade">
8.11. Open Upgrade and Downgrade
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.11. オープンアップグレードとダウングレード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When an OPEN is done for a file and the lockowner for which the open is being done already has the file open, the result is to upgrade the open file status maintained on the server to include the access and deny bits specified by the new OPEN as well as those for the existing OPEN. The result is that there is one open file, as far as the protocol is concerned, and it includes the union of the access and deny bits for all of the OPEN requests completed. Only a single CLOSE will be done to reset the effects of both OPENs. Note that the client, when issuing the OPEN, may not know that the same file is in fact being opened. The above only applies if both OPENs result in the OPENed object being designated by the same filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ファイルに対してOPENが実行され、オープンが実行されているロック所有者が既にファイルを開いている場合、結果として、サーバー上で維持されているオープンファイルステータスがアップグレードされ、新しいOPENで指定されたアクセスおよび拒否ビットが含まれます。既存のOPENのものと同様です。その結果、プロトコルに関する限り、1つのオープンファイルが存在し、完了したすべてのOPEN要求のアクセスおよび拒否ビットの結合が含まれます。両方のOPENの影響をリセットするために、単一のCLOSEのみが実行されます。クライアントは、OPENを発行するときに、同じファイルが実際に開かれていることを認識していない場合があることに注意してください。上記は、両方のOPENの結果、OPENedオブジェクトが同じファイルハンドルによって指定される場合にのみ適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server chooses to export multiple filehandles corresponding to the same file object and returns different filehandles on two different OPENs of the same file object, the server MUST NOT &#34;OR&#34; together the access and deny bits and coalesce the two open files. Instead the server must maintain separate OPENs with separate stateids and will require separate CLOSEs to free them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが同じファイルオブジェクトに対応する複数のファイルハンドルをエクスポートすることを選択し、同じファイルオブジェクトの2つの異なるOPENで異なるファイルハンドルを返す場合、サーバーはアクセスと拒否ビットを一緒に「OR」して、2つの開いているファイルを結合してはなりません（MUST NOT）。代わりに、サーバーは個別の状態IDを持つ個別のOPENを維持する必要があり、それらを解放するには個別のCLOSEが必要になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When multiple open files on the client are merged into a single open file object on the server, the close of one of the open files (on the client) may necessitate change of the access and deny status of the open file on the server. This is because the union of the access and deny bits for the remaining opens may be smaller (i.e., a proper subset) than previously. The OPEN_DOWNGRADE operation is used to make the necessary change and the client should use it to update the server so that share reservation requests by other clients are handled properly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント上の複数の開いているファイルがサーバー上の単一の開いているファイルオブジェクトにマージされると、開いているファイルの1つ（クライアント上）を閉じると、アクセスの変更とサーバー上の開いているファイルのステータスの拒否が必要になる場合があります。これは、残りのオープンのアクセスおよび拒否ビットの和集合が以前よりも小さい（つまり、適切なサブセットである）可能性があるためです。 OPEN_DOWNGRADE操作は必要な変更を行うために使用され、クライアントはそれを使用してサーバーを更新し、他のクライアントによる共有予約要求が適切に処理されるようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-12--Short-and-Long-Leases">
8.12. Short and Long Leases
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.12. 短期および長期リース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When determining the time period for the server lease, the usual lease tradeoffs apply. Short leases are good for fast server recovery at a cost of increased RENEW or READ (with zero length) requests. Longer leases are certainly kinder and gentler to servers trying to handle very large numbers of clients. The number of RENEW requests drop in proportion to the lease time. The disadvantages of long leases are slower recovery after server failure (the server must wait for the leases to expire and the grace period to elapse before granting new lock requests) and increased file contention (if client fails to transmit an unlock request then server must wait for lease expiration before granting new locks).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーリースの期間を決定するときは、通常のリーストレードオフが適用されます。短いリースは、RENEWまたはREAD（長さが0の）要求の増加を犠牲にして、サーバーの高速回復に適しています。リースが長いほど、非常に多くのクライアントを処理しようとするサーバーにとって、より親切で穏やかになります。 RENEW要求の数は、リース時間に比例して減少します。長いリースの欠点は、サーバー障害後の回復が遅くなることです（サーバーはリースの期限が切れるまで待機し、猶予期間が経過してから新しいロック要求を許可する必要があります）、ファイルの競合が増加します（クライアントがロック解除要求の送信に失敗した場合、サーバーは待機する必要があります）新しいロックを許可する前のリースの有効期限について）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Long leases are usable if the server is able to store lease state in non-volatile memory. Upon recovery, the server can reconstruct the lease state from its non-volatile memory and continue operation with its clients and therefore long leases would not be an issue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがリース状態を不揮発性メモリに保存できる場合は、長いリースを使用できます。リカバリ時に、サーバーはその不揮発性メモリからリース状態を再構築し、クライアントとの操作を続行できるため、長いリースは問題になりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-13--Clocks-Propagation-Delay-and-Calculating-Lease-Expiration">
8.13. Clocks, Propagation Delay, and Calculating Lease Expiration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.13. クロック、伝搬遅延、およびリースの有効期限の計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 To avoid the need for synchronized clocks, lease times are granted by the server as a time delta. However, there is a requirement that the client and server clocks do not drift excessively over the duration of the lock. There is also the issue of propagation delay across the network which could easily be several hundred milliseconds as well as the possibility that requests will be lost and need to be retransmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
同期されたクロックの必要性を回避するために、リース時間はサーバーによってタイムデルタとして付与されます。ただし、クライアントとサーバーのクロックがロックの期間にわたって過度にドリフトしないという要件があります。また、ネットワーク全体での伝播遅延の問題もあり、これは数百ミリ秒になりやすいだけでなく、リクエストが失われ、再送信が必要になる可能性もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To take propagation delay into account, the client should subtract it from lease times (e.g., if the client estimates the one-way propagation delay as 200 msec, then it can assume that the lease is already 200 msec old when it gets it). In addition, it will take another 200 msec to get a response back to the server. So the client must send a lock renewal or write data back to the server 400 msec before the lease would expire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
伝播遅延を考慮に入れるには、クライアントはそれをリース時間から差し引く必要があります（たとえば、クライアントが一方向の伝播遅延を200ミリ秒と推定する場合、リースを取得した時点でリースがすでに200ミリ秒古いと想定できます）。さらに、サーバーに応答を返すまでにさらに200ミリ秒かかります。したがって、リースが期限切れになる前に、クライアントはロック更新を送信するか、データをサーバーに400ミリ秒書き戻す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server&#39;s lease period configuration should take into account the network distance of the clients that will be accessing the server&#39;s resources. It is expected that the lease period will take into account the network propagation delays and other network delay factors for the client population. Since the protocol does not allow for an automatic method to determine an appropriate lease period, the server&#39;s administrator may have to tune the lease period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーのリース期間の構成では、サーバーのリソースにアクセスするクライアントのネットワーク距離を考慮する必要があります。リース期間では、クライアントの人口に対するネットワークの伝播の遅延やその他のネットワークの遅延要因が考慮されることが予想されます。プロトコルでは適切なリース期間を決定するための自動方法が許可されていないため、サーバーの管理者はリース期間を調整する必要がある場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-14--Migration-Replication-and-State">
8.14. Migration, Replication and State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.14. 移行、複製、状態
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When responsibility for handling a given file system is transferred to a new server (migration) or the client chooses to use an alternate server (e.g., in response to server unresponsiveness) in the context of file system replication, the appropriate handling of state shared between the client and server (i.e., locks, leases, stateids, and clientids) is as described below. The handling differs between migration and replication. For related discussion of file server state and recover of such see the sections under &#34;File Locking and Share Reservations&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のファイルシステムを処理する責任が新しいサーバーに移行された場合（移行）、またはクライアントがファイルシステムレプリケーションのコンテキストで代替サーバーを使用することを選択した場合（サーバーの応答がないなど）、状態の適切な処理はクライアントとサーバー（つまり、ロック、リース、ステートID、およびクライアントID）は以下のとおりです。移行とレプリケーションでは処理が異なります。ファイルサーバーの状態とその回復の関連する説明については、「ファイルのロックと共有の予約」のセクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If server replica or a server immigrating a filesystem agrees to, or is expected to, accept opaque values from the client that originated from another server, then it is a wise implementation practice for the servers to encode the &#34;opaque&#34; values in network byte order. This way, servers acting as replicas or immigrating filesystems will be able to parse values like stateids, directory cookies, filehandles, etc. even if their native byte order is different from other servers cooperating in the replication and migration of the filesystem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーレプリカまたはファイルシステムを移行するサーバーが、別のサーバーから発信されたクライアントからの不透明な値を受け入れることに同意する、または予期する場合、サーバーがネットワークバイトオーダーで「不透明」な値をエンコードすることは賢明な実装方法です。 。このようにして、レプリカとして機能するサーバーまたはファイルシステムを移行するサーバーは、ネイティブのバイト順がファイルシステムのレプリケーションと移行で協力している他のサーバーと異なる場合でも、stateid、ディレクトリCookie、ファイルハンドルなどの値を解析できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-14-1--Migration-and-State">
8.14.1. Migration and State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.14.1. 移行と状態
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In the case of migration, the servers involved in the migration of a filesystem SHOULD transfer all server state from the original to the new server. This must be done in a way that is transparent to the client. This state transfer will ease the client&#39;s transition when a filesystem migration occurs. If the servers are successful in transferring all state, the client will continue to use stateids assigned by the original server. Therefore the new server must recognize these stateids as valid. This holds true for the clientid as well. Since responsibility for an entire filesystem is transferred with a migration event, there is no possibility that conflicts will arise on the new server as a result of the transfer of locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
移行の場合、ファイルシステムの移行に関与するサーバーは、すべてのサーバーの状態を元のサーバーから新しいサーバーに転送する必要があります（SHOULD）。これは、クライアントに対して透過的な方法で行う必要があります。この状態転送により、ファイルシステムの移行が発生したときのクライアントの移行が容易になります。サーバーがすべての状態の転送に成功した場合、クライアントは元のサーバーによって割り当てられた状態IDを引き続き使用します。したがって、新しいサーバーはこれらの状態IDを有効として認識する必要があります。これは、clientidにも当てはまります。ファイルシステム全体の責任は移行イベントで転送されるため、ロックの転送の結果として新しいサーバーで競合が発生する可能性はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As part of the transfer of information between servers, leases would be transferred as well. The leases being transferred to the new server will typically have a different expiration time from those for the same client, previously on the old server. To maintain the property that all leases on a given server for a given client expire at the same time, the server should advance the expiration time to the later of the leases being transferred or the leases already present. This allows the client to maintain lease renewal of both classes without special effort.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー間の情報転送の一部として、リースも転送されます。新しいサーバーに転送されるリースは、通常、以前のサーバーにあった同じクライアントのリースとは異なる有効期限があります。特定のクライアントの特定のサーバー上のすべてのリースが同時に期限切れになるという特性を維持するには、サーバーは、転送されるリースまたはすでに存在するリースの遅い方に期限を早める必要があります。これにより、クライアントは特別な作業なしで両方のクラスのリース更新を維持できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The servers may choose not to transfer the state information upon migration. However, this choice is discouraged. In this case, when the client presents state information from the original server, the client must be prepared to receive either NFS4ERR_STALE_CLIENTID or NFS4ERR_STALE_STATEID from the new server. The client should then recover its state information as it normally would in response to a server failure. The new server must take care to allow for the recovery of state information as it would in the event of server restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、移行時に状態情報を転送しないことを選択できます。ただし、この選択はお勧めできません。この場合、クライアントが元のサーバーから状態情報を提示するとき、クライアントは新しいサーバーからNFS4ERR_STALE_CLIENTIDまたはNFS4ERR_STALE_STATEIDのいずれかを受信する準備をする必要があります。その後、クライアントは、サーバーの障害に応じて通常のように状態情報を回復する必要があります。新しいサーバーは、サーバーが再起動した場合と同様に、状態情報を回復できるように注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-14-2--Replication-and-State">
8.14.2. Replication and State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.14.2. レプリケーションと状態
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since client switch-over in the case of replication is not under server control, the handling of state is different. In this case, leases, stateids and clientids do not have validity across a transition from one server to another. The client must re-establish its locks on the new server. This can be compared to the re-establishment of locks by means of reclaim-type requests after a server reboot. The difference is that the server has no provision to distinguish requests reclaiming locks from those obtaining new locks or to defer the latter. Thus, a client re-establishing a lock on the new server (by means of a LOCK or OPEN request), may have the requests denied due to a conflicting lock. Since replication is intended for read-only use of filesystems, such denial of locks should not pose large difficulties in practice. When an attempt to re-establish a lock on a new server is denied, the client should treat the situation as if his original lock had been revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レプリケーションの場合のクライアントの切り替えはサーバーの制御下にないため、状態の処理は異なります。この場合、リース、ステートID、およびクライアントIDは、あるサーバーから別のサーバーへの移行中は有効ではありません。クライアントは、新しいサーバーでロックを再確立する必要があります。これは、サーバーの再起動後の再利用タイプの要求によるロックの再確立と比較できます。違いは、サーバーには、ロックを再利用する要求と新しいロックを取得する要求を区別したり、ロックを延期したりする機能がないことです。したがって、クライアントが（LOCKまたはOPEN要求によって）新しいサーバーでロックを再確立すると、競合するロックのために要求が拒否される場合があります。レプリケーションはファイルシステムの読み取り専用の使用を目的としているため、このようなロックの拒否は実際には大きな困難をもたらすことはありません。新しいサーバーでロックを再確立する試みが拒否された場合、クライアントは、元のロックが取り消されたかのように状況を処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-14-3--Notification-of-Migrated-Lease">
8.14.3. Notification of Migrated Lease
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.14.3. 移行したリースの通知
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of lease renewal, the client may not be submitting requests for a filesystem that has been migrated to another server. This can occur because of the implicit lease renewal mechanism. The client renews leases for all filesystems when submitting a request to any one filesystem at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リースの更新の場合、クライアントは別のサーバーに移行されたファイルシステムのリクエストを送信していない可能性があります。これは、暗黙的なリース更新メカニズムが原因で発生する可能性があります。クライアントは、サーバーの1つのファイルシステムに要求を送信するときに、すべてのファイルシステムのリースを更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order for the client to schedule renewal of leases that may have been relocated to the new server, the client must find out about lease relocation before those leases expire. To accomplish this, all operations which implicitly renew leases for a client (i.e., OPEN, CLOSE, READ, WRITE, RENEW, LOCK, LOCKT, LOCKU), will return the error NFS4ERR_LEASE_MOVED if responsibility for any of the leases to be renewed has been transferred to a new server. This condition will continue until the client receives an NFS4ERR_MOVED error and the server receives the subsequent GETATTR(fs_locations) for an access to each filesystem for which a lease has been moved to a new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが新しいサーバーに再配置された可能性のあるリースの更新をスケジュールするためには、クライアントはそれらのリースが期限切れになる前にリースの再配置について知る必要があります。これを実現するために、クライアントのリースを暗黙的に更新するすべての操作（つまり、OPEN、CLOSE、READ、WRITE、RENEW、LOCK、LOCKT、LOCKU）は、更新されるリースのいずれかの責任があった場合、エラーNFS4ERR_LEASE_MOVEDを返します。新しいサーバーに転送されました。この状態は、クライアントがNFS4ERR_MOVEDエラーを受け取り、サーバーがリースを新しいサーバーに移動した各ファイルシステムへのアクセスに対する後続のGETATTR（fs_locations）を受け取るまで続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client receives an NFS4ERR_LEASE_MOVED error, it should perform an operation on each filesystem associated with the server in question. When the client receives an NFS4ERR_MOVED error, the client can follow the normal process to obtain the new server information (through the fs_locations attribute) and perform renewal of those leases on the new server. If the server has not had state transferred to it transparently, the client will receive either NFS4ERR_STALE_CLIENTID or NFS4ERR_STALE_STATEID from the new server, as described above, and the client can then recover state information as it does in the event of server failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがNFS4ERR_LEASE_MOVEDエラーを受信すると、問題のサーバーに関連付けられている各ファイルシステムで操作を実行する必要があります。クライアントがNFS4ERR_MOVEDエラーを受信すると、クライアントは通常のプロセスに従って（fs_locations属性を通じて）新しいサーバー情報を取得し、新しいサーバーでこれらのリースの更新を実行できます。サーバーに透過的に状態が転送されていない場合、クライアントは上記のように新しいサーバーからNFS4ERR_STALE_CLIENTIDまたはNFS4ERR_STALE_STATEIDのいずれかを受け取り、サーバーに障害が発生した場合と同様に、クライアントは状態情報を回復できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-14-4--Migration-and-the-Leasetime-Attribute">
8.14.4. Migration and the Lease_time Attribute
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.14.4. 移行とLease_time属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order that the client may appropriately manage its leases in the case of migration, the destination server must establish proper values for the lease_time attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
移行時にクライアントがリースを適切に管理できるようにするために、移行先サーバーは、lease_time属性に適切な値を設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When state is transferred transparently, that state should include the correct value of the lease_time attribute. The lease_time attribute on the destination server must never be less than that on the source since this would result in premature expiration of leases granted by the source server. Upon migration in which state is transferred transparently, the client is under no obligation to re-fetch the lease_time attribute and may continue to use the value previously fetched (on the source server).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態が透過的に転送される場合、その状態には、lease_time属性の正しい値が含まれている必要があります。ソースサーバーによって付与されたリースの期限切れが早まるため、宛先サーバーのlease_time属性をソースの属性よりも小さくすることはできません。状態が透過的に転送される移行では、クライアントは、lease_time属性を再フェッチする義務はなく、以前にフェッチした値（ソースサーバー上）を引き続き使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If state has not been transferred transparently (i.e., the client sees a real or simulated server reboot), the client should fetch the value of lease_time on the new (i.e., destination) server, and use it for subsequent locking requests. However the server must respect a grace period at least as long as the lease_time on the source server, in order to ensure that clients have ample time to reclaim their locks before potentially conflicting non-reclaimed locks are granted. The means by which the new server obtains the value of lease_time on the old server is left to the server implementations. It is not specified by the NFS version 4 protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
状態が透過的に転送されていない場合（つまり、クライアントに実際のサーバーまたは再起動されたサーバーの再起動が表示される場合）、クライアントは新しい（つまり宛先）サーバーのlease_timeの値をフェッチし、それを後続のロック要求に使用する必要があります。ただし、サーバーは、少なくともソースサーバーのlease_timeの間は猶予期間を尊重する必要があります。これにより、再利用されない競合するロックが許可される前に、クライアントがロックを再利用するための十分な時間を確保できます。新しいサーバーが古いサーバーのlease_timeの値を取得する方法は、サーバーの実装に任されています。 NFSバージョン4プロトコルでは指定されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--Client-Side-Caching">
9. Client-Side Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. クライアント側のキャッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client-side caching of data, of file attributes, and of file names is essential to providing good performance with the NFS protocol. Providing distributed cache coherence is a difficult problem and previous versions of the NFS protocol have not attempted it. Instead, several NFS client implementation techniques have been used to reduce the problems that a lack of coherence poses for users. These techniques have not been clearly defined by earlier protocol specifications and it is often unclear what is valid or invalid client behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ、ファイル属性、およびファイル名のクライアント側キャッシュは、NFSプロトコルで良好なパフォーマンスを提供するために不可欠です。分散キャッシュコヒーレンスを提供することは困難な問題であり、以前のバージョンのNFSプロトコルはこれを試みていません。代わりに、一貫性の欠如がユーザーにもたらす問題を軽減するために、いくつかのNFSクライアント実装手法が使用されています。これらの手法は、以前のプロトコル仕様では明確に定義されておらず、有効または無効なクライアントの動作が明確でないことがよくあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 protocol uses many techniques similar to those that have been used in previous protocol versions. The NFS version 4 protocol does not provide distributed cache coherence. However, it defines a more limited set of caching guarantees to allow locks and share reservations to be used without destructive interference from client side caching.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルは、以前のプロトコルバージョンで使用されていたものと同様の多くの手法を使用します。 NFSバージョン4プロトコルは、分散キャッシュの一貫性を提供しません。ただし、クライアント側のキャッシングによる破壊的な干渉なしにロックと共有の予約を使用できるように、より限定的なキャッシング保証のセットを定義しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, the NFS version 4 protocol introduces a delegation mechanism which allows many decisions normally made by the server to be made locally by clients. This mechanism provides efficient support of the common cases where sharing is infrequent or where sharing is read-only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、NFSバージョン4プロトコルは、通常サーバーによって行われる多くの決定がクライアントによってローカルで行われることを可能にする委任メカニズムを導入します。このメカニズムは、共有頻度が低い、または共有が読み取り専用である一般的なケースを効率的にサポートします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-1--Performance-Challenges-for-Client-Side-Caching">
9.1. Performance Challenges for Client-Side Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. クライアント側キャッシュのパフォーマンスの課題
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Caching techniques used in previous versions of the NFS protocol have been successful in providing good performance. However, several scalability challenges can arise when those techniques are used with very large numbers of clients. This is particularly true when clients are geographically distributed which classically increases the latency for cache revalidation requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前のバージョンのNFSプロトコルで使用されていたキャッシュ技術は、優れたパフォーマンスを提供することに成功しています。ただし、これらの手法を非常に多数のクライアントで使用する場合、いくつかのスケーラビリティの課題が発生する可能性があります。これは、クライアントが地理的に分散していて、キャッシュの再検証リクエストのレイテンシが従来から増加している場合に特に当てはまります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The previous versions of the NFS protocol repeat their file data cache validation requests at the time the file is opened. This behavior can have serious performance drawbacks. A common case is one in which a file is only accessed by a single client. Therefore, sharing is infrequent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前のバージョンのNFSプロトコルは、ファイルが開かれたときにファイルデータキャッシュの検証要求を繰り返します。この動作は、パフォーマンスに重大な欠点をもたらす可能性があります。一般的なケースは、ファイルが単一のクライアントによってのみアクセスされる場合です。したがって、共有はまれです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this case, repeated reference to the server to find that no conflicts exist is expensive. A better option with regards to performance is to allow a client that repeatedly opens a file to do so without reference to the server. This is done until potentially conflicting operations from another client actually occur.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この場合、サーバーを繰り返し参照して競合が存在しないことを確認すると、コストがかかります。パフォーマンスに関するより良いオプションは、サーバーを参照せずにファイルを繰り返し開くクライアントがファイルを開くことを許可することです。これは、別のクライアントからの潜在的に競合する操作が実際に発生するまで行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A similar situation arises in connection with file locking. Sending file lock and unlock requests to the server as well as the read and write requests necessary to make data caching consistent with the locking semantics (see the section &#34;Data Caching and File Locking&#34;) can severely limit performance. When locking is used to provide protection against infrequent conflicts, a large penalty is incurred. This penalty may discourage the use of file locking by applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルのロックに関しても同様の状況が発生します。ファイルのロックとロック解除の要求をサーバーに送信し、データのキャッシュをロックのセマンティクスと一致させるために必要な読み取りと書き込みの要求を送信すると（「データのキャッシュとファイルのロック」のセクションを参照）、パフォーマンスが大幅に制限されます。まれな競合に対する保護を提供するためにロックを使用すると、大きなペナルティが発生します。このペナルティにより、アプリケーションによるファイルロックの使用が妨げられる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 protocol provides more aggressive caching strategies with the following design goals:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルは、次の設計目標でより積極的なキャッシング戦略を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Compatibility with a large range of server semantics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 幅広いサーバーセマンティクスとの互換性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Provide the same caching benefits as previous versions of the NFS protocol when unable to provide the more aggressive model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o より積極的なモデルを提供できない場合は、NFSプロトコルの以前のバージョンと同じキャッシュの利点を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Requirements for aggressive caching are organized so that a large portion of the benefit can be obtained even when not all of the requirements can be met.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o アグレッシブキャッシングの要件は、すべての要件を満たせなくても、メリットの大部分を獲得できるように編成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The appropriate requirements for the server are discussed in later sections in which specific forms of caching are covered. (see the section &#34;Open Delegation&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの適切な要件については、後のセクションで説明します。このセクションでは、特定の形式のキャッシングについて説明します。 （「オープン委任」のセクションを参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2--Delegation-and-Callbacks">
9.2. Delegation and Callbacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. 委任とコールバック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recallable delegation of server responsibilities for a file to a client improves performance by avoiding repeated requests to the server in the absence of inter-client conflict. With the use of a &#34;callback&#34; RPC from server to client, a server recalls delegated responsibilities when another client engages in sharing of a delegated file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルに対するサーバーの責任をクライアントに呼び戻せる委任は、クライアント間の競合がない場合にサーバーへの要求が繰り返されることを回避することにより、パフォーマンスを向上させます。サーバーからクライアントへの「コールバック」RPCを使用すると、サーバーは、他のクライアントが委任されたファイルの共有に従事するときに、委任された責任を呼び戻します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A delegation is passed from the server to the client, specifying the object of the delegation and the type of delegation. There are different types of delegations but each type contains a stateid to be used to represent the delegation when performing operations that depend on the delegation. This stateid is similar to those associated with locks and share reservations but differs in that the stateid for a delegation is associated with a clientid and may be used on behalf of all the open_owners for the given client. A delegation is made to the client as a whole and not to any specific process or thread of control within it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
委任はサーバーからクライアントに渡され、委任のオブジェクトと委任のタイプが指定されます。委任にはさまざまなタイプがありますが、各タイプには、委任に依存する操作を実行するときに委任を表すために使用されるstateidが含まれています。この状態IDは、ロックと共有の予約に関連付けられているものと似ていますが、委任の状態IDがクライアントIDに関連付けられ、特定のクライアントのすべてのopen_ownersの代わりに使用できるという点で異なります。委任はクライアント全体に対して行われ、その中の特定のプロセスや制御のスレッドに対しては行われません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because callback RPCs may not work in all environments (due to firewalls, for example), correct protocol operation does not depend on them. Preliminary testing of callback functionality by means of a CB_NULL procedure determines whether callbacks can be supported. The CB_NULL procedure checks the continuity of the callback path. A server makes a preliminary assessment of callback availability to a given client and avoids delegating responsibilities until it has determined that callbacks are supported. Because the granting of a delegation is always conditional upon the absence of conflicting access, clients must not assume that a delegation will be granted and they must always be prepared for OPENs to be processed without any delegations being granted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コールバックRPCはすべての環境（ファイアウォールなど）で機能しない場合があるため、正しいプロトコル操作はそれらに依存しません。 CB_NULLプロシージャを使用したコールバック機能の予備テストにより、コールバックをサポートできるかどうかが決まります。 CB_NULLプロシージャは、コールバックパスの連続性をチェックします。サーバーは、指定されたクライアントへのコールバックの可用性を事前に評価し、コールバックがサポートされていると判断するまで責任の委任を回避します。委任の許可は常にアクセスの競合がないことを条件とするため、クライアントは委任が許可されると想定してはならず、委任が許可されずにOPENが処理されるように常に準備しておく必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once granted, a delegation behaves in most ways like a lock. There is an associated lease that is subject to renewal together with all of the other leases held by that client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
付与された委任は、ロックのようにほとんどの方法で動作します。そのクライアントが保持している他のすべてのリースと一緒に更新される関連リースがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike locks, an operation by a second client to a delegated file will cause the server to recall a delegation through a callback.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックとは異なり、委任されたファイルに対する2番目のクライアントの操作では、サーバーがコールバックを通じて委任を呼び戻します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On recall, the client holding the delegation must flush modified state (such as modified data) to the server and return the delegation. The conflicting request will not receive a response until the recall is complete. The recall is considered complete when the client returns the delegation or the server times out on the recall and revokes the delegation as a result of the timeout. Following the resolution of the recall, the server has the information necessary to grant or deny the second client&#39;s request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
呼び戻し時に、委任を保持しているクライアントは、変更された状態（変更されたデータなど）をサーバーにフラッシュし、委任を返す必要があります。競合する要求は、再呼び出しが完了するまで応答を受け取りません。クライアントが委任を返すか、サーバーが再呼び出しでタイムアウトし、タイムアウトの結果として委任を取り消した場合、再呼び出しは完了したと見なされます。再呼び出しの解決後、サーバーは2番目のクライアントの要求を許可または拒否するために必要な情報を取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the time the client receives a delegation recall, it may have substantial state that needs to be flushed to the server. Therefore, the server should allow sufficient time for the delegation to be returned since it may involve numerous RPCs to the server. If the server is able to determine that the client is diligently flushing state to the server as a result of the recall, the server may extend the usual time allowed for a recall. However, the time allowed for recall completion should not be unbounded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが委任の取り消しを受け取った時点で、サーバーにフラッシュする必要のあるかなりの状態がある場合があります。したがって、サーバーには多数のRPCが含まれる可能性があるため、サーバーは委任が返されるのに十分な時間を確保する必要があります。再呼び出しの結果として、サーバーがクライアントがサーバーに状態をこまめにフラッシュしていると判断できる場合、サーバーは、再呼び出しに許可されている通常の時間を延長できます。ただし、リコール完了に許可される時間には制限がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An example of this is when responsibility to mediate opens on a given file is delegated to a client (see the section &#34;Open Delegation&#34;). The server will not know what opens are in effect on the client. Without this knowledge the server will be unable to determine if the access and deny state for the file allows any particular open until the delegation for the file has been returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例は、特定のファイルのオープンを仲​​介する責任がクライアントに委任されている場合です（「オープン委任」のセクションを参照）。サーバーは、クライアントでどのオープンが有効であるかを認識しません。この知識がないと、サーバーは、ファイルの委任が返されるまで、ファイルのアクセスと拒否の状態が特定のオープンを許可するかどうかを判断できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client failure or a network partition can result in failure to respond to a recall callback. In this case, the server will revoke the delegation which in turn will render useless any modified state still on the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント障害またはネットワークパーティションにより、再呼び出しコールバックへの応答が失敗する場合があります。この場合、サーバーは委任を取り消し、クライアント上で変更された状態を無効にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2-1--Delegation-Recovery">
9.2.1. Delegation Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.1. 委任の回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are three situations that delegation recovery must deal with:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任の回復では、3つの状況に対処する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Client reboot or restart
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントの再起動または再起動
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Server reboot or restart
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーの再起動または再起動
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Network partition (full or callback-only)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ネットワークパーティション（フルまたはコールバックのみ）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event the client reboots or restarts, the failure to renew leases will result in the revocation of record locks and share reservations. Delegations, however, may be treated a bit differently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが再起動または再起動した場合、リースの更新に失敗すると、レコードロックと共有予約が取り消されます。ただし、委任の扱いは少し異なる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There will be situations in which delegations will need to be reestablished after a client reboots or restarts. The reason for this is the client may have file data stored locally and this data was associated with the previously held delegations. The client will need to reestablish the appropriate file state on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが再起動または再起動した後、委任を再確立する必要がある状況があります。これは、クライアントにファイルデータがローカルに格納されている可能性があり、このデータが以前に保持されていた委任に関連付けられていたためです。クライアントはサーバー上で適切なファイル状態を再確立する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To allow for this type of client recovery, the server MAY extend the period for delegation recovery beyond the typical lease expiration period. This implies that requests from other clients that conflict with these delegations will need to wait. Because the normal recall process may require significant time for the client to flush changed state to the server, other clients need be prepared for delays that occur because of a conflicting delegation. This longer interval would increase the window for clients to reboot and consult stable storage so that the delegations can be reclaimed. For open delegations, such delegations are reclaimed using OPEN with a claim type of CLAIM_DELEGATE_PREV. (See the sections on &#34;Data Caching and Revocation&#34; and &#34;Operation 18: OPEN&#34; for discussion of open delegation and the details of OPEN respectively).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このタイプのクライアント回復を可能にするために、サーバーは委任回復の期間を通常のリースの有効期限を超えて延長してもよい（MAY）。これは、これらの委任と競合する他のクライアントからの要求は待機する必要があることを意味します。通常の再呼び出しプロセスでは、クライアントが変更された状態をサーバーにフラッシュするのにかなりの時間がかかる場合があるため、他のクライアントは、委任の競合が原因で発生する遅延に備える必要があります。このより長い間隔は、クライアントが再起動して安定したストレージを参照し、委任を取り戻すことができるウィンドウを増やします。オープンな委任の場合、そのような委任は、クレームタイプがCLAIM_DELEGATE_PREVのOPENを使用して再利用されます。 （それぞれオープンデリゲートとOPENの詳細については、「データキャッシングと取り消し」および「操作18：OPEN」のセクションを参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server MAY support a claim type of CLAIM_DELEGATE_PREV, but if it does, it MUST NOT remove delegations upon SETCLIENTID_CONFIRM, and instead MUST, for a period of time no less than that of the value of the lease_time attribute, maintain the client&#39;s delegations to allow time for the client to issue CLAIM_DELEGATE_PREV requests. The server that supports CLAIM_DELEGATE_PREV MUST support the DELEGPURGE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはクレームタイプCLAIM_DELEGATE_PREVをサポートする場合がありますが、サポートする場合は、SETCLIENTID_CONFIRMでの委任を削除してはならず（MUST）、代わりに、lease_time属性の値の期間以上、クライアントの委任を許可して維持する必要があります。クライアントがCLAIM_DELEGATE_PREVリクエストを発行する時間。 CLAIM_DELEGATE_PREVをサポートするサーバーは、DELEGPURGE操作をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server reboots or restarts, delegations are reclaimed (using the OPEN operation with CLAIM_PREVIOUS) in a similar fashion to record locks and share reservations. However, there is a slight semantic difference. In the normal case if the server decides that a delegation should not be granted, it performs the requested action (e.g., OPEN) without granting any delegation. For reclaim, the server grants the delegation but a special designation is applied so that the client treats the delegation as having been granted but recalled by the server. Because of this, the client has the duty to write all modified state to the server and then return the delegation. This process of handling delegation reclaim reconciles three principles of the NFS version 4 protocol:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが再起動または再起動すると、委任は（CLAIM_PREVIOUSを指定したOPEN操作を使用して）ロックを記録し、予約を共有するのと同じ方法で再利用されます。ただし、わずかな意味上の違いがあります。通常の場合、サーバーが委任を許可しないと決定すると、サーバーは委任を許可せずに要求されたアクション（OPENなど）を実行します。再利用の場合、サーバーは委任を許可しますが、クライアントが委任を許可されたがサーバーによってリコールされたものとして扱うように、特別な指定が適用されます。このため、クライアントには、変更されたすべての状態をサーバーに書き込んでから委任を返す義務があります。委任再利用を処理するこのプロセスは、NFSバージョン4プロトコルの3つの原則を調整します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Upon reclaim, a client reporting resources assigned to it by an earlier server instance must be granted those resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 再利用時には、以前のサーバーインスタンスによって割り当てられたリソースを報告するクライアントに、それらのリソースを付与する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has unquestionable authority to determine whether delegations are to be granted and, once granted, whether they are to be continued.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーには、委任を許可するかどうかを決定する権限があり、一度許可すると、継続するかどうかを決定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The use of callbacks is not to be depended upon until the client has proven its ability to receive them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o コールバックの使用は、クライアントがそれらを受信する能力を証明するまでは依存しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a network partition occurs, delegations are subject to freeing by the server when the lease renewal period expires. This is similar to the behavior for locks and share reservations. For delegations, however, the server may extend the period in which conflicting requests are held off. Eventually the occurrence of a conflicting request from another client will cause revocation of the delegation. A loss of the callback path (e.g., by later network configuration change) will have the same effect. A recall request will fail and revocation of the delegation will result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークパーティションが発生すると、リースの更新期間が終了すると、委任はサーバーによって解放されます。これは、ロックおよび共有予約の動作に似ています。ただし、委任の場合、サーバーは、競合する要求が保留される期間を延長できます。最終的に、別のクライアントからの要求の競合が発生すると、委任が取り消されます。コールバックパスが失われた場合（後でネットワーク構成が変更された場合など）にも同じ影響があります。取り消し要求は失敗し、委任の取り消しが行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client normally finds out about revocation of a delegation when it uses a stateid associated with a delegation and receives the error NFS4ERR_EXPIRED. It also may find out about delegation revocation after a client reboot when it attempts to reclaim a delegation and receives that same error. Note that in the case of a revoked write open delegation, there are issues because data may have been modified by the client whose delegation is revoked and separately by other clients. See the section &#34;Revocation Recovery for Write Open Delegation&#34; for a discussion of such issues. Note also that when delegations are revoked, information about the revoked delegation will be written by the server to stable storage (as described in the section &#34;Crash Recovery&#34;). This is done to deal with the case in which a server reboots after revoking a delegation but before the client holding the revoked delegation is notified about the revocation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは通常、委任に関連付けられた状態IDを使用し、エラーNFS4ERR_EXPIREDを受け取ると、委任の取り消しについて調べます。また、クライアントの再起動後に委任を再利用しようとして同じエラーを受け取ったときに、委任の取り消しについても知ることができます。取り消された書き込みオープン委任の場合、委任が取り消されたクライアントによってデータが変更された可能性があり、他のクライアントによって個別に変更された可能性があることに注意してください。このような問題の説明については、「書き込みオープン委任の失効回復」セクションを参照してください。また、委任が取り消されると、取り消された委任に関する情報がサーバーによって安定したストレージに書き込まれることにも注意してください（「クラッシュリカバリ」セクションで説明）。これは、委任を取り消した後で、取り消された委任を保持しているクライアントに取り消しが通知される前にサーバーが再起動する場合に対処するために行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3--Data-Caching">
9.3. Data Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. データキャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When applications share access to a set of files, they need to be implemented so as to take account of the possibility of conflicting access by another application. This is true whether the applications in question execute on different clients or reside on the same client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションが一連のファイルへのアクセスを共有する場合は、別のアプリケーションによるアクセスの競合の可能性を考慮に入れて、それらを実装する必要があります。これは、問題のアプリケーションが異なるクライアントで実行されているか、同じクライアントに存在しているかに関係なく当てはまります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Share reservations and record locks are the facilities the NFS version 4 protocol provides to allow applications to coordinate access by providing mutual exclusion facilities. The NFS version 4 protocol&#39;s data caching must be implemented such that it does not invalidate the assumptions that those using these facilities depend upon.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有予約とレコードロックは、NFSバージョン4プロトコルが提供する機能であり、相互排除機能を提供することにより、アプリケーションがアクセスを調整できるようにします。 NFSバージョン4プロトコルのデータキャッシングは、これらの機能を使用するユーザーが依存する前提を無効にしないように実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3-1--Data-Caching-and-OPENs">
9.3.1. Data Caching and OPENs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.1. データキャッシングとOPEN
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to avoid invalidating the sharing assumptions that applications rely on, NFS version 4 clients should not provide cached data to applications or modify it on behalf of an application when it would not be valid to obtain or modify that same data via a READ or WRITE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションが依存する共有の仮定が無効になるのを防ぐために、NFSバージョン4クライアントは、キャッシュされたデータをアプリケーションに提供したり、読み取りまたは書き込みを介して同じデータを取得または変更することが有効でない場合に、アプリケーションに代わってそれを変更しないでください。操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Furthermore, in the absence of open delegation (see the section &#34;Open Delegation&#34;) two additional rules apply. Note that these rules are obeyed in practice by many NFS version 2 and version 3 clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、オープンな委任がない場合（「オープンな委任」のセクションを参照）、2つの追加ルールが適用されます。これらのルールは、実際には多くのNFSバージョン2およびバージョン3クライアントによって遵守されていることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o First, cached data present on a client must be revalidated after doing an OPEN. Revalidating means that the client fetches the change attribute from the server, compares it with the cached change attribute, and if different, declares the cached data (as well as the cached attributes) as invalid. This is to ensure that the data for the OPENed file is still correctly reflected in the client&#39;s cache. This validation must be done at least when the client&#39;s OPEN operation includes DENY=WRITE or BOTH thus terminating a period in which other clients may have had the opportunity to open the file with WRITE access. Clients may choose to do the revalidation more often (i.e., at OPENs specifying DENY=NONE) to parallel the NFS version 3 protocol&#39;s practice for the benefit of users assuming this degree of cache revalidation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o まず、クライアントに存在するキャッシュされたデータは、OPENの実行後に再検証する必要があります。再検証とは、クライアントがサーバーから変更属性をフェッチし、それをキャッシュされた変更属性と比較し、異なる場合は、キャッシュされたデータ（およびキャッシュされた属性）を無効として宣言することを意味します。これは、OPENedファイルのデータがクライアントのキャッシュに正しく反映されるようにするためです。この検証は、少なくともクライアントのOPEN操作にDENY = WRITEまたはBOTHが含まれている場合に実行する必要があるため、他のクライアントがWRITEアクセスでファイルを開く機会があった可能性がある期間を終了します。クライアントは、より頻繁に（つまり、OPENでDENY = NONEを指定して）再検証を行うことを選択して、ユーザーがこの程度のキャッシュの再検証を想定するために、NFSバージョン3プロトコルの慣行と並行することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Since the change attribute is updated for data and metadata modifications, some client implementors may be tempted to use the time_modify attribute and not change to validate cached data, so that metadata changes do not spuriously invalidate clean data. The implementor is cautioned in this approach. The change attribute is guaranteed to change for each update to the file, whereas time_modify is guaranteed to change only at the granularity of the time_delta attribute. Use by the client&#39;s data cache validation logic of time_modify and not change runs the risk of the client incorrectly marking stale data as valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
change属性はデータとメタデータの変更のために更新されるため、一部のクライアント実装者は、time_modify属性を使用してキャッシュデータの検証を変更しないように誘惑され、メタデータの変更がクリーンなデータを誤って無効にすることがないようにします。このアプローチでは、実装者に警告が出されます。 change属性は、ファイルの更新ごとに変更されることが保証されていますが、time_modifyは、time_delta属性の粒度でのみ変更されることが保証されています。クライアントのデータキャッシュ検証ロジックであるtime_modifyを使用し、変更しないと、クライアントが古いデータを有効として誤ってマークするリスクがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Second, modified data must be flushed to the server before closing a file OPENed for write. This is complementary to the first rule. If the data is not flushed at CLOSE, the revalidation done after client OPENs as file is unable to achieve its purpose. The other aspect to flushing the data before close is that the data must be committed to stable storage, at the server, before the CLOSE operation is requested by the client. In the case of a server reboot or restart and a CLOSEd file, it may not be possible to retransmit the data to be written to the file. Hence, this requirement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第2に、書き込み用にOPENされたファイルを閉じる前に、変更されたデータをサーバーにフラッシュする必要があります。これは最初のルールを補足するものです。データがCLOSEでフラッシュされない場合、ファイルがその目的を達成できないため、クライアントがOPENした後に行われる再検証。閉じる前にデータをフラッシュするもう1つの側面は、クライアントがCLOSE操作を要求する前に、サーバーでデータを安定したストレージにコミットする必要があることです。サーバーの再起動または再起動とCLOSEdファイルの場合、ファイルに書き込まれるデータを再送信できない可能性があります。したがって、この要件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3-2--Data-Caching-and-File-Locking">
9.3.2. Data Caching and File Locking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.2. データのキャッシュとファイルのロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For those applications that choose to use file locking instead of share reservations to exclude inconsistent file access, there is an analogous set of constraints that apply to client side data caching. These rules are effective only if the file locking is used in a way that matches in an equivalent way the actual READ and WRITE operations executed. This is as opposed to file locking that is based on pure convention. For example, it is possible to manipulate a two-megabyte file by dividing the file into two one-megabyte regions and protecting access to the two regions by file locks on bytes zero and one. A lock for write on byte zero of the file would represent the right to do READ and WRITE operations on the first region. A lock for write on byte one of the file would represent the right to do READ and WRITE operations on the second region. As long as all applications manipulating the file obey this convention, they will work on a local filesystem. However, they may not work with the NFS version 4 protocol unless clients refrain from data caching.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有予約の代わりにファイルロックを使用して、一貫性のないファイルアクセスを除外することを選択したアプリケーションには、クライアント側のデータキャッシュに適用される一連の類似した制約があります。これらのルールは、実際のREADおよびWRITE操作が実行されたのと同等の方法で一致する方法でファイルロックが使用されている場合にのみ有効です。これは、純粋な規則に基づくファイルロックとは対照的です。たとえば、ファイルを2つの1メガバイトの領域に分割し、2つの領域へのアクセスをバイト0と1のファイルロックによって保護することで、2メガバイトのファイルを操作できます。ファイルのバイト0に対する書き込みのロックは、最初の領域でREADおよびWRITE操作を実行する権利を表します。ファイルのバイト1に対する書き込みのロックは、2番目の領域でREADおよびWRITE操作を実行する権利を表します。ファイルを操作するすべてのアプリケーションがこの規則に従う限り、ローカルファイルシステムで動作します。ただし、クライアントがデータキャッシュを控えない限り、NFSバージョン4プロトコルでは機能しない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rules for data caching in the file locking environment are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルロック環境でのデータキャッシングのルールは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o First, when a client obtains a file lock for a particular region, the data cache corresponding to that region (if any cached data exists) must be revalidated. If the change attribute indicates that the file may have been updated since the cached data was obtained, the client must flush or invalidate the cached data for the newly locked region. A client might choose to invalidate all of non-modified cached data that it has for the file but the only requirement for correct operation is to invalidate all of the data in the newly locked region.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o まず、クライアントが特定の領域のファイルロックを取得すると、その領域に対応するデータキャッシュ（キャッシュされたデータが存在する場合）を再検証する必要があります。変更された属性が、キャッシュされたデータの取得後にファイルが更新された可能性があることを示している場合、クライアントは、新しくロックされた領域のキャッシュされたデータをフラッシュまたは無効にする必要があります。クライアントは、ファイルにある変更されていないすべてのキャッシュデータを無効にすることを選択する場合がありますが、正しく動作するための唯一の要件は、新しくロックされた領域のすべてのデータを無効にすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Second, before releasing a write lock for a region, all modified data for that region must be flushed to the server. The modified data must also be written to stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 次に、リージョンの書き込みロックを解放する前に、そのリージョンのすべての変更データをサーバーにフラッシュする必要があります。変更されたデータも安定したストレージに書き込む必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that flushing data to the server and the invalidation of cached data must reflect the actual byte ranges locked or unlocked. Rounding these up or down to reflect client cache block boundaries will cause problems if not carefully done. For example, writing a modified block when only half of that block is within an area being unlocked may cause invalid modification to the region outside the unlocked area. This, in turn, may be part of a region locked by another client. Clients can avoid this situation by synchronously performing portions of write operations that overlap that portion (initial or final) that is not a full block. Similarly, invalidating a locked area which is not an integral number of full buffer blocks would require the client to read one or two partial blocks from the server if the revalidation procedure shows that the data which the client possesses may not be valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーへのデータのフラッシュとキャッシュデータの無効化は、ロックまたはロック解除された実際のバイト範囲を反映する必要があることに注意してください。これらを切り上げまたは切り下げてクライアントキャッシュブロックの境界を反映させると、注意深く行わないと問題が発生します。たとえば、ブロックの半分だけがロック解除されている領域内にあるときに変更されたブロックを書き込むと、ロック解除された領域の外側の領域が無効に変更される可能性があります。これは、別のクライアントによってロックされている領域の一部である可能性があります。クライアントは、フルブロックではない部分（初期または最終）とオーバーラップする書き込み操作の部分を同期的に実行することにより、この状況を回避できます。同様に、完全なバッファーブロックの整数ではないロックされた領域を無効にすると、クライアントが所有するデータが有効でない可能性があることが再検証手順で示される場合、クライアントはサーバーから1つまたは2つの部分ブロックを読み取る必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The data that is written to the server as a prerequisite to the unlocking of a region must be written, at the server, to stable storage. The client may accomplish this either with synchronous writes or by following asynchronous writes with a COMMIT operation. This is required because retransmission of the modified data after a server reboot might conflict with a lock held by another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リージョンのロック解除の前提条件としてサーバーに書き込まれるデータは、サーバーで安定したストレージに書き込まれる必要があります。クライアントは、同期書き込みを使用するか、COMMIT操作で非同期書き込みを実行することにより、これを実行できます。これは、サーバーの再起動後の変更されたデータの再送信が別のクライアントによって保持されているロックと競合する可能性があるために必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client implementation may choose to accommodate applications which use record locking in non-standard ways (e.g., using a record lock as a global semaphore) by flushing to the server more data upon an LOCKU than is covered by the locked range. This may include modified data within files other than the one for which the unlocks are being done. In such cases, the client must not interfere with applications whose READs and WRITEs are being done only within the bounds of record locks which the application holds. For example, an application locks a single byte of a file and proceeds to write that single byte. A client that chose to handle a LOCKU by flushing all modified data to the server could validly write that single byte in response to an unrelated unlock. However, it would not be valid to write the entire block in which that single written byte was located since it includes an area that is not locked and might be locked by another client. Client implementations can avoid this problem by dividing files with modified data into those for which all modifications are done to areas covered by an appropriate record lock and those for which there are modifications not covered by a record lock. Any writes done for the former class of files must not include areas not locked and thus not modified on the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの実装は、非標準的な方法でレコードロックを使用するアプリケーション（たとえば、グローバルセマフォとしてレコードロックを使用する）に対応することを選択できます。これには、ロック解除が行われているファイル以外のファイル内の変更されたデータが含まれる場合があります。このような場合、クライアントは、アプリケーションが保持するレコードロックの境界内でのみREADおよびWRITEが実行されるアプリケーションに干渉してはなりません。たとえば、アプリケーションはファイルの1バイトをロックし、その1バイトの書き込みを続行します。変更されたすべてのデータをサーバーにフラッシュすることによりLOCKUを処理することを選択したクライアントは、無関係なロック解除に応答してその1バイトを有効に書き込むことができます。ただし、ロックされていない領域が含まれていて、別のクライアントによってロックされている可能性があるため、書き込まれた単一のバイトが配置されたブロック全体を書き込むことは無効です。クライアントの実装では、データが変更されたファイルを、適切なレコードロックによってカバーされる領域に対してすべての変更が行われるファイルと、レコードロックによってカバーされない変更があるファイルに分割することで、この問題を回避できます。前のクラスのファイルに対して行われた書き込みには、ロックされていない領域が含まれていて、クライアントで変更されていないことが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3-3--Data-Caching-and-Mandatory-File-Locking">
9.3.3. Data Caching and Mandatory File Locking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.3. データキャッシングと必須ファイルロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client side data caching needs to respect mandatory file locking when it is in effect. The presence of mandatory file locking for a given file is indicated when the client gets back NFS4ERR_LOCKED from a READ or WRITE on a file it has an appropriate share reservation for. When mandatory locking is in effect for a file, the client must check for an appropriate file lock for data being read or written. If a lock exists for the range being read or written, the client may satisfy the request using the client&#39;s validated cache. If an appropriate file lock is not held for the range of the read or write, the read or write request must not be satisfied by the client&#39;s cache and the request must be sent to the server for processing. When a read or write request partially overlaps a locked region, the request should be subdivided into multiple pieces with each region (locked or not) treated appropriately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント側のデータキャッシュは、有効な場合、必須のファイルロックを尊重する必要があります。特定のファイルの必須ファイルロックの存在は、クライアントが適切な共有予約を持っているファイルの読み取りまたは書き込みからNFS4ERR_LOCKEDを取得したときに示されます。ファイルに対して強制ロックが有効になっている場合、クライアントは、読み取りまたは書き込み中のデータに対して適切なファイルロックを確認する必要があります。読み取りまたは書き込みされている範囲にロックが存在する場合、クライアントは、クライアントの検証済みキャッシュを使用して要求を満たすことができます。読み取りまたは書き込みの範囲で適切なファイルロックが保持されていない場合、読み取りまたは書き込み要求はクライアントのキャッシュによって満たされず、要求はサーバーに送信されて処理される必要があります。読み取りまたは書き込み要求がロックされた領域と部分的にオーバーラップする場合、要求は複数の部分に分割され、各領域（ロックされているかどうかにかかわらず）が適切に処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3-4--Data-Caching-and-File-Identity">
9.3.4. Data Caching and File Identity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.4. データキャッシングとファイルID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When clients cache data, the file data needs to be organized according to the filesystem object to which the data belongs. For NFS version 3 clients, the typical practice has been to assume for the purpose of caching that distinct filehandles represent distinct filesystem objects. The client then has the choice to organize and maintain the data cache on this basis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがデータをキャッシュする場合、ファイルデータは、データが属するファイルシステムオブジェクトに従って編成する必要があります。 NFSバージョン3クライアントの場合、典型的な方法は、キャッシングの目的で、個別のファイルハンドルが個別のファイルシステムオブジェクトを表すと想定することでした。その後、クライアントは、これに基づいてデータキャッシュを整理および維持することを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the NFS version 4 protocol, there is now the possibility to have significant deviations from a &#34;one filehandle per object&#34; model because a filehandle may be constructed on the basis of the object&#39;s pathname. Therefore, clients need a reliable method to determine if two filehandles designate the same filesystem object. If clients were simply to assume that all distinct filehandles denote distinct objects and proceed to do data caching on this basis, caching inconsistencies would arise between the distinct client side objects which mapped to the same server side object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルでは、ファイルハンドルはオブジェクトのパス名に基づいて構築される可能性があるため、「オブジェクトごとに1つのファイルハンドル」モデルから大幅に逸脱する可能性があります。したがって、クライアントは、2つのファイルハンドルが同じファイルシステムオブジェクトを指定しているかどうかを判断するための信頼できる方法を必要とします。クライアントがすべての個別のファイルハンドルが個別のオブジェクトを表すと仮定し、これに基づいてデータキャッシングを続行すると、同じサーバーサイドオブジェクトにマップされた個別のクライアントサイドオブジェクト間でキャッシュの不整合が発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By providing a method to differentiate filehandles, the NFS version 4 protocol alleviates a potential functional regression in comparison with the NFS version 3 protocol. Without this method, caching inconsistencies within the same client could occur and this has not been present in previous versions of the NFS protocol. Note that it is possible to have such inconsistencies with applications executing on multiple clients but that is not the issue being addressed here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルハンドルを区別する方法を提供することにより、NFSバージョン4プロトコルは、NFSバージョン3プロトコルと比較して潜在的な機能低下を軽減します。この方法がないと、同じクライアント内でキャッシュの不整合が発生する可能性があり、これは以前のバージョンのNFSプロトコルには存在しませんでした。複数のクライアントで実行されているアプリケーションとこのような不整合が生じる可能性がありますが、ここでは対処されていないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 For the purposes of data caching, the following steps allow an NFS version 4 client to determine whether two distinct filehandles denote the same server side object: o If GETATTR directed to two filehandles returns different values of the fsid attribute, then the filehandles represent distinct objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
データキャッシュの目的で、次の手順により、NFSバージョン4クライアントは、2つの異なるファイルハンドルが同じサーバー側オブジェクトを表すかどうかを判断できます。o 2つのファイルハンドルに向けられたGETATTRがfsid属性の異なる値を返す場合、ファイルハンドルは異なるオブジェクトを表します。 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If GETATTR for any file with an fsid that matches the fsid of the two filehandles in question returns a unique_handles attribute with a value of TRUE, then the two objects are distinct.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 問題の2つのファイルハンドルのfsidに一致するfsidを持つファイルのGETATTRが、値がTRUEのunique_handles属性を返す場合、2つのオブジェクトは異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If GETATTR directed to the two filehandles does not return the fileid attribute for both of the handles, then it cannot be determined whether the two objects are the same. Therefore, operations which depend on that knowledge (e.g., client side data caching) cannot be done reliably.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2つのファイルハンドルに向けられたGETATTRが両方のハンドルのfileid属性を返さない場合、2つのオブジェクトが同じかどうかを判断できません。したがって、その知識に依存する操作（クライアント側のデータキャッシュなど）は確実に実行できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If GETATTR directed to the two filehandles returns different values for the fileid attribute, then they are distinct objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2つのファイルハンドルに向けられたGETATTRがfileid属性に異なる値を返す場合、それらは異なるオブジェクトです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Otherwise they are the same object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o それ以外は同じオブジェクトです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-4--Open-Delegation">
9.4. Open Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4. オープンな委任
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a file is being OPENed, the server may delegate further handling of opens and closes for that file to the opening client. Any such delegation is recallable, since the circumstances that allowed for the delegation are subject to change. In particular, the server may receive a conflicting OPEN from another client, the server must recall the delegation before deciding whether the OPEN from the other client may be granted. Making a delegation is up to the server and clients should not assume that any particular OPEN either will or will not result in an open delegation. The following is a typical set of conditions that servers might use in deciding whether OPEN should be delegated:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルがOPENされているとき、サーバーはそのファイルのオープンとクローズの処理をオープンしているクライアントに委任する場合があります。委任を許可された状況は変更される可能性があるため、このような委任は再呼び出し可能です。特に、サーバーは別のクライアントから競合するOPENを受信する可能性があります。サーバーは、他のクライアントからのOPENが許可されるかどうかを決定する前に委任をリコールする必要があります。委任を行うかどうかはサーバー次第であり、クライアントは、特定のOPENがオープン委任をもたらすかどうかを想定してはなりません。以下は、OPENを委任する必要があるかどうかを決定する際にサーバーが使用する可能性のある典型的な一連の条件です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client must be able to respond to the server&#39;s callback requests. The server will use the CB_NULL procedure for a test of callback ability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントは、サーバーのコールバック要求に応答できる必要があります。サーバーは、コールバック機能のテストにCB_NULLプロシージャを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client must have responded properly to previous recalls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントは以前のリコールに適切に応答している必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There must be no current open conflicting with the requested delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 現在、要求された委任と競合するオープンオープンがあってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There should be no current delegation that conflicts with the delegation being requested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 要求されている委任と競合する現在の委任があってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The probability of future conflicting open requests should be low based on the recent history of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルの最近の履歴に基づいて、将来の競合するオープンリクエストの可能性は低くなるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The existence of any server-specific semantics of OPEN/CLOSE that would make the required handling incompatible with the prescribed handling that the delegated client would apply (see below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 必要な処理を、委任されたクライアントが適用する規定の処理と互換性のないものにする、OPEN / CLOSEのサーバー固有のセマンティクスの存在（以下を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two types of open delegations, read and write. A read open delegation allows a client to handle, on its own, requests to open a file for reading that do not deny read access to others. Multiple read open delegations may be outstanding simultaneously and do not conflict. A write open delegation allows the client to handle, on its own, all opens. Only one write open delegation may exist for a given file at a given time and it is inconsistent with any read open delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オープン委任には、読み取りと書き込みの2つのタイプがあります。読み取りオープン委任により、クライアントは、他のユーザーへの読み取りアクセスを拒否しない読み取り用にファイルを開く要求を、それ自体で処理できます。複数の読み取りオープン委任は同時に未解決であり、競合しない場合があります。書き込みオープン委任により、クライアントは単独ですべてのオープンを処理できます。指定されたファイルに対して同時に指定できる書き込みオープン委任は1つだけです。これは、読み取りオープン委任と矛盾します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client has a read open delegation, it may not make any changes to the contents or attributes of the file but it is assured that no other client may do so. When a client has a write open delegation, it may modify the file data since no other client will be accessing the file&#39;s data. The client holding a write delegation may only affect file attributes which are intimately connected with the file data: size, time_modify, change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントに読み取りオープン委任がある場合、ファイルの内容または属性に変更を加えることはできませんが、他のクライアントが行うことはないことが保証されます。クライアントに書き込みオープン委任がある場合、他のクライアントがファイルのデータにアクセスしないため、クライアントはファイルデータを変更する可能性があります。書き込み委任を保持しているクライアントは、ファイルデータと密接に関連しているファイル属性（サイズ、time_modify、変更）にのみ影響を与える可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client has an open delegation, it does not send OPENs or CLOSEs to the server but updates the appropriate status internally. For a read open delegation, opens that cannot be handled locally (opens for write or that deny read access) must be sent to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントにオープンな委任がある場合、クライアントはサーバーにOPENまたはCLOSEを送信しませんが、内部で適切なステータスを更新します。読み取りオープン委任の場合、ローカルで処理できないオープン（書き込みのためのオープンまたは読み取りアクセスを拒否する）をサーバーに送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an open delegation is made, the response to the OPEN contains an open delegation structure which specifies the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オープン委任が行われると、OPENへの応答には、以下を指定するオープン委任構造が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the type of delegation (read or write)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 委任のタイプ（読み取りまたは書き込み）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o space limitation information to control flushing of data on close (write open delegation only, see the section &#34;Open Delegation and Data Caching&#34;)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クローズ時のデータのフラッシュを制御するためのスペース制限情報（オープン委任のみを書き込み、「オープン委任とデータキャッシング」のセクションを参照）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o an nfsace4 specifying read and write permissions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 読み取りおよび書き込み権限を指定するnfsace4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o a stateid to represent the delegation for READ and WRITE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READおよびWRITEの委任を表す状態ID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The delegation stateid is separate and distinct from the stateid for the OPEN proper. The standard stateid, unlike the delegation stateid, is associated with a particular lock_owner and will continue to be valid after the delegation is recalled and the file remains open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任状態IDは、OPEN固有の状態IDとは別のものです。委任状態IDとは異なり、標準の状態IDは特定のlock_ownerに関連付けられており、委任が呼び出されてファイルが開いたままになった後も引き続き有効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a request internal to the client is made to open a file and open delegation is in effect, it will be accepted or rejected solely on the basis of the following conditions. Any requirement for other checks to be made by the delegate should result in open delegation being denied so that the checks can be made by the server itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント内部の要求がファイルを開くように行われ、オープン委任が有効である場合、次の条件に基づいてのみ、それが受け入れられるか拒否されます。デリゲートが他のチェックを行う必要があると、サーバー自体がチェックできるように、オープンな委任が拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The access and deny bits for the request and the file as described in the section &#34;Share Reservations&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「予約の共有」セクションで説明されている、リクエストとファイルのアクセスビットと拒否ビット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The read and write permissions as determined below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 以下で決定される読み取りおよび書き込み権限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfsace4 passed with delegation can be used to avoid frequent ACCESS calls. The permission check should be as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任で渡されたnfsace4は、頻繁なACCESS呼び出しを回避するために使用できます。権限チェックは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the nfsace4 indicates that the open may be done, then it should be granted without reference to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o nfsace4がオープンを実行できることを示している場合は、サーバーを参照せずに許可する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the nfsace4 indicates that the open may not be done, then an ACCESS request must be sent to the server to obtain the definitive answer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o nfsace4がオープンが実行されない可能性があることを示している場合、最終的な回答を取得するには、ACCESS要求をサーバーに送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server may return an nfsace4 that is more restrictive than the actual ACL of the file. This includes an nfsace4 that specifies denial of all access. Note that some common practices such as mapping the traditional user &#34;root&#34; to the user &#34;nobody&#34; may make it incorrect to return the actual ACL of the file in the delegation response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ファイルの実際のACLよりも制限の厳しいnfsace4を返す場合があります。これには、すべてのアクセスの拒否を指定するnfsace4が含まれます。従来のユーザー「root」をユーザー「nobody」にマッピングするなどのいくつかの一般的な方法では、委任応答でファイルの実際のACLを返すことが正しくない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of delegation together with various other forms of caching creates the possibility that no server authentication will ever be performed for a given user since all of the user&#39;s requests might be satisfied locally. Where the client is depending on the server for authentication, the client should be sure authentication occurs for each user by use of the ACCESS operation. This should be the case even if an ACCESS operation would not be required otherwise. As mentioned before, the server may enforce frequent authentication by returning an nfsace4 denying all access with every open delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任を他のさまざまな形式のキャッシュと組み合わせて使用​​すると、ユーザーのすべての要求がローカルで満たされる可能性があるため、特定のユーザーに対してサーバー認証が実行されない可能性があります。クライアントが認証をサーバーに依存している場合、クライアントはACCESS操作を使用して、ユーザーごとに認証が行われるようにする必要があります。これは、ACCESS操作が必要でない場合でも当てはまります。前述のように、サーバーは、開いているすべての委任ですべてのアクセスを拒否するnfsace4を返すことにより、頻繁な認証を実施する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-4-1--Open-Delegation-and-Data-Caching">
9.4.1. Open Delegation and Data Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.1. オープンな委任とデータキャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 OPEN delegation allows much of the message overhead associated with the opening and closing files to be eliminated. An open when an open delegation is in effect does not require that a validation message be sent to the server. The continued endurance of the &#34;read open delegation&#34; provides a guarantee that no OPEN for write and thus no write has occurred. Similarly, when closing a file opened for write and if write open delegation is in effect, the data written does not have to be flushed to the server until the open delegation is recalled. The continued endurance of the open delegation provides a guarantee that no open and thus no read or write has been done by another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
OPEN委任により、ファイルのオープンとクローズに関連するメッセージオーバーヘッドの多くを排除できます。オープン委任が有効な場合のオープンでは、検証メッセージをサーバーに送信する必要はありません。 「読み取りオープン委任」の継続的な耐久性により、書き込み用のOPENがないため、書き込みが発生しないことが保証されます。同様に、書き込み用に開かれたファイルを閉じるとき、書き込みオープン委任が有効になっている場合、オープン委任が呼び出されるまで、書き込まれたデータをサーバーにフラッシュする必要はありません。オープンな委任の継続的な耐久性は、他のクライアントによってオープンが行われず、したがって読み取りまたは書き込みが行われないことを保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the purposes of open delegation, READs and WRITEs done without an OPEN are treated as the functional equivalents of a corresponding type of OPEN. This refers to the READs and WRITEs that use the special stateids consisting of all zero bits or all one bits. Therefore, READs or WRITEs with a special stateid done by another client will force the server to recall a write open delegation. A WRITE with a special stateid done by another client will force a recall of read open delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オープン委任の目的で、OPENなしで行われるREADおよびWRITEは、対応するタイプのOPENと機能的に同等のものとして扱われます。これは、すべて0のビットまたはすべて1のビットで構成される特別な状態IDを使用するREADおよびWRITEを指します。したがって、別のクライアントが特別な状態IDを使用してREADまたはWRITEを実行すると、サーバーは書き込みオープン委譲を強制的に呼び出します。別のクライアントが特別な状態IDを使用してWRITEを実行すると、読み取りオープンの委任が強制的に呼び出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With delegations, a client is able to avoid writing data to the server when the CLOSE of a file is serviced. The file close system call is the usual point at which the client is notified of a lack of stable storage for the modified file data generated by the application. At the close, file data is written to the server and through normal accounting the server is able to determine if the available filesystem space for the data has been exceeded (i.e., server returns NFS4ERR_NOSPC or NFS4ERR_DQUOT). This accounting includes quotas. The introduction of delegations requires that a alternative method be in place for the same type of communication to occur between client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任を使用すると、クライアントは、ファイルのCLOSEが処理されるときに、サーバーへのデータの書き込みを回避できます。ファイルクローズシステムコールは、アプリケーションによって生成された変更されたファイルデータ用の安定したストレージの不足をクライアントに通知する通常のポイントです。終了時に、ファイルデータはサーバーに書き込まれ、通常のアカウンティングを通じて、サーバーはデータに使用可能なファイルシステム領域を超えているかどうかを判別できます（つまり、サーバーはNFS4ERR_NOSPCまたはNFS4ERR_DQUOTを返します）。このアカウンティングには割り当てが含まれます。委任を導入するには、クライアントとサーバー間で同じ種類の通信を行うための代替方法を用意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the delegation response, the server provides either the limit of the size of the file or the number of modified blocks and associated block size. The server must ensure that the client will be able to flush data to the server of a size equal to that provided in the original delegation. The server must make this assurance for all outstanding delegations. Therefore, the server must be careful in its management of available space for new or modified data taking into account available filesystem space and any applicable quotas. The server can recall delegations as a result of managing the available filesystem space. The client should abide by the server&#39;s state space limits for delegations. If the client exceeds the stated limits for the delegation, the server&#39;s behavior is undefined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任応答では、サーバーはファイルのサイズの制限、または変更されたブロックの数と関連するブロックサイズのいずれかを提供します。サーバーは、クライアントが元の委任で提供されたものと同じサイズのデータ​​をサーバーにフラッシュできるようにする必要があります。サーバーは、すべての未解決の委任に対してこの保証を行う必要があります。したがって、サーバーは、使用可能なファイルシステムのスペースと適用可能な割り当て量を考慮して、新規または変更されたデータ用の使用可能なスペースの管理に注意する必要があります。サーバーは、使用可能なファイルシステム領域を管理した結果、委任を呼び出すことができます。クライアントは、委任に関するサーバーの状態スペース制限を遵守する必要があります。クライアントが指定された委任の制限を超えると、サーバーの動作は未定義になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on server conditions, quotas or available filesystem space, the server may grant write open delegations with very restrictive space limitations. The limitations may be defined in a way that will always force modified data to be flushed to the server on close.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの状態、割り当て量、または利用可能なファイルシステムのスペースに基づいて、サーバーはスペース制限が非常に制限された書き込みオープン委任を許可する場合があります。制限は、変更されたデータを常に閉じるときに強制的にサーバーにフラッシュするように定義できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 With respect to authentication, flushing modified data to the server after a CLOSE has occurred may be problematic. For example, the user of the application may have logged off the client and unexpired authentication credentials may not be present. In this case, the client may need to take special care to ensure that local unexpired credentials will in fact be available. This may be accomplished by tracking the expiration time of credentials and flushing data well in advance of their expiration or by making private copies of credentials to assure their availability when needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
認証に関しては、CLOSEが発生した後に変更されたデータをサーバーにフラッシュすることは問題となる場合があります。たとえば、アプリケーションのユーザーがクライアントからログオフし、有効期限が切れていない認証資格情報が存在しない場合があります。この場合、クライアントは、有効期限が切れていないローカルの資格情報が実際に使用可能になるように特別な注意を払う必要がある場合があります。これは、資格情報の有効期限を追跡し、有効期限の前にデータをフラッシュするか、資格情報のプライベートコピーを作成して、必要なときに可用性を保証することで実現できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-4-2--Open-Delegation-and-File-Locks">
9.4.2. Open Delegation and File Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.2. 委任とファイルロックを開く
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client holds a write open delegation, lock operations may be performed locally. This includes those required for mandatory file locking. This can be done since the delegation implies that there can be no conflicting locks. Similarly, all of the revalidations that would normally be associated with obtaining locks and the flushing of data associated with the releasing of locks need not be done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが書き込みオープン委任を保持している場合、ロック操作がローカルで実行される場合があります。これには、必須のファイルロックに必要なものが含まれます。委任は競合するロックがないことを暗示しているため、これを行うことができます。同様に、通常はロックの取得に関連するすべての再検証と、ロックの解放に関連するデータのフラッシュを実行する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client holds a read open delegation, lock operations are not performed locally. All lock operations, including those requesting non-exclusive locks, are sent to the server for resolution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが読み取りオープン委任を保持している場合、ロック操作はローカルでは実行されません。非排他的ロックを要求するものを含むすべてのロック操作は、解決のためにサーバーに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-4-3--Handling-of-CBGETATTR">
9.4.3. Handling of CB_GETATTR
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.3. CB_GETATTRの処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server needs to employ special handling for a GETATTR where the target is a file that has a write open delegation in effect. The reason for this is that the client holding the write delegation may have modified the data and the server needs to reflect this change to the second client that submitted the GETATTR. Therefore, the client holding the write delegation needs to be interrogated. The server will use the CB_GETATTR operation. The only attributes that the server can reliably query via CB_GETATTR are size and change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ターゲットが書き込みオープン委任が有効になっているファイルであるGETATTRに対して特別な処理を採用する必要があります。これは、書き込み委任を保持しているクライアントがデータを変更した可能性があり、サーバーがこの変更をGETATTRを送信した2番目のクライアントに反映する必要があるためです。したがって、書き込み委任を保持しているクライアントに問い合わせる必要があります。サーバーはCB_GETATTR操作を使用します。サーバーがCB_GETATTRを介して確実に照会できる属性は、サイズと変更のみです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since CB_GETATTR is being used to satisfy another client&#39;s GETATTR request, the server only needs to know if the client holding the delegation has a modified version of the file. If the client&#39;s copy of the delegated file is not modified (data or size), the server can satisfy the second client&#39;s GETATTR request from the attributes stored locally at the server. If the file is modified, the server only needs to know about this modified state. If the server determines that the file is currently modified, it will respond to the second client&#39;s GETATTR as if the file had been modified locally at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_GETATTRは別のクライアントのGETATTR要求を満たすために使用されているため、サーバーは、委任を保持しているクライアントが変更されたバージョンのファイルを持っているかどうかを知るだけで済みます。委任されたファイルのクライアントのコピーが変更されていない場合（データまたはサイズ）、サーバーは、サーバーにローカルに格納されている属性からの2番目のクライアントのGETATTR要求を満たすことができます。ファイルが変更された場合、サーバーはこの変更された状態についてのみ知る必要があります。ファイルが現在変更されているとサーバーが判断すると、サーバーでファイルがローカルで変更されたかのように、2番目のクライアントのGETATTRに応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the form of the change attribute is determined by the server and is opaque to the client, the client and server need to agree on a method of communicating the modified state of the file. For the size attribute, the client will report its current view of the file size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変更属性の形式はサーバーによって決定され、クライアントに対して不透明であるため、クライアントとサーバーは、ファイルの変更された状態を通信する方法について合意する必要があります。 size属性の場合、クライアントはファイルサイズの現在のビューを報告します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the change attribute, the handling is more involved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変更属性の場合、処理はより複雑になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the client, the following steps will be taken when receiving a write delegation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの場合、書き込み委任を受信するときに次の手順が実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The value of the change attribute will be obtained from the server and cached. Let this value be represented by c.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 変更属性の値はサーバーから取得され、キャッシュされます。この値をcで表すとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client will create a value greater than c that will be used for communicating modified data is held at the client. Let this value be represented by d.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントは、クライアントで保持されている変更されたデータの通信に使用されるcより大きい値を作成します。この値をdで表すとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the client is queried via CB_GETATTR for the change attribute, it checks to see if it holds modified data. If the file is modified, the value d is returned for the change attribute value. If this file is not currently modified, the client returns the value c for the change attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントは、CB_GETATTRを介して変更属性を照会されると、変更されたデータを保持しているかどうかを確認します。ファイルが変更されると、変更属性値として値dが返されます。このファイルが現在変更されていない場合、クライアントは、変更属性の値cを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For simplicity of implementation, the client MAY for each CB_GETATTR return the same value d. This is true even if, between successive CB_GETATTR operations, the client again modifies in the file&#39;s data or metadata in its cache. The client can return the same value because the only requirement is that the client be able to indicate to the server that the client holds modified data. Therefore, the value of d may always be c + 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装を簡単にするために、各CB_GETATTRのクライアントは同じ値dを返す場合があります。これは、連続するCB_GETATTR操作の間に、クライアントがキャッシュ内のファイルのデータまたはメタデータを再度変更した場合でも当てはまります。クライアントが変更されたデータを保持していることをクライアントがサーバーに示すことができることが唯一の要件であるため、クライアントは同じ値を返すことができます。したがって、dの値は常にc + 1になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the change attribute is opaque to the client in the sense that it has no idea what units of time, if any, the server is counting change with, it is not opaque in that the client has to treat it as an unsigned integer, and the server has to be able to see the results of the client&#39;s changes to that integer. Therefore, the server MUST encode the change attribute in network order when sending it to the client. The client MUST decode it from network order to its native order when receiving it and the client MUST encode it network order when sending it to the server. For this reason, change is defined as an unsigned integer rather than an opaque array of octets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
change属性は、サーバーが変更をカウントしている時間単位がある場合、その意味がわからないという意味でクライアントに対して不透明ですが、クライアントがそれを符号なし整数として処理する必要があるという点では不透明ではありません。サーバーは、その整数に対するクライアントの変更の結果を見ることができる必要があります。したがって、サーバーは、クライアントに送信するときに、変更属性をネットワーク順にエンコードする必要があります。クライアントは、それを受信するときにネットワークの順序からそのネイティブの順序にデコードする必要があり、クライアントはサーバーに送信するときにネットワークの順序をエンコードする必要があります。このため、変更はオクテットの不透明な配列ではなく、符号なし整数として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the server, the following steps will be taken when providing a write delegation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーでは、書き込み委任を提供するときに次の手順が実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Upon providing a write delegation, the server will cache a copy of the change attribute in the data structure it uses to record the delegation. Let this value be represented by sc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 書き込み委任を提供すると、サーバーは変更属性のコピーを、委任の記録に使用するデータ構造にキャッシュします。この値をscで表すとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When a second client sends a GETATTR operation on the same file to the server, the server obtains the change attribute from the first client. Let this value be cc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2番目のクライアントが同じファイルのGETATTR操作をサーバーに送信すると、サーバーは最初のクライアントから変更属性を取得します。この値をccとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the value cc is equal to sc, the file is not modified and the server returns the current values for change, time_metadata, and time_modify (for example) to the second client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 値ccがscと等しい場合、ファイルは変更されず、サーバーは変更、time_metadata、time_modifyなどの現在の値を2番目のクライアントに返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the value cc is NOT equal to sc, the file is currently modified at the first client and most likely will be modified at the server at a future time. The server then uses its current time to construct attribute values for time_metadata and time_modify. A new value of sc, which we will call nsc, is computed by the server, such that nsc &gt;= sc + 1. The server then returns the constructed time_metadata, time_modify, and nsc values to the requester. The server replaces sc in the delegation record with nsc. To prevent the possibility of time_modify, time_metadata, and change from appearing to go backward (which would happen if the client holding the delegation fails to write its modified data to the server before the delegation is revoked or returned), the server SHOULD update the file&#39;s metadata record with the constructed attribute values. For reasons of reasonable performance, committing the constructed attribute values to stable storage is OPTIONAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 値ccがscと等しくない場合、ファイルは現在最初のクライアントで変更されており、おそらくサーバーで将来変更されます。次に、サーバーは現在の時刻を使用して、time_metadataおよびtime_modifyの属性値を作成します。 nscと呼ばれるscの新しい値は、nsc&gt; = sc + 1のようにサーバーによって計算されます。サーバーは、構築されたtime_metadata、time_modify、およびnscの値をリクエスターに返します。サーバーは、委任レコードのscをnscに置き換えます。 time_modify、time_metadata、およびchangeが後退しているように見える可能性を回避するには（委任が取り消されるか戻される前に、委任を保持しているクライアントが変更されたデータをサーバーに書き込めなかった場合に発生します）、サーバーはファイルの更新を行う必要があります（SHOULD）構築された属性値を持つメタデータレコード。妥当なパフォーマンスの理由から、構築された属性値を安定したストレージにコミットすることはオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
As discussed earlier in this section, the client MAY return the same cc value on subsequent CB_GETATTR calls, even if the file was modified in the client&#39;s cache yet again between successive CB_GETATTR calls. Therefore, the server must assume that the file has been modified yet again, and MUST take care to ensure that the new nsc it constructs and returns is greater than the previous nsc it returned. An example implementation&#39;s delegation record would satisfy this mandate by including a boolean field (let us call it &#34;modified&#34;) that is set to false when the delegation is granted, and an sc value set at the time of grant to the change attribute value. The modified field would be set to true the first time cc != sc, and would stay true until the delegation is returned or revoked. The processing for constructing nsc, time_modify, and time_metadata would use this pseudo code:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このセクションで前述したように、クライアントのキャッシュでファイルが変更されていても、後続のCB_GETATTR呼び出しの間にクライアントが同じcc値を返す場合があります（MAY）。したがって、サーバーはファイルがまだ変更されていると想定する必要があり、サーバーが構築して返す新しいnscが以前に返されたnscよりも大きくなるように注意する必要があります。実装例の委任レコードは、委任が許可されたときにfalseに設定されたブールフィールド（「変更済み」と呼ぶ）と、変更属性値への許可時に設定されたsc値を含めることにより、この義務を満たします。変更されたフィールドは、初めてcc！= scにtrueに設定され、委任が返されるか取り消されるまでtrueのままです。 nsc、time_modify、およびtime_metadataを作成する処理では、次の疑似コードを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      if (!modified) {
          do CB_GETATTR for change and size;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             if (cc != sc)
                 modified = TRUE;
         } else {
                 do CB_GETATTR for size;
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         if (modified) {
             sc = sc + 1;
          time_modify = time_metadata = current_time;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          update sc, time_modify, time_metadata into file&#39;s metadata;
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
return to client (that sent GETATTR) the attributes it requested, but make sure size comes from what CB_GETATTR returned. Do not update the file&#39;s metadata with the client&#39;s modified size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
要求した属性（GETATTRを送信した）をクライアントに返しますが、サイズがCB_GETATTRが返したものであることを確認してください。クライアントの変更後のサイズでファイルのメタデータを更新しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In the case that the file attribute size is different than the server&#39;s current value, the server treats this as a modification regardless of the value of the change attribute retrieved via CB_GETATTR and responds to the second client as in the last step.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイル属性のサイズがサーバーの現在の値と異なる場合、サーバーは、CB_GETATTRを介して取得した変更属性の値に関係なく、これを変更として扱い、最後の手順と同様に2番目のクライアントに応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This methodology resolves issues of clock differences between client and server and other scenarios where the use of CB_GETATTR break down.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この方法論は、クライアントとサーバー間のクロックの違いの問題と、CB_GETATTRの使用が失敗する他のシナリオを解決します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be noted that the server is under no obligation to use CB_GETATTR and therefore the server MAY simply recall the delegation to avoid its use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはCB_GETATTRを使用する義務がないため、サーバーは委任をリコールしてその使用を回避してもよいことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-4-4--Recall-of-Open-Delegation">
9.4.4. Recall of Open Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.4. オープンな委任の想起
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following events necessitate recall of an open delegation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のイベントでは、オープンな委任を呼び戻す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Potentially conflicting OPEN request (or READ/WRITE done with &#34;special&#34; stateid)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 競合する可能性のあるOPEN要求（または「特別な」stateidで行われるREAD / WRITE）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SETATTR issued by another client
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 別のクライアントによって発行されたSETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o REMOVE request for the file
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルのREMOVEリクエスト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RENAME request for the file as either source or target of the RENAME
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RENAMEのソースまたはターゲットとしてのファイルのRENAME要求
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whether a RENAME of a directory in the path leading to the file results in recall of an open delegation depends on the semantics of the server filesystem. If that filesystem denies such RENAMEs when a file is open, the recall must be performed to determine whether the file in question is, in fact, open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルへのパスにあるディレクトリのRENAMEによってオープンな委任が呼び戻されるかどうかは、サーバーのファイルシステムのセマンティクスによって異なります。ファイルが開いているときにそのファイルシステムがそのようなRENAMEを拒否した場合、問題のファイルが実際に開いているかどうかを判断するために再呼び出しを実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to the situations above, the server may choose to recall open delegations at any time if resource constraints make it advisable to do so. Clients should always be prepared for the possibility of recall.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の状況に加えて、リソースの制約によりそうすることが推奨されている場合、サーバーはいつでも開いている委任を呼び出すことを選択できます。クライアントは常にリコールの可能性に備える必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client receives a recall for an open delegation, it needs to update state on the server before returning the delegation. These same updates must be done whenever a client chooses to return a delegation voluntarily. The following items of state need to be dealt with:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、開いている委任の取り消しを受信すると、委任を返す前にサーバーの状態を更新する必要があります。これらの同じ更新は、クライアントが自発的に委任を返すことを選択するたびに実行する必要があります。以下の状態の項目を処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the file associated with the delegation is no longer open and no previous CLOSE operation has been sent to the server, a CLOSE operation must be sent to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 委任に関連付けられているファイルが開かれておらず、以前のCLOSE操作がサーバーに送信されていない場合は、CLOSE操作をサーバーに送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If a file has other open references at the client, then OPEN operations must be sent to the server. The appropriate stateids will be provided by the server for subsequent use by the client since the delegation stateid will not longer be valid. These OPEN requests are done with the claim type of CLAIM_DELEGATE_CUR. This will allow the presentation of the delegation stateid so that the client can establish the appropriate rights to perform the OPEN. (see the section &#34;Operation 18: OPEN&#34; for details.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルにクライアントで他の開いている参照がある場合、OPEN操作をサーバーに送信する必要があります。委任状態IDは有効でなくなるため、サーバーが適切な状態IDを提供し、クライアントが後で使用できるようにします。これらのOPEN要求は、CLAIM_DELEGATE_CURのクレームタイプで実行されます。これにより、クライアントがOPENを実行するための適切な権限を確立できるように、委任状態IDを提示できます。 （詳細については、「操作18：OPEN」のセクションを参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If there are granted file locks, the corresponding LOCK operations need to be performed. This applies to the write open delegation case only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 許可されたファイルロックがある場合、対応するLOCK操作を実行する必要があります。これは、書き込みオープン委任の場合にのみ適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For a write open delegation, if at the time of recall the file is not open for write, all modified data for the file must be flushed to the server. If the delegation had not existed, the client would have done this data flush before the CLOSE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 書き込みオープン委任の場合、リコール時にファイルが書き込み用に開かれていない場合、ファイルのすべての変更されたデータをサーバーにフラッシュする必要があります。委任が存在しなかった場合、クライアントはCLOSE操作の前にこのデータフラッシュを実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For a write open delegation when a file is still open at the time of recall, any modified data for the file needs to be flushed to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 呼び戻し時にファイルがまだ開いている書き込みオープン委任の場合、ファイルの変更されたデータをサーバーにフラッシュする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o With the write open delegation in place, it is possible that the file was truncated during the duration of the delegation. For example, the truncation could have occurred as a result of an OPEN UNCHECKED with a size attribute value of zero. Therefore, if a truncation of the file has occurred and this operation has not been propagated to the server, the truncation must occur before any modified data is written to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 書き込みオープン委任が設定されていると、委任の実行中にファイルが切り捨てられた可能性があります。たとえば、サイズ属性値がゼロのOPEN UNCHECKEDの結果として切り捨てが発生した可能性があります。したがって、ファイルの切り捨てが発生し、この操作がサーバーに伝達されていない場合、変更されたデータがサーバーに書き込まれる前に切り捨てが行われる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of write open delegation, file locking imposes some additional requirements. To precisely maintain the associated invariant, it is required to flush any modified data in any region for which a write lock was released while the write delegation was in effect. However, because the write open delegation implies no other locking by other clients, a simpler implementation is to flush all modified data for the file (as described just above) if any write lock has been released while the write open delegation was in effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
書き込みオープン委任の場合、ファイルロックはいくつかの追加要件を課します。関連する不変条件を正確に維持するには、書き込み委任が有効である間に書き込みロックが解放されたすべての領域で、変更されたデータをフラッシュする必要があります。ただし、書き込みオープン委任は他のクライアントによる他のロックを意味しないため、書き込みオープン委任が有効である間に書き込みロックが解放された場合、より簡単な実装は、ファイルのすべての変更済みデータをフラッシュすることです（上記のとおり）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation need not wait until delegation recall (or deciding to voluntarily return a delegation) to perform any of the above actions, if implementation considerations (e.g., resource availability constraints) make that desirable. Generally, however, the fact that the actual open state of the file may continue to change makes it not worthwhile to send information about opens and closes to the server, except as part of delegation return. Only in the case of closing the open that resulted in obtaining the delegation would clients be likely to do this early, since, in that case, the close once done will not be undone. Regardless of the client&#39;s choices on scheduling these actions, all must be performed before the delegation is returned, including (when applicable) the close that corresponds to the open that resulted in the delegation. These actions can be performed either in previous requests or in previous operations in the same COMPOUND request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装の考慮事項（リソースの可用性の制約など）により望ましい場合は、実装は、委任の取り消し（または委任を自発的に返すことを決定する）まで上記のアクションを実行するまで待つ必要はありません。ただし、一般に、ファイルの実際のオープン状態が変化し続ける可能性があるため、委任の返却の場合を除いて、オープンとクローズに関する情報をサーバーに送信する価値はありません。委任を取得する結果となったオープンを閉じる場合にのみ、クライアントはこれを早期に行う可能性があります。その場合、一度行われたクローズは元に戻されないためです。これらのアクションのスケジュールに関するクライアントの選択に関係なく、委任が発生したオープンに対応するクローズ（該当する場合）を含め、すべてが委任が返される前に実行する必要があります。これらのアクションは、同じCOMPOUNDリクエストの以前のリクエストまたは以前の操作で実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-4-5--Clients-that-Fail-to-Honor-Delegation-Recalls">
9.4.5. Clients that Fail to Honor Delegation Recalls
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.5. 委任取り消しを受け入れられないクライアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client may fail to respond to a recall for various reasons, such as a failure of the callback path from server to the client. The client may be unaware of a failure in the callback path. This lack of awareness could result in the client finding out long after the failure that its delegation has been revoked, and another client has modified the data for which the client had a delegation. This is especially a problem for the client that held a write delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、サーバーからクライアントへのコールバックパスの失敗など、さまざまな理由でリコールに応答できない場合があります。クライアントは、コールバックパスの障害に気付かない可能性があります。この認識の欠如により、クライアントは、委任が取り消されたことが障害のかなり後に判明し、別のクライアントが、クライアントが委任したデータを変更しました。これは、書き込み委任を保持していたクライアントにとって特に問題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server also has a dilemma in that the client that fails to respond to the recall might also be sending other NFS requests, including those that renew the lease before the lease expires. Without returning an error for those lease renewing operations, the server leads the client to believe that the delegation it has is in force.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、サーバーは、呼び戻しに応答しないクライアントが他のNFS要求を送信している可能性があるというジレンマも抱えています。これには、リースの有効期限が切れる前にリースを更新するものも含まれます。これらのリース更新操作でエラーを返さずに、サーバーはクライアントに、委任が有効であると信じ込ませます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This difficulty is solved by the following rules:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この問題は、次のルールによって解決されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the callback path is down, the server MUST NOT revoke the delegation if one of the following occurs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o コールバックパスがダウンしているときに、次のいずれかが発生した場合、サーバーは委任を取り消してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The client has issued a RENEW operation and the server has returned an NFS4ERR_CB_PATH_DOWN error. The server MUST renew the lease for any record locks and share reservations the client has that the server has known about (as opposed to those locks and share reservations the client has established but not yet sent to the server, due to the delegation). The server SHOULD give the client a reasonable time to return its delegations to the server before revoking the client&#39;s delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- クライアントがRENEW操作を発行し、サーバーがNFS4ERR_CB_PATH_DOWNエラーを返しました。サーバーは、サーバーが認識しているレコードロックと共有予約のリースを更新する必要があります（委任により、クライアントが確立したがサーバーにまだ送信されていないロックと共有予約とは対照的です）。サーバーは、クライアントの委任を取り消す前に、その委任をサーバーに返すための適切な時間をクライアントに与える必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The client has not issued a RENEW operation for some period of time after the server attempted to recall the delegation. This period of time MUST NOT be less than the value of the lease_time attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- サーバーが委任を取り消そうとした後、クライアントはしばらくの間RENEW操作を発行しませんでした。この期間は、lease_time属性の値よりも小さくしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the client holds a delegation, it can not rely on operations, except for RENEW, that take a stateid, to renew delegation leases across callback path failures. The client that wants to keep delegations in force across callback path failures must use RENEW to do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントが委任を保持している場合、コールバックパスの障害が発生したときに委任リースを更新するために、stateidを取得するRENEW以外の操作に依存することはできません。コールバックパスの障害が発生しても委任を有効に保ちたいクライアントは、RENEWを使用してこれを行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-4-6--Delegation-Revocation">
9.4.6. Delegation Revocation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.6. 委任の取り消し
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the point a delegation is revoked, if there are associated opens on the client, the applications holding these opens need to be notified. This notification usually occurs by returning errors for READ/WRITE operations or when a close is attempted for the open file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任が取り消された時点で、クライアントに関連付けられたオープンがある場合、これらのオープンを保持しているアプリケーションに通知する必要があります。この通知は通常、READ / WRITE操作のエラーを返すことによって、または開いているファイルに対してクローズが試行されたときに発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If no opens exist for the file at the point the delegation is revoked, then notification of the revocation is unnecessary. However, if there is modified data present at the client for the file, the user of the application should be notified. Unfortunately, it may not be possible to notify the user since active applications may not be present at the client. See the section &#34;Revocation Recovery for Write Open Delegation&#34; for additional details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任が取り消された時点でファイルのオープンが存在しない場合、取り消しの通知は不要です。ただし、ファイルにクライアントで変更されたデータが存在する場合は、アプリケーションのユーザーに通知する必要があります。残念ながら、アクティブなアプリケーションがクライアントに存在しない可能性があるため、ユーザーに通知することができない場合があります。詳細については、「書き込みオープン委任の失効回復」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-5--Data-Caching-and-Revocation">
9.5. Data Caching and Revocation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5. データのキャッシュと失効
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When locks and delegations are revoked, the assumptions upon which successful caching depend are no longer guaranteed. For any locks or share reservations that have been revoked, the corresponding owner needs to be notified. This notification includes applications with a file open that has a corresponding delegation which has been revoked. Cached data associated with the revocation must be removed from the client. In the case of modified data existing in the client&#39;s cache, that data must be removed from the client without it being written to the server. As mentioned, the assumptions made by the client are no longer valid at the point when a lock or delegation has been revoked. For example, another client may have been granted a conflicting lock after the revocation of the lock at the first client. Therefore, the data within the lock range may have been modified by the other client. Obviously, the first client is unable to guarantee to the application what has occurred to the file in the case of revocation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックと委任が取り消されると、キャッシュの成功に依存する前提は保証されなくなります。取り消されたロックまたは共有の予約については、対応する所有者に通知する必要があります。この通知には、取り消された対応する委任があるファイルを開いているアプリケーションが含まれます。失効に関連付けられたキャッシュデータは、クライアントから削除する必要があります。クライアントのキャッシュに存在する変更されたデータの場合、そのデータはサーバーに書き込まれずにクライアントから削除する必要があります。前述のように、クライアントが行った前提は、ロックまたは委任が取り消された時点では無効になります。たとえば、別のクライアントは、最初のクライアントでのロックの取り消し後に、競合するロックを許可されている場合があります。したがって、ロック範囲内のデータが他のクライアントによって変更された可能性があります。明らかに、最初のクライアントは、失効の場合にファイルに何が起こったかをアプリケーションに保証することができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Notification to a lock owner will in many cases consist of simply returning an error on the next and all subsequent READs/WRITEs to the open file or on the close. Where the methods available to a client make such notification impossible because errors for certain operations may not be returned, more drastic action such as signals or process termination may be appropriate. The justification for this is that an invariant for which an application depends on may be violated. Depending on how errors are typically treated for the client operating environment, further levels of notification including logging, console messages, and GUI pop-ups may be appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ロックの所有者への通知は、多くの場合、開いているファイルへの次の、およびその後のすべての読み取り/書き込みまたは閉じるときにエラーを返すだけです。特定の操作のエラーが返されない可能性があるため、クライアントが使用できるメソッドがそのような通知を不可能にする場合、シグナルやプロセスの終了などのより徹底的なアクションが適切な場合があります。これの正当性は、アプリケーションが依存する不変条件に違反する可能性があることです。クライアントのオペレーティング環境でエラーが通常どのように処理されるかに応じて、ロギング、コンソールメッセージ、およびGUIポップアップを含む、さらに高いレベルの通知が適切な場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-5-1--Revocation-Recovery-for-Write-Open-Delegation">
9.5.1. Revocation Recovery for Write Open Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5.1. 書き込みオープン委任の失効回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Revocation recovery for a write open delegation poses the special issue of modified data in the client cache while the file is not open. In this situation, any client which does not flush modified data to the server on each close must ensure that the user receives appropriate notification of the failure as a result of the revocation. Since such situations may require human action to correct problems, notification schemes in which the appropriate user or administrator is notified may be necessary. Logging and console messages are typical examples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
書き込みオープン委任の失効リカバリは、ファイルが開いていないときにクライアントキャッシュに変更されたデータの特別な問題を引き起こします。この状況では、閉じるたびに変更されたデータをサーバーにフラッシュしないクライアントは、失効の結果としてユーザーが失敗の適切な通知を確実に受け取るようにする必要があります。このような状況では、問題を修正するために人間のアクションが必要になる場合があるため、適切なユーザーまたは管理者に通知する通知スキームが必要になる場合があります。ロギングおよびコンソールメッセージは典型的な例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there is modified data on the client, it must not be flushed normally to the server. A client may attempt to provide a copy of the file data as modified during the delegation under a different name in the filesystem name space to ease recovery. Note that when the client can determine that the file has not been modified by any other client, or when the client has a complete cached copy of file in question, such a saved copy of the client&#39;s view of the file may be of particular value for recovery. In other case, recovery using a copy of the file based partially on the client&#39;s cached data and partially on the server copy as modified by other clients, will be anything but straightforward, so clients may avoid saving file contents in these situations or mark the results specially to warn users of possible problems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント上に変更されたデータがある場合、それをサーバーに正常にフラッシュしてはなりません。クライアントは、委任中に変更されたファイルデータのコピーを、ファイルシステム名前空間の別の名前で提供して、回復を容易にすることを試みる場合があります。クライアントがファイルが他のクライアントによって変更されていないことを判別できる場合、またはクライアントに問題のファイルの完全なキャッシュコピーがある場合、ファイルのクライアントのビューのそのような保存されたコピーは、回復。その他の場合、クライアントのキャッシュデータに部分的に基づいたファイルのコピーと、他のクライアントによって変更されたサーバーコピーに部分的に基づいたファイルを使用したリカバリは簡単ではありません。そのため、クライアントはこれらの状況でファイルの内容を保存しないか、結果にマークを付けることができます特に、起こりうる問題をユーザーに警告します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Saving of such modified data in delegation revocation situations may be limited to files of a certain size or might be used only when sufficient disk space is available within the target filesystem. Such saving may also be restricted to situations when the client has sufficient buffering resources to keep the cached copy available until it is properly stored to the target filesystem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任取り消し状況でのこのような変更されたデータの保存は、特定のサイズのファイルに制限されるか、ターゲットファイルシステム内で十分なディスク領域が利用可能な場合にのみ使用される場合があります。このような保存は、ターゲットファイルシステムに適切に保存されるまで、キャッシュされたコピーを利用可能な状態に保つのに十分なバッファリングリソースがクライアントにある場合にも制限されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-6--Attribute-Caching">
9.6. Attribute Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6. 属性キャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The attributes discussed in this section do not include named attributes. Individual named attributes are analogous to files and caching of the data for these needs to be handled just as data caching is for ordinary files. Similarly, LOOKUP results from an OPENATTR directory are to be cached on the same basis as any other pathnames and similarly for directory contents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このセクションで説明する属性には、名前付き属性は含まれていません。個々の名前付き属性はファイルに類似しており、これらのデータのキャッシュは、通常のファイルのデータキャッシュと同じように処理する必要があります。同様に、OPENATTRディレクトリからのLOOKUPの結果は、他のパス名と同じ基準で、ディレクトリの内容についても同様にキャッシュされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients may cache file attributes obtained from the server and use them to avoid subsequent GETATTR requests. Such caching is write through in that modification to file attributes is always done by means of requests to the server and should not be done locally and cached. The exception to this are modifications to attributes that are intimately connected with data caching. Therefore, extending a file by writing data to the local data cache is reflected immediately in the size as seen on the client without this change being immediately reflected on the server. Normally such changes are not propagated directly to the server but when the modified data is flushed to the server, analogous attribute changes are made on the server. When open delegation is in effect, the modified attributes may be returned to the server in the response to a CB_RECALL call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはサーバーから取得したファイル属性をキャッシュし、それを使用して後続のGETATTR要求を回避できます。このようなキャッシングは、ファイル属性の変更が常にサーバーへの要求によって行われ、ローカルで行われてキャッシュされるべきではないという点で、ライトスルーです。これの例外は、データキャッシングと密接に関連している属性の変更です。したがって、ローカルデータキャッシュにデータを書き込んでファイルを拡張すると、この変更がサーバーにすぐに反映されることなく、クライアントに表示されるサイズにすぐに反映されます。通常、このような変更はサーバーに直接伝達されませんが、変更されたデータがサーバーにフラッシュされると、サーバーで同様の属性変更が行われます。オープン委任が有効な場合、CB_RECALL呼び出しへの応答で、変更された属性がサーバーに返されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The result of local caching of attributes is that the attribute caches maintained on individual clients will not be coherent. Changes made in one order on the server may be seen in a different order on one client and in a third order on a different client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性のローカルキャッシングの結果、個々のクライアントで維持される属性キャッシュは一貫しなくなります。サーバーで1つの順序で行われた変更は、1つのクライアントでは別の順序で、別のクライアントでは3番目の順序で表示される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The typical filesystem application programming interfaces do not provide means to atomically modify or interrogate attributes for multiple files at the same time. The following rules provide an environment where the potential incoherences mentioned above can be reasonably managed. These rules are derived from the practice of previous NFS protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
典型的なファイルシステムアプリケーションプログラミングインターフェイスは、同時に複数のファイルの属性を自動的に変更または照会する手段を提供しません。次のルールは、上記の潜在的な矛盾を合理的に管理できる環境を提供します。これらのルールは、以前のNFSプロトコルの慣習から派生しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o All attributes for a given file (per-fsid attributes excepted) are cached as a unit at the client so that no non-serializability can arise within the context of a single file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 特定のファイルのすべての属性（fsidごとの属性を除く）は、単一のファイルのコンテキスト内で非直列化が発生しないように、クライアントでユニットとしてキャッシュされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An upper time boundary is maintained on how long a client cache entry can be kept without being refreshed from the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントのキャッシュエントリをサーバーから更新せずに保持できる時間の上限は維持されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When operations are performed that change attributes at the server, the updated attribute set is requested as part of the containing RPC. This includes directory operations that update attributes indirectly. This is accomplished by following the modifying operation with a GETATTR operation and then using the results of the GETATTR to update the client&#39;s cached attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーで属性を変更する操作が実行されると、含まれているRPCの一部として更新された属性セットが要求されます。これには、属性を間接的に更新するディレクトリ操作が含まれます。これは、GETATTR操作で変更操作を実行し、GETATTRの結果を使用してクライアントのキャッシュされた属性を更新することで実現されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that if the full set of attributes to be cached is requested by READDIR, the results can be cached by the client on the same basis as attributes obtained via GETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キャッシュする属性の完全なセットがREADDIRによって要求された場合、GETATTRを介して取得した属性と同じ基準で、クライアントが結果をキャッシュできることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client may validate its cached version of attributes for a file by fetching just both the change and time_access attributes and assuming that if the change attribute has the same value as it did when the attributes were cached, then no attributes other than time_access have changed. The reason why time_access is also fetched is because many servers operate in environments where the operation that updates change does not update time_access. For example, POSIX file semantics do not update access time when a file is modified by the write system call. Therefore, the client that wants a current time_access value should fetch it with change during the attribute cache validation processing and update its cached time_access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、change属性とtime_access属性の両方をフェッチし、属性のキャッシュ時と同じ値がchange属性にある場合は、time_access以外の属性は変更されていないと想定して、ファイルの属性のキャッシュバージョンを検証します。 time_accessもフェッチされるのは、更新を変更する操作ではtime_accessが更新されない環境で多くのサーバーが動作するためです。たとえば、POSIXファイルセマンティクスは、writeシステムコールによってファイルが変更された場合、アクセス時間を更新しません。したがって、現在のtime_access値を必要とするクライアントは、属性キャッシュの検証処理中に変更を加えてフェッチし、キャッシュされたtime_accessを更新する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client may maintain a cache of modified attributes for those attributes intimately connected with data of modified regular files (size, time_modify, and change). Other than those three attributes, the client MUST NOT maintain a cache of modified attributes. Instead, attribute changes are immediately sent to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、変更された通常のファイル（サイズ、time_modify、および変更）のデータと密接に関連している属性の変更された属性のキャッシュを維持できます。これらの3つの属性以外では、クライアントは変更された属性のキャッシュを維持してはなりません（MUST NOT）。代わりに、属性の変更はすぐにサーバーに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some operating environments, the equivalent to time_access is expected to be implicitly updated by each read of the content of the file object. If an NFS client is caching the content of a file object, whether it is a regular file, directory, or symbolic link, the client SHOULD NOT update the time_access attribute (via SETATTR or a small READ or READDIR request) on the server with each read that is satisfied from cache. The reason is that this can defeat the performance benefits of caching content, especially since an explicit SETATTR of time_access may alter the change attribute on the server. If the change attribute changes, clients that are caching the content will think the content has changed, and will re-read unmodified data from the server. Nor is the client encouraged to maintain a modified version of time_access in its cache, since this would mean that the client will either eventually have to write the access time to the server with bad performance effects, or it would never update the server&#39;s time_access, thereby resulting in a situation where an application that caches access time between a close and open of the same file observes the access time oscillating between the past and present. The time_access attribute always means the time of last access to a file by a read that was satisfied by the server. This way clients will tend to see only time_access changes that go forward in time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のオペレーティング環境では、time_accessに相当するものが、ファイルオブジェクトのコンテンツを読み取るたびに暗黙的に更新されることが期待されます。 NFSクライアントがファイルオブジェクトのコンテンツをキャッシュしている場合、それが通常のファイル、ディレクトリ、シンボリックリンクのいずれであっても、クライアントは、サーバーのtime_access属性を（SETATTRまたは小さなREADまたはREADDIRリクエストを介して）更新しないでください。キャッシュから満たされる読み取り。その理由は、特にtime_accessの明示的なSETATTRがサーバーの変更属性を変更する可能性があるため、コンテンツをキャッシュすることによるパフォーマンス上の利点が損なわれる可能性があるためです。変更属性が変更されると、コンテンツをキャッシュしているクライアントは、コンテンツが変更されたと見なし、変更されていないデータをサーバーから再読み取りします。また、クライアントが変更されたバージョンのtime_accessをキャッシュに保持することも推奨されません。これは、クライアントが最終的にパフォーマンスの低下を伴うサーバーへのアクセス時間を書き込まなければならないか、サーバーのtime_accessを更新しないことを意味します。その結果、同じファイルのクローズとオープンの間のアクセス時間をキャッシュするアプリケーションが、過去と現在の間で変動するアクセス時間を観察する状況になります。 time_access属性は常に、サーバーによって満たされた読み取りによってファイルに最後にアクセスした時刻を意味します。このようにして、クライアントは時間とともに進むtime_accessの変更のみを確認する傾向があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-7--Data-and-Metadata-Caching-and-Memory-Mapped-Files">
9.7. Data and Metadata Caching and Memory Mapped Files
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.7. データとメタデータのキャッシュとメモリマップファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Some operating environments include the capability for an application to map a file&#39;s content into the application&#39;s address space. Each time the application accesses a memory location that corresponds to a block that has not been loaded into the address space, a page fault occurs and the file is read (or if the block does not exist in the file, the block is allocated and then instantiated in the application&#39;s address space).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
一部のオペレーティング環境には、アプリケーションがファイルのコンテンツをアプリケーションのアドレス空間にマップする機能が含まれています。アプリケーションがアドレス空間にロードされていないブロックに対応するメモリロケーションにアクセスするたびに、ページフォールトが発生し、ファイルが読み取られます（または、ブロックがファイルに存在しない場合は、ブロックが割り当てられてからアプリケーションのアドレス空間でインスタンス化されます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As long as each memory mapped access to the file requires a page fault, the relevant attributes of the file that are used to detect access and modification (time_access, time_metadata, time_modify, and change) will be updated. However, in many operating environments, when page faults are not required these attributes will not be updated on reads or updates to the file via memory access (regardless whether the file is local file or is being access remotely). A client or server MAY fail to update attributes of a file that is being accessed via memory mapped I/O. This has several implications:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルへの各メモリマップアクセスにページフォールトが必要である限り、アクセスと変更の検出に使用されるファイルの関連属性（time_access、time_metadata、time_modify、およびchange）が更新されます。ただし、多くの動作環境では、ページフォールトが必要ない場合、これらの属性はメモリアクセスによるファイルの読み取りまたは更新時に更新されません（ファイルがローカルファイルであるかリモートアクセスであるかに関係なく）。クライアントまたはサーバーは、メモリマップI / Oを介してアクセスされているファイルの属性の更新に失敗する場合があります。これにはいくつかの意味があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If there is an application on the server that has memory mapped a file that a client is also accessing, the client may not be able to get a consistent value of the change attribute to determine whether its cache is stale or not. A server that knows that the file is memory mapped could always pessimistically return updated values for change so as to force the application to always get the most up to date data and metadata for the file. However, due to the negative performance implications of this, such behavior is OPTIONAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントがアクセスしているファイルをメモリマップしたサーバー上のアプリケーションがある場合、クライアントは変更属性の一貫した値を取得できず、キャッシュが古いかどうかを判断できない場合があります。ファイルがメモリマップされていることを認識しているサーバーは、常に変更に対して更新された値を悲観的に返し、アプリケーションが常にファイルの最新のデータとメタデータを取得するように強制できます。ただし、これはパフォーマンスに悪影響を及ぼすため、このような動作はオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the memory mapped file is not being modified on the server, and instead is just being read by an application via the memory mapped interface, the client will not see an updated time_access attribute. However, in many operating environments, neither will any process running on the server. Thus NFS clients are at no disadvantage with respect to local processes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o メモリマップファイルがサーバー上で変更されておらず、メモリマップインターフェイスを介してアプリケーションによって読み取られているだけの場合、クライアントには更新されたtime_access属性が表示されません。ただし、多くのオペレーティング環境では、サーバーで実行されるプロセスもありません。したがって、NFSクライアントは、ローカルプロセスに関して不利になることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If there is another client that is memory mapping the file, and if that client is holding a write delegation, the same set of issues as discussed in the previous two bullet items apply. So, when a server does a CB_GETATTR to a file that the client has modified in its cache, the response from CB_GETATTR will not necessarily be accurate. As discussed earlier, the client&#39;s obligation is to report that the file has been modified since the delegation was granted, not whether it has been modified again between successive CB_GETATTR calls, and the server MUST assume that any file the client has modified in cache has been modified again between successive CB_GETATTR calls. Depending on the nature of the client&#39;s memory management system, this weak obligation may not be possible. A client MAY return stale information in CB_GETATTR whenever the file is memory mapped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルをメモリマッピングしている別のクライアントがあり、そのクライアントが書き込み委任を保持している場合、前の2つの箇条書き項目で説明したのと同じ一連の問題が適用されます。したがって、クライアントがキャッシュで変更したファイルに対してサーバーがCB_GETATTRを実行する場合、CB_GETATTRからの応答は必ずしも正確ではありません。前述のように、クライアントの義務は、委任が許可されてからファイルが変更されたことを報告することであり、連続するCB_GETATTR呼び出しの間に再度変更されたかどうかではなく、サーバーは、クライアントがキャッシュで変更したファイルが連続するCB_GETATTR呼び出しの間で再度変更されました。クライアントのメモリ管理システムの性質によっては、この弱い義務が不可能な場合があります。クライアントは、ファイルがメモリマップされている場合は常に、古い情報をCB_GETATTRに返す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The mixture of memory mapping and file locking on the same file is problematic. Consider the following scenario, where the page size on each client is 8192 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 同じファイルでのメモリマッピングとファイルロックの混在は問題があります。各クライアントのページサイズが8192バイトである次のシナリオを考えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Client A memory maps first page (8192 bytes) of file X
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- クライアントAのメモリは、ファイルXの最初のページ（8192バイト）をマップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Client B memory maps first page (8192 bytes) of file X
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- クライアントBのメモリは、ファイルXの最初のページ（8192バイト）をマップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Client A write locks first 4096 bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- クライアントAの書き込みが最初の4096バイトをロックする
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Client B write locks second 4096 bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- クライアントBの書き込みロック、2番目の4096バイト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Client A, via a STORE instruction modifies part of its locked region.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- クライアントAは、STORE命令を使用して、ロックされた領域の一部を変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Simultaneous to client A, client B issues a STORE on part of its locked region.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- クライアントAと同時に、クライアントBはロックされた領域の一部にSTOREを発行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here the challenge is for each client to resynchronize to get a correct view of the first page. In many operating environments, the virtual memory management systems on each client only know a page is modified, not that a subset of the page corresponding to the respective lock regions has been modified. So it is not possible for each client to do the right thing, which is to only write to the server that portion of the page that is locked. For example, if client A simply writes out the page, and then client B writes out the page, client A&#39;s data is lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここでの課題は、各クライアントが再同期して最初のページの正しいビューを取得することです。多くのオペレーティング環境では、各クライアントの仮想メモリ管理システムはページが変更されたことだけを認識し、それぞれのロック領域に対応するページのサブセットが変更されたことを認識しません。そのため、各クライアントが正しいことを行うことはできません。つまり、ページのロックされている部分のみをサーバーに書き込みます。たとえば、クライアントAが単にページを書き込んだ後、クライアントBがそのページを書き込んだ場合、クライアントAのデータは失われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Moreover, if mandatory locking is enabled on the file, then we have a different problem. When clients A and B issue the STORE instructions, the resulting page faults require a record lock on the entire page. Each client then tries to extend their locked range to the entire page, which results in a deadlock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、ファイルで強制ロックが有効になっている場合は、別の問題があります。クライアントAとBがSTORE命令を発行すると、結果として生じるページフォールトはページ全体のレコードロックを必要とします。次に、各クライアントはロックされた範囲をページ全体に拡張しようとしますが、デッドロックが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Communicating the NFS4ERR_DEADLOCK error to a STORE instruction is difficult at best.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DEADLOCKエラーをSTORE命令に伝達することは、せいぜい困難です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client is locking the entire memory mapped file, there is no problem with advisory or mandatory record locking, at least until the client unlocks a region in the middle of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがメモリマップファイル全体をロックしている場合、少なくともクライアントがファイルの中央にある領域のロックを解除するまで、アドバイザリまたは必須のレコードロックに問題はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given the above issues the following are permitted:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の問題を考慮すると、次のことが許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Clients and servers MAY deny memory mapping a file they know there are record locks for.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- クライアントとサーバーは、レコードロックがあることがわかっているファイルのメモリマッピングを拒否する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Clients and servers MAY deny a record lock on a file they know is memory mapped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- クライアントとサーバーは、メモリがマップされていることがわかっているファイルのレコードロックを拒否する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- A client MAY deny memory mapping a file that it knows requires mandatory locking for I/O. If mandatory locking is enabled after the file is opened and mapped, the client MAY deny the application further access to its mapped file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- クライアントは、I / Oの必須ロックが必要であることがわかっているファイルのメモリマッピングを拒否する場合があります。ファイルが開かれてマップされた後に強制ロックが有効になっている場合、クライアントは、アプリケーションがマップされたファイルにそれ以上アクセスすることを拒否できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-8--Name-Caching">
9.8. Name Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.8. 名前のキャッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The results of LOOKUP and READDIR operations may be cached to avoid the cost of subsequent LOOKUP operations. Just as in the case of attribute caching, inconsistencies may arise among the various client caches. To mitigate the effects of these inconsistencies and given the context of typical filesystem APIs, an upper time boundary is maintained on how long a client name cache entry can be kept without verifying that the entry has not been made invalid by a directory change operation performed by another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOOKUPおよびREADDIR操作の結果は、後続のLOOKUP操作のコストを回避するためにキャッシュされる場合があります。属性キャッシュの場合と同様に、さまざまなクライアントキャッシュ間で不整合が発生する可能性があります。これらの不整合の影響を軽減し、一般的なファイルシステムAPIのコンテキストを考慮して、クライアント名キャッシュエントリを保持できる期間の上限が維持されます。別のクライアント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client is not making changes to a directory for which there exist name cache entries, the client needs to periodically fetch attributes for that directory to ensure that it is not being modified. After determining that no modification has occurred, the expiration time for the associated name cache entries may be updated to be the current time plus the name cache staleness bound.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが名前キャッシュエントリが存在するディレクトリに変更を加えていない場合、クライアントはそのディレクトリの属性を定期的にフェッチして、変更されていないことを確認する必要があります。変更が発生していないと判断した後、関連付けられた名前キャッシュエントリの有効期限は、現在の時間に名前キャッシュの古さの限界を加えたものに更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client is making changes to a given directory, it needs to determine whether there have been changes made to the directory by other clients. It does this by using the change attribute as reported before and after the directory operation in the associated change_info4 value returned for the operation. The server is able to communicate to the client whether the change_info4 data is provided atomically with respect to the directory operation. If the change values are provided atomically, the client is then able to compare the pre-operation change value with the change value in the client&#39;s name cache. If the comparison indicates that the directory was updated by another client, the name cache associated with the modified directory is purged from the client. If the comparison indicates no modification, the name cache can be updated on the client to reflect the directory operation and the associated timeout extended. The post-operation change value needs to be saved as the basis for future change_info4 comparisons.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが特定のディレクトリに変更を加えているとき、他のクライアントによってディレクトリに加えられた変更があるかどうかを判断する必要があります。これは、操作に対して返された関連するchange_info4値のディレクトリ操作の前後に報告されているように、change属性を使用して行われます。サーバーは、change_info4データがディレクトリ操作に関してアトミックに提供されているかどうかをクライアントと通信できます。変更値がアトミックに提供される場合、クライアントは操作前の変更値をクライアントの名前キャッシュ内の変更値と比較できます。比較により、ディレクトリが別のクライアントによって更新されたことが示された場合、変更されたディレクトリに関連付けられた名前キャッシュはクライアントから削除されます。比較によって変更がないことが示された場合、クライアントで名前キャッシュを更新して、ディレクトリ操作と関連するタイムアウトを延長することができます。操作後の変更値は、将来のchange_info4比較の基礎として保存する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 As demonstrated by the scenario above, name caching requires that the client revalidate name cache data by inspecting the change attribute of a directory at the point when the name cache item was cached. This requires that the server update the change attribute for directories when the contents of the corresponding directory is modified. For a client to use the change_info4 information appropriately and correctly, the server must report the pre and post operation change attribute values atomically. When the server is unable to report the before and after values atomically with respect to the directory operation, the server must indicate that fact in the change_info4 return value. When the information is not atomically reported, the client should not assume that other clients have not changed the directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
上記のシナリオで示されているように、名前のキャッシュでは、名前のキャッシュアイテムがキャッシュされた時点でディレクトリの変更属性を検査して、名前のキャッシュデータをクライアントが再検証する必要があります。これには、対応するディレクトリの内容が変更されたときに、サーバーがディレクトリの変更属性を更新する必要があります。クライアントがchange_info4情報を適切かつ正しく使用するには、サーバーは操作の前後の変更属性値をアトミックに報告する必要があります。サーバーがディレクトリ操作に関して前の値と後の値をアトミックに報告できない場合、サーバーはその事実をchange_info4の戻り値に示す必要があります。情報がアトミックに報告されない場合、クライアントは、他のクライアントがディレクトリを変更していないと想定しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-9--Directory-Caching">
9.9. Directory Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.9. ディレクトリキャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The results of READDIR operations may be used to avoid subsequent READDIR operations. Just as in the cases of attribute and name caching, inconsistencies may arise among the various client caches. To mitigate the effects of these inconsistencies, and given the context of typical filesystem APIs, the following rules should be followed:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READDIR操作の結果は、後続のREADDIR操作を回避するために使用できます。属性と名前のキャッシュの場合と同様に、さまざまなクライアントキャッシュ間で不整合が発生する可能性があります。これらの不整合の影響を軽減するために、そして典型的なファイルシステムAPIのコンテキストを考えると、次のルールに従う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Cached READDIR information for a directory which is not obtained in a single READDIR operation must always be a consistent snapshot of directory contents. This is determined by using a GETATTR before the first READDIR and after the last of READDIR that contributes to the cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 単一のREADDIR操作で取得されないディレクトリのキャッシュされたREADDIR情報は、常にディレクトリの内容の一貫したスナップショットである必要があります。これは、最初のREADDIRの前と、キャッシュに寄与する最後のREADDIRの後にGETATTRを使用して決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An upper time boundary is maintained to indicate the length of time a directory cache entry is considered valid before the client must revalidate the cached information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントがキャッシュされた情報を再検証する必要がある前に、ディレクトリキャッシュエントリが有効と見なされる時間の長さを示すために、時間の上限が維持されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The revalidation technique parallels that discussed in the case of name caching. When the client is not changing the directory in question, checking the change attribute of the directory with GETATTR is adequate. The lifetime of the cache entry can be extended at these checkpoints. When a client is modifying the directory, the client needs to use the change_info4 data to determine whether there are other clients modifying the directory. If it is determined that no other client modifications are occurring, the client may update its directory cache to reflect its own changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再検証手法は、名前のキャッシングの場合で説明した手法と類似しています。クライアントが問題のディレクトリを変更していない場合は、GETATTRを使用してディレクトリの変更属性を確認するのが適切です。キャッシュエントリの有効期間は、これらのチェックポイントで延長できます。クライアントがディレクトリを変更しているとき、クライアントはchange_info4データを使用して、ディレクトリを変更している他のクライアントがあるかどうかを判断する必要があります。他のクライアントの変更が発生していないと判断された場合、クライアントは自身の変更を反映するためにディレクトリキャッシュを更新できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As demonstrated previously, directory caching requires that the client revalidate directory cache data by inspecting the change attribute of a directory at the point when the directory was cached. This requires that the server update the change attribute for directories when the contents of the corresponding directory is modified. For a client to use the change_info4 information appropriately and correctly, the server must report the pre and post operation change attribute values atomically. When the server is unable to report the before and after values atomically with respect to the directory operation, the server must indicate that fact in the change_info4 return value. When the information is not atomically reported, the client should not assume that other clients have not changed the directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前に示したように、ディレクトリキャッシュでは、クライアントがディレクトリがキャッシュされた時点でディレクトリの変更属性を検査して、ディレクトリキャッシュデータを再検証する必要があります。これには、対応するディレクトリの内容が変更されたときに、サーバーがディレクトリの変更属性を更新する必要があります。クライアントがchange_info4情報を適切かつ正しく使用するには、サーバーは操作の前後の変更属性値をアトミックに報告する必要があります。サーバーがディレクトリ操作に関して前の値と後の値をアトミックに報告できない場合、サーバーはその事実をchange_info4の戻り値に示す必要があります。情報がアトミックに報告されない場合、クライアントは、他のクライアントがディレクトリを変更していないと想定しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10--Minor-Versioning">
10. Minor Versioning
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. マイナーバージョン管理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To address the requirement of an NFS protocol that can evolve as the need arises, the NFS version 4 protocol contains the rules and framework to allow for future minor changes or versioning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必要に応じて進化する可能性があるNFSプロトコルの要件に対処するために、NFSバージョン4プロトコルには、将来のマイナーな変更やバージョン管理を可能にするルールとフレームワークが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The base assumption with respect to minor versioning is that any future accepted minor version must follow the IETF process and be documented in a standards track RFC. Therefore, each minor version number will correspond to an RFC. Minor version zero of the NFS version 4 protocol is represented by this RFC. The COMPOUND procedure will support the encoding of the minor version being requested by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイナーバージョン管理に関する基本的な前提は、将来受け入れられるすべてのマイナーバージョンがIETFプロセスに従い、標準トラックRFCに文書化されている必要があることです。したがって、各マイナーバージョン番号はRFCに対応します。 NFSバージョン4プロトコルのマイナーバージョン0は、このRFCで表されています。 COMPOUNDプロシージャは、クライアントによって要求されているマイナーバージョンのエンコーディングをサポートします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following items represent the basic rules for the development of minor versions. Note that a future minor version may decide to modify or add to the following rules as part of the minor version definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の項目は、マイナーバージョンの開発に関する基本的な規則を表しています。将来のマイナーバージョンでは、マイナーバージョン定義の一部として、次のルールを変更または追加する可能性があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
1. Procedures are not added or deleted
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
1. プロシージャは追加または削除されません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
To maintain the general RPC model, NFS version 4 minor versions will not add to or delete procedures from the NFS program.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
一般的なRPCモデルを維持するために、NFSバージョン4のマイナーバージョンは、NFSプログラムにプロシージャを追加または削除しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
2. Minor versions may add operations to the COMPOUND and CB_COMPOUND procedures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
2. マイナーバージョンでは、COMPOUNDおよびCB_COMPOUNDプロシージャに操作が追加される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
The addition of operations to the COMPOUND and CB_COMPOUND procedures does not affect the RPC model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
COMPOUNDおよびCB_COMPOUNDプロシージャに操作を追加しても、RPCモデルには影響しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
2.1 Minor versions may append attributes to GETATTR4args, bitmap4, and GETATTR4res.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
2.1 マイナーバージョンは、GETATTR4args、bitmap4、およびGETATTR4resに属性を追加する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
This allows for the expansion of the attribute model to allow for future growth or adaptation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
これにより、属性モデルを拡張して、将来の成長または適応を可能にすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
2.2 Minor version X must append any new attributes after the last documented attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
2.2 マイナーバージョンXでは、ドキュメント化された最後の属性の後に新しい属性を追加する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Since attribute results are specified as an opaque array of per-attribute XDR encoded results, the complexity of adding new attributes in the midst of the current definitions will be too burdensome.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
属性の結果は、属性ごとのXDRエンコードされた結果の不透明な配列として指定されるため、現在の定義の最中に新しい属性を追加することの複雑さは、非常に負担になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
3. Minor versions must not modify the structure of an existing operation&#39;s arguments or results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
3. マイナーバージョンは、既存の操作の引数または結果の構造を変更してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Again the complexity of handling multiple structure definitions for a single operation is too burdensome. New operations should be added instead of modifying existing structures for a minor version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
繰り返しになりますが、単一の操作で複数の構造定義を処理することの複雑さは、負担が大きすぎます。マイナーバージョンの既存の構造を変更する代わりに、新しい操作を追加する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
This rule does not preclude the following adaptations in a minor version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
このルールは、マイナーバージョンでの以下の適応を排除するものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
o adding bits to flag fields such as new attributes to GETATTR&#39;s bitmap4 data type
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
o GETATTRのbitmap4データ型への新しい属性などのフラグフィールドへのビットの追加
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
o adding bits to existing attributes like ACLs that have flag words
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
o フラグワードを持つACLなどの既存の属性にビットを追加する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
o extending enumerated types (including NFS4ERR_*) with new values
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
o 列挙型（NFS4ERR_ *を含む）を新しい値で拡張する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
4. Minor versions may not modify the structure of existing attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
4. マイナーバージョンは、既存の属性の構造を変更しない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
5. Minor versions may not delete operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
5. マイナーバージョンは操作を削除しない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
This prevents the potential reuse of a particular operation &#34;slot&#34; in a future minor version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
これにより、将来のマイナーバージョンで特定の操作「スロット」が再利用される可能性がなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
6. Minor versions may not delete attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
6. マイナーバージョンは属性を削除しない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
7. Minor versions may not delete flag bits or enumeration values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
7. マイナーバージョンは、フラグビットまたは列挙値を削除しない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
8. Minor versions may declare an operation as mandatory to NOT implement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
8. マイナーバージョンでは、操作を実装しないように必須として宣言する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Specifying an operation as &#34;mandatory to not implement&#34; is equivalent to obsoleting an operation. For the client, it means that the operation should not be sent to the server. For the server, an NFS error can be returned as opposed to &#34;dropping&#34; the request as an XDR decode error. This approach allows for the obsolescence of an operation while maintaining its structure so that a future minor version can reintroduce the operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
操作を「実装しないことを強制する」として指定することは、操作を廃止することと同じです。クライアントの場合は、操作をサーバーに送信しないことを意味します。サーバーの場合、XDRデコードエラーとして要求を「ドロップ」するのではなく、NFSエラーを返すことができます。このアプローチにより、構造を維持しながら操作を廃止できるため、将来のマイナーバージョンで操作を再導入できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
8.1 Minor versions may declare attributes mandatory to NOT implement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
8.1 マイナーバージョンでは、実装しないように必須の属性を宣言する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
8.2 Minor versions may declare flag bits or enumeration values as mandatory to NOT implement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
8.2 マイナーバージョンでは、フラグビットまたは列挙値を実装しないように必須として宣言する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
9. Minor versions may downgrade features from mandatory to recommended, or recommended to optional.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
9. マイナーバージョンは、機能を必須から推奨に、または推奨からオプションにダウングレードする場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
10. Minor versions may upgrade features from optional to recommended or recommended to mandatory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
10. マイナーバージョンでは、機能をオプションから推奨、または推奨から必須にアップグレードできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
11. A client and server that support minor version X must support minor versions 0 (zero) through X-1 as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
11. マイナーバージョンXをサポートするクライアントおよびサーバーは、マイナーバージョン0（ゼロ）からX-1までもサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
12. No new features may be introduced as mandatory in a minor version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
12. マイナーバージョンでは、必須として新機能を導入することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
This rule allows for the introduction of new functionality and forces the use of implementation experience before designating a feature as mandatory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
このルールにより、新しい機能の導入が可能になり、機能を必須として指定する前に実装エクスペリエンスを強制的に使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
13. A client MUST NOT attempt to use a stateid, filehandle, or similar returned object from the COMPOUND procedure with minor version X for another COMPOUND procedure with minor version Y, where X != Y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
13. クライアントは、マイナーバージョンXのCOMPOUNDプロシージャから返された状態ID、ファイルハンドル、または類似のオブジェクトを、マイナーバージョンYの別のCOMPOUNDプロシージャ（X！= Y）に使用してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11--Internationalization">
11. Internationalization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. 国際化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The primary issue in which NFS version 4 needs to deal with internationalization, or I18N, is with respect to file names and other strings as used within the protocol. The choice of string representation must allow reasonable name/string access to clients which use various languages. The UTF-8 encoding of the UCS as defined by [ISO10646] allows for this type of access and follows the policy described in &#34;IETF Policy on Character Sets and Languages&#34;, [RFC2277].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4が国際化（I18N）に対処する必要がある主な問題は、プロトコル内で使用されるファイル名およびその他の文字列に関するものです。文字列表現の選択では、さまざまな言語を使用するクライアントに適切な名前/文字列アクセスを許可する必要があります。 [ISO10646]で定義されているUCSのUTF-8エンコーディングは、このタイプのアクセスを許可し、「文字セットと言語に関するIETFポリシー」、[RFC2277]で説明されているポリシーに従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3454], otherwise know as &#34;stringprep&#34;, documents a framework for using Unicode/UTF-8 in networking protocols, so as &#34;to increase the likelihood that string input and string comparison work in ways that make sense for typical users throughout the world.&#34; A protocol must define a profile of stringprep &#34;in order to fully specify the processing options.&#34; The remainder of this Internationalization section defines the NFS version 4 stringprep profiles. Much of terminology used for the remainder of this section comes from stringprep.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3454]、別名「stringprep」は、ネットワークプロトコルでUnicode / UTF-8を使用するためのフレームワークを文書化したもので、「世界中の一般的なユーザーにとって意味のある方法で文字列入力と文字列比較が機能する可能性を高めるため」 」プロトコルは、「処理オプションを完全に指定するために」stringprepのプロファイルを定義する必要があります。この国際化セクションの残りの部分では、NFSバージョン4のstringprepプロファイルを定義します。このセクションの残りの部分で使用される用語の多くは、stringprepに由来しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are three UTF-8 string types defined for NFS version 4: utf8str_cs, utf8str_cis, and utf8str_mixed. Separate profiles are defined for each. Each profile defines the following, as required by stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4には、utf8str_cs、utf8str_cis、およびutf8str_mixedの3つのUTF-8文字列タイプが定義されています。それぞれに個別のプロファイルが定義されています。 stringprepでの必要に応じて、各プロファイルは以下を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o The intended applicability of the profile o The character repertoire that is the input and output to stringprep (which is Unicode 3.2 for referenced version of stringprep)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
oプロファイルの意図された適用性o stringprepへの入力および出力である文字レパートリー（stringprepの参照バージョンのUnicode 3.2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The mapping tables from stringprep used (as described in section 3 of stringprep)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 使用されたstringprepのマッピングテーブル（stringprepのセクション3で説明）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Any additional mapping tables specific to the profile
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o プロファイル固有の追加のマッピングテーブル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Unicode normalization used, if any (as described in section 4 of stringprep)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 使用されているUnicode正規化（ある場合）（stringprepのセクション4で説明）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The tables from stringprep listing of characters that are prohibited as output (as described in section 5 of stringprep)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 出力として禁止されている文字のstringprepリストからのテーブル（stringprepのセクション5で説明）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The bidirectional string testing used, if any (as described in section 6 of stringprep)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 使用される双方向文字列テスト（ある場合）（stringprepのセクション6で説明）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Any additional characters that are prohibited as output specific to the profile
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o プロファイル固有の出力として禁止されている追加の文字
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stringprep discusses Unicode characters, whereas NFS version 4 renders UTF-8 characters. Since there is a one to one mapping from UTF-8 to Unicode, where ever the remainder of this document refers to to Unicode, the reader should assume UTF-8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
StringprepはUnicode文字について説明しますが、NFSバージョン4はUTF-8文字をレンダリングします。 UTF-8からUnicodeへの1対1のマッピングがあるため、このドキュメントの残りの部分ではUnicodeを参照しているため、読者はUTF-8を想定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Much of the text for the profiles comes from [RFC3454].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロファイルのテキストの多くは[RFC3454]からのものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1--Stringprep-profile-for-the-utf8strcs-type">
11.1. Stringprep profile for the utf8str_cs type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. utf8str_csタイプのStringprepプロファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every use of the utf8str_cs type definition in the NFS version 4 protocol specification follows the profile named nfs4_cs_prep.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコル仕様でのutf8str_csタイプ定義のすべての使用は、nfs4_cs_prepという名前のプロファイルに従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1-1--Intended-applicability-of-the-nfs4csprep-profile">
11.1.1. Intended applicability of the nfs4_cs_prep profile
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.1. nfs4_cs_prepプロファイルの意図された適用性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The utf8str_cs type is a case sensitive string of UTF-8 characters. Its primary use in NFS Version 4 is for naming components and pathnames. Components and pathnames are stored on the server&#39;s filesystem. Two valid distinct UTF-8 strings might be the same after processing via the utf8str_cs profile. If the strings are two names inside a directory, the NFS version 4 server will need to either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_csタイプは、大文字と小文字が区別されるUTF-8文字列です。 NFSバージョン4での主な用途は、コンポーネントとパス名の命名です。コンポーネントとパス名はサーバーのファイルシステムに保存されます。 utf8str_csプロファイルで処理した後、2つの有効な異なるUTF-8文字列が同じになる可能性があります。文字列がディレクトリ内の2つの名前である場合、NFSバージョン4サーバーは次のいずれかを行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o disallow the creation of a second name if it&#39;s post processed form collides with that of an existing name, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 後処理されたフォームが既存の名前のフォームと衝突する場合、2番目の名前の作成を許可しない、または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o allow the creation of the second name, but arrange so that after post processing, the second name is different than the post processed form of the first name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2番目の名前の作成を許可しますが、後処理後に2番目の名前が1番目の名前の後処理形式と異なるように調整します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1-2--Character-repertoire-of-nfs4csprep">
11.1.2. Character repertoire of nfs4_cs_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2. nfs4_cs_prepの文字レパートリー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cs_prep profile uses Unicode 3.2, as defined in stringprep&#39;s Appendix A.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cs_prepプロファイルは、stringprepの付録A.1で定義されているように、Unicode 3.2を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1-3--Mapping-used-by-nfs4csprep">
11.1.3. Mapping used by nfs4_cs_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.3. nfs4_cs_prepによって使用されるマッピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cs_prep profile specifies mapping using the following tables from stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cs_prepプロファイルは、stringprepの次のテーブルを使用してマッピングを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table B.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表B.1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table B.2 is normally not part of the nfs4_cs_prep profile as it is primarily for dealing with case-insensitive comparisons. However, if the NFS version 4 file server supports the case_insensitive filesystem attribute, and if case_insensitive is true, the NFS version 4 server MUST use Table B.2 (in addition to Table B1) when processing utf8str_cs strings, and the NFS version 4 client MUST assume Table B.2 (in addition to Table B.1) are being used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表B.2は、主に大文字と小文字を区別しない比較を処理するためのものであるため、通常、nfs4_cs_prepプロファイルの一部ではありません。ただし、NFSバージョン4ファイルサーバーがcase_insensitiveファイルシステム属性をサポートし、case_insensitiveがtrueの場合、NFSバージョン4サーバーは、utf8str_cs文字列の処理時に（表B1に加えて）表B.2を使用する必要があり、NFSバージョン4クライアント（表B.1に加えて）表B.2が使用されていると想定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the case_preserving attribute is present and set to false, then the NFS version 4 server MUST use table B.2 to map case when processing utf8str_cs strings. Whether the server maps from lower to upper case or the upper to lower case is an implementation dependency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
case_preserving属性が存在し、falseに設定されている場合、NFSバージョン4サーバーは、テーブルB.2を使用して、utf8str_cs文字列を処理するときに大文字と小文字をマップする必要があります。サーバーが小文字から大文字にマップするか、大文字から小文字にマップするかは、実装の依存関係です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1-4--Normalization-used-by-nfs4csprep">
11.1.4. Normalization used by nfs4_cs_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.4. nfs4_cs_prepで使用される正規化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cs_prep profile does not specify a normalization form. A later revision of this specification may specify a particular normalization form. Therefore, the server and client can expect that they may receive unnormalized characters within protocol requests and responses. If the operating environment requires normalization, then the implementation must normalize utf8str_cs strings within the protocol before presenting the information to an application (at the client) or local filesystem (at the server).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cs_prepプロファイルは、正規化形式を指定していません。この仕様の今後の改訂では、特定の正規化形式を指定する可能性があります。したがって、サーバーとクライアントは、プロトコルの要求と応答内で正規化されていない文字を受け取る可能性があることを期待できます。オペレーティング環境が正規化を必要とする場合、実装は、情報をアプリケーション（クライアント）またはローカルファイルシステム（サーバー）に提示する前に、プロトコル内のutf8str_cs文字列を正規化する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1-5--Prohibited-output-for-nfs4csprep">
11.1.5. Prohibited output for nfs4_cs_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.5. nfs4_cs_prepの禁止出力
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cs_prep profile specifies prohibiting using the following tables from stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cs_prepプロファイルは、stringprepから次のテーブルを使用することを禁止することを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.3 Table C.4 Table C.5 Table C.6 Table C.7 Table C.8 Table C.9
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.3表C.4表C.5表C.6表C.7表C.8表C.9
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1-6--Bidirectional-output-for-nfs4csprep">
11.1.6. Bidirectional output for nfs4_cs_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.6. nfs4_cs_prepの双方向出力
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cs_prep profile does not specify any checking of bidirectional strings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cs_prepプロファイルは、双方向文字列のチェックを指定しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-2--Stringprep-profile-for-the-utf8strcis-type">
11.2. Stringprep profile for the utf8str_cis type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. utf8str_cisタイプのStringprepプロファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every use of the utf8str_cis type definition in the NFS version 4 protocol specification follows the profile named nfs4_cis_prep.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコル仕様でのutf8str_cisタイプ定義のすべての使用は、nfs4_cis_prepという名前のプロファイルに従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-2-1--Intended-applicability-of-the-nfs4cisprep-profile">
11.2.1. Intended applicability of the nfs4_cis_prep profile
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.1. nfs4_cis_prepプロファイルの意図された適用性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The utf8str_cis type is a case insensitive string of UTF-8 characters. Its primary use in NFS Version 4 is for naming NFS servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_cisタイプは、大文字と小文字を区別しないUTF-8文字列です。 NFSバージョン4での主な用途は、NFSサーバーの命名です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-2-2--Character-repertoire-of-nfs4cisprep">
11.2.2. Character repertoire of nfs4_cis_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.2. nfs4_cis_prepの文字レパートリー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cis_prep profile uses Unicode 3.2, as defined in stringprep&#39;s Appendix A.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cis_prepプロファイルは、stringprepの付録A.1で定義されているように、Unicode 3.2を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-2-3--Mapping-used-by-nfs4cisprep">
11.2.3. Mapping used by nfs4_cis_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.3. nfs4_cis_prepで使用されるマッピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cis_prep profile specifies mapping using the following tables from stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cis_prepプロファイルは、stringprepの次のテーブルを使用してマッピングを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table B.1 Table B.2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表B.1表B.2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-2-4--Normalization-used-by-nfs4cisprep">
11.2.4. Normalization used by nfs4_cis_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.4. nfs4_cis_prepで使用される正規化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cis_prep profile specifies using Unicode normalization form KC, as described in stringprep.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cis_prepプロファイルは、stringprepで説明されているように、KCからのUnicode正規化の使用を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-2-5--Prohibited-output-for-nfs4cisprep">
11.2.5. Prohibited output for nfs4_cis_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.5. nfs4_cis_prepの禁止出力
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cis_prep profile specifies prohibiting using the following tables from stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cis_prepプロファイルは、stringprepから次のテーブルを使用することを禁止することを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.1.2 Table C.2.2 Table C.3 Table C.4 Table C.5 Table C.6 Table C.7 Table C.8 Table C.9
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.1.2表C.2.2表C.3表C.4表C.5表C.6表C.7表C.8表C.9
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-2-6--Bidirectional-output-for-nfs4cisprep">
11.2.6. Bidirectional output for nfs4_cis_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.6. nfs4_cis_prepの双方向出力
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cis_prep profile specifies checking bidirectional strings as described in stringprep&#39;s section 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cis_prepプロファイルは、stringprepのセクション6で説明されているように、双方向文字列のチェックを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-3--Stringprep-profile-for-the-utf8strmixed-type">
11.3. Stringprep profile for the utf8str_mixed type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3. utf8str_mixedタイプのStringprepプロファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every use of the utf8str_mixed type definition in the NFS version 4 protocol specification follows the profile named nfs4_mixed_prep.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコル仕様でのutf8str_mixedタイプ定義の使用はすべて、nfs4_mixed_prepという名前のプロファイルに従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-3-1--Intended-applicability-of-the-nfs4mixedprep-profile">
11.3.1. Intended applicability of the nfs4_mixed_prep profile
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.1. nfs4_mixed_prepプロファイルの意図された適用性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The utf8str_mixed type is a string of UTF-8 characters, with a prefix that is case sensitive, a separator equal to &#39;@&#39;, and a suffix that is fully qualified domain name. Its primary use in NFS Version 4 is for naming principals identified in an Access Control Entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_mixedタイプはUTF-8文字の文字列で、プレフィックスは大文字と小文字が区別され、区切り文字は「@」に等しく、サフィックスは完全修飾ドメイン名です。 NFSバージョン4でのその主な用途は、アクセス制御エントリで識別されるプリンシパルに名前を付けることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-3-2--Character-repertoire-of-nfs4mixedprep">
11.3.2. Character repertoire of nfs4_mixed_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.2. nfs4_mixed_prepの文字レパートリー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_mixed_prep profile uses Unicode 3.2, as defined in stringprep&#39;s Appendix A.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_mixed_prepプロファイルは、stringprepの付録A.1で定義されているように、Unicode 3.2を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-3-3--Mapping-used-by-nfs4cisprep">
11.3.3. Mapping used by nfs4_cis_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.3. nfs4_cis_prepで使用されるマッピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the prefix and the separator of a utf8str_mixed string, the nfs4_mixed_prep profile specifies mapping using the following table from stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_mixed文字列の接頭辞と区切り記号の場合、nfs4_mixed_prepプロファイルは、stringprepの次のテーブルを使用してマッピングを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table B.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表B.1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the suffix of a utf8str_mixed string, the nfs4_mixed_prep profile specifies mapping using the following tables from stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_mixed文字列のサフィックスの場合、nfs4_mixed_prepプロファイルは、stringprepの次のテーブルを使用してマッピングを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table B.1 Table B.2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表B.1表B.2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-3-4--Normalization-used-by-nfs4mixedprep">
11.3.4. Normalization used by nfs4_mixed_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.4. nfs4_mixed_prepで使用される正規化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_mixed_prep profile specifies using Unicode normalization form KC, as described in stringprep.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_mixed_prepプロファイルは、stringprepで説明されているように、KCからのUnicode正規化の使用を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-3-5--Prohibited-output-for-nfs4mixedprep">
11.3.5. Prohibited output for nfs4_mixed_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.5. nfs4_mixed_prepの禁止出力
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_mixed_prep profile specifies prohibiting using the following tables from stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_mixed_prepプロファイルは、stringprepから次のテーブルを使用することを禁止することを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.1.2 Table C.2.2 Table C.3 Table C.4 Table C.5 Table C.6 Table C.7 Table C.8 Table C.9
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.1.2表C.2.2表C.3表C.4表C.5表C.6表C.7表C.8表C.9
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-3-6--Bidirectional-output-for-nfs4mixedprep">
11.3.6. Bidirectional output for nfs4_mixed_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.6. nfs4_mixed_prepの双方向出力
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_mixed_prep profile specifies checking bidirectional strings as described in stringprep&#39;s section 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_mixed_prepプロファイルは、stringprepのセクション6で説明されているように、双方向文字列のチェックを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-4--UTF-8-Related-Errors">
11.4. UTF-8 Related Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4. UTF-8関連のエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where the client sends an invalid UTF-8 string, the server should return an NFS4ERR_INVAL error. This includes cases in which inappropriate prefixes are detected and where the count includes trailing bytes that do not constitute a full UCS character.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが無効なUTF-8文字列を送信する場合、サーバーはNFS4ERR_INVALエラーを返す必要があります。これには、不適切なプレフィックスが検出された場合や、完全なUCS文字を構成しない末尾のバイトがカウントに含まれる場合が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where the client supplied string is valid UTF-8 but contains characters that are not supported by the server as a value for that string (e.g., names containing characters that have more than two octets on a filesystem that supports Unicode characters only), the server should return an NFS4ERR_BADCHAR error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが提供する文字列は有効なUTF-8であるが、サーバーがその文字列の値としてサポートしていない文字（たとえば、Unicode文字のみをサポートするファイルシステムで2オクテットを超える文字を含む名前）を含む場合、サーバーNFS4ERR_BADCHARエラーを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Where a UTF-8 string is used as a file name, and the filesystem, while supporting all of the characters within the name, does not allow that particular name to be used, the server should return the error NFS4ERR_BADNAME. This includes situations in which the server filesystem imposes a normalization constraint on name strings, but will also include such situations as filesystem prohibitions of &#34;.&#34; and &#34;..&#34; as file names for certain operations, and other such constraints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
UTF-8文字列がファイル名として使用されており、ファイルシステムは名前内のすべての文字をサポートしているが、その特定の名前の使用を許可していない場合、サーバーはエラーNFS4ERR_BADNAMEを返す必要があります。これには、サーバーのファイルシステムが名前文字列に正規化の制約を課す状況が含まれますが、「。」のファイルシステムの禁止などの状況も含まれます。および「..」は、特定の操作やその他の制約のファイル名として使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12--Error-Definitions">
12. Error Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. エラー定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS error numbers are assigned to failed operations within a compound request. A compound request contains a number of NFS operations that have their results encoded in sequence in a compound reply. The results of successful operations will consist of an NFS4_OK status followed by the encoded results of the operation. If an NFS operation fails, an error status will be entered in the reply and the compound request will be terminated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSエラー番号は、複合要求内の失敗した操作に割り当てられます。複合要求には、複合応答で結果が順番にエンコードされたいくつかのNFS操作が含まれています。成功した操作の結果は、NFS4_OKステータスと、それに続く操作のエンコードされた結果で構成されます。 NFS操作が失敗した場合、エラーステータスが応答に入力され、複合要求は終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A description of each defined error follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定義された各エラーの説明は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4_OK Indicates the operation completed successfully.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4_OK操作が正常に完了したことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ACCESS Permission denied. The caller does not have the correct permission to perform the requested operation. Contrast this with NFS4ERR_PERM, which restricts itself to owner or privileged user permission failures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ACCESS権限が拒否されました。呼び出し元には、要求された操作を実行するための適切な権限がありません。これをNFS4ERR_PERMと比較してください。NFS4ERR_PERMは、所有者または特権ユーザーのアクセス許可エラーに制限されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ATTRNOTSUPP An attribute specified is not supported by the server. Does not apply to the GETATTR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ATTRNOTSUPP指定された属性はサーバーでサポートされていません。 GETATTR操作には適用されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ADMIN_REVOKED Due to administrator intervention, the lockowner&#39;s record locks, share reservations, and delegations have been revoked by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ADMIN_REVOKED管理者の介入により、ロック所有者のレコードロック、共有の予約、および委任はサーバーによって取り消されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADCHAR A UTF-8 string contains a character which is not supported by the server in the context in which it being used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADCHAR UTF-8文字列には、使用されているコンテキストでサーバーによってサポートされていない文字が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BAD_COOKIE READDIR cookie is stale.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BAD_COOKIE READDIR cookieが古くなっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADHANDLE Illegal NFS filehandle. The filehandle failed internal consistency checks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADHANDLE不正なNFSファイルハンドル。ファイルハンドルが内部整合性チェックに失敗しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADNAME A name string in a request consists of valid UTF-8 characters supported by the server but the name is not supported by the server as a valid name for current operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADNAMEリクエスト内の名前文字列は、サーバーでサポートされている有効なUTF-8文字で構成されていますが、サーバーで現在の操作の有効な名前としてサポートされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADOWNER An owner, owner_group, or ACL attribute value can not be translated to local representation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADOWNER所有者、所有者グループ、またはACL属性値はローカル表現に変換できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADTYPE An attempt was made to create an object of a type not supported by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADTYPEサーバーでサポートされていないタイプのオブジェクトを作成しようとしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BAD_RANGE The range for a LOCK, LOCKT, or LOCKU operation is not appropriate to the allowable range of offsets for the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4 ERR_BAD_RANGE LOCK、LOCK、またはLOCK操作の範囲は、サーバーのオフセットの許容範囲に適していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BAD_SEQID The sequence number in a locking request is neither the next expected number or the last number processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BAD_SEQIDロック要求のシーケンス番号は、次に予期される番号でも、最後に処理された番号でもありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BAD_STATEID A stateid generated by the current server instance, but which does not designate any locking state (either current or superseded) for a current lockowner-file pair, was used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BAD_STATEID現在のサーバーインスタンスによって生成されたが、現在のロック所有者とファイルのペアのロック状態（現在または優先）を指定していない状態IDが使用されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADXDR The server encountered an XDR decoding error while processing an operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADXDRサーバーは、操作の処理中にXDRデコードエラーを検出しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_CLID_INUSE The SETCLIENTID operation has found that a client id is already in use by another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_CLID_INUSE SETCLIENTID操作で、クライアントIDがすでに別のクライアントで使用されていることがわかりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DEADLOCK The server has been able to determine a file locking deadlock condition for a blocking lock request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DEADLOCKサーバーは、ブロッキングロック要求のファイルロックデッドロック状態を判別できました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DELAY The server initiated the request, but was not able to complete it in a timely fashion. The client should wait and then try the request with a new RPC transaction ID. For example, this error should be returned from a server that supports hierarchical storage and receives a request to process a file that has been migrated. In this case, the server should start the immigration process and respond to client with this error. This error may also occur when a necessary delegation recall makes processing a request in a timely fashion impossible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DELAYサーバーはリクエストを開始しましたが、タイムリーにそれを完了することができませんでした。クライアントは待機してから、新しいRPCトランザクションIDを使用して要求を試行する必要があります。たとえば、このエラーは、階層ストレージをサポートし、移行されたファイルを処理するためのリクエストを受信するサーバーから返される必要があります。この場合、サーバーは移民プロセスを開始し、このエラーでクライアントに応答する必要があります。このエラーは、必要な委任の取り消しにより、要求をタイムリーに処理することが不可能になった場合にも発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DENIED An attempt to lock a file is denied. Since this may be a temporary condition, the client is encouraged to retry the lock request until the lock is accepted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DENIEDファイルをロックする試みが拒否されました。これは一時的な状態である可能性があるため、クライアントは、ロックが受け入れられるまでロック要求を再試行することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DQUOT Resource (quota) hard limit exceeded. The user&#39;s resource limit on the server has been exceeded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DQUOTリソース（割り当て）のハード制限を超えました。サーバー上のユーザーのリソース制限を超えました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_EXIST File exists. The file specified already exists.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_EXISTファイルが存在します。指定されたファイルは既に存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_EXPIRED A lease has expired that is being used in the current operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_EXPIRED現在の操作で使用されているリースの期限が切れました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_FBIG File too large. The operation would have caused a file to grow beyond the server&#39;s limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_FBIGファイルが大きすぎます。この操作により、ファイルがサーバーの制限を超えて大きくなっていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_FHEXPIRED The filehandle provided is volatile and has expired at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_FHEXPIRED提供されたファイルハンドルは揮発性であり、サーバーで有効期限が切れています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_FILE_OPEN The operation can not be successfully processed because a file involved in the operation is currently open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_FILE_OPEN操作に関連するファイルが現在開いているため、操作を正常に処理できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_GRACE The server is in its recovery or grace period which should match the lease period of the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_GRACEサーバーは、サーバーのリース期間と一致する回復または猶予期間です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_INVAL Invalid argument or unsupported argument for an operation. Two examples are attempting a READLINK on an object other than a symbolic link or specifying a value for an enum field that is not defined in the protocol (e.g., nfs_ftype4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_INVAL操作に対して無効な引数またはサポートされていない引数。 2つの例は、シンボリックリンク以外のオブジェクトでREADLINKを試行すること、またはプロトコルで定義されていない列挙型フィールド（nfs_ftype4など）に値を指定することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_IO I/O error. A hard error (for example, a disk error) occurred while processing the requested operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_IO I / Oエラー。要求された操作の処理中にハードエラー（ディスクエラーなど）が発生しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ISDIR Is a directory. The caller specified a directory in a non-directory operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ISDIRはディレクトリです。呼び出し元は、非ディレクトリ操作でディレクトリを指定しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LEASE_MOVED A lease being renewed is associated with a filesystem that has been migrated to a new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LEASE_MOVED更新されるリースは、新しいサーバーに移行されたファイルシステムに関連付けられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LOCKED A read or write operation was attempted on a locked file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LOCKEDロックされたファイルに対して読み取りまたは書き込み操作が試行されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LOCK_NOTSUPP Server does not support atomic upgrade or downgrade of locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LOCK_NOTSUPPサーバーは、ロックのアトミックアップグレードまたはダウングレードをサポートしていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LOCK_RANGE A lock request is operating on a sub-range of a current lock for the lock owner and the server does not support this type of request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LOCK_RANGEロック要求は、ロック所有者の現在のロックのサブ範囲で動作しており、サーバーはこのタイプの要求をサポートしていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LOCKS_HELD A CLOSE was attempted and file locks would exist after the CLOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LOCKS_HELD CLOSEが試行され、CLOSEの後にファイルロックが存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_MINOR_VERS_MISMATCH The server has received a request that specifies an unsupported minor version. The server must return a COMPOUND4res with a zero length operations result array.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_MINOR_VERS_MISMATCHサーバーは、サポートされていないマイナーバージョンを指定する要求を受け取りました。サーバーは、長さがゼロの演算結果配列を持つCOMPOUND4resを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_MLINK Too many hard links.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_MLINKハードリンクが多すぎます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_MOVED The filesystem which contains the current filehandle object has been relocated or migrated to another server. The client may obtain the new filesystem location by obtaining the &#34;fs_locations&#34; attribute for the current filehandle. For further discussion, refer to the section &#34;Filesystem Migration or Relocation&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_MOVED現在のファイルハンドルオブジェクトを含むファイルシステムが別のサーバーに再配置または移行されました。クライアントは、現在のファイルハンドルの「fs_locations」属性を取得することにより、新しいファイルシステムの場所を取得できます。詳細については、「ファイルシステムの移行または再配置」のセクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NAMETOOLONG The filename in an operation was too long.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NAMETOOLONG操作のファイル名が長すぎました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOENT No such file or directory. The file or directory name specified does not exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOENTそのようなファイルまたはディレクトリはありません。指定されたファイルまたはディレクトリ名は存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOFILEHANDLE The logical current filehandle value (or, in the case of RESTOREFH, the saved filehandle value) has not been set properly. This may be a result of a malformed COMPOUND operation (i.e., no PUTFH or PUTROOTFH before an operation that requires the current filehandle be set).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOFILEHANDLE論理的な現在のファイルハンドル値（または、RESTOREFHの場合は、保存されたファイルハンドル値）が正しく設定されていません。これは、不正な形式のCOMPOUND操作の結果である可能性があります（つまり、現在のファイルハンドルの設定を必要とする操作の前に、PUTFHまたはPUTROOTFHがありません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NO_GRACE A reclaim of client state has fallen outside of the grace period of the server. As a result, the server can not guarantee that conflicting state has not been provided to another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NO_GRACEクライアント状態の再利用がサーバーの猶予期間外になりました。その結果、サーバーは競合する状態が別のクライアントに提供されていないことを保証できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOSPC No space left on device. The operation would have caused the server&#39;s filesystem to exceed its limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOSPCデバイスにスペースが残っていません。この操作により、サーバーのファイルシステムが制限を超えていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOTDIR Not a directory. The caller specified a non-directory in a directory operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOTDIRディレクトリではありません。呼び出し元がディレクトリ操作で非ディレクトリを指定しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOTEMPTY An attempt was made to remove a directory that was not empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOTEMPTY空でないディレクトリを削除しようとしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOTSUPP Operation is not supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOTSUPP操作はサポートされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOT_SAME This error is returned by the VERIFY operation to signify that the attributes compared were not the same as provided in the client&#39;s request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOT_SAMEこのエラーは、比較された属性がクライアントの要求で提供されたものと同じではなかったことを示すために、VERIFY操作によって返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NXIO I/O error. No such device or address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NXIO I / Oエラー。そのようなデバイスやアドレスはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OLD_STATEID A stateid which designates the locking state for a lockowner-file at an earlier time was used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OLD_STATEID以前にロック所有者ファイルのロック状態を指定する状態IDが使用されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OPENMODE The client attempted a READ, WRITE, LOCK or SETATTR operation not sanctioned by the stateid passed (e.g., writing to a file opened only for read).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OPENMODEクライアントが、渡された状態IDによって許可されていないREAD、WRITE、LOCK、またはSETATTR操作を試みました（たとえば、読み取り専用に開かれたファイルへの書き込み）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OP_ILLEGAL An illegal operation value has been specified in the argop field of a COMPOUND or CB_COMPOUND procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OP_ILLEGAL COMPOUNDまたはCB_COMPOUNDプロシージャのargopフィールドに無効な操作値が指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_PERM Not owner. The operation was not allowed because the caller is either not a privileged user (root) or not the owner of the target of the operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_PERM所有者ではありません。呼び出し元が特権ユーザー（root）でも操作のターゲットの所有者でもないため、操作は許可されませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_RECLAIM_BAD The reclaim provided by the client does not match any of the server&#39;s state consistency checks and is bad.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_RECLAIM_BADクライアントによって提供された再利用は、サーバーのどの状態の整合性チェックとも一致せず、不良です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_RECLAIM_CONFLICT The reclaim provided by the client has encountered a conflict and can not be provided. Potentially indicates a misbehaving client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_RECLAIM_CONFLICTクライアントによって提供された再利用で競合が発生したため、提供できません。誤動作しているクライアントを示している可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_RESOURCE For the processing of the COMPOUND procedure, the server may exhaust available resources and can not continue processing operations within the COMPOUND procedure. This error will be returned from the server in those instances of resource exhaustion related to the processing of the COMPOUND procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_RESOURCE COMPOUNDプロシージャの処理のために、サーバーは使用可能なリソースを使い果たし、COMPOUNDプロシージャ内で処理操作を続行できません。このエラーは、COMPOUNDプロシージャの処理に関連するリソース枯渇のインスタンスでサーバーから返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_RESTOREFH The RESTOREFH operation does not have a saved filehandle (identified by SAVEFH) to operate upon.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_RESTOREFH RESTOREFH操作には、操作対象の保存されたファイルハンドル（SAVEFHで識別）がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ROFS Read-only filesystem. A modifying operation was attempted on a read-only filesystem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ROFS読み取り専用ファイルシステム。読み取り専用ファイルシステムで変更操作が試行されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_SAME This error is returned by the NVERIFY operation to signify that the attributes compared were the same as provided in the client&#39;s request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_SAMEこのエラーはNVERIFY操作によって返され、比較された属性がクライアントの要求で提供されたものと同じであることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_SERVERFAULT An error occurred on the server which does not map to any of the legal NFS version 4 protocol error values. The client should translate this into an appropriate error. UNIX clients may choose to translate this to EIO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_SERVERFAULT有効なNFSバージョン4プロトコルエラー値のいずれにもマップしないエラーがサーバーで発生しました。クライアントはこれを適切なエラーに変換する必要があります。 UNIXクライアントは、これをEIOに変換することを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_SHARE_DENIED An attempt to OPEN a file with a share reservation has failed because of a share conflict.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_SHARE_DENIED共有の競合のため、共有予約でファイルを開く試みが失敗しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_STALE Invalid filehandle. The filehandle given in the arguments was invalid. The file referred to by that filehandle no longer exists or access to it has been revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_STALE無効なファイルハンドル。引数で指定されたファイルハンドルが無効でした。そのファイルハンドルによって参照されているファイルが存在しないか、そのファイルへのアクセスが取り消されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_STALE_CLIENTID A clientid not recognized by the server was used in a locking or SETCLIENTID_CONFIRM request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_STALE_CLIENTIDサーバーが認識しないclientidが、ロックまたはSETCLIENTID_CONFIRMリクエストで使用されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_STALE_STATEID A stateid generated by an earlier server instance was used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_STALE_STATEID以前のサーバーインスタンスによって生成された状態IDが使用されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_SYMLINK The current filehandle provided for a LOOKUP is not a directory but a symbolic link. Also used if the final component of the OPEN path is a symbolic link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_SYMLINK LOOKUPに提供されている現在のファイルハンドルは、ディレクトリではなくシンボリックリンクです。 OPENパスの最後のコンポーネントがシンボリックリンクである場合にも使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_TOOSMALL The encoded response to a READDIR request exceeds the size limit set by the initial request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_TOOSMALL READDIR要求に対するエンコードされた応答が、最初の要求によって設定されたサイズ制限を超えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_WRONGSEC The security mechanism being used by the client for the operation does not match the server&#39;s security policy. The client should change the security mechanism being used and retry the operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_WRONGSECクライアントが操作に使用しているセキュリティメカニズムが、サーバーのセキュリティポリシーと一致しません。クライアントは、使用されているセキュリティメカニズムを変更して、操作を再試行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_XDEV Attempt to do an operation between different fsids.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_XDEV異なるfsid間で操作を実行しようとしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13--NFS-version-4-Requests">
13. NFS version 4 Requests
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. NFSバージョン4要求
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the NFS version 4 RPC program, there are two traditional RPC procedures: NULL and COMPOUND. All other functionality is defined as a set of operations and these operations are defined in normal XDR/RPC syntax and semantics. However, these operations are encapsulated within the COMPOUND procedure. This requires that the client combine one or more of the NFS version 4 operations into a single request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4 RPCプログラムの場合、2つの従来のRPCプロシージャ、NULLとCOMPOUNDがあります。他のすべての機能は一連の操作として定義され、これらの操作は通常のXDR / RPC構文とセマンティクスで定義されます。ただし、これらの操作はCOMPOUNDプロシージャ内にカプセル化されています。これには、クライアントが1つ以上のNFSバージョン4操作を単一の要求に結合することが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS4_CALLBACK program is used to provide server to client signaling and is constructed in a similar fashion as the NFS version 4 program. The procedures CB_NULL and CB_COMPOUND are defined in the same way as NULL and COMPOUND are within the NFS program. The CB_COMPOUND request also encapsulates the remaining operations of the NFS4_CALLBACK program. There is no predefined RPC program number for the NFS4_CALLBACK program. It is up to the client to specify a program number in the &#34;transient&#34; program range. The program and port number of the NFS4_CALLBACK program are provided by the client as part of the SETCLIENTID/SETCLIENTID_CONFIRM sequence. The program and port can be changed by another SETCLIENTID/SETCLIENTID_CONFIRM sequence, and it is possible to use the sequence to change them within a client incarnation without removing relevant leased client state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4_CALLBACKプログラムは、サーバーからクライアントへのシグナリングを提供するために使用され、NFSバージョン4プログラムと同様の方法で構築されます。プロシージャCB_NULLおよびCB_COMPOUNDは、NFSプログラム内のNULLおよびCOMPOUNDと同じ方法で定義されます。 CB_COMPOUND要求は、NFS4_CALLBACKプログラムの残りの操作もカプセル化します。 NFS4_CALLBACKプログラムには、事前定義されたRPCプログラム番号はありません。 「一時的な」プログラム範囲でプログラム番号を指定するのはクライアントの責任です。 NFS4_CALLBACKプログラムのプログラムとポート番号は、SETCLIENTID / SETCLIENTID_CONFIRMシーケンスの一部としてクライアントから提供されます。プログラムとポートは、別のSETCLIENTID / SETCLIENTID_CONFIRMシーケンスによって変更できます。シーケンスを使用して、関連するリースされたクライアントの状態を削除せずに、クライアントインカネーション内でそれらを変更できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-1--Compound-Procedure">
13.1. Compound Procedure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. 複合手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMPOUND procedure provides the opportunity for better performance within high latency networks. The client can avoid cumulative latency of multiple RPCs by combining multiple dependent operations into a single COMPOUND procedure. A compound operation may provide for protocol simplification by allowing the client to combine basic procedures into a single request that is customized for the client&#39;s environment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャは、レイテンシの長いネットワーク内でパフォーマンスを向上させる機会を提供します。クライアントは、複数の依存操作を1つのCOMPOUNDプロシージャに結合することにより、複数のRPCの累積待ち時間を回避できます。複合操作では、クライアントがクライアントの環境に合わせてカスタマイズされた単一の要求に基本的な手順を組み合わせることができるようにすることで、プロトコルを簡素化できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_COMPOUND procedure precisely parallels the features of COMPOUND as described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_COMPOUNDプロシージャは、上記のCOMPOUNDの機能に正確に対応しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic structure of the COMPOUND procedure is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャの基本構造は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-----+--------------+--------+-----------+-----------+-----------+--
   | tag | minorversion | numops | op + args | op + args | op + args |
   +-----+--------------+--------+-----------+-----------+-----------+--
   and the reply&#39;s structure is:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +------------+-----+--------+-----------------------+--
      |last status | tag | numres | status + op + results |
      +------------+-----+--------+-----------------------+--
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The numops and numres fields, used in the depiction above, represent the count for the counted array encoding use to signify the number of arguments or results encoded in the request and response. As per the XDR encoding, these counts must match exactly the number of operation arguments or results encoded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上の図で使用されているnumopsおよびnumresフィールドは、リクエストとレスポンスでエンコードされた引数または結果の数を示すために使用される、カウントされた配列エンコーディングのカウントを表します。 XDRエンコードに従って、これらのカウントは、エンコードされた操作引数または結果の数と正確に一致する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-2--Evaluation-of-a-Compound-Request">
13.2. Evaluation of a Compound Request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2. 複合リクエストの評価
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server will process the COMPOUND procedure by evaluating each of the operations within the COMPOUND procedure in order. Each component operation consists of a 32 bit operation code, followed by the argument of length determined by the type of operation. The results of each operation are encoded in sequence into a reply buffer. The results of each operation are preceded by the opcode and a status code (normally zero). If an operation results in a non-zero status code, the status will be encoded and evaluation of the compound sequence will halt and the reply will be returned. Note that evaluation stops even in the event of &#34;non error&#34; conditions such as NFS4ERR_SAME.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、COMPOUNDプロシージャ内の各操作を順番に評価して、COMPOUNDプロシージャを処理します。各コンポーネント演算は32ビットの演算コードで構成され、その後に演算のタイプで決まる長さの引数が続きます。各操作の結果は、応答バッファーに順番にエンコードされます。各操作の結果の前には、オペコードとステータスコード（通常はゼロ）が付きます。操作の結果がゼロ以外のステータスコードの場合、ステータスがエンコードされ、複合シーケンスの評価が停止し、応答が返されます。 NFS4ERR_SAMEなどの「非エラー」条件が発生した場合でも、評価は停止することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are no atomicity requirements for the operations contained within the COMPOUND procedure. The operations being evaluated as part of a COMPOUND request may be evaluated simultaneously with other COMPOUND requests that the server receives.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャに含まれる操作には、原子性の要件はありません。 COMPOUNDリクエストの一部として評価される操作は、サーバーが受信する他のCOMPOUNDリクエストと同時に評価される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is the client&#39;s responsibility for recovering from any partially completed COMPOUND procedure. Partially completed COMPOUND procedures may occur at any point due to errors such as NFS4ERR_RESOURCE and NFS4ERR_DELAY. This may occur even given an otherwise valid operation string. Further, a server reboot which occurs in the middle of processing a COMPOUND procedure may leave the client with the difficult task of determining how far COMPOUND processing has proceeded. Therefore, the client should avoid overly complex COMPOUND procedures in the event of the failure of an operation within the procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
部分的に完了したCOMPOUNDプロシージャから回復するのはクライアントの責任です。 NFS4ERR_RESOURCEやNFS4ERR_DELAYなどのエラーが原因で、部分的に完了したCOMPOUNDプロシージャがいつでも発生する可能性があります。これは、それ以外の場合は有効な操作文字列を指定した場合でも発生する可能性があります。さらに、COMPOUNDプロシージャの処理中に発生するサーバーのリブートは、COMPOUND処理がどこまで進んだかを判断するという難しいタスクをクライアントに残す可能性があります。したがって、クライアントは、プロシージャ内の操作が失敗した場合に、過度に複雑なCOMPOUNDプロシージャを回避する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each operation assumes a &#34;current&#34; and &#34;saved&#34; filehandle that is available as part of the execution context of the compound request. Operations may set, change, or return the current filehandle. The &#34;saved&#34; filehandle is used for temporary storage of a filehandle value and as operands for the RENAME and LINK operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各操作は、複合要求の実行コンテキストの一部として使用可能な「現在の」および「保存された」ファイルハンドルを想定しています。操作は、現在のファイルハンドルを設定、変更、または返す場合があります。 「保存された」ファイルハンドルは、ファイルハンドル値の一時的な保存に使用され、RENAMEおよびLINK操作のオペランドとして使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-3--Synchronous-Modifying-Operations">
13.3. Synchronous Modifying Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3. 同期修正操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS version 4 operations that modify the filesystem are synchronous. When an operation is successfully completed at the server, the client can depend that any data associated with the request is now on stable storage (the one exception is in the case of the file data in a WRITE operation with the UNSTABLE option specified).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムを変更するNFSバージョン4の操作は同期的です。サーバーで操作が正常に完了すると、クライアントは、要求に関連付けられたすべてのデータが安定したストレージにあることを信頼できます（1つの例外は、UNSTABLEオプションが指定されたWRITE操作のファイルデータの場合です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This implies that any previous operations within the same compound request are also reflected in stable storage. This behavior enables the client&#39;s ability to recover from a partially executed compound request which may resulted from the failure of the server. For example, if a compound request contains operations A and B and the server is unable to send a response to the client, depending on the progress the server made in servicing the request the result of both operations may be reflected in stable storage or just operation A may be reflected. The server must not have just the results of operation B in stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、同じ複合リクエスト内の以前の操作も安定したストレージに反映されることを意味します。この動作により、サーバーの障害が原因である可能性のある、部分的に実行された複合リクエストからクライアントが回復できるようになります。たとえば、複合リクエストに操作AとBが含まれ、サーバーがクライアントに応答を送信できない場合、サーバーがリクエストを処理する際の進行状況に応じて、両方の操作の結果が安定したストレージまたは操作のみに反映される場合があります。 Aが反映される場合があります。サーバーは、操作Bの結果だけを安定したストレージに保管してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-4--Operation-Values">
13.4. Operation Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4. 操作値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The operations encoded in the COMPOUND procedure are identified by operation values. To avoid overlap with the RPC procedure numbers, operations 0 (zero) and 1 are not defined. Operation 2 is not defined but reserved for future use with minor versioning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャでエンコードされた操作は、操作値によって識別されます。 RPCプロシージャ番号との重複を避けるため、操作0（ゼロ）と1は定義されていません。操作2は定義されていませんが、マイナーバージョン管理で将来使用するために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14--NFS-version-4-Procedures">
14. NFS version 4 Procedures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. NFSバージョン4の手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-1--Procedure-0-NULL---No-Operation">
14.1. Procedure 0: NULL - No Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1. 手順0：NULL-操作なし
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt;null&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt;null&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Standard NULL procedure. Void argument, void response. This procedure has no functionality associated with it. Because of this it is sometimes used to measure the overhead of processing a service request. Therefore, the server should ensure that no unnecessary work is done in servicing this procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
標準のNULLプロシージャ。無効な引数、無効な応答。この手順には、関連する機能はありません。このため、サービス要求の処理のオーバーヘッドを測定するために使用されることがあります。したがって、サーバーは、この手順を実行する際に不要な作業が行われないようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
None.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
なし。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2--Procedure-1-COMPOUND---Compound-Operations">
14.2. Procedure 1: COMPOUND - Compound Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2. 手順1：COMPOUND-複合操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
compoundargs -&gt; compoundres
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
複合引数-&gt;複合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union nfs_argop4 switch (nfs_opnum4 argop) {
             case &lt;OPCODE&gt;: &lt;argument&gt;;
             ...
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct COMPOUND4args {
             utf8str_cs      tag;
             uint32_t        minorversion;
             nfs_argop4      argarray&lt;&gt;;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union nfs_resop4 switch (nfs_opnum4 resop){
             case &lt;OPCODE&gt;: &lt;result&gt;;
             ...
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct COMPOUND4res {
             nfsstat4        status;
             utf8str_cs      tag;
             nfs_resop4      resarray&lt;&gt;;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMPOUND procedure is used to combine one or more of the NFS operations into a single RPC request. The main NFS RPC program has two main procedures: NULL and COMPOUND. All other operations use the COMPOUND procedure as a wrapper.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャは、1つ以上のNFS操作を1つのRPC要求に結合するために使用されます。メインのNFS RPCプログラムには、NULLとCOMPOUNDの2つの主要な手順があります。他のすべての操作では、COMPOUNDプロシージャがラッパーとして使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMPOUND procedure is used to combine individual operations into a single RPC request. The server interprets each of the operations in turn. If an operation is executed by the server and the status of that operation is NFS4_OK, then the next operation in the COMPOUND procedure is executed. The server continues this process until there are no more operations to be executed or one of the operations has a status value other than NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャは、個々の操作を1つのRPC要求に結合するために使用されます。サーバーは各操作を順番に解釈します。サーバーによって操作が実行され、その操作のステータスがNFS4_OKである場合、COMPOUNDプロシージャの次の操作が実行されます。サーバーは、実行する操作がなくなるか、操作の1つがNFS4_OK以外のステータス値になるまで、このプロセスを続行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the processing of the COMPOUND procedure, the server may find that it does not have the available resources to execute any or all of the operations within the COMPOUND sequence. In this case, the error NFS4ERR_RESOURCE will be returned for the particular operation within the COMPOUND procedure where the resource exhaustion occurred. This assumes that all previous operations within the COMPOUND sequence have been evaluated successfully. The results for all of the evaluated operations must be returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャの処理中に、サーバーは、COMPOUNDシーケンス内の操作の一部またはすべてを実行するために使用できるリソースがないことに気付く場合があります。この場合、リソースの枯渇が発生したCOMPOUNDプロシージャ内の特定の操作に対して、エラーNFS4ERR_RESOURCEが返されます。これは、COMPOUNDシーケンス内の以前のすべての操作が正常に評価されていることを前提としています。評価されたすべての操作の結果をクライアントに返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server will generally choose between two methods of decoding the client&#39;s request. The first would be the traditional one-pass XDR decode, in which decoding of the entire COMPOUND precedes execution of any operation within it. If there is an XDR decoding error in this case, an RPC XDR decode error would be returned. The second method would be to make an initial pass to decode the basic COMPOUND request and then to XDR decode each of the individual operations, as the server is ready to execute it. In this case, the server may encounter an XDR decode error during such an operation decode, after previous operations within the COMPOUND have been executed. In this case, the server would return the error NFS4ERR_BADXDR to signify the decode error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは通常、クライアントの要求をデコードする2つの方法から選択します。 1つ目は、従来のワンパスXDRデコードです。この場合、COMPOUND全体のデコードは、その内部での操作の実行に先行します。この場合にXDRデコードエラーが発生すると、RPC XDRデコードエラーが返されます。 2番目の方法は、基本的なCOMPOUNDリクエストをデコードする最初のパスを作成し、サーバーが実行する準備ができているので、個々の操作のそれぞれをXDRデコードすることです。この場合、COMPOUND内の以前の操作が実行された後、サーバーはそのような操作のデコード中にXDRデコードエラーに遭遇する可能性があります。この場合、サーバーはNFS4ERR_BADXDRエラーを返し、デコードエラーを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMPOUND arguments contain a &#34;minorversion&#34; field. The initial and default value for this field is 0 (zero). This field will be used by future minor versions such that the client can communicate to the server what minor version is being requested. If the server receives a COMPOUND procedure with a minorversion field value that it does not support, the server MUST return an error of NFS4ERR_MINOR_VERS_MISMATCH and a zero length resultdata array.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND引数には、「minorversion」フィールドが含まれています。このフィールドの初期値とデフォルト値は0（ゼロ）です。このフィールドは、クライアントがどのマイナーバージョンが要求されているかをサーバーと通信できるように、将来のマイナーバージョンで使用されます。サーバーがサポートしていないマイナーバージョンフィールド値のCOMPOUNDプロシージャを受信した場合、サーバーはNFS4ERR_MINOR_VERS_MISMATCHのエラーと長さゼロの結果データ配列を返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Contained within the COMPOUND results is a &#34;status&#34; field. If the results array length is non-zero, this status must be equivalent to the status of the last operation that was executed within the COMPOUND procedure. Therefore, if an operation incurred an error then the &#34;status&#34; value will be the same error value as is being returned for the operation that failed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
COMPOUND結果には、「ステータス」フィールドが含まれています。結果の配列の長さがゼロ以外の場合、このステータスはCOMPOUNDプロシージャ内で実行された最後の操作のステータスと同じである必要があります。したがって、操作でエラーが発生した場合、「ステータス」の値は、失敗した操作で返されるエラー値と同じになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that operations, 0 (zero) and 1 (one) are not defined for the COMPOUND procedure. Operation 2 is not defined but reserved for future definition and use with minor versioning. If the server receives a operation array that contains operation 2 and the minorversion field has a value of 0 (zero), an error of NFS4ERR_OP_ILLEGAL, as described in the next paragraph, is returned to the client. If an operation array contains an operation 2 and the minorversion field is non-zero and the server does not support the minor version, the server returns an error of NFS4ERR_MINOR_VERS_MISMATCH. Therefore, the NFS4ERR_MINOR_VERS_MISMATCH error takes precedence over all other errors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャには、操作0（ゼロ）および1（1）が定義されていないことに注意してください。操作2は定義されていませんが、将来の定義およびマイナーバージョン管理での使用のために予約されています。サーバーが操作2を含む操作配列を受信し、minorversionフィールドの値が0（ゼロ）の場合、次の段落で説明するように、NFS4ERR_OP_ILLEGALのエラーがクライアントに返されます。操作配列に操作2が含まれ、minorversionフィールドがゼロ以外であり、サーバーがマイナーバージョンをサポートしていない場合、サーバーはNFS4ERR_MINOR_VERS_MISMATCHのエラーを返します。したがって、NFS4ERR_MINOR_VERS_MISMATCHエラーは、他のすべてのエラーよりも優先されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible that the server receives a request that contains an operation that is less than the first legal operation (OP_ACCESS) or greater than the last legal operation (OP_RELEASE_LOCKOWNER).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、最初の正当な操作（OP_ACCESS）よりも小さい操作、または最後の正当な操作（OP_RELEASE_LOCKOWNER）よりも大きい操作を含む要求を受信する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this case, the server&#39;s response will encode the opcode OP_ILLEGAL rather than the illegal opcode of the request. The status field in the ILLEGAL return results will set to NFS4ERR_OP_ILLEGAL. The COMPOUND procedure&#39;s return results will also be NFS4ERR_OP_ILLEGAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この場合、サーバーの応答は、要求の不正なオペコードではなく、オペコードOP_ILLEGALをエンコードします。 ILLEGALの戻り結果のステータスフィールドはNFS4ERR_OP_ILLEGALに設定されます。 COMPOUNDプロシージャの戻り結果もNFS4ERR_OP_ILLEGALになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The definition of the &#34;tag&#34; in the request is left to the implementor. It may be used to summarize the content of the compound request for the benefit of packet sniffers and engineers debugging implementations. However, the value of &#34;tag&#34; in the response SHOULD be the same value as provided in the request. This applies to the tag field of the CB_COMPOUND procedure as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエスト内の「タグ」の定義は実装者に任されています。パケットスニッファとエンジニアのデバッグ実装のために、複合リクエストの内容を要約するために使用できます。ただし、応答の「タグ」の値は、要求で提供されたものと同じ値である必要があります。これは、CB_COMPOUNDプロシージャのタグフィールドにも適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since an error of any type may occur after only a portion of the operations have been evaluated, the client must be prepared to recover from any failure. If the source of an NFS4ERR_RESOURCE error was a complex or lengthy set of operations, it is likely that if the number of operations were reduced the server would be able to evaluate them successfully. Therefore, the client is responsible for dealing with this type of complexity in recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オペレーションの一部のみが評価された後で、あらゆるタイプのエラーが発生する可能性があるため、クライアントは障害から回復する準備をする必要があります。 NFS4ERR_RESOURCEエラーの原因が複雑な、または長い操作のセットであった場合、操作の数が減った場合、サーバーはそれらを正常に評価できる可能性があります。したがって、クライアントは、回復におけるこの種の複雑さを処理する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All errors defined in the protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルで定義されたすべてのエラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-1--Operation-3-ACCESS---Check-Access-Rights">
14.2.1. Operation 3: ACCESS - Check Access Rights
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.1. 操作3：アクセス-アクセス権の確認
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), accessreq -&gt; supported, accessrights
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、accessreq-&gt;サポート、アクセス権
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     const ACCESS4_READ      = 0x00000001;
     const ACCESS4_LOOKUP    = 0x00000002;
     const ACCESS4_MODIFY    = 0x00000004;
     const ACCESS4_EXTEND    = 0x00000008;
     const ACCESS4_DELETE    = 0x00000010;
     const ACCESS4_EXECUTE   = 0x00000020;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct ACCESS4args {
             /* CURRENT_FH: object */
             uint32_t        access;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct ACCESS4resok {
             uint32_t        supported;
             uint32_t        access;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union ACCESS4res switch (nfsstat4 status) {
      case NFS4_OK:
              ACCESS4resok   resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS determines the access rights that a user, as identified by the credentials in the RPC request, has with respect to the file system object specified by the current filehandle. The client encodes the set of access rights that are to be checked in the bit mask &#34;access&#34;. The server checks the permissions encoded in the bit mask. If a status of NFS4_OK is returned, two bit masks are included in the response. The first, &#34;supported&#34;, represents the access rights for which the server can verify reliably. The second, &#34;access&#34;, represents the access rights available to the user for the filehandle provided. On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESSは、RPC要求の資格情報によって識別されるように、ユーザーが現在のファイルハンドルで指定されたファイルシステムオブジェクトに対して持つアクセス権を決定します。クライアントは、ビットマスク「アクセス」でチェックされるアクセス権のセットをエンコードします。サーバーは、ビットマスクにエンコードされたアクセス許可をチェックします。 NFS4_OKのステータスが返された場合、2つのビットマスクが応答に含まれます。最初の「サポートされる」は、サーバーが確実に検証できるアクセス権を表します。 2番目の「アクセス」は、提供されたファイルハンドルに対してユーザーが利用できるアクセス権を表します。成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the supported field will contain only as many values as were originally sent in the arguments. For example, if the client sends an ACCESS operation with only the ACCESS4_READ value set and the server supports this value, the server will return only ACCESS4_READ even if it could have reliably checked other values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サポートされるフィールドには、最初に引数で送信されたのと同じ数の値のみが含まれることに注意してください。たとえば、クライアントがACCESS4_READ値のみを設定してACCESS操作を送信し、サーバーがこの値をサポートしている場合、サーバーは他の値を確実にチェックできたとしてもACCESS4_READのみを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The results of this operation are necessarily advisory in nature. A return status of NFS4_OK and the appropriate bit set in the bit mask does not imply that such access will be allowed to the file system object in the future. This is because access rights can be revoked by the server at any time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作の結果は、必然的に助言です。 NFS4_OKの戻りステータスとビットマスクに設定された適切なビットは、そのようなアクセスが将来ファイルシステムオブジェクトに許可されることを意味しません。これは、サーバーがいつでもアクセス権を取り消すことができるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following access permissions may be requested:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のアクセス許可が要求される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_READ Read data from file or read a directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_READファイルからデータを読み取るか、ディレクトリを読み取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_LOOKUP Look up a name in a directory (no meaning for non-directory objects).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_LOOKUPディレクトリで名前を検索します（ディレクトリ以外のオブジェクトには意味がありません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_MODIFY Rewrite existing file data or modify existing directory entries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_MODIFY既存のファイルデータを書き換えるか、既存のディレクトリエントリを変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_EXTEND Write new data or add directory entries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_EXTEND新しいデータを書き込むか、ディレクトリエントリを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_DELETE Delete an existing directory entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_DELETE既存のディレクトリエントリを削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_EXECUTE Execute file (no meaning for a directory).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_EXECUTEファイルを実行します（ディレクトリには意味がありません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, it is not sufficient for the client to attempt to deduce access permissions by inspecting the uid, gid, and mode fields in the file attributes or by attempting to interpret the contents of the ACL attribute. This is because the server may perform uid or gid mapping or enforce additional access control restrictions. It is also possible that the server may not be in the same ID space as the client. In these cases (and perhaps others), the client can not reliably perform an access check with only current file attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般に、クライアントがファイル属性のuid、gid、およびmodeフィールドを調べたり、ACL属性の内容を解釈したりして、アクセス許可を推測するだけでは不十分です。これは、サーバーがuidまたはgidマッピングを実行したり、追加のアクセス制御制限を適用したりする可能性があるためです。また、サーバーがクライアントと同じIDスペースにない場合もあります。これらのケース（およびおそらく他のケース）では、クライアントは現在のファイル属性のみではアクセスチェックを確実に実行できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In the NFS version 2 protocol, the only reliable way to determine whether an operation was allowed was to try it and see if it succeeded or failed. Using the ACCESS operation in the NFS version 4 protocol, the client can ask the server to indicate whether or not one or more classes of operations are permitted. The ACCESS operation is provided to allow clients to check before doing a series of operations which will result in an access failure. The OPEN operation provides a point where the server can verify access to the file object and method to return that information to the client. The ACCESS operation is still useful for directory operations or for use in the case the UNIX API &#34;access&#34; is used on the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFSバージョン2プロトコルでは、操作が許可されているかどうかを判断する信頼できる唯一の方法は、操作を試行して、操作が成功したか失敗したかを確認することでした。クライアントは、NFSバージョン4プロトコルでACCESS操作を使用して、1つ以上のクラスの操作が許可されているかどうかをサーバーに要求することができます。 ACCESS操作は、クライアントがアクセス障害を引き起こす一連の操作を実行する前に確認できるようにするために提供されています。 OPEN操作は、サーバーがファイルオブジェクトへのアクセスを確認できるポイントと、その情報をクライアントに返すメソッドを提供します。 ACCESS操作は、ディレクトリ操作や、UNIX APIの「アクセス」がクライアントで使用されている場合に使用する場合にも役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The information returned by the server in response to an ACCESS call is not permanent. It was correct at the exact time that the server performed the checks, but not necessarily afterwards. The server can revoke access permission at any time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS呼び出しへの応答としてサーバーから返される情報は永続的なものではありません。サーバーがチェックを実行した正確な時点で正しかったが、必ずしもその後ではなかった。サーバーはいつでもアクセス許可を取り消すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client should use the effective credentials of the user to build the authentication information in the ACCESS request used to determine access rights. It is the effective user and group credentials that are used in subsequent read and write operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、ユーザーの有効な資格情報を使用して、アクセス権を決定するために使用されるACCESSリクエストで認証情報を構築する必要があります。これは、後続の読み取りおよび書き込み操作で使用される有効なユーザーおよびグループの資格情報です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many implementations do not directly support the ACCESS4_DELETE permission. Operating systems like UNIX will ignore the ACCESS4_DELETE bit if set on an access request on a non-directory object. In these systems, delete permission on a file is determined by the access permissions on the directory in which the file resides, instead of being determined by the permissions of the file itself. Therefore, the mask returned enumerating which access rights can be determined will have the ACCESS4_DELETE value set to 0. This indicates to the client that the server was unable to check that particular access right. The ACCESS4_DELETE bit in the access mask returned will then be ignored by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くの実装では、ACCESS4_DELETE権限を直接サポートしていません。 UNIXなどのオペレーティングシステムは、非ディレクトリオブジェクトに対するアクセス要求で設定されている場合、ACCESS4_DELETEビットを無視します。これらのシステムでは、ファイルの削除権限は、ファイル自体の権限ではなく、ファイルが存在するディレクトリへのアクセス権限によって決定されます。したがって、決定できるアクセス権を列挙して返されたマスクでは、ACCESS4_DELETE値が0に設定されます。これは、サーバーがその特定のアクセス権をチェックできなかったことをクライアントに示します。返されたアクセスマスクのACCESS4_DELETEビットは、クライアントによって無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-2--Operation-4-CLOSE---Close-File">
14.2.2. Operation 4: CLOSE - Close File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.2. 操作4：CLOSE-ファイルを閉じる
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), seqid, open_stateid -&gt; open_stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、seqid、open_stateid-&gt; open_stateid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct CLOSE4args {
             /* CURRENT_FH: object */
             seqid4          seqid
             stateid4        open_stateid;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union CLOSE4res switch (nfsstat4 status) {
      case NFS4_OK:
              stateid4       open_stateid;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CLOSE operation releases share reservations for the regular or named attribute file as specified by the current filehandle. The share reservations and other state information released at the server as a result of this CLOSE is only associated with the supplied stateid. The sequence id provides for the correct ordering. State associated with other OPENs is not affected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSE操作は、現在のファイルハンドルで指定された通常または名前付きの属性ファイルの共有予約を解放します。このCLOSEの結果としてサーバーで解放された共有予約およびその他の状態情報は、指定されたstateidにのみ関連付けられます。シーケンスIDは正しい順序を提供します。他のOPENに関連する状態は影響を受けません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If record locks are held, the client SHOULD release all locks before issuing a CLOSE. The server MAY free all outstanding locks on CLOSE but some servers may not support the CLOSE of a file that still has record locks held. The server MUST return failure if any locks would exist after the CLOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レコードロックが保持されている場合、クライアントはCLOSEを発行する前にすべてのロックを解放する必要があります（SHOULD）。サーバーはCLOSEのすべての未処理のロックを解放してもよい（MAY）が、一部のサーバーは、まだレコードロックが保持されているファイルのCLOSEをサポートしない場合があります。 CLOSEの後にロックが存在する場合、サーバーは失敗を返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even though CLOSE returns a stateid, this stateid is not useful to the client and should be treated as deprecated. CLOSE &#34;shuts down&#34; the state associated with all OPENs for the file by a single open_owner. As noted above, CLOSE will either release all file locking state or return an error. Therefore, the stateid returned by CLOSE is not useful for operations that follow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSEはstateidを返しますが、このstateidはクライアントには役立ちません。非推奨として扱う必要があります。 CLOSEは、単一のopen_ownerによるファイルのすべてのOPENに関連付けられた状態を「シャットダウン」します。上記のように、CLOSEはすべてのファイルロック状態を解除するか、エラーを返します。したがって、CLOSEによって返される状態IDは、その後の操作には役立ちません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCKS_HELD NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCKS_HELD NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-3--Operation-5-COMMIT---Commit-Cached-Data">
14.2.3. Operation 5: COMMIT - Commit Cached Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.3. 操作5：COMMIT-キャッシュデータのコミット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), offset, count -&gt; verifier
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、オフセット、カウント-&gt;検証
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct COMMIT4args {
             /* CURRENT_FH: file */
             offset4         offset;
             count4          count;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct COMMIT4resok {
             verifier4       writeverf;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union COMMIT4res switch (nfsstat4 status) {
      case NFS4_OK:
              COMMIT4resok   resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMMIT operation forces or flushes data to stable storage for the file specified by the current filehandle. The flushed data is that which was previously written with a WRITE operation which had the stable field set to UNSTABLE4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMIT操作は、現在のファイルハンドルで指定されたファイルのデータを強制的に保存するか、安定したストレージにフラッシュします。フラッシュされたデータは、安定したフィールドがUNSTABLE4に設定されたWRITE操作で以前に書き込まれたデータです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The offset specifies the position within the file where the flush is to begin. An offset value of 0 (zero) means to flush data starting at the beginning of the file. The count specifies the number of bytes of data to flush. If count is 0 (zero), a flush from offset to the end of the file is done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オフセットは、フラッシュを開始するファイル内の位置を指定します。オフセット値0（ゼロ）は、ファイルの先頭からデータをフラッシュすることを意味します。カウントは、フラッシュするデータのバイト数を指定します。 countが0（ゼロ）の場合、オフセットからファイルの最後までのフラッシュが行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server returns a write verifier upon successful completion of the COMMIT. The write verifier is used by the client to determine if the server has restarted or rebooted between the initial WRITE(s) and the COMMIT. The client does this by comparing the write verifier returned from the initial writes and the verifier returned by the COMMIT operation. The server must vary the value of the write verifier at each server event or instantiation that may lead to a loss of uncommitted data. Most commonly this occurs when the server is rebooted; however, other events at the server may result in uncommitted data loss as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMITが正常に完了すると、サーバーは書き込みベリファイアを返します。クライアントが書き込みベリファイアを使用して、サーバーが最初のWRITEとCOMMITの間に再起動または再起動したかどうかを判断します。クライアントは、最初の書き込みから返された書き込みベリファイアとCOMMIT操作によって返されたベリファイアを比較することにより、これを行います。サーバーは、コミットされていないデータの損失につながる可能性のあるサーバーイベントまたはインスタンス化ごとに、書き込みベリファイアの値を変更する必要があります。最も一般的には、これはサーバーの再起動時に発生します。ただし、サーバーで他のイベントが発生すると、コミットされていないデータが失われる可能性もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMMIT operation is similar in operation and semantics to the POSIX fsync(2) system call that synchronizes a file&#39;s state with the disk (file data and metadata is flushed to disk or stable storage). COMMIT performs the same operation for a client, flushing any unsynchronized data and metadata on the server to the server&#39;s disk or stable storage for the specified file. Like fsync(2), it may be that there is some modified data or no modified data to synchronize. The data may have been synchronized by the server&#39;s normal periodic buffer synchronization activity. COMMIT should return NFS4_OK, unless there has been an unexpected error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMIT操作の操作とセマンティクスは、ファイルの状態をディスクと同期するPOSIX fsync（2）システムコールと似ています（ファイルデータとメタデータはディスクまたは安定したストレージにフラッシュされます）。 COMMITはクライアントに対して同じ操作を実行し、サーバー上の同期されていないデータとメタデータをサーバーのディスクまたは指定されたファイルの安定したストレージにフラッシュします。 fsync（2）と同様に、同期する変更されたデータがあるか、変更されたデータがない可能性があります。データは、サーバーの通常の定期的なバッファー同期アクティビティによって同期された可能性があります。予期しないエラーが発生していない限り、COMMITはNFS4_OKを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMIT differs from fsync(2) in that it is possible for the client to flush a range of the file (most likely triggered by a buffer-reclamation scheme on the client before file has been completely written).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMITは、クライアントがファイルの範囲をフラッシュすることができるという点でfsync（2）とは異なります（ファイルが完全に書き込まれる前に、クライアントのバッファ再利用スキームによってトリガーされる可能性が高いです）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The server implementation of COMMIT is reasonably simple. If the server receives a full file COMMIT request, that is starting at offset 0 and count 0, it should do the equivalent of fsync()&#39;ing the file. Otherwise, it should arrange to have the cached data in the range specified by offset and count to be flushed to stable storage. In both cases, any metadata associated with the file must be flushed to stable storage before returning. It is not an error for there to be nothing to flush on the server. This means that the data and metadata that needed to be flushed have already been flushed or lost during the last server failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
COMMITのサーバー実装はかなり単純です。サーバーがオフセット0とカウント0から始まる完全なファイルCOMMIT要求を受信した場合、サーバーはファイルのfsync()を実行するのと同じことを行う必要があります。それ以外の場合は、キャッシュされたデータをオフセットとカウントで指定された範囲にして、安定したストレージにフラッシュするように調整する必要があります。どちらの場合も、ファイルに関連付けられているメタデータは、戻る前に安定したストレージにフラッシュする必要があります。サーバー上でフラッシュするものが何もないことはエラーではありません。つまり、フラッシュする必要があったデータとメタデータは、最後のサーバー障害時にすでにフラッシュされているか、失われています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client implementation of COMMIT is a little more complex. There are two reasons for wanting to commit a client buffer to stable storage. The first is that the client wants to reuse a buffer. In this case, the offset and count of the buffer are sent to the server in the COMMIT request. The server then flushes any cached data based on the offset and count, and flushes any metadata associated with the file. It then returns the status of the flush and the write verifier. The other reason for the client to generate a COMMIT is for a full file flush, such as may be done at close. In this case, the client would gather all of the buffers for this file that contain uncommitted data, do the COMMIT operation with an offset of 0 and count of 0, and then free all of those buffers. Any other dirty buffers would be sent to the server in the normal fashion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMITのクライアント実装はもう少し複雑です。クライアントバッファを安定したストレージにコミットする理由は2つあります。 1つ目は、クライアントがバッファを再利用することです。この場合、バッファのオフセットとカウントは、COMMITリクエストでサーバーに送信されます。次に、サーバーはオフセットとカウントに基づいてキャッシュされたデータをフラッシュし、ファイルに関連付けられているメタデータをフラッシュします。次に、フラッシュと書き込みベリファイアのステータスを返します。クライアントがCOMMITを生成するもう1つの理由は、クローズ時に実行されるなど、ファイル全体をフラッシュするためです。この場合、クライアントは、コミットされていないデータを含むこのファイルのすべてのバッファーを収集し、オフセット0とカウント0でCOMMIT操作を実行してから、それらのバッファーをすべて解放します。他のダーティバッファは通常の方法でサーバーに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After a buffer is written by the client with the stable parameter set to UNSTABLE4, the buffer must be considered as modified by the client until the buffer has either been flushed via a COMMIT operation or written via a WRITE operation with stable parameter set to FILE_SYNC4 or DATA_SYNC4. This is done to prevent the buffer from being freed and reused before the data can be flushed to stable storage on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安定したパラメータをUNSTABLE4に設定してクライアントによってバッファが書き込まれた後、COMMIT操作を介してバッファがフラッシュされるか、安定したパラメータをFILE_SYNC4に設定したWRITE操作を介して書き込まれるまで、バッファはクライアントによって変更されたと見なされる必要があります。 DATA_SYNC4。これは、サーバー上の安定したストレージにデータをフラッシュする前に、バッファーが解放されて再利用されるのを防ぐために行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a response is returned from either a WRITE or a COMMIT operation and it contains a write verifier that is different than previously returned by the server, the client will need to retransmit all of the buffers containing uncommitted cached data to the server. How this is to be done is up to the implementor. If there is only one buffer of interest, then it should probably be sent back over in a WRITE request with the appropriate stable parameter. If there is more than one buffer, it might be worthwhile retransmitting all of the buffers in WRITE requests with the stable parameter set to UNSTABLE4 and then retransmitting the COMMIT operation to flush all of the data on the server to stable storage. The timing of these retransmissions is left to the implementor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
書き込み操作またはCOMMIT操作から応答が返され、サーバーから以前に返されたものとは異なる書き込みベリファイアが含まれている場合、クライアントは、コミットされていないキャッシュデータを含むすべてのバッファーをサーバーに再送信する必要があります。これをどのように行うかは、実装者次第です。対象となるバッファが1つしかない場合は、適切な安定したパラメータを指定して、WRITEリクエストで送信する必要があります。複数のバッファがある場合、stableパラメータをUNSTABLE4に設定してWRITEリクエストですべてのバッファを再送信し、次にCOMMIT操作を再送信して、サーバー上のすべてのデータを安定したストレージにフラッシュします。これらの再送信のタイミングは実装者に任されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above description applies to page-cache-based systems as well as buffer-cache-based systems. In those systems, the virtual memory system will need to be modified instead of the buffer cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の説明は、ページキャッシュベースのシステムとバッファキャッシュベースのシステムに適用されます。これらのシステムでは、バッファキャッシュの代わりに仮想メモリシステムを変更する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-4--Operation-6-CREATE---Create-a-Non-Regular-File-Object">
14.2.4. Operation 6: CREATE - Create a Non-Regular File Object
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.4. 操作6：作成-通常以外のファイルオブジェクトを作成する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), name, type, attrs -&gt; (cfh), change_info, attrs_set
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、名前、タイプ、attrs-&gt;（cfh）、change_info、attrs_set
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union createtype4 switch (nfs_ftype4 type) {
      case NF4LNK:
              linktext4      linkdata;
      case NF4BLK:
      case NF4CHR:
              specdata4      devdata;
      case NF4SOCK:
      case NF4FIFO:
      case NF4DIR:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct CREATE4args {
             /* CURRENT_FH: directory for creation */
             createtype4     objtype;
             component4      objname;
             fattr4          createattrs;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct CREATE4resok {
             change_info4    cinfo;
             bitmap4         attrset;        /* attributes set */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union CREATE4res switch (nfsstat4 status) {
      case NFS4_OK:
              CREATE4resok resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CREATE operation creates a non-regular file object in a directory with a given name. The OPEN operation MUST be used to create a regular file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CREATE操作は、指定された名前のディレクトリに通常でないファイルオブジェクトを作成します。通常のファイルを作成するには、OPEN操作を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The objname specifies the name for the new object. The objtype determines the type of object to be created: directory, symlink, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
objnameは、新しいオブジェクトの名前を指定します。 objtypeは、作成されるオブジェクトのタイプ（ディレクトリ、シンボリックリンクなど）を決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an object of the same name already exists in the directory, the server will return the error NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じ名前のオブジェクトがディレクトリにすでに存在する場合、サーバーはエラーNFS4ERR_EXISTを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the directory where the new file object was created, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the file object creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいファイルオブジェクトが作成されたディレクトリの場合、サーバーはchange_info4情報をcinfoに返します。 change_info4構造体のアトミックフィールドを使用すると、サーバーは、変更前と変更後の属性がファイルオブジェクトの作成に関してアトミックに取得されたかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the objname has a length of 0 (zero), or if objname does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
objnameの長さが0（ゼロ）である場合、またはobjnameがUTF-8定義に従っていない場合、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current filehandle is replaced by that of the new object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルは、新しいオブジェクトのファイルハンドルに置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The createattrs specifies the initial set of attributes for the object. The set of attributes may include any writable attribute valid for the object type. When the operation is successful, the server will return to the client an attribute mask signifying which attributes were successfully set for the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
createattrsは、オブジェクトの属性の初期セットを指定します。属性のセットには、オブジェクトタイプに有効な書き込み可能な属性を含めることができます。操作が成功すると、サーバーは、オブジェクトにどの属性が正常に設定されたかを示す属性マスクをクライアントに返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If createattrs includes neither the owner attribute nor an ACL with an ACE for the owner, and if the server&#39;s filesystem both supports and requires an owner attribute (or an owner ACE) then the server MUST derive the owner (or the owner ACE). This would typically be from the principal indicated in the RPC credentials of the call, but the server&#39;s operating environment or filesystem semantics may dictate other methods of derivation. Similarly, if createattrs includes neither the group attribute nor a group ACE, and if the server&#39;s filesystem both supports and requires the notion of a group attribute (or group ACE), the server MUST derive the group attribute (or the corresponding owner ACE) for the file. This could be from the RPC call&#39;s credentials, such as the group principal if the credentials include it (such as with AUTH_SYS), from the group identifier associated with the principal in the credentials (for e.g., POSIX systems have a passwd database that has the group identifier for every user identifier), inherited from directory the object is created in, or whatever else the server&#39;s operating environment or filesystem semantics dictate. This applies to the OPEN operation too.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
createattrsに所有者属性も、所有者のACEを含むACLも含まれておらず、サーバーのファイルシステムが所有者属性（または所有者ACE）をサポートおよび要求している場合、サーバーは所有者（または所有者ACE）を導出する必要があります。これは通常、呼び出しのRPC資格情報に示されているプリンシパルからのものですが、サーバーの動作環境またはファイルシステムのセマンティクスによって、他の派生方法が決まる場合があります。同様に、createattrsにグループ属性もグループACEも含まれておらず、サーバーのファイルシステムがグループ属性（またはグループACE）の概念をサポートおよび要求している場合、サーバーは、グループ属性（または対応する所有者ACE）を導出する必要があります。ファイル。これは、RPC呼び出しの資格情報（資格情報に含まれている場合（AUTH_SYSなど）の場合はグループプリンシパルなど）から、資格情報のプリンシパルに関連付けられているグループ識別子から（たとえば、POSIXシステムには、すべてのユーザー識別子のグループ識別子）、オブジェクトが作成されたディレクトリから継承されたもの、またはサーバーの動作環境やファイルシステムのセマンティクスで指定されたもの。これは、OPEN操作にも適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Conversely, it is possible the client will specify in createattrs an owner attribute or group attribute or ACL that the principal indicated the RPC call&#39;s credentials does not have permissions to create files for. The error to be returned in this instance is NFS4ERR_PERM. This applies to the OPEN operation too.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
逆に、RPC呼び出しの資格情報にファイルを作成するためのアクセス許可がないことをプリンシパルが示した所有者属性またはグループ属性またはACLを、クライアントがcreateattrsで指定する可能性があります。このインスタンスで返されるエラーはNFS4ERR_PERMです。これは、OPEN操作にも適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client desires to set attribute values after the create, a SETATTR operation can be added to the COMPOUND request so that the appropriate attributes will be set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが作成後に属性値を設定することを望む場合、適切な属性が設定されるように、SETATTR操作をCOMPOUND要求に追加できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ATTRNOTSUPP NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADOWNER NFS4ERR_BADTYPE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_PERM NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ATTRNOTSUPP NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADOWNER NFS4ERR_BADTYPE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_PERM NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-5--Operation-7-DELEGPURGE---Purge-Delegations-Awaiting-Recovery">
14.2.5. Operation 7: DELEGPURGE - Purge Delegations Awaiting Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.5. 操作7：DELEGPURGE-回復を待機している委任のパージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
clientid -&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
clientid-&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct DELEGPURGE4args {
             clientid4       clientid;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct DELEGPURGE4res {
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Purges all of the delegations awaiting recovery for a given client. This is useful for clients which do not commit delegation information to stable storage to indicate that conflicting requests need not be delayed by the server awaiting recovery of delegation information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のクライアントの回復を待っているすべての代表団をパージします。これは、委託情報を安定したストレージにコミットしないクライアントが、委託情報の回復を待機しているサーバーが競合する要求を遅らせる必要がないことを示すのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation should be used by clients that record delegation information on stable storage on the client. In this case, DELEGPURGE should be issued immediately after doing delegation recovery on all delegations known to the client. Doing so will notify the server that no additional delegations for the client will be recovered allowing it to free resources, and avoid delaying other clients who make requests that conflict with the unrecovered delegations. The set of delegations known to the server and the client may be different. The reason for this is that a client may fail after making a request which resulted in delegation but before it received the results and committed them to the client&#39;s stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、クライアントの安定したストレージに委任情報を記録するクライアントが使用する必要があります。この場合、クライアントに既知のすべての委任に対して委任リカバリーを実行した直後に、DELEGPURGEを発行する必要があります。これにより、クライアントの追加の委任が回復されずにリソースを解放できることがサーバーに通知され、回復されていない委任と競合する要求を行う他のクライアントの遅延が回避されます。サーバーとクライアントが認識している委任のセットは異なる場合があります。これは、委任の原因となった要求を行った後、結果を受信して​​クライアントの安定したストレージにコミットする前に、クライアントが失敗する可能性があるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MAY support DELEGPURGE, but if it does not, it MUST NOT support CLAIM_DELEGATE_PREV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはDELEGPURGEをサポートする場合がありますが、サポートしない場合は、CLAIM_DELEGATE_PREVをサポートしてはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 NFS4ERR_BADXDR NFS4ERR_NOTSUPP NFS4ERR_LEASE_MOVED NFS4ERR_MOVED NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE_CLIENTID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFS4ERR_BADXDR NFS4ERR_NOTSUPP NFS4ERR_LEASE_MOVED NFS4ERR_MOVED NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE_CLIENTID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-6--Operation-8-DELEGRETURN---Return-Delegation">
14.2.6. Operation 8: DELEGRETURN - Return Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.6. 操作8：DELEGRETURN-委任を返す
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), stateid -&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、stateid-&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct DELEGRETURN4args {
             /* CURRENT_FH: delegated file */
             stateid4        stateid;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct DELEGRETURN4res {
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Returns the delegation represented by the current filehandle and stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルと状態IDによって表される委任を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Delegations may be returned when recalled or voluntarily (i.e., before the server has recalled them). In either case the client must properly propagate state changed under the context of the delegation to the server before returning the delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任は、リコールされたとき、または自発的に（つまり、サーバーがリコールする前に）返される場合があります。どちらの場合でも、クライアントは、委任を返す前に、委任のコンテキストで変更された状態をサーバーに適切に伝達する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ADMIN_REVOKED NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_EXPIRED NFS4ERR_INVAL NFS4ERR_LEASE_MOVED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOTSUPP NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ADMIN_REVOKED NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_EXPIRED NFS4ERR_INVAL NFS4ERR_LEASE_MOVED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOTSUPP NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERSTALE NFSERR_SERVERSTALE NFSERR_4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-7--Operation-9-GETATTR---Get-Attributes">
14.2.7. Operation 9: GETATTR - Get Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.7. 操作9：GETATTR-属性の取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), attrbits -&gt; attrbits, attrvals
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、attrbits-&gt; attrbits、attrvals
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct GETATTR4args {
             /* CURRENT_FH: directory or file */
             bitmap4         attr_request;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct GETATTR4resok {
             fattr4          obj_attributes;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union GETATTR4res switch (nfsstat4 status) {
      case NFS4_OK:
              GETATTR4resok  resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The GETATTR operation will obtain attributes for the filesystem object specified by the current filehandle. The client sets a bit in the bitmap argument for each attribute value that it would like the server to return. The server returns an attribute bitmap that indicates the attribute values for which it was able to return, followed by the attribute values ordered lowest attribute number first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETATTR操作は、現在のファイルハンドルによって指定されたファイルシステムオブジェクトの属性を取得します。クライアントは、サーバーが返す各属性値のビットマップ引数にビットを設定します。サーバーは、返すことができた属性値を示す属性ビットマップを返し、次に属性値が最も小さい属性番号の順に並べられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server must return a value for each attribute that the client requests if the attribute is supported by the server. If the server does not support an attribute or cannot approximate a useful value then it must not return the attribute value and must not set the attribute bit in the result bitmap. The server must return an error if it supports an attribute but cannot obtain its value. In that case no attribute values will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが属性をサポートしている場合、サーバーはクライアントが要求する各属性の値を返す必要があります。サーバーが属性をサポートしていないか、有用な値を概算できない場合、サーバーは属性値を返してはならず、結果のビットマップに属性ビットを設定してはなりません。属性をサポートしていてもその値を取得できない場合、サーバーはエラーを返す必要があります。その場合、属性値は返されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All servers must support the mandatory attributes as specified in the section &#34;File Attributes&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのサーバーは、「ファイル属性」セクションで指定されている必須属性をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-8--Operation-10-GETFH---Get-Current-Filehandle">
14.2.8. Operation 10: GETFH - Get Current Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.8. 操作10：GETFH-現在のファイルハンドルを取得する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) -&gt; filehandle
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）-&gt;ファイルハンドル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* CURRENT_FH: */
     void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct GETFH4resok {
             nfs_fh4         object;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union GETFH4res switch (nfsstat4 status) {
      case NFS4_OK:
             GETFH4resok     resok4;
      default:
             void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation returns the current filehandle value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、現在のファイルハンドル値を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Operations that change the current filehandle like LOOKUP or CREATE do not automatically return the new filehandle as a result. For instance, if a client needs to lookup a directory entry and obtain its filehandle then the following request is needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOOKUPやCREATEなどの現在のファイルハンドルを変更する操作は、結果として新しいファイルハンドルを自動的に返しません。たとえば、クライアントがディレクトリエントリを検索してそのファイルハンドルを取得する必要がある場合は、次のリクエストが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PUTFH (directory filehandle) LOOKUP (entry name) GETFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PUTFH（ディレクトリファイルハンドル）LOOKUP（エントリ名）GETFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-9--Operation-11-LINK---Create-Link-to-a-File">
14.2.9. Operation 11: LINK - Create Link to a File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.9. 操作11：リンク-ファイルへのリンクを作成する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(sfh), (cfh), newname -&gt; (cfh), change_info
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（sfh）、（cfh）、newname-&gt;（cfh）、change_info
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LINK4args {
             /* SAVED_FH: source object */
             /* CURRENT_FH: target directory */
             component4      newname;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LINK4resok {
             change_info4    cinfo;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union LINK4res switch (nfsstat4 status) {
      case NFS4_OK:
              LINK4resok resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LINK operation creates an additional newname for the file represented by the saved filehandle, as set by the SAVEFH operation, in the directory represented by the current filehandle. The existing file and the target directory must reside within the same filesystem on the server. On success, the current filehandle will continue to be the target directory. If an object exists in the target directory with the same name as newname, the server must return NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LINK操作は、SAVEFH操作で設定された、保存されたファイルハンドルで表されるファイルの追加の新しい名前を、現在のファイルハンドルで表されるディレクトリに作成します。既存のファイルとターゲットディレクトリは、サーバー上の同じファイルシステム内に存在する必要があります。成功した場合、現在のファイルハンドルは引き続きターゲットディレクトリになります。 newnameと同じ名前のオブジェクトがターゲットディレクトリに存在する場合、サーバーはNFS4ERR_EXISTを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the target directory, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the link creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットディレクトリの場合、サーバーはchange_info4情報をcinfoに返します。 change_info4構造体のアトミックフィールドを使用すると、サーバーは、リンクの作成に関して変更前と変更後の属性がアトミックに取得されたかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the newname has a length of 0 (zero), or if newname does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
newnameの長さが0（ゼロ）である場合、またはnewnameがUTF-8定義に従っていない場合、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Changes to any property of the &#34;hard&#34; linked files are reflected in all of the linked files. When a link is made to a file, the attributes for the file should have a value for numlinks that is one greater than the value before the LINK operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「ハード」リンクファイルのプロパティへの変更は、すべてのリンクファイルに反映されます。ファイルへのリンクが作成されるとき、ファイルの属性には、リンク操作前の値よりも1大きいnumlinksの値が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The statement &#34;file and the target directory must reside within the same filesystem on the server&#34; means that the fsid fields in the attributes for the objects are the same. If they reside on different filesystems, the error, NFS4ERR_XDEV, is returned. On some servers, the filenames, &#34;.&#34; and &#34;..&#34;, are illegal as newname.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「ファイルとターゲットディレクトリはサーバー上の同じファイルシステム内に存在する必要がある」というステートメントは、オブジェクトの属性のfsidフィールドが同じであることを意味します。それらが異なるファイルシステムに存在する場合、エラーNFS4ERR_XDEVが返されます。一部のサーバーでは、ファイル名「。」および「..」は、newnameとしては不正です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that newname is already linked to the file represented by the saved filehandle, the server will return NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保存されたファイルハンドルによって表されるファイルにnewnameがすでにリンクされている場合、サーバーはNFS4ERR_EXISTを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that symbolic links are created with the CREATE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シンボリックリンクはCREATE操作で作成されることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 NFS4ERR_ACCESS NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_FHEXPIRED NFS4ERR_FILE_OPEN NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_MLINK NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC NFS4ERR_XDEV
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFS4ERR_ACCESS NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_FHEXPIRED NFS4ERR_FILE_OPEN NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_MLINK NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC NFS4ERR_XDEV
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-10--Operation-12-LOCK---Create-Lock">
14.2.10. Operation 12: LOCK - Create Lock
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.10. 操作12：LOCK-ロックの作成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) locktype, reclaim, offset, length, locker -&gt; stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）locktype、reclaim、offset、length、locker-&gt; stateid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct open_to_lock_owner4 {
             seqid4          open_seqid;
             stateid4        open_stateid;
             seqid4          lock_seqid;
             lock_owner4     lock_owner;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct exist_lock_owner4 {
             stateid4        lock_stateid;
             seqid4          lock_seqid;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union locker4 switch (bool new_lock_owner) {
      case TRUE:
             open_to_lock_owner4     open_owner;
      case FALSE:
             exist_lock_owner4       lock_owner;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     enum nfs_lock_type4 {
             READ_LT         = 1,
             WRITE_LT        = 2,
             READW_LT        = 3,    /* blocking read */
             WRITEW_LT       = 4     /* blocking write */
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LOCK4args {
             /* CURRENT_FH: file */
             nfs_lock_type4  locktype;
             bool            reclaim;
             offset4         offset;
             length4         length;
             locker4         locker;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LOCK4denied {
             offset4         offset;
             length4         length;
             nfs_lock_type4  locktype;
             lock_owner4     owner;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LOCK4resok {
             stateid4        lock_stateid;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union LOCK4res switch (nfsstat4 status) {
      case NFS4_OK:
              LOCK4resok     resok4;
      case NFS4ERR_DENIED:
              LOCK4denied    denied;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LOCK operation requests a record lock for the byte range specified by the offset and length parameters. The lock type is also specified to be one of the nfs_lock_type4s. If this is a reclaim request, the reclaim parameter will be TRUE;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK操作は、offsetパラメータとlengthパラメータで指定されたバイト範囲のレコードロックを要求します。ロックタイプもnfs_lock_type4sの1つとして指定されています。これが再利用リクエストの場合、再利用パラメーターはTRUEになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Bytes in a file may be locked even if those bytes are not currently allocated to the file. To lock the file from a specific offset through the end-of-file (no matter how long the file actually is) use a length field with all bits set to 1 (one). If the length is zero, or if a length which is not all bits set to one is specified, and length when added to the offset exceeds the maximum 64-bit unsigned integer value, the error NFS4ERR_INVAL will result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ファイル内のバイトは、それらのバイトが現在ファイルに割り当てられていなくてもロックされる場合があります。特定のオフセットからファイルの終わりまでファイルをロックするには（ファイルが実際にどのくらい長くても）、すべてのビットが1に設定された長さフィールドを使用します。長さがゼロの場合、またはすべてのビットが1に設定されていない長さが指定され、オフセットに追加されたときの長さが最大64ビットの符号なし整数値を超える場合、エラーNFS4ERR_INVALが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some servers may only support locking for byte offsets that fit within 32 bits. If the client specifies a range that includes a byte beyond the last byte offset of the 32-bit range, but does not include the last byte offset of the 32-bit and all of the byte offsets beyond it, up to the end of the valid 64-bit range, such a 32-bit server MUST return the error NFS4ERR_BAD_RANGE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のサーバーは、32ビット以内に収まるバイトオフセットのロックのみをサポートする場合があります。クライアントが32ビット範囲の最後のバイトオフセットを超えるバイトを含む範囲を指定するが、32ビットの最後のバイトオフセットとそれを超えるすべてのバイトオフセットを含まない場合、有効な64ビット範囲、そのような32ビットサーバーはエラーNFS4ERR_BAD_RANGEを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that the lock is denied, the owner, offset, and length of a conflicting lock are returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックが拒否された場合、競合するロックの所有者、オフセット、および長さが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server is unable to determine the exact offset and length of the conflicting lock, the same offset and length that were provided in the arguments should be returned in the denied results. The File Locking section contains a full description of this and the other file locking operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが競合するロックの正確なオフセットと長さを判別できない場合、引数で指定されたものと同じオフセットと長さが拒否された結果に返されます。 「ファイルのロック」セクションには、これとその他のファイルロック操作の詳細な説明が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK operations are subject to permission checks and to checks against the access type of the associated file. However, the specific right and modes required for various type of locks, reflect the semantics of the server-exported filesystem, and are not specified by the protocol. For example, Windows 2000 allows a write lock of a file open for READ, while a POSIX-compliant system does not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK操作は、権限チェックと、関連ファイルのアクセスタイプに対するチェックの対象となります。ただし、さまざまなタイプのロックに必要な特定の権限とモードは、サーバーでエクスポートされたファイルシステムのセマンティクスを反映しており、プロトコルでは指定されていません。たとえば、Windows 2000では、読み取り用に開いているファイルの書き込みロックが許可されていますが、POSIX準拠のシステムでは許可されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When the client makes a lock request that corresponds to a range that the lockowner has locked already (with the same or different lock type), or to a sub-region of such a range, or to a region which includes multiple locks already granted to that lockowner, in whole or in part, and the server does not support such locking operations (i.e., does not support POSIX locking semantics), the server will return the error NFS4ERR_LOCK_RANGE. In that case, the client may return an error, or it may emulate the required operations, using only LOCK for ranges that do not include any bytes already locked by that lock_owner and LOCKU of locks held by that lock_owner (specifying an exactly-matching range and type). Similarly, when the client makes a lock request that amounts to upgrading (changing from a read lock to a write lock) or downgrading (changing from write lock to a read lock) an existing record lock, and the server does not support such a lock, the server will return NFS4ERR_LOCK_NOTSUPP. Such operations may not perfectly reflect the required semantics in the face of conflicting lock requests from other clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントが、ロック所有者がすでにロックした（同じまたは異なるロックタイプで）範囲、またはそのような範囲のサブ領域、またはすでに許可されている複数のロックを含む領域に対応するロック要求を行ったときそのロック所有者の全体または一部であり、サーバーがそのようなロック操作をサポートしていない（つまり、POSIXロックセマンティクスをサポートしていない）場合、サーバーはエラーNFS4ERR_LOCK_RANGEを返します。その場合、クライアントはエラーを返すか、必要な操作をエミュレートし、そのlock_ownerによってすでにロックされているバイトとそのlock_ownerによって保持されているロックのLOCKUを含まない範囲のLOCKのみを使用します（完全に一致する範囲を指定します）およびタイプ）。同様に、クライアントが既存のレコードロックをアップグレード（読み取りロックから書き込みロックに変更）またはダウングレード（書き込みロックから読み取りロックに変更）するロック要求を作成し、サーバーがそのようなロックをサポートしていない場合、サーバーはNFS4ERR_LOCK_NOTSUPPを返します。このような操作は、他のクライアントからのロック要求の競合に直面して、必要なセマンティクスを完全に反映していない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The locker argument specifies the lock_owner that is associated with the LOCK request. The locker4 structure is a switched union that indicates whether the lock_owner is known to the server or if the lock_owner is new to the server. In the case that the lock_owner is known to the server and has an established lock_seqid, the argument is just the lock_owner and lock_seqid. In the case that the lock_owner is not known to the server, the argument contains not only the lock_owner and lock_seqid but also the open_stateid and open_seqid. The new lock_owner case covers the very first lock done by the lock_owner and offers a method to use the established state of the open_stateid to transition to the use of the lock_owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
locker引数は、LOCK要求に関連付けられているlock_ownerを指定します。 locker4構造は、lock_ownerがサーバーに認識されているかどうか、またはlock_ownerがサーバーに新しいかどうかを示すスイッチドユニオンです。 lock_ownerがサーバーに認識されていて、確立されたlock_seqidがある場合、引数は、lock_ownerとlock_seqidだけです。サーバーがlock_ownerを認識していない場合、引数には、lock_ownerとlock_seqidだけでなく、open_stateidとopen_seqidも含まれます。新しいlock_ownerケースは、lock_ownerによって行われた最初のロックをカバーし、open_stateidの確立された状態を使用して、lock_ownerの使用に移行するメソッドを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_RANGE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_DEADLOCK NFS4ERR_DELAY NFS4ERR_DENIED NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCK_NOTSUPP NFS4ERR_LOCK_RANGE NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NO_GRACE NFS4ERR_OLD_STATEID NFS4ERR_OPENMODE NFS4ERR_RECLAIM_BAD NFS4ERR_RECLAIM_CONFLICT NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_CLIENTID NFS4ERR_STALE_STATEID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_RANGE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_DEADLOCK NFS4ERR_DELAY NFS4ERR_DENIED NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCK_NOTSUPP NFS4ERR_LOCK_RANGE NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NO_GRACE NFS4ERR_OLD_STATEID NFS4ERR_OPENMODE NFS4ERR_RECLAIM_BAD NFS4ERR_RECLAIM_CONFLICT NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_CLIENTID NFS4ERR_STALE_STATEID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-11--Operation-13-LOCKT---Test-For-Lock">
14.2.11. Operation 13: LOCKT - Test For Lock
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.11. 操作13：LOCKT-ロックのテスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     (cfh) locktype, offset, length owner -&gt; {void, NFS4ERR_DENIED -&gt;
     owner}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LOCKT4args {
             /* CURRENT_FH: file */
             nfs_lock_type4  locktype;
             offset4         offset;
             length4         length;
             lock_owner4     owner;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LOCK4denied {
             offset4         offset;
             length4         length;
             nfs_lock_type4  locktype;
             lock_owner4     owner;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union LOCKT4res switch (nfsstat4 status) {
      case NFS4ERR_DENIED:
              LOCK4denied    denied;
      case NFS4_OK:
              void;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LOCKT operation tests the lock as specified in the arguments. If a conflicting lock exists, the owner, offset, length, and type of the conflicting lock are returned; if no lock is held, nothing other than NFS4_OK is returned. Lock types READ_LT and READW_LT are processed in the same way in that a conflicting lock test is done without regard to blocking or non-blocking. The same is true for WRITE_LT and WRITEW_LT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCKT操作は、引数で指定されたロックをテストします。競合するロックが存在する場合、競合するロックの所有者、オフセット、長さ、およびタイプが返されます。ロックが保持されていない場合、NFS4_OK以外は何も返されません。ロックタイプREAD_LTおよびREADW_LTは、ブロッキングまたは非ブロッキングに関係なく、競合するロックテストが実行されるという同じ方法で処理されます。 WRITE_LTおよびWRITEW_LTについても同様です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ranges are specified as for LOCK. The NFS4ERR_INVAL and NFS4ERR_BAD_RANGE errors are returned under the same circumstances as for LOCK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
範囲はLOCKの場合と同様に指定されます。 NFS4ERR_INVALおよびNFS4ERR_BAD_RANGEエラーは、LOCKの場合と同じ状況で返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server is unable to determine the exact offset and length of the conflicting lock, the same offset and length that were provided in the arguments should be returned in the denied results. The File Locking section contains further discussion of the file locking mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが競合するロックの正確なオフセットと長さを判別できない場合、引数で指定されたものと同じオフセットと長さが拒否された結果に返されます。ファイルロックのセクションでは、ファイルロックのメカニズムについて詳しく説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCKT uses a lock_owner4 rather a stateid4, as is used in LOCK to identify the owner. This is because the client does not have to open the file to test for the existence of a lock, so a stateid may not be available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCKTは、所有者を識別するためにLOCKで使用されるように、stateid4ではなく、lock_owner4を使用します。これは、クライアントがロックの存在をテストするためにファイルを開く必要がないため、stateidが使用できない場合があるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The test for conflicting locks should exclude locks for the current lockowner. Note that since such locks are not examined the possible existence of overlapping ranges may not affect the results of LOCKT. If the server does examine locks that match the lockowner for the purpose of range checking, NFS4ERR_LOCK_RANGE may be returned.. In the event that it returns NFS4_OK, clients may do a LOCK and receive NFS4ERR_LOCK_RANGE on the LOCK request because of the flexibility provided to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
競合するロックのテストでは、現在のロック所有者のロックを除外する必要があります。このようなロックは検査されないため、重複する範囲が存在しても、LOCKTの結果に影響しない可能性があることに注意してください。サーバーが範囲チェックの目的でロック所有者と一致するロックを検査する場合、NFS4ERR_LOCK_RANGEが返されることがあります。NFS4_OKを返す場合、クライアントはLOCKを実行し、LOCK要求でNFS4ERR_LOCK_RANGEを受信することがあります。サーバ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BAD_RANGE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DENIED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCK_RANGE NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_CLIENTID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BAD_RANGE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DENIED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCK_RANGE_ERR_ERR_NFS_ERRERR_NFS_ERRERR_NFS_ERRERR_NFS_ERRERR_NFS_ERR_ERR_NFS_ERR_ERR_NFS_ERR_ERR_NFS_ERR_ERR_NFS_ERR_ERR_NFS_ERR_ERR_NFS_ERR_ERR_NFS_ERR_ERR_NFS_ERR_ERR_NFS_ERR_ERR_NFS_ERR_ERR_NFS_ERRERR_NFS_ERRERR_NFS_ERRERR_NFS_ERRERR_NFS_ERR_FERR_N_FERR_NFS）_4の場合NFS4ERR_MOVED
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-12--Operation-14-LOCKU---Unlock-File">
14.2.12. Operation 14: LOCKU - Unlock File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.12. 操作14：LOCKU-ファイルのロック解除
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) type, seqid, stateid, offset, length -&gt; stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）type、seqid、stateid、offset、length-&gt; stateid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LOCKU4args {
             /* CURRENT_FH: file */
             nfs_lock_type4  locktype;
             seqid4          seqid;
             stateid4        stateid;
             offset4         offset;
             length4         length;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union LOCKU4res switch (nfsstat4 status) {
      case   NFS4_OK:
              stateid4       stateid;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LOCKU operation unlocks the record lock specified by the parameters. The client may set the locktype field to any value that is legal for the nfs_lock_type4 enumerated type, and the server MUST accept any legal value for locktype. Any legal value for locktype has no effect on the success or failure of the LOCKU operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCKU操作は、パラメーターで指定されたレコードロックをアンロックします。クライアントは、locktypeフィールドをnfs_lock_type4列挙型に有効な任意の値に設定できます。サーバーは、locktypeに有効な任意の値を受け入れる必要があります。 locktypeの正当な値は、LOCKU操作の成功または失敗には影響しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ranges are specified as for LOCK. The NFS4ERR_INVAL and NFS4ERR_BAD_RANGE errors are returned under the same circumstances as for LOCK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
範囲はLOCKの場合と同様に指定されます。 NFS4ERR_INVALおよびNFS4ERR_BAD_RANGEエラーは、LOCKの場合と同じ状況で返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If the area to be unlocked does not correspond exactly to a lock actually held by the lockowner the server may return the error NFS4ERR_LOCK_RANGE. This includes the case in which the area is not locked, where the area is a sub-range of the area locked, where it overlaps the area locked without matching exactly or the area specified includes multiple locks held by the lockowner. In all of these cases, allowed by POSIX locking semantics, a client receiving this error, should if it desires support for such operations, simulate the operation using LOCKU on ranges corresponding to locks it actually holds, possibly followed by LOCK requests for the sub-ranges not being unlocked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ロック解除される領域が、ロック所有者が実際に保持しているロックに正確に対応していない場合、サーバーはエラーNFS4ERR_LOCK_RANGEを返すことがあります。これには、領域がロックされていない場合、領域がロックされた領域のサブ範囲である場合、完全に一致せずにロックされた領域と重なる場合、または指定された領域にロック所有者が保持する複数のロックが含まれる場合が含まれます。これらのすべてのケースで、POSIXロックセマンティクスによって許可され、このエラーを受け取るクライアントは、そのような操作のサポートが必要な場合、実際に保持しているロックに対応する範囲でLOCKUを使用して操作をシミュレートし、その後にサブロック解除されていない範囲。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_RANGE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCK_RANGE NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_RANGE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCK_RANGE NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-13--Operation-15-LOOKUP---Lookup-Filename">
14.2.13. Operation 15: LOOKUP - Lookup Filename
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.13. 操作15：LOOKUP-ルックアップファイル名
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), component -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、コンポーネント-&gt;（cfh）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LOOKUP4args {
             /* CURRENT_FH: directory */
             component4      objname;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LOOKUP4res {
             /* CURRENT_FH: object */
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation LOOKUPs or finds a filesystem object using the directory specified by the current filehandle. LOOKUP evaluates the component and if the object exists the current filehandle is replaced with the component&#39;s filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、現在のファイルハンドルで指定されたディレクトリを使用してファイルシステムオブジェクトを検索または検索します。 LOOKUPはコンポーネントを評価し、オブジェクトが存在する場合、現在のファイルハンドルがコンポーネントのファイルハンドルに置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the component cannot be evaluated either because it does not exist or because the client does not have permission to evaluate the component, then an error will be returned and the current filehandle will be unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンポーネントが存在しないため、またはクライアントにコンポーネントを評価する権限がないためにコンポーネントを評価できない場合、エラーが返され、現在のファイルハンドルは変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the component is a zero length string or if any component does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンポーネントがゼロ長の文字列である場合、またはいずれかのコンポーネントがUTF-8定義に従っていない場合、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client wants to achieve the effect of a multi-component lookup, it may construct a COMPOUND request such as (and obtain each filehandle):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがマルチコンポーネントルックアップの効果を実現したい場合は、次のようなCOMPOUNDリクエストを作成します（各ファイルハンドルを取得します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PUTFH (directory filehandle) LOOKUP &#34;pub&#34; GETFH LOOKUP &#34;foo&#34; GETFH LOOKUP &#34;bar&#34; GETFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PUTFH（ディレクトリファイルハンドル）LOOKUP &#34;pub&#34; GETFH LOOKUP &#34;foo&#34; GETFH LOOKUP &#34;bar&#34; GETFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS version 4 servers depart from the semantics of previous NFS versions in allowing LOOKUP requests to cross mountpoints on the server. The client can detect a mountpoint crossing by comparing the fsid attribute of the directory with the fsid attribute of the directory looked up. If the fsids are different then the new directory is a server mountpoint. UNIX clients that detect a mountpoint crossing will need to mount the server&#39;s filesystem. This needs to be done to maintain the file object identity checking mechanisms common to UNIX clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4サーバーは、サーバー上のマウントポイントを横断するLOOKUP要求を許可するという点で、以前のNFSバージョンのセマンティクスから逸脱しています。クライアントは、ディレクトリのfsid属性と、検索されたディレクトリのfsid属性を比較することにより、マウントポイントの交差を検出できます。 fsidが異なる場合、新しいディレクトリはサーバーのマウントポイントです。マウントポイントの交差を検出するUNIXクライアントは、サーバーのファイルシステムをマウントする必要があります。これは、UNIXクライアントに共通のファイルオブジェクトIDチェックメカニズムを維持するために実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers that limit NFS access to &#34;shares&#34; or &#34;exported&#34; filesystems should provide a pseudo-filesystem into which the exported filesystems can be integrated, so that clients can browse the server&#39;s name space. The clients&#39; view of a pseudo filesystem will be limited to paths that lead to exported filesystems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSアクセスを「共有」または「エクスポートされた」ファイルシステムに制限するサーバーは、クライアントがサーバーの名前空間を参照できるように、エクスポートされたファイルシステムを統合できる疑似ファイルシステムを提供する必要があります。疑似ファイルシステムのクライアントのビューは、エクスポートされたファイルシステムにつながるパスに制限されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: previous versions of the protocol assigned special semantics to the names &#34;.&#34; and &#34;..&#34;. NFS version 4 assigns no special semantics to these names. The LOOKUPP operator must be used to lookup a parent directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：以前のバージョンのプロトコルでは、名前「。」に特別なセマンティクスが割り当てられていました。そして「..」。 NFSバージョン4は、これらの名前に特別なセマンティクスを割り当てません。親ディレクトリを検索するには、LOOKUPP演算子を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this operation does not follow symbolic links. The client is responsible for all parsing of filenames including filenames that are modified by symbolic links encountered during the lookup process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作はシンボリックリンクをたどらないことに注意してください。クライアントは、ルックアッププロセス中に検出されたシンボリックリンクによって変更されたファイル名を含むすべてのファイル名の解析を担当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle supplied is not a directory but a symbolic link, the error NFS4ERR_SYMLINK is returned as the error. For all other non-directory file types, the error NFS4ERR_NOTDIR is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
提供された現在のファイルハンドルがディレクトリではなくシンボリックリンクである場合、エラーNFS4ERR_SYMLINKがエラーとして返されます。他のすべての非ディレクトリファイルタイプの場合、エラーNFS4ERR_NOTDIRが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADXDR NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_SYMLINK NFS4ERR_WRONGSEC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADXDR NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_SYMLINK NFS4ERR_WRONGSEC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-14--Operation-16-LOOKUPP---Lookup-Parent-Directory">
14.2.14. Operation 16: LOOKUPP - Lookup Parent Directory
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.14. 操作16：LOOKUPP-親ディレクトリの検索
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）-&gt;（cfh）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* CURRENT_FH: object */
     void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LOOKUPP4res {
             /* CURRENT_FH: directory */
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current filehandle is assumed to refer to a regular directory or a named attribute directory. LOOKUPP assigns the filehandle for its parent directory to be the current filehandle. If there is no parent directory an NFS4ERR_NOENT error must be returned. Therefore, NFS4ERR_NOENT will be returned by the server when the current filehandle is at the root or top of the server&#39;s file tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルは、通常のディレクトリまたは名前付き属性ディレクトリを参照すると想定されています。 LOOKUPPは、親ディレクトリのファイルハンドルを現在のファイルハンドルに割り当てます。親ディレクトリがない場合は、NFS4ERR_NOENTエラーを返す必要があります。したがって、現在のファイルハンドルがサーバーのファイルツリーのルートまたは最上位にある場合、サーバーはNFS4ERR_NOENTを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As for LOOKUP, LOOKUPP will also cross mountpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOOKUPに関しては、LOOKUPPもマウントポイントをクロスします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle is not a directory or named attribute directory, the error NFS4ERR_NOTDIR is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルがディレクトリまたは名前付き属性ディレクトリでない場合、エラーNFS4ERR_NOTDIRが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-15--Operation-17-NVERIFY---Verify-Difference-in-Attributes">
14.2.15. Operation 17: NVERIFY - Verify Difference in Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.15. Operation 17: NVERIFY - Verify Difference in Attributes
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     (cfh), fattr -&gt; -
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct NVERIFY4args {
             /* CURRENT_FH: object */
             fattr4          obj_attributes;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct NVERIFY4res {
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used to prefix a sequence of operations to be performed if one or more attributes have changed on some filesystem object. If all the attributes match then the error NFS4ERR_SAME must be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、ファイルシステムオブジェクトの1つ以上の属性が変更された場合に実行される一連の操作の前に付けるために使用されます。すべての属性が一致する場合、エラーNFS4ERR_SAMEを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is useful as a cache validation operator. If the object to which the attributes belong has changed then the following operations may obtain new data associated with that object. For instance, to check if a file has been changed and obtain new data if it has:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、キャッシュ検証演算子として役立ちます。属性が属するオブジェクトが変更された場合、次の操作でそのオブジェクトに関連付けられた新しいデータを取得できます。たとえば、ファイルが変更されているかどうかを確認し、次の場合は新しいデータを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PUTFH (public) LOOKUP &#34;foobar&#34; NVERIFY attrbits attrs READ 0 32767
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PUTFH（パブリック）LOOKUP &#34;foobar&#34; NVERIFY attrbits attrs READ 0 32767
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that a recommended attribute is specified in the NVERIFY operation and the server does not support that attribute for the filesystem object, the error NFS4ERR_ATTRNOTSUPP is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NVERIFY操作で推奨属性が指定されていて、サーバーがファイルシステムオブジェクトのその属性をサポートしていない場合、エラーNFS4ERR_ATTRNOTSUPPがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the attribute rdattr_error or any write-only attribute (e.g., time_modify_set) is specified, the error NFS4ERR_INVAL is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性rdattr_errorまたは書き込み専用属性（time_modify_setなど）が指定されている場合、エラーNFS4ERR_INVALがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ATTRNOTSUPP NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SAME NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ATTRNOTSUPP NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SAME NFS4ERR_SAMALE NFS4ERR_SERVERFAULT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-16--Operation-18-OPEN---Open-a-Regular-File">
14.2.16. Operation 18: OPEN - Open a Regular File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.16. 操作18：OPEN-通常のファイルを開く
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), seqid, share_access, share_deny, owner, openhow, claim -&gt; (cfh), stateid, cinfo, rflags, open_confirm, attrset delegation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、seqid、share_access、share_deny、所有者、openhow、クレーム-&gt;（cfh）、stateid、cinfo、rflags、open_confirm、attrset委任
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct OPEN4args {
             seqid4          seqid;
             uint32_t        share_access;
             uint32_t        share_deny;
             open_owner4     owner;
             openflag4       openhow;
             open_claim4     claim;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     enum createmode4 {
             UNCHECKED4      = 0,
             GUARDED4        = 1,
             EXCLUSIVE4      = 2
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union createhow4 switch (createmode4 mode) {
      case UNCHECKED4:
      case GUARDED4:
              fattr4         createattrs;
      case EXCLUSIVE4:
              verifier4      createverf;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     enum opentype4 {
             OPEN4_NOCREATE  = 0,
             OPEN4_CREATE    = 1
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union openflag4 switch (opentype4 opentype) {
      case OPEN4_CREATE:
              createhow4     how;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* Next definitions used for OPEN delegation */
     enum limit_by4 {
             NFS_LIMIT_SIZE          = 1,
             NFS_LIMIT_BLOCKS        = 2
             /* others as needed */
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct nfs_modified_limit4 {
             uint32_t        num_blocks;
             uint32_t        bytes_per_block;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union nfs_space_limit4 switch (limit_by4 limitby) {
      /* limit specified as file size */
      case NFS_LIMIT_SIZE:
              uint64_t               filesize;
      /* limit specified by number of blocks */
      case NFS_LIMIT_BLOCKS:
              nfs_modified_limit4    mod_blocks;
     } ;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     enum open_delegation_type4 {
             OPEN_DELEGATE_NONE      = 0,
             OPEN_DELEGATE_READ      = 1,
             OPEN_DELEGATE_WRITE     = 2
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     enum open_claim_type4 {
             CLAIM_NULL              = 0,
             CLAIM_PREVIOUS          = 1,
             CLAIM_DELEGATE_CUR      = 2,
             CLAIM_DELEGATE_PREV     = 3
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct open_claim_delegate_cur4 {
             stateid4        delegate_stateid;
             component4      file;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union open_claim4 switch (open_claim_type4 claim) {
      /*
       * No special rights to file. Ordinary OPEN of the specified file.
       */
      case CLAIM_NULL:
              /* CURRENT_FH: directory */
              component4     file;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /*
       * Right to the file established by an open previous to server
       * reboot.  File identified by filehandle obtained at that time
       * rather than by name.
       */
      case CLAIM_PREVIOUS:
              /* CURRENT_FH: file being reclaimed */
              open_delegation_type4   delegate_type;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /*
       * Right to file based on a delegation granted by the server.
       * File is specified by name.
       */
      case CLAIM_DELEGATE_CUR:
              /* CURRENT_FH: directory */
              open_claim_delegate_cur4       delegate_cur_info;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* Right to file based on a delegation granted to a previous boot
       * instance of the client.  File is specified by name.
       */
      case CLAIM_DELEGATE_PREV:
              /* CURRENT_FH: directory */
              component4     file_delegate_prev;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_read_delegation4 {
           stateid4        stateid;        /* Stateid for delegation*/
           bool            recall;         /* Pre-recalled flag for
                                              delegations obtained
                                              by reclaim
                                              (CLAIM_PREVIOUS) */
           nfsace4         permissions;    /* Defines users who don&#39;t
                                              need an ACCESS call to
                                              open for read */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_write_delegation4 {
           stateid4        stateid;        /* Stateid for delegation*/
           bool            recall;         /* Pre-recalled flag for
                                              delegations obtained
                                              by reclaim
                                              (CLAIM_PREVIOUS) */
           nfs_space_limit4 space_limit;   /* Defines condition that
                                              the client must check to
                                              determine whether the
                                              file needs to be flushed
                                              to the server on close.
                                              */
           nfsace4         permissions;    /* Defines users who don&#39;t
                                              need an ACCESS call as
                                              part of a delegated
                                              open. */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union open_delegation4
   switch (open_delegation_type4 delegation_type) {
           case OPEN_DELEGATE_NONE:
                   void;
           case OPEN_DELEGATE_READ:
                   open_read_delegation4 read;
           case OPEN_DELEGATE_WRITE:
                   open_write_delegation4 write;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const OPEN4_RESULT_CONFIRM      = 0x00000002;
   const OPEN4_RESULT_LOCKTYPE_POSIX = 0x00000004;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPEN4resok {
           stateid4        stateid;        /* Stateid for open */
           change_info4    cinfo;          /* Directory Change Info */
           uint32_t        rflags;         /* Result flags */
           bitmap4         attrset;        /* attributes on create */
           open_delegation4 delegation;    /* Info on any open
                                              delegation */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union OPEN4res switch (nfsstat4 status) {
    case NFS4_OK:
           /* CURRENT_FH: opened file */
           OPEN4resok      resok4;
    default:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WARNING TO CLIENT IMPLEMENTORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの実装者への警告
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN resembles LOOKUP in that it generates a filehandle for the client to use. Unlike LOOKUP though, OPEN creates server state on the filehandle. In normal circumstances, the client can only release this state with a CLOSE operation. CLOSE uses the current filehandle to determine which file to close. Therefore the client MUST follow every OPEN operation with a GETFH operation in the same COMPOUND procedure. This will supply the client with the filehandle such that CLOSE can be used appropriately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENは、クライアントが使用するファイルハンドルを生成する点でLOOKUPに似ています。ただし、LOOKUPとは異なり、OPENはファイルハンドルにサーバー状態を作成します。通常の状況では、クライアントはCLOSE操作でのみこの状態を解放できます。 CLOSEは、現在のファイルハンドルを使用して、閉じるファイルを決定します。したがって、クライアントはすべてのOPEN操作の後に、同じCOMPOUNDプロシージャのGETFH操作を実行する必要があります。これにより、クライアントにファイルハンドルが提供され、CLOSEを適切に使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Simply waiting for the lease on the file to expire is insufficient because the server may maintain the state indefinitely as long as another client does not attempt to make a conflicting access to the same file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別のクライアントが同じファイルへのアクセスの競合を試みない限り、サーバーは状態を無期限に維持できるため、ファイルのリースが期限切れになるのを待つだけでは不十分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The OPEN operation creates and/or opens a regular file in a directory with the provided name. If the file does not exist at the server and creation is desired, specification of the method of creation is provided by the openhow parameter. The client has the choice of three creation methods: UNCHECKED, GUARDED, or EXCLUSIVE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN操作は、指定された名前のディレクトリに通常のファイルを作成またはオープンします。ファイルがサーバーに存在せず、作成が必要な場合は、作成方法の指定がopenhowパラメータによって提供されます。クライアントは、3つの作成方法（UNCHECKED、GUARDED、またはEXCLUSIVE）を選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle is a named attribute directory, OPEN will then create or open a named attribute file. Note that exclusive create of a named attribute is not supported. If the createmode is EXCLUSIVE4 and the current filehandle is a named attribute directory, the server will return EINVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが名前付き属性ディレクトリである場合、OPENは名前付き属性ファイルを作成または開きます。名前付き属性の排他的な作成はサポートされていないことに注意してください。 createmodeがEXCLUSIVE4で、現在のファイルハンドルが名前付き属性ディレクトリである場合、サーバーはEINVALを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 UNCHECKED means that the file should be created if a file of that name does not exist and encountering an existing regular file of that name is not an error. For this type of create, createattrs specifies the initial set of attributes for the file. The set of attributes may include any writable attribute valid for regular files. When an UNCHECKED create encounters an existing file, the attributes specified by createattrs are not used, except that when an size of zero is specified, the existing file is truncated. If GUARDED is specified, the server checks for the presence of a duplicate object by name before performing the create. If a duplicate exists, an error of NFS4ERR_EXIST is returned as the status. If the object does not exist, the request is performed as described for UNCHECKED. For each of these cases (UNCHECKED and GUARDED) where the operation is successful, the server will return to the client an attribute mask signifying which attributes were successfully set for the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
UNCHECKEDは、その名前のファイルが存在せず、その名前の既存の通常のファイルに遭遇してもエラーではない場合にファイルを作成する必要があることを意味します。このタイプの作成の場合、createattrsはファイルの属性の初期セットを指定します。属性のセットには、通常のファイルに有効な任意の書き込み可能な属性を含めることができます。 UNCHECKED作成で既存のファイルが検出されると、createattrsで指定された属性は使用されません。ただし、サイズにゼロを指定した場合、既存のファイルは切り捨てられます。 GUARDEDが指定されている場合、サーバーは、作成を実行する前に名前で重複オブジェクトの存在を確認します。重複が存在する場合、ステータスとしてNFS4ERR_EXISTのエラーが返されます。オブジェクトが存在しない場合、UNCHECKEDの説明に従って要求が実行されます。操作が成功したこれらの各ケース（チェックされていない、ガードされている）の場合、サーバーは、オブジェクトにどの属性が正常に設定されたかを示す属性マスクをクライアントに返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCLUSIVE specifies that the server is to follow exclusive creation semantics, using the verifier to ensure exclusive creation of the target. The server should check for the presence of a duplicate object by name. If the object does not exist, the server creates the object and stores the verifier with the object. If the object does exist and the stored verifier matches the client provided verifier, the server uses the existing object as the newly created object. If the stored verifier does not match, then an error of NFS4ERR_EXIST is returned. No attributes may be provided in this case, since the server may use an attribute of the target object to store the verifier. If the server uses an attribute to store the exclusive create verifier, it will signify which attribute by setting the appropriate bit in the attribute mask that is returned in the results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCLUSIVEは、サーバーが排他的作成セマンティクスに従うことを指定し、ベリファイアを使用してターゲットの排他的作成を保証します。サーバーは名前で重複オブジェクトの存在を確認する必要があります。オブジェクトが存在しない場合、サーバーはオブジェクトを作成し、オブジェクトとともにベリファイアを格納します。オブジェクトが存在し、格納されているベリファイアがクライアント提供のベリファイアと一致する場合、サーバーは既存のオブジェクトを新しく作成されたオブジェクトとして使用します。保存されたベリファイアが一致しない場合、NFS4ERR_EXISTのエラーが返されます。この場合、サーバーはターゲットオブジェクトの属性を使用してベリファイアを格納できるため、属性を指定できません。サーバーが属性を使用して排他的作成ベリファイアを格納する場合、サーバーは結果で返される属性マスクに適切なビットを設定することにより、どの属性かを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the target directory, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the link creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットディレクトリの場合、サーバーはchange_info4情報をcinfoに返します。 change_info4構造体のアトミックフィールドを使用すると、サーバーは、リンクの作成に関して変更前と変更後の属性がアトミックに取得されたかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon successful creation, the current filehandle is replaced by that of the new object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
作成が成功すると、現在のファイルハンドルは新しいオブジェクトのファイルハンドルに置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The OPEN operation provides for Windows share reservation capability with the use of the share_access and share_deny fields of the OPEN arguments. The client specifies at OPEN the required share_access and share_deny modes. For clients that do not directly support SHAREs (i.e., UNIX), the expected deny value is DENY_NONE. In the case that there is a existing SHARE reservation that conflicts with the OPEN request, the server returns the error NFS4ERR_SHARE_DENIED. For a complete SHARE request, the client must provide values for the owner and seqid fields for the OPEN argument. For additional discussion of SHARE semantics see the section on &#39;Share Reservations&#39;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN操作は、OPEN引数のshare_accessおよびshare_denyフィールドを使用して、Windows共有予約機能を提供します。クライアントは、OPENで必要なshare_accessおよびshare_denyモードを指定します。 SHAREを直接サポートしないクライアント（UNIXなど）の場合、予期される拒否値はDENY_NONEです。 OPEN要求と競合する既存のSHARE予約がある場合、サーバーはエラーNFS4ERR_SHARE_DENIEDを返します。完全なSHARE要求の場合、クライアントはOPEN引数の所有者およびseqidフィールドに値を提供する必要があります。 SHAREセマンティクスの詳細については、「予約の共有」のセクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that the client is recovering state from a server failure, the claim field of the OPEN argument is used to signify that the request is meant to reclaim state previously held.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがサーバーの障害から状態を回復している場合、OPEN引数のクレームフィールドは、要求が以前に保持された状態を取り戻すことを意図していることを示すために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The &#34;claim&#34; field of the OPEN argument is used to specify the file to be opened and the state information which the client claims to possess. There are four basic claim types which cover the various situations for an OPEN. They are as follows: CLAIM_NULL For the client, this is a new OPEN request and there is no previous state associate with the file for the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
OPEN引数の「claim」フィールドは、開かれるファイルとクライアントが所有すると主張する状態情報を指定するために使用されます。 OPENのさまざまな状況に対応する4つの基本的なクレームタイプがあります。それらは次のとおりです。CLAIM_NULLクライアントの場合、これは新しいOPEN要求であり、クライアントのファイルに関連付けられている以前の状態はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_PREVIOUS The client is claiming basic OPEN state for a file that was held previous to a server reboot. Generally used when a server is returning persistent filehandles; the client may not have the file name to reclaim the OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_PREVIOUSクライアントは、サーバーの再起動前に保持されていたファイルの基本的なOPEN状態を要求しています。通常、サーバーが永続的なファイルハンドルを返すときに使用されます。クライアントには、OPENを再利用するためのファイル名がない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_DELEGATE_CUR The client is claiming a delegation for OPEN as granted by the server. Generally this is done as part of recalling a delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_DELEGATE_CURクライアントは、サーバーによって許可されたOPENの委任を要求しています。一般的に、これは委任を呼び戻す一環として行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_DELEGATE_PREV The client is claiming a delegation granted to a previous client instance; used after the client reboots. The server MAY support CLAIM_DELEGATE_PREV. If it does support CLAIM_DELEGATE_PREV, SETCLIENTID_CONFIRM MUST NOT remove the client&#39;s delegation state, and the server MUST support the DELEGPURGE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_DELEGATE_PREVクライアントは、以前のクライアントインスタンスに付与された委任を要求しています。クライアントの再起動後に使用されます。サーバーはCLAIM_DELEGATE_PREVをサポートしてもよい（MAY）。 CLAIM_DELEGATE_PREVをサポートする場合、SETCLIENTID_CONFIRMはクライアントの委任状態を削除してはならず（MUST NOT）、サーバーはDELEGPURGE操作をサポートしなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For OPEN requests whose claim type is other than CLAIM_PREVIOUS (i.e., requests other than those devoted to reclaiming opens after a server reboot) that reach the server during its grace or lease expiration period, the server returns an error of NFS4ERR_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クレームタイプがCLAIM_PREVIOUS以外のOPENリクエスト（つまり、サーバーの再起動後のオープンの再利用専用のリクエスト以外のリクエスト）が猶予期間またはリースの有効期限中にサーバーに到達すると、サーバーはNFS4ERR_GRACEのエラーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For any OPEN request, the server may return an open delegation, which allows further opens and closes to be handled locally on the client as described in the section Open Delegation. Note that delegation is up to the server to decide. The client should never assume that delegation will or will not be granted in a particular instance. It should always be prepared for either case. A partial exception is the reclaim (CLAIM_PREVIOUS) case, in which a delegation type is claimed. In this case, delegation will always be granted, although the server may specify an immediate recall in the delegation structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN要求の場合、サーバーはオープン委任を返す可能性があります。これにより、「オープン委任」のセクションで説明されているように、クライアントでローカルでさらにオープンとクローズを処理できます。委任は決定するサーバー次第であることに注意してください。クライアントは、特定のインスタンスで委任が許可されるかどうかを決して想定しないでください。どちらの場合も常に準備する必要があります。部分的な例外は、委任タイプが要求される再利用（CLAIM_PREVIOUS）の場合です。この場合、サーバーは委任構造で即時の再呼び出しを指定できますが、委任は常に許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rflags returned by a successful OPEN allow the server to return information governing how the open file is to be handled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENが成功すると返されるrflagsにより、サーバーは、開いているファイルの処理方法を管理する情報を返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_RESULT_CONFIRM indicates that the client MUST execute an OPEN_CONFIRM operation before using the open file. OPEN4_RESULT_LOCKTYPE_POSIX indicates the server&#39;s file locking behavior supports the complete set of Posix locking techniques. From this the client can choose to manage file locking state in a way to handle a mis-match of file locking management.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_RESULT_CONFIRMは、クライアントがオープンファイルを使用する前にOPEN_CONFIRM操作を実行する必要があることを示します。 OPEN4_RESULT_LOCKTYPE_POSIXは、サーバーのファイルロック動作がPosixロック技術の完全なセットをサポートすることを示します。これにより、クライアントは、ファイルロック管理の不一致を処理する方法でファイルロック状態を管理することを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the component is of zero length, NFS4ERR_INVAL will be returned. The component is also subject to the normal UTF-8, character support, and name checks. See the section &#34;UTF-8 Related Errors&#34; for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンポーネントの長さがゼロの場合、NFS4ERR_INVALが返されます。このコンポーネントは、通常のUTF-8、文字サポート、および名前のチェックも受けます。詳細については、「UTF-8関連のエラー」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an OPEN is done and the specified lockowner already has the resulting filehandle open, the result is to &#34;OR&#34; together the new share and deny status together with the existing status. In this case, only a single CLOSE need be done, even though multiple OPENs were completed. When such an OPEN is done, checking of share reservations for the new OPEN proceeds normally, with no exception for the existing OPEN held by the same lockowner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENが実行され、指定されたロック所有者が既にファイルハンドルを開いている場合、結果は新しい共有を「OR」し、既存のステータスとステータスを拒否します。この場合、複数のOPENが完了した場合でも、1回のCLOSEで済みます。そのようなOPENが実行されると、新しいOPENの共有予約のチェックは、同じロック所有者が保持している既存のOPENを例外として、通常どおりに進行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the underlying filesystem at the server is only accessible in a read-only mode and the OPEN request has specified ACCESS_WRITE or ACCESS_BOTH, the server will return NFS4ERR_ROFS to indicate a read-only filesystem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの基礎となるファイルシステムが読み取り専用モードでのみアクセス可能であり、OPEN要求でACCESS_WRITEまたはACCESS_BOTHが指定されている場合、サーバーはNFS4ERR_ROFSを返し、読み取り専用ファイルシステムを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with the CREATE operation, the server MUST derive the owner, owner ACE, group, or group ACE if any of the four attributes are required and supported by the server&#39;s filesystem. For an OPEN with the EXCLUSIVE4 createmode, the server has no choice, since such OPEN calls do not include the createattrs field. Conversely, if createattrs is specified, and includes owner or group (or corresponding ACEs) that the principal in the RPC call&#39;s credentials does not have authorization to create files for, then the server may return NFS4ERR_PERM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CREATE操作と同様に、4つの属性のいずれかが必要であり、サーバーのファイルシステムでサポートされている場合、サーバーは所有者、所有者ACE、グループ、またはグループACEを導出する必要があります。 EXCLUSIVE4 createmodeを使用したOPENの場合、そのようなOPEN呼び出しにはcreateattrsフィールドが含まれていないため、サーバーには選択肢がありません。逆に、createattrsが指定されており、RPC呼び出しの資格情報のプリンシパルがファイルを作成する権限を持っていない所有者またはグループ（または対応するACE）が含まれている場合、サーバーはNFS4ERR_PERMを返すことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of a OPEN which specifies a size of zero (e.g., truncation) and the file has named attributes, the named attributes are left as is. They are not removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サイズがゼロ（切り捨てなど）を指定するOPENで、ファイルに名前付き属性がある場合、名前付き属性はそのまま残ります。それらは削除されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The OPEN operation contains support for EXCLUSIVE create. The mechanism is similar to the support in NFS version 3 [RFC1813]. As in NFS version 3, this mechanism provides reliable exclusive creation. Exclusive create is invoked when the how parameter is EXCLUSIVE. In this case, the client provides a verifier that can reasonably be expected to be unique. A combination of a client identifier, perhaps the client network address, and a unique number generated by the client, perhaps the RPC transaction identifier, may be appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
OPEN操作には、EXCLUSIVE作成のサポートが含まれています。このメカニズムは、NFSバージョン3 [RFC1813]のサポートに似ています。 NFSバージョン3と同様に、このメカニズムは信頼できる排他的作成を提供します。排他的作成は、howパラメーターがEXCLUSIVEのときに呼び出されます。この場合、クライアントは、一意であると合理的に期待できるベリファイアを提供します。クライアント識別子（おそらくクライアントのネットワークアドレス）と、クライアントによって生成された一意の番号（おそらくRPCトランザクション識別子）の組み合わせが適切な場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the object does not exist, the server creates the object and stores the verifier in stable storage. For filesystems that do not provide a mechanism for the storage of arbitrary file attributes, the server may use one or more elements of the object meta-data to store the verifier. The verifier must be stored in stable storage to prevent erroneous failure on retransmission of the request. It is assumed that an exclusive create is being performed because exclusive semantics are critical to the application. Because of the expected usage, exclusive CREATE does not rely solely on the normally volatile duplicate request cache for storage of the verifier. The duplicate request cache in volatile storage does not survive a crash and may actually flush on a long network partition, opening failure windows. In the UNIX local filesystem environment, the expected storage location for the verifier on creation is the meta-data (time stamps) of the object. For this reason, an exclusive object create may not include initial attributes because the server would have nowhere to store the verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトが存在しない場合、サーバーはオブジェクトを作成し、ベリファイアを安定したストレージに保存します。任意のファイル属性を保存するメカニズムを提供しないファイルシステムの場合、サーバーは、オブジェクトメタデータの1つ以上の要素を使用してベリファイアを保存します。ベリファイアは、リクエストの再送信での誤った失敗を防ぐために、安定したストレージに保存する必要があります。排他的なセマンティクスがアプリケーションにとって重要であるため、排他的な作成が実行されていると想定されます。予想される使用法のため、排他的CREATEは、ベリファイアのストレージを通常揮発性の複製リクエストキャッシュだけに依存するわけではありません。揮発性ストレージの重複したリクエストキャッシュはクラッシュに耐えられず、実際には長いネットワークパーティションでフラッシュされ、失敗ウィンドウが開くことがあります。 UNIXローカルファイルシステム環境では、作成時にベリファイアに予想される格納場所は、オブジェクトのメタデータ（タイムスタンプ）です。このため、サーバーにはベリファイアを格納する場所がないため、排他オブジェクトの作成には初期属性が含まれない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server can not support these exclusive create semantics, possibly because of the requirement to commit the verifier to stable storage, it should fail the OPEN request with the error, NFS4ERR_NOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベリファイアを安定したストレージにコミットする必要があるために、サーバーがこれらの排他的作成セマンティクスをサポートできない場合、OPEN要求はエラーNFS4ERR_NOTSUPPで失敗するはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During an exclusive CREATE request, if the object already exists, the server reconstructs the object&#39;s verifier and compares it with the verifier in the request. If they match, the server treats the request as a success. The request is presumed to be a duplicate of an earlier, successful request for which the reply was lost and that the server duplicate request cache mechanism did not detect. If the verifiers do not match, the request is rejected with the status, NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
排他的CREATEリクエスト中に、オブジェクトがすでに存在する場合、サーバーはオブジェクトのベリファイアを再構築し、リクエスト内のベリファイアと比較します。それらが一致する場合、サーバーは要求を成功として扱います。要求は、応答が失われ、サーバーの複製要求キャッシュメカニズムが検出しなかった、以前の成功した要求の複製であると推定されます。ベリファイアが一致しない場合、リクエストはステータスNFS4ERR_EXISTで拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the client has performed a successful exclusive create, it must issue a SETATTR to set the correct object attributes. Until it does so, it should not rely upon any of the object attributes, since the server implementation may need to overload object meta-data to store the verifier. The subsequent SETATTR must not occur in the same COMPOUND request as the OPEN. This separation will guarantee that the exclusive create mechanism will continue to function properly in the face of retransmission of the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the client has performed a successful exclusive create, it must issue a SETATTR to set the correct object attributes. Until it does so, it should not rely upon any of the object attributes, since the server implementation may need to overload object meta-data to store the verifier. The subsequent SETATTR must not occur in the same COMPOUND request as the OPEN. This separation will guarantee that the exclusive create mechanism will continue to function properly in the face of retransmission of the request.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Use of the GUARDED attribute does not provide exactly-once semantics. In particular, if a reply is lost and the server does not detect the retransmission of the request, the operation can fail with NFS4ERR_EXIST, even though the create was performed successfully. The client would use this behavior in the case that the application has not requested an exclusive create but has asked to have the file truncated when the file is opened. In the case of the client timing out and retransmitting the create request, the client can use GUARDED to prevent against a sequence like: create, write, create (retransmitted) from occurring.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
GUARDED属性を使用しても、1回限りのセマンティクスは提供されません。特に、応答が失われ、サーバーが要求の再送信を検出しない場合、作成が正常に実行された場合でも、NFS4ERR_EXISTで操作が失敗する可能性があります。クライアントがこの動作を使用するのは、アプリケーションが排他的作成を要求していないが、ファイルを開くときにファイルを切り捨てるように要求した場合です。クライアントがタイムアウトして作成要求を再送信する場合、クライアントはGUARDEDを使用して、作成、書き込み、作成（再送信）などのシーケンスが発生しないようにすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For SHARE reservations, the client must specify a value for share_access that is one of READ, WRITE, or BOTH. For share_deny, the client must specify one of NONE, READ, WRITE, or BOTH. If the client fails to do this, the server must return NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SHARE予約の場合、クライアントは、READ、WRITE、またはBOTHのいずれかであるshare_accessの値を指定する必要があります。 share_denyの場合、クライアントはNONE、READ、WRITE、またはBOTHのいずれかを指定する必要があります。クライアントがこれに失敗した場合、サーバーはNFS4ERR_INVALを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on the share_access value (READ, WRITE, or BOTH) the client should check that the requester has the proper access rights to perform the specified operation. This would generally be the results of applying the ACL access rules to the file for the current requester. However, just as with the ACCESS operation, the client should not attempt to second-guess the server&#39;s decisions, as access rights may change and may be subject to server administrative controls outside the ACL framework. If the requester is not authorized to READ or WRITE (depending on the share_access value), the server must return NFS4ERR_ACCESS. Note that since the NFS version 4 protocol does not impose any requirement that READs and WRITEs issued for an open file have the same credentials as the OPEN itself, the server still must do appropriate access checking on the READs and WRITEs themselves.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
share_access値（READ、WRITE、またはBOTH）に基づいて、クライアントは、リクエスターが指定された操作を実行するための適切なアクセス権を持っていることを確認する必要があります。これは通常、現在のリクエスターのファイルにACLアクセスルールを適用した結果です。ただし、ACCESS操作の場合と同様に、アクセス権が変更されたり、ACLフレームワークの外部でサーバーの管理制御が行われたりする可能性があるため、クライアントはサーバーの決定を推測しないでください。リクエスターが（share_access値に応じて）READまたはWRITEを許可されていない場合、サーバーはNFS4ERR_ACCESSを返す必要があります。 NFSバージョン4プロトコルは、オープンファイルに対して発行されたREADおよびWRITEがOPEN自体と同じ資格情報を持つ必要がないため、サーバーはREADおよびWRITE自体に対して適切なアクセスチェックを実行する必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the component provided to OPEN is a symbolic link, the error NFS4ERR_SYMLINK will be returned to the client. If the current filehandle is not a directory, the error NFS4ERR_NOTDIR will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENに提供されたコンポーネントがシンボリックリンクである場合、エラーNFS4ERR_SYMLINKがクライアントに返されます。現在のファイルハンドルがディレクトリでない場合、エラーNFS4ERR_NOTDIRが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_ATTRNOTSUPP NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADOWNER NFS4ERR_BAD_SEQID NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_IO NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_NOTSUPP NFS4ERR_NO_GRACE NFS4ERR_PERM NFS4ERR_RECLAIM_BAD NFS4ERR_RECLAIM_CONFLICT NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_SHARE_DENIED NFS4ERR_STALE NFS4ERR_STALE_CLIENTID NFS4ERR_SYMLINK NFS4ERR_WRONGSEC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_ATTRNOTSUPP NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADOWNER NFS4ERR_BAD_SEQID NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_IO NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_NOTSUPP NFS4ERR_NO_GRACE NFS4ERR_PERM NFS4ERR_RECLAIM_BAD NFS4ERR_RECLAIM_CONFLICT NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_SHARE_DENIED NFS4ERR_STALE NFS4ERR_STALE_CLIENTID NFS4ERR_SYMLINK NFS4ERR_WRONGSEC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-17--Operation-19-OPENATTR---Open-Named-Attribute-Directory">
14.2.17. Operation 19: OPENATTR - Open Named Attribute Directory
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.17. 操作19：OPENATTR-名前付き属性ディレクトリを開く
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) createdir -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）createdir-&gt;（cfh）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct OPENATTR4args {
             /* CURRENT_FH: object */
             bool    createdir;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct OPENATTR4res {
             /* CURRENT_FH: named attr directory*/
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The OPENATTR operation is used to obtain the filehandle of the named attribute directory associated with the current filehandle. The result of the OPENATTR will be a filehandle to an object of type NF4ATTRDIR. From this filehandle, READDIR and LOOKUP operations can be used to obtain filehandles for the various named attributes associated with the original filesystem object. Filehandles returned within the named attribute directory will have a type of NF4NAMEDATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENATTR操作は、現在のファイルハンドルに関連付けられている名前付き属性ディレクトリのファイルハンドルを取得するために使用されます。 OPENATTRの結果は、NF4ATTRDIRタイプのオブジェクトへのファイルハンドルになります。このファイルハンドルから、READDIRおよびLOOKUP操作を使用して、元のファイルシステムオブジェクトに関連付けられたさまざまな名前付き属性のファイルハンドルを取得できます。名前付き属性ディレクトリ内で返されるファイルハンドルは、NF4NAMEDATTRのタイプになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The createdir argument allows the client to signify if a named attribute directory should be created as a result of the OPENATTR operation. Some clients may use the OPENATTR operation with a value of FALSE for createdir to determine if any named attributes exist for the object. If none exist, then NFS4ERR_NOENT will be returned. If createdir has a value of TRUE and no named attribute directory exists, one is created. The creation of a named attribute directory assumes that the server has implemented named attribute support in this fashion and is not required to do so by this definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
createdir引数を使用すると、OPENATTR操作の結果として名前付き属性ディレクトリを作成する必要があるかどうかをクライアントが示すことができます。一部のクライアントは、createdirの値がFALSEのOPENATTR操作を使用して、オブジェクトに名前付き属性が存在するかどうかを判断します。存在しない場合は、NFS4ERR_NOENTが返されます。 createdirの値がTRUEで、名前付き属性ディレクトリが存在しない場合は、1つ作成されます。名前付き属性ディレクトリの作成は、サーバーがこの方法で名前付き属性のサポートを実装していることを前提としており、この定義ではそうする必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server does not support named attributes for the current filehandle, an error of NFS4ERR_NOTSUPP will be returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが現在のファイルハンドルの名前付き属性をサポートしていない場合、NFS4ERR_NOTSUPPのエラーがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_FHEXPIRED NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_FHEXPIRED NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_RESOURCE NFS4ERR_RESOURCE NFS4ERR_RESOURCE NFS4ERR_FAULT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-18--Operation-20-OPENCONFIRM---Confirm-Open">
14.2.18. Operation 20: OPEN_CONFIRM - Confirm Open
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.18. 操作20：OPEN_CONFIRM-オープンの確認
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), seqid, stateid-&gt; stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、seqid、stateid-&gt; stateid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct OPEN_CONFIRM4args {
             /* CURRENT_FH: opened file */
             stateid4        open_stateid;
             seqid4          seqid;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct OPEN_CONFIRM4resok {
             stateid4        open_stateid;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union OPEN_CONFIRM4res switch (nfsstat4 status) {
      case NFS4_OK:
              OPEN_CONFIRM4resok     resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used to confirm the sequence id usage for the first time that a open_owner is used by a client. The stateid returned from the OPEN operation is used as the argument for this operation along with the next sequence id for the open_owner. The sequence id passed to the OPEN_CONFIRM must be 1 (one) greater than the seqid passed to the OPEN operation from which the open_confirm value was obtained. If the server receives an unexpected sequence id with respect to the original open, then the server assumes that the client will not confirm the original OPEN and all state associated with the original OPEN is released by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、open_ownerがクライアントによって初めて使用されたときに、シーケンスIDの使用を確認するために使用されます。 OPEN操作から返された状態IDは、open_ownerの次のシーケンスIDとともに、この操作の引数として使用されます。 OPEN_CONFIRMに渡されるシーケンスIDは、open_confirm値の取得元であるOPEN操作に渡されるseqidよりも1大きい必要があります。サーバーが元のオープンに関して予期しないシーケンスIDを受信した場合、サーバーはクライアントが元のOPENを確認せず、元のOPENに関連付けられたすべての状態がサーバーによって解放されると想定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A given client might generate many open_owner4 data structures for a given clientid. The client will periodically either dispose of its open_owner4s or stop using them for indefinite periods of time. The latter situation is why the NFS version 4 protocol does not have an explicit operation to exit an open_owner4: such an operation is of no use in that situation. Instead, to avoid unbounded memory use, the server needs to implement a strategy for disposing of open_owner4s that have no current lock, open, or delegation state for any files and have not been used recently. The time period used to determine when to dispose of open_owner4s is an implementation choice. The time period should certainly be no less than the lease time plus any grace period the server wishes to implement beyond a lease time. The OPEN_CONFIRM operation allows the server to safely dispose of unused open_owner4 data structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
特定のクライアントは、特定のclientidに対して多くのopen_owner4データ構造を生成する場合があります。クライアントは定期的にopen_owner4sを破棄するか、無期限に使用を停止します。後者の状況は、NFSバージョン4プロトコルにopen_owner4を終了する明示的な操作がない理由です。そのような操作は、その状況では役に立ちません。代わりに、無制限のメモリ使用を回避するために、サーバーは、ファイルの現在のロック、オープン、または委任状態がなく、最近使用されていないopen_owner4sを破棄する戦略を実装する必要があります。 open_owner4sをいつ破棄するかを決定するために使用される期間は、実装の選択です。この期間は、確かにリース時間と、サーバーがリース時間を超えて実装したい猶予期間を足したものでなければなりません。 OPEN_CONFIRM操作により、サーバーは未使用のopen_owner4データ構造を安全に破棄できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that a client issues an OPEN operation and the server no longer has a record of the open_owner4, the server needs to ensure that this is a new OPEN and not a replay or retransmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがOPEN操作を発行し、サーバーにopen_owner4のレコードがなくなった場合、サーバーはこれが新しいOPENであり、再生や再送信ではないことを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers must not require confirmation on OPENs that grant delegations or are doing reclaim operations. See section &#34;Use of Open Confirmation&#34; for details. The server can easily avoid this by noting whether it has disposed of one open_owner4 for the given clientid. If the server does not support delegation, it might simply maintain a single bit that notes whether any open_owner4 (for any client) has been disposed of.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、委任を許可する、または再利用操作を行うOPENの確認を要求してはなりません。詳細については、「オープン確認の使用」セクションを参照してください。サーバーは、指定されたclientidに対して1つのopen_owner4を破棄したかどうかを確認することで、これを簡単に回避できます。サーバーが委任をサポートしていない場合は、open_owner4（任意のクライアント用）が破棄されたかどうかを示す単一のビットを維持するだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server must hold unconfirmed OPEN state until one of three events occur. First, the client sends an OPEN_CONFIRM request with the appropriate sequence id and stateid within the lease period. In this case, the OPEN state on the server goes to confirmed, and the open_owner4 on the server is fully established.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、3つのイベントのいずれかが発生するまで、未確認のOPEN状態を保持する必要があります。最初に、クライアントは適切なシーケンスIDとステートIDを含むOPEN_CONFIRMリクエストをリース期間内に送信します。この場合、サーバーのOPEN状態は確認済みになり、サーバーのopen_owner4は完全に確立されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Second, the client sends another OPEN request with a sequence id that is incorrect for the open_owner4 (out of sequence). In this case, the server assumes the second OPEN request is valid and the first one is a replay. The server cancels the OPEN state of the first OPEN request, establishes an unconfirmed OPEN state for the second OPEN request, and responds to the second OPEN request with an indication that an OPEN_CONFIRM is needed. The process then repeats itself. While there is a potential for a denial of service attack on the client, it is mitigated if the client and server require the use of a security flavor based on Kerberos V5, LIPKEY, or some other flavor that uses cryptography.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2番目に、クライアントは、open_owner4に対して正しくないシーケンスID（シーケンス外）を含む別のOPEN要求を送信します。この場合、サーバーは2番目のOPEN要求が有効であり、最初の要求が再生であると想定します。サーバーは最初のOPEN要求のOPEN状態をキャンセルし、2番目のOPEN要求に対して未確認のOPEN状態を確立し、OPEN_CONFIRMが必要であることを示す2番目のOPEN要求に応答します。その後、プロセスは繰り返されます。クライアントでのサービス拒否攻撃の可能性がありますが、クライアントとサーバーがKerberos V5、LIPKEY、または暗号化を使用するその他のフレーバーに基づくセキュリティフレーバーの使用を必要とする場合は軽減されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 What if the server is in the unconfirmed OPEN state for a given open_owner4, and it receives an operation on the open_owner4 that has a stateid but the operation is not OPEN, or it is OPEN_CONFIRM but with the wrong stateid? Then, even if the seqid is correct, the server returns NFS4ERR_BAD_STATEID, because the server assumes the operation is a replay: if the server has no established OPEN state, then there is no way, for example, a LOCK operation could be valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーが特定のopen_owner4に対して未確認のOPEN状態にあり、stateidを持つが操作がOPENではないopen_owner4で操作を受信した場合、または操作がOPEN_CONFIRMであるが間違ったstateidである場合はどうなりますか？次に、seqidが正しい場合でも、サーバーはNFS4ERR_BAD_STATEIDを返します。これは、サーバーが操作を再生であると想定しているためです。サーバーにOPEN状態が確立されていない場合、たとえばLOCK操作が有効であるなどの方法はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Third, neither of the two aforementioned events occur for the open_owner4 within the lease period. In this case, the OPEN state is canceled and disposal of the open_owner4 can occur.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3番目に、前述の2つのイベントのどちらも、リース期間内のopen_owner4では発生しません。この場合、OPEN状態が取り消され、open_owner4が破棄される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-19--Operation-21-OPENDOWNGRADE---Reduce-Open-File-Access">
14.2.19. Operation 21: OPEN_DOWNGRADE - Reduce Open File Access
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.19. 操作21：OPEN_DOWNGRADE-オープンファイルアクセスを減らす
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), stateid, seqid, access, deny -&gt; stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、stateid、seqid、access、deny-&gt; stateid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct OPEN_DOWNGRADE4args {
             /* CURRENT_FH: opened file */
             stateid4        open_stateid;
             seqid4          seqid;
             uint32_t        share_access;
             uint32_t        share_deny;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct OPEN_DOWNGRADE4resok {
             stateid4        open_stateid;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union OPEN_DOWNGRADE4res switch(nfsstat4 status) {
      case NFS4_OK:
             OPEN_DOWNGRADE4resok    resok4;
      default:
             void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used to adjust the share_access and share_deny bits for a given open. This is necessary when a given openowner opens the same file multiple times with different share_access and share_deny flags. In this situation, a close of one of the opens may change the appropriate share_access and share_deny flags to remove bits associated with opens no longer in effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used to adjust the share_access and share_deny bits for a given open. This is necessary when a given openowner opens the same file multiple times with different share_access and share_deny flags. In this situation, a close of one of the opens may change the appropriate share_access and share_deny flags to remove bits associated with opens no longer in effect.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The share_access and share_deny bits specified in this operation replace the current ones for the specified open file. The share_access and share_deny bits specified must be exactly equal to the union of the share_access and share_deny bits specified for some subset of the OPENs in effect for current openowner on the current file. If that constraint is not respected, the error NFS4ERR_INVAL should be returned. Since share_access and share_deny bits are subsets of those already granted, it is not possible for this request to be denied because of conflicting share reservations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作で指定されたshare_accessビットとshare_denyビットは、指定された開いているファイルの現在のビットを置き換えます。指定されたshare_accessビットとshare_denyビットは、現在のファイルの現在のopenownerに対して有効なOPENのサブセットに対して指定されたshare_accessビットとshare_denyビットの和集合と正確に一致している必要があります。その制約が守られない場合、エラーNFS4ERR_INVALが返されます。 share_accessビットとshare_denyビットはすでに付与されているもののサブセットであるため、共有予約の競合が原因でこの要求が拒否されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_STALE4 NFS_ERR_STALE4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-20--Operation-22-PUTFH---Set-Current-Filehandle">
14.2.20. Operation 22: PUTFH - Set Current Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.20. 操作22：PUTFH-現在のファイルハンドルの設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
filehandle -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
ファイルハンドル-&gt;（cfh）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct PUTFH4args {
             nfs_fh4         object;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct PUTFH4res {
             /* CURRENT_FH: */
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Replaces the current filehandle with the filehandle provided as an argument.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルを引数として提供されたファイルハンドルで置き換えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the security mechanism used by the requester does not meet the requirements of the filehandle provided to this operation, the server MUST return NFS4ERR_WRONGSEC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエスタが使用するセキュリティメカニズムがこの操作に提供されるファイルハンドルの要件を満たさない場合、サーバーはNFS4ERR_WRONGSECを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Commonly used as the first operator in an NFS request to set the context for following operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、NFS要求の最初の演算子として使用され、後続の操作のコンテキストを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_FHEXPIRED NFS4ERR_MOVED NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_FHEXPIRED NFS4ERR_MOVED NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-21--Operation-23-PUTPUBFH---Set-Public-Filehandle">
14.2.21. Operation 23: PUTPUBFH - Set Public Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.21. Operation 23: PUTPUBFH - Set Public Filehandle
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- -&gt;（cfh）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct PUTPUBFH4res {
             /* CURRENT_FH: public fh */
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Replaces the current filehandle with the filehandle that represents the public filehandle of the server&#39;s name space. This filehandle may be different from the &#34;root&#34; filehandle which may be associated with some other directory on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルを、サーバーの名前空間のパブリックファイルハンドルを表すファイルハンドルに置き換えます。このファイルハンドルは、サーバー上の他のディレクトリに関連付けられている「ルート」ファイルハンドルとは異なる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The public filehandle represents the concepts embodied in [RFC2054], [RFC2055], [RFC2224]. The intent for NFS version 4 is that the public filehandle (represented by the PUTPUBFH operation) be used as a method of providing WebNFS server compatibility with NFS versions 2 and 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
公開ファイルハンドルは、[RFC2054]、[RFC2055]、[RFC2224]で具体化された概念を表します。 NFSバージョン4の目的は、パブリックファイルハンドル（PUTPUBFH操作で表される）を、NFSバージョン2および3とのWebNFSサーバー互換性を提供する方法として使用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The public filehandle and the root filehandle (represented by the PUTROOTFH operation) should be equivalent. If the public and root filehandles are not equivalent, then the public filehandle MUST be a descendant of the root filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パブリックファイルハンドルとルートファイルハンドル（PUTROOTFH操作で表される）は同等である必要があります。パブリックファイルハンドルとルートファイルハンドルが同等でない場合、パブリックファイルハンドルはルートファイルハンドルの子孫である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Used as the first operator in an NFS request to set the context for following operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の操作のコンテキストを設定するためのNFS要求の最初のオペレーターとして使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 With the NFS version 2 and 3 public filehandle, the client is able to specify whether the path name provided in the LOOKUP should be evaluated as either an absolute path relative to the server&#39;s root or relative to the public filehandle. [RFC2224] contains further discussion of the functionality. With NFS version 4, that type of specification is not directly available in the LOOKUP operation. The reason for this is because the component separators needed to specify absolute vs. relative are not allowed in NFS version 4. Therefore, the client is responsible for constructing its request such that the use of either PUTROOTFH or PUTPUBFH are used to signify absolute or relative evaluation of an NFS URL respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFSバージョン2および3のパブリックファイルハンドルを使用すると、クライアントは、LOOKUPで提供されるパス名を、サーバーのルートからの絶対パスとパブリックファイルハンドルからの絶対パスのどちらとして評価するかを指定できます。 [RFC2224]には、機能の詳細な説明が含まれています。 NFSバージョン4では、そのタイプの仕様はLOOKUP操作では直接利用できません。これは、NFSバージョン4では絶対と相対の指定に必要なコンポーネントの区切り文字が許可されていないためです。したがって、クライアントは、PUTROOTFHまたはPUTPUBFHのいずれかを使用して絶対または相対を表すように要求を作成する必要があります。それぞれNFS URLの評価。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that there are warnings mentioned in [RFC2224] with respect to the use of absolute evaluation and the restrictions the server may place on that evaluation with respect to how much of its namespace has been made available. These same warnings apply to NFS version 4. It is likely, therefore that because of server implementation details, an NFS version 3 absolute public filehandle lookup may behave differently than an NFS version 4 absolute resolution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
絶対評価の使用に関して[RFC2224]で言及されている警告と、サーバーがその名前空間の利用可能量に関してその評価に課す制限に注意してください。これらの同じ警告はNFSバージョン4にも当てはまります。したがって、サーバーの実装の詳細により、NFSバージョン3の絶対パブリックファイルハンドルルックアップは、NFSバージョン4の絶対解像度とは異なる動作をする可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is a form of security negotiation as described in [RFC2755] that uses the public filehandle a method of employing SNEGO. This method is not available with NFS version 4 as filehandles are not overloaded with special meaning and therefore do not provide the same framework as NFS versions 2 and 3. Clients should therefore use the security negotiation mechanisms described in this RFC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2755]で説明されているように、パブリックファイルハンドルを使用してSNEGOを使用する方法のセキュリティネゴシエーションの形式があります。この方法は、NFSバージョン4では使用できません。ファイルハンドルが特別な意味でオーバーロードされないため、NFSバージョン2および3と同じフレームワークが提供されないため、クライアントはこのRFCで説明されているセキュリティネゴシエーションメカニズムを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_WRONGSEC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_WRONGSEC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-22--Operation-24-PUTROOTFH---Set-Root-Filehandle">
14.2.22. Operation 24: PUTROOTFH - Set Root Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.22. 操作24：PUTROOTFH-ルートファイルハンドルの設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- -&gt; (cfh)
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct PUTROOTFH4res {
             /* CURRENT_FH: root fh */
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Replaces the current filehandle with the filehandle that represents the root of the server&#39;s name space. From this filehandle a LOOKUP operation can locate any other filehandle on the server. This filehandle may be different from the &#34;public&#34; filehandle which may be associated with some other directory on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルを、サーバーの名前空間のルートを表すファイルハンドルに置き換えます。このファイルハンドルから、LOOKUP操作はサーバー上の他のファイルハンドルを見つけることができます。このファイルハンドルは、サーバー上の他のディレクトリに関連付けられている「パブリック」ファイルハンドルとは異なる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Commonly used as the first operator in an NFS request to set the context for following operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、NFS要求の最初の演算子として使用され、後続の操作のコンテキストを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_WRONGSEC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_WRONGSEC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-23--Operation-25-READ---Read-from-File">
14.2.23. Operation 25: READ - Read from File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.23. 操作25：読み取り-ファイルから読み取り
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), stateid, offset, count -&gt; eof, data
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、stateid、offset、count-&gt; eof、data
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct READ4args {
             /* CURRENT_FH: file */
             stateid4        stateid;
             offset4         offset;
             count4          count;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct READ4resok {
             bool            eof;
             opaque          data&lt;&gt;;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union READ4res switch (nfsstat4 status) {
      case NFS4_OK:
              READ4resok     resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The READ operation reads data from the regular file identified by the current filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READ操作は、現在のファイルハンドルで識別される通常のファイルからデータを読み取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client provides an offset of where the READ is to start and a count of how many bytes are to be read. An offset of 0 (zero) means to read data starting at the beginning of the file. If offset is greater than or equal to the size of the file, the status, NFS4_OK, is returned with a data length set to 0 (zero) and eof is set to TRUE. The READ is subject to access permissions checking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、READの開始位置のオフセットと、読み取るバイト数のカウントを提供します。オフセット0（ゼロ）は、ファイルの先頭からデータを読み取ることを意味します。オフセットがファイルのサイズ以上の場合、ステータスNFS4_OKが返され、データ長は0（ゼロ）に設定され、eofはTRUEに設定されます。 READは、アクセス許可チェックの対象です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client specifies a count value of 0 (zero), the READ succeeds and returns 0 (zero) bytes of data again subject to access permissions checking. The server may choose to return fewer bytes than specified by the client. The client needs to check for this condition and handle the condition appropriately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが0（ゼロ）のカウント値を指定した場合、READは成功し、アクセス許可のチェックに従って、再び0（ゼロ）バイトのデータを返します。サーバーは、クライアントが指定したよりも少ないバイト数を返すことを選択できます。クライアントはこの状態を確認し、状態を適切に処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The stateid value for a READ request represents a value returned from a previous record lock or share reservation request. The stateid is used by the server to verify that the associated share reservation and any record locks are still valid and to update lease timeouts for the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READ要求のstateid値は、前のレコードロックまたは共有予約要求から返された値を表します。サーバーはstateidを使用して、関連付けられた共有予約とレコードロックがまだ有効であることを確認し、クライアントのリースタイムアウトを更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the read ended at the end-of-file (formally, in a correctly formed READ request, if offset + count is equal to the size of the file), or the read request extends beyond the size of the file (if offset + count is greater than the size of the file), eof is returned as TRUE; otherwise it is FALSE. A successful READ of an empty file will always return eof as TRUE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
読み取りがファイルの終わりで終了した場合（正式には、正しく形成されたREAD要求で、offset + countがファイルのサイズに等しい場合）、または読み取り要求がファイルのサイズを超えている場合（offset +の場合） countがファイルのサイズより大きい場合）、eofはTRUEとして返されます。それ以外の場合はFALSEです。空のファイルの読み取りが成功すると、常にeofがTRUEとして返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle is not a regular file, an error will be returned to the client. In the case the current filehandle represents a directory, NFS4ERR_ISDIR is return; otherwise, NFS4ERR_INVAL is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが通常のファイルでない場合、エラーがクライアントに返されます。現在のファイルハンドルがディレクトリを表す場合、NFS4ERR_ISDIRが返されます。それ以外の場合は、NFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a READ with a stateid value of all bits 0, the server MAY allow the READ to be serviced subject to mandatory file locks or the current share deny modes for the file. For a READ with a stateid value of all bits 1, the server MAY allow READ operations to bypass locking checks at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのビット0のstateid値を持つREADの場合、サーバーは、必須のファイルロックまたはファイルの現在の共有拒否モードに従って、READのサービスを許可できます（MAY）。すべてのビット1のstateid値を持つREADの場合、サーバーは、READ操作がサーバーでのロックチェックをバイパスすることを許可する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible for the server to return fewer than count bytes of data. If the server returns less than the count requested and eof is set to FALSE, the client should issue another READ to get the remaining data. A server may return less data than requested under several circumstances. The file may have been truncated by another client or perhaps on the server itself, changing the file size from what the requesting client believes to be the case. This would reduce the actual amount of data available to the client. It is possible that the server may back off the transfer size and reduce the read request return. Server resource exhaustion may also occur necessitating a smaller read return.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが返すデータはcountバイトより少ない場合があります。サーバーが要求された数より少ない数を返し、eofがFALSEに設定されている場合、クライアントは残りのデータを取得するために別のREADを発行する必要があります。サーバーは、いくつかの状況下で要求されたよりも少ないデータを返す場合があります。ファイルが別のクライアントまたはサーバー自体で切り捨てられている可能性があり、要求元のクライアントがそうであると信じているファイルサイズを変更しています。これにより、クライアントが使用できる実際のデータ量が減少します。サーバーが転送サイズをバックオフし、読み取り要求の戻りを減らす可能性があります。サーバーリソースの枯渇も発生する可能性があり、読み取りの戻りを小さくする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If mandatory file locking is on for the file, and if the region corresponding to the data to be read from file is write locked by an owner not associated the stateid, the server will return the NFS4ERR_LOCKED error. The client should try to get the appropriate read record lock via the LOCK operation before re-attempting the READ. When the READ completes, the client should release the record lock via LOCKU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルに対して必須のファイルロックがオンになっていて、ファイルから読み取られるデータに対応する領域が、stateidに関連付けられていない所有者によって書き込みロックされている場合、サーバーはNFS4ERR_LOCKEDエラーを返します。クライアントは、READを再試行する前に、LOCK操作を介して適切な読み取りレコードロックを取得する必要があります。 READが完了すると、クライアントはLOCKUを介してレコードロックを解放する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_IO NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCKED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NXIO NFS4ERR_OLD_STATEID NFS4ERR_OPENMODE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_IO NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCKED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NXIO NFS4ERR_OLD_STATEID NFS4ERR_OPENMODE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-24--Operation-26-READDIR---Read-Directory">
14.2.24. Operation 26: READDIR - Read Directory
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.24. 操作26：READDIR-ディレクトリの読み取り
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS (cfh), cookie, cookieverf, dircount, maxcount, attr_request -&gt; cookieverf { cookie, name, attrs }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構文（cfh）、cookie、cookieverf、dircount、maxcount、attr_request-&gt; cookieverf {cookie、name、attrs}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct READDIR4args {
             /* CURRENT_FH: directory */
             nfs_cookie4     cookie;
             verifier4       cookieverf;
             count4          dircount;
             count4          maxcount;
             bitmap4         attr_request;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct entry4 {
             nfs_cookie4     cookie;
             component4      name;
             fattr4          attrs;
             entry4          *nextentry;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct dirlist4 {
             entry4          *entries;
             bool            eof;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct READDIR4resok {
             verifier4       cookieverf;
             dirlist4        reply;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union READDIR4res switch (nfsstat4 status) {
      case NFS4_OK:
              READDIR4resok  resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The READDIR operation retrieves a variable number of entries from a filesystem directory and returns client requested attributes for each entry along with information to allow the client to request additional directory entries in a subsequent READDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READDIR操作は、ファイルシステムディレクトリから可変数のエントリを取得し、クライアントが後続のREADDIRで追加のディレクトリエントリを要求できるようにする情報とともに、各エントリのクライアント要求属性を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The arguments contain a cookie value that represents where the READDIR should start within the directory. A value of 0 (zero) for the cookie is used to start reading at the beginning of the directory. For subsequent READDIR requests, the client specifies a cookie value that is provided by the server on a previous READDIR request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The arguments contain a cookie value that represents where the READDIR should start within the directory. A value of 0 (zero) for the cookie is used to start reading at the beginning of the directory. For subsequent READDIR requests, the client specifies a cookie value that is provided by the server on a previous READDIR request.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cookieverf value should be set to 0 (zero) when the cookie value is 0 (zero) (first directory read). On subsequent requests, it should be a cookieverf as returned by the server. The cookieverf must match that returned by the READDIR in which the cookie was acquired. If the server determines that the cookieverf is no longer valid for the directory, the error NFS4ERR_NOT_SAME must be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookieverf値は、cookie値が0（ゼロ）（最初のディレクトリー読み取り）の場合、0（ゼロ）に設定する必要があります。後続のリクエストでは、サーバーから返されるcookieverfである必要があります。 cookieverfは、Cookieが取得されたREADDIRによって返されるものと一致する必要があります。サーバーがcookieverfがディレクトリに対して無効であると判断した場合、エラーNFS4ERR_NOT_SAMEを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The dircount portion of the argument is a hint of the maximum number of bytes of directory information that should be returned. This value represents the length of the names of the directory entries and the cookie value for these entries. This length represents the XDR encoding of the data (names and cookies) and not the length in the native format of the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数のdircount部分は、返されるディレクトリ情報の最大バイト数のヒントです。この値は、ディレクトリエントリの名前の長さとこれらのエントリのCookie値を表します。この長さは、データ（名前とCookie）のXDRエンコードを表し、サーバーのネイティブ形式の長さではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The maxcount value of the argument is the maximum number of bytes for the result. This maximum size represents all of the data being returned within the READDIR4resok structure and includes the XDR overhead. The server may return less data. If the server is unable to return a single directory entry within the maxcount limit, the error NFS4ERR_TOOSMALL will be returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数のmaxcount値は、結果の最大バイト数です。この最大サイズは、READDIR4resok構造内で返されるすべてのデータを表し、XDRオーバーヘッドが含まれます。サーバーが返すデータが少なくなる場合があります。サーバーがmaxcount制限内の単一のディレクトリエントリを返すことができない場合、エラーNFS4ERR_TOOSMALLがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, attr_request represents the list of attributes to be returned for each directory entry supplied by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, attr_request represents the list of attributes to be returned for each directory entry supplied by the server.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On successful return, the server&#39;s response will provide a list of directory entries. Each of these entries contains the name of the directory entry, a cookie value for that entry, and the associated attributes as requested. The &#34;eof&#34; flag has a value of TRUE if there are no more entries in the directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正常に戻ると、サーバーの応答はディレクトリエントリのリストを提供します。これらの各エントリには、ディレクトリエントリの名前、そのエントリのCookie値、および要求された関連属性が含まれています。 「eof」フラグの値は、ディレクトリにエントリがなくなるとTRUEになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The cookie value is only meaningful to the server and is used as a &#34;bookmark&#34; for the directory entry. As mentioned, this cookie is used by the client for subsequent READDIR operations so that it may continue reading a directory. The cookie is similar in concept to a READ offset but should not be interpreted as such by the client. Ideally, the cookie value should not change if the directory is modified since the client may be caching these values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
cookie値はサーバーにとってのみ意味があり、ディレクトリエントリの「ブックマーク」として使用されます。前述のように、このCookieは、後続のREADDIR操作でクライアントによって使用されるため、ディレクトリの読み取りを続行できます。 Cookieの概念はREADオフセットと似ていますが、クライアントがそのように解釈するべきではありません。理想的には、クライアントがこれらの値をキャッシュしている可能性があるため、ディレクトリが変更された場合でもCookieの値は変更しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some cases, the server may encounter an error while obtaining the attributes for a directory entry. Instead of returning an error for the entire READDIR operation, the server can instead return the attribute &#39;fattr4_rdattr_error&#39;. With this, the server is able to communicate the failure to the client and not fail the entire operation in the instance of what might be a transient failure. Obviously, the client must request the fattr4_rdattr_error attribute for this method to work properly. If the client does not request the attribute, the server has no choice but to return failure for the entire READDIR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
場合によっては、ディレクトリエントリの属性を取得中に、サーバーでエラーが発生することがあります。 READDIR操作全体のエラーを返す代わりに、サーバーは属性 &#39;fattr4_rdattr_error&#39;を返すことができます。これにより、サーバーはクライアントに障害を通知でき、一時的な障害の可能性があるインスタンスの操作全体を失敗させることはありません。明らかに、このメソッドが適切に機能するには、クライアントがfattr4_rdattr_error属性を要求する必要があります。クライアントが属性を要求しない場合、サーバーはREADDIR操作全体の失敗を返すしかありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For some filesystem environments, the directory entries &#34;.&#34; and &#34;..&#34; have special meaning and in other environments, they may not. If the server supports these special entries within a directory, they should not be returned to the client as part of the READDIR response. To enable some client environments, the cookie values of 0, 1, and 2 are to be considered reserved. Note that the UNIX client will use these values when combining the server&#39;s response and local representations to enable a fully formed UNIX directory presentation to the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For some filesystem environments, the directory entries &#34;.&#34; and &#34;..&#34; have special meaning and in other environments, they may not. If the server supports these special entries within a directory, they should not be returned to the client as part of the READDIR response. To enable some client environments, the cookie values of 0, 1, and 2 are to be considered reserved. Note that the UNIX client will use these values when combining the server&#39;s response and local representations to enable a fully formed UNIX directory presentation to the application.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For READDIR arguments, cookie values of 1 and 2 should not be used and for READDIR results cookie values of 0, 1, and 2 should not be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READDIR引数の場合、Cookie値1および2は使用しないでください。また、READDIR結果の場合、Cookie値0、1、および2は返されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server&#39;s filesystem directory representations can differ greatly. A client&#39;s programming interfaces may also be bound to the local operating environment in a way that does not translate well into the NFS protocol. Therefore the use of the dircount and maxcount fields are provided to allow the client the ability to provide guidelines to the server. If the client is aggressive about attribute collection during a READDIR, the server has an idea of how to limit the encoded response. The dircount field provides a hint on the number of entries based solely on the names of the directory entries. Since it is a hint, it may be possible that a dircount value is zero. In this case, the server is free to ignore the dircount value and return directory information based on the specified maxcount value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server&#39;s filesystem directory representations can differ greatly. A client&#39;s programming interfaces may also be bound to the local operating environment in a way that does not translate well into the NFS protocol. Therefore the use of the dircount and maxcount fields are provided to allow the client the ability to provide guidelines to the server. If the client is aggressive about attribute collection during a READDIR, the server has an idea of how to limit the encoded response. The dircount field provides a hint on the number of entries based solely on the names of the directory entries. Since it is a hint, it may be possible that a dircount value is zero. In this case, the server is free to ignore the dircount value and return directory information based on the specified maxcount value.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cookieverf may be used by the server to help manage cookie values that may become stale. It should be a rare occurrence that a server is unable to continue properly reading a directory with the provided cookie/cookieverf pair. The server should make every effort to avoid this condition since the application at the client may not be able to properly handle this type of failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはcookieverfを使用して、古くなる可能性のあるCookie値の管理を支援します。サーバーが提供されたcookie / cookieverfペアでディレクトリを適切に読み続けることができないのはまれなことです。クライアントのアプリケーションはこのタイプの障害を適切に処理できない可能性があるため、サーバーはこの状態を回避するためにあらゆる努力をする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of the cookieverf will also protect the client from using READDIR cookie values that may be stale. For example, if the file system has been migrated, the server may or may not be able to use the same cookie values to service READDIR as the previous server used. With the client providing the cookieverf, the server is able to provide the appropriate response to the client. This prevents the case where the server may accept a cookie value but the underlying directory has changed and the response is invalid from the client&#39;s context of its previous READDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookieverfを使用すると、古くなっている可能性のあるREADDIR Cookie値を使用してクライアントを保護することもできます。たとえば、ファイルシステムが移行されている場合、サーバーは、以前のサーバーが使用していたものと同じCookie値を使用してREADDIRを処理できる場合とできない場合があります。クライアントがcookieverfを提供すると、サーバーはクライアントに適切な応答を提供できます。これにより、サーバーがCookie値を受け入れることができるが、基になるディレクトリが変更され、クライアントの以前のREADDIRのコンテキストからの応答が無効になるという事態を防ぐことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since some servers will not be returning &#34;.&#34; and &#34;..&#34; entries as has been done with previous versions of the NFS protocol, the client that requires these entries be present in READDIR responses must fabricate them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のサーバーは &#34;。&#34;を返さないため。以前のバージョンのNFSプロトコルで行われていた「..」エントリと同様に、これらのエントリがREADDIR応答に存在する必要があるクライアントは、それらを作成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BAD_COOKIE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_TOOSMALL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BAD_COOKIE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_SERVERFAULT NFS4ERR_SERVERFAUL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-25--Operation-27-READLINK---Read-Symbolic-Link">
14.2.25. Operation 27: READLINK - Read Symbolic Link
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.25. 操作27：READLINK-シンボリックリンクの読み取り
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) -&gt; linktext
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）-&gt; linktext
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* CURRENT_FH: symlink */
     void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct READLINK4resok {
             linktext4       link;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union READLINK4res switch (nfsstat4 status) {
      case NFS4_OK:
              READLINK4resok resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READLINK reads the data associated with a symbolic link. The data is a UTF-8 string that is opaque to the server. That is, whether created by an NFS client or created locally on the server, the data in a symbolic link is not interpreted when created, but is simply stored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READLINKは、シンボリックリンクに関連付けられたデータを読み取ります。データは、サーバーに対して不透明なUTF-8文字列です。つまり、NFSクライアントによって作成されたものか、サーバー上でローカルに作成されたものかにかかわらず、シンボリックリンクのデータは作成時に解釈されず、単に格納されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A symbolic link is nominally a pointer to another file. The data is not necessarily interpreted by the server, just stored in the file. It is possible for a client implementation to store a path name that is not meaningful to the server operating system in a symbolic link. A READLINK operation returns the data to the client for interpretation. If different implementations want to share access to symbolic links, then they must agree on the interpretation of the data in the symbolic link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シンボリックリンクは、名目上は別のファイルへのポインタです。データは必ずしもサーバーによって解釈されるのではなく、ファイルに格納されるだけです。クライアントの実装では、サーバーのオペレーティングシステムにとって意味のないパス名をシンボリックリンクに格納することができます。 READLINK操作は、解釈のためにデータをクライアントに返します。異なる実装がシンボリックリンクへのアクセスを共有する場合は、シンボリックリンクのデータの解釈に同意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The READLINK operation is only allowed on objects of type NF4LNK. The server should return the error, NFS4ERR_INVAL, if the object is not of type, NF4LNK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READLINK操作は、NF4LNKタイプのオブジェクトでのみ許可されます。オブジェクトのタイプがNF4LNKではない場合、サーバーはエラーNFS4ERR_INVALを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-26--Operation-28-REMOVE---Remove-Filesystem-Object">
14.2.26. Operation 28: REMOVE - Remove Filesystem Object
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.26. 操作28：REMOVE-ファイルシステムオブジェクトの削除
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), filename -&gt; change_info
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、ファイル名-&gt; change_info
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct REMOVE4args {
             /* CURRENT_FH: directory */
             component4       target;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct REMOVE4resok {
             change_info4    cinfo;
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union REMOVE4res switch (nfsstat4 status) {
      case NFS4_OK:
              REMOVE4resok   resok4;
      default:
              void;
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The REMOVE operation removes (deletes) a directory entry named by filename from the directory corresponding to the current filehandle. If the entry in the directory was the last reference to the corresponding filesystem object, the object may be destroyed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The REMOVE operation removes (deletes) a directory entry named by filename from the directory corresponding to the current filehandle. If the entry in the directory was the last reference to the corresponding filesystem object, the object may be destroyed.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the directory where the filename was removed, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the removal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイル名が削除されたディレクトリの場合、サーバーはcinfoにchange_info4情報を返します。 change_info4構造体のアトミックフィールドを使用すると、サーバーは、削除に関して変更前と変更後の属性がアトミックに取得されたかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the target has a length of 0 (zero), or if target does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットの長さが0（ゼロ）である場合、またはターゲットがUTF-8定義に従っていない場合、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS versions 2 and 3 required a different operator RMDIR for directory removal and REMOVE for non-directory removal. This allowed clients to skip checking the file type when being passed a non-directory delete system call (e.g., unlink() in POSIX) to remove a directory, as well as the converse (e.g., a rmdir() on a non-directory) because they knew the server would check the file type. NFS version 4 REMOVE can be used to delete any directory entry independent of its file type. The implementor of an NFS version 4 client&#39;s entry points from the unlink() and rmdir() system calls should first check the file type against the types the system call is allowed to remove before issuing a REMOVE. Alternatively, the implementor can produce a COMPOUND call that includes a LOOKUP/VERIFY sequence to verify the file type before a REMOVE operation in the same COMPOUND call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン2および3では、ディレクトリの削除には別の演算子RMDIRが必要であり、ディレクトリ以外の削除にはREMOVEが必要でした。これにより、クライアントは、ディレクトリを削除するための非ディレクトリ削除システムコール（例：POSIXのunlink()）を渡されたときにファイルタイプのチェックをスキップし、逆（例：非ディレクトリのrmdir()） ）サーバーがファイルタイプをチェックすることを知っていたからです。 NFSバージョン4のREMOVEを使用すると、ファイルタイプに関係なく、ディレクトリエントリを削除できます。 unlink()およびrmdir()システムコールからのNFSバージョン4クライアントのエントリポイントの実装者は、REMOVEを発行する前に、システムコールが削除できるタイプに対してファイルタイプを最初にチェックする必要があります。または、実装者は、LOOKUP / VERIFYシーケンスを含むCOMPOUND呼び出しを生成して、同じCOMPOUND呼び出しでREMOVE操作を実行する前にファイルタイプを確認できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The concept of last reference is server specific. However, if the numlinks field in the previous attributes of the object had the value 1, the client should not rely on referring to the object via a filehandle. Likewise, the client should not rely on the resources (disk space, directory entry, and so on) formerly associated with the object becoming immediately available. Thus, if a client needs to be able to continue to access a file after using REMOVE to remove it, the client should take steps to make sure that the file will still be accessible. The usual mechanism used is to RENAME the file from its old name to a new hidden name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後の参照の概念はサーバー固有です。ただし、オブジェクトの以前の属性のnumlinksフィールドの値が1の場合、クライアントはファイルハンドルを介してオブジェクトを参照することに依存すべきではありません。同様に、クライアントは、以前オブジェクトに関連付けられていたリソース（ディスク領域、ディレクトリエントリなど）がすぐに利用可能になることに依存してはなりません。したがって、クライアントがREMOVEを使用してファイルを削除した後も引き続きファイルにアクセスできるようにする必要がある場合、クライアントは、ファイルが引き続きアクセス可能であることを確認する手順を実行する必要があります。使用される通常のメカニズムは、ファイルの名前を古い名前から新しい非表示の名前に変更することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server finds that the file is still open when the REMOVE arrives:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REMOVEが到着したときにサーバーがファイルがまだ開いていることを検出した場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server SHOULD NOT delete the file&#39;s directory entry if the file was opened with OPEN4_SHARE_DENY_WRITE or OPEN4_SHARE_DENY_BOTH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルがOPEN4_SHARE_DENY_WRITEまたはOPEN4_SHARE_DENY_BOTHで開かれた場合、サーバーはファイルのディレクトリエントリを削除してはなりません（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the file was not opened with OPEN4_SHARE_DENY_WRITE or OPEN4_SHARE_DENY_BOTH, the server SHOULD delete the file&#39;s directory entry. However, until last CLOSE of the file, the server MAY continue to allow access to the file via its filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルがOPEN4_SHARE_DENY_WRITEまたはOPEN4_SHARE_DENY_BOTHで開かれなかった場合、サーバーはファイルのディレクトリエントリを削除する必要があります（SHOULD）。ただし、ファイルの最後のCLOSEまで、サーバーはそのファイルハンドルを介してファイルへのアクセスを許可し続ける場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_FILE_OPEN NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_NOTEMPTY NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_FILE_OPEN NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_NOTEMPTY NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-27--Operation-29-RENAME---Rename-Directory-Entry">
14.2.27. Operation 29: RENAME - Rename Directory Entry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.27. 操作29：RENAME-ディレクトリエントリの名前変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(sfh), oldname, (cfh), newname -&gt; source_change_info, target_change_info
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(sfh), oldname, (cfh), newname -&gt; source_change_info, target_change_info
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct RENAME4args {
             /* SAVED_FH: source directory */
             component4      oldname;
             /* CURRENT_FH: target directory */
             component4      newname;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct RENAME4resok {
             change_info4    source_cinfo;
             change_info4    target_cinfo;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union RENAME4res switch (nfsstat4 status) {
      case NFS4_OK:
              RENAME4resok   resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RENAME operation renames the object identified by oldname in the source directory corresponding to the saved filehandle, as set by the SAVEFH operation, to newname in the target directory corresponding to the current filehandle. The operation is required to be atomic to the client. Source and target directories must reside on the same filesystem on the server. On success, the current filehandle will continue to be the target directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RENAMEオペレーションは、SAVEFHオペレーションで設定された、保存されたファイルハンドルに対応するソースディレクトリのoldnameで識別されるオブジェクトの名前を、現在のファイルハンドルに対応するターゲットディレクトリのnewnameに変更します。操作はクライアントに対してアトミックである必要があります。ソースディレクトリとターゲットディレクトリは、サーバー上の同じファイルシステムに存在する必要があります。成功した場合、現在のファイルハンドルは引き続きターゲットディレクトリになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the target directory already contains an entry with the name, newname, the source object must be compatible with the target: either both are non-directories or both are directories and the target must be empty. If compatible, the existing target is removed before the rename occurs (See the IMPLEMENTATION subsection of the section &#34;Operation 28: REMOVE - Remove Filesystem Object&#34; for client and server actions whenever a target is removed). If they are not compatible or if the target is a directory but not empty, the server will return the error, NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the target directory already contains an entry with the name, newname, the source object must be compatible with the target: either both are non-directories or both are directories and the target must be empty. If compatible, the existing target is removed before the rename occurs (See the IMPLEMENTATION subsection of the section &#34;Operation 28: REMOVE - Remove Filesystem Object&#34; for client and server actions whenever a target is removed). If they are not compatible or if the target is a directory but not empty, the server will return the error, NFS4ERR_EXIST.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If oldname and newname both refer to the same file (they might be hard links of each other), then RENAME should perform no action and return success.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oldnameとnewnameの両方が同じファイルを参照している場合（お互いのハードリンクである可能性があります）、RENAMEは何も実行せず、成功を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For both directories involved in the RENAME, the server returns change_info4 information. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the rename.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RENAMEに関係する両方のディレクトリについて、サーバーはchange_info4情報を返します。 change_info4構造体のアトミックフィールドを使用すると、サーバーは、名前変更に関して変更前と変更後の属性がアトミックに取得されたかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the oldname refers to a named attribute and the saved and current filehandles refer to different filesystem objects, the server will return NFS4ERR_XDEV just as if the saved and current filehandles represented directories on different filesystems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oldnameが名前付き属性を参照し、保存済みファイルハンドルと現在のファイルハンドルが異なるファイルシステムオブジェクトを参照する場合、サーバーは、保存済みファイルハンドルと現在のファイルハンドルが異なるファイルシステム上のディレクトリを表す場合と同様にNFS4ERR_XDEVを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the oldname or newname has a length of 0 (zero), or if oldname or newname does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oldnameまたはnewnameの長さが0（ゼロ）である場合、またはoldnameまたはnewnameがUTF-8定義に従っていない場合、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RENAME operation must be atomic to the client. The statement &#34;source and target directories must reside on the same filesystem on the server&#34; means that the fsid fields in the attributes for the directories are the same. If they reside on different filesystems, the error, NFS4ERR_XDEV, is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RENAME操作は、クライアントに対してアトミックである必要があります。 「ソースディレクトリとターゲットディレクトリはサーバー上の同じファイルシステムに存在する必要がある」というステートメントは、ディレクトリの属性のfsidフィールドが同じであることを意味します。それらが異なるファイルシステムに存在する場合、エラーNFS4ERR_XDEVが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on the value of the fh_expire_type attribute for the object, the filehandle may or may not expire on a RENAME. However, server implementors are strongly encouraged to attempt to keep filehandles from expiring in this fashion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on the value of the fh_expire_type attribute for the object, the filehandle may or may not expire on a RENAME. However, server implementors are strongly encouraged to attempt to keep filehandles from expiring in this fashion.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On some servers, the file names &#34;.&#34; and &#34;..&#34; are illegal as either oldname or newname, and will result in the error NFS4ERR_BADNAME. In addition, on many servers the case of oldname or newname being an alias for the source directory will be checked for. Such servers will return the error NFS4ERR_INVAL in these cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のサーバーでは、ファイル名は「。」です。および「..」はoldnameまたはnewnameとしては不正であり、エラーNFS4ERR_BADNAMEが発生します。さらに、多くのサーバーでは、oldnameまたはnewnameがソースディレクトリのエイリアスであるかどうかがチェックされます。このようなサーバーは、これらの場合にエラーNFS4ERR_INVALを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If either of the source or target filehandles are not directories, the server will return NFS4ERR_NOTDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースまたはターゲットのファイルハンドルのいずれかがディレクトリでない場合、サーバーはNFS4ERR_NOTDIRを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 NFS4ERR_ACCESS NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_FHEXPIRED NFS4ERR_FILE_OPEN NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_NOTEMPTY NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC NFS4ERR_XDEV
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFS4ERR_ACCESS NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_FHEXPIRED NFS4ERR_FILE_OPEN NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_NOTEMPTY NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC NFS4ERR_XDEV
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-28--Operation-30-RENEW---Renew-a-Lease">
14.2.28. Operation 30: RENEW - Renew a Lease
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.28. 操作30：RENEW-リースを更新する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
clientid -&gt; ()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
clientid-&gt;()
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct RENEW4args {
             clientid4       clientid;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct RENEW4res {
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RENEW operation is used by the client to renew leases which it currently holds at a server. In processing the RENEW request, the server renews all leases associated with the client. The associated leases are determined by the clientid provided via the SETCLIENTID operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RENEW操作は、クライアントが現在サーバーで保持しているリースを更新するために使用されます。 RENEW要求の処理中に、サーバーはクライアントに関連付けられたすべてのリースを更新します。関連するリースは、SETCLIENTID操作で提供されるクライアントIDによって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client holds delegations, it needs to use RENEW to detect when the server has determined that the callback path is down. When the server has made such a determination, only the RENEW operation will renew the lease on delegations. If the server determines the callback path is down, it returns NFS4ERR_CB_PATH_DOWN. Even though it returns NFS4ERR_CB_PATH_DOWN, the server MUST renew the lease on the record locks and share reservations that the client has established on the server. If for some reason the lock and share reservation lease cannot be renewed, then the server MUST return an error other than NFS4ERR_CB_PATH_DOWN, even if the callback path is also down.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client holds delegations, it needs to use RENEW to detect when the server has determined that the callback path is down. When the server has made such a determination, only the RENEW operation will renew the lease on delegations. If the server determines the callback path is down, it returns NFS4ERR_CB_PATH_DOWN. Even though it returns NFS4ERR_CB_PATH_DOWN, the server MUST renew the lease on the record locks and share reservations that the client has established on the server. If for some reason the lock and share reservation lease cannot be renewed, then the server MUST return an error other than NFS4ERR_CB_PATH_DOWN, even if the callback path is also down.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client that issues RENEW MUST choose the principal, RPC security flavor, and if applicable, GSS-API mechanism and service via one of the following algorithms:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RENEWを発行するクライアントは、次のアルゴリズムのいずれかを介して、RPCの主要なセキュリティフレーバーと、該当する場合はGSS-APIメカニズムとサービスを選択する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client uses the same principal, RPC security flavor -- and if the flavor was RPCSEC_GSS -- the same mechanism and service that was used when the client id was established via SETCLIENTID_CONFIRM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントは同じプリンシパルであるRPCセキュリティフレーバーを使用し、フレーバーがRPCSEC_GSSの場合は、SETCLIENTID_CONFIRMを介してクライアントIDが確​​立されたときに使用されたのと同じメカニズムとサービスを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client uses any principal, RPC security flavor mechanism and service combination that currently has an OPEN file on the server. I.e., the same principal had a successful OPEN operation, the file is still open by that principal, and the flavor, mechanism, and service of RENEW match that of the previous OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントは、現在サーバー上にOPENファイルを持っている、RPCセキュリティフレーバーメカニズムとサービスの組み合わせを使用します。つまり、同じプリンシパルがOPEN操作に成功し、ファイルはそのプリンシパルによってまだ開かれており、RENEWのフレーバー、メカニズム、およびサービスは以前のOPENのものと一致しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MUST reject a RENEW that does not use one the aforementioned algorithms, with the error NFS4ERR_ACCESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、前述のアルゴリズムを使用しないRENEWをエラーNFS4ERR_ACCESSで拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_BADXDR NFS4ERR_CB_PATH_DOWN NFS4ERR_EXPIRED NFS4ERR_LEASE_MOVED NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE_CLIENTID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_BADXDR NFS4ERR_CB_PATH_DOWN NFS4ERR_EXPIRED NFS4ERR_LEASE_MOVED NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE_CLIENTID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-29--Operation-31-RESTOREFH---Restore-Saved-Filehandle">
14.2.29. Operation 31: RESTOREFH - Restore Saved Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.29. 操作31：RESTOREFH-保存されたファイルハンドルの復元
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(sfh) -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（sfh）-&gt;（cfh）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* SAVED_FH: */
     void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct RESTOREFH4res {
             /* CURRENT_FH: value of saved fh */
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Set the current filehandle to the value in the saved filehandle. If there is no saved filehandle then return the error NFS4ERR_RESTOREFH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルを保存されたファイルハンドルの値に設定します。保存されたファイルハンドルがない場合は、エラーNFS4ERR_RESTOREFHを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Operations like OPEN and LOOKUP use the current filehandle to represent a directory and replace it with a new filehandle. Assuming the previous filehandle was saved with a SAVEFH operator, the previous filehandle can be restored as the current filehandle. This is commonly used to obtain post-operation attributes for the directory, e.g.,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENやLOOKUPなどの操作では、現在のファイルハンドルを使用してディレクトリを表し、それを新しいファイルハンドルで置き換えます。以前のファイルハンドルがSAVEFH演算子で保存されたと仮定すると、以前のファイルハンドルを現在のファイルハンドルとして復元できます。これは通常、ディレクトリの操作後の属性を取得するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
PUTFH (directory filehandle) SAVEFH GETATTR attrbits (pre-op dir attrs) CREATE optbits &#34;foo&#34; attrs GETATTR attrbits (file attributes) RESTOREFH GETATTR attrbits (post-op dir attrs)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
PUTFH（ディレクトリファイルハンドル）SAVEFH GETATTR attrbits（pre-op dir attrs）CREATE optbits &#34;foo&#34; attrs GETATTR attrbits（file attributes）RESTOREFH GETATTR attrbits（post-op dir attrs）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_MOVED NFS4ERR_RESOURCE NFS4ERR_RESTOREFH NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_MOVED NFS4ERR_RESOURCE NFS4ERR_RESTOREFH NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-30--Operation-32-SAVEFH---Save-Current-Filehandle">
14.2.30. Operation 32: SAVEFH - Save Current Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.30. 操作32：SAVEFH-現在のファイルハンドルを保存
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) -&gt; (sfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）-&gt;（sfh）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* CURRENT_FH: */
     void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct SAVEFH4res {
             /* SAVED_FH: value of current fh */
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Save the current filehandle. If a previous filehandle was saved then it is no longer accessible. The saved filehandle can be restored as the current filehandle with the RESTOREFH operator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルを保存します。以前のファイルハンドルが保存されている場合は、アクセスできなくなります。保存されたファイルハンドルは、RESTOREFHオペレーターを使用して現在のファイルハンドルとして復元できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-31--Operation-33-SECINFO---Obtain-Available-Security">
14.2.31. Operation 33: SECINFO - Obtain Available Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.31. 操作33：SECINFO-利用可能なセキュリティを取得する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     (cfh), name -&gt; { secinfo }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct SECINFO4args {
             /* CURRENT_FH: directory */
             component4     name;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     enum rpc_gss_svc_t {/* From RFC 2203 */
             RPC_GSS_SVC_NONE        = 1,
             RPC_GSS_SVC_INTEGRITY   = 2,
             RPC_GSS_SVC_PRIVACY     = 3
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct rpcsec_gss_info {
             sec_oid4        oid;
             qop4            qop;
             rpc_gss_svc_t   service;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union secinfo4 switch (uint32_t flavor) {
      case RPCSEC_GSS:
              rpcsec_gss_info        flavor_info;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     typedef secinfo4 SECINFO4resok&lt;&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union SECINFO4res switch (nfsstat4 status) {
      case NFS4_OK:
              SECINFO4resok resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SECINFO operation is used by the client to obtain a list of valid RPC authentication flavors for a specific directory filehandle, file name pair. SECINFO should apply the same access methodology used for LOOKUP when evaluating the name. Therefore, if the requester does not have the appropriate access to LOOKUP the name then SECINFO must behave the same way and return NFS4ERR_ACCESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはSECINFO操作を使用して、特定のディレクトリファイルハンドルとファイル名のペアの有効なRPC認証フレーバーのリストを取得します。 SECINFOは、名前を評価するときにLOOKUPに使用されるものと同じアクセス方法を適用する必要があります。したがって、リクエスターがLOOKUP名に適切にアクセスできない場合、SECINFOは同じように動作し、NFS4ERR_ACCESSを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The result will contain an array which represents the security mechanisms available, with an order corresponding to server&#39;s preferences, the most preferred being first in the array. The client is free to pick whatever security mechanism it both desires and supports, or to pick in the server&#39;s preference order the first one it supports. The array entries are represented by the secinfo4 structure. The field &#39;flavor&#39; will contain a value of AUTH_NONE, AUTH_SYS (as defined in [RFC1831]), or RPCSEC_GSS (as defined in [RFC2203]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果には、サーバーの設定に対応する順序で使用可能なセキュリティメカニズムを表す配列が含まれます。最も優先されるのは配列の最初です。クライアントは、希望とサポートの両方のセキュリティメカニズムを自由に選択することも、サーバーが最初にサポートする優先順位を自由に選択することもできます。配列エントリは、secinfo4構造によって表されます。フィールド &#39;flavor&#39;には、AUTH_NONE、AUTH_SYS（[RFC1831]で定義）、またはRPCSEC_GSS（[RFC2203]で定義）の値が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the flavors AUTH_NONE and AUTH_SYS, no additional security information is returned. For a return value of RPCSEC_GSS, a security triple is returned that contains the mechanism object id (as defined in [RFC2743]), the quality of protection (as defined in [RFC2743]) and the service type (as defined in [RFC2203]). It is possible for SECINFO to return multiple entries with flavor equal to RPCSEC_GSS with different security triple values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AUTH_NONEおよびAUTH_SYSフレーバーの場合、追加のセキュリティ情報は返されません。 RPCSEC_GSSの戻り値の場合、メカニズムオブジェクトID（[RFC2743]で定義）、保護の品質（[RFC2743]で定義）、およびサービスタイプ（[RFC2203]で定義）を含むセキュリティトリプルが返されます）。 SECINFOは、異なるセキュリティトリプル値を持つRPCSEC_GSSに等しいフレーバーを持つ複数のエントリを返すことが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the name has a length of 0 (zero), or if name does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前の長さが0（ゼロ）である場合、または名前がUTF-8定義に従っていない場合、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SECINFO operation is expected to be used by the NFS client when the error value of NFS4ERR_WRONGSEC is returned from another NFS operation. This signifies to the client that the server&#39;s security policy is different from what the client is currently using. At this point, the client is expected to obtain a list of possible security flavors and choose what best suits its policies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SECINFO操作は、NFS4ERR_WRONGSECのエラー値が別のNFS操作から返されたときに、NFSクライアントによって使用されることが期待されています。これは、サーバーのセキュリティポリシーがクライアントが現在使用しているものとは異なることをクライアントに示します。この時点で、クライアントは可能なセキュリティフレーバーのリストを取得し、そのポリシーに最適なものを選択することが期待されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As mentioned, the server&#39;s security policies will determine when a client request receives NFS4ERR_WRONGSEC. The operations which may receive this error are: LINK, LOOKUP, OPEN, PUTFH, PUTPUBFH, PUTROOTFH, RESTOREFH, RENAME, and indirectly READDIR. LINK and RENAME will only receive this error if the security used for the operation is inappropriate for saved filehandle. With the exception of READDIR, these operations represent the point at which the client can instantiate a filehandle into the &#34;current filehandle&#34; at the server. The filehandle is either provided by the client (PUTFH, PUTPUBFH, PUTROOTFH) or generated as a result of a name to filehandle translation (LOOKUP and OPEN). RESTOREFH is different because the filehandle is a result of a previous SAVEFH. Even though the filehandle, for RESTOREFH, might have previously passed the server&#39;s inspection for a security match, the server will check it again on RESTOREFH to ensure that the security policy has not changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前述のように、サーバーのセキュリティポリシーは、クライアント要求がNFS4ERR_WRONGSECを受信するタイミングを決定します。このエラーを受け取る可能性のある操作は、LINK、LOOKUP、OPEN、PUTFH、PUTPUBFH、PUTROOTFH、RESTOREFH、RENAME、および間接的にREADDIRです。 LINKおよびRENAMEは、操作に使用されたセキュリティが保存されたファイルハンドルに不適切な場合にのみこのエラーを受け取ります。 READDIRを除いて、これらの操作は、クライアントがファイルハンドルをサーバーの「現在のファイルハンドル」にインスタンス化できる時点を表します。ファイルハンドルは、クライアント（PUTFH、PUTPUBFH、PUTROOTFH）によって提供されるか、名前からファイルハンドルへの変換（LOOKUPおよびOPEN）の結果として生成されます。ファイルハンドルは以前のSAVEFHの結果であるため、RESTOREFHは異なります。 RESTOREFHの場合、ファイルハンドルは以前にサーバーのセキュリティ一致の検査に合格した可能性がありますが、サーバーはRESTOREFHで再度それをチェックして、セキュリティポリシーが変更されていないことを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client wants to resolve an error return of NFS4ERR_WRONGSEC, the following will occur:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがNFS4ERR_WRONGSECのエラーリターンを解決する場合、次のことが起こります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For LOOKUP and OPEN, the client will use SECINFO with the same current filehandle and name as provided in the original LOOKUP or OPEN to enumerate the available security triples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUPおよびOPENの場合、クライアントは、元のLOOKUPまたはOPENで提供されているものと同じ現在のファイルハンドルおよび名前のSECINFOを使用して、使用可能なセキュリティトリプルを列挙します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For LINK, PUTFH, RENAME, and RESTOREFH, the client will use SECINFO and provide the parent directory filehandle and object name which corresponds to the filehandle originally provided by the PUTFH RESTOREFH, or for LINK and RENAME, the SAVEFH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LINK、PUTFH、RENAME、およびRESTOREFHの場合、クライアントはSECINFOを使用して、PUTFH RESTOREFHによって最初に提供されたファイルハンドルに対応する親ディレクトリのファイルハンドルとオブジェクト名を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o For PUTROOTFH and PUTPUBFH, the client will be unable to use the SECINFO operation since SECINFO requires a current filehandle and none exist for these two operations. Therefore, the client must iterate through the security triples available at the client and reattempt the PUTROOTFH or PUTPUBFH operation. In the unfortunate event none of the MANDATORY security triples are supported by the client and server, the client SHOULD try using others that support integrity. Failing that, the client can try using AUTH_NONE, but because such forms lack integrity checks, this puts the client at risk. Nonetheless, the server SHOULD allow the client to use whatever security form the client requests and the server supports, since the risks of doing so are on the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
o PUTROOTFHおよびPUTPUBFHの場合、SECINFOは現在のファイルハンドルを必要とし、これら2つの操作には何も存在しないため、クライアントはSECINFO操作を使用できません。したがって、クライアントは、クライアントで使用可能なセキュリティトリプルを反復処理し、PUTROOTFHまたはPUTPUBFH操作を再試行する必要があります。残念なことに、必須のセキュリティトリプルがクライアントとサーバーでサポートされていない場合、クライアントは整合性をサポートする他のものを使用してください。これに失敗すると、クライアントはAUTH_NONEの使用を試みることができますが、そのようなフォームには整合性チェックがないため、これによりクライアントが危険にさらされます。それにも関わらず、サーバーのリスクはクライアント側にあるため、サーバーはクライアントがクライアントの要求とサーバーがサポートするセキュリティ形式を使用することを許可する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The READDIR operation will not directly return the NFS4ERR_WRONGSEC error. However, if the READDIR request included a request for attributes, it is possible that the READDIR request&#39;s security triple does not match that of a directory entry. If this is the case and the client has requested the rdattr_error attribute, the server will return the NFS4ERR_WRONGSEC error in rdattr_error for the entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READDIR操作は、NFS4ERR_WRONGSECエラーを直接返しません。ただし、READDIR要求に属性の要求が含まれている場合、READDIR要求のセキュリティトリプルがディレクトリエントリのセキュリティトリプルと一致しない可能性があります。この場合、クライアントがrdattr_error属性を要求すると、サーバーはエントリのrdattr_errorにNFS4ERR_WRONGSECエラーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See the section &#34;Security Considerations&#34; for a discussion on the recommendations for security flavor used by SECINFO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SECINFOが使用するセキュリティフレーバーの推奨事項については、「セキュリティに関する考慮事項」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADXDR NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADXDR NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_RESOURCE NFS4ERR_REULT NFS4ERR_REULT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-32--Operation-34-SETATTR---Set-Attributes">
14.2.32. Operation 34: SETATTR - Set Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.32. 操作34：SETATTR-属性の設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), stateid, attrmask, attr_vals -&gt; attrsset
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、stateid、attrmask、attr_vals-&gt; attrsset
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct SETATTR4args {
             /* CURRENT_FH: target object */
             stateid4        stateid;
             fattr4          obj_attributes;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct SETATTR4res {
             nfsstat4        status;
             bitmap4         attrsset;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SETATTR operation changes one or more of the attributes of a filesystem object. The new attributes are specified with a bitmap and the attributes that follow the bitmap in bit order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTR操作は、ファイルシステムオブジェクトの1つ以上の属性を変更します。新しい属性は、ビットマップとビットマップのビットオーダーに続く属性で指定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The stateid argument for SETATTR is used to provide file locking context that is necessary for SETATTR requests that set the size attribute. Since setting the size attribute modifies the file&#39;s data, it has the same locking requirements as a corresponding WRITE. Any SETATTR that sets the size attribute is incompatible with a share reservation that specifies DENY_WRITE. The area between the old end-of-file and the new end-of-file is considered to be modified just as would have been the case had the area in question been specified as the target of WRITE, for the purpose of checking conflicts with record locks, for those cases in which a server is implementing mandatory record locking behavior. A valid stateid should always be specified. When the file size attribute is not set, the special stateid consisting of all bits zero should be passed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTRのstateid引数は、サイズ属性を設定するSETATTR要求に必要なファイルロックコンテキストを提供するために使用されます。 size属性を設定するとファイルのデータが変更されるため、対応するWRITEと同じロック要件があります。サイズ属性を設定するSETATTRは、DENY_WRITEを指定する共有予約と互換性がありません。古いファイルの終わりと新しいファイルの終わりの間の領域は、問題の領域がWRITEのターゲットとして指定されている場合と同様に、との競合をチェックするために変更されたと見なされます。レコードロック。サーバーが必須のレコードロック動作を実装している場合に使用します。常に有効な状態IDを指定する必要があります。ファイルサイズ属性が設定されていない場合は、すべてのビットがゼロからなる特別な状態IDを渡す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On either success or failure of the operation, the server will return the attrsset bitmask to represent what (if any) attributes were successfully set. The attrsset in the response is a subset of the bitmap4 that is part of the obj_attributes in the argument.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作の成功または失敗のいずれかで、サーバーは、attrssetビットマスクを返し、正常に設定された属性（存在する場合）を表します。応答のattrssetは、引数のobj_attributesの一部であるビットマップ4のサブセットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the request specifies the owner attribute to be set, the server should allow the operation to succeed if the current owner of the object matches the value specified in the request. Some servers may be implemented in a way as to prohibit the setting of the owner attribute unless the requester has privilege to do so. If the server is lenient in this one case of matching owner values, the client implementation may be simplified in cases of creation of an object followed by a SETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求が設定する所有者属性を指定する場合、サーバーは、オブジェクトの現在の所有者が要求で指定された値と一致する場合に操作を成功させる必要があります。一部のサーバーは、リクエスターがそうする特権を持たない限り、所有者属性の設定を禁止するような方法で実装される場合があります。サーバーが所有者の値を一致させるこの1つのケースに寛容である場合、SETATTRが後に続くオブジェクトの作成の場合に、クライアントの実装が単純化される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The file size attribute is used to request changes to the size of a file. A value of 0 (zero) causes the file to be truncated, a value less than the current size of the file causes data from new size to the end of the file to be discarded, and a size greater than the current size of the file causes logically zeroed data bytes to be added to the end of the file. Servers are free to implement this using holes or actual zero data bytes. Clients should not make any assumptions regarding a server&#39;s implementation of this feature, beyond that the bytes returned will be zeroed. Servers must support extending the file size via SETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ファイルサイズ属性は、ファイルサイズの変更を要求するために使用されます。値0（ゼロ）はファイルを切り捨て、ファイルの現在のサイズより小さい値は新しいサイズからファイルの終わりまでのデータを破棄し、サイズはファイルの現在のサイズより大きい論理的にゼロにされたデータバイトがファイルの最後に追加されます。サーバーは、ホールまたは実際のゼロデータバイトを使用してこれを自由に実装できます。クライアントは、サーバーのこの機能の実装に関して、返されたバイトがゼロになることを前提にしてはなりません。サーバーは、SETATTRによるファイルサイズの拡張をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTR is not guaranteed atomic. A failed SETATTR may partially change a file&#39;s attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTRはアトミックではありません。失敗したSETATTRは、ファイルの属性を部分的に変更する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Changing the size of a file with SETATTR indirectly changes the time_modify. A client must account for this as size changes can result in data deletion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTRを使用してファイルのサイズを変更すると、time_modifyが間接的に変更されます。サイズを変更するとデータが削除される可能性があるため、クライアントはこれを考慮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The attributes time_access_set and time_modify_set are write-only attributes constructed as a switched union so the client can direct the server in setting the time values. If the switched union specifies SET_TO_CLIENT_TIME4, the client has provided an nfstime4 to be used for the operation. If the switch union does not specify SET_TO_CLIENT_TIME4, the server is to use its current time for the SETATTR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性time_access_setおよびtime_modify_setは、クライアントがサーバーに時間値の設定を指示できるように、スイッチドユニオンとして構築された書き込み専用属性です。スイッチドユニオンがSET_TO_CLIENT_TIME4を指定している場合、クライアントは操作に使用するnfstime4を提供しています。スイッチユニオンでSET_TO_CLIENT_TIME4が指定されていない場合、サーバーはSETATTR操作に現在の時刻を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If server and client times differ, programs that compare client time to file times can break. A time maintenance protocol should be used to limit client/server time skew.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーとクライアントの時間が異なる場合、クライアントの時間とファイルの時間を比較するプログラムが機能しなくなる可能性があります。時間保守プロトコルを使用して、クライアント/サーバーの時間のずれを制限する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of a COMPOUND containing a VERIFY operation specifying only the change attribute, immediately followed by a SETATTR, provides a means whereby a client may specify a request that emulates the functionality of the SETATTR guard mechanism of NFS version 3. Since the function of the guard mechanism is to avoid changes to the file attributes based on stale information, delays between checking of the guard condition and the setting of the attributes have the potential to compromise this function, as would the corresponding delay in the NFS version 4 emulation. Therefore, NFS version 4 servers should take care to avoid such delays, to the degree possible, when executing such a request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変更属性のみを指定し、直後にSETATTRを指定するVERIFY操作を含むCOMPOUNDを使用すると、NFSバージョン3のSETATTRガードメカニズムの機能をエミュレートするリクエストをクライアントが指定できるようになります。ガードの機能メカニズムは、古い情報に基づくファイル属性の変更を回避することです。NFSバージョン4エミュレーションの対応する遅延と同様に、ガード条件のチェックと属性の設定の間の遅延は、この機能を損なう可能性があります。したがって、NFSバージョン4サーバーは、このような要求を実行するときに、可能な限りこのような遅延を回避するように注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server does not support an attribute as requested by the client, the server should return NFS4ERR_ATTRNOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがクライアントから要求された属性をサポートしていない場合、サーバーはNFS4ERR_ATTRNOTSUPPを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A mask of the attributes actually set is returned by SETATTR in all cases. That mask must not include attributes bits not requested to be set by the client, and must be equal to the mask of attributes requested to be set only if the SETATTR completes without error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実際に設定される属性のマスクは、すべての場合にSETATTRによって返されます。そのマスクには、クライアントが設定するように要求していない属性ビットを含めてはならず、SETATTRがエラーなしで完了した場合にのみ設定するように要求された属性のマスクと等しくなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_ATTRNOTSUPP NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADOWNER NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXPIRED NFS4ERR_FBIG NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_LOCKED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_OLD_STATEID NFS4ERR_OPENMODE NFS4ERR_PERM NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_ATTRNOTSUPP NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADOWNER NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXPIRED NFS4ERR_FBIG NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_LOCKED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_OLD_STATEID NFS4ERR_OPENMODE NFS4ERR_PERM NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-33--Operation-35-SETCLIENTID---Negotiate-Clientid">
14.2.33. Operation 35: SETCLIENTID - Negotiate Clientid
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.33. 操作35：SETCLIENTID-クライアントIDをネゴシエートする
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
client, callback, callback_ident -&gt; clientid, setclientid_confirm
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
client、callback、callback_ident-&gt; clientid、setclientid_confirm
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct SETCLIENTID4args {
             nfs_client_id4  client;
             cb_client4      callback;
             uint32_t        callback_ident;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct SETCLIENTID4resok {
             clientid4       clientid;
             verifier4       setclientid_confirm;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union SETCLIENTID4res switch (nfsstat4 status) {
      case NFS4_OK:
              SETCLIENTID4resok      resok4;
      case NFS4ERR_CLID_INUSE:
              clientaddr4    client_using;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client uses the SETCLIENTID operation to notify the server of its intention to use a particular client identifier, callback, and callback_ident for subsequent requests that entail creating lock, share reservation, and delegation state on the server. Upon successful completion the server will return a shorthand clientid which, if confirmed via a separate step, will be used in subsequent file locking and file open requests. Confirmation of the clientid must be done via the SETCLIENTID_CONFIRM operation to return the clientid and setclientid_confirm values, as verifiers, to the server. The reason why two verifiers are necessary is that it is possible to use SETCLIENTID and SETCLIENTID_CONFIRM to modify the callback and callback_ident information but not the shorthand clientid. In that event, the setclientid_confirm value is effectively the only verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはSETCLIENTID操作を使用して、サーバー上でのロック、共有予約、および委任状態の作成を伴う後続の要求に対して、特定のクライアント識別子、コールバック、およびcallback_identを使用する意図をサーバーに通知します。正常に完了すると、サーバーは省略形のclientidを返します。これは、別の手順で確認された場合、後続のファイルロックおよびファイルオープン要求で使用されます。 clientidの確認はSETCLIENTID_CONFIRMオペレーションを介して行われ、clientidとsetclientid_confirmの値がベリファイアとしてサーバーに返されます。 2つのベリファイアが必要な理由は、SETCLIENTIDとSETCLIENTID_CONFIRMを使用して、コールバックとコールバックID情報を変更できるが、省略形のクライアントIDは変更できないためです。その場合、事実上、setclientid_confirm値が唯一のベリファイアになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The callback information provided in this operation will be used if the client is provided an open delegation at a future point. Therefore, the client must correctly reflect the program and port numbers for the callback program at the time SETCLIENTID is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作で提供されるコールバック情報は、将来クライアントにオープンな委任が提供される場合に使用されます。したがって、クライアントは、SETCLIENTIDの使用時に、コールバックプログラムのプログラムとポート番号を正しく反映する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The callback_ident value is used by the server on the callback. The client can leverage the callback_ident to eliminate the need for more than one callback RPC program number, while still being able to determine which server is initiating the callback.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The callback_ident value is used by the server on the callback. The client can leverage the callback_ident to eliminate the need for more than one callback RPC program number, while still being able to determine which server is initiating the callback.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To understand how to implement SETCLIENTID, make the following notations. Let:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDを実装する方法を理解するには、次の表記を行います。みましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
x be the value of the client.id subfield of the SETCLIENTID4args structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
xは、SETCLIENTID4args構造体のclient.idサブフィールドの値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
v be the value of the client.verifier subfield of the SETCLIENTID4args structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
v SETCLIENTID4args構造のclient.verifierサブフィールドの値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c be the value of the clientid field returned in the SETCLIENTID4resok structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cは、SETCLIENTID4resok構造体で返されるclientidフィールドの値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
k represent the value combination of the fields callback and callback_ident fields of the SETCLIENTID4args structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kは、SETCLIENTID4args構造体のフィールドcallbackおよびcallback_identフィールドの値の組み合わせを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
s be the setclientid_confirm value returned in the SETCLIENTID4resok structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
■SETCLIENTID4resok構造体で返されるsetclientid_confirm値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{ v, x, c, k, s } be a quintuple for a client record. A client record is confirmed if there has been a SETCLIENTID_CONFIRM operation to confirm it. Otherwise it is unconfirmed. An unconfirmed record is established by a SETCLIENTID call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{v、x、c、k、s}は、クライアントレコードの5つ組です。確認のためのSETCLIENTID_CONFIRM操作があった場合、クライアントレコードが確認されます。それ以外の場合は未確認です。未確認のレコードは、SETCLIENTID呼び出しによって確立されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since SETCLIENTID is a non-idempotent operation, let us assume that the server is implementing the duplicate request cache (DRC).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDはべき等ではない操作であるため、サーバーが重複要求キャッシュ（DRC）を実装していると仮定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server gets a SETCLIENTID { v, x, k } request, it processes it in the following manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがSETCLIENTID {v、x、k}リクエストを受け取ると、次の方法でそれを処理します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It first looks up the request in the DRC. If there is a hit, it returns the result cached in the DRC. The server does NOT remove client state (locks, shares, delegations) nor does it modify any recorded callback and callback_ident information for client { x }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o まずDRCでリクエストを検索します。ヒットがある場合、DRCにキャッシュされた結果を返します。サーバーはクライアントの状態（ロック、共有、委任）を削除せず、クライアント{x}の記録されたコールバックとcallback_ident情報を変更しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
For any DRC miss, the server takes the client id string x, and searches for client records for x that the server may have recorded from previous SETCLIENTID calls. For any confirmed record with the same id string x, if the recorded principal does not match that of SETCLIENTID call, then the server returns a NFS4ERR_CLID_INUSE error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DRCミスの場合、サーバーはクライアントID文字列xを取得し、サーバーが以前のSETCLIENTID呼び出しから記録した可能性のあるxのクライアントレコードを検索します。同じID文字列xを持つ確認済みのレコードについて、記録されたプリンシパルがSETCLIENTID呼び出しのプリンシパルと一致しない場合、サーバーはNFS4ERR_CLID_INUSEエラーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
For brevity of discussion, the remaining description of the processing assumes that there was a DRC miss, and that where the server has previously recorded a confirmed record for client x, the aforementioned principal check has successfully passed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
説明を簡潔にするために、残りの処理の説明では、DRCミスがあったこと、およびサーバーがクライアントxの確認済みレコードを以前に記録している場合、前述のプリンシパルチェックが成功したことを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server checks if it has recorded a confirmed record for { v, x, c, l, s }, where l may or may not equal k. If so, and since the id verifier v of the request matches that which is confirmed and recorded, the server treats this as a probable callback information update and records an unconfirmed { v, x, c, k, t } and leaves the confirmed { v, x, c, l, s } in place, such that t != s. It does not matter if k equals l or not. Any pre-existing unconfirmed { v, x, c, *, * } is removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは、{v、x、c、l、s}の確認済みレコードを記録したかどうかをチェックします。ここで、lはkと等しい場合と等しくない場合があります。その場合、リクエストのidベリファイアvが確認および記録されたものと一致するため、サーバーはこれをコールバック情報の更新の可能性として扱い、未確認の{v、x、c、k、t}を記録して確認済みの{ v、x、c、l、s}が所定の位置に配置され、t！= sとなる。 kがlに等しいかどうかは問題ではありません。既存の未確認の{v、x、c、*、*}は削除されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server returns { c, t }. It is indeed returning the old clientid4 value c, because the client apparently only wants to update callback value k to value l. It&#39;s possible this request is one from the Byzantine router that has stale callback information, but this is not a problem. The callback information update is only confirmed if followed up by a SETCLIENTID_CONFIRM { c, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは{c、t}を返します。実際、クライアントはコールバック値kを値lに更新したいだけなので、古いclientid4値cを返します。このリクエストは、古いコールバック情報を持つビザンチンルーターからのリクエストである可能性がありますが、これは問題ではありません。コールバック情報の更新は、SETCLIENTID_CONFIRM {c、t}が続く場合にのみ確認されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server awaits confirmation of k via SETCLIENTID_CONFIRM { c, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、SETCLIENTID_CONFIRM {c、t}によるkの確認を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server does NOT remove client (lock/share/delegation) state for x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、xのクライアント（ロック/共有/委任）状態を削除しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has previously recorded a confirmed { u, x, c, l, s } record such that v != u, l may or may not equal k, and has not recorded any unconfirmed { *, x, *, *, * } record for x. The server records an unconfirmed { v, x, d, k, t } (d != c, t != s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは以前に、確認済みの{u、x、c、l、s}レコードを記録したため、v！= u、lはkに等しい場合と等しくない場合があり、未確認の{*、x、*、*、*は記録していません。 xのレコード。サーバーは未確認の{v、x、d、k、t}（d！= c、t！= s）を記録します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server returns { d, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは{d、t}を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server awaits confirmation of { d, k } via SETCLIENTID_CONFIRM { d, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、SETCLIENTID_CONFIRM {d、t}による{d、k}の確認を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server does NOT remove client (lock/share/delegation) state for x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、xのクライアント（ロック/共有/委任）状態を削除しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has previously recorded a confirmed { u, x, c, l, s } record such that v != u, l may or may not equal k, and recorded an unconfirmed { w, x, d, m, t } record such that c != d, t != s, m may or may not equal k, m may or may not equal l, and k may or may not equal l. Whether w == v or w != v makes no difference. The server simply removes the unconfirmed { w, x, d, m, t } record and replaces it with an unconfirmed { v, x, e, k, r } record, such that e != d, e != c, r != t, r != s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは以前に、確認済みの{u、x、c、l、s}レコードを記録したため、v！= u、lはkに等しい場合と等しくない場合があり、未確認の{w、x、d、m、t}レコードを記録しましたc！= d、t！= s、mはkと等しくても等しくなくてもよく、mはlと等しくても等しくなくてもよく、kはlと等しくても等しくなくてもかまいません。 w == vでもw！= vでも違いはありません。サーバーは、未確認の{w、x、d、m、t}レコードを削除し、それを未確認の{v、x、e、k、r}レコードに置き換えるだけで、e！= d、e！= c、r ！= t、r！= s。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server returns { e, r }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは{e、r}を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server awaits confirmation of { e, k } via SETCLIENTID_CONFIRM { e, r }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、SETCLIENTID_CONFIRM {e、r}による{e、k}の確認を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server does NOT remove client (lock/share/delegation) state for x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、xのクライアント（ロック/共有/委任）状態を削除しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has no confirmed { *, x, *, *, * } for x. It may or may not have recorded an unconfirmed { u, x, c, l, s }, where l may or may not equal k, and u may or may not equal v. Any unconfirmed record { u, x, c, l, * }, regardless whether u == v or l == k, is replaced with an unconfirmed record { v, x, d, k, t } where d != c, t != s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーにはxの確認済み{*、x、*、*、*}がありません。未確認の{u、x、c、l、s}が記録されている場合と記録されていない場合があり、lはkと等しい場合と異なる場合があり、uはvと異なる場合があります。未確認のレコード{u、x、c、l 、*}は、u == vでもl == kでも、未確認のレコード{v、x、d、k、t}で置き換えられます。ここで、d！= c、t！= sです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server returns { d, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは{d、t}を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server awaits confirmation of { d, k } via SETCLIENTID_CONFIRM { d, t }. The server does NOT remove client (lock/share/delegation) state for x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server awaits confirmation of { d, k } via SETCLIENTID_CONFIRM { d, t }. The server does NOT remove client (lock/share/delegation) state for x.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server generates the clientid and setclientid_confirm values and must take care to ensure that these values are extremely unlikely to ever be regenerated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはclientidとsetclientid_confirmの値を生成し、これらの値が再生成される可能性が極めて低いことを確認するように注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADXDR NFS4ERR_CLID_INUSE NFS4ERR_INVAL NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADXDR NFS4ERR_CLID_INUSE NFS4ERR_INVAL NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-34--Operation-36-SETCLIENTIDCONFIRM---Confirm-Clientid">
14.2.34. Operation 36: SETCLIENTID_CONFIRM - Confirm Clientid
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.34. Operation 36: SETCLIENTID_CONFIRM - Confirm Clientid
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     clientid, verifier -&gt; -
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct SETCLIENTID_CONFIRM4args {
             clientid4       clientid;
             verifier4       setclientid_confirm;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct SETCLIENTID_CONFIRM4res {
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used by the client to confirm the results from a previous call to SETCLIENTID. The client provides the server supplied (from a SETCLIENTID response) clientid. The server responds with a simple status of success or failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、クライアントが以前のSETCLIENTIDの呼び出しの結果を確認するために使用されます。クライアントは、（SETCLIENTID応答から）提供されたクライアントIDのサーバーを提供します。サーバーは、成功または失敗の単純なステータスで応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client must use the SETCLIENTID_CONFIRM operation to confirm the following two distinct cases:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、SETCLIENTID_CONFIRM操作を使用して、次の2つの異なるケースを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client&#39;s use of a new shorthand client identifier (as returned from the server in the response to SETCLIENTID), a new callback value (as specified in the arguments to SETCLIENTID) and a new callback_ident (as specified in the arguments to SETCLIENTID) value. The client&#39;s use of SETCLIENTID_CONFIRM in this case also confirms the removal of any of the client&#39;s previous relevant leased state. Relevant leased client state includes record locks, share reservations, and where the server does not support the CLAIM_DELEGATE_PREV claim type, delegations. If the server supports CLAIM_DELEGATE_PREV, then SETCLIENTID_CONFIRM MUST NOT remove delegations for this client; relevant leased client state would then just include record locks and share reservations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントによる新しい短縮クライアント識別子（SETCLIENTIDへの応答でサーバーから返される）、新しいコールバック値（SETCLIENTIDの引数で指定）、および新しいcallback_ident（SETCLIENTIDの引数で指定）の値。この場合のクライアントのSETCLIENTID_CONFIRMの使用は、クライアントの以前の関連するリース状態の削除も確認します。関連するリースクライアントの状態には、レコードロック、共有予約、およびサーバーがCLAIM_DELEGATE_PREVクレームタイプをサポートしていない場合の委任が含まれます。サーバーがCLAIM_DELEGATE_PREVをサポートする場合、SETCLIENTID_CONFIRMはこのクライアントの委任を削除してはなりません（MUST NOT）。その場合、関連するリースクライアントの状態には、レコードロックと共有予約のみが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client&#39;s re-use of an old, previously confirmed, shorthand client identifier, a new callback value, and a new callback_ident value. The client&#39;s use of SETCLIENTID_CONFIRM in this case MUST NOT result in the removal of any previous leased state (locks, share reservations, and delegations)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 古い、以前に確認された、省略形のクライアント識別子、新しいコールバック値、および新しいcallback_ident値のクライアントの再利用。この場合のクライアントのSETCLIENTID_CONFIRMの使用は、以前のリース状態（ロック、共有予約、および委任）を削除してはいけません（MUST NOT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We use the same notation and definitions for v, x, c, k, s, and unconfirmed and confirmed client records as introduced in the description of the SETCLIENTID operation. The arguments to SETCLIENTID_CONFIRM are indicated by the notation { c, s }, where c is a value of type clientid4, and s is a value of type verifier4 corresponding to the setclientid_confirm field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTID操作の説明で紹介したv、x、c、k、s、および未確認および確認済みのクライアントレコードには、同じ表記法と定義を使用します。 SETCLIENTID_CONFIRMへの引数は、表記{c、s}で示されます。ここで、cはclientid4型の値、sはsetclientid_confirmフィールドに対応するverifier4型の値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with SETCLIENTID, SETCLIENTID_CONFIRM is a non-idempotent operation, and we assume that the server is implementing the duplicate request cache (DRC).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDと同様に、SETCLIENTID_CONFIRMはべき等ではない操作であり、サーバーは重複リクエストキャッシュ（DRC）を実装していると想定しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server gets a SETCLIENTID_CONFIRM { c, s } request, it processes it in the following manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがSETCLIENTID_CONFIRM {c、s}リクエストを受け取ると、次の方法で処理します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It first looks up the request in the DRC. If there is a hit, it returns the result cached in the DRC. The server does not remove any relevant leased client state nor does it modify any recorded callback and callback_ident information for client { x } as represented by the shorthand value c.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o まずDRCでリクエストを検索します。ヒットがある場合、DRCにキャッシュされた結果を返します。サーバーは、関連するリースされたクライアントの状態を削除したり、省略値cで表されるクライアント{x}の記録されたコールバックおよびcallback_ident情報を変更したりしません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a DRC miss, the server checks for client records that match the shorthand value c. The processing cases are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DRCミスの場合、サーバーは、省略値cに一致するクライアントレコードをチェックします。処理ケースは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has recorded an unconfirmed { v, x, c, k, s } record and a confirmed { v, x, c, l, t } record, such that s != t. If the principals of the records do not match that of the SETCLIENTID_CONFIRM, the server returns NFS4ERR_CLID_INUSE, and no relevant leased client state is removed and no recorded callback and callback_ident information for client { x } is changed. Otherwise, the confirmed { v, x, c, l, t } record is removed and the unconfirmed { v, x, c, k, s } is marked as confirmed, thereby modifying recorded and confirmed callback and callback_ident information for client { x }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは未確認の{v、x、c、k、s}レコードと確認済みの{v、x、c、l、t}レコードを記録しました（s！= tなど）。レコードのプリンシパルがSETCLIENTID_CONFIRMのプリンシパルと一致しない場合、サーバーはNFS4ERR_CLID_INUSEを返し、関連するリースされたクライアントの状態は削除されず、クライアント{x}の記録されたコールバックおよびcallback_ident情報は変更されません。それ以外の場合は、確認済みの{v、x、c、l、t}レコードが削除され、未確認の{v、x、c、k、s}が確認済みとしてマークされます。これにより、クライアント{xの記録および確認済みのコールバックとcallback_ident情報が変更されます}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server does not remove any relevant leased client state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、関連するリースされたクライアントの状態を削除しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server returns NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーはNFS4_OKを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has not recorded an unconfirmed { v, x, c, *, * } and has recorded a confirmed { v, x, c, *, s }. If the principals of the record and of SETCLIENTID_CONFIRM do not match, the server returns NFS4ERR_CLID_INUSE without removing any relevant leased client state and without changing recorded callback and callback_ident values for client { x }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは未確認の{v、x、c、*、*}を記録しておらず、確認済みの{v、x、c、*、s}を記録しています。レコードのプリンシパルとSETCLIENTID_CONFIRMのプリンシパルが一致しない場合、サーバーは関連するリースされたクライアントの状態を削除せずに、クライアント{x}の記録されたコールバックとcallback_ident値を変更せずに、NFS4ERR_CLID_INUSEを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the principals match, then what has likely happened is that the client never got the response from the SETCLIENTID_CONFIRM, and the DRC entry has been purged. Whatever the scenario, since the principals match, as well as { c, s } matching a confirmed record, the server leaves client x&#39;s relevant leased client state intact, leaves its callback and callback_ident values unmodified, and returns NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
プリンシパルが一致する場合は、クライアントがSETCLIENTID_CONFIRMから応答を受け取っておらず、DRCエントリが削除されている可能性があります。どのシナリオでも、プリンシパルが一致し、{c、s}が確認済みレコードと一致するため、サーバーはクライアントxの関連するリースされたクライアントの状態をそのまま残し、コールバックとcallback_identの値を変更せずに、NFS4_OKを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has not recorded a confirmed { *, *, c, *, * }, and has recorded an unconfirmed { *, x, c, k, s }. Even if this is a retry from client, nonetheless the client&#39;s first SETCLIENTID_CONFIRM attempt was not received by the server. Retry or not, the server doesn&#39;t know, but it processes it as if were a first try. If the principal of the unconfirmed { *, x, c, k, s } record mismatches that of the SETCLIENTID_CONFIRM request the server returns NFS4ERR_CLID_INUSE without removing any relevant leased client state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは確認済みの{*、*、c、*、*}を記録しておらず、未確認の{*、x、c、k、s}を記録しています。これがクライアントからの再試行であっても、クライアントの最初のSETCLIENTID_CONFIRM試行はサーバーによって受信されませんでした。再試行するかどうか、サーバーは認識しませんが、最初の試行のように処理します。未確認の{*、x、c、k、s}レコードのプリンシパルがSETCLIENTID_CONFIRMリクエストのプリンシパルと一致しない場合、サーバーは関連するリースクライアントの状態を削除せずにNFS4ERR_CLID_INUSEを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Otherwise, the server records a confirmed { *, x, c, k, s }. If there is also a confirmed { *, x, d, *, t }, the server MUST remove the client x&#39;s relevant leased client state, and overwrite the callback state with k. The confirmed record { *, x, d, *, t } is removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
それ以外の場合、サーバーは確認済みの{*、x、c、k、s}を記録します。確認済みの{*、x、d、*、t}もある場合、サーバーはクライアントxの関連するリースされたクライアント状態を削除し、コールバック状態をkで上書きする必要があります。確認されたレコード{*、x、d、*、t}が削除されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Server returns NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーはNFS4_OKを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has no record of a confirmed or unconfirmed { *, *, c, *, s }. The server returns NFS4ERR_STALE_CLIENTID. The server does not remove any relevant leased client state, nor does it modify any recorded callback and callback_ident information for any client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーには確認済みまたは未確認の{*、*、c、*、s}の記録がありません。サーバーはNFS4ERR_STALE_CLIENTIDを返します。サーバーは、関連するリースされたクライアントの状態を削除したり、クライアントの記録されたコールバックやcallback_ident情報を変更したりしません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server needs to cache unconfirmed { v, x, c, k, s } client records and await for some time their confirmation. As should be clear from the record processing discussions for SETCLIENTID and SETCLIENTID_CONFIRM, there are cases where the server does not deterministically remove unconfirmed client records. To avoid running out of resources, the server is not required to hold unconfirmed records indefinitely. One strategy the server might use is to set a limit on how many unconfirmed client records it will maintain, and then when the limit would be exceeded, remove the oldest record. Another strategy might be to remove an unconfirmed record when some amount of time has elapsed. The choice of the amount of time is fairly arbitrary but it is surely no higher than the server&#39;s lease time period. Consider that leases need to be renewed before the lease time expires via an operation from the client. If the client cannot issue a SETCLIENTID_CONFIRM after a SETCLIENTID before a period of time equal to that of a lease expires, then the client is unlikely to be able maintain state on the server during steady state operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは未確認の{v、x、c、k、s}クライアントレコードをキャッシュし、しばらくの間それらの確認を待つ必要があります。 SETCLIENTIDおよびSETCLIENTID_CONFIRMのレコード処理の説明から明らかなように、サーバーが未確認のクライアントレコードを確定的に削除しない場合があります。リソースの不足を回避するために、サーバーは未確認のレコードを無期限に保持する必要はありません。サーバーが使用する可能性がある1つの戦略は、サーバーが保持する未確認のクライアントレコードの数に制限を設定し、制限を超える場合は最も古いレコードを削除することです。別の戦略は、一定の時間が経過したときに未確認のレコードを削除することです。時間の選択はかなり恣意的ですが、それは確かにサーバーのリース期間より長くはありません。クライアントからの操作によってリース時間が期限切れになる前に、リースを更新する必要があることを考慮してください。 SETCLIENTIDの後、リースの期間と同じ期間が経過する前にクライアントがSETCLIENTID_CONFIRMを発行できない場合、クライアントは定常状態の操作中にサーバーの状態を維持できない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client does send a SETCLIENTID_CONFIRM for an unconfirmed record that the server has already deleted, the client will get NFS4ERR_STALE_CLIENTID back. If so, the client should then start over, and send SETCLIENTID to reestablish an unconfirmed client record and get back an unconfirmed clientid and setclientid_confirm verifier. The client should then send the SETCLIENTID_CONFIRM to confirm the clientid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがサーバーがすでに削除した未確認のレコードに対してSETCLIENTID_CONFIRMを送信した場合、クライアントはNFS4ERR_STALE_CLIENTIDを返します。その場合は、クライアントは最初からやり直し、SETCLIENTIDを送信して未確認のクライアントレコードを再確立し、未確認のclientidおよびsetclientid_confirmベリファイアを取得します。その後、クライアントはSETCLIENTID_CONFIRMを送信してclientidを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTID_CONFIRM does not establish or renew a lease. However, if SETCLIENTID_CONFIRM removes relevant leased client state, and that state does not include existing delegations, the server MUST allow the client a period of time no less than the value of lease_time attribute, to reclaim, (via the CLAIM_DELEGATE_PREV claim type of the OPEN operation) its delegations before removing unreclaimed delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTID_CONFIRMは、リースを確立または更新しません。ただし、SETCLIENTID_CONFIRMが関連するリースされたクライアントの状態を削除し、その状態に既存の委任が含まれていない場合、サーバーは、クライアントがlease_time属性の値以上の期間、（OPENのCLAIM_DELEGATE_PREVクレームタイプを介して）再要求することを許可する必要がありますオペレーション）未回収の委任を削除する前のその委任。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADXDR NFS4ERR_CLID_INUSE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE_CLIENTID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADXDR NFS4ERR_CLID_INUSE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE_CLIENTID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-35--Operation-37-VERIFY---Verify-Same-Attributes">
14.2.35. Operation 37: VERIFY - Verify Same Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.35. 操作37：VERIFY-同じ属性を確認する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     (cfh), fattr -&gt; -
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct VERIFY4args {
             /* CURRENT_FH: object */
             fattr4          obj_attributes;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct VERIFY4res {
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The VERIFY operation is used to verify that attributes have a value assumed by the client before proceeding with following operations in the compound request. If any of the attributes do not match then the error NFS4ERR_NOT_SAME must be returned. The current filehandle retains its value after successful completion of the operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VERIFY操作は、複合リクエストで次の操作に進む前に、属性がクライアントによって想定された値を持っていることを確認するために使用されます。いずれかの属性が一致しない場合は、エラーNFS4ERR_NOT_SAMEを返す必要があります。現在のファイルハンドルは、操作が正常に完了した後もその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One possible use of the VERIFY operation is the following compound sequence. With this the client is attempting to verify that the file being removed will match what the client expects to be removed. This sequence can help prevent the unintended deletion of a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VERIFY操作の1つの可能な使用法は、次の複合シーケンスです。これにより、クライアントは、削除されるファイルが、クライアントが削除することを期待しているものと一致することを確認しようとします。このシーケンスは、意図しないファイルの削除を防ぐのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
PUTFH (directory filehandle) LOOKUP (file name) VERIFY (filehandle == fh) PUTFH (directory filehandle) REMOVE (file name)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
PUTFH（ディレクトリファイルハンドル）LOOKUP（ファイル名）VERIFY（ファイルハンドル== fh）PUTFH（ディレクトリファイルハンドル）REMOVE（ファイル名）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This sequence does not prevent a second client from removing and creating a new file in the middle of this sequence but it does help avoid the unintended result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This sequence does not prevent a second client from removing and creating a new file in the middle of this sequence but it does help avoid the unintended result.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that a recommended attribute is specified in the VERIFY operation and the server does not support that attribute for the filesystem object, the error NFS4ERR_ATTRNOTSUPP is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VERIFY操作で推奨属性が指定されていて、サーバーがファイルシステムオブジェクトのその属性をサポートしていない場合、エラーNFS4ERR_ATTRNOTSUPPがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the attribute rdattr_error or any write-only attribute (e.g., time_modify_set) is specified, the error NFS4ERR_INVAL is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性rdattr_errorまたは書き込み専用属性（time_modify_setなど）が指定されている場合、エラーNFS4ERR_INVALがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ATTRNOTSUPP NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOT_SAME NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ATTRNOTSUPP NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOT_SAME NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_NOSOURCEHANDLE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-36--Operation-38-WRITE---Write-to-File">
14.2.36. Operation 38: WRITE - Write to File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.36. 操作38：書き込み-ファイルへの書き込み
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), stateid, offset, stable, data -&gt; count, committed, writeverf
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、stateid、offset、stable、data-&gt; count、commited、writeverf
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     enum stable_how4 {
             UNSTABLE4       = 0,
             DATA_SYNC4      = 1,
             FILE_SYNC4      = 2
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct WRITE4args {
             /* CURRENT_FH: file */
             stateid4        stateid;
             offset4         offset;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             stable_how4     stable;
             opaque          data&lt;&gt;;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct WRITE4resok {
             count4          count;
             stable_how4     committed;
             verifier4       writeverf;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union WRITE4res switch (nfsstat4 status) {
      case NFS4_OK:
              WRITE4resok    resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The WRITE operation is used to write data to a regular file. The target file is specified by the current filehandle. The offset specifies the offset where the data should be written. An offset of 0 (zero) specifies that the write should start at the beginning of the file. The count, as encoded as part of the opaque data parameter, represents the number of bytes of data that are to be written. If the count is 0 (zero), the WRITE will succeed and return a count of 0 (zero) subject to permissions checking. The server may choose to write fewer bytes than requested by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WRITE操作は、通常のファイルにデータを書き込むために使用されます。ターゲットファイルは、現在のファイルハンドルによって指定されます。オフセットは、データが書き込まれるオフセットを指定します。オフセット0（ゼロ）は、ファイルの先頭から書き込みを開始することを指定します。不透明なデータパラメータの一部としてエンコードされたカウントは、書き込まれるデータのバイト数を表します。カウントが0（ゼロ）の場合、WRITEは成功し、権限チェックの対象として0（ゼロ）のカウントを返します。サーバーは、クライアントが要求したよりも少ないバイト数を書き込むことを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Part of the write request is a specification of how the write is to be performed. The client specifies with the stable parameter the method of how the data is to be processed by the server. If stable is FILE_SYNC4, the server must commit the data written plus all filesystem metadata to stable storage before returning results. This corresponds to the NFS version 2 protocol semantics. Any other behavior constitutes a protocol violation. If stable is DATA_SYNC4, then the server must commit all of the data to stable storage and enough of the metadata to retrieve the data before returning. The server implementor is free to implement DATA_SYNC4 in the same fashion as FILE_SYNC4, but with a possible performance drop. If stable is UNSTABLE4, the server is free to commit any part of the data and the metadata to stable storage, including all or none, before returning a reply to the client. There is no guarantee whether or when any uncommitted data will subsequently be committed to stable storage. The only guarantees made by the server are that it will not destroy any data without changing the value of verf and that it will not commit the data and metadata at a level less than that requested by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
書き込み要求の一部は、書き込みの実行方法の指定です。クライアントは、stableパラメーターを使用して、サーバーによるデータの処理方法を指定します。 stableがFILE_SYNC4の場合、サーバーは結果を返す前に、書き込まれたデータとすべてのファイルシステムメタデータを安定したストレージにコミットする必要があります。これは、NFSバージョン2プロトコルのセマンティクスに対応しています。その他の動作はプロトコル違反になります。 stableがDATA_SYNC4の場合、サーバーはすべてのデータを安定したストレージにコミットし、戻る前にデータを取得するのに十分なメタデータをコミットする必要があります。サーバーの実装者は、FILE_SYNC4と同じ方法でDATA_SYNC4を自由に実装できますが、パフォーマンスが低下する可能性があります。 stableがUNSTABLE4の場合、サーバーは、クライアントに応答を返す前に、データおよびメタデータのすべてまたは一部を含めずに、安定したストレージに自由にコミットできます。コミットされていないデータが後で安定したストレージにコミットされるかどうか、またはいつコミットされるかは保証されません。サーバーが行う唯一の保証は、verfの値を変更せずにデータを破棄しないこと、およびクライアントから要求されたレベルよりも低いレベルでデータとメタデータをコミットしないことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The stateid value for a WRITE request represents a value returned from a previous record lock or share reservation request. The stateid is used by the server to verify that the associated share reservation and any record locks are still valid and to update lease timeouts for the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WRITE要求のstateid値は、前のレコードロックまたは共有予約要求から返された値を表します。サーバーはstateidを使用して、関連付けられた共有予約とレコードロックがまだ有効であることを確認し、クライアントのリースタイムアウトを更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon successful completion, the following results are returned. The count result is the number of bytes of data written to the file. The server may write fewer bytes than requested. If so, the actual number of bytes written starting at location, offset, is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正常に完了すると、次の結果が返されます。カウント結果は、ファイルに書き込まれたデータのバイト数です。サーバーは要求されたよりも少ないバイトを書き込む場合があります。その場合、オフセットで始まる場所に書き込まれた実際のバイト数が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server also returns an indication of the level of commitment of the data and metadata via committed. If the server committed all data and metadata to stable storage, committed should be set to FILE_SYNC4. If the level of commitment was at least as strong as DATA_SYNC4, then committed should be set to DATA_SYNC4. Otherwise, committed must be returned as UNSTABLE4. If stable was FILE4_SYNC, then committed must also be FILE_SYNC4: anything else constitutes a protocol violation. If stable was DATA_SYNC4, then committed may be FILE_SYNC4 or DATA_SYNC4: anything else constitutes a protocol violation. If stable was UNSTABLE4, then committed may be either FILE_SYNC4, DATA_SYNC4, or UNSTABLE4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、commitedを介したデータとメタデータのコミットメントのレベルの指標も返します。サーバーがすべてのデータとメタデータを安定したストレージにコミットした場合、committedをFILE_SYNC4に設定する必要があります。コミットメントのレベルが少なくともDATA_SYNC4と同じくらい強い場合は、committedをDATA_SYNC4に設定する必要があります。それ以外の場合、commitedはUNSTABLE4として返される必要があります。 stableがFILE4_SYNCの場合、commitedもFILE_SYNC4でなければなりません。それ以外はプロトコル違反になります。安定がDATA_SYNC4の場合、コミットされるのはFILE_SYNC4またはDATA_SYNC4である可能性があります。それ以外はプロトコル違反を構成します。 stableがUNSTABLE4の場合、commitedはFILE_SYNC4、DATA_SYNC4、またはUNSTABLE4のいずれかになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The final portion of the result is the write verifier. The write verifier is a cookie that the client can use to determine whether the server has changed instance (boot) state between a call to WRITE and a subsequent call to either WRITE or COMMIT. This cookie must be consistent during a single instance of the NFS version 4 protocol service and must be unique between instances of the NFS version 4 protocol server, where uncommitted data may be lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果の最後の部分は書き込みベリファイアです。書き込みベリファイアは、クライアントが、サーバーがWRITEの呼び出しとそれに続くWRITEまたはCOMMITの呼び出しの間にインスタンス（ブート）状態を変更したかどうかを判断するために使用できるCookieです。このCookieは、NFSバージョン4プロトコルサービスの単一インスタンスで一貫している必要があり、コミットされていないデータが失われる可能性があるNFSバージョン4プロトコルサーバーのインスタンス間で一意でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client writes data to the server with the stable argument set to UNSTABLE4 and the reply yields a committed response of DATA_SYNC4 or UNSTABLE4, the client will follow up some time in the future with a COMMIT operation to synchronize outstanding asynchronous data and metadata with the server&#39;s stable storage, barring client error. It is possible that due to client crash or other error that a subsequent COMMIT will not be received by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが安定した引数をUNSTABLE4に設定してサーバーにデータを書き込み、その応答がDATA_SYNC4またはUNSTABLE4のコミットされた応答を生成する場合、クライアントはCOMMIT操作でしばらく待って、未処理の非同期データとメタデータを同期します。サーバーの安定したストレージ。クライアントエラーはありません。クライアントのクラッシュまたはその他のエラーのために、後続のCOMMITがサーバーによって受信されない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 For a WRITE with a stateid value of all bits 0, the server MAY allow the WRITE to be serviced subject to mandatory file locks or the current share deny modes for the file. For a WRITE with a stateid value of all bits 1, the server MUST NOT allow the WRITE operation to bypass locking checks at the server and are treated exactly the same as if a stateid of all bits 0 were used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
すべてのビット0のstateid値を持つWRITEの場合、サーバーは、必須のファイルロックまたはファイルの現在の共有拒否モードに従って、WRITEのサービスを許可できます（MAY）。すべてのビット1の状態ID値を持つWRITEの場合、サーバーは、書き込み操作がサーバーでのロックチェックをバイパスすることを許可してはならず、すべてのビット0の状態IDが使用された場合とまったく同じに扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible for the server to write fewer bytes of data than requested by the client. In this case, the server should not return an error unless no data was written at all. If the server writes less than the number of bytes specified, the client should issue another WRITE to write the remaining data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがクライアントの要求よりも少ないバイト数のデータを書き込む可能性があります。この場合、データがまったく書き込まれていなければ、サーバーはエラーを返すべきではありません。サーバーが指定したバイト数より少ない数を書き込む場合、クライアントは残りのデータを書き込むために別のWRITEを発行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is assumed that the act of writing data to a file will cause the time_modified of the file to be updated. However, the time_modified of the file should not be changed unless the contents of the file are changed. Thus, a WRITE request with count set to 0 should not cause the time_modified of the file to be updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データをファイルに書き込む動作により、ファイルのtime_modifiedが更新されることが想定されています。ただし、ファイルの内容が変更されない限り、ファイルのtime_modifiedは変更しないでください。したがって、カウントが0に設定されたWRITE要求によって、ファイルのtime_modifiedが更新されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The definition of stable storage has been historically a point of contention. The following expected properties of stable storage may help in resolving design issues in the implementation. Stable storage is persistent storage that survives:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安定したストレージの定義は、歴史的に論争の的となってきました。安定したストレージの次の予想されるプロパティは、実装における設計問題の解決に役立つ場合があります。安定したストレージは存続する永続的なストレージです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. Repeated power failures. 2. Hardware failures (of any board, power supply, etc.). 3. Repeated software crashes, including reboot cycle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. 繰り返し停電。 2.ハードウェア障害（ボード、電源など）。 3.再起動サイクルを含め、繰り返しソフトウェアがクラッシュします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This definition does not address failure of the stable storage module itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この定義は、安定したストレージモジュール自体の障害には対応していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The verifier is defined to allow a client to detect different instances of an NFS version 4 protocol server over which cached, uncommitted data may be lost. In the most likely case, the verifier allows the client to detect server reboots. This information is required so that the client can safely determine whether the server could have lost cached data. If the server fails unexpectedly and the client has uncommitted data from previous WRITE requests (done with the stable argument set to UNSTABLE4 and in which the result committed was returned as UNSTABLE4 as well) it may not have flushed cached data to stable storage. The burden of recovery is on the client and the client will need to retransmit the data to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベリファイアは、キャッシュされたコミットされていないデータが失われる可能性のあるNFSバージョン4プロトコルサーバーのさまざまなインスタンスをクライアントが検出できるように定義されています。ほとんどの場合、ベリファイアにより、クライアントはサーバーの再起動を検出できます。この情報は、サーバーがキャッシュされたデータを失ったかどうかをクライアントが安全に判断できるようにするために必要です。サーバーが予期せず失敗し、クライアントが以前のWRITEリクエストからコミットされていないデータを持っている場合（stable引数をUNSTABLE4に設定し、コミットされた結果がUNSTABLE4としても返された場合）、キャッシュされたデータが安定したストレージにフラッシュされていない可能性があります。リカバリの負担はクライアントにあり、クライアントはデータをサーバーに再送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A suggested verifier would be to use the time that the server was booted or the time the server was last started (if restarting the server without a reboot results in lost buffers).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A suggested verifier would be to use the time that the server was booted or the time the server was last started (if restarting the server without a reboot results in lost buffers).
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The committed field in the results allows the client to do more effective caching. If the server is committing all WRITE requests to stable storage, then it should return with committed set to FILE_SYNC4, regardless of the value of the stable field in the arguments. A server that uses an NVRAM accelerator may choose to implement this policy. The client can use this to increase the effectiveness of the cache by discarding cached data that has already been committed on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果の認定フィールドにより、クライアントはより効果的なキャッシュを実行できます。サーバーがすべてのWRITE要求を安定したストレージにコミットしている場合、引数のstableフィールドの値に関係なく、committedをFILE_SYNC4に設定して戻る必要があります。 NVRAMアクセラレータを使用するサーバーは、このポリシーの実装を選択できます。クライアントはこれを使用して、サーバーで既にコミットされているキャッシュデータを破棄することで、キャッシュの効果を高めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some implementations may return NFS4ERR_NOSPC instead of NFS4ERR_DQUOT when a user&#39;s quota is exceeded. In the case that the current filehandle is a directory, the server will return NFS4ERR_ISDIR. If the current filehandle is not a regular file or a directory, the server will return NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部の実装では、ユーザーのクォータを超えると、NFS4ERR_DQUOTではなくNFS4ERR_NOSPCが返される場合があります。現在のファイルハンドルがディレクトリの場合、サーバーはNFS4ERR_ISDIRを返します。現在のファイルハンドルが通常のファイルまたはディレクトリでない場合、サーバーはNFS4ERR_INVALを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If mandatory file locking is on for the file, and corresponding record of the data to be written file is read or write locked by an owner that is not associated with the stateid, the server will return NFS4ERR_LOCKED. If so, the client must check if the owner corresponding to the stateid used with the WRITE operation has a conflicting read lock that overlaps with the region that was to be written. If the stateid&#39;s owner has no conflicting read lock, then the client should try to get the appropriate write record lock via the LOCK operation before re-attempting the WRITE. When the WRITE completes, the client should release the record lock via LOCKU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルに対して必須のファイルロックがオンになっていて、書き込まれるデータの対応するレコードが、stateidに関連付けられていない所有者によって読み取りまたは書き込みロックされている場合、サーバーはNFS4ERR_LOCKEDを返します。その場合、クライアントは、WRITE操作で使用された状態IDに対応する所有者が、書き込まれる予定の領域と重複する競合する読み取りロックを持っているかどうかを確認する必要があります。状態IDの所有者に競合する読み取りロックがない場合、クライアントは、書き込みを再試行する前に、LOCK操作を介して適切な書き込みレコードロックを取得する必要があります。 WRITEが完了すると、クライアントはLOCKUを介してレコードロックを解放する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the stateid&#39;s owner had a conflicting read lock, then the client has no choice but to return an error to the application that attempted the WRITE. The reason is that since the stateid&#39;s owner had a read lock, the server either attempted to temporarily effectively upgrade this read lock to a write lock, or the server has no upgrade capability. If the server attempted to upgrade the read lock and failed, it is pointless for the client to re-attempt the upgrade via the LOCK operation, because there might be another client also trying to upgrade. If two clients are blocked trying upgrade the same lock, the clients deadlock. If the server has no upgrade capability, then it is pointless to try a LOCK operation to upgrade.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態IDの所有者が競合する読み取りロックを持っていた場合、クライアントは書き込みを試みたアプリケーションにエラーを返す以外に選択肢はありません。その理由は、stateidの所有者が読み取りロックを持っていたため、サーバーがこの読み取りロックを一時的に効果的に書き込みロックにアップグレードしようとしたか、サーバーにアップグレード機能がないためです。サーバーが読み取りロックをアップグレードしようとして失敗した場合、別のクライアントもアップグレードを試みている可能性があるため、クライアントがLOCK操作を介してアップグレードを再試行しても意味がありません。 2つのクライアントが同じロックをアップグレードしようとしてブロックされた場合、クライアントはデッドロックします。サーバーにアップグレード機能がない場合は、LOCK操作を実行してアップグレードしても意味がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXPIRED NFS4ERR_FBIG NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCKED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NXIO NFS4ERR_OLD_STATEID NFS4ERR_OPENMODE NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXPIRED NFS4ERR_FBIG NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCKED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NXIO NFS4ERR_OLD_STATEID NFS4ERR_OPENMODE NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-37--Operation-39-RELEASELOCKOWNER---Release-Lockowner-State">
14.2.37. Operation 39: RELEASE_LOCKOWNER - Release Lockowner State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.37. 操作39：RELEASE_LOCKOWNER-Lockowner状態の解放
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
lockowner -&gt; ()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
ロック所有者-&gt;()
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct RELEASE_LOCKOWNER4args {
             lock_owner4     lock_owner;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct RELEASE_LOCKOWNER4res {
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used to notify the server that the lock_owner is no longer in use by the client. This allows the server to release cached state related to the specified lock_owner. If file locks, associated with the lock_owner, are held at the server, the error NFS4ERR_LOCKS_HELD will be returned and no further action will be taken.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、lock_ownerがクライアントによって使用されなくなったことをサーバーに通知するために使用されます。これにより、サーバーは指定されたlock_ownerに関連するキャッシュされた状態を解放できます。 lock_ownerに関連付けられているファイルロックがサーバーで保持されている場合、エラーNFS4ERR_LOCKS_HELDが返され、それ以上のアクションは行われません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client may choose to use this operation to ease the amount of server state that is held. Depending on behavior of applications at the client, it may be important for the client to use this operation since the server has certain obligations with respect to holding a reference to a lock_owner as long as the associated file is open. Therefore, if the client knows for certain that the lock_owner will no longer be used under the context of the associated open_owner4, it should use RELEASE_LOCKOWNER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、この操作を使用して、保持されるサーバー状態の量を軽減することを選択できます。クライアントでのアプリケーションの動作によっては、サーバーが関連ファイルが開いている限り、lock_ownerへの参照を保持することに関して一定の義務があるため、クライアントがこの操作を使用することが重要になる場合があります。したがって、関連するopen_owner4のコンテキストでlock_ownerが使用されなくなることをクライアントが確実に知っている場合は、RELEASE_LOCKOWNERを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ADMIN_REVOKED NFS4ERR_BADXDR NFS4ERR_EXPIRED NFS4ERR_LEASE_MOVED NFS4ERR_LOCKS_HELD NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE_CLIENTID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ADMIN_REVOKED NFS4ERR_BADXDR NFS4ERR_EXPIRED NFS4ERR_LEASE_MOVED NFS4ERR_LOCKS_HELD NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE_CLIENTID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-38--Operation-10044-ILLEGAL---Illegal-operation">
14.2.38. Operation 10044: ILLEGAL - Illegal operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.38. 操作10044：違法-不正な操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     &lt;null&gt; -&gt; ()
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             struct ILLEGAL4res {
                     nfsstat4        status;
             };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is a placeholder for encoding a result to handle the case of the client sending an operation code within COMPOUND that is not supported. See the COMPOUND procedure description for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、サポートされていないCOMPOUND内の操作コードを送信するクライアントのケースを処理する結果をエンコードするためのプレースホルダーです。詳細については、COMPOUNDプロシージャの説明を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The status field of ILLEGAL4res MUST be set to NFS4ERR_OP_ILLEGAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ILLEGAL4resのステータスフィールドはNFS4ERR_OP_ILLEGALに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client will probably not send an operation with code OP_ILLEGAL but if it does, the response will be ILLEGAL4res just as it would be with any other invalid operation code. Note that if the server gets an illegal operation code that is not OP_ILLEGAL, and if the server checks for legal operation codes during the XDR decode phase, then the ILLEGAL4res would not be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはおそらくコードOP_ILLEGALで操作を送信しませんが、送信すると、他の無効な操作コードの場合と同様に、応答はILLEGAL4resになります。サーバーがOP_ILLEGALではない不正な操作コードを取得し、サーバーがXDRデコードフェーズ中に有効な操作コードをチェックした場合、ILLEGAL4resは返されないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OP_ILLEGAL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OP_ILLEGAL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15--NFS-version-4-Callback-Procedures">
15. NFS version 4 Callback Procedures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. NFSバージョン4のコールバック手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The procedures used for callbacks are defined in the following sections. In the interest of clarity, the terms &#34;client&#34; and &#34;server&#34; refer to NFS clients and servers, despite the fact that for an individual callback RPC, the sense of these terms would be precisely the opposite.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コールバックに使用される手順は、次のセクションで定義されています。明確にするために、「クライアント」と「サーバー」という用語はNFSのクライアントとサーバーを指しますが、個々のコールバックRPCの場合、これらの用語の意味はまったく逆になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1--Procedure-0-CBNULL---No-Operation">
15.1. Procedure 0: CB_NULL - No Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1. 手順0：CB_NULL-操作なし
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;null&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;null&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Standard NULL procedure. Void argument, void response. Even though there is no direct functionality associated with this procedure, the server will use CB_NULL to confirm the existence of a path for RPCs from server to client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
標準のNULLプロシージャ。無効な引数、無効な応答。この手順に直接関連する機能はありませんが、サーバーはCB_NULLを使用して、サーバーからクライアントへのRPCのパスの存在を確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
None.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
なし。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-2--Procedure-1-CBCOMPOUND---Compound-Operations">
15.2. Procedure 1: CB_COMPOUND - Compound Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2. 手順1：CB_COMPOUND-複合操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
compoundargs -&gt; compoundres
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
複合引数-&gt;複合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     enum nfs_cb_opnum4 {
             OP_CB_GETATTR           = 3,
             OP_CB_RECALL            = 4,
             OP_CB_ILLEGAL           = 10044
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union nfs_cb_argop4 switch (unsigned argop) {
      case OP_CB_GETATTR:    CB_GETATTR4args opcbgetattr;
      case OP_CB_RECALL:     CB_RECALL4args  opcbrecall;
      case OP_CB_ILLEGAL:    void            opcbillegal;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct CB_COMPOUND4args {
             utf8str_cs      tag;
             uint32_t        minorversion;
             uint32_t        callback_ident;
             nfs_cb_argop4   argarray&lt;&gt;;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union nfs_cb_resop4 switch (unsigned resop){
      case OP_CB_GETATTR:    CB_GETATTR4res  opcbgetattr;
      case OP_CB_RECALL:     CB_RECALL4res   opcbrecall;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct CB_COMPOUND4res {
             nfsstat4 status;
             utf8str_cs      tag;
             nfs_cb_resop4   resarray&lt;&gt;;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_COMPOUND procedure is used to combine one or more of the callback procedures into a single RPC request. The main callback RPC program has two main procedures: CB_NULL and CB_COMPOUND. All other operations use the CB_COMPOUND procedure as a wrapper.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_COMPOUND procedure is used to combine one or more of the callback procedures into a single RPC request. The main callback RPC program has two main procedures: CB_NULL and CB_COMPOUND. All other operations use the CB_COMPOUND procedure as a wrapper.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the processing of the CB_COMPOUND procedure, the client may find that it does not have the available resources to execute any or all of the operations within the CB_COMPOUND sequence. In this case, the error NFS4ERR_RESOURCE will be returned for the particular operation within the CB_COMPOUND procedure where the resource exhaustion occurred. This assumes that all previous operations within the CB_COMPOUND sequence have been evaluated successfully.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_COMPOUNDプロシージャの処理中に、クライアントは、CB_COMPOUNDシーケンス内の操作の一部またはすべてを実行するために使用できるリソースがないことに気付く場合があります。この場合、リソースの枯渇が発生したCB_COMPOUNDプロシージャ内の特定の操作に対して、エラーNFS4ERR_RESOURCEが返されます。これは、CB_COMPOUNDシーケンス内の以前のすべての操作が正常に評価されていることを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Contained within the CB_COMPOUND results is a &#39;status&#39; field. This status must be equivalent to the status of the last operation that was executed within the CB_COMPOUND procedure. Therefore, if an operation incurred an error then the &#39;status&#39; value will be the same error value as is being returned for the operation that failed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_COMPOUNDの結果には、「ステータス」フィールドが含まれています。このステータスは、CB_COMPOUNDプロシージャ内で実行された最後の操作のステータスと同等である必要があります。したがって、操作でエラーが発生した場合、 &#39;status&#39;の値は、失敗した操作に対して返されるエラー値と同じになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the definition of the &#34;tag&#34; field, see the section &#34;Procedure 1: COMPOUND - Compound Operations&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「タグ」フィールドの定義については、「手順1：COMPOUND-複合操作」のセクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value of callback_ident is supplied by the client during SETCLIENTID. The server must use the client supplied callback_ident during the CB_COMPOUND to allow the client to properly identify the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
callback_identの値は、SETCLIENTID中にクライアントによって提供されます。サーバーは、クライアントがサーバーを適切に識別できるようにするために、CB_COMPOUND中にクライアント提供のcallback_identを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Illegal operation codes are handled in the same way as they are handled for the COMPOUND procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不正な操作コードは、COMPOUNDプロシージャで処理されるのと同じ方法で処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_COMPOUND procedure is used to combine individual operations into a single RPC request. The client interprets each of the operations in turn. If an operation is executed by the client and the status of that operation is NFS4_OK, then the next operation in the CB_COMPOUND procedure is executed. The client continues this process until there are no more operations to be executed or one of the operations has a status value other than NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_COMPOUNDプロシージャは、個々の操作を1つのRPC要求に結合するために使用されます。クライアントは各操作を順番に解釈します。操作がクライアントによって実行され、その操作のステータスがNFS4_OKの場合、CB_COMPOUNDプロシージャの次の操作が実行されます。クライアントは、実行する操作がなくなるか、操作の1つがNFS4_OK以外のステータス値になるまで、このプロセスを続行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_OP_ILLEGAL NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_OP_ILLEGAL NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-2-1--Operation-3-CBGETATTR---Get-Attributes">
15.2.1. Operation 3: CB_GETATTR - Get Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.1. 操作3：CB_GETATTR-属性の取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
fh, attr_request -&gt; attrmask, attr_vals
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
fh、attr_request-&gt; attrmask、attr_vals
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct CB_GETATTR4args {
             nfs_fh4 fh;
             bitmap4 attr_request;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct CB_GETATTR4resok {
             fattr4  obj_attributes;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union CB_GETATTR4res switch (nfsstat4 status) {
      case NFS4_OK:
              CB_GETATTR4resok       resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_GETATTR operation is used by the server to obtain the current modified state of a file that has been write delegated. The attributes size and change are the only ones guaranteed to be serviced by the client. See the section &#34;Handling of CB_GETATTR&#34; for a full description of how the client and server are to interact with the use of CB_GETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはCB_GETATTR操作を使用して、書き込み委任されたファイルの現在の変更状態を取得します。属性sizeおよびchangeは、クライアントによるサービスが保証されている唯一の属性です。クライアントとサーバーがCB_GETATTRの使用と対話する方法の詳細については、「CB_GETATTRの処理」のセクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the filehandle specified is not one for which the client holds a write open delegation, an NFS4ERR_BADHANDLE error is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたファイルハンドルが、クライアントが書き込みオープン委任を保持しているものでない場合、NFS4ERR_BADHANDLEエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client returns attrmask bits and the associated attribute values only for the change attribute, and attributes that it may change (time_modify, and size).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、変更属性および変更される可能性のある属性（time_modify、およびサイズ）に対してのみ、attrmaskビットと関連する属性値を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-2-2--Operation-4-CBRECALL---Recall-an-Open-Delegation">
15.2.2. Operation 4: CB_RECALL - Recall an Open Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.2. 操作4：CB_RECALL-開いている委任を呼び出す
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
stateid, truncate, fh -&gt; ()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
状態ID、切り捨て、fh-&gt;()
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct CB_RECALL4args {
             stateid4        stateid;
             bool            truncate;
             nfs_fh4         fh;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct CB_RECALL4res {
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_RECALL operation is used to begin the process of recalling an open delegation and returning it to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_RECALL操作は、開いている委任を呼び出してサーバーに返すプロセスを開始するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The truncate flag is used to optimize recall for a file which is about to be truncated to zero. When it is set, the client is freed of obligation to propagate modified data for the file to the server, since this data is irrelevant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
切り捨てフラグは、ゼロに切り捨てられようとしているファイルの再呼び出しを最適化するために使用されます。これが設定されると、ファイルの変更されたデータは無関係であるため、クライアントはファイルに変更されたデータをサーバーに伝搬する義務がなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the handle specified is not one for which the client holds an open delegation, an NFS4ERR_BADHANDLE error is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたハンドルが、クライアントが開いている委任を保持するハンドルでない場合、NFS4ERR_BADHANDLEエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the stateid specified is not one corresponding to an open delegation for the file specified by the filehandle, an NFS4ERR_BAD_STATEID is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定された状態IDが、ファイルハンドルで指定されたファイルの開いている委任に対応するものではない場合、NFS4ERR_BAD_STATEIDが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client should reply to the callback immediately. Replying does not complete the recall except when an error was returned. The recall is not complete until the delegation is returned using a DELEGRETURN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはすぐにコールバックに応答する必要があります。エラーが返された場合を除いて、返信してもリコールは完了しません。 DELEGRETURNを使用して委任が返されるまで、再呼び出しは完了しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-2-3--Operation-10044-CBILLEGAL---Illegal-Callback-Operation">
15.2.3. Operation 10044: CB_ILLEGAL - Illegal Callback Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.3. 操作10044：CB_ILLEGAL-不正なコールバック操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あらすじ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     &lt;null&gt; -&gt; ()
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             struct CB_ILLEGAL4res {
                     nfsstat4        status;
             };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is a placeholder for encoding a result to handle the case of the client sending an operation code within COMPOUND that is not supported. See the COMPOUND procedure description for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、サポートされていないCOMPOUND内の操作コードを送信するクライアントのケースを処理する結果をエンコードするためのプレースホルダーです。詳細については、COMPOUNDプロシージャの説明を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The status field of CB_ILLEGAL4res MUST be set to NFS4ERR_OP_ILLEGAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_ILLEGAL4resのステータスフィールドはNFS4ERR_OP_ILLEGALに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A server will probably not send an operation with code OP_CB_ILLEGAL but if it does, the response will be CB_ILLEGAL4res just as it would be with any other invalid operation code. Note that if the client gets an illegal operation code that is not OP_ILLEGAL, and if the client checks for legal operation codes during the XDR decode phase, then the CB_ILLEGAL4res would not be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーはおそらくコードOP_CB_ILLEGALの操作を送信しませんが、送信すると、他の無効な操作コードの場合と同様に、応答はCB_ILLEGAL4resになります。クライアントがOP_ILLEGAL以外の不正なオペレーションコードを取得した場合、およびクライアントがXDRデコードフェーズ中に正当なオペレーションコードをチェックした場合、CB_ILLEGAL4resは返されないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OP_ILLEGAL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OP_ILLEGAL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="16--Security-Considerations">
16. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS has historically used a model where, from an authentication perspective, the client was the entire machine, or at least the source IP address of the machine. The NFS server relied on the NFS client to make the proper authentication of the end-user. The NFS server in turn shared its files only to specific clients, as identified by the client&#39;s source IP address. Given this model, the AUTH_SYS RPC security flavor simply identified the end-user using the client to the NFS server. When processing NFS responses, the client ensured that the responses came from the same IP address and port number that the request was sent to. While such a model is easy to implement and simple to deploy and use, it is certainly not a safe model. Thus, NFSv4 mandates that implementations support a security model that uses end to end authentication, where an end-user on a client mutually authenticates (via cryptographic schemes that do not expose passwords or keys in the clear on the network) to a principal on an NFS server. Consideration should also be given to the integrity and privacy of NFS requests and responses. The issues of end to end mutual authentication, integrity, and privacy are discussed as part of the section on &#34;RPC and Security Flavor&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSはこれまで、認証の観点から見ると、クライアントがマシン全体、または少なくともマシンのソースIPアドレスであるモデルを使用してきました。 NFSサーバーは、NFSクライアントに依存して、エンドユーザーの適切な認証を行いました。次に、NFSサーバーは、クライアントのソースIPアドレスによって識別されるように、特定のクライアントのみにファイルを共有しました。このモデルを前提として、AUTH_SYS RPCセキュリティフレーバーは、NFSサーバーに対してクライアントを使用するエンドユーザーを単純に識別しました。 NFS応答を処理するとき、クライアントは、要求が送信されたのと同じIPアドレスとポート番号から応答が送信されることを確認しました。このようなモデルは実装が簡単で、展開と使用が簡単ですが、確かに安全なモデルではありません。したがって、NFSv4は、実装がエンドツーエンド認証を使用するセキュリティモデルをサポートすることを義務付けています。クライアントのエンドユーザーは、（ネットワーク上で平文でパスワードまたはキーを公開しない暗号化スキームを介して）上のプリンシパルに相互認証します。 NFSサーバー。 NFSの要求と応答の整合性とプライバシーについても考慮する必要があります。エンドツーエンドの相互認証、整合性、およびプライバシーの問題は、「RPCとセキュリティフレーバー」のセクションの一部として説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that while NFSv4 mandates an end to end mutual authentication model, the &#34;classic&#34; model of machine authentication via IP address checking and AUTH_SYS identification can still be supported with the caveat that the AUTH_SYS flavor is neither MANDATORY nor RECOMMENDED by this specification, and so interoperability via AUTH_SYS is not assured.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4はエンドツーエンドの相互認証モデルを義務付けていますが、IPアドレスチェックとAUTH_SYS識別によるマシン認証の「クラシック」モデルは、AUTH_SYSフレーバーがこの仕様によって必須でも推奨でもないことに注意してサポートできます。 AUTH_SYSによる相互運用性は保証されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For reasons of reduced administration overhead, better performance and/or reduction of CPU utilization, users of NFS version 4 implementations may choose to not use security mechanisms that enable integrity protection on each remote procedure call and response. The use of mechanisms without integrity leaves the customer vulnerable to an attacker in between the NFS client and server that modifies the RPC request and/or the response. While implementations are free to provide the option to use weaker security mechanisms, there are two operations in particular that warrant the implementation overriding user choices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
管理オーバーヘッドの削減、パフォーマンスの向上、および/またはCPU使用率の削減の理由により、NFSバージョン4実装のユーザーは、各リモートプロシージャコールと応答で整合性保護を可能にするセキュリティメカニズムを使用しないことを選択する場合があります。整合性のないメカニズムを使用すると、RPC要求や応答を変更するNFSクライアントとサーバーの間の攻撃者に対して顧客が脆弱になります。実装はより弱いセキュリティメカニズムを使用するオプションを自由に提供できますが、特にユーザーの選択を上書きする実装を保証する2つの操作があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first such operation is SECINFO. It is recommended that the client issue the SECINFO call such that it is protected with a security flavor that has integrity protection, such as RPCSEC_GSS with a security triple that uses either rpc_gss_svc_integrity or rpc_gss_svc_privacy (rpc_gss_svc_privacy includes integrity protection) service. Without integrity protection encapsulating SECINFO and therefore its results, an attacker in the middle could modify results such that the client might select a weaker algorithm in the set allowed by server, making the client and/or server vulnerable to further attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のそのような操作はSECINFOです。クライアントは、rpc_gss_svc_integrityまたはrpc_gss_svc_privacy（rpc_gss_svc_privacyが整合性保護を含む）サービスを使用するセキュリティトリプルを持つRPCSEC_GSSなどの整合性保護を備えたセキュリティフレーバーで保護されるように、SECINFO呼び出しを発行することをお勧めします。 SECINFOとその結果をカプセル化する整合性保護がないと、途中の攻撃者が結果を変更して、クライアントがサーバーによって許可されたセット内のより弱いアルゴリズムを選択し、クライアントやサーバーがさらなる攻撃に対して脆弱になる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second operation that should definitely use integrity protection is any GETATTR for the fs_locations attribute. The attack has two steps. First the attacker modifies the unprotected results of some operation to return NFS4ERR_MOVED. Second, when the client follows up with a GETATTR for the fs_locations attribute, the attacker modifies the results to cause the client migrate its traffic to a server controlled by the attacker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
完全性保護を確実に使用する必要がある2番目の操作は、fs_locations属性のGETATTRです。攻撃には2つのステップがあります。まず、攻撃者は何らかの操作の保護されていない結果を変更して、NFS4ERR_MOVEDを返します。次に、クライアントがfs_locations属性のGETATTRをフォローアップすると、攻撃者は結果を変更して、クライアントが攻撃者によって制御されているサーバーにトラフィックを移行させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the operations SETCLIENTID/SETCLIENTID_CONFIRM are responsible for the release of client state, it is imperative that the principal used for these operations is checked against and match the previous use of these operations. See the section &#34;Client ID&#34; for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作SETCLIENTID / SETCLIENTID_CONFIRMはクライアントの状態の解放を担当するため、これらの操作に使用されるプリンシパルがチェックされ、これらの操作の以前の使用と一致することが不可欠です。詳細については、「クライアントID」のセクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="17--IANA-Considerations">
17. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. IANAに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="17-1--Named-Attribute-Definition">
17.1. Named Attribute Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1. 名前付き属性の定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 protocol provides for the association of named attributes to files. The name space identifiers for these attributes are defined as string names. The protocol does not define the specific assignment of the name space for these file attributes. Even though the name space is not specifically controlled to prevent collisions, an IANA registry has been created for the registration of NFS version 4 named attributes. Registration will be achieved through the publication of an Informational RFC and will require not only the name of the attribute but the syntax and semantics of the named attribute contents; the intent is to promote interoperability where common interests exist. While application developers are allowed to define and use attributes as needed, they are encouraged to register the attributes with IANA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルは、名前付き属性とファイルの関連付けを提供します。これらの属性の名前空間識別子は、文字列名として定義されます。プロトコルは、これらのファイル属性の名前空間の特定の割り当てを定義していません。名前空間は衝突を防ぐために特に制御されていませんが、NANAバージョン4の名前付き属性を登録するためのIANAレジストリが作成されています。登録は、Informational RFCの発行を通じて行われ、属性の名前だけでなく、名前付き属性コンテンツの構文とセマンティクスも必要になります。その目的は、共通の利益が存在する相互運用性を促進することです。アプリケーション開発者は必要に応じて属性を定義して使用することができますが、IANAに属性を登録することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="17-2--ONC-RPC-Network-Identifiers-netids">
17.2. ONC RPC Network Identifiers (netids)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2. ONC RPCネットワーク識別子（netids）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The section &#34;Structured Data Types&#34; discussed the r_netid field and the corresponding r_addr field of a clientaddr4 structure. The NFS version 4 protocol depends on the syntax and semantics of these fields to effectively communicate callback information between client and server. Therefore, an IANA registry has been created to include the values defined in this document and to allow for future expansion based on transport usage/availability. Additions to this ONC RPC Network Identifier registry must be done with the publication of an RFC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The section &#34;Structured Data Types&#34; discussed the r_netid field and the corresponding r_addr field of a clientaddr4 structure. The NFS version 4 protocol depends on the syntax and semantics of these fields to effectively communicate callback information between client and server. Therefore, an IANA registry has been created to include the values defined in this document and to allow for future expansion based on transport usage/availability. Additions to this ONC RPC Network Identifier registry must be done with the publication of an RFC.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial values for this registry are as follows (some of this text is replicated from section 2.2 for clarity):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このレジストリの初期値は次のとおりです（このテキストの一部は、明確にするためにセクション2.2から複製されています）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Network Identifier (or r_netid for short) is used to specify a transport protocol and associated universal address (or r_addr for short). The syntax of the Network Identifier is a US-ASCII string. The initial definitions for r_netid are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワーク識別子（または略してr_netid）は、トランスポートプロトコルと関連するユニバーサルアドレス（略してr_addr）を指定するために使用されます。ネットワーク識別子の構文はUS-ASCII文字列です。 r_netidの初期定義は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&#34;tcp&#34; - TCP over IP version 4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
「tcp」-TCP over IPバージョン4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&#34;udp&#34; - UDP over IP version 4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&#34;udp&#34;-UDP over IPバージョン4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&#34;tcp6&#34; - TCP over IP version 6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&#34;tcp6&#34;-TCP over IPバージョン6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&#34;udp6&#34; - UDP over IP version 6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
「udp6」-UDP over IPバージョン6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: the &#39;&#34;&#39; marks are used for delimiting the strings for this document and are not part of the Network Identifier string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：「」マークは、このドキュメントの文字列を区切るために使用され、ネットワークID文字列の一部ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the &#34;tcp&#34; and &#34;udp&#34; Network Identifiers the Universal Address or r_addr (for IPv4) is a US-ASCII string and is of the form:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「tcp」および「udp」ネットワーク識別子の場合、ユニバーサルアドレスまたはr_addr（IPv4の場合）はUS-ASCII文字列であり、次の形式です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
h1.h2.h3.h4.p1.p2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
h1.h2.h3.h4.p1.p2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The prefix, &#34;h1.h2.h3.h4&#34;, is the standard textual form for representing an IPv4 address, which is always four octets long. Assuming big-endian ordering, h1, h2, h3, and h4, are respectively, the first through fourth octets each converted to ASCII-decimal. Assuming big-endian ordering, p1 and p2 are, respectively, the first and second octets each converted to ASCII-decimal. For example, if a host, in big-endian order, has an address of 0x0A010307 and there is a service listening on, in big endian order, port 0x020F (decimal 527), then complete universal address is &#34;10.1.3.7.2.15&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プレフィックス「h1.h2.h3.h4」は、IPv4アドレスを表すための標準のテキスト形式であり、常に4オクテットです。ビッグエンディアンの順序付けであると仮定すると、h1、h2、h3、およびh4はそれぞれ、最初のオクテットから4番目のオクテットがASCIIの10進数に変換されます。ビッグエンディアンの順序付けを想定すると、p1とp2はそれぞれ、ASCII 10進数に変換された最初と2番目のオクテットです。たとえば、ビッグエンディアン順のホストのアドレスが0x0A010307で、ビッグエンディアン順のポート0x020F（10進数の527）でリッスンしているサービスがある場合、完全なユニバーサルアドレスは「10.1.3.7.2.15」です。 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the &#34;tcp6&#34; and &#34;udp6&#34; Network Identifiers the Universal Address or r_addr (for IPv6) is a US-ASCII string and is of the form:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「tcp6」および「udp6」ネットワーク識別子の場合、ユニバーサルアドレスまたはr_addr（IPv6の場合）はUS-ASCII文字列で、次の形式です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      x1:x2:x3:x4:x5:x6:x7:x8.p1.p2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The suffix &#34;p1.p2&#34; is the service port, and is computed the same way as with universal addresses for &#34;tcp&#34; and &#34;udp&#34;. The prefix, &#34;x1:x2:x3:x4:x5:x6:x7:x8&#34;, is the standard textual form for representing an IPv6 address as defined in Section 2.2 of [RFC2373]. Additionally, the two alternative forms specified in Section 2.2 of [RFC2373] are also acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サフィックス「p1.p2」はサービスポートであり、「tcp」および「udp」のユニバーサルアドレスと同じ方法で計算されます。接頭辞「x1：x2：x3：x4：x5：x6：x7：x8」は、[RFC2373]のセクション2.2で定義されているIPv6アドレスを表すための標準のテキスト形式です。さらに、[RFC2373]のセクション2.2で指定されている2つの代替形式も許容されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As mentioned, the registration of new Network Identifiers will require the publication of an Information RFC with similar detail as listed above for the Network Identifier itself and corresponding Universal Address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すでに述べたように、新しいネットワーク識別子の登録には、ネットワーク識別子自体と対応するユニバーサルアドレスについて、上記と同様の詳細で情報RFCを公開する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18--RPC-definition-file">
18. RPC definition file
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. RPC定義ファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (C) The Internet Society (1998,1999,2000,2001,2002).
    *  All Rights Reserved.
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *      nfs4_prot.x
    *
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
%#pragma ident &#34;%W%&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
％＃プラグマID「％W％」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Basic typedefs for RFC 1832 data type definitions
    */
   typedef int             int32_t;
   typedef unsigned int    uint32_t;
   typedef hyper           int64_t;
   typedef unsigned hyper  uint64_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Sizes
    */
   const NFS4_FHSIZE               = 128;
   const NFS4_VERIFIER_SIZE        = 8;
   const NFS4_OPAQUE_LIMIT         = 1024;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * File types
    */
   enum nfs_ftype4 {
           NF4REG          = 1,    /* Regular File */
           NF4DIR          = 2,    /* Directory */
           NF4BLK          = 3,    /* Special File - block device */
           NF4CHR          = 4,    /* Special File - character device */
           NF4LNK          = 5,    /* Symbolic Link */
           NF4SOCK         = 6,    /* Special File - socket */
           NF4FIFO         = 7,    /* Special File - fifo */
           NF4ATTRDIR      = 8,    /* Attribute Directory */
           NF4NAMEDATTR    = 9     /* Named Attribute */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Error status
    */
   enum nfsstat4 {
           NFS4_OK                 = 0,    /* everything is okay      */
           NFS4ERR_PERM            = 1,    /* caller not privileged   */
           NFS4ERR_NOENT           = 2,    /* no such file/directory  */
           NFS4ERR_IO              = 5,    /* hard I/O error          */
           NFS4ERR_NXIO            = 6,    /* no such device          */
           NFS4ERR_ACCESS          = 13,   /* access denied           */
           NFS4ERR_EXIST           = 17,   /* file already exists     */
           NFS4ERR_XDEV            = 18,   /* different filesystems   */
           /* Unused/reserved        19 */
           NFS4ERR_NOTDIR          = 20,   /* should be a directory   */
           NFS4ERR_ISDIR           = 21,   /* should not be directory */
           NFS4ERR_INVAL           = 22,   /* invalid argument        */
           NFS4ERR_FBIG            = 27,   /* file exceeds server max */
           NFS4ERR_NOSPC           = 28,   /* no space on filesystem  */
           NFS4ERR_ROFS            = 30,   /* read-only filesystem    */
           NFS4ERR_MLINK           = 31,   /* too many hard links     */
           NFS4ERR_NAMETOOLONG     = 63,   /* name exceeds server max */
           NFS4ERR_NOTEMPTY        = 66,   /* directory not empty     */
           NFS4ERR_DQUOT           = 69,   /* hard quota limit reached*/
           NFS4ERR_STALE           = 70,   /* file no longer exists   */
           NFS4ERR_BADHANDLE       = 10001,/* Illegal filehandle      */
           NFS4ERR_BAD_COOKIE      = 10003,/* READDIR cookie is stale */
           NFS4ERR_NOTSUPP         = 10004,/* operation not supported */
           NFS4ERR_TOOSMALL        = 10005,/* response limit exceeded */
           NFS4ERR_SERVERFAULT     = 10006,/* undefined server error  */
           NFS4ERR_BADTYPE         = 10007,/* type invalid for CREATE */
           NFS4ERR_DELAY           = 10008,/* file &#34;busy&#34; - retry     */
           NFS4ERR_SAME            = 10009,/* nverify says attrs same */
           NFS4ERR_DENIED          = 10010,/* lock unavailable        */
           NFS4ERR_EXPIRED         = 10011,/* lock lease expired      */
           NFS4ERR_LOCKED          = 10012,/* I/O failed due to lock  */
           NFS4ERR_GRACE           = 10013,/* in grace period         */
           NFS4ERR_FHEXPIRED       = 10014,/* filehandle expired      */
           NFS4ERR_SHARE_DENIED    = 10015,/* share reserve denied    */
           NFS4ERR_WRONGSEC        = 10016,/* wrong security flavor   */
           NFS4ERR_CLID_INUSE      = 10017,/* clientid in use         */
           NFS4ERR_RESOURCE        = 10018,/* resource exhaustion     */
           NFS4ERR_MOVED           = 10019,/* filesystem relocated    */
           NFS4ERR_NOFILEHANDLE    = 10020,/* current FH is not set   */
           NFS4ERR_MINOR_VERS_MISMATCH = 10021,/* minor vers not supp */
           NFS4ERR_STALE_CLIENTID  = 10022,/* server has rebooted     */
           NFS4ERR_STALE_STATEID   = 10023,/* server has rebooted     */
           NFS4ERR_OLD_STATEID     = 10024,/* state is out of sync    */
           NFS4ERR_BAD_STATEID     = 10025,/* incorrect stateid       */
           NFS4ERR_BAD_SEQID       = 10026,/* request is out of seq.  */
           NFS4ERR_NOT_SAME        = 10027,/* verify - attrs not same */
           NFS4ERR_LOCK_RANGE      = 10028,/* lock range not supported*/
           NFS4ERR_SYMLINK         = 10029,/* should be file/directory*/
           NFS4ERR_RESTOREFH       = 10030,/* no saved filehandle     */
           NFS4ERR_LEASE_MOVED     = 10031,/* some filesystem moved   */
           NFS4ERR_ATTRNOTSUPP     = 10032,/* recommended attr not sup*/
           NFS4ERR_NO_GRACE        = 10033,/* reclaim outside of grace*/
           NFS4ERR_RECLAIM_BAD     = 10034,/* reclaim error at server */
           NFS4ERR_RECLAIM_CONFLICT = 10035,/* conflict on reclaim    */
           NFS4ERR_BADXDR          = 10036,/* XDR decode failed       */
           NFS4ERR_LOCKS_HELD      = 10037,/* file locks held at CLOSE*/
           NFS4ERR_OPENMODE        = 10038,/* conflict in OPEN and I/O*/
           NFS4ERR_BADOWNER        = 10039,/* owner translation bad   */
           NFS4ERR_BADCHAR         = 10040,/* utf-8 char not supported*/
           NFS4ERR_BADNAME         = 10041,/* name not supported      */
           NFS4ERR_BAD_RANGE       = 10042,/* lock range not supported*/
           NFS4ERR_LOCK_NOTSUPP    = 10043,/* no atomic up/downgrade  */
           NFS4ERR_OP_ILLEGAL      = 10044,/* undefined operation     */
           NFS4ERR_DEADLOCK        = 10045,/* file locking deadlock   */
           NFS4ERR_FILE_OPEN       = 10046,/* open file blocks op.    */
           NFS4ERR_ADMIN_REVOKED   = 10047,/* lockowner state revoked */
           NFS4ERR_CB_PATH_DOWN    = 10048 /* callback path down      */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Basic data types
    */
   typedef uint32_t        bitmap4&lt;&gt;;
   typedef uint64_t        offset4;
   typedef uint32_t        count4;
   typedef uint64_t        length4;
   typedef uint64_t        clientid4;
   typedef uint32_t        seqid4;
   typedef opaque          utf8string&lt;&gt;;
   typedef utf8string      utf8str_cis;
   typedef utf8string      utf8str_cs;
   typedef utf8string      utf8str_mixed;
   typedef utf8str_cs      component4;
   typedef component4      pathname4&lt;&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef uint64_t        nfs_lockid4;
   typedef uint64_t        nfs_cookie4;
   typedef utf8str_cs      linktext4;
   typedef opaque          sec_oid4&lt;&gt;;
   typedef uint32_t        qop4;
   typedef uint32_t        mode4;
   typedef uint64_t        changeid4;
   typedef opaque          verifier4[NFS4_VERIFIER_SIZE];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Timeval
    */
   struct nfstime4 {
           int64_t         seconds;
           uint32_t        nseconds;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum time_how4 {
           SET_TO_SERVER_TIME4 = 0,
           SET_TO_CLIENT_TIME4 = 1
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union settime4 switch (time_how4 set_it) {
    case SET_TO_CLIENT_TIME4:
            nfstime4       time;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * File access handle
    */
   typedef opaque  nfs_fh4&lt;NFS4_FHSIZE&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * File attribute definitions
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * FSID structure for major/minor
    */
   struct fsid4 {
           uint64_t        major;
           uint64_t        minor;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    * Filesystem locations attribute for relocation/migration
    */
   struct fs_location4 {
           utf8str_cis     server&lt;&gt;;
           pathname4       rootpath;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fs_locations4 {
           pathname4       fs_root;
           fs_location4    locations&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Various Access Control Entry definitions
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Mask that indicates which Access Control Entries are supported.
    * Values for the fattr4_aclsupport attribute.
    */
   const ACL4_SUPPORT_ALLOW_ACL    = 0x00000001;
   const ACL4_SUPPORT_DENY_ACL     = 0x00000002;
   const ACL4_SUPPORT_AUDIT_ACL    = 0x00000004;
   const ACL4_SUPPORT_ALARM_ACL    = 0x00000008;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef uint32_t        acetype4;
   /*
    * acetype4 values, others can be added as needed.
    */
   const ACE4_ACCESS_ALLOWED_ACE_TYPE      = 0x00000000;
   const ACE4_ACCESS_DENIED_ACE_TYPE       = 0x00000001;
   const ACE4_SYSTEM_AUDIT_ACE_TYPE        = 0x00000002;
   const ACE4_SYSTEM_ALARM_ACE_TYPE        = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * ACE flag
    */
   typedef uint32_t aceflag4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * ACE flag values
    */
   const ACE4_FILE_INHERIT_ACE             = 0x00000001;
   const ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;
   const ACE4_NO_PROPAGATE_INHERIT_ACE     = 0x00000004;
   const ACE4_INHERIT_ONLY_ACE             = 0x00000008;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;
   const ACE4_FAILED_ACCESS_ACE_FLAG       = 0x00000020;
   const ACE4_IDENTIFIER_GROUP             = 0x00000040;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * ACE mask
    */
   typedef uint32_t        acemask4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * ACE mask values
    */
   const ACE4_READ_DATA            = 0x00000001;
   const ACE4_LIST_DIRECTORY       = 0x00000001;
   const ACE4_WRITE_DATA           = 0x00000002;
   const ACE4_ADD_FILE             = 0x00000002;
   const ACE4_APPEND_DATA          = 0x00000004;
   const ACE4_ADD_SUBDIRECTORY     = 0x00000004;
   const ACE4_READ_NAMED_ATTRS     = 0x00000008;
   const ACE4_WRITE_NAMED_ATTRS    = 0x00000010;
   const ACE4_EXECUTE              = 0x00000020;
   const ACE4_DELETE_CHILD         = 0x00000040;
   const ACE4_READ_ATTRIBUTES      = 0x00000080;
   const ACE4_WRITE_ATTRIBUTES     = 0x00000100;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACE4_DELETE               = 0x00010000;
   const ACE4_READ_ACL             = 0x00020000;
   const ACE4_WRITE_ACL            = 0x00040000;
   const ACE4_WRITE_OWNER          = 0x00080000;
   const ACE4_SYNCHRONIZE          = 0x00100000;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * ACE4_GENERIC_READ -- defined as combination of
    *      ACE4_READ_ACL |
    *      ACE4_READ_DATA |
    *      ACE4_READ_ATTRIBUTES |
    *      ACE4_SYNCHRONIZE
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const ACE4_GENERIC_READ = 0x00120081;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const ACE4_GENERIC_READ = 0x00120081;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * ACE4_GENERIC_WRITE -- defined as combination of
    *      ACE4_READ_ACL |
    *      ACE4_WRITE_DATA |
    *      ACE4_WRITE_ATTRIBUTES |
    *      ACE4_WRITE_ACL |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    *      ACE4_APPEND_DATA |
    *      ACE4_SYNCHRONIZE
    */
   const ACE4_GENERIC_WRITE = 0x00160106;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * ACE4_GENERIC_EXECUTE -- defined as combination of
    *      ACE4_READ_ACL
    *      ACE4_READ_ATTRIBUTES
    *      ACE4_EXECUTE
    *      ACE4_SYNCHRONIZE
    */
   const ACE4_GENERIC_EXECUTE = 0x001200A0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Access Control Entry definition
    */
   struct nfsace4 {
           acetype4        type;
           aceflag4        flag;
           acemask4        access_mask;
           utf8str_mixed   who;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Field definitions for the fattr4_mode attribute
    */
   const MODE4_SUID = 0x800;  /* set user id on execution */
   const MODE4_SGID = 0x400;  /* set group id on execution */
   const MODE4_SVTX = 0x200;  /* save text even after use */
   const MODE4_RUSR = 0x100;  /* read permission: owner */
   const MODE4_WUSR = 0x080;  /* write permission: owner */
   const MODE4_XUSR = 0x040;  /* execute permission: owner */
   const MODE4_RGRP = 0x020;  /* read permission: group */
   const MODE4_WGRP = 0x010;  /* write permission: group */
   const MODE4_XGRP = 0x008;  /* execute permission: group */
   const MODE4_ROTH = 0x004;  /* read permission: other */
   const MODE4_WOTH = 0x002;  /* write permission: other */
   const MODE4_XOTH = 0x001;  /* execute permission: other */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Special data/attribute associated with
    * file types NF4BLK and NF4CHR.
    */
   struct specdata4 {
           uint32_t        specdata1;      /* major device number */
           uint32_t        specdata2;      /* minor device number */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Values for fattr4_fh_expire_type
    */
   const   FH4_PERSISTENT          = 0x00000000;
   const   FH4_NOEXPIRE_WITH_OPEN  = 0x00000001;
   const   FH4_VOLATILE_ANY        = 0x00000002;
   const   FH4_VOL_MIGRATION       = 0x00000004;
   const   FH4_VOL_RENAME          = 0x00000008;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef bitmap4         fattr4_supported_attrs;
   typedef nfs_ftype4      fattr4_type;
   typedef uint32_t        fattr4_fh_expire_type;
   typedef changeid4       fattr4_change;
   typedef uint64_t        fattr4_size;
   typedef bool            fattr4_link_support;
   typedef bool            fattr4_symlink_support;
   typedef bool            fattr4_named_attr;
   typedef fsid4           fattr4_fsid;
   typedef bool            fattr4_unique_handles;
   typedef uint32_t        fattr4_lease_time;
   typedef nfsstat4        fattr4_rdattr_error;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef nfsace4         fattr4_acl&lt;&gt;;
   typedef uint32_t        fattr4_aclsupport;
   typedef bool            fattr4_archive;
   typedef bool            fattr4_cansettime;
   typedef bool            fattr4_case_insensitive;
   typedef bool            fattr4_case_preserving;
   typedef bool            fattr4_chown_restricted;
   typedef uint64_t        fattr4_fileid;
   typedef uint64_t        fattr4_files_avail;
   typedef nfs_fh4         fattr4_filehandle;
   typedef uint64_t        fattr4_files_free;
   typedef uint64_t        fattr4_files_total;
   typedef fs_locations4   fattr4_fs_locations;
   typedef bool            fattr4_hidden;
   typedef bool            fattr4_homogeneous;
   typedef uint64_t        fattr4_maxfilesize;
   typedef uint32_t        fattr4_maxlink;
   typedef uint32_t        fattr4_maxname;
   typedef uint64_t        fattr4_maxread;
   typedef uint64_t        fattr4_maxwrite;
   typedef utf8str_cs      fattr4_mimetype;
   typedef mode4           fattr4_mode;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef uint64_t        fattr4_mounted_on_fileid;
   typedef bool            fattr4_no_trunc;
   typedef uint32_t        fattr4_numlinks;
   typedef utf8str_mixed   fattr4_owner;
   typedef utf8str_mixed   fattr4_owner_group;
   typedef uint64_t        fattr4_quota_avail_hard;
   typedef uint64_t        fattr4_quota_avail_soft;
   typedef uint64_t        fattr4_quota_used;
   typedef specdata4       fattr4_rawdev;
   typedef uint64_t        fattr4_space_avail;
   typedef uint64_t        fattr4_space_free;
   typedef uint64_t        fattr4_space_total;
   typedef uint64_t        fattr4_space_used;
   typedef bool            fattr4_system;
   typedef nfstime4        fattr4_time_access;
   typedef settime4        fattr4_time_access_set;
   typedef nfstime4        fattr4_time_backup;
   typedef nfstime4        fattr4_time_create;
   typedef nfstime4        fattr4_time_delta;
   typedef nfstime4        fattr4_time_metadata;
   typedef nfstime4        fattr4_time_modify;
   typedef settime4        fattr4_time_modify_set;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Mandatory Attributes
    */
   const FATTR4_SUPPORTED_ATTRS    = 0;
   const FATTR4_TYPE               = 1;
   const FATTR4_FH_EXPIRE_TYPE     = 2;
   const FATTR4_CHANGE             = 3;
   const FATTR4_SIZE               = 4;
   const FATTR4_LINK_SUPPORT       = 5;
   const FATTR4_SYMLINK_SUPPORT    = 6;
   const FATTR4_NAMED_ATTR         = 7;
   const FATTR4_FSID               = 8;
   const FATTR4_UNIQUE_HANDLES     = 9;
   const FATTR4_LEASE_TIME         = 10;
   const FATTR4_RDATTR_ERROR       = 11;
   const FATTR4_FILEHANDLE         = 19;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Recommended Attributes
    */
   const FATTR4_ACL                = 12;
   const FATTR4_ACLSUPPORT         = 13;
   const FATTR4_ARCHIVE            = 14;
   const FATTR4_CANSETTIME         = 15;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const FATTR4_CASE_INSENSITIVE   = 16;
   const FATTR4_CASE_PRESERVING    = 17;
   const FATTR4_CHOWN_RESTRICTED   = 18;
   const FATTR4_FILEID             = 20;
   const FATTR4_FILES_AVAIL        = 21;
   const FATTR4_FILES_FREE         = 22;
   const FATTR4_FILES_TOTAL        = 23;
   const FATTR4_FS_LOCATIONS       = 24;
   const FATTR4_HIDDEN             = 25;
   const FATTR4_HOMOGENEOUS        = 26;
   const FATTR4_MAXFILESIZE        = 27;
   const FATTR4_MAXLINK            = 28;
   const FATTR4_MAXNAME            = 29;
   const FATTR4_MAXREAD            = 30;
   const FATTR4_MAXWRITE           = 31;
   const FATTR4_MIMETYPE           = 32;
   const FATTR4_MODE               = 33;
   const FATTR4_NO_TRUNC           = 34;
   const FATTR4_NUMLINKS           = 35;
   const FATTR4_OWNER              = 36;
   const FATTR4_OWNER_GROUP        = 37;
   const FATTR4_QUOTA_AVAIL_HARD   = 38;
   const FATTR4_QUOTA_AVAIL_SOFT   = 39;
   const FATTR4_QUOTA_USED         = 40;
   const FATTR4_RAWDEV             = 41;
   const FATTR4_SPACE_AVAIL        = 42;
   const FATTR4_SPACE_FREE         = 43;
   const FATTR4_SPACE_TOTAL        = 44;
   const FATTR4_SPACE_USED         = 45;
   const FATTR4_SYSTEM             = 46;
   const FATTR4_TIME_ACCESS        = 47;
   const FATTR4_TIME_ACCESS_SET    = 48;
   const FATTR4_TIME_BACKUP        = 49;
   const FATTR4_TIME_CREATE        = 50;
   const FATTR4_TIME_DELTA         = 51;
   const FATTR4_TIME_METADATA      = 52;
   const FATTR4_TIME_MODIFY        = 53;
   const FATTR4_TIME_MODIFY_SET    = 54;
   const FATTR4_MOUNTED_ON_FILEID  = 55;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef opaque  attrlist4&lt;&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * File attribute container
    */
   struct fattr4 {
           bitmap4         attrmask;
           attrlist4       attr_vals;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Change info for the client
    */
   struct change_info4 {
           bool            atomic;
           changeid4       before;
           changeid4       after;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct clientaddr4 {
           /* see struct rpcb in RFC 1833 */
           string r_netid&lt;&gt;;               /* network id */
           string r_addr&lt;&gt;;                /* universal address */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Callback program info as provided by the client
    */
   struct cb_client4 {
           uint32_t        cb_program;
           clientaddr4     cb_location;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Stateid
    */
   struct stateid4 {
           uint32_t        seqid;
           opaque          other[12];
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Client ID
    */
   struct nfs_client_id4 {
           verifier4       verifier;
           opaque          id&lt;NFS4_OPAQUE_LIMIT&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_owner4 {
           clientid4       clientid;
           opaque          owner&lt;NFS4_OPAQUE_LIMIT&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct lock_owner4 {
           clientid4       clientid;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           opaque          owner&lt;NFS4_OPAQUE_LIMIT&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum nfs_lock_type4 {
           READ_LT         = 1,
           WRITE_LT        = 2,
           READW_LT        = 3,    /* blocking read */
           WRITEW_LT       = 4     /* blocking write */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * ACCESS: Check access permission
    */
   const ACCESS4_READ      = 0x00000001;
   const ACCESS4_LOOKUP    = 0x00000002;
   const ACCESS4_MODIFY    = 0x00000004;
   const ACCESS4_EXTEND    = 0x00000008;
   const ACCESS4_DELETE    = 0x00000010;
   const ACCESS4_EXECUTE   = 0x00000020;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ACCESS4args {
           /* CURRENT_FH: object */
           uint32_t        access;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ACCESS4resok {
           uint32_t        supported;
           uint32_t        access;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union ACCESS4res switch (nfsstat4 status) {
    case NFS4_OK:
            ACCESS4resok   resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * CLOSE: Close a file and release share reservations
    */
   struct CLOSE4args {
           /* CURRENT_FH: object */
           seqid4          seqid;
           stateid4        open_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
union CLOSE4res switch (nfsstat4 status) { case NFS4_OK:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
union CLOSE4resスイッチ（nfsstat4ステータス）{ケースNFS4_OK：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            stateid4       open_stateid;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * COMMIT: Commit cached data on server to stable storage
    */
   struct COMMIT4args {
           /* CURRENT_FH: file */
           offset4         offset;
           count4          count;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COMMIT4resok {
           verifier4       writeverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union COMMIT4res switch (nfsstat4 status) {
    case NFS4_OK:
            COMMIT4resok   resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * CREATE: Create a non-regular file
    */
   union createtype4 switch (nfs_ftype4 type) {
    case NF4LNK:
            linktext4      linkdata;
    case NF4BLK:
    case NF4CHR:
            specdata4      devdata;
    case NF4SOCK:
    case NF4FIFO:
    case NF4DIR:
            void;
    default:
            void;          /* server should return NFS4ERR_BADTYPE */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CREATE4args {
           /* CURRENT_FH: directory for creation */
           createtype4     objtype;
           component4      objname;
           fattr4          createattrs;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CREATE4resok {
           change_info4    cinfo;
           bitmap4         attrset;        /* attributes set */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union CREATE4res switch (nfsstat4 status) {
    case NFS4_OK:
            CREATE4resok resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * DELEGPURGE: Purge Delegations Awaiting Recovery
    */
   struct DELEGPURGE4args {
           clientid4       clientid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DELEGPURGE4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * DELEGRETURN: Return a delegation
    */
   struct DELEGRETURN4args {
           /* CURRENT_FH: delegated file */
           stateid4        deleg_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DELEGRETURN4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * GETATTR: Get file attributes
    */
   struct GETATTR4args {
           /* CURRENT_FH: directory or file */
           bitmap4         attr_request;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct GETATTR4resok {
           fattr4          obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union GETATTR4res switch (nfsstat4 status) {
    case NFS4_OK:
            GETATTR4resok  resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * GETFH: Get current filehandle
    */
   struct GETFH4resok {
           nfs_fh4         object;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union GETFH4res switch (nfsstat4 status) {
    case NFS4_OK:
           GETFH4resok     resok4;
    default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * LINK: Create link to an object
    */
   struct LINK4args {
           /* SAVED_FH: source object */
           /* CURRENT_FH: target directory */
           component4      newname;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LINK4resok {
           change_info4    cinfo;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LINK4res switch (nfsstat4 status) {
    case NFS4_OK:
            LINK4resok resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * For LOCK, transition from open_owner to new lock_owner
    */
   struct open_to_lock_owner4 {
           seqid4          open_seqid;
           stateid4        open_stateid;
           seqid4          lock_seqid;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           lock_owner4     lock_owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * For LOCK, existing lock_owner continues to request file locks
    */
   struct exist_lock_owner4 {
           stateid4        lock_stateid;
           seqid4          lock_seqid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union locker4 switch (bool new_lock_owner) {
    case TRUE:
           open_to_lock_owner4     open_owner;
    case FALSE:
           exist_lock_owner4       lock_owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * LOCK/LOCKT/LOCKU: Record lock management
    */
   struct LOCK4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           bool            reclaim;
           offset4         offset;
           length4         length;
           locker4         locker;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOCK4denied {
           offset4         offset;
           length4         length;
           nfs_lock_type4  locktype;
           lock_owner4     owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOCK4resok {
           stateid4        lock_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LOCK4res switch (nfsstat4 status) {
    case NFS4_OK:
            LOCK4resok     resok4;
    case NFS4ERR_DENIED:
            LOCK4denied    denied;
    default:
            void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOCKT4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           offset4         offset;
           length4         length;
           lock_owner4     owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LOCKT4res switch (nfsstat4 status) {
    case NFS4ERR_DENIED:
            LOCK4denied    denied;
    case NFS4_OK:
            void;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOCKU4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           seqid4          seqid;
           stateid4        lock_stateid;
           offset4         offset;
           length4         length;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LOCKU4res switch (nfsstat4 status) {
    case   NFS4_OK:
            stateid4       lock_stateid;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * LOOKUP: Lookup filename
    */
   struct LOOKUP4args {
           /* CURRENT_FH: directory */
           component4      objname;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOOKUP4res {
           /* CURRENT_FH: object */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * LOOKUPP: Lookup parent directory
    */
   struct LOOKUPP4res {
           /* CURRENT_FH: directory */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * NVERIFY: Verify attributes different
    */
   struct NVERIFY4args {
           /* CURRENT_FH: object */
           fattr4          obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct NVERIFY4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Various definitions for OPEN
    */
   enum createmode4 {
           UNCHECKED4      = 0,
           GUARDED4        = 1,
           EXCLUSIVE4      = 2
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union createhow4 switch (createmode4 mode) {
    case UNCHECKED4:
    case GUARDED4:
            fattr4         createattrs;
    case EXCLUSIVE4:
            verifier4      createverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum opentype4 {
           OPEN4_NOCREATE  = 0,
           OPEN4_CREATE    = 1
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union openflag4 switch (opentype4 opentype) {
    case OPEN4_CREATE:
            createhow4     how;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Next definitions used for OPEN delegation */
   enum limit_by4 {
           NFS_LIMIT_SIZE          = 1,
           NFS_LIMIT_BLOCKS        = 2
           /* others as needed */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nfs_modified_limit4 {
           uint32_t        num_blocks;
           uint32_t        bytes_per_block;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union nfs_space_limit4 switch (limit_by4 limitby) {
    /* limit specified as file size */
    case NFS_LIMIT_SIZE:
            uint64_t               filesize;
    /* limit specified by number of blocks */
    case NFS_LIMIT_BLOCKS:
            nfs_modified_limit4    mod_blocks;
   } ;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Share Access and Deny constants for open argument
    */
   const OPEN4_SHARE_ACCESS_READ   = 0x00000001;
   const OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;
   const OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const OPEN4_SHARE_DENY_NONE     = 0x00000000;
   const OPEN4_SHARE_DENY_READ     = 0x00000001;
   const OPEN4_SHARE_DENY_WRITE    = 0x00000002;
   const OPEN4_SHARE_DENY_BOTH     = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum open_delegation_type4 {
           OPEN_DELEGATE_NONE      = 0,
           OPEN_DELEGATE_READ      = 1,
           OPEN_DELEGATE_WRITE     = 2
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum open_claim_type4 {
           CLAIM_NULL              = 0,
           CLAIM_PREVIOUS          = 1,
           CLAIM_DELEGATE_CUR      = 2,
           CLAIM_DELEGATE_PREV     = 3
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_claim_delegate_cur4 {
           stateid4        delegate_stateid;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           component4      file;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union open_claim4 switch (open_claim_type4 claim) {
    /*
     * No special rights to file. Ordinary OPEN of the specified file.
     */
    case CLAIM_NULL:
           /* CURRENT_FH: directory */
           component4      file;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /*
     * Right to the file established by an open previous to server
     * reboot.  File identified by filehandle obtained at that time
     * rather than by name.
     */
    case CLAIM_PREVIOUS:
           /* CURRENT_FH: file being reclaimed */
           open_delegation_type4   delegate_type;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /*
     * Right to file based on a delegation granted by the server.
     * File is specified by name.
     */
    case CLAIM_DELEGATE_CUR:
           /* CURRENT_FH: directory */
           open_claim_delegate_cur4        delegate_cur_info;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Right to file based on a delegation granted to a previous boot
     * instance of the client.  File is specified by name.
     */
    case CLAIM_DELEGATE_PREV:
            /* CURRENT_FH: directory */
           component4      file_delegate_prev;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * OPEN: Open a file, potentially receiving an open delegation
    */
   struct OPEN4args {
           seqid4          seqid;
           uint32_t        share_access;
           uint32_t        share_deny;
           open_owner4     owner;
           openflag4       openhow;
           open_claim4     claim;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_read_delegation4 {
           stateid4        stateid;        /* Stateid for delegation*/
           bool            recall;         /* Pre-recalled flag for
                                              delegations obtained
                                              by reclaim
                                              (CLAIM_PREVIOUS) */
           nfsace4         permissions;    /* Defines users who don&#39;t
                                              need an ACCESS call to
                                              open for read */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_write_delegation4 {
           stateid4        stateid;        /* Stateid for delegation */
           bool            recall;         /* Pre-recalled flag for
                                              delegations obtained
                                              by reclaim
                                              (CLAIM_PREVIOUS) */
           nfs_space_limit4 space_limit;   /* Defines condition that
                                              the client must check to
                                              determine whether the
                                              file needs to be flushed
                                              to the server on close.
                                              */
           nfsace4         permissions;    /* Defines users who don&#39;t
                                              need an ACCESS call as
                                              part of a delegated
                                              open. */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union open_delegation4
   switch (open_delegation_type4 delegation_type) {
           case OPEN_DELEGATE_NONE:
                   void;
           case OPEN_DELEGATE_READ:
                   open_read_delegation4 read;
           case OPEN_DELEGATE_WRITE:
                   open_write_delegation4 write;
   };
   /*
    * Result flags
    */
   /* Client must confirm open */
   const OPEN4_RESULT_CONFIRM      = 0x00000002;
   /* Type of file locking behavior at the server */
   const OPEN4_RESULT_LOCKTYPE_POSIX = 0x00000004;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPEN4resok {
           stateid4        stateid;        /* Stateid for open */
           change_info4    cinfo;          /* Directory Change Info */
           uint32_t        rflags;         /* Result flags */
           bitmap4         attrset;        /* attribute set for create*/
           open_delegation4 delegation;    /* Info on any open
                                              delegation */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union OPEN4res switch (nfsstat4 status) {
    case NFS4_OK:
           /* CURRENT_FH: opened file */
           OPEN4resok      resok4;
    default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * OPENATTR: open named attributes directory
    */
   struct OPENATTR4args {
           /* CURRENT_FH: object */
           bool    createdir;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPENATTR4res {
           /* CURRENT_FH: named attr directory */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * OPEN_CONFIRM: confirm the open
    */
   struct OPEN_CONFIRM4args {
           /* CURRENT_FH: opened file */
           stateid4        open_stateid;
           seqid4          seqid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPEN_CONFIRM4resok {
           stateid4        open_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union OPEN_CONFIRM4res switch (nfsstat4 status) {
       case NFS4_OK:
               OPEN_CONFIRM4resok     resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * OPEN_DOWNGRADE: downgrade the access/deny for a file
    */
   struct OPEN_DOWNGRADE4args {
           /* CURRENT_FH: opened file */
           stateid4        open_stateid;
           seqid4          seqid;
           uint32_t        share_access;
           uint32_t        share_deny;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPEN_DOWNGRADE4resok {
           stateid4        open_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union OPEN_DOWNGRADE4res switch(nfsstat4 status) {
    case NFS4_OK:
           OPEN_DOWNGRADE4resok    resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * PUTFH: Set current filehandle
    */
   struct PUTFH4args {
           nfs_fh4         object;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct PUTFH4res {
           /* CURRENT_FH: */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * PUTPUBFH: Set public filehandle
    */
   struct PUTPUBFH4res {
           /* CURRENT_FH: public fh */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * PUTROOTFH: Set root filehandle
    */
   struct PUTROOTFH4res {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* CURRENT_FH: root fh */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * READ: Read from file
    */
   struct READ4args {
           /* CURRENT_FH: file */
           stateid4        stateid;
           offset4         offset;
           count4          count;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct READ4resok {
           bool            eof;
           opaque          data&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union READ4res switch (nfsstat4 status) {
    case NFS4_OK:
            READ4resok     resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * READDIR: Read directory
    */
   struct READDIR4args {
           /* CURRENT_FH: directory */
           nfs_cookie4     cookie;
           verifier4       cookieverf;
           count4          dircount;
           count4          maxcount;
           bitmap4         attr_request;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct entry4 {
           nfs_cookie4     cookie;
           component4      name;
           fattr4          attrs;
           entry4          *nextentry;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct dirlist4 {
           entry4          *entries;
           bool            eof;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct READDIR4resok {
           verifier4       cookieverf;
           dirlist4        reply;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union READDIR4res switch (nfsstat4 status) {
    case NFS4_OK:
            READDIR4resok  resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * READLINK: Read symbolic link
    */
   struct READLINK4resok {
           linktext4       link;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union READLINK4res switch (nfsstat4 status) {
    case NFS4_OK:
            READLINK4resok resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * REMOVE: Remove filesystem object
    */
   struct REMOVE4args {
           /* CURRENT_FH: directory */
           component4      target;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct REMOVE4resok {
           change_info4    cinfo;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union REMOVE4res switch (nfsstat4 status) {
    case NFS4_OK:
            REMOVE4resok   resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    * RENAME: Rename directory entry
    */
   struct RENAME4args {
           /* SAVED_FH: source directory */
           component4      oldname;
           /* CURRENT_FH: target directory */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           component4      newname;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RENAME4resok {
           change_info4    source_cinfo;
           change_info4    target_cinfo;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union RENAME4res switch (nfsstat4 status) {
    case NFS4_OK:
           RENAME4resok    resok4;
    default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * RENEW: Renew a Lease
    */
   struct RENEW4args {
           clientid4       clientid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RENEW4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * RESTOREFH: Restore saved filehandle
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RESTOREFH4res {
           /* CURRENT_FH: value of saved fh */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * SAVEFH: Save current filehandle
    */
   struct SAVEFH4res {
           /* SAVED_FH: value of current fh */
           nfsstat4        status;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * SECINFO: Obtain Available Security Mechanisms
    */
   struct SECINFO4args {
           /* CURRENT_FH: directory */
           component4      name;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    * From RFC 2203
    */
   enum rpc_gss_svc_t {
           RPC_GSS_SVC_NONE        = 1,
           RPC_GSS_SVC_INTEGRITY   = 2,
           RPC_GSS_SVC_PRIVACY     = 3
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct rpcsec_gss_info {
           sec_oid4        oid;
           qop4            qop;
           rpc_gss_svc_t   service;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* RPCSEC_GSS has a value of &#39;6&#39; - See RFC 2203 */
   union secinfo4 switch (uint32_t flavor) {
    case RPCSEC_GSS:
            rpcsec_gss_info        flavor_info;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef secinfo4 SECINFO4resok&lt;&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union SECINFO4res switch (nfsstat4 status) {
    case NFS4_OK:
            SECINFO4resok resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * SETATTR: Set attributes
    */
   struct SETATTR4args {
           /* CURRENT_FH: target object */
           stateid4        stateid;
           fattr4          obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETATTR4res {
           nfsstat4        status;
           bitmap4         attrsset;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * SETCLIENTID
    */
   struct SETCLIENTID4args {
           nfs_client_id4  client;
           cb_client4      callback;
           uint32_t        callback_ident;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETCLIENTID4resok {
           clientid4       clientid;
           verifier4       setclientid_confirm;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union SETCLIENTID4res switch (nfsstat4 status) {
    case NFS4_OK:
            SETCLIENTID4resok      resok4;
    case NFS4ERR_CLID_INUSE:
            clientaddr4    client_using;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETCLIENTID_CONFIRM4args {
           clientid4       clientid;
           verifier4       setclientid_confirm;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETCLIENTID_CONFIRM4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * VERIFY: Verify attributes same
    */
   struct VERIFY4args {
           /* CURRENT_FH: object */
           fattr4          obj_attributes;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct VERIFY4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * WRITE: Write to file
    */
   enum stable_how4 {
           UNSTABLE4       = 0,
           DATA_SYNC4      = 1,
           FILE_SYNC4      = 2
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct WRITE4args {
           /* CURRENT_FH: file */
           stateid4        stateid;
           offset4         offset;
           stable_how4     stable;
           opaque          data&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct WRITE4resok {
           count4          count;
           stable_how4     committed;
           verifier4       writeverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union WRITE4res switch (nfsstat4 status) {
    case NFS4_OK:
            WRITE4resok    resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * RELEASE_LOCKOWNER: Notify server to release lockowner
    */
   struct RELEASE_LOCKOWNER4args {
           lock_owner4     lock_owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RELEASE_LOCKOWNER4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    * ILLEGAL: Response for illegal operation numbers
    */
   struct ILLEGAL4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Operation arrays
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum nfs_opnum4 {
           OP_ACCESS               = 3,
           OP_CLOSE                = 4,
           OP_COMMIT               = 5,
           OP_CREATE               = 6,
           OP_DELEGPURGE           = 7,
           OP_DELEGRETURN          = 8,
           OP_GETATTR              = 9,
           OP_GETFH                = 10,
           OP_LINK                 = 11,
           OP_LOCK                 = 12,
           OP_LOCKT                = 13,
           OP_LOCKU                = 14,
           OP_LOOKUP               = 15,
           OP_LOOKUPP              = 16,
           OP_NVERIFY              = 17,
           OP_OPEN                 = 18,
           OP_OPENATTR             = 19,
           OP_OPEN_CONFIRM         = 20,
           OP_OPEN_DOWNGRADE       = 21,
           OP_PUTFH                = 22,
           OP_PUTPUBFH             = 23,
           OP_PUTROOTFH            = 24,
           OP_READ                 = 25,
           OP_READDIR              = 26,
           OP_READLINK             = 27,
           OP_REMOVE               = 28,
           OP_RENAME               = 29,
           OP_RENEW                = 30,
           OP_RESTOREFH            = 31,
           OP_SAVEFH               = 32,
           OP_SECINFO              = 33,
           OP_SETATTR              = 34,
           OP_SETCLIENTID          = 35,
           OP_SETCLIENTID_CONFIRM  = 36,
           OP_VERIFY               = 37,
           OP_WRITE                = 38,
           OP_RELEASE_LOCKOWNER    = 39,
           OP_ILLEGAL              = 10044
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union nfs_argop4 switch (nfs_opnum4 argop) {
    case OP_ACCESS:        ACCESS4args opaccess;
    case OP_CLOSE:         CLOSE4args opclose;
    case OP_COMMIT:        COMMIT4args opcommit;
    case OP_CREATE:        CREATE4args opcreate;
    case OP_DELEGPURGE:    DELEGPURGE4args opdelegpurge;
    case OP_DELEGRETURN:   DELEGRETURN4args opdelegreturn;
    case OP_GETATTR:       GETATTR4args opgetattr;
    case OP_GETFH:         void;
    case OP_LINK:          LINK4args oplink;
    case OP_LOCK:          LOCK4args oplock;
    case OP_LOCKT:         LOCKT4args oplockt;
    case OP_LOCKU:         LOCKU4args oplocku;
    case OP_LOOKUP:        LOOKUP4args oplookup;
    case OP_LOOKUPP:       void;
    case OP_NVERIFY:       NVERIFY4args opnverify;
    case OP_OPEN:          OPEN4args opopen;
    case OP_OPENATTR:      OPENATTR4args opopenattr;
    case OP_OPEN_CONFIRM:  OPEN_CONFIRM4args opopen_confirm;
    case OP_OPEN_DOWNGRADE:        OPEN_DOWNGRADE4args opopen_downgrade;
    case OP_PUTFH:         PUTFH4args opputfh;
    case OP_PUTPUBFH:      void;
    case OP_PUTROOTFH:     void;
    case OP_READ:          READ4args opread;
    case OP_READDIR:       READDIR4args opreaddir;
    case OP_READLINK:      void;
    case OP_REMOVE:        REMOVE4args opremove;
    case OP_RENAME:        RENAME4args oprename;
    case OP_RENEW:         RENEW4args oprenew;
    case OP_RESTOREFH:     void;
    case OP_SAVEFH:        void;
    case OP_SECINFO:       SECINFO4args opsecinfo;
    case OP_SETATTR:       SETATTR4args opsetattr;
    case OP_SETCLIENTID:   SETCLIENTID4args opsetclientid;
    case OP_SETCLIENTID_CONFIRM:   SETCLIENTID_CONFIRM4args
                                           opsetclientid_confirm;
    case OP_VERIFY:        VERIFY4args opverify;
    case OP_WRITE:         WRITE4args opwrite;
    case OP_RELEASE_LOCKOWNER:     RELEASE_LOCKOWNER4args
                                       oprelease_lockowner;
    case OP_ILLEGAL:       void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union nfs_resop4 switch (nfs_opnum4 resop){
    case OP_ACCESS:        ACCESS4res opaccess;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    case OP_CLOSE:         CLOSE4res opclose;
    case OP_COMMIT:        COMMIT4res opcommit;
    case OP_CREATE:        CREATE4res opcreate;
    case OP_DELEGPURGE:    DELEGPURGE4res opdelegpurge;
    case OP_DELEGRETURN:   DELEGRETURN4res opdelegreturn;
    case OP_GETATTR:       GETATTR4res opgetattr;
    case OP_GETFH:         GETFH4res opgetfh;
    case OP_LINK:          LINK4res oplink;
    case OP_LOCK:          LOCK4res oplock;
    case OP_LOCKT:         LOCKT4res oplockt;
    case OP_LOCKU:         LOCKU4res oplocku;
    case OP_LOOKUP:        LOOKUP4res oplookup;
    case OP_LOOKUPP:       LOOKUPP4res oplookupp;
    case OP_NVERIFY:       NVERIFY4res opnverify;
    case OP_OPEN:          OPEN4res opopen;
    case OP_OPENATTR:      OPENATTR4res opopenattr;
    case OP_OPEN_CONFIRM:  OPEN_CONFIRM4res opopen_confirm;
    case OP_OPEN_DOWNGRADE:        OPEN_DOWNGRADE4res opopen_downgrade;
    case OP_PUTFH:         PUTFH4res opputfh;
    case OP_PUTPUBFH:      PUTPUBFH4res opputpubfh;
    case OP_PUTROOTFH:     PUTROOTFH4res opputrootfh;
    case OP_READ:          READ4res opread;
    case OP_READDIR:       READDIR4res opreaddir;
    case OP_READLINK:      READLINK4res opreadlink;
    case OP_REMOVE:        REMOVE4res opremove;
    case OP_RENAME:        RENAME4res oprename;
    case OP_RENEW:         RENEW4res oprenew;
    case OP_RESTOREFH:     RESTOREFH4res oprestorefh;
    case OP_SAVEFH:        SAVEFH4res opsavefh;
    case OP_SECINFO:       SECINFO4res opsecinfo;
    case OP_SETATTR:       SETATTR4res opsetattr;
    case OP_SETCLIENTID:   SETCLIENTID4res opsetclientid;
    case OP_SETCLIENTID_CONFIRM:   SETCLIENTID_CONFIRM4res
                                           opsetclientid_confirm;
    case OP_VERIFY:        VERIFY4res opverify;
    case OP_WRITE:         WRITE4res opwrite;
    case OP_RELEASE_LOCKOWNER:     RELEASE_LOCKOWNER4res
                                       oprelease_lockowner;
    case OP_ILLEGAL:       ILLEGAL4res opillegal;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COMPOUND4args {
           utf8str_cs      tag;
           uint32_t        minorversion;
           nfs_argop4      argarray&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
struct COMPOUND4res {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
struct COMPOUND4res {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           nfsstat4 status;
           utf8str_cs      tag;
           nfs_resop4      resarray&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Remote file service routines
    */
   program NFS4_PROGRAM {
           version NFS_V4 {
                   void
                           NFSPROC4_NULL(void) = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
COMPOUND4res NFSPROC4_COMPOUND(COMPOUND4args) = 1;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
COMPOUND4res NFSPROC4_COMPOUND（COMPOUND4args）= 1;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           } = 4;
   } = 100003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * NFS4 Callback Procedure Definitions and Program
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * CB_GETATTR: Get Current Attributes
    */
   struct CB_GETATTR4args {
           nfs_fh4 fh;
           bitmap4 attr_request;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_GETATTR4resok {
           fattr4  obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union CB_GETATTR4res switch (nfsstat4 status) {
    case NFS4_OK:
            CB_GETATTR4resok       resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * CB_RECALL: Recall an Open Delegation
    */
   struct CB_RECALL4args {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           stateid4        stateid;
           bool            truncate;
           nfs_fh4         fh;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_RECALL4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * CB_ILLEGAL: Response for illegal operation numbers
    */
   struct CB_ILLEGAL4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Various definitions for CB_COMPOUND
    */
   enum nfs_cb_opnum4 {
           OP_CB_GETATTR           = 3,
           OP_CB_RECALL            = 4,
           OP_CB_ILLEGAL           = 10044
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union nfs_cb_argop4 switch (unsigned argop) {
    case OP_CB_GETATTR:    CB_GETATTR4args opcbgetattr;
    case OP_CB_RECALL:     CB_RECALL4args  opcbrecall;
    case OP_CB_ILLEGAL:    void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union nfs_cb_resop4 switch (unsigned resop){
    case OP_CB_GETATTR:    CB_GETATTR4res  opcbgetattr;
    case OP_CB_RECALL:     CB_RECALL4res   opcbrecall;
    case OP_CB_ILLEGAL:    CB_ILLEGAL4res  opcbillegal;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_COMPOUND4args {
           utf8str_cs      tag;
           uint32_t        minorversion;
           uint32_t        callback_ident;
           nfs_cb_argop4   argarray&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_COMPOUND4res {
           nfsstat4 status;
           utf8str_cs      tag;
           nfs_cb_resop4   resarray&lt;&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Program number is in the transient range since the client
    * will assign the exact transient program number and provide
    * that to the server via the SETCLIENTID operation.
    */
   program NFS4_CALLBACK {
           version NFS_CB {
                   void
                           CB_NULL(void) = 0;
                   CB_COMPOUND4res
                           CB_COMPOUND(CB_COMPOUND4args) = 1;
           } = 1;
   } = 0x40000000;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="19--Acknowledgements">
19. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. 謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authors thank and acknowledge:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authors thank and acknowledge:
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Neil Brown for his extensive review and comments of various documents. Rick Macklem at the University of Guelph, Mike Frisch, Sergey Klyushin, and Dan Trufasiu of Hummingbird Ltd., and Andy Adamson, Bruce Fields, Jim Rees, and Kendrick Smith from the CITI organization at the University of Michigan, for their implementation efforts and feedback on the protocol specification. Mike Kupfer for his review of the file locking and ACL mechanisms. Alan Yoder for his input to ACL mechanisms. Peter Astrand for his close review of the protocol specification. Ran Atkinson for his constant reminder that users do matter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Neil Brownは、さまざまなドキュメントの広範なレビューとコメントを提供してくれました。グエルフ大学のリック・マックレム、ハミングバード社のマイク・フリッシュ、セルゲイ・クリュシン、ダン・トルファシウ、ミシガン大学のCITI組織のアンディ・アダムソン、ブルース・フィールズ、ジム・リース、ケンドリック・スミスは、その実装の取り組みとプロトコル仕様に関するフィードバック。 Mike Kupfer氏によるファイルロックとACLメカニズムのレビュー。 ACLメカニズムへの入力に対するAlan Yoder。プロトコル仕様の綿密なレビューを行ったPeter Astrand。 Atkinson氏は、ユーザーが重要であることを常に思い出させてくれました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20--Normative-References">
20. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ISO10646] &#34;ISO/IEC 10646-1:1993. International Standard -- Information technology -- Universal Multiple-Octet Coded Character Set (UCS) -- Part 1: Architecture and Basic Multilingual Plane.&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ISO10646]「ISO / IEC 10646-1：1993。国際標準-情報技術-ユニバーサルマルチオクテットコード化文字セット（UCS）-パート1：アーキテクチャと基本的な多言語プレーン。」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793] Postel, J., &#34;Transmission Control Protocol&#34;, STD 7, RFC 793, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793] Postel, J., &#34;Transmission Control Protocol&#34;, STD 7, RFC 793, September 1981.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1831] Srinivasan, R., &#34;RPC: Remote Procedure Call Protocol Specification Version 2&#34;, RFC 1831, August 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1831] Srinivasan, R., &#34;RPC: Remote Procedure Call Protocol Specification Version 2&#34;, RFC 1831, August 1995.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1832] Srinivasan, R., &#34;XDR: External Data Representation Standard&#34;, RFC 1832, August 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1832] Srinivasan、R。、「XDR：外部データ表現標準」、RFC 1832、1995年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2373] Hinden, R. and S. Deering, &#34;IP Version 6 Addressing Architecture&#34;, RFC 2373, July 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2373] Hinden、R。およびS. Deering、「IPバージョン6アドレッシングアーキテクチャ」、RFC 2373、1998年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1964] Linn, J., &#34;The Kerberos Version 5 GSS-API Mechanism&#34;, RFC 1964, June 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1964] Linn, J., &#34;The Kerberos Version 5 GSS-API Mechanism&#34;, RFC 1964, June 1996.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2025] Adams, C., &#34;The Simple Public-Key GSS-API Mechanism (SPKM)&#34;, RFC 2025, October 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2025] Adams、C。、「The Simple Public-Key GSS-API Mechanism（SPKM）」、RFC 2025、1996年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2203] Eisler, M., Chiu, A. and L. Ling, &#34;RPCSEC_GSS Protocol Specification&#34;, RFC 2203, September 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2203] Eisler、M.、Chiu、A。およびL. Ling、「RPCSEC_GSS Protocol Specification」、RFC 2203、1997年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2277] Alvestrand, H., &#34;IETF Policy on Character Sets and Languages&#34;, BCP 19, RFC 2277, January 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2277] Alvestrand、H。、「文字セットと言語に関するIETFポリシー」、BCP 19、RFC 2277、1998年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2279] Yergeau, F., &#34;UTF-8, a transformation format of ISO 10646&#34;, RFC 2279, January 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2279] Yergeau、F。、「UTF-8、ISO 10646の変換フォーマット」、RFC 2279、1998年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2623] Eisler, M., &#34;NFS Version 2 and Version 3 Security Issues and the NFS Protocol&#39;s Use of RPCSEC_GSS and Kerberos V5&#34;, RFC 2623, June 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2623] Eisler、M。、「NFSバージョン2およびバージョン3のセキュリティ問題とNFSプロトコルによるRPCSEC_GSSおよびKerberos V5の使用」、RFC 2623、1999年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2743] Linn, J., &#34;Generic Security Service Application Program Interface, Version 2, Update 1&#34;, RFC 2743, January 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2743] Linn、J。、「Generic Security Service Application Program Interface、Version 2、Update 1」、RFC 2743、2000年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2847] Eisler, M., &#34;LIPKEY - A Low Infrastructure Public Key Mechanism Using SPKM&#34;, RFC 2847, June 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2847] Eisler、M。、「LIPKEY-低インフラストラクチャ公開鍵メカニズム（SPKMを使用）」、RFC 2847、2000年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3010] Shepler, S., Callaghan, B., Robinson, D., Thurlow, R., Beame, C., Eisler, M. and D. Noveck, &#34;NFS version 4 Protocol&#34;, RFC 3010, December 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3010] Shepler, S., Callaghan, B., Robinson, D., Thurlow, R., Beame, C., Eisler, M. and D. Noveck, &#34;NFS version 4 Protocol&#34;, RFC 3010, December 2000.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3454] Hoffman, P. and P. Blanchet, &#34;Preparation of Internationalized Strings (&#34;stringprep&#34;)&#34;, RFC 3454, December 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3454] Hoffman、P.およびP. Blanchet、「Preparation of Internationalized Strings（ &#34;stringprep&#34;）」、RFC 3454、2002年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Unicode1] The Unicode Consortium, &#34;The Unicode Standard, Version 3.0&#34;, Addison-Wesley Developers Press, Reading, MA, 2000. ISBN 0-201-61633-5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Unicode1] The Unicode Consortium, &#34;The Unicode Standard, Version 3.0&#34;, Addison-Wesley Developers Press, Reading, MA, 2000. ISBN 0-201-61633-5.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                             More information available at:
                             http://www.unicode.org/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Unicode2] &#34;Unsupported Scripts&#34; Unicode, Inc., The Unicode Consortium, P.O. Box 700519, San Jose, CA 95710-0519 USA, September 1999. http://www.unicode.org/unicode/standard/ unsupported.html
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Unicode2] &#34;Unsupported Scripts&#34; Unicode, Inc., The Unicode Consortium, P.O. Box 700519, San Jose, CA 95710-0519 USA, September 1999. http://www.unicode.org/unicode/standard/ unsupported.html
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="21--Informative-References">
21. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Floyd] S. Floyd, V. Jacobson, &#34;The Synchronization of Periodic Routing Messages,&#34; IEEE/ACM Transactions on Networking, 2(2), pp. 122- 136, April 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[フロイド] S.フロイド、V。ジェイコブソン、「定期的なルーティングメッセージの同期」、IEEE / ACM Transactions on Networking、2（2）、pp。122-136、1994年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Gray] C. Gray, D. Cheriton, &#34;Leases: An Efficient Fault-Tolerant Mechanism for Distributed File Cache Consistency,&#34; Proceedings of the Twelfth Symposium on Operating Systems Principles, p. 202-210, December 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[グレー] C.グレイ、D。シェリトン、「リース：分散ファイルキャッシュの一貫性のための効率的なフォールトトレラントメカニズム」、オペレーティングシステム原則に関する第12回シンポジウムのプロシーディング、p。 202-210、1989年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Juszczak] Juszczak, Chet, &#34;Improving the Performance and Correctness of an NFS Server,&#34; USENIX Conference Proceedings, USENIX Association, Berkeley, CA, June 1990, pages 53-63. Describes reply cache implementation that avoids work in the server by handling duplicate requests. More important, though listed as a side-effect, the reply cache aids in the avoidance of destructive non-idempotent operation re-application -- improving correctness.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Juszczak] Juszczak, Chet, &#34;Improving the Performance and Correctness of an NFS Server,&#34; USENIX Conference Proceedings, USENIX Association, Berkeley, CA, June 1990, pages 53-63. Describes reply cache implementation that avoids work in the server by handling duplicate requests. More important, though listed as a side-effect, the reply cache aids in the avoidance of destructive non-idempotent operation re-application -- improving correctness.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Kazar] Kazar, Michael Leon, &#34;Synchronization and Caching Issues in the Andrew File System,&#34; USENIX Conference Proceedings, USENIX Association, Berkeley, CA, Dallas Winter 1988, pages 27-36. A description of the cache consistency scheme in AFS. Contrasted with other distributed file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Kazar] Kazar, Michael Leon, &#34;Synchronization and Caching Issues in the Andrew File System,&#34; USENIX Conference Proceedings, USENIX Association, Berkeley, CA, Dallas Winter 1988, pages 27-36. A description of the cache consistency scheme in AFS. Contrasted with other distributed file systems.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Macklem] Macklem, Rick, &#34;Lessons Learned Tuning the 4.3BSD Reno Implementation of the NFS Protocol,&#34; Winter USENIX Conference Proceedings, USENIX Association, Berkeley, CA, January 1991. Describes performance work in tuning the 4.3BSD Reno NFS implementation. Describes performance improvement (reduced CPU loading) through elimination of data copies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Macklem] Macklem, Rick, &#34;Lessons Learned Tuning the 4.3BSD Reno Implementation of the NFS Protocol,&#34; Winter USENIX Conference Proceedings, USENIX Association, Berkeley, CA, January 1991. Describes performance work in tuning the 4.3BSD Reno NFS implementation. Describes performance improvement (reduced CPU loading) through elimination of data copies.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Mogul] Mogul, Jeffrey C., &#34;A Recovery Protocol for Spritely NFS,&#34; USENIX File System Workshop Proceedings, Ann Arbor, MI, USENIX Association, Berkeley, CA, May 1992. Second paper on Spritely NFS proposes a lease-based scheme for recovering state of consistency protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Mogul] Mogul、Jeffrey C。、「A Recovery Protocol for Spritely NFS」、USENIX File System Workshop Proceedings、Ann Arbor、MI、USENIX Association、Berkeley、CA、1992年5月。SpritelyNFSに関する2番目のペーパーは、リースベースのスキームを提案する整合性プロトコルの状態を回復するため。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Nowicki] Nowicki, Bill, &#34;Transport Issues in the Network File System,&#34; ACM SIGCOMM newsletter Computer Communication Review, April 1989. A brief description of the basis for the dynamic retransmission work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Nowicki] Nowicki, Bill, &#34;Transport Issues in the Network File System,&#34; ACM SIGCOMM newsletter Computer Communication Review, April 1989. A brief description of the basis for the dynamic retransmission work.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Pawlowski] Pawlowski, Brian, Ron Hixon, Mark Stein, Joseph Tumminaro, &#34;Network Computing in the UNIX and IBM Mainframe Environment,&#34; Uniforum `89 Conf. Proc., (1989) Description of an NFS server implementation for IBM&#39;s MVS operating system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Pawlowski] Pawlowski, Brian, Ron Hixon, Mark Stein, Joseph Tumminaro, &#34;Network Computing in the UNIX and IBM Mainframe Environment,&#34; Uniforum `89 Conf. Proc., (1989) Description of an NFS server implementation for IBM&#39;s MVS operating system.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1094] Sun Microsystems, Inc., &#34;NFS: Network File System Protocol Specification&#34;, RFC 1094, March 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1094] Sun Microsystems、Inc。、「NFS：Network File System Protocol Specification」、RFC 1094、1989年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1345] Simonsen, K., &#34;Character Mnemonics &amp; Character Sets&#34;, RFC 1345, June 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1345] Simonsen、K。、「Character Nnemonics＆Character Sets」、RFC 1345、1992年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1813] Callaghan, B., Pawlowski, B. and P. Staubach, &#34;NFS Version 3 Protocol Specification&#34;, RFC 1813, June 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1813] Callaghan、B.、Pawlowski、B。およびP. Staubach、「NFSバージョン3プロトコル仕様」、RFC 1813、1995年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3232] Reynolds, J., Editor, &#34;Assigned Numbers: RFC 1700 is Replaced by an On-line Database&#34;, RFC 3232, January 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3232] Reynolds、J。、編集者、「割り当てられた番号：RFC 1700はオンラインデータベースに置き換えられました」、RFC 3232、2002年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1833] Srinivasan, R., &#34;Binding Protocols for ONC RPC Version 2&#34;, RFC 1833, August 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1833] Srinivasan、R。、「ONC RPCバージョン2のバインディングプロトコル」、RFC 1833、1995年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2054] Callaghan, B., &#34;WebNFS Client Specification&#34;, RFC 2054, October 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2054] Callaghan、B。、「WebNFSクライアント仕様」、RFC 2054、1996年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2055] Callaghan, B., &#34;WebNFS Server Specification&#34;, RFC 2055, October 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2055] Callaghan、B。、「WebNFSサーバー仕様」、RFC 2055、1996年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2152] Goldsmith, D. and M. Davis, &#34;UTF-7 A Mail-Safe Transformation Format of Unicode&#34;, RFC 2152, May 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2152] Goldsmith、D。およびM. Davis、「UTF-7 A Mail-Safe Transformation Format of Unicode」、RFC 2152、1997年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2224] Callaghan, B., &#34;NFS URL Scheme&#34;, RFC 2224, October 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2224] Callaghan, B., &#34;NFS URL Scheme&#34;, RFC 2224, October 1997.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2624] Shepler, S., &#34;NFS Version 4 Design Considerations&#34;, RFC 2624, June 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2624] Shepler, S., &#34;NFS Version 4 Design Considerations&#34;, RFC 2624, June 1999.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2755] Chiu, A., Eisler, M. and B. Callaghan, &#34;Security Negotiation for WebNFS&#34; , RFC 2755, June 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2755] Chiu、A.、Eisler、M。、およびB. Callaghan、「WebNFSのセキュリティネゴシエーション」、RFC 2755、2000年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Sandberg] Sandberg, R., D. Goldberg, S. Kleiman, D. Walsh, B. Lyon, &#34;Design and Implementation of the Sun Network Filesystem,&#34; USENIX Conference Proceedings, USENIX Association, Berkeley, CA, Summer 1985. The basic paper describing the SunOS implementation of the NFS version 2 protocol, and discusses the goals, protocol specification and trade-offs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Sandberg] Sandberg、R.、D. Goldberg、S. Kleiman、D. Walsh、B. Lyon、 &#34;Design and Implementation of the Sun Network Filesystem&#34;、USENIX Conference Proceedings、USENIX Association、Berkeley、CA、Summer 1985。 NFSバージョン2プロトコルのSunOS実装を説明し、目標、プロトコル仕様、およびトレードオフについて説明する基本的なペーパー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Srinivasan] Srinivasan, V., Jeffrey C. Mogul, &#34;Spritely NFS: Implementation and Performance of Cache Consistency Protocols&#34;, WRL Research Report 89/5, Digital Equipment Corporation Western Research Laboratory, 100 Hamilton Ave., Palo Alto, CA, 94301, May 1989. This paper analyzes the effect of applying a Sprite-like consistency protocol applied to standard NFS. The issues of recovery in a stateful environment are covered in [Mogul].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Srinivasan] Srinivasan, V., Jeffrey C. Mogul, &#34;Spritely NFS: Implementation and Performance of Cache Consistency Protocols&#34;, WRL Research Report 89/5, Digital Equipment Corporation Western Research Laboratory, 100 Hamilton Ave., Palo Alto, CA, 94301, May 1989. This paper analyzes the effect of applying a Sprite-like consistency protocol applied to standard NFS. The issues of recovery in a stateful environment are covered in [Mogul].
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XNFS] The Open Group, Protocols for Interworking: XNFS, Version 3W, The Open Group, 1010 El Camino Real Suite 380, Menlo Park, CA 94025, ISBN 1-85912-184-5, February 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XNFS] The Open Group, Protocols for Interworking: XNFS, Version 3W, The Open Group, 1010 El Camino Real Suite 380, Menlo Park, CA 94025, ISBN 1-85912-184-5, February 1998.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                             HTML version available:
                             http://www.opengroup.org
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22--Authors-Information">
22. Authors&#39; Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22. Authors&#39; Information
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-1--Editors-Address">
22.1. Editor&#39;s Address
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.1. 編集者の住所
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Spencer Shepler Sun Microsystems, Inc. 7808 Moonflower Drive Austin, Texas 78750
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Spencer Shepler Sun Microsystems, Inc. 7808 Moonflower Drive Austin, Texas 78750
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1 512-349-9376
   EMail: spencer.shepler@sun.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-2--Authors-Addresses">
22.2. Authors&#39; Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.2. Authors&#39; Addresses
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Carl Beame Hummingbird Ltd.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Carl Beame Hummingbird Ltd.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: beame@bws.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Brent Callaghan Sun Microsystems, Inc. 17 Network Circle Menlo Park, CA 94025
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Brent Callaghan Sun Microsystems、Inc. 17 Network Circle Menlo Park、CA 94025
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1 650-786-5067
   EMail: brent.callaghan@sun.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mike Eisler 5765 Chase Point Circle Colorado Springs, CO 80919
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイクアイスラー5765チェイスポイントサークルコロラドスプリングス、コロラド州80919
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1 719-599-9026
   EMail: mike@eisler.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David Noveck Network Appliance 375 Totten Pond Road Waltham, MA 02451
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David Noveck Network Appliance 375 Totten Pond Road Waltham、MA 02451
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1 781-768-5347
   EMail: dnoveck@netapp.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David Robinson Sun Microsystems, Inc. 5300 Riata Park Court Austin, TX 78727
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David Robinson Sun Microsystems, Inc. 5300 Riata Park Court Austin, TX 78727
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1 650-786-5088
   EMail: david.robinson@sun.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Robert Thurlow Sun Microsystems, Inc. 500 Eldorado Blvd. Broomfield, CO 80021
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Robert Thurlow Sun Microsystems、Inc. 500 Eldorado Blvd.ブルームフィールド、コロラド州80021
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1 650-786-5096
   EMail: robert.thurlow@sun.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="23--Full-Copyright-Statement">
23. Full Copyright Statement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
23. Full Copyright Statement
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2003). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2003). All Rights Reserved.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記で付与された制限付きのアクセス許可は永続的であり、インターネットソサエティまたはその後継者または譲受人によって取り消されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントとここに含まれる情報は「現状有姿」で提供され、インターネット社会およびインターネット技術タスクフォースは、明示または黙示を問わず、ここに記載されている情報の使用が保証するものに限定されない一切の保証を含みません。商品性または特定の目的への適合性に関する権利または黙示の保証を侵害すること。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
