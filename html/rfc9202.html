<!DOCTYPE html>


<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 9202 - Datagram Transport Layer Security (DTLS) Profile for Authentication and Authorization for Constrained Environments (ACE) 日本語訳</title>

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">9202</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc9202">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 9202 - Datagram Transport Layer Security (DTLS) Profile for Authentication and Authorization for Constrained Environments (ACE) 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc9202">
            https://datatracker.ietf.org/doc/html/rfc9202
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 9202 - データグラムトランスポートレイヤーセキュリティ（DTLS）制約された環境の認証と承認のためのプロファイル（ACE）</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                         S. Gerdes
Request for Comments: 9202                                   O. Bergmann
Category: Standards Track                                     C. Bormann
ISSN: 2070-1721                                   Universität Bremen TZI
                                                             G. Selander
                                                             Ericsson AB
                                                                L. Seitz
                                                               Combitech
                                                             August 2022
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Datagram Transport Layer Security (DTLS) Profile for Authentication and Authorization for Constrained Environments (ACE)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
データグラムトランスポートレイヤーセキュリティ（DTLS）制約された環境の認証と承認のためのプロファイル（ACE）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification defines a profile of the Authentication and Authorization for Constrained Environments (ACE) framework that allows constrained servers to delegate client authentication and authorization. The protocol relies on DTLS version 1.2 or later for communication security between entities in a constrained network using either raw public keys or pre-shared keys. A resource-constrained server can use this protocol to delegate management of authorization information to a trusted host with less-severe limitations regarding processing power and memory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、制約されたサーバーがクライアント認証と承認を委任できるようにする制約付き環境（ACE）フレームワークの認証と認証のプロファイルを定義します。このプロトコルは、生のパブリックキーまたは事前共有キーを使用して、制約付きネットワーク内のエンティティ間の通信セキュリティについて、DTLSバージョン1.2以降に依存しています。リソースに制約のあるサーバーは、このプロトコルを使用して、許可情報の管理を、処理能力とメモリに関するより重度の制限を伴わない信頼できるホストに委任することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、インターネット標準トラックドキュメントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 7841のセクション2で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9202.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https：//www.rfc-editor.org/info/rfc9202で取得できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2022 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（c）2022 IETF Trustおよび文書著者として特定された人。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、修正されたBSDライセンスで説明されているように保証なしで提供される修正されたBSDライセンステキストを含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction
     1.1.  Terminology
   2.  Protocol Overview
   3.  Protocol Flow
     3.1.  Communication between the Client and the Authorization
           Server
     3.2.  Raw Public Key Mode
       3.2.1.  Access Token Retrieval from the Authorization Server
       3.2.2.  DTLS Channel Setup between the Client and Resource
               Server
     3.3.  Pre-shared Key Mode
       3.3.1.  Access Token Retrieval from the Authorization Server
       3.3.2.  DTLS Channel Setup between the Client and Resource
               Server
     3.4.  Resource Access
   4.  Dynamic Update of Authorization Information
   5.  Token Expiration
   6.  Secure Communication with an Authorization Server
   7.  Security Considerations
     7.1.  Reuse of Existing Sessions
     7.2.  Multiple Access Tokens
     7.3.  Out-of-Band Configuration
   8.  Privacy Considerations
   9.  IANA Considerations
   10. References
     10.1.  Normative References
     10.2.  Informative References
   Acknowledgments
   Authors&#39; Addresses
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification defines a profile of the ACE framework [RFC9200]. In this profile, a client (C) and a resource server (RS) use the Constrained Application Protocol (CoAP) [RFC7252] over DTLS version 1.2 [RFC6347] to communicate. This specification uses DTLS 1.2 terminology, but later versions such as DTLS 1.3 [RFC9147] can be used instead. The client obtains an access token bound to a key (the proof-of-possession (PoP) key) from an authorization server (AS) to prove its authorization to access protected resources hosted by the resource server. Also, the client and the resource server are provided by the authorization server with the necessary keying material to establish a DTLS session. The communication between the client and authorization server may also be secured with DTLS. This specification supports DTLS with raw public keys (RPKs) [RFC7250] and with pre-shared keys (PSKs) [RFC4279]. How token introspection [RFC7662] is performed between the RS and AS is out of scope for this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、ACEフレームワーク[RFC9200]のプロファイルを定義します。このプロファイルでは、クライアント（c）とリソースサーバー（RS）は、DTLSバージョン1.2 [RFC6347]を介して制約付きアプリケーションプロトコル（COAP）[RFC7252]を使用して通信します。この仕様ではDTLS 1.2用語を使用しますが、代わりにDTLS 1.3 [RFC9147]などの後のバージョンを使用できます。クライアントは、リソースサーバーがホストする保護されたリソースにアクセスする許可を証明するために、認証サーバー（AS）からキー（プルーフオブポッセッション（POP）キー）にバインドされたアクセストークンを取得します。また、クライアントとリソースサーバーは、authorizationサーバーからDTLSセッションを確立するために必要なキーイング資料を提供されます。クライアントサーバーと承認サーバー間の通信は、DTLSで保護される場合があります。この仕様は、生のパブリックキー（RPK）[RFC7250]および事前共有キー（PSK）[RFC4279]を使用したDTLSをサポートしています。トークン内省[RFC7662]がRS間で実行される方法と、この仕様の範囲外であるASは実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ACE framework requires that the client and server mutually authenticate each other before any application data is exchanged. DTLS enables mutual authentication if both the client and server prove their ability to use certain keying material in the DTLS handshake. The authorization server assists in this process on the server side by incorporating keying material (or information about keying material) into the access token, which is considered a proof-of-possession token.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACEフレームワークでは、アプリケーションデータが交換される前に、クライアントとサーバーが相互に認証する必要があります。DTLSは、クライアントとサーバーの両方がDTLSハンドシェイクで特定のキーイング素材を使用する能力を証明する場合、相互認証を可能にします。Authorization Serverは、キーイング素材（またはキーイングマテリアルに関する情報）をアクセストークンに組み込むことにより、サーバー側のこのプロセスを支援します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the RPK mode, the client proves that it can use the RPK bound to the token and the server shows that it can use a certain RPK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPKモードでは、クライアントはトークンにバインドされたRPKを使用できることを証明し、サーバーは特定のRPKを使用できることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The resource server needs access to the token in order to complete this exchange. For the RPK mode, the client must upload the access token to the resource server before initiating the handshake, as described in Section 5.10.1 of the ACE framework [RFC9200].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースサーバーは、この交換を完了するためにトークンにアクセスする必要があります。RPKモードの場合、ACEフレームワーク[RFC9200]のセクション5.10.1で説明されているように、ハンドシェイクを開始する前に、クライアントはアクセストークンをリソースサーバーにアップロードする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the PSK mode, the client and server show with the DTLS handshake that they can use the keying material that is bound to the access token. To transfer the access token from the client to the resource server, the psk_identity parameter in the DTLS PSK handshake may be used instead of uploading the token prior to the handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PSKモードでは、クライアントとサーバーは、DTLSの握手を使用して、アクセストークンにバインドされているキーイング素材を使用できることを示しています。アクセストークンをクライアントからリソースサーバーに転送するには、握手の前にトークンをアップロードする代わりに、DTLS PSKハンドシェイクのPSK_IDIDETITYパラメーターを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As recommended in Section 5.8 of [RFC9200], this specification uses Concise Binary Object Representation (CBOR) web tokens to convey claims within an access token issued by the server. While other formats could be used as well, those are out of scope for this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9200]のセクション5.8で推奨されているように、この仕様は簡潔なバイナリオブジェクト表現（CBOR）Webトークンを使用して、サーバーが発行したアクセストークン内でクレームを伝えます。他の形式も使用できますが、これらはこのドキュメントの範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-1--Terminology">
1.1. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. 用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, および &#34;OPTIONAL&#34; はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Readers are expected to be familiar with the terms and concepts described in [RFC9200] and [RFC9201].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
読者は、[RFC9200]および[RFC9201]で説明されている用語と概念に精通していることが期待されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authorization information (authz-info) resource refers to the authorization information endpoint, as specified in [RFC9200]. The term claim is used in this document with the same semantics as in [RFC9200], i.e., it denotes information carried in the access token or returned from introspection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9200]で指定されているように、承認情報（AUTHZ-INFO）リソースは、[RFC9200]で指定されている認証情報エンドポイントを指します。この文書では、[RFC9200]と同じセマンティクスでこのドキュメントで使用されています。つまり、アクセストークンに掲載される情報を示したり、内省から返されたりします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Throughout this document, examples for CBOR data items are expressed in CBOR extended diagnostic notation as defined in Section 8 of [RFC8949] and Appendix G of [RFC8610] (&#34;diagnostic notation&#34;), unless noted otherwise. We often use diagnostic notation comments to provide a textual representation of the numeric parameter names and values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメント全体で、CBORデータ項目の例は、[RFC8949]のセクション8および[RFC8610]の付録G（「診断表記」）の付録Gで定義されているように、CBOR拡張診断表記で表されます。診断表記コメントを使用して、数値パラメーター名と値のテキスト表現を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Protocol-Overview">
2. Protocol Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. プロトコルの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CoAP-DTLS profile for ACE specifies the transfer of authentication information and, if necessary, authorization information between the client (C) and the resource server (RS) during setup of a DTLS session for CoAP messaging. It also specifies how the client can use CoAP over DTLS to retrieve an access token from the authorization server (AS) for a protected resource hosted on the resource server. As specified in Section 6.7 of [RFC9200], use of DTLS for one or both of these interactions is completely independent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACEのCOAP-DTLSプロファイルは、認証情報の転送と、必要に応じて、COAPメッセージング用のDTLSセッションのセットアップ中に、クライアント（c）とリソースサーバー（RS）の間の許可情報を指定します。また、クライアントがDTLを介してCoapを使用して、リソースサーバーでホストされている保護されたリソースのAuthorization Server（AS）からアクセストークンを取得する方法を指定します。[RFC9200]のセクション6.7で指定されているように、これらの相互作用の一方または両方にDTLを使用することは完全に独立しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This profile requires the client to retrieve an access token for the protected resource(s) it wants to access on the resource server, as specified in [RFC9200]. Figure 1 shows the typical message flow in this scenario (messages in square brackets are optional):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロファイルでは、[RFC9200]で指定されているように、リソースサーバーにアクセスしたい保護されたリソースのアクセストークンをクライアントに取得する必要があります。図1は、このシナリオの典型的なメッセージフローを示しています（四角い括弧内のメッセージはオプションです）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      C                                RS                   AS
      | [---- Resource Request ------&gt;]|                     |
      |                                |                     |
      | [&lt;-AS Request Creation Hints-] |                     |
      |                                |                     |
      | ------- Token Request  ----------------------------&gt; |
      |                                |                     |
      | &lt;---------------------------- Access Token --------- |
      |                               + Access Information   |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
Figure 1: Retrieving an Access Token
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
図1：アクセストークンの取得
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To determine the authorization server in charge of a resource hosted at the resource server, the client can send an initial Unauthorized Resource Request message to the resource server. The resource server then denies the request and sends an AS Request Creation Hints message containing the address of its authorization server back to the client, as specified in Section 5.3 of [RFC9200].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースサーバーでホストされているリソースを担当する承認サーバーを決定するために、クライアントは最初の許可されていないリソース要求メッセージをリソースサーバーに送信できます。次に、リソースサーバーはリクエストを拒否し、[RFC9200]のセクション5.3で指定されているように、認証サーバーのアドレスをクライアントに戻すリクエスト作成ヒントメッセージを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the client knows the authorization server&#39;s address, it can send an access token request to the token endpoint at the authorization server, as specified in [RFC9200]. As the access token request and the response may contain confidential data, the communication between the client and the authorization server must be confidentiality protected and ensure authenticity. The client is expected to have been registered at the authorization server, as outlined in Section 4 of [RFC9200].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがAuthorization Serverのアドレスを知っていれば、[RFC9200]で指定されているように、Authorization Serverのトークンエンドポイントにアクセストークン要求を送信できます。アクセストークン要求と応答には機密データが含まれている可能性があるため、クライアントと承認サーバーの間の通信は機密性保護され、信頼性を確保する必要があります。クライアントは、[RFC9200]のセクション4で概説されているように、承認サーバーに登録されていると予想されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The access token returned by the authorization server can then be used by the client to establish a new DTLS session with the resource server. When the client intends to use an asymmetric proof-of-possession key in the DTLS handshake with the resource server, the client MUST upload the access token to the authz-info resource, i.e., the authz-info endpoint, on the resource server before starting the DTLS handshake, as described in Section 5.10.1 of [RFC9200]. In case the client uses a symmetric proof-of-possession key in the DTLS handshake, the procedure above MAY be used, or alternatively the access token MAY instead be transferred in the DTLS ClientKeyExchange message (see Section 3.3.2). In any case, DTLS MUST be used in a mode that provides replay protection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Authorization Serverによって返されるアクセストークンは、クライアントがリソースサーバーとの新しいDTLSセッションを確立するために使用できます。クライアントがリソースサーバーを使用してDTLSハンドシェイクで非対称のプルーフオブポッセッションキーを使用する予定である場合、クライアントはAuthZ-INFOリソース、つまりAuthZ-INFOエンドポイントにアクセストークンをリソースサーバーにアップロードする必要があります。[RFC9200]のセクション5.10.1で説明されているように、DTLSの握手を開始します。クライアントがDTLSハンドシェイクで対称的な入力キーを使用している場合、上記の手順を使用するか、代わりにアクセストークンをDTLS Client KeyExchangeメッセージで転送する場合があります（セクション3.3.2を参照）。いずれにせよ、DTLはリプレイ保護を提供するモードで使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 2 depicts the common protocol flow for the DTLS profile after the client has retrieved the access token from the authorization server (AS).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図2は、クライアントが認証サーバー（AS）からアクセストークンを取得した後、DTLSプロファイルの共通プロトコルフローを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      C                            RS                   AS
      | [--- Access Token ------&gt;] |                     |
      |                            |                     |
      | &lt;== DTLS channel setup ==&gt; |                     |
      |                            |                     |
      | == Authorized Request ===&gt; |                     |
      |                            |                     |
      | &lt;=== Protected Resource == |                     |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
Figure 2: Protocol Overview
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
図2：プロトコルの概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Protocol-Flow">
3. Protocol Flow
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. プロトコルフロー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following sections specify how CoAP is used to interchange access-related data between the resource server, the client, and the authorization server so that the authorization server can provide the client and the resource server with sufficient information to establish a secure channel and convey authorization information specific for this communication relationship to the resource server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のセクションでは、COAPがリソースサーバー、クライアント、および認証サーバー間のアクセス関連データを交換するために使用する方法を指定して、認証サーバーがクライアントとリソースサーバーに安全なチャネルを確立し、認証を伝えるのに十分な情報を提供できるようにします。リソースサーバーとのこの通信関係に固有の情報。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 3.1 describes how the communication between the client (C) and the authorization server (AS) must be secured. Depending on the CoAP security mode used (see also Section 9 of [RFC7252]), the client-to-AS request, AS-to-client response, and DTLS session establishment carry slightly different information. Section 3.2 addresses the use of raw public keys, while Section 3.3 defines how pre-shared keys are used in this profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション3.1では、クライアント（c）と承認サーバー（AS）の間の通信を保護する方法について説明します。使用されるCOAPセキュリティモード（[RFC7252]のセクション9も参照）に応じて、クライアントからクライアントへのリクエスト、AS-Client応答、DTLSセッションの確立は、わずかに異なる情報を提供します。セクション3.2では、生の公開キーの使用について説明し、セクション3.3では、このプロファイルで事前共有キーがどのように使用されるかを定義しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--Communication-between-the-Client-and-the-Authorization-Server">
3.1. Communication between the Client and the Authorization Server
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. クライアントと承認サーバー間の通信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To retrieve an access token for the resource that the client wants to access, the client requests an access token from the authorization server. Before the client can request the access token, the client and the authorization server MUST establish a secure communication channel. This profile assumes that the keying material to secure this communication channel has securely been obtained either by manual configuration or in an automated provisioning process. The following requirements, in alignment with Section 6.5 of [RFC9200], therefore must be met:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがアクセスしたいリソースのアクセストークンを取得するために、クライアントは承認サーバーからアクセストークンを要求します。クライアントがアクセストークンを要求する前に、クライアントと承認サーバーは安全な通信チャネルを確立する必要があります。このプロファイルは、この通信チャネルを保護するためのキーイング材料が、手動構成または自動化されたプロビジョニングプロセスのいずれかによって安全に取得されていることを前提としています。したがって、[RFC9200]のセクション6.5と整合して、以下の要件を満たす必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The client MUST securely have obtained keying material to communicate with the authorization server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* クライアントは、認証サーバーと通信するためのキーイング資料を安全に取得している必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Furthermore, the client MUST verify that the authorization server is authorized to provide access tokens (including authorization information) about the resource server to the client and that this authorization information about the authorization server is still valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* さらに、クライアントは、クライアントにリソースサーバーに関するアクセストークン（承認情報を含む）をクライアントに提供する認定サーバーが認定されていること、および承認サーバーに関するこの認証情報がまだ有効であることを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Also, the authorization server MUST securely have obtained keying material for the client and obtained authorization rules approved by the resource owner (RO) concerning the client and the resource server that relate to this keying material.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* また、承認サーバーは、クライアントのキーイング資料を安全に取得し、クライアントとこのキーイング素材に関連するリソースサーバーに関するリソース所有者（RO）によって承認された認証ルールを取得する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client and the authorization server MUST use their respective keying material for all exchanged messages. How the security association between the client and the authorization server is bootstrapped is not part of this document. The client and the authorization server must ensure the confidentiality, integrity, and authenticity of all exchanged messages within the ACE protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントと承認サーバーは、交換されたすべてのメッセージに対してそれぞれのキーイン素材を使用する必要があります。クライアントと承認サーバーのセキュリティ関連がブートストラップされている方法は、このドキュメントの一部ではありません。クライアントと承認サーバーは、ACEプロトコル内のすべての交換メッセージの機密性、整合性、および信頼性を確保する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 6 specifies how communication with the authorization server is secured.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション6では、Authorization Serverとの通信が保護される方法を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--Raw-Public-Key-Mode">
3.2. Raw Public Key Mode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 生の公開キーモード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client uses raw public key authentication, the procedure is as described in the following.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが生の公開キー認証を使用する場合、手順は以下で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-1--Access-Token-Retrieval-from-the-Authorization-Server">
3.2.1. Access Token Retrieval from the Authorization Server
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. Authorization Serverからのトークン検索にアクセスします
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the client and the authorization server mutually authenticated each other and validated each other&#39;s authorization, the client sends a token request to the authorization server&#39;s token endpoint. The client MUST add a req_cnf object carrying either its raw public key or a unique identifier for a public key that it has previously made known to the authorization server. It is RECOMMENDED that the client uses DTLS with the same keying material to secure the communication with the authorization server, proving possession of the key as part of the token request. Other mechanisms for proving possession of the key may be defined in the future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントと承認サーバーが相互に認証され、互いの認証を検証した後、クライアントはトークン要求を認証サーバーのトークンエンドポイントに送信します。クライアントは、以前に認証サーバーに知られていた公開キーの生の公開鍵または一意の識別子のいずれかを運ぶREQ_CNFオブジェクトを追加する必要があります。クライアントは、同じキーイング素材を備えたDTLSを使用して、承認サーバーとの通信を確保し、トークンリクエストの一部としてキーの所有を証明することをお勧めします。キーの所有を証明するための他のメカニズムは、将来定義される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An example access token request from the client to the authorization server is depicted in Figure 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントから承認サーバーへのアクセストークン要求の例を図3に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      POST coaps://as.example.com/token
      Content-Format: application/ace+cbor
      Payload:
      {
        / grant_type / 33 : / client_credentials / 2,
        / audience /    5 : &#34;tempSensor4711&#34;,
        / req_cnf /     4 : {
          / COSE_Key / 1 : {
            / kty /  1 : / EC2 /   2,
            / crv / -1 : / P-256 / 1,
            / x /   -2 : h&#39;e866c35f4c3c81bb96a1/.../&#39;,
            / y /   -3 : h&#39;2e25556be097c8778a20/.../&#39;
          }
        }
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Figure 3: Access Token Request Example for RPK Mode
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
図3：RPKモードのアクセストークン要求例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The example shows an access token request for the resource identified by the string &#34;tempSensor4711&#34; on the authorization server using a raw public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例は、生の公開キーを使用して承認サーバーの文字列「tempsensor4711」によって識別されたリソースのアクセストークン要求を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authorization server MUST check if the client that it communicates with is associated with the RPK in the req_cnf parameter before issuing an access token to it. If the authorization server determines that the request is to be authorized according to the respective authorization rules, it generates an access token response for the client. The access token MUST be bound to the RPK of the client by means of the cnf claim.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Authorization Serverは、通信するクライアントが、アクセストークンを発行する前に、REQ_CNFパラメーターのRPKに関連付けられているかどうかを確認する必要があります。承認サーバーが、リクエストがそれぞれの承認規則に従って承認されることを決定した場合、クライアントのアクセストークン応答を生成します。アクセストークンは、CNFクレームによってクライアントのRPKにバインドする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The response MUST contain an ace_profile parameter if the ace_profile parameter in the request is empty and MAY contain this parameter otherwise (see Section 5.8.2 of [RFC9200]). This parameter is set to coap_dtls to indicate that this profile MUST be used for communication between the client and the resource server. The response also contains an access token with information for the resource server about the client&#39;s public key. The authorization server MUST return in its response the parameter rs_cnf unless it is certain that the client already knows the public key of the resource server. The authorization server MUST ascertain that the RPK specified in rs_cnf belongs to the resource server that the client wants to communicate with. The authorization server MUST protect the integrity of the access token such that the resource server can detect unauthorized changes. If the access token contains confidential data, the authorization server MUST also protect the confidentiality of the access token.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストのACE_Profileパラメーターが空であり、そうでない場合はこのパラメーターが含まれる場合がある場合、応答にはACE_Profileパラメーターを含める必要があります（[RFC9200]のセクション5.8.2を参照）。このパラメーターは、COAP_DTLSに設定されており、このプロファイルをクライアントとリソースサーバー間の通信に使用する必要があることを示します。応答には、クライアントの公開キーに関するリソースサーバーの情報を含むアクセストークンも含まれています。承認サーバーは、クライアントがリソースサーバーの公開キーを既に知っていることが確実でない限り、その応答でパラメーターRS_CNFを返す必要があります。承認サーバーは、RS_CNFで指定されたRPKが、クライアントが通信したいリソースサーバーに属していることを確認する必要があります。認証サーバーは、リソースサーバーが不正な変更を検出できるように、アクセストークンの整合性を保護する必要があります。アクセストークンに機密データが含まれている場合、承認サーバーはアクセストークンの機密性も保護する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client MUST ascertain that the access token response belongs to a certain, previously sent access token request, as the request may specify the resource server with which the client wants to communicate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、クライアントが通信したいリソースサーバーを指定できるため、アクセストークンの応答が特定の、以前に送信されたアクセストークン要求に属していることを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An example access token response from the authorization server to the client is depicted in Figure 4. Here, the contents of the access_token claim have been truncated to improve readability. For the client, the response comprises Access Information that contains the server&#39;s public key in the rs_cnf parameter. Caching proxies process the Max-Age option in the CoAP response, which has a default value of 60 seconds (Section 5.6.1 of [RFC7252]). The authorization server SHOULD adjust the Max-Age option such that it does not exceed the expires_in parameter to avoid stale responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
認証サーバーからクライアントへのアクセストークン応答の例を図4に示します。ここでは、Access_Tokenクレームの内容が読みやすくなるように切り捨てられています。クライアントの場合、応答は、RS_CNFパラメーターにサーバーの公開キーを含むアクセス情報を含みます。キャッシュプロキシは、60秒のデフォルト値を持つCOAP応答で最大年齢オプションを処理します（[RFC7252]のセクション5.6.1）。Authorization Serverは、古い応答を避けるために有効期限を超えないように最大年齢オプションを調整する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      2.01 Created
      Content-Format: application/ace+cbor
      Max-Age: 3560
      Payload:
      {
        / access_token / 1 : b64&#39;SlAV32hk&#39;/...
         (remainder of CWT omitted for brevity;
         CWT contains the client&#39;s RPK in the cnf claim)/,
        / expires_in /  2 : 3600,
        / rs_cnf /     41 : {
          / COSE_Key /  1 : {
            / kty /  1 : / EC2 /   2,
            / crv / -1 : / P-256 / 1,
            / x /   -2 : h&#39;d7cc072de2205bdc1537/.../&#39;,
            / y /   -3 : h&#39;f95e1d4b851a2cc80fff/.../&#39;
          }
        }
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Figure 4: Access Token Response Example for RPK Mode
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
図4：RPKモードのアクセストークン応答の例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-2--DTLS-Channel-Setup-between-the-Client-and-Resource-Server">
3.2.2. DTLS Channel Setup between the Client and Resource Server
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2. クライアントとリソースサーバーの間のDTLSチャネルのセットアップ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Before the client initiates the DTLS handshake with the resource server, the client MUST send a POST request containing the obtained access token to the authz-info resource hosted by the resource server. After the client receives a confirmation that the resource server has accepted the access token, it proceeds to establish a new DTLS channel with the resource server. The client MUST use its correct public key in the DTLS handshake. If the authorization server has specified a cnf field in the access token response, the client MUST use this key. Otherwise, the client MUST use the public key that it specified in the req_cnf of the access token request. The client MUST specify this public key in the SubjectPublicKeyInfo structure of the DTLS handshake, as described in [RFC7250].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがリソースサーバーでDTLSハンドシェイクを開始する前に、クライアントは、リソースサーバーがホストするAuthZ-INFOリソースに取得したアクセストークンを含むPOSTリクエストを送信する必要があります。クライアントがリソースサーバーがアクセストークンを受け入れたことの確認を受け取った後、リソースサーバーで新しいDTLSチャネルを確立するようになります。クライアントは、DTLSハンドシェイクで正しい公開キーを使用する必要があります。承認サーバーがアクセストークン応答でCNFフィールドを指定した場合、クライアントはこのキーを使用する必要があります。それ以外の場合、クライアントは、アクセストークンリクエストのREQ_CNFで指定した公開キーを使用する必要があります。クライアントは、[RFC7250]で説明されているように、DTLSハンドシェイクの件名PublicKeyInfo構造にこの公開キーを指定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client does not have the keying material belonging to the public key, the client MAY try to send an access token request to the AS, where the client specifies its public key in the req_cnf parameter. If the AS still specifies a public key in the response that the client does not have, the client SHOULD re-register with the authorization server to establish a new client public key. This process is out of scope for this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが公開キーに属するキーイング素材を持っていない場合、クライアントはASにアクセストークン要求を送信しようとすることができます。ASがクライアントが持っていない応答の公開キーをまだ指定している場合、クライアントは認証サーバーで再登録して、新しいクライアントの公開キーを確立する必要があります。このプロセスは、このドキュメントの範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To be consistent with [RFC7252], which allows for shortened Message Authentication Code (MAC) tags in constrained environments, an implementation that supports the RPK mode of this profile MUST at least support the cipher suite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 [RFC7251]. As discussed in [RFC7748], new Elliptic Curve Cryptography (ECC) curves have been defined recently that are considered superior to the so-called NIST curves. Implementations of this profile MUST therefore implement support for curve25519 (cf. [RFC8032], [RFC8422]), as this curve is said to be efficient and less dangerous, regarding implementation errors, than the secp256r1 curve mandated in [RFC7252].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制約された環境でメッセージ認証コード（MAC）タグを短縮できる[RFC7252]と一致するには、このプロファイルのRPKモードをサポートする実装は、少なくともCipher Suite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 [RFC7251]をサポートする必要があります。[RFC7748]で説明したように、いわゆるNIST曲線よりも優れていると考えられる新しい楕円曲線暗号（ECC）曲線が最近定義されています。したがって、このプロファイルの実装は、[RFC7252]で義務付けられているSECP256R1曲線よりも効率的で危険ではないと言われているため、このプロファイルの実装はCurve25519（[RFC8032]、[RFC8422]を参照[RFC8032]、[RFC8422]を参照）を実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The resource server MUST check if the access token is still valid, if the resource server is the intended destination (i.e., the audience) of the token, and if the token was issued by an authorized authorization server (see also Section 5.10.1.1 of [RFC9200]). The access token is constructed by the authorization server such that the resource server can associate the access token with the client&#39;s public key. The cnf claim MUST contain either the client&#39;s RPK or, if the key is already known by the resource server (e.g., from previous communication), a reference to this key. If the authorization server has no certain knowledge that the client&#39;s key is already known to the resource server, the client&#39;s public key MUST be included in the access token&#39;s cnf parameter. If CBOR web tokens [RFC8392] are used (as recommended in [RFC9200]), keys MUST be encoded as specified in [RFC8747]. A resource server MUST have the capacity to store one access token for every proof-of-possession key of every authorized client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースサーバーは、アクセストークンがまだ有効であるかどうか、リソースサーバーがトークンの意図した宛先（つまり、聴衆）であるかどうか、トークンが認定認可サーバーによって発行されたかどうかを確認する必要があります（のセクション5.10.1.1も参照してください。 [RFC9200]）。アクセストークンは、リソースサーバーがアクセストークンをクライアントの公開キーに関連付けることができるように、承認サーバーによって構築されます。 CNFクレームには、クライアントのRPKまたはキーがリソースサーバーによって既にわかっている場合（以前の通信など）、このキーへの参照を含める必要があります。承認サーバーに、クライアントのキーがリソースサーバーに既に知られているという特定の知識がない場合、クライアントの公開キーはアクセストークンのCNFパラメーターに含める必要があります。 Cbor Webトークン[RFC8392]を使用する場合（[RFC9200]で推奨されているように）、[RFC8747]で指定されているようにキーをエンコードする必要があります。リソースサーバーには、すべての承認されたクライアントのすべてのプルーフオブポッセッションキーに対して1つのアクセストークンを保存する能力が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The raw public key used in the DTLS handshake with the client MUST belong to the resource server. If the resource server has several raw public keys, it needs to determine which key to use. The authorization server can help with this decision by including a cnf parameter in the access token that is associated with this communication. In this case, the resource server MUST use the information from the cnf field to select the proper keying material.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとのDTLSハンドシェイクで使用される生の公開鍵は、リソースサーバーに属している必要があります。リソースサーバーにいくつかの生のパブリックキーがある場合、使用するキーを決定する必要があります。Authorization Serverは、この通信に関連付けられているAccessトークンにCNFパラメーターを含めることにより、この決定に役立ちます。この場合、リソースサーバーは、CNFフィールドの情報を使用して、適切なキーイング材料を選択する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, the handshake only finishes if the client and the resource server are able to use their respective keying material.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、クライアントとリソースサーバーがそれぞれのキーイング素材を使用できる場合にのみ、握手が終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3--Pre-shared-Key-Mode">
3.3. Pre-shared Key Mode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. 事前に共有キーモード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client uses pre-shared key authentication, the procedure is as described in the following.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが事前に共有キー認証を使用する場合、手順は以下で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-1--Access-Token-Retrieval-from-the-Authorization-Server">
3.3.1. Access Token Retrieval from the Authorization Server
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1. Authorization Serverからのトークン検索にアクセスします
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To retrieve an access token for the resource that the client wants to access, the client MAY include a req_cnf object carrying an identifier for a symmetric key in its access token request to the authorization server. This identifier can be used by the authorization server to determine the shared secret to construct the proof-of-possession token. The authorization server MUST check if the identifier refers to a symmetric key that was previously generated by the authorization server as a shared secret for the communication between this client and the resource server. If no such symmetric key was found, the authorization server MUST generate a new symmetric key that is returned in its response to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがアクセスしたいリソースのアクセストークンを取得するには、クライアントには、Access Tokenリクエストの対称キーの識別子を承認サーバーに運ぶREQ_CNFオブジェクトを含めることができます。この識別子は、承認サーバーによって使用されて、共有された秘密を決定して、所有証明のトークンを構築することができます。承認サーバーは、識別子が、このクライアントとリソースサーバー間の通信の共有秘密として、承認サーバーによって以前に生成された対称キーを参照するかどうかを確認する必要があります。そのような対称キーが見つからなかった場合、承認サーバーは、クライアントへの応答で返される新しい対称キーを生成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authorization server MUST determine the authorization rules for the client it communicates with, as defined by the resource owner, and generate the access token accordingly. If the authorization server authorizes the client, it returns an AS-to-client response. If the ace_profile parameter is present, it is set to coap_dtls. The authorization server MUST ascertain that the access token is generated for the resource server that the client wants to communicate with. Also, the authorization server MUST protect the integrity of the access token to ensure that the resource server can detect unauthorized changes. If the token contains confidential data, such as the symmetric key, the confidentiality of the token MUST also be protected. Depending on the requested token type and algorithm in the access token request, the authorization server adds Access Information to the response that provides the client with sufficient information to set up a DTLS channel with the resource server. The authorization server adds a cnf parameter to the Access Information carrying a COSE_Key object that informs the client about the shared secret that is to be used between the client and the resource server. To convey the same secret to the resource server, the authorization server can include it directly in the access token by means of the cnf claim or provide sufficient information to enable the resource server to derive the shared secret from the access token. As an alternative, the resource server MAY use token introspection to retrieve the keying material for this access token directly from the authorization server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
承認サーバーは、リソース所有者によって定義されているように、通信するクライアントの承認ルールを決定し、それに応じてアクセストークンを生成する必要があります。 Authorization Serverがクライアントを承認する場合、クライアントからクライアントへの応答を返します。 ACE_Profileパラメーターが存在する場合、COAP_DTLSに設定されています。 Authorization Serverは、クライアントが通信したいリソースサーバーに対してアクセストークンが生成されていることを確認する必要があります。また、承認サーバーは、アクセストークンの整合性を保護して、リソースサーバーが不正な変更を検出できるようにする必要があります。トークンに対称キーなどの機密データが含まれている場合、トークンの機密性も保護する必要があります。アクセストークン要求の要求されたトークンタイプとアルゴリズムに応じて、承認サーバーは、リソースサーバーでDTLSチャネルを設定するのに十分な情報をクライアントに提供する応答にアクセス情報を追加します。 Authorization Serverは、クライアントとリソースサーバーの間で使用される共有秘密についてクライアントに通知するCOSE_KEYオブジェクトを運ぶアクセス情報にCNFパラメーターを追加します。同じ秘密をリソースサーバーに伝えるために、承認サーバーは、CNFクレームを使用してアクセストークンに直接含めるか、リソースサーバーがアクセストークンから共有秘密を導き出すことができるように十分な情報を提供することができます。別の方法として、リソースサーバーはトークン内省を使用して、このアクセストークンのキーイング素材を認証サーバーから直接取得する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An example access token request for an access token with a symmetric proof-of-possession key is illustrated in Figure 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
対称的なプルーフオブポッセッションキーを備えたアクセストークンのアクセストークンの例を図5に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      POST coaps://as.example.com/token
      Content-Format: application/ace+cbor
      Payload:
      {
        / audience / 5 : &#34;smokeSensor1807&#34;
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
Figure 5: Example Access Token Request, (Implicit) Symmetric PoP Key
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
図5：アクセストークン要求の例、（暗黙的）対称ポップキー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A corresponding example access token response is illustrated in Figure 6. In this example, the authorization server returns a 2.01 response containing a new access token (truncated to improve readability) and information for the client, including the symmetric key in the cnf claim. The information is transferred as a CBOR data structure as specified in [RFC9200].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
対応する例アクセストークン応答を図6に示します。この例では、認証サーバーは、CNFクレームの対称キーを含む、新しいアクセストークン（読みやすくなるように切り捨てられた）とクライアントの情報を含む2.01応答を返します。情報は、[RFC9200]で指定されているように、CBORデータ構造として転送されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      2.01 Created
      Content-Format: application/ace+cbor
      Max-Age: 85800
      Payload:
      {
         / access_token /  1 : h&#39;d08343a1/...
           (remainder of CWT omitted for brevity)/&#39;,
         / token_type /   34 : / PoP / 2,
         / expires_in /    2 : 86400,
         / ace_profile /  38 : / coap_dtls / 1,
         / cnf /           8 : {
           / COSE_Key / 1 : {
             / kty / 1 : / symmetric / 4,
             / kid / 2 : h&#39;3d027833fc6267ce&#39;,
             / k /  -1 : h&#39;73657373696f6e6b6579&#39;
           }
         }
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Figure 6: Example Access Token Response, Symmetric PoP Key
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
図6：アクセストークン応答の例、対称ポップキー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The access token also comprises a cnf claim. This claim usually contains a COSE_Key object [RFC8152] that carries either the symmetric key itself or a key identifier that can be used by the resource server to determine the secret key it shares with the client. If the access token carries a symmetric key, the access token MUST be encrypted using a COSE_Encrypt0 structure (see Section 7.1 of [RFC8392]). The authorization server MUST use the keying material shared with the resource server to encrypt the token.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクセストークンは、CNFクレームも含まれます。このクレームには通常、対称キー自体またはクライアントと共有するシークレットキーを決定するためにリソースサーバーが使用できるキー識別子を搭載するCOSE_KEYオブジェクト[RFC8152]が含まれています。アクセストークンに対称キーがある場合、アクセストークンはCOSE_ENCRYPT0構造を使用して暗号化する必要があります（[RFC8392]のセクション7.1を参照）。Authorization Serverは、リソースサーバーと共有されたキーイング素材を使用して、トークンを暗号化する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cnf structure in the access token is provided in Figure 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクセストークンのCNF構造を図7に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   / cnf / 8 : {
     / COSE_Key / 1 : {
       / kty / 1 : / symmetric / 4,
       / kid / 2 : h&#39;3d027833fc6267ce&#39;
     }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Figure 7: Access Token without Keying Material
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
図7：キーイング素材なしでトークンにアクセスします
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A response that declines any operation on the requested resource is constructed according to Section 5.2 of [RFC6749] (cf. Section 5.8.3 of [RFC9200]). Figure 8 shows an example for a request that has been rejected due to invalid request parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求されたリソースの操作を拒否する応答は、[RFC6749]のセクション5.2に従って構築されます（[RFC9200]のセクション5.8.3を参照）。図8は、無効な要求パラメーターのために拒否された要求の例を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       4.00 Bad Request
       Content-Format: application/ace+cbor
       Payload:
       {
         / error / 30 : / invalid_request / 1
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Figure 8: Example Access Token Response with Reject
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
図8：拒否付きのアクセストークン応答の例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The method for how the resource server determines the symmetric key from an access token containing only a key identifier is application specific; the remainder of this section provides one example.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースサーバーがキー識別子のみを含むアクセストークンから対称キーを決定する方法の方法は、アプリケーション固有です。このセクションの残りの部分には、一例があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authorization server and the resource server are assumed to share a key derivation key used to derive the symmetric key shared with the client from the key identifier in the access token. The key derivation key may be derived from some other secret key shared between the authorization server and the resource server. This key needs to be securely stored and processed in the same way as the key used to protect the communication between the authorization server and the resource server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Authorization Serverとリソースサーバーは、アクセストークンのキー識別子からクライアントと共有された対称キーを導出するために使用されるキー派生キーを共有すると想定されています。キー派生キーは、Authorization ServerとResource Serverの間で共有される他のシークレットキーから派生する場合があります。このキーは、認証サーバーとリソースサーバー間の通信を保護するために使用されるキーと同じ方法で安全に保存および処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Knowledge of the symmetric key shared with the client must not reveal any information about the key derivation key or other secret keys shared between the authorization server and resource server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントと共有された対称キーの知識は、承認サーバーとリソースサーバーの間で共有されるキー派生キーまたは他のシークレットキーに関する情報を明らかにしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to generate a new symmetric key to be used by the client and resource server, the authorization server generates a new key identifier that MUST be unique among all key identifiers used by the authorization server for this resource server. The authorization server then uses the key derivation key shared with the resource server to derive the symmetric key, as specified below. Instead of providing the keying material in the access token, the authorization server includes the key identifier in the kid parameter (see Figure 7). This key identifier enables the resource server to calculate the symmetric key used for the communication with the client using the key derivation key and a key derivation function (KDF) to be defined by the application, for example, HKDF-SHA-256. The key identifier picked by the authorization server MUST be unique for each access token where a unique symmetric key is required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとリソースサーバーが使用する新しい対称キーを生成するために、Authorization Serverは、このリソースサーバーにAuthorization Serverが使用するすべてのキー識別子の中で一意でなければならない新しいキー識別子を生成します。承認サーバーは、以下に指定されているように、リソースサーバーと共有されたキーデリューションキーを使用して対称キーを導出します。Accessトークンにキーイング素材を提供する代わりに、Authorization ServerにはKIDパラメーターにキー識別子が含まれます（図7を参照）。このキー識別子により、リソースサーバーは、キー派生キーとキー派生関数（KDF）を使用してクライアントとの通信に使用される対称キーを計算して、たとえばHKDF-SHA-256で定義されます。Authorization Serverによって選択されたキー識別子は、一意の対称キーが必要な場合に、アクセストークンごとに一意でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this example, the HMAC-based key derivation function (HKDF) consists of the composition of the HKDF-Extract and HKDF-Expand steps [RFC5869]. The symmetric key is derived from the key identifier, the key derivation key, and other data:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例では、HMACベースのキー導出関数（HKDF）は、HKDF-ExtractおよびHKDF-Expandステップの組成[RFC5869]で構成されています。対称キーは、キー識別子、キー派生キー、およびその他のデータから導出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
OKM = HKDF(salt, IKM, info, L),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
okm = hkdf（塩、ikm、info、l）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* OKM, the output keying material, is the derived symmetric key
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* OKM、出力キーイン素材は、派生した対称キーです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* salt is the empty byte string
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 塩は空のバイト文字列です
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* IKM, the input keying material, is the key derivation key, as defined above
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 入力キーイング材料であるIKMは、上記で定義されているようにキー派生キーです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* info is the serialization of a CBOR array consisting of [RFC8610]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 情報は、[RFC8610]で構成されるCBORアレイのシリアル化です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            info = [
              type : tstr,
              L    : uint,
              access_token : bytes
            ]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
where:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ただし：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- type is set to the constant text string &#34;ACE-CoAP-DTLS-key-derivation&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- タイプは定数テキスト文字列「Ace-coap-dtls-key-derivation」に設定されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- L is the size of the symmetric key in bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- lはバイトの対称キーのサイズです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- access_token is the content of the access_token field, as transferred from the authorization server to the resource server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Access_Tokenは、Access_Tokenフィールドのコンテンツであり、Authorization Serverからリソースサーバーに転送されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All CBOR data types are encoded in CBOR using preferred serialization and deterministic encoding, as specified in Section 4 of [RFC8949]. In particular, this implies that the type and L components use the minimum length encoding. The content of the access_token field is treated as opaque data for the purpose of key derivation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのCBORデータ型は、[RFC8949]のセクション4で指定されているように、優先シリアル化と決定論的エンコードを使用してCBORでエンコードされます。特に、これは、タイプとLのコンポーネントが最小長さエンコーディングを使用していることを意味します。Access_Tokenフィールドのコンテンツは、キー派生を目的として不透明なデータとして扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of a unique (per-resource-server) kid and the use of a key derivation IKM that MUST be unique per AS/RS pair, as specified above, will ensure that the derived key is not shared across multiple clients. However, to provide variation in the derived key across different tokens used by the same client, it is additionally RECOMMENDED to include the iat claim and either the exp or exi claims in the access token.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記で指定されているように、AS/RSペアごとに一意でなければならないキー派生IKMのユニークな（リソースごとの）子供の使用は、派生キーが複数のクライアントで共有されないことを保証します。ただし、同じクライアントが使用するさまざまなトークンで派生キーのバリエーションを提供するには、IATクレームとアクセストークンのEXPまたはEXIクレームのいずれかを含めることをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-2--DTLS-Channel-Setup-between-the-Client-and-Resource-Server">
3.3.2. DTLS Channel Setup between the Client and Resource Server
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.2. クライアントとリソースサーバーの間のDTLSチャネルのセットアップ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client receives an access token response from an authorization server, the client MUST check if the access token response is bound to a certain, previously sent access token request, as the request may specify the resource server with which the client wants to communicate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが認証サーバーからアクセストークン応答を受信した場合、クライアントは、クライアントが通信したいリソースサーバーを指定できるため、アクセストークン応答が特定のアクセストークン要求にバインドされているかどうかを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client checks if the payload of the access token response contains an access_token parameter and a cnf parameter. With this information, the client can initiate the establishment of a new DTLS channel with a resource server. To use DTLS with pre-shared keys, the client follows the PSK key exchange algorithm specified in Section 2 of [RFC4279], using the key conveyed in the cnf parameter of the AS response as a PSK when constructing the premaster secret. To be consistent with the recommendations in [RFC7252], a client in the PSK mode MUST support the cipher suite TLS_PSK_WITH_AES_128_CCM_8 [RFC6655].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、アクセストークン応答のペイロードにAccess_TokenパラメーターとCNFパラメーターが含まれているかどうかを確認します。この情報を使用すると、クライアントはリソースサーバーを使用して新しいDTLSチャネルの確立を開始できます。事前に共有キーを使用してDTLを使用するために、クライアントは、Premaster Secretを構築する際にPSKとしてAS応答として伝達されたキーを使用して、[RFC4279]のセクション2で指定されたPSKキー交換アルゴリズムに従います。[RFC7252]の推奨事項と一致するには、PSKモードのクライアントは、Cipher Suite TLS_PSK_WITH_AES_128_CCM_8 [RFC6655]をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In PreSharedKey mode, the knowledge of the shared secret by the client and the resource server is used for mutual authentication between both peers. Therefore, the resource server must be able to determine the shared secret from the access token. Following the general ACE authorization framework, the client can upload the access token to the resource server&#39;s authz-info resource before starting the DTLS handshake. The client then needs to indicate during the DTLS handshake which previously uploaded access token it intends to use. To do so, it MUST create a COSE_Key structure with the kid that was conveyed in the rs_cnf claim in the token response from the authorization server and the key type symmetric. This structure then is included as the only element in the cnf structure whose CBOR serialization is used as value for psk_identity, as shown in Figure 9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PresharedKeyモードでは、クライアントとリソースサーバーによる共有秘密の知識は、両方のピア間の相互認証に使用されます。したがって、リソースサーバーは、アクセストークンから共有秘密を決定できる必要があります。一般的なACE Authorizationフレームワークに従って、クライアントはDTLSハンドシェイクを開始する前に、アクセストークンをリソースサーバーのAuthZ-INFOリソースにアップロードできます。その後、クライアントは、使用する予定のアクセストークンを以前にアップロードしたDTLSハンドシェイク中に示す必要があります。そのためには、Authorization ServerおよびKey Type Symmetricからのトークン応答でRS_CNFクレームで伝えられたKIDとCOSE_KEY構造を作成する必要があります。この構造は、図9に示すように、CBORシリアル化がPSK_IDENTITYの値として使用されるCNF構造の唯一の要素として含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   { / cnf / 8 : {
      / COSE_Key / 1 : {
         / kty / 1 : / symmetric / 4,
         / kid / 2 : h&#39;3d027833fc6267ce&#39;
       }
     }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Figure 9: Access Token Containing a Single kid Parameter
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
図9：シングルキッドパラメーターを含むアクセストークン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The actual CBOR serialization for the data structure from Figure 9 as a sequence of bytes in hexadecimal notation will be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
16進表のバイトのシーケンスとしての図9のデータ構造の実際のCBORシリアル化は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A1 08 A1 01 A2 01 04 02 48 3D 02 78 33 FC 62 67 CE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A1 08 A1 01 A2 01 04 02 48 3D 02 78 33 FC 62 67 CE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an alternative to the access token upload, the client can provide the most recent access token in the psk_identity field of the ClientKeyExchange message. To do so, the client MUST treat the contents of the access_token field from the AS-to-client response as opaque data, as specified in Section 4.2 of [RFC7925], and not perform any recoding. This allows the resource server to retrieve the shared secret directly from the cnf claim of the access token.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクセストークンアップロードの代替として、クライアントはClient KeyExchangeメッセージのPSK_IDIDITYフィールドに最新のアクセストークンを提供できます。そのためには、クライアントは、[RFC7925]のセクション4.2で指定されているように、ASC-Client応答からASC-Client応答から不透明なデータとしてAccess_Tokenフィールドの内容を扱う必要があり、レコーディングを実行しません。これにより、リソースサーバーは、アクセストークンのCNFクレームから共有秘密を直接取得できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DTLS 1.3 [RFC9147] does not use the ClientKeyExchange message; for DTLS 1.3, the access token is placed in the identity field of a PSKIdentity within the PreSharedKeyExtension of the ClientHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DTLS 1.3 [RFC9147]は、ClientKeyExchangeメッセージを使用しません。DTLS 1.3の場合、アクセストークンは、ClientHelloのpresharedKeyextension内のpskidentityのIDフィールドに配置されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a resource server receives a ClientKeyExchange message that contains a psk_identity with a length greater than zero, it MUST parse the contents of the psk_identity field as a CBOR data structure and process the contents as following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースサーバーがゼロを超える長さのpsk_identityを含むclientkeyexchangeメッセージを受信した場合、psk_identityフィールドの内容をCBORデータ構造として解析し、次のように内容を処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* If the data contains a cnf field with a COSE_Key structure with a kid, the resource server continues the DTLS handshake with the associated key that corresponds to this kid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* データに子供を持つCOSE_KEY構造を持つCNFフィールドが含まれている場合、リソースサーバーは、この子供に対応する関連キーでDTLSの握手を継続します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* If the data comprises additional CWT information, this information must be stored as an access token for this DTLS association before continuing with the DTLS handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* データが追加のCWT情報で構成されている場合、この情報は、DTLSハンドシェイクを継続する前に、このDTLSアソシエーションのアクセストークンとして保存する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the contents of the psk_identity do not yield sufficient information to select a valid access token for the requesting client, the resource server aborts the DTLS handshake with an illegal_parameter alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PSK_IDENTITYの内容が、リクエストクライアントの有効なアクセストークンを選択するのに十分な情報を生成しない場合、リソースサーバーはILLEGAL_PARAMETERアラートでDTLSハンドシェイクを中止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the resource server receives an access token, it MUST check if the access token is still valid, if the resource server is the intended destination (i.e., the audience of the token), and if the token was issued by an authorized authorization server. This specification implements access tokens as proof-of-possession tokens. Therefore, the access token is bound to a symmetric PoP key that is used as a shared secret between the client and the resource server. A resource server MUST have the capacity to store one access token for every proof-of-possession key of every authorized client. The resource server may use token introspection [RFC7662] on the access token to retrieve more information about the specific token. The use of introspection is out of scope for this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースサーバーがアクセストークンを受信した場合、アクセストークンがまだ有効であるかどうか、リソースサーバーが意図した宛先（つまり、トークンの視聴者）であるかどうか、トークンが承認承認サーバーによって発行されたかどうかを確認する必要があります。この仕様により、アクセストークンは、プルーフオブポッセッショントークンとして実装されています。したがって、アクセストークンは、クライアントとリソースサーバーの間の共有秘密として使用される対称ポップキーにバインドされます。リソースサーバーには、すべての承認されたクライアントのすべてのプルーフオブポッセッションキーに対して1つのアクセストークンを保存する能力が必要です。リソースサーバーは、アクセストークンでトークン内省[RFC7662]を使用して、特定のトークンに関する詳細情報を取得する場合があります。内省の使用は、この仕様の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the client can retrieve the shared secret from the contents of the cnf parameter in the AS-to-client response, the resource server uses the information contained in the cnf claim of the access token to determine the actual secret when no explicit kid was provided in the psk_identity field. If key derivation is used, the cnf claim MUST contain a kid parameter to be used by the server as the IKM for key derivation, as described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、AS-Client応答のCNFパラメーターの内容から共有秘密を取得できますが、リソースサーバーは、アクセストークンのCNFクレームに含まれる情報を使用して、明示的なKIDが提供されなかったときに実際の秘密を決定するPSK_IDENTITYフィールドで。キー派生を使用する場合、上記のように、サーバーがキー導入のためにIKMとして使用するKIDパラメーターをCNF請求に含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-4--Resource-Access">
3.4. Resource Access
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. リソースアクセス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once a DTLS channel has been established as described in either Sections 3.2 or 3.3, respectively, the client is authorized to access resources covered by the access token it has uploaded to the authz-info resource that is hosted by the resource server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それぞれセクション3.2または3.3のいずれかで説明されているようにDTLSチャネルが確立されると、クライアントは、リソースサーバーによってホストされているAuthZ-INFOリソースにアップロードされたアクセストークンの対象となるリソースにアクセスすることを許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the successful establishment of the DTLS channel, the client and the resource server have proven that they can use their respective keying material. An access token that is bound to the client&#39;s keying material is associated with the channel. According to Section 5.10.1 of [RFC9200], there should be only one access token for each client. New access tokens issued by the authorization server SHOULD replace previously issued access tokens for the respective client. The resource server therefore needs a common understanding with the authorization server about how access tokens are ordered. The authorization server may, e.g., specify a cti claim for the access token (see Section 5.9.2 of [RFC9200]) to employ a strict order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DTLSチャネルの確立が成功したため、クライアントとリソースサーバーは、それぞれのキーイング素材を使用できることを証明しています。クライアントのキーイング素材にバインドされているアクセストークンは、チャネルに関連付けられています。[RFC9200]のセクション5.10.1によると、各クライアントに1つのアクセストークンのみが必要です。Authorization Serverによって発行された新しいアクセストークンは、それぞれのクライアントに以前に発行されたアクセストークンを置き換える必要があります。したがって、リソースサーバーは、アクセストークンの注文方法について認証サーバーで共通の理解が必要です。Authorization Serverは、たとえば、厳格な順序を使用するために、アクセストークン（[RFC9200]のセクション5.9.2を参照）のCTIクレームを指定する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any request that the resource server receives on a DTLS channel that is tied to an access token via its keying material MUST be checked against the authorization rules that can be determined with the access token. The resource server MUST check for every request if the access token is still valid. If the token has expired, the resource server MUST remove it. Incoming CoAP requests that are not authorized with respect to any access token that is associated with the client MUST be rejected by the resource server with a 4.01 response. The response SHOULD include AS Request Creation Hints, as described in Section 5.2 of [RFC9200].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースサーバーがキーイング素材を介してアクセストークンに関連付けられているDTLSチャネルで受信するリクエストは、アクセストークンで決定できる承認ルールに対してチェックする必要があります。リソースサーバーは、アクセストークンがまだ有効である場合、すべての要求を確認する必要があります。トークンの有効期限が切れた場合、リソースサーバーは削除する必要があります。クライアントに関連付けられているアクセストークンに関して許可されていない着信COAP要求は、4.01応答でリソースサーバーによって拒否される必要があります。応答には、[RFC9200]のセクション5.2で説明されているように、リクエスト作成ヒントとして含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The resource server MUST NOT accept an incoming CoAP request as authorized if any of the following fails:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースサーバーは、次のいずれかが失敗した場合、承認されたように着信COAP要求を受け入れてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The message was received on a secure channel that has been established using the procedure defined in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. メッセージは、このドキュメントで定義されている手順を使用して確立された安全なチャネルで受信されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The authorization information tied to the sending client is valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 送信クライアントに関連付けられている許可情報は有効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The request is destined for the resource server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. リクエストはリソースサーバー向けです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. The resource URI specified in the request is covered by the authorization information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. リクエストで指定されたリソースURIは、承認情報でカバーされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. The request method is an authorized action on the resource with respect to the authorization information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. リクエスト方法は、承認情報に関するリソースに対する承認されたアクションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Incoming CoAP requests received on a secure DTLS channel that are not thus authorized MUST be rejected according to Section 5.10.2 of [RFC9200]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このように許可されていない安全なDTLSチャネルで受信した着信COAPリクエストは、[RFC9200]のセクション5.10.2に従って拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. with response code 4.03 (Forbidden) when the resource URI specified in the request is not covered by the authorization information and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. リクエストで指定されたリソースURIが承認情報でカバーされていない場合、応答コード4.03（禁止）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. with response code 4.05 (Method Not Allowed) when the resource URI specified in the request is covered by the authorization information but not the requested action.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. リクエストで指定されたリソースURIが承認情報でカバーされているが、要求されたアクションではない場合、応答コード4.05（方法は許可されていません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client MUST ascertain that its keying material is still valid before sending a request or processing a response. If the client recently has updated the access token (see Section 4), it must be prepared that its request is still handled according to the previous authorization rules, as there is no strict ordering between access token uploads and resource access messages. See also Section 7.2 for a discussion of access token processing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、リクエストを送信したり、応答を処理する前に、キーイング素材がまだ有効であることを確認する必要があります。クライアントが最近アクセストークンを更新した場合（セクション4を参照）、アクセストークンアップロードとリソースアクセスメッセージの間に厳格な順序がないため、その要求は以前の承認ルールに従って処理されることを準備する必要があります。アクセストークン処理の説明については、セクション7.2も参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client gets an error response containing AS Request Creation Hints (cf. Section 5.3 of [RFC9200]) as a response to its requests, it SHOULD request a new access token from the authorization server in order to continue communication with the resource server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがリクエストのヒント（[RFC9200]のセクション5.3を参照）を含むエラー応答をその要求への応答として取得する場合、リソースサーバーとの通信を継続するために、認証サーバーから新しいアクセストークンを要求する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unauthorized requests that have been received over a DTLS session SHOULD be treated as nonfatal by the resource server, i.e., the DTLS session SHOULD be kept alive until the associated access token has expired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DTLSセッションで受信された不正なリクエストは、リソースサーバーによって非致命的なものとして扱われる必要があります。つまり、DTLSセッションは、関連するアクセストークンの有効期限が切れるまで生存しておく必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Dynamic-Update-of-Authorization-Information">
4. Dynamic Update of Authorization Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 認証情報の動的な更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Resource servers must only use a new access token to update the authorization information for a DTLS session if the keying material that is bound to the token is the same that was used in the DTLS handshake. By associating the access tokens with the identifier of an existing DTLS session, the authorization information can be updated without changing the cryptographic keys for the DTLS communication between the client and the resource server, i.e., an existing session can be used with updated permissions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースサーバーは、新しいアクセストークンを使用して、トークンにバインドされているキーイング素材がDTLSハンドシェイクで使用されたキーイング素材が同じである場合にのみ、DTLSセッションの承認情報を更新する必要があります。アクセストークンを既存のDTLSセッションの識別子に関連付けることにより、クライアントとリソースサーバー間のDTLS通信の暗号化キーを変更せずに認証情報を更新できます。つまり、既存のセッションを更新された許可で使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client can therefore update the authorization information stored at the resource server at any time without changing an established DTLS session. To do so, the client requests a new access token from the authorization server for the intended action on the respective resource and uploads this access token to the authz-info resource on the resource server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、クライアントは、確立されたDTLSセッションを変更することなく、いつでもリソースサーバーに保存されている承認情報を更新できます。そのために、クライアントは、それぞれのリソースで意図したアクションについて認証サーバーに新しいアクセストークンを要求し、このアクセストークンをリソースサーバーのAUTHZ-INFOリソースにアップロードします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 10 depicts the message flow where the client requests a new access token after a security association between the client and the resource server has been established using this protocol. If the client wants to update the authorization information, the token request MUST specify the key identifier of the proof-of-possession key used for the existing DTLS channel between the client and the resource server in the kid parameter of the client-to-AS request. The authorization server MUST verify that the specified kid denotes a valid verifier for a proof-of-possession token that has previously been issued to the requesting client. Otherwise, the client-to-AS request MUST be declined with the error code unsupported_pop_key, as defined in Section 5.8.3 of [RFC9200].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図10は、クライアントとリソースサーバーのセキュリティ関連がこのプロトコルを使用して確立された後、クライアントが新しいアクセストークンを要求するメッセージフローを示しています。クライアントが承認情報を更新する場合、トークン要求は、クライアントとASのKIDパラメーターのクライアントとリソースサーバーの間の既存のDTLSチャネルに使用されるプルーフオブポッセッションキーのキー識別子を指定する必要があります。リクエスト。承認サーバーは、指定されたKIDが、以前にリクエストクライアントに発行されたプルーフオブポッセッショントークンの有効な検証を示していることを確認する必要があります。それ以外の場合、[RFC9200]のセクション5.8.3で定義されているように、クライアントからASのリクエストを拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the authorization server issues a new access token to update existing authorization information, it MUST include the specified kid parameter in this access token. A resource server MUST replace the authorization information of any existing DTLS session that is identified by this key identifier with the updated authorization information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
承認サーバーが新しいアクセストークンを発行して既存の認証情報を更新する場合、このアクセストークンに指定されたKIDパラメーターを含める必要があります。リソースサーバーは、このキー識別子によって識別された既存のDTLSセッションの承認情報を更新された承認情報に置き換える必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      C                            RS                   AS
      | &lt;===== DTLS channel =====&gt; |                     |
      |        + Access Token      |                     |
      |                            |                     |
      | --- Token Request  ----------------------------&gt; |
      |                            |                     |
      | &lt;---------------------------- New Access Token - |
      |                           + Access Information   |
      |                            |                     |
      | --- Update /authz-info --&gt; |                     |
      |     New Access Token       |                     |
      |                            |                     |
      | == Authorized Request ===&gt; |                     |
      |                            |                     |
      | &lt;=== Protected Resource == |                     |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
Figure 10: Overview of Dynamic Update Operation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
図10：動的更新操作の概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Token-Expiration">
5. Token Expiration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. トークンの有効期限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The resource server MUST delete access tokens that are no longer valid. DTLS associations that have been set up in accordance with this profile are always tied to specific tokens (which may be exchanged with a dynamic update, as described in Section 4). As tokens may become invalid at any time (e.g., because they have expired), the association may become useless at some point. A resource server therefore MUST terminate existing DTLS association after the last access token associated with this association has expired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースサーバーは、もはや有効でないアクセストークンを削除する必要があります。このプロファイルに従ってセットアップされたDTLS関連は、常に特定のトークンに結び付けられています（セクション4で説明されているように、動的アップデートと交換される場合があります）。トークンはいつでも無効になる可能性があるため（たとえば、期限切れになったため）、ある時点で協会は役に立たない場合があります。したがって、リソースサーバーは、この関連付けに関連付けられた最後のアクセストークンが期限切れになった後、既存のDTLSアソシエーションを終了する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As specified in Section 5.10.3 of [RFC9200], the resource server MUST notify the client with an error response with code 4.01 (Unauthorized) for any long-running request before terminating the association.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9200]のセクション5.10.3で指定されているように、リソースサーバーは、協会を終了する前に、長期にわたる要求に対してコード4.01（不正）のエラー応答をクライアントに通知する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Secure-Communication-with-an-Authorization-Server">
6. Secure Communication with an Authorization Server
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 認証サーバーとの安全な通信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As specified in the ACE framework (Sections 5.8 and 5.9 of [RFC9200]), the requesting entity (the resource server and/or the client) and the authorization server communicate via the token endpoint or introspection endpoint. The use of CoAP and DTLS for this communication is RECOMMENDED in this profile. Other protocols fulfilling the security requirements defined in Section 5 of [RFC9200] MAY be used instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACEフレームワーク（[RFC9200]のセクション5.8および5.9）で指定されているように、リクエストエンティティ（リソースサーバーおよび/またはクライアント）と認証サーバーは、トークンエンドポイントまたは内省エンドポイントを介して通信します。このコミュニケーションにCOAPとDTLSの使用は、このプロファイルで推奨されます。[RFC9200]のセクション5で定義されているセキュリティ要件を満たす他のプロトコルは、代わりに使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
How credentials (e.g., PSK, RPK, X.509 cert) for using DTLS with the authorization server are established is out of scope for this profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
認証サーバーでDTLSを使用するための資格情報（PSK、RPK、X.509証明書など）が確立される方法は、このプロファイルの範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If other means of securing the communication with the authorization server are used, the communication security requirements from Section 6.2 of [RFC9200] remain applicable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
認証サーバーとの通信を保護する他の手段が使用されている場合、[RFC9200]のセクション6.2からの通信セキュリティ要件が適用されたままです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Security-Considerations">
7. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies a profile for the Authentication and Authorization for Constrained Environments (ACE) framework [RFC9200]. As it follows this framework&#39;s general approach, the general security considerations from Section 6 of [RFC9200] also apply to this profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、制約された環境（ACE）フレームワーク[RFC9200]の認証と認証のプロファイルを指定します。このフレームワークの一般的なアプローチに従って、[RFC9200]のセクション6からの一般的なセキュリティに関する考慮事項もこのプロファイルに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authorization server must ascertain that the keying material for the client that it provides to the resource server actually is associated with this client. Malicious clients may hand over access tokens containing their own access permissions to other entities. This problem cannot be completely eliminated. Nevertheless, in RPK mode, it should not be possible for clients to request access tokens for arbitrary public keys; if the client can cause the authorization server to issue a token for a public key without proving possession of the corresponding private key, this allows for identity misbinding attacks, where the issued token is usable by an entity other than the intended one. At some point, the authorization server therefore needs to validate that the client can actually use the private key corresponding to the client&#39;s public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Authorization Serverは、リソースサーバーに提供するクライアントのキーイング素材が実際にこのクライアントに関連付けられていることを確認する必要があります。悪意のあるクライアントは、他のエンティティへの独自のアクセス許可を含むアクセストークンを引き渡すことができます。この問題を完全に排除することはできません。それにもかかわらず、RPKモードでは、クライアントが任意のパブリックキーのアクセストークンを要求することはできないはずです。クライアントが、対応する秘密鍵の所有権を証明せずに認証サーバーに公開キーのトークンを発行できる場合、これにより、発行されたトークンが意図されたエンティ以外のエンティティが使用できるアイデンティティの違い攻撃が可能になります。したがって、ある時点で、承認サーバーは、クライアントがクライアントの公開キーに対応する秘密キーを実際に使用できることを検証する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When using pre-shared keys provisioned by the authorization server, the security level depends on the randomness of PSKs and the security of the TLS cipher suite and key exchange algorithm. As this specification targets constrained environments, message payloads exchanged between the client and the resource server are expected to be small and rare. CoAP [RFC7252] mandates the implementation of cipher suites with abbreviated, 8-byte tags for message integrity protection. For consistency, this profile requires implementation of the same cipher suites. For application scenarios where the cost of full-width authentication tags is low compared to the overall amount of data being transmitted, the use of cipher suites with 16-byte integrity protection tags is preferred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Authorization Serverによってプロビジョニングされた事前に共有キーを使用する場合、セキュリティレベルは、PSKのランダム性とTLS暗号スイートとキーエクスチェンジアルゴリズムのセキュリティに依存します。この仕様は制約された環境をターゲットにするため、クライアントとリソースサーバーの間で交換されるメッセージペイロードは小さくてまれであると予想されます。COAP [RFC7252]は、メッセージ整合性保護のための省略された8バイトのタグを暗号スイートの実装に義務付けています。一貫性のために、このプロファイルには同じ暗号スイートの実装が必要です。完全な幅認証タグのコストが送信されるデータの全体的な量と比較して低いアプリケーションシナリオの場合、16バイトの整合性保護タグを備えた暗号スイートの使用が推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PSK mode of this profile offers a distribution mechanism to convey authorization tokens together with a shared secret to a client and a server. As this specification aims at constrained devices and uses CoAP [RFC7252] as the transfer protocol, at least the cipher suite TLS_PSK_WITH_AES_128_CCM_8 [RFC6655] should be supported. The access tokens and the corresponding shared secrets generated by the authorization server are expected to be sufficiently short-lived to provide similar forward-secrecy properties to using ephemeral Diffie-Hellman (DHE) key exchange mechanisms. For longer-lived access tokens, DHE cipher suites should be used, i.e., cipher suites of the form TLS_DHE_PSK_* or TLS_ECDHE_PSK_*.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロファイルのPSKモードは、クライアントとサーバーに共有された秘密とともに認証トークンを伝えるための分布メカニズムを提供します。この仕様は制約されたデバイスを目的としており、COAP [RFC7252]を転送プロトコルとして使用するため、少なくともCipher Suite TLS_PSK_WITH_AES_128_CCM_8 [RFC6655]をサポートする必要があります。Access TokensとAuthorization Serverによって生成された対応する共有秘密は、Ephemeral Diffie-Hellman（DHE）の主要な交換メカニズムを使用するために同様の前方セクシープロパティを提供するのに十分な短命であると予想されます。長寿命のアクセストークンの場合、dhe cipherスイートを使用する必要があります。つまり、tls_dhe_psk_*またはtls_ecdhe_psk_*のフォームの暗号スイートを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Constrained devices that use DTLS [RFC6347] [RFC9147] are inherently vulnerable to Denial of Service (DoS) attacks, as the handshake protocol requires creation of internal state within the device. This is specifically of concern where an adversary is able to intercept the initial cookie exchange and interject forged messages with a valid cookie to continue with the handshake. A similar issue exists with the unprotected authorization information endpoint when the resource server needs to keep valid access tokens for a long time. Adversaries could fill up the constrained resource server&#39;s internal storage for a very long time with intercepted or otherwise retrieved valid access tokens. To mitigate against this, the resource server should set a time boundary until an access token that has not been used until then will be deleted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DTLS [RFC6347] [RFC9147]を使用する制約付きデバイスは、ハンドシェイクプロトコルにはデバイス内の内部状態の作成が必要なため、サービス拒否（DOS）攻撃に対して本質的に脆弱です。これは、敵が最初のCookie Exchangeを傍受し、有効なCookieを介して介入した鍛造メッセージを握手し続けることができる場合、特に懸念事項です。リソースサーバーが有効なアクセストークンを長時間維持する必要がある場合、保護されていない承認情報エンドポイントにも同様の問題が存在します。敵は、傍受された、またはその他の方法で取得された有効なアクセストークンで、制約付きリソースサーバーの内部ストレージを非常に長い間埋めることができます。これに反対するために、リソースサーバーは、それまで使用されていないアクセストークンが削除されるまで、時間境界を設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protection of access tokens that are stored in the authorization information endpoint depends on the keying material that is used between the authorization server and the resource server; the resource server must ensure that it processes only access tokens that are integrity protected (and encrypted) by an authorization server that is authorized to provide access tokens for the resource server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Authorization Information Endpointに保存されているアクセストークンの保護は、Authorization ServerとResource Serverの間で使用されるキーイング素材に依存します。リソースサーバーは、リソースサーバーにアクセストークンを提供する許可された認定サーバーによって、整合性保護（および暗号化された）のアクセストークンのみを処理することを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-1--Reuse-of-Existing-Sessions">
7.1. Reuse of Existing Sessions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 既存のセッションの再利用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid the overhead of a repeated DTLS handshake, [RFC7925] recommends session resumption [RFC8446] to reuse session state from an earlier DTLS association and thus requires client-side implementation. In this specification, the DTLS session is subject to the authorization rules denoted by the access token that was used for the initial setup of the DTLS association. Enabling session resumption would require the server to transfer the authorization information with the session state in an encrypted SessionTicket to the client. Assuming that the server uses long-lived keying material, this could open up attacks due to the lack of forward secrecy. Moreover, using this mechanism, a client can resume a DTLS session without proving the possession of the PoP key again. Therefore, session resumption should be used only in combination with reasonably short-lived PoP keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
繰り返されるDTLSハンドシェイクのオーバーヘッドを回避するために、[RFC7925]は、セッション再開[RFC8446]を以前のDTLS協会からセッション状態を再利用することを推奨しているため、クライアント側の実装が必要です。この仕様では、DTLSセッションは、DTLS協会の初期セットアップに使用されたアクセストークンによって示される承認ルールの対象となります。セッション再開を有効にすると、サーバーは、暗号化されたセッションチケットでセッション状態を持つ許可情報をクライアントに転送する必要があります。サーバーが長寿命のキーイング素材を使用していると仮定すると、これは将来の秘密がないために攻撃を開く可能性があります。さらに、このメカニズムを使用して、クライアントはPOPキーの所有を再び証明することなくDTLSセッションを再開できます。したがって、セッション再開は、合理的に短命のポップキーと組み合わせてのみ使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since renegotiation of DTLS associations is prone to attacks as well, [RFC7925] requires that clients decline any renegotiation attempt. A server that wants to initiate rekeying therefore SHOULD periodically force a full handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DTLS関連の再交渉も攻撃を受ける傾向があるため、[RFC7925]では、クライアントが再交渉の試みを拒否する必要があります。したがって、再キーイングを開始したいサーバーは、定期的に完全な握手を強制する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-2--Multiple-Access-Tokens">
7.2. Multiple Access Tokens
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. 複数のアクセストークン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementers SHOULD avoid using multiple access tokens for a client (see also Section 5.10.1 of [RFC9200]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装者は、クライアントに複数のアクセストークンの使用を避ける必要があります（[RFC9200]のセクション5.10.1も参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even when a single access token per client is used, an attacker could compromise the dynamic update mechanism for existing DTLS connections by delaying or reordering packets destined for the authz-info endpoint. Thus, the order in which operations occur at the resource server (and thus which authorization info is used to process a given client request) cannot be guaranteed. Especially in the presence of later-issued access tokens that reduce the client&#39;s permissions from the initial access token, it is impossible to guarantee that the reduction in authorization will take effect prior to the expiration of the original token.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントごとに1つのアクセストークンを使用している場合でも、攻撃者は、authz-infoエンドポイントに向けたパケットを遅延または並べ替えることにより、既存のDTLS接続の動的更新メカニズムを損なう可能性があります。したがって、リソースサーバーで操作が発生する順序（したがって、特定のクライアント要求の処理に使用される許可情報）は保証できません。特に、最初のアクセストークンからクライアントの許可を減らす後期に発行されたアクセストークンが存在する場合、元のトークンの満了前に承認の減少が有効になることを保証することは不可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-3--Out-of-Band-Configuration">
7.3. Out-of-Band Configuration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. バンド外構成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To communicate securely, the authorization server, the client, and the resource server require certain information that must be exchanged outside the protocol flow described in this document. The authorization server must have obtained authorization information concerning the client and the resource server that is approved by the resource owner, as well as corresponding keying material. The resource server must have received authorization information approved by the resource owner concerning its authorization managers and the respective keying material. The client must have obtained authorization information concerning the authorization server approved by its owner, as well as the corresponding keying material. Also, the client&#39;s owner must have approved of the client&#39;s communication with the resource server. The client and the authorization server must have obtained a common understanding about how this resource server is identified to ensure that the client obtains access tokens and keying material for the correct resource server. If the client is provided with a raw public key for the resource server, it must be ascertained to which resource server (which identifier and authorization information) the key is associated. All authorization information and keying material must be kept up to date.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安全に通信するには、認証サーバー、クライアント、およびリソースサーバーに、このドキュメントで説明されているプロトコルフローの外で交換する必要がある特定の情報が必要です。承認サーバーは、リソース所有者によって承認されたクライアントとリソースサーバー、ならびに対応するキーイングマテリアルに関する承認情報を取得している必要があります。リソースサーバーは、その認可マネージャーとそれぞれのキーイング資料に関して、リソース所有者によって承認された承認情報を受け取っている必要があります。クライアントは、所有者によって承認された承認サーバーと、対応するキーイング資料に関する承認情報を取得している必要があります。また、クライアントの所有者は、クライアントとリソースサーバーとの通信を承認している必要があります。クライアントと承認サーバーは、クライアントが正しいリソースサーバーのアクセストークンとキーイング素材を取得することを保証するために、このリソースサーバーがどのように識別されるかについての共通の理解を取得している必要があります。クライアントにリソースサーバーの生の公開キーが提供されている場合、キーが関連付けられているリソースサーバー（識別子と承認情報）を確認する必要があります。すべての承認情報とキーイング資料は最新の状態に保つ必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--Privacy-Considerations">
8. Privacy Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. プライバシーに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This privacy considerations from Section 7 of [RFC9200] apply also to this profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9200]のセクション7からのこのプライバシーに関する考慮事項は、このプロファイルにも適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An unprotected response to an unauthorized request may disclose information about the resource server and/or its existing relationship with the client. It is advisable to include as little information as possible in an unencrypted response. When a DTLS session between an authenticated client and the resource server already exists, more detailed information MAY be included with an error response to provide the client with sufficient information to react on that particular error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
許可されていないリクエストに対する保護されていない応答は、リソースサーバーおよび/またはクライアントとの既存の関係に関する情報を開示する場合があります。暗号化されていない応答にできるだけ少ない情報を含めることをお勧めします。認証されたクライアントとリソースサーバーの間のDTLSセッションがすでに存在する場合、より詳細な情報をエラー応答に含めて、その特定のエラーに反応するのに十分な情報をクライアントに提供することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Also, unprotected requests to the resource server may reveal information about the client, e.g., which resources the client attempts to request or the data that the client wants to provide to the resource server. The client SHOULD NOT send confidential data in an unprotected request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、リソースサーバーへの保護されていないリクエストは、クライアント、たとえばクライアントが要求しようとするリソースまたはクライアントがリソースサーバーに提供したいデータについての情報を明らかにする場合があります。クライアントは、保護されていないリクエストで機密データを送信しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that some information might still leak after the DTLS session is established, due to observable message sizes, the source, and the destination addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
観察可能なメッセージサイズ、ソース、および宛先アドレスのために、DTLSセッションが確立された後もまだいくつかの情報が漏れている可能性があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--IANA-Considerations">
9. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following registration has been made in the &#34;ACE Profiles&#34; registry, following the procedure specified in [RFC9200].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9200]で指定された手順に従って、「ACEプロファイル」レジストリで次の登録が行われました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Name: coap_dtls Description: Profile for delegating client Authentication and Authorization for Constrained Environments by establishing a Datagram Transport Layer Security (DTLS) channel between resource-constrained nodes. CBOR Value: 1 Reference: RFC 9202
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前：COAP_DTLS説明：リソースに制約されたノード間でデータグラムトランスポートレイヤーセキュリティ（DTLS）チャネルを確立することにより、制約された環境のクライアント認証と承認を委任するプロファイル。CBOR値：1リファレンス：RFC 9202
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10--References">
10. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-1--Normative-References">
10.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;https://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487/RFC2119、1997年3月、&lt;https://www.rfc-editor.org/info/RFC2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4279] Eronen, P., Ed. and H. Tschofenig, Ed., &#34;Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)&#34;, RFC 4279, DOI 10.17487/RFC4279, December 2005, &lt;https://www.rfc-editor.org/info/rfc4279&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4279] Eronen、P.、ed。およびH. Tschofenig編、「輸送層のセキュリティ（TLS）のための事前共有キーヒルスーツ」、RFC 4279、DOI 10.17487/RFC4279、2005年12月、&lt;https://www.rfc-editor.org/info/RFC42799&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6347] Rescorla, E. and N. Modadugu, &#34;Datagram Transport Layer Security Version 1.2&#34;, RFC 6347, DOI 10.17487/RFC6347, January 2012, &lt;https://www.rfc-editor.org/info/rfc6347&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6347] Rescorla、E。およびN. Modadugu、「データグラムトランスポートレイヤーセキュリティバージョン1.2」、RFC 6347、DOI 10.17487/RFC6347、2012年1月、&lt;https://www.rfc-editor.org/info/rfc6347&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6749] Hardt, D., Ed., &#34;The OAuth 2.0 Authorization Framework&#34;, RFC 6749, DOI 10.17487/RFC6749, October 2012, &lt;https://www.rfc-editor.org/info/rfc6749&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6749] Hardt、D.、ed。、「The Oauth 2.0 Authorization Framework」、RFC 6749、DOI 10.17487/RFC6749、2012年10月、&lt;https://www.rfc-editor.org/info/rfc6749&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7250] Wouters, P., Ed., Tschofenig, H., Ed., Gilmore, J., Weiler, S., and T. Kivinen, &#34;Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)&#34;, RFC 7250, DOI 10.17487/RFC7250, June 2014, &lt;https://www.rfc-editor.org/info/rfc7250&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7250] Wouters、P.、ed。、Tschofenig、H.、Ed。、Gilmore、J.、Weiler、S.、およびT. Kivinen、「TLAPERIER LAYER SECURET（TLS）およびDatagram Transport Layerの生の公共キーを使用するSecurity（DTLS） &#34;、RFC 7250、DOI 10.17487/RFC7250、2014年6月、&lt;https://www.rfc-editor.org/info/rfc7250&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7251] McGrew, D., Bailey, D., Campagna, M., and R. Dugal, &#34;AES-CCM Elliptic Curve Cryptography (ECC) Cipher Suites for TLS&#34;, RFC 7251, DOI 10.17487/RFC7251, June 2014, &lt;https://www.rfc-editor.org/info/rfc7251&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7251] McGrew、D.、Bailey、D.、Campagna、M。、およびR. Dugal、「AES-CCM楕円曲線暗号化（ECC）TLSの暗号スイート」、RFC 7251、DOI 10.17487/RFC7251、2014年6月、&lt;https://www.rfc-editor.org/info/rfc7251&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7252] Shelby, Z., Hartke, K., and C. Bormann, &#34;The Constrained Application Protocol (CoAP)&#34;, RFC 7252, DOI 10.17487/RFC7252, June 2014, &lt;https://www.rfc-editor.org/info/rfc7252&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7252] Shelby、Z.、Hartke、K。、およびC. Bormann、「制約付きアプリケーションプロトコル（COAP）」、RFC 7252、DOI 10.17487/RFC7252、2014年6月、&lt;https：//www.rfc-editor。org/info/rfc7252&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7925] Tschofenig, H., Ed. and T. Fossati, &#34;Transport Layer Security (TLS) / Datagram Transport Layer Security (DTLS) Profiles for the Internet of Things&#34;, RFC 7925, DOI 10.17487/RFC7925, July 2016, &lt;https://www.rfc-editor.org/info/rfc7925&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7925] Tschofenig、H.、ed。T. Fossati、「モノのインターネットの輸送層セキュリティ（TLS）/データグラムトランスポートレイヤーセキュリティ（DTLS）プロファイル」、RFC 7925、DOI 10.17487/RFC7925、2016年7月、&lt;https：//www.rfc-editor。org/info/rfc7925&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8152] Schaad, J., &#34;CBOR Object Signing and Encryption (COSE)&#34;, RFC 8152, DOI 10.17487/RFC8152, July 2017, &lt;https://www.rfc-editor.org/info/rfc8152&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8152] Schaad、J。、「Cborオブジェクトの署名と暗号化（COSE）」、RFC 8152、DOI 10.17487/RFC8152、2017年7月、&lt;https://www.rfc-editor.org/info/rfc8152&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba, B., &#34;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&#34;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487/RFC8174、2017年5月、&lt;https：//www.rfc-editor.org/info/RFC8174&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8392] Jones, M., Wahlstroem, E., Erdtman, S., and H. Tschofenig, &#34;CBOR Web Token (CWT)&#34;, RFC 8392, DOI 10.17487/RFC8392, May 2018, &lt;https://www.rfc-editor.org/info/rfc8392&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8392] Jones、M.、Wahlstroem、E.、Erdtman、S.、およびH. Tschofenig、「Cbor Web Token（CWT）」、RFC 8392、DOI 10.17487/RFC8392、2018年5月、&lt;https：// www。rfc-editor.org/info/rfc8392&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8422] Nir, Y., Josefsson, S., and M. Pegourie-Gonnard, &#34;Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier&#34;, RFC 8422, DOI 10.17487/RFC8422, August 2018, &lt;https://www.rfc-editor.org/info/rfc8422&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8422] Nir、Y.、Josefsson、S。、およびM. Pegourie-Gonnard、「輸送層セキュリティ（TLS）バージョン（TLS）バージョン用の楕円曲線暗号化（ECC）暗号スイート」、RFC 8422、DOI 10.17487/RFC8422、2018年8月、&lt;https://www.rfc-editor.org/info/rfc8422&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8747] Jones, M., Seitz, L., Selander, G., Erdtman, S., and H. Tschofenig, &#34;Proof-of-Possession Key Semantics for CBOR Web Tokens (CWTs)&#34;, RFC 8747, DOI 10.17487/RFC8747, March 2020, &lt;https://www.rfc-editor.org/info/rfc8747&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8747] Jones、M.、Seitz、L.、Selander、G.、Erdtman、S。、およびH. Tschofenig、「Cbor Web Tokens（CWTS）のプルーフオブポッセッションキーセマンティクス」、RFC 8747、DOI 10.17487/RFC8747、2020年3月、&lt;https://www.rfc-editor.org/info/rfc8747&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8949] Bormann, C. and P. Hoffman, &#34;Concise Binary Object Representation (CBOR)&#34;, STD 94, RFC 8949, DOI 10.17487/RFC8949, December 2020, &lt;https://www.rfc-editor.org/info/rfc8949&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8949] Bormann、C。and P. Hoffman、「Concise binary Object Lepressation（CBOR）」、STD 94、RFC 8949、DOI 10.17487/RFC8949、2020年12月、&lt;https://www.rfc-editor.org/info/RFC8949&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9147] Rescorla, E., Tschofenig, H., and N. Modadugu, &#34;The Datagram Transport Layer Security (DTLS) Protocol Version 1.3&#34;, RFC 9147, DOI 10.17487/RFC9147, April 2022, &lt;https://www.rfc-editor.org/info/rfc9147&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9147] Rescorla、E.、Tschofenig、H。、およびN. Modadugu、「データグラム輸送層セキュリティ（DTLS）プロトコルバージョン1.3」、RFC 9147、DOI 10.17487/RFC9147、2022年4月、&lt;https：// www。rfc-editor.org/info/rfc9147&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9200] Seitz, L., Selander, G., Wahlstroem, E., Erdtman, S., and H. Tschofenig, &#34;Authentication and Authorization for Constrained Environments (ACE) Using the OAuth 2.0 Framework (ACE-OAuth)&#34;, RFC 9200, DOI 10.17487/RFC9200, August 2022, &lt;https://www.rfc-editor.org/info/rfc9200&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9200] Seitz、L.、Selander、G.、Wahlstroem、E.、Erdtman、S.、およびH. Tschofenig、「OAUTH 2.0フレームワーク（ACE-OAUTH）を使用した制約環境（ACE）の認証と認証（ACE-OAuth）」RFC 9200、DOI 10.17487/RFC9200、2022年8月、&lt;https://www.rfc-editor.org/info/rfc9200&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9201] Seitz, L., &#34;Additional OAuth Parameters for Authentication and Authorization for Constrained Environments (ACE)&#34;, RFC 9201, DOI 10.17487/RFC9201, August 2022, &lt;https://www.rfc-editor.org/info/rfc9201&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9201] Seitz、L。、「制約環境の認証と認証のための追加のOAuthパラメーター（ACE）」、RFC 9201、DOI 10.17487/RFC9201、2022年&lt;https://www.rfc-editor.org/info/RFC9201&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-2--Informative-References">
10.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5869] Krawczyk, H. and P. Eronen, &#34;HMAC-based Extract-and-Expand Key Derivation Function (HKDF)&#34;, RFC 5869, DOI 10.17487/RFC5869, May 2010, &lt;https://www.rfc-editor.org/info/rfc5869&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5869] Krawczyk、H。およびP. Eronen、「HMACベースの抽出および拡張キー誘導関数（HKDF）」、RFC 5869、DOI 10.17487/RFC5869、2010年5月、&lt;https：//ww.rfc-editor.org/info/rfc5869&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6655] McGrew, D. and D. Bailey, &#34;AES-CCM Cipher Suites for Transport Layer Security (TLS)&#34;, RFC 6655, DOI 10.17487/RFC6655, July 2012, &lt;https://www.rfc-editor.org/info/rfc6655&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6655] McGrew、D。およびD. Bailey、「輸送層のセキュリティ用AES-CCM暗号スイート（TLS）」、RFC 6655、DOI 10.17487/RFC6655、2012年7月、&lt;https：//www.rfc-editor.org/info/rfc6655&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7662] Richer, J., Ed., &#34;OAuth 2.0 Token Introspection&#34;, RFC 7662, DOI 10.17487/RFC7662, October 2015, &lt;https://www.rfc-editor.org/info/rfc7662&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7662] Richer、J.、ed。、「Oauth 2.0トークン内省」、RFC 7662、DOI 10.17487/RFC7662、2015年10月、&lt;https://www.rfc-editor.org/info/rfc762&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7748] Langley, A., Hamburg, M., and S. Turner, &#34;Elliptic Curves for Security&#34;, RFC 7748, DOI 10.17487/RFC7748, January 2016, &lt;https://www.rfc-editor.org/info/rfc7748&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7748] Langley、A.、Hamburg、M。、およびS. Turner、「セキュリティのための楕円曲線」、RFC 7748、DOI 10.17487/RFC7748、2016年1月、&lt;https://www.rfc-editor.org/info/RFC7748&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8032] Josefsson, S. and I. Liusvaara, &#34;Edwards-Curve Digital Signature Algorithm (EdDSA)&#34;, RFC 8032, DOI 10.17487/RFC8032, January 2017, &lt;https://www.rfc-editor.org/info/rfc8032&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8032] Josefsson、S。およびI. Liusvaara、「Edwards-Curve Digital Signature Algorithm（EDDSA）」、RFC 8032、DOI 10.17487/RFC8032、2017年1月、&lt;https：//www.rfc-editor.org/info//RFC8032&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8446] Rescorla, E., &#34;The Transport Layer Security (TLS) Protocol Version 1.3&#34;, RFC 8446, DOI 10.17487/RFC8446, August 2018, &lt;https://www.rfc-editor.org/info/rfc8446&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8446] Rescorla、E。、「輸送層セキュリティ（TLS）プロトコルバージョン1.3」、RFC 8446、DOI 10.17487/RFC8446、2018年8月、&lt;https://www.rfc-editor.org/info/rfc846&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8610] Birkholz, H., Vigano, C., and C. Bormann, &#34;Concise Data Definition Language (CDDL): A Notational Convention to Express Concise Binary Object Representation (CBOR) and JSON Data Structures&#34;, RFC 8610, DOI 10.17487/RFC8610, June 2019, &lt;https://www.rfc-editor.org/info/rfc8610&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8610] Birkholz、H.、Vigano、C。、およびC. Bormann、「Scise Data Definition Language（CDDL）：簡潔なバイナリオブジェクト表現（CBOR）およびJSONデータ構造を表現する表記規則」、RFC 8610、DOI 10.17487/RFC8610、2019年6月、&lt;https://www.rfc-editor.org/info/rfc8610&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Special thanks to Jim Schaad for his contributions and reviews of this document and to Ben Kaduk for his thorough reviews of this document. Thanks also to Paul Kyzivat for his review. The authors also would like to thank Marco Tiloca for his contributions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書の貢献とレビュー、およびこの文書の徹底的なレビューについては、ベン・カドゥクに感謝します。彼のレビューをしてくれたPaul Kyzivatにも感謝します。著者はまた、彼の貢献についてマルコ・ティロカに感謝したいと思います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ludwig Seitz worked on this document as part of the CelticNext projects CyberWI and CRITISEC with funding from Vinnova.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ludwig Seitzは、CelticNext Projectの一部として、CyberwiとCritisecのヴィノバからの資金提供でこの文書に取り組みました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stefanie Gerdes Universität Bremen TZI Postfach 330440 D-28359 Bremen Germany Phone: +49-421-218-63906 Email: gerdes@tzi.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stefanie GerdesUniversitätBremenTziPostfach 330440 D-28359 Bremen Germany電話：49-421-218-63906メール：gerdes@tzi.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Olaf Bergmann Universität Bremen TZI Postfach 330440 D-28359 Bremen Germany Phone: +49-421-218-63904 Email: bergmann@tzi.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Olaf BergmannUniversitätBremenTziPostfach 330440 D-28359 Bremen Germany電話：49-421-218-63904メール：bergmann@tzi.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Carsten Bormann Universität Bremen TZI Postfach 330440 D-28359 Bremen Germany Phone: +49-421-218-63921 Email: cabo@tzi.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Carsten BormannUniversitätBremenTziPostfach 330440 D-28359 Bremen Germany電話：49-421-218-63921メール：cabo@tzi.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Göran Selander Ericsson AB Email: goran.selander@ericsson.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GöranSelanderEricsson ABメール：goran.selander@ericsson.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ludwig Seitz Combitech Djäknegatan 31 SE-211 35 Malmö Sweden Email: ludwig.seitz@combitech.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ludwig Seitz CombitechDjäknegatan31 SE-211 35MalmöSwedenメール：ludwig.seitz@combitech.com
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
