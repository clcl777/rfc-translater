<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 3072 - Structured Data Exchange Format (SDXF) 日本語訳</title>
  <meta name="description" content="RFC 3072は、Structured Data Exchange Format（SDXF）の仕様を定義しており、データの構造化された交換を目的としています。SDXFは、データの表現と転送を効率化し、相互運用性を向上させるためのフォーマットです。">
  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="./master.css">
  <script src="./index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">3072</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc3072">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 3072 - Structured Data Exchange Format (SDXF) 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc3072">
            https://datatracker.ietf.org/doc/html/rfc3072
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 3072 - 構造化されたデータ交換形式（SDXF）</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <p class="card-text">[要約] RFC 3072は、Structured Data Exchange Format（SDXF）の仕様を定義しており、データの構造化された交換を目的としています。SDXFは、データの表現と転送を効率化し、相互運用性を向上させるためのフォーマットです。</p>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                       M. Wildgrube
Request for Comments: 3072                                    March 2001
Category: Informational
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
Structured Data Exchange Format (SDXF)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
構造化されたデータ交換形式（SDXF）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、インターネットコミュニティに情報を提供します。いかなる種類のインターネット標準を指定しません。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2001). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）The Internet Society（2001）。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
IESG Note
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
IESGノート
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies a data exchange format and, partially, an API that can be used for creating and parsing such a format. The IESG notes that the same problem space can be addressed using formats that the IETF normally uses including ASN.1 and XML. The document reader is strongly encouraged to carefully read section 13 before choosing SDXF over ASN.1 or XML. Further, when storing text in SDXF, the user is encourage to use the datatype for UTF-8, specified in section 2.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、データ交換形式と、そのような形式の作成と解析に使用できるAPIを部分的に指定します。IESGは、IETFがASN.1やXMLを含む通常使用する形式を使用して、同じ問題空間に対処できることを指摘しています。ドキュメントリーダーは、ASN.1またはXMLよりもSDXFを選択する前に、セクション13を注意深く読むことを強くお勧めします。さらに、テキストをSDXFに保存する場合、ユーザーはセクション2.5で指定されたUTF-8にデータ型を使用することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification describes an all-purpose interchange format for use as a file format or for net-working. Data is organized in chunks which can be ordered in hierarchical structures. This format is self-describing and CPU-independent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様では、ファイル形式またはネットワーキングに使用するための汎用インターチェンジ形式について説明します。データは、階層構造で注文できるチャンクで編成されています。この形式は、自己記述的であり、CPUに依存しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction ................................................. 2
   2.  Description of the SDXF data format .......................... 3
   3.  Introduction to the SDXF functions ........................... 5
   3.1 General remarks .............................................. 5
   3.2 Writing a SDXF buffer ........................................ 5
   3.3 Reading a SDXF buffer ........................................ 6
   3.4 Example ...................................................... 6
   4.  Platform independence ........................................ 8
   5.  Compression .................................................. 9
   6.  Encryption ...................................................11
   7.  Arrays........................................................11
   8.  Description of the SDXF functions ............................12
      8.1 Introduction .................................................12
   8.2 Basic definitions ............................................13
   8.3 Definitions for C++ ..........................................15
   8.4 Common Definitions ...........................................16
   8.5 Special functions ............................................17
   9.  &#39;Support&#39; of UTF-8 ...........................................19
   10.  Security Considerations .....................................19
   11.  Some general hints ..........................................20
   12.  IANA Considerations .........................................20
   13.  Discussion ..................................................21
   13.1 SDXF vs. ASN.1 ..............................................21
   13.2 SDXF vs. XML ................................................22
   14.  Author&#39;s Address ............................................24
   15.  Acknowledgements ............................................24
   16.  References ..................................................24
   17.  Full Copyright Statement ....................................26
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The purpose of the Structured Data eXchange Format (SDXF) is to permit the interchange of an arbitrary structured data block with different kinds of data (numerical, text, bitstrings). Because data is normalized to an abstract computer architecture independent &#34;network format&#34;, SDXF is usable as a network interchange data format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構造化されたデータ交換形式（SDXF）の目的は、異なる種類のデータ（数値、テキスト、ビットストリング）を持つ任意の構造化データブロックの交換を許可することです。データは抽象的なコンピューターアーキテクチャに依存しない「ネットワーク形式」に正規化されるため、SDXFはネットワークインターチェンジデータ形式として使用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This data format is not limited to any application, the demand for this format is that it is usable as a text format for word-processing, as a picture format, a sound format, for remote procedure calls with complex parameters, suitable for document formats, for interchanging business data, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このデータ形式はアプリケーションに限定されません。この形式の需要は、文書形式に適した複雑なパラメーターを使用したリモート手順呼び出しの画像形式、サウンド形式として、ワードプロセスのテキスト形式として使用可能であることです。、交換するビジネスデータなど。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXF is self-describing, every program can unpack every SDXF-data without knowing the meaning of the individual data elements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXFは自己記述的であり、すべてのプログラムは、個々のデータ要素の意味を知らずにすべてのSDXF-DATAを開梱できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Together with the description of the data format a set of functions will be introduced. With the help of these functions one can create and access the data elements of SDXF. The idea is that a programmer should only use these functions instead of maintaining the structure by himself on the level of bits and bytes. (In the speech of object-oriented programming these functions are methods of an object which works as a handle for a given SDXF data block.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ形式の説明とともに、一連の関数が導入されます。これらの機能の助けを借りて、SDXFのデータ要素を作成およびアクセスできます。アイデアは、プログラマーは、ビットとバイトのレベルで自分で構造を維持するのではなく、これらの関数のみを使用する必要があるということです。（オブジェクト指向プログラミングのスピーチでは、これらの関数は、特定のSDXFデータブロックのハンドルとして機能するオブジェクトの方法です。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXF is not limited to a specific platform, along with a correct preparation of the SDXF functions the SDXF data can be interchanged (via network or data carrier) across the boundaries of different architectures (specified by the character code like ASCII, ANSI or EBCDIC and the byte order for binary data).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXFは特定のプラットフォームに限定されません。SDXF関数の正しい準備とともに、SDXFデータは（ネットワークまたはデータキャリアを介して）異なるアーキテクチャの境界を越えて交換できます（ASCII、ANSI、EBCDICなどの文字コードで指定されています。バイナリデータのバイト順序）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXF is also prepared to compress and encrypt parts or the whole block of SDXF data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXFは、部品またはSDXFデータのブロック全体を圧縮および暗号化する準備もできています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2. Description of SDXF data format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2. SDXFデータ形式の説明。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.1 First we introduce the term &#34;chunk&#34;. A chunk is a data structure with a fixed set of components. A chunk may be &#34;elementary&#34; or &#34;structured&#34;. The latter one contains itself one or more other chunks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.1 最初に「チャンク」という用語を紹介します。チャンクは、コンポーネントの固定セットを備えたデータ構造です。チャンクは、「小学校」または「構造化」される場合があります。後者には、1つ以上の他のチャンクが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A chunk consists of a header and the data body (content):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンクは、ヘッダーとデータ本体（コンテンツ）で構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +----------+-----+-------+-----------------------------------+
   | Name     | Pos.| Length| Description                       |
   +----------+-----+-------+-----------------------------------+
   | chunk-ID |  1  |   2   | ID of the chunk (unsigned short)  |
   | flags    |  3  |   1   | type and properties of this chunk |
   | length   |  4  |   3   | length  of the following data     |
   | content  |  7  |   *)  | net data or a list of of chunks   |
   +----------+-----+-------+-----------------------------------+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(* as stated in &#34;length&#34;. total length of chunk is length+6. The chunk ID is a non-zero positive number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（*「長さ」で述べられているように。チャンクの全長は長さ6です。チャンクIDはゼロ以外の正の数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
or more visually:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
またはより視覚的に：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +----+----+----+----+----+----+----+----+----+-...
   | chunkID | fl | length       |  content
   +----+----+----+----+----+----+----+----+----+-...
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
or in ASN.1 syntax:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
またはasn.1構文：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   chunk  ::=  SEQUENCE
   {
     chunkID INTEGER (1..65535),
     flags   BIT STRING,
     length  OCTET STRING SIZE 3, -- or: INTEGER (0..16777215)
     content OCTET STRING
   }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.2 Structured chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.2 構造化されたチャンク。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A structured chunk is marked as such by the flag byte (see 2.5). Opposed to an elementary chunk its content consists of a list of chunks (elementary or structured):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構造化されたチャンクは、フラグバイトによってそのようにマークされます（2.5を参照）。小学校とは対照的に、そのコンテンツはチャンクのリスト（小学校または構造化）で構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +----+-+---+-------+-------+-------+-----+-------+
   | id |f|len| chunk | chunk | chunk | ... | chunk |
   +----+-+---+-------+-------+-------+-----+-------+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the help of this concept you can reproduce every hierarchically structured data into a SDXF chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この概念の助けを借りて、すべての階層的に構造化されたデータをSDXFチャンクに再現できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.3 Some Remarks about the internal representation of the chunk&#39;s elements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.3 チャンクの要素の内部表現に関するいくつかの発言：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Binary values are always in high-order-first (big endian) format, like the binary values in the IP header (network format). A length of 300 (=256 + 32 + 12) is stored as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイナリ値は、IPヘッダー（ネットワーク形式）のバイナリ値と同様に、常に高次（ビッグエンディアン）形式です。300の長さ（= 256 32 12）が保存されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +----+----+----+----+----+----+----+----+----+--
   |         |    | 00   01   2C |  content
   +----+----+----+----+----+----+----+----+----+--
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
in hexadecimal notation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
16進表で。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is also valid for the chunk-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、Chunk-IDにも有効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.4 Character values in the content portion are also an object of adaptation: see chapter 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.4 コンテンツ部分の文字値は、適応のオブジェクトでもあります。第4章を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.5 Meaning of the flag-bits: Let us represent the flag byte in this manner:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.5 フラッグビットの意味：この方法でフラグバイトを表してみましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     +-+-+-+-+-+-+-+-+
     |0|1|2|3|4|5|6|7|
     +-+-+-+-+-+-+-+-+
      | | | | | | | |
      | | | | | | | +-- reserved
      | | | | | | +---- array
      | | | | | +------ short chunk
      | | | | +-------- encrypted chunk
      | | | +---------- compressed chunk
      | | |
      +-+-+------------ data type (0..7)
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
data types are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ型は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0 -- pending structure (chunk is inconsistent, see also 11.1) 1 -- structure 2 -- bit string 3 -- numeric 4 -- character 5 -- float (ANSI/IEEE 754-1985) 6 -- UTF-8 7 -- reserved
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0-保留構造（チャンクは一貫性がない、11.1も参照）1-構造2-ビット文字列3-数値4-文字5-フロート（ANSI/IEEE 754-1985）6-UTF-8 7 -  予約済み
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.6 A short chunk has no data body. The 3 byte Length field is used as data bytes instead. This is used in order to save space when there are many small chunks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.6 短いチャンクにはデータ本文がありません。3バイトの長さフィールドは、代わりにデータバイトとして使用されます。これは、多くの小さなチャンクがあるときにスペースを節約するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.7 Compressed and encrypted chunks are explained in chapter 5 and 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.7 圧縮および暗号化されたチャンクについては、第5章と6章で説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.8 Arrays are explained in chapter 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.8 アレイについては、第7章で説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.9 Handling of UTF-8 is explained in chapter 9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.9 UTF-8の処理については、第9章で説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.10 Not all combinations of bits are allowed or reasonable:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.10 すべてのビットの組み合わせが許可されていないわけでも、合理的ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- the flags &#39;array&#39; and &#39;short&#39; are mutually exclusive. - &#39;short&#39; is not applicable for data type &#39;structure&#39; and &#39;float&#39;. - &#39;array&#39; is not applicable for data type &#39;structure&#39;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- フラグの「配列」と「短い」は相互に排他的です。 - 「ショート」は、データ型「構造」と「フロート」には適用されません。 - 「配列」は、データ型「構造」には適用されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Introduction-to-the-SDXF-functions">
3. Introduction to the SDXF functions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. SDXF関数の紹介
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1-General-remarks">
3.1 General remarks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1 一般的な発言
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The functionality of the SDXF concept is not bounded to any programming language, but of course the functions themselves must be coded in a particular language. I discuss these functions in C and C++, because in the meanwhile these languages are available on almost all platforms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXFコンセプトの機能はプログラミング言語に限定されていませんが、もちろん機能自体は特定の言語でコード化する必要があります。一方、これらの言語はほぼすべてのプラットフォームで利用できるため、これらの機能についてはCとCで説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All these functions for reading and writing SDXF chunks uses only one parameter, a parameter structure. In C++ this parameter structure is part of the &#34;SDXF class&#34; and the SDXF functions are methods of this class.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXFチャンクを読み書きするためのこれらの機能はすべて、パラメーター構造であるパラメーター1つのパラメーターのみを使用します。Cでは、このパラメーター構造は「SDXFクラス」の一部であり、SDXF関数はこのクラスの方法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An exact description of the interface is given in chapter 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インターフェイスの正確な説明は、第8章に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-Writing-a-SDXF-buffer">
3.2 Writing a SDXF buffer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2 SDXFバッファーの書き込み
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For to write SDXF chunks, there are following functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXFチャンクを書くために、次の機能があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
init -- initialize the parameter structure create -- create a new chunk leave -- &#34;close&#34; a structured chunk
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
init-パラメーター構造の初期化作成 - 新しいチャンク休暇を作成 - 構造化されたチャンクを「閉じる」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-Reading-a-SDXF-buffer">
3.3 Reading a SDXF buffer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3 SDXFバッファーの読み取り
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For to read SDXF chunks, there are following functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXFチャンクを読むために、次の機能があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
init -- initialize the parameter structure enter -- &#34;go into&#34; a structured chunk next -- &#34;go to&#34; the next chunk inside a structured chunk extract -- extract the content of an elementary chunk into user&#39;s data area leave -- &#34;go out&#34; off a structured chunk
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
init-パラメーター構造の初期化ENTERの入力 - 「進む」構造化されたチャンクNext-」に移動します。構造化されたチャンクから出て
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
3.4 Example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
3.4 例：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
3.4.1 Writing:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
3.4.1 書き込み：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For demonstration we use a reduced (outlined) C++ Form of these functions with polymorph definitions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デモンストレーションには、これらの関数の縮小（概要）c形式をポリモーフ定義を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void create (short chunkID); // opens a new structure, void create (short chunkID, char *string); // creates a new chunk with dataType character, etc.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void create（short chunkid）;//新しい構造を開き、void create（short chunkid、char *string）;// datatype文字などで新しいチャンクを作成します）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sequence:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンス：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   SDXF x(new); // create the SDXF object &#34;x&#34; for a new chunk
                // includes the &#34;init&#34;
   x.create (3301);   // opens a new structure
   x.create (3302, &#34;first chunk&#34;);
   x.create (3303, &#34;second chunk&#34;);
   x.create (3304);   // opens a new structure
   x.create (3305, &#34;chunk in a structure&#34;);
   x.create (3306, &#34;next chunk in a structure&#34;);
   x.leave ();        // closes the inner structure
   x.create (3307, &#34;third chunk&#34;);
   x.leave ();        // closes the outer structure
      creates a chunk which we can show graphically like:
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   3301
    |
    +--- 3302 = &#34;first chunk&#34;
    |
    +--- 3303 = &#34;second chunk&#34;
    |
    +--- 3304
    |      |
    |      +--- 3305 = &#34;chunk in a structure&#34;
    |      |
    |      +--- 3306 = &#34;next chunk in a structure&#34;
    |
    +--- 3307 = &#34;last chunk&#34;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-4-2-Reading">
3.4.2 Reading
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.2 読む
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A typically access to a structured SDXF chunk is a selection inside a loop:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、構造化されたSDXFチャンクへのアクセスは、ループ内の選択です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   SDXF x(old); // defines a SDXF object &#34;x&#34; for an old chunk
   x.enter ();  // enters the structure
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   while (x.rc == 0) // 0 == ok, rc will set by the SDXF functions
   {
     switch (x.chunkID)
     {
       case 3302:
         x.extract (data1, maxLength1);
                   // extr. 1st chunk into data1
         break;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
case 3303: x.extract (data2, maxLength2); // extr. 2nd chunk into data2 break;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
ケース3303：x.Extrage（data2、maxlength2）;// ingr。Data2ブレイクに2番目のチャンク。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       case 3304:  // we know this is a structure
         x.enter (); // enters the inner structure
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         while (x.rc == 0) // inner loop
         {
           switch (x.chunkID)
           {
             case 3305:
               x.extract (data3, maxLength3);
                         // extr. the chunk inside struct.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               break;
             case 3306:
               x.extract (data4, maxLength4);
                         // extr. 2nd chunk inside struct.
               break;
           }
           x.next (); // returns x.rc == 1 at end of structure
         } // end-while
         break;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       case 3307:
         x.extract (data5, maxLength5);
                   // extract last chunk into data
         break;
       // default: none - ignore unknown chunks !!!
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     } // end-switch
     x.next (); // returns x.rc = 1 at end of structure
   } // end-while
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Platform-independence">
4. Platform independence
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. プラットフォームの独立性
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The very most of the computer platforms today have a 8-Bits-in-a-Byte architecture, which enables data exchange between these platforms. But there are two significant points in which platforms may be different:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
今日のコンピュータープラットフォームのほとんどには、8ビットのバイトアーキテクチャがあり、これらのプラットフォーム間のデータ交換が可能です。しかし、プラットフォームが異なる場合がある2つの重要なポイントがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a) The representation of binary numerical (the short and long int and floats).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a) バイナリ数値の表現（短いINTおよびLONG INTおよびFLOAT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b) The representation of characters (ASCII/ANSI vs. EBCDIC)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b) 文字の表現（ASCII/ANSI対EBCDIC）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Point (a) is the phenomenon of &#34;byte swapping&#34;: How is a short int value 259 = 0x0103 = X&#39;0103&#39; be stored at address 4402?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポイント（a）は「バイトスワッピング」の現象です。短いINT値259 = 0x0103 = X&#39;0103 &#39;はどのようにアドレス4402に保存されていますか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two flavours are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのフレーバーは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4402 4403 01 03 the big-endian, and 03 01 the little-endian.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4402 4403 01 03ビッグエンディアン、および03 01リトルエンディアン。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Point (b) is represented by a table of the assignment of the 256 possible values of a Byte to printable or control characters. (In ASCII the letter &#34;A&#34; is assigned to value (or position) 0x41 = 65, in EBCDIC it is 0xC1 = 193.) The solution of these problems is to normalize the data:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポイント（b）は、印刷可能な文字または制御文字へのバイトの256の可能な値の割り当ての表で表されます。（ASCIIでは、文字「A」は値（または位置）0x41 = 65に割り当てられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We fix:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
修正：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(a) The internal representation of binary numerals are 2-complements in big-endian order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(a) バイナリ数字の内部表現は、大幅な順序で2つの複製です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(b) The internal representation of characters is ISO 8859-1 (also known as Latin 1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(b) 文字の内部表現はISO 8859-1（ラテン1とも呼ばれます）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fixing of point (b) should be regarded as a first strike. In some environment 8859-1 seems not to be the best choice, in a greek or russian environment 8859-5 or 8859-7 are appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポイント（b）の修正は、最初のストライキと見なされるべきです。一部の環境では、8859-1は最良の選択ではないようです。ギリシャまたはロシアの環境では、8859-5または8859-7が適切です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nevertheless, in a specific group (or world) of applications, that is to say all the applications which wants to interchange data with a defined protocol (via networking or diskette or something else), this internal character table must be unique.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それにもかかわらず、特定のグループ（または世界）のアプリケーション、つまり、定義されたプロトコル（ネットワークやディスケットなど）とデータを交換したいすべてのアプリケーションが、この内部文字テーブルは一意でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So a possibility to define a translation table (and his inversion) should be given.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、翻訳テーブル（および彼の反転）を定義する可能性を与える必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Important: You construct a SDXF chunk not for a specific addressee, but you adapt your data into a normalized format (or network format).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重要：特定の宛先ではなくSDXFチャンクを構築しますが、データを正規化された形式（またはネットワーク形式）に適応させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This adaption is not done by the programmer, it will be done by the create and extract function. An administrator has take care of defining the correct translation tables.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この適応はプログラマーによって行われるのではなく、作成および抽出機能によって行われます。管理者は、正しい翻訳テーブルの定義に注意しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Compression">
5. Compression
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 圧縮
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As stated in 2.5 there is a flag bit which declares that the following data (elementary or structured) are compressed. This data is not further interpretable until it is decompressed. Compression is transparently done by the SDXF functions: &#34;create&#34; does the compression for elementary chunks, &#34;leave&#34; for structured chunks, &#34;extract&#34; does the decompression for elementary chunks, &#34;enter&#34; for structured chunks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.5に記載されているように、次のデータ（初等または構造化）が圧縮されていることを宣言するフラグビットがあります。このデータは、減圧されるまでさらに解釈できません。圧縮はSDXF関数によって透過的に行われます。「create」は、基本チャンクの圧縮を行い、構造化されたチャンクの「残し」、「抽出」は、「基本チャンクの減圧」を行い、構造化されたチャンクに「入力します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transparently means that the programmer has only to tell the SDXF functions that he want compress the following chunk(s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
透過的には、プログラマーがSDXF関数に次のチャンクを圧縮したいことを伝えるだけであることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For choosing between different compression methods and for controlling the decompressed (original) length, there is an additional definition: After the chunk header for a compressed chunk, a compression header is following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
異なる圧縮方法を選択し、減圧（元の）長さを制御するために、追加の定義があります。圧縮チャンクのチャンクヘッダーの後、圧縮ヘッダーが次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-----------------------+---------------+----------------&gt;
   |      chunk header     | compr. header | compressed data
   +---+---+---+---+---+---+---+---+---+---+----------------&gt;
   |chunkID|flg|   length  |md | orglength |
   +---+---+---+---+---+---+---+---+---+---+----------------&gt;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- &#39;orglength&#39; is the original (decompressed) length of the data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 「Orglength」は、データの元の（減圧された）長さです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- &#39;md&#39; is the &#34;compression method&#34;: Two methods are described here:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 「MD」は「圧縮方法」です。ここでは、2つの方法が説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
# method 01 for a simple (fast but not very effective) &#34;Run Length 1&#34; or &#34;Byte Run 1&#34; algorithm. (More then two consecutive identical characters are replaced by the number of these characters and the character itself.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
＃メソッド01単純な（高速ではないがあまり効果的ではない）「実行長1」または「バイト実行1」アルゴリズムの場合。（2つの連続した同一の文字が、これらの文字の数と文字自体に置き換えられます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
more precisely:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
より正確に：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The compressed data consists of several sections of various length. Every section starts with a &#34;counter&#34; byte, a signed &#34;tiny&#34; (8 bit) integer, which contains a length information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
圧縮データは、さまざまな長さのいくつかのセクションで構成されています。すべてのセクションは、「カウンター」バイト、署名された「小さな」（8ビット）整数で始まり、長さの情報が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
If this byte contains the value &#34;n&#34;, with n &gt;= 0 (and n &lt;128), the next n+1 bytes will be taken unchanged; with n &lt; 0 (and n &gt; -128), the next byte will be replicated -n+1 times; n = -128 will be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
このバイトにn&gt; = 0（およびn &lt;128）の値「n」が含まれている場合、次のn 1バイトは変更されません。n &lt;0（およびn&gt; -128）では、次のバイトが1回複製されます。n = -128は無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Appending blanks will be cutted in general. If these are necessary, they can be reconstructed while &#34;extract&#34;ing with the parameter field &#34;filler&#34; (see 8.2.1) set to space character.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
アプリデンディングブランクは一般にカットされます。これらが必要な場合は、パラメーターフィールド「フィラー」（8.2.1を参照）を使用して「抽出」しているときに再構築できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
# method 02 for the wonderful &#34;deflate&#34; algorithm which comes from the &#34;zip&#34;-people. The authors are: Jean-loup Gailly (deflate routine), Mark Adler (inflate routine), and others.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
＃メソッド02「zip」ペオプルに由来する素晴らしい「デフレート」アルゴリズム。著者は、Jean-Loup Gailly（DEFLATEルーチン）、Mark Adler（膨張ルーチン）などです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The deflate format is described in [DEFLATE].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
DEFLATE形式は[DEFLATE]で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The values for the compression method number are maintained by IANA, see chap. 12.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
圧縮法番号の値はIANAによって維持されます。Chapを参照してください。12.1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Encryption">
6. Encryption
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 暗号化
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As stated in 2.5 there is a flag bit which declares that the following data (elementary or structured) is encrypted. This data is not interpretable until it is decrypted. En/Decryption is transparently done by the SDXF functions, &#34;create&#34; does the encryption for elementary chunks, &#34;leave&#34; for structured chunks, &#34;extract&#34; does the decryption for elementary chunks, &#34;enter&#34; for structured chunks. (Yes it sounds very similar to chapter 5.) More then one encryption method for a given range of applications is not very reasonable. Some encryption algorithms work with block ciphering algorithms. That means that the length of the data to encrypt must be rounded up to the next multiple of this block length. This blocksize (zero means non-blocking) is reported by the encryption interface routine (addressed by the option field *encryptProc, see chapter 8.5) with mode=3. If blocking is used, at least one byte is added, the last byte of the lengthening data contains the number of added bytes minus one. With this the decryption interface routine can calculate the real data length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.5に記載されているように、次のデータ（初等または構造化）が暗号化されていることを宣言するフラグビットがあります。このデータは、復号化されるまで解釈できません。EN/復号化はSDXF関数によって透過的に行われ、「Create」は基本チャンクの暗号化を行い、構造化されたチャンクの「残し」、「抽出」は「基本チャンクの復号化」を行い、「構造的なチャンクに「入力」します。（はい、それは第5章に非常に似ているように聞こえます）。一部の暗号化アルゴリズムは、ブロック微分アルゴリズムで動作します。つまり、暗号化するデータの長さは、このブロックの長さの次の倍数に切り上げなければなりません。このブロックサイズ（ゼロは非ブロックを意味します）は、モード= 3で暗号化インターフェイスルーチン（オプションフィールド *encryptProc、第8.5章を参照）によって報告されます。ブロッキングを使用すると、少なくとも1つのバイトが追加されます。延長データの最後のバイトには、追加されたバイトの数を引いた数が含まれています。これにより、復号化インターフェイスルーチンは実際のデータ長を計算できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an application (or network connect handshaking protocol) needs to negotiate an encryption method it should be used a method number maintained by IANA, see chap. 12.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーション（またはネットワーク接続ハンドシェーキングプロトコル）が暗号化方法をネゴシエートする必要がある場合は、IANAによって維持されるメソッド番号を使用する必要があります。Chapを参照してください。12.2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even the en/decryption is done transparently, an encryption key (password) must be given to the SDXF functions. Encryption is done after translating character data into, decryption is done before translation from the internal (&#34;network-&#34;) format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EN/復号化が透過的に行われていても、暗号化キー（パスワード）をSDXF関数に指定する必要があります。暗号化は、文字データを翻訳した後に行われ、復号化は内部（「ネットワーク」）形式から変換される前に行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If both, encryption and compression are applied on the same chunk, compression is done first - compression on good encrypted data (same strings appears as different after encryption) tends to zero compression rates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化と圧縮の両方が同じチャンクに適用される場合、最初に圧縮が行われます - 良好な暗号化されたデータでの圧縮（暗号化後に同じ文字列が異なると表示されます）は圧縮速度がゼロになる傾向があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Arrays">
7. Arrays
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 配列
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An array is a sequence of chunks with identical chunk-ID, length and data type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
配列は、同じチャンクID、長さ、データ型を備えた一連のチャンクです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At first a hint: in principle a special definition in SDXF for such an array is not really necessary:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初はヒント：原則として、このような配列のSDXFの特別な定義は実際には必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is not forbidden that there are more than one chunk with equal chunk-ID within the same structured chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じ構造化されたチャンク内に等しいチャンクIDを持つ複数のチャンクがあることは禁止されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore with a sequence of SDX_next / SDX_extract calls one can fill the destination array step by step.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、一連のSDX_NEXT / SDX_EXTRACTコールを使用すると、宛先配列を段階的に入力できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there are many occurrences of chunks with the same chunk-ID (and a comparative small length), the overhead of the chunk-packages may be significant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じチャンクID（および比較小さな長さ）でチャンクの多くの発生がある場合、チャンクパッケージのオーバーヘッドは重要な場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore the array flag is introduced. An array chunk has only one chunk header for the complete sequence of elementary chunks. After the chunk header for an array chunk, an array header is following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、配列フラグが導入されます。Array Chunkには、一連の基本チャンクの完全なシーケンス用のチャンクヘッダーが1つしかありません。アレイチャンクのチャンクヘッダーの後、アレイヘッダーが次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is a short integer (big endian!) which contains the number of the array elements (CT). Every element has a fixed length (EL), so the chunklength (CL) is CL = EL * CT + 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、アレイ要素の数（CT）を含む短い整数（Big Endian！）です。すべての要素の固定長（EL）があるため、ChunkLength（CL）はCl = EL * CT 2です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The data elements follows immediately after the array header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ要素は、配列ヘッダーの直後に続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The complete array will be constructed by SDX_create, the complete array will be read by SDX_extract.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
完全な配列はSDX_Createによって構築され、完全な配列はSDX_EXTRACTによって読み取られます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The parameter fields (see 8.2.1) &#39;dataLength&#39; and &#39;count&#39; are used for the SDXF functions &#39;extract&#39; and &#39;create&#39;:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パラメーターフィールド（8.2.1を参照）「Datalength」と「Count」は、SDXF関数「抽出」および「作成」に使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Field &#39;dataLength&#39; is the common length of the array elements, &#39;count&#39; is the actual dimension of the array for &#39;create&#39; (input).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールド「Datalength」は配列要素の一般的な長さであり、「カウント」は「create」（入力）の配列の実際の次元です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the &#39;extract&#39; function &#39;count&#39; acts both as an input and output parameter:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「抽出」関数の場合、「カウント」は、入力パラメーターと出力パラメーターの両方として機能します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Input : the maximum dimension output: the actual array dimension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入力：最大寸法出力：実際の配列寸法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(If output count is greater than input count, the &#39;data cutted&#39; warning will be responded and the destination array is filled up to the maximum dimension.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（出力カウントが入力カウントよりも大きい場合、「データ削減」警告が応答され、宛先配列が最大寸法に満たされます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--Description-of-the-SDXF-functions">
8. Description of the SDXF functions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. SDXF関数の説明
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1-Introduction">
8.1 Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1 はじめに
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Following the principles of Object Oriented Programming, not only the description of the data is necessary, but also the functions which manipulate data - the &#34;methods&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクト指向プログラミングの原則に従って、データの説明だけでなく、データを操作する機能（「メソッド」も操作する」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the programmer knowing the methods is more important than knowing the data structure, the methods has to know the exact specifications of the data and guarantees the consistence of the data while creating them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メソッドを知るプログラマがデータ構造を知るよりも重要であるため、メソッドはデータの正確な仕様を知り、データを作成しながらデータの一貫性を保証する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A SDXF object is an instance of a parameter structure which acts as a programming interface. Especially it points to an actual SDXF data chunk, and, while processing on this data, there is a pointer to the actual inner chunk which will be the focus for the next operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXFオブジェクトは、プログラミングインターフェイスとして機能するパラメーター構造のインスタンスです。特に、実際のSDXFデータチャンクを指しており、このデータで処理する際に、実際の内側チャンクへのポインターがあり、次の操作の焦点となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The benefit of an exact interface description is the same as using for example the standard C library functions: By using standard interfaces your code remains platform independent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正確なインターフェイスの説明の利点は、たとえば標準のCライブラリ関数を使用することと同じです。標準インターフェイスを使用することにより、コードはプラットフォームに依存しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2-Basic-definitions">
8.2 Basic definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2 基本的な定義
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2-1-The-SDXF-Parameter-structure">
8.2.1 The SDXF Parameter structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.1 SDXFパラメーター構造
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All SDXF access functions need only one parameter, a pointer to the SDXF parameter structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのSDXFアクセス関数には、SDXFパラメーター構造へのポインター、1つのパラメーターのみが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First 3 prerequisite definitions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の3つの前提条件定義：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef short int ChunkID; typedef unsigned char Byte;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef short int chunkid;typedef unsigned charバイト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef struct Chunk
   {
     ChunkID    chunkID;
     Byte       flags;
     char       length [3];
     Byte       data;
   } Chunk;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
And now the parameter structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そして今、パラメーター構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef struct
   {
     ChunkID  chunkID;       // name (ID) of Chunk
     Byte    *container;     // pointer to the whole Chunk
     long     bufferSize;    // size of container
     Chunk   *currChunk;     // pointer to actual Chunk
     long     dataLength;    // length of data in Chunk
     long     maxLength;     // max. length of Chunk for SDX_extract
     long     remainingSize; // rem. size in cont. after SDX_create
     long     value;         // for data type numeric
     double   fvalue;        // for data type float
     char    *function;      // name of the executed SDXF function
     Byte    *data;          // pointer to Data
     Byte    *cryptkey;      // pointer to Crypt Key
     short    count;         // (max.) number of elements in an array
     short    dataType;      // Chunk data type / init open type
     short    ec;            // extended return-code
        short    rc;            // return-code
     short    level;         // level of hierarchy
     char     filler;        // filler char for SDX_extract
     Byte     encrypt;       // Indication if data to encrypt (0 / 1)
     Byte     compression;   // compression method
                             //   (00=none, 01=RL1, 02=zip/deflate)
   } SDX_obj, *SDX_handle;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Only the &#34;public&#34; fields of the parameter structure which acts as input and output for the SDXF functions is described here. A given implementation may add some &#34;private&#34; fields to this structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXF関数の入力と出力として機能するパラメーター構造の「パブリック」フィールドのみがここで説明されています。特定の実装により、この構造に「プライベート」フィールドが追加される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2-2-Basic-Functions">
8.2.2 Basic Functions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.2 基本機能
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All these functions works with a SDX_handle as the only formal parameter. Every function returns as output ec and rc as a report of success. For the values for ec, rc and dataType see chap. 8.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのすべての関数は、SDX_Handleを唯一の正式なパラメーターとして使用します。すべての関数は、成功のレポートとして出力ECおよびRCとして戻ります。EC、RC、およびデータ型の値については、Chapを参照してください。8.4。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
1. SDX_init : Initialize the parameter structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
1. SDX_INIT：パラメーター構造を初期化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
input : container, dataType, bufferSize (for dataType = SDX_NEW only) output: currChunk, dataLength (for dataType = SDX_OLD only), ec, rc, the other fields of the parameter structure will be initialized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
入力：コンテナ、データタイプ、緩衝（データタイプ= SDX_NEWのみ）出力：Currchunk、DatAlength（Datatype = SDX_OLDのみ）、EC、RC、パラメーター構造の他のフィールドが初期化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
2. SDX_enter : Enter a structured chunk. You can access the first chunk inside this structured chunk. input : none output: currChunk, chunkID, dataLength, level, dataType, ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
2. SDX_ENTER：構造化されたチャンクを入力します。この構造化されたチャンク内の最初のチャンクにアクセスできます。入力：なし出力：Currchunk、Chunkid、Datalength、Level、Datatype、EC、RC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
3. SDX_leave : Leave the actual entered structured chunk. input : none output: currChunk, chunkID, dataLength, level, dataType, ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
3. SDX_LEAVE：実際に入力された構造化されたチャンクを残します。入力：なし出力：Currchunk、Chunkid、Datalength、Level、Datatype、EC、RC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
4. SDX_next : Go to the next chunk inside a structured chunk. input : none output: currChunk, chunkID, dataLength, dataType, count, ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
4. SDX_NEXT：構造化されたチャンク内の次のチャンクに移動します。入力：なし出力：Currchunk、Chunkid、Datalength、DataType、Count、EC、RC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
At the end of a structured chunk SDX_next returns rc = SDX_RC_failed and ec = SDX_EC_eoc (end of chunk) The actual structured chunk is SDX_leave&#39;d automatically.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
構造化されたチャンクの最後に、rc = sdx_rc_failedおよびec = sdx_ec_eoc（chunkの終わり）を返します。実際の構造化されたチャンクはsdx_leave&#39;dです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
5. SDX_extract : Extract data of the actual chunk. (If actual chunk is structured, only a copy is done, elsewhere the data is converted to host format.) input / output depends on the dataType:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
5. SDX_Extra：実際のチャンクのデータを抽出します。（実際のチャンクが構造化されている場合、コピーのみが行われます。他の場所では、データはホスト形式に変換されます。）入力 /出力はデータ型に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if dataType is structured, binary or char: input : data, maxLength, count, filler output: dataLength, count, ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DataTypeが構造化されている場合、バイナリまたはchar：入力：データ、MaxLength、Count、Filler Output：Datalength、Count、EC、RC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if dataType is numeric (float resp.): input : none output: value (fvalue resp.), ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
データタイプが数値（float rep。）：input：none output：value（fvalue resp。）、ec、rc
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
6. SDX_select : Go to the (next) chunk with a given chunkID. input : chunkID output: currChunk, dataLength, dataType, ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
6. SDX_SELECT：特定のチャンクで（次の）チャンクに移動します。入力：Chunkid Output：Currchunk、Datalength、DataType、EC、RC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
7. SDX_create : Creating a new chunk (at the end of the actual structured chunk). input : chunkID, dataLength, data, (f)value, dataType, compression, encrypt, count update: remainingSize, level output: currChunk, dataLength, ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
7. SDX_CREATE：新しいチャンクを作成します（実際の構造化されたチャンクの最後に）。入力：Chunkid、DataLength、Data、（f）値、データ型、圧縮、暗号化、カウントアップデート：残り、レベル出力：Currchunk、Datalength、EC、RC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
8. SDX_append : Append a complete chunk at the end of the actual structured chunk). input : data, maxLength, currChunk update: remainingSize, level output: chunkID, chunkLength, maxLength, dataType, ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
8. SDX_APPEND：実際の構造化されたチャンクの最後に完全なチャンクを追加します）。入力：データ、MaxLength、Currchunk Update：残り、レベル出力：Chunkid、ChunkLength、MaxLength、Datatype、EC、RC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-3-Definitions-for-C">
8.3 Definitions for C++
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3 cの定義
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is the specification of the SDXF class in C++: (The type &#39;Byte&#39; is defined as &#34;unsigned char&#34; for bitstrings, opposed to &#34;signed char&#34; for character strings)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、cのSDXFクラスの仕様です（型 &#39;byte&#39;は、ビットストリングの「符号なしのchar」として定義され、キャラクター文字列の「署名されたchar」とは反対です）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
class C_SDXF { public:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クラスC_SDXF {public：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     // constructors and destructor:
     C_SDXF  ();                          // dummy
     C_SDXF  (Byte *cont);                // old container
     C_SDXF  (Byte *cont, long size);     // new container
     C_SDXF  (long size);                 // new container
     ~C_SDXF ();
     // methods:
          void init  (void);                   // old container
     void init  (Byte *cont);             // old container
     void init  (Byte *cont, long size);  // new container
     void init  (long size);              // new container
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     void enter   (void);
     void leave   (void);
     void next    (void);
     long extract (Byte *data, long length);    // chars, bits
     long extract (void);                       // numeric data
     void create  (ChunkID);                    // structured
     void create  (ChunkID, long value);        // numeric
     void create  (ChunkID, double fvalue);     // float
     void create  (ChunkID, Byte *data, long length);// binary
     void create  (ChunkID, char *data);             // chars
     void set_compression (Byte compression_method);
     void set_encryption  (Byte *encryption_key);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
// interface:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
// インターフェース：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     ChunkID  id;        // see 8.4.1
     short    dataType;  // see 8.4.2
     long     length;    // length of data or chunk
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     long     value;
     double   fvalue;
     short    rc;  // the raw return code       see 8.4.3
     short    ec;  // the extended return code  see 8.4.4
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
protected: // implementation dependent ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
保護：//実装依存...
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8.4 Common Definitions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8.4 一般的な定義：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8.4.1 Definition of ChunkID:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8.4.1 Chunkidの定義：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef short ChunkID;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedefショートチャンク。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8.4.2 Values for dataType:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8.4.2 データ型の値：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDX_DT_inconsistent = 0 SDX_DT_structured = 1 SDX_DT_binary = 2 SDX_DT_numeric = 3 SDX_DT_char = 4 SDX_DT_float = 5 SDX_DT_UTF8 = 6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sdx_dt_inconsistent = 0 sdx_dt_structured = 1 sdx_dt_binary = 2 sdx_dt_numeric = 3 sdx_dt_char = 4 sdx_dt_float = 5 sdx_dt_utf8 = 6 6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 data types for SDX_init: SDX_OLD = 1 SDX_NEW = 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sdx_initのデータ型：sdx_old = 1 sdx_new = 2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8.4.3 Values for rc:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8.4.3 RCの値：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDX_RC_ok = 0 SDX_RC_failed = 1 SDX_RC_warning = 1 SDX_RC_illegalOperation = 2 SDX_RC_dataError = 3 SDX_RC_parameterError = 4 SDX_RC_programError = 5 SDX_RC_noMemory = 6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDX_RC_OK = 0 SDX_RC_FAILED = 1 SDX_RC_WARNING = 1 SDX_RC_ILLEGALOPERATION = 2 SDX_RC_DATAERROR = 3 SDX_RC_PARAMETERERROR = 4 SDX_RC_RC_PORMORMERROR = 5 SDX_RC_NOMEMORY = 6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8.4.4 Values for ec:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8.4.4 ECの値：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   SDX_EC_ok              =  0
   SDX_EC_eoc             =  1 // end of chunk
   SDX_EC_notFound        =  2
   SDX_EC_dataCutted      =  3
   SDX_EC_overflow        =  4
   SDX_EC_wrongInitType   =  5
   SDX_EC_comprerr        =  6 // compression error
   SDX_EC_forbidden       =  7
   SDX_EC_unknown         =  8
   SDX_EC_levelOvflw      =  9
   SDX_EC_paramMissing    = 10
   SDX_EC_magicError      = 11
   SDX_EC_not_consistent  = 12
   SDX_EC_wrongDataType   = 13
   SDX_EC_noMemory        = 14
   SDX_EC_error           = 99 // rc is sufficiently
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-5-Special-functions">
8.5 Special functions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5 特別な機能
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Besides the basic definitions there is a global function (SDX_getOptions) which returns a pointer to a global table of options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本的な定義に加えて、グローバルな機能（SDX_GETOPTIONS）があり、グローバルオプションの表にポインターを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the help of these options you can adapt the behaviour of SDXF. Especially you can define an alternative pair of translation tables or an alternative function which reads these tables from an external resource (p.e. from disk).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのオプションの助けを借りて、SDXFの動作を適応させることができます。特に、翻訳テーブルの代替ペアまたは外部リソース（ディスクからのP.E.）からこれらのテーブルを読み取る代替機能を定義できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Within this table of options there is also a pointer to the function which is used for encryption / decryption: You can install your own encryption algorithm by setting this pointer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオプションの表には、暗号化 /復号化に使用される関数へのポインターもあります。このポインターを設定して、独自の暗号化アルゴリズムをインストールできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The options pointer is received by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションポインターは次のように受信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   SDX_TOptions *opt = SDX_getOptions ();
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
と：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef struct
   {
    Byte            *toHost;        // Trans tab net -&gt; host
    Byte            *toNet;         // Trans tab host -&gt; net
    int              maxlevel;      // highest possible level
    int              translation;   // translation net &lt;-&gt; host
                                    // is in effect=1 or not=0
    TEncryptProc    *encryptProc;   // alternate encryption routine
    TGetTablesProc  *getTablesProc; // alternate routine defining
                                    // translation Tables
    TcvtUTF8Proc    *convertUTF8;   // routine to convert to/from UTF-8
   }  SDX_TOptions;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef long TencryptProc (
     int   mode,   // 1= to encrypt, 2= to decrypt, 3= encrypted length
     Byte *buffer, // data to en/decrypt
     long  len,    // len: length of buffer
     char *passw); // Password
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    // returns length of en/de-crypted data
    // (parameter buffer and passw are ignored for mode=3)
    // returns blocksize for mode=3 and len=0.
    // blocksize is zero for non-blocking algorithms
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef int TGetTablesProc (Byte **toNet, Byte **toHost);
    // toNet, toHost: pointer to output params.  Both params
    // points to translation tables of 256 Bytes.
    // returns success: 1 = ok, 0 = error.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef int TcvtUTF8Proc
   ( int   mode,     // 1 = to UTF-8, 2 = from UTF-8
     Byte *target, int *targetlength,  // output
     Byte *source, int sourcelength);  // input
   // targetlength contains maximal size as input param.
   // returns success: 1 = ok, 0 = no conversion
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
9. &#39;Support&#39; of UTF-8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
9. UTF-8の「サポート」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many systems supports [UTF-8] as a character format for transferred data. The benefit is that no fixing of a specific character set for an application is needed because the set of &#39;all&#39; characters is used, represented by the &#39;Universal Character Set&#39; UCS-2 [UCS], a double byte coding for characters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くのシステムは、転送されたデータの文字形式として[UTF-8]をサポートしています。利点は、「All」文字のセットが「Universal Characterセット」UCS-2 [UCS]で表されるため、アプリケーション用の特定の文字セットの修正が必要であることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXF does not really deal with UTF-8 by itself, there are many possibilities to interprete an UTF-8 sequence: The application may:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXFは、それ自体でUTF-8を実際に扱っていません。UTF-8シーケンスを解釈する可能性は多くあります。アプリケーションは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- reconstruct the UCS-2 sequence, - accepts only the pure ASCII character and maps non-ASCII to a special &#39;non-printable&#39; character. - target is pure ASCII, non-ASCII is replaced in a senseful manner (French accented vowels replaced by vowels without accents, etc.). - target is a specific ANSI character set, the non-ASCII chars are mapped as possible, other replaced to a &#39;non-printable&#39;. - etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- UCS-2シーケンスを再構築する - 純粋なASCII文字のみを受け入れ、非ASCIIを特別な「印刷できない」文字にマップします。 - ターゲットは純粋なASCIIであり、非ASCIIは意味のある方法で置き換えられます（アクセントなどのない母音に置き換えられたフランスのアクセントの母音など）。 - ターゲットは特定のANSI文字セットであり、非ASCIIチャーは可能な限りマッピングされ、その他は「印刷できない」に置き換えられます。 - など。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
But SDXF offers an interface for the &#39;extract&#39; and &#39;create&#39; functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、SDXFは「抽出」および「作成」関数のインターフェイスを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A function pointer may be specified in the options table to maintain this possibility (see 8.5). Default for this pointer is NULL: No further conversions are done by SDXF, the data are copied &#39;as is&#39;, it is treated as a bit string as for data type &#39;binary&#39;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この可能性を維持するために、オプションテーブルに関数ポインターを指定できます（8.5を参照）。このポインターのデフォルトはnullです。これ以上の変換はSDXFによって行われません。データは「現状のまま」でコピーされ、データ型「バイナリ」のように少し文字列として扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If this function is specified, it is used by the &#39;create&#39; function with the &#39;toUTF8&#39; mode, and by the &#39;extract&#39; function with the &#39; fromUTF8&#39; mode. The invoking of these functions is done by SDXF transparently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数が指定されている場合、「toutf8」モードを使用した「作成」関数と、「fromutf8」モードで「抽出」関数によって使用されます。これらの機能の呼び出しは、SDXFによって透過的に行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the function returns zero (no conversion) SDXF copies the data without conversion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関数がゼロ（変換なし）を返す場合、SDXFは変換せずにデータをコピーします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10--Security-Considerations">
10. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. セキュリティに関する考慮事項
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any corruption of data in the chunk headers denounce the complete SDXF structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンクヘッダーのデータの破損は、完全なSDXF構造を非難します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any corruption of data in a encrypted or compressed SDXF structure makes this chunk unusable. An integrity check after decryption or decompression should be done by the &#34;enter&#34; function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化または圧縮されたSDXF構造内のデータの破損により、このチャンクは使用できなくなります。復号化または減圧後の整合性チェックは、「Enter」関数によって行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While using TCP/IP (more precisely: IP) as a transmission medium we can trust on his CRC check on the transport layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP/IP（より正確に：IP）を送信媒体として使用している間、輸送層でのCRCチェックで信頼できることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11--Some-general-hints">
11. Some general hints
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. いくつかの一般的なヒント
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. A consistent construction of a SDXF structure is done if every &#34;create&#34; to a structured chunk is closed by a paired &#34;leave&#34;. While a structured chunk is under construction, his data type is set to zero - that means: this chunk is inconsistent. The SDX_leave function sets the datatype to &#34;structured&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. SDXF構造の一貫した構造は、構造化されたチャンクのすべての「作成」がペアの「休暇」によって閉じられている場合に行われます。構造化されたチャンクは建設中ですが、彼のデータ型はゼロに設定されています。つまり、このチャンクは矛盾しています。SDX_Leave関数は、データ型を「構造化」に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. While creating an elementary chunk a platform dependent transformation to a platform independent format of the data is performed - at the end of construction the content of the buffer is ready to transport to another site, without any further translation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 基本チャンクの作成中、プラットフォームに依存するデータのデータの独立した形式への依存変換が実行されます。建設の最後に、バッファのコンテンツは、さらなる翻訳なしで別のサイトに輸送する準備ができています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. As you see no data definition in your programming language is needed for to construct a specific SDXF structure. The data is created dynamically by function calls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 特定のSDXF構造を構築するためには、プログラミング言語にデータ定義が必要ありません。データは、関数呼び出しによって動的に作成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. With SDXF as a base you can define protocols for client / server applications. These protocols may be extended in downward compatibility manner by following two rules:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. SDXFをベースとして使用すると、クライアント /サーバーアプリケーションのプロトコルを定義できます。これらのプロトコルは、2つのルールに従うことにより、下向きの互換性で拡張できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Rule 1: Ignore unknown chunkIDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ルール1：不明な帯域を無視します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Rule 2: The sequence of chunks should not be significant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ルール2：チャンクのシーケンスは重要ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12--IANA-Considerations">
12. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. IANAの考慮事項
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The compression and encryption algorithms for SDXF is not fixed, SDXF is open for various algorithms. Therefore an agreement is necessary to interprete the compression and encryption algorithm method numbers. (Encryption methods are not a semantic part of SDXF, but may be used for a connection protocol to negotiate the encryption method to use.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXFの圧縮および暗号化アルゴリズムは固定されていません。SDXFはさまざまなアルゴリズムに対して開かれています。したがって、圧縮および暗号化アルゴリズムのメソッド番号を解釈するには、合意が必要です。（暗号化方法はSDXFのセマンティック部分ではありませんが、使用する暗号化方法をネゴシエートするために接続プロトコルに使用できます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Following two items are registered by IANA:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の2つの項目がIANAによって登録されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-1-COMPRESSION-METHODS-FOR-SDXF">
12.1 COMPRESSION METHODS FOR SDXF
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1 SDXFの圧縮方法
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   The compressed SDXF chunk starts with a &#34;compression header&#34;.  This
   header contains the compression method as an unsigned 1-Byte integer
   (1-255).  These numbers are assigned by IANA and listed here:
      compression
    method     Description                     Hints
   ---------   ------------------------------- -------------
         01    RUN-LENGTH algorithm            see chap. 5
         02    DEFLATE (ZIP)                   see [DEFLATE]
     03-239    IANA to assign
    240-255    private or application specific
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2-ENCRYPTION-METHODS-FOR-SDXF">
12.2 ENCRYPTION METHODS FOR SDXF
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2 SDXFの暗号化方法
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An unique encryption method is fixed or negotiated by handshaking. For the latter one a number for each encryption method is necessary. These numbers are unsigned 1-Byte integers (1-255). These numbers are assigned by IANA and listed here:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一意の暗号化方法は、手作業で固定または交渉されます。後者の場合、各暗号化方法の数値が必要です。これらの数値は、署名されていない1バイト整数（1-255）です。これらの番号はIANAによって割り当てられ、ここにリストされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   encryption
     method    Description
    ---------  ------------------------------
     01-239    IANA to assign
    240-255    private or application specific
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
12.3 Hints for assigning a number:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
12.3 番号を割り当てるためのヒント：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Developers which want to register a compression or encrypt method for SDXF should contact IANA for a method number. The ASSIGNED NUMBERS document should be referred to for a current list of METHOD numbers and their corresponding protocols, see [IANA]. The new method SHOULD be a standard published as a RFC or by a established standardization organization (as OSI).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXFの圧縮または暗号化方法を登録する開発者は、メソッド番号についてIANAに連絡する必要があります。割り当てられた番号ドキュメントは、メソッド番号とそれらに対応するプロトコルの現在のリストについて参照する必要があります。[IANA]を参照してください。新しい方法は、RFCとして、または確立された標準化組織（OSIとして）によって公開される標準である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13--Discussion">
13. Discussion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. 考察
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are already some standards for Internet data exchanging, IETF prefers ASN.1 and XML therefore. So the reasons for establish a new data format should be discussed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFは、インターネットデータの交換にはすでにいくつかの基準があります。したがって、IETFはXMLを好みます。したがって、新しいデータ形式を確立する理由について説明する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-1-SDXF-vs--ASN-1">
13.1 SDXF vs. ASN.1
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1 SDXF対ASN.1
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The demand of ASN.1 (see [ASN.1]) is to serve program language independent means to define data structures. The real data format which is used to send the data is not defined by ASN.1 but usually BER or PER (or some derivates of them like CER and DER) are used in this context, see [BER] and [PER].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
asn.1（[asn.1]を参照）の需要は、データ構造を定義するためのプログラム言語に依存しない手段を提供することです。データの送信に使用される実際のデータ形式は、asn.1によって定義されませんが、通常はBERまたはPER（またはCERやDERのような派生物）がこのコンテキストで使用されます。[BER]および[PER]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The idea behind ASN.1 is: On every platform on which a given application is to develop descriptions of the used data structures are available in ASN.1 notation. Out off these notations the real language dependent definitions are generated with the help of an ASN.1-compiler.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ASN.1の背後にあるアイデアは、特定のアプリケーションが使用されているデータ構造の説明を開発することであるすべてのプラットフォームで、ASN.1表記で利用可能です。これらの表記の外で、ASN.1コンパイラの助けを借りて、実際の言語依存定義が生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This compiler generates also transform functions for these data structures for to pack and unpack to and from the BER (or other) format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このコンパイラは、これらのデータ構造の関数を生成し、BER（または他の）形式をパックして開梱するために変換されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A direct comparison between ASN.1 and SDXF is somehow inappropriate: The data format of SDXF is related rather to BER (and relatives). The use of ASN.1 to define data structures is no contradiction to SDXF, but: SDXF does not require a complete data structure to build the message to send, nor a complete data structure will be generated out off the received message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ASN.1とSDXFの直接的な比較は何らかの形で不適切です。SDXFのデータ形式は、BER（および親relative）に関連しています。データ構造を定義するためにASN.1を使用することはSDXFと矛盾するものではありませんが、SDXFは送信するメッセージを作成するために完全なデータ構造を必要としません。また、受信したメッセージから完全なデータ構造も生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The main difference lies in the concept of building and interpretation of the message, I want to name it the &#34;static&#34; and &#34;dynamic&#34; concept:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
主な違いは、メッセージの構築と解釈の概念にあります。「静的」と「動的な」概念と名付けたいと思います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ASN.1 uses a &#34;static&#34; approach: The whole data structure must exists before the message can be created.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ASN.1は「静的」アプローチを使用します。メッセージを作成する前に、データ構造全体が存在する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SDXF constructs and interpretes the message in a &#34;dynamic&#34; way, the message will be packed and unpacked step by step by SDXF functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SDXFはメッセージを「ダイナミックな」方法で構築および解釈するため、メッセージは梱包され、SDXF関数ごとに段階的に開梱されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of static structures may be appropriate for a series of applications, but for complex tasks it is often impossible to define the message as a whole. As an example try to define an ASN.1 description for a complex structured text document which is presented in XML: There are sections and paragraphs and text elements which may recursively consist of sections with specific text attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的構造の使用は、一連のアプリケーションに適している場合がありますが、複雑なタスクでは、メッセージ全体を定義することは不可能です。例として、XMLで提示されている複雑な構造化されたテキストドキュメントのasn.1説明を定義してみてください。特定のテキスト属性を持つセクションで再帰的に構成される可能性のあるセクションとパラグラフとテキスト要素があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-2-SDXF-vs--XML">
13.2 SDXF vs. XML
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2 SDXF対XML
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On the one hand SDXF and XML are similar as they can handle any recursive complex data stream. The main difference is the kind of data which are to be maintained:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一方では、SDXFとXMLは、再帰的な複雑なデータストリームを処理できるため、似ています。主な違いは、維持されるデータの種類です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o XML works with pure text data (though it should be noted that the character representation is not standardized by XML). And: a XML document with all his tags is readable by human. Binary data as graphic is not included directly but may be referenced by an external link as in HTML.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o XMLは純粋なテキストデータで動作します（ただし、文字表現はXMLによって標準化されていないことに注意する必要があります）。および：すべてのタグを備えたXMLドキュメントは、人間が読むことができます。グラフィックとしてのバイナリデータは直接含まれていませんが、HTMLのように外部リンクによって参照される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In XML there is no strong separation between informational and control data, escape characters (like &#34;&lt;&#34; and &#34;&amp;&#34;) and the &lt;![CDATA[...]]&gt; construction are used to distinguish between these two types of data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
XMLでは、情報データと制御データの間に強い分離はありません。エスケープ文字（「&lt;」や「＆」など）、&lt;！[cdata [...]]&gt;構造は、これら2つのタイプのデータを区別するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SDXF maintains machine-readable data, it is not designed to be readable by human nor to edit SDXF data with a text editor (even more if compression and encryption is used). With the help of the SDXF functions you have a quick and easy access to every data element. The standard parser for a SDXF data structure follows always a simple template, the &#34;while - switch -case ID - enter/extract&#34; pattern as outlined in chap. 3.4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SDXFは機械可読データを維持します。これは、人間が読みやすくすることも、テキストエディターでSDXFデータを編集するようにも設計されていません（圧縮と暗号化が使用される場合はさらに多く）。 SDXF関数の助けを借りて、すべてのデータ要素にすばやく簡単にアクセスできます。 SDXFデータ構造の標準パーサーは、常に単純なテンプレート、「while -switch -case id -Enter/抽出」パターンに続きます。 3.4.2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because of the complete different philosophy behind XML and SDXF (and even ASN.1) a direct comparison may not be very senseful, as XML has its own right to exist next to ASN.1 (and even SDXF).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
XMLとSDXFの背後にある完全な異なる哲学のために、XMLにはASN.1（およびSDXF）の隣に存在する独自の権利があるため、直接的な比較はそれほど意味がないかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nevertheless there is a chance to convert a XML data stream into a SDXF structure: As a first strike, every XML tag becomes a SDXF chunk ID. An elementary sequence &lt;tag&gt;pure text&lt;/tag&gt; can be transformed into an elementary (non-structured) chunk with data type &#34;character&#34;. Tags with attributes and sequences with nested tags are transformed into structured chunks. Because XML allows a tag sequence everywhere in a text stream, an artificially &#34;elementary text&#34; tag must be introduced: If &lt;t&gt; is the tag for text elements, the sequence:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それにもかかわらず、XMLデータストリームをSDXF構造に変換する機会があります。最初のストライクとして、すべてのXMLタグはSDXFチャンクIDになります。初等シーケンス&lt;タグ&gt;純粋なテキスト&lt;/tag&gt;は、データ型「文字」を使用して小学校（非構造化）チャンクに変換できます。ネストされたタグを使用した属性とシーケンスを持つタグは、構造化されたチャンクに変換されます。XMLはテキストストリーム内のどこでもタグシーケンスを許可するため、人為的に「基本テキスト」タグを導入する必要があります。&lt;t&gt;がテキスト要素のタグである場合、シーケンス：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   &lt;t&gt;this is a text &lt;attr value=&#39;bold&#39;&gt;with&lt;/attr&gt; attributes&lt;/t&gt;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is to be &#34;in thought&#34; replaced by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のことに置き換えられることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   &lt;t&gt;&lt;et&gt;this is a text &lt;/et&gt;&lt;attr value=&#39;bold&#39;&gt;&lt;et&gt;with&lt;/et&gt;&lt;/attr&gt;
   &lt;et&gt; attributes&lt;/et&gt;&lt;/t&gt;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(With &#34;et&#34; as the &#34;elementary text&#34; tag) This results in following SDXF structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（「ET」を「初等のテキスト」タグとして）これにより、SDXF構造に続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ID_t
   |
   +-- ID_et = &#34; this is a text &#34;
   |
   +-- ID_attr
   |   |
   |   +-- ID_value = &#34;bold&#34;
   |   |
   |   +-- ID_et = &#34;with&#34;
   |
   +-- ID_et = &#34; attributes&#34;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ID_t and ID_et may be represented by the same chunk ID, only distinguished by the data type (&#34;structured&#34; for &lt;t&gt; and &#34;character&#34; for &lt;et&gt;)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ID_TおよびID_ETは、同じチャンクIDで表される場合があり、データ型（&lt;t&gt;の「構造」と&lt;et&gt;の「文字」）によってのみ区別される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Binary data as pictures can be directly imbedded into a SDXF structure instead referencing them as an external link like in HTML.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
写真としてのバイナリデータは、HTMLのような外部リンクとしてそれらを参照する代わりに、SDXF構造に直接埋め込むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14--Authors-Address">
14. Author&#39;s Address
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. 著者の連絡先
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Max Wildgrube Schlossstrasse 120 60486 Frankfurt Germany
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Max WildGrube SchlossStrasse 120 60486フランクフルトドイツ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: max@wildgrube.com
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15--Acknowledgements">
15. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. 謝辞
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I would like to thank Michael J. Slifcak (mslifcak@iss.net) for the supporting discussions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サポートの議論について、Michael J. Slifcak（mslifcak@iss.net）に感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="16--References">
16. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. 参考文献
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ASN.1] Information processing systems - Open Systems Interconnection, &#34;Specification of Abstract Syntax Notation One (ASN.1)&#34;, International Organization for Standardization, International Standard 8824, December 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ASN.1]情報処理システム - オープンシステムの相互接続、「抽象的構文表記1（ASN.1）の仕様」、国際標準化機関、国際標準8824、1987年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BER] Information Processing Systems - Open Systems Interconnection - &#34;Specification of Basic Encoding Rules for Abstract Notation One (ASN.1)&#34;, International Organization for Standardization, International Standard 8825-1, December 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BER]情報処理システム - オープンシステムの相互接続 - 「抽象表記1（ASN.1）の基本エンコードルールの仕様」、国際標準化機関、国際標準8825-1、1987年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DEFLATE] Deutsch, P., &#34;DEFLATE Compressed Data Format Specification version 1.3&#34;, RFC 1951, May 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DEFLATE] Deutsch、P。、「Deflate圧縮データ形式仕様バージョン1.3」、RFC 1951、1996年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IANA] Internet Assigned Numbers Authority, http://www.iana.org/numbers.htm
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IANA]インターネットが割り当てられた数字の権限、http://www.iana.org/numbers.htm
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PER] Information Processing Systems - Open Systems Interconnection -&#34;Specification of Packed Encoding Rules for Abstract Syntax Notation One (ASN.1)&#34;, International Organization for Standardization, International Standard 8825-2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PER]情報処理システム - オープンシステムの相互接続 - 「抽象的構文表記1（ASN.1）のための詰め込まれたエンコードルールの仕様」、国際標準化機関、国際標準8825-2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UCS] ISO/IEC 10646-1:1993. International Standard -- Information technology -- Universal Multiple-Octet Coded Character Set (UCS)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UCS] ISO/IEC 10646-1：1993。国際標準 - 情報技術 - ユニバーサルマルチオクテットコード化された文字セット（UCS）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UTF8] Yergeau, F., &#34;UTF-8, a transformation format of ISO 10646&#34;, RFC 2279, January 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UTF8] Yergeau、F。、「UTF-8、ISO 10646の変換形式」、RFC 2279、1998年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="17--Full-Copyright-Statement">
17. Full Copyright Statement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. 完全な著作権声明
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2001). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）The Internet Society（2001）。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書と本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFCエディター機能の資金は現在、インターネット協会によって提供されています。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
