<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 4251 - The Secure Shell (SSH) Protocol Architecture 日本語訳</title>
  <meta name="description" content="RFC 4251は、セキュアシェル（SSH）プロトコルアーキテクチャに関する文書で、SSHプロトコルの概要、用語、アーキテクチャ、およびプロトコルの構成要素を定義しています。SSHは、ネットワーク上で安全なリモートログインやその他の安全なネットワークサービスを提供するために広く利用されています。このRFCは、SSHプロトコルファミリーの基礎となるもので、関連するRFCにはRFC 4252（SSH認証プロトコル）、RFC 4253（SSHトランスポート層プロトコル）、RFC 4254（SSH接続プロトコル）などがあります。これらの文書は、SSHプロトコルの詳細な仕様と実装ガイドラインを提供します。">
  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="./master.css">
  <script src="./index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">4251</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc4251">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 4251 - The Secure Shell (SSH) Protocol Architecture 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc4251">
            https://datatracker.ietf.org/doc/html/rfc4251
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 4251 - セキュアシェル（SSH）プロトコルアーキテクチャ</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <p class="card-text">[要約] RFC 4251は、セキュアシェル（SSH）プロトコルアーキテクチャに関する文書で、SSHプロトコルの概要、用語、アーキテクチャ、およびプロトコルの構成要素を定義しています。SSHは、ネットワーク上で安全なリモートログインやその他の安全なネットワークサービスを提供するために広く利用されています。このRFCは、SSHプロトコルファミリーの基礎となるもので、関連するRFCにはRFC 4252（SSH認証プロトコル）、RFC 4253（SSHトランスポート層プロトコル）、RFC 4254（SSH接続プロトコル）などがあります。これらの文書は、SSHプロトコルの詳細な仕様と実装ガイドラインを提供します。</p>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                          T. Ylonen
Request for Comments: 4251              SSH Communications Security Corp
Category: Standards Track                                C. Lonvick, Ed.
                                                     Cisco Systems, Inc.
                                                            January 2006
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
The Secure Shell (SSH) Protocol Architecture
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
セキュアシェル（SSH）プロトコルアーキテクチャ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2006).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（C）The Internet Society（2006）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Secure Shell (SSH) Protocol is a protocol for secure remote login and other secure network services over an insecure network. This document describes the architecture of the SSH protocol, as well as the notation and terminology used in SSH protocol documents. It also discusses the SSH algorithm naming system that allows local extensions. The SSH protocol consists of three major components: The Transport Layer Protocol provides server authentication, confidentiality, and integrity with perfect forward secrecy. The User Authentication Protocol authenticates the client to the server. The Connection Protocol multiplexes the encrypted tunnel into several logical channels. Details of these protocols are described in separate documents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュアシェル（SSH）プロトコルは、安全でないリモートログインや、安全でないネットワークを介したその他の安全なネットワークサービスのためのプロトコルです。このドキュメントでは、SSHプロトコルのアーキテクチャと、SSHプロトコルドキュメントで使用されている表記法および用語について説明します。また、ローカル拡張を可能にするSSHアルゴリズムの命名システムについても説明します。 SSHプロトコルは、次の3つの主要コンポーネントで構成されています。トランスポート層プロトコルは、サーバー認証、機密性、および完全性転送完全性を備えた整合性を提供します。ユーザー認証プロトコルは、サーバーに対してクライアントを認証します。接続プロトコルは、暗号化されたトンネルをいくつかの論理チャネルに多重化します。これらのプロトコルの詳細は、別のドキュメントで説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................3
   2. Contributors ....................................................3
   3. Conventions Used in This Document ...............................4
   4. Architecture ....................................................4
      4.1. Host Keys ..................................................4
      4.2. Extensibility ..............................................6
      4.3. Policy Issues ..............................................6
      4.4. Security Properties ........................................7
      4.5. Localization and Character Set Support .....................7
   5. Data Type Representations Used in the SSH Protocols .............8
   6. Algorithm and Method Naming ....................................10
   7. Message Numbers ................................................11
   8. IANA Considerations ............................................12
   9. Security Considerations ........................................13
      9.1. Pseudo-Random Number Generation ...........................13
      9.2. Control Character Filtering ...............................14
      9.3. Transport .................................................14
           9.3.1. Confidentiality ....................................14
           9.3.2. Data Integrity .....................................16
           9.3.3. Replay .............................................16
           9.3.4. Man-in-the-middle ..................................17
           9.3.5. Denial of Service ..................................19
           9.3.6. Covert Channels ....................................20
           9.3.7. Forward Secrecy ....................................20
           9.3.8. Ordering of Key Exchange Methods ...................20
           9.3.9. Traffic Analysis ...................................21
      9.4. Authentication Protocol ...................................21
           9.4.1. Weak Transport .....................................21
           9.4.2. Debug Messages .....................................22
           9.4.3. Local Security Policy ..............................22
           9.4.4. Public Key Authentication ..........................23
           9.4.5. Password Authentication ............................23
           9.4.6. Host-Based Authentication ..........................23
      9.5. Connection Protocol .......................................24
           9.5.1. End Point Security .................................24
           9.5.2. Proxy Forwarding ...................................24
           9.5.3. X11 Forwarding .....................................24
   10. References ....................................................26
      10.1. Normative References .....................................26
      10.2. Informative References ...................................26
   Authors&#39; Addresses ................................................29
   Trademark Notice ..................................................29
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Secure Shell (SSH) is a protocol for secure remote login and other secure network services over an insecure network. It consists of three major components:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュアシェル（SSH）は、安全でないリモートログインや、安全でないネットワークを介したその他の安全なネットワークサービスのためのプロトコルです。 3つの主要コンポーネントで構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Transport Layer Protocol [SSH-TRANS] provides server authentication, confidentiality, and integrity. It may optionally also provide compression. The transport layer will typically be run over a TCP/IP connection, but might also be used on top of any other reliable data stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o トランスポート層プロトコル[SSH-TRANS]は、サーバー認証、機密性、および整合性を提供します。オプションで圧縮を提供することもできます。トランスポート層は通常、TCP / IP接続を介して実行されますが、他の信頼できるデータストリームの上で使用することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The User Authentication Protocol [SSH-USERAUTH] authenticates the client-side user to the server. It runs over the transport layer protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ユーザー認証プロトコル[SSH-USERAUTH]は、サーバーに対してクライアント側ユーザーを認証します。トランスポート層プロトコル上で実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Connection Protocol [SSH-CONNECT] multiplexes the encrypted tunnel into several logical channels. It runs over the user authentication protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 接続プロトコル[SSH-CONNECT]は、暗号化されたトンネルをいくつかの論理チャネルに多重化します。ユーザー認証プロトコル上で実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client sends a service request once a secure transport layer connection has been established. A second service request is sent after user authentication is complete. This allows new protocols to be defined and coexist with the protocols listed above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安全なトランスポート層接続が確立されると、クライアントはサービス要求を送信します。ユーザー認証が完了すると、2番目のサービス要求が送信されます。これにより、新しいプロトコルを定義し、上記のプロトコルと共存させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The connection protocol provides channels that can be used for a wide range of purposes. Standard methods are provided for setting up secure interactive shell sessions and for forwarding (&#34;tunneling&#34;) arbitrary TCP/IP ports and X11 connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続プロトコルは、幅広い目的に使用できるチャネルを提供します。安全な対話型シェルセッションを設定し、任意のTCP / IPポートとX11接続を転送（「トンネリング」）するための標準的な方法が提供されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Contributors">
2. Contributors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 貢献者
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The major original contributors of this set of documents have been: Tatu Ylonen, Tero Kivinen, Timo J. Rinne, Sami Lehtinen (all of SSH Communications Security Corp), and Markku-Juhani O. Saarinen (University of Jyvaskyla). Darren Moffat was the original editor of this set of documents and also made very substantial contributions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントセットの主要な元の貢献者は、Tatu Ylonen、Tero Kivinen、Timo J. Rinne、Sami Lehtinen（SSH Communications Security Corpのすべて）、およびMarkku-Juhani O. Saarinen（Jyvaskyla大学）です。ダレンモファットは、この一連のドキュメントの最初の編集者であり、非常に大きな貢献もしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many people contributed to the development of this document over the years. People who should be acknowledged include Mats Andersson, Ben Harris, Bill Sommerfeld, Brent McClure, Niels Moller, Damien Miller, Derek Fawcus, Frank Cusack, Heikki Nousiainen, Jakob Schlyter, Jeff Van Dyke, Jeffrey Altman, Jeffrey Hutzelman, Jon Bright, Joseph Galbraith, Ken Hornstein, Markus Friedl, Martin Forssen, Nicolas Williams, Niels Provos, Perry Metzger, Peter Gutmann, Simon Josefsson, Simon Tatham, Wei Dai, Denis Bider, der Mouse, and Tadayoshi Kohno. Listing their names here does not mean that they endorse this document, but that they have contributed to it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの開発には、長年にわたって多くの人々が貢献してくれました。認められるべき人には、マット・アンダーソン、ベン・ハリス、ビル・ソマーフェルト、ブレント・マクルーア、ニールス・モラー、ダミアン・ミラー、デレク・フォーカス、フランク・カザック、ヘイッキ・ノイシャイネン、ジェイコブ・シュリター、ジェフ・ヴァン・ダイク、ジェフリー・アルトマン、ジェフリー・ハッツェルマン、ジョン・ブライト、ジョセフガルブレイス、ケンホーンスタイン、マーカスフリードル、マーティンフォーセン、ニコラスウィリアムズ、ニールスプロボス、ペリーメッツガー、ピーターグトマン、サイモンジョセフソン、サイモンタサム、ウェイダイ、デニスビダー、マウス、デアマウス、河野忠義。ここに彼らの名前をリストすることは、彼らがこの文書を支持することを意味するのではなく、彼らがそれに貢献したことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Conventions-Used-in-This-Document">
3. Conventions Used in This Document
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. このドキュメントで使用される規則
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All documents related to the SSH protocols shall use the keywords &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; to describe requirements. These keywords are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSHプロトコルに関連するすべてのドキュメントは、キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」を使用するものとします。要件を説明する「オプション」。これらのキーワードは、[RFC2119]で説明されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The keywords &#34;PRIVATE USE&#34;, &#34;HIERARCHICAL ALLOCATION&#34;, &#34;FIRST COME FIRST SERVED&#34;, &#34;EXPERT REVIEW&#34;, &#34;SPECIFICATION REQUIRED&#34;, &#34;IESG APPROVAL&#34;, &#34;IETF CONSENSUS&#34;, and &#34;STANDARDS ACTION&#34; that appear in this document when used to describe namespace allocation are to be interpreted as described in [RFC2434].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントに表示されるキーワード「プライベート使用」、「階層割り当て」、「ファーストカムファーストサーブド」、「エキスパートレビュー」、「仕様が必要」、「IESG承認」、「IETFコンセンサス」、および「標準アクション」名前空間の割り当てを説明するために使用されるものは、[RFC2434]で説明されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Protocol fields and possible values to fill them are defined in this set of documents. Protocol fields will be defined in the message definitions. As an example, SSH_MSG_CHANNEL_DATA is defined as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルフィールドと、フィールドに入力できる値は、この一連のドキュメントで定義されています。プロトコルフィールドはメッセージ定義で定義されます。例として、SSH_MSG_CHANNEL_DATAは次のように定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
byte SSH_MSG_CHANNEL_DATA uint32 recipient channel string data
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
バイトSSH_MSG_CHANNEL_DATA uint32受信者チャネル文字列データ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Throughout these documents, when the fields are referenced, they will appear within single quotes. When values to fill those fields are referenced, they will appear within double quotes. Using the above example, possible values for &#39;data&#39; are &#34;foo&#34; and &#34;bar&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのドキュメント全体で、フィールドが参照されている場合、フィールドは一重引用符で囲まれています。それらのフィールドを満たす値が参照される場合、それらは二重引用符で囲まれて表示されます。上記の例を使用すると、「data」の可能な値は「foo」と「bar」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Architecture">
4. Architecture
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 建築
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--Host-Keys">
4.1. Host Keys
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. ホストキー
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each server host SHOULD have a host key. Hosts MAY have multiple host keys using multiple different algorithms. Multiple hosts MAY share the same host key. If a host has keys at all, it MUST have at least one key that uses each REQUIRED public key algorithm (DSS [FIPS-186-2]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各サーバーホストにはホストキーが必要です（SHOULD）。ホストは、複数の異なるアルゴリズムを使用して複数のホストキーを持っている場合があります。複数のホストが同じホストキーを共有する場合があります。ホストに鍵がある場合、ホストには、それぞれの必須の公開鍵アルゴリズム（DSS [FIPS-186-2]）を使用する少なくとも1つの鍵が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server host key is used during key exchange to verify that the client is really talking to the correct server. For this to be possible, the client must have a priori knowledge of the server&#39;s public host key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーホストキーは、クライアントが実際に正しいサーバーと通信していることを確認するために、キー交換中に使用されます。これを可能にするには、クライアントはサーバーの公開ホストキーについて事前に知っている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two different trust models can be used:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つの異なる信頼モデルを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client has a local database that associates each host name (as typed by the user) with the corresponding public host key. This method requires no centrally administered infrastructure, and no third-party coordination. The downside is that the database of name-to-key associations may become burdensome to maintain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントには、各ホスト名（ユーザーが入力したもの）を対応する公開ホストキーに関連付けるローカルデータベースがあります。この方法では、集中管理されたインフラストラクチャやサードパーティの調整は必要ありません。欠点は、名前とキーの関連付けのデータベースを維持するのが面倒になることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The host name-to-key association is certified by a trusted certification authority (CA). The client only knows the CA root key, and can verify the validity of all host keys certified by accepted CAs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ホスト名とキーの関連付けは、信頼された証明機関（CA）によって証明されています。クライアントはCAルートキーだけを知っており、承認されたCAによって認証されたすべてのホストキーの有効性を確認できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second alternative eases the maintenance problem, since ideally only a single CA key needs to be securely stored on the client. On the other hand, each host key must be appropriately certified by a central authority before authorization is possible. Also, a lot of trust is placed on the central infrastructure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つ目の方法では、クライアントに安全に格納する必要があるのは1つのCAキーだけなので、メンテナンスの問題が軽減されます。一方、各ホストキーは、認証が可能になる前に中央機関によって適切に認証される必要があります。また、中央のインフラストラクチャには多くの信頼が置かれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol provides the option that the server name - host key association is not checked when connecting to the host for the first time. This allows communication without prior communication of host keys or certification. The connection still provides protection against passive listening; however, it becomes vulnerable to active man-in-the-middle attacks. Implementations SHOULD NOT normally allow such connections by default, as they pose a potential security problem. However, as there is no widely deployed key infrastructure available on the Internet at the time of this writing, this option makes the protocol much more usable during the transition time until such an infrastructure emerges, while still providing a much higher level of security than that offered by older solutions (e.g., telnet [RFC0854] and rlogin [RFC1282]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルは、初めてホストに接続するときにサーバー名とホストキーの関連付けをチェックしないというオプションを提供します。これにより、事前のホストキーや認証の伝達なしに通信できます。接続は、パッシブリスニングに対する保護を提供します。ただし、アクティブな中間者攻撃に対して脆弱になります。実装は、潜在的なセキュリティ問題を引き起こすので、通常、デフォルトでそのような接続を許可しないでください。ただし、この記事の執筆時点ではインターネット上に広く展開されている主要なインフラストラクチャは存在しないため、このオプションを選択すると、移行期間中、このようなインフラストラクチャが出現するまでの間、プロトコルがより使いやすくなり、それよりもはるかに高いレベルのセキュリティが提供されます古いソリューション（telnet [RFC0854]やrlogin [RFC1282]など）によって提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations SHOULD try to make the best effort to check host keys. An example of a possible strategy is to only accept a host key without checking the first time a host is connected, save the key in a local database, and compare against that key on all future connections to that host.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、ホストキーをチェックするために最善の努力をする必要があります。可能な戦略の例としては、ホストが初めて接続されたときにチェックせずにホストキーのみを受け入れ、ローカルデータベースにキーを保存し、そのホストへの今後のすべての接続でそのキーと比較することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations MAY provide additional methods for verifying the correctness of host keys, e.g., a hexadecimal fingerprint derived from the SHA-1 hash [FIPS-180-2] of the public key. Such fingerprints can easily be verified by using telephone or other external communication channels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、ホスト鍵の正当性を検証するための追加の方法、たとえば、公開鍵のSHA-1ハッシュ[FIPS-180-2]から派生した16進数のフィンガープリントを提供する場合があります。このような指紋は、電話またはその他の外部通信チャネルを使用して簡単に確認できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All implementations SHOULD provide an option not to accept host keys that cannot be verified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての実装は、検証できないホストキーを受け入れないオプションを提供する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The members of this Working Group believe that &#39;ease of use&#39; is critical to end-user acceptance of security solutions, and no improvement in security is gained if the new solutions are not used. Thus, providing the option not to check the server host key is believed to improve the overall security of the Internet, even though it reduces the security of the protocol in configurations where it is allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このワーキンググループのメンバーは、エンドユーザーがセキュリティソリューションを受け入れるためには「使いやすさ」が重要であり、新しいソリューションを使用しないとセキュリティの向上は得られないと考えています。したがって、サーバーのホストキーをチェックしないオプションを提供すると、許可されている構成ではプロトコルのセキュリティが低下しますが、インターネットの全体的なセキュリティが向上すると考えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2--Extensibility">
4.2. Extensibility
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. 拡張性
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We believe that the protocol will evolve over time, and some organizations will want to use their own encryption, authentication, and/or key exchange methods. Central registration of all extensions is cumbersome, especially for experimental or classified features. On the other hand, having no central registration leads to conflicts in method identifiers, making interoperability difficult.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルは時間とともに進化し、一部の組織では独自の暗号化、認証、および/または鍵交換方法を使用したいと考えています。すべての拡張機能の集中登録は、特に実験的機能または分類された機能の場合、面倒です。一方、中央登録がないと、メソッド識別子の競合が発生し、相互運用性が難しくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We have chosen to identify algorithms, methods, formats, and extension protocols with textual names that are of a specific format. DNS names are used to create local namespaces where experimental or classified extensions can be defined without fear of conflicts with other implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定の形式のテキスト名を使用して、アルゴリズム、メソッド、形式、および拡張プロトコルを識別することを選択しました。 DNS名は、他の実装との競合を恐れずに実験的または分類された拡張を定義できるローカル名前空間を作成するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One design goal has been to keep the base protocol as simple as possible, and to require as few algorithms as possible. However, all implementations MUST support a minimal set of algorithms to ensure interoperability (this does not imply that the local policy on all hosts would necessarily allow these algorithms). The mandatory algorithms are specified in the relevant protocol documents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
設計目標の1つは、基本プロトコルをできるだけシンプルに保ち、必要なアルゴリズムをできるだけ少なくすることです。ただし、すべての実装は相互運用性を保証するために最小限のアルゴリズムのセットをサポートする必要があります（これは、すべてのホストのローカルポリシーがこれらのアルゴリズムを必ずしも許可することを意味しません）。必須アルゴリズムは、関連するプロトコルドキュメントで指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional algorithms, methods, formats, and extension protocols can be defined in separate documents. See Section 6, Algorithm Naming, for more information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追加のアルゴリズム、メソッド、フォーマット、および拡張プロトコルは、個別のドキュメントで定義できます。詳細については、セクション6「アルゴリズムの命名」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3--Policy-Issues">
4.3. Policy Issues
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. ポリシーの問題
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol allows full negotiation of encryption, integrity, key exchange, compression, and public key algorithms and formats. Encryption, integrity, public key, and compression algorithms can be different for each direction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルにより、暗号化、整合性、鍵交換、圧縮、公開鍵のアルゴリズムと形式の完全なネゴシエーションが可能になります。暗号化、整合性、公開鍵、および圧縮アルゴリズムは、方向ごとに異なる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following policy issues SHOULD be addressed in the configuration mechanisms of each implementation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のポリシーの問題は、各実装の構成メカニズムで対処する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Encryption, integrity, and compression algorithms, separately for each direction. The policy MUST specify which is the preferred algorithm (e.g., the first algorithm listed in each category).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 暗号化、整合性、および圧縮アルゴリズム。方向ごとに個別に。ポリシーでは、どちらが優先アルゴリズムであるかを指定する必要があります（たとえば、各カテゴリにリストされている最初のアルゴリズム）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Public key algorithms and key exchange method to be used for host authentication. The existence of trusted host keys for different public key algorithms also affects this choice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ホスト認証に使用される公開鍵アルゴリズムと鍵交換方式。さまざまな公開鍵アルゴリズムの信頼できるホスト鍵の存在も、この選択に影響します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The authentication methods that are to be required by the server for each user. The server&#39;s policy MAY require multiple authentication for some or all users. The required algorithms MAY depend on the location from where the user is trying to gain access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーが各ユーザーに要求する認証方法。サーバーのポリシーでは、一部またはすべてのユーザーに対して複数の認証が必要になる場合があります。必要なアルゴリズムは、ユーザーがアクセスを取得しようとしている場所に依存する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The operations that the user is allowed to perform using the connection protocol. Some issues are related to security; for example, the policy SHOULD NOT allow the server to start sessions or run commands on the client machine, and MUST NOT allow connections to the authentication agent unless forwarding such connections has been requested. Other issues, such as which TCP/IP ports can be forwarded and by whom, are clearly issues of local policy. Many of these issues may involve traversing or bypassing firewalls, and are interrelated with the local security policy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ユーザーが接続プロトコルを使用して実行できる操作。一部の問題はセキュリティに関連しています。たとえば、ポリシーはサーバーがクライアントマシンでセッションを開始したりコマンドを実行したりすることを許可してはならず（SHOULD NOT）、認証エージェントへの接続を許可してはなりません（そのような接続の転送が要求されていない場合）。どのTCP / IPポートを転送できるか、誰が転送できるかなどのその他の問題は、ローカルポリシーの問題です。これらの問題の多くは、ファイアウォールの通過またはバイパスを伴う可能性があり、ローカルセキュリティポリシーと相互に関連しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-4--Security-Properties">
4.4. Security Properties
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. セキュリティのプロパティ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The primary goal of the SSH protocol is to improve security on the Internet. It attempts to do this in a way that is easy to deploy, even at the cost of absolute security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSHプロトコルの主な目的は、インターネットのセキュリティを向上させることです。絶対的なセキュリティを犠牲にしても、展開が簡単な方法でこれを試みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o All encryption, integrity, and public key algorithms used are well-known, well-established algorithms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 使用されるすべての暗号化、整合性、および公開鍵アルゴリズムは、よく知られた確立されたアルゴリズムです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o All algorithms are used with cryptographically sound key sizes that are believed to provide protection against even the strongest cryptanalytic attacks for decades.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o すべてのアルゴリズムは、何十年にもわたって最も強力な暗号解読攻撃からの保護を提供すると考えられている暗号的に健全な鍵サイズで使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o All algorithms are negotiated, and in case some algorithm is broken, it is easy to switch to some other algorithm without modifying the base protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o すべてのアルゴリズムがネゴシエートされ、一部のアルゴリズムが壊れた場合でも、基本プロトコルを変更せずに他のアルゴリズムに簡単に切り替えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specific concessions were made to make widespread, fast deployment easier. The particular case where this comes up is verifying that the server host key really belongs to the desired host; the protocol allows the verification to be left out, but this is NOT RECOMMENDED. This is believed to significantly improve usability in the short term, until widespread Internet public key infrastructures emerge.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
広範で迅速な導入を容易にするために、特定の譲歩が行われました。これが発生する特定のケースは、サーバーホストキーが実際に目的のホストに属していることを確認することです。プロトコルでは検証を省略できますが、これは推奨されません。これにより、広範囲にわたるインターネット公開鍵インフラストラクチャが出現するまで、短期的には使いやすさが大幅に向上すると考えられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-5--Localization-and-Character-Set-Support">
4.5. Localization and Character Set Support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. ローカリゼーションと文字セットのサポート
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the most part, the SSH protocols do not directly pass text that would be displayed to the user. However, there are some places where such data might be passed. When applicable, the character set for the data MUST be explicitly specified. In most places, ISO-10646 UTF-8 encoding is used [RFC3629]. When applicable, a field is also provided for a language tag [RFC3066].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ほとんどの場合、SSHプロトコルは、ユーザーに表示されるテキストを直接渡しません。ただし、そのようなデータが渡される可能性のある場所がいくつかあります。該当する場合、データの文字セットを明示的に指定する必要があります。ほとんどの場所で、ISO-10646 UTF-8エンコーディングが使用されます[RFC3629]。該当する場合、言語タグ[RFC3066]のフィールドも提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One big issue is the character set of the interactive session. There is no clear solution, as different applications may display data in different formats. Different types of terminal emulation may also be employed in the client, and the character set to be used is effectively determined by the terminal emulation. Thus, no place is provided for directly specifying the character set or encoding for terminal session data. However, the terminal emulation type (e.g., &#34;vt100&#34;) is transmitted to the remote site, and it implicitly specifies the character set and encoding. Applications typically use the terminal type to determine what character set they use, or the character set is determined using some external means. The terminal emulation may also allow configuring the default character set. In any case, the character set for the terminal session is considered primarily a client local issue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つの大きな問題は、インタラクティブセッションの文字セットです。さまざまなアプリケーションがさまざまな形式でデータを表示する可能性があるため、明確な解決策はありません。異なるタイプの端末エミュレーションもクライアントで使用でき、使用する文字セットは端末エミュレーションによって効果的に決定されます。したがって、端末セッションデータの文字セットまたはエンコーディングを直接指定する場所はありません。ただし、ターミナルエミュレーションタイプ（「vt100」など）はリモートサイトに送信され、文字セットとエンコーディングを暗黙的に指定します。アプリケーションは通常、端末タイプを使用して、使用する文字セットを決定するか、文字セットは何らかの外部手段を使用して決定します。端末エミュレーションでは、デフォルトの文字セットを構成することもできます。いずれの場合も、ターミナルセッションの文字セットは、主にクライアントのローカルの問題と見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Internal names used to identify algorithms or protocols are normally never displayed to users, and must be in US-ASCII.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アルゴリズムまたはプロトコルを識別するために使用される内部名は、通常、ユーザーには表示されず、US-ASCIIである必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client and server user names are inherently constrained by what the server is prepared to accept. They might, however, occasionally be displayed in logs, reports, etc. They MUST be encoded using ISO 10646 UTF-8, but other encodings may be required in some cases. It is up to the server to decide how to map user names to accepted user names. Straight bit-wise, binary comparison is RECOMMENDED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバーのユーザー名は、サーバーが受け入れる準備ができているものによって本質的に制約されます。ただし、ログ、レポートなどに表示される場合があります。ISO10646 UTF-8を使用してエンコードする必要がありますが、場合によっては他のエンコードが必要になることがあります。ユーザー名を受け入れられたユーザー名にマップする方法を決定するのはサーバーです。単純なビット単位のバイナリ比較が推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For localization purposes, the protocol attempts to minimize the number of textual messages transmitted. When present, such messages typically relate to errors, debugging information, or some externally configured data. For data that is normally displayed, it SHOULD be possible to fetch a localized message instead of the transmitted message by using a numerical code. The remaining messages SHOULD be configurable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ローカリゼーションの目的で、プロトコルは送信されるテキストメッセージの数を最小限に抑えようとします。通常、このようなメッセージは、エラー、デバッグ情報、または外部で構成されたデータに関連しています。通常表示されるデータの場合、数値コードを使用して、送信されたメッセージの代わりにローカライズされたメッセージをフェッチできるようにする必要があります。残りのメッセージは構成可能である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Data-Type-Representations-Used-in-the-SSH-Protocols">
5. Data Type Representations Used in the SSH Protocols
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. SSHプロトコルで使用されるデータ型表現
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
byte
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A byte represents an arbitrary 8-bit value (octet). Fixed length data is sometimes represented as an array of bytes, written byte[n], where n is the number of bytes in the array.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1バイトは、任意の8ビット値（オクテット）を表します。固定長データは、byte [n]と記述されたバイトの配列として表される場合があります。nは配列内のバイト数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
boolean
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブール値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A boolean value is stored as a single byte. The value 0 represents FALSE, and the value 1 represents TRUE. All non-zero values MUST be interpreted as TRUE; however, applications MUST NOT store values other than 0 and 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ブール値は1バイトとして格納されます。値0はFALSEを表し、値1はTRUEを表します。ゼロ以外の値はすべてTRUEとして解釈する必要があります。ただし、アプリケーションは0と1以外の値を格納してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint32
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スロベ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Represents a 32-bit unsigned integer. Stored as four bytes in the order of decreasing significance (network byte order). For example: the value 699921578 (0x29b7f4aa) is stored as 29 b7 f4 aa.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
32ビットの符号なし整数を表します。重要度の降順（ネットワークバイト順）で4バイトとして格納されます。たとえば、値699921578（0x29b7f4aa）は29 b7 f4 aaとして格納されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint64
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint64
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Represents a 64-bit unsigned integer. Stored as eight bytes in the order of decreasing significance (network byte order).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
64ビットの符号なし整数を表します。重要度の降順（ネットワークバイト順）で8バイトとして格納されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
string
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Arbitrary length binary string. Strings are allowed to contain arbitrary binary data, including null characters and 8-bit characters. They are stored as a uint32 containing its length (number of bytes that follow) and zero (= empty string) or more bytes that are the value of the string. Terminating null characters are not used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
任意の長さのバイナリ文字列。文字列には、null文字や8ビット文字を含む任意のバイナリデータを含めることができます。それらは、その長さ（後続のバイト数）とゼロ（=空の文字列）以上の文字列の値であるバイトを含むuint32として格納されます。ヌル文字の終了は使用されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Strings are also used to store text. In that case, US-ASCII is used for internal names, and ISO-10646 UTF-8 for text that might be displayed to the user. The terminating null character SHOULD NOT normally be stored in the string. For example: the US-ASCII string &#34;testing&#34; is represented as 00 00 00 07 t e s t i n g. The UTF-8 mapping does not alter the encoding of US-ASCII characters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
文字列はテキストの保存にも使用されます。その場合、US-ASCIIが内部名に使用され、ISO-10646 UTF-8がユーザーに表示されるテキストに使用されます。終端のnull文字は通常、文字列に格納してはいけません（SHOULD NOT）。例：US-ASCII文字列「testing」は00 00 00 07 t e s t i n gとして表されます。 UTF-8マッピングは、US-ASCII文字のエンコーディングを変更しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mpint
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mpint
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Represents multiple precision integers in two&#39;s complement format, stored as a string, 8 bits per byte, MSB first. Negative numbers have the value 1 as the most significant bit of the first byte of the data partition. If the most significant bit would be set for a positive number, the number MUST be preceded by a zero byte. Unnecessary leading bytes with the value 0 or 255 MUST NOT be included. The value zero MUST be stored as a string with zero bytes of data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
多精度整数を2の補数形式で表し、1バイトあたり8ビット、MSBファーストの文字列として格納されます。負の数は、データパーティションの最初のバイトの最上位ビットとして値1を持ちます。最上位ビットが正の数に設定される場合は、数値の前にゼロバイトを付ける必要があります。値0または255の不要な先行バイトを含めてはなりません（MUST NOT）。値0は、0バイトのデータを持つ文字列として格納する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
By convention, a number that is used in modular computations in Z_n SHOULD be represented in the range 0 &lt;= x &lt; n.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
慣例により、Z_nのモジュラー計算で使用される数値は、0 &lt;= x &lt;nの範囲で表す必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Examples:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
例：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         value (hex)        representation (hex)
         -----------        --------------------
         0                  00 00 00 00
         9a378f9b2e332a7    00 00 00 08 09 a3 78 f9 b2 e3 32 a7
         80                 00 00 00 02 00 80
         -1234              00 00 00 02 ed cc
         -deadbeef          00 00 00 05 ff 21 52 41 11
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
name-list
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前リスト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A string containing a comma-separated list of names. A name-list is represented as a uint32 containing its length (number of bytes that follow) followed by a comma-separated list of zero or more names. A name MUST have a non-zero length, and it MUST NOT contain a comma (&#34;,&#34;). As this is a list of names, all of the elements contained are names and MUST be in US-ASCII. Context may impose additional restrictions on the names. For example, the names in a name-list may have to be a list of valid algorithm identifiers (see Section 6 below), or a list of [RFC3066] language tags. The order of the names in a name-list may or may not be significant. Again, this depends on the context in which the list is used. Terminating null characters MUST NOT be used, neither for the individual names, nor for the list as a whole.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
名前のコンマ区切りリストを含む文字列。名前リストは、その長さ（後続のバイト数）とそれに続く0個以上の名前のコンマ区切りリストを含むuint32として表されます。名前の長さはゼロ以外でなければならず、カンマ（ &#34;、&#34;）を含んではいけません。これは名前のリストであるため、含まれているすべての要素は名前であり、US-ASCIIである必要があります。コンテキストにより、名前に追加の制限が課される場合があります。たとえば、名前リストの名前は、有効なアルゴリズム識別子のリスト（下記のセクション6を参照）、または[RFC3066]言語タグのリストである必要がある場合があります。名前リスト内の名前の順序は、重要な場合とそうでない場合があります。繰り返しますが、これはリストが使用されるコンテキストに依存します。個々の名前やリスト全体ではなく、終端のnull文字を使用してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Examples:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
例：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       value                      representation (hex)
       -----                      --------------------
       (), the empty name-list    00 00 00 00
       (&#34;zlib&#34;)                   00 00 00 04 7a 6c 69 62
       (&#34;zlib,none&#34;)              00 00 00 09 7a 6c 69 62 2c 6e 6f 6e 65
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Algorithm-and-Method-Naming">
6. Algorithm and Method Naming
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. アルゴリズムとメソッドの命名
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SSH protocols refer to particular hash, encryption, integrity, compression, and key exchange algorithms or methods by name. There are some standard algorithms and methods that all implementations MUST support. There are also algorithms and methods that are defined in the protocol specification, but are OPTIONAL. Furthermore, it is expected that some organizations will want to use their own algorithms or methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSHプロトコルは、特定のハッシュ、暗号化、整合性、圧縮、および鍵交換アルゴリズムまたはメソッドを名前で参照します。すべての実装がサポートしなければならない標準のアルゴリズムとメソッドがいくつかあります。プロトコル仕様で定義されているがオプションのアルゴリズムとメソッドもあります。さらに、一部の組織は独自のアルゴリズムまたはメソッドを使用することを望んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this protocol, all algorithm and method identifiers MUST be printable US-ASCII, non-empty strings no longer than 64 characters. Names MUST be case-sensitive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルでは、すべてのアルゴリズムとメソッドの識別子は、印刷可能なUS-ASCIIであり、64文字以下の空でない文字列である必要があります。名前は大文字と小文字を区別する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two formats for algorithm and method names:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アルゴリズム名とメソッド名には2つの形式があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Names that do not contain an at-sign (&#34;@&#34;) are reserved to be assigned by IETF CONSENSUS. Examples include &#34;3des-cbc&#34;, &#34;sha-1&#34;, &#34;hmac-sha1&#34;, and &#34;zlib&#34; (the doublequotes are not part of the name). Names of this format are only valid if they are first registered with the IANA. Registered names MUST NOT contain an at-sign (&#34;@&#34;), comma (&#34;,&#34;), whitespace, control characters (ASCII codes 32 or less), or the ASCII code 127 (DEL). Names are case-sensitive, and MUST NOT be longer than 64 characters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o アットマーク（ &#34;@&#34;）を含まない名前は、IETF CONSENSUSによって割り当てられるように予約されています。例には、「3des-cbc」、「sha-1」、「hmac-sha1」、および「zlib」が含まれます（二重引用符は名前の一部ではありません）。この形式の名前は、IANAに最初に登録された場合にのみ有効です。登録名には、アットマーク（ &#34;@&#34;）、コンマ（ &#34;、&#34;）、空白、制御文字（ASCIIコード32以下）、またはASCIIコード127（DEL）を含めてはなりません（MUST NOT）。名前は大文字と小文字が区別され、64文字以下にする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Anyone can define additional algorithms or methods by using names in the format name@domainname, e.g., &#34;ourcipher-cbc@example.com&#34;. The format of the part preceding the at-sign is not specified; however, these names MUST be printable US-ASCII strings, and MUST NOT contain the comma character (&#34;,&#34;), whitespace, control characters (ASCII codes 32 or less), or the ASCII code 127 (DEL). They MUST have only a single at-sign in them. The part following the at-sign MUST be a valid, fully qualified domain name [RFC1034] controlled by the person or organization defining the name. Names are case-sensitive, and MUST NOT be longer than 64 characters. It is up to each domain how it manages its local namespace. It should be noted that these names resemble STD 11 [RFC0822] email addresses. This is purely coincidental and has nothing to do with STD 11 [RFC0822].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「ourcipher-cbc@example.com」のように、名前@ドメイン名の形式の名前を使用して、誰でも追加のアルゴリズムまたはメソッドを定義できます。アットマークの前の部分の形式は指定されていません。ただし、これらの名前は印刷可能なUS-ASCII文字列である必要があり、カンマ文字（ &#34;、&#34;）、空白、制御文字（ASCIIコード32以下）、またはASCIIコード127（DEL）を含めることはできません。彼らはそれらに単一のアットサインのみを持たなければなりません。アットマークに続く部分は、名前を定義する人または組織によって制御される有効な完全修飾ドメイン名[RFC1034]である必要があります。名前は大文字と小文字が区別され、64文字以下にする必要があります。ローカル名前空間をどのように管理するかは、各ドメイン次第です。これらの名前はSTD 11 [RFC0822]の電子メールアドレスに似ていることに注意してください。これはまったくの偶然であり、STD 11 [RFC0822]とは関係ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Message-Numbers">
7. Message Numbers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. メッセージ番号
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSH packets have message numbers in the range 1 to 255. These numbers have been allocated as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSHパケットには、1〜255の範囲のメッセージ番号があります。これらの番号は、次のように割り当てられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transport layer protocol:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランスポート層プロトコル：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1 to 19 Transport layer generic (e.g., disconnect, ignore, debug, etc.) 20 to 29 Algorithm negotiation 30 to 49 Key exchange method specific (numbers can be reused for different authentication methods)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1から19トランスポート層の汎用（切断、無視、デバッグなど）20から29アルゴリズムのネゴシエーション30から49鍵交換方法固有（番号はさまざまな認証方法に再利用できます）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
User authentication protocol:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザー認証プロトコル：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
50 to 59 User authentication generic 60 to 79 User authentication method specific (numbers can be reused for different authentication methods)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
50から59ユーザー認証汎用60から79ユーザー認証方法固有（数値は異なる認証方法に再利用できます）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Connection protocol:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続プロトコル：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
80 to 89 Connection protocol generic 90 to 127 Channel related messages
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
80〜89接続プロトコルの一般的な90〜127チャネル関連のメッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reserved for client protocols:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントプロトコル用に予約済み：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
128 to 191 Reserved
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
128〜191予約済み
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Local extensions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ローカル拡張：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
192 to 255 Local extensions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
192〜255ローカル拡張
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--IANA-Considerations">
8. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. IANAに関する考慮事項
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is part of a set. The instructions for the IANA for the SSH protocol, as defined in this document, [SSH-USERAUTH], [SSH-TRANS], and [SSH-CONNECT], are detailed in [SSH-NUMBERS]. The following is a brief summary for convenience, but note well that [SSH-NUMBERS] contains the actual instructions to the IANA, which may be superseded in the future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはセットの一部です。このドキュメントで定義されている、SSHプロトコルのIANAの手順[SSH-USERAUTH]、[SSH-TRANS]、および[SSH-CONNECT]については、[SSH-NUMBERS]で詳しく説明しています。以下は便宜上の簡単な要約ですが、[SSH-NUMBERS]にはIANAへの実際の指示が含まれていることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Allocation of the following types of names in the SSH protocols is assigned by IETF consensus:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSHプロトコルでの次のタイプの名前の割り当ては、IETFコンセンサスによって割り当てられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Service Names * Authentication Methods * Connection Protocol Channel Names * Connection Protocol Global Request Names * Connection Protocol Channel Request Names
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サービス名*認証方法*接続プロトコルのチャネル名*接続プロトコルのグローバル要求名*接続プロトコルのチャネル要求名
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Key Exchange Method Names
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 鍵交換メソッド名
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Assigned Algorithm Names * Encryption Algorithm Names * MAC Algorithm Names * Public Key Algorithm Names * Compression Algorithm Names
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 割り当てられたアルゴリズム名*暗号化アルゴリズム名* MACアルゴリズム名*公開鍵アルゴリズム名*圧縮アルゴリズム名
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These names MUST be printable US-ASCII strings, and MUST NOT contain the characters at-sign (&#34;@&#34;), comma (&#34;,&#34;), whitespace, control characters (ASCII codes 32 or less), or the ASCII code 127 (DEL). Names are case-sensitive, and MUST NOT be longer than 64 characters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの名前は印刷可能なUS-ASCII文字列である必要があり、アットマーク（ &#34;@&#34;）、コンマ（ &#34;、&#34;）、空白、制御文字（ASCIIコード32以下）、またはASCIIコード127（ DEL）。名前は大文字と小文字が区別され、64文字以下にする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Names with the at-sign (&#34;@&#34;) are locally defined extensions and are not controlled by the IANA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アットマーク（ &#34;@&#34;）が付いた名前はローカルで定義された拡張子であり、IANAによって制御されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each category of names listed above has a separate namespace. However, using the same name in multiple categories SHOULD be avoided to minimize confusion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の名前の各カテゴリには、個別の名前空間があります。ただし、混乱を最小限にするために、複数のカテゴリで同じ名前を使用することは避けてください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Message numbers (see Section 7) in the range of 0 to 191 are allocated via IETF CONSENSUS, as described in [RFC2434]. Message numbers in the 192 to 255 range (local extensions) are reserved for PRIVATE USE, also as described in [RFC2434].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2434]で説明されているように、0〜191の範囲のメッセージ番号（セクション7を参照）は、IETF CONSENSUSを介して割り当てられます。 [RFC2434]でも説明されているように、192〜255の範囲（ローカル拡張）のメッセージ番号は、PRIVATE USE用に予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--Security-Considerations">
9. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. セキュリティに関する考慮事項
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to make the entire body of Security Considerations more accessible, Security Considerations for the transport, authentication, and connection documents have been gathered here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティに関する考慮事項全体にアクセスしやすくするために、トランスポート、認証、および接続に関するセキュリティに関する考慮事項がここに集められています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The transport protocol [SSH-TRANS] provides a confidential channel over an insecure network. It performs server host authentication, key exchange, encryption, and integrity protection. It also derives a unique session id that may be used by higher-level protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランスポートプロトコル[SSH-TRANS]は、安全でないネットワーク上で機密チャネルを提供します。サーバーホスト認証、キー交換、暗号化、整合性保護を実行します。また、上位レベルのプロトコルで使用できる一意のセッションIDも取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authentication protocol [SSH-USERAUTH] provides a suite of mechanisms that can be used to authenticate the client user to the server. Individual mechanisms specified in the authentication protocol use the session id provided by the transport protocol and/or depend on the security and integrity guarantees of the transport protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
認証プロトコル[SSH-USERAUTH]は、サーバーに対してクライアントユーザーを認証するために使用できる一連のメカニズムを提供します。認証プロトコルで指定された個々のメカニズムは、トランスポートプロトコルによって提供されるセッションIDを使用するか、トランスポートプロトコルのセキュリティと整合性の保証に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The connection protocol [SSH-CONNECT] specifies a mechanism to multiplex multiple streams (channels) of data over the confidential and authenticated transport. It also specifies channels for accessing an interactive shell, for proxy-forwarding various external protocols over the secure transport (including arbitrary TCP/IP protocols), and for accessing secure subsystems on the server host.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続プロトコル[SSH-CONNECT]は、機密で認証されたトランスポートを介してデータの複数のストリーム（チャネル）を多重化するメカニズムを指定します。また、対話型シェルにアクセスしたり、安全なトランスポート（任意のTCP / IPプロトコルを含む）を介してさまざまな外部プロトコルをプロキシ転送したり、サーバーホスト上の安全なサブシステムにアクセスしたりするためのチャネルも指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-1--Pseudo-Random-Number-Generation">
9.1. Pseudo-Random Number Generation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. 疑似乱数の生成
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This protocol binds each session key to the session by including random, session specific data in the hash used to produce session keys. Special care should be taken to ensure that all of the random numbers are of good quality. If the random data here (e.g., Diffie-Hellman (DH) parameters) are pseudo-random, then the pseudo-random number generator should be cryptographically secure (i.e., its next output not easily guessed even when knowing all previous outputs) and, furthermore, proper entropy needs to be added to the pseudo-random number generator. [RFC4086] offers suggestions for sources of random numbers and entropy. Implementers should note the importance of entropy and the well-meant, anecdotal warning about the difficulty in properly implementing pseudo-random number generating functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルは、セッションキーの生成に使用されるハッシュにランダムなセッション固有のデータを含めることにより、各セッションキーをセッションにバインドします。すべての乱数が高品質になるように、特別な注意を払う必要があります。ここのランダムデータ（Diffie-Hellman（DH）パラメーターなど）が疑似ランダムである場合、疑似乱数ジェネレーターは暗号的に安全でなければなりません（つまり、次の出力は以前のすべての出力を知っていても簡単に推測できません）。さらに、疑似乱数ジェネレータに適切なエントロピーを追加する必要があります。 [RFC4086]は、乱数とエントロピーのソースの提案を提供します。実装者は、エントロピーの重要性と、疑似乱数生成関数を適切に実装することの難しさについての意味のある逸話的な警告に注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The amount of entropy available to a given client or server may sometimes be less than what is required. In this case, one must either resort to pseudo-random number generation regardless of insufficient entropy or refuse to run the protocol. The latter is preferable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のクライアントまたはサーバーで使用できるエントロピーの量は、必要な量よりも少ない場合があります。この場合、不十分なエントロピーに関係なく疑似乱数を生成するか、プロトコルの実行を拒否する必要があります。後者が好ましい。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2--Control-Character-Filtering">
9.2. Control Character Filtering
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. 制御文字フィルタリング
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When displaying text to a user, such as error or debug messages, the client software SHOULD replace any control characters (except tab, carriage return, and newline) with safe sequences to avoid attacks by sending terminal control characters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラーメッセージやデバッグメッセージなどのテキストをユーザーに表示する場合、クライアントソフトウェアは、制御文字（タブ、キャリッジリターン、改行を除く）を安全なシーケンスに置き換えて、端末制御文字を送信することによる攻撃を回避する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3--Transport">
9.3. Transport
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. 輸送
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3-1--Confidentiality">
9.3.1. Confidentiality
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.1. 守秘義務
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is beyond the scope of this document and the Secure Shell Working Group to analyze or recommend specific ciphers other than the ones that have been established and accepted within the industry. At the time of this writing, commonly used ciphers include 3DES, ARCFOUR, twofish, serpent, and blowfish. AES has been published by The US Federal Information Processing Standards as [FIPS-197], and the cryptographic community has accepted AES as well. As always, implementers and users should check current literature to ensure that no recent vulnerabilities have been found in ciphers used within products. Implementers should also check to see which ciphers are considered to be relatively stronger than others and should recommend their use to users over relatively weaker ciphers. It would be considered good form for an implementation to politely and unobtrusively notify a user that a stronger cipher is available and should be used when a weaker one is actively chosen.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
業界内で確立され受け入れられている暗号以外の特定の暗号を分析または推奨することは、このドキュメントおよびSecure Shellワーキンググループの範囲を超えています。この記事の執筆時点で一般的に使用されている暗号には、3DES、ARCFOUR、twofish、serpent、blowfishがあります。 AESは米国連邦情報処理標準によって[FIPS-197]として公開されており、暗号化コミュニティもAESを受け入れています。いつものように、実装者とユーザーは最新の文献をチェックして、製品内で使用される暗号に最近の脆弱性が発見されていないことを確認する必要があります。実装者は、どの暗号が他よりも比較的強力であると見なされるかを確認し、比較的弱い暗号よりもユーザーに使用することを推奨する必要があります。より強力な暗号が利用可能であり、より弱い暗号がアクティブに選択されている場合に使用する必要があることを、実装に対して礼儀正しくかつ控えめに通知することは、実装にとって適切な形式と見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;none&#34; cipher is provided for debugging and SHOULD NOT be used except for that purpose. Its cryptographic properties are sufficiently described in [RFC2410], which will show that its use does not meet the intent of this protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「なし」の暗号はデバッグ用に提供されており、その目的以外では使用しないでください。その暗号特性は[RFC2410]で十分に説明されています、それはその使用がこのプロトコルの意図を満たさないことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The relative merits of these and other ciphers may also be found in current literature. Two references that may provide information on the subject are [SCHNEIER] and [KAUFMAN]. Both of these describe the CBC mode of operation of certain ciphers and the weakness of this scheme. Essentially, this mode is theoretically vulnerable to chosen cipher-text attacks because of the high predictability of the start of packet sequence. However, this attack is deemed difficult and not considered fully practicable, especially if relatively long block sizes are used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの暗号と他の暗号の相対的なメリットも、現在の文献に記載されています。この主題に関する情報を提供する可能性のある2つの参考文献は、[SCHNEIER]と[KAUFMAN]です。これらはどちらも、特定の暗号のCBC操作モードと、この方式の弱点を説明しています。本質的に、このモードは、パケットシーケンスの開始の予測可能性が高いため、選択された暗号文攻撃に対して理論的に脆弱です。ただし、特に比較的長いブロックサイズが使用されている場合、この攻撃は困難であり、完全に実用的であるとは見なされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additionally, another CBC mode attack may be mitigated through the insertion of packets containing SSH_MSG_IGNORE. Without this technique, a specific attack may be successful. For this attack (commonly known as the Rogaway attack [ROGAWAY], [DAI], [BELLARE]) to work, the attacker would need to know the Initialization Vector (IV) of the next block that is going to be encrypted. In CBC mode that is the output of the encryption of the previous block. If the attacker does not have any way to see the packet yet (i.e., it is in the internal buffers of the SSH implementation or even in the kernel), then this attack will not work. If the last packet has been sent out to the network (i.e., the attacker has access to it), then he can use the attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、SSH_MSG_IGNOREを含むパケットを挿入することで、別のCBCモードの攻撃を軽減できます。この手法がなければ、特定の攻撃が成功する可能性があります。この攻撃（一般にRogaway攻撃[ROGAWAY]、[DAI]、[BELLARE]として知られています）が機能するためには、攻撃者は暗号化される次のブロックの初期化ベクトル（IV）を知っている必要があります。 CBCモードでは、前のブロックの暗号化の出力です。攻撃者がまだパケットを見る方法がない場合（つまり、SSH実装の内部バッファー内、またはカーネル内にある場合）、この攻撃は機能しません。最後のパケットがネットワークに送信された場合（つまり、攻撃者がそれにアクセスできる場合）、攻撃を使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the optimal case, an implementer would need to add an extra packet only if the packet has been sent out onto the network and there are no other packets waiting for transmission. Implementers may wish to check if there are any unsent packets awaiting transmission; unfortunately, it is not normally easy to obtain this information from the kernel or buffers. If there are no unsent packets, then a packet containing SSH_MSG_IGNORE SHOULD be sent. If a new packet is added to the stream every time the attacker knows the IV that is supposed to be used for the next packet, then the attacker will not be able to guess the correct IV, thus the attack will never be successful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最適なケースでは、実装者は、パケットがネットワークに送出され、他のパケットが送信を待機していない場合にのみ、追加のパケットを追加する必要があります。実装者は、送信を待っている未送信のパケットがあるかどうかを確認したい場合があります。残念ながら、カーネルやバッファからこの情報を取得することは通常簡単ではありません。未送信のパケットがない場合は、SSH_MSG_IGNOREを含むパケットを送信する必要があります（SHOULD）。攻撃者が次のパケットに使用されるはずのIVを認識するたびに新しいパケットがストリームに追加されると、攻撃者は正しいIVを推測できないため、攻撃は成功しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example, consider the following case:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例として、次のケースを考えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Client                                                  Server
      ------                                                  ------
      TCP(seq=x, len=500)             ----&gt;
       contains Record 1
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-26">
[500 ms passes, no ACK]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-26">
「５００ ｍｓ ぱっせｓ、 の あＣＫ」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      TCP(seq=x, len=1000)            ----&gt;
       contains Records 1,2
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-64">
ACK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-64">
アラス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The Nagle algorithm + TCP retransmits mean that the two records get coalesced into a single TCP segment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Nagleアルゴリズム+ TCP再送信は、2つのレコードが単一のTCPセグメントに結合されることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Record 2 is not at the beginning of the TCP segment and never will be because it gets ACKed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. レコード2はTCPセグメントの先頭ではなく、ACKされるため決してありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Yet, the attack is possible because Record 1 has already been seen.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. しかし、レコード1はすでに確認されているため、攻撃は可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As this example indicates, it is unsafe to use the existence of unflushed data in the TCP buffers proper as a guide to whether an empty packet is needed, since when the second write() is performed the buffers will contain the un-ACKed Record 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例が示すように、2番目のwrite()が実行されるとバッファーにACKされていないレコード1が含まれるため、空のパケットが必要かどうかのガイドとして適切なTCPバッファー内のフラッシュされていないデータの存在を使用するのは安全ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On the other hand, it is perfectly safe to have the following situation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一方、次のような状況が発生しても安全です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Client                                                  Server
      ------                                                  ------
      TCP(seq=x, len=500)             ----&gt;
         contains SSH_MSG_IGNORE
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      TCP(seq=y, len=500)             ----&gt;
         contains Data
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Provided that the IV for the second SSH Record is fixed after the data for the Data packet is determined, then the following should be performed:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
データパケットのデータが決定された後、2番目のSSHレコードのIVが修正された場合、以下を実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
read from user encrypt null packet encrypt data packet
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ユーザーからの読み取りnullパケットの暗号化データパケットの暗号化
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3-2--Data-Integrity">
9.3.2. Data Integrity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.2. データの整合性
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This protocol does allow the Data Integrity mechanism to be disabled. Implementers SHOULD be wary of exposing this feature for any purpose other than debugging. Users and administrators SHOULD be explicitly warned anytime the &#34;none&#34; MAC is enabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルでは、データ整合性メカニズムを無効にすることができます。実装者は、デバッグ以外の目的でこの機能を公開することに注意する必要があります。ユーザーと管理者は、「なし」のMACが有効になっている場合は常に明示的に警告する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So long as the &#34;none&#34; MAC is not used, this protocol provides data integrity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「なし」のMACが使用されない限り、このプロトコルはデータの整合性を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because MACs use a 32-bit sequence number, they might start to leak information after 2**32 packets have been sent. However, following the rekeying recommendations should prevent this attack. The transport protocol [SSH-TRANS] recommends rekeying after one gigabyte of data, and the smallest possible packet is 16 bytes. Therefore, rekeying SHOULD happen after 2**28 packets at the very most.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MACは32ビットのシーケンス番号を使用するため、2 ** 32パケットが送信された後、MACは情報をリークし始める可能性があります。ただし、キー再生成の推奨に従うことで、この攻撃を防ぐことができます。トランスポートプロトコル[SSH-TRANS]では、1ギガバイトのデータの後でキーの再生成を推奨しており、最小のパケットは16バイトです。したがって、鍵の再生成は、せいぜい2 ** 28パケット後に発生する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3-3--Replay">
9.3.3. Replay
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.3. リプレイ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of a MAC other than &#34;none&#34; provides integrity and authentication. In addition, the transport protocol provides a unique session identifier (bound in part to pseudo-random data that is part of the algorithm and key exchange process) that can be used by higher level protocols to bind data to a given session and prevent replay of data from prior sessions. For example, the authentication protocol ([SSH-USERAUTH]) uses this to prevent replay of signatures from previous sessions. Because public key authentication exchanges are cryptographically bound to the session (i.e., to the initial key exchange), they cannot be successfully replayed in other sessions. Note that the session id can be made public without harming the security of the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「なし」以外のMACを使用すると、整合性と認証が提供されます。さらに、トランスポートプロトコルは、特定のセッションにデータをバインドし、データの再生を防ぐために上位レベルのプロトコルで使用できる一意のセッション識別子（アルゴリズムと鍵交換プロセスの一部である疑似ランダムデータに一部バインド）を提供します以前のセッションからのデータ。たとえば、認証プロトコル（[SSH-USERAUTH]）はこれを使用して、以前のセッションからの署名の再生を防ぎます。公開鍵認証交換はセッションに暗号化されて（つまり、最初の鍵交換に）バインドされているため、他のセッションでは正常に再生できません。セッションIDは、プロトコルのセキュリティを損なうことなく公開できることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If two sessions have the same session id (hash of key exchanges), then packets from one can be replayed against the other. It must be stressed that the chances of such an occurrence are, needless to say, minimal when using modern cryptographic methods. This is all the more true when specifying larger hash function outputs and DH parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのセッションが同じセッションID（キー交換のハッシュ）を持っている場合、一方からのパケットを他方に対して再生できます。最新の暗号化方法を使用する場合、言うまでもなく、そのような発生の可能性は最小限であることを強調しなければなりません。これは、より大きなハッシュ関数の出力とDHパラメーターを指定する場合にはなおさら当てはまります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Replay detection using monotonically increasing sequence numbers as input to the MAC, or HMAC in some cases, is described in [RFC2085], [RFC2246], [RFC2743], [RFC1964], [RFC2025], and [RFC4120]. The underlying construct is discussed in [RFC2104]. Essentially, a different sequence number in each packet ensures that at least this one input to the MAC function will be unique and will provide a nonrecurring MAC output that is not predictable to an attacker. If the session stays active long enough, however, this sequence number will wrap. This event may provide an attacker an opportunity to replay a previously recorded packet with an identical sequence number but only if the peers have not rekeyed since the transmission of the first packet with that sequence number. If the peers have rekeyed, then the replay will be detected since the MAC check will fail. For this reason, it must be emphasized that peers MUST rekey before a wrap of the sequence numbers. Naturally, if an attacker does attempt to replay a captured packet before the peers have rekeyed, then the receiver of the duplicate packet will not be able to validate the MAC and it will be discarded. The reason that the MAC will fail is because the receiver will formulate a MAC based upon the packet contents, the shared secret, and the expected sequence number. Since the replayed packet will not be using that expected sequence number (the sequence number of the replayed packet will have already been passed by the receiver), the calculated MAC will not match the MAC received with the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAC、または場合によってはHMACへの入力として単調に増加するシーケンス番号を使用するリプレイ検出は、[RFC2085]、[RFC2246]、[RFC2743]、[RFC1964]、[RFC2025]、および[RFC4120]で説明されています。基礎となる構成は[RFC2104]で説明されています。基本的に、各パケットのシーケンス番号が異なると、少なくともMAC関数へのこの1つの入力が一意になり、攻撃者が予測できない繰り返し発生しないMAC出力が提供されます。ただし、セッションが十分長くアクティブなままの場合、このシーケンス番号は折り返されます。このイベントは、同じシーケンス番号を持つ以前に記録されたパケットを再生する機会を攻撃者に提供する可能性がありますが、そのシーケンス番号を持つ最初のパケットの送信以降、ピアがキーを再生成していない場合のみです。ピアがキーを再生成した場合、MACチェックが失敗するため、リプレイが検出されます。このため、シーケンス番号をラップする前に、ピアがキーを再生成する必要があることを強調する必要があります。当然のことながら、ピアがキーを再生成する前に攻撃者がキャプチャしたパケットを再生しようとした場合、複製パケットの受信者はMACを検証できず、破棄されます。 MACが失敗する理由は、受信者がパケットの内容、共有シークレット、および予期されるシーケンス番号に基づいてMACを作成するためです。リプレイされたパケットはその予期されたシーケンス番号を使用しないため（リプレイされたパケットのシーケンス番号は受信側から既に渡されているため）、計算されたMACはパケットで受信したMACと一致しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3-4--Man-in-the-middle">
9.3.4. Man-in-the-middle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.4. 真ん中の男
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This protocol makes no assumptions or provisions for an infrastructure or means for distributing the public keys of hosts. It is expected that this protocol will sometimes be used without first verifying the association between the server host key and the server host name. Such usage is vulnerable to man-in-the-middle attacks. This section describes this and encourages administrators and users to understand the importance of verifying this association before any session is initiated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルは、ホストの公開鍵を配布するためのインフラストラクチャまたは手段を想定または提供していません。このプロトコルは、最初にサーバーホストキーとサーバーホスト名の関連付けを確認せずに使用されることが予想されます。このような使用法は、中間者攻撃に対して脆弱です。このセクションでは、これについて説明し、セッションを開始する前にこの関連付けを確認することの重要性を理解するよう管理者とユーザーに奨励します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are three cases of man-in-the-middle attacks to consider. The first is where an attacker places a device between the client and the server before the session is initiated. In this case, the attack device is trying to mimic the legitimate server and will offer its public key to the client when the client initiates a session. If it were to offer the public key of the server, then it would not be able to decrypt or sign the transmissions between the legitimate server and the client unless it also had access to the private key of the host. The attack device will also, simultaneously to this, initiate a session to the legitimate server, masquerading itself as the client. If the public key of the server had been securely distributed to the client prior to that session initiation, the key offered to the client by the attack device will not match the key stored on the client. In that case, the user SHOULD be given a warning that the offered host key does not match the host key cached on the client. As described in Section 4.1, the user may be free to accept the new key and continue the session. It is RECOMMENDED that the warning provide sufficient information to the user of the client device so the user may make an informed decision. If the user chooses to continue the session with the stored public key of the server (not the public key offered at the start of the session), then the session-specific data between the attacker and server will be different between the client-to-attacker session and the attacker-to-server sessions due to the randomness discussed above. From this, the attacker will not be able to make this attack work since the attacker will not be able to correctly sign packets containing this session-specific data from the server, since he does not have the private key of that server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考慮すべき中間者攻撃の3つのケースがあります。 1つ目は、セッションが開始される前に、攻撃者がクライアントとサーバーの間にデバイスを置く場所です。この場合、攻撃デバイスは正当なサーバーを模倣しようとしており、クライアントがセッションを開始すると、公開鍵をクライアントに提供します。サーバーの公開鍵を提供する場合、ホストの秘密鍵にもアクセスできない限り、正当なサーバーとクライアント間の伝送を復号化または署名することはできません。攻撃デバイスは、これと同時に、正当なサーバーへのセッションを開始し、自身をクライアントに見せかけます。サーバーの公開鍵がセッションの開始前にクライアントに安全に配布されていた場合、攻撃デバイスによってクライアントに提供された鍵は、クライアントに保存されている鍵と一致しません。その場合、提供されたホストキーがクライアントにキャッシュされたホストキーと一致しないという警告がユーザーに表示される必要があります。セクション4.1で説明したように、ユーザーは自由に新しいキーを受け入れてセッションを続行できます。警告は、クライアントデバイスのユーザーに十分な情報を提供して、ユーザーが十分な情報に基づいて決定できるようにすることをお勧めします。ユーザーがサーバーの保存された公開鍵（セッションの開始時に提供された公開鍵ではない）でセッションを続行することを選択した場合、攻撃者とサーバー間のセッション固有のデータは、クライアントから上で説明したランダム性のため、攻撃者セッションと攻撃者からサーバーへのセッション。これにより、攻撃者はサーバーの秘密キーを持っていないため、サーバーからのこのセッション固有のデータを含むパケットに正しく署名できないため、攻撃者はこの攻撃を機能させることができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second case that should be considered is similar to the first case in that it also happens at the time of connection, but this case points out the need for the secure distribution of server public keys. If the server public keys are not securely distributed, then the client cannot know if it is talking to the intended server. An attacker may use social engineering techniques to pass off server keys to unsuspecting users and may then place a man-in-the-middle attack device between the legitimate server and the clients. If this is allowed to happen, then the clients will form client-to-attacker sessions, and the attacker will form attacker-to-server sessions and will be able to monitor and manipulate all of the traffic between the clients and the legitimate servers. Server administrators are encouraged to make host key fingerprints available for checking by some means whose security does not rely on the integrity of the actual host keys. Possible mechanisms are discussed in Section 4.1 and may also include secured Web pages, physical pieces of paper, etc. Implementers SHOULD provide recommendations on how best to do this with their implementation. Because the protocol is extensible, future extensions to the protocol may provide better mechanisms for dealing with the need to know the server&#39;s host key before connecting. For example, making the host key fingerprint available through a secure DNS lookup, or using Kerberos ([RFC4120]) over GSS-API ([RFC1964]) during key exchange to authenticate the server are possibilities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考慮すべき2番目のケースは、接続時にも発生するという点で1番目のケースと似ていますが、このケースはサーバー公開鍵の安全な配布の必要性を指摘しています。サーバーの公開鍵が安全に配布されていない場合、クライアントは目的のサーバーと通信しているかどうかを知ることができません。攻撃者はソーシャルエンジニアリング技術を使用して、疑いを持たないユーザーにサーバーキーを渡してから、正当なサーバーとクライアントの間にman-in-the-middle攻撃デバイスを配置する可能性があります。これが許可されている場合、クライアントはクライアントから攻撃者へのセッションを形成し、攻撃者は攻撃者からサーバーへのセッションを形成し、クライアントと正当なサーバー間のすべてのトラフィックを監視および操作できるようになります。サーバー管理者は、セキュリティが実際のホストキーの整合性に依存しないなんらかの方法で、ホストキーのフィンガープリントを確認できるようにすることをお勧めします。可能なメカニズムはセクション4.1で説明されており、セキュリティで保護されたWebページ、紙の物理的な断片なども含まれる場合があります。実装者は、実装でこれを行うための最善の方法に関する推奨事項を提供する必要があります。プロトコルは拡張可能であるため、プロトコルの将来の拡張により、接続前にサーバーのホストキーを知る必要性に対処するためのより良いメカニズムが提供される可能性があります。たとえば、安全なDNSルックアップを通じてホストキーフィンガープリントを利用可能にするか、サーバーを認証するためのキー交換中にGSS-API（[RFC1964]）経由でKerberos（[RFC4120]）を使用することが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the third man-in-the-middle case, attackers may attempt to manipulate packets in transit between peers after the session has been established. As described in Section 9.3.3, a successful attack of this nature is very improbable. As in Section 9.3.3, this reasoning does assume that the MAC is secure and that it is infeasible to construct inputs to a MAC algorithm to give a known output. This is discussed in much greater detail in Section 6 of [RFC2104]. If the MAC algorithm has a vulnerability or is weak enough, then the attacker may be able to specify certain inputs to yield a known MAC. With that, they may be able to alter the contents of a packet in transit. Alternatively, the attacker may be able to exploit the algorithm vulnerability or weakness to find the shared secret by reviewing the MACs from captured packets. In either of those cases, an attacker could construct a packet or packets that could be inserted into an SSH stream. To prevent this, implementers are encouraged to utilize commonly accepted MAC algorithms, and administrators are encouraged to watch current literature and discussions of cryptography to ensure that they are not using a MAC algorithm that has a recently found vulnerability or weakness.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3番目のman-in-the-middleのケースでは、攻撃者は、セッションが確立された後、ピア間で転送中のパケットを操作しようと試みる可能性があります。セクション9.3.3で説明されているように、この種の攻撃が成功することはほとんどありません。セクション9.3.3のように、この推論はMACが安全であり、既知の出力を提供するためにMACアルゴリズムへの入力を構成することが実行不可能であることを前提としています。これについては、[RFC2104]のセクション6で詳しく説明しています。 MACアルゴリズムに脆弱性があるか、十分に弱い場合、攻撃者は特定の入力を指定して既知のMACを生成できる可能性があります。これにより、転送中のパケットの内容を変更できる可能性があります。または、攻撃者はアルゴリズムの脆弱性または脆弱性を利用して、キャプチャされたパケットからMACを確認することにより、共有秘密を見つけることができる場合があります。これらのいずれの場合でも、攻撃者はSSHストリームに挿入される可能性のあるパケットを構築する可能性があります。これを防ぐために、実装者は一般に受け入れられているMACアルゴリズムを利用することをお勧めします。管理者は、最新の脆弱性や弱点が見つかったMACアルゴリズムを使用していないことを確認するために、現在の文献と暗号化の議論を監視することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In summary, the use of this protocol without a reliable association of the binding between a host and its host keys is inherently insecure and is NOT RECOMMENDED. However, it may be necessary in non-security-critical environments, and will still provide protection against passive attacks. Implementers of protocols and applications running on top of this protocol should keep this possibility in mind.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要約すると、ホストとそのホストキー間のバインディングを確実に関連付けずにこのプロトコルを使用することは、本質的に安全ではなく、推奨されません。ただし、セキュリティが重要でない環境では必要になる場合があり、パッシブ攻撃に対する保護を提供します。プロトコルおよびこのプロトコル上で実行されるアプリケーションの実装者は、この可能性を覚えておく必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3-5--Denial-of-Service">
9.3.5. Denial of Service
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.5. サービス拒否
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This protocol is designed to be used over a reliable transport. If transmission errors or message manipulation occur, the connection is closed. The connection SHOULD be re-established if this occurs. Denial of service attacks of this type (wire cutter) are almost impossible to avoid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルは、信頼性の高いトランスポートで使用するように設計されています。送信エラーまたはメッセージ操作が発生した場合、接続は閉じられます。これが発生した場合、接続を再確立する必要があります（SHOULD）。このタイプのサービス拒否攻撃（ワイヤーカッター）を回避することはほとんど不可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, this protocol is vulnerable to denial of service attacks because an attacker can force the server to go through the CPU and memory intensive tasks of connection setup and key exchange without authenticating. Implementers SHOULD provide features that make this more difficult, for example, only allowing connections from a subset of clients known to have valid users.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、このプロトコルはサービス拒否攻撃に対して脆弱です。これは、攻撃者が認証せずにサーバーにCPUとメモリを集中的に使用する接続設定とキー交換を通過させるためです。実装者は、これをより困難にする機能を提供する必要があります。たとえば、有効なユーザーがいることがわかっているクライアントのサブセットからの接続のみを許可します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3-6--Covert-Channels">
9.3.6. Covert Channels
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.6. 隠れチャネル
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol was not designed to eliminate covert channels. For example, the padding, SSH_MSG_IGNORE messages, and several other places in the protocol can be used to pass covert information, and the recipient has no reliable way of verifying whether such information is being sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルは、隠れチャネルを排除するようには設計されていません。たとえば、パディング、SSH_MSG_IGNOREメッセージ、およびプロトコルの他のいくつかの場所を使用して秘密情報を渡すことができ、受信者はそのような情報が送信されているかどうかを確認する確実な方法がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3-7--Forward-Secrecy">
9.3.7. Forward Secrecy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.7. 秘密の転送
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be noted that the Diffie-Hellman key exchanges may provide perfect forward secrecy (PFS). PFS is essentially defined as the cryptographic property of a key-establishment protocol in which the compromise of a session key or long-term private key after a given session does not cause the compromise of any earlier session [ANSI-T1.523-2001]. SSH sessions resulting from a key exchange using the diffie-hellman methods described in the section Diffie-Hellman Key Exchange of [SSH-TRANS] (including &#34;diffie-hellman-group1-sha1&#34; and &#34;diffie-hellman-group14-sha1&#34;) are secure even if private keying/authentication material is later revealed, but not if the session keys are revealed. So, given this definition of PFS, SSH does have PFS. However, this property is not commuted to any of the applications or protocols using SSH as a transport. The transport layer of SSH provides confidentiality for password authentication and other methods that rely on secret data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Diffie-Hellman鍵交換は、Perfect Forward Secrecy（PFS）を提供する場合があることに注意してください。 PFSは基本的に、キー確立プロトコルの暗号化プロパティとして定義されています。このプロトコルでは、特定のセッション後のセッションキーまたは長期的な秘密キーの侵害が、以前のセッションの侵害を引き起こさない[ANSI-T1.523-2001] 。 [SSH-TRANS]のDiffie-Hellman鍵交換セクションで説明されているdiffie-hellman方式を使用した鍵交換から生じるSSHセッション（ &#34;diffie-hellman-group1-sha1&#34;と &#34;diffie-hellman-group14-sha1&#34;を含む）秘密鍵/認証情報が後で明らかになったとしても安全ですが、セッション鍵が明らかにされた場合はそうではありません。したがって、このPFSの定義を考えると、SSHにはPFSがあります。ただし、このプロパティは、SSHをトランスポートとして使用するアプリケーションやプロトコルには通用しません。 SSHのトランスポート層は、パスワード認証および秘密データに依存するその他の方法に機密性を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Of course, if the DH private parameters for the client and server are revealed, then the session key is revealed, but these items can be thrown away after the key exchange completes. It&#39;s worth pointing out that these items should not be allowed to end up on swap space and that they should be erased from memory as soon as the key exchange completes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もちろん、クライアントとサーバーのDHプライベートパラメーターが公開されている場合、セッションキーは公開されますが、これらのアイテムはキー交換の完了後に破棄できます。これらのアイテムがスワップスペースに配置されてはならず、キー交換が完了するとすぐにメモリから消去されることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3-8--Ordering-of-Key-Exchange-Methods">
9.3.8. Ordering of Key Exchange Methods
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.8. キー交換メソッドの順序
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As stated in the section on Algorithm Negotiation of [SSH-TRANS], each device will send a list of preferred methods for key exchange. The most-preferred method is the first in the list. It is RECOMMENDED that the algorithms be sorted by cryptographic strength, strongest first. Some additional guidance for this is given in [RFC3766].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SSH-TRANS]のアルゴリズムネゴシエーションのセクションで述べたように、各デバイスはキー交換の優先メソッドのリストを送信します。最も推奨される方法は、リストの最初です。アルゴリズムは、暗号強度で並べ替えることをお勧めします。これに関するいくつかの追加のガイダンスは[RFC3766]で与えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3-9--Traffic-Analysis">
9.3.9. Traffic Analysis
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.9. トラフィック分析
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Passive monitoring of any protocol may give an attacker some information about the session, the user, or protocol specific information that they would otherwise not be able to garner. For example, it has been shown that traffic analysis of an SSH session can yield information about the length of the password - [Openwall] and [USENIX]. Implementers should use the SSH_MSG_IGNORE packet, along with the inclusion of random lengths of padding, to thwart attempts at traffic analysis. Other methods may also be found and implemented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルのパッシブモニタリングにより、攻撃者はセッション、ユーザー、またはプロトコル固有の情報を入手できます。たとえば、SSHセッションのトラフィック分析により、パスワードの長さに関する情報が得られることが示されています-[Openwall]および[USENIX]。実装者はSSH_MSG_IGNOREパケットを使用し、ランダムな長さのパディングを含めることで、トラフィック分析の試行を阻止する必要があります。他の方法を見つけて実装することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-4--Authentication-Protocol">
9.4. Authentication Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4. 認証プロトコル
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The purpose of this protocol is to perform client user authentication. It assumes that this runs over a secure transport layer protocol, which has already authenticated the server machine, established an encrypted communications channel, and computed a unique session identifier for this session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルの目的は、クライアントのユーザー認証を実行することです。これは、サーバーマシンを既に認証し、暗号化された通信チャネルを確立し、このセッションの一意のセッション識別子を計算したセキュアなトランスポート層プロトコル上で実行されることを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Several authentication methods with different security characteristics are allowed. It is up to the server&#39;s local policy to decide which methods (or combinations of methods) it is willing to accept for each user. Authentication is no stronger than the weakest combination allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
異なるセキュリティ特性を持ついくつかの認証方法が許可されています。各ユーザーに対してどのメソッド（またはメソッドの組み合わせ）を受け入れるかを決定するのは、サーバーのローカルポリシーです。認証は、許可されている最も弱い組み合わせよりも強力ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server may go into a sleep period after repeated unsuccessful authentication attempts to make key search more difficult for attackers. Care should be taken so that this doesn&#39;t become a self-denial of service vector.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
認証の試行が繰り返し失敗した後、サーバーがスリープ期間に入り、攻撃者がキー検索を困難にする可能性があります。これがサービス拒否の自己否定にならないように注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-4-1--Weak-Transport">
9.4.1. Weak Transport
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.1. 弱い輸送
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the transport layer does not provide confidentiality, authentication methods that rely on secret data SHOULD be disabled. If it does not provide strong integrity protection, requests to change authentication data (e.g., a password change) SHOULD be disabled to prevent an attacker from modifying the ciphertext without being noticed, or rendering the new authentication data unusable (denial of service).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランスポート層が機密性を提供しない場合は、秘密データに依存する認証方法を無効にする必要があります（SHOULD）。強力な整合性保護を提供しない場合は、認証データを変更するリクエスト（パスワードの変更など）を無効にして、攻撃者が気付かずに暗号文を変更したり、新しい認証データを使用不能（サービス拒否）にしたりしないようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The assumption stated above, that the Authentication Protocol only runs over a secure transport that has previously authenticated the server, is very important to note. People deploying SSH are reminded of the consequences of man-in-the-middle attacks if the client does not have a very strong a priori association of the server with the host key of that server. Specifically, for the case of the Authentication Protocol, the client may form a session to a man-in- the-middle attack device and divulge user credentials such as their username and password. Even in the cases of authentication where no user credentials are divulged, an attacker may still gain information they shouldn&#39;t have by capturing key-strokes in much the same way that a honeypot works.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
認証プロトコルは以前にサーバーを認証した安全なトランスポート上でのみ実行されるという上記の仮定は、注意することが非常に重要です。 SSHを展開する人々は、クライアントがサーバーとそのサーバーのホストキーとのアプリオリな関連付けが非常に強力でない場合、中間者攻撃の結果を思い出します。具体的には、認証プロトコルの場合、クライアントは中間者攻撃デバイスへのセッションを形成し、ユーザー名やパスワードなどのユーザー資格情報を漏らします。ユーザーの資格情報が漏らされない認証の場合でも、ハニーポットが機能するのとほぼ同じ方法でキーストロークをキャプチャすることにより、攻撃者はまだ持っていないはずの情報を入手する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-4-2--Debug-Messages">
9.4.2. Debug Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.2. デバッグメッセージ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Special care should be taken when designing debug messages. These messages may reveal surprising amounts of information about the host if not properly designed. Debug messages can be disabled (during user authentication phase) if high security is required. Administrators of host machines should make all attempts to compartmentalize all event notification messages and protect them from unwarranted observation. Developers should be aware of the sensitive nature of some of the normal event and debug messages, and may want to provide guidance to administrators on ways to keep this information away from unauthorized people. Developers should consider minimizing the amount of sensitive information obtainable by users during the authentication phase, in accordance with the local policies. For this reason, it is RECOMMENDED that debug messages be initially disabled at the time of deployment and require an active decision by an administrator to allow them to be enabled. It is also RECOMMENDED that a message expressing this concern be presented to the administrator of a system when the action is taken to enable debugging messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デバッグメッセージを設計するときは、特別な注意が必要です。これらのメッセージは、適切に設計されていない場合、ホストに関する驚くべき量の情報を明らかにする可能性があります。高度なセキュリティが必要な場合は、デバッグメッセージを無効にできます（ユーザー認証フェーズ中）。ホストマシンの管理者は、すべてのイベント通知メッセージを区分して、不当な監視からメッセージを保護するためのあらゆる試みを行う必要があります。開発者は、一部の通常のイベントおよびデバッグメッセージの機密性を認識している必要があり、権限のない人からこの情報を遠ざける方法について管理者にガイダンスを提供したい場合があります。開発者は、ローカルポリシーに従って、認証フェーズ中にユーザーが取得できる機密情報の量を最小限に抑えることを検討する必要があります。このため、デバッグメッセージは展開時に最初は無効にして、有効にするために管理者が積極的に決定することをお勧めします。また、デバッグメッセージを有効にするアクションが実行されたときに、この懸念を表すメッセージをシステムの管理者に提示することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-4-3--Local-Security-Policy">
9.4.3. Local Security Policy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.3. ローカルセキュリティポリシー
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The implementer MUST ensure that the credentials provided validate the professed user and also MUST ensure that the local policy of the server permits the user the access requested. In particular, because of the flexible nature of the SSH connection protocol, it may not be possible to determine the local security policy, if any, that should apply at the time of authentication because the kind of service being requested is not clear at that instant. For example, local policy might allow a user to access files on the server, but not start an interactive shell. However, during the authentication protocol, it is not known whether the user will be accessing files, attempting to use an interactive shell, or even both. In any event, where local security policy for the server host exists, it MUST be applied and enforced correctly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装者は、提供された資格情報が公言したユーザーを検証することを確認する必要があり、サーバーのローカルポリシーがユーザーに要求されたアクセスを許可することを確認する必要もあります。特に、SSH接続プロトコルには柔軟性があるため、要求されたサービスの種類がその時点で明確でないため、認証時に適用する必要があるローカルセキュリティポリシーを決定することができない場合があります。 。たとえば、ローカルポリシーでは、ユーザーはサーバー上のファイルにアクセスできますが、インタラクティブシェルを開始することはできません。ただし、認証プロトコルの間、ユーザーがファイルにアクセスするか、対話型シェルを使用しようとするか、あるいはその両方であるかは不明です。いずれにしても、サーバーホストのローカルセキュリティポリシーが存在する場合は、それを正しく適用および実施する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementers are encouraged to provide a default local policy and make its parameters known to administrators and users. At the discretion of the implementers, this default policy may be along the lines of anything-goes where there are no restrictions placed upon users, or it may be along the lines of excessively-restrictive, in which case, the administrators will have to actively make changes to the initial default parameters to meet their needs. Alternatively, it may be some attempt at providing something practical and immediately useful to the administrators of the system so they don&#39;t have to put in much effort to get SSH working. Whatever choice is made must be applied and enforced as required above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装者は、デフォルトのローカルポリシーを提供し、そのパラメーターを管理者とユーザーに知らせることをお勧めします。実装者の裁量で、このデフォルトのポリシーは、ユーザーに制限が課されていない場合は何でも、または過度に制限されている場合があります。その場合、管理者は積極的に行う必要があります。必要に応じて、初期デフォルトパラメータを変更します。あるいは、システムの管理者に実用的ですぐに役立つ何かを提供しようとする試みである可能性があるため、SSHを動作させるために多くの労力を費やす必要はありません。上記の必要に応じて、選択した内容を適用して適用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-4-4-Public-Key-Authentication">
9.4.4 Public Key Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.4 公開鍵認証
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of public key authentication assumes that the client host has not been compromised. It also assumes that the private key of the server host has not been compromised.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
公開鍵認証の使用は、クライアントホストが危険にさらされていないことを前提としています。また、サーバーホストの秘密キーが危険にさらされていないことも前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This risk can be mitigated by the use of passphrases on private keys; however, this is not an enforceable policy. The use of smartcards, or other technology to make passphrases an enforceable policy is suggested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このリスクは、秘密鍵にパスフレーズを使用することで軽減できます。ただし、これは強制可能なポリシーではありません。スマートカードまたはその他のテクノロジーを使用してパスフレーズを強制可能なポリシーにすることをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server could require both password and public key authentication; however, this requires the client to expose its password to the server (see the section on Password Authentication below.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、パスワード認証と公開鍵認証の両方を要求できます。ただし、これにはクライアントがサーバーにパスワードを公開する必要があります（以下のパスワード認証のセクションを参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-4-5--Password-Authentication">
9.4.5. Password Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.5. パスワード認証
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The password mechanism, as specified in the authentication protocol, assumes that the server has not been compromised. If the server has been compromised, using password authentication will reveal a valid username/password combination to the attacker, which may lead to further compromises.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
認証プロトコルで指定されているパスワードメカニズムは、サーバーが危険にさらされていないことを前提としています。サーバーが危険にさらされている場合、パスワード認証を使用すると、有効なユーザー名とパスワードの組み合わせが攻撃者に明らかになるため、さらに危険にさらされる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This vulnerability can be mitigated by using an alternative form of authentication. For example, public key authentication makes no assumptions about security on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この脆弱性は、代替の認証形式を使用することで軽減できます。たとえば、公開キー認証では、サーバーのセキュリティについて想定していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-4-6--Host-Based-Authentication">
9.4.6. Host-Based Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.6. ホストベースの認証
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Host-based authentication assumes that the client has not been compromised. There are no mitigating strategies, other than to use host-based authentication in combination with another authentication method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホストベースの認証は、クライアントが危険にさらされていないことを前提としています。ホストベースの認証を別の認証方法と組み合わせて使用​​する以外に、緩和策はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-5--Connection-Protocol">
9.5. Connection Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5. 接続プロトコル
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-5-1--End-Point-Security">
9.5.1. End Point Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5.1. エンドポイントのセキュリティ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
End point security is assumed by the connection protocol. If the server has been compromised, any terminal sessions, port forwarding, or systems accessed on the host are compromised. There are no mitigating factors for this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントのセキュリティは、接続プロトコルによって想定されています。サーバーが危険にさらされている場合、ターミナルセッション、ポート転送、またはホスト上でアクセスされるシステムが危険にさらされます。これを緩和する要素はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client has been compromised, and the server fails to stop the attacker at the authentication protocol, all services exposed (either as subsystems or through forwarding) will be vulnerable to attack. Implementers SHOULD provide mechanisms for administrators to control which services are exposed to limit the vulnerability of other services. These controls might include controlling which machines and ports can be targeted in port-forwarding operations, which users are allowed to use interactive shell facilities, or which users are allowed to use exposed subsystems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが危険にさらされており、サーバーが認証プロトコルでの攻撃者の停止に失敗した場合、（サブシステムとして、または転送によって）公開されたすべてのサービスは、攻撃に対して脆弱になります。実装者は、他のサービスの脆弱性を制限するために公開されるサービスを管理者が制御するためのメカニズムを提供する必要があります（SHOULD）。これらの制御には、ポート転送操作の対象となるマシンやポート、対話型シェル機能の使用を許可するユーザー、公開されたサブシステムの使用を許可するユーザーの制御などがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-5-2--Proxy-Forwarding">
9.5.2. Proxy Forwarding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5.2. プロキシ転送
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SSH connection protocol allows for proxy forwarding of other protocols such as SMTP, POP3, and HTTP. This may be a concern for network administrators who wish to control the access of certain applications by users located outside of their physical location. Essentially, the forwarding of these protocols may violate site-specific security policies, as they may be undetectably tunneled through a firewall. Implementers SHOULD provide an administrative mechanism to control the proxy forwarding functionality so that site-specific security policies may be upheld.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSH接続プロトコルは、SMTP、POP3、HTTPなどの他のプロトコルのプロキシ転送を可能にします。これは、物理的な場所の外にいるユーザーによる特定のアプリケーションへのアクセスを制御することを望むネットワーク管理者にとっては問題になるかもしれません。本質的に、これらのプロトコルの転送は、ファイアウォールを介して検出不能にトンネリングされる可能性があるため、サイト固有のセキュリティポリシーに違反する可能性があります。実装者は、サイト固有のセキュリティポリシーを維持できるように、プロキシ転送機能を制御する管理メカニズムを提供する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, a reverse proxy forwarding functionality is available, which, again, can be used to bypass firewall controls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、リバースプロキシ転送機能も利用できます。これも、ファイアウォール制御をバイパスするために使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As indicated above, end-point security is assumed during proxy forwarding operations. Failure of end-point security will compromise all data passed over proxy forwarding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のように、プロキシ転送操作中はエンドポイントセキュリティが想定されます。エンドポイントセキュリティの失敗は、プロキシ転送を介して渡されるすべてのデータを危険にさらします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-5-3--X11-Forwarding">
9.5.3. X11 Forwarding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5.3. X11転送
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another form of proxy forwarding provided by the SSH connection protocol is the forwarding of the X11 protocol. If end-point security has been compromised, X11 forwarding may allow attacks against the X11 server. Users and administrators should, as a matter of course, use appropriate X11 security mechanisms to prevent unauthorized use of the X11 server. Implementers, administrators, and users who wish to further explore the security mechanisms of X11 are invited to read [SCHEIFLER] and analyze previously reported
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSH接続プロトコルによって提供されるプロキシ転送の別の形式は、X11プロトコルの転送です。エンドポイントのセキュリティが侵害されている場合、X11転送はX11サーバーに対する攻撃を許可する可能性があります。ユーザーと管理者は、当然のことながら、適切なX11セキュリティメカニズムを使用して、X11サーバーの不正使用を防止する必要があります。 X11のセキュリティメカニズムをさらに探求したい実装者、管理者、およびユーザーは、[SCHEIFLER]を読んで、以前に報告されたものを分析することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
problems with the interactions between SSH forwarding and X11 in CERT vulnerabilities VU#363181 and VU#118892 [CERT].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CERT脆弱性VU＃363181およびVU＃118892 [CERT]でのSSH転送とX11間の相互作用に関する問題。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
X11 display forwarding with SSH, by itself, is not sufficient to correct well known problems with X11 security [VENEMA]. However, X11 display forwarding in SSH (or other secure protocols), combined with actual and pseudo-displays that accept connections only over local IPC mechanisms authorized by permissions or access control lists (ACLs), does correct many X11 security problems, as long as the &#34;none&#34; MAC is not used. It is RECOMMENDED that X11 display implementations default to allow the display to open only over local IPC. It is RECOMMENDED that SSH server implementations that support X11 forwarding default to allow the display to open only over local IPC. On single-user systems, it might be reasonable to default to allow the local display to open over TCP/IP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSHを使用したX11ディスプレイ転送だけでは、X11セキュリティのよく知られた問題を修正するには不十分です[VENEMA]。ただし、SSH（または他の安全なプロトコル）でのX11ディスプレイ転送を、アクセス許可またはアクセス制御リスト（ACL）によって承認されたローカルIPCメカニズムを介してのみ接続を受け入れる実際のディスプレイと疑似ディスプレイと組み合わせると、多くのX11セキュリティ問題が修正されます「なし」のMACは使用されません。 X11ディスプレイ実装では、デフォルトでローカルIPC経由でのみディスプレイを開くことができるようにすることをお勧めします。ローカルIPC経由でのみディスプレイを開くことができるように、X11転送のデフォルトをサポートするSSHサーバー実装が推奨されます。シングルユーザーシステムでは、TCP / IPを介してローカルディスプレイを開くことができるようにデフォルト設定するのが妥当かもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementers of the X11 forwarding protocol SHOULD implement the magic cookie access-checking spoofing mechanism, as described in [SSH-CONNECT], as an additional mechanism to prevent unauthorized use of the proxy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
X11転送プロトコルの実装者は、[SSH-CONNECT]で説明されているように、プロキシの不正使用を防ぐための追加のメカニズムとして、マジッククッキーのアクセスチェックスプーフィングメカニズムを実装する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10--References">
10. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 参考文献
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-1--Normative-References">
10.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. 引用文献
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SSH-TRANS] Ylonen, T. and C. Lonvick, Ed., &#34;The Secure Shell (SSH) Transport Layer Protocol&#34;, RFC 4253, January 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SSH-TRANS] Ylonen、T。およびC. Lonvick、編、「The Secure Shell（SSH）Transport Layer Protocol」、RFC 4253、2006年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SSH-USERAUTH] Ylonen, T. and C. Lonvick, Ed., &#34;The Secure Shell (SSH) Authentication Protocol&#34;, RFC 4252, January 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SSH-USERAUTH] Ylonen、T。およびC. Lonvick、編、「The Secure Shell（SSH）Authentication Protocol」、RFC 4252、2006年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SSH-CONNECT] Ylonen, T. and C. Lonvick, Ed., &#34;The Secure Shell (SSH) Connection Protocol&#34;, RFC 4254, January 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SSH-CONNECT] Ylonen、T。およびC. Lonvick、編、「The Secure Shell（SSH）Connection Protocol」、RFC 4254、2006年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SSH-NUMBERS] Lehtinen, S. and C. Lonvick, Ed., &#34;The Secure Shell (SSH) Protocol Assigned Numbers&#34;, RFC 4250, January 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SSH-NUMBERS] Lehtinen、S。およびC. Lonvick、編、「Secure Shell（SSH）Protocol Assigned Numbers」、RFC 4250、2006年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2434] Narten, T. and H. Alvestrand, &#34;Guidelines for Writing an IANA Considerations Section in RFCs&#34;, BCP 26, RFC 2434, October 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2434] Narten、T。およびH. Alvestrand、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 2434、1998年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3066] Alvestrand, H., &#34;Tags for the Identification of Languages&#34;, BCP 47, RFC 3066, January 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3066] Alvestrand、H。、「言語の識別のためのタグ」、BCP 47、RFC 3066、2001年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3629] Yergeau, F., &#34;UTF-8, a transformation format of ISO 10646&#34;, STD 63, RFC 3629, November 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3629] Yergeau、F。、「UTF-8、ISO 10646の変換フォーマット」、STD 63、RFC 3629、2003年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-2--Informative-References">
10.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. 参考引用
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC0822] Crocker, D., &#34;Standard for the format of ARPA Internet text messages&#34;, STD 11, RFC 822, August 1982.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC0822]クロッカーD。、「ARPAインターネットテキストメッセージのフォーマットの標準」、STD 11、RFC 822、1982年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC0854] Postel, J. and J. Reynolds, &#34;Telnet Protocol Specification&#34;, STD 8, RFC 854, May 1983.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC0854] Postel、J。およびJ. Reynolds、「Telnet Protocol Specification」、STD 8、RFC 854、1983年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1034] Mockapetris, P., &#34;Domain names - concepts and facilities&#34;, STD 13, RFC 1034, November 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1034] Mockapetris、P。、「ドメイン名-概念と機能」、STD 13、RFC 1034、1987年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1282] Kantor, B., &#34;BSD Rlogin&#34;, RFC 1282, December 1991.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1282] Office、B。、「BSD Rlogin」、RFC 1282、1991年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4120] Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &#34;The Kerberos Network Authentication Service (V5)&#34;, RFC 4120, July 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4120] Neuman、C.、Yu、T.、Hartman、S。、およびK. Raeburn、「The Kerberos Network Authentication Service（V5）」、RFC 4120、2005年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1964] Linn, J., &#34;The Kerberos Version 5 GSS-API Mechanism&#34;, RFC 1964, June 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1964] Linn、J。、「The Kerberos Version 5 GSS-API Mechanism」、RFC 1964、1996年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2025] Adams, C., &#34;The Simple Public-Key GSS-API Mechanism (SPKM)&#34;, RFC 2025, October 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2025] Adams、C。、「The Simple Public-Key GSS-API Mechanism（SPKM）」、RFC 2025、1996年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2085] Oehler, M. and R. Glenn, &#34;HMAC-MD5 IP Authentication with Replay Prevention&#34;, RFC 2085, February 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2085] Oehler、M。、およびR. Glenn、「HMAC-MD5 IP Authentication with Replay Prevention」、RFC 2085、1997年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, &#34;HMAC: Keyed-Hashing for Message Authentication&#34;, RFC 2104, February 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2104] Krawczyk、H.、Bellare、M。、およびR. Canetti、「HMAC：Keyed-Hashing for Message Authentication」、RFC 2104、1997年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2246] Dierks, T. and C. Allen, &#34;The TLS Protocol Version 1.0&#34;, RFC 2246, January 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2246] Dierks、T。およびC. Allen、「The TLS Protocol Version 1.0」、RFC 2246、1999年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2410] Glenn, R. and S. Kent, &#34;The NULL Encryption Algorithm and Its Use With IPsec&#34;, RFC 2410, November 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2410] Glenn、R。およびS. Kent、「NULL暗号化アルゴリズムとIPsecでのその使用」、RFC 2410、1998年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2743] Linn, J., &#34;Generic Security Service Application Program Interface Version 2, Update 1&#34;, RFC 2743, January 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2743] Linn、J。、「Generic Security Service Application Program Interface Version 2、Update 1」、RFC 2743、2000年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3766] Orman, H. and P. Hoffman, &#34;Determining Strengths For Public Keys Used For Exchanging Symmetric Keys&#34;, BCP 86, RFC 3766, April 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3766]オーマン、H。、およびP.ホフマン、「対称鍵の交換に使用される公開鍵の強度の決定」、BCP 86、RFC 3766、2004年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4086] Eastlake, D., 3rd, Schiller, J., and S. Crocker, &#34;Randomness Requirements for Security&#34;, BCP 106, RFC 4086, June 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4086] Eastlake、D.、3rd、Schiller、J。、およびS. Crocker、「Randomness Requirements for Security」、BCP 106、RFC 4086、2005年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FIPS-180-2] US National Institute of Standards and Technology, &#34;Secure Hash Standard (SHS)&#34;, Federal Information Processing Standards Publication 180-2, August 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FIPS-180-2]米国国立標準技術研究所、「Secure Hash Standard（SHS）」、連邦情報処理標準出版物180-2、2002年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FIPS-186-2] US National Institute of Standards and Technology, &#34;Digital Signature Standard (DSS)&#34;, Federal Information Processing Standards Publication 186- 2, January 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FIPS-186-2]米国国立標準技術研究所、「デジタル署名標準（DSS）」、連邦情報処理標準出版物186-2、2000年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FIPS-197] US National Institute of Standards and Technology, &#34;Advanced Encryption Standard (AES)&#34;, Federal Information Processing Standards Publication 197, November 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FIPS-197]米国国立標準技術研究所、「Advanced Encryption Standard（AES）」、連邦情報処理標準出版物197、2001年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ANSI-T1.523-2001] American National Standards Institute, Inc., &#34;Telecom Glossary 2000&#34;, ANSI T1.523-2001, February 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ANSI-T1.523-2001] American National Standards Institute、Inc。、「Telecom Glossary 2000」、ANSI T1.523-2001、2001年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SCHNEIER] Schneier, B., &#34;Applied Cryptography Second Edition: protocols algorithms and source in code in C&#34;, John Wiley and Sons, New York, NY, 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[シュナイアー]シュナイアーB。、「Applied Cryptography Second Edition：protocol algorithm and source in code in C」、John Wiley and Sons、ニューヨーク、ニューヨーク、1996。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SCHEIFLER] Scheifler, R., &#34;X Window System : The Complete Reference to Xlib, X Protocol, Icccm, Xlfd, 3rd edition.&#34;, Digital Press, ISBN 1555580882, February 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SCHEIFLER] Scheifler、R。、「X Window System：The Complete Reference to Xlib、X Protocol、Icccm、Xlfd、3rd edition。」、Digital Press、ISBN 1555580882、1992年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[KAUFMAN] Kaufman, C., Perlman, R., and M. Speciner, &#34;Network Security: PRIVATE Communication in a PUBLIC World&#34;, Prentice Hall Publisher, 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[KAUFMAN] Kaufman、C.、Perlman、R。、およびM. Speciner、「ネットワークセキュリティ：パブリックワールドでのプライベートコミュニケーション」、Prentice Hall Publisher、1995年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CERT] CERT Coordination Center, The., &#34;http://www.cert.org/nav/index_red.html&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CERT] CERT Coordination Center、The。、「http://www.cert.org/nav/index_red.html」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[VENEMA] Venema, W., &#34;Murphy&#39;s Law and Computer Security&#34;, Proceedings of 6th USENIX Security Symposium, San Jose CA http://www.usenix.org/publications/library/ proceedings/sec96/venema.html, July 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[VENEMA]ヴェネマ、W、「マーフィーの法則とコンピュータセキュリティ」、第6回USENIXセキュリティシンポジウムの議事録、サンノゼカリフォルニアhttp://www.usenix.org/publications/library/procedings/sec96/venema.html、1996年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ROGAWAY] Rogaway, P., &#34;Problems with Proposed IP Cryptography&#34;, Unpublished paper http://www.cs.ucdavis.edu/~rogaway/ papers/draft-rogaway-ipsec-comments-00.txt, 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ROGAWAY] Rogaway、P。、「Proposeds with Proposed IP Cryptography」、未公開の論文http://www.cs.ucdavis.edu/~rogaway/papers/draft-rogaway-ipsec-comments-00.txt、1996。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DAI] Dai, W., &#34;An attack against SSH2 protocol&#34;, Email to the SECSH Working Group ietf-ssh@netbsd.org ftp:// ftp.ietf.org/ietf-mail-archive/secsh/2002- 02.mail, Feb 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DAI] Dai、W。、「SSH2プロトコルに対する攻撃」、SECSHワーキンググループへのメールietf-ssh@netbsd.org ftp：// ftp.ietf.org/ietf-mail-archive/secsh/2002- 02 .mail、2002年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BELLARE] Bellaire, M., Kohno, T., and C. Namprempre, &#34;Authenticated Encryption in SSH: Fixing the SSH Binary Packet Protocol&#34;, Proceedings of the 9th ACM Conference on Computer and Communications Security, Sept 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BELLARE] Bellaire、M.、Kohno、T。、およびC. Namprempre、「SSHでの認証済み暗号化：SSHバイナリパケットプロトコルの修正」、第9回コンピュータおよび通信セキュリティに関するACM会議の議事録、2002年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Openwall] Solar Designer and D. Song, &#34;SSH Traffic Analysis Attacks&#34;, Presentation given at HAL2001 and NordU2002 Conferences, Sept 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Openwall]ソーラーデザイナーとD.ソング、「SSHトラフィック分析攻撃」、HAL2001およびNordU2002カンファレンスでのプレゼンテーション、2001年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[USENIX] Song, X.D., Wagner, D., and X. Tian, &#34;Timing Analysis of Keystrokes and SSH Timing Attacks&#34;, Paper given at 10th USENIX Security Symposium, 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[USENIX] Song、X.D.、Wagner、D。、およびX. Tian、「キーストロークとSSHタイミング攻撃のタイミング分析」、2001年第10回USENIXセキュリティシンポジウムで発表された論文。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tatu Ylonen SSH Communications Security Corp Valimotie 17 00380 Helsinki Finland
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tatu Ylonen SSH Communications Security Corp Valimotie 17 00380 Helsinkiフィンランド
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: ylo@ssh.com
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Chris Lonvick (editor) Cisco Systems, Inc. 12515 Research Blvd. Austin 78759 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Chris Lonvick（編集者）Cisco Systems、Inc. 12515 Research Blvd.オースティン78759アメリカ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: clonvick@cisco.com
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Trademark Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
商標に関する通知
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;ssh&#34; is a registered trademark in the United States and/or other countries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「ssh」は、米国およびその他の国における登録商標です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完全な著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2006).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（C）The Internet Society（2006）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、BCP 78に含まれる権利、ライセンス、および制限の対象であり、そこに記載されている場合を除き、著者はすべての権利を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein are provided on an &#34;AS IS&#34; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントとここに含まれる情報は、「現状のまま」で提供され、寄稿者、彼/彼女の代理人、または（もしあれば）組織、インターネットエンジニアリングおよびインターネットエンジニアリングタスクフォースは、すべての保証を明示的または明示的に提供します。ここに含まれる情報の使用により、商品性または特定の目的への適合性に関するいかなる権利または黙示の保証も侵害されないという保証を含みますが、これに限定されるものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Intellectual Property
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
知的財産
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFは、このドキュメントに記載されているテクノロジーの実装または使用に関連すると主張される可能性がある知的財産権またはその他の権利の有効性または範囲、またはそのような権利に基づくライセンスが適用されるかどうかに関係なく、いかなる立場も取りません。利用できる;また、そのような権利を特定するために独立した取り組みを行ったことを表すものでもありません。 RFC文書の権利に関する手順に関する情報は、BCP 78およびBCP 79にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF事務局に対して行われたIPR開示のコピー、および利用可能になるライセンスの保証、または一般ライセンスを取得しようとした試み、またはこの仕様の実装者またはユーザーがそのような所有権を使用するための許可を取得した結果を取得できます。 http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFは、この規格を実装するために必要となる可能性のある技術をカバーする可能性のある著作権、特許、特許出願、またはその他の所有権に注意を向けるよう、関係者に呼びかけます。 IEETのietf-ipr@ietf.orgに情報を送信してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFCエディター機能の資金は、IETF管理サポート活動（IASA）によって提供されます。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
